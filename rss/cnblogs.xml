<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JAVA提高十一：LinkedList深入分析 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/7768779.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/7768779.html</guid>
<description>&lt;p&gt;&lt;span&gt;上一节，我们学习了ArrayList 类，本节我们来学习一下LinkedList，LinkedList相对ArrayList而言其使用频率并不是很高，因为其访问元素的性能相对于ArrayList而言比较慢，至于原因我们下面讲开始讲解，本节重点是了解其内部的结构，会简单实现一个简单的LinkedList 即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、LinkedList的简单使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;任何代码在深入分析前，首先需要会使用，因此我们先看下基本的使用列子:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study.collection;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.LinkedList;


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestLinkedList {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试LinkedList的API&lt;/span&gt;
&lt;span&gt;        testLinkedListAPIs() ;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将LinkedList当作 LIFO(后进先出)的堆栈&lt;/span&gt;
&lt;span&gt;        useLinkedListAsLIFO();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将LinkedList当作 FIFO(先进先出)的队列&lt;/span&gt;
&lt;span&gt;        useLinkedListAsFIFO();
    }
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 测试LinkedList中部分API
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testLinkedListAPIs() {
        String val &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LinkedList llist;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;llist.offer(&quot;10&quot;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新建一个LinkedList&lt;/span&gt;
        LinkedList llist = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedList();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;---- 添加操作 ----
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依次添加1,2,3&lt;/span&gt;
        llist.add(&quot;1&quot;&lt;span&gt;);
        llist.add(&lt;/span&gt;&quot;2&quot;&lt;span&gt;);
        llist.add(&lt;/span&gt;&quot;3&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将“4”添加到第一个位置&lt;/span&gt;
        llist.add(1, &quot;4&quot;&lt;span&gt;);
        

        System.out.println(&lt;/span&gt;&quot;\nTest \&quot;addFirst(), removeFirst(), getFirst()\&quot;&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (01) 将“10”添加到第一个位置。  失败的话，抛出异常！&lt;/span&gt;
        llist.addFirst(&quot;10&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;llist:&quot;+&lt;span&gt;llist);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (02) 将第一个元素删除。        失败的话，抛出异常！&lt;/span&gt;
        System.out.println(&quot;llist.removeFirst():&quot;+&lt;span&gt;llist.removeFirst());
        System.out.println(&lt;/span&gt;&quot;llist:&quot;+&lt;span&gt;llist);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (03) 获取第一个元素。          失败的话，抛出异常！&lt;/span&gt;
        System.out.println(&quot;llist.getFirst():&quot;+&lt;span&gt;llist.getFirst());


        System.out.println(&lt;/span&gt;&quot;\nTest \&quot;offerFirst(), pollFirst(), peekFirst()\&quot;&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (01) 将“10”添加到第一个位置。  返回true。&lt;/span&gt;
        llist.offerFirst(&quot;10&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;llist:&quot;+&lt;span&gt;llist);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (02) 将第一个元素删除。        失败的话，返回null。&lt;/span&gt;
        System.out.println(&quot;llist.pollFirst():&quot;+&lt;span&gt;llist.pollFirst());
        System.out.println(&lt;/span&gt;&quot;llist:&quot;+&lt;span&gt;llist);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (03) 获取第一个元素。          失败的话，返回null。&lt;/span&gt;
        System.out.println(&quot;llist.peekFirst():&quot;+&lt;span&gt;llist.peekFirst());
    

        System.out.println(&lt;/span&gt;&quot;\nTest \&quot;addLast(), removeLast(), getLast()\&quot;&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (01) 将“20”添加到最后一个位置。  失败的话，抛出异常！&lt;/span&gt;
        llist.addLast(&quot;20&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;llist:&quot;+&lt;span&gt;llist);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (02) 将最后一个元素删除。        失败的话，抛出异常！&lt;/span&gt;
        System.out.println(&quot;llist.removeLast():&quot;+&lt;span&gt;llist.removeLast());
        System.out.println(&lt;/span&gt;&quot;llist:&quot;+&lt;span&gt;llist);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (03) 获取最后一个元素。          失败的话，抛出异常！&lt;/span&gt;
        System.out.println(&quot;llist.getLast():&quot;+&lt;span&gt;llist.getLast());


        System.out.println(&lt;/span&gt;&quot;\nTest \&quot;offerLast(), pollLast(), peekLast()\&quot;&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (01) 将“20”添加到第一个位置。  返回true。&lt;/span&gt;
        llist.offerLast(&quot;20&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;llist:&quot;+&lt;span&gt;llist);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (02) 将第一个元素删除。        失败的话，返回null。&lt;/span&gt;
        System.out.println(&quot;llist.pollLast():&quot;+&lt;span&gt;llist.pollLast());
        System.out.println(&lt;/span&gt;&quot;llist:&quot;+&lt;span&gt;llist);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (03) 获取第一个元素。          失败的话，返回null。&lt;/span&gt;
        System.out.println(&quot;llist.peekLast():&quot;+&lt;span&gt;llist.peekLast());

         

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将第3个元素设置300。不建议在LinkedList中使用此操作，因为效率低！&lt;/span&gt;
        llist.set(2, &quot;300&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取第3个元素。不建议在LinkedList中使用此操作，因为效率低！&lt;/span&gt;
        System.out.println(&quot;\nget(3):&quot;+llist.get(2&lt;span&gt;));


        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ---- toArray(T[] a) ----
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将LinkedList转行为数组&lt;/span&gt;
        String[] arr = (String[])llist.toArray(&lt;span&gt;new&lt;/span&gt; String[0&lt;span&gt;]);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String str:arr) 
            System.out.println(&lt;/span&gt;&quot;str:&quot;+&lt;span&gt;str);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出大小&lt;/span&gt;
        System.out.println(&quot;size:&quot;+&lt;span&gt;llist.size());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清空LinkedList&lt;/span&gt;
&lt;span&gt;        llist.clear();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断LinkedList是否为空&lt;/span&gt;
        System.out.println(&quot;isEmpty():&quot;+llist.isEmpty()+&quot;\n&quot;&lt;span&gt;);

    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将LinkedList当作 LIFO(后进先出)的堆栈
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; useLinkedListAsLIFO() {
        System.out.println(&lt;/span&gt;&quot;\nuseLinkedListAsLIFO&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新建一个LinkedList&lt;/span&gt;
        LinkedList stack = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedList();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将1,2,3,4添加到堆栈中&lt;/span&gt;
        stack.push(&quot;1&quot;&lt;span&gt;);
        stack.push(&lt;/span&gt;&quot;2&quot;&lt;span&gt;);
        stack.push(&lt;/span&gt;&quot;3&quot;&lt;span&gt;);
        stack.push(&lt;/span&gt;&quot;4&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印“栈”&lt;/span&gt;
        System.out.println(&quot;stack:&quot;+&lt;span&gt;stack);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除“栈顶元素”&lt;/span&gt;
        System.out.println(&quot;stack.pop():&quot;+&lt;span&gt;stack.pop());
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取出“栈顶元素”&lt;/span&gt;
        System.out.println(&quot;stack.peek():&quot;+&lt;span&gt;stack.peek());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印“栈”&lt;/span&gt;
        System.out.println(&quot;stack:&quot;+&lt;span&gt;stack);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 将LinkedList当作 FIFO(先进先出)的队列
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; useLinkedListAsFIFO() {
        System.out.println(&lt;/span&gt;&quot;\nuseLinkedListAsFIFO&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新建一个LinkedList&lt;/span&gt;
        LinkedList queue = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkedList();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将10,20,30,40添加到队列。每次都是插入到末尾&lt;/span&gt;
        queue.add(&quot;10&quot;&lt;span&gt;);
        queue.add(&lt;/span&gt;&quot;20&quot;&lt;span&gt;);
        queue.add(&lt;/span&gt;&quot;30&quot;&lt;span&gt;);
        queue.add(&lt;/span&gt;&quot;40&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印“队列”&lt;/span&gt;
        System.out.println(&quot;queue:&quot;+&lt;span&gt;queue);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除(队列的第一个元素)&lt;/span&gt;
        System.out.println(&quot;queue.remove():&quot;+&lt;span&gt;queue.remove());
    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取(队列的第一个元素)&lt;/span&gt;
        System.out.println(&quot;queue.element():&quot;+&lt;span&gt;queue.element());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印“队列”&lt;/span&gt;
        System.out.println(&quot;queue:&quot;+&lt;span&gt;queue);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;从上面的代码可以看出，LinkedList的功能非常多，既可以用于存放元素的集合功能，还具备了堆栈的功能，还拥有队列的功能。这均源于其不仅仅实现了List接口还是实现了Queue接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但在介绍LinkedList接口前，从名字可以看出LinkedList 即底层采用的是链表的结构，那什么是链表，需要提前有一个认识：顾名思义，链表就和链子一样，每一环都要连接着后边的一环和前边的一环，这样，当我们需要找这根链子的某一环的时候，只要我们能找到链子的任意一环，都可以找到我们需要的那一环。我们看一个图，就能很好的理解了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201711/401339-20171101215845076-1468163548.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在LinkedList中，我们把链子的“环”叫做“节点”，每个节点都是同样的结构。节点与节点之间相连，构成了我们LinkedList的基本数据结构，也是LinkedList的核心。&lt;/span&gt;&lt;span&gt;链表又分为单向链表和双向链表，而单向/双向链表又可以分为循环链表和非循环链表，下面简单就这四种链表进行图解说明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 1.1.单向链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;          单向链表就是通过每个结点的指针指向下一个结点从而链接起来的结构，最后一个节点的next指向null。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201711/401339-20171101220224341-1334091097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 2.单向循环链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　单向循环链表和单向列表的不同是，最后一个节点的next不是指向null，而是指向head节点，形成一个“环”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201711/401339-20171101220259513-264189636.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 1. 3.双向链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　从名字就可以看出，双向链表是包含两个指针的，pre指向前一个节点，next指向后一个节点，但是第一个节点head的pre指向null，最后一个节点的tail指向null。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201711/401339-20171101220417263-1881705280.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 4.双向循环链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;         &lt;/strong&gt; 双向循环链表和双向链表的不同在于，第一个节点的pre指向最后一个节点，最后一个节点的next指向第一个节点，也形成一个“环”。&lt;strong&gt;而LinkedList就是基于双向循环链表设计的。&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201711/401339-20171101220440216-1517727898.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;更形象的解释下就是：双向循环链表就像一群小孩手牵手围成一个圈，第一个小孩的右手拉着第二个小孩的左手，第二个小孩的左手拉着第一个小孩的右手。。。最后一个小孩的右手拉着第一个小孩的左手。【接下来我们进入源代码的分析，说明linkedlist 我们采用的JDK1.8进行分析，只所以不用1.6是因为，在1.6  1.7 的时候进行过变动将1.6中的环形结构优化为了直线型了链表结构，然后回到了1.8又有部分的变动，因为从上面可以看出链表的由4种不向ArrayList单一演进，所以这里直接选择用1.8来分析】&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 二、LinkedList的概述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;LinkedList是List和Deque接口的双向链表的实现。实现了所有可选列表操作，并允许包括null值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LinkedList既然是通过双向链表去实现的，那么它可以被当作堆栈、队列或双端队列进行操作。并且其顺序访问非常高效，而随机访问效率比较低。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，此实现不是同步的。 如果多个线程同时访问一个LinkedList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。这通常是通过同步那些用来封装列表的 对象来实现的。但如果没有这样的对象存在，则该列表需要运用{@link Collections#synchronizedList Collections.synchronizedList}来进行“包装”，该方法最好是在创建列表对象时完成，为了避免对列表进行突发的非同步操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
List list = Collections.synchronizedList(&lt;span&gt;new&lt;/span&gt; LinkedList(...));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;类中的iterator()方法和listIterator()方法返回的iterators迭代器是&lt;strong&gt;fail-fast&lt;/strong&gt;的：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.Node节点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; {
        E item;    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前节点所包含的值&lt;/span&gt;
        Node&amp;lt;E&amp;gt; next;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下一个节点&lt;/span&gt;
        Node&amp;lt;E&amp;gt; prev;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上一个节点&lt;/span&gt;
&lt;span&gt;
        Node(Node&lt;/span&gt;&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.item =&lt;span&gt; element;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prev =&lt;span&gt; prev;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.LinkedList类结构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过LinkedList实现的接口可知，其支持队列操作，双向列表操作，能被克隆，支持序列化&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedList&amp;lt;E&amp;gt;
    &lt;span&gt;extends&lt;/span&gt; AbstractSequentialList&amp;lt;E&amp;gt;
    &lt;span&gt;implements&lt;/span&gt; List&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt;&lt;span&gt;, Cloneable, java.io.Serializable
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; LinkedList的大小（指其所含的元素个数）&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 指向第一个节点
     * 不变的: (first == null &amp;amp;&amp;amp; last == null) ||
     *            (first.prev == null &amp;amp;&amp;amp; first.item != null)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; first;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 指向最后一个节点
     * 不变的: (first == null &amp;amp;&amp;amp; last == null) ||
     *            (last.next == null &amp;amp;&amp;amp; last.item != null)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; last;

    ......
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;LinkedList包含了三个重要的对象&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;strong&gt;first、last 和 size。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) &lt;strong&gt;&lt;strong&gt;first&lt;/strong&gt;&lt;/strong&gt; 是双向链表的表头，它是双向链表节点所对应的类Node的实例&lt;/p&gt;
&lt;p&gt;(2) &lt;strong&gt;&lt;strong&gt;last&lt;/strong&gt;&lt;/strong&gt; 是双向链表的最后一个元素，它是双向链表节点所对应的类Node的实例&lt;/p&gt;
&lt;p&gt;(3) &lt;strong&gt;size&lt;/strong&gt; 是双向链表中节点的个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.构造函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LinkedList提供了两种种方式的构造器，构造一个空列表、以及构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回的顺序排列的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构建一个空列表&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LinkedList() {
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 构造一个包含指定collection的元素的列表，这些元素按照该collection的迭代器返回的顺序排列的
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt;  c 包含用于去构造LinkedList的元素的collection
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; NullPointerException 如果指定的collection为空
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构建一个包含指定集合c的列表&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; LinkedList(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; E&amp;gt;&lt;span&gt; c) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;();
        addAll(c);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、LinkedList 方法功能源码分析&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;93&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * LinkedList底层使用双向链表，实现了List和deque。实现所有的可选List操作，并可以只有所有元素（包括空值）
 * 其大小理论上仅受内存大小的限制
 *
 * 所有的操作都可以作为一个双联列表来执行（及对双向链表操作）。
 * 把对链表的操作封装起来，并对外提供看起来是对普通列表操作的方法。
 * 遍历从起点、终点、或指定位置开始
 * 内部方法，注释会描述为节点的操作(如删除第一个节点)，公开的方法会描述为元素的操作(如删除第一个元素)
 *
 * LinkedList不是线程安全的，如果在多线程中使用（修改），需要在外部作同步处理。
 * 
 * 需要弄清元素（节点）的索引和位置的区别，不然有几个地方不好理解，具体在碰到的地方会解释。
 * 
 * 迭代器可以快速报错
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LinkedList&amp;lt;E&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractSequentialList&amp;lt;E&amp;gt; &lt;span&gt;implements&lt;/span&gt; List&amp;lt;E&amp;gt;, Deque&amp;lt;E&amp;gt;&lt;span&gt;, Cloneable, java.io.Serializable
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;容量&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首节点&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; first;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尾节点&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; last;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认构造函数&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LinkedList() {
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过一个集合初始化LinkedList，元素顺序有这个集合的迭代器返回顺序决定&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; LinkedList(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; E&amp;gt;&lt;span&gt; c) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;();
        addAll(c);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用对应参数作为第一个节点，内部使用&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; linkFirst(E e) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; f = first;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到首节点&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(&lt;span&gt;null&lt;/span&gt;, e, f);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个节点&lt;/span&gt;
        first = newNode;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置首节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            last &lt;/span&gt;= newNode;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果之前首节点为空(size==0)，那么尾节点就是首节点&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            f.prev &lt;/span&gt;= newNode;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果之前首节点不为空，之前的首节点的前一个节点为当前首节点&lt;/span&gt;
        size++;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;长度+1&lt;/span&gt;
        modCount++;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改次数+1&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用对应参数作为尾节点&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; linkLast(E e) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; l = last; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到尾节点&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(l, e, &lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用参数创建一个节点&lt;/span&gt;
        last = newNode;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置尾节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            first &lt;/span&gt;= newNode;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果之前尾节点为空(size==0)，首节点即尾节点&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            l.next &lt;/span&gt;= newNode;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果之前尾节点不为空，之前的尾节点的后一个就是当前的尾节点&lt;/span&gt;
        size++&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在指定节点前插入节点，节点succ不能为空&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; linkBefore(E e, Node&amp;lt;E&amp;gt;&lt;span&gt; succ) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; pred = succ.prev;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取前一个节点&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(pred, e, succ);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用参数创建新的节点，向前指向前一个节点，向后指向当前节点&lt;/span&gt;
        succ.prev = newNode;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前节点指向新的节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (pred == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            first &lt;/span&gt;= newNode;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果前一个节点为null，新的节点就是首节点&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            pred.next &lt;/span&gt;= newNode;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果存在前节点，那么前节点的向后指向新节点&lt;/span&gt;
        size++&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除首节点并返回删除前首节点的值，内部使用&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; E unlinkFirst(Node&amp;lt;E&amp;gt;&lt;span&gt; f) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; E element = f.item;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取首节点的值&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; next = f.next;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到下一个节点&lt;/span&gt;
        f.item = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        f.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;便于垃圾回收期清理&lt;/span&gt;
        first = next;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首节点的下一个节点成为新的首节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            last &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不存在下一个节点，则首尾都为null(空表)&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            next.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果存在下一个节点，那它向前指向null&lt;/span&gt;
        size--&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; element;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除尾节点并返回删除前尾节点的值，内部使用&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; E unlinkLast(Node&amp;lt;E&amp;gt;&lt;span&gt; l) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; E element = l.item;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取值&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; prev = l.prev;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取尾节点前一个节点&lt;/span&gt;
        l.item = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        l.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;便于垃圾回收期清理&lt;/span&gt;
        last = prev;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;前一个节点成为新的尾节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (prev == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            first &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果前一个节点不存在，则首尾都为null(空表)&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            prev.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果前一个节点存在，先后指向null&lt;/span&gt;
        size--&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; element;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除指定节点并返回被删除的元素值&lt;/span&gt;
    E unlink(Node&amp;lt;E&amp;gt;&lt;span&gt; x) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前值和前后节点&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; E element =&lt;span&gt; x.item;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; next =&lt;span&gt; x.next;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; prev =&lt;span&gt; x.prev;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prev == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            first &lt;/span&gt;= next;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果前一个节点为空(如当前节点为首节点)，后一个节点成为新的首节点&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            prev.next &lt;/span&gt;= next;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果前一个节点不为空，那么他先后指向当前的下一个节点&lt;/span&gt;
            x.prev = &lt;span&gt;null&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方便gc回收&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            last &lt;/span&gt;= prev;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果后一个节点为空(如当前节点为尾节点)，当前节点前一个成为新的尾节点&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            next.prev &lt;/span&gt;= prev;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果后一个节点不为空，后一个节点向前指向当前的前一个节点&lt;/span&gt;
            x.next = &lt;span&gt;null&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方便gc回收&lt;/span&gt;
&lt;span&gt;        }
        x.item &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方便gc回收&lt;/span&gt;
        size--&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; element;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取第一个元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E getFirst() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; f = first;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到首节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;)          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果为空，抛出异常&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; f.item;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取最后一个元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E getLast() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; l = last;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到尾节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;)          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果为空，抛出异常&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; l.item;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除第一个元素并返回删除的元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E removeFirst() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; f = first;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到第一个节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;)          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果为空，抛出异常&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; unlinkFirst(f);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除最后一个元素并返回删除的值&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E removeLast() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; l = last;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到最后一个节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;)          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果为空，抛出异常&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; unlinkLast(l);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加元素作为第一个元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addFirst(E e) {
        linkFirst(e);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;店家元素作为最后一个元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addLast(E e) {
        linkLast(e);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查是否包含某个元素，返回bool&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; contains(Object o) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; indexOf(o) != -1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回指定元素的索引位置，不存在就返回-1，然后比较返回bool值&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回列表长度&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; size;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个元素，默认添加到末尾作为最后一个元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
        linkLast(e);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除指定元素，默认从first节点开始，删除第一次出现的那个元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; remove(Object o) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;会根据是否为null分开处理。若值不是null，会用到对象的equals()方法&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.item == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    unlink(x);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(x.item)) {
                    unlink(x);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加指定集合的元素到列表，默认从最后开始添加&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addAll(Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; E&amp;gt;&lt;span&gt; c) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; addAll(size, c);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;size表示最后一个位置，可以理解为元素的位置分别为1~size&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从指定位置（而不是下标！下标即索引从0开始，位置可以看做从1开始，其实也是0）后面添加指定集合的元素到列表中，只要有至少一次添加就会返回true
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;index换成position应该会更好理解，所以也就是从索引为index(position)的元素的前面索引为index-1的后面添加！
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当然位置可以为0啊，为0的时候就是从位置0(虽然它不存在)后面开始添加嘛，所以理所当前就是添加到第一个位置（位置1的前面）的前面了啊！
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;比如列表：0 1 2 3，如果此处index=4(实际索引为3)，就是在元素3后面添加；如果index=3(实际索引为2)，就在元素2后面添加。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原谅我的表达水平，我已经尽力解释了...&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; addAll(&lt;span&gt;int&lt;/span&gt; index, Collection&amp;lt;? &lt;span&gt;extends&lt;/span&gt; E&amp;gt;&lt;span&gt; c) {
        checkPositionIndex(index);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查索引是否正确（0&amp;lt;=index&amp;lt;=size）&lt;/span&gt;
        Object[] a = c.toArray();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到元素数组&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; numNew = a.length;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到元素个数&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (numNew == 0)            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若没有元素要添加，直接返回false&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; pred, succ;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index == size) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是在末尾开始添加，当前节点后一个节点初始化为null，前一个节点为尾节点&lt;/span&gt;
            succ = &lt;span&gt;null&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里可以看做node(index)，不过index=size了（index最大只能是size-1），所以这里的succ只能=null，也方便后面判断&lt;/span&gt;
            pred = last;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里看做noede(index-1)，当然实现是不能这么写的，看做这样只是为了好理解，所以就是在node(index-1的后面开始添加元素)&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt; {                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是从末尾开始添加，当前位置的节点为指定位置的节点，前一个节点为要添加的节点的前一个节点&lt;/span&gt;
            succ = node(index); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加好元素后(整个新加的)的后一个节点&lt;/span&gt;
            pred = succ.prev;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里依然是node(index-1)&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历数组并添加到列表中&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Object o : a) {
            @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
            E e &lt;/span&gt;=&lt;span&gt; (E) o;
            Node&lt;/span&gt;&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(pred, e, &lt;span&gt;null&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个节点，向前指向上面得到的前节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (pred == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                first &lt;/span&gt;= newNode;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若果前节点为null，则新加的节点为首节点&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                pred.next &lt;/span&gt;= newNode;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果存在前节点，前节点会向后指向新加的节点&lt;/span&gt;
            pred = newNode;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新加的节点成为前一个节点&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (succ == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pred.next = null  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加上这句也可以更好的理解&lt;/span&gt;
            last = pred;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是从最后开始添加的，则最后添加的节点成为尾节点&lt;/span&gt;
        } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            pred.next &lt;/span&gt;= succ;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是从最后开始添加的，则最后添加的节点向后指向之前得到的后续第一个节点&lt;/span&gt;
            succ.prev = pred;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前，后续的第一个节点也应改为向前指向最后一个添加的节点&lt;/span&gt;
&lt;span&gt;        }
        size &lt;/span&gt;+=&lt;span&gt; numNew;
        modCount&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空表&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方便gc回收垃圾&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; ) {
            Node&lt;/span&gt;&amp;lt;E&amp;gt; next =&lt;span&gt; x.next;
            x.item &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            x.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            x.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            x &lt;/span&gt;=&lt;span&gt; next;
        }
        first &lt;/span&gt;= last = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        size &lt;/span&gt;= 0&lt;span&gt;;
        modCount&lt;/span&gt;++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取指定索引的节点的值&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; E get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        checkElementIndex(index);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node(index).item;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改指定索引的值并返回之前的值&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; E set(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E element) {
        checkElementIndex(index);
        Node&lt;/span&gt;&amp;lt;E&amp;gt; x =&lt;span&gt; node(index);
        E oldVal &lt;/span&gt;=&lt;span&gt; x.item;
        x.item &lt;/span&gt;=&lt;span&gt; element;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldVal;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定位置后面（即索引为这个值的元素的前面）添加元素&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E element) {
        checkPositionIndex(index);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index ==&lt;span&gt; size)
            linkLast(element);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果指定位置为最后，则添加到链表最后&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果指定位置不是最后，则添加到指定位置前&lt;/span&gt;
&lt;span&gt;            linkBefore(element, node(index));
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除指定位置的元素，&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; E remove(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        checkElementIndex(index);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; unlink(node(index));
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查索引是否超出范围，因为元素索引是0~size-1的，所以index必须满足0&amp;lt;=index&amp;lt;size&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isElementIndex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt;&lt;span&gt; size;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查位置是否超出范围，index必须在index~size之间（含），如果超出，返回false&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isPositionIndex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt;=&lt;span&gt; size;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;异常详情&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String outOfBoundsMsg(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Index: &quot;+index+&quot;, Size: &quot;+&lt;span&gt;size;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查元素索引是否超出范围，若已超出，就抛出异常&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; checkElementIndex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isElementIndex(index))
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IndexOutOfBoundsException(outOfBoundsMsg(index));
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查位置是否超出范围，若已超出，就抛出异常&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; checkPositionIndex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isPositionIndex(index))
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IndexOutOfBoundsException(outOfBoundsMsg(index));
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取指定位置的节点&lt;/span&gt;
    Node&amp;lt;E&amp;gt; node(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果位置索引小于列表长度的一半(或一半减一)，从前面开始遍历；否则，从后面开始遍历&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (index &amp;lt; (size &amp;gt;&amp;gt; 1&lt;span&gt;)) {
            Node&lt;/span&gt;&amp;lt;E&amp;gt; x = first;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;index==0时不会循环，直接返回first&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; index; i++&lt;span&gt;)
                x &lt;/span&gt;=&lt;span&gt; x.next;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Node&lt;/span&gt;&amp;lt;E&amp;gt; x =&lt;span&gt; last;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = size - 1; i &amp;gt; index; i--&lt;span&gt;)
                x &lt;/span&gt;=&lt;span&gt; x.prev;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取指定元素从first开始的索引位置，不存在就返回-1
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能按条件双向找了，所以通常根据索引获得元素的速度比通过元素获得索引的速度快&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; indexOf(Object o) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.item == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; index;
                index&lt;/span&gt;++&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(x.item))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; index;
                index&lt;/span&gt;++&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取指定元素从first开始最后出现的索引，不存在就返回-1
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;但实际查找是从last开始的&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; lastIndexOf(Object o) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index =&lt;span&gt; size;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = last; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.prev) {
                index&lt;/span&gt;--&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.item == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; index;
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = last; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.prev) {
                index&lt;/span&gt;--&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(x.item))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; index;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供普通队列和双向队列的功能，当然，也可以实现栈，FIFO，FILO
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出队（从前端），获得第一个元素，不存在会返回null，不会删除元素（节点）&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E peek() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; f =&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : f.item;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出队（从前端），不删除元素，若为null会抛出异常而不是返回null&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E element() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getFirst();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出队（从前端），如果不存在会返回null，存在的话会返回值并移除这个元素（节点）&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E poll() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; f =&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : unlinkFirst(f);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出队（从前端），如果不存在会抛出异常而不是返回null，存在的话会返回值并移除这个元素（节点）&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E remove() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; removeFirst();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;入队（从后端），始终返回true&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; offer(E e) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; add(e);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;入队（从前端），始终返回true&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; offerFirst(E e) {
        addFirst(e);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;入队（从后端），始终返回true&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; offerLast(E e) {
        addLast(e);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;linkLast(e)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出队（从前端），获得第一个元素，不存在会返回null，不会删除元素（节点）&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E peekFirst() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; f =&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : f.item;
     }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出队（从后端），获得最后一个元素，不存在会返回null，不会删除元素（节点）&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E peekLast() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; l =&lt;span&gt; last;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : l.item;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出队（从前端），获得第一个元素，不存在会返回null，会删除元素（节点）&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E pollFirst() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; f =&lt;span&gt; first;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (f == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : unlinkFirst(f);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出队（从后端），获得最后一个元素，不存在会返回null，会删除元素（节点）&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E pollLast() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; l =&lt;span&gt; last;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : unlinkLast(l);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;入栈，从前面添加&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; push(E e) {
        addFirst(e);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出栈，返回栈顶元素，从前面移除（会删除）&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E pop() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; removeFirst();
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Removes the first occurrence of the specified element in this
     * list (when traversing the list from head to tail).  If the list
     * does not contain the element, it is unchanged.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; o element to be removed from this list, if present
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; true} if the list contained the specified element
     * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.6
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; removeFirstOccurrence(Object o) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; remove(o);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Removes the last occurrence of the specified element in this
     * list (when traversing the list from head to tail).  If the list
     * does not contain the element, it is unchanged.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; o element to be removed from this list, if present
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; true} if the list contained the specified element
     * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.6
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; removeLastOccurrence(Object o) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = last; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.prev) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x.item == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    unlink(x);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = last; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.prev) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (o.equals(x.item)) {
                    unlink(x);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Returns a list-iterator of the elements in this list (in proper
     * sequence), starting at the specified position in the list.
     * Obeys the general contract of {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; List.listIterator(int)}.&amp;lt;p&amp;gt;
     *
     * The list-iterator is &amp;lt;i&amp;gt;fail-fast&amp;lt;/i&amp;gt;: if the list is structurally
     * modified at any time after the Iterator is created, in any way except
     * through the list-iterator's own {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; remove} or {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; add}
     * methods, the list-iterator will throw a
     * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; ConcurrentModificationException}.  Thus, in the face of
     * concurrent modification, the iterator fails quickly and cleanly, rather
     * than risking arbitrary, non-deterministic behavior at an undetermined
     * time in the future.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index index of the first element to be returned from the
     *              list-iterator (by a call to {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; next})
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; a ListIterator of the elements in this list (in proper
     *         sequence), starting at the specified position in the list
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IndexOutOfBoundsException {&lt;/span&gt;&lt;span&gt;@inheritDoc&lt;/span&gt;&lt;span&gt;}
     * &lt;/span&gt;&lt;span&gt;@see&lt;/span&gt;&lt;span&gt; List#listIterator(int)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; ListIterator&amp;lt;E&amp;gt; listIterator(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
        checkPositionIndex(index);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListItr(index);
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ListItr &lt;span&gt;implements&lt;/span&gt; ListIterator&amp;lt;E&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; lastReturned;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; next;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nextIndex;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; expectedModCount =&lt;span&gt; modCount;
        ListItr(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert isPositionIndex(index);&lt;/span&gt;
            next = (index == size) ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : node(index);
            nextIndex &lt;/span&gt;=&lt;span&gt; index;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nextIndex &amp;lt;&lt;span&gt; size;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
            checkForComodification();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;hasNext())
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
            lastReturned &lt;/span&gt;=&lt;span&gt; next;
            next &lt;/span&gt;=&lt;span&gt; next.next;
            nextIndex&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lastReturned.item;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasPrevious() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nextIndex &amp;gt; 0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E previous() {
            checkForComodification();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;hasPrevious())
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
            lastReturned &lt;/span&gt;= next = (next == &lt;span&gt;null&lt;/span&gt;) ?&lt;span&gt; last : next.prev;
            nextIndex&lt;/span&gt;--&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lastReturned.item;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; nextIndex() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextIndex;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; previousIndex() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nextIndex - 1&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            checkForComodification();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastReturned == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
            Node&lt;/span&gt;&amp;lt;E&amp;gt; lastNext =&lt;span&gt; lastReturned.next;
            unlink(lastReturned);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next ==&lt;span&gt; lastReturned)
                next &lt;/span&gt;=&lt;span&gt; lastNext;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                nextIndex&lt;/span&gt;--&lt;span&gt;;
            lastReturned &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            expectedModCount&lt;/span&gt;++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; set(E e) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastReturned == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException();
            checkForComodification();
            lastReturned.item &lt;/span&gt;=&lt;span&gt; e;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(E e) {
            checkForComodification();
            lastReturned &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                linkLast(e);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                linkBefore(e, next);
            nextIndex&lt;/span&gt;++&lt;span&gt;;
            expectedModCount&lt;/span&gt;++&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEachRemaining(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt;&lt;span&gt; action) {
            Objects.requireNonNull(action);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (modCount == expectedModCount &amp;amp;&amp;amp; nextIndex &amp;lt;&lt;span&gt; size) {
                action.accept(next.item);
                lastReturned &lt;/span&gt;=&lt;span&gt; next;
                next &lt;/span&gt;=&lt;span&gt; next.next;
                nextIndex&lt;/span&gt;++&lt;span&gt;;
            }
            checkForComodification();
        }
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkForComodification() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modCount !=&lt;span&gt; expectedModCount)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;节点的数据结构，包含前后节点的引用和当前节点&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;E&amp;gt;&lt;span&gt; {
        E item;
        Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; next;
        Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; prev;
        Node(Node&lt;/span&gt;&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.item =&lt;span&gt; element;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prev =&lt;span&gt; prev;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回迭代器&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; descendingIterator() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DescendingIterator();
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为采用链表实现，所以迭代器很简单&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DescendingIterator &lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ListItr itr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListItr(size());
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; itr.hasPrevious();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; itr.previous();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            itr.remove();
        }
    }
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; LinkedList&amp;lt;E&amp;gt;&lt;span&gt; superClone() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (LinkedList&amp;lt;E&amp;gt;) &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.clone();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CloneNotSupportedException e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InternalError(e);
        }
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Returns a shallow copy of this {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; LinkedList}. (The elements
     * themselves are not cloned.)
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; a shallow copy of this {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; LinkedList} instance
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object clone() {
        LinkedList&lt;/span&gt;&amp;lt;E&amp;gt; clone =&lt;span&gt; superClone();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Put clone into &quot;virgin&quot; state&lt;/span&gt;
        clone.first = clone.last = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        clone.size &lt;/span&gt;= 0&lt;span&gt;;
        clone.modCount &lt;/span&gt;= 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initialize clone with our elements&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next)
            clone.add(x.item);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; clone;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Returns an array containing all of the elements in this list
     * in proper sequence (from first to last element).
     *
     * &amp;lt;p&amp;gt;The returned array will be &quot;safe&quot; in that no references to it are
     * maintained by this list.  (In other words, this method must allocate
     * a new array).  The caller is thus free to modify the returned array.
     *
     * &amp;lt;p&amp;gt;This method acts as bridge between array-based and collection-based
     * APIs.
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; an array containing all of the elements in this list
     *         in proper sequence
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object[] toArray() {
        Object[] result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[size];
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next)
            result[i&lt;/span&gt;++] =&lt;span&gt; x.item;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Returns an array containing all of the elements in this list in
     * proper sequence (from first to last element); the runtime type of
     * the returned array is that of the specified array.  If the list fits
     * in the specified array, it is returned therein.  Otherwise, a new
     * array is allocated with the runtime type of the specified array and
     * the size of this list.
     *
     * &amp;lt;p&amp;gt;If the list fits in the specified array with room to spare (i.e.,
     * the array has more elements than the list), the element in the array
     * immediately following the end of the list is set to {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; null}.
     * (This is useful in determining the length of the list &amp;lt;i&amp;gt;only&amp;lt;/i&amp;gt; if
     * the caller knows that the list does not contain any null elements.)
     *
     * &amp;lt;p&amp;gt;Like the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #toArray()} method, this method acts as bridge between
     * array-based and collection-based APIs.  Further, this method allows
     * precise control over the runtime type of the output array, and may,
     * under certain circumstances, be used to save allocation costs.
     *
     * &amp;lt;p&amp;gt;Suppose {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; x} is a list known to contain only strings.
     * The following code can be used to dump the list into a newly
     * allocated array of {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; String}:
     *
     * &amp;lt;pre&amp;gt;
     *     String[] y = x.toArray(new String[0]);&amp;lt;/pre&amp;gt;
     *
     * Note that {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; toArray(new Object[0])} is identical in function to
     * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; toArray()}.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; a the array into which the elements of the list are to
     *          be stored, if it is big enough; otherwise, a new array of the
     *          same runtime type is allocated for this purpose.
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; an array containing the elements of the list
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; ArrayStoreException if the runtime type of the specified array
     *         is not a supertype of the runtime type of every element in
     *         this list
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; NullPointerException if the specified array is null
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T[] toArray(T[] a) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a.length &amp;lt;&lt;span&gt; size)
            a &lt;/span&gt;=&lt;span&gt; (T[])java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), size);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
        Object[] result &lt;/span&gt;=&lt;span&gt; a;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next)
            result[i&lt;/span&gt;++] =&lt;span&gt; x.item;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (a.length &amp;gt;&lt;span&gt; size)
            a[size] &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
    }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = 876323262645176354L&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Saves the state of this {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; LinkedList} instance to a stream
     * (that is, serializes it).
     *
     * &lt;/span&gt;&lt;span&gt;@serialData&lt;/span&gt;&lt;span&gt; The size of the list (the number of elements it
     *             contains) is emitted (int), followed by all of its
     *             elements (each an Object) in the proper order.
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; writeObject(java.io.ObjectOutputStream s)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; java.io.IOException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write out any hidden serialization magic&lt;/span&gt;
&lt;span&gt;        s.defaultWriteObject();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write out size&lt;/span&gt;
&lt;span&gt;        s.writeInt(size);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write out all elements in the proper order.&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (Node&amp;lt;E&amp;gt; x = first; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; x.next)
            s.writeObject(x.item);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Reconstitutes this {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; LinkedList} instance from a stream
     * (that is, deserializes it).
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; readObject(java.io.ObjectInputStream s)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; java.io.IOException, ClassNotFoundException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Read in any hidden serialization magic&lt;/span&gt;
&lt;span&gt;        s.defaultReadObject();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Read in size&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; s.readInt();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Read in all elements in the proper order.&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; size; i++&lt;span&gt;)
            linkLast((E)s.readObject());
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Creates a &amp;lt;em&amp;gt;&amp;lt;a href=&quot;Spliterator.html#binding&quot;&amp;gt;late-binding&amp;lt;/a&amp;gt;&amp;lt;/em&amp;gt;
     * and &amp;lt;em&amp;gt;fail-fast&amp;lt;/em&amp;gt; {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Spliterator} over the elements in this
     * list.
     *
     * &amp;lt;p&amp;gt;The {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Spliterator} reports {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Spliterator#SIZED} and
     * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Spliterator#ORDERED}.  Overriding implementations should document
     * the reporting of additional characteristic values.
     *
     * @implNote
     * The {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Spliterator} additionally reports {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Spliterator#SUBSIZED}
     * and implements {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; trySplit} to permit limited parallelism..
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; a {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Spliterator} over the elements in this list
     * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.8
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Spliterator&amp;lt;E&amp;gt;&lt;span&gt; spliterator() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LLSpliterator&amp;lt;E&amp;gt;(&lt;span&gt;this&lt;/span&gt;, -1, 0&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; A customized variant of Spliterators.IteratorSpliterator &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LLSpliterator&amp;lt;E&amp;gt; &lt;span&gt;implements&lt;/span&gt; Spliterator&amp;lt;E&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BATCH_UNIT = 1 &amp;lt;&amp;lt; 10;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; batch array size increment&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_BATCH = 1 &amp;lt;&amp;lt; 25;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; max batch array size;&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; LinkedList&amp;lt;E&amp;gt; list; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; null OK unless traversed&lt;/span&gt;
        Node&amp;lt;E&amp;gt; current;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; current node; null until initialized&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; est;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt; size estimate; -1 until first needed&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; expectedModCount; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; initialized when est set&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; batch;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; batch size for splits&lt;/span&gt;
        LLSpliterator(LinkedList&amp;lt;E&amp;gt; list, &lt;span&gt;int&lt;/span&gt; est, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expectedModCount) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.list =&lt;span&gt; list;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.est =&lt;span&gt; est;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.expectedModCount =&lt;span&gt; expectedModCount;
        }
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getEst() {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; force initialization&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; LinkedList&amp;lt;E&amp;gt;&lt;span&gt; lst;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((s = est) &amp;lt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((lst = list) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    s &lt;/span&gt;= est = 0&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    expectedModCount &lt;/span&gt;=&lt;span&gt; lst.modCount;
                    current &lt;/span&gt;=&lt;span&gt; lst.first;
                    s &lt;/span&gt;= est =&lt;span&gt; lst.size;
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; estimateSize() { &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;long&lt;/span&gt;&lt;span&gt;) getEst(); }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Spliterator&amp;lt;E&amp;gt;&lt;span&gt; trySplit() {
            Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; getEst();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;gt; 1 &amp;amp;&amp;amp; (p = current) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = batch +&lt;span&gt; BATCH_UNIT;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;gt;&lt;span&gt; s)
                    n &lt;/span&gt;=&lt;span&gt; s;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n &amp;gt;&lt;span&gt; MAX_BATCH)
                    n &lt;/span&gt;=&lt;span&gt; MAX_BATCH;
                Object[] a &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[n];
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = 0&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt; { a[j++] = p.item; } &lt;span&gt;while&lt;/span&gt; ((p = p.next) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; j &amp;lt;&lt;span&gt; n);
                current &lt;/span&gt;=&lt;span&gt; p;
                batch &lt;/span&gt;=&lt;span&gt; j;
                est &lt;/span&gt;= s -&lt;span&gt; j;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Spliterators.spliterator(a, 0&lt;span&gt;, j, Spliterator.ORDERED);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; forEachRemaining(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt;&lt;span&gt; action) {
            Node&lt;/span&gt;&amp;lt;E&amp;gt; p; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((n = getEst()) &amp;gt; 0 &amp;amp;&amp;amp; (p = current) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                current &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                est &lt;/span&gt;= 0&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                    E e &lt;/span&gt;=&lt;span&gt; p.item;
                    p &lt;/span&gt;=&lt;span&gt; p.next;
                    action.accept(e);
                } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; --n &amp;gt; 0&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (list.modCount !=&lt;span&gt; expectedModCount)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAdvance(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; E&amp;gt;&lt;span&gt; action) {
            Node&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (action == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getEst() &amp;gt; 0 &amp;amp;&amp;amp; (p = current) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;--&lt;span&gt;est;
                E e &lt;/span&gt;=&lt;span&gt; p.item;
                current &lt;/span&gt;=&lt;span&gt; p.next;
                action.accept(e);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (list.modCount !=&lt;span&gt; expectedModCount)
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConcurrentModificationException();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; characteristics() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Spliterator.ORDERED | Spliterator.SIZED |&lt;span&gt; Spliterator.SUBSIZED;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码解释参考自：http://blog.csdn.net/anxpp/article/details/51203591，感谢anxpp 的分享。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LinkedList和ArrayList的对比：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、顺序插入速度ArrayList会比较快，因为ArrayList是基于数组实现的，数组是事先new好的，只要往指定位置塞一个数据就好了；LinkedList则不同，每次顺序插入的时候LinkedList将new一个对象出来，如果对象比较大，那么new的时间势必会长一点，再加上一些引用赋值的操作，所以顺序插入LinkedList必然慢于ArrayList&lt;/p&gt;
&lt;p&gt;2、基于上一点，因为LinkedList里面不仅维护了待插入的元素，还维护了Entry的前置Entry和后继Entry，如果一个LinkedList中的Entry非常多，那么LinkedList将比ArrayList更耗费一些内存&lt;/p&gt;
&lt;p&gt;3、数据遍历的速度，看最后一部分，这里就不细讲了，结论是：&lt;strong&gt;使用各自遍历效率最高的方式，ArrayList的遍历效率会比LinkedList的遍历效率高一些&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4、有些说法认为LinkedList做插入和删除更快，这种说法其实是不准确的：&lt;/p&gt;
&lt;p&gt;（1）LinkedList做插入、删除的时候，慢在寻址，快在只需要改变前后Entry的引用地址&lt;/p&gt;
&lt;p&gt;（2）ArrayList做插入、删除的时候，慢在数组元素的批量copy，快在寻址&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，如果待插入、删除的元素是在数据结构的前半段尤其是非常靠前的位置的时候，LinkedList的效率将大大快过ArrayList，因为ArrayList将批量copy大量的元素；越往后，对于LinkedList来说，因为它是双向链表，所以在第2个元素后面插入一个数据和在倒数第2个元素后面插入一个元素在效率上基本没有差别，但是ArrayList由于要批量copy的元素越来越少，操作速度必然追上乃至超过LinkedList&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从这个分析看出，如果你十分确定你插入、删除的元素是在前半段，那么就使用LinkedList；如果你十分确定你删除、删除的元素在比较靠后的位置，那么可以考虑使用ArrayList。如果你不能确定你要做的插入、删除是在哪儿呢？那还是建议你使用LinkedList吧，因为一来LinkedList整体插入、删除的执行效率比较稳定，没有ArrayList这种越往后越快的情况；二来插入元素的时候，弄得不好ArrayList就要进行一次扩容，记住，&lt;strong&gt;ArrayList底层数组扩容是一个既消耗时间又消耗空间的操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、自己实现一个简单的LinkedList&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面学习了那么多，感觉还是自己来实现一个比较容易理解，并且面试的时候如果考到了，自己写一个简单的即可，理解原理才是最重要的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.定义一个Node节点&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study.collection;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来表示一个节点&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
     Node previous;   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上一个节点&lt;/span&gt;
&lt;span&gt;     Object obj;
     Node next;        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下一个节点&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node() {
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node(Node previous, Object obj, Node next) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.previous =&lt;span&gt; previous;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.obj =&lt;span&gt; obj;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node getPrevious() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; previous;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPrevious(Node previous) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.previous =&lt;span&gt; previous;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getObj() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setObj(Object obj) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.obj =&lt;span&gt; obj;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node getNext() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setNext(Node next) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
    }
    
    
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2.定义链表实现&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study.collection;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyLinkedList &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;implements List&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Node first; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首节点&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Node last;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;尾节点&lt;/span&gt;
    
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;个数&lt;/span&gt;
    
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; add(Object obj){
        Node n &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Node(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立一个新的节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(first==&lt;span&gt;null&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果首节点为空&lt;/span&gt;
&lt;span&gt;        {
            n.setPrevious(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            n.setObj(obj);
            n.setNext(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            first &lt;/span&gt;= n;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;则这个时候此进入的为第一个元素，那么首节点和尾节点均为新加入的这个节点&lt;/span&gt;
            last =&lt;span&gt; n;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接往last节点后增加新的节点&lt;/span&gt;
            n.setPrevious(last); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为这个时候只有一个,那么这个时候往后面添加元素,所以这个时候新加的节点的前节点为last&lt;/span&gt;
&lt;span&gt;            n.setObj(obj);
            n.setNext(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            
            last.setNext(n); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原来last的next 节点就是它了&lt;/span&gt;
&lt;span&gt;            
            last &lt;/span&gt;= n; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;n 变成了last &lt;/span&gt;
&lt;span&gt;        }
        size&lt;/span&gt;++&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; size;
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rangeCheck(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(index&amp;lt;0||index&amp;gt;=&lt;span&gt;size){
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Exception();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                e.printStackTrace();
            }
        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object get(&lt;span&gt;int&lt;/span&gt; index){   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;        rangeCheck(index);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0 1 2 3 4&lt;/span&gt;
        Node temp =&lt;span&gt; node(index);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(temp!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp.obj;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 这个是关键的步骤，根据索引找到对应的节点，这个时候只要遍历即可,而且遍历的&amp;lt;index 就可以了,因为最后就是它了。
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Node node(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index){
        Node temp &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(first!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index &amp;lt; (size &amp;gt;&amp;gt; 1&lt;span&gt;)) 
            {
                temp &lt;/span&gt;=&lt;span&gt; first;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;index;i++&lt;span&gt;)
                {
                    temp &lt;/span&gt;=&lt;span&gt; temp.next;
                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                temp &lt;/span&gt;=&lt;span&gt; last;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = size - 1; i &amp;gt; index; i--&lt;span&gt;){
                    temp &lt;/span&gt;=&lt;span&gt; temp.previous;
                }
            }
            
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        LinkedList l;&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp;
    }
    
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; remove(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index){
        Node temp &lt;/span&gt;=&lt;span&gt; node(index);
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(temp!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            Node up &lt;/span&gt;=&lt;span&gt; temp.previous;
            Node down &lt;/span&gt;=&lt;span&gt; temp.next;
            up.next &lt;/span&gt;=&lt;span&gt; down;
            down.previous &lt;/span&gt;=&lt;span&gt; up;
            size&lt;/span&gt;--&lt;span&gt;;
        }
        
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index,Object obj){
        Node temp &lt;/span&gt;=&lt;span&gt; node(index);
        
        Node newNode &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node();
        newNode.obj &lt;/span&gt;=&lt;span&gt; obj;
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(temp!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            Node up &lt;/span&gt;=&lt;span&gt; temp.previous;
            up.next &lt;/span&gt;=&lt;span&gt; newNode;
            newNode.previous &lt;/span&gt;=&lt;span&gt; up;
            
            newNode.next &lt;/span&gt;=&lt;span&gt; temp;
            temp.previous &lt;/span&gt;=&lt;span&gt; newNode;
            
            size&lt;/span&gt;++&lt;span&gt;;
        }
    }
    
    
    
    
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        MyLinkedList list &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyLinkedList();
        list.add(&lt;/span&gt;&quot;aaa&quot;&lt;span&gt;);
        list.add(&lt;/span&gt;&quot;bbb&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        list.add(1,&quot;BBBB&quot;);&lt;/span&gt;
        list.add(&quot;ccc&quot;&lt;span&gt;);
        list.add(&lt;/span&gt;&quot;ddd&quot;&lt;span&gt;);
        list.add(&lt;/span&gt;&quot;eee&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        list.remove(1);&lt;/span&gt;
        System.out.println(list.get(3&lt;span&gt;)); 
    }
    

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;http://www.cnblogs.com/CherishFX/p/4734490.html&lt;br/&gt;http://www.cnblogs.com/tstd/p/5046819.html&lt;br/&gt;http://blog.csdn.net/zw0283/article/details/51132161&lt;br/&gt;http://blog.csdn.net/anxpp/article/details/51203591&lt;/p&gt;
</description>
<pubDate>Wed, 01 Nov 2017 23:34:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/7768779.html</dc:identifier>
</item>
<item>
<title>[Bayesian] “我是bayesian我怕谁”系列 - Variational Inference - 郝一二三</title>
<link>http://www.cnblogs.com/jesse123/p/7764672.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jesse123/p/7764672.html</guid>
<description>&lt;p&gt;涉及的领域可能有些生僻，骗不了大家点赞。但毕竟是人工智能的主流技术，在园子却成了非主流。&lt;/p&gt;
&lt;p&gt;不可否认的是：乃值钱的技术，提高身价的技术，改变世界观的技术。&lt;/p&gt;

&lt;p&gt;关于变分，通常的课本思路是：&lt;/p&gt;
&lt;p&gt;GMM --&amp;gt; EM --&amp;gt; VI --&amp;gt; &lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_5&quot; class=&quot;entrylistItemTitle&quot; href=&quot;http://www.cnblogs.com/jesse123/p/7501743.html&quot;&gt;Variational Bayesian Gaussian Mixture&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GMM是个好东西，实用的模型，也是讲解收敛算法的一个好载体。&lt;/p&gt;
&lt;p&gt;关于这部分内容，如果你懂中文，推荐一个人，&lt;a title=&quot;教材链接&quot; href=&quot;http://www-staff.it.uts.edu.au/~ydxu/ml_course/&quot; target=&quot;_blank&quot;&gt;徐亦达老师&lt;/a&gt;。中文教学，亲手推算公式给读者的视频，是需要珍惜和珍藏的。&lt;/p&gt;
&lt;p&gt;因为提供了ppt，也有配套的视频，于是上半年将链接中的内容都走了一遍，感觉棒棒哒～&lt;/p&gt;
&lt;p&gt;基本上涵盖了该领域主流技术七成的基础内容，同时也节省了我大量的时间，学完后内力通常都能提高一两成的样子。&lt;/p&gt;
&lt;p&gt;再次道一句：“&lt;span&gt;好人一生平安&lt;/span&gt;“&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;GMM --&amp;gt; EM&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;From: &lt;a href=&quot;http://www-staff.it.uts.edu.au/~ydxu/ml_course/em.pdf&quot; target=&quot;_blank&quot;&gt;http://www-staff.it.uts.edu.au/~ydxu/ml_course/em.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解决的问题也很简单，一堆点，你通过平移或是缩放，用几个高斯去拟合数据。到底用几个高斯，这是个问题，而且是个高级问题。能提出这个问题，说明你是一只有潜力变成凤凰的菜鸡。&lt;/p&gt;
&lt;p&gt;我们目前先考虑采用固定个数的高斯去”尽量地”拟合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/310015/201711/310015-20171101070121170-128032784.png&quot; alt=&quot;&quot; width=&quot;391&quot; height=&quot;340&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Figure, fitting with three Gaussian distribution&lt;/p&gt;
&lt;p&gt;注意，这里的高斯是多维高斯；&lt;/p&gt;
&lt;p&gt;总有人说数学基础很重要，确实如此，问问自己两个最最基本的问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;多维高斯的表达形式是？&lt;/li&gt;
&lt;li&gt;有一个满足多维高斯的变量&lt;em&gt;&lt;strong&gt;x&lt;/strong&gt;&lt;/em&gt;，那么&lt;em&gt;&lt;strong&gt;x&lt;/strong&gt;&lt;/em&gt;&lt;sup&gt;2&lt;/sup&gt;满足的分布以及参数是？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;暂时不会也没关系，毕竟不是每个人都想当牛人拿高薪求创业。怕得就是不愿懂但还是想当牛人拿高薪求创业的孩子们。&lt;/p&gt;
&lt;p&gt;如何懂？可以拿一本《多元变量分析》or《矩阵论》打基础。&lt;/p&gt;

&lt;p&gt;说到底，就是个如何估参的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/310015/201711/310015-20171101074256670-1902562256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公式1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;图中的每个点，你可以说属于任何一个高斯，只是概率不同罢了。&lt;/p&gt;
&lt;p&gt;自然而然地，需要加上一个隐变量z来表示这个意思： &lt;span&gt;&lt;strong&gt;p(Z|X, Θ)&lt;/strong&gt;&lt;/span&gt; 　&lt;span&gt;＃某个点Ｘ属于哪一个高斯的概率&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/310015/201711/310015-20171101075833404-241598374.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公式2&lt;/strong&gt;：更新θ&lt;/p&gt;
&lt;p&gt;关于这个更新theta的公式，其实这么想会容易理解一些：&lt;/p&gt;
&lt;p&gt;Ａ君：我觉得目前的Θ&lt;sup&gt;(g)&lt;/sup&gt;已经是最优了。&lt;/p&gt;
&lt;p&gt;Ｂ君：真得？如果你说的没错，那么argmax后对p(Z,X|Θ)中Θ的求解结果就应该是你说的这个最优Θ&lt;sup&gt;(g)&lt;/sup&gt;，你确定？赌一把？&lt;/p&gt;
&lt;p&gt;Ａ君：这个嘛，你说的没错，如果得出的结论Θ&lt;sup&gt;(g+1)&lt;/sup&gt;不等于我这个最优Θ&lt;sup&gt;(g)&lt;/sup&gt;，那么我就说错了，得修正Θ&lt;sup&gt;(g)&lt;/sup&gt; = Θ&lt;sup&gt;(g+1)&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;Ｂ君：问题来了，我也不知道如此更新下去，收敛的目的地是否是最优的Θ。&lt;sup&gt;&lt;br/&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;Ａ君：恩，需要去证明。&lt;/p&gt;
&lt;p&gt;Ｂ君：是的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/310015/201711/310015-20171101082851341-23818354.jpg&quot; alt=&quot;&quot; width=&quot;577&quot; height=&quot;176&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3涨是目的；更新Θ后，若1涨，2跌就能达到目的&lt;/p&gt;
&lt;p&gt;先证明了：只要θ在变，【2】就会跌；【详见原视频讲解，有用到&lt;span&gt;&lt;strong&gt;Jensen's inequality&lt;/strong&gt;&lt;/span&gt;】&lt;/p&gt;
&lt;p&gt;所以，【1】涨【3】肯定也涨。&lt;/p&gt;
&lt;p&gt;那么，如何让【1】涨呢？这不就是【公式2】的意思么（argmax）！&lt;/p&gt;
&lt;p&gt;注意数学基础，【公式2】就是【1】部分，只是表达方式不同，一个是期望的形式，一个是积分的形式。&lt;/p&gt;

&lt;p&gt;【公式2】中明显有两个概率，把每个概率展开，写出具体的形式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/310015/201711/310015-20171101090045763-1861233222.png&quot; alt=&quot;&quot; width=&quot;599&quot; height=&quot;308&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;把这个具体的形式带入【公式2】，然后……&amp;lt;看视频中计算过程&amp;gt;……，【公式2】变为了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/310015/201711/310015-20171101090326935-282540138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这就是EM方法中的likelihood，使其最大化即可；同时也是更新θ的公式。&lt;/p&gt;
&lt;p&gt;通常，有了likelihood也就有了一切，之后求导便是。&lt;/p&gt;
&lt;p&gt;对谁求导？你想优化谁就对谁求导！&lt;/p&gt;
&lt;p&gt;要优化谁？当然是θ这个向量代表的各个具体的参数咯！&lt;/p&gt;
&lt;p&gt;Θ = {α&lt;sub&gt;1&lt;/sub&gt;, . . . α&lt;sub&gt;k&lt;/sub&gt; , µ&lt;sub&gt;1&lt;/sub&gt;, . . . µ&lt;sub&gt;k&lt;/sub&gt; , Σ&lt;sub&gt;1&lt;/sub&gt;, . . . Σ&lt;sub&gt;k&lt;/sub&gt; }&lt;/p&gt;

&lt;p&gt;既然是EM，那么，&lt;/p&gt;
&lt;p&gt;Iterate:&lt;br/&gt;1. [E-step] Infer &lt;span&gt;missing values &lt;span&gt;{latent variables}&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;given current parameters　--&amp;gt; 根据公式求p(Z|X,θ)，其实有点高斯采样的感觉，得到了下图中每个采样点的&lt;span&gt;p(&lt;em&gt;l&lt;/em&gt;|X&lt;sub&gt;i&lt;/sub&gt;,θ&lt;sup&gt;(g)&lt;/sup&gt;)&lt;/span&gt;&lt;br/&gt;2. [M-step] Optimize &lt;span&gt;parameters&lt;/span&gt; &lt;span&gt;{θ}&lt;/span&gt; given the “filled-in” data　--&amp;gt;  套入下面公式即可；公式通过求导的结果而来，具体会用到&lt;span&gt;&lt;strong&gt;“拉格朗日乘子法+KKT条件”&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/310015/201711/310015-20171101093255826-1913434595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;就是这么一回事，感觉也没什么可说。 但细细想来有一个问题，上述过程中涉及到大量的贝叶斯定理，也就会有求后验分布这样的过程，如果涉及的分布不是高斯这样的友好分布，导致求后验分布困难，那上述的这段流程岂不是走不下来了么？&lt;/p&gt;


&lt;div readability=&quot;16.5&quot;&gt;
&lt;div readability=&quot;28&quot;&gt;
&lt;p&gt;简单易懂的理解变分其实就是一句话：用简单的分布q去近似复杂的分布p。&lt;br/&gt;首先，&lt;span&gt;为什么要选择用变分推断？&lt;/span&gt;&lt;br/&gt;因为，&lt;span&gt;大多数情况下后验分布很难求&lt;/span&gt;啊。如果后验概率好求解的话我们直接EM就搞出来了。&lt;/p&gt;
&lt;p&gt;当后验分布难于求解的时候我们就希望选择一些简单的分布来近似这些复杂的后验分布，至于这种简单的分布怎么选，有很多方法比如：Bethe自由能，平均场定理。&lt;span&gt;而应用最广泛的要数平均场定理。为什么？&lt;/span&gt;&lt;br/&gt;因为它假设各个变量之间相互独立砍断了所有变量之间的依赖关系。&lt;span&gt;这又有什么好处呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们拿一个不太恰当的例子来形象的说明一下：用古代十字军东征来作为例子说明一下mean field。十字军组成以骑兵为主步兵为辅，开战之前骑兵手持重标枪首先冲击敌阵步兵手持刀斧跟随，一旦接战就成了单对单的决斗。那么在每个人的战斗力基本相似的情况下某个人的战斗力可以由其他人的均值代替这是平均场的思想。这样在整个军队没有什么战术配合的情况下军队的战斗力可以由这些单兵的战斗力来近似这是变分的思想。&lt;br/&gt;当求解Inference问题的时候相当于积分掉无关变量求边际分布，如果变量维度过高，积分就会变得非常困难，而且你积分的分布p又可能非常复杂因此就彻底将这条路堵死了。采用平均场就是将这种复杂的多元积分变成简单的多个一元积分，而且我们选择的q是指数族内的分布，更易于积分求解。&lt;span&gt;如果变量间的依赖关系很强怎么办？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那就是structured mean field解决的问题了。&lt;/p&gt;
&lt;p&gt;说到这里我们就知道了为什么要用变分，&lt;span&gt;那么怎么用？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;过程很简单，推导很复杂。&lt;br/&gt;整个过程只需要：&lt;br/&gt;1、根据图模型写出联合分布&lt;br/&gt;2、写出mean filed 的形式（给出变分参数及其生成隐变量的分布）&lt;br/&gt;3、写出ELBO（为什么是ELBO？优化它跟优化KL divergence等价，KL divergence因为含有后验分布不好优化）&lt;br/&gt;4、求偏导进行变分参数学习&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;EM --&amp;gt; VI&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;From: &lt;a href=&quot;http://www-staff.it.uts.edu.au/~ydxu/ml_course/variational.pdf&quot; target=&quot;_blank&quot;&gt;http://www-staff.it.uts.edu.au/~ydxu/ml_course/variational.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该页表述很清晰，p是未知的真实分布，如何找一个q分布来尽可能地近似p，以下就是理论依据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/310015/201711/310015-20171101164041654-422788207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ln (p(X)) = Evidence Lower Bound (ELOB) + KL divergence&lt;/p&gt;
&lt;p&gt;做一个iid假设来近似真实分布p：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/310015/201711/310015-20171101165435357-220367782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;之后，将L(q)替换为iid假设后，成为如下形式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/310015/201711/310015-20171101165241748-1936672727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Figure, Evidence Lower Bound (ELOB) &lt;/p&gt;
&lt;p&gt;到此，菜鸡可能会有点迷惑，这么做到底为了什么？不用怕，其实当初我也迷惑，：）&lt;/p&gt;
&lt;p&gt;但到此，我们至少知道&lt;span&gt;做了一个iid的假设&lt;span&gt;，&lt;/span&gt;这个很重要&lt;/span&gt;，记住这一步。&lt;/p&gt;
&lt;p&gt;那么，为了理解这个假设，趁热先直接上个例子如何：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; title=&quot;手算推导Bayesian GMM&quot; href=&quot;http://www.cnblogs.com/jesse123/p/6927714.html&quot;&gt;[Bayes] Variational Inference for Bayesian GMMs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链接中的目的：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;推导出近似各个变量的公式。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;为什么不能用EM？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;例子中涉及的分布除了高斯还有好多，情况太复杂，一看就是后验不好求。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;为什么要折腾这个复杂的东东？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;示意图很明了，与普通GMM相比，模型加了dirichlet，就跟突然有了大脑。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/310015/201711/310015-20171102070008998-1532627493.png&quot; alt=&quot;&quot; width=&quot;347&quot; height=&quot;260&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看来，模型加了先验（变得复杂），对performance确实有莫大的好处。&lt;/p&gt;
&lt;p&gt;模型复杂就不好估参，其中后验计算复杂也是原因之一。&lt;/p&gt;
&lt;p&gt;看上去，变分推断的必要性成了显而易见的常识。&lt;/p&gt;
&lt;p&gt;写到这里，希望菜鸡对变分有了更深的认识，本文的初衷不是教材，更多的是充当tutor，帮助大家理清思路，加深认识，建立知识体系。&lt;/p&gt;
&lt;p&gt;“学习”这种东西，最终还是自己的事儿，但“引导”确实需要他人来给予。&lt;/p&gt;

&lt;p&gt;书归正传，这个结论就是使用变分的核心：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/310015/201711/310015-20171102070359185-1208498694.png&quot; alt=&quot;&quot; width=&quot;815&quot; height=&quot;103&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/310015/201711/310015-20171102070647466-1372848100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/310015/201711/310015-20171102070805873-542408914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;迭代过程：注意一一对应的关系，变量命名有区别，注意分辨&lt;/p&gt;

&lt;p&gt;求近似公式的方法用起来很方便啊，如何得到的呢？&lt;/p&gt;
&lt;p&gt;这就要回头到 &lt;span&gt;&lt;strong&gt;Figure, Evidence Lower Bound (ELOB)&lt;/strong&gt; &lt;span&gt;，继续我们的思路。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;“&lt;span&gt;做了一个iid的假设&lt;span&gt;，&lt;/span&gt;这个很重要&lt;/span&gt;”，实例中也就是：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/310015/201711/310015-20171102071201638-1675468520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么一定要做这个假设？&lt;/p&gt;
&lt;p&gt;因为变分中迭代过程两部分变量的关系：第一部分迭代结果给第二部分；第二部分迭代结果给第一部分；&lt;/p&gt;
&lt;p&gt;当然，这两部分变量要假设为iid咯。&lt;/p&gt;
&lt;p&gt;突然，就这么好理解了……&lt;/p&gt;
&lt;p&gt;至于具体的原理推导过程，在此不添加“网络信息冗余”，建议看原视频讲解。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;VI --&amp;gt; &lt;span&gt;&lt;a id=&quot;CategoryEntryList1_EntryStoryList_ctl00_Entries_TitleUrl_5&quot; class=&quot;entrylistItemTitle&quot; href=&quot;http://www.cnblogs.com/jesse123/p/7501743.html&quot;&gt;Variational Bayesian GMM&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;From: &lt;a href=&quot;http://www.cnblogs.com/jesse123/p/7501743.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/jesse123/p/7501743.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这部分内容得请高人，为什么会自动调整拟合混合分布，涉及到Dirichlet process的研究，读者姑且把Dirichlet看做是每个高斯的权重调整，就相当于图像中的透明属性。&lt;/p&gt;
&lt;p&gt;不太清楚目前研究的进展如何，理论基础可能还未完备，但实践效果往往挺好。&lt;/p&gt;

&lt;p&gt;本篇就到这里，关于变分的使用，未来还会有涉及，慢慢体会。&lt;/p&gt;
&lt;p&gt;愿菜鸡们建立起人工智能的知识体系，与世界接轨，而非被路人忽悠。&lt;/p&gt;

</description>
<pubDate>Wed, 01 Nov 2017 23:27:00 +0000</pubDate>
<dc:creator>郝一二三</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jesse123/p/7764672.html</dc:identifier>
</item>
<item>
<title>FastDFS 集群 安装 配置 - 纯洁的微笑</title>
<link>http://www.cnblogs.com/ityouknow/p/7769142.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ityouknow/p/7769142.html</guid>
<description>&lt;p&gt;这篇文章介绍如何搭建FastDFS 集群&lt;/p&gt;
&lt;p&gt;FastDFS是一个开源的轻量级分布式文件系统，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。&lt;/p&gt;
&lt;p&gt;FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;环境准备&lt;/h2&gt;
&lt;p&gt;系统系统 centos6.5&lt;br/&gt;六台服务器：192.168.53.85/86/90&lt;br/&gt;192.168.54.73/74/75&lt;br/&gt;安装包：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fastdfs-5.05.tar.gz&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;libfastcommon-1.0.36.zip&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;nginx-1.7.9.tar.gz&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务器规划&lt;/p&gt;
&lt;p&gt;tracker服务器：192.168.53.85/86&lt;br/&gt;storage服务器：192.168.53.90&lt;br/&gt;192.168.54.73/74/75&lt;/p&gt;
&lt;h2 id=&quot;安装fastdfs全部&quot;&gt;安装Fastdfs(全部)&lt;/h2&gt;
&lt;p&gt;安装依赖包&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：FastDFS 5.x 取消了对 libevent 的依赖，添加了对 libfastcommon 的依赖。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在安装FastDFS和Nginx之前，需确保gcc、gcc-c++、 libstdc++-devel、make等依赖库和工具已经安装&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;#安装依赖软件&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;yum&lt;/span&gt; -y install gcc gcc-c++ libstdc++-devel pcre-devel zlib-devel wget make
&lt;span class=&quot;kw&quot;&gt;yum&lt;/span&gt; -y groupinstall &lt;span class=&quot;st&quot;&gt;'Development Tools'&lt;/span&gt; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装libfastcommon类库&lt;/p&gt;
&lt;p&gt;安装FastDFS必须先安装libfastcommon类库，否则会导致报错，安装直接根据如下几个步骤即可~&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;unzip&lt;/span&gt; libfastcommon-1.0.36.zip  -d /usr/local

&lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; /usr/local/libfastcommon-1.0.36
&lt;span class=&quot;kw&quot;&gt;./make.sh&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;./make.sh&lt;/span&gt; install&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装FastDFS&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;tar&lt;/span&gt; -xvzf fastdfs-5.05.tar.gz -C /usr/local

&lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; /usr/local/fastdfs-5.05
&lt;span class=&quot;kw&quot;&gt;./make.sh&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;./make.sh&lt;/span&gt; install&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装好之后，在/usr/bin目录下，可以看fdfs开头的命令工具&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;FastDFS安装完成之后，所有配置文件在/etc/fdfs目录下，tracker需要tracker.conf配置文件，storage需要storage.conf配置文件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;安装tracker8586&quot;&gt;安装tracker（85/86）&lt;/h2&gt;
&lt;p&gt;将tracker.conf.sample文件重命名为tracker.conf，然后修改配置文件/etc/fdfs/tracker.conf&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 存储日志和数据的根目录&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;mkdir&lt;/span&gt; /root/fastdfs

&lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; /etc/fdfs
&lt;span class=&quot;kw&quot;&gt;cp&lt;/span&gt; tracker.conf.sample tracker.conf&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只需要修改 base_pash路径（文件存储路径）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;vi&lt;/span&gt; tracker.conf
&lt;span class=&quot;ot&quot;&gt;base_path=&lt;/span&gt;/root/fastdfs&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置文件中有这几个参数需要注意：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;co&quot;&gt;#启用配置文件&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;disabled=&lt;/span&gt;false
&lt;span class=&quot;co&quot;&gt;#设置tracker的端口号&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;port=&lt;/span&gt;22122
&lt;span class=&quot;co&quot;&gt;#设置tracker的数据文件和日志目录（需手动创建）&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;base_path=&lt;/span&gt;/root/fastdfs
&lt;span class=&quot;co&quot;&gt;#设置http端口号&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;http.server_port&lt;/span&gt;=9090&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code&gt;/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf start&lt;/code&gt;尝试启动tracker&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;[&lt;span class=&quot;kw&quot;&gt;root@localhost&lt;/span&gt; ~]# fdfs_trackerd /etc/fdfs/tracker.conf restart
[&lt;span class=&quot;kw&quot;&gt;root@localhost&lt;/span&gt; ~]# &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;没有报错，查看端口22122是否开始监听，确认启动是否成功。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;[&lt;span class=&quot;kw&quot;&gt;root@localhost&lt;/span&gt; ~]# ps -ef&lt;span class=&quot;kw&quot;&gt;|grep&lt;/span&gt; fdfs
&lt;span class=&quot;kw&quot;&gt;root&lt;/span&gt;      6078     1  0 11:59 ?        00:00:00 /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf start
&lt;span class=&quot;kw&quot;&gt;root&lt;/span&gt;      6101  6054  0 12:01 pts/2    00:00:00 grep fdfs
[&lt;span class=&quot;kw&quot;&gt;root@localhost&lt;/span&gt; ~]# netstat -unltp &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;grep&lt;/span&gt; fdfs
&lt;span class=&quot;kw&quot;&gt;tcp&lt;/span&gt;        0      0 0.0.0.0:22122               0.0.0.0:*                   LISTEN      6078/fdfs_trackerd  &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以查看tracker的日志是否启动成功&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;[&lt;span class=&quot;kw&quot;&gt;root@localhost&lt;/span&gt; ~]# cat /root/fastdfs/logs/trackerd.log 
[&lt;span class=&quot;kw&quot;&gt;2017-10-09&lt;/span&gt; 11:59:12] INFO - FastDFS v5.05, base_path=/root/fastdfs, run_by ...&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，一个简单的的tracker配置就完成了，Tracker也成功启动~， 接下来要做的就是完成Storage的配置~&lt;/p&gt;

&lt;h2 id=&quot;安装storage90737475&quot;&gt;安装storage（90/73/74/75）&lt;/h2&gt;
&lt;p&gt;将存储节点分为两个组，其中group1 （72、73）、group2 （74、75）。&lt;/p&gt;
&lt;p&gt;创建存储目录和配置文件&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;mkdir&lt;/span&gt; /root/fastdfs

&lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; /etc/fdfs
&lt;span class=&quot;kw&quot;&gt;cp&lt;/span&gt; storage.conf.sample storage.conf&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改配置&lt;/p&gt;
&lt;p&gt;storage主要完成base_path，store_path以及tracker的连接地址以及storage的http服务端口配置等。&lt;/p&gt;
&lt;p&gt;主要有如下几个参数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;vi&lt;/span&gt; /etc/fdfs/storage.conf
&lt;span class=&quot;co&quot;&gt;# 内容&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;group_name=&lt;/span&gt;group1                   &lt;span class=&quot;co&quot;&gt;# 组名（第一组为group1，第二组为group2，依次类推...）&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;base_path=&lt;/span&gt;/root/fastdfs             &lt;span class=&quot;co&quot;&gt;# 数据和日志文件存储根目录&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;store_path0=&lt;/span&gt;/root/fastdfs           &lt;span class=&quot;co&quot;&gt;#第一个存储目录，第二个存储目录起名为：store_path1=xxx，其它存储目录名依次类推...&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;store_path_count=&lt;/span&gt;1                  &lt;span class=&quot;co&quot;&gt;# 存储路径个数，需要和store_path个数匹配&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;tracker_server=&lt;/span&gt;192.168.53.85:22122          &lt;span class=&quot;co&quot;&gt;# tracker服务器IP和端口&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;tracker_server=&lt;/span&gt;192.168.53.86:22122          &lt;span class=&quot;co&quot;&gt;# tracker服务器IP和端口&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动Storage&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;启动storage，会根据配置文件的设置自动创建多级存储目录，查看端口23000是否开始监听，确认启动是否成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;[&lt;span class=&quot;kw&quot;&gt;root@localhost&lt;/span&gt; fdfs]# fdfs_storaged /etc/fdfs/storage.conf restart
[&lt;span class=&quot;kw&quot;&gt;root@localhost&lt;/span&gt; fdfs]# netstat -unltp &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;grep&lt;/span&gt; fdfs
&lt;span class=&quot;kw&quot;&gt;tcp&lt;/span&gt;        0      0 0.0.0.0:23000               0.0.0.0:*                   LISTEN      5551/fdfs_storaged  &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以查看storage的日志是否启动成功。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;[&lt;span class=&quot;kw&quot;&gt;root@localhost&lt;/span&gt; logs]# cat /root/fastdfs/logs/storaged.log 
[&lt;span class=&quot;kw&quot;&gt;2017-10-09&lt;/span&gt; 15:39:12] INFO - FastDFS v5.05, base_path=/root/fastdfs, store_path_count=1 ...&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;验证storage是否登记到tracker服务器&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;fdfs_monitor /etc/fdfs/storage.conf&lt;/code&gt;，运行fdfs_monitor查看storage服务器是否已经登记到tracker服务器。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;可以在任一存储节点上使用如下命令查看集群的状态信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;fdfs_monitor&lt;/span&gt; /etc/fdfs/storage.conf&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果出现ip_addr = Active, 则表明storage服务器已经登记到tracker服务器，如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;Storage&lt;/span&gt; 1:
        &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; = 192.168.53.90
        &lt;span class=&quot;kw&quot;&gt;ip_addr&lt;/span&gt; = 192.168.53.90 (localhost)  &lt;span class=&quot;kw&quot;&gt;ACTIVE&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，tracker、storage等配置都完成并成功启动&lt;/p&gt;
&lt;p&gt;接下来，继续完成Nginx和fastdfs-nginx-module的安装和配置&lt;/p&gt;

&lt;h2 id=&quot;在storage上安装nginx&quot;&gt;在storage上安装nginx&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：fastdfs-nginx-module模块只需要安装到storage上。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;
&lt;p&gt;解压安装包&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;tar&lt;/span&gt; -xvzf fastdfs-nginx-module_v1.16.tar.gz -C /usr/local
&lt;span class=&quot;kw&quot;&gt;tar&lt;/span&gt; -zvxf nginx-1.7.9.tar.gz  -C /usr/local&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要先配置软链接:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ln&lt;/span&gt; -sv /usr/include/fastcommon /usr/local/include/fastcommon 
&lt;span class=&quot;kw&quot;&gt;ln&lt;/span&gt; -sv /usr/include/fastdfs /usr/local/include/fastdfs 
&lt;span class=&quot;kw&quot;&gt;ln&lt;/span&gt; -sv /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;安装nginx的时候，添加 fastdfs-nginx-module-master模块，如：&lt;br/&gt;&lt;code&gt;./configure --add-module=../fastdfs-nginx-module/src/&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; /usr/local/nginx-1.7.9
&lt;span class=&quot;kw&quot;&gt;./configure&lt;/span&gt; --prefix=/usr/local/nginx --add-module=/usr/local/fastdfs-nginx-module/src&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;configure 成功输出结果：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;checking&lt;/span&gt; for OS
 &lt;span class=&quot;kw&quot;&gt;+&lt;/span&gt; Linux 2.6.32-431.el6.x86_64 x86_64
&lt;span class=&quot;kw&quot;&gt;checking&lt;/span&gt; for C compiler ... found
 &lt;span class=&quot;kw&quot;&gt;+&lt;/span&gt; using GNU C compiler
 &lt;span class=&quot;kw&quot;&gt;+&lt;/span&gt; gcc version: 4.4.7 20120313 (Red Hat 4.4.7-18) &lt;span class=&quot;kw&quot;&gt;(GCC)&lt;/span&gt; 
&lt;span class=&quot;kw&quot;&gt;checking&lt;/span&gt; for gcc -pipe switch ... found

&lt;span class=&quot;kw&quot;&gt;......&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;nginx&lt;/span&gt; http access log file: &lt;span class=&quot;st&quot;&gt;&quot;/usr/local/nginx/logs/access.log&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;nginx&lt;/span&gt; http client request body temporary files: &lt;span class=&quot;st&quot;&gt;&quot;client_body_temp&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;nginx&lt;/span&gt; http proxy temporary files: &lt;span class=&quot;st&quot;&gt;&quot;proxy_temp&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;nginx&lt;/span&gt; http fastcgi temporary files: &lt;span class=&quot;st&quot;&gt;&quot;fastcgi_temp&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;nginx&lt;/span&gt; http uwsgi temporary files: &lt;span class=&quot;st&quot;&gt;&quot;uwsgi_temp&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;nginx&lt;/span&gt; http scgi temporary files: &lt;span class=&quot;st&quot;&gt;&quot;scgi_temp&quot;&lt;/span&gt; &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;configure成功了&lt;/p&gt;
&lt;p&gt;接下来执行make和make install&lt;/p&gt;

&lt;p&gt;确定编译没有出错，再进行install&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;make&lt;/span&gt; install &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装成功，查看版本信息&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;/usr/local/nginx/sbin/nginx&lt;/span&gt; -V&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;配置fastdfs-nginx-module&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进入fastdfs-nginx-module的src目录，将md_fastdfs.conf配置文件拷贝到/etc/fdfs/目录中&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; /usr/local/fastdfs-nginx-module/src
&lt;span class=&quot;kw&quot;&gt;cp&lt;/span&gt; mod_fastdfs.conf /etc/fdfs/&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置 mod_fastdfs.conf&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;vim&lt;/span&gt; /etc/fdfs/mod_fastdfs.conf&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;一般只需改动以下几个参数即可：
&lt;span class=&quot;ot&quot;&gt;base_path=&lt;/span&gt;/root/fastdfs           &lt;span class=&quot;co&quot;&gt;#保存日志目录&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;tracker_server=&lt;/span&gt;192.168.53.85:22122
&lt;span class=&quot;ot&quot;&gt;tracker_server=&lt;/span&gt;192.168.53.86:22122 
&lt;span class=&quot;ot&quot;&gt;storage_server_port=&lt;/span&gt;23000         &lt;span class=&quot;co&quot;&gt;#storage服务器的端口号&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;group_name=&lt;/span&gt;group1                 &lt;span class=&quot;co&quot;&gt;#当前服务器的group名&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;url_have_group_name&lt;/span&gt; = true        &lt;span class=&quot;co&quot;&gt;#文件url中是否有group名&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;store_path_count=&lt;/span&gt;1                &lt;span class=&quot;co&quot;&gt;#存储路径个数，需要和store_path个数匹配&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;store_path0=&lt;/span&gt;/root/fastdfs         &lt;span class=&quot;co&quot;&gt;#存储路径&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;group_count&lt;/span&gt; = 2                   &lt;span class=&quot;co&quot;&gt;#设置组的个数&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在末尾增加3个组的具体信息：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;[&lt;span class=&quot;kw&quot;&gt;group1&lt;/span&gt;]
&lt;span class=&quot;ot&quot;&gt;group_name=&lt;/span&gt;group1
&lt;span class=&quot;ot&quot;&gt;storage_server_port=&lt;/span&gt;23000
&lt;span class=&quot;ot&quot;&gt;store_path_count=&lt;/span&gt;1
&lt;span class=&quot;ot&quot;&gt;store_path0=&lt;/span&gt;/root/fastdfs

[&lt;span class=&quot;kw&quot;&gt;group2&lt;/span&gt;]
&lt;span class=&quot;ot&quot;&gt;group_name=&lt;/span&gt;group2
&lt;span class=&quot;ot&quot;&gt;storage_server_port=&lt;/span&gt;23000
&lt;span class=&quot;ot&quot;&gt;store_path_count=&lt;/span&gt;1
&lt;span class=&quot;ot&quot;&gt;store_path0=&lt;/span&gt;/root/fastdfs&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建立M00至存储目录的符号连接。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ln&lt;/span&gt; -s /root/fastdfs/data /root/fastdfs/data/M00
&lt;span class=&quot;kw&quot;&gt;ll&lt;/span&gt; /root/fastdfs/data/M00&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;配置nginx&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编辑&lt;code&gt;/usr/local/nginx/conf&lt;/code&gt;配置文件目录下的nginx.conf，设置添加storage信息并保存。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;vim&lt;/span&gt; /usr/local/nginx/conf/nginx.conf&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将server段中的listen端口号改为8080，启动用户使用root。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;user&lt;/span&gt; root
&lt;span class=&quot;kw&quot;&gt;listen&lt;/span&gt;       8080&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在server段中添加：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;location&lt;/span&gt; ~/group[1-2]/M00 {
    &lt;span class=&quot;kw&quot;&gt;root&lt;/span&gt; /root/fastdfs/data&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;ngx_fastdfs_module;&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;复制fastdfs中的http.conf、mime.types文件到/etc/fdfs&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;cp&lt;/span&gt; /usr/local/fastdfs-5.05/conf/http.conf /usr/local/fastdfs-5.05/conf/mime.types  /etc/fdfs&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，nginx以及FastDFS插件模块设置完成。&lt;/p&gt;
&lt;h3 id=&quot;运行&quot;&gt;运行&lt;/h3&gt;
&lt;p&gt;运行nginx之前，先要把防火墙中对应的端口打开（本例中为8080）。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;iptables&lt;/span&gt; -I INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT
&lt;span class=&quot;kw&quot;&gt;/etc/init.d/iptables&lt;/span&gt; save&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动nginx，确认启动是否成功。（查看是否对应端口8080是否开始监听）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;[&lt;span class=&quot;kw&quot;&gt;root@localhost&lt;/span&gt; ~]# /usr/local/nginx/sbin/nginx
&lt;span class=&quot;kw&quot;&gt;ngx_http_fastdfs_set&lt;/span&gt; pid=12768
[&lt;span class=&quot;kw&quot;&gt;root@localhost&lt;/span&gt; ~]# netstat -unltp &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;grep&lt;/span&gt; nginx
&lt;span class=&quot;kw&quot;&gt;tcp&lt;/span&gt;        0      0 0.0.0.0:8080                0.0.0.0:*                   LISTEN      12769/nginx  &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可查看nginx的日志是否启动成功或是否有错误。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;cat&lt;/span&gt; /usr/local/nginx/logs/error.log&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在error.log中没有错误，既启动成功。可以打开浏览器，直接访问http://192.168.53.90:8080，查看是否弹出nginx欢迎页面。&lt;/p&gt;
&lt;p&gt;查看到欢迎页则说明，nginx运行成功。之后依次在其它storage上全部安装上nginx并确认运行正常。&lt;/p&gt;
&lt;p&gt;将nginx设置为开机启动：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;vim&lt;/span&gt; /etc/rc.d/rc.local&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将运行命令行添加进文件：&lt;code&gt;/usr/local/nginx/sbin/nginx&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;在tracker上安装nginx&quot;&gt;在tracker上安装nginx&lt;/h2&gt;
&lt;p&gt;在tracker上安装的nginx主要为了提供http访问的反向代理、负载均衡以及缓存服务。&lt;/p&gt;
&lt;h3 id=&quot;安装-1&quot;&gt;安装&lt;/h3&gt;
&lt;p&gt;解压&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;tar&lt;/span&gt; -zvxf nginx-1.7.9.tar.gz  -C /usr/local&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行./configure进行安装前的设置，主要设置安装路径&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;cd&lt;/span&gt; /usr/local/nginx-1.7.9
&lt;span class=&quot;kw&quot;&gt;./configure&lt;/span&gt; --prefix=/usr/local/nginx&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行make进行编译，确保编译成功。&lt;/p&gt;

&lt;p&gt;运行make install进行安装。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;make&lt;/span&gt; install&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;配置-1&quot;&gt;配置&lt;/h3&gt;
&lt;p&gt;编辑/usr/local/nginx/conf配置文件目录下的nginx.conf，设置负载均衡&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;vim&lt;/span&gt; /usr/local/nginx/conf/nginx.conf&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置信息&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;worker_processes&lt;/span&gt;  4&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;                  &lt;span class=&quot;co&quot;&gt;#根据CPU核心数而定&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;events&lt;/span&gt; {
    &lt;span class=&quot;kw&quot;&gt;worker_connections&lt;/span&gt;  65535&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;co&quot;&gt;#最大链接数&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;use&lt;/span&gt; epoll&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;                        &lt;span class=&quot;co&quot;&gt;#新版本的Linux可使用epoll加快处理性能&lt;/span&gt;
}
&lt;span class=&quot;kw&quot;&gt;http&lt;/span&gt; {
    &lt;span class=&quot;co&quot;&gt;#设置group1的服务器&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;upstream&lt;/span&gt; fdfs_group1 {
        &lt;span class=&quot;kw&quot;&gt;server&lt;/span&gt; 192.168.53.90:8080 weight=1 max_fails=2 fail_timeout=30s&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;server&lt;/span&gt; 192.168.54.229:8080 weight=1 max_fails=2 fail_timeout=30s&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    }
    &lt;span class=&quot;co&quot;&gt;#设置group2的服务器&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;upstream&lt;/span&gt; fdfs_group2 {
        &lt;span class=&quot;kw&quot;&gt;server&lt;/span&gt; 192.168.54.233:8080 weight=1 max_fails=2 fail_timeout=30s&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;server&lt;/span&gt; 192.168.54.234:8080 weight=1 max_fails=2 fail_timeout=30s&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
    }

   &lt;span class=&quot;kw&quot;&gt;server&lt;/span&gt; {
       &lt;span class=&quot;co&quot;&gt;#设置服务器端口&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;listen&lt;/span&gt;       8080&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
       &lt;span class=&quot;co&quot;&gt;#设置group1的负载均衡参数&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;location&lt;/span&gt; /group1/M00 {
            &lt;span class=&quot;kw&quot;&gt;proxy_pass&lt;/span&gt; http://fdfs_group1&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        }
        &lt;span class=&quot;co&quot;&gt;#设置group2的负载均衡参数&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;location&lt;/span&gt; /group2/M00 {
            &lt;span class=&quot;kw&quot;&gt;proxy_pass&lt;/span&gt; http://fdfs_group2&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
        }
      }

    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，nginx设置完成。&lt;/p&gt;
&lt;h3 id=&quot;运行-1&quot;&gt;运行&lt;/h3&gt;
&lt;p&gt;运行nginx之前，先要把防火墙中对应的端口打开（本例中为8080）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;iptables&lt;/span&gt; -I INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT
&lt;span class=&quot;kw&quot;&gt;/etc/init.d/iptables&lt;/span&gt; save&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动nginx，确认启动是否成功。（查看是否对应端口8080是否开始监听）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;[&lt;span class=&quot;kw&quot;&gt;root@localhost&lt;/span&gt; ~]# /usr/local/nginx/sbin/nginx
&lt;span class=&quot;kw&quot;&gt;ngx_http_fastdfs_set&lt;/span&gt; pid=12768
[&lt;span class=&quot;kw&quot;&gt;root@localhost&lt;/span&gt; ~]# netstat -unltp &lt;span class=&quot;kw&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;grep&lt;/span&gt; nginx
&lt;span class=&quot;kw&quot;&gt;tcp&lt;/span&gt;        0      0 0.0.0.0:8080                0.0.0.0:*                   LISTEN      12769/nginx  &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可查看nginx的日志是否启动成功或是否有错误。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;cat&lt;/span&gt; /usr/local/nginx/logs/error.log&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;尝试上传一个文件到FastDFS，然后访问试试。先配置client.conf文件。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;cp&lt;/span&gt; client.conf.sample  client.conf
&lt;span class=&quot;kw&quot;&gt;vim&lt;/span&gt; /etc/fdfs/client.conf&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改以下参数：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;ot&quot;&gt;base_path=&lt;/span&gt;/root/fastdfs                   &lt;span class=&quot;co&quot;&gt;#日志存放路径&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;tracker_server=&lt;/span&gt;192.168.53.85:22122         
&lt;span class=&quot;ot&quot;&gt;tracker_server=&lt;/span&gt;192.168.53.86:22122 
&lt;span class=&quot;kw&quot;&gt;http.tracker_server_port&lt;/span&gt;=8080&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用/usr/local/bin/fdfs_upload_file上传一个文件，程序会自动返回文件的URL。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;[&lt;span class=&quot;kw&quot;&gt;root@localhost&lt;/span&gt; fdfs]# fdfs_upload_file /etc/fdfs/client.conf /root/test.jpg
&lt;span class=&quot;kw&quot;&gt;group2/M00/00/00/wKg26VncfamAEqZ0AAu-4Kcs3QI677.jpg&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后使用浏览器访问:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;http&lt;/span&gt;://192.168.53.85:8080/group2/M00/00/00/wKg26VncfamAEqZ0AAu-4Kcs3QI677.jpg&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看有查看到图片,说明集群搭建成功！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ityouknow.com/assets/images/neo.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;生产中可以将：&lt;code&gt;/root/fastdfs&lt;/code&gt; 替换为：&lt;code&gt;/fdfs/storage&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;报错&quot;&gt;报错&lt;/h2&gt;
&lt;h3 id=&quot;编译nginx的时候报错&quot;&gt;编译nginx的时候报错&lt;/h3&gt;
&lt;p&gt;在nginx目录下，执行configure之后，进行make编译报错，报错内容如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;s&lt;/span&gt; -I src/mail \
                -o objs/addon/src/ngx_http_fastdfs_module.o \
                /usr/local/fastdfs-nginx-module/src/ngx_http_fastdfs_module.c
&lt;span class=&quot;kw&quot;&gt;In&lt;/span&gt; file included from /usr/local/fastdfs-nginx-module/src/ngx_http_fastdfs_module.c:6:
&lt;span class=&quot;kw&quot;&gt;/usr/local/fastdfs-nginx-module/src&lt;/span&gt;/common.c:&lt;span class=&quot;kw&quot;&gt;21&lt;/span&gt;:25: error: fdfs_define.h: No such file or directory

&lt;span class=&quot;kw&quot;&gt;......&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;/usr/local/fastdfs-nginx-module/src&lt;/span&gt;/ngx_http_fastdfs_module.c:&lt;span class=&quot;kw&quot;&gt;933&lt;/span&gt;: error: ‘true’ undeclared (first use in this function)
&lt;span class=&quot;kw&quot;&gt;make&lt;/span&gt;[1]: *** [objs/addon/src/ngx_http_fastdfs_module.o] Error 1
&lt;span class=&quot;kw&quot;&gt;make&lt;/span&gt;[1]: Leaving directory &lt;span class=&quot;kw&quot;&gt;`/usr/local/nginx-1.7.9&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;make: *** [build] Error 2&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;做以下修改&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;vim&lt;/span&gt; /usr/local/fastdfs-nginx-module/src/config&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将、&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;ot&quot;&gt;CORE_INCS=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;$CORE_INCS&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; /usr/local/include/fastdfs /usr/local/include/fastcommon/&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;ot&quot;&gt;CORE_INCS=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;$CORE_INCS&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; /usr/include/fastdfs /usr/local/include/fastcommon/&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实就是改动了fastdfs的路径，没改之前直接访问&lt;code&gt;cd /usr/local/include/fastdfs&lt;/code&gt;为空目录。&lt;/p&gt;
&lt;p&gt;或者设置对应的软连接也可以。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ln&lt;/span&gt; -sv /usr/include/fastcommon /usr/local/include/fastcommon 
&lt;span class=&quot;kw&quot;&gt;ln&lt;/span&gt; -sv /usr/include/fastdfs /usr/local/include/fastdfs 
&lt;span class=&quot;kw&quot;&gt;ln&lt;/span&gt; -sv /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改完成之后在nginx目录，重新configure和make就好了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;./configure&lt;/span&gt; --prefix=/usr/local/nginx --add-module=/usr/local/fastdfs-nginx-module/src
&lt;span class=&quot;kw&quot;&gt;make&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;启动nginx报错&quot;&gt;启动nginx报错&lt;/h3&gt;
&lt;p&gt;在在storage上配置nginx相关信息后启动nginx，查看日志发现报错：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;cat&lt;/span&gt; /usr/local/nginx/logs/error.log
&lt;span class=&quot;kw&quot;&gt;ngx_http_fastdfs_process_init&lt;/span&gt; pid=12770
[&lt;span class=&quot;kw&quot;&gt;2017-10-10&lt;/span&gt; 13:41:44] ERROR - file: ini_file_reader.c, line: 631, include file &lt;span class=&quot;st&quot;&gt;&quot;http.conf&quot;&lt;/span&gt; not exists, line: &lt;span class=&quot;st&quot;&gt;&quot;#include http.conf&quot;&lt;/span&gt;
[&lt;span class=&quot;kw&quot;&gt;2017-10-10&lt;/span&gt; 13:41:44] ERROR - file: /usr/local/fastdfs-nginx-module/src/common.c, line: 155, load conf file &lt;span class=&quot;st&quot;&gt;&quot;/etc/fdfs/mod_fastdfs.conf&quot;&lt;/span&gt; fail, ret code: 2
&lt;span class=&quot;kw&quot;&gt;2017/10/10&lt;/span&gt; 13:41:44 [alert] 12769#0: worker process 12770 exited with fatal code 2 and cannot be respawned&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;复制fastdfs中的http.conf、mime.types文件到/etc/fdfs&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;cp&lt;/span&gt; /usr/local/fastdfs-5.05/conf/http.conf /usr/local/fastdfs-5.05/conf/mime.types  /etc/fdfs&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后重启nginx&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;killall&lt;/span&gt; nginx
&lt;span class=&quot;kw&quot;&gt;/usr/local/nginx/sbin/nginx&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看日志，还报错：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;[&lt;span class=&quot;kw&quot;&gt;root@localhost&lt;/span&gt; logs]# cat /usr/local/nginx/logs/error.log
&lt;span class=&quot;kw&quot;&gt;ngx_http_fastdfs_process_init&lt;/span&gt; pid=12813
[&lt;span class=&quot;kw&quot;&gt;2017-10-10&lt;/span&gt; 14:05:33] ERROR - file: /usr/local/fastdfs-nginx-module/src/common.c, line: 180, config file: /etc/fdfs/mod_fastdfs.conf, you must set url_have_group_name to true to support multi-group!
&lt;span class=&quot;kw&quot;&gt;2017/10/10&lt;/span&gt; 14:05:33 [alert] 12812#0: worker process 12813 exited with fatal code 2 and cannot be respawned&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;vim&lt;/span&gt;  /etc/fdfs/mod_fastdfs.conf&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;ot&quot;&gt;url_have_group_name=&lt;/span&gt;false&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改为&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;ot&quot;&gt;url_have_group_name=&lt;/span&gt;true &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启正常&lt;/p&gt;

&lt;h3 id=&quot;测试图片无法访问&quot;&gt;测试图片无法访问&lt;/h3&gt;
&lt;p&gt;搭建完成之后，访问&lt;code&gt;http://192.168.53.85:8080/group2/M00/00/00/wKg26VncfamAEqZ0AAu-4Kcs3QI677.jpg&lt;/code&gt;&lt;br/&gt;地址图片总是报404无法找到，跟踪到storage服务器，查看nginx的error日志发现如下；&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ERROR&lt;/span&gt; - file: /usr/local/fastdfs-nginx-module/src/common.c, line: 877, stat file: /root/fastdfs/data/00/00/wKg1Wlnchn2AOo0kAAu-4Kcs3QI239.jpg fail, errno: 13, error info: Permission denied&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原因是nginx启动的时候默认会以nobody用户来启动，这样的话就权限访问&lt;code&gt;/root/fastdfs/data&lt;/code&gt;的权限&lt;/p&gt;
&lt;p&gt;修改这个问题有两个版本，第一个方案设置nginx以root身份启动，或者设置nobody用户权限可以访问&lt;code&gt;/root/fastdfs/data&lt;/code&gt;地址。这里只展示第一种方案的修改&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;vim&lt;/span&gt; /usr/local/nginx/conf/nginx.conf
&lt;span class=&quot;co&quot;&gt;# 修改nobody为root&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;user&lt;/span&gt; root&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启nginx后问题解决&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里有一个网友整理的word版本的安装配置文档，包括缓存各方面的内容比较全面，需要的朋友在公众号回复：“fastdfs”&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://my.oschina.net/wangmengjun/blog/1142982&quot;&gt;CentOS上安装分布式文件系统FastDFS &amp;amp; 配置和问题&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Nov 2017 15:35:00 +0000</pubDate>
<dc:creator>纯洁的微笑</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ityouknow/p/7769142.html</dc:identifier>
</item>
<item>
<title>[译]你真的了解外边距折叠吗 - 闲鱼~</title>
<link>http://www.cnblogs.com/Ghunter/p/7766003.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Ghunter/p/7766003.html</guid>
<description>&lt;blockquote readability=&quot;1.6666666666667&quot;&gt;
&lt;p&gt;译自：&lt;a href=&quot;https://www.sitepoint.com/collapsing-margins/&quot; title=&quot;https://www.sitepoint.com/collapsing-margins/&quot;&gt;Collapsing Margins&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;外边距折叠是CSS布局中很小的一个知识点，但是却能够对我们的页面布局产生很大的影响。这篇文章详细介绍了外边距折叠的情况及如何避免，希望能够帮助大家加深理解。水平有限，翻译不当还请指正。&lt;br/&gt;~文章内容略显啰嗦，可以重点关注代码部分~&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;让我们来探究一下外边距折叠的结果是什么，它将怎样影响页面上的元素。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.w3.org/TR/CSS21/box.html#collapsing-margins&quot;&gt;W3C规范&lt;/a&gt;是这样定义外边距折叠的：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;In this specification, the expression collapsing margins means that adjoining margins (no non-empty content, padding, or border areas, or clearance separate them) of two or more boxes (which may be next to one another or nested) combine to form a single margin.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单说，这个定义表明当垂直方向两个元素的外边距（&lt;em&gt;译&lt;/em&gt;：即&lt;code&gt;margin&lt;/code&gt;）相接触时，只有&lt;code&gt;margin&lt;/code&gt;值较大的会被选用，而&lt;code&gt;margin&lt;/code&gt;较小的元素的外边距会被折叠为0。在其中一个元素的&lt;code&gt;margin&lt;/code&gt;为负值的情况下，两元素的外边距是两者求和。如果两个元素的外边距都是负值，那么取较小的负值作为最终外边距（如-3px,-5px,取-5px）。这个定义适用于相邻或嵌套的元素上。&lt;br/&gt;在一些情况下元素的外边距不会折叠：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;浮动元素&lt;/li&gt;
&lt;li&gt;绝对定位元素&lt;/li&gt;
&lt;li&gt;行内块元素&lt;/li&gt;
&lt;li&gt;设置了&lt;code&gt;overflow&lt;/code&gt;不为&lt;code&gt;visible&lt;/code&gt;的元素（不会与其子元素发生外边距折叠）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cleared&lt;/code&gt;元素（上外边距不会与其父块的下外边距折叠。&lt;em&gt;译&lt;/em&gt;：此处不太理解，原文是They do not collapse their top margins with their parent block’s bottom margin.）&lt;/li&gt;
&lt;li&gt;根元素&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这是一个很难理解的概念，让我们来看一些例子。&lt;/p&gt;
&lt;h2 id=&quot;相邻元素间的外边界折叠&quot;&gt;相邻元素间的外边界折叠&lt;/h2&gt;
&lt;p&gt;相邻元素的外边距折叠。简言之，就是文档流（&lt;em&gt;译&lt;/em&gt;：normal document flow，国内常译为文档流）中垂直方向相邻的块级元素，只有&lt;code&gt;margin&lt;/code&gt;值最大的元素的外边距会被采用，而&lt;code&gt;margin&lt;/code&gt;较小的元素的外边距会被折叠为0。例如，如果一个元素的&lt;code&gt;margin-bottom&lt;/code&gt;为&lt;code&gt;25px&lt;/code&gt;，在其下方相邻的元素的&lt;code&gt;margin-top&lt;/code&gt;为&lt;code&gt;20px&lt;/code&gt;，那么只有&lt;code&gt;25px&lt;/code&gt;的下外边距会被应用，即两元素间的距离为&lt;code&gt;25px&lt;/code&gt;，而不是&lt;code&gt;45px&lt;/code&gt;（25+20）。&lt;br/&gt;这个行为最好通过一个简短的例子说明，请看下面的代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;h1 &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;  
  &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;25px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#cfc&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
p &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;20px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#cf9&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/Ghunter/1107122/o_1398314844css-box-model_collapsing-margins.png&quot; alt=&quot;相邻元素间的外边距折叠&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图1所示，两个元素间的间隙只有&lt;code&gt;25px&lt;/code&gt;，较小的外边距被折叠为0。如果上述例子中元素的外边距相等（如，都是20像素），那么两元素间的距离就只是&lt;code&gt;20px&lt;/code&gt;。&lt;br/&gt;有一种情况下会发生轻微的偏差：如果其中一个元素的上或下外边距为负数，那么最终的元素间距为正数与负数的和。下面这个示例展示了这一点：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;h1 &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;25px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#cfc&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
p &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;-20px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#cf9&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;h1&lt;/code&gt;元素的下外边距是一个正数（&lt;code&gt;25px&lt;/code&gt;），&lt;code&gt;p&lt;/code&gt;元素的上外边距是一个负数（&lt;code&gt;-20px&lt;/code&gt;），在这种情况下，这两个值将进行求和计算得到最终的间距：&lt;code&gt;25px&lt;/code&gt; + (&lt;code&gt;-20px&lt;/code&gt;) = &lt;code&gt;5px&lt;/code&gt;。&lt;br/&gt;如果计算的结果是一个负数，将会导致一个元素覆盖另外一个元素。你可能会说负的外边距使元素在相反的方向上生成正的外边距，关于负的外边距的更多信息请查阅外边距。（&lt;em&gt;译&lt;/em&gt;：这句话翻译起来实在别扭，自行理解吧，也欢迎你在评论里给出自己的见解）&lt;/p&gt;
&lt;h2 id=&quot;父子元素间的外边距折叠&quot;&gt;父子元素间的外边距折叠&lt;/h2&gt;
&lt;p&gt;目前为止，我们只讨论了相邻元素间的外边距折叠，但同样的情况适用于外边界接触的父子元素间。这里的接触是指在相邻的&lt;code&gt;margin&lt;/code&gt;之间没有&lt;code&gt;padding&lt;/code&gt;，&lt;code&gt;border&lt;/code&gt;和&lt;code&gt;content&lt;/code&gt;。在下面的例子中，一个父元素包含了一个被设置了上外边距的子元素：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;h1 &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#cff&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
div &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;40px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;25px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#cfc&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
p &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;20px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#cf9&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上边的样式表中，为&lt;code&gt;p&lt;/code&gt;元素声明了一个上外边距，在下边的代码中可以看到&lt;code&gt;p&lt;/code&gt;元素是&lt;code&gt;div&lt;/code&gt;元素的子元素。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Heading Content&lt;span class=&quot;kw&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;Paragraph content&lt;span class=&quot;kw&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图2中可以看到这段代码的结果：&lt;br/&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/Ghunter/1107122/t_1398314904css-box-model_collapsing-margins2.png&quot; alt=&quot;父子元素间的外边距折叠&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你可能会认为&lt;code&gt;p&lt;/code&gt;元素和&lt;code&gt;h1&lt;/code&gt;元素的间距为&lt;code&gt;60px&lt;/code&gt;，因为&lt;code&gt;div&lt;/code&gt;元素的&lt;code&gt;margin-top&lt;/code&gt;是&lt;code&gt;40px&lt;/code&gt;，并且&lt;code&gt;p&lt;/code&gt;元素的&lt;code&gt;margin-top&lt;/code&gt;为&lt;code&gt;20px&lt;/code&gt;。你或许也会认为在&lt;code&gt;p&lt;/code&gt;元素的上方会有&lt;code&gt;20px&lt;/code&gt;的范围展示&lt;code&gt;div&lt;/code&gt;元素的背景色。但是如图所示，并非如此，因为发生了外边距折叠，导致只有最大的外边距被应用（和相邻块一样）。&lt;br/&gt;事实上如果&lt;code&gt;div&lt;/code&gt;元素没有上外边距（&lt;em&gt;译&lt;/em&gt;：即&lt;code&gt;margin-top&lt;/code&gt;为0）并且&lt;code&gt;p&lt;/code&gt;元素的&lt;code&gt;margin-top&lt;/code&gt;为&lt;code&gt;40px&lt;/code&gt;我们会得到相同的结果。&lt;code&gt;p&lt;/code&gt;元素的&lt;code&gt;40px&lt;/code&gt;上外边距转化成&lt;code&gt;div&lt;/code&gt;元素的上外边距，将&lt;code&gt;div&lt;/code&gt;元素下移&lt;code&gt;40px&lt;/code&gt;，并使&lt;code&gt;p&lt;/code&gt;元素紧贴&lt;code&gt;div&lt;/code&gt;顶部。在&lt;code&gt;div&lt;/code&gt;元素内&lt;code&gt;p&lt;/code&gt;元素的上方不会有背景色展示。&lt;br/&gt;为了使两个元素的外边距都展示，并且使&lt;code&gt;div&lt;/code&gt;的背景色展示在&lt;code&gt;p&lt;/code&gt;元素的上方，这里需要设置一个&lt;code&gt;border&lt;/code&gt;或者&lt;code&gt;padding&lt;/code&gt;去阻止外边距折叠。我们简单的为&lt;code&gt;div&lt;/code&gt;元素添加一个上边框，就可以得到最初期待的效果：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;h1 &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#cff&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
div &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;40px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;25px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#cfc&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;border-top:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#000&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
p &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;20px&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#cf9&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在图3中，我们可以看到&lt;code&gt;div&lt;/code&gt;元素与&lt;code&gt;h1&lt;/code&gt;元素的距离依旧是&lt;code&gt;40px&lt;/code&gt;，但是&lt;code&gt;p&lt;/code&gt;元素被下移了&lt;code&gt;20px&lt;/code&gt;的距离，因此显示了&lt;code&gt;20px&lt;/code&gt;范围的&lt;code&gt;div&lt;/code&gt;背景色（通过设置外边框）。&lt;br/&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/Ghunter/1107122/t_1398314949css-box-model_collapsing-margins3.png&quot; alt=&quot;设置border消除外边界折叠&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们不希望在设计上展示可见的上边框，&lt;code&gt;1px&lt;/code&gt;的上内边距会产生同样的效果。记住&lt;code&gt;border&lt;/code&gt;和&lt;code&gt;padding&lt;/code&gt;应该应用在父&lt;code&gt;div&lt;/code&gt;上，在&lt;code&gt;p&lt;/code&gt;元素上不会阻止外边距折叠，因为&lt;code&gt;p&lt;/code&gt;元素的&lt;code&gt;margin&lt;/code&gt;在&lt;code&gt;border&lt;/code&gt;的外面。&lt;br/&gt;上述示例只讨论了单个父元素和单个子元素外边距接触的情况，同样的处理方式也适用于多重子孙元素（即，嵌套的元素。&lt;em&gt;译&lt;/em&gt;：原文是several children，字面意思是多个子元素，但实际指多重嵌套的子孙元素）均含有垂直相邻外边距的情况：即所有的外边距会折叠为一个单独的外边距。虽然上面的示例只提到了上外边距，但同样的效果作用于下外边距，下文会看到。&lt;br/&gt;在下面的示例中，我们嵌套了四层&lt;code&gt;div&lt;/code&gt;元素，每一个都设置了&lt;code&gt;10px&lt;/code&gt;的外边距。每个&lt;code&gt;div&lt;/code&gt;都设置了不同的背景色，所以我们可以清楚的看到外边距折叠的效果：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.box&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;10px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.a&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#777&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.b&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#999&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.c&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#bbb&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.d&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#ddd&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fl&quot;&gt;.e&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;background:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;#fff&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图4展示了上述 CSS 的结果。&lt;br/&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/Ghunter/1107122/t_1398314988css-box-model_collapsing-margins4.png&quot; alt=&quot;多层嵌套外边距折叠&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正如这个例子所示，这段CSS的效果是引人注目的：所有的垂直方向外边距折叠为一个单独的，&lt;code&gt;10px&lt;/code&gt;的外边距。不同于水平方向所示的每个外边距都可见，虽然我们为每个元素设置了不同的背景色，但垂直方向并没有展示类似的颜色。整个块将会被放置在距文档流中其他元素&lt;code&gt;10px&lt;/code&gt;的位置上，所有嵌套的块的外边距将会折叠成一个。&lt;br/&gt;如上所述，阻止外边界折叠最简单的方法是为每个元素添加内边距或边框。如果我们希望每个元素间的外边距是&lt;code&gt;10px&lt;/code&gt;，可以通过简单的设置一个&lt;code&gt;9px&lt;/code&gt;的&lt;code&gt;margin&lt;/code&gt;和&lt;code&gt;1px&lt;/code&gt;的&lt;code&gt;padding&lt;/code&gt;来实现：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode css&quot;&gt;
&lt;code class=&quot;sourceCode css&quot;&gt;&lt;span class=&quot;fl&quot;&gt;.box&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;margin:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;9px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;padding:&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;1px&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;微小的改动会阻止垂直方向上的外边距折叠，效果图5所示。&lt;br/&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/Ghunter/1107122/t_1398315046css-box-model_collapsing-margins5.png&quot; alt=&quot;阻止外边距折叠&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，考虑IE的兼容性是很重要的。第一个例子（图4）中的元素在IE中会直接展示位图5的效果。另外值得一提的是在IE之外的其他浏览器中，设置&lt;code&gt;overflow&lt;/code&gt;为不等于&lt;code&gt;visible&lt;/code&gt;的其他值时会产生同样的效果。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;尽管外边距折叠给人的第一印象不够直观，但它确实使得多层元素嵌套的情况更加简单，也更令人满意。如果有需要你也可以使用上述简单方式阻止外边距折叠。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;那么，现在你真的读懂外边距折叠了吗？不如我们来做个小小的测试吧。对A,B,C三个块级元素分别设置&lt;code&gt;margin&lt;/code&gt;如下图所示，请问：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把B和C同时放到A中，BC间距是多少？&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;基于问题1，把B的&lt;code&gt;margin&lt;/code&gt;改为&lt;code&gt;-30px&lt;/code&gt;呢？&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;基于问题1，把BC的&lt;code&gt;margin&lt;/code&gt;均取负数呢？&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;把B放入A内，C放入B内时，ABC的位置是怎样的？&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;基于问题4，B的&lt;code&gt;margin&lt;/code&gt;为&lt;code&gt;-30px&lt;/code&gt;呢？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://images.cnblogs.com/cnblogs_com/Ghunter/1107122/o_QQ%E6%88%AA%E5%9B%BE20171101224413.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实践出真知，不确定答案的同学还是亲自动手试试吧:)&lt;/p&gt;
</description>
<pubDate>Wed, 01 Nov 2017 15:09:00 +0000</pubDate>
<dc:creator>闲鱼~</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Ghunter/p/7766003.html</dc:identifier>
</item>
<item>
<title>平台框架-101 - kid551</title>
<link>http://www.cnblogs.com/kid551/p/7768720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kid551/p/7768720.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/672506/201711/672506-20171101215043529-31373015.jpg&quot; alt=&quot;&quot; width=&quot;859&quot; height=&quot;644&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原文首发于我的微信公众号：GeekArtT .&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将源代码编译，加载进入内存，相应的构建于程序员脑海中的程序便在计算机上跑(run)起来了。这看似简单的步骤背后，却是一个从无到有的施展魔法的过程。&lt;/p&gt;
&lt;p&gt;初学programming的时候，不太能够分清楚手写的源代码和在内存中运行的机器代码（运行时代码）的区别。一直被教育，机器代码是通过源代码的编译生成的。机器代码所做的事情，会完全依赖于源代码所表达的意图。或者可以被通俗地理解为：因为源代码是人可以识别的语言，机器代码是机器可以识别的语言，而编译，便是将两者做了一个翻译而建立起来的桥梁。&lt;/p&gt;
&lt;p&gt;如此，在我脑海中建立起来的两者关系便是，这两者就是完全等价的一回事。你想要机器做什么，那么只要在源代码里体现就好了。这一说法的直接推论便是：&lt;strong&gt;如果我在运行的程序中发现缺少了什么功能，那么直接在源代码里增加修改就好了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而这其实是一句表面上政治正确，却在细节上会造成完全不同理解的模糊说法。而如果你恰好在细节上将差别弄错，那么你对整个程序编写的认识、对软件工程存在的意义以及API框架设计的好坏标准，将会形成完全错误的理解（事实上，曾经的我，正是在这些方面陷入过深坑）。&lt;/p&gt;
&lt;p&gt;编译前的源代码和运行起来的机器代码，表面上是一个一一对应的关系，但实际上已经是两个不同的时空世界。虽然运行起来的代码是&lt;strong&gt;完全根据&lt;/strong&gt;源代码指定的规则和意图来做事情。可一旦机器代码运行起来，源代码将对运行时的代码毫无办法，产生不了一点影响。你&lt;strong&gt;不能够&lt;/strong&gt;通过&lt;strong&gt;临时增加一些源代码&lt;/strong&gt;的方式，来为运行时的程序增添一些功能或者feature。你只能老老实实地利用好当前运行着的程序为你提供的现成功能。&lt;/p&gt;
&lt;p&gt;这里的trick是，运行时的代码已经不是代码了，它已经是运转起来的机器，或者说机器状态。而源代码提供的是让计算机如何运行的步骤指令，你可以把它理解为一份分步骤操作的菜谱。而处在运行时的程序，它已经是一套按照源代码的指令转动起来的机器。在这个程序中，它有且只能做之前源代码规定好的事情。如果要想让计算机产生别的行为，那就不得不让计算机停止当前的运转，然后重新塞给它一份执行步骤的说明书，然后重新开始运转。&lt;/p&gt;
&lt;p&gt;所以，通过修改源代码，你确实可以为程序增加新的功能，但你不得不把当前的程序停止掉，然后重新构建计算机运行的状态。&lt;/p&gt;
&lt;p&gt;如果用相对粗糙的比喻可以理解为：如果把程序员看作是能够施展法术，让微观的&lt;strong&gt;原子&lt;/strong&gt;形成现实宏观世界的&lt;strong&gt;物体&lt;/strong&gt;的魔法师（请脑补SICP的封面图案），那么这些原子便是源代码，而运行时的机器代码便是相应物理世界的物体。一旦物体形成，你便只有使用物体的能力，却没有再次更改物体性质的能力。也就是，你没有办法通过操作原子的排列方式，将手中的一把大刀，变成一杆长枪。&lt;/p&gt;
&lt;p&gt;从这个角度讲，编译前的源代码和运行时的代码，是处在两个不同时空的存在。一旦机器运行起来，你便&lt;strong&gt;只能够&lt;/strong&gt;使用当前运行着的程序所提供的功能去做动态操作（也就是对运行的计算机做操作），你不能够通过增添源代码的方式为当前的程序制作新的功能。&lt;/p&gt;
&lt;p&gt;于是，程序在运行状态时所提供的这些功能，便是一切的关键。因为它们是构成你将来一切操作的原始操作（元操作）。这便是程序所提供的API了。&lt;/p&gt;
&lt;p&gt;一套程序提供API的意义，并不是它能够以多么不同的方式对计算机做影响，而是它能够对它所形成的“它的世界”做多少影响。举个例子，一款游戏程序的计算方式、调用CPU的方式、让显示器呈现图像的方式并不会有多么的独特和不同。关键在于游戏里提供的操作方式（可理解为终端用户的API），是你唯一可以运用的、拿去攻击boss并对boss产生影响的方式。你无法通过计算机上一般性的“减法操作”，来减少boss的血槽值。&lt;/p&gt;
&lt;p&gt;既然对你建造的这个MyApp的程序世界的所有影响，都要由这些基础的API来构成。那么如何设计这些API，让它们足够少、却又能够提供足够多的组合方式，去满足你对MyApp世界的各种需求，就成为了关键。&lt;/p&gt;
&lt;p&gt;一个极好的API设计案例，当然是数学领域的几何学。通过《几何原本》上描绘的几条基本定理，便将欧式几何世界的性质、操作和需求全部囊括。而仅仅是改变第五公设的论述，又形成了另一套几何世界——非欧几何。并且也是这么几条基本公理（API），便将非欧几何的需求、操作全部囊括。&lt;/p&gt;
&lt;p&gt;从这个角度来讲，某一个程序的一组精挑细选的API，便可以看作是数学领域中一个分支的公理假设集。而每一套这样的API，便构成了一个独有的世界。所以，这套精简的API便是支撑整个你创造的世界的&lt;strong&gt;骨架&lt;/strong&gt;，也就是通常所说的&lt;strong&gt;框架&lt;/strong&gt;了。而这套框架，事实上形成了一组构建世界的工具箱，或者是工作坊，也可以叫做工作平台（platform）。因为在这个平台上，你可以建造、加工你所处的MyApp世界。那它当然是最核心也最富有潜力、想象的基建设施平台了。&lt;/p&gt;
&lt;p&gt;那么，一套程序（产品）是否具备平台意识，其实决定了它未来的想象。例如，如果你的程序只能够做规定它做的事情，没有任何开放给开发者的API，那它就只是个固定的东西，而不是一套可以完善、成长的生态系统。例如，一款俄罗斯方块游戏，你能做的，便是按照规则去玩，不能够再添加别的新鲜想法。而反观Apple 处理自己App的方式，它不是说给你一个固定不变的App，而是给你提供一套可以建造App的工具/平台/框架，让你可以按照自己的想法去做各种不同的App，去构建你脑海中不同的世界。又或是Facebook这款社交软件，它并没有选择成为一款静态的产品，而是提供足够多的API，让作为开发者的你去完善它，去为Facebook的成长贡献一份力量。&lt;/p&gt;
&lt;p&gt;所以，对于一个特定程序之外的开发者来说，ta并不是万能的 。而这个特定程序的构建者，才是那个上帝。如果这款程序的构建者，不提供对外开放的API，那么外来者便没有办法去对这个特定的程序世界做修改。另一方面，如果一款产品不提供对外的API，也就是不具备平台思维，那么它也将失去世界上其他程序员为它带来的生长养分。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;近期回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484021&amp;amp;idx=1&amp;amp;sn=61327099a99e1a0ffa2361bc9a25e723&amp;amp;chksm=ec20e5c9db576cdf4b4c06b50dd52de580cdf79bde5389e66af1a3334a7b37d4fe0554565cd0&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;新入手MacBook Pro环境搭建&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484008&amp;amp;idx=1&amp;amp;sn=8d1e6de98b5ac438a8923283ead216c4&amp;amp;chksm=ec20e5d4db576cc2a4366966dc105d7ec237e98538ea6fee6c9b7cc688e3bf6884ac619b6fa7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;做一名「技术掮客」去变现自己的技术&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247483998&amp;amp;idx=1&amp;amp;sn=acb416bb9f336d7cea1e66c7ba86d260&amp;amp;chksm=ec20e5e2db576cf4ddf72e51c295e562a1a0d62389c1ce157a60d093828fb32255a58a80cc0b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;「极客时间」带来的社区价值思考&lt;/a&gt;》&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果你喜欢我的文章或分享，请长按下面的二维码关注我的微信公众号，谢谢！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxPlOTGK4uYCNPSK7ADI9xNIfB1ic7Cpmen9fZvzt1ZoBdoiapSQV0fHAHvahBiaO6R2k0OH1Jyx2bHuA/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; width=&quot;auto&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxPlOTGK4uYCNPSK7ADI9xNIfB1ic7Cpmen9fZvzt1ZoBdoiapSQV0fHAHvahBiaO6R2k0OH1Jyx2bHuA/0?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VIP赞赏专区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxPlOTGK4uYCNPSK7ADI9xNI0nibuKnVBZ8XYPvYggVcaRMJuRwiaiaR1ZAhTcYic1gia9ibgJywZG2NxrJg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; width=&quot;252&quot; height=&quot;252&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxPlOTGK4uYCNPSK7ADI9xNI0nibuKnVBZ8XYPvYggVcaRMJuRwiaiaR1ZAhTcYic1gia9ibgJywZG2NxrJg/0?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1152&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Nov 2017 13:52:00 +0000</pubDate>
<dc:creator>kid551</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kid551/p/7768720.html</dc:identifier>
</item>
<item>
<title>话说LightningChart是最快最美的图表控件，到底先进在哪里？ - LightningChart</title>
<link>http://www.cnblogs.com/lightningchart/p/7768617.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lightningchart/p/7768617.html</guid>
<description>&lt;p&gt;LightningChart Ultimate v.8.2 最新版本新特征告诉你它先进在哪里！&lt;/p&gt;

&lt;p&gt;1. Headless 模式&lt;/p&gt;
&lt;p&gt;headless模式允许在没有GUI的情况下使用LC。例如，在Windows Service和控制台应用程序中。以下示例是为报告或网页生成的图表。 &lt;/p&gt;
&lt;p&gt;在headless模式下，图表框被捕获为图像。可以通过利用以下方法来获取位图，例如 &lt;/p&gt;
&lt;p&gt;• OutputStream 属性&lt;/p&gt;
&lt;p&gt;• SaveToStream 方法&lt;/p&gt;
&lt;p&gt;• CopyToClipboard 方法&lt;/p&gt;
&lt;p&gt;• CaptureToByArray 方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1124004/201711/1124004-20171101212418248-240862411.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该服务可以设置为在本地网络服务器运行或在云端的Windows Server运行。 &lt;/p&gt;
&lt;p&gt;在Windows Application和Windows Service之间的进程间通信中，例如，可以使用Named管道或Socket I / O通信。&lt;/p&gt;
&lt;p&gt;SDK中包含一个新的Headless模式演示解决方案。它在本地计算机上使用Windows服务器。WPF应用程序使用Named Pipes连接到它，并显示服务器发送的图像流。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1124004/201711/1124004-20171101212713076-59816817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1124004/201711/1124004-20171101212722810-839902624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解释了带有命名管道和后台线程的 Headless演示解决方案的内部操作消。 &lt;/p&gt;


&lt;p&gt;2. ViewXY BarSeries中的BaseLevel&lt;/p&gt;
&lt;p&gt;BarSeries中添加的BaseLevel属性是所有系列值的一个系列最小值，并指示条的起始位置。在堆叠视图中，它将增加（如果为正）或减小（如果为负）条的大小。如果是StackedToSum，则条尺寸是相对的，并且像Stacked一样计算。&lt;/p&gt;
&lt;p&gt;BaseLevel设置为100。条值为10,20,35,50,65,45,30,25,20,5。&lt;/p&gt;
&lt;p&gt;在之前的LightningChart版本中，像BaseLevel一样的条形图设置为0。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1124004/201711/1124004-20171101212755076-1749013849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;BaseLevel设置为100。条值为10,20,35,50,65,45,30,25,20,5。&lt;/p&gt;
&lt;p&gt;在之前的LightningChart版本中，像BaseLevel一样的条形图设置为0。 &lt;/p&gt;


&lt;p&gt;3. MeshModel程序化构建&lt;/p&gt;
&lt;p&gt;MeshModel支持以编程方式构建MeshModel几何。它允许可视化由于计算而产生的对象和形状。&lt;/p&gt;
&lt;p&gt;以下创建方法可用 &lt;/p&gt;
&lt;p&gt;•创建（位置、颜色、索引）&lt;/p&gt;
&lt;p&gt;•创建（位置、颜色、法线、索引）&lt;/p&gt;
&lt;p&gt;•创建（位置、纹理坐标、位图、textureWrapMode、索引）&lt;/p&gt;
&lt;p&gt;•创建（位置、法线、纹理坐标、位图、textureWrapMode、索引） &lt;/p&gt;
&lt;p&gt;索引数组（索引）参数对于所有方法都是可选的。如果提供它们将定义从给定的阵列使用哪些顶点、颜色、光线法线和纹理坐标。当多个三角形之间共享相同的顶点时，使用索引会节省资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1124004/201711/1124004-20171101212844357-312835581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由代码构造的MeshModels。 &lt;/p&gt;
&lt;p&gt;旋转、缩放和定位属性等以及事件也适用于从顶点以编程方式创建的MeshModel，它们的工作方式类似于从顶点以编程方式加载，与处理加载对象方式相同。&lt;/p&gt;


&lt;p&gt;4. 3D中单维缩放&lt;/p&gt;
&lt;p&gt;只能使用鼠标拖动来缩放一个维度。&lt;/p&gt;
&lt;p&gt;ZoomPanOptions下添加了用于控制单维缩放的新选项。&lt;/p&gt;
&lt;p&gt;LeftMouseButtonAction，RightMouseButtonAction和MiddleMouseButtonAction属性现在有ZoomX，ZoomY和ZoomZ的新选项。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1124004/201711/1124004-20171101212939732-537607756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;5. ViewXY中的图例框，对齐&lt;/p&gt;
&lt;p&gt;AlignmentInVerticalMargin属性添加了左/右/中心选项，到ViewXY的LegendBox。该属性控制图例框的水平定位设置为相同的垂直边距。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1124004/201711/1124004-20171101213037701-981382862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AlignmentInVerticalMargin控制水平定位&lt;/p&gt;


&lt;p&gt;6.控制图例框中的“强度”和“表面”系列调色板的可视性。&lt;/p&gt;
&lt;p&gt;通过设置LegendBox.IntensityScales.Visible可以隐藏调色板比例为“False”（in ViewXY）和LegendBox.SurfaceScales.Visible为“False”（在View3D中）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1124004/201711/1124004-20171101213100310-150089026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Nov 2017 13:35:00 +0000</pubDate>
<dc:creator>LightningChart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lightningchart/p/7768617.html</dc:identifier>
</item>
<item>
<title>数据库的使用你可能忽略了这些 - IT米粉</title>
<link>http://www.cnblogs.com/joylee/p/7768457.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/joylee/p/7768457.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;数据库的管理是一个非常专业的事情，对数据库的调优、监控一般是由数据库工程师完成，但是开发人员也经常与数据库打交道，即使是简单的增删改查也是有很多窍门，这里，一起来聊聊数据库中很容易忽略的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;字段长度省着点用&quot;&gt;字段长度省着点用&lt;/h2&gt;
&lt;p&gt;先说说我们常用的类型的存储长度：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;tinyint&lt;/td&gt;
&lt;td&gt;1字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;smallint&lt;/td&gt;
&lt;td&gt;2字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;4字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;bigint&lt;/td&gt;
&lt;td&gt;8字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;4字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;decimal(m,d)&lt;/td&gt;
&lt;td&gt;0-4字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;8字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;timestamp&lt;/td&gt;
&lt;td&gt;4字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;char(m)&lt;/td&gt;
&lt;td&gt;m个字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;varchar(m)&lt;/td&gt;
&lt;td&gt;可变长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;可变长度&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;很明显，不同的类型存储的长度有很大区别的，对查询的效率有影响，字段长度对索引的影响是很大的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字符串字段长度都差不多的，可以预估长度的，用char&lt;/li&gt;
&lt;li&gt;字符串长度差异大，用varchar,限制长度，不要浪费空间&lt;/li&gt;
&lt;li&gt;整型根据大小，选择合适的类型&lt;/li&gt;
&lt;li&gt;时间建议用timestamp&lt;/li&gt;
&lt;li&gt;建议使用decimal，不建议使用float,如果是价格，可以考虑用int或bigint，如1元，存储的就是100&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;放弃uuidguid的使用&quot;&gt;放弃uuid(guid)的使用&lt;/h2&gt;
&lt;p&gt;不管是uuid，还是guid，使用的时候都是为了避免同时生成重复的ID，但是建议考虑其他方案，原因如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;uuid没有顺序&lt;/li&gt;
&lt;li&gt;uuid太长&lt;/li&gt;
&lt;li&gt;uuid规则完全不可控&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;推荐的方案用bigint（首选），或者char来存储，生成方式参考snowflake的算法，有顺序、长度固定、比uuid更短，当然，也几乎不会重复。&lt;/p&gt;
&lt;h2 id=&quot;大表减少联表最好是单表查询&quot;&gt;大表减少联表，最好是单表查询&lt;/h2&gt;
&lt;p&gt;单表查询的优势很多，查询效率极高，便于分表分库扩展，但是很多时候大家都觉得真正实现起来不太现实，完全失去了关系数据库的意义，但是单表的性能优势太明显，一般总会有办法解决的:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;合理的冗余字段&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;配合内存数据库（redis\mongodb）使用&lt;/li&gt;
&lt;li&gt;联表变多次查询（下文会有说明）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果考虑都后期数据量大，需要分表分库，就应该尽早实时单表查询，现在的数据库分表分库的中间件基本都无法支持联表查询。即使如mycat最多支持两个表的联表查询，但是也有很明显的性能损耗。&lt;/p&gt;
&lt;h2 id=&quot;索引的正确处理方式&quot;&gt;索引的正确处理方式&lt;/h2&gt;
&lt;p&gt;索引的优势这里就不多说了，索引使用不当会有反效果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据量很小的表，不需要索引&lt;/li&gt;
&lt;li&gt;一个表的索引不宜过多，建议最多就5个，索引不可能满足所有的场景，但是了个满足绝大部分的场景&lt;/li&gt;
&lt;li&gt;mysql 和 sqlserver的索引差别还挺大的，需要注意。例如：&lt;br/&gt;mysql索引字段的顺序对性能有很大影响，sqlserver优化过，影响很小&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;多查几次比联表可能要好&quot;&gt;多查几次比联表可能要好&lt;/h2&gt;
&lt;p&gt;提出这个方案相信会得到很多人的反对，但是我相信这个结论还是非常适合数据量大的场景。多查几次数据库有这么几个弊端：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;增加了网络消耗&lt;/li&gt;
&lt;li&gt;增加了数据库的连接数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实，这两个问题在现在基本都可以忽略的，数据库和应用的连接基本都是内网，这个网络连接的效率还是很高的。数据库对连接池的优化已经比较成熟了，连接数只要不是太多，影响也不会太严重，但是多查几次的优势却很多：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单表效率更高&lt;/li&gt;
&lt;li&gt;便于后期扩展分表分库库&lt;/li&gt;
&lt;li&gt;有效利用数据库本身的结果缓存&lt;/li&gt;
&lt;li&gt;减少锁表，联表会锁多个表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，多查几次这个度一定要把握。千万不要在一个循环里面查询数据库。我们也应该尽量减少查询数据库的次数。我们可以接受1次查询变2次查询，如果你变成10次查询，那就要放弃了。&lt;br/&gt;举个例子：&lt;br/&gt;查询商品的时候，需要显示分类表的分类名&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; category.name,product.name &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; product  &lt;span class=&quot;kw&quot;&gt;inner&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;join&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;category&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;on&lt;/span&gt; p.categoryid=category.id&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建议的方式：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; categoryid,name  &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; product 
&lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; categoryname &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;category&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; categoryid &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; (&lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，你可以再优化一下，查询分类名之前，对product的categoryid排序一下，这样速度更快。因为我们前面已经用snowflake生成了有顺序的主键了。&lt;br/&gt;补充一下，in的效率并不是你想象的那么慢，如果保持在100个节点（很多书籍介绍1000个节点，我们保守一点），性能还是很高的。&lt;/p&gt;
&lt;h2 id=&quot;尽量使用简单的数据库脚本&quot;&gt;尽量使用简单的数据库脚本&lt;/h2&gt;
&lt;p&gt;很多用过 .net Entity Framework 的人都说这个框架太慢，其实慢主要是两点：错误的使用延迟加载（外键关联）、生成SQL编译太慢。Entity Framework生成的SQL脚本有太多没用的东西，导致编译太慢。&lt;br/&gt;数据库脚本尽量使用简单的，不要用太长的一个SQL脚本，会导致初次执行的时候，编译SQL脚本花费太多的时间。&lt;/p&gt;
&lt;h2 id=&quot;尽量去避免聚合操作&quot;&gt;尽量去避免聚合操作&lt;/h2&gt;
&lt;p&gt;聚合操作如count,group等，是数据库性能的大杀手，经常会出现大面积的表扫描和索表的情况，所以大家能看到很多平台都把数量的计算给隐藏了，商品查询不去实时显示count的结果。如淘宝，就不显示查询结果的数量，只是显示前100页。&lt;br/&gt;避免聚合操作的方法就是将实时的count计算结果用字段去存储，去累加这个结果。当然，也可以考虑用spark等实时计算框架去处理，这种高深的技术，不在此次讨论范围内。（PS:主要是我也不懂）&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;程序的优化很多时候都是一些细节的问题，更应该注意平时的积累，阿里SQL的规范有很多可以吸取的地方，以上也是自己工作中的一些总结，欢迎大家补充。&lt;br/&gt;（完）&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎大家关注我的公众号交流、学习、第一时间获取最新的文章。&lt;br/&gt;微信号：itmifen&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fjqwqm6v25j30760760t7.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 01 Nov 2017 13:03:00 +0000</pubDate>
<dc:creator>IT米粉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/joylee/p/7768457.html</dc:identifier>
</item>
<item>
<title>「编程之外」青春是如此美好，又怎忍平凡度过 - OkayChen</title>
<link>http://www.cnblogs.com/okaychen/p/7765852.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/okaychen/p/7765852.html</guid>
<description>&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201711/1140602-20171101130631545-1261006104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;span&gt;读了博友吕大豹前辈的博文&lt;a href=&quot;http://www.cnblogs.com/lvdabao/p/5273249.html&quot; target=&quot;_blank&quot;&gt;《假如大学可以重来》&lt;/a&gt;，我决定走心写下这篇文章：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不像考卷一样所有的问题都能得到一个答案，真正的人生有些事情永远没有答案，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　青春是如此美好，我们又怎忍心平凡度过.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;~~已经大二了，我总是相信，做喜欢的事，总是值得的和最快乐的，虽然不善言谈，但是我发现已经把&lt;span&gt;&lt;strong&gt;编程&lt;/strong&gt;&lt;/span&gt;和&lt;span&gt;&lt;strong&gt;写文章&lt;/strong&gt;&lt;/span&gt;当做自己的一种生活常态或是一种习惯，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在同学看来每天如此或许很累很空虚吧，但是他们不知道其实&lt;span&gt;&lt;strong&gt;&lt;span&gt;我的内心是有多么的充实和快乐&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;~~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我相信我们的坚持总是有收获：&lt;span&gt;&lt;span&gt;上个月&lt;/span&gt;爱范儿&lt;span&gt;的一个编辑作者联系我&lt;/span&gt;，&lt;span&gt;邀请我加入了他们的&lt;span&gt;vip群&lt;/span&gt;，就这样我的文章发表在了&lt;span&gt;&lt;span&gt;知名媒体&lt;/span&gt;爱范儿 和 爱范儿知晓程序&lt;/span&gt; 等相关平台&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201711/1140602-20171101130356216-1978858794.png&quot; alt=&quot;&quot; width=&quot;1025&quot; height=&quot;228&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;   对于一个大学生小作者来说，最大的快乐就是读者和媒体的欣赏，这无疑给了我莫大的动力~ 谢谢你&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201711/1140602-20171101183721435-1938345742.png&quot; alt=&quot;&quot; width=&quot;626&quot; height=&quot;354&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;span&gt;高中的时候我们不清楚自己想要什么，模糊的说我们知道我们是为了一所'大学'，或者说为了'明天'， 为了奔一个好的'前途'。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　直到幸福悄然来到，我们来到大学，觉得从小灌输的'到了大学就轻松了'的观念，脱离了家长和老师的包围圈，恨不得玩到天昏地暗。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　有同学跟我说：'你大一的时候好安静~'，其实不然，我只是换一种方式发出自己的声音，我是一个疯狂的人，看似安静的背后，是滚烫的热血。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以说我并不是一个优等生，但是我一旦为一件事情痴迷，就愿意疯狂为之付出，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　记得小时候父亲在广州安置的还不错，家境条件不算差，我的玩具是伙伴中最多的，小时候喜欢用很多很多的玩具摆出两军对峙的情形，然后用自己的想象力去描绘他们的战争，总是偏心的，最喜欢的玩具总是胜利的一方；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接触电脑也比较早，初中就开始接触电脑，但是我却是以一种错误的方式开始使用它，那一段的疯狂岁月我不会忘记，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　直到那一晚我爸妈让我幡然醒悟，结束了我那一段荒诞又不舍的青春和叛逆年华，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我感谢那一段错误的青春，让现在的我不怕挫折和艰苦，以一种坚定的姿态行走，因为我们已经走错过，不要让爱你的人寒了心；&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;　　记得刚步入大学校园，在琳琅满目的大学生社团中，我基于自己的优势，会&lt;span&gt;&lt;strong&gt;&lt;span&gt;画画&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;和&lt;span&gt;&lt;strong&gt;&lt;span&gt;Dreamweaver&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;，选择了大学生网络工作室设计组，好像这一切貌似都是注定，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我那时候不知道Dreamweaver是前端开发的一个工具，但是因为接触较早我却已经熟练的使用它，它也是我的前端启蒙软件，就这样我顺顺利利的进入了工作室，从ps到前端，开始了我的前端之路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　记不清从什么时候开始，自己喜欢上买书和读书，在当当买书经常有活动，每次总是拿出自己做外包的钱毫不吝啬，它们是属于我一生的财富，不知道爱写作的我将来有没有能力去写书或者译书~期待ing&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201711/1140602-20171101183447795-856421915.jpg&quot; alt=&quot;&quot; width=&quot;150&quot; height=&quot;201&quot;/&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201711/1140602-20171101183509185-1114723520.jpg&quot; alt=&quot;&quot; width=&quot;271&quot; height=&quot;203&quot;/&gt; ...&amp;lt;此处省略hah做参考喽&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从基础的笔记分块来记录，到现在笔记分块分天来记录，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　据称&lt;span&gt;雷军叔叔&lt;/span&gt;的整个大学都是在图书馆度过的，&lt;/span&gt;&lt;span&gt;这又让我想起了《异类》中的&lt;span&gt;比尔乔伊&lt;/span&gt;，那时候的他都每天都待在计算机中心，直到清晨7点才离开，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;曾经的我错误的这么疯狂过，现在我想以一种正确的方式在去疯狂一次&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　外包项目一点一点的做，（郑州百格教育的官网，江苏南通集团的APP，微信狗的一起团小程序，深圳政府党建网的修改工作我都有负责）业务代码写了不少，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201711/1140602-20171101184305966-1372145517.png&quot; alt=&quot;&quot; width=&quot;452&quot; height=&quot;245&quot;/&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1140602/201711/1140602-20171101184423232-2079524613.png&quot; alt=&quot;&quot; width=&quot;454&quot; height=&quot;248&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　开始觉得自己需要去补充知识，继续了大一上持续学习的状态，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　还记得之前看过一篇文章，业务代码都写不好是一个很大的问题，但是只会写业务代码必然是不可取的，解决问题的思路都不同，眼界和见识都有很大的差别。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　小时候不明白坚持的是什么，长大后不明白坚持的对不对，做自己坚持的人很累，很辛苦；做随波逐流的人，很无趣。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　青春是如此的美好，我们又怎么忍心平凡度过，这几天读东野圭吾的《我的晃荡青春》--他的自传，我眼前浮现了我的那段荒诞的青春，心中满是感激v&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这世界上最幸福的事莫过于：幡然醒悟后，岁月安好，只愿你们还不老，曾经爱我的人，今后交给我来守护。&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 01 Nov 2017 11:16:00 +0000</pubDate>
<dc:creator>OkayChen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/okaychen/p/7765852.html</dc:identifier>
</item>
<item>
<title>不借助vue-cli，自行构建一个vue项目 - zhaoxingya</title>
<link>http://www.cnblogs.com/xingyazhao/p/7767602.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xingyazhao/p/7767602.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　对于刚刚接触vue的同学来说，直接用官方的构建工具vue-cli来生成一个项目结构会存在一些疑惑，比如:   &lt;em&gt;.vue&lt;/em&gt;组件 为什么可以写成三段式（tempalte、script、style）? 整个项目是怎样组织运行起来的，main.js - App.vue - 各个组件 之间是怎么相互引用的？&lt;/p&gt;
&lt;p&gt;　　为了让更多同学理解，我们不借助官方构建工具，自行构建一个类似于官方的项目结构，去体会它的运作机制。&lt;/p&gt;
&lt;p&gt;　　在自行构建的项目中，我们的组件并不使用.vue文件方式，因为这种文件是经过了vue-loader做了相应的处理，意思可以理解为将组件&amp;lt;template&amp;gt;&amp;lt;/template&amp;gt;中的模板编译到了组件对象中。而我们既然选择原生的方式，那么我们就应该将模板写在组件选项'template'中（虽然这种方式没有语法高亮，但要记得我们这样做的目的），而我们的组件后缀是.js。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;开始：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1. 进入自己的项目根目录，初始化npm&lt;/p&gt;
&lt;p&gt;　　npm init&lt;/p&gt;
&lt;p&gt;　　2. 安装vue包到项目&lt;/p&gt;
&lt;p&gt;　　npm install --save-dev vue&lt;/p&gt;
&lt;p&gt;　　3. 创建index.html/src目录/dist目录&lt;/p&gt;
&lt;p&gt;　　touch index.html　　mkdir src　　mkdir dist &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;文件功能：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　到目前，我们的项目结构：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1036165/201711/1036165-20171101162056326-1637164839.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接下来我们在src路径下创建，js入口文件main.js，项目根组件App.js，和组件目录components，并且我们象征性的创建两个组件cp1.js、cp2.js ：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1036165/201711/1036165-20171101162540982-1363667174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　main.js 是所有js的入口，（那么我们在index.html文件中只需要引入这个文件就够了？ -- 并不是），该文件将会声明与其他组件的依赖关系（而其他组件又会声明和别的组件的关系），我们在写完项目的时候需要使用webpack打包整个项目的js代码，而这个main.js就是打包寻找依赖的入口。&lt;/p&gt;
&lt;p&gt;　　我们得知通过Vuejs构建的项目，是组件化的，项目可以说是由一个个组件构成的，在一个组件中可以使用其他的组件作为自己的子组件，那么必然会存在一个根组件，它就是App.js。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;组件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　components文件夹下存放的是项目中的除根组件外的其他组件，我们在写这些组件的时候应该遵循的一个原则就是：&lt;strong&gt;与外界隔绝，不做任何与外界耦合的假设&lt;/strong&gt;。那么我们就来我们就开始编写组件cp1.js吧：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1036165/201711/1036165-20171101164105123-790502783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　请注意它和.vue组件写法的区别，我们的组件模板是写在template选项中的。并且提供给外界一个props参数接口msg。&lt;/p&gt;

&lt;p&gt;　　接下来我们需要在根组件中引用这个组件，根组件的写法遵循同样的原则：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1036165/201711/1036165-20171101164733529-1476699533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　要使用cp1组件，首先要将其import导入，因为cp1.js中导出的写法是export default，所以我们在这可以给cp1组件对象随意命名（import后紧随的'cp1'就是我们的命名），这是ES6的语法规则。&lt;/p&gt;
&lt;p&gt;　　记住：每个组件对象我们都需要使用export default进行导出，因为这样外界才可以调用它，并且将 给此组件的命名权 递交给使用者。&lt;/p&gt;
&lt;p&gt;　　我们看到，在根模板中我们有components选项，用来注册将使用的组件（局部注册）。此选项对象中的key将作为模板中标签，value为其他组件对象。&lt;/p&gt;
&lt;p&gt;　　在模板中我们使用了cp1标签，并且给其props属性msg赋值为'Message from parent ~'。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;入口：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　组件都写好了，那如何将其挂载到html页面中呢，这个时候我们需要一个桥梁，就是main.js：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1036165/201711/1036165-20171101170250560-2092362344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这次我们终于用到Vue了！（记得先导入），并且导入App根组件，将其注册为Vue实例的组件，并且在模板中使用它（template:'&amp;lt;app&amp;gt;&amp;lt;/app&amp;gt;'），然后将这个Vue实例挂载到index.html中id为app的元素中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;打包：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在打包之前我们需要先修改vue npm包的package.json文件，将默认导出的‘只包含运行时’改为‘完整版’，即将如下两项的'runtime'去掉（运行时不包含编译器 | 编译器作用：用来将模板字符串编译成为 JavaScript 渲染函数的代码&amp;gt;，因此组件对象不支持 template 选项）：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1036165/201711/1036165-20171101172207138-1270820955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在项目根路径执行打包（全局安装过webpack）&lt;/p&gt;
&lt;p&gt;　　webpack ./src/main.js ./dist/main.bundle.js&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;index.html：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;将打包后的文件引入到页面：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1036165/201711/1036165-20171101173326013-1703716730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接下来去浏览器访问它吧～&lt;/p&gt;


&lt;p&gt;　　效果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1036165/201711/1036165-20171101173440779-220905955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




</description>
<pubDate>Wed, 01 Nov 2017 09:37:00 +0000</pubDate>
<dc:creator>zhaoxingya</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xingyazhao/p/7767602.html</dc:identifier>
</item>
<item>
<title>“购物狂欢节”如何应对“羊毛党” - 腾讯云技术社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/7767525.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/7767525.html</guid>
<description>&lt;p&gt;欢迎大家前往&lt;a href=&quot;https://cloud.tencent.com/community&quot;&gt;腾讯云社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦~&lt;/p&gt;&lt;div readability=&quot;141&quot;&gt;
&lt;h2 id=&quot;-&quot;&gt;基于用户画像大数据的电商防刷架构&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;作者：颜国平&lt;br/&gt;摘要：最近几年，电商行业飞速发展，各种创业公司犹如雨后春笋大量涌现，商家通过各种活动形式的补贴来获取用户、培养用户的消费习惯，即将到来的“ 购物狂欢节”尤其明显。但任何一件事情都具有两面性，高额的补贴、优惠同时了也催生了“羊毛党”。“羊毛党”的行为距离欺诈只有一步之遥，他们的存在严重破环了活动的目的，侵占了活动的资源，使得正常的用户享受不到活动的直接好处。这篇文章主要分享下腾讯自己是如何通过大数据、用户画像、建模来防止被刷、恶意撞库的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;-&quot;&gt;黑产“羊毛党”现状介绍&lt;/h2&gt;
&lt;p&gt;“羊毛党”一般先利用自动机注册大量的目标网站账号，当目标网站搞促销、优惠等活动的时候，利用这些账号参与活动刷取较多的优惠，最后通过某宝等电商平台转卖获益。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;一.“羊毛党”分工&lt;/h3&gt;
&lt;p&gt;据初步估计，全国“羊毛党”在20万人左右，他们往往有着明确的分工，已形成了几大团伙：&lt;/p&gt;
&lt;p&gt;1.软件制作团伙：专门制作各种自动、半自动的黑产工具，比如注册自动机、刷单自动机等；他们主要靠出售各种黑产工具、提供升级服务等形式来获利。&lt;br/&gt;2.短信代接平台：实现手机短信的自动收发。这其中，有一些短信平台是亦正亦邪，不但提供给正常的商家使用，一些黑产也会购买相关的服务。&lt;br/&gt;3.账号出售团伙：他们主要是大量注册各种账号，通过转卖账号来获利；该团伙与刷单团伙往往属于同一团伙。&lt;br/&gt;4.刷单团伙：到各种电商平台刷单，获取优惠，并且通过第三方的电商平台出售优惠，实现套现。&lt;/p&gt;
&lt;p&gt;也就是说，这些“羊毛党“在电商促销或优惠活动中，已逐步形成了相对完善的刷单及变现工作流程（见图1：电商刷单团伙工作流程）:&lt;br/&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1509501258853_3782_1509501200197.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图1：电商刷单团队的工作流程&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;二.“羊毛党”从业特点&lt;/h3&gt;
&lt;p&gt;从“羊毛党“的分工与工作流程看，他们具有以下从业特点：&lt;br/&gt;1.专业化：有专业团队、人员、机器来做。&lt;br/&gt;2.团伙化：已经形成一定规模的团伙，而且分工明确；从刷单软件制作、短信代收发平台、电商刷单到变卖套现等环节，已经形成完整的刷单团伙。&lt;br/&gt;3.地域化：刷单黑产团伙基本分布在沿海的一些经济发达城市，比如，北京、上海、广东等城市，这或许跟发达城市更加容易接触到新事物、新观念有关。&lt;br/&gt;下图2显示了我们TOP5的黑产刷单团伙分别位于：北京、上海、广州、江苏、浙江这些沿海较发达的经济区域。&lt;br/&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1509501288060_2591_1509501229395.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图2 TOP5黑产刷单团伙的地域分布&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;三.对抗刷单的思路&lt;/h3&gt;
&lt;p&gt;面对黑产刷单，我们有什么对抗思路呢？一般来讲，对抗刷单主要从注册、登陆、活动三个环节入手：&lt;br/&gt;1.注册环节：识别虚假注册、减少“羊毛党”能够使用的账号量。在注册环节识别虚假注册的账号，并进行拦截和打击。&lt;br/&gt;2.登录场景：提高虚假账号登录门槛，从而减少能够到达活动环节的虚假账号量。比如，登录环节通过验证码、短信验证码等手段来降低自动机的登录效率，从而达到减少虚假账号登录量、减轻活动现场安全压力的目的。&lt;br/&gt;3.活动环节：这个是防刷单对抗的主战场，也是减少“羊毛党”获利的直接战场；这里的对抗措施，一般有两个方面： 1）通过验证码（短信、语音）降低黑产刷单的效率。 2）大幅度降低异常账号的优惠力度。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;电商防刷架构&lt;/h2&gt;
&lt;h3 id=&quot;-&quot;&gt;一. 腾讯防刷总体架构&lt;/h3&gt;
&lt;p&gt;面对疯狂的黑产刷单，按照对抗刷单的思路，基于腾讯的多维度大数据，腾讯专门设计并构建了电商防刷技术体系。总体防刷架构见下图3：&lt;br/&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1509501333340_5540_1509501274709.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图3：腾讯防刷单技术架构&lt;br/&gt;从上面的总体架构我们可以看到，整个系统分三层：接入层、实时计算层、存储&amp;amp;挖掘层。整个系统充分利用了腾讯海量业务生态中的多维度大数据，以及全方位的风控经验与能力。接下来我们详细介绍其中的一些核心模块。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;二.防刷单技术架构核心模块与框架介绍&lt;/h3&gt;
&lt;h4 id=&quot;1-&quot;&gt;1.风险学习引擎&lt;/h4&gt;
&lt;p&gt;对于风险学习引擎而言，效率问题非常关键。该模块线上采用的都是C++实现的DBScan等针对大数据的快速聚类算法，性能卓越；而且主要的工作都是线下进行，所以线上系统也不存在学习的效率问题。&lt;br/&gt;风险学习引擎采用了黑/白双分类器风险判定机制，可以很好地减少对正常用户的误伤。例如，某个IP是恶意的IP，那么该IP上可能会有一些正常的用户，比如大网关IP。再比如，黑产通过ADSL拨号上网，那么就会造成恶意与正常用户共用一个IP的情况。&lt;br/&gt;其中，黑分类器风险判定是根据特征、机器学习算法、规则/经验模型，来判断本次请求异常的概率。而白分类器风险判定则是判断属于正常请求的概率。见下图4示意：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1509501378269_652_1509501319559.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图4 风险引擎的宏观构成&lt;/p&gt;
&lt;h4 id=&quot;2-&quot;&gt;2.分类器逻辑框架&lt;/h4&gt;
&lt;p&gt;如何实现风险评估的判定呢？我们以黑分类器为例，来详细剖析下分类器的逻辑框架。&lt;/p&gt;
&lt;p&gt;系统总体是采用一种矩阵式的逻辑框架。&lt;/p&gt;
&lt;p&gt;黑分类器最初设计是整体检测判定，即按需随意地建立一个个针对黑产的检测规则、模型。但这种设计出来的结果，发现不是这个逻辑漏过了，而是那个逻辑误伤量大，要对某一类的账号加强安全打击力度，改动起来也非常麻烦。&lt;/p&gt;
&lt;p&gt;因此，我们最终设计出一套矩阵式的框架（见下图5），较好地解决上述问题。&lt;br/&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1509501419072_6205_1509501360496.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图5 黑分类器的矩阵逻辑框架&lt;br/&gt;矩阵的横向采用了Adaboost方法，该方法是一种迭代算法，其核心思想是针对同一个训练集训练不同的弱分类器，然后把这些分类器集合起来，构成一个最终的分类器。而我们这里每一个弱分类器都只能解决一种帐号类型的安全风险判断，集中起来才能解决所有账户的风险检测。&lt;br/&gt;这个矩阵逻辑的横向方法，在工程实现上也带来三个好处：&lt;br/&gt;1.便于实现轻重分离。比如某平台虚假账号集中在邮箱账号，策略就可以加大对邮箱账号的打击力度，影响范围也局限在邮箱帐号，而不是该平台所有的账号。&lt;br/&gt;2.减少模型训练的难度。模型训练最大的难度在于样本的均衡性问题，拆分成子问题，就不需要考虑不同账号类型之间的数据配比、均衡性问题，大大降低了模型训练时正负样本比率的问题。&lt;br/&gt;3.逻辑的健壮性。某一个分类器的训练出现了问题，受影响的范围不至于扩展到全局。&lt;/p&gt;
&lt;p&gt;矩阵纵向则采用了Bagging方法，该方法是一种用来提高学习算法准确度的方法。它在同一个训练集合上构造预测函数系列，然后设法将他们组合成一个预测函数，从而来提高预测结果的准确性。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;腾讯大数据处理平台－魔方&lt;/h2&gt;
&lt;p&gt;毫无疑问，对抗黑产刷单离不开大数据。大数据一直在安全对抗领域发挥着重要的作用，从我们的对抗经验来看，大数据不仅仅是数据规模很大，而且还包括两个方面：&lt;br/&gt;1.数据广度：要有丰富的数据类型。比如，不仅仅要有社交领域的数据、还要有游戏、支付、自媒体等领域的数据，这样就提供了一个广阔的视野让我们来看待黑产的行为特点。&lt;br/&gt;2.数据深度：黑产的对抗，我们一直强调纵深防御。不仅仅要有注册数据，还要有登录，以及账号的使用的数据，这样我们才能更好的识别恶意。&lt;br/&gt;所以想要做风控和大数据的团队，一定要注意在自己的产品上多埋点，拿到足够多的数据，先沉淀下来。&lt;br/&gt;腾讯安全团队研发了一个叫魔方的大数据处理和分析的平台，底层集成了MySQL、MongoDB，Spark、Hadoop等技术，在用户层面我们只需要写一些简单的SQL语句、完成一些配置就可以实现例行分析。&lt;br/&gt;这里我们收集了社交、电商、支付、游戏等场景的数据，针对这些数据我们建立一些模型，发现哪些是恶意的数据，并且将数据沉淀下来。&lt;br/&gt;沉淀下来的对安全有意义的数据，一方面就存储在魔方平台上，供线下审计做模型使用；另一方面会做成实时的服务，提供给线上的系统查询使用。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;一.腾讯用户画像沉淀方法&lt;/h3&gt;
&lt;p&gt;用户画像，本质上就是给账号、设备等打标签。但我们这里主要从安全的角度出发来打标签，比如IP画像，我们会标注IP是不是代理IP，这些对我们做策略是有帮助的。&lt;br/&gt;我们看看腾讯的IP画像，目前沉淀的逻辑如下图6：&lt;br/&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1509501489829_8594_1509501431294.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图6 IP画像系统构成&lt;br/&gt;一般的业务都有针对IP的频率、次数限制的策略，那么黑产为了对抗，必然会大量采用代理IP来绕过限制。既然代理IP的识别如此重要，那我们就以代理IP为例来谈下腾讯识别代理IP的过程。&lt;br/&gt;识别一个IP是不是代理IP，技术不外乎就是如下四种：&lt;br/&gt;1.反向探测技术：扫描IP是不是开通了80,8080等代理服务器经常开通的端口，显然一个普通的用户IP不太可能开通如上的端口。&lt;br/&gt;2.HTTP头部的X_Forwarded_For：开通了HTTP代理的IP可以通过此法来识别是不是代理IP；如果带有XFF信息，该IP是代理IP无疑。&lt;br/&gt;3.Keep-alive报文：如果带有Proxy-Connection的Keep-alive报文，该IP毫无疑问是代理IP。&lt;br/&gt;4.查看IP上端口：如果一个IP有的端口大于10000，那么该IP大多也存在问题，普通的家庭IP开这么大的端口几乎是不可能的。&lt;br/&gt;以上代理IP检测的方法几乎都是公开的，但是盲目去扫描全网的IP，被拦截不说，效率也是一个很大的问题。&lt;br/&gt;因此，我们的除了利用网络爬虫爬取代理IP外，还利用如下办法来加快代理IP的收集：通过业务建模，收集恶意IP（黑产使用代理IP的可能性比较大）然后再通过协议扫描的方式来判断这些IP是不是代理IP。每天腾讯都能发现千万级别的恶意IP，其中大部分还是代理IP。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;二.腾讯用户画像类别概览&lt;/h3&gt;
&lt;p&gt;腾讯用户画像的维度与类别很多，这里仅举部分用户画像数据来说明。比如用户画像其中有手机画像和QQ画像这两个重要类别。涉及画像的标签见下图7：&lt;br/&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1509501520940_4395_1509501462339.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;以QQ的画像为例，比如，一个QQ只登录IM、不登录其他腾讯的业务、不聊天、频繁的加好友、被好友删除、QQ空间要么没开通、要么开通了QQ空间但是评论多但回复少，这种号码我们一般会标注QQ养号（色情、营销），类似的我们也会给QQ打上其他标签。&lt;br/&gt;标签的类别和明细，需要做风控的人自己去设定，比如：地理位置，按省份标记。性别，按男女标记。其他细致规则以此规律自己去设定。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;三. 风险判定的基础逻辑&lt;/h3&gt;
&lt;p&gt;有了用户画像的基础数据，我们就可以进行风险判定了。腾讯风险判定的系统现已开放为腾讯云的能力，即天御系统。我们来看一下风险判定的基础逻辑，见下图8：&lt;br/&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1509501567314_8022_1509501508766.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图8 腾讯云天御系统防御逻辑示意图&lt;/p&gt;
&lt;p&gt;实时防御系统使用C/C++开发实现，所有的数据通过共享内存的方式进行存储，相比其他的系统，安全系统更有他自己特殊的情况，因此这里我们可以使用“有损”的思路来实现，大大降低了开发成本和难度。&lt;/p&gt;
&lt;p&gt;但这里在安全策略方面，可能会面临一个挑战：多台机器，使用共享内存，如何保障数据一致性？其实，安全策略不需要做到强数据一致性。&lt;/p&gt;
&lt;p&gt;从安全本身的角度看，风险本身就是一个概率值，不确定，所以有一点数据不一致，不影响全局。但是安全系统也有自己的特点，安全系统一般突发流量比较大，我们这里就需要设置各种应急开关，而且需要微信号、短信等方式方便快速切换，避免将影响扩散到后端系统。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;电商企业接入天御系统，启用带防刷能力的业务架构&lt;/h2&gt;
&lt;p&gt;通过剖析腾讯对抗“羊毛党”刷单的防刷系统技术架构与原理，我们了解到了天御系统可以帮助咱们电商企业在促销、优惠活动时，有效打击黑产刷单团伙。特别是马上到来的双十一“购物狂欢节”，该系统将让广大电商企业更好地服务用户，真正为用户带来贴心的实惠与好处。&lt;/p&gt;
&lt;p&gt;天御系统可适应的场景包括但不限于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;电商o2o刷单、刷券、刷红包&lt;/li&gt;
&lt;li&gt;防止虚假账号注册&lt;/li&gt;
&lt;li&gt;防止用户名、密码被撞库&lt;/li&gt;
&lt;li&gt;防止恶意登录&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么如何接入并使用天御系统呢？其实，电商企业接入天御系统仅需要四步，见下图9：&lt;br/&gt;其中：第一步离线数据分析与第二步搭建实时模型为前期的准备工作，第三步正式接入其实并不耗费多少时间，不过第四步上线后，还需要持续的优化，以进一步提高对抗的能力。&lt;br/&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1509501608087_4514_1509501549574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图9 企业接入天御系统步骤&lt;br/&gt;业务接入天御系统后的架构图，见下图10：&lt;br/&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1509501625234_6997_1509501566595.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图10 业务接入天御防刷后的架构图&lt;br/&gt;从上图可以看到，接入天御防刷是旁路接入，不需要调整现有业务任何核心逻辑、关键流程，可以快速上线。另外，运行过程中，即使天御防刷有任何异常也不会影响业务主逻辑。&lt;br/&gt;&lt;strong&gt;Q&amp;amp;A&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;Q：风险学习引擎是自研的，还是使用的开源库？&lt;/strong&gt;&lt;br/&gt;风险学习引擎包括两个部分，线上和线下两部分：&lt;br/&gt;线上：自己利用c/c++来实现。&lt;br/&gt;线下：涉及利用python开源库来做的，主要是一些通用算法的训练和调优。&lt;br/&gt;&lt;strong&gt;Q：请问魔方平台中用到的MongDB是不是经过改造？因为MongDB一直不被看好，出现问题也比较多。&lt;/strong&gt;&lt;br/&gt;我们做了部分改造，主要是DB的引擎方面。&lt;br/&gt;&lt;strong&gt;Q：请问黑分类器和白分类器有什么区别？&lt;/strong&gt;&lt;br/&gt;白分类器主要用来识别正常用户，黑分类器识别虚假用户。&lt;br/&gt;&lt;strong&gt;Q：风险概率的权重指标是如何考虑的？&lt;/strong&gt;&lt;br/&gt;先通过正负样本进行训练，并且做参数显著性检查；然后，人工会抽查一些参数的权重，看看跟经验是否相符。&lt;br/&gt;&lt;strong&gt;Q：安全跟风控职责如何区分呢？&lt;/strong&gt;&lt;br/&gt;相比安全，风控的外延更丰富，更注重宏观全局；针对一个公司来讲，风控是包括安全、法务、公关、媒体、客服等在内一整套应急处理预案。&lt;br/&gt;&lt;strong&gt;Q：如果识别错了，误伤了正常用户会造成什么后果么？比如影响单次操作还是会一直失败。&lt;/strong&gt;&lt;br/&gt;如果识别错了正常用户不会被误伤，但是会导致体验多加了一个环节，如弹出验证码、或者人工客服核对等。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;作者：颜国平，原腾讯云－天御系统研发负责人。一直负责腾讯自有验证码、业务安全、防刷、账号安全等研发工作。内部支持的产品（游戏、电商、腾讯投资的O2O企业）非常广泛。在业务安全领域项目经验丰富，并且具备深度学习、大数据架构搭建等实战经验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 01 Nov 2017 09:27:00 +0000</pubDate>
<dc:creator>腾讯云技术社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/7767525.html</dc:identifier>
</item>
</channel>
</rss>