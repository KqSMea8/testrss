<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MAVEN打包时没有将src/main/cache文件夹打到到WAR包中 - yjjddd85</title>
<link>http://www.cnblogs.com/yesok/p/9952677.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yesok/p/9952677.html</guid>
<description>&lt;p&gt;某项目中ehcache配置文件写在src/main/cache中，结果用maven打包时，得到的WAR包里面没有这个文件夹&lt;/p&gt;
&lt;p&gt;因为maven打包时默认只打包src/main/java中的文件和src/main/resources中的文件，如果要将src/main/cache文件夹也打包到war中，需要将这个文件夹移到resources中，打包后，在classes文件夹中。可以通过classpath:cache/取得文件目录&lt;/p&gt;
&lt;p&gt;当然也可以修改pom.xml，只是不建议这么做。&lt;/p&gt;
</description>
<pubDate>Tue, 13 Nov 2018 07:55:00 +0000</pubDate>
<dc:creator>yjjddd85</dc:creator>
<og:description>某项目中ehcache配置文件写在src/main/cache中，结果用maven打包时，得到的WAR包里面没有这个文件夹 因为maven打包时默认只打包src/main/java中的文件和src/m</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yesok/p/9952677.html</dc:identifier>
</item>
<item>
<title>Dubbo体验（一） - 农码红尘</title>
<link>http://www.cnblogs.com/sunTin/p/9950997.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunTin/p/9950997.html</guid>
<description>&lt;p&gt;    最近新加入一个项目组，所使用的是Dubbo，采用的架构是分布式架构，数据库采用MySQL分片。之前也接触过一下，但为了能更好融入团队，所以找Dubbo官网看文档。&lt;/p&gt;
&lt;p&gt;才发现Dubbo的官网已搬去github。好吧，最近太关注于SpringCloud。&lt;/p&gt;
&lt;p&gt;附上现在Dubbo地址 ：http://dubbo.apache.org/zh-cn/docs/user/quick-start.html 。&lt;/p&gt;
&lt;p&gt;Dubbo由于之前没咋更新，被人诟病。但无可争议，这是一个很强大的服务治理框架，历经双十一考验，有着非常完整的中文文档。&lt;/p&gt;
&lt;p&gt; 十月底，看到一则消息，Spring Cloud Alibaba正式入驻Spring Cloud官方孵化器！附上阿里的spring-cloud地址：&lt;/p&gt;
&lt;p&gt;https://github.com/spring-cloud-incubator/spring-cloud-alibaba 。&lt;/p&gt;

&lt;p&gt;  什么鬼， 似乎跑题了耶，废话不说，先来Dubbo试一波。&lt;/p&gt;

&lt;p&gt;　　一款分布式服务框架&lt;/p&gt;
&lt;p&gt;　　高性能和透明化的RPC远程服务调用方案&lt;/p&gt;
&lt;p&gt;　　SOA服务治理方案&lt;/p&gt;
&lt;p&gt;顺便一提RPC：&lt;/p&gt;
&lt;p&gt;来自百度百科：&lt;/p&gt;
&lt;p&gt;RPC（Remote Procedure Call）—&lt;a href=&quot;https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/7854346&quot; target=&quot;_blank&quot; data-lemmaid=&quot;7854346&quot;&gt;远程过程调用&lt;/a&gt;，它是一种通过&lt;a href=&quot;https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C/143243&quot; target=&quot;_blank&quot; data-lemmaid=&quot;143243&quot;&gt;网络&lt;/a&gt;从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。&lt;a href=&quot;https://baike.baidu.com/item/RPC%E5%8D%8F%E8%AE%AE&quot; target=&quot;_blank&quot;&gt;RPC协议&lt;/a&gt;假定某些&lt;a href=&quot;https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/8048821&quot; target=&quot;_blank&quot; data-lemmaid=&quot;8048821&quot;&gt;传输协议&lt;/a&gt;的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI&lt;a href=&quot;https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/9636548&quot; target=&quot;_blank&quot; data-lemmaid=&quot;9636548&quot;&gt;网络通信&lt;/a&gt;模型中，RPC跨越了&lt;a href=&quot;https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82/4329536&quot; target=&quot;_blank&quot; data-lemmaid=&quot;4329536&quot;&gt;传输层&lt;/a&gt;和&lt;a href=&quot;https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82/4329788&quot; target=&quot;_blank&quot; data-lemmaid=&quot;4329788&quot;&gt;应用层&lt;/a&gt;。RPC使得开发包括网络&lt;a href=&quot;https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F&quot; target=&quot;_blank&quot;&gt;分布式&lt;/a&gt;多程序在内的应用程序更加容易。&lt;/p&gt;
&lt;p&gt;大概意思可以这么理解：现在有两台服务器A、B，分别部署不同的应用a,b。当A服务器想要调用B服务器上应用b提供的函数或方法的时候，由于不在一个内存空间，不能直接调用，需要通过网络传输调用。 A可以通过使用参数将信息传送给B，而后可以通过传回的结果得到信息。而这一过程，对于开发人员来说是透明的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036590/201811/1036590-20181113105926748-1203851406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;节点角色说明&lt;/h5&gt;

&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;节点&lt;/th&gt;
&lt;th&gt;角色说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;Provider&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;暴露服务的服务提供方&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;Consumer&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;调用远程服务的服务消费方&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;服务注册与发现的注册中心&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;Monitor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;统计服务的调用次数和调用时间的监控中心&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Container&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;服务运行容器&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5&gt;&lt;span&gt;&lt;br/&gt;调用关系说明&lt;/span&gt;调用关系说明&lt;/h5&gt;
&lt;ol start=&quot;0&quot;&gt;&lt;li&gt;服务容器负责启动，加载，运行服务提供者。&lt;/li&gt;
&lt;li&gt;服务提供者在启动时，向注册中心注册自己提供的服务。&lt;/li&gt;
&lt;li&gt;服务消费者在启动时，向注册中心订阅自己所需的服务。&lt;/li&gt;
&lt;li&gt;注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。&lt;/li&gt;
&lt;li&gt;服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。&lt;/li&gt;
&lt;li&gt;服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;       &lt;span&gt;Dubbo是基于Spring的Schema进行扩展&lt;/span&gt;，对应用没有任何API侵入，就是说开发者采用只需要采用Spring即可开发。&lt;/p&gt;
&lt;p&gt;本次Demo 采用maven+idea 进行开发，使用zookeeper作为服务注册中心。&lt;/p&gt;
&lt;h2&gt;Server 端开发&lt;/h2&gt;
&lt;p&gt;工程结构如下所示&lt;/p&gt;
&lt;h2&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1036590/201811/1036590-20181113142648186-1524087292.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;p&gt; maven工程一般第一步就是配置pom.xml，导入jar包。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;span&gt;
         xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;dubbo&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.2.6.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.5.3&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.101tec&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;zkclient&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;0.9&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 接下来是provider接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dubbotest;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Provider{
    String send(String name) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;provider实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dubbotest.impl;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.dubbotest.Provider;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DemoServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Provider {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String send(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        System.out.println(&lt;/span&gt;&quot; got a argument: &quot; +&lt;span&gt; name);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;message from provider: &quot; +&lt;span&gt; name;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;配置application.xml，使用Spring暴露服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
       xmlns:dubbo&lt;/span&gt;=&quot;http://code.alibabatech.com/schema/dubbo&quot;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;code.alibabatech.com/schema/dubbo&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;code.alibabatech.com/schema/dubbo/dubbo.xsd&lt;/span&gt;
        &quot;&amp;gt;
    &amp;lt;!-- 具体的实现bean --&amp;gt;
    &amp;lt;bean id=&quot;demoService&quot;
          &lt;span&gt;class&lt;/span&gt;=&quot;com.dubbotest.impl.DemoServiceImpl&quot; /&amp;gt;
    &amp;lt;!-- 提供方应用信息，用于计算依赖关系 --&amp;gt;
    &amp;lt;dubbo:application name=&quot;anyname_provider&quot; /&amp;gt;
    &amp;lt;!-- 使用zookeeper注册中心暴露服务地址 --&amp;gt;
    &amp;lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&amp;gt;
    &amp;lt;!-- 用dubbo协议在20880端口暴露服务 --&amp;gt;
    &amp;lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&amp;gt;
    &amp;lt;!-- 声明需要暴露的服务接口 --&amp;gt;
    &amp;lt;dubbo:service &lt;span&gt;interface&lt;/span&gt;=&quot;com.dubbotest.Provider&quot;&lt;span&gt;
                   ref&lt;/span&gt;=&quot;demoService&quot; /&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;启动类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dubbo.test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        ClassPathXmlApplicationContext context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;new&lt;/span&gt; String[] {&quot;applicationContext.xml&quot;&lt;span&gt;});
        context.start();
        System.out.println(&lt;/span&gt;&quot; provider run &quot;&lt;span&gt;);
        System.in.read(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按任意键退出&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Client端开发&lt;/h2&gt;
&lt;p&gt;接下来，client差不多 ，工程结构如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036590/201811/1036590-20181113145614874-1205944973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也需配置接口，正常来说，可以将server的接口打成jar包，然后client端导入即可。&lt;/p&gt;
&lt;p&gt;配置application.xml，此处是consumer，用于远程服务调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
       xmlns:dubbo&lt;/span&gt;=&quot;http://code.alibabatech.com/schema/dubbo&quot;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;code.alibabatech.com/schema/dubbo&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;code.alibabatech.com/schema/dubbo/dubbo.xsd&lt;/span&gt;
        &quot;&amp;gt;
    &amp;lt;!-- 具体的实现bean --&amp;gt;
    &amp;lt;bean id=&quot;demoService&quot;
          &lt;span&gt;class&lt;/span&gt;=&quot;com.dubbotest.impl.DemoServiceImpl&quot; /&amp;gt;
    &amp;lt;!-- 提供方应用信息，用于计算依赖关系 --&amp;gt;
    &amp;lt;dubbo:application name=&quot;anyname_provider&quot; /&amp;gt;
    &amp;lt;!-- 使用zookeeper注册中心暴露服务地址 --&amp;gt;
    &amp;lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; /&amp;gt;
    &amp;lt;!-- 用dubbo协议在20880端口暴露服务 --&amp;gt;
    &amp;lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&amp;gt;
    &amp;lt;!-- 声明需要暴露的服务接口 --&amp;gt;
    &amp;lt;dubbo:service &lt;span&gt;interface&lt;/span&gt;=&quot;com.dubbotest.Provider&quot;&lt;span&gt;
                   ref&lt;/span&gt;=&quot;demoService&quot; /&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;配置consumer 启动类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.dubbo.test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.dubbotest.Provider;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.Format;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.SimpleDateFormat;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Consumer {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args)&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        ClassPathXmlApplicationContext context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&lt;span&gt;new&lt;/span&gt; String[] { &quot;applicationContext.xml&quot;&lt;span&gt; });
        context.start();
        Provider demoService &lt;/span&gt;= (Provider) context.getBean(&quot;demoService&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取远程服务代理&lt;/span&gt;
        Format sdf = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;span&gt;);
        String  mgs &lt;/span&gt;= demoService.send(sdf.format(&lt;span&gt;new&lt;/span&gt; Date()));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行远程方法&lt;/span&gt;
        System.out.println( mgs);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 显示结果&lt;/span&gt;
&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; OK，接下来，就是测试是否发送成功。先启动ZK，再启动Test类，在控制台棵看到  provider run ，说明启动成功。&lt;/p&gt;
&lt;p&gt;再启动consumer 类。可看到控制台，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1036590/201811/1036590-20181113145722728-2018741674.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明调用成功。&lt;/p&gt;

&lt;p&gt;通过这个Demo，我们可以看到，使用Dubbo，我们只需使用Spring配置即可开发，对应用无入侵性。&lt;/p&gt;
&lt;p&gt;其次我们无需关注底层的线程IO模型，网络通讯问题。&lt;/p&gt;
&lt;p&gt;还有就是服务自动注册与发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。&lt;/p&gt;
</description>
<pubDate>Tue, 13 Nov 2018 07:52:00 +0000</pubDate>
<dc:creator>农码红尘</dc:creator>
<og:description>最近新加入一个项目组，所使用的是Dubbo，采用的架构是分布式架构，数据库采用MySQL分片。之前也接触过一下，但为了能更好融入团队，所以找Dubbo官网看文档。 才发现Dubbo的官网已搬去gith</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunTin/p/9950997.html</dc:identifier>
</item>
<item>
<title>抽象工厂模式 创建型 设计模式(四) - noteless</title>
<link>http://www.cnblogs.com/noteless/p/9952480.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/9952480.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;抽象工厂模式是工厂方法模式的进一步抽象&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在工厂模式中，客户端程序依赖（消费）一种抽象产品角色Product&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有的ConcreteCreator的返回类型都是Product，因为抽象工厂角色Creator就是返回Product &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，如果一个系统需要依赖多个不同的抽象产品角色怎么办？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是需要Product1 Product2 ... 他们是不同的抽象角色，工厂模式就歇菜了，简单工厂模式也只是一种类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时，就需要抽象工厂模式，抽象工厂模式可以创建多种类型的产品&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简言之，&lt;span&gt;&lt;strong&gt;工厂模式只能生产一种产品，比如青岛啤酒厂生产各式样的啤酒，他不可能生产大米&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;抽象工厂角色就可以生产啤酒和大米&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;产品族与产品等级&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;想要理解抽象工厂的本质，需要先介绍两个概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;产品族和产品等级结构&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;产品等级结构指的是产品的分类划分结构&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;功能相关联的不同产品（位于不同的等级结构）就组成了一个产品族&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;我们举例说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如实际项目中，DAO（数据库访问层）都有CRUD 操作（增查改删）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是有不同的数据库，假设使用MYSQL和ORACLE两种数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么对于CRUD操作都有两种类型 MYSQL和ORACLE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;产品的等级结构如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153226512-986682641.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bea7dea_4170&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153226821-941926347.png&quot; alt=&quot;image_5bea7dea_4170&quot; width=&quot;969&quot; height=&quot;219&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;CRUD操作四个操作对应四个等级产品（简单理解就是四种类型产品）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四个等级中的MYSQL 就组成了一个产品族&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;四个等级中的ORACLE 也组成了一个产品族&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;再比如 快餐店经常都有销售鸡腿和汉堡（两种产品）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是有不同的快餐店，比如KFC和Mcdonalds&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;产品的等级结构如下图&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153227084-25943649.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bea7dea_2800&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153227306-1500379937.png&quot; alt=&quot;image_5bea7dea_2800&quot; width=&quot;542&quot; height=&quot;199&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;鸡腿和汉堡对应两个产品等级体系结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两个等级结构中的KFC组成了一个产品族&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两个等级结构中的Mcdonalds组成了一个产品族&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;再比如，计算机中有文字处理软件和图像处理软件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是计算机有不同的操作系统平台，比如Windows和Linux&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153228808-1775723779.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bea7dea_4e33&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153229013-652602962.png&quot; alt=&quot;image_5bea7dea_4e33&quot; width=&quot;526&quot; height=&quot;196&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;有文字处理和图像处理两种产品等级结构&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;两个等级结构中的windows平台下软件组成了一个产品族&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两个等级结构中的Linux平台下软件组成了一个产品族 &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;所以说，&lt;span&gt;&lt;strong&gt;不同类型的产品，就是不同的等级结构&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;水果是一个等级，蔬菜是一个等级，PC是一个等级&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;不同等级结构中，相关联的一组功能就是一个产品族&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相关联的含义是有一些公共的限制约束或者特性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;水果是一个等级，蔬菜是一个等级&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;热带水果和热带蔬菜，产地都是南方属于热带地区 ， 这就是一个产品族 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;主板是一个等级，有多种厂家生产，比如华硕 戴尔&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显示器是一个等级，有多种厂家生产，比如华硕 戴尔&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;主板和显式器可以组成电脑的一部分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;华硕主板和华硕显示器都是华硕品牌的，是一个产品族&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;一个产品族中，有多少个产品，跟产品等级结构的个数是一致的&lt;br/&gt;也就是说有多少种产品，一个产品族就有多少个&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;有CRUD四个产品等级，一个mysql产品族就有四个产品&lt;br/&gt;有鸡腿汉堡两个产品等级，KFC产品族就有两种产品&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;产品族就是一个产品类别中拿出来一个&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;所以就是一个类型有多少种，就是有多少个产品族&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;简单理解就是：&lt;span&gt;&lt;strong&gt;每个类型来一个，就构成了一个产品族&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;想要使用工厂模式，首先就是要理清楚产品的等级结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单工厂和工厂方法模式都只能创建一种等级结构的产品&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果想要创建多个等级结构的产品，你可以借助于多个工厂方法模式 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，&lt;span&gt;&lt;strong&gt;如果有产品族的概念，你可以考虑抽象工厂模式&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;需要特别关注是否有关联和共同约束限制条件，也就是是否能够成为产品族&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;意图&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;提供一个创建一系列相关或者相互依赖对象的接口，而无需指定他们具体的类。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实就是工厂方法模式中一个方法，创建一个类型，此处多个方法，创建多个类型，简单理解就是这样&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;说完了产品等级结构和产品族的概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们看下抽象工厂模式的结构&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;产品等级结构product&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ProductA和ProductB&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他们分别有对应的两种类型的产品&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ConcreteProductA1 和 ConcreteProductA2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ConcreteProductB1 和 ConcreteProductB2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;抽象工厂角色Creator&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;Creator可以创建ProductA和ProductB两种抽象类型&lt;br/&gt;他有两个实现类工厂ConcreteCreator1和 ConcreteCreator2&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;具体的工厂ConcreteCreator&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;每一个ConcreteCreator都可以生产一个产品族的产品&lt;br/&gt;也就是ConcreteCreator1可以生产ConcreteProductA1 和 ConcreteProductB1&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153229996-1629346581.png&quot;&gt;&lt;img title=&quot;image_5bea7dea_7a2&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153230295-1143687311.png&quot; alt=&quot;image_5bea7dea_7a2&quot; width=&quot;903&quot; height=&quot;617&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;角色介绍&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;抽象工厂角色（Abstract Factory）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;工厂方法的核心，与系统具体逻辑无关，通常是java接口或者抽象类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所有的具体的工厂都需要实现它，也就是上图中的Creator&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;具体工厂角色（Concrete Factory）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直接接受客户端程序请求，创建产品的实例，它可以创建一个产品族的实例对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;抽象产品角色（Abstract Product）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为一类产品对象声明一个抽象表示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;具体产品角色（Concrete Product）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义一个被创建的具体的对象的类型，实现Abstract Product接口&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;类似工厂模式，具体的工厂角色可以有多个，分别对应不同的产品族&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有几个产品族就会有几个具体的工厂&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;示例代码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;有两个产品等级结构 Fruit和Vegetable 也就是有水果和蔬菜两种商品&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设有两个商店，他们都提供水果和蔬菜&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个商店提供的水果和蔬菜是苹果和土豆&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二个商店提供的水果和蔬菜是橘子和白菜&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是苹果Apple和土豆Potato是一个产品族，由一个店铺在卖&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;橘子Orange和大白菜Cabbage是一个产品族，由一个店铺在卖&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;产品类Fruit以及Apple和Orange与工厂模式中示例代码一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Vegetable表示蔬菜的抽象角色 Potato和Cabbage为具体的蔬菜&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有抽象工厂角色Factory&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以及具体的工厂ConcreteFactory1  和 ConcreteFactory2&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153230569-558358987.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bea7dea_6a2e&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153230761-1642517113.png&quot; alt=&quot;image_5bea7dea_6a2e&quot; width=&quot;249&quot; height=&quot;250&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Fruit产品结构体系&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; abstractFactory;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/9.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Fruit {
String description();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; abstractFactory;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/9.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Apple &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Fruit {
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String description() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;apple&quot;&lt;span&gt;;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; abstractFactory;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/9.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Orange &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Fruit {
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String description() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Orange&quot;&lt;span&gt;;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;蔬菜产品结构体系&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; abstractFactory;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/10.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Vegetable {
String description();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; abstractFactory;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/10.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Potato &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Vegetable {
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String description() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;potato&quot;&lt;span&gt;;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; abstractFactory;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/10.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cabbage &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Vegetable {
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String description() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;cabbage&quot;&lt;span&gt;;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;工厂体系&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; abstractFactory;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/9.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Factory {
Fruit createFruit();
Vegetable createVegetable();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; abstractFactory;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/10.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConcreateFactory1 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Factory {
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Fruit createFruit() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Apple();
}
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Vegetable createVegetable() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Potato();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; abstractFactory;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* Created by noteless on 2018/10/10.
* Description:
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConcreateFactory2 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Factory {
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Fruit createFruit() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Orange();
}
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Vegetable createVegetable() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cabbage();
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试代码&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153230948-1334545788.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bea7dea_1d33&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153231175-1637418471.png&quot; alt=&quot;image_5bea7dea_1d33&quot; width=&quot;577&quot; height=&quot;633&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;可以看得出来，下图的形式中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只需要修改一行代码，就可以做到整个产品族的切换&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153231379-2095352519.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bea7deb_1e9b&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153231710-1759155541.png&quot; alt=&quot;image_5bea7deb_1e9b&quot; width=&quot;485&quot; height=&quot;166&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;使用场景&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;抽象工厂模式，是工厂模式的进一步抽象，可以创建多个层级结构的产品&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;抽象工厂模式是将工厂模式拓展到他的产品族中，不再是仅仅创建同一个产品，而是创建一个“族”&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;当系统中有多于一个的产品族，而且，系统在某刻只是消费其中某个产品族&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;也就是同属于同一个产品族中的产品 会在一起工作使用&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种场景下，比较适合抽象工厂模式&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;比如上面的例子，KFC和MCDonalds都有鸡腿和汉堡，你去了KFC点餐那就是KFC的鸡腿和汉堡&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在KFC的“工厂”中，你调用鸡腿和汉堡方法，获得鸡腿和汉堡&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果你想要KFC的鸡腿和MCDonalds的汉堡的话&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你或许就是如下这种形式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Factory factory1 = new KFC();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;KFC.鸡腿；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Factory factory2 = new MCDonalds();&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MCDonalds.汉堡；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是上面这种形式，需要两个工厂，这样也是可以的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;但是你&lt;span&gt;&lt;strong&gt;应该避免胡乱随便的产品等级结构混杂在一起使用抽象工厂模式&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之所以是创建了一个产品族，而不是任意八竿子打不着的产品中 ， 是因为： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果产品等级结构变得更多，完全没有产品族的概念，比如水果、蔬菜、主板、显示器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他们没有产品族的概念，也更不会一起使用，每种产品等级结构都下属很多类型 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你像刚才那样KFC的鸡腿和MCDonalds的汉堡 混搭的话&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可能使用时，要创建多个工厂实例，每个工厂到底生产什么怕是自己都要混乱了，因为他们不是产品族，不成体系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还不如针对于每种产品等级结构一个单独的工厂模式更加条理清晰，混搭完全不符合单一职责原则&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;简单想下两种场景就可以理解，比如海尔生产 冰箱洗衣机电视机微波炉等等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些产品是同一个产品族，都是海尔XXX&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;哪怕有美的XX 西门子XX你都不会凌乱&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是如果A厂生产 苹果 土豆 A主板 A显示器 A显卡&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另一个B厂生产橘子 白菜 B主板 B显示器  B显卡&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另一个C厂生产水蜜桃 茄子 C主板 C显示器  C显卡&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当你需要苹果白菜茄子A主板B显示器C显卡时会不会凌乱？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;所以说，想要使用抽象工厂模式，一定要理清楚产品的层级结构体系以及产品族的概念&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;如果根本没有产品族的概念，那么不适合使用抽象工厂模式，你或许应该考虑多个不同的工厂方法模式&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;与工厂方法模式 最直白的差异就在于：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;抽象工厂方法可以创建整个产品族，而工厂方法仅仅只能创建一种等级结构的产品&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当你需要使用创建型模式的时候，如果你需要选择工厂模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么你应该最先考虑简单工厂模式的形式，尽管他简单到都不算是一种模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果简单工厂模式不能胜任，产品等级结构过于复杂或者业务逻辑复杂，可以考虑使用工厂方法模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当产品等级结构很多，势必会出现过多的工厂方法模式，也就是过多的工厂&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么，如果这些产品中，能够组合成产品族的概念&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则可以应用抽象工厂模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;换句话说，当你需要创建不同的等级产品结构时，可以考虑抽象工厂模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从这一点看，抽象工厂模式不就是工厂模式的进一步延伸扩展嘛&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;抽象工厂的核心就在于抽象工厂角色，创建了所有类型的抽象产品&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;抽象工厂角色创建的就是一族的抽象产品角色，就是每种抽象产品角色创建一个&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有多少个产品等级结构，他就有几个方法创建对应的产品&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以必然，所有的实现类，都能够创建所有的产品类型，也就是创建的功能拓展到了产品族&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面的结构图中，没有画红色的两条，画上可能更好理解&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153232074-1139314509.png&quot;&gt;&lt;span&gt;&lt;img title=&quot;image_5bea7deb_6e98&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153232352-523300414.png&quot; alt=&quot;image_5bea7deb_6e98&quot; width=&quot;915&quot; height=&quot;643&quot; border=&quot;0&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;抽象工厂模式，与产品族的概念息息相关，必须要理解产品族的概念&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;产品族的概念并不是严格的必须是同一品牌或者同一厂家这般强关联&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;但是他们必须是有所关联，也就是有共同的约束，比如在同一个操作系统上使用&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;只有你找到了某种关联约束，可以组织成产品族，也就是前文中的产品族的产品会一起工作&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;那么才可以使用抽象工厂，一定不要毫无关联而且也不是一起使用的产品等级结构放置在一起&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;还要确保产品等级结构不会轻易发生变化&lt;/strong&gt;&lt;/span&gt;，否则，时常变动那么就意味着相关的工厂角色都需要频繁的修改&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是不能忍受的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果结构图中，去掉ProductB，这看起来是不是就是工厂模式？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说相对于工厂模式，抽象工厂模式最直观的变化就是，将工厂的能力范围扩展到了产品族上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个工厂可以创建同一个产品族的多种产品&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153232815-845723144.png&quot;&gt;&lt;img title=&quot;image_5bea7deb_dab&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201811/897393-20181113153233044-1928119960.png&quot; alt=&quot;image_5bea7deb_dab&quot; width=&quot;873&quot; height=&quot;313&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;div readability=&quot;31&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;扩展产品族&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果增加新的产品族时，也就是层级结构不变，但是每种产品结构下面具体产品变多了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如Fruit下面多了一个Banana香蕉    Vegetable 下面多了个  Carrot 胡萝卜&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就需要增加一个具体的工厂，用于生产制造Banana 和 Carrot  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于其他的代码，则不需要任何修改，满足开闭原则的要求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;扩展产品等级结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果增加新的产品等级，比如Fruit Vegetable 又增加了一个肉类Meat 有羊肉牛肉等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怎么办？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么，我们需要从抽象工厂角色Creator就开始增加一个方法用于创建肉类 Meat createMeat（）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最顶级的抽象角色新增了方法，也就意味着所有的具体工厂，这些实现类，都需要随之变动&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扩展等级结构，显然是致命的！完全不符合开闭原则，这是他的一大缺点&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;看得出来，&lt;span&gt;&lt;strong&gt;抽象工厂模式在扩展方面向产品族的扩展倾斜&lt;/strong&gt;&lt;/span&gt;，给产品族的扩展提供了方便&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是在扩展产品等级结构时，却无法提供便利，所以适用于产品等级结构不太会变动的场景&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;



</description>
<pubDate>Tue, 13 Nov 2018 07:47:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>抽象工厂模式简介,介绍了抽象工厂模式意图,结构,产品族以及产品等级的概念,并且提供了代码示例java版抽象工厂模式,抽象工厂模式与工厂模式的对比差异</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/9952480.html</dc:identifier>
</item>
<item>
<title>Elasticsearch.Net 官网示例的坑 - 清蒸土豆细丝</title>
<link>http://www.cnblogs.com/Rawls/p/9952586.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rawls/p/9952586.html</guid>
<description>&lt;p&gt;　　经过昨天的ElasticSearch 安装，服务以及可以启动了，接下来就可以开发了，找到了官网提供的API以及示例，Es 官方提供的.net 客户端有两个版本一个低级版本： 【Elasticsearch.Net.dll】这个dll文件官方解释无依赖关系的客户端，对于您如何构建和表示您的请求和相应没有任何意见；它足够抽象，因此所有的ElasticSearch API端点都表示为方法，不会妨碍你构建json、reque、response 对象方式，它还带有内置的，可配置、可覆盖的集群故障转移、重试机制。&lt;/p&gt;
&lt;p&gt;　　另一个高级版本： 【Nest.dll】 是一个高级客户端、具有映射所有请求和响应对象的优势，附带强类型查询DSL，并利用特定的.Net功能，如协变结果和POCO的自动映射；Nest内部包含了Elastic.net 版本；&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/404126/201811/404126-20181113153936800-33132652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后两个DLL文件的安装命令如下：&lt;/p&gt;
&lt;p&gt;　　安装ElasticSearch.net.dll命令：Install-Package Elasticsearch.Net&lt;/p&gt;
&lt;p&gt;　　安装nest.dll命令：Install-Package NEST&lt;/p&gt;

&lt;p&gt;命令运行之后，&lt;span&gt;vs 会下载最新版本的dall文件，一定要注意版本号，这个就是后面的大坑，自己好不容易爬出来&lt;/span&gt;；&lt;/p&gt;

&lt;p&gt;然后，就开始代码编写了，怎么写？难道写个“hello，word”？NO，NO，刚接触，没办法，只有去抄了，去哪里抄，当然是官网了，官网示例：&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/client/net-api/5.x/elasticsearch-net-getting-started.html&quot;&gt;https://www.elastic.co/guide/en/elasticsearch/client/net-api/5.x/elasticsearch-net-getting-started.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;，在抄的过程中，一定要理解并加以思考，在实际项目里面灵活运用。&lt;/p&gt;

&lt;p&gt;为了操作方便，先弄一个Winfrom 程序，拉一个窗体，再来个按钮，触发个Click事件，然后，在添加引用，把刚刚下载的两个Dll文件添加到项目中；好了，一切准备就绪，开始上菜了！&lt;/p&gt;

&lt;p&gt;代码就不贴了，都是官网示例中的代码；&lt;/p&gt;
&lt;p&gt;然后，程序就还没有运行，就报错了，这心情，我擦，这可是刚起步，这可是完全按照官网示例去写的，竟然报错！！！&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/404126/201811/404126-20181113154018443-874268446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;错误提示：&lt;span&gt;people 无法转换为 “Elasticsearch.Net.IndexRequestParameters ”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/404126/201811/404126-20181113154043693-363565967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就各种途径找解决方案，中午吃饭的时候还在想，这官网真坑，案例都是错的，最后，在浏览官网的时候注意到一个东西，就是菜单选项。.NET API 版本号&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/404126/201811/404126-20181113154107946-31276200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;心想，会不会跟版本号有关系，反正找不到解决方法，只有试一试了，然后又去看了下，下载的dll文件；&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/404126/201811/404126-20181113154129373-294740486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这下，肯定了我的想法，下载的dll版本是6.4.0 的，看的官网示例是5.X 的；&lt;/p&gt;

&lt;p&gt;然后，把官网示例切换到6.X，然后把官网代码照着写了一遍，然后可以可以成功运行了；来看下运行后的数据结果(插入数据的代码示例)；&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/404126/201811/404126-20181113154156576-1405440279.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至此，算是入门了，折腾了那么久，一定要写篇博客记录下，以免别人也遇到这种事情；&lt;/p&gt;
</description>
<pubDate>Tue, 13 Nov 2018 07:45:00 +0000</pubDate>
<dc:creator>清蒸土豆细丝</dc:creator>
<og:description>经过昨天的ElasticSearch 安装，服务以及可以启动了，接下来就可以开发了，找到了官网提供的API以及示例，Es 官方提供的.net 客户端有两个版本一个低级版本： 【Elasticsearc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Rawls/p/9952586.html</dc:identifier>
</item>
<item>
<title>浅析微信支付：如何使用沙箱环境测试 - YClimb</title>
<link>http://www.cnblogs.com/yclimb/p/9952440.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yclimb/p/9952440.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文是【浅析微信支付】系列文章的第十篇，主要讲解如何使用沙箱环境来测试微信支付。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;浅析微信支付系列已经更新十篇了哟～，没有看过的朋友们可以看一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/XCR1Ts-uabuC573_vLb3Qg&quot;&gt;浅析微信支付：下载对账单和资金账单&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/IyWjWB__-VsqKO8SL0DL3Q&quot;&gt;浅析微信支付：申请退款、退款回调接口、查询退款&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/SG4sTHsUKKJF-_Qgpjh0jA&quot;&gt;浅析微信支付：查询订单和关闭订单&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Zr3ldgsMIg_cBrtuS2c7_g&quot;&gt;浅析微信支付：支付结果通知&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在实际开发中，通常我们都是在开发环境中开发，本地环境也有很多限制，比如：微信支付无法调起、H5链接需要鉴权、支付结果通知需要外网等。&lt;/p&gt;
&lt;p&gt;面对以上的问题，微信官方给出了解决的方法，就是咋们这篇文章的 &lt;code&gt;沙箱环境&lt;/code&gt;，也就是微信支付的官方测试环境，这个环境能做些什么呢？我觉得最重要的一点就是我们可以实时根据官方的例子调用对应的接口，并且接口会马上返回结果，拿微信支付预支付单接口来说，调用以后会实时返回我们支付的相关信息，这样就免于开发时不知道返回结果而苦恼。&lt;/p&gt;
&lt;h3 id=&quot;仿真测试系统&quot;&gt;仿真测试系统&lt;/h3&gt;
&lt;p&gt;为降低商户测试门槛，微信支付团队开发了一套独立的仿真测试系统。该系统根据验收用例金额的不同返回不同的响应报文，以满足商户正常功能测试、安全/异常测试及性能测试的需求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181113151727607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lDbGltYg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;微信支付仿真测试系统1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1为微信支付仿真测试系统（后简称仿真系统）的简化原理图。仿真系统的API协议与正式API完全相同（API接口文档）。商户开发者只需将正式API的调用URL增加一层&lt;code&gt;sandboxnew&lt;/code&gt;路径，即可对接到仿真系统。&lt;/p&gt;
&lt;p&gt;例如，刷卡支付URL：https://api.mch.weixin.qq.com/pay/micropay&lt;br/&gt;变更为：https://api.mch.weixin.qq.com/sandboxnew/pay/micropay。&lt;/p&gt;
&lt;p&gt;仿真系统与生产环境完全独立，包括存储层。商户在仿真系统所做的所有交易（如下单、支付、查询）均为无资金流的假数据，即：用户无需真实扣款，商户也不会有资金入账。代金券同理，沙箱环境中无需商户真实制券与发券，亦不会出现真实扣券情况。验收仿真测试系统的API验签密钥需从API获取:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181113151758217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lDbGltYg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;仿真测试系统的API验证签名&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;源码交互过程&quot;&gt;源码&amp;amp;交互过程&lt;/h3&gt;
&lt;p&gt;以下为微信官方的&lt;code&gt;仿真测试系统&lt;/code&gt;文档：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=23_1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面说明具体的交互过程和相关的仿真测试系统的API验证签名，为什么需要这个签名接口呢？这是因为使用 &lt;code&gt;沙箱环境&lt;/code&gt; 时使用的是真实的&lt;code&gt;商户号&lt;/code&gt;、&lt;code&gt;小程序/公众号APP_ID&lt;/code&gt;，但是 &lt;code&gt;API密钥&lt;/code&gt;这个参数必须使用 &lt;code&gt;沙箱环境&lt;/code&gt; 的 &lt;code&gt;sandbox_signkey&lt;/code&gt;，此接口主要是取得这个参数。&lt;/p&gt;
&lt;p&gt;注：仿真测试环境中的商户号（父子商户号）需使用真实商户号。&lt;/p&gt;
&lt;p&gt;下面为取得 &lt;code&gt;sandbox_signkey&lt;/code&gt;的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 获取沙盒 sandbox_signkey
 *
 * @author yclimb
 * @date 2018/9/18
 */
private void doGetSandboxSignKey() throws Exception {
    WXPayConfigImpl config = WXPayConfigImpl.getInstance();
    HashMap&amp;lt;String, String&amp;gt; data = new HashMap&amp;lt;String, String&amp;gt;();
    // 商户号
    data.put(&quot;mch_id&quot;, config.getMchID());
    // 获取随机字符串
    data.put(&quot;nonce_str&quot;, WXPayUtil.generateNonceStr());
    // 生成签名
    String sign = WXPayUtil.generateSignature(data, config.getKey());
    data.put(&quot;sign&quot;, sign);
    
    // 得到 sandbox_signkey
    WXPay wxPay = new WXPay(config);
    String result = wxPay.requestWithoutCert(&quot;/sandboxnew/pay/getsignkey&quot;, data, 10000, 10000);
    System.out.println(result);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小伙伴可以根据 &lt;code&gt;result&lt;/code&gt; 来获取具体的返回数据，解析之后获取 &lt;code&gt;sandbox_signkey&lt;/code&gt;参数。&lt;/p&gt;
&lt;p&gt;商户接入仿真系统的交互流程示例：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;商户发起刷卡支付请求，使用POST方式调用 https://api.mch.weixin.qq.com/sandboxnew/pay/micropay&lt;/li&gt;
&lt;li&gt;带sandboxnew 的https请求会被nginx路由到仿真系统。仿真系统根据支付金额（total_fee字段）返回预期报文给商户。同时，落地该笔请求数据；&lt;/li&gt;
&lt;li&gt;商户发起查单，调用 https://api.mch.weixin.qq.com/sandboxnew/pay/orderquery，带上微信订单号（transaction_id）或商户内部单号（out_trade_no）；&lt;/li&gt;
&lt;li&gt;仿真系统收到查单请求后，根据单号及金额返回预期的查单结果给商户；&lt;/li&gt;
&lt;li&gt;商户下载对账单，调用 https://api.mch.weixin.qq.com/sandboxnew/pay/downloadbill ，仿真系统返回固定的账单格式给商户。注：账单内容不一定与商户在仿真系统产生的交易完全相同。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;沙箱说明：sandbox/sandboxnew&lt;br/&gt;微信支付沙箱环境，是提供给微信支付商户的开发者，用于模拟支付及回调通知。以验证商户是否理解回调通知、账单格式，以及是否对异常做了正确的处理。&lt;br/&gt;◆ 如何对接沙箱环境？&lt;br/&gt;1、修改商户自有程序或配置中，微信支付api的链接，如：被扫支付官网的url为：https://api.mch.weixin.qq.com/pay/micropay 增加sandboxnew路径，变更为https://api.mch.weixin.qq.com/sandboxnew/pay/micropay ， 即可接入沙箱验收环境，其它接口类似；&lt;br/&gt;2、在微信支付开发调试站点（站点链接：http://mch.weixin.qq.com/wiki/doc/api/index.php ），按接口文档填入正确的支付参数，发起微信支付请求，完成支付；&lt;br/&gt;3、验收完成后，修改程序或配置中的api链接（重要！），去掉sandboxnew路径。对接现网环境。&lt;/p&gt;
&lt;p&gt;说明地址：&lt;br/&gt;https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=23_1&lt;br/&gt;https://pay.weixin.qq.com/wiki/doc/api/app/app.php?chapter=21_2&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;其实 &lt;code&gt;沙箱环境&lt;/code&gt;主要是为了方便在开发时及时获得接口返回值和进行 &lt;code&gt;商户支付验收&lt;/code&gt;使用，本文讲了如何获取 &lt;code&gt;sandbox_signkey&lt;/code&gt;参数，然后如何进行模拟对接，在实际接口URL后增加 &lt;code&gt;sandboxnew&lt;/code&gt; 即可，接口会实时返回结果参数，此点于正式环境不同（正式环境支付后是异步调用，沙箱环境是实时返回）。&lt;/p&gt;
&lt;p&gt;注意：有的接口沙箱环境的接口并不只是在链接中增加 &lt;code&gt;sandboxnew&lt;/code&gt;，整个链接都会改变，在实际操作中我们应该查看官方文档一一对照，如支付退款接口，正式线接口为：&lt;code&gt;/secapi/pay/refund&lt;/code&gt;，而沙箱环境接口为：&lt;code&gt;/sandboxnew/pay/refund&lt;/code&gt;，在沙箱环境中去掉了 &lt;code&gt;secapi&lt;/code&gt; 这一路径，请小伙伴一定要注意。&lt;/p&gt;
&lt;p&gt;预告：为了更好的验证微信支付安全性，我们需要接入微信的 &lt;code&gt;验收测试&lt;/code&gt;，下一篇文章 &lt;code&gt;支付验收示例和验收指引&lt;/code&gt; 为大家讲解，敬请期待！！！&lt;/p&gt;
&lt;p&gt;​如果想要提前一览源码的小伙伴，可以先看看我的 github，地址如下：&lt;br/&gt;​&lt;br/&gt;​&lt;code&gt;​https://github.com/YClimb/wxpay-sdk/blob/master/README.md ​&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;加作者私人微信，作者微信号如下 &lt;code&gt;yclimb&lt;/code&gt;，标明 &lt;code&gt;微信支付&lt;/code&gt; 可拉入微信支付讨论群与小伙伴一起探讨哦，一定要标明 &lt;code&gt;微信支付&lt;/code&gt; 哦～&lt;/p&gt;
&lt;p&gt;到此本文就结束了，关注公众号查看更多推送！！！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180130111432962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWUNsaW1i/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;关注我的公众号&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Tue, 13 Nov 2018 07:27:00 +0000</pubDate>
<dc:creator>YClimb</dc:creator>
<og:description>本文是【浅析微信支付】系列文章的第十篇，主要讲解如何使用沙箱环境来测试微信支付。 浅析微信支付系列已经更新十篇了哟～，没有看过的朋友们可以看一下。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yclimb/p/9952440.html</dc:identifier>
</item>
<item>
<title>【由浅至深】redis 实现发布订阅的几种方式 - nicye</title>
<link>http://www.cnblogs.com/kellynic/p/9952386.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kellynic/p/9952386.html</guid>
<description>&lt;p&gt;非常感谢&lt;a href=&quot;https://www.cnblogs.com/yilezhu&quot;&gt;依乐祝&lt;/a&gt;发表文章&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9947905.html&quot;&gt;《.NET Core开发者的福音之玩转Redis的又一傻瓜式神器推荐》&lt;/a&gt;，对csredis作了一次完整的诠释。&lt;/p&gt;

&lt;p&gt;提到消息队列，最熟悉无疑是 rabbitmq，它基本是业界标准的解决方案。本文详细介绍 redis 多种实现轻订阅方法，作者认为非常有趣并加以总结，希望对有需要的朋友学习 redis 功能有一定的带入作用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201811/31407-20181113141142452-1709263635.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;//程序1：使用代码实现订阅端
var sub = RedisHelper.Subscribe((&quot;chan1&quot;, msg =&amp;gt; Console.WriteLine(msg.Body)));
//sub.Disponse(); //停止订阅

//程序2：使用代码实现发布端
RedisHelper.Publish(&quot;chan1&quot;, &quot;111&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优势：支持多端订阅、简单、性能高；&lt;br/&gt;缺点：数据会丢失；&lt;/p&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;http://doc.redisfans.com/pub_sub/subscribe.html&quot; class=&quot;uri&quot;&gt;http://doc.redisfans.com/pub_sub/subscribe.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201811/31407-20181113141746858-1591168835.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;//程序1：使用代码实现订阅端
while (running) {
    try {
        var msg = RedisHelper.BLPop(5, &quot;list1&quot;);
        if (string.IsNullOrEmpty(msg) == false) {
            Console.WriteLine(msg);
        }
    } catch (Exception ex) {
        Console.WriteLine(ex.Message);
    }
}

//程序2：使用代码实现发布端
RedisHelper.LPush(&quot;list1&quot;, &quot;111&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;优势：数据不会丢失、简单、性能高；&lt;br/&gt;缺点：不支持多端（存在资源争抢）；&lt;/p&gt;
&lt;p&gt;总结：为了解决方法一的痛点，我们实现了本方法，并且很漂亮的制造了一个新问题（不支持多端订阅）。&lt;/p&gt;
&lt;h2 id=&quot;学习使用-blpop&quot;&gt;学习使用 BLPOP&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;BLPOP key [key ...] timeout&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;BLPOP 是列表的阻塞式(blocking)弹出原语。&lt;/p&gt;
&lt;p&gt;它是 LPOP 命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被 BLPOP 命令阻塞，直到等待超时或发现可弹出元素为止。&lt;/p&gt;
&lt;p&gt;当给定多个 key 参数时，按参数 key 的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。&lt;/p&gt;
&lt;h3 id=&quot;非阻塞行为&quot;&gt;非阻塞行为&lt;/h3&gt;
&lt;p&gt;当 BLPOP 被调用时，如果给定 key 内至少有一个非空列表，那么弹出遇到的第一个非空列表的头元素，并和被弹出元素所属的列表的名字一起，组成结果返回给调用者。&lt;/p&gt;
&lt;p&gt;当存在多个给定 key 时， BLPOP 按给定 key 参数排列的先后顺序，依次检查各个列表。&lt;/p&gt;
&lt;p&gt;假设现在有 job 、 command 和 request 三个列表，其中 job 不存在， command 和 request 都持有非空列表。考虑以下命令：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;BLPOP job command request 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;BLPOP 保证返回的元素来自 command ，因为它是按”查找 job -&amp;gt; 查找 command -&amp;gt; 查找 request “这样的顺序，第一个找到的非空列表。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;redis&amp;gt; DEL job command request           # 确保key都被删除
(integer) 0

redis&amp;gt; LPUSH command &quot;update system...&quot;  # 为command列表增加一个值
(integer) 1

redis&amp;gt; LPUSH request &quot;visit page&quot;        # 为request列表增加一个值
(integer) 1

redis&amp;gt; BLPOP job command request 0       # job 列表为空，被跳过，紧接着 command 列表的第一个元素被弹出。
1) &quot;command&quot;                             # 弹出元素所属的列表
2) &quot;update system...&quot;                    # 弹出元素所属的值&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;阻塞行为&quot;&gt;阻塞行为&lt;/h3&gt;
&lt;p&gt;如果所有给定 key 都不存在或包含空列表，那么 BLPOP 命令将阻塞连接，直到等待超时，或有另一个客户端对给定 key 的任意一个执行 LPUSH 或 RPUSH 命令为止。&lt;/p&gt;
&lt;p&gt;超时参数 timeout 接受一个以秒为单位的数字作为值。超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely) 。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;redis&amp;gt; EXISTS job                # 确保两个 key 都不存在
(integer) 0
redis&amp;gt; EXISTS command
(integer) 0

redis&amp;gt; BLPOP job command 300     # 因为key一开始不存在，所以操作会被阻塞，直到另一客户端对 job 或者 command 列表进行 PUSH 操作。
1) &quot;job&quot;                         # 这里被 push 的是 job
2) &quot;do my home work&quot;             # 被弹出的值
(26.26s)                         # 等待的秒数

redis&amp;gt; BLPOP job command 5       # 等待超时的情况
(nil)
(5.66s)                          # 等待的秒数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多学习资料：&lt;a href=&quot;http://doc.redisfans.com/list/blpop.html&quot; class=&quot;uri&quot;&gt;http://doc.redisfans.com/list/blpop.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本方法根据方法二演变而来，设计图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/31407/201811/31407-20181113150753858-1137909712.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如何实现三端订阅，都可收到消息，三端分别为 sub3, sub4, sub5：&lt;/p&gt;
&lt;p&gt;1、sub3, sub4, sub5 使用【方法二】订阅 listkey：list1_sub3，list1_sub4，list1_sub5；&lt;/p&gt;
&lt;p&gt;2、总订阅端订阅 listkey：list1，总订阅端收到消息后，执行 lpush list1_sub1 msg， lpush list1_sub2 msg， lpush list1_sub3 msg；&lt;/p&gt;
&lt;p&gt;总订阅端订阅原始消息，随后将消息分发给其他订阅端，从而解决【方法二】不支持多端同时订阅的缺点。&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;nuget Install-Package CSRedisCore&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var rds = new CSRedis.CSRedisClient(&quot;127.0.0.1:6379,password=,poolsize=50,ssl=false,writeBuffer=10240&quot;);

//sub1, sub2 争抢订阅（只可一端收到消息）
var sub1 = rds.SubscribeList(&quot;list1&quot;, msg =&amp;gt; Console.WriteLine($&quot;sub1 -&amp;gt; list1 : {msg}&quot;));
var sub2 = rds.SubscribeList(&quot;list1&quot;, msg =&amp;gt; Console.WriteLine($&quot;sub2 -&amp;gt; list1 : {msg}&quot;));

//sub3, sub4, sub5 非争抢订阅（多端都可收到消息）
var sub3 = rds.SubscribeListBroadcast(&quot;list2&quot;, &quot;sub3&quot;, msg =&amp;gt; Console.WriteLine($&quot;sub3 -&amp;gt; list2 : {msg}&quot;));
var sub4 = rds.SubscribeListBroadcast(&quot;list2&quot;, &quot;sub4&quot;, msg =&amp;gt; Console.WriteLine($&quot;sub4 -&amp;gt; list2 : {msg}&quot;));
var sub5 = rds.SubscribeListBroadcast(&quot;list2&quot;, &quot;sub5&quot;, msg =&amp;gt; Console.WriteLine($&quot;sub5 -&amp;gt; list2 : {msg}&quot;));

//sub6 是redis自带的普通订阅
var sub6 = rds.Subscribe((&quot;chan1&quot;, msg =&amp;gt; Console.WriteLine(msg.Body)));

Console.ReadKey();
sub1.Dispose();
sub2.Dispose();
sub3.Dispose();
sub4.Dispose();
sub5.Dispose();
sub6.Dispose();

rds.Dispose();
return;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试功能时，发布端可以使用 redis-cli 工具。&lt;/p&gt;

&lt;p&gt;redis 功能何其多且相当好玩有趣 ，大家应尽可能多带着兴趣爱好去学习它。&lt;/p&gt;
&lt;p&gt;若文中有不好的地方，请提出批评与改正方法，谢谢观赏。&lt;/p&gt;
&lt;p&gt;本文使用到 CSRedisCore 的开源地址：&lt;a href=&quot;https://github.com/2881099/csredis&quot; class=&quot;uri&quot;&gt;https://github.com/2881099/csredis&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 13 Nov 2018 07:19:00 +0000</pubDate>
<dc:creator>nicye</dc:creator>
<og:description>非常感谢</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kellynic/p/9952386.html</dc:identifier>
</item>
<item>
<title>kubernetes实战(八)：k8s集群安全机制RBAC - 杜先生的博客</title>
<link>http://www.cnblogs.com/dukuan/p/9948063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dukuan/p/9948063.html</guid>
<description>&lt;p&gt;1、基本概念&lt;/p&gt;
&lt;p&gt;　　RBAC(Role-Based Access Control，基于角色的访问控制)在k8s v1.5中引入，在v1.6版本时升级为Beta版本，并成为kubeadm安装方式下的默认选项，相对于其他访问控制方式，新的RBAC具有如下优势：&lt;/p&gt;
&lt;p&gt;　　- 对集群中的资源和非资源权限均有完整的覆盖&lt;/p&gt;
&lt;p&gt;　　  整个RBAC完全由几个API对象完成，同其他API对象一样，可以用kubectl或API进行操作&lt;/p&gt;
&lt;p&gt;　　  可以在运行时进行调整，无需重启API Server&lt;/p&gt;
&lt;p&gt;　　要使用RBAC授权模式，需要在API Server的启动参数中加上--authorization-mode=RBAC&lt;/p&gt;

&lt;p&gt;2、RBAC原理和用法&lt;/p&gt;
&lt;p&gt;2.1 RBAC的API资源对象说明&lt;/p&gt;
&lt;p&gt;　　RBAC引入了4个新的顶级资源对象：Role、ClusterRole、RoleBinding、ClusterRoleBinding。同其他API资源对象一样，用户可以使用kubectl或者API调用等方式操作这些资源对象。&lt;/p&gt;
&lt;p&gt;　　- 角色(Role)&lt;/p&gt;
&lt;p&gt;　　  一个角色就是一组权限的集合，这里的权限都是许可形式的，不存在拒绝的规则。在一个命名空间中，可以用角色来定义一个角色，如果是集群级别的，就需要使用ClusterRole了。&lt;/p&gt;
&lt;p&gt;　　  角色只能对命名空间内的资源进行授权，下面的例子中定义的角色具备读取Pod的权限：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;kind: Role
apiVersion: rbac.authorization.k8s.io&lt;/span&gt;/&lt;span&gt;v1betal
metadata:
    namespace: default
    name: pod&lt;/span&gt;-&lt;span&gt;reader

rules:
&lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;]  # 空字符串表示核心API群
  resource: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pods&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;watch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　  rules中的参数说明：&lt;/p&gt;
&lt;p&gt;　　  - apiGroup：支持的API组列表，例如：APIVersion: batch/v1、APIVersion: extensions:v1betal、apiVersion:apps/v1betal等&lt;/p&gt;
&lt;p&gt;　　    resources：支持的资源对象列表，例如：pods、deployments、jobs等&lt;/p&gt;
&lt;p&gt;　　    verbs：对资源对象的操作方法列表，例如：get、watch、list、delete、replace、patch等&lt;/p&gt;

&lt;p&gt;　　- 集群角色(ClusterRole)&lt;/p&gt;
&lt;p&gt;　　  集群角色除了具有和角色一致的命名空间内资源的管理能力，因其集群级别的范围，还可以用于以下特殊元素的授权。&lt;/p&gt;
&lt;p&gt;　　  - 集群范围的资源，例如Node&lt;/p&gt;
&lt;p&gt;　　    非资源型的路径，例如/healthz&lt;/p&gt;
&lt;p&gt;　　    包含全部命名空间的资源，例如pods&lt;/p&gt;
&lt;p&gt;　　  下面的集群角色可以让用户有权访问任意一个或所有命名空间的secrets：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;kind: ClusterRole
apiVersion: rbac.authorization.k8s.io&lt;/span&gt;/&lt;span&gt;v1betal
metadata:&lt;br/&gt;# name: secret-reader
  # ClusterRole不受限于命名空间，所以省略了namespace name的定义

rules:
&lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;]
  resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secrets&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;watch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　- 角色绑定(RoleBinding)和集群角色绑定(ClusterRoleBinding)&lt;/p&gt;
&lt;p&gt;　　  角色绑定或集群角色绑定用来把一个角色绑定到一个目标上，绑定目标可以是User、Group或者Service Account。使用RoleBinding为某个命名空间授权，ClusterRoleBinding为集群范围内授权。&lt;/p&gt;
&lt;p&gt;　　  RoleBinding可以引用Role进行授权，下例中的RoleBinding将在default命名空间中把pod-reader角色授予用户jane，可以让jane用户读取default命名空间的Pod：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;kind: RoleBinding
apiVersion: rbac.authorization.k8s.io&lt;/span&gt;/&lt;span&gt;v1betal
metadata:
  name: read&lt;/span&gt;-&lt;span&gt;pods
  namespace: default

subjects:
&lt;/span&gt;-&lt;span&gt; kind: User
  name: jane
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: pod&lt;/span&gt;-&lt;span&gt;reader
  apiGroup: rbac.authorization.k8s.io&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　  RoleBinding也可以引用ClusterRole，对属于同一命名空间内ClusterRole定义的资源主体进行授权。一种常见的做法是集群管理员为集群范围预先定义好一组角色(ClusterRole)，然后在多个命名空间中重复使用这些ClusterRole。&lt;/p&gt;
&lt;p&gt;　　  使用RoleBinding绑定集群角色secret-reader，使dave只能读取development命名空间中的secret：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;kind: RoleBinding
apiVersion: rbac.authorization.k8s.io&lt;/span&gt;/&lt;span&gt;v1betal
metadata:
  name: read&lt;/span&gt;-&lt;span&gt;secrets
  namespace: development

subjects:
&lt;/span&gt;-&lt;span&gt; kind: User
  name: dave
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: secret&lt;/span&gt;-&lt;span&gt;reader
  apiGroup: rbac.authorization.k8s.io&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　  集群角色绑定中的角色只能是集群角色，用于进行集群级别或者对所有命名空间都生效的授权。&lt;/p&gt;
&lt;p&gt;　　  允许manager组的用户读取任意namespace中的secret&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io&lt;/span&gt;/&lt;span&gt;v1betal
metadata:
  name: read&lt;/span&gt;-secrets-&lt;span&gt;global
subjects:
&lt;/span&gt;-&lt;span&gt; kind: Group
  name: manager
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: secret&lt;/span&gt;-&lt;span&gt;reader
  apiGroup: rbac.authorization.k8s.io&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.2 对资源的引用方式&lt;/p&gt;
&lt;p&gt;　　多数资源可以用其名称的字符串来表达，也就是Endpoint中的URL相对路径，例如pods。然后，某些Kubernetes API包含下级资源，例如Pod的日志(logs)。Pod日志的Endpoint是GET /api/v1/namespaces/{namespaces}/pods/{name}/log。&lt;/p&gt;
&lt;p&gt;　　Pod是一个命名空间内的资源，log就是一个下级资源。要在一个RBAC角色中体现，则需要用斜线/来分割资源和下级资源。若想授权让某个主体同时能够读取Pod和Pod log，则可以配置resources为一个数组：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;kind: Role
apiVersion: rbac.authorization.k8s.io&lt;/span&gt;/&lt;span&gt;v1betal
metadata:
  namespace: default
  name: pod&lt;/span&gt;-and-pod-logs-&lt;span&gt;reader
rules:
&lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;]
  resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pods&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pods/log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　资源还可以通过名字(ResourceName)进行引用。在指定ResourceName后，使用get、delete、update、patch动词的请求，就会被限制在这个资源实例范围内。例如下面的声明让一个主体只能对一个叫my-configmap的configmap进行get和update操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;kind: Role
apiVersion: rbac.authorization.k8s.io&lt;/span&gt;/&lt;span&gt;v1betal
metadata:
  namespace: default
  name: configmap&lt;/span&gt;-&lt;span&gt;updater
rules:
&lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;]
  resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;configmap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  resourceNames: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my-configmap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.3 常见的角色(Role)示例&lt;/p&gt;
&lt;p&gt;　　- 允许读取核心API组中Pod的资源：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;rules:
&lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;]
  resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pods&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;watch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　- 允许读写&quot;extensions&quot;和&quot;apps&quot;两个API组中的deployment资源&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;rules:
&lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;extensions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apps&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;deployments&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;watch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;patch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　- 允许读写pods及读写jobs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;rules:
&lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;]
  resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pods&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;watch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;batch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;extensions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jobs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]&lt;br/&gt;&lt;/span&gt;  verbs: [&quot;get&quot;, &quot;list&quot;, &quot;watch&quot;, &quot;create&quot;, &quot;update&quot;, &quot;patch&quot;, &quot;delete&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　- 允许读取一个名为my-config的ConfigMap(必须绑定到一个RoleBinding来限制到一个namespace下的ConfigMap)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;rules:
&lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;]
  resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;configmaps&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  resourceNames: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my-config&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　- 读取核心组的node资源(Node属于集群级别的资源，必须放在ClusterRole中，并使用ClusterRoleBinding进行绑定)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;rules:
&lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;]
  resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nodes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;watch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　- 允许对非资源端点/healthz及其所有子路径进行GET/POST操作(必须使用ClusterRole和ClusterRoleBinding)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;rules:
&lt;/span&gt;- nonResourceURLs: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/healthz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/healthz/*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.4 常用的角色绑定&lt;/p&gt;
&lt;p&gt;　　- 用户名Alice@example.com&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;subjects:
&lt;/span&gt;-&lt;span&gt; kind: User
  name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Alice@example.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  apiGroup: rbac.authorization.k8s.io&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　- 组名frontend-admins&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;subjects:
&lt;/span&gt;-&lt;span&gt; kind: Group
  name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;frontend-admins&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  apiGroup: rbac.authorization.k8s.io&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　- kube-system命名空间中的默认Service Account&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;subjects:
&lt;/span&gt;-&lt;span&gt; kind: ServiceAccount
  name: default
  namespace: kube&lt;/span&gt;-system
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　- qa命名空间中的所有Service Account&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;subjects:
&lt;/span&gt;-&lt;span&gt; kind: Group
  name: system:serviceaccounts:qa
  apiGroup: rbac.authorization.k8s.io&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　- 所有Service Account&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;subjects:
&lt;/span&gt;-&lt;span&gt; kind: Group
  name: system:serviceaccounts
  apiGroup: rbac.authorization.k8s.io&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　- 所有认证用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;subjects:
&lt;/span&gt;-&lt;span&gt; kind: Group
  name: system:authentication
  apiGroup: rbac.authorization.k8s.io&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　- 所有未认证用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;subjects:
&lt;/span&gt;-&lt;span&gt; kind: Group
  name: system:unauthentication
  apiGroup: rbac.authorization.k8s.io&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　- 全部用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;subjects:
&lt;/span&gt;-&lt;span&gt; kind: Group
  name: system:authentication
  apiGroup: rbac.authorization.k8s.io
&lt;/span&gt;-&lt;span&gt; kind: Group
  name: system:unauthentication
  apiGroup: rbac.authorization.k8s.io&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.5 默认的角色和角色绑定&lt;/p&gt;
&lt;p&gt;　　API Server会创建一套默认的ClusterRole和ClusterRoleBinding对象，其中很多是以system:为前缀的，以表明这些资源属于基础架构，对这些对象的改动可能造成集群故障。&lt;/p&gt;
&lt;p&gt;　　所有默认的ClusterRole和RoleBinding都会用标签kubernetes.io/bootstrapping=rbac-defaults进行标记。&lt;/p&gt;
&lt;p&gt;　　常见的系统角色如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201811/1095387-20181113140449696-135481995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　有些默认角色不是以system:为前缀的，这部分角色是针对用户的，其中包含超级用户角色cluster-admin，有的用于集群一级的角色cluster-status，还有针对namespace的角色admin、edit、view&lt;/p&gt;
&lt;p&gt;　　常见的用户角色如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201811/1095387-20181113140717649-48869429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　- 核心Master组件角色&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095387/201811/1095387-20181113141018211-786117712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2.6 授权注意事项：预防提权和授权初始化&lt;/p&gt;
&lt;p&gt;　　RBAC API拒绝用户利用编辑角色或者角色绑定的方式进行提权。这一限制是在API层面做出的，因此即使RBAC没有启用也仍然有效。&lt;/p&gt;
&lt;p&gt;　　用户只能在拥有一个角色的所有权限，且与该角色的生效范围一致的前提下，才能对角色进行创建和更新。例如用户user-1没有列出集群中所有secret的权限，就不能创建具有这一权限的集群角色。要让一个用户能够创建或更新角色，需要以下权限：&lt;/p&gt;
&lt;p&gt;　　- 为其授予一个允许创建/更新Role或ClusterRole资源对象的角色；&lt;/p&gt;
&lt;p&gt;　　  为用户授予角色，要覆盖该用户所能控制的所有权限范围。用户如果尝试创建超出其自身权限的角色或者集群角色，则该API调用会被禁止。&lt;/p&gt;
&lt;p&gt;　　如果一个用户的权限包含了一个角色的所有权限，那么就可以为其创建和更新角色绑定；或者如果被授予了针对某个角色的绑定授权，则也有权完成此操作。&lt;/p&gt;
&lt;p&gt;　　例如：user1没有列出集群内所有secret的权限，就无法为一个具有这样权限的角色创建集群角色绑定。要使用户能够创建、更新这一角色绑定，则需要有如下做法：&lt;/p&gt;
&lt;p&gt;　　- 为其授予一个允许创建和更新角色绑定或者集群角色绑定的角色&lt;/p&gt;
&lt;p&gt;　　  为其授予绑定某一角色的权限，有隐式或显式两种方法&lt;/p&gt;
&lt;p&gt;　　  - 隐式：让其具有所有该角色的权限&lt;/p&gt;
&lt;p&gt;　　  - 显式：让用户授予针对该角色或集群角色绑定操作的权限&lt;/p&gt;
&lt;p&gt;　　让user-1有对user-1-namespace命名空间中的其他用户授予admin、edit及view角色&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
apiVersion: rbac.authorization.k8s.io/&lt;span&gt;v1betal
kind: ClusterRole
metadata:
  name: role&lt;/span&gt;-&lt;span&gt;grantor
rules:
&lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rbac.authorization.k8s.io&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rolebindings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rbac.authorization.k8s.io&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clusterroles&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  resourceNames: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;edit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;---&lt;span&gt;
apiVersion: rbac.authorization.k8s.io&lt;/span&gt;/&lt;span&gt;v1betal
kind: RoleBinding
metadata:
  name: role&lt;/span&gt;-grantor-&lt;span&gt;binding
  namespace: user&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;namespace
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: role&lt;/span&gt;-&lt;span&gt;grantor
subjects:
&lt;/span&gt;-&lt;span&gt; apiGroup: rbac.authorization.k8s.io
  kind: User
  name: user&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在进行第一个角色和角色绑定时，必须让初始用户具备其尚未被授予的权限，要进行初始的角色和角色绑定设置，有以下两种方法：&lt;/p&gt;
&lt;p&gt;　　- 使用属于system:masters组的身份，这一群组默认具有cluster-admin这一超级角色的绑定。&lt;/p&gt;
&lt;p&gt;　　  如果API Server以--insecure-port参数运行，则客户端通过这个非安全端口进行接口调用，这一端口没有认证鉴权的限制。&lt;/p&gt;

</description>
<pubDate>Tue, 13 Nov 2018 07:12:00 +0000</pubDate>
<dc:creator>杜先生的博客</dc:creator>
<og:description>1、基本概念 RBAC(Role-Based Access Control，基于角色的访问控制)在k8s v1.5中引入，在v1.6版本时升级为Beta版本，并成为kubeadm安装方式下的默认选项，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dukuan/p/9948063.html</dc:identifier>
</item>
<item>
<title>Mach-O简介及实际应用 - 皮拉夫大王</title>
<link>http://www.cnblogs.com/dengzhuli/p/9952202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dengzhuli/p/9952202.html</guid>
<description>&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-ae1ee1dfb28bd818.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;

&lt;p&gt;    在正题开始之前，我们先来聊聊iOS中的hook技术。一谈到hook，很多人首先想到的是runtime，runtime确实强大，但是它存在很多局限性：&lt;/p&gt;
&lt;p&gt;1）、侵入性：一旦hook了某个类的方法，那么只能这个类的所有对象的方法都会被hook。&lt;/p&gt;
&lt;p&gt;2）、语言上的局限性：runtime 的hook 只能作用于OC方法。&lt;/p&gt;
&lt;p&gt;    开源框架Aspects很巧妙的解决了第一个问题，Aspects通过动态创建子类的方式将对当前类的hook转换为对当前类动态生成的子类的hook，以此避免对当前类其他对象的代码侵入，这与KVO的实现思路是一致的。而fishhook能从一定程度上辅助runtime解决hook对语言局限性的问题。&lt;/p&gt;

&lt;p&gt;    fishhook是Facebook开源的一个C语言的hook工具，我们可以使用fishhook来hook动态链接的C函数。为什么在这里要强调动态链接呢？因为fishhook只能hook iOS系统的C函数，你自己编写的C函数是无法hook的。&lt;/p&gt;
&lt;p&gt;    fishhook使用起来很简单，在这里就不谈了，先来简单介绍下fishhook的实现原理。由于动态库并不参与前期的静态编译链接，所以在程序的可执行文件中，代码段并不包含动态库相关函数的汇编后的指令。那么系统是如何根据函数的调用符号找到真实的函数地址呢？在Mach-O文件中存在符号表和动态符号表以及字符串表，字符串表中存储了所有的字符信息，比如代码int a = 100;这个变量a的名字即存在字符串表中。符号表则存储了所有符号位于字符串表中的位置信息，动态符号表存储了动态库符号位于符号表中的偏移信息。动态库的section中的reserved1存储了该section的偏移量X，动态符号表偏移X后即是该section的符号表索引数组Indices的首地址，以Indices数组中的值为索引，可以在符号表中获取到当前的符号在字符串表中的偏移，从而获取到符号字符串。通过该section的addr字段可以获取到该section的符号绑定表，表中记录着动态符号如：printf所对应的函数地址，修改符号绑定表的内容为指定函数地址即实现了hook。fishhook看起来非常的绕，这是由于动态链接存在复杂的索引关系，在这里就不过多介绍了，有兴趣的可以搜索下有关fishhook的博文，优秀博文非常多。&lt;/p&gt;
&lt;p&gt;    fishhook很厉害，但是在刚接触时我有两个疑问：1、fishhook能hook C++函数吗？在我的前篇文章中也提出了hook C++函数的问题，但是在留言中貌似没有得到有效的答案。2、fishhook 为什么不能hook自己写的C函数呢？下面我们来一一解答这两个问题。&lt;/p&gt;

&lt;p&gt;在程序员还是使用纸带写代码的时候，人们约定在指定的某几位代表指令，不同的0、1组合代表不同的指令。如：&lt;a target=&quot;_blank&quot;&gt;01000000&lt;/a&gt;中，0100代表跳转指令，后面的0000代表目标地址。由于汇编的出现，0100被用jump来代替，这就是最早的符号，符号表能映根据符号映射到一个指令。C语言也是与此类似，实际上我们也是通过一个符号来代表一个函数的地址，但是随着程序的不断变大，符号冲突的概率逐渐增加。一个程序员在一个.c文件实现了hello函数，可能另一个程序员在另一个.c文件中也实现了一个同名的hello函数，在这两个文件进行编译和汇编后，会在各自的目标文件中形成同名的强符号，导致最终链接时报错。这是由于在C语言中，函数和初始化后的全局变量默认都是强符号，如果你想改为弱符号，那么可以使用__attribute__((weak))修饰。在这里提一下最近58客户端发现的一个有意思的事情。在iOS 8.11.1版本以后，我们发现buggly上崩溃日志都会携带一个来自RN的函数调用栈RCTFBQuickPerformanceLoggerConfigureHooks，在RN中它的声明如下，&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-033bd202ab8d37ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;但是在源码中，这个函数没有任何实现，完全是一个空函数。看名字这个函数是hook使用的，那么它是怎么实现hook的呢？将RCT__EXTERN 展开后为__attribute__((visibility(&quot;default&quot;)))，其作用为将RCTFBQuickPerformanceLoggerConfigureHooks向外界暴露，如果外界存在同名函数，那么RCTFBQuickPerformanceLoggerConfigureHooks会报符号冲突的错误。那么如何做到即能暴露符号，又不造成符号冲突呢？这就利用了__attribute__((weak))，将RCTFBQuickPerformanceLoggerConfigureHooks生命为弱符号，当外界有同名函数时，SDK内部调用外届的函数，否则调用内部空函数。&lt;/p&gt;
&lt;p&gt;    为了防止出现函数名冲突，在UNIX的C环境下，所有的函数会被加上”_”前缀，也就是说void hello ( )，符号实际上为”_hello”，这种机制能够避免与系统函数的冲突。C++为了解决符号冲突的问题，表现的更为彻底。与C相比，C++有命名空间的限制，可以极大地避免函数的冲突，除了命名空间外，C++还存在构造和析构函数，函数重载等特征。这就导致C++的函数符号要比C函数更复杂。同样的一个函数，在C和C++中，函数符号是完全不一样的。假设有函数&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-7f780fcc843324af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;在C环境下，它的符号为”_cleanup”，而在C++环境下它的符号为“__Z7cleanupPv”，这就表明，同样一个函数在C和C++中，修饰机制是不一样的。为了避免由于符号不同导致的问题，很多开源代码会加上extern &quot;C” {}来限定函数在C环境。但是在C环境中并不识别extern &quot;C”标识，因此你会看到很多的开源代码中存在以下代码&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-492aa32b15de3f67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;其意图在于如果在C++环境中则限定为C环境。那么究竟C++的修饰机制是怎样的呢？我们看到一个C++函数，如何推断出它的符号呢？很遗憾，我没有找到明确的关于C++函数符号修饰的介绍，不同的编译器不同的平台签名有所不同。不过没有关系，办法还是有的，假设我想知道JavaScriptCore中某个C++函数的符号，那么我们可以创建一个cpp文件，将C++函数名复制过去，&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-5e96b2d6155f8462.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;声明命名空间和枚举&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-9c365e1be22c163e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;创建函数&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;然后通过gcc -c将文件编译成目标文件WBIMC++.o，然后调用命令nm WBIMC++.o即可查看相应的符号。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-75ee83f0b6d29d22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;能获取到C++的符号，是不是也就意味着hook C++函数是可行的。我们在fishhook的符号中随便传入一个JavaScriptCore的C++函数符号”_ZNK3JSC11SlotVisitor18containsOpaqueRootEPv“，通过代码断点调试发现，fishhook能够正确获取和替换函数指针&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-9072cedcf37bd351.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;因此hook C++是可行的。&lt;/p&gt;

&lt;p&gt;    在接触Mach-O之前，我有两个疑问，第一个是之前提出的问题，fishhook为什么不能hook自己写的C函数。第二个问题是跟58正在做的技术项目相关，如何动态调用static 函数。弄清楚这两个问题必须要对Mach-O有较为透彻的了解。&lt;/p&gt;
&lt;p&gt;    什么是Mach-O，按我的理解就是遵循特定结构的文件。一般比较常见的文件有：应用程序、目标文件、动态库、链接器等，其中应用程序、目标文件.o是尤为重要的。Mach-O可以分为三个部分：&lt;/p&gt;
&lt;h4&gt;1）、Header&lt;/h4&gt;
&lt;p&gt;Header是文件的头部信息，包括CPU信息、文件类型、Command条数及Size信息。总体来说，作为开发者Header使用的较少，比较常用的是(uintptr_t)&amp;amp;_mh_execute_header获取header地址进行计算用。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-6a73ae7803f1f6f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;Header&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;2）、Commands&lt;/h4&gt;
&lt;p&gt;Commands描述的是文件的加载信息，加载信息有很多，加载的段、符号表、动态库信息等都在Commands中取到。这个部分信息还是比较有用的，我们可以从这里获取到符号表和字符串表的偏移量，下文中会有详细的解释。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-7eaed4c9311b827d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;Commands&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;首先来说下段（Segment），上图中可以看出共加载了4个段，__PAGEZERO是一个空段，它位于文件起始段的位置。__TEXT和__DATA分别是文本段和数据段，分别存储了代码信息和数据信息。__LINKEDIT是链接信息段，可以通过__LINKEDIT进行地址计算。段又可以细分为section，每个Segment可以包含多个section。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-29779f552e0d731f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;段展开&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;3）、数据区&lt;/h4&gt;
&lt;p&gt;    除了Header和Commands外所有的原始数据。Commands是对数据的汇总提示，而数据区则是真实的数据。Commands与数据区的关系就像size和char*的关系。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-d6f271693a81bd41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;数据展示&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;接下来先介绍几个比较重要的模块：&lt;/p&gt;
&lt;h4&gt;1）、(__TEXT,__text)&lt;/h4&gt;
&lt;p&gt;这里存放的是汇编后的代码，当我们进行编译时，每个.m文件会经过预编译-&amp;gt;编译-&amp;gt;汇编形成.o文件，称之为目标文件。汇编后，所有的代码会形成汇编指令存储在.o文件的(__TEXT,__text)区（（__DATA,__data）也是类似）。链接后，所有的.o文件会合并成一个文件，所有.o文件的(__TEXT,__text)数据都会按链接顺序存放到应用文件的(__TEXT,__text)中。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-3e4e0ae03e2bf0d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;(__TEXT,__text)&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;2）、(__DATA,__data)&lt;/h4&gt;
&lt;p&gt;存储数据的section，static在进行非零赋值后会存储在这里，如果static 变量没有赋值或者赋值为0，那么它会存储在(__DATA,__bss)中。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-39eceb57c0c4490b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;(__DATA,__data)&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;3）、Symbol Table&lt;/h4&gt;
&lt;p&gt;符号表，这个是重点中的重点，符号表是将地址和符号联系起来的桥梁。符号表并不能直接存储符号，而是存储符号位于字符串表的位置。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-2d38be6801388a2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;Symbol Table&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;4）、String Table&lt;/h4&gt;
&lt;p&gt;字符串表所有的变量名、函数名等，都以字符串的形式存储在字符串表中。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-03bac1e704f70d71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;String Table&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;5）、动态符号表&lt;/h4&gt;
&lt;p&gt;动态符号表存储的是动态库函数位于符号表的偏移信息。(__DATA,__la_symbol_ptr) section 可以从动态符号表中获取到该section位于符号表的索引数组。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-207d2981b9db6c1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;动态符号表&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;动态符号表并不存储符号信息，而是存储其位于符号表的偏移信息。Fishhook源码看起来比较复杂主要是因为hook的是动态链接的函数，索引和链接关系比较绕。但是我们自己编写的C函数不是动态链接的，而是在编译链接后代码指令就存储在文件内部的函数，因此不会用到动态符号表。接下来我们以static 函数为例，看看如何动态的查找自己编写的函数地址。&lt;/p&gt;

&lt;p&gt;在58iOS客户端中大量存在static函数，这些static函数该如何动态调用呢？能否通过脚本来调用static函数呢？在调研Mach-O之前，我们是一愁莫展，尝试使用dlsym函数获取静态函数，但是实践发现dlsym并不能获取到函数地址。在了解Mach-O后，我们发现Mach-O文件中存放了所有编译过的的函数指令，static 函数也一定在文件中。假设在文件中下面函数&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-378f37e806deb090.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;示例函数&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;在Mach-O文件中，搜索代码段，可以发现静态函数存放在代码段中，其地址为0x1000010C0&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-60be45fb431f6d52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;查看函数地址&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;那么我们如何通过函数的名称获取到函数地址呢？所谓的函数名实际上就是函数符号，因此函数地址与函数名强关联。&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-cd35197b43584dd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;符号表与字符串表、函数地址、section的关系&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;符号表实际上是个结构体数组，结构体nlist_64中包括该符号位于字符串表的偏移，section索引，以及对应的地址信息。在符号表中，实际上不能直接获取到其对应的符号，在图中我们能看到符号为”_s_cleanup”，这实际上是工具帮我们获取好后展示出来的，实际上我们在代码中只能拿到其位于字符串表中的索引，在_s_cleanup的符号表中其索引为0x594，也就是说字符串表+0x594即为_s_cleanup字符串符号。&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-68aabcbc513ade01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;字符串表的起始地址&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;从上图中可以看出字符串表的起始地址为0x6004，0x6004+0x594 = 0x6598。&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-e5e36e0806d80b78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;计算符号位置获取符号&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;获取到字符串符号后，我们可以知道这个符号是不是我们想要的符号，如果是我们想要的符号，那么获取其函数地址。到这里，应该说通过Mach-O文件获取静态链接函数地址已经完美解决了。需要注意的是，这个函数地址并不是真实的地址，需要计算出其相对于真实地址的偏移，再加上真实文件地址即为真实函数地址。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-fd9eb0aadf761d74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;函数地址计算&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;那么如何获取函数符号表、字符串表呢？实际上segment和符号表在Commands中是顺序存放的，_mh_execute_header.ncmds可以根据索引遍历所有的Command。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-fd6c7096d6ec6b76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;找到LC_SYMTAB后，LC_SYMTAB会告诉我们符号表位于可执行文件的偏移以及字符串表位于可执行文件的偏移。地址计算后即可得到符号表和字符串表&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-279170f70bc7baf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;获取符号表和字符串表&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;最终效果如下：&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-b85044e887185235.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;动态调用static函数演示&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;细心的同学可能会发现一个bug，static 函数在不同的文件中是可以同名的，参数只有一个函数符号的话如何确定是哪个文件中函数？实际上在符号表中，是可以存在相同符号的，即如果两个文件中都存在s_cleanup函数，那么符号表中会存在两个_s_cleanup,只不过他们的函数地址不同。那么如何区分同名静态函数呢？实际上在链接时，各个段可以理解为按文件的顺序存放的，也就是说符号表实际上也是存在文件顺序的。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-0aa39442bc630497.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;链接过程简图&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;符号表的type可以区分出这个符号是否是文件相关信息，type == 0x64则是文件相关信息，因此在遍历符号表时可以判断出当前正在遍历哪个文件的符号。能判断出正在遍历哪个文件，那么bug就迎刃而解。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-c4c5e99fb8b1346f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;获取文件名&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;    另外，如果static 函数只是在代码中实现了，但是并没有任何调用的地方，那么在编译时，编译器会将static函数优化掉，不会生成相关指令。因此符号表中不会存储static函数相关信息，也就无法实现动态调用。如果想要做到static 数据存取，那么方式与此类似，只不过获取到的地址不是函数地址，而是数据存储地址，如果static 是函数内的局部变量，那么其符号需要加上函数符号，比如&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-dd3c71d79d07c01e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;那么它的静态变量s_iData符号为&quot;_application:didFinishLaunchingWithOptions:.s_iData”。通过memset即可修改变量的值。&lt;/p&gt;
&lt;p&gt;    关于Mach-O还有个比较有意思的是，我们可以自定义section，将数据和函数指令放入我们指定的section中，&lt;/p&gt;

&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-a901736bcaa619a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;修改函数存放section&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;编译链接后，其文件中多了个(__TEXT,__mysection)，并且函数还能正常运行。这为我们进行代码混淆又提供了一个手段。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-3889d852ecb1c63f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;在了解Mach-O之前，我们无法动态调用内联函数，动态调用任意C函数首先需要尝试是否能够通过dlsym函数获取到指针，如果获取不到函数指针则可能说明是内联函数，因此需要根据if-else来判断是哪个内联函数。但是现在我们可以通过Mach-O发现，所谓的内联函数在iOS代码中都是以static inline 修饰的，那么在编译时内联函数的函数符号会被写入当前目标文件的符号表，函数实现会被当做指令写入代码段，如同普通函数一样。在AppDelegate.m中调用CGSizeMake后，查看AppDelegate的目标文件符号表，可以看出符号表中包含内联函数的符号，如同普通函数一样。&lt;/p&gt;

&lt;div class=&quot;image-package&quot;&gt;&lt;img class=&quot;uploaded-img&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4642217-35a25d0c1c08b7d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; width=&quot;auto&quot; height=&quot;auto&quot;/&gt;&lt;p&gt;_CGSizeMake&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;    在iOS领域hook的方式有很多种，在不是必须的情况下还是少用为妙，hook之后出现问题非常难排查。本文主要介绍了如何根据Mach-O文件，获取静态链接的函数地址，动态链接的函数可以参考fishhook。&lt;/p&gt;
</description>
<pubDate>Tue, 13 Nov 2018 06:54:00 +0000</pubDate>
<dc:creator>皮拉夫大王</dc:creator>
<og:description>一、前言 在正题开始之前，我们先来聊聊iOS中的hook技术。一谈到hook，很多人首先想到的是runtime，runtime确实强大，但是它存在很多局限性： 1）、侵入性：一旦hook了某个类的方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dengzhuli/p/9952202.html</dc:identifier>
</item>
<item>
<title>系统架构设计师-软件水平考试（高级）-理论-需求 - 血夜之末</title>
<link>http://www.cnblogs.com/Tiancheng-Duan/p/9952050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tiancheng-Duan/p/9952050.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;系统架构设计师-需求&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最近很久没有发文章了。最近事情挺多的，也不知道该发那方面的内容。正好这两天有空闲，就整理整理思绪，把一些总结发表一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　经过考虑后，先将软考-架构相关的内容发出来，之后有时间，也会将一些额外的理论知识和经验写出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　参考：《系统架构设计师考试全程指导》，《系统架构设计师与系统分析师历年试题分析与解答》，《系统架构设计师教程》第四版，《软件体系结构原理，方法与实践》 等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　（如果只是应试，这些就足够了，按照核心脉络图学习，将资料书作为字典查询，从而建立体系，充实内容。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　补充参考：《Head first design pattern》（《Head first 设计模式》），《尽在双11：阿里巴巴技术演进与超越》，《大型网站系统与JAVA中间件实践》，《大型网站技术架构演进与性能优化》，《大型网站系统与JAVA中间件实践》，《大型分布式网站架构设计与实践》，《大型网站技术架构 核心原理与案例分析》&lt;a class=&quot;a-link&quot; title=&quot;大型网站技术架构演进与性能优化&quot; href=&quot;https://item.jd.com/12371801.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　（这些书都是对官方架构书的扩展与延伸。正如某人说的，官方架构书中的每个章节拿出来，都可以写出一本书来。。。当然我这里的补充也比较片面，主要针对设计模式与分布式网站架构等。至于项目管理等方面，并没有进行推荐。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　另外，这里的内容大多比较简略。如果想要深入的话，可以自己深入学习，也可以@我。当然，大牛就忽略这篇文章吧。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　（主要发出来，看大家有没有对此的需求。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一，XMIND：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/987666/201811/987666-20181113142315157-833142124.jpg&quot; alt=&quot;&quot; width=&quot;1610&quot; height=&quot;3200&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;二，补充：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　无论站在什么角度，需求都是十分重要的。考试方面，需求的获取，变更，处理都是比较热的考点。而与之相关的SA，OOA也是必考的内容。往期论文也考过需求获取的问题。从实践角度，需求也是必不可少的。如果是开发一个新的系统，可能会有百分之二三十的时间用在需求的获取上。而再开发后的运维阶段，程序员也一直在于需求打交道（尤其是小公司，更是有可能一天三个样，使得开发人员身心疲惫）。据统计，在系统上线的两三年内，系统以改正性维护为主，而在之后，往往则以完善性维护为主。而完善性维护与新需求息息相关。&lt;/span&gt;&lt;/p&gt;



</description>
<pubDate>Tue, 13 Nov 2018 06:40:00 +0000</pubDate>
<dc:creator>血夜之末</dc:creator>
<og:description>架构中需求相关问题脉络图</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tiancheng-Duan/p/9952050.html</dc:identifier>
</item>
<item>
<title>JAVA I/O系统 - 不该相遇在秋天</title>
<link>http://www.cnblogs.com/fengyumeng/p/9952079.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengyumeng/p/9952079.html</guid>
<description>&lt;p&gt;　　java的I/O系统是一个大块头，包含的东西太多了（就贴接口表格就能贴的让人头晕目眩），而且内容顺序不好安排，横切有字节流字符流，竖切有输入输出，再加新旧几轮迭代，三个维度纵横交错，真的不好写，以至于写这篇博客之前心里纠结了很久才下定的决心。&lt;/p&gt;
&lt;p&gt;　　因为不系统的梳理出来仔仔细细的过一遍，就不算是理解了。&lt;/p&gt;
&lt;p&gt;　　本篇博客只是自己整理，记录的是自己觉得有必要记录的东西，所以有一些偏冷门的类和用法是没有收录的，因为类实在太多了，记那么多根本没有必要，反倒让人学起来找不着东南西北。&lt;/p&gt;
&lt;p&gt;　　总之一句话：走大路，看辅路，不用管岔路。岔路留着让百度去查。&lt;/p&gt;
&lt;h3&gt;I/O基础知识&lt;/h3&gt;
&lt;h4&gt;流&lt;/h4&gt;
&lt;p&gt;　　java程序通过流执行I/O（I/O的意思就是 输入/输出）。&lt;/p&gt;
&lt;p&gt;　　流，是一种抽象，要么产生信息，要么使用信息，流通过java的IO系统链接到物理设备。&lt;/p&gt;
&lt;p&gt;　　尽管所有的流链接的物理设备是不同的，但是他们的行为方式都是相同的，因此，可以为任何类型的设备应用相同的IO类和方法。这意味着可以将许多不同类型的输入：磁盘文件、键盘或网络socket，抽象为输入流。与之对应，输出流可以引用控制台、磁盘文件或网络连接。&lt;/p&gt;
&lt;p&gt;　　流是处理输入/输出的一种清晰方式，例如代码中所有的部分都不需要去理解键盘和网络之间的区别，只需要操作流就行了，也就是说，‘流’屏蔽了实际IO设备中处理数据的细节。&lt;/p&gt;
&lt;h4&gt;字节流和字符流&lt;/h4&gt;
&lt;p&gt;　　java定义了两种类型的流：字节流和字符流，两种流都有输入、输出两个内容。&lt;/p&gt;
&lt;p&gt;　　InputStream和OutStream针对字节流和而设计，为处理字节的输入和输出提供了方法。&lt;/p&gt;
&lt;p&gt;　　Reader和Writer针对字符流而设计，为处理字符的输入和输出提供了方便的方法。&lt;/p&gt;
&lt;p&gt;　　最初版本的java 1.0并没有提供字符流，因此，所有IO都是面向字节的。字符流是java 1.1添加的，并且某些面向字节的类和方法不再推荐使用。&lt;/p&gt;
&lt;p&gt;　　另外一点：在最底层，所有IO仍然是面向字节的，基于字符的流只是为处理字符提供了一种方便和高效的方法。&lt;/p&gt;
&lt;h3&gt;关闭流的两种方式&lt;/h3&gt;
&lt;h4&gt;手动关闭&lt;/h4&gt;
&lt;p&gt;　　通常，当不需要时，流必须关闭，如果没有关闭，就可能会导致内存泄漏以及资源紧张。&lt;/p&gt;
&lt;p&gt;　　从java最初发布以来就一直有关闭流的close()方法，对于这种方式，通常是在finally代码块中调用close()方法。&lt;/p&gt;
&lt;h4&gt;自动关闭&lt;/h4&gt;
&lt;p&gt;　　到JDK7的时候，官方增加了一个新特性，该特性提供了另外一种管理资源的方式，这种方式能自动关闭文件。&lt;/p&gt;
&lt;p&gt;　　该特性以try语句的扩展版为基础：try(在这里生成流){}.&lt;/p&gt;
&lt;p&gt;　　当try代码块结束时，资源会被自动关闭，它的优点是当不再需要文件或者其他资源时，可以防止无意中忘记释放他们。&lt;/p&gt;
&lt;p&gt;下面是带资源的try语句的3个关键点：&lt;/p&gt;
&lt;p&gt;　　1.由带资源的try语句管理的资源必须是实现了AutoCloseable接口的类的对象。&lt;br/&gt;　　2.在try代码中声明的资源被隐式声明为final。&lt;br/&gt;　　3.通过使用分号分割每个声明可以管理多个资源。&lt;/p&gt;
&lt;p&gt;　　带资源的try语句流线化了释放资源的过程，并消除了可能在无意中忘记释放资源的风险，所以如果可能的话，尽量在开发中使用这种方式。&lt;/p&gt;
&lt;h3&gt;字节流&lt;/h3&gt;
&lt;h4&gt;顶级抽象类&lt;/h4&gt;
&lt;h5&gt;InputStream&lt;/h5&gt;
&lt;p&gt;　　字节流的顶层抽象类，定义了java的字节流输入模型。&lt;/p&gt;
&lt;p&gt;方法列表：&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr&gt;&lt;td&gt;方法&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;int available()&lt;/td&gt;
&lt;td&gt;返回当前可读取的输入字节数&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;void close&lt;/td&gt;
&lt;td&gt;关闭输入流&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;boolean markSupported()&lt;/td&gt;
&lt;td&gt;当前流是否支持打标记&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;void mark(int limit)&lt;/td&gt;
&lt;td&gt;在输入流的当前位置放一个标记（并不是所有的流都支持这个特性），该标记在读入limit个字节之前一直都有效。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;void reset()&lt;/td&gt;
&lt;td&gt;将输入流的指针重置为前面设置的标记，如果当前没有任何标记，则指针重置到开头。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;int read()&lt;/td&gt;
&lt;td&gt;读入一个字节，并返回该字节。（这个read方法在碰到输入流的结尾时返回-1）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;int read(byte b[])&lt;/td&gt;
&lt;td&gt;读入一个字节数组，返回实际读入的字节数。（在碰到数据流的结尾时返回-1，这个方法最多读入b.length个字节）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;int read(byte[] b,int off,int len)&lt;/td&gt;
&lt;td&gt;读入一个字节数组，从byte[off]开始读，最多读取len个字节，返回实际读入的字节数，碰到输入流的结尾时返回-1.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;long skip(long n)&lt;/td&gt;
&lt;td&gt;在输入流中跳过n个字节，返回实际跳过的字节数。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;









&lt;h5&gt;OutputStream&lt;/h5&gt;
&lt;p&gt;　　字节流的顶层抽象类，定义了java的字节流输出模型。&lt;/p&gt;
&lt;p&gt;方法列表：&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td&gt;方法&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;void write(int n)&lt;/td&gt;
&lt;td&gt;写出一个字节的数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;void write(byte[] b)&lt;/td&gt;
&lt;td&gt;写出一个字节数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;void write(byte[] b,int off,int len)&lt;/td&gt;
&lt;td&gt;写出一个字节数组，从b[off]开始写，最多写len个字节。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;void flush()&lt;/td&gt;
&lt;td&gt;冲刷输出流，结束输出状态。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;void close()&lt;/td&gt;
&lt;td&gt;冲刷并关闭输出流。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;






&lt;h4&gt;文件流&lt;/h4&gt;
&lt;h5&gt;FileInputStream类&lt;/h5&gt;
&lt;p&gt;　　FileInputStream继承于InputStream，该对象可以用于从文件中读取字节。&lt;/p&gt;
&lt;p&gt;构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　FileInputStream(String filePath);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件的完整路径&lt;/span&gt;
　　FileInputStream(File fileObj);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件的File对象&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这两个构造器都会抛出FileNotFoundException异常。&lt;/p&gt;
&lt;p&gt;从流中读取内容的两种方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;try&lt;/span&gt;(FileInputStream f = &lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;./src/bytes/en.txt&quot;&lt;span&gt;)){
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
            System.out.println(&lt;/span&gt;&quot;总字节是：&quot;+(size =&lt;span&gt; f.available()));

            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = 3&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(num&amp;gt;0&lt;span&gt;){
                System.out.println(&lt;/span&gt;&quot;单个字节的读：&quot;+(&lt;span&gt;char&lt;/span&gt;&lt;span&gt;) f.read());
                num&lt;/span&gt;--&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意：此时io流的指针已经到了第4个字节了，所以下面打印的内容不包含前3个字节。&lt;/span&gt;
            &lt;span&gt;byte&lt;/span&gt; b[] = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[size];
            f.read(b);
            System.out.println(&lt;/span&gt;&quot;文件内容是：&quot;+&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(b));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;文件内容是：&quot;+new String(b,0,size));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;也可以这样&lt;/span&gt;
        }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e){
            e.printStackTrace();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;FileOutputStream类&lt;/h5&gt;
&lt;p&gt;　　FileOutputStream继承于OutputStream，该对象可以将字节写入文件。&lt;/p&gt;
&lt;p&gt;构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　FileOutputStream(String filePath)
　　FileOutputStream(String filePath,&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; append)
　　FileOutputStream(File fileObj)
　　FileOutputStream(File fileObj,&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; append)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和FileInputStream一样，不同的是有一个append参数，这个参数如果为true，则以追加的方式打开文件，否则，这个方法会删除同名的已有文件创建一个新的输出流。&lt;/p&gt;
&lt;p&gt;　　另外，如果试图打开只读文件会抛出异常。&lt;/p&gt;
&lt;p&gt;以下演示将数据写入文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;try&lt;/span&gt;(FileOutputStream f1 = &lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;./io/src/bytes/file1.txt&quot;&lt;span&gt;);
            FileOutputStream f2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;./io/src/bytes/file2.txt&quot;&lt;span&gt;);
            FileOutputStream f3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;./io/src/bytes/file3.txt&quot;&lt;span&gt;)
        ){
            String source &lt;/span&gt;= &quot;1234567890&quot;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] buf =&lt;span&gt; source.getBytes();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每跳一个字节写&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;buf.length;i+=2&lt;span&gt;){
                f1.write(buf[i]);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写全部&lt;/span&gt;
&lt;span&gt;            f2.write(buf);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写最后四分之一  （写出来的是90，因为7.5就是第8个字节，也就是会从第9个字节开始写）&lt;/span&gt;
            f3.write(buf,buf.length-buf.length/4,buf.length/4&lt;span&gt;);

        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e){
            e.printStackTrace();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;字节数组流&lt;/h4&gt;
&lt;h5&gt;ByteArrayInputStream类&lt;/h5&gt;
&lt;p&gt;　　ByteArrayInputStream类继承于InputStream，是使用字节数组作为源的输入流的一个实现，这个类有两个构造函数，都需要一个字节数组来提供数据源。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　ByteArrayInputStream(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; array[])
　　ByteArrayInputStream(&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; array[],&lt;span&gt;int&lt;/span&gt; start,&lt;span&gt;int&lt;/span&gt; num)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构造函数演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
　　String str = &quot;1234567890&quot;&lt;span&gt;;
　　&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] b =&lt;span&gt; str.getBytes();
　　ByteArrayInputStream in1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayInputStream(b);
　　ByteArrayInputStream in2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ByteArrayInputStream(b,0,3);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从第0个字节开始读 读3个&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ByteArrayInputStream实现了mark()和reset()方法，用法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        String str = &quot;1234567890&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] b =&lt;span&gt; str.getBytes();
        ByteArrayInputStream in1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayInputStream(b);

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = 5&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;5;i++&lt;span&gt;){
            System.out.print((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;) in1.read());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：12345&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(i == 2&lt;span&gt;){
                in1.mark(i);
            }
        }
        in1.reset();
        System.out.println();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;5;i++&lt;span&gt;){
            System.out.print((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;) in1.read());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：45678&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果没有mark标记，则调用reset()会将指针重置到开头。（如果没有in1.mark(i)这行，那么第二个输出也是123456）&lt;/p&gt;
&lt;h5&gt;ByteArrayOutputStream类&lt;/h5&gt;
&lt;p&gt;　　ByteArrayOutputStream是使用字节数组作为目标的输出流的一个实现。&lt;/p&gt;
&lt;p&gt;它有两个构造函数，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　ByteArrayOutputStream()
　　ByteArrayOutputStream(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第一个构造函数，创建一个32字节的缓冲区。&lt;br/&gt;　　第二个构造函数，创建一个num大小的缓冲区。&lt;/p&gt;
&lt;p&gt;　　缓冲区会被保存在ByteArrayOutputStream中受保护的属性buf变量中。&lt;/p&gt;
&lt;p&gt;　　如果需要的话，缓冲区的大小会自动增加，缓冲区能够保存的字节数量包含在ByteArrayOutputStream中受保护的属性count变量中。&lt;/p&gt;
&lt;p&gt;下面演示ByteArrayOutputStream类的使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        String source = &quot;1234567890&quot;&lt;span&gt;;
        ByteArrayOutputStream out1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayOutputStream();
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] b =&lt;span&gt; source.getBytes();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            out1.write(b);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e){
            e.printStackTrace();
        }
        System.out.println(out1.toString());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：1234567890&lt;/span&gt;

        &lt;span&gt;byte&lt;/span&gt;[] bb =&lt;span&gt; out1.toByteArray();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;bb.length;i++&lt;span&gt;){
            System.out.print((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;)bb[i]);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：1234567890&lt;/span&gt;
&lt;span&gt;        System.out.println();

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;(FileOutputStream f = &lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;./io/src/bytes/f.txt&quot;&lt;span&gt;)){
            out1.writeTo(f);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把out1的内容写入f&lt;/span&gt;
        }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e){
            e.printStackTrace();
        }

        out1.reset();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;3;i++&lt;span&gt;){
            out1.write(&lt;/span&gt;'X'&lt;span&gt;);
        }
        System.out.println(out1.toString());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出：XXX&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，最后的输出是三个X，也就是说，它并不是在插入内容，而是把后面的擦掉了。&lt;/p&gt;
&lt;h4&gt;字节缓冲流&lt;/h4&gt;
&lt;p&gt;　　对于面向字节的流，缓冲流通过将内存缓冲区附加到IO系统来扩展过滤流。这种流允许java一次对多个字节执行多次IO操作，从而提升性能。&lt;/p&gt;
&lt;p&gt;　　因为可以使用缓冲区，所以略过、标记、或重置流都是可能发生的，BufferedInputStream类、BufferedOutputStream类、PushbackInputStream类都实现了缓冲流。&lt;/p&gt;
&lt;h5&gt;BufferedInputStream类&lt;/h5&gt;
&lt;p&gt;　　缓冲IO是很常见的性能优化手段，BufferedInputStream类允许将任何InputStream对象封装到缓冲流中以提高性能，因为带缓冲区的输入流从流中读入字符时，不会每次都对设备访问。&lt;/p&gt;
&lt;p&gt;构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　BufferedInputStream(InputStream inputStream)
　　BufferedInputStream(InputStream inputStream,&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; bufSize)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　缓冲输入流除了任何InputStream都实现了的read()和skip()方法外，还支持mark()和reset()方法。&lt;/p&gt;
&lt;p&gt;下面演示如何把一个字符串读两遍，第二遍略过前5个字节：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        String s = &quot;1234567890&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] buf =&lt;span&gt; s.getBytes();
        ByteArrayInputStream in &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayInputStream(buf);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;(BufferedInputStream f = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedInputStream(in)){
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; f.available();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; limit = 4&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;c;i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; r =&lt;span&gt; f.read();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i ==&lt;span&gt; limit){
                    f.mark(limit);
                }
                System.out.print((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;) r);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出1234567890&lt;/span&gt;
&lt;span&gt;            }
            System.out.println();
            f.reset();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;c-(limit+1);i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; r =&lt;span&gt; f.read();
                System.out.print((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;) r);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出67890&lt;/span&gt;
&lt;span&gt;            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e){
            e.printStackTrace();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;BufferedOutputStream类&lt;/h5&gt;
&lt;p&gt;　　创建一个带缓冲区的输出流，带缓冲区的输出流在收集要写出的字符时，不会每次都对设备访问，当缓冲区填满或者当流被冲刷时，数据就被写出，因此调用flush()方法才是数据刷盘。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　BufferedOutputStream(OutputStream outputStream)
　　BufferedOutputStream(OutputStream outputStream,&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; bufSize)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;try&lt;/span&gt;(FileOutputStream f = &lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;./io/src/bytes/bufOutput.txt&quot;&lt;span&gt;)){
            String source &lt;/span&gt;= &quot;1234567890&quot;&lt;span&gt;;
            BufferedOutputStream buf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedOutputStream(f);
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] b =&lt;span&gt; source.getBytes();

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;b.length;i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i == 3&lt;span&gt;){
                    buf.flush();
                    buf.write(&lt;/span&gt;'-'&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i == 6&lt;span&gt;){
                    buf.flush();
                    buf.write(&lt;/span&gt;'-'&lt;span&gt;);
                }
                buf.write(b[i]);
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e){
            e.printStackTrace();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后写入文件的内容是：123-456&lt;/p&gt;
&lt;p&gt;可见最后的7890一直在缓冲输出流中，不调用flush()就不会写入文件。&lt;/p&gt;
&lt;h5&gt;PushbackInputStream类&lt;/h5&gt;
&lt;p&gt;　　一个可以预览字节的输入流，它读取字节，但并不破坏他们，读取后可以再将他们回推到输入流中，下次调用read()时可以再次被读取。&lt;/p&gt;
&lt;p&gt;构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　PushbackInputStream(InputStream inputStream)
　　PushbackInputStream(InputStream inputStream,&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个构造函数创建的流对象允许将一个字节回推到输入流。&lt;/p&gt;
&lt;p&gt;第二个构造函数创建的流对象具有一个长度为num的回推缓冲区，从而允许将多个字节回推到输入流中。&lt;/p&gt;
&lt;p&gt;　　除了来自InputStream的方法外，PushbackInputStream类提供了回推方法：unread(int b)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        String source = &quot;12345&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] b =&lt;span&gt; source.getBytes();
        ByteArrayInputStream byteArrayInputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayInputStream(b);
        PushbackInputStream push &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PushbackInputStream(byteArrayInputStream);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; bytes;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; push.available();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;size;i++&lt;span&gt;){
                bytes &lt;/span&gt;=&lt;span&gt; push.read();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i == 1&lt;span&gt;){
                    push.unread(bytes);
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i == 3&lt;span&gt;){
                    push.unread(bytes);
                }
                System.out.print((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;) bytes);
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e){
            e.printStackTrace();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后的输出结果是：12233&lt;/p&gt;
&lt;p&gt;另外也可以回推字节数组unread(byte buf[])&lt;/p&gt;
&lt;p&gt;　　注意：PushbackInputStream会使得标记重置功能无效，因此在使用mark()和reset()之前应该先用markSupported()检查。&lt;/p&gt;
&lt;h4&gt;打印流&lt;/h4&gt;
&lt;h5&gt;PrintStream类&lt;/h5&gt;
&lt;p&gt;　　用的最多的System.out.println()就是PrintStream类里的方法。&lt;/p&gt;
&lt;p&gt;　　PrintStream最初的目的是为了以可视化格式打印所有的基本数据类型以及String对象，它的最重要的两个方法：print()和println()可以打印出各种类型，如果参数不是基本类型，那么会自动调用对象的toString()方法并显示结果。&lt;/p&gt;
&lt;h3&gt;字符流&lt;/h3&gt;
&lt;p&gt;　　虽然字节流为了处理各种类型的IO操作提供了充足的功能，但是老的IO流继承层次结构仅支持8位字节流，并不能直接操作16位的Unicode字符。&lt;/p&gt;
&lt;p&gt;　　因为java的一个主要目的就是实现代码的“一次编写，到处运行”，为了国际化的大业，需要为字符提供直接的IO支持，因此添加了Reader和Writer继承层次结构，另外，新类库的设计使得它的操作比旧类库更快。&lt;/p&gt;
&lt;h4&gt;顶级抽象类&lt;/h4&gt;
&lt;h5&gt;Reader&lt;/h5&gt;
&lt;p&gt;　　字符流的顶级抽象类，定义了java字符流的输入模型。&lt;/p&gt;
&lt;p&gt;方法列表：&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;13.5&quot;&gt;&lt;tr&gt;&lt;td&gt;方法&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;int read()&lt;/td&gt;
&lt;td&gt;读取一个字符，返回表示该字符的证书，如果达到文件末尾，则返回-1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;int read(char buff[])&lt;/td&gt;
&lt;td&gt;读取buff.length个字符，返回成功读取的字符数，如果达到文件末尾，则返回-1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;int read(CharBuffer buff)&lt;/td&gt;
&lt;td&gt;读取字符，返回成功读取的字符数，如果达到文件末尾，则返回-1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;int read(char buff[],int offset,int num)&lt;/td&gt;
&lt;td&gt;从buff[offset]开始读，读取num个字符，如果文件达到末尾，则返回-1&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;long skip(long num)&lt;/td&gt;
&lt;td&gt;跳过num个字符，返回实际跳过的字符数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;void close()&lt;/td&gt;
&lt;td&gt;关闭输入流，如果试图继续读取，会产生IO异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;boolean ready()&lt;/td&gt;
&lt;td&gt;如果下一个输入请求不等待，就返回true，否则返回false&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;boolean markSupported()&lt;/td&gt;
&lt;td&gt;如果这个流支持mark或者reset，就返回true&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;void mark(int num)&lt;/td&gt;
&lt;td&gt;在当前流的位置放置标记，该标记在reset()之前一直有效&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;void reset()&lt;/td&gt;
&lt;td&gt;将输入指针重新设置为前面设置的标记位置&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;









&lt;h5&gt;Writer&lt;/h5&gt;
&lt;p&gt;　　字符流的顶级抽象类，定义了java字符流的输出模型。&lt;/p&gt;
&lt;p&gt;方法列表：&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;16&quot;&gt;&lt;tr&gt;&lt;td&gt;方法&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Writer append(char cn)&lt;/td&gt;
&lt;td&gt;将cn追加到调用输出流的末尾，返回对调用流的引用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Writer append(CharSequence chars)&lt;/td&gt;
&lt;td&gt;将chars追加到调用输出流的末尾，返回对调用流的引用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;Writer append(CharSequence chars,int begin,int end)&lt;/td&gt;
&lt;td&gt;将chars从begin到end-1之间的字符追加到输出流的末尾，返回对调用流的引用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;void close()&lt;/td&gt;
&lt;td&gt;关闭输出流，如果试图继续向其中写入内容，将产生IO异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;void flush()&lt;/td&gt;
&lt;td&gt;完成输出状态，从而清空所有缓冲区，即刷新输出缓冲区&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;void write(int ch)&lt;/td&gt;
&lt;td&gt;写入一个字符到输出流中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;void write(char buff[])&lt;/td&gt;
&lt;td&gt;将整个字符数组写入输出流中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;void write(char buff[],int offset,int num)&lt;/td&gt;
&lt;td&gt;将buff数组中从buff[offset]开始的num个字符写入输出流中&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;void write(String str)&lt;/td&gt;
&lt;td&gt;将str写到输出流中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;void write(String str,int offset,int num)&lt;/td&gt;
&lt;td&gt;将字符串str中从offset开始写，写num个字符&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;









&lt;h4&gt;文件流&lt;/h4&gt;
&lt;h5&gt;FileReader类&lt;/h5&gt;
&lt;p&gt;　　FileReader类可以创建用于读取文件内容的Reader对象。&lt;/p&gt;
&lt;p&gt;　　注意：FileReader 用于读取字符流。要读取原始字节流，请考虑使用 FileInputStream。&lt;/p&gt;
&lt;p&gt;构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　FileReader(String filePath)
　　FileReader(File fileObj)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面演示如何从文件中读取数据并在标准输出设备上进行显示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;try&lt;/span&gt;(FileReader f = &lt;span&gt;new&lt;/span&gt; FileReader(&quot;./io/src/chars/fileReader.txt&quot;&lt;span&gt;)){
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((c = f.read()) != -1&lt;span&gt;){
                System.out.print((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;) c);
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e){
            e.printStackTrace();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;FileWriter类&lt;/h5&gt;
&lt;p&gt;　　FileWriter类可以创建能够用于写入文件的Writer对象。&lt;/p&gt;
&lt;p&gt;　　文件是否可用或是否可以被创建取决于底层平台。特别是某些平台一次只允许一个 &lt;tt&gt;FileWriter&lt;/tt&gt;（或其他文件写入对象）打开文件进行写入。在这种情况下，如果所涉及的文件已经打开，则此类中的构造方法将失败。&lt;/p&gt;
&lt;p&gt;　　&lt;code&gt;FileWriter&lt;/code&gt; 用于写入字符流。要写入原始字节流，请考虑使用 &lt;code&gt;FileOutputStream&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　FileWriter(String filePath)
　　FileWriter(String filePath,&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; append)
　　FileWriter(File fileObj)
　　FileWriter(File fileObj,&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; append)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　append参数代表是否追加到文件末尾。&lt;/p&gt;
&lt;p&gt;以下演示使用FileWriter将字符串写入文件的用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;try&lt;/span&gt;(FileWriter f1 = &lt;span&gt;new&lt;/span&gt; FileWriter(&quot;./io/src/chars/file1.txt&quot;&lt;span&gt;);
            FileWriter f2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileWriter(&quot;./io/src/chars/file2.txt&quot;&lt;span&gt;);
            FileWriter f3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileWriter(&quot;./io/src/chars/file3.txt&quot;&lt;span&gt;)
        ){
            String source &lt;/span&gt;= &quot;1234567890&quot;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; length =&lt;span&gt; source.length();
            &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] buff =&lt;span&gt; source.toCharArray();

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;length;i+=2&lt;span&gt;){
                f1.write(buff[i]);
            }

            f2.write(source);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;f2.write(buff);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等价

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写最后四分之一  （写出来的是90，因为7.5就是第8个字节，也就是会从第9个字节开始写）&lt;/span&gt;
            f3.write(buff,buff.length-buff.length/4,buff.length/4&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e){
            e.printStackTrace();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;字符数组流&lt;/h4&gt;
&lt;h5&gt;CharArrayReader类&lt;/h5&gt;
&lt;p&gt;　　CharArrayReader类是使用字符数组作为源的一个输入流的实现，该类具有两个构造函数，每个构造函数都需要一个字符数组来提供数据源&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　CharArrayReader(&lt;span&gt;char&lt;/span&gt;&lt;span&gt; array[])
　　CharArrayReader(&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; array[],&lt;span&gt;int&lt;/span&gt; start,&lt;span&gt;int&lt;/span&gt; num)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第二个构造函数根据字符数组创建Reader对象，指定从start的索引位置的字符开始，一共num个字符。&lt;/p&gt;
&lt;p&gt;以下演示使用字符数组来读取数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        String source = &quot;1234567890&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; length =&lt;span&gt; source.length();
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] c =&lt;span&gt; source.toCharArray();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;(CharArrayReader r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CharArrayReader(c)){
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0;i &amp;lt; length; i++&lt;span&gt;){
                System.out.print((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;) r.read());
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e){
            e.printStackTrace();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h5&gt;CharArrayWriter类&lt;/h5&gt;
&lt;p&gt;　　CharArrayWriter类是使用数组作为目标的一个输出流实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　CharArrayWriter()
　　CharArrayWriter(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在第一种形式中，创建使用默认大小的缓冲区，在第二种形式中，创建由num指定大小的缓冲区。&lt;/p&gt;
&lt;p&gt;　　缓冲区保存在CharArrayWtier类的buf属性变量中，如果需要，缓冲区的大小可以自动增加，缓冲区能够容纳的字符数量保存在CharArrayWriter类的count属性变量中，两个属性都是受保护类型。&lt;/p&gt;
&lt;p&gt;写法都是一样的，以下演示CharArrayWriter把字符写入文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        String source = &quot;1234567890&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] c =&lt;span&gt; source.toCharArray();
        CharArrayWriter w &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CharArrayWriter();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            w.write(c);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e){
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;(FileWriter f = &lt;span&gt;new&lt;/span&gt; FileWriter(&quot;./io/src/chars/charArray.txt&quot;&lt;span&gt;)){
            w.writeTo(f);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e){
            e.printStackTrace();
        }
        w.reset();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;3;i++&lt;span&gt;){
            w.write(&lt;/span&gt;'X'&lt;span&gt;);
        }
        System.out.println(w.toString());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出XXX&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;缓冲流&lt;/h4&gt;
&lt;h5&gt;BufferedReader类&lt;/h5&gt;
&lt;p&gt;　　BufferedReader类通过缓冲输入提高性能，该类具有两个构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　BufferedReader(Reader inputStream)
　　BufferedReader(Reader inputStream,&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; bufSize)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第二个构造函数指定创建bufSize大小的缓冲字符流。&lt;/p&gt;
&lt;p&gt;　　与面向字节的流一样，缓冲的输入字符流也实现了mark()和reset()方法，并且markSupported()会返回true.&lt;/p&gt;
&lt;p&gt;下面例子重写BufferedInputStream的示例，使之输出相同：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        String s = &quot;1234567890&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] buf =&lt;span&gt; s.toCharArray();
        CharArrayReader in &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CharArrayReader(buf);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;(BufferedReader f = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedReader(in)){
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; buf.length;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; limit = 4&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;c;i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; r =&lt;span&gt; f.read();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i ==&lt;span&gt; limit){
                    f.mark(limit);
                }
                System.out.print((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;) r);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出1234567890&lt;/span&gt;
&lt;span&gt;            }
            System.out.println();
            f.reset();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;c-(limit+1);i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; r =&lt;span&gt; f.read();
                System.out.print((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;) r);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出67890&lt;/span&gt;
&lt;span&gt;            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e){
            e.printStackTrace();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;BufferedWriter类&lt;/h5&gt;
&lt;p&gt;　　BufferedWriter是缓冲输出的Writer，使用BufferedWriter可以通过减少实际向输出设备物理的写入数据的次数来提高性能。&lt;/p&gt;
&lt;p&gt;构造函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　BufferedWriter(Writer outputStream)
　　BufferedWriter(Writer outputStream,&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; bufSize)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第一种形式创建的缓冲流使用具有默认大小的缓冲区，在第二种形式中缓冲区的大小是由bufSize指定的。&lt;/p&gt;
&lt;p&gt;同样的，改写BufferedOutputStream的示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;try&lt;/span&gt;(FileWriter f = &lt;span&gt;new&lt;/span&gt; FileWriter(&quot;./io/src/chars/bufOutput.txt&quot;&lt;span&gt;)){
            String source &lt;/span&gt;= &quot;1234567890&quot;&lt;span&gt;;
            BufferedWriter buf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedWriter(f);
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] b =&lt;span&gt; source.getBytes();

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;b.length;i++&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i == 3&lt;span&gt;){
                    buf.flush();
                    buf.write(&lt;/span&gt;'-'&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i == 6&lt;span&gt;){
                    buf.flush();
                    buf.write(&lt;/span&gt;'-'&lt;span&gt;);
                }
                buf.write(b[i]);
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e){
            e.printStackTrace();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写入文件的内容是：123-456&lt;/p&gt;
&lt;h5&gt;PushbackReader类&lt;/h5&gt;
&lt;p&gt;　　PushbackReader类允许将字符回推到输入流，下面是该类的两个构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　PushbackReader(Reader inputStream)
　　PushbackReader(Reader inputStream,&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; bufSize)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第一个构造函数创建的缓冲流允许回推一个字符，第二种形式回推缓冲区的大小由bufSize指定。&lt;/p&gt;
&lt;p&gt;　　PushbackReader类提供了unread()方法，该方法实现了回推动作，有如下三种形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　&lt;span&gt;void&lt;/span&gt;&lt;span&gt; unread(in ch);
　　&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; unread(&lt;span&gt;char&lt;/span&gt;&lt;span&gt; buffer[]);
　　&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; unread(&lt;span&gt;char&lt;/span&gt; buffer[],&lt;span&gt;int&lt;/span&gt; offset,&lt;span&gt;int&lt;/span&gt; num);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第一种形式回推cn传递的字符，后续调用read()就将返回这个被回推的字符。&lt;br/&gt;　　第二种形式返回buffer中的字符，第三种形式回推buffer中从offset位置开始的num个字符。&lt;/p&gt;
&lt;p&gt;　　当回推缓冲区已满时，如果试图返回字符，则会抛出IO异常。&lt;/p&gt;
&lt;p&gt;下面示例PushbackReader的使用方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        String source = &quot;12345&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] c =&lt;span&gt; source.toCharArray();
        CharArrayReader charArrayReader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CharArrayReader(c);
        PushbackReader push &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PushbackReader(charArrayReader);
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; bytes;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; source.length();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;size;i++&lt;span&gt;){
                bytes &lt;/span&gt;=&lt;span&gt; push.read();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i == 1&lt;span&gt;){
                    push.unread(bytes);
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i == 3&lt;span&gt;){
                    push.unread(bytes);
                }
                System.out.print((&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt;) bytes);
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e){
            e.printStackTrace();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出的结果是：12233&lt;/p&gt;
&lt;h4&gt;打印流&lt;/h4&gt;
&lt;h5&gt;PrintWriter类&lt;/h5&gt;
&lt;p&gt;　　PrintWriter本质上是PrintStream的面向字符的版本，&lt;/p&gt;
&lt;p&gt;构造函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　PrintWriter(OutputStream outputStream)
　　PrintWriter(OutputStream outputStream,&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; autoFlushingOn)
　　PrintWriter(Writer outputStream)
　　PrintWriter(Writer outputStream,&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; autoFlushingOn)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　autoFlushingOn参数控制每次调用println()/printf()或format()方法时，是否自动刷新输出缓冲区，如果为true，就自动刷新，否则不自动刷新，没有指定的构造函数不自动刷新。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　PrintWriter(File outputFile)
　　PrintWriter(File outputFile,String charSet)
　　PrintWriter(String outputFileName)
　　PrintWriter(String outputFileName,String charSet)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这几个构造函数允许从File对象或根据文件路径创建PrintWriter对象，对于每种形式，都会自动创建文件，所有之前存在的同名文件都会被销毁。一旦创建PrintWriter对象，就将所有输出定向到指定文件，可以通过charSet传递的名称来指定字符编码。&lt;/p&gt;
&lt;p&gt;以下演示PrintWriter的简单用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        String source = &quot;123456&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;(FileWriter f = &lt;span&gt;new&lt;/span&gt; FileWriter(&quot;./io/src/chars/print.txt&quot;&lt;span&gt;)){
            PrintWriter printWriter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PrintWriter(f);
            printWriter.print(source);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            e.printStackTrace();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 随机访问文件&lt;/h3&gt;
&lt;h4&gt;RandomAccessFile类&lt;/h4&gt;
&lt;p&gt;　　RandomAccessFile是一个完全独立的类，从Object派生而来，它不属于InputStream/OutputStream也不属于Reader/Writer。&lt;/p&gt;
&lt;p&gt;　　它拥有和别的IO类型本质不同的行为，因为我们可以在一个文件里将指针向前和向后移动。&lt;/p&gt;
&lt;p&gt;构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　RandomAccessFile(File fileObj,String mode)
　　RandomAccessFile(String filename,String mode)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第一个构造函数fileObj指定了作为File对象打开的文件。&lt;br/&gt;　　第二个构造函数文件名称是通过filename传递的。&lt;/p&gt;
&lt;p&gt;两种方式都有mode指定访问模式：&lt;/p&gt;
&lt;p&gt;　　r 以只读方式打开 调用结果对象的任何write方法都将抛出IOException&lt;br/&gt;　　rw以读写方式打开，如果该文件不存在，则创建该文件&lt;br/&gt;　　rws以读写方式打开，如果该文件不存在，则创建该文件，并且对文件的内容或元数据的每个更新都将同步写入到底层的存储设备&lt;br/&gt;　　rwd以读写方式打开，如果该文件不存在，则创建该文件，并且对文件的内容的每个更新都将同步写入到底层的存储设备&lt;/p&gt;
&lt;p&gt;　　rws和rwd显然是不存在缓冲环节的，如果该文件位于本地存储设备上，那么可以保证调用对此文件所做的所有更新均被写入该设备，这对确保在系统崩溃时不会丢失重要信息特别有用，如果该文件不在本地设备上，则无法提供这样的保证。&lt;/p&gt;
&lt;p&gt;　　其中rwd模式可用于减少执行IO的操作数量，仅要求更新写入设备。&lt;/p&gt;
&lt;p&gt;很重要的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　&lt;span&gt;void&lt;/span&gt; seek(&lt;span&gt;long&lt;/span&gt; newPos) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置指针位置&lt;/span&gt;
　　&lt;span&gt;long&lt;/span&gt; getFilePointer()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回当前指针位置&lt;/span&gt;
　　&lt;span&gt;long&lt;/span&gt; length()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回文件长度&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;控制台I/O&lt;/h3&gt;
&lt;h4&gt;Console类&lt;/h4&gt;
&lt;p&gt;　　Console类可访问与当前 Java 虚拟机关联的基于字符的控制台设备，也就是说用于从控制台读取内容以及向控制台写入内容，该类主要是提供方便，因为大部分功能都可以通过System.in和System.out得到。&lt;/p&gt;
&lt;p&gt;　　Console类没有提供构造函数，可以通过调用System.console()方法获取Console对象。&lt;/p&gt;
&lt;p&gt;　　如果控制台可用，就返回对控制台的引用，否则返回null。并不是在所有情况下控制台都是可用的，如果返回null，就不能进行控制台I/O。（虚拟机是否具有控制台取决于底层平台，还取决于调用虚拟机的方式。如果虚拟机从一个交互式命令行开始启动，且没有重定向标准输入和输出流，那么其控制台将存在，并且通常连接到键盘并从虚拟机启动的地方显示。如果虚拟机是自动启动的（例如，由后台作业调度程序启动），那么它通常没有控制台。）&lt;/p&gt;
&lt;p&gt;方法列表：&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr&gt;&lt;td&gt;方法&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;void flush()&lt;/td&gt;
&lt;td&gt;刷新控制台，并强制立即写入所有缓冲的输出。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;Console format(String fmtString,Object...args)&lt;/td&gt;
&lt;td&gt;使用fmtString指定的格式将args写到控制台&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;Console printf(String fmtString,Object...args)&lt;/td&gt;
&lt;td&gt;使用fmtString指定的格式将args写到控制台的便捷方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Reader reader()&lt;/td&gt;
&lt;td&gt;返回对连接到控制台的Reader对象的引用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;String readLine()&lt;/td&gt;
&lt;td&gt;从控制台读取单行文，当用户按下回车键时，输入结束。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;String readLine(String fmtString,Object...args)&lt;/td&gt;
&lt;td&gt;提供一个格式化提示，然后从控制台读取单行文本。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;char[] readPassword()&lt;/td&gt;
&lt;td&gt;从控制台读取密码，禁用回显。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;char[] readPassword(String fmtString,Object...args)&lt;/td&gt;
&lt;td&gt;提供一个格式化提示，然后从控制台读取密码，禁用回显。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PrintWriter writer()&lt;/td&gt;
&lt;td&gt;返回对连接到控制台的Writer对象的引用&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;









&lt;p&gt;　　注意：在IDE中启动时，控制台引用是null。&lt;/p&gt;
&lt;h3&gt;序列化&lt;/h3&gt;
&lt;h4&gt;序列化的应用&lt;/h4&gt;
&lt;p&gt;　　序列化是将对象写入字节流的过程，可以实现将对象保存到文件中，并且可以通过反序列化过程来恢复这些对象。&lt;/p&gt;
&lt;p&gt;　　实现远程方法调用也需要序列化，远程方法调用允许在一个机器上的java对象调用在另外一台机器上的java对象的方法，可以将对象作为参数提供给远程方法，发送机器序列化对象并且进行传递。&lt;/p&gt;
&lt;p&gt;　　假设将要序列化的对象具有指向其他对象的引用，而这些对象又具有更多对象的引用。&lt;/p&gt;
&lt;p&gt;　　这些对象以及他们之间的关系形成了一张对象网，在这个对象网中，还可能存在环形引用，对象也可能包含指向他们自身的引用，在这些情形中，对象的序列化和反序列化都能够正确的工作。&lt;/p&gt;
&lt;p&gt;　　如果试图序列化位于对象图顶部的对象，那么所有其他引用的对象都会被递归的定位和序列化，类似的，在反序列化的过程中，能够正确的恢复所有这些对象以及对他们的引用。&lt;/p&gt;
&lt;p&gt;　　对象的默认序列化机制写入的内容是：对象的类，类签名，以及非瞬态和非静态字段的值。其他对象的引用（瞬态和静态字段除外）也会导致写入那些对象。可使用引用共享机制对单个对象的多个引用进行编码，这样即可将对象的图形恢复为最初写入它们时的形状。&lt;/p&gt;
&lt;h4&gt;Serializable&lt;/h4&gt;
&lt;p&gt;　　只有实现了Serializable接口的类才能够通过序列化功能进行保存和恢复。&lt;/p&gt;
&lt;p&gt;　　Serializable接口没有定义成员，只是简单的用于指示类可以被序列化，如果一个类是可序列化的，那么这个类的所有子类也都是可序列化的。&lt;/p&gt;
&lt;h4&gt;保存和加载序列化对象&lt;/h4&gt;
&lt;h5&gt;ObjectOutputStream类&lt;/h5&gt;
&lt;p&gt;　　ObjectOutputStream类负责将对象写入流中，只能将支持 java.io.Serializable 接口的对象写入流中，每个 serializable 对象的类都被编码，编码内容包括类名和类签名、对象的字段值和数组值，以及从初始对象中引用的其他所有对象的闭包。&lt;/p&gt;
&lt;p&gt;构造函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　ObjectOutputStream(OutputStream outStream)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　参数outStream是将向其中写入序列化对象的输出流，关闭ObjectOutputStream对象会自动关闭OutStream指定的底层流。&lt;/p&gt;
&lt;p&gt;　　void writerObject()方法用于将对象写入流中。所有对象（包括 String 和数组）都可以通过 writeObject 写入。可将多个对象或基元写入流中。必须使用与写入对象时相同的类型和顺序从相应 ObjectInputstream 中读回对象。&lt;/p&gt;
&lt;h5&gt;ObjectInputStream类&lt;/h5&gt;
&lt;p&gt;　　ObjectInputStream 对以前使用 ObjectOutputStream 写入的基本数据和对象进行反序列化。&lt;/p&gt;
&lt;p&gt;　　ObjectOutputStream 和 ObjectInputStream 分别与 FileOutputStream 和 FileInputStream 一起使用时，可以为应用程序提供对对象图形的持久存储。ObjectInputStream 用于恢复那些以前序列化的对象。其他用途包括使用套接字流在主机之间传递对象，或者用于编组和解组远程通信系统中的实参和形参。&lt;/p&gt;
&lt;p&gt;　　只有支持 java.io.Serializable 或 java.io.Externalizable 接口的对象才能从流读取。&lt;/p&gt;
&lt;p&gt;　　读取对象类似于运行新对象的构造方法。为对象分配内存并将其初始化为零 (NULL)。为不可序列化类调用无参数构造方法，然后从以最接近 java.lang.object 的可序列化类开始和以对象的最特定类结束的流恢复可序列化类的字段。&lt;/p&gt;
&lt;p&gt;下面示例从文件存取对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;try&lt;/span&gt;(FileOutputStream file = &lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;./io/src/serializables/1.txt&quot;&lt;span&gt;)){
            ObjectOutputStream oos &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectOutputStream(file);
            oos.writeInt(&lt;/span&gt;12345&lt;span&gt;);
            oos.writeObject(&lt;/span&gt;&quot;Today2&quot;&lt;span&gt;);
            oos.writeObject(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
            oos.close();
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;(FileInputStream file = &lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;./io/src/serializables/1.txt&quot;&lt;span&gt;)){
            ObjectInputStream ois &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ObjectInputStream(file);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; ois.readInt();
            String name &lt;/span&gt;=&lt;span&gt; (String) ois.readObject();
            Date date &lt;/span&gt;=&lt;span&gt; (Date) ois.readObject();
            ois.close();
            System.out.println(&lt;/span&gt;&quot;i:&quot;+i+&quot;,name:&quot;+name+&quot;,date:&quot;+&lt;span&gt;date);
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            e.printStackTrace();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;序列化的控制&lt;/h4&gt;
&lt;h5&gt;Externalizable接口&lt;/h5&gt;
&lt;p&gt;　　java对序列化和反序列化的功能都可以自动进行，然而在有些情况，我们可能需要控制这些过程，比如可能希望使用压缩和加密技术，此时就需要Externalizable接口了。&lt;/p&gt;
&lt;p&gt;　　在这些特殊情况下，可以通过实现Externalizable接口来代替实现Serializable接口，&lt;/p&gt;
&lt;p&gt;　　它有两个方法WriterExternal()和ReadExternal()必须被实现，这两个方法会在序列化和反序列化的过程中被自动调用，以便执行一些特殊操作。&lt;/p&gt;
&lt;p&gt;比如下面这个PersonExternalizableVo类，它的存取过程都必须手动实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PersonExternalizableVo &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Externalizable {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; writeExternal(ObjectOutput out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        out.writeInt(id);
        out.writeObject(name);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; readExternal(ObjectInput in) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ClassNotFoundException {
        id &lt;/span&gt;=&lt;span&gt; in.readInt();
        name &lt;/span&gt;=&lt;span&gt; (String)in.readObject();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;getter...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;setter...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;toString...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;瞬态和静态&lt;/h5&gt;
&lt;p&gt;　　当我们队序列化进行控制时，可能某个特定的子对象不想让java的序列化机制自动保存与恢复，如果子对象表示的是我们不希望将其序列化的敏感信息（如密码），通常就会面临这种情况，有两种办法可以实现这种需求。&lt;/p&gt;
&lt;p&gt;　　第一种是瞬态，关键字transient。&lt;/p&gt;
&lt;p&gt;比如以下password字段将不会被序列化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　&lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; String password;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第二种是静态，即static静态属性。&lt;/p&gt;
&lt;p&gt;　　序列化机制在遇到瞬态和静态属性时候会自动忽略。&lt;/p&gt;
&lt;p&gt;　　注意：实现Externalizable的对象在默认情况下是不会保存任何字段的，所以transient字段只能用再实现了Serializable接口的类中。&lt;/p&gt;
&lt;h3&gt;File类&lt;/h3&gt;
&lt;h4&gt;文件操作&lt;/h4&gt;
&lt;p&gt;　　尽管java.io定义的大多数类都是操作流，但是File类却不是，File类直接处理文件和文件系统，也就是说，File类没有指定如何从文件检索信息以及如何向文件中存储信息。&lt;/p&gt;
&lt;p&gt;　　精确的说，File类是文件和目录路径名的抽象表示形式。&lt;/p&gt;
&lt;p&gt;　　File类的实例是不可变的；也就是说，一旦创建，File 对象表示的抽象路径名将永不改变。&lt;/p&gt;
&lt;p&gt;构造方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　File(String directoryPath)
　　File(String directoryPath,String filename)
　　File(File dirObj,String filename)
　　File(URI uriObj)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中，directoryPath是文件的路径名，filename是文件或者子目录的名称，dirObj是指定目录的File对象，uriObj是描述文件的URI对象。&lt;/p&gt;
&lt;p&gt;下面的示例创建了3个File对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　File f1 = &lt;span&gt;new&lt;/span&gt; File(&quot;/&quot;&lt;span&gt;);
　　File f2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(&quot;/&quot;,&quot;1.txt&quot;&lt;span&gt;)
　　File f3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(f1,&quot;1.txt&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般的方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        File file = &lt;span&gt;new&lt;/span&gt; File(&quot;./io/src/files/1.txt&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;名称:&quot;+&lt;span&gt;file.getName());
        System.out.println(&lt;/span&gt;&quot;路径名称:&quot;+&lt;span&gt;file.getPath());
        System.out.println(&lt;/span&gt;&quot;绝对路径名称:&quot;+&lt;span&gt;file.getAbsolutePath());
        System.out.println(&lt;/span&gt;&quot;父目录的路径名称:&quot;+&lt;span&gt;file.getParent());
        System.out.println(&lt;/span&gt;&quot;是否存在:&quot;+&lt;span&gt;file.exists());
        System.out.println(&lt;/span&gt;&quot;是否可写:&quot;+&lt;span&gt;file.canWrite());
        System.out.println(&lt;/span&gt;&quot;是否可读:&quot;+&lt;span&gt;file.canRead());
        System.out.println(&lt;/span&gt;&quot;是否隐藏:&quot;+&lt;span&gt;file.isHidden());
        System.out.println(&lt;/span&gt;&quot;是否是目录:&quot;+&lt;span&gt;file.isDirectory());
        System.out.println(&lt;/span&gt;&quot;是否是文件:&quot;+&lt;span&gt;file.isFile());
        System.out.println(&lt;/span&gt;&quot;是否是绝对路径:&quot;+&lt;span&gt;file.isAbsolute());
        System.out.println(&lt;/span&gt;&quot;最后一次修改时间:&quot;+&lt;span&gt;file.lastModified());
        System.out.println(&lt;/span&gt;&quot;文件大小:&quot;+file.length()+&quot;bytes&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当File表示的路径是一个目录时，可以调用list()方法获取目录下的路径列表&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        File file1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(file.getParent());
        String[] s &lt;/span&gt;=&lt;span&gt; file1.list();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String str : s){
            System.out.println(str);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一些有用的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　&lt;span&gt;boolean&lt;/span&gt; renameTo(File newName);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重命名&lt;/span&gt;
　　&lt;span&gt;boolean&lt;/span&gt; mkdir();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建该名称&lt;/span&gt;
　　&lt;span&gt;boolean&lt;/span&gt; mkdirs();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归创建该路径&lt;/span&gt;
　　&lt;span&gt;boolean&lt;/span&gt; delete();删除文件，如果目录为空的话可以删除目录。
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;文件筛选&lt;/h4&gt;
&lt;p&gt;　　list()方法还有一个使用形式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　String[] list(FilenameFilter fiter);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在这种形式中，fiter是一个实现了FilenameFilter接口的对象，该对象中实现了accept(File dir, String name)方法，该方法返回boolean值，会针对每个文件调用一次，返回true代表选择，返回false代表过滤掉。&lt;/p&gt;
&lt;p&gt;使用示例如下 只返回.txt后缀的文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OnlyExt &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; FilenameFilter {
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String ext;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; OnlyExt(String str){
        ext &lt;/span&gt;= &quot;.&quot;+&lt;span&gt;str;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; accept(File dir, String name) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name.endsWith(ext);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        FilenameFilter filenameFilter = &lt;span&gt;new&lt;/span&gt; OnlyExt(&quot;txt&quot;&lt;span&gt;);
        String[] strs &lt;/span&gt;=&lt;span&gt; file1.list(filenameFilter);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String t : strs){
            System.out.println(t);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;文件列表对象&lt;/h4&gt;
&lt;p&gt;　　list()方法还有一种形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　File[] listFiles()
　　File[] listFiles(FilenameFiter fiter)
　　File[] listFiles(FileFiter fiter)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　它返回的是File对象数组。&lt;/p&gt;
&lt;p&gt;　　第三个构造函数的实现方法是accept(File path)，也是对每个文件调用一次&lt;/p&gt;
&lt;p&gt;以下改写OnlyExt类，使之筛选出同样的文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FilterExt &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; FileFilter {
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; String ext;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FilterExt(String str){
        ext &lt;/span&gt;= &quot;.&quot;+&lt;span&gt;str;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; accept(File pathname) {
        String name &lt;/span&gt;=&lt;span&gt; pathname.getName();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name.endsWith(ext);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        FileFilter fileFilter = &lt;span&gt;new&lt;/span&gt; FilterExt(&quot;txt&quot;&lt;span&gt;);
        File[] files &lt;/span&gt;=&lt;span&gt; file1.listFiles(fileFilter);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(File f :files){
            System.out.println(f.getName());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;写在最后&lt;/h3&gt;
&lt;p&gt;　　源码分享：&lt;a href=&quot;https://gitee.com/zhao-baolin/java_learning/tree/master/io&quot; target=&quot;_blank&quot;&gt;https://gitee.com/zhao-baolin/java_learning/tree/master/io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　io只是一部分，后面还会整理新io的知识，系统的知识储备是非常非常非常重要的事情。&lt;/p&gt;
&lt;p&gt;　　学习这条路，永无止境。&lt;/p&gt;
&lt;p&gt;　　你好，再见。&lt;/p&gt;
</description>
<pubDate>Tue, 13 Nov 2018 06:37:00 +0000</pubDate>
<dc:creator>不该相遇在秋天</dc:creator>
<og:description>java的I/O系统是一个大块头，包含的东西太多了（就贴接口表格就能贴的让人头晕目眩），而且内容顺序不好安排，横切有字节流字符流，竖切有输入输出，再加新旧几轮迭代，三个维度纵横交错，真的不好写，以至于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fengyumeng/p/9952079.html</dc:identifier>
</item>
</channel>
</rss>