<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>云心出岫——Splay Tree - 仪式黑刃</title>
<link>http://www.cnblogs.com/hongshijie/p/9497158.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongshijie/p/9497158.html</guid>
<description>&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;之前我们谈论过&lt;span lang=&quot;zh-CN&quot;&gt;AVL&lt;span lang=&quot;zh-CN&quot;&gt;树，这是一种典型适度平衡的二叉搜索树，成立条件是保持平衡因子在&lt;span lang=&quot;en-US&quot;&gt;[-1,1]的范围内&lt;span lang=&quot;zh-CN&quot;&gt;，这个条件已经是针对理想平衡做出的一个妥协了，但依然显得过于苛刻，因为在很多时候我们需要频繁的做重平衡操作，能不能改进一下，让失衡先积累着，然后等到某个时机，一下子全部解决呢？严谨一点来水就是我们能否秉持一种更为宽松的准则，同时又从长远、整体的角度来看，依然不失某种意义上的平衡性呢？如果比作人的话，&lt;span lang=&quot;zh-CN&quot;&gt;AVL&lt;span lang=&quot;zh-CN&quot;&gt;树就犹如那种处处谨慎的性格，一点风吹草动就要调整自己。那么&lt;span lang=&quot;en-US&quot;&gt;……&lt;span lang=&quot;zh-CN&quot;&gt;能否成为那类更为潇洒的人呢？怎样才能御风蓬叶，泛彼无垠，不被苛刻的平衡所拘束呢？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;根据写作套路，那肯定就是点题了……对！就是伸展树了，他的出现是因为有人注意到了在信息处理过程中的&lt;span lang=&quot;en-US&quot;&gt;“&lt;span lang=&quot;zh-CN&quot;&gt;局部性&lt;span lang=&quot;en-US&quot;&gt;”&lt;span lang=&quot;zh-CN&quot;&gt;，就是刚被访问过的数据，极有可能很快的被再次访问到，只要针对这个特性大做文章，就能切中肯綮，而不用对“保持平衡”这件事风声鹤唳了。这也是下面我们要分析的重点。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在二叉搜索树里也时常遇到，主要是两种情况：&lt;/p&gt;
&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;每次刚刚访问过的某一个节点有可能很快的会再次被我们访问到&lt;/li&gt;
&lt;li&gt;下次访问的节点即便不是刚访问过的那个节点，也不会离得太远&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过此前的学习我们已经知道，对于AVL树而 每一次查找所需的时间都是logn，因此任意的连续m次查找，所需要的累积时间就是mlogn，为了改进，就针对这个局部性来做一做文章吧：&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; 先来看一个例子，然后类比推理即可。链表里越靠近表头的节点的查找速度越快，遍历所走的步数少嘛，那么如果数据访问有局部性，我们就——访问一个元素后立即把他移动到最前端。&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180820034419992-1922217186.png&quot; alt=&quot;&quot; width=&quot;624&quot; height=&quot;131&quot;/&gt;&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt;这样做的逻辑是：根据局部性，接下来将要访问的元素很可能就是刚访问的那个元素，而这个元素就在最前端，头部元素的访问是访问是唾手可得的，走一步就到了。从整个数据结构的生命周期而言，这样一个列表结构即便最初是完全随机分布的，在经过了足够长时间的使用之后，在某一段时间内被集中访问的元素都会集中到这个列表的前端去。我们已经知道这个区域（列表前段部分）的访问效率是相应更高的，那就能有更高的访问效率了。&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;现在回到二叉树，为了对比就让树横过来。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180820034452581-18605573.png&quot; alt=&quot;&quot; width=&quot;535&quot; height=&quot;202&quot;/&gt;&lt;/p&gt;

&lt;p&gt;树的顶部元素访问效率更高，所以我们要参照列表，把经常要访问到的元素尽可能的移送到接近树根的位置，也就是要尽可能的降低他们的深度。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180820034509751-2045464734.png&quot; alt=&quot;&quot; width=&quot;537&quot; height=&quot;205&quot;/&gt; &lt;/p&gt;


&lt;p&gt;那我们就这么办：某个元素一经访问，就把它移到树根处。具体做法就是把被访问元素不断做旋转操作直到抵达树根，这样的策略被称为“逐层伸展”，是一种朴素的想法，但是不够好，因为在最坏情况下树退化为一条单链，我们来个极端的，每次恶意访问最深的节点，就会变成这样：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180820034520746-933824319.png&quot; alt=&quot;&quot; width=&quot;399&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;先注意一下特征：每层只挂了一个节点，这是弊端所在，后面还会提到。然后经过一轮询问，这个树就&lt;span lang=&quot;en-US&quot;&gt;复原了&lt;span lang=&quot;zh-CN&quot;&gt;。看一下整个过程（竖着看）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180820034530723-1502220990.png&quot; alt=&quot;&quot; width=&quot;605&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;我们分析一下这一轮操作的代价：假设树的规模是&lt;span lang=&quot;en-US&quot;&gt;n&lt;span lang=&quot;zh-CN&quot;&gt;，访问&lt;span lang=&quot;en-US&quot;&gt;第一个最深节点的成本是n&lt;span lang=&quot;zh-CN&quot;&gt;，第二个节点&lt;span lang=&quot;en-US&quot;&gt;是n-1&lt;span lang=&quot;zh-CN&quot;&gt;，第三个是&lt;span lang=&quot;en-US&quot;&gt;n-2&lt;span lang=&quot;zh-CN&quot;&gt;，然后是&lt;span lang=&quot;en-US&quot;&gt;n-3&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;n-4和最终的1&lt;span lang=&quot;zh-CN&quot;&gt;。整个成本按算术级数增长，这就很恐怖了，总体时间O（N&lt;sup&gt;2&lt;/sup&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;），分摊到整个周期的&lt;span lang=&quot;en-US&quot;&gt;n次操作&lt;span lang=&quot;zh-CN&quot;&gt;，复杂度Ω&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;（&lt;span lang=&quot;en-US&quot;&gt;N&lt;span lang=&quot;zh-CN&quot;&gt;）居高不下，和AVL树的&lt;span lang=&quot;en-US&quot;&gt;logN相差甚远&lt;span lang=&quot;zh-CN&quot;&gt;，这已经沦落到了线性序列的地步。另外还有一个弊端在于：我们需要为此考虑很多种特殊情况。所以这个策略无法让人满意。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;我们还要另找方法——在初始访问路径上进行一些神奇的旋转，只用了O（&lt;span lang=&quot;en-US&quot;&gt;1&lt;span lang=&quot;zh-CN&quot;&gt;）的空间，而且保持O（log&lt;span lang=&quot;en-US&quot;&gt;N&lt;span lang=&quot;zh-CN&quot;&gt;）&lt;span lang=&quot;en-US&quot;&gt;的时间复杂度&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;具体而言就是：双层伸展，向上追溯两层，通过两次旋转把被访问节点&lt;span lang=&quot;en-US&quot;&gt;上移至祖父的位置&lt;span lang=&quot;zh-CN&quot;&gt;，而且！不是像之前一样自下而上伸展，而是自顶向下进行伸展。这可以说是Splay&lt;span lang=&quot;en-US&quot;&gt;Tree的点睛之笔&lt;span lang=&quot;zh-CN&quot;&gt;。这是在&lt;span lang=&quot;en-US&quot;&gt;1985年Tarjan大神的一篇论文&lt;span lang=&quot;zh-CN&quot;&gt;《&lt;span lang=&quot;zh-CN&quot;&gt;Self-adjusting binary search trees&lt;span lang=&quot;zh-CN&quot;&gt;》&lt;span lang=&quot;en-US&quot;&gt;里提出来的，有兴趣可以去Google Scholar上瞻仰一番&lt;span lang=&quot;zh-CN&quot;&gt;（和他有关的还有一个Tarjan算法，是关于图的连通性的神奇算法）。祖孙三代&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;的相对位置无非四种：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180820034545155-1485729712.png&quot; alt=&quot;&quot; width=&quot;383&quot; height=&quot;339&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;子孙异侧&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先从难啃的骨头开始。有些书上会把这种情况称为“之字形”，以此为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180820034900487-1902706369.png&quot; alt=&quot;&quot; width=&quot;734&quot; height=&quot;204&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;“这特&lt;/span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;么不就是双旋转么，而且这也就是逐层伸展两次而已，没什么实质区别啊（摔）”，没错，这个部分区别不大，但重点在于另外这条龙一只眼睛，那才是闪光之处：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;zh-CN&quot;&gt;子孙同侧&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;有些书上也称为“一字形”。&lt;span lang=&quot;en-US&quot;&gt;我们先看一下逐层伸展的调整过程&lt;span lang=&quot;zh-CN&quot;&gt;，然后和T&lt;span lang=&quot;en-US&quot;&gt;arjan的策略作一比较&lt;span lang=&quot;zh-CN&quot;&gt;，就知道差距有多大了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180820034915901-1675881667.png&quot; alt=&quot;&quot; width=&quot;717&quot; height=&quot;213&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这是我们凡人想到的方法。下面是Tarjan的点睛之笔：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180820034920051-2258662.png&quot; alt=&quot;&quot; width=&quot;712&quot; height=&quot;220&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;这里的重中之重是：需要首先越级，从祖父而不是父节点来开始旋转，具体来说就是，经过祖父节点的一次左&lt;span lang=&quot;en-US&quot;&gt;-&lt;span lang=&quot;zh-CN&quot;&gt;左旋转，节点&lt;span lang=&quot;zh-CN&quot;&gt;p&lt;span lang=&quot;zh-CN&quot;&gt;以及&lt;span lang=&quot;zh-CN&quot;&gt;v&lt;span lang=&quot;zh-CN&quot;&gt;都会上升一层。接下来对新的树根也就是&lt;span lang=&quot;zh-CN&quot;&gt;p&lt;span lang=&quot;zh-CN&quot;&gt;，再做一次左&lt;span lang=&quot;en-US&quot;&gt;-&lt;span lang=&quot;zh-CN&quot;&gt;左旋转，把v拉上来成为树根，Done。把这两种方法作一对比，&lt;span lang=&quot;en-US&quot;&gt;emmm好像没什么大差别啊&lt;span lang=&quot;zh-CN&quot;&gt;，是吧？的确这里面的神奇之处一时半会难以察觉，看起来反正都是提高了两层倍，不过它们&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;在局部拓扑结构上还是有微妙差异的，更重要的是——这种局部的微妙差异将导致全局的不同，而且那种不同将是根本性的、颠覆性的！Splay Tree在这个伸展方式的革命中失去的只是锁链，他们获得的将是整个世界。&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; 现在来看看这个差异所带来的利好。如果用这种方式我们再来访问最深的节点，会有什么改进呢？ &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180820034949162-1158936964.png&quot; alt=&quot;&quot; width=&quot;590&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;现在的改进在于每一层能挂更多的节点了，这就是有效控制树高的一个方法。之前说的逐层伸展最坏情况之所以“坏”是因为，尽管能调整到树根，但是在这个过程中树的高度会以算术级数的速度急剧膨胀，这是一种不计后果的方法，所以很坏。而T&lt;span lang=&quot;en-US&quot;&gt;arjan的方法优越性在于&lt;span lang=&quot;zh-CN&quot;&gt;，在每次即使访问最深的节点时候，也能控制树高，渐进意义上是之前逐层伸展树高的一半，记得前面说的“会导致全局的不同”么，就是这里的树高缩减一半！这个特性太好了，节点越多，访问次数越多，这个控制的效果越明显，这也被称为Splay&lt;span lang=&quot;en-US&quot;&gt;Tree的折叠效果&lt;span lang=&quot;zh-CN&quot;&gt;。那么总结一下双层伸展的核心优势——&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180820035002936-778574673.png&quot; alt=&quot;&quot; width=&quot;644&quot; height=&quot;329&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;通过这个例子可以看出：任何一个节点经过访问，再经双层调整后，这个节点所在的路径长度就会减半。甚至可以说&lt;span lang=&quot;zh-CN&quot;&gt;——&lt;span lang=&quot;zh-CN&quot;&gt;这种效果具有某种意义上的智能：既然在一棵&lt;span lang=&quot;zh-CN&quot;&gt;BST&lt;span lang=&quot;zh-CN&quot;&gt;中非常忌讳访问很深的节点（这会导致复杂度急剧上升），那这种折叠效果自然就会具有对坏节点的修复作用，我们就不必担心了。犹如含羞草一旦感受到威胁，就会通过迅速收缩，将自己的弱点隐藏起来。因此在采用&lt;span lang=&quot;zh-CN&quot;&gt;Tarjan&lt;span lang=&quot;zh-CN&quot;&gt;所建议的这种新的策略之后，刚才所举的那种最坏情况就不至持续的发生，可以证明的是单次操作的时间上界是O（log&lt;span lang=&quot;en-US&quot;&gt;N&lt;span lang=&quot;zh-CN&quot;&gt;）。这&lt;span lang=&quot;en-US&quot;&gt;也就是说&lt;span lang=&quot;zh-CN&quot;&gt;！&lt;span lang=&quot;en-US&quot;&gt;我们现在不仅足以应对此前涉及的最坏情况&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;而且也不会有任何其他的最坏情况&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;这是一个再好不过的消息了&lt;span lang=&quot;zh-CN&quot;&gt;，简直让人开心到爆炸啊！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;复习一下：对Splay Tree最合适的做法是&lt;span lang=&quot;zh-CN&quot;&gt;双层伸展，即向上追溯两层，通过两次旋转把被访问节点&lt;span lang=&quot;en-US&quot;&gt;上移至祖父的位置&lt;span lang=&quot;zh-CN&quot;&gt;，并且宏观看来是自顶向下进行伸展。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;现在&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;我们先把以上的伸展策略由理想变为现实，然后以此作为基础，去缔造更丰富的功能。&lt;/p&gt;
&lt;p&gt;先给出相关的类型声明和要用到的组件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#ifndef Splay_h
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; Splay_h
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; SplayNode;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt; SplayNode *&lt;span&gt;SplayTree;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt; SplayNode *&lt;span&gt;Position;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; SplayTree FindIn(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x,SplayTree T);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; SplayTree Splaying(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Item,Position X);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; SplayTree Insert(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Item,SplayTree T);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; SplayTree Remove(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Item,SplayTree T);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;SplayTree FindMin(SplayTree T);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;Position FindMax(SplayTree T);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Retrieve(SplayTree T);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#endif&lt;/span&gt; /* Splay_h */
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; SplayNode{
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    SplayTree left;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    SplayTree right;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Position SingleRotateWithLeft(Position p){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;zig&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     Position temp=p-&amp;gt;&lt;span&gt;left;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     p-&amp;gt;left=temp-&amp;gt;&lt;span&gt;right;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     temp-&amp;gt;right=&lt;span&gt;p;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     
&lt;span&gt;28&lt;/span&gt; }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;zig&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Position SingleRotateWithRight(Position g){
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     Position temp=g-&amp;gt;&lt;span&gt;right;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     g-&amp;gt;right=temp-&amp;gt;&lt;span&gt;left;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     temp-&amp;gt;left=&lt;span&gt;g;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;zag&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后我们要把一棵树从无到有的过程给做出来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Position Origin=&lt;span&gt;NULL;  
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;SplayTree Init(){
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!Origin) {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;When the tree we talked about is non-exsitent.&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         Origin=(SplayTree)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; SplayNode));
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         Origin-&amp;gt;left=Origin-&amp;gt;right=&lt;span&gt;NULL;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Origin;
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里用Origin代表空指针是为了代码的可读性，这样日后再看起来就能通过变量名清晰地理解代码含义了。不至于过三个月自己写的代码都看不懂2333&lt;/p&gt;

&lt;p&gt;下面给出双层伸展过程，这是一个被动技能，上一篇里讲的已经很清楚了所以注释就稍微简略一些。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Top-down splay procedure,not requiring Item to be in the tree&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; SplayTree Splaying(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Item,Position X) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; SplayNode Header;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    Position LeftMax,RightMin;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     Header.left=Header.right=&lt;span&gt;Origin;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     LeftMax=RightMin=&amp;amp;&lt;span&gt;Header;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     Origin-&amp;gt;value=&lt;span&gt;Item;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (Item != X-&amp;gt;&lt;span&gt;value) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (Item &amp;lt; X-&amp;gt;&lt;span&gt;value) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (Item &amp;lt; X-&amp;gt;left-&amp;gt;&lt;span&gt;value) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 X=&lt;span&gt;SingleRotateWithLeft(X);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(X-&amp;gt;left==&lt;span&gt;Origin)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Link right&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             RightMin-&amp;gt;left=&lt;span&gt;X;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             RightMin=&lt;span&gt;X;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             X=X-&amp;gt;&lt;span&gt;left;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(Item &amp;gt; X-&amp;gt;right-&amp;gt;&lt;span&gt;value)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 X=&lt;span&gt;SingleRotateWithRight(X);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(X-&amp;gt;right==&lt;span&gt;Origin)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Link left&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             LeftMax-&amp;gt;right=&lt;span&gt;X;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             LeftMax=&lt;span&gt;X;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             X=X-&amp;gt;&lt;span&gt;right;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     }&lt;span&gt;//&lt;/span&gt;&lt;span&gt;while Item != X-&amp;gt;value
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Reassemble&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     LeftMax-&amp;gt;right=X-&amp;gt;&lt;span&gt;left;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     RightMin-&amp;gt;left=X-&amp;gt;&lt;span&gt;right;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     X-&amp;gt;left=&lt;span&gt;Header.right;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     X-&amp;gt;right=&lt;span&gt;Header.left;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; X;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;然后是插入，这个要分情况讨论。&lt;span lang=&quot;en-US&quot;&gt;假设T是当前的树根&lt;span lang=&quot;zh-CN&quot;&gt;，如果T是空树，那么我们建立一颗单节点树。否则的话就围绕着Item把T展开，先把T提到树根的位置（下面的两种情况演示都建立在执行过对T伸展之后）。如果已经存在这个元素，就什么也不做，直接返回。其他的情况就剩&lt;span lang=&quot;en-US&quot;&gt;ins &amp;gt; T 或者 ins &amp;lt; T 了&lt;span lang=&quot;zh-CN&quot;&gt;，我们来分别讨论，比如在下图中插入&lt;span lang=&quot;en-US&quot;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818134459805-31790422.png&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;312&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第一步先申请一个节点 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818134529129-1857698954.png&quot; alt=&quot;&quot; width=&quot;336&quot; height=&quot;297&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;然后比较当前根和待插入节点的数值，如果根大了的话，那么就让T和它的右子树一同作为&lt;span lang=&quot;en-US&quot;&gt;newNode的一棵右子树&lt;span lang=&quot;zh-CN&quot;&gt;，相应地让T的左子树成为&lt;span lang=&quot;en-US&quot;&gt;newNode的左子树&lt;span lang=&quot;zh-CN&quot;&gt;。并且让T的左指针收回去。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818134603797-1482425728.png&quot; alt=&quot;&quot; width=&quot;343&quot; height=&quot;257&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后因为要返回T，把T所存的地址变更为新的树根即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818134647181-53818322.png&quot; alt=&quot;&quot; width=&quot;348&quot; height=&quot;322&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一道非常美味的Splay树插入过程就制作完成了。&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;这是根&lt;span lang=&quot;en-US&quot;&gt;&amp;gt;&lt;span lang=&quot;zh-CN&quot;&gt;待插入节点，那如果根&lt;span lang=&quot;en-US&quot;&gt;&amp;lt;待插入节点呢&lt;span lang=&quot;zh-CN&quot;&gt;？逻辑是类似而又对称的。比如在上图的基础上插入&lt;span lang=&quot;en-US&quot;&gt;15&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818134831619-1919545139.png&quot; alt=&quot;&quot; width=&quot;409&quot; height=&quot;244&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;比较&lt;span lang=&quot;en-US&quot;&gt;root的值和ins的值&lt;span lang=&quot;zh-CN&quot;&gt;，比&lt;span lang=&quot;en-US&quot;&gt;root大&lt;span lang=&quot;zh-CN&quot;&gt;，那就让T和它的左子树一同作为&lt;span lang=&quot;en-US&quot;&gt;newNode的左子树&lt;span lang=&quot;zh-CN&quot;&gt;，让T的右子树成为&lt;span lang=&quot;en-US&quot;&gt;newNode的右子树&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818134852478-1390175600.png&quot; alt=&quot;&quot; width=&quot;371&quot; height=&quot;245&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 最后变更一下T的值，即可。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818134923550-493122004.png&quot; alt=&quot;&quot; width=&quot;299&quot; height=&quot;285&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其他的细节都很好理解了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; SplayTree Insert(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Item,SplayTree T) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;T means original root&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; Position NewNode=&lt;span&gt;NULL;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;NewNode)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         NewNode=&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; SplayNode));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     NewNode-&amp;gt;value=&lt;span&gt;Item;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (T==&lt;span&gt;Origin)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         NewNode-&amp;gt;left=NewNode-&amp;gt;right=&lt;span&gt;NULL;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         T=&lt;span&gt;NewNode;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         T=&lt;span&gt;Splaying(Item, T);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (T-&amp;gt;value &amp;gt;&lt;span&gt; Item)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;look at left subtree&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             NewNode-&amp;gt;left=T-&amp;gt;&lt;span&gt;left;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             NewNode-&amp;gt;right=&lt;span&gt;T;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             T-&amp;gt;left=&lt;span&gt;Origin;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             T=NewNode;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;make inserted element as root of tree&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(T-&amp;gt;value &amp;lt;&lt;span&gt; Item)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;look at right subtree&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             NewNode-&amp;gt;right=T-&amp;gt;&lt;span&gt;right;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             NewNode-&amp;gt;left=&lt;span&gt;T;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             T-&amp;gt;right=&lt;span&gt;Origin;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             T=NewNode;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;make inserted element as root of tree&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; T; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Already in the tree,we do nothing.&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     
&lt;span&gt;38&lt;/span&gt;     NewNode=&lt;span&gt;NULL;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  it given convince for the next insert,then next insert will call malloc straightly&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; T;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;always make the parameter T act as the root be returned&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后说删除，这个删除就轻松多了，因为每次展开之后，待删除的元素已经放在根的位置了。话说删除过程比对应的插入过程还要简短，这实属罕见.....&lt;/p&gt;
&lt;p&gt;先举个例子，我们要删除5。这是删除前的图，用T表示删除之前全树的树根（切记，不然后面容易搞混）： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818135200855-229552754.png&quot; alt=&quot;&quot; width=&quot;291&quot; height=&quot;329&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;对&lt;span lang=&quot;en-US&quot;&gt;5做一次Splaying&lt;span lang=&quot;zh-CN&quot;&gt;，就到顶点了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818135237266-954207320.png&quot; alt=&quot;&quot; width=&quot;287&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;当根左子树存在的时候，临时节点（&lt;span lang=&quot;en-US&quot;&gt;new tree&lt;span lang=&quot;zh-CN&quot;&gt;）抓住&lt;span lang=&quot;en-US&quot;&gt;left subtree&lt;span lang=&quot;zh-CN&quot;&gt;，以便作为日后的根，接着做一次展开，New&lt;span lang=&quot;en-US&quot;&gt;tree就变成新的根了&lt;span lang=&quot;zh-CN&quot;&gt;，然后让newTree的右侧挂钩抓住T的右子树&lt;span lang=&quot;en-US&quot;&gt;…我自己画个图吧&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818135356439-1590699347.png&quot; alt=&quot;&quot; width=&quot;383&quot; height=&quot;272&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;然后把原来的根&lt;span lang=&quot;en-US&quot;&gt;T&lt;span lang=&quot;zh-CN&quot;&gt;（所指的那块内存）&lt;span lang=&quot;en-US&quot;&gt;free&lt;span lang=&quot;en-US&quot;&gt;掉&lt;span lang=&quot;zh-CN&quot;&gt;，当然这时候T还是存在的，只是那块内存还给OS了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818135424745-1493014240.png&quot; alt=&quot;&quot; width=&quot;411&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来为了保持程序逻辑的统一性，我们还是返回T，为了让T指向正确的位置，就让T指向当前的根。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180818135734482-1858226003.png&quot; alt=&quot;&quot; width=&quot;403&quot; height=&quot;325&quot;/&gt;&lt;/p&gt;

&lt;p&gt;大功告成，然后把T打发回去就好了。具体过程如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; SplayTree Remove(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Item,SplayTree T){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Position NewTree;  &lt;span&gt;//
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (T) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         T=&lt;span&gt;Splaying(Item, T);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (Item==T-&amp;gt;&lt;span&gt;value) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;primarily we find it&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(!T-&amp;gt;&lt;span&gt;left)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 NewTree=T-&amp;gt;&lt;span&gt;right;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 NewTree=T-&amp;gt;&lt;span&gt;left;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 NewTree=&lt;span&gt;Splaying(Item, NewTree);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 NewTree-&amp;gt;right=T-&amp;gt;&lt;span&gt;right;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(T);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             T=&lt;span&gt;NewTree;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; T;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;写到这里我不禁想吐槽一下课本，多给点步骤图不行么……我一开始脑内调试了好久才完全理解的。为了减轻我们的学习成本，我就把里面每一个步骤的分解动作都画出来了，希望能弥补原书缺少实例的这一缺憾吧，书是好书，就是太抽象了&lt;span lang=&quot;en-US&quot;&gt;2333  如果光看代码没有实例步骤图，只有抽象的开始图片和结束图片，就很难迅速理解。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;伸展树到这里就结束了&lt;span lang=&quot;zh-CN&quot;&gt;，下一站是——红黑树！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 19 Aug 2018 22:01:00 +0000</pubDate>
<dc:creator>仪式黑刃</dc:creator>
<og:description>之前我们谈论过AVL树，这是一种典型适度平衡的二叉搜索树，成立条件是保持平衡因子在[-1,1]的范围内，这个条件已经是针对理想平衡做出的一个妥协了，但依然显得过于苛刻，因为在很多时候我们需要频繁的做重</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hongshijie/p/9497158.html</dc:identifier>
</item>
<item>
<title>[python] 3 、基于串口通信的嵌入式设备上位机自动测试程序框架（简陋框架） - beautifulzzzz</title>
<link>http://www.cnblogs.com/zjutlitao/p/9503525.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjutlitao/p/9503525.html</guid>
<description>&lt;p&gt;星期一, 20. 八月 2018 01:53上午 - beautifulzzzz&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;1、前言&lt;/h3&gt;
&lt;p&gt;做类似zigbee、ble mesh...无线网络节点性能测试的时候，手动操作然后看表象往往很难找出真正的原因，而且有些深层次问题隐藏在弱网环境中、或大量测试中，因在上位机上用脚本实现自动化挂机测试便显得尤为重要。&lt;/p&gt;
&lt;p&gt;本文介绍一种用python写的基于串口通信的上位机自动测试程序框架（简陋框架）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;代码框架介绍&quot;&gt;2、代码框架介绍&lt;/h4&gt;
&lt;p&gt;如下：整个代码包含两层app+bsp,其中:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bsp层放硬件相关的代码（比如linux系统用python2.7写的串口驱动类）；&lt;/li&gt;
&lt;li&gt;app层中包含两个应用程序&lt;code&gt;app_app_auto_test_0xda_0xdb_adapter&lt;/code&gt;和&lt;code&gt;app_app_auto_test_off_line&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中应用程序是基于bsp中的代码实现的，进入每个独立的应用程序文件夹，运行make all则可以运行～&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  mesh_test_toos git:(master) ✗ tree
.
├── app
│   ├── app_app_auto_test_0xda_0xdb_adapter
│   │   ├── app_auto_test.py
│   │   ├── app_frame.py
│   │   ├── main.py
│   │   └── makefile
│   └── app_app_auto_test_off_line
│       ├── app_frame.py
│       ├── app_frame.pyc
│       ├── main.py
│       └── makefile
└── bsp
    ├── bsp_serial.py
    ├── bsp_serial.pyc
    ├── bsp_system.py
    └── bsp_system.pyc

4 directories, 12 files&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;bsp代码介绍&quot;&gt;3、bsp代码介绍&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;bsp_system.py：&lt;/strong&gt;该文件目前只放了一个获取当前时间戳的函数，精确到毫秒：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env python
# coding=utf-8

import time


def get_time_stamp():
    ct = time.time()
    local_time = time.localtime(ct)
    data_head = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, local_time)
    data_secs = (ct - long(ct)) * 1000
    time_stamp = &quot;[%s.%03d] &quot; % (data_head, data_secs)
    return time_stamp

version = '0.1'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;bsp_serial.py：&lt;/strong&gt;该文件在pyserial上封装了一个bsp_serial类，该类包含下面几个成员函数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实例化函数：自动读取系统中所有串口，如果有多个则会让你选择一个，并进行打开，产生一个ser成员变量&lt;/li&gt;
&lt;li&gt;iswaiting函数：读取之前要先调用该函数，看看是否有数据&lt;/li&gt;
&lt;li&gt;read函数：读取一字节&lt;/li&gt;
&lt;li&gt;write函数：写一个数组的数据&lt;/li&gt;
&lt;li&gt;close函数：关闭函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;A demo for read:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ser1 = bsp_serial.bsp_serial(9600)  
while 1&amp;lt;2:
    if ser1.iswaiting() &amp;gt; 0:
        x = ser1.read()
        print x&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt; If you want to write datas when reading, you should use the thread (next will show you) !&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;app_app_auto_test_off_line-demo介绍&quot;&gt;4、app_app_auto_test_off_line demo介绍&lt;/h4&gt;
&lt;p&gt;该脚本为自动测试无线网络中的某一个节点的长挂机情况下是否有掉线情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://odff1d90v.bkt.clouddn.com/20180820/check_node_on_off.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该网络中有一个mesh灯节点和一个和PC相连的dongle mesh节点，由于ble mesh的特性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;处于同一mesh网络中的节点中维护一个全部节点的在线/离线状态的表&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此如果想实现监听灯节点的在线/离线状态，只需要周期性地从dongle节点中读取状态表即可！这里每隔15S dongle节点将状态表以图中所示FRAME的格式传给PC：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;head为帧头，固定的&lt;/li&gt;
&lt;li&gt;cmd为帧命令，同步状态表时其值为0x07&lt;/li&gt;
&lt;li&gt;length为数据长度，这里为8&lt;/li&gt;
&lt;li&gt;data1、data2为数据，每4个字节表示一个节点的状态，第1字节表示节点ID，第二字节为0表示离线&lt;/li&gt;
&lt;li&gt;check为校验，为除该位其它位数据和模256&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;app_frame.py&lt;/strong&gt; 中实现的则是用于解析数据包的类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env python
# coding=utf-8

import sys
import termios

class FRAME:
    HEAD1=0
    HEAD2=1
    VERSION=2
    CMD=3
    LEN1=4
    LEN2=5
    LEN_HEAD=6

    MAX_DATA_BUF_SIZE = 1000

    def __init__(self,fun_analysis):
    self.data_buf = &quot;&quot;
    self.fun_analysis = fun_analysis


    '''
    judge frame is ok
    '''
    def frame_ok(self,str):
    start_pos = 0
    fram_len = 0
    end_pos = 0
    str_len = len(str)
    while start_pos&amp;lt;str_len:
        pos = start_pos
        if((ord(str[pos]) == 0x55) and (pos!=str_len-1) and (ord(str[pos+1]) == 0xAA)):
            break
        start_pos = start_pos+1
    
    if(start_pos == str_len):#no find
        return (-1,start_pos,end_pos)

    if(start_pos + FRAME.LEN_HEAD &amp;lt; str_len):
        #print str_len,start_pos,FRAME.LEN2
        fram_len = ord(str[start_pos+FRAME.LEN2])
        end_pos = start_pos + FRAME.LEN_HEAD +fram_len
        #print fram_len,end_pos
        if(end_pos &amp;lt; str_len):
            return (0,start_pos,end_pos)

    return (-2,start_pos,end_pos)



    '''
    insert data to frame fifo
    '''
    def insert_data(self,data):
    self.data_buf+=data
    if len(self.data_buf) &amp;gt; self.MAX_DATA_BUF_SIZE:
        self.data_buf = &quot;&quot;


    '''
    analysis frame and perform  
    '''
    def run(self):
    while 1&amp;lt;2:
        (ret,start_pos,end_pos) = self.frame_ok(self.data_buf)
        #print (ret,start_pos,end_pos)
        if(ret == 0):
            self.fun_analysis(self.data_buf[start_pos:end_pos+1])
            self.data_buf = self.data_buf[end_pos:]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FRAME类的实例化函数需要注册一个命令解析函数fun_analysis；frame_ok用于判断数据包是否正确；insert_data用于将串口收到的数据插入到FIFO中，接收插入数据和处理分开；run函数用于不断从FIFO中取出数据并判断是否是一个有效数据包，并进而调用fun_analysis进行解析及后续处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt; run函数需要独占一个线程！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;br/&gt;则在&lt;strong&gt;main.py&lt;/strong&gt;中分别开两个线程 —— 串口接收线程和帧RUN线程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import threading
import app_frame
import sys

sys.path.append('../../bsp')
import bsp_serial
import bsp_system


def init():
    #......(略)

def analysis_cmd(str):
    #......(略)

def ser_receive():
    global ser1
    global frame

    while 1&amp;lt;2:
    if ser1.iswaiting() &amp;gt; 0:
        x = ser1.read()
        frame.insert_data(x)


total_num = 0
fail_times = 0
ser1 = bsp_serial.bsp_serial(9600)
frame = app_frame.FRAME(analysis_cmd)      


try:
    init()

    threads = [] 
    t1 = threading.Thread(target=ser_receive)
    t2 = threading.Thread(target=frame.run)

    threads.append(t1)
    threads.append(t2)   

    for t in threads:
    t.setDaemon(True)
    t.start()

    t.join()

except Exception, e:
    ser1.close()             # close port
    print(&quot;safe exit&quot;+str(e))&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;串口接收线程不断读取串口数据，并插入到帧对象的FIFO中&lt;/li&gt;
&lt;li&gt;帧RUN函数不断解析FIFO中的数据，若检测到一个有效数据包，则调用analysis_cmd处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最终效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://odff1d90v.bkt.clouddn.com/20180820/on_off_line_data.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;app_app_auto_test_0xda_0xdb_adapter-demo介绍&quot;&gt;5、app_app_auto_test_0xda_0xdb_adapter demo介绍&lt;/h4&gt;
&lt;p&gt;这个例子和上面的很像，用于测试一条GET STATE命令的成功率：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1）整个mesh网路的架构还是dongle+1个node灯；&lt;/li&gt;
&lt;li&gt;2）PC通过串口发请求命令给dongle；&lt;/li&gt;
&lt;li&gt;3）dongle收到cmd1立刻通过串口应答该命令，并向灯节点请求状态；&lt;/li&gt;
&lt;li&gt;4）灯收到请求将状态返回给dongle，dongle再通过串口给PC；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可见：自动化测试整个流程不像DEMO1中的那么简单，这里有多次应答，因此我们必须注意设置timeout！&lt;/p&gt;
&lt;p&gt;因此在&lt;strong&gt;app_auto_test.py&lt;/strong&gt;实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#...略
class AUTO_PROCESS:
    START=0
    PROCESS1=1
    PROCESS2=2
    FINISH=3

    def __init__(self,ser):
        self.auto = AUTO_PROCESS.START
        self.ser = ser

    def analysis_cmd(self,str):
        #...略
        if cmd1 == 0x08:
        print &quot;\033[1;34m&amp;gt;&amp;gt; \033[0m&quot;,
        self.auto = self.PROCESS2

    def run(self):
        #...略
        all_times = 0
        fail1_times = 0
        fail2_times = 0

        while 1&amp;lt;2:
            if self.auto == self.START:
                all_times = all_times + 1
                time.sleep(2)
                self.ser.write(cmd_get_status_all) 
                self.auto = AUTO_PROCESS.PROCESS1
                time.sleep(2)
            elif self.auto == self.PROCESS1:
                fail1_times = fail1_times + 1
                print &quot;fail %d&quot; %self.auto
                self.auto = self.START
            elif self.auto == self.PROCESS2:
                fail2_times = fail2_times + 1
                print &quot;fail %d&quot; %self.auto
                self.auto = self.START
            else:
                print &quot;success %d total:%d fail1:%d fail2:%d&quot; %(self.auto,all_times,fail1_times,fail2_times)
                self.auto = self.START&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FRAME的analysis_cmd函数用于解析串口返回的命令，来判断改变成员变量auto的值；run函数用于主动发送请求并等待返回，如果超时未收到返回，则会改变auto为失败，并打印结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;链接&quot;&gt;链接&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@beautifulzzzz
智能硬件、物联网，热爱技术，关注产品
博客：http://blog.beautifulzzzz.com
园友交流群：414948975&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 19 Aug 2018 19:47:00 +0000</pubDate>
<dc:creator>beautifulzzzz</dc:creator>
<og:description>星期一, 20. 八月 2018 01:53上午 beautifulzzzz ![][ bar] 1、前言 做类似zigbee、ble mesh...无线网络节点性能测试的时候，手动操作然后看表象往往</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjutlitao/p/9503525.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 的 WebGL 和 VR 技术的 3D 机房数据中心可视化 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/9503486.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/9503486.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 3D 机房数据中心可视化应用中，随着视频监控联网系统的不断普及和发展, 网络摄像机更多的应用于监控系统中，尤其是高清时代的来临，更加快了网络摄像机的发展和应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180820020234801-137915723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在监控摄像机数量的不断庞大的同时，在监控系统中面临着严峻的现状问题：海量视频分散、孤立、视角不完整、位置不明确等问题，始终围绕着使用者。因此，如何更直观、更明确的管理摄像机和掌控视频动态，已成为提升视频应用价值的重要话题。所以当前项目正是从解决此现状问题的角度，应运而生。围绕如何提高、管理和有效利用前端设备采集的海量信息为公共安全服务，特别是在技术融合大趋势下，如何结合当前先进的视频融合，虚实融合、三维动态等技术，实现三维场景实时动态可视化监控，更有效的识别、分析、挖掘海量数据的有效信息服务公共应用，已成为视频监控平台可视化发展的趋势和方向。目前，在监控行业中，海康、大华等做监控行业领导者可基于这样的方式规划公共场所园区等的摄像头规划安放布局，可以通过海康、大华等摄像头品牌的摄像头参数，调整系统中摄像头模型的可视范围，监控方向等，更方便的让人们直观的了解摄像头的监控区域，监控角度等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180820020257928-452162414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是项目地址：&lt;a href=&quot;http://www.hightopo.com/demo/Camera/index.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;基于 HTML5 的 WebGL 自定义 3D 摄像头监控模型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果预览&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整体场景-摄像头效果图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074129353-858216626.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;局部场景-摄像头效果图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074159610-98573873.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码生成&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;摄像头模型及场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项目中使用的摄像头模型是通过 3dMax 建模生成的，该建模工具可以导出 obj 与 mtl 文件，在 HT 中可以通过解析 obj 与 mtl 文件来生成 3d 场景中的摄像头模型。&lt;/p&gt;
&lt;p&gt;项目中场景通过 HT 的 3d 编辑器进行搭建，场景中的模型有些是通过 HT 建模，有些通过 3dMax 建模，之后导入 HT 中，场景中的地面白色的灯光，是通过 HT 的 3d 编辑器进行地面贴图呈现出来的效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锥体建模&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3D 模型是由最基础的三角形面拼接合成，例如 1 个矩形可以由 2 个三角形构成，1 个立方体由 6 个面即 12 个三角形构成， 以此类推更复杂的模型可以由许多的小三角形组合合成。因此 3D 模型定义即为对构造模型的所有三角形的描述， 而每个三角形由三个顶点 vertex 构成， 每个顶点 vertex 由 x, y, z 三维空间坐标决定，HT 采用右手螺旋定则来确定三个顶点构造三角形面的正面。&lt;/p&gt;
&lt;p&gt;HT 中通过 &lt;strong&gt;ht.Default.setShape3dModel(name, model)&lt;/strong&gt; 函数，可注册自定义 3D 模型，摄像头前方生成的锥体便是通过该方法生成。可以将该锥体看成由 5 个顶点，6 个三角形组成，具体图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074221681-1867969782.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;ht.Default.setShape3dModel(name, model)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;strong&gt;name&lt;/strong&gt; 为模型名称，如果名称与预定义的一样，则会替换预定义的模型 &lt;br/&gt;2. &lt;strong&gt;model&lt;/strong&gt; 为JSON类型对象，其中 &lt;em&gt;&lt;strong&gt;vs&lt;/strong&gt;&lt;/em&gt; 表示顶点坐标数组，&lt;em&gt;&lt;strong&gt;is&lt;/strong&gt;&lt;/em&gt; 表示索引数组，&lt;em&gt;&lt;strong&gt;uv&lt;/strong&gt;&lt;/em&gt; 表示贴图坐标数组，如果想要单独定义某个面，可以通过 &lt;em&gt;&lt;strong&gt;bottom_vs，bottom_is，bottom_uv，top_vs，top_is， top_uv&lt;/strong&gt; &lt;/em&gt;等来定义，之后便可以通过&lt;em&gt;&lt;strong&gt; shape3d.top.*， shape3d.bottom.*&lt;/strong&gt;&lt;/em&gt;  等单独控制某个面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下是我定义模型的代码:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
// camera 是当前的摄像头图元
// fovy 为摄像头的张角的一半的 tan 值
var setRangeModel = function&lt;span&gt;(camera, fovy) {
    var fovyVal = 0.5 *&lt;span&gt; fovy;
    var pointArr = [0, 0, 0, -fovyVal, fovyVal, 0.5, fovyVal, fovyVal, 0.5, fovyVal, -fovyVal, 0.5, -fovyVal, -fovyVal, 0.5&lt;span&gt;];
    ht.Default.setShape3dModel(camera.getTag(), [{
        vs: pointArr,
        is: [2, 1, 0, 4, 1, 0, 4, 3, 0, 3, 2, 0&lt;span&gt;],
        from_vs: pointArr.slice(3, 15&lt;span&gt;),
        from_is: [3, 1, 0, 3, 2, 1&lt;span&gt;],
        from_uv: [0, 0, 1, 0, 1, 1, 0, 1&lt;span&gt;]
    }]);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我将当前摄像头的 tag 标签值作为模型的名称，tag 标签在 HT 中用于唯一标识一个图元，用户可以自定义 tag 的值。通过 pointArr 记录当前五面体的五个顶点坐标信息，代码中通过 from_vs, from_is, from_uv 单独构建五面体底面，底面用于显示当前摄像头呈现的图像。&lt;/p&gt;
&lt;p&gt;代码中设置了锥体 style 对象的 &lt;strong&gt;wf.geometry&lt;/strong&gt; 属性，通过该属性可以为锥体添加模型的线框，增强模型的立体效果，并且通过&lt;strong&gt; wf.color，wf.width&lt;/strong&gt; 等参数调节线框的颜色，粗细等。&lt;/p&gt;
&lt;p&gt;相关模型 style 属性的设置代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
 1 &lt;span&gt;rangeNode.s({
 2     'shape3d'&lt;span&gt;: cameraName,
 3     // 摄像头模型名称
 4     'shape3d.color': 'rgba(52, 148, 252, 0.3)'&lt;span&gt;,
 5     // 锥体模型颜色
 6     'shape3d.reverse.flip': true&lt;span&gt;,
 7     // 锥体模型的反面是否显示正面的内容
 8     'shape3d.light': false&lt;span&gt;,
 9     // 锥体模型是否受光线影响
10     'shape3d.transparent': true&lt;span&gt;,
11     // 锥体模型是否透明
12     '3d.movable': false&lt;span&gt;,
13     // 锥体模型是否可移动
14     'wf.geometry': true // 是否显示锥体模型线框
15 });&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;摄像头图像生成原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;透视投影&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;透视投影是为了获得接近真实三维物体的视觉效果而在二维的纸或者画布平面上绘图或者渲染的一种方法，它也称为透视图。 透视使得远的对象变小，近的对象变大，平行线会出现先交等更更接近人眼观察的视觉效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074233279-699657637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，透视投影最终显示到屏幕上的内容只有截头锥体( View Frustum )部分的内容， 因此 Graph3dView 提供了 eye, center, up, far，near，fovy 和 aspect 参数来控制截头锥体的具体范围。具体的透视投影可以参考 &lt;strong&gt;HT for Web&lt;/strong&gt; 的 &lt;a href=&quot;https://hightopo.com/guide/guide/core/3d/ht-3d-guide.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;3D&lt;/a&gt; 手册。&lt;/p&gt;
&lt;p&gt;根据上图的描述，在本项目中可以在摄像头初始化之后，缓存当前 3d 场景 eyes 眼睛的位置，以及 center 中心的位置，之后将 3d 场景 eyes 眼睛和 center 中心设置成摄像头中心点的位置，然后在这个时刻获取当前 3d 场景的截图，该截图即为当前摄像头的监控图像，之后再将 3d 场景的 center 与 eyes 设置成开始时缓存的 eyes 与 center 位置，通过该方法即可实现 3d 场景中任意位置的快照，从而实现摄像头监控图像实时生成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关伪代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 1 function&lt;span&gt; getFrontImg(camera, rangeNode) {
 2     var oldEye =&lt;span&gt; g3d.getEye();
 3     var oldCenter =&lt;span&gt; g3d.getCenter();
 4     var oldFovy =&lt;span&gt; g3d.getFovy();
 5 &lt;span&gt;    g3d.setEye(摄像头位置);
 6 &lt;span&gt;    g3d.setCenter(摄像头朝向);
 7 &lt;span&gt;    g3d.setFovy(摄像头张角);
 8 &lt;span&gt;    g3d.setAspect(摄像头宽高比);
 9 &lt;span&gt;    g3d.validateImp();
10 &lt;span&gt;    g3d.toDataURL();
11 &lt;span&gt;    g3d.setEye(oldEye);;
12 &lt;span&gt;    g3d.setCenter(oldCenter);
13 &lt;span&gt;    g3d.setFovy(oldFovy);
14 &lt;span&gt;    g3d.setAspect(undefined);
15 &lt;span&gt;    g3d.validateImp();
16 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过测试之后，通过该方法进行图像的获取会导致页面有所卡顿，因为是获取当前 3d 场景的整体截图，由于当前3d场景是比较大的，所以 toDataURL 获取图像信息是非常慢的，因此我采取了离屏的方式来获取图像，具体方式如下：&lt;br/&gt;   1. 创建一个新的 3d 场景，将当前场景的宽度与高度都设置为 200px 的大小，并且当前 3d 场景的内容与主屏的场景是一样的，HT中通过 new ht.graph3d.Graph3dView(dataModel) 来新建场景，其中的 dataModel 为当前场景的所有图元，所以主屏与离屏的 3d 场景都共用同一个 dataModel，保证了场景的一致。&lt;br/&gt;   2. 将新创建的场景位置设置成屏幕看不到的地方，并且添加进 dom 中。&lt;br/&gt;   3. 将之前对主屏获取图像的操作变成对离屏获取图像的操作，此时离屏图像的大小相对之前主屏获取图像的大小小很多，并且离屏获取不需要保存原来的眼睛 eyes 的位置以及 center 中心的位置，因为我们没有改变主屏的 eyes 与 center 的位置， 所以也减少的切换带来的开销，大大提高了摄像头获取图像的速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下是该方法实现的代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
 1 function&lt;span&gt; getFrontImg(camera, rangeNode) {
 2     // 截取当前图像时将该摄像头所属的五面体隐藏
 3     rangeNode.s('shape3d.from.visible', false&lt;span&gt;);
 4     rangeNode.s('shape3d.visible', false&lt;span&gt;);
 5     rangeNode.s('wf.geometry', false&lt;span&gt;);
 6     var cameraP3 =&lt;span&gt; camera.p3();
 7     var cameraR3 =&lt;span&gt; camera.r3();
 8     var cameraS3 =&lt;span&gt; camera.s3();
 9     var updateScreen = function&lt;span&gt;() {
10 &lt;span&gt;        demoUtil.Canvas2dRender(camera, outScreenG3d.getCanvas());
11 &lt;span&gt;        rangeNode.s({
12             'shape3d.from.image': camera.a('canvas'&lt;span&gt;)
13 &lt;span&gt;        });
14         rangeNode.s('shape3d.from.visible', true&lt;span&gt;);
15         rangeNode.s('shape3d.visible', true&lt;span&gt;);
16         rangeNode.s('wf.geometry', true&lt;span&gt;);
17 &lt;span&gt;    };
18 
19     // 当前锥体起始位置
20     var realP3 = [cameraP3[0], cameraP3[1] + cameraS3[1] / 2, cameraP3[2] + cameraS3[2] / 2&lt;span&gt;];
21     // 将当前眼睛位置绕着摄像头起始位置旋转得到正确眼睛位置
22     var realEye =&lt;span&gt; demoUtil.getCenter(cameraP3, realP3, cameraR3);
23 
24 &lt;span&gt;    outScreenG3d.setEye(realEye);
25     outScreenG3d.setCenter(demoUtil.getCenter(realEye, [realEye[0], realEye[1], realEye[2] + 5&lt;span&gt;], cameraR3));
26     outScreenG3d.setFovy(camera.a('fovy'&lt;span&gt;));
27 &lt;span&gt;    outScreenG3d.validate();
28 &lt;span&gt;    updateScreen();
29 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面代码中有一个 getCenter 方法是用于获取 3d 场景中点 A 绕着点 B 旋转 angle 角度之后得到的点 A 在 3d 场景中的位置，方法中采用了 HT 封装的 ht.Math 下面的方法，以下为代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
 1 // pointA 为 pointB 围绕的旋转点
 2 // pointB 为需要旋转的点
 3 // r3 为旋转的角度数组 [xAngle, yAngle, zAngle] 为绕着 x, y, z 轴分别旋转的角度 
 4 var getCenter = function&lt;span&gt;(pointA, pointB, r3) {
 5     var mtrx = new&lt;span&gt; ht.Math.Matrix4();
 6     var euler = new&lt;span&gt; ht.Math.Euler();
 7     var v1 = new&lt;span&gt; ht.Math.Vector3();
 8     var v2 = new&lt;span&gt; ht.Math.Vector3();
 9 
10     mtrx.makeRotationFromEuler(euler.set(r3[0], r3[1], r3[2&lt;span&gt;]));
11 
12 &lt;span&gt;    v1.fromArray(pointB).sub(v2.fromArray(pointA));
13 &lt;span&gt;    v2.copy(v1).applyMatrix4(mtrx);
14 &lt;span&gt;    v2.sub(v1);
15 
16     return [pointB[0] + v2.x, pointB[1] + v2.y, pointB[2] +&lt;span&gt; v2.z];
17 };&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里应用到向量的部分知识，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OA + OB = OC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074251110-1058475078.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法分为以下几个步骤求解：&lt;/p&gt;
&lt;p&gt;   1.  &lt;strong&gt;var mtrx = new ht.Math.Matrix4()&lt;/strong&gt; 创建一个转换矩阵，通过 &lt;strong&gt;mtrx.makeRotationFromEuler(euler.set(r3[0], r3[1], r3[2]))&lt;/strong&gt; 获取绕着 r3[0]，r3[1]，r3[2] 即 x 轴，y 轴，z 轴旋转的旋转矩阵。&lt;br/&gt;   2. 通过&lt;strong&gt; new ht.Math.Vector3()&lt;/strong&gt; 创建 v1，v2 两个向量。&lt;br/&gt;   3.&lt;strong&gt; v1.fromArray(pointB)&lt;/strong&gt; 为建立一个从原点到 pointB 的一个向量。&lt;br/&gt;   4. &lt;strong&gt;v2.fromArray(pointA)&lt;/strong&gt; 为建立一个从原点到 pointA 的一个向量。&lt;br/&gt;   5. &lt;strong&gt;v1.fromArray(pointB).sub(v2.fromArray(pointA))&lt;/strong&gt; 即向量 OB - OA 此时得到的向量为 AB，此时 v1 变为向量 AB。&lt;br/&gt;   6. &lt;strong&gt;v2.copy(v1)&lt;/strong&gt; v2 向量拷贝 v1 向量，之后通过 &lt;strong&gt;v2.copy(v1).applyMatrix4(mtrx)&lt;/strong&gt; 对 v2 向量应用旋转矩阵，变换之后即为 v1向量绕着 pointA 旋转之后的的向量 v2。&lt;br/&gt;   7. 此时通过 &lt;strong&gt;v2.sub(v1)&lt;/strong&gt; 就获取了起始点为 pointB，终点为 pointB 旋转之后点构成的向量，该向量此时即为 v2。&lt;br/&gt;   8. 通过向量公式得到旋转之后的点为 [pointB[0] + v2.x, pointB[1] + v2.y, pointB[2] + v2.z]。&lt;/p&gt;
&lt;p&gt;项目中的 3D 场景例子其实是 &lt;a href=&quot;http://www.hightopo.com/&quot; target=&quot;_blank&quot;&gt;Hightopo&lt;/a&gt; 最近贵州数博会，HT 上工业互联网展台的 VR 示例，大众对 VR/AR 的期待很高，但路还是得一步步走，即使融资了 23 亿美金的 Magic Leap 的第一款产品也只能是 &lt;a href=&quot;https://mp.weixin.qq.com/s/Z-gcPasf6E4OdNbqBwBhFA&quot; target=&quot;_blank&quot;&gt;Full of Shit&lt;/a&gt;，这话题以后再展开，这里就上段当时现场的视频照片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074306832-325606716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2d 图像贴到 3d 模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过上一步的介绍我们可以获取当前摄像机位置的截屏图像，那么如何将当前图像贴到前面所构建的五面体底部呢？前面通过 from_vs, from_is 来构建底部的长方形，所以在 HT 中可以通过将五面体的 style 中 shape3d.from.image 属性设置成当前图像，其中 from_uv 数组用来定义贴图的位置，具体如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074323039-360588324.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;strong&gt;以下为定义贴图位置 from_uv 的代码：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;1 from_uv: [0, 0, 1, 0, 1, 1, 0, 1] &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;from_uv 就是定义贴图的位置数组，根据上图的解释，可以将 2d 图像贴到 3d 模型的 from 面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制面板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HT 中通过 &lt;strong&gt;new ht.widget.Panel()&lt;/strong&gt; 来生成如下图的面板：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074334164-1462206036.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;面板中每个摄像头都有一个模块来呈现当前监控图像，其实这个地方也是一个 canvas，该 canvas 与场景中锥体前面的监控图像是同一个 canvas，每一个摄像头都有一个自己的 canvas 用来保存当前摄像头的实时监控画面，这样就可以将该 canvas 贴到任何地方，将该 canvas 添加进面板的代码如下：&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;1 &lt;span&gt;formPane.addRow([{ 2 element: camera.a('canvas'&lt;span&gt;) 3 }], 240, 240); &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码中将 canvas 节点存储在摄像头图元的 attr 属性下面，之后便可以通过&lt;strong&gt; camera.a('canvas')&lt;/strong&gt; 来获取当前摄像头的画面。&lt;/p&gt;
&lt;p&gt;在面板中的每一个控制节点都是通过&lt;strong&gt; formPane.addRow&lt;/strong&gt; 来进行添加，具体可参考 HT for Web 的&lt;a href=&quot;http://www.hightopo.com/guide/guide/plugin/form/ht-form-guide.html&quot; target=&quot;_blank&quot;&gt;表单手册&lt;/a&gt;。之后通过 ht.widget.Panel 将表单面板 formPane 添加进 panel 面板中，具体可参考 HT for Web 的&lt;a href=&quot;http://www.hightopo.com/guide/guide/plugin/panel/ht-panel-guide.html&quot; target=&quot;_blank&quot;&gt;面板手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部分控制代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
 1 formPane.addRow(['rotateY'&lt;span&gt;, {
 2 &lt;span&gt;    slider: {
 3         min: -&lt;span&gt;Math.PI,
 4 &lt;span&gt;        max: Math.PI,
 5         value: r3[1&lt;span&gt;],
 6         onValueChanged: function&lt;span&gt;() {
 7             var cameraR3 =&lt;span&gt; camera.r3();
 8             camera.r3([cameraR3[0], this.getValue(), cameraR3[2&lt;span&gt;]]);
 9             rangeNode.r3([cameraR3[0], this.getValue(), cameraR3[2&lt;span&gt;]]);
10 &lt;span&gt;            getFrontImg(camera, rangeNode);
11 &lt;span&gt;        }
12 &lt;span&gt;    }
13 }], [0.1, 0.15]);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制面板通过 &lt;strong&gt;addRow&lt;/strong&gt; 来添加控制元素，以上代码为添加摄像头绕着 y 轴进行旋转的控制，&lt;strong&gt;onValueChanged&lt;/strong&gt; 在 slider 的数值改变的时候调用，此时通过&lt;strong&gt; camera.r3()&lt;/strong&gt; 获取当前摄像头的旋转参数， 由于是绕着 y 轴旋转所以 x 轴与 z 轴的角度是不变的，变的是 y 轴的旋转角度，所以通过&lt;strong&gt; camera.r3([cameraR3[0], this.getValue(), cameraR3[2]])&lt;/strong&gt; 来调整摄像头的旋转角度以及通过 &lt;strong&gt;rangeNode.r3([cameraR3[0], this.getValue(), cameraR3[2]])&lt;/strong&gt; 来设置摄像头前方锥体的旋转角度，然后调用之前封装好的 &lt;strong&gt;getFrontImg&lt;/strong&gt; 函数来获取此时旋转角度下面的实时图像信息。&lt;/p&gt;
&lt;p&gt;项目中通过 Panel 面板的配置参数 &lt;strong&gt;titleBackground: rgba(230, 230, 230, 0.4) &lt;/strong&gt;即可将标题背景设置为具有透明度的背景，其它类似的 titleColor, titleHeight 等标题参数都可以配置，通过 separatorColor,separatorWidth 等分割参数可以设置内部面板之间分割线的颜色，宽度等。最后面板通过&lt;strong&gt; panel.setPositionRelativeTo('rightTop')&lt;/strong&gt; 将面板的位置设置成右上角，并且通过 &lt;strong&gt;document.body.appendChild(panel.getView())&lt;/strong&gt; 将面板最外层的 div 添加进页面中， &lt;strong&gt;panel.getView()&lt;/strong&gt; 用来获取面板的最外层 dom 节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体初始化面板代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
 1 function&lt;span&gt; initPanel() {
 2     var panel = new&lt;span&gt; ht.widget.Panel();
 3     var config =&lt;span&gt; {
 4         title: &quot;摄像头控制面板&quot;&lt;span&gt;,
 5         titleBackground: 'rgba(230, 230, 230, 0.4)'&lt;span&gt;,
 6         titleColor: 'rgb(0, 0, 0)'&lt;span&gt;,
 7         titleHeight: 30&lt;span&gt;,
 8         separatorColor: 'rgb(67, 175, 241)'&lt;span&gt;,
 9         separatorWidth: 1&lt;span&gt;,
10         exclusive: true&lt;span&gt;,
11 &lt;span&gt;        items: []
12 &lt;span&gt;    };
13     cameraArr.forEach(function&lt;span&gt;(data, num) {
14         var camera = data['camera'&lt;span&gt;];
15         var rangeNode = data['rangeNode'&lt;span&gt;];
16         var formPane = new&lt;span&gt; ht.widget.FormPane();
17 &lt;span&gt;        initFormPane(formPane, camera, rangeNode);
18 &lt;span&gt;        config.items.push({
19             title: &quot;摄像头&quot; + (num + 1&lt;span&gt;),
20             titleBackground: 'rgba(230, 230, 230, 0.4)'&lt;span&gt;,
21             titleColor: 'rgb(0, 0, 0)'&lt;span&gt;,
22             titleHeight: 30&lt;span&gt;,
23             separatorColor: 'rgb(67, 175, 241)'&lt;span&gt;,
24             separatorWidth: 1&lt;span&gt;,
25 &lt;span&gt;            content: formPane,
26             flowLayout: true&lt;span&gt;,
27             contentHeight: 400&lt;span&gt;,
28             width: 250&lt;span&gt;,
29             expanded: num === 0
30 &lt;span&gt;        });
31 &lt;span&gt;    });
32 &lt;span&gt;    panel.setConfig(config);
33     panel.setPositionRelativeTo('rightTop'&lt;span&gt;);
34 &lt;span&gt;    document.body.appendChild(panel.getView());
35     window.addEventListener(&quot;resize&quot;&lt;span&gt;,
36     function&lt;span&gt;() {
37 &lt;span&gt;        panel.invalidate();
38 &lt;span&gt;    });
39 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在控制面板中可以调整摄像头的方向，摄像头监控的辐射范围，摄像头前方锥体的长度等等，并且摄像头的图像是实时生成，以下为运行截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074359161-1813880965.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是本项目采用的 3D 场景结合 HT for Web 的 VR 技术实现的操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074423850-451548743.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 19 Aug 2018 18:03:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 在 3D 机房数据中心可视化应用中，随着视频监控联网系统的不断普及和发展, 网络摄像机更多的应用于监控系统中，尤其是高清时代的来临，更加快了网络摄像机的发展和应用。 在监控摄像机数量的不断庞大的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/9503486.html</dc:identifier>
</item>
<item>
<title>首个应用到大规模真实工业场景的神经网络控制系统在谷歌上线了 - 唯笑志在</title>
<link>http://www.cnblogs.com/lsjwq/p/9503262.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsjwq/p/9503262.html</guid>
<description>&lt;p&gt;&lt;span&gt;      即便深度学习和其它机器学习方法近几年已经取得了不小的发展，但是把它们直接应用在真实工业场景中、让它们直接控制工业系统还未曾见到。深度学习本身缺乏鲁棒性、面对新状况难以预测行为等一些特性固然是重要的掣肘之处，如何让算法逐步提高控制范围、协调与人类的协作方式也是难题。DeepMind 和谷歌最近就做出了新一步尝试，取得了不小的成功，然后在 DeepMind 博客上进行了介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180819233017793-1925826638.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      我们人类社会面对的许多紧迫问题中，有许多问题还在变得越来越复杂，所有人都急切地想要找到好的解决方法。对于 DeepMind 和谷歌来说，他们相信如果人类可以把 AI 作为探寻新知识的工具加以利用，找到解决方法就会容易得多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     2016 年时，DeepMind 和谷歌联手开发了一个基于 AI 的动作推荐系统，向负责维护、调节冷却系统的数据中心运营人员推荐不同状况下的应对方法，它让谷歌当时已经具有很高能源效率的推荐系统数据中心向前更进了一步。他们的出发点也很简单，为了应对全球气候变化，大型能耗场所的一点点小改进也能在在减少能源消耗、减少二氧化碳排放方面有重大影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      最近，DeepMind 把这个系统升级到了一个全新的级别上：不再像原来的系统那样向人类推荐一些动作，然后由人类去完成，AI 系统现在会直接控制数据中心的冷却系统，当然了它也仍然受到数据中心运营人员的专业监控。这是首个基于云的控制系统，已经在多个谷歌的数据中心中安静地运行、持续地节省能源。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;工作方式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;     每隔 5 分钟，这个基于云的 AI 会从数据中心的数千个传感器中采集数据，获得数据中心冷却系统的状态快照，然后把它输入深度神经网络。这个网络会预测各种可能的操作的不同组合会如何影响数据中心的能量消耗。然后 AI 就会就会在满足鲁棒安全性限制的条件下判断出一组能够最小化能源消耗的动作。这些动作的判断结果接下来会被发回给数据中心，由本地的控制系统验证并执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180819233047904-1670913403.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        这种系统运行的想法其实来自于在数据中心使用原来那个 AI 推荐系统的操作人员。他们告诉 DeepMind 的研究人员们，虽然系统给他们教了一些最新最好的操作技巧，比如让冷却介质覆盖更多的设备，而不是更少，但是实现这些推荐操作其实需要花费非常多的操作精力和长期规划。所以他们自然地就很想知道，能不能不需要人来出力就达到类似的能源节省效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       现在他们就可以很高兴地宣布，答案是能。谷歌的一位数据库操作人员表示：「我们希望可以节省能源，同时也降低操作人员的工作强度。自动化的系统就可以让我们以更高的频率执行更细粒度的行动，同时出的错误还更少。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;兼顾安全性和可靠性&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;      谷歌的数据中心里一般都有上千台服务器，它们支撑着谷歌搜索、Gmail、YouTube 等用户们每天都会使用的服务。确保这些服务可以可靠、高效地运行是最关键的一件事。DeepMind 和谷歌一起设计 AI 智能体以及背后的控制界面时，都是带着安全、可靠的思维从头设计的，还使用了 8 种不同的机制确保系统能够总是能够按照预期行动。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      他们使用的方法里，其中一种较为简单的是估计不确定性。对于总计上亿个可能的动作中的每一种，AI 智能体都需要计算自己认为这是一个好的动作的信心。估计出来信心太低的动作就不去考虑了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      另一个方法是两层验证。AI 计算出的最优行动首先需要根据一个内置的、由数据中心运营人员们制定的安全限制清单做检查。计算的结果通过检查、从云端发送到实际的数据中心之后，当地的控制系统还会再次把指令根据自己的一套安全限制清单再检查一遍。这种冗余设计的检查流程确保了系统的运行总是在当地的限制之内的，操作人员们也总是对操作的边界有完全的控制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      最重要的是，谷歌的数据中心总是会受到人类的完全控制的，人类随时可以选择退出 AI 控制模式。这时候，控制系统会自动从 AI 控制无缝地切换到基于现代自动化工业使用的基于现场规则的以及启发式设计的控制系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      他们设计的其它安全机制如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180819233145141-2081503648.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;&lt;span&gt;          连续监控、自动错误重启、平滑切换、两层验证、不间断通讯、不确定性估计、规则与启发式设计的备用控制系统、人类指令优先越用越节省能源&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;      相比于原来的动作推荐系统需要操作人员自己检查以及实施推荐的动作，新的 AI 控制系统是自己直接实现这些动作的。DeepMind 和谷歌的研究人员在开发它时也有有意识地把系统的优化边界设定到了一个更窄更小的策略中，让它把安全和可靠作为首要目标，也就是说对于节约能源的目标来说，它需要在过于节约导致的不稳定风险和优化不足的低反馈之间找到平衡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      虽然只上线了几个月时间，这个系统已经可以稳定地节约平均 30% 左右的能源，而且他们还期待系统未来可以改善更多。这是因为随着数据更多，系统的优化判断能力也会变得更强，如下图。随着技术越来越成熟，DeepMind 和谷歌的研究人员未来也会把系统的优化边界设置得宽松一些，来达到更好的能源节约效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/279374/201808/279374-20180819233219766-45247200.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      这个 AI 直接控制的系统时不时找到一些新的方法管理冷却系统，有一些方法甚至让数据库操作人员觉得惊讶。与这个系统紧密协作的一位谷歌数据中心运营人员就惊讶道：「这个 AI 会利用冬天外面比较冷的特点，产生比平时更冷的冷却水，然后减少了给数据中心降温所需的能源消耗。规则是不会自己变得越来越好的，但是 AI 可以啊。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      对于已经安全运行、独立运行、降低能耗的 AI 直接控制系统，DeepMind 和谷歌都觉得非常激动。不过，在数据中心中使用这样的系统才仅仅是个开始。在长远的未来，他们认为还有很多的潜力把这样的技术运用在其他工业场景中，也就可以在更大的规模上帮助对抗气候变化。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt; 1.&lt;a id=&quot;post_title_link_4978884&quot; href=&quot;http://www.cnblogs.com/lsjwq/p/4978884.html&quot;&gt;[连载]《C#通讯（串口和网络）框架的设计与实现》&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; 2.[&lt;a href=&quot;http://www.cnblogs.com/lsjwq/p/5316577.html&quot; target=&quot;_blank&quot;&gt;开源]C#跨平台物联网通讯框架ServerSuperIO（SSIO）介绍&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; 2.&lt;a href=&quot;http://www.cnblogs.com/lsjwq/p/5359907.html&quot; target=&quot;_blank&quot;&gt;应用SuperIO（SIO）和开源跨平台物联网框架ServerSuperIO（SSIO）构建系统的整体方案&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; 3.&lt;a href=&quot;http://www.cnblogs.com/lsjwq/p/5122612.html&quot;&gt;C#工业物联网和集成系统解决方案的技术路线（数据源、数据采集、数据上传与接收、ActiveMQ、Mongodb、WebApi、手机App）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; 5.github地址：&lt;a href=&quot;https://github.com/wxzz/ServerSuperIO&quot; target=&quot;_blank&quot;&gt;https://github.com/wxzz/ServerSuperIO&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;a href=&quot;http://www.cnblogs.com/lsjwq/p/8531046.html&quot; target=&quot;_blank&quot;&gt;6.助力中小企业级连云端，促进工业互联网平台蓬勃发展，全套解决方案。&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 物联网&amp;amp;集成技术 QQ群：&lt;span&gt;54256083 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 19 Aug 2018 15:34:00 +0000</pubDate>
<dc:creator>唯笑志在</dc:creator>
<og:description>即便深度学习和其它机器学习方法近几年已经取得了不小的发展，但是把它们直接应用在真实工业场景中、让它们直接控制工业系统还未曾见到。深度学习本身缺乏鲁棒性、面对新状况难以预测行为等一些特性固然是重要的掣肘</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lsjwq/p/9503262.html</dc:identifier>
</item>
<item>
<title>在bugku关于CBC翻转攻击思路 - 落花四月</title>
<link>http://www.cnblogs.com/lxz-1263030049/p/9503048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lxz-1263030049/p/9503048.html</guid>
<description>&lt;p&gt;今天在bugku遇到关于CBC翻转攻击的题目，总结了一下关于CBC翻转攻击的原理，以及关于这道题目的解题思路&lt;/p&gt;
&lt;p&gt;CBC翻转攻击的主要目的：通过损坏密文字节来改变明文字节。(注：借助CBC内部的模式) 通过添加单引号等恶意字符来绕过过滤器，或通过将用户ID更改为admin来提升权限，或者更改应用程序所需的明文的任何其他后果。&lt;/p&gt;
&lt;p&gt;加密过程：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819213651316-2019008060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上图CBC加密原理图&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1：Plaintext：待加密的数据。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2：IV：用于随机化加密的比特块，保证即使对相同明文多次加密，也可以得到不同的密文。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3： Ciphertext：加密后的数据&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;4：Key:分组加密使用的密钥&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;这里重要的一点是CBC在一个固定长度的位组上工作，称为块。在本文中，我们将使用每个16字节的块。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;整个加密的过程简单说来就是：&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&quot;1&quot;&gt;&lt;li&gt;首先将明文分组(常见的以16字节为一组)，位数不足的使用特殊字符填充。&lt;/li&gt;
&lt;li&gt;生成一个随机的初始化向量(IV)和一个密钥。&lt;/li&gt;
&lt;li&gt;将IV和第一组明文异或。&lt;/li&gt;
&lt;li&gt;用密钥对3中xor后产生的密文加密。&lt;/li&gt;
&lt;li&gt;用4中产生的密文对第二组明文进行xor操作。&lt;/li&gt;
&lt;li&gt;用密钥对5中产生的密文加密。&lt;/li&gt;
&lt;li&gt;重复4-7，到最后一组明文。&lt;/li&gt;
&lt;li&gt;将IV和加密后的密文拼接在一起，得到最终的密文。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从第一块开始，首先与一个初始向量IV异或（IV只在第一处作用），然后把异或的结果配合Key进行加密，得到第一块的密文，并且把加密的结果与下一块的明文进行异或，一直这样进行下去。因此这种模式最重要的特点就是：&lt;em&gt;前一块的密文用来产生后一块的密文。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819213754766-343131230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;这是解密过程，解密的过程其实只要理解了加密，反过来看解密过程就也很简单了，同样的，&lt;strong&gt;前一块密文参与下一块密文的还原&lt;/strong&gt;。&lt;/p&gt;
&lt;ol start=&quot;1&quot;&gt;&lt;li&gt;从密文中提取出IV，然后将密文分组。&lt;/li&gt;
&lt;li&gt;使用密钥对第一组的密文解密，然后和IV进行xor得到明文。&lt;/li&gt;
&lt;li&gt;使用密钥对第二组密文解密，然后和2中的密文xor得到明文。&lt;/li&gt;
&lt;li&gt;重复2-3，直到最后一组密文。&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;left&quot;&gt;下图是为解释翻转攻击的原理图：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819213811836-1879206320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里可以注意到前一块Ciphertext用来产生下一块明文，如果我们改变前一块Ciphertext中的一个字节，然后和下一块解密后的密文xor，就可以得到一个不同的明文，而这个明文是我们可以控制的。利用这一点，我们就欺骗服务端或者绕过过滤器&lt;/p&gt;
&lt;p&gt;再解释一下：&lt;/p&gt;
&lt;p&gt;根据解密方式我们可以知道，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
A=ciphertext(N-1),B=plaintext(N)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;,C为第N块待异或且经过解密的字符，C'为我们经过翻转要得到的明文。&lt;/p&gt;
&lt;p&gt;所以我们可以打得到关系：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
A = B ^&lt;span&gt; C

C &lt;/span&gt;= A ^&lt;span&gt; B

A &lt;/span&gt;^ B ^ C =&lt;span&gt; 0

A &lt;/span&gt;^ B ^ C ^ C&lt;span&gt;'&lt;/span&gt;&lt;span&gt; = C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据关系式可以得到&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
A&lt;span&gt;'&lt;/span&gt;&lt;span&gt; = A ^ C ^ C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;所以说我们只需要修改前一组密文所对应的本组明文相同位置的字符，即可得到想要的明文&lt;/p&gt;

&lt;p&gt;下面就是关于Bugku的题目&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://118.89.219.210:49168/&quot;&gt;http://118.89.219.210:49168/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这一题属于常规思路，可是不容易想到，我记得以前做过类似的题目，毕竟是萌新总会有很多知识点会忘记(QAQ)&lt;/p&gt;
&lt;p&gt;使用备份文件脚本进行扫描就会得到：脚本代码：&lt;/p&gt;
&lt;p&gt;运行之后就会得到：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819213845006-2103839019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;打开链接发现是应该可以下载的文件并且文件是以.swp为后缀名&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于swp文件：&lt;/strong&gt;&lt;br/&gt;使用vi，经常可以看到swp这个文件。那这个文件是怎么产生的呢，当打开一个文件，vi就会生成这么一个.(filename)swp文件 以备不测（比如非正常退出），如果你正常退出，那么这个这个swp文件将会自动删除&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;怎么恢复.swp：&lt;/strong&gt;&lt;br/&gt;可以使用&lt;br/&gt;vim -r：命令来查看当前目录下的所有swp文件 &lt;br/&gt;vi -r {your file name} ：命令恢复文件&lt;br/&gt;rm .{your file name}.swp：命令删除swp文件，不然每一次编辑时总是有这个提示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819213926106-2106555694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;就会得到html文档：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819213940199-204193635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看到该题的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html PUBLIC &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-//W3C//DTD XHTML 1.0 Transitional//EN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;;

&lt;/span&gt;&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;

&amp;lt;meta http-equiv=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;

&amp;lt;title&amp;gt;Login Form&amp;lt;/title&amp;gt;

&amp;lt;link href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static/css/style.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stylesheet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;

&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;static/js/jquery.min.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;

$(document).ready(function() {

    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).focus(function() {

        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.user-icon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).css(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-48px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    });

    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).blur(function() {

        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.user-icon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).css(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    });

    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).focus(function() {

        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.pass-icon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).css(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-48px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    });

    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).blur(function() {

        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.pass-icon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).css(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    });

});

&lt;/span&gt;&amp;lt;/script&amp;gt;

&amp;lt;/head&amp;gt;

&amp;lt;&lt;span&gt;?php

define(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SECRET_KEY&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, file_get_contents(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/root/key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;));

define(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;METHOD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aes-128-cbc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

session_start();

function get_random_iv(){

    $random_iv&lt;/span&gt;=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;($i=0;$i&amp;lt;16;$i++&lt;span&gt;){

        $random_iv.&lt;/span&gt;=chr(rand(1,255&lt;span&gt;));

    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; $random_iv;

}

function login($info){

    $iv &lt;/span&gt;=&lt;span&gt; get_random_iv();

    $plain &lt;/span&gt;=&lt;span&gt; serialize($info);

    $cipher &lt;/span&gt;=&lt;span&gt; openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);

    $_SESSION[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = $info[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;];

    setcookie(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, base64_encode($iv));

    setcookie(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cipher&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, base64_encode($cipher));

}

function check_login(){

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(isset($_COOKIE[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cipher&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &amp;amp;&amp;amp; isset($_COOKIE[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;iv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])){

        $cipher &lt;/span&gt;= base64_decode($_COOKIE[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cipher&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]);

        $iv &lt;/span&gt;= base64_decode($_COOKIE[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;($plain =&lt;span&gt; openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){

            $info &lt;/span&gt;= unserialize($plain) &lt;span&gt;or&lt;/span&gt; die(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;base64_decode('&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.base64_encode($plain).&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;') can't unserialize&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            $_SESSION[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = $info[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;];

        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{

            die(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERROR!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        }

    }

}

function show_homepage(){

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ($_SESSION[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]===&lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;){

        echo &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;Hello admin&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

        echo &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;Flag is $flag&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{

        echo &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;hello &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.$_SESSION[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

        echo &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;Only admin can see flag&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

    }

    echo &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;&amp;lt;a href=&quot;loginout.php&quot;&amp;gt;Log out&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

}

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(isset($_POST[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]) &amp;amp;&amp;amp; isset($_POST[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])){

    $username &lt;/span&gt;= (string)$_POST[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;];

    $password &lt;/span&gt;= (string)$_POST[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;];

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;($username === &lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;){

        exit(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;p&amp;gt;admin are not allowed to login&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{

        $info &lt;/span&gt;= array(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;=&amp;gt;$username,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;=&amp;gt;&lt;span&gt;$password);

        login($info);

        show_homepage();

    }

}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(isset($_SESSION[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])){

        check_login();

        show_homepage();

    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{

        echo &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;body class=&quot;login-body&quot;&amp;gt;&lt;/span&gt;

                &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wrapper&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

                    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user-icon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;

                    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pass-icon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;

                    &amp;lt;form name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login-form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login-form&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; action=&lt;span&gt;&quot;&quot;&lt;/span&gt; method=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

                        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

                        &amp;lt;h1&amp;gt;Login Form&amp;lt;/h1&amp;gt;

                        &amp;lt;span&amp;gt;Fill out the form below to login to my super awesome imaginary control panel.&amp;lt;/span&amp;gt;

                        &amp;lt;/div&amp;gt;

                        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

                        &amp;lt;input name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onfocus=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this.value=\'\'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;

                        &amp;lt;input name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;input password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; onfocus=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this.value=\'\'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;

                        &amp;lt;/div&amp;gt;

                        &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;footer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

                        &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;submit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;

                        &amp;lt;/div&amp;gt;

                    &amp;lt;/form&amp;gt;

                &amp;lt;/div&amp;gt;

            &amp;lt;/body&amp;gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;
    }

}

?&lt;/span&gt;&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819214019266-800100518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;GO一下可以看到cookie中返回的iv和cipher&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819214031791-38781494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;将输入序列化得s:2:{s:8:&quot;username&quot;;s:5:&quot;adcin&quot;;s:8:&quot;password&quot;;s:3:&quot;123&quot;;}&lt;/p&gt;&lt;p&gt;然后每16字节分组得&lt;/p&gt;&lt;p&gt;① a : 2 : { s : 8 : &quot; u s e r n a&lt;/p&gt;&lt;p&gt;② m e &quot; ; s : 5 : &quot; a d c i n &quot; ;&lt;/p&gt;&lt;p&gt;③ s : 8 : &quot; p a s s w o r d &quot; ; s&lt;/p&gt;&lt;p&gt;④ : 3 : &quot; 1 2 3 &quot; ; }&lt;/p&gt;&lt;p&gt;可见，如果我们想要将②中的c变成m就需要对①中的s进行改变&lt;/p&gt;&lt;p&gt;于是我们编写脚本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; base64,urllib

 

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_newCipher():

    cipher &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输入所得cipher&lt;/span&gt;
&lt;span&gt;
    cipher &lt;/span&gt;=&lt;span&gt; base64.b64decode(urllib.unquote(cipher))

    newCipher &lt;/span&gt;= cipher[0:x] + chr(ord(cipher[x])^ord(&lt;span&gt;''&lt;/span&gt;)^ord(&lt;span&gt;''&lt;/span&gt;)) + cipher[x+1:]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;x为需要改变值所在的字节数，第二个ord中为输入值，第三个ord中为目标值&lt;/span&gt;

    &lt;span&gt;print&lt;/span&gt;&lt;span&gt; urllib.quote(base64.b64encode(newCipher))

 

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_newIV():

    cipher &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;get_newCipher提交后所得的无法反序列化密文&lt;/span&gt;
&lt;span&gt;
    iv &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;所得iv&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;cipher = urllib.unquote(cipher)&lt;/span&gt;
&lt;span&gt;
    cipher &lt;/span&gt;=&lt;span&gt; base64.b64decode(cipher)

    iv &lt;/span&gt;=&lt;span&gt; base64.b64decode(urllib.unquote(iv))

    newIv &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;&lt;span&gt;

    right &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;被损坏前正确的明文&lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(16&lt;span&gt;):

        newIv &lt;/span&gt;+= chr(ord(right[i])^ord(iv[i])^&lt;span&gt;ord(cipher[i]))

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt; urllib.quote(base64.b64encode(newIv))

 

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;get_newCipher()&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;get_newIV()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819214049986-1318280528.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;发现新密文无法反序列化，这是因为，我们将c修改成m时破坏了①中的结构&lt;/p&gt;&lt;p&gt;于是我们将新得到的密文复制，通过base64解密过后的iv与新密文解密的明文与原始①中数据对应异或&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819214107886-1209046428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;提交新的iv和刚才得到的cipher即可&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1335842/201808/1335842-20180819214116327-1609219020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 19 Aug 2018 14:35:00 +0000</pubDate>
<dc:creator>落花四月</dc:creator>
<og:description>今天在bugku遇到关于CBC翻转攻击的题目，总结了一下关于CBC翻转攻击的原理，以及关于这道题目的解题思路 CBC翻转攻击的主要目的：通过损坏密文字节来改变明文字节。(注：借助CBC内部的模式) 通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lxz-1263030049/p/9503048.html</dc:identifier>
</item>
<item>
<title>模型训练技巧 - Remixi</title>
<link>http://www.cnblogs.com/MrPan/p/9503008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrPan/p/9503008.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;strong&gt;神经网络模型设计训练流程&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220028577-1549476732.png&quot; alt=&quot;&quot; width=&quot;457&quot; height=&quot;275&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-1 神经模型设计流程&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  当我们设计并训练好一个神经网络之后，需要在训练集上进行验证模型效果是否良好。这一步的目的在于判断模型是否存在欠拟合；在确定已经在训练集上拟合的很好，就需要在测试集上进行验证，如果验证结果差就需要重新设计模型；如果效果一般，可能需要增加正则化，或者增加训练数据；&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;欠拟合处理策略&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 当模型在训练集上的表现结果并不好的时候，在排除不是数据集和训过程有问题，你可以采用以下几个方法来进行处理。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;更换激活函数&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;Sigmoid激活函数&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt; Sigmoid函数的形式如（1）所示，图结构如图1-2所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220100564-80741928.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220119443-614365601.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-2 sigmoid函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 但是使用Sigmoid函数作为激活函数会存在梯度消失的现象。就是当神经网络的隐藏层数量超过3层的时候，底层的参数更新就几乎为0；&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;ReLu（Rectified Linear Unit）激活函数&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;  ReLu函数的形式如（2）所示，图形结构如图1-3所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220148006-851973452.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220157598-845420076.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-3 ReLu函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  使用ReLu作为激活函数的原因在于：1）计算更为简单，相比与Sigmoid函数，ReLu计算的更为简单2）ReLu相当于无穷多个不同偏置的Sigmoid函数叠加起来的效果3）ReLu可以解决梯度消失的问题。由于ReLu函数结构，当某个神经元的输出为0时（如图1-4所示），就相当于该神经元在神经网络中不起任何作用，可以将这一些神经元从神经网络中舍去（如图1-5）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220217353-1087723902.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-4 神经网络中输出为0的神经元&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220229086-1147170579.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-5 “瘦长线性”神经网络&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;Leaky ReLu激活函数&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt; 由于当ReLu的输入&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220304117-2093020863.png&quot; alt=&quot;&quot;/&gt;时，对应的神经元就不起任何作用。因此，Leaky ReLu的改进点是当输入&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220326561-1335249396.png&quot; alt=&quot;&quot;/&gt;时，输出不再是0，而是一个较小值。Leaky ReLu函数结构如（3）所示，&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220348703-300624542.png&quot; alt=&quot;&quot;/&gt;的取值通常需要人工赋值，如当&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220404863-2115143455.png&quot; alt=&quot;&quot;/&gt;时，函数结构如1-6所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220424614-1384799947.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220432899-1167203425.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-6 Leaky ReLu激活函数&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;Parametric ReLu激活函数&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt; 由于在Leaky ReLu中的需要人工赋值，&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220452843-1647427588.png&quot; alt=&quot;&quot;/&gt;赋值的好坏需要一定的先验知识。因此，Parametric ReLu中的&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220458896-1526494545.png&quot; alt=&quot;&quot;/&gt;是参数，是可以被训练出来，甚至每一个神经元都可以有不同的&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220519055-1605786361.png&quot; alt=&quot;&quot;/&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220538448-1449263584.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-7 Parametric ReLu激活函数&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220617013-1043569404.png&quot; alt=&quot;&quot;/&gt;的训练情况更一般参数一样，但跟一般的参数更新有所区别的是&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220636609-1771210759.png&quot; alt=&quot;&quot;/&gt;采用带有动量的更新方法&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220652090-1775680114.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  其中&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220706847-133753959.png&quot; alt=&quot;&quot;/&gt;为动量，&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220717337-469155912.png&quot; alt=&quot;&quot;/&gt;为学习率；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;Maxout可学习激活函数（Learnable Activation Function）&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;  Maxout是一种可学习的激活函数，它可以学习出来ReLu函数的形式。因此，ReLu是Maxout的一种特殊情况。 Maxout结构如图1-8所示，当输出值跟权重相乘后，并不是送进激活函数进行转换，而是将若干元素作为一组（元素数量需预先设定），选择最大值作为输出。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220757775-744211274.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-8 Maxout结构&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;  以图1-9为例，当其中一个输入为1，则最终可以的激活函数实行为图1-10所示。根据你选择多少个元素作为一组，就可以训练出任意的分段函数。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220811285-1568848537.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-9 Maxout示例&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220819819-1270030876.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-10 Maxout训练出的激活函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;自适应学习率&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;Adagrad&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;     Adagrad是将学习率的取值跟之前所有偏微分值的均方值的根号有关系。以当个参数为例，具体的计算如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220857283-1638200175.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  其中，&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220913537-1363937525.png&quot; alt=&quot;&quot;/&gt;表示对&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819220925232-515174367.png&quot; alt=&quot;&quot;/&gt;的偏导数；&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221006725-484944069.png&quot; alt=&quot;&quot;/&gt;表示将先前所有对参数的偏导数的平方进行累加，并求均值，最后再取根号；&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;RMSProp&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;  RMSProp的计算公式如（7）所示，从公式中可以看出，在进行参数更新的时候，不仅考虑了当前的梯度&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221034621-1335391927.png&quot; alt=&quot;&quot;/&gt;，也考虑了先前历史的梯度&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221053709-357184914.png&quot; alt=&quot;&quot;/&gt;。其中&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221130593-810902320.png&quot; alt=&quot;&quot;/&gt;是可以自己设置的常数，当&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221139505-1054147401.png&quot; alt=&quot;&quot;/&gt;的值较小时，就表示比较相信当前的梯度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221204373-359643941.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;Momentum&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt; Momentum的思想来自于现实生活中的场景，当我们往一个崎岖的抛一个球时，由于重力势能，会导致球不一定停留在第一个凹点，可能会翻过第一个凸点，到达全局最低点。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221224782-1079428788.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-11 Momentum现实场景&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt; 因此，不同于以往的移动方向只考虑梯度方向，也会考虑到以往的移动方向。具体的计算公式中为（8）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221305855-766813087.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;过拟合处理策略&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;早停（Early Stopping）&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;  早停的思想就是，当模型在训练集上的训练误差在降低时，在测试集的测试误差可能会增加，如图1-12所示。因此需要在训练误差和测试误差之间做一个权衡。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221325916-703338767.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-12 训练误差与测试误差&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;正则化（Regularization）&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;   添加正则化的目的在于增加模型的平滑性，并且通常会在已有的损失函数上添加一些跟参数相关的项。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;L2正则化&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;   假定现在已经确定的损失函数为L(θ)，而L2正则化会对添加一项，L(θ)形式如（9）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221500711-1947239097.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  当添加上L2之后，对于参数的跟新形式变为（10）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221517675-1430514937.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  对于（10）的&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221530607-1553521416.png&quot; alt=&quot;&quot;/&gt;跟不添加L2正则项是一样的，而增加L2后，就相当于参数w在更新之前总是会乘上一个小于1的数，因此总是会使w的值减小，这个计算过程称作Weight Decay。L2的效果是使得参数越来越接近0，而我们在初始化参数时通常也会初始化接近于0的值；而我们更新的参数是使得参数越来越远离0,；因此，L2的效果跟早停的效果有些相似。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;L1正则化&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;    L1正则化跟L2正则化非常相似，只是L2是取平方和，而L1是取绝对值，形式如（11）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221652097-1969573478.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   添加L1项后，参数的更新形式就为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221716977-533968560.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 因此，当w&amp;gt;0时，&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221744755-1343737879.png&quot; alt=&quot;&quot;/&gt;为正，从而使得w的值减小；反之，当w&amp;lt;0时，就会加上一个正数，从而使w的值增加。由于L2是每次都乘上一个小于0的系数因此w减小的会比较明显；而L1是每次都减去一个固定值，因此下降的比较缓慢；所以，在最终训练出来的w，添加L2项的参数普遍较小；添加L1的参数可能有大有小。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;Dropout&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;   Dropout的做法是对于一个确定好的神经网络模型，每一次更新参数前都会对原始模型中的每一个神经元进行采样，决定是否丢弃神经元，每一个神经元都有p%的几率被丢掉。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221806759-885008727.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-13 dropout采样过程&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221816803-1057551220.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-14 dropout采样后的NN结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     在训练的时候需要对模型进行dropout采样，但是当测试的时候就不要进行采样，而且，每一个参数都要乘上（1-p）%。如图1-15所示，假设dropout几率为50%，则训练时有一半的神经元会被丢弃。而在测试时，为了使测试和训练的输出尽可能相同，就需要对每一个权重都乘上（1-p）%，以保持输出值的平衡（如图1-15右图所示）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221840184-1156979169.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;图1-15 dropout测试权重处理&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;Dropout原理解释&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;  Dropout可以看做是一种集成学习。集成学习的做法大致是，从训练集中采样出多笔数据，分别去训练不同的模型（模型的结构可以不同）。用训练出的多个模型分别对测试集进行预测，将最终的结果进行平均（如图1-16所示）。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221912279-633833096.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-16 集成学习的处理方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 假定设计的神经网络中的神经元个数为M个，每个神经元可能被dropout或者不被dropout。因此，每个神经元有2种选择，而M个神经元就有2&lt;sup&gt;M&lt;/sup&gt;选择，对应的就可以产生2&lt;sup&gt;M&lt;/sup&gt;种模型结构。因此，在训练模型时，就相当于训练了多个模型。对于模型中的某个权重是，在不同的dropout的神经网络中是共享的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221925312-952072953.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-17 dropout训练过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  但是，在训练好之后，需要进行预测。但是无法将如此多的模型分别进行存储，并单独预测。于是，为了解决这个问题，就在所有的不Dropout的模型的权重都乘上（1-p）%。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819221936175-1056544669.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图1-18 dropout权重处理&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt; Dropout在线性激活函数上的表现会更好。原因在于，当激活函数为线性是，所有权重都乘上（1-p）%，dropout后的模型输出跟集成输出的结果更加接近了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;Sigmoid梯度消失分析&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 但是使用Sigmoid函数作为激活函数会存在梯度消失的现象。就是当神经网络的隐藏层数量超过3层的时候，底层的参数更新就几乎为0；这是因为Sigmoid求导公式为S(x)'=S(x)(1-S(x))，当时x=0,S(x)=0.5时，maxS(x)'=0.25而当我们要求解底层的参数时，需要累乘上层参数的斜率，也就是要乘上多个小于0.25的数，当乘的个数较多时，&lt;img src=&quot;https://images2018.cnblogs.com/blog/953413/201808/953413-20180819222243568-150993961.png&quot; alt=&quot;&quot;/&gt;的值就会变得很小，从而导致梯度消失现象。而由于ReLu函数的斜率为1，进行求导在累乘，不会产生上述情况。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.bilibili.com/video/av10590361/?spm_id_from=333.788.videocard.0&quot;&gt;&lt;span&gt;[1]机器学习-李宏毅&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 19 Aug 2018 14:27:00 +0000</pubDate>
<dc:creator>Remixi</dc:creator>
<og:description>模型训练技巧 神经网络模型设计训练流程 图1-1 神经模型设计流程 当我们设计并训练好一个神经网络之后，需要在训练集上进行验证模型效果是否良好。这一步的目的在于判断模型是否存在欠拟合；在确定已经在训练</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrPan/p/9503008.html</dc:identifier>
</item>
<item>
<title>区块链的共识算法 及 分叉 的通俗讲解 （一） - 指尖下的幽灵</title>
<link>http://www.cnblogs.com/linguanh/p/9502971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linguanh/p/9502971.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：林冠宏 / 指尖下的幽灵&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;0.80357142857143&quot;&gt;
&lt;p&gt;掘金：&lt;a href=&quot;https://juejin.im/user/587f0dfe128fe100570ce2d8&quot; class=&quot;uri&quot;&gt;https://juejin.im/user/587f0dfe128fe100570ce2d8&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.0975609756098&quot;&gt;
&lt;p&gt;博客：&lt;a href=&quot;http://www.cnblogs.com/linguanh/&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/linguanh/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.3095238095238&quot;&gt;
&lt;p&gt;GitHub ： &lt;a href=&quot;https://github.com/af913337456/&quot; class=&quot;uri&quot;&gt;https://github.com/af913337456/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.2179487179487&quot;&gt;
&lt;p&gt;腾讯云专栏： &lt;a href=&quot;https://cloud.tencent.com/developer/user/1148436/activities&quot; class=&quot;uri&quot;&gt;https://cloud.tencent.com/developer/user/1148436/activities&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;本文不做一般入门的区块链描述讲解。着重简述讲解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;区块链的分叉&lt;/li&gt;
&lt;li&gt;共识算法&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;由于最近的开发工作是与以太坊公链相关的去中心化交易所，项目两个多月之久，对区块链相关的知识内容了解了一些，故择文以记录之，但求文字通俗易懂，无纰漏。因自身求学过程中所遇坑无数，业内良文亦少之又少，深感朦胧之懂之不爽。此外，亦坚信区块链技术未来必能大放光芒，因现在多应用于虚拟货币，故人谈区块链，内心首想皆炒币相关之内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简单过一下区块链&quot;&gt;简单过一下区块链&lt;/h3&gt;
&lt;p&gt;我们一般意识形态中的 链 是&lt;code&gt;铁链&lt;/code&gt;，由铁铸成，一环扣一环。形象地，区块链的也可以这么理解，只不过它不是由铁铸成，而是由拥有一定&lt;code&gt;数据结构的块&lt;/code&gt;连接而成，这是一个最&lt;code&gt;简单的雏形&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;见下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/19/16551d9f9a4d86a1?w=1422&amp;amp;h=427&amp;amp;f=png&amp;amp;s=44594&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;通俗讲解共识&quot;&gt;通俗讲解共识&lt;/h3&gt;
&lt;p&gt;所谓&lt;code&gt;共识&lt;/code&gt;，通俗来说，就是我们大家对某种事物的理解达成一致的意思。比如说日常的开会讨论问题，又比如判断一个动物是不是猫，我们肉眼看了后觉得像猫，其满足猫的特征，那么我们认为它是猫。共识，是一种规则。&lt;/p&gt;
&lt;p&gt;继续我们的会议例子。参与&lt;code&gt;会议的人&lt;/code&gt;，通过&lt;code&gt;开会&lt;/code&gt;的方式来达到&lt;code&gt;谈论解决问题&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对比&lt;code&gt;区块链&lt;/code&gt;中，参与&lt;code&gt;挖矿的矿工&lt;/code&gt;通过某种&lt;code&gt;共识方式(算法)&lt;/code&gt;来解决&lt;code&gt;让自己的账本跟其他节点的账本保持一致&lt;/code&gt;。让账本保持一致的深入一层意思就是，让链中区块信息保持一致。&lt;/p&gt;
&lt;p&gt;为什么需要&lt;code&gt;共识&lt;/code&gt;，不需要可不可以？当然不可以，生活中没了&lt;code&gt;共识的规则&lt;/code&gt;，一切乱套。区块链没了&lt;code&gt;共识的规则&lt;/code&gt;，各个节点各干各的，失去一致的意义。&lt;/p&gt;
&lt;p&gt;这两个例子的对应的关系如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;会议的人&lt;/code&gt; = &lt;code&gt;挖矿的矿工&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;开会&lt;/code&gt; = &lt;code&gt;共识方式(算法)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;谈论解决问题&lt;/code&gt; = &lt;code&gt;让自己的账本跟其他节点的账本保持一致&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你对&lt;code&gt;节点&lt;/code&gt;的概念意思不懂，请先理解为&lt;code&gt;矿工&lt;/code&gt;，一个节点内部包含很多角色，矿工是其中之一。&lt;/p&gt;
&lt;h3 id=&quot;共识算法&quot;&gt;共识算法&lt;/h3&gt;
&lt;p&gt;目前常见的在区块链中，节点们&lt;code&gt;让自己的账本跟其他节点的账本保持一致&lt;/code&gt;的&lt;code&gt;共识方式(算法)&lt;/code&gt;有如下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PoW，代表者是比特币 (BTC)
&lt;ul&gt;&lt;li&gt;弊端：
&lt;ul&gt;&lt;li&gt;矿池的出现，一定程度上违背了去中心化的初衷，同时也使得51%攻击成为可能，影响其安全性。&lt;/li&gt;
&lt;li&gt;存在巨大的算力浪费，看看矿池消耗大量的电力资源，随着难度增加，挖出的不够付电费&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PoS，代表者是以太坊 (ETH)，从PoW过度到PoS
&lt;ul&gt;&lt;li&gt;弊端：
&lt;ul&gt;&lt;li&gt;破坏者对网络的攻击成本很低，拥有代币就能竞争&lt;/li&gt;
&lt;li&gt;另外拥有代币数量大的节点获得记账权的概率会更大，会使得网络共识受少数富裕账户支配，从而失去公正性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;DPoS，代表者是柚子(EOS)
&lt;ul&gt;&lt;li&gt;弊端：
&lt;ul&gt;&lt;li&gt;选举固定数量的见证人作为记账候选人有可能不适合于完全去中心化的场景&lt;/li&gt;
&lt;li&gt;在网络节点很少的场景，选举的见证人的代表性也不强.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;PBFT 拜占庭容错，联盟链中常用
&lt;ul&gt;&lt;li&gt;弊端：
&lt;ul&gt;&lt;li&gt;不适合公有链，适合联盟链&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面通俗讲解下每种&lt;code&gt;共识算法&lt;/code&gt;的概念，注意！是概念，非代码层面的详细实现。&lt;/p&gt;
&lt;h4 id=&quot;pow&quot;&gt;PoW&lt;/h4&gt;
&lt;p&gt;它的全称是：&lt;code&gt;Proof of Work 工作量证明&lt;/code&gt;。字面意思，就是谁做的活越多，谁话事权越大，一定层面上类似现实生活的多劳多得的概念。该例子会穿插生活事例，其他的几个讲解将不再累赘。&lt;/p&gt;
&lt;p&gt;拿&lt;code&gt;比特币&lt;/code&gt;为例子，&lt;code&gt;比特币挖矿&lt;/code&gt;就是通过计算符合某一个比特币&lt;code&gt;区块头&lt;/code&gt;的&lt;code&gt;哈希散列值&lt;/code&gt;争夺&lt;code&gt;记账权&lt;/code&gt;。这个过程需要通过大量的计算实现，简单理解就是你进行的计算量大（工作量大），你就有大概率获得记账权，即矿工的挖出的区块并入主链。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;区块头&lt;/code&gt;，区块链中的区块的头部。你有一个饭盒，饭盒第一层，形象为动物头部，称之为头部。第一层放着米饭，米饭就是头部装载着的东西&lt;/li&gt;
&lt;li&gt;&lt;code&gt;哈希散列值&lt;/code&gt;，一种通过数学公式计算得出的值
&lt;ul&gt;&lt;li&gt;&lt;code&gt;哈希&lt;/code&gt;：数学中的散列函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;散列值&lt;/code&gt;: 通过哈希函数得出的值&lt;/li&gt;
&lt;li&gt;例如加法公式：1 + 2 = 3。那么&lt;code&gt;哈希公式&lt;/code&gt;：hash(1,2) = 结果&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;区块头&lt;/code&gt;的&lt;code&gt;哈希散列值&lt;/code&gt;，饭盒第一层装着的是饭。那么这里的这个值就是&lt;code&gt;区块头&lt;/code&gt;装着的东西&lt;/li&gt;
&lt;li&gt;&lt;code&gt;记账权&lt;/code&gt;，话事权，谁挖出的&lt;code&gt;区块&lt;/code&gt;是有效的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以说。在很多个节点都在挖矿的情况下，大家都有可能挖出一个区块，随之广播到其他节点中去，那么每个节点中会根据谁先挖出为准，确认该区块，并入链中。&lt;/p&gt;
&lt;p&gt;对比现实生活，数学竞赛中，参数者 相当于矿工，一道题目，谁先做出就公布计算过程和答案，不由裁判判断，由参赛者一起验证，没问题后，宣布该题目结束，解题者等相关信息被记录到册子/数据库/网络。之后继续下一道题。&lt;/p&gt;
&lt;p&gt;回到比特币挖矿中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这道难题就是 &lt;code&gt;计算出正确的哈希散列值&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;计算哈希散列值&lt;/code&gt; 随着难度系数增大，会越来越困难&lt;/li&gt;
&lt;li&gt;计算需要耗费大量的电力资源，工作量大&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;一旦计算出了，就告诉其他节点&lt;/li&gt;
&lt;li&gt;节点收到通知后，停下手上的计算工作&lt;/li&gt;
&lt;li&gt;节点开始验证信息
&lt;ul&gt;&lt;li&gt;信息有效，当前的块被挖出，各节点开始重新挖下一个&lt;/li&gt;
&lt;li&gt;信息无效，各节点继续自己的手上的计算工作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;成功挖出有效区块的节点获得奖励，比特币奖励&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同时解出问题的情况怎么办？---① 答案见下一章节 &lt;a href=&quot;http://www.cnblogs.com/linguanh/p/区块链分叉&quot; class=&quot;uri&quot;&gt;区块链分叉&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;区块链分叉&quot;&gt;区块链分叉&lt;/h3&gt;
&lt;p&gt;注意私有节点不在讨论范围内，所有节点基于公有节点。分叉的情况有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;硬分叉
&lt;ul&gt;&lt;li&gt;一旦出现，最后的结果是一分为二&lt;/li&gt;
&lt;li&gt;术语的说法：&lt;code&gt;旧节点&lt;/code&gt;无法认可新节点产生的区块，为&lt;code&gt;硬分叉&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;软分叉
&lt;ul&gt;&lt;li&gt;一旦出现，最后的结果是能掰正的&lt;/li&gt;
&lt;li&gt;术语的说法：&lt;code&gt;旧节点&lt;/code&gt;能够认可新节点产生的区块，为&lt;code&gt;软分叉&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在先回答上一章节留下的问题 --- ①，&lt;br/&gt;① 的情况是&lt;code&gt;软分叉&lt;/code&gt;的一种，当有两个或多个节点同时挖出了同区块号码的一个区块，然后它们同时广播信息出去，假设一个是&lt;code&gt;A&lt;/code&gt;，而另一个是&lt;code&gt;B&lt;/code&gt;，那么距离 A 比较近的节点，还没等到收到其他消息就先收到了 A 的信息，并开始确认 A 所挖出的这个区块的信息，随后加入A挖出的这个区块到自己所在的公链中去。同理 距离 B 比较近的节点，也会先处理 B 挖出的区块信息并添加入自己所在的公链中。&lt;/p&gt;
&lt;p&gt;上面文字对应于下图。距离 A 最近的是 &lt;code&gt;节点1&lt;/code&gt;，距离 B 最近的是 &lt;code&gt;节点5&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/19/16551c11266d98cc?w=1202&amp;amp;h=916&amp;amp;f=png&amp;amp;s=215220&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，出现了链的分叉。这是一种使用了同样共识算法，共识规则下导致的分叉，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/19/16551ddf6bee353c?w=1387&amp;amp;h=512&amp;amp;f=png&amp;amp;s=67111&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现了这种情况，矿工是比较好自我纠正的。由于解题能力和矿工的数量成正比，因此两条链的&lt;code&gt;增长速度&lt;/code&gt;也是不一样的，在一段时间之后，总有一条链的长度要超过另一条。当矿工发现全网有一条更长的链时，他就会抛弃他当前的链，把新的更长的链全部复制回来，在这条链的基础上继续挖矿。所有矿工都这样操作，这条链就成为了主链，分叉出来的链便会被抛弃掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/19/16551f433b551ede?w=1336&amp;amp;h=653&amp;amp;f=png&amp;amp;s=102821&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;硬分叉的出现&quot;&gt;硬分叉的出现&lt;/h4&gt;
&lt;p&gt;如果区块链软件的共识规则被改变，并且这种规则改变无法向前兼容，旧节点无法认可新节点产生的区块，且旧节点偏偏就是不升级，那么该分叉将导致链一分为二。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;分叉点后的链&lt;/code&gt;，往后互不影响，节点在站好派别后，也不会再互相广播区块信息。&lt;code&gt;新节点&lt;/code&gt;和&lt;code&gt;旧节点&lt;/code&gt;会开始在不同的区块链上运行（&lt;code&gt;挖矿&lt;/code&gt;、&lt;code&gt;交易&lt;/code&gt;、&lt;code&gt;验证&lt;/code&gt;等）&lt;/p&gt;
&lt;p&gt;举个简单的例子，如果节点版本1.0 所接收的区块结构字段是10个，1年后发布节点2.0版本，2.0 兼容 1.0，但是 1.0 的不能接受 2.0 版本中多出的字段。&lt;/p&gt;
&lt;p&gt;硬分叉的过程:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开发者发布新的&lt;code&gt;节点代码&lt;/code&gt;，新的改变了区块链的共识规则且不被旧的兼容，于是&lt;code&gt;节点程序出现了分叉&lt;/code&gt;（software fork）&lt;/li&gt;
&lt;li&gt;区块链网络中部分节点开始运行新的节点代码，在新规则下产生的交易与区块将被旧节点拒绝，旧节点&lt;code&gt;开始短暂的断开&lt;/code&gt;与这些发送被自己拒绝的交易与区块新节点的连接，于是整个区块链&lt;code&gt;网络出现了分叉&lt;/code&gt;（network fork)&lt;/li&gt;
&lt;li&gt;新节点的矿工开始基于新规则挖矿，旧的依然用旧的规则，不同的的矿工&lt;code&gt;算力出现了分叉&lt;/code&gt;（mining fork）&lt;/li&gt;
&lt;li&gt;最终，整个区块链出现了分叉（chain fork）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一个实例：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;2017年8月1号，Bitcoin Cash（BCH）区块链成功在区块高度478559与主链分离。这一新的加密货币默认区块大小为8MB，并且可以实现区块容量的动态调整。&lt;br/&gt;由于旧节点只认可小于1MB的区块，所以运行BCH客户端节点产生的区块无法向前兼容，将被旧节点拒绝，最后运行不同客户端的矿工将会长期运行在两条不同的区块链上（BTC和BCH）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;软分叉的出现&quot;&gt;软分叉的出现&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;不同的节点短时间差内挖出了同区块号的区块，也就是上面的&lt;code&gt;例子&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;因共识规则被改变，旧节点能够识别新节点产生的区块，旧的块不能被新的接受
&lt;ul&gt;&lt;li&gt;新节点全网算力大于50%&lt;/li&gt;
&lt;li&gt;新节点全网算力小于等于50%&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第二种的软分叉是不一定能由节点自我纠正的。万全的解决方案必须依赖人力升级节点到同版本。&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;当 &lt;code&gt;新节点全网算力大于50%&lt;/code&gt;，因为新节点算力大于50%，所以不论旧节点升级不升级，最长的链也一定会是全部由新节点生成的区块组成的链。而且，这条最长链最终都会是双方都认为合法的一条，原因参考上面谈到的最长链复制，因满足下面几点所以能被复制。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;旧的能接收新的，在分叉点之后的区块参杂着
&lt;ul&gt;&lt;li&gt;旧节点的区块&lt;/li&gt;
&lt;li&gt;新节点的区块&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;新的不能接收旧的，但是最终及其之后总比旧的长&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当 &lt;code&gt;新节点全网算力小于等于50%&lt;/code&gt;，最终不能通过短的复制长的达到统一，结果是：&lt;code&gt;分叉&lt;/code&gt;。原因如下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;旧节点最终会比新节点的链要长&lt;/li&gt;
&lt;li&gt;新的总是不能接受旧的，不会去复制一条含有自己不能接受的块的链&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;写到这，发现内容铺开后比我想象中的要多。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/19/165527bbd831d8da?w=1139&amp;amp;h=377&amp;amp;f=png&amp;amp;s=45148&quot;/&gt;&lt;br/&gt;故目前暂时分成&lt;code&gt;两章节&lt;/code&gt;，剩下的共识算法的介绍留到&lt;code&gt;第二章&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/chabuduoxiansheng1/article/details/79740018&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/chabuduoxiansheng1/article/details/79740018&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/s_lisheng/article/details/78022645&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/s_lisheng/article/details/78022645&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 19 Aug 2018 14:25:00 +0000</pubDate>
<dc:creator>指尖下的幽灵</dc:creator>
<og:description>作者：林冠宏 / 指尖下的幽灵 掘金：https://juejin.im/user/587f0dfe128fe100570ce2d8 博客：http://www.cnblogs.com/linguan</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linguanh/p/9502971.html</dc:identifier>
</item>
<item>
<title>Java Runnable与Callable区别 - jihite</title>
<link>http://www.cnblogs.com/kaituorensheng/p/9502968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kaituorensheng/p/9502968.html</guid>
<description>&lt;h3&gt;接口定义&lt;/h3&gt;
&lt;p&gt;#Callable接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Callable&amp;lt;V&amp;gt;&lt;span&gt; {
    V call() &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#Runnable接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;相同点&lt;/h3&gt;
&lt;p&gt;都是接口&lt;/p&gt;
&lt;p&gt;都可以编写多线程程序&lt;/p&gt;
&lt;p&gt;都采用Thread.start()启动线程&lt;/p&gt;
&lt;h3&gt;不同点&lt;/h3&gt;
&lt;p&gt;Runnable没有返回值；Callable可以返回执行结果，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果&lt;/p&gt;
&lt;p&gt;Callable接口的call()方法允许抛出异常；Runnable的run()方法异常只能在内部消化，不能往上继续抛&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注&lt;/strong&gt;&lt;/span&gt;：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。&lt;/p&gt;
&lt;h3&gt;示例&lt;/h3&gt;
&lt;p&gt;#Callable-1&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Callable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutionException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.FutureTask;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CallableAndFuture {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Callable&lt;/span&gt;&amp;lt;Integer&amp;gt; callable = &lt;span&gt;new&lt;/span&gt; Callable&amp;lt;Integer&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Integer call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                Thread.sleep(&lt;/span&gt;6000&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random().nextInt();
            }
        };
        FutureTask&lt;/span&gt;&amp;lt;Integer&amp;gt; future = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;&amp;gt;&lt;span&gt;(callable);
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(future).start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;hello begin&quot;&lt;span&gt;);
            System.out.println(future.isDone());
            System.out.println(future.get());
            System.out.println(future.isDone());
            System.out.println(&lt;/span&gt;&quot;hello end&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ExecutionException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;hello begin
&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
1664014921
&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
hello end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#Callable-2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Callable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutionException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.FutureTask;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CallableThreadTest &lt;span&gt;implements&lt;/span&gt; Callable&amp;lt;Integer&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ExecutionException, InterruptedException {
        CallableThreadTest ctt &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CallableThreadTest();
        FutureTask&lt;/span&gt;&amp;lt;Integer&amp;gt; ft = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;&amp;gt;&lt;span&gt;(ctt);
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(ft, &quot;有返回值的线程&quot;&lt;span&gt;).start();
        System.out.println(&lt;/span&gt;&quot;子线程的返回值&quot; +&lt;span&gt; ft.get());
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer call() {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 10; i += 2&lt;span&gt;) {
            System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; &quot; +&lt;span&gt; i);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
有返回值的线程 0&lt;span&gt;
有返回值的线程 &lt;/span&gt;2&lt;span&gt;
有返回值的线程 &lt;/span&gt;4&lt;span&gt;
有返回值的线程 &lt;/span&gt;6&lt;span&gt;
有返回值的线程 &lt;/span&gt;8&lt;span&gt;
子线程的返回值10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;优势&lt;/h3&gt;
&lt;p&gt;多线程返回执行结果是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下&lt;strong&gt;取消&lt;/strong&gt;该线程的任务，真的是非常有用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CallableAndFuture {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Callable&lt;/span&gt;&amp;lt;Integer&amp;gt; callable = &lt;span&gt;new&lt;/span&gt; Callable&amp;lt;Integer&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Integer call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                Thread.sleep(&lt;/span&gt;6000&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random().nextInt();
            }
        };
        FutureTask&lt;/span&gt;&amp;lt;Integer&amp;gt; future = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;&amp;gt;&lt;span&gt;(callable);
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(future).start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;hello begin&quot;&lt;span&gt;);
            System.out.println(future.isDone());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;            future.cancel(false);&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;future.isCancelled()) {
                System.out.println(future.get());
                System.out.println(future.isDone());
                System.out.println(&lt;/span&gt;&quot;hello end&quot;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                System.out.println(&lt;/span&gt;&quot;cancel~&quot;&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ExecutionException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 19 Aug 2018 14:17:00 +0000</pubDate>
<dc:creator>jihite</dc:creator>
<og:description>接口定义 #Callable接口 #Runnable接口 相同点 都是接口 都可以编写多线程程序 都采用Thread.start()启动线程 不同点 Runnable没有返回值；Callable可以返</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kaituorensheng/p/9502968.html</dc:identifier>
</item>
<item>
<title>《深入理解计算机系统》自学历程（一）模拟高速缓存逻辑（下） - 炎寒</title>
<link>http://www.cnblogs.com/xiayongming/p/9502875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiayongming/p/9502875.html</guid>
<description>&lt;p&gt;经过&lt;strong&gt;三次重写&lt;/strong&gt;，和&lt;strong&gt;合计30多个小时的开发&lt;/strong&gt;，终于把这个简单的逻辑做完了。（自己太笨）&lt;/p&gt;
&lt;p&gt;因为刚刚接触C，写的代码实现方式肯定有不对的地方，逻辑上可能也有疏漏，如果有看官发现问题还望及时给予指正，谢谢。&lt;/p&gt;


&lt;h2&gt;1.1目标：&lt;/h2&gt;
&lt;p&gt;维护一个单独的缓存空间，该空间是低一级存储的缓存。缓存的大小比低级存储的大小要小很多，通过一个逻辑将底层存储的数据抽到缓存中的一个位置。&lt;/p&gt;
&lt;h2&gt;1.2 实现思路：&lt;/h2&gt;
&lt;p&gt;　　通过阅读《深入理解计算机系统》一书，了解低级存储与缓存之间关联规则是基于存储地址的，通过一个地址映射的规则，将低级存储的地址映射到缓存的制定位置。&lt;/p&gt;
&lt;h3&gt;　　1.2.1 存储：&lt;/h3&gt;
&lt;p&gt;　　　　存储是由一个个位构成的，每个位都有一个对应的地址，地址的大小取决于计算机的字长。&lt;/p&gt;
&lt;h3&gt;　　1.2.2 低级存储：&lt;/h3&gt;
&lt;p&gt;　　　　在这次的设计中低级存储只是一个抽象概念，实际上就是内存中的一块空间，只不过我通过映射值将低级存储的地址改为从F000开始的地址。&lt;/p&gt;
&lt;h3&gt;　　1.2.3 缓存：&lt;/h3&gt;
&lt;p&gt;　　　　缓存是比低级存储小得多的集合，因为存储越大寻址的时间越长，所以需要一个小的缓存来存储处理器近期使用到的数据。&lt;/p&gt;
&lt;p&gt;　　　　这次设计中的缓存也只是一个抽象概念，也是内存的一块空间，也是通过映射值将缓存的地址改为A000开始的地址。&lt;/p&gt;
&lt;p&gt;　　如何将低级存储的地址映射到缓存——缓存模型：&lt;/p&gt;
&lt;p&gt;　　　　缓存模型主要分——组、行、缓存单元&lt;/p&gt;
&lt;h4&gt;　　　　1.2.3.1 组&lt;/h4&gt;
&lt;p&gt;　　　　　　在逻辑上没有体现，知识对地址进行切割并划分了一个范围，是在映射逻辑上有关，在实际内存中不会存储。&lt;/p&gt;
&lt;h4&gt;　　　　1.2.3.2 行&lt;/h4&gt;
&lt;p&gt;　　　　　　也是一个逻辑体现，主要是为了更好的提升缓存的寻址效率而设置的思想。&lt;/p&gt;
&lt;h4&gt;　　　　1.2.3.3 缓存单元：&lt;/h4&gt;
&lt;p&gt;　　　　　　实际存储数据的对象，其中包含了标识、是否加载、以及字节块。&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;strong&gt;标识：&lt;/strong&gt;标识是地址的一部分根据规则截取出来的，通过地址另一部分找到对应的组以后就会对其中的行进行遍历，根据标识找到对应的行。&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;strong&gt;是否加载：&lt;/strong&gt;用来标识该缓存是否已经加载数据。&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;strong&gt;字节块：&lt;/strong&gt;用来存储缓存数据。（大小可设置）&lt;/p&gt;
&lt;p&gt;　　   　&lt;strong&gt;1.2.3.4 总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　通过上述的几个对象，我们将缓存组织成了一个三层的结构，第一层是组、第二层是行、第三层是存储单元。一个缓存可以有S个组，可以有E个行，每行只能有一个缓存单元。&lt;/p&gt;
&lt;h3&gt;　　&lt;strong&gt;1.2.4 全相连高速缓存、组相连高速缓存、直接映射高速缓存&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　　　全相连高速缓存就是缓存中只有一个组，有E个行的方式实现。&lt;/p&gt;
&lt;p&gt;　　　　组相连高速缓存就是一个缓存中有S个组，E个行的实现方式。&lt;/p&gt;
&lt;p&gt;　　　　直接映射高速缓存就是一个缓存中有S个组，1个行和1个缓存单元的实现方式。&lt;/p&gt;
&lt;h3&gt;　　 1.2.5 缓存各项指标的设置：&lt;/h3&gt;
&lt;p&gt;　　　　组数、行数、缓存数据块的大小的设置直接影响缓存的效率但也要根据实际情况，大小对不同的情况有不同的策略。&lt;/p&gt;


&lt;h2&gt;　　2.1 公共常量：&lt;/h2&gt;
&lt;p&gt;　　　　计算机字长：MemAddrLength&lt;/p&gt;
&lt;h2&gt;　　2.2 几个核心对象：&lt;/h2&gt;
&lt;h3&gt;　　　　2.2.1 硬件控制器：HWController&lt;/h3&gt;
&lt;p&gt;　　　　　　属性：&lt;/p&gt;
&lt;p&gt;　　　　　　　　存储空间大小&lt;/p&gt;
&lt;p&gt;　　　　　　1）写方法（Write）：传入一个虚拟硬件地址（自己映射的，从F000开始）和一个长度。映射后写入数据到内存。&lt;/p&gt;
&lt;p&gt;　　　　　　2）读方法（Read）：传入一个虚拟硬件地址和一个长度。映射后从内存读出数据，并写到一个新的内存空间并返回该指针。&lt;/p&gt;
&lt;h3&gt;　　　　2.2.2 缓存控制器：CacheController&lt;/h3&gt;
&lt;p&gt;　　　　　　1）缓存单元查询器（CacheFinder）：&lt;/p&gt;
&lt;p&gt;　　　　　　2）读方法（Read）：传入一个硬件虚拟地址和长度，在缓存中查找对应的单元，如果找不到从硬件中读取数据写到缓存，并将数据写到内存新的空间中、返回该指针。&lt;/p&gt;
&lt;p&gt;　　　　　　3）写方法（Write）：传入一个硬件虚拟地址和长度，将数据写入到硬件中再写到缓存里（实际上缓存会有多种策略、直写/不直写等等）。&lt;/p&gt;
&lt;p&gt;　　　　　　4）取下一个（Next）：将传入缓存单元指针移动到相邻的下一个缓存单元，如果超出缓存范围则返回0x00。&lt;/p&gt;
&lt;h2&gt;　　2.3 执行结果概述&lt;/h2&gt;
&lt;p&gt;　　返回四大部分：&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　1）总体介绍部分，会将地址空间、缓存的S、E、B、t几个主要参数值显示出来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1126312/201808/1126312-20180819214017794-1982648866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2）内存查看部分，会将初始化后虚拟硬件存储和缓存存储的值都写出来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1126312/201808/1126312-20180819214117128-1050858882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1126312/201808/1126312-20180819214149859-2101098484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）缓存大小显示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1126312/201808/1126312-20180819214205284-869079733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）缓存读值测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面的集合是所有缓存单元的参数和右侧缓存单元字节块中的数据。&lt;/p&gt;
&lt;p&gt;上面的集合是根据指令从缓存中读取出来的数据内容。&lt;/p&gt;
&lt;p&gt;通过这两个集合可以验证读取数据是否正确。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1126312/201808/1126312-20180819214804303-1557373069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 剩下没解决的问题：&lt;/p&gt;
&lt;p&gt;在写缓存的时候，如果该组所有缓存单元都已经初始化了，就需要通过一个科学的方式选择一个块覆盖或驱逐，目前是用随机数，不太合理。&lt;/p&gt;
&lt;p&gt;抽象不够，没有悟透和语言不熟导致很多复用问题比较多，有问题望指出。后续有时间我会继续完善。&lt;/p&gt;
&lt;p&gt;说不定有BUG，如果有客观指正。&lt;/p&gt;



&lt;div class=&quot;cnblogs_code&quot; readability=&quot;185&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;  2&lt;/span&gt; #include &amp;lt;stdlib.h&amp;gt;
&lt;span&gt;  3&lt;/span&gt; #include &amp;lt;math.h&amp;gt;
&lt;span&gt;  4&lt;/span&gt; #include &amp;lt;unistd.h&amp;gt;
&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt; * 基本设定初始化
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt; _memSize = &lt;span&gt;1024&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;内存大小（字节）&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt; _memAddrLength = &lt;span&gt;16&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地址长度&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt; _cacheSize = &lt;span&gt;256&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存大小&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt; * 硬件控制器
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; HWController{
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt; _memStartAddr; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;start addr 0XF0&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; _memAddr;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _memOffset;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt;* (*Read)(unsigned &lt;span&gt;long&lt;/span&gt; memOffset, unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; length);
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; (*Write)(unsigned &lt;span&gt;long&lt;/span&gt; memOffset, unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;char&lt;/span&gt; *data, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; length);
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt; * 缓存控制器：
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt; *      1）缓存单元集合指针 CacheUnitArrayPtr
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt; *      2）缓存查询函数 CacheFinder
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt; *      3）缓存读函数 Read
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt; *      4）缓存写函数 Write
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; CacheController {
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _s;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _sMask;
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _S;
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _E;
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _b;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _bMask;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _B;
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _t;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _tMask;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; _C;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _unitCount;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _unitSize;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _cacheSize;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _cacheStartAddr;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; _cacheMemAddr;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; _cacheOffset;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheUnit*&lt;span&gt; CacheUnitArrayPtr;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheUnit* (*Next)(&lt;span&gt;struct&lt;/span&gt; CacheController *ctrl,&lt;span&gt;struct&lt;/span&gt; CacheUnit *&lt;span&gt;unit);
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheUnit* (*CacheFinder)(&lt;span&gt;struct&lt;/span&gt; CacheController *ctrl,unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; Addr);
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt;* (*Read)(&lt;span&gt;struct&lt;/span&gt; CacheController *ctrl,&lt;span&gt;struct&lt;/span&gt; HWController *hwctrl,unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; length);
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; (*Write)(&lt;span&gt;struct&lt;/span&gt; CacheController *ctrl,&lt;span&gt;struct&lt;/span&gt; HWController *hwctrl,unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;char&lt;/span&gt; *data, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; length);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt; * 缓存单元
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt; *      1）数据块集合指针 BlockArrayPtr;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt; *      2）t标志位 tCode;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt; *      3）热标识位 hot;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; CacheUnit {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; BlockArrayPtr;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; tCode;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt; Hot;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;HWController&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; _hwWrite(unsigned &lt;span&gt;long&lt;/span&gt; memOffset, unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;char&lt;/span&gt; *data, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; length){
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt;* ptr = (unsigned &lt;span&gt;char&lt;/span&gt;*)(memOffset +&lt;span&gt; addr);
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(length--&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;         *ptr = *&lt;span&gt;data;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         ptr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;         data++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt;* _hwRead(unsigned &lt;span&gt;long&lt;/span&gt; memOffset, unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; length){
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *ptr = (unsigned &lt;span&gt;char&lt;/span&gt;*)(memOffset +&lt;span&gt; addr);
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *retPtr = &lt;span&gt;malloc&lt;/span&gt;&lt;span&gt;(length);
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *loopPtr =&lt;span&gt; retPtr;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(length--&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         *loopPtr = *&lt;span&gt;ptr;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;         ptr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;         loopPtr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; retPtr;
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; HWController*&lt;span&gt; GetHWCtroller(){
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; HWController *ctrl = &lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; HWController));
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; *rPtr = &lt;span&gt;malloc&lt;/span&gt;(_memSize);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get ptr point to Memory Space.&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;     (*ctrl)._memStartAddr = &lt;span&gt;0xF000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;     (*ctrl)._memOffset = (unsigned &lt;span&gt;long&lt;/span&gt;) (rPtr - (*&lt;span&gt;ctrl)._memStartAddr);
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;     (*ctrl)._memAddr =&lt;span&gt; rPtr;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;     (*ctrl).Write =&lt;span&gt; _hwWrite;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;     (*ctrl).Read =&lt;span&gt; _hwRead;
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *ptr =&lt;span&gt; rPtr;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;( i &amp;lt;&lt;span&gt; _memSize ){
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;         *ptr = i + &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;         ptr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;         i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; 
&lt;span&gt;110&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;==&amp;gt;Memory:\r\n startAddr:%X,offset:%X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(unsigned &lt;span&gt;int&lt;/span&gt;)(*ctrl)._memStartAddr,(unsigned &lt;span&gt;int&lt;/span&gt;)((*&lt;span&gt;ctrl)._memOffset ));
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; 
&lt;span&gt;112&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ctrl;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CacheController&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; CacheUnit* _next(&lt;span&gt;struct&lt;/span&gt; CacheController *ctrl,&lt;span&gt;struct&lt;/span&gt; CacheUnit *&lt;span&gt;unit){
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;    unit = (&lt;span&gt;struct&lt;/span&gt; CacheUnit *)((unsigned &lt;span&gt;long&lt;/span&gt;)unit + ctrl-&amp;gt;&lt;span&gt;_unitSize);
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt; unit &amp;gt;= (ctrl-&amp;gt;_cacheSize + ctrl-&amp;gt;_cacheMemAddr) ? &lt;span&gt;0x00&lt;/span&gt;&lt;span&gt; : unit;
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; CacheUnit* _cacheFinder(&lt;span&gt;struct&lt;/span&gt; CacheController *ctrl,unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; addr){
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt; _tBit = (addr&amp;amp;(*ctrl)._tMask)&amp;gt;&amp;gt;((*ctrl)._b+(*&lt;span&gt;ctrl)._s);
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt; _sBit = (addr&amp;amp;(*ctrl)._sMask)&amp;gt;&amp;gt;((*&lt;span&gt;ctrl)._b);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt; _bBit = (addr&amp;amp;(*&lt;span&gt;ctrl)._bMask);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    printf(&quot;\r\n\r\n====&amp;gt;Find Addr:%X \r\n tMask:%X,tVal:%X \t sMask:%X,sVal:%X \t bMask:%X,bVal:%X&quot;,addr,(*ctrl)._tMask,_tBit,(*ctrl)._sMask,_sBit,(*ctrl)._bMask,_bBit);&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheUnit* _unit = (&lt;span&gt;struct&lt;/span&gt; CacheUnit*)((*ctrl)._cacheStartAddr + ctrl-&amp;gt;_cacheOffset + _sBit * ((*ctrl)._E * ctrl-&amp;gt;&lt;span&gt;_unitSize));
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; e = (*&lt;span&gt;ctrl)._E;
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; ( e--&lt;span&gt; )
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;((*_unit).tCode ==&lt;span&gt; _tBit){
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _unit;
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;         _unit = (&lt;span&gt;struct&lt;/span&gt; CacheUnit *)(((unsigned &lt;span&gt;long&lt;/span&gt;)_unit)+ ctrl-&amp;gt;&lt;span&gt;_unitSize);
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt;* _cacheRead(&lt;span&gt;struct&lt;/span&gt; CacheController *ctrl,&lt;span&gt;struct&lt;/span&gt; HWController *hwctrl,unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; length){
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheUnit *unit = ctrl-&amp;gt;&lt;span&gt;CacheFinder(ctrl,addr);
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;todo: 找时间把Loader抽象出来或者其他方式优化复用。&lt;/span&gt;
&lt;span&gt;141&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(!unit || !(*&lt;span&gt;unit).Hot){
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;         unsigned &lt;span&gt;char&lt;/span&gt; *read = hwctrl-&amp;gt;Read(hwctrl-&amp;gt;&lt;span&gt;_memOffset,addr,length);
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;         ctrl-&amp;gt;&lt;span&gt;Write(ctrl,hwctrl,addr,read,length);
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;         unit = ctrl-&amp;gt;&lt;span&gt;CacheFinder(ctrl,addr);
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(!unit || !(*&lt;span&gt;unit).Hot){
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\nERROR::can not load cache by %X !!!! \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ,(unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)addr);
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;             exit(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *memPtr = &lt;span&gt;malloc&lt;/span&gt;&lt;span&gt;(length);
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *memLoopPtr =&lt;span&gt; memPtr;
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *blockPtr = (*unit).BlockArrayPtr + (ctrl-&amp;gt;_bMask &amp;amp;&lt;span&gt; addr);
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i &amp;lt;&lt;span&gt; length){
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;         *memLoopPtr = *&lt;span&gt;blockPtr;
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;         memLoopPtr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;         blockPtr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(blockPtr &amp;gt;= (*unit).BlockArrayPtr + (*&lt;span&gt;ctrl)._B){
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;             unit = ctrl-&amp;gt;CacheFinder(ctrl,addr + i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(!unit || !(*&lt;span&gt;unit).Hot){
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;                     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\nERROR::can not load cache by %X !!!! \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ,(unsigned &lt;span&gt;int&lt;/span&gt;)(addr +&lt;span&gt; i));
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;                     exit(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;             blockPtr = unit-&amp;gt;&lt;span&gt;BlockArrayPtr;
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;         i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; memPtr;
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; _cacheWrite(&lt;span&gt;struct&lt;/span&gt; CacheController *ctrl,&lt;span&gt;struct&lt;/span&gt; HWController *hwctrl,unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;char&lt;/span&gt; *data, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; length){
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入底层内存先。&lt;/span&gt;
&lt;span&gt;172&lt;/span&gt;     hwctrl-&amp;gt;Write(hwctrl-&amp;gt;&lt;span&gt;_memOffset,addr,data,length);
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入缓存&lt;/span&gt;
&lt;span&gt;174&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *ptr =&lt;span&gt; data;
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; 
&lt;span&gt;177&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i&amp;lt;&lt;span&gt;length){
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;         &lt;span&gt;struct&lt;/span&gt; CacheUnit *unit = ctrl-&amp;gt;CacheFinder(ctrl,addr +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(!unit||!unit-&amp;gt;&lt;span&gt;Hot)
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;             unsigned &lt;span&gt;long&lt;/span&gt; startAddr = (unsigned &lt;span&gt;long&lt;/span&gt;)(ctrl-&amp;gt;_cacheMemAddr + (((ctrl-&amp;gt;_sMask &amp;amp; (addr + i)) &amp;gt;&amp;gt; ((*ctrl)._b)) * ctrl-&amp;gt;_E) * ctrl-&amp;gt;&lt;span&gt;_unitSize) ;
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;             unsigned &lt;span&gt;long&lt;/span&gt; endAddr = (unsigned &lt;span&gt;long&lt;/span&gt;)(ctrl-&amp;gt;_cacheMemAddr + (((ctrl-&amp;gt;_sMask &amp;amp; (addr + i)) &amp;gt;&amp;gt; ((*ctrl)._b)) * ctrl-&amp;gt;_E)) + ctrl-&amp;gt;_E * ctrl-&amp;gt;&lt;span&gt;_unitSize;
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;             unit = (&lt;span&gt;struct&lt;/span&gt; CacheUnit *&lt;span&gt;)startAddr;
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; hit = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(unit){
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(!unit-&amp;gt;&lt;span&gt;Hot)
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;                     hit=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;                 unit = ctrl-&amp;gt;&lt;span&gt;Next(ctrl,unit);
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;((unsigned &lt;span&gt;long&lt;/span&gt;)unit &amp;gt;=&lt;span&gt; endAddr){
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;hit)
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt;                 printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\rnhit!!!\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt;                &lt;span&gt;int&lt;/span&gt; rm = rand() % ( ctrl-&amp;gt;&lt;span&gt;_E );
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;                unit = startAddr + rm * ctrl-&amp;gt;&lt;span&gt;_unitSize;
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;             unit-&amp;gt;tCode = ((addr + i) &amp;amp; ctrl-&amp;gt;_tMask) &amp;gt;&amp;gt; ((*ctrl)._b+(*&lt;span&gt;ctrl)._s);
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;             unit-&amp;gt;Hot = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt;         unsigned &lt;span&gt;char&lt;/span&gt; *blockPtr = unit-&amp;gt;BlockArrayPtr + ((addr+i)&amp;amp;ctrl-&amp;gt;&lt;span&gt;_bMask);
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;         *blockPtr = *&lt;span&gt;ptr;
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;         ptr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;         i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; CacheController* GetCacheController(unsigned &lt;span&gt;int&lt;/span&gt; _memAddrLength, unsigned &lt;span&gt;int&lt;/span&gt; cacheSize, unsigned &lt;span&gt;int&lt;/span&gt; blockSize,unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; E){
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheController *cache = &lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; CacheController));
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;     (*cache)._b = (unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)log2(blockSize);
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;     (*cache)._B =&lt;span&gt; blockSize;
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;     (*cache)._bMask = (unsigned &lt;span&gt;long&lt;/span&gt;) pow(&lt;span&gt;2&lt;/span&gt;,(*cache)._b) - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; 
&lt;span&gt;217&lt;/span&gt;     (*cache)._E =&lt;span&gt; E;
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt; 
&lt;span&gt;219&lt;/span&gt;     (*cache)._S = cacheSize / (*cache)._B / (*&lt;span&gt;cache)._E;
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt;     (*cache)._s = (unsigned &lt;span&gt;int&lt;/span&gt;)log2((*&lt;span&gt;cache)._S);
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;     (*cache)._sMask = (unsigned &lt;span&gt;long&lt;/span&gt;) pow(&lt;span&gt;2&lt;/span&gt;,((*cache)._b + (*cache)._s)) - (*cache)._bMask - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt; 
&lt;span&gt;223&lt;/span&gt;     (*cache)._C = (*cache)._B * (*cache)._E * (*&lt;span&gt;cache)._S;
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt; 
&lt;span&gt;225&lt;/span&gt;     (*cache)._t = _memAddrLength - (*cache)._s - (*&lt;span&gt;cache)._b;
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;     (*cache)._tMask = (unsigned &lt;span&gt;long&lt;/span&gt;) pow(&lt;span&gt;2&lt;/span&gt;,_memAddrLength) - (*cache)._bMask - (*cache)._sMask - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; 
&lt;span&gt;228&lt;/span&gt;     (*cache)._unitCount = (*cache)._E * (*&lt;span&gt;cache)._S;
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt;     (*cache)._unitSize = &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt; CacheUnit) + (*&lt;span&gt;cache)._B;
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; 
&lt;span&gt;231&lt;/span&gt;     (*cache)._cacheSize = (*cache)._unitSize * (*&lt;span&gt;cache)._unitCount;
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;apply mem&lt;/span&gt;
&lt;span&gt;233&lt;/span&gt;     (*cache)._cacheMemAddr = &lt;span&gt;malloc&lt;/span&gt;((*&lt;span&gt;cache)._cacheSize);
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;     (*cache)._cacheStartAddr = &lt;span&gt;0xA000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;     (*cache)._cacheOffset = (unsigned &lt;span&gt;long&lt;/span&gt;)((*cache)._cacheMemAddr - cache-&amp;gt;&lt;span&gt;_cacheStartAddr);
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; 
&lt;span&gt;237&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt; counter = (*&lt;span&gt;cache)._unitCount;
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheUnit *unit = (&lt;span&gt;struct&lt;/span&gt; CacheUnit*)(*&lt;span&gt;cache)._cacheMemAddr;
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt; 
&lt;span&gt;240&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(counter){
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;         (*unit).Hot = &lt;span&gt;0x00&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;         (*unit).tCode =&lt;span&gt; counter;
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt;         (*unit).BlockArrayPtr = (unsigned &lt;span&gt;char&lt;/span&gt; *)(((unsigned &lt;span&gt;long&lt;/span&gt;)unit) + &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; CacheUnit));
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(x = &lt;span&gt;0&lt;/span&gt;;x &amp;lt; cache-&amp;gt;_B ; x++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;             *(unit-&amp;gt;BlockArrayPtr + x) = (unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt;)x;
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt;         unit = (&lt;span&gt;struct&lt;/span&gt; CacheUnit*)((*unit).BlockArrayPtr + (*&lt;span&gt;cache)._B);
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;         counter--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;     (*cache).Next =&lt;span&gt; _next;
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt;     (*cache).CacheFinder =&lt;span&gt; _cacheFinder;
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;     (*cache).Read =&lt;span&gt; _cacheRead;
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt;     (*cache).Write =&lt;span&gt; _cacheWrite;
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt; 
&lt;span&gt;256&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n==&amp;gt;CacheSize:\r\n MemAddrLength = %d. C = %d, \r\nS = %d, E = %d, B = %d; \r\n s = %d, b = %d, t = %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,_memAddrLength,(*cache)._C,(*cache)._S,(*cache)._E,(*cache)._B,(*cache)._s,(*cache)._b,(*&lt;span&gt;cache)._t);
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\ncacheAddr:%X,cacheStartAddr:%X, cacheOffset:%X, cacheSize:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(unsigned &lt;span&gt;int&lt;/span&gt;)(*cache)._cacheMemAddr,(unsigned &lt;span&gt;int&lt;/span&gt;)(*cache)._cacheStartAddr,(unsigned &lt;span&gt;int&lt;/span&gt;)(*cache)._cacheOffset,(unsigned &lt;span&gt;int&lt;/span&gt;) (*&lt;span&gt;cache)._cacheSize);
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\nbMask:%x,sMask:%x,tMask:%x&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(unsigned &lt;span&gt;int&lt;/span&gt;)(*cache)._bMask,(unsigned &lt;span&gt;int&lt;/span&gt;)(*cache)._sMask,(unsigned &lt;span&gt;int&lt;/span&gt;)(*&lt;span&gt;cache)._tMask);
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt; 
&lt;span&gt;260&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache;
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt; 
&lt;span&gt;263&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;utility&lt;/span&gt;
&lt;span&gt;264&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PrintMem(&lt;span&gt;char&lt;/span&gt;* title, unsigned &lt;span&gt;long&lt;/span&gt; addr, unsigned &lt;span&gt;long&lt;/span&gt; length,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; split){
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n\r\n=====&amp;gt; title::%s::  Printing Mem %X,Length:%d  &amp;lt;=======\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,title,(unsigned &lt;span&gt;int&lt;/span&gt;)addr,(unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)length);
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *ptr = (unsigned &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;)addr;
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt; 
&lt;span&gt;268&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;269&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i &amp;lt;&lt;span&gt; length){
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;( i % &lt;span&gt;16&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n%d\t%X\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,i,(unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ptr);
&lt;/span&gt;&lt;span&gt;272&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;273&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;( i &amp;gt; &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; i % &lt;span&gt;4&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;274&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;276&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t%X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,*&lt;span&gt;ptr);
&lt;/span&gt;&lt;span&gt;277&lt;/span&gt;         ptr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt;         i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;279&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;281&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PrintCache(&lt;span&gt;char&lt;/span&gt;* title, &lt;span&gt;struct&lt;/span&gt; CacheController*&lt;span&gt; ctrl){
&lt;/span&gt;&lt;span&gt;282&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n\r\n=====&amp;gt; title::%s::  Printing Mem %X,Length:%d  &amp;lt;=======\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,title,(unsigned &lt;span&gt;int&lt;/span&gt;)(ctrl-&amp;gt;_cacheStartAddr + ctrl-&amp;gt;_cacheOffset),(unsigned &lt;span&gt;int&lt;/span&gt;)ctrl-&amp;gt;&lt;span&gt;_unitCount);
&lt;/span&gt;&lt;span&gt;283&lt;/span&gt; 
&lt;span&gt;284&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheUnit *unit = ( &lt;span&gt;struct&lt;/span&gt; CacheUnit *)(ctrl-&amp;gt;_cacheStartAddr + ctrl-&amp;gt;&lt;span&gt;_cacheOffset);
&lt;/span&gt;&lt;span&gt;285&lt;/span&gt;     unsigned &lt;span&gt;char&lt;/span&gt; *blockPtr = unit-&amp;gt;&lt;span&gt;BlockArrayPtr;
&lt;/span&gt;&lt;span&gt;286&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;287&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;288&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i &amp;lt; ctrl-&amp;gt;&lt;span&gt;_unitCount){
&lt;/span&gt;&lt;span&gt;289&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n--Unit%d[[tCode:%d,BlockPtr:%X,Hot:%d]] Blocks:\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,i+&lt;span&gt;1&lt;/span&gt;,(unsigned &lt;span&gt;int&lt;/span&gt;)unit-&amp;gt;tCode,(unsigned &lt;span&gt;int&lt;/span&gt;)unit-&amp;gt;BlockArrayPtr,(unsigned &lt;span&gt;int&lt;/span&gt;)unit-&amp;gt;&lt;span&gt;Hot);
&lt;/span&gt;&lt;span&gt;290&lt;/span&gt;         j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;291&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(j &amp;lt; ctrl-&amp;gt;&lt;span&gt;_B){
&lt;/span&gt;&lt;span&gt;292&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t%X&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(unsigned &lt;span&gt;int&lt;/span&gt;)*&lt;span&gt;blockPtr);
&lt;/span&gt;&lt;span&gt;293&lt;/span&gt;             blockPtr++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;294&lt;/span&gt;             j++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;295&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;296&lt;/span&gt;         unit = (&lt;span&gt;struct&lt;/span&gt; CacheUnit *)(((unsigned &lt;span&gt;long&lt;/span&gt;)unit) + &lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt; CacheUnit) + ctrl-&amp;gt;&lt;span&gt;_B);
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt;         blockPtr = unit-&amp;gt;&lt;span&gt;BlockArrayPtr;
&lt;/span&gt;&lt;span&gt;298&lt;/span&gt;         i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;299&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;300&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;301&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
&lt;/span&gt;&lt;span&gt;302&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello, World!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;303&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; HWController hwCtrl = *&lt;span&gt;GetHWCtroller();
&lt;/span&gt;&lt;span&gt;304&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheController cacheCtrl = *GetCacheController(_memAddrLength,_cacheSize,&lt;span&gt;32&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;305&lt;/span&gt; 
&lt;span&gt;306&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;HW Unit Test
&lt;/span&gt;&lt;span&gt;307&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    PrintMem(&quot;&quot;,(unsigned long)hwCtrl._memAddr,16,0);
&lt;/span&gt;&lt;span&gt;308&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    unsigned char temp = 0xAA;
&lt;/span&gt;&lt;span&gt;309&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    unsigned char *data = &amp;amp;temp;
&lt;/span&gt;&lt;span&gt;310&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    hwCtrl.Write(hwCtrl._memOffset,0XF002,data,1);
&lt;/span&gt;&lt;span&gt;311&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    PrintMem(&quot; HWMEM 0~16 &quot;,(unsigned long)hwCtrl._memAddr,16,0);
&lt;/span&gt;&lt;span&gt;312&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    unsigned char *retData = hwCtrl.Read(hwCtrl._memOffset,0XF002,1);
&lt;/span&gt;&lt;span&gt;313&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    PrintMem(&quot; HWMEM 0XF002 &quot;,(unsigned long)retData,1,0);
&lt;/span&gt;&lt;span&gt;314&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    unsigned char *retData = hwCtrl.Read(hwCtrl._memOffset,0XF002,1);&lt;/span&gt;
&lt;span&gt;315&lt;/span&gt;     PrintMem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; HWMEM ALL &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(unsigned &lt;span&gt;long&lt;/span&gt;)hwCtrl._memAddr,_memSize,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;316&lt;/span&gt; 
&lt;span&gt;317&lt;/span&gt; 
&lt;span&gt;318&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Cache Unit Test&lt;/span&gt;
&lt;span&gt;319&lt;/span&gt;     PrintMem(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; CACHE ALL &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(unsigned &lt;span&gt;long&lt;/span&gt;)cacheCtrl._cacheMemAddr,cacheCtrl._cacheSize,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;320&lt;/span&gt; 
&lt;span&gt;321&lt;/span&gt; 
&lt;span&gt;322&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;struct test&lt;/span&gt;
&lt;span&gt;323&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; CacheUnit cu =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;324&lt;/span&gt;             &lt;span&gt;0x00&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;325&lt;/span&gt;             &lt;span&gt;0x00&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;326&lt;/span&gt;             &lt;span&gt;0x00&lt;/span&gt;
&lt;span&gt;327&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;328&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n ============&amp;gt;&amp;gt; CacheUnitTypeSize %d \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; CacheUnit));
&lt;/span&gt;&lt;span&gt;329&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n ============&amp;gt;&amp;gt; CacheUnitSize %d \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(cu));
&lt;/span&gt;&lt;span&gt;330&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n ============&amp;gt;&amp;gt; CacheUnitSize.Hot %d \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(cu.Hot));
&lt;/span&gt;&lt;span&gt;331&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n ============&amp;gt;&amp;gt; CacheUnitSize.tCode %d \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(cu.tCode));
&lt;/span&gt;&lt;span&gt;332&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n ============&amp;gt;&amp;gt; CacheUnitSize ptr %d \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(cu.BlockArrayPtr));
&lt;/span&gt;&lt;span&gt;333&lt;/span&gt; 
&lt;span&gt;334&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ReadCacheTest&lt;/span&gt;
&lt;span&gt;335&lt;/span&gt;     PrintMem(&lt;span&gt;&quot;&quot;&lt;/span&gt;,cacheCtrl.Read(&amp;amp;cacheCtrl,&amp;amp;hwCtrl,&lt;span&gt;0XF038&lt;/span&gt;,&lt;span&gt;16&lt;/span&gt;),&lt;span&gt;16&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;336&lt;/span&gt;     PrintCache(&lt;span&gt;&quot;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;cacheCtrl);
&lt;/span&gt;&lt;span&gt;337&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;338&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 19 Aug 2018 13:58:00 +0000</pubDate>
<dc:creator>炎寒</dc:creator>
<og:description>经过三次重写，和合计30多个小时的开发，终于把这个简单的逻辑做完了。（自己太笨） 因为刚刚接触C，写的代码实现方式肯定有不对的地方，逻辑上可能也有疏漏，如果有看官发现问题还望及时给予指正，谢谢。 一、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiayongming/p/9502875.html</dc:identifier>
</item>
<item>
<title>Java并发编程原理与实战三十一:Future&amp;FutureTask 浅析 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/9502771.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/9502771.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、Futrue模式有什么用？&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;------&amp;gt;正所谓技术来源与生活，这里举个栗子。在家里，我们都有煮菜的经验。（如果没有的话，你们还怎样来泡女朋友呢？你懂得）。现在女票要你煮四菜一汤，这汤是鸡汤，有常识的人鸡汤要煲好久滴。如果你先炒四个菜，最后再煲汤，估计都已经一天的时间了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;好了。如果我们先煲汤，在煲汤的时候，同时去炒四个菜。这个模式就是Future模式啦。是不是很简单。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------》实现Future模式的，我们直接用JDK提供给我们的FutureTask类就可以了。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-----》直接上代码吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;FutureTask 是实现了RunnableFuture&amp;lt;&amp;gt;接口，而RunnablFuture接口继承了Runnable和Future接口.&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;223.5&quot;&gt;
&lt;p&gt;&lt;span&gt;1、Future可以让我们提前处理一些复杂的运行。非常的方便。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这里，我们自己去实现一个Future！！！！是不是很兴奋。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;本人编程的思想一般都是来自于生活。从问题出发，再去找到对应的解决方法。而不是先学习大量无关的解决问题的方法，再去解决问题（当然要辩证去看这个问题）。。。不知道有无人看不懂这句话呢？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;------》设计目的：设计一个方法，能在未来某一个时间点，拿出一个结果。如果在未来的那个时刻拿不出来，那就让线程去等待，一直等到拿个结果（无论成功还是出错的结果）才开始执行另外的事情。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
=====================================================
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 场景：一天，我要去订一个蛋糕，去到蛋糕店，下了个订单，我就去上班了，下班之后，拿到蛋糕，回家吃啦。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 面向对象思想，蛋糕店，使用工厂模式的对象。客人，一个对象。产品，里面有订单的对象。
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ，去到蛋糕店，拿到蛋糕店给的订单，使用工厂模式来模拟这个工厂，&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainTest {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
Factory pf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Factory(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个蛋糕店&lt;/span&gt;
Future f = pf.createOrder(&quot;蛋糕&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 蛋糕店生成什么产品，返回一个生成什么的订单&lt;/span&gt;
System.out.println(&quot;我去上班了,下班回来拿蛋糕。。。&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据订单拿到做好的蛋糕，如果没做完就要等待蛋糕店做完。&lt;/span&gt;
System.out.println(&quot;下班去拿蛋糕，拿到蛋糕了&quot;+&lt;span&gt;f.getProduct());
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Factory相当于蛋糕店，接受订单，开始生产蛋糕&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Factory {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提供客人一个订单&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Future createOrder(String name) {
Future f &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Future();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个订单&lt;/span&gt;
&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
System.out.println(&lt;/span&gt;&quot;开始生产蛋糕&quot;&lt;span&gt;);
Product product &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Product(name); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成产品&lt;/span&gt;
System.out.println(&quot;生产蛋糕结束&quot;&lt;span&gt;);
f.setProduct(product);
}
}).start();
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; f;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Product {

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 订单编号&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; String name; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成的产品名称&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Product(String name) {
&lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;();
Random random &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; random.nextInt();
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
e.printStackTrace();
}
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getId() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setId(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id) {
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
}

@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Product [id=&quot; + id + &quot;, name=&quot; + name + &quot;]&quot;&lt;span&gt;;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Future {
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Product product;
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; flag;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true:生产完了，false：还没生产完&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setProduct(Product product) {
&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.product=&lt;span&gt;product;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(flag) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果生产完，直接返回就可以，不用再重新设置了。&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
}
flag&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
notifyAll(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 叫醒所有处于wait状态的线程&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; Product getProduct() {
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!flag) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当还没有生产完的时候，就要等待。&lt;/span&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
wait();
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
e.printStackTrace();
}
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; product;
}

@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Future [product=&quot; + product + &quot;]&quot;&lt;span&gt;;
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、Future源码解读&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、Future API以及应用场景&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、Future的核心实现原理&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3、Future的源码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、怎样使用Future API呢？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-----》如果一问到这个问题，可以马上向起这三点。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.1 new 一个Callable&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.2 将刚刚创建的Callable的实例交给FutureTask&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1.3 将刚刚创建的FutureTask实例交给Thread&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、如果有看过源码的朋友，都会问一个问题，就是Callable和Runnable有什么区别？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-----》Runnable的run方法是被线程调用的，在run方法时异步执行的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Callable的Call方法，不是异步执行的，是由Future的run方法调用的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接口Callable：有返回结果并且可能抛出异常的任务； &lt;br/&gt;接口Runnable：没有返回结果 &lt;br/&gt;接口Future：表示异步执行的结果； &lt;br/&gt;类FutureTask：实现Future、Runnable等接口，是一个异步执行的任务。可以直接执行，或包装成Callable执行；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体详细可以参考：https://blog.csdn.net/lican19911221/article/details/78200344&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、再次理解Future模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先上一个场景：假如你突然想做饭，但是没有厨具，也没有食材。网上购买厨具比较方便，食材去超市买更放心。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;实现分析：在快递员送厨具的期间，我们肯定不会闲着，可以去超市买食材。所以，在主线程里面另起一个子线程去网购厨具。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;但是，子线程执行的结果是要返回厨具的，而run方法是没有返回值的。所以，这才是难点，需要好好考虑一下。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;模拟代码1：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CommonCook {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一步 网购厨具&lt;/span&gt;
        OnlineShopping thread = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OnlineShopping();
        thread.start();
        thread.join();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保证厨具送到
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二步 去超市购买食材&lt;/span&gt;
        Thread.sleep(2000);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟购买食材时间&lt;/span&gt;
        Shicai shicai = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Shicai();
        System.out.println(&lt;/span&gt;&quot;第二步：食材到位&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三步 用厨具烹饪食材&lt;/span&gt;
        System.out.println(&quot;第三步：开始展现厨艺&quot;&lt;span&gt;);
        cook(thread.chuju, shicai);
        
        System.out.println(&lt;/span&gt;&quot;总共用时&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 网购厨具线程&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OnlineShopping &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
        
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Chuju chuju;

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            System.out.println(&lt;/span&gt;&quot;第一步：下单&quot;&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;第一步：等待送货&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                Thread.sleep(&lt;/span&gt;5000);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟送货时间&lt;/span&gt;
            } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&lt;/span&gt;&quot;第一步：快递送到&quot;&lt;span&gt;);
            chuju &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Chuju();
        }
        
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  用厨具烹饪食材&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cook(Chuju chuju, Shicai shicai) {}
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 厨具类&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Chuju {}
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 食材类&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Shicai {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;第一步：下单
第一步：等待送货
第一步：快递送到
第二步：食材到位
第三步：开始展现厨艺
总共用时7013ms&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看到，多线程已经失去了意义。在厨具送到期间，我们不能干任何事。对应代码，就是调用join方法阻塞主线程。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有人问了，不阻塞主线程行不行？？？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;不行！！！&lt;/span&gt;&lt;br/&gt;&lt;span&gt;从代码来看的话，run方法不执行完，属性chuju就没有被赋值，还是null。换句话说，没有厨具，怎么做饭。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Java现在的多线程机制，核心方法run是没有返回值的；如果要保存run方法里面的计算结果，必须等待run方法计算完，无论计算过程多么耗时。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;面对这种尴尬的处境，程序员就会想：在子线程run方法计算的期间，能不能在主线程里面继续异步执行？？？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Where there is a will，there is a way！！！&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这种想法的核心就是Future模式，下面先应用一下Java自己实现的Future模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模拟代码2：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Callable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutionException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.FutureTask;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FutureCook {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; System.currentTimeMillis();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一步 网购厨具&lt;/span&gt;
        Callable&amp;lt;Chuju&amp;gt; onlineShopping = &lt;span&gt;new&lt;/span&gt; Callable&amp;lt;Chuju&amp;gt;&lt;span&gt;() {

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Chuju call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                System.out.println(&lt;/span&gt;&quot;第一步：下单&quot;&lt;span&gt;);
                System.out.println(&lt;/span&gt;&quot;第一步：等待送货&quot;&lt;span&gt;);
                Thread.sleep(&lt;/span&gt;5000);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟送货时间&lt;/span&gt;
                System.out.println(&quot;第一步：快递送到&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Chuju();
            }
            
        };
        FutureTask&lt;/span&gt;&amp;lt;Chuju&amp;gt; task = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;Chuju&amp;gt;&lt;span&gt;(onlineShopping);
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(task).start();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二步 去超市购买食材&lt;/span&gt;
        Thread.sleep(2000);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟购买食材时间&lt;/span&gt;
        Shicai shicai = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Shicai();
        System.out.println(&lt;/span&gt;&quot;第二步：食材到位&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三步 用厨具烹饪食材&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!task.isDone()) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 联系快递员，询问是否到货&lt;/span&gt;
            System.out.println(&quot;第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）&quot;&lt;span&gt;);
        }
        Chuju chuju &lt;/span&gt;=&lt;span&gt; task.get();
        System.out.println(&lt;/span&gt;&quot;第三步：厨具到位，开始展现厨艺&quot;&lt;span&gt;);
        cook(chuju, shicai);
        
        System.out.println(&lt;/span&gt;&quot;总共用时&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;&lt;span&gt;);
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  用厨具烹饪食材&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cook(Chuju chuju, Shicai shicai) {}
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 厨具类&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Chuju {}
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 食材类&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Shicai {}

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;第一步：下单
第一步：等待送货
第二步：食材到位
第三步：厨具还没到，心情好就等着（心情不好就调用cancel方法取消订单）
第一步：快递送到
第三步：厨具到位，开始展现厨艺
总共用时5005ms&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看见，在快递员送厨具的期间，我们没有闲着，可以去买食材；而且我们知道厨具到没到，甚至可以在厨具没到的时候，取消订单不要了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好神奇，有没有。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面具体分析一下第二段代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）&lt;/strong&gt;把耗时的网购厨具逻辑，封装到了一个Callable的call方法里面。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Callable&amp;lt;V&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Computes a result, or throws an exception if unable to do so.
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; computed result
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception if unable to compute a result
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    V call() &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Callable接口可以看作是Runnable接口的补充，call方法带有返回值，并且可以抛出异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）&lt;/strong&gt;把Callable实例当作参数，生成一个FutureTask的对象，然后把这个对象当作一个Runnable，作为参数另起线程。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FutureTask&amp;lt;V&amp;gt; &lt;span&gt;implements&lt;/span&gt; RunnableFuture&amp;lt;V&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; RunnableFuture&amp;lt;V&amp;gt; &lt;span&gt;extends&lt;/span&gt; Runnable, Future&amp;lt;V&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Future&amp;lt;V&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; cancel(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; mayInterruptIfRunning);

    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isCancelled();

    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isDone();

    V get() &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException;

    V get(&lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; timeout, TimeUnit unit)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException, TimeoutException;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个继承体系中的核心接口是Future。Future的核心思想是：一个方法f，计算过程可能非常耗时，等待f返回，显然不明智。可以在调用f的时候，立马返回一个Future，可以通过Future这个数据结构去&lt;em&gt;&lt;strong&gt;控制&lt;/strong&gt;&lt;/em&gt;方法f的计算过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里的&lt;em&gt;&lt;strong&gt;控制&lt;/strong&gt;&lt;/em&gt;包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;get方法：获取计算结果（如果还没计算完，也是必须等待的）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cancel方法：还没计算完，可以取消计算过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;isDone方法：判断是否计算完&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;isCancelled方法：判断计算是否被取消&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些接口的设计很完美，FutureTask的实现注定不会简单，后面再说。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）&lt;/strong&gt;在第三步里面，调用了isDone方法查看状态，然后直接调用task.get方法获取厨具，不过这时还没送到，所以还是会等待3秒。对比第一段代码的执行结果，这里我们节省了2秒。这是因为在快递员送货期间，我们去超市购买食材，这两件事在同一时间段内异步执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过以上3步，我们就完成了对Java原生Future模式最基本的应用。下面具体分析下FutureTask的实现，先看JDK8的，再比较一下JDK6的实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然FutureTask也是一个Runnable，那就看看它的run方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (state != NEW ||
            !UNSAFE.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, runnerOffset,
                                         &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, Thread.currentThread()))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Callable&lt;/span&gt;&amp;lt;V&amp;gt; c = callable; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里的callable是从构造方法里面传人的&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (c != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; state ==&lt;span&gt; NEW) {
                V result;
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; ran;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    result &lt;/span&gt;=&lt;span&gt; c.call();
                    ran &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
                    result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    ran &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    setException(ex); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存call方法抛出的异常&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ran)
                    set(result); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存call方法的执行结果&lt;/span&gt;
&lt;span&gt;            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; runner must be non-null until state is settled to
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; prevent concurrent calls to run()&lt;/span&gt;
            runner = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; state must be re-read after nulling runner to prevent
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; leaked interrupts&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; state;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;gt;=&lt;span&gt; INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;先看try语句块里面的逻辑，发现run方法的主要逻辑就是运行Callable的call方法，然后将保存结果或者异常（用的一个属性result）。这里比较难想到的是，将call方法抛出的异常也保存起来了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里表示状态的属性state是个什么鬼&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
*&lt;span&gt; Possible state transitions:
     &lt;/span&gt;* NEW -&amp;gt; COMPLETING -&amp;gt;&lt;span&gt; NORMAL
     &lt;/span&gt;* NEW -&amp;gt; COMPLETING -&amp;gt;&lt;span&gt; EXCEPTIONAL
     &lt;/span&gt;* NEW -&amp;gt;&lt;span&gt; CANCELLED
     &lt;/span&gt;* NEW -&amp;gt; INTERRUPTING -&amp;gt;&lt;span&gt; INTERRUPTED
     &lt;/span&gt;*/
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; state;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NEW          = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; COMPLETING   = 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NORMAL       = 2&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; EXCEPTIONAL  = 3&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CANCELLED    = 4&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INTERRUPTING = 5&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; INTERRUPTED  = 6;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;把FutureTask看作一个Future，那么它的作用就是控制Callable的call方法的执行过程，在执行的过程中自然会有状态的转换：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）一个FutureTask新建出来，state就是NEW状态；COMPETING和INTERRUPTING用的进行时，表示瞬时状态，存在时间极短(&lt;em&gt;为什么要设立这种状态？？？不解&lt;/em&gt;)；NORMAL代表顺利完成；EXCEPTIONAL代表执行过程出现异常；CANCELED代表执行过程被取消；INTERRUPTED被中断&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）执行过程顺利完成：NEW -&amp;gt; COMPLETING -&amp;gt; NORMAL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）执行过程出现异常：NEW -&amp;gt; COMPLETING -&amp;gt; EXCEPTIONAL&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）执行过程被取消：NEW -&amp;gt; CANCELLED&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5）执行过程中，线程中断：NEW -&amp;gt; INTERRUPTING -&amp;gt; INTERRUPTED&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码中状态判断、CAS操作等细节，请读者自己阅读。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再看看get方法的实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; V get() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; state;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;lt;=&lt;span&gt; COMPLETING)
            s &lt;/span&gt;= awaitDone(&lt;span&gt;false&lt;/span&gt;, 0L&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; report(s);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; awaitDone(&lt;span&gt;boolean&lt;/span&gt; timed, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nanos)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; deadline = timed ? System.nanoTime() + nanos : 0L&lt;span&gt;;
        WaitNode q &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; queued = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted()) {
                removeWaiter(q);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
            }

            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; state;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;gt;&lt;span&gt; COMPLETING) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (q != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    q.thread &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (s == COMPLETING) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; cannot time out yet&lt;/span&gt;
&lt;span&gt;                Thread.yield();
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (q == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                q &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WaitNode();
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;queued)
                queued &lt;/span&gt;= UNSAFE.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, waitersOffset,
                                                     q.next &lt;/span&gt;=&lt;span&gt; waiters, q);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (timed) {
                nanos &lt;/span&gt;= deadline -&lt;span&gt; System.nanoTime();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nanos &amp;lt;= 0L&lt;span&gt;) {
                    removeWaiter(q);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
                }
                LockSupport.parkNanos(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, nanos);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                LockSupport.park(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;get方法的逻辑很简单，如果call方法的执行过程已完成，就把结果给出去；如果未完成，就将当前线程挂起等待。awaitDone方法里面死循环的逻辑，推演几遍就能弄懂；它里面挂起线程的主要创新是定义了WaitNode类，来将多个等待线程组织成队列，这是与JDK6的实现最大的不同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;挂起的线程何时被唤醒：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; finishCompletion() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert state &amp;gt; COMPLETING;&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (WaitNode q; (q = waiters) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (UNSAFE.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;, waitersOffset, q, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                    Thread t &lt;/span&gt;=&lt;span&gt; q.thread;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        q.thread &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        LockSupport.unpark(t); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒线程&lt;/span&gt;
&lt;span&gt;                    }
                    WaitNode next &lt;/span&gt;=&lt;span&gt; q.next;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    q.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; unlink to help gc&lt;/span&gt;
                    q =&lt;span&gt; next;
                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }

        done();

        callable &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; to reduce footprint&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上就是JDK8的大体实现逻辑，像cancel、set等方法，也请读者自己阅读。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再来看看JDK6的实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JDK6的FutureTask的基本操作都是通过自己的内部类Sync来实现的，而Sync继承自AbstractQueuedSynchronizer这个出镜率极高的并发工具类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; State value representing that task is running &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RUNNING   = 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; State value representing that task ran &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; RAN       = 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; State value representing that task was cancelled &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CANCELLED = 4&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; The underlying callable &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Callable&amp;lt;V&amp;gt;&lt;span&gt; callable;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; The result to return from get() &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; V result;
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; The exception to throw from get() &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; Throwable exception;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;里面的状态只有基本的几个，而且计算结果和异常是分开保存的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 V innerGet() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException {
            acquireSharedInterruptibly(&lt;/span&gt;0&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getState() ==&lt;span&gt; CANCELLED)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancellationException();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (exception != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExecutionException(exception);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个get方法里面处理等待线程队列的方式是调用了acquireSharedInterruptibly方法，看过我之前几篇博客文章的读者应该非常熟悉了。其中的等待线程队列、线程挂起和唤醒等逻辑，这里不再赘述，如果不明白，请出门左转。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后来看看，Future模式衍生出来的更高级的应用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再上一个场景：我们自己写一个简单的数据库连接池，能够复用数据库连接，并且能在高并发情况下正常工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现代码1：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ConcurrentHashMap;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConnectionPool {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ConcurrentHashMap&amp;lt;String, Connection&amp;gt; pool = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, Connection&amp;gt;&lt;span&gt;();
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Connection getConnection(String key) {
        Connection conn &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (pool.containsKey(key)) {
            conn &lt;/span&gt;=&lt;span&gt; pool.get(key);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            conn &lt;/span&gt;=&lt;span&gt; createConnection();
            pool.putIfAbsent(key, conn);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; conn;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Connection createConnection() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Connection();
    }
    
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Connection {}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们用了ConcurrentHashMap，这样就不必把getConnection方法置为synchronized(当然也可以用Lock)，当多个线程同时调用getConnection方法时，性能大幅提升。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;貌似很完美了，但是有可能导致多余连接的创建，推演一遍：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;某一时刻，同时有3个线程进入getConnection方法，调用pool.containsKey(key)都返回false，然后3个线程各自都创建了连接。虽然ConcurrentHashMap的put方法只会加入其中一个，但还是生成了2个多余的连接。如果是真正的数据库连接，那会造成极大的资源浪费。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，我们现在的难点是：如何在多线程访问getConnection方法时，只执行一次createConnection。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结合之前Future模式的实现分析：当3个线程都要创建连接的时候，如果只有一个线程执行createConnection方法创建一个连接，其它2个线程只需要用这个连接就行了。再延伸，把createConnection方法放到一个Callable的call方法里面，然后生成FutureTask。我们只需要让一个线程执行FutureTask的run方法，其它的线程只执行get方法就好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Callable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ConcurrentHashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutionException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.FutureTask;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConnectionPool {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ConcurrentHashMap&amp;lt;String, FutureTask&amp;lt;Connection&amp;gt;&amp;gt; pool = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;String, FutureTask&amp;lt;Connection&amp;gt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Connection getConnection(String key) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException, ExecutionException {
        FutureTask&lt;/span&gt;&amp;lt;Connection&amp;gt; connectionTask =&lt;span&gt; pool.get(key);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (connectionTask != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; connectionTask.get();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Callable&lt;/span&gt;&amp;lt;Connection&amp;gt; callable = &lt;span&gt;new&lt;/span&gt; Callable&amp;lt;Connection&amp;gt;&lt;span&gt;() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Connection call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; createConnection();
                }
            };
            FutureTask&lt;/span&gt;&amp;lt;Connection&amp;gt; newTask = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;Connection&amp;gt;&lt;span&gt;(callable);
            connectionTask &lt;/span&gt;=&lt;span&gt; pool.putIfAbsent(key, newTask);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (connectionTask == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                connectionTask &lt;/span&gt;=&lt;span&gt; newTask;
                connectionTask.run();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; connectionTask.get();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Connection createConnection() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Connection();
    }

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Connection {
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;推演一遍：当3个线程同时进入else语句块时，各自都创建了一个FutureTask，但是ConcurrentHashMap只会加入其中一个。第一个线程执行pool.putIfAbsent方法后返回null，然后connectionTask被赋值，接着就执行run方法去创建连接，最后get。后面的线程执行pool.putIfAbsent方法不会返回null，就只会执行get方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在并发的环境下，通过FutureTask作为中间转换，成功实现了让某个方法只被一个线程执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、区别&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Future是一个接口，FutureTask是Future的一个实现类，并实现了Runnable，因此FutureTask可以传递到线程对象Thread中新建一个线程执行。所以可以通过Excutor(线程池)来执行，也可传递给Thread对象执行。&lt;br/&gt;如果在主线程中需要执行比较耗时的操作，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。&lt;br/&gt;FutureTask是为了弥补Thread的不足而设计的，它可以让程序员准确地知道线程什么时候执行完成并获得到线程执行完成后返回的结果（如果有需要）。&lt;br/&gt;FutureTask是一种可以取消的异步的计算任务。它的计算是通过Callable实现的，它等价于可以携带结果的Runnable，并且有三个状态：等待、运行和完成。完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。&lt;br/&gt;Executor框架利用FutureTask来完成异步任务，并可以用来进行任何潜在的耗时的计算。一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考文献：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;https://www.cnblogs.com/cz123/p/7693064.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;《java并发编程实战》龙果学院&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 19 Aug 2018 13:33:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<og:description>一、Futrue模式有什么用？ &gt;正所谓技术来源与生活，这里举个栗子。在家里，我们都有煮菜的经验。（如果没有的话，你们还怎样来泡女朋友呢？你懂得）。现在女票要你煮四菜一汤，这汤是鸡汤，有常识的人</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/9502771.html</dc:identifier>
</item>
</channel>
</rss>