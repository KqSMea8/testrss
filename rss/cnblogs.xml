<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>HDU 5934 强联通分量 - thges</title>
<link>http://www.cnblogs.com/mj-liylho/p/7679730.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mj-liylho/p/7679730.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;span class=&quot;math display&quot;&gt;\[Bomb\]&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[Total Submission(s): 1853 Accepted Submission(s): 608 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Problem Description&lt;br/&gt;There are N bombs needing exploding.Each bomb has three attributes: exploding radius ri, position (xi,yi) and lighting-cost ci which means you need to pay ci cost making it explode.&lt;/p&gt;
&lt;p&gt;If a un-lighting bomb is in or on the border the exploding area of another exploding one, the un-lighting bomb also will explode.&lt;/p&gt;
&lt;p&gt;Now you know the attributes of all bombs, please use the minimum cost to explode all bombs.&lt;/p&gt;
&lt;p&gt;Input&lt;br/&gt;First line contains an integer T, which indicates the number of test cases.&lt;/p&gt;
&lt;p&gt;Every test case begins with an integers N, which indicates the numbers of bombs.&lt;/p&gt;
&lt;p&gt;In the following N lines, the ith line contains four intergers xi, yi, ri and ci, indicating the coordinate of ith bomb is (xi,yi), exploding radius is ri and lighting-cost is ci.&lt;/p&gt;
&lt;p&gt;Limits&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1≤T≤20&lt;/li&gt;
&lt;li&gt;1≤N≤1000&lt;/li&gt;
&lt;li&gt;−108≤xi,yi,ri≤108&lt;/li&gt;
&lt;li&gt;1≤ci≤104&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Output&lt;br/&gt;For every test case, you should output 'Case #x: y', where x indicates the case number and counts from 1 and y is the minimum cost.&lt;/p&gt;
&lt;p&gt;Sample Input&lt;br/&gt;1 5 0 0 1 5 1 1 1 6 0 1 1 7 3 0 2 10 5 0 1 4&lt;/p&gt;
&lt;p&gt;Sample Output&lt;br/&gt;Case #1: 15&lt;/p&gt;
&lt;p&gt;Source&lt;br/&gt;2016年中国大学生程序设计竞赛（杭州）&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[思路：将给出的点之间连边，对每个强联通分量去最小值即可。\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;59&quot;&gt;
&lt;pre class=&quot;sourceCode c++&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//#include&amp;lt;regex&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define db double&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include&amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define ll long long&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define vec vector&amp;lt;ll&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define Mt  vector&amp;lt;vec&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define ci(x) scanf(&quot;%d&quot;,&amp;amp;x)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define cd(x) scanf(&quot;%lf&quot;,&amp;amp;x)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define cl(x) scanf(&quot;%lld&quot;,&amp;amp;x)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define pi(x) printf(&quot;%d&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;n&quot;,x)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define pd(x) printf(&quot;%f&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;n&quot;,x)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define pl(x) printf(&quot;%lld&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;n&quot;,x)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define MP make_pair&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define PB push_back&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define inf 0x3f3f3f3f3f3f3f3f&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define fr(i, a, b) for(int i=a;i&amp;lt;=b;i++)&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; N = &lt;span class=&quot;fl&quot;&gt;4e6&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; mod = &lt;span class=&quot;fl&quot;&gt;1e9&lt;/span&gt; + &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; MOD = mod - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; db eps = &lt;span class=&quot;fl&quot;&gt;1e-18&lt;/span&gt;;
&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; db PI = acos(&lt;span class=&quot;fl&quot;&gt;-1.0&lt;/span&gt;);
&lt;span class=&quot;kw&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;namespace&lt;/span&gt; std;
&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; P {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; f, to, nxt;
} e[N];

&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; PP {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; x, y, r, c;
} a[N];
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; hea[&lt;span class=&quot;dv&quot;&gt;3500&lt;/span&gt;];
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, cnt, sig, tt, cont;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; deg[&lt;span class=&quot;dv&quot;&gt;3500&lt;/span&gt;], sta[&lt;span class=&quot;dv&quot;&gt;3500&lt;/span&gt;], col[&lt;span class=&quot;dv&quot;&gt;3500&lt;/span&gt;], vis[&lt;span class=&quot;dv&quot;&gt;3500&lt;/span&gt;], low[&lt;span class=&quot;dv&quot;&gt;3500&lt;/span&gt;], dfn[&lt;span class=&quot;dv&quot;&gt;3500&lt;/span&gt;], need[&lt;span class=&quot;dv&quot;&gt;3500&lt;/span&gt;], contz[&lt;span class=&quot;dv&quot;&gt;3500&lt;/span&gt;];

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; add(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; f, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; to) {&lt;span class=&quot;co&quot;&gt;//建边&lt;/span&gt;
    e[cont].to = to;
    e[cont].f = f;
    e[cont].nxt = hea[f];
    hea[f] = cont++;
}

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; tarjan(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; u) {&lt;span class=&quot;co&quot;&gt;//强联通分量&lt;/span&gt;
    vis[u] = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    low[u] = dfn[u] = cnt++;
    sta[++tt] = u;
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = hea[u]; i != &lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;; i = e[i].nxt) {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; v = e[i].to;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (vis[v] == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) tarjan(v);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (vis[v] == &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) low[u] = min(low[u], low[v]);
    }
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (dfn[u] == low[u]) {
        sig++;
        &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; {
            col[sta[tt]] = sig;
            vis[sta[tt]] = &lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;;
        } &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (sta[tt--] != u);
    }
}

&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; cal() {
    cnt = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
    sig = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    tt = &lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;;
    memset(dfn, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(dfn));memset(col, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(col));memset(vis, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(vis));
    memset(sta, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(sta));memset(low, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(low));memset(deg, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(deg));
    memset(contz, &lt;span class=&quot;bn&quot;&gt;0x3f3f3f3f&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(contz));
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i++) &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!vis[i]) tarjan(i);
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; cont; i++) {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; u = e[i].f;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; v = e[i].to;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (col[u] != col[v]) deg[col[v]]++;
    }
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i++) &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!deg[col[i]]) contz[col[i]] = min(contz[col[i]], a[i].c);
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ans = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; i &amp;lt;= sig; i++) &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!deg[i]) ans += contz[i];
    pi(ans);
}

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; main() {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; t;
    ci(t);
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ii = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; ii &amp;lt;= t; ii++) {
        ci(n);
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i++) scanf(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d%d%d%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, &amp;amp;a[i].x, &amp;amp;a[i].y, &amp;amp;a[i].r, &amp;amp;a[i].c);
        cont = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        memset(hea, &lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;sizeof&lt;/span&gt;(hea));
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; n; i++) {
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; j &amp;lt; n; j++) {
                ll tmp = a[i].x - a[j].x;
                ll tmp2 = a[i].y - a[j].y;
                ll d1 = tmp * tmp + tmp2 * tmp2;
                ll d2 = &lt;span class=&quot;dv&quot;&gt;1ll&lt;/span&gt; * a[i].r * a[i].r;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (d1 &amp;lt;= d2) add(i, j);
            }
        }
        printf(&lt;span class=&quot;st&quot;&gt;&quot;Case #&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;: &quot;&lt;/span&gt;, ii);
        cal();
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Mon, 16 Oct 2017 17:45:00 +0000</pubDate>
<dc:creator>thges</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mj-liylho/p/7679730.html</dc:identifier>
</item>
<item>
<title>PE格式第五讲,手工添加节表 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7679712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7679712.html</guid>
<description>


&lt;p&gt;作者：IBinary&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/iBinary/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/iBinary/&lt;/a&gt;&lt;br/&gt;版权所有，欢迎保留原文链接进行转载：)&lt;/p&gt;
&lt;p&gt;首先我们要用汇编编写一段汇编代码,用来生成标准PE&lt;/p&gt;
&lt;h2&gt;一丶标准PE生成的汇编代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
.&lt;span&gt;386&lt;/span&gt;&lt;span&gt;
.model flat, stdcall
option &lt;/span&gt;&lt;span&gt;casemap:&lt;/span&gt;&lt;span&gt;none

include windows.&lt;/span&gt;&lt;span&gt;inc&lt;/span&gt;&lt;span&gt;
include user32.&lt;/span&gt;&lt;span&gt;inc&lt;/span&gt;&lt;span&gt;
include kernel32.&lt;/span&gt;&lt;span&gt;inc&lt;/span&gt;&lt;span&gt;

includelib user32.lib
includelib kernel32.lib

.data
    g_szMsg db &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello PE!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 0dh, 0ah, &lt;span&gt;00&lt;/span&gt;&lt;span&gt;

.code
&lt;/span&gt;&lt;span&gt;START:&lt;/span&gt;&lt;span&gt;
  invoke MessageBoxA, NULL, offset g_szMsg, NULL, MB_OK
  invoke ExitProcess, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;

end START&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后可以生成一个标准PE&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171017003851990-286354447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然为了讲解这里使用标准PE,你也可以自己随便找个PE尝试.&lt;/p&gt;
&lt;h2&gt;二丶手工添加节表&lt;/h2&gt;
&lt;p&gt;手工添加节表,我们首先有几个步骤&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;

1.复制一个节到最后一个节下面&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
2.在NT头中的文件头中,修改节区数量的个数
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;3.修改节表中新节的虚拟地址大小 &lt;br/&gt;4.修改节表中文件的对齐值 &lt;br/&gt;5.修改节表中新节的虚拟地址&lt;br/&gt;6.修改可选头(选线头或者叫做扩展头)中的镜像大小 &lt;/span&gt;&lt;span&gt;*/&lt;br/&gt;写完才发现好像比这里面多一项,自己看下吧.有图有教程.不难.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先我们先做第一步,找到最后一个节,拷贝一份,复制到下面&lt;/p&gt;
&lt;h3&gt;1.寻找最后一个节,复制到下面&lt;/h3&gt;
&lt;p&gt;当然也可以不是最后一个,不过最后一个比较方便&lt;/p&gt;
&lt;p&gt;使用010 Edit打开我们的Hello.exe,找到最后一个节&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171017004339427-855379544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;010有强大的模版功能,使用模版,可以直接找到最后一个节,我们可以看到,现在有3个节存在&lt;/p&gt;
&lt;p&gt;复制最后一个节,拷贝到0220h的地方&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171017004516240-346039123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在已经完成了第一步了,复制节到下边&lt;/p&gt;
&lt;h3&gt;2.修改NT头中的文件头中的节区数量&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171017004644365-1314367239.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改为4,使用模版功能可以快速找到&lt;/p&gt;
&lt;h3&gt;3.修改表中虚拟地址大小&lt;/h3&gt;
&lt;p&gt;使用010的模版重新解析以下,会发现我们的节已经添加了,现在要做的就是修正偏移了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171017004859615-1508616894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击我们的节,开始修正偏移即可&lt;/p&gt;
&lt;p&gt;修改我们新添加节的虚拟地址大小&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171017004954084-2018864347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.修改新节中的虚拟地址&lt;/h3&gt;
&lt;h3&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171017005314615-1313578780.png&quot; alt=&quot;&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;上一个节的虚拟地址是从3000开始的,所以我们修改为4000h,相差一个分页即可.但是注意上图可以看出,我正要修改,还没有修改,这里我是修改了,只不过为了方便大家观看为什么修改,所以我在开始编辑的时候就截图了&lt;/p&gt;
&lt;h3&gt;5.修改文件对齐值&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171017005453240-2021397739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文件对齐值默认是512,也就是200h,所以这里不用修改,但是注意,文件对齐值在可选头中可以设置的.不过最好不要动了.&lt;/p&gt;
&lt;h3&gt;6.设置文件偏移&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171017005559568-1192678942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上一个节的文件偏移是800开始,代表了节区的地址在800的位置,那么我们新添加的就改为A00h&lt;/p&gt;
&lt;p&gt;%200(文件对齐值)对齐,这个地方使我们的节区&lt;/p&gt;
&lt;h3&gt;7.添加文件大小&lt;/h3&gt;
&lt;p&gt;上面我们设置了文件对齐值是200h了,那么我们就要添加200h(512)个字节,在对应的文件偏移处&lt;/p&gt;
&lt;p&gt;我们设置的文件偏移处是A00,所以拷贝512个对齐值复制到A00位置即可.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171017005907506-473031236.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8.设置文件映射大小&lt;/p&gt;
&lt;p&gt;我们新添加了一个节,那么映射到内存中就要多出一个分页大小,我们要设置一下&lt;/p&gt;
&lt;p&gt;设置位置 NT头-&amp;gt;可选头-&amp;gt;sizeofImage(文件映射大小)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171017010201302-966034088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;保存PE文件,我们运行,然后OD调试查看.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171017010502427-2140729514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OD查看一下是否成功添加节&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171017010643756-336354006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跳转到虚拟地址处查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201710/1197364-20171017010716896-657982901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是我们设置的90,所以已经成功添加了一个节&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;p&gt;作者：IBinary&lt;br/&gt;出处：&lt;a href=&quot;http://www.cnblogs.com/iBinary/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/iBinary/&lt;/a&gt;&lt;br/&gt;版权所有，欢迎保留原文链接进行转载：)&lt;/p&gt;
</description>
<pubDate>Mon, 16 Oct 2017 17:18:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7679712.html</dc:identifier>
</item>
<item>
<title>Vue中之nextTick函数源码分析 - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/7679684.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/7679684.html</guid>
<description>&lt;p&gt;Vue中之nextTick函数源码分析&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 什么是Vue.nextTick()？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;官方文档解释如下：&lt;br/&gt;在下次DOM更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 为什么要使用nextTick?&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;演示Vue&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://tugenhua0707.github.io/vue/vue1/vue.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;ref&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
          {{name}}
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data: {
          name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aa&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        },
        mounted() {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.updateData();
        },
        methods: {
          updateData() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; self &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
            console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$el.textContent); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; aa&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$nextTick(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
              console.log(self.$el.textContent); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; bb&lt;/span&gt;
&lt;span&gt;            });
          }
        }
      });
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码 在页面视图上显示bb，但是当我在控制台打印的时候，获取的文本内容还是 aa，但是使用 nextTick后，获取的文本内容就是最新的内容bb了，因此在这种情况下，我们可以使用nextTick函数了。&lt;br/&gt;上面的代码为什么改变this.name = 'bb';后，再使用console.log(this.$el.textContent);打印的值还是aa呢？那是因为设置name的值后，DOM还没有更新到，所以获取值还是之前的值，但是我们放到nextTick函数里面的时候，代码会在DOM更新后执行，因此DOM更新后，再去获取元素的值就可以获取到最新值了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;理解DOM更新&lt;/strong&gt;：在VUE中，当我们修改了data中的某一个值后，并不会立即反应到该el中，vue将对更改的数据放到watcher的一个异步队列中，只有在当前任务空闲时才会执行watcher队列任务，这就有一个延迟时间，因此放到 nextTick函数后就可以获取该el的最新值了。如果我们把上面的nextTick&lt;br/&gt;改成setTimeout也是可以的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Vue源码详解之nextTick（源码在 vue/src/core/util/env.js）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在理解nextTick源码之前，我们先来理解下 html5中新增的 MutationObserver的API，它的作用是用来监听DOM变动的接口，它能监听一个dom对象发生的子节点删除，属性修改，文本内容修改等等，具体使用看我这边博客&lt;a href=&quot;http://www.cnblogs.com/tugenhua0707/articles/6849948.html&quot; target=&quot;_blank&quot;&gt;(http://www.cnblogs.com/tugenhua0707/articles/6849948.html).&lt;/a&gt;&lt;br/&gt;nextTick源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
export const nextTick = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
  const callbacks &lt;/span&gt;=&lt;span&gt; []
  let pending &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  let timerFunc

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; nextTickHandler () {
    pending &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     之所以要slice复制一份出来是因为有的cb执行过程中又会往callbacks中加入内容，比如$nextTick的回调函数里又有$nextTick，
     那么这些应该放入到下一个轮次的nextTick去执行，所以拷贝一份，遍历完成即可，防止一直循环下去。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    const copies &lt;/span&gt;= callbacks.slice(0&lt;span&gt;)
    callbacks.length &lt;/span&gt;= 0
    &lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; copies.length; i++&lt;span&gt;) {
      copies[i]()
    }
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the nextTick behavior leverages the microtask queue, which can be accessed&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; via either native Promise.then or MutationObserver.&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; MutationObserver has wider support, however it is seriously bugged in&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; UIWebView in iOS &amp;gt;= 9.3.3 when triggered in touch event handlers. It&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; completely stops working after triggering a few times... so, if native&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Promise is available, we will use it:&lt;/span&gt;
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; istanbul ignore if &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    nextTick行为利用了microtask队列, 先使用 Promise.resolve().then(nextTickHandler)来将异步回调
    放入到microtask中，Promise 和 MutationObserver都可以使用，但是 MutationObserver 在IOS9.3以上的
    WebView中有bug，因此如果满足第一项的话就可以执行，如果没有原生Promise就用 MutationObserver。
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; Promise !== 'undefined' &amp;amp;&amp;amp;&lt;span&gt; isNative(Promise)) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p =&lt;span&gt; Promise.resolve()
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; logError = err =&amp;gt;&lt;span&gt; { console.error(err) }
    timerFunc &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
      p.then(nextTickHandler).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(logError)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; in problematic UIWebViews, Promise.then doesn't completely break, but&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; it can get stuck in a weird state where callbacks are pushed into the&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; microtask queue but the queue isn't being flushed, until the browser&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; needs to do some other work, e.g. handle a timer. Therefore we can&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;force&quot; the microtask queue to be flushed by adding an empty timer.&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isIOS) setTimeout(noop)
    }
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; MutationObserver !== 'undefined' &amp;amp;&amp;amp;&lt;span&gt; (
    isNative(MutationObserver) &lt;/span&gt;||
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; PhantomJS and iOS 7.x&lt;/span&gt;
    MutationObserver.toString() === '[object MutationObserverConstructor]'&lt;span&gt;
  )) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; use MutationObserver where native Promise is not available,&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g. PhantomJS IE11, iOS7, Android 4.4&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     创建一个MutationObserver，observe监听到DOM改动之后执行的回调 nextTickHandler 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; counter = 1
    &lt;span&gt;var&lt;/span&gt; observer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MutationObserver(nextTickHandler)
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; textNode =&lt;span&gt; document.createTextNode(String(counter));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用MutationObserver的接口，监听文本节点的字符内容&lt;/span&gt;
&lt;span&gt;    observer.observe(textNode, {
      characterData: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    });
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     每次执行timerFunc函数都会让文本节点的内容在0/1之间切换，切换之后将新赋值到那个我们MutationObserver监听的文本节点上去。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    timerFunc &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
      counter &lt;/span&gt;= (counter + 1) % 2&lt;span&gt;
      textNode.data &lt;/span&gt;=&lt;span&gt; String(counter)
    }
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; fallback to setTimeout&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     如果上面的两种都不支持的话，我们就使用setTimeout来执行
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    timerFunc &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
      setTimeout(nextTickHandler, &lt;/span&gt;0&lt;span&gt;)
    }
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; queueNextTick (cb?: Function, ctx?&lt;span&gt;: Object) {
    let _resolve
    callbacks.push(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cb) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          cb.call(ctx)
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
          handleError(e, ctx, &lt;/span&gt;'nextTick'&lt;span&gt;)
        }
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_resolve) {
        _resolve(ctx)
      }
    });
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 如果pending为true，表明本轮事件循环中已经执行过 timerFunc(nextTickHandler, 0) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pending) {
      pending &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      timerFunc()
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!cb &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; Promise !== 'undefined'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
        _resolve &lt;/span&gt;=&lt;span&gt; resolve
      })
    }
  }
})()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;整体思路理解：首先 nextTick 是一个闭包函数，代码立即执行，在理解整体代码之前，我们先来看个类似的demo，如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;演示Vue&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;var&lt;/span&gt;&lt;span&gt; nextTick &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; queueNextTick(cb, ctx) {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cb) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
              cb.call(ctx)
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
              console.log(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;出错了&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            }
          }
        }
      })();

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法调用&lt;/span&gt;
&lt;span&gt;      nextTick(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        console.log(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印2&lt;/span&gt;
&lt;span&gt;      })
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;demo代码和上面的代码很类似。&lt;br/&gt;我们也可以再来抽离使用nextTick做demo代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; nextTick2 = (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
  const callbacks &lt;/span&gt;=&lt;span&gt; [];
  let pending &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  let timerFunc;

  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; nextTickHandler () {
    pending &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    const copies &lt;/span&gt;= callbacks.slice(0&lt;span&gt;)
    callbacks.length &lt;/span&gt;= 0
    &lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; copies.length; i++&lt;span&gt;) {
      copies[i]()
    }
  }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; Promise !== 'undefined'&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p =&lt;span&gt; Promise.resolve()
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; logError = err =&amp;gt;&lt;span&gt; { console.error(err) }
    timerFunc &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
      p.then(nextTickHandler).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(logError)
    }
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; MutationObserver !== 'undefined' ||
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; PhantomJS and iOS 7.x&lt;/span&gt;
    MutationObserver.toString() === '[object MutationObserverConstructor]'&lt;span&gt;
  ) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; use MutationObserver where native Promise is not available,&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g. PhantomJS IE11, iOS7, Android 4.4&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; counter = 1
    &lt;span&gt;var&lt;/span&gt; observer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MutationObserver(nextTickHandler)
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; textNode =&lt;span&gt; document.createTextNode(String(counter))
    observer.observe(textNode, {
      characterData: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    })
    timerFunc &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
      counter &lt;/span&gt;= (counter + 1) % 2&lt;span&gt;
      textNode.data &lt;/span&gt;=&lt;span&gt; String(counter)
    }
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; fallback to setTimeout&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; istanbul ignore next &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    timerFunc &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
      setTimeout(nextTickHandler, &lt;/span&gt;0&lt;span&gt;)
    }
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; queueNextTick (cb, ctx) {
    let _resolve
    callbacks.push(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cb) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          cb.call(ctx)
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
          handleError(e, ctx, &lt;/span&gt;'nextTick'&lt;span&gt;)
        }
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_resolve) {
        _resolve(ctx)
      }
    })
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pending) {
      pending &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      timerFunc()
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!cb &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; Promise !== 'undefined'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
        _resolve &lt;/span&gt;=&lt;span&gt; resolve
      })
    }
  }
})();
nextTick2(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
  console.log(&lt;/span&gt;2222&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码是nextTick源码的抽离，为了更好的理解nextTick，做了如上的demo。&lt;br/&gt;我们再来理解一下整体的代码的含义；&lt;br/&gt;先定义数组 callbacks = [];来存放所有需要执行的回调函数，定义let pending = false；判断本轮事件是否执行过 timerFunc(nextTickHandler, 0)这个函数，为true说明执行过 timeFunc函数，接着定义nextTickHandler函数，该函数的作用是依次遍历数组callbacks保存的函数，依次执行；&lt;br/&gt;请看源代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; nextTickHandler () {
  pending &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
  const copies &lt;/span&gt;= callbacks.slice(0&lt;span&gt;)
  callbacks.length &lt;/span&gt;= 0
  &lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; copies.length; i++&lt;span&gt;) {
    copies[i]()
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就是三个判断了，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; Promise !== 'undefined' &amp;amp;&amp;amp;&lt;span&gt; isNative(Promise)) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p =&lt;span&gt; Promise.resolve();
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; logError = err =&amp;gt;&lt;span&gt; { console.error(err) }
  timerFunc &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
    p.then(nextTickHandler).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(logError);
} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; MutationObserver !== 'undefined' &amp;amp;&amp;amp;&lt;span&gt; (
    isNative(MutationObserver) &lt;/span&gt;||
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; PhantomJS and iOS 7.x&lt;/span&gt;
    MutationObserver.toString() === '[object MutationObserverConstructor]'&lt;span&gt;
)){
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; counter = 1
  &lt;span&gt;var&lt;/span&gt; observer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MutationObserver(nextTickHandler)
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; textNode =&lt;span&gt; document.createTextNode(String(counter))
  observer.observe(textNode, {
    characterData: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
  })
  timerFunc &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
    counter &lt;/span&gt;= (counter + 1) % 2&lt;span&gt;
    textNode.data &lt;/span&gt;=&lt;span&gt; String(counter)
  }
} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
  timerFunc &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
    setTimeout(nextTickHandler, &lt;/span&gt;0&lt;span&gt;)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先判断是否支持Promise对象，如果支持的话，定义了timeFunc()函数，为了下一步调用做准备，然后继续判断是否支持该对象 MutationObserver，&lt;br/&gt;如果支持的话，创建一个文本节点，监听该节点数据是否发生改变，如果发生改变的话，调用timerFunc函数，counter值会在0/1切换，如果值改变了的话，&lt;br/&gt;把该数据值赋值到data属性上面去，那么data属性发生改变了，就会重新渲染页面(因为vue是通过Object.defineProperty来监听属性值是否发生改变)，&lt;br/&gt;如果上面两种情况都不满足的话，那么直接使用setTimeout来执行nextTickHandler函数了；&lt;br/&gt;最后nextTick代码返回一个函数，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; queueNextTick (cb?: Function, ctx?&lt;span&gt;: Object) {
  let _resolve
  callbacks.push(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cb) {
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        cb.call(ctx)
      } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
        handleError(e, ctx, &lt;/span&gt;'nextTick'&lt;span&gt;)
      }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_resolve) {
      _resolve(ctx)
    }
  })
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pending) {
    pending &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    timerFunc()
  }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!cb &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; Promise !== 'undefined'&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
      _resolve &lt;/span&gt;=&lt;span&gt; resolve
    })
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码的含义是：传入的cb是否是函数，ctx参数是否是一个对象，如果cb是一个函数的话，使用cb.call(ctx), 如果timerFunc没有执行过的话，那么pending为&lt;br/&gt;false，因此执行 timerFunc()函数。基本的思路就是这样的。&lt;/p&gt;
</description>
<pubDate>Mon, 16 Oct 2017 16:36:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tugenhua0707/p/7679684.html</dc:identifier>
</item>
<item>
<title>从给数组中的对象去重看Javascript中的reduce() - 手撕黄油</title>
<link>http://www.cnblogs.com/caideyipi/p/7679681.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caideyipi/p/7679681.html</guid>
<description>&lt;p&gt;假设有这样一个数组：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
let person =&lt;span&gt; [
     {id: &lt;/span&gt;0, name: &quot;小明&quot;&lt;span&gt;},
     {id: &lt;/span&gt;1, name: &quot;小张&quot;&lt;span&gt;},
     {id: &lt;/span&gt;2, name: &quot;小李&quot;&lt;span&gt;},
     {id: &lt;/span&gt;3, name: &quot;小孙&quot;&lt;span&gt;},
     {id: &lt;/span&gt;1, name: &quot;小周&quot;&lt;span&gt;},
     {id: &lt;/span&gt;2, name: &quot;小陈&quot;&lt;span&gt;},   
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们想去掉数组中id重复的对象，比如同样id为2的两个对象——&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;{id: 2, name: &quot;小李&quot;}和{id: 2, name: &quot;小陈&quot;} （去掉任何一个都可以）&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;我们该如何去做呢？&lt;/p&gt;
&lt;p&gt;事实上，对于数组对象，传统的去重方法无能为力，至于forEach()、filter()等迭代方法也不好使；真正能做到优雅去重的，是ES5新增加的一个方法——&lt;span&gt;reduce()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;reduce()方法接收一个回调函数作为第一个参数，回调函数又接受四个参数，分别是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;1. cur =&amp;gt; 首个值或者与后面的值叠加的结果；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2. next =&amp;gt; 下一个要叠加的值；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3. index =&amp;gt; 索引值；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;4. arr =&amp;gt; 数组本身；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;reduce常用的方法就是不断叠加数组中的每一项，并返回出来；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
let log =&lt;span&gt; console.log.bind(console);
let arr &lt;/span&gt;= [1,2,3,4,5,6&lt;span&gt;];
arr &lt;/span&gt;= arr.reduce((cur,next) =&amp;gt;&lt;span&gt; {
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cur +&lt;span&gt; next;
})
log(arr); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出，上面代码的最终结果就是1+2+3+4+5+6 = 21；&lt;/p&gt;
&lt;p&gt;此外，reduce还可以接收第二参数，用来声明回调函数（第一个参数）的cur的类型和初始值；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
let log =&lt;span&gt; console.log.bind(console);
let arr &lt;/span&gt;= [1,2,3,4,5,6&lt;span&gt;];
arr &lt;/span&gt;= arr.reduce((cur,next) =&amp;gt;&lt;span&gt; {
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cur +&lt;span&gt; next;
}，&lt;/span&gt;0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定cur的类型为Number并且初始值为0，当设为1时，最终打印的值为22&lt;/span&gt;
log(arr); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;reduce()大致就是这样。通过这个方法，我们可以非常优雅的实现数组中的对象去重，让我们回到文章开头的那个数组：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
let log =&lt;span&gt; console.log.bind(console);
let person &lt;/span&gt;=&lt;span&gt; [
     {id: &lt;/span&gt;0, name: &quot;小明&quot;&lt;span&gt;},
     {id: &lt;/span&gt;1, name: &quot;小张&quot;&lt;span&gt;},
     {id: &lt;/span&gt;2, name: &quot;小李&quot;&lt;span&gt;},
     {id: &lt;/span&gt;3, name: &quot;小孙&quot;&lt;span&gt;},
     {id: &lt;/span&gt;1, name: &quot;小周&quot;&lt;span&gt;},
     {id: &lt;/span&gt;2, name: &quot;小陈&quot;&lt;span&gt;},   
];

let obj &lt;/span&gt;=&lt;span&gt; {};

person &lt;/span&gt;= person.reduce((cur,next) =&amp;gt;&lt;span&gt; {
    obj[next.id] &lt;/span&gt;? &quot;&quot; : obj[next.id] = &lt;span&gt;true&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; cur.push(next);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cur;
},[]) //设置cur默认类型为数组，并且初始值为空的数组
log(person);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印person后，我们就可以得到去重后的数组。&lt;/p&gt;
</description>
<pubDate>Mon, 16 Oct 2017 16:35:00 +0000</pubDate>
<dc:creator>手撕黄油</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/caideyipi/p/7679681.html</dc:identifier>
</item>
<item>
<title>elasticsearch高级组合查询ava - 新风之谷</title>
<link>http://www.cnblogs.com/zengxiaoyi36/p/7679560.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zengxiaoyi36/p/7679560.html</guid>
<description>&lt;p&gt;/**&lt;br/&gt;     * 高级检索（组合条件检索）must相当于sql and操作&lt;br/&gt;     * @param modelType 0为模糊查询，1为精确查询&lt;br/&gt;     * @param index 索引&lt;br/&gt;     * @param map key为查询字段和value为查询内容&lt;br/&gt;     * @param Page 分页页码&lt;br/&gt;     * @param Pagesize 每页显示条数&lt;br/&gt;     * @return SearchHits  &lt;br/&gt;     */&lt;br/&gt;    public static SearchHits AdvancedQuery1(Integer modelType,String index,Map&amp;lt;String,String&amp;gt; map,int Page,int Pagesize){&lt;br/&gt;        SearchRequestBuilder sr =transportClient.prepareSearch(index);&lt;br/&gt;        BoolQueryBuilder queryBuilder=QueryBuilders.boolQuery();&lt;br/&gt;        System.out.println(index);&lt;br/&gt;        if(modelType==0){&lt;br/&gt;            for(Map.Entry&amp;lt;String, String&amp;gt; entry : map.entrySet()){&lt;/p&gt;
&lt;p&gt;              //wildcardQuery 模糊查询&lt;br/&gt;                queryBuilder.must(QueryBuilders.wildcardQuery(entry.getKey(), entry.getValue()+&quot;*&quot;));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        else if(modelType==1){&lt;br/&gt;            for(Map.Entry&amp;lt;String, String&amp;gt; entry : map.entrySet()){&lt;/p&gt;
&lt;p&gt;                 //termQuery 查询精确&lt;br/&gt;                queryBuilder.must(QueryBuilders.termQuery(entry.getKey(),entry.getValue()));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        sr.setQuery(queryBuilder)&lt;br/&gt;          .setFrom((Page-1)*Pagesize)&lt;br/&gt;          .setSize(Pagesize);&lt;br/&gt;        SearchResponse response=sr.get();&lt;br/&gt;        SearchHits hits=response.getHits();&lt;br/&gt;        return hits;&lt;br/&gt;        &lt;br/&gt;    }&lt;/p&gt;
</description>
<pubDate>Mon, 16 Oct 2017 15:44:00 +0000</pubDate>
<dc:creator>新风之谷</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zengxiaoyi36/p/7679560.html</dc:identifier>
</item>
<item>
<title>递归调用在循环体内: 把循环展开, 这种情况是先循环再递归 - georgeguo</title>
<link>http://www.cnblogs.com/georgejguo/p/7679498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/georgejguo/p/7679498.html</guid>
<description>&lt;p&gt;&lt;strong&gt;整理自陈莉君（翻译深入理解Linux内核的作者）老师文章。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阿里2015笔试中有这样一道题目：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在一台主流配置的PC上，调用f(35)所需要的时间大概是（ ）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int f(int x){&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;int s = 0;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;while(x++ &amp;gt;0) s+= f(x);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;return max(s,1);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A．几毫秒 B．几秒 C．几分钟 D．几小时&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本题涉及到的知识点包括数据的表示和运算、时间复杂度。考查考生对带符号整数的表示、递归调用的执行过程、计算机系统性能、虚拟存储器、C语言语句等相关知识的理解和运用能力。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数学上的分析推导结果与计算机系统中的执行结果是有差异的。例如，在数学中一个数可以无限大，但在计算机中受表示位数的限制，数的值是有限的。用数学分析的方法，本题的递归是可以终止的，但受存储容量的限制，在计算机中递归调用时会有栈溢出的问题，导致程序不能正常执行结束。类似的问题还有很多，这是平时编程时需要注意的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设题目中的函数用C语言书写，要分析调用f(35)所需的时间，就得分析代码执行中循环执行次数和递归调用次数等，下面深入剖析f(35)执行过程中存在的问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：以下231为2的31次方。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）程序是否会终止？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用f(35)时，入口参数x=35。从数学的角度理解while中的判断表达式“x++ &amp;gt;0”，会认为x在增量后永远大于0，这是一个永真式，从而做出错误结论：程序死循环。在计算机中数值是有范围的，int型数据用补码表示，占4个字节，能表示的最大正数是231-1 = 7FFF FFFFH。231的机器数是8000 0000H，其值为int型，能表示的最小负数-2147483648，因此当x = 8000 0000H 时，x &amp;gt; 0的值为假，程序退出while循环，因此，若不考虑栈溢出，则程序能执行结束。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）使递归终止的最大x值是多少？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;while(x++ &amp;gt;0)语句在Microsoft VC中的机器代码如下，该语句的执行过程是：先把x的值分别保存到EDX和EAX寄存器；然后对EAX寄存器内容加1，以实现x = x+1操作；最后再用EDX的内容（x的旧值）进行x&amp;gt;0的条件判断。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mov edx, dword ptr [ebp+8]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mov eax,dword ptr [ebp+8]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;add eax, 1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mov dword ptr [ebp+8], eax&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;test edx, edx&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;jle f+77h (00401097)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因此，当调用f(231-1)时，x = 231-1=7FFF FFFFH，先执行x=7FFF FFFFH+1 = 8000 0000H=231，然后，用旧的x=7FFF FFFFH与0比较，比较结果为真，故执行while循环体，在循环体中调用f(231)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用f(231)时，x为231 = 8000 0000H，其真值为负数，因此，与0比较的结果为假，故跳出while循环体，程序结束。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;综上所述，使递归终止的最大x值是231，即执行f(231)时结束递归调用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）函数f(x)的递归调用情况如何？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;f(x)是一个递归调用过程，并且递归调用在循环体内，因此调用关系较复杂。图1显示了f(231-4)执行中的递归调用情况。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1252125/201710/1252125-20171016231005474-421057238.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;        图1 f(231-4)执行中的递归调用情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在f(x)执行过程中，把执行f(x)过程体的总次数记为f(x)执行次数，把一次递归调用的最大次数记为f(x)递归深度。表1给出了x为不同值时，执行f(x)的次数和递归深度。这两个参数显示了f(x)函数的执行过程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       表1  x为不同值时，f(x)执行的次数和递归调用深度&lt;/strong&gt;&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt; &lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;f(x)执行次数&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;递归深度&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;f(231)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;f(231-1)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;f(231-2)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;f(231-3)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;f(231-4)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;16&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;f(231-n)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;2n&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;n+1&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;f(35)=f(231-2147483613)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;22147483613&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;2147483614&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;（4） 递归调用过程的执行情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统会给每一个用户进程分配存放代码和数据的用户空间，用户空间中的栈区用来存放程序运行时过程调用的参数、返回地址、过程局部变量等。随着程序的执行，栈区不断动态地从高地址向低地址增长或向反方向减退。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户栈由若干个栈帧组成，每个过程对应一个栈帧，帧指针寄存器EBP指定一个栈帧的起始地址，栈指针寄存器ESP指向栈顶，当前栈帧的范围在EBP和ESP指向的区域之间。过程执行时，由于不断有数据入栈，所以栈指针ESP会动态移动，而帧指针EBP固定不变。在一个过程内对栈中信息的访问大多通过帧指针EBP进行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IA-32规定，寄存器EAX、ECX和EDX是调用者保存寄存器，EBX、ESI、EDI寄存器是被调用者保存寄存器。若过程P调用过程Q时，P在需要时先在自己的栈区保存EAX、ECX和EDX、入口参数和返回地址，接着跳转到Q执行。Q在自己的栈帧中先保存P的EBP值，并设置EBP指向当前Q栈帧的栈低，根据需要保存EBX、ESI、EDI，再在栈中给Q的局部变量分配空间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在递归调用执行中，每个递归调用过程都有一个栈帧。栈帧中可能包含如图2所示的信息。&lt;/strong&gt;&lt;/p&gt;

&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;2&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;调用者的EBP值&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; height=&quot;25&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;调用者的EBX、ESI、EDI&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;过程局部变量&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;自己的EAX、ECX和EDX&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;入口参数n&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;入口参数1&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; height=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;返回地址&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;           图2 一次递归调用中的栈帧&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图3显示了在windows系统中f(x)函数调用时的部分机器指令。可以看出f(x)的栈帧至少有84B。系统分配给一个进程的用户栈只有有限的空间，因此，递归调用的次数是有限的。f(35)的递归深度是2147483614，即至少需要2147483614×84字节，即大于170GB的栈帧空间。在32位系统中，最大虚拟地址空间仅有4GB，用户栈只是其中的一部分，所以f(35)在执行过程中会出现栈溢出的现象。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1252125/201710/1252125-20171016231142052-859559500.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;br/&gt;        图3 f(x)函数调用时的部分机器指令&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5） f(35)在32位系统中的实际执行情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设在Intel x86+windows+VC+C语言环境中执行f(35)。VC中默认分配栈的大小是1MB，虽然用户可以调整栈大小，但栈的容量是有限的。按2MB的栈空间、栈大小按80字节计算：2MB÷80B≈26214，因此f(x)递归调用的次数不会超过26214-1=26213次。从图4.9中可以看出，栈溢出时，f(x)函数体最多执行26213次。栈溢出时每个f(x)函数体只在while语句中执行，假设每个f(x)函数体执行100条指令，即使指令平均CPI为3，时钟频率为2.4GHz，f(35)的执行时间也只有26213×100×3÷2.4GHz ≈3.2 ms左右时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对f(35)的执行做了测试，在栈大小是1MB时，递归调用11244次后栈溢出；在栈设置为2MB时，递归调用22642次后栈溢出，显然运行时间只有几毫秒。在Microsoft VisualStudio 2012环境中运行，出现如图4所示结果，表明出现了栈溢出（Stack overflow）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1252125/201710/1252125-20171016231224849-947524528.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;综上所述，答案为A。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上整理自陈莉君老师的文章。对于其中不容易理解的&lt;strong&gt;图1 f(231-4)执行中的递归调用情况&lt;/strong&gt;这里给出注释：&lt;/p&gt;
&lt;p&gt;对于递归在循环体内我们可以把循环展开，这种情况是先循环再递归：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;while(x++ &amp;gt;0) s+= f(x);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;等价写法(当x=0x80000000-2)：&lt;/p&gt;
&lt;p&gt;if(0x80000000 -2 &amp;gt;0) { // if(x &amp;gt;0)&lt;/p&gt;
&lt;p&gt;0x80000000-1; //x++&lt;/p&gt;
&lt;p&gt;s+=f(0x80000000-1); //f(x)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;if(0x80000000-1 &amp;gt; 0) {&lt;/p&gt;
&lt;p&gt;0x80000000;&lt;/p&gt;
&lt;p&gt;s+=f(0x80000000);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
</description>
<pubDate>Mon, 16 Oct 2017 15:43:00 +0000</pubDate>
<dc:creator>georgeguo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/georgejguo/p/7679498.html</dc:identifier>
</item>
<item>
<title>Bootstrap表格样式(附源码文件)--Bootstrap - 奇客艺术</title>
<link>http://www.cnblogs.com/qikeyishu/p/7679517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qikeyishu/p/7679517.html</guid>
<description>&lt;h3&gt;&lt;span&gt;1、表格默认样式&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;&amp;lt;h4&amp;gt;表格默认样式&amp;lt;/h4&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;table&amp;gt;&amp;lt;!--默认样式--&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;序号&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;&lt;span&gt;2、表格基础样式&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;&amp;lt;h4&amp;gt;表格基础样式&amp;lt;/h4&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;table class=&quot;&lt;span&gt;table&lt;/span&gt;&quot;&amp;gt;&amp;lt;!--表格基础样式--&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;序号&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;&lt;span&gt;3、带背景条纹的表格&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;&amp;lt;h4&amp;gt;带背景条纹&amp;lt;/h4&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;table class=&quot;table &lt;span&gt;table-striped&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;序号&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;&lt;span&gt;4、带边框的表格&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;&amp;lt;h4&amp;gt;带边框的表格&amp;lt;/h4&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;table class=&quot;table &lt;span&gt;table-bordered&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;序号&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;&lt;span&gt;5、显示鼠标悬停效果的表格&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;&amp;lt;h4&amp;gt;鼠标悬停的表格&amp;lt;/h4&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;table class=&quot;table table-bordered &lt;span&gt;table-hover&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;序号&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;&lt;span&gt;6、紧凑型表格&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;&amp;lt;h4&amp;gt;紧凑型表格&amp;lt;/h4&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;table class=&quot;table table-bordered &lt;span&gt;table-condensed&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;序号&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;&lt;span&gt;7、表格行内样式&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;&amp;lt;h4&amp;gt;表格行内样式&amp;lt;/h4&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;table class=&quot;table table-bordered table-condensed&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr class=&quot;&lt;span&gt;info&lt;/span&gt;&quot;&amp;gt;&amp;lt;th&amp;gt;序号&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr class=&quot;&lt;span&gt;success&lt;/span&gt;&quot;&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr class=&quot;&lt;span&gt;warning&lt;/span&gt;&quot;&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr class=&quot;&lt;span&gt;danger&lt;/span&gt;&quot;&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;tr class=&quot;&lt;span&gt;active&lt;/span&gt;&quot;&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;&lt;span&gt;8、响应式表格&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;&amp;lt;h4&amp;gt;响应式表格&amp;lt;/h4&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;div class=&quot;row&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;div class=&quot;col-sm-4&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;div class=&quot;&lt;span&gt;table-responsive&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;table class=&quot;table table-bordered table-condensed&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　&amp;lt;tr class=&quot;info&quot;&amp;gt;&amp;lt;th&amp;gt;序号&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　&amp;lt;tr class=&quot;success&quot;&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　&amp;lt;tr class=&quot;warning&quot;&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　&amp;lt;tr class=&quot;danger&quot;&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　&amp;lt;tr class=&quot;active&quot;&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;&lt;span&gt;9、demo.html：&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;head&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;title&amp;gt;Bootstrap表格样式&amp;lt;/title&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;css/bootstrap.css&quot;&amp;gt;&lt;/span&gt;&lt;/h4&gt;

&lt;h4&gt;　　&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&amp;gt;&lt;/h4&gt;

&lt;h4&gt;&lt;span&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;body&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&amp;lt;div class=&quot;container&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;h4&amp;gt;表格默认样式&amp;lt;/h4&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;table&amp;gt;&amp;lt;!--默认样式--&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;序号&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;h4&amp;gt;表格基础样式&amp;lt;/h4&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;table class=&quot;&lt;span&gt;table&lt;/span&gt;&quot;&amp;gt;&amp;lt;!--表格基础样式--&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;序号&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;h4&amp;gt;带背景条纹&amp;lt;/h4&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;table class=&lt;span&gt;&quot;table&lt;/span&gt; &lt;span&gt; table-striped&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;序号&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;h4&amp;gt;带边框的表格&amp;lt;/h4&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;table class=&quot;table &lt;span&gt;table-bordered&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;序号&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;h4&amp;gt;鼠标悬停的表格&amp;lt;/h4&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;table class=&quot;table table-bordered &lt;span&gt;table-hover&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;序号&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;h4&amp;gt;紧凑型表格&amp;lt;/h4&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;table class=&quot;table table-bordered &lt;span&gt;table-condensed&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;序号&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;h4&amp;gt;表格行内样式&amp;lt;/h4&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;table class=&quot;table table-bordered table-condensed&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr class=&quot;&lt;span&gt;info&lt;/span&gt;&quot;&amp;gt;&amp;lt;th&amp;gt;序号&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr class=&quot;&lt;span&gt;success&lt;/span&gt;&quot;&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr class=&quot;&lt;span&gt;warning&lt;/span&gt;&quot;&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr class=&quot;&lt;span&gt;danger&lt;/span&gt;&quot;&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;tr class=&quot;&lt;span&gt;active&lt;/span&gt;&quot;&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;h4&amp;gt;响应式表格&amp;lt;/h4&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;div class=&quot;row&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;div class=&quot;col-sm-4&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　&amp;lt;div class=&quot;&lt;span&gt;table-responsive&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　　　&amp;lt;table class=&quot;table table-bordered table-condensed&quot;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　　　　　&amp;lt;tr class=&quot;info&quot;&amp;gt;&amp;lt;th&amp;gt;序号&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;姓名&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;年龄&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　　　　　&amp;lt;tr class=&quot;success&quot;&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　　　　　&amp;lt;tr class=&quot;warning&quot;&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　　　　　&amp;lt;tr class=&quot;danger&quot;&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　　　　　&amp;lt;tr class=&quot;active&quot;&amp;gt;&amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;小玲&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;20&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　　　&amp;lt;/table&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　　　&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　　　&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;Effect Picture：&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1186474/201710/1186474-20171016232734802-1573265908.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;源码文件下载：&lt;a id=&quot;&quot; href=&quot;https://files.cnblogs.com/files/qikeyishu/Bootstrap%E8%A1%A8%E6%A0%BC%E6%A0%B7%E5%BC%8F.zip&quot;&gt;Bootstrap表格样式.zip&lt;/a&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;文章原创，转载请注明出处，感谢大家的合作！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Oct 2017 15:38:00 +0000</pubDate>
<dc:creator>奇客艺术</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qikeyishu/p/7679517.html</dc:identifier>
</item>
<item>
<title>jquery各种事件使用方法总结（from：天宇之游） - 牙齿有个缺缺</title>
<link>http://www.cnblogs.com/GP1014336455/p/7679543.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GP1014336455/p/7679543.html</guid>
<description>
&lt;p&gt;&lt;span&gt;ps：本博客转自博主  天宇之游 ，地址：&lt;span class=&quot;text_gray&quot;&gt;&lt;a class=&quot;gray&quot; href=&quot;http://www.cnblogs.com/cwp-bg/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cwp-bg/&lt;/a&gt;  ，再次感谢天宇之游。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;jquery事件使用方法总结&lt;/p&gt;&lt;p&gt;&lt;span&gt;一、鼠标事件&lt;/span&gt;&lt;br/&gt;1. click()：鼠标单击事件&lt;/p&gt;&lt;p&gt;$div = $(&quot;div&quot;)&lt;br/&gt;$div.click(data,function (event) { //点击盒子变蓝&lt;br/&gt;    $(this).css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;    });&lt;br/&gt;    console.log(event);&lt;br/&gt;})&lt;/p&gt;&lt;p&gt;    参数function：匿名函数有且只有一个默认的参数event，event输出事件相关的信息；不允许有其他的参数，可以不写。&lt;br/&gt;    参数data：有时候需要传递额外的数据给函数，data可以是一个数组，不需要可以省略。&lt;/p&gt;&lt;p&gt;扩展：&lt;/p&gt;&lt;p&gt;//event参数可以获取事件的各种属性，有几个常用&lt;/p&gt;&lt;p&gt;event.target:  获取触发事件的元素&lt;/p&gt;&lt;p&gt;$div.click(function (event) {&lt;br/&gt;            $(event.target).css({&lt;br/&gt;                    &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;                });&lt;br/&gt;    })&lt;br/&gt;    &lt;br/&gt;event.data: 获取事件传入的参数数据。&lt;br/&gt;event.pageX: 获取鼠标光标点击距离文档左边left的距离；&lt;br/&gt;event.pageY: 获取鼠标光标点击距离文档上边top的距离；&lt;/p&gt;&lt;p&gt;event.offsetX: 获取鼠标光标点击距离元素左边left的距离；&lt;br/&gt;event.offssetY: 获取鼠标光标点击距离元素上边top的距离；&lt;/p&gt;&lt;p&gt;event.screenX: 获取鼠标光标点击距离屏幕left的距离；&lt;br/&gt;event.screenY: 获取鼠标光标点击距离屏幕top的距离；&lt;/p&gt;&lt;p&gt;2. dblclick()：鼠标双击事件&lt;/p&gt;&lt;p&gt;$div = $(&quot;div&quot;)&lt;br/&gt;$div.dblclick()(function (event) { //双击盒子变蓝&lt;br/&gt;    $(this).css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;    });               &lt;br/&gt;})&lt;/p&gt;&lt;p&gt;    参数和click的用法完全一样，event同样可以获取众多的属性。&lt;/p&gt;&lt;p&gt;3. 鼠标进入和离开（进入子元素也触发）&lt;/p&gt;&lt;p&gt;    mouseover()：进入&lt;br/&gt;    mouseout()：离开&lt;/p&gt;&lt;p&gt;$div = $(&quot;div&quot;)&lt;br/&gt;$div.mouseover(function (event) {&lt;br/&gt;    $(this).css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;    });               &lt;br/&gt;})&lt;br/&gt;$div.mouseout(function (event) {&lt;br/&gt;    $(this).css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;    });               &lt;br/&gt;})&lt;/p&gt;&lt;p&gt;    参数同上，绑定后鼠标进入元素的子元素会再次触发。&lt;/p&gt;&lt;p&gt;4. 鼠标进入和离开（进入子元素不触发）&lt;/p&gt;&lt;p&gt;    mouseenter() 鼠标进入&lt;br/&gt;    mouseleave() 鼠标离开&lt;/p&gt;&lt;p&gt;$div = $(&quot;div&quot;)&lt;br/&gt;$div.mouseenter(function (event) {&lt;br/&gt;    $(this).css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;    });               &lt;br/&gt;})&lt;br/&gt;$div.mouseleave(function (event) {&lt;br/&gt;    $(this).css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;    });               &lt;br/&gt;})&lt;/p&gt;&lt;p&gt;    参数同上，绑定后鼠标进入和离开子元素不会再次触发。&lt;/p&gt;&lt;p&gt;5. hover():同时为mouseenter和mouseleave事件指定处理函数&lt;/p&gt;&lt;p&gt;$div = $(&quot;div&quot;)&lt;br/&gt;// 鼠标进入和移出事件&lt;br/&gt;    $div.hover(function (event) {&lt;br/&gt;        $div.css({&lt;br/&gt;            &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;        })&lt;/p&gt;&lt;p&gt;    },function (event) {&lt;br/&gt;        $div.css({&lt;br/&gt;            &quot;background&quot;: &quot;red&quot;,&lt;br/&gt;        });&lt;br/&gt;    })&lt;/p&gt;&lt;p&gt;    hover可以同时加入两个function，第一个是鼠标进入触发，第二个是移出触发。&lt;br/&gt;    前面不可以添加data参数，否则报错。&lt;/p&gt;&lt;p&gt;6. 鼠标按下和松开&lt;/p&gt;&lt;p&gt;    mouseup() 松开鼠标&lt;br/&gt;    mousedown() 按下鼠标&lt;/p&gt;&lt;p&gt;$div = $(&quot;div&quot;)&lt;br/&gt;$div.mousedown(function (event) {&lt;br/&gt;    $(this).css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;    });&lt;br/&gt;    console.log(event);&lt;br/&gt;})&lt;/p&gt;&lt;p&gt;$div.mouseup(function (event) {&lt;br/&gt;    $(this).css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;    });&lt;br/&gt;    console.log(event);&lt;br/&gt;})&lt;/p&gt;&lt;p&gt;    参数同click，和点击事件click不同的是，click在鼠标点击（包括按下和松开）后才触发事件，这里是按下或松开就会触发。&lt;/p&gt;&lt;p&gt;7. mousemove() 鼠标在元素内部移动&lt;/p&gt;&lt;p&gt;    同法和参数同上。&lt;/p&gt;&lt;p&gt;&lt;span&gt;二、键盘事件&lt;/span&gt;&lt;br/&gt;*keypress()：按下键盘（指的是按下）&lt;/p&gt;&lt;p&gt; $(window).keypress([20],function (event) {&lt;br/&gt;        $div.css({&lt;br/&gt;            &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;        });&lt;br/&gt;    console.log(event.which);            &lt;br/&gt;    })&lt;/p&gt;&lt;p&gt;    参数：同鼠标事件，第一个参数传递数据，function默认参数event值按下键盘事件。&lt;br/&gt;    键盘事件需要绑定可获得焦点的元素，如：input，body，html，一般绑定窗口：window。&lt;br/&gt;    如果需要具体判断按下了那个按键，使用event.which,返回键盘字母的ascii码。&lt;/p&gt;&lt;p&gt;注意：如果按下不放开，事件会连续触发。&lt;br/&gt;*按下和松开&lt;/p&gt;&lt;p&gt;    keydown() 按下键盘&lt;br/&gt;    keyup() 松开键盘&lt;/p&gt;&lt;p&gt;$(window).keydown([20],function (event) {&lt;br/&gt;    $div.css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;    });&lt;br/&gt;    console.log(event);&lt;br/&gt;})&lt;/p&gt;&lt;p&gt;$(window).keyup([20],function (event) {&lt;br/&gt;    $div.css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;    });&lt;br/&gt;    console.log(event);&lt;br/&gt;})&lt;/p&gt;&lt;p&gt;    参数同上。&lt;br/&gt;    keydown和keypress方法区别在于，keypress事件不会触发所有的按键，比如 ALT、CTRL、SHIFT、ESC等。&lt;/p&gt;&lt;p&gt;&lt;span&gt;三、焦点事件&lt;/span&gt;&lt;br/&gt;* 元素获取和失去焦点&lt;/p&gt;&lt;p&gt;    blur() 元素失去焦点&lt;br/&gt;    focus() 元素获得焦点&lt;/p&gt;&lt;p&gt;$put = $(&quot;input&quot;);&lt;br/&gt;$put.focus():元素自动获取焦点&lt;/p&gt;&lt;p&gt;$put.focus(function (event) {&lt;br/&gt;    console.log(event);&lt;br/&gt;        $div.css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;            })&lt;br/&gt;})//获取焦点后触发事件&lt;/p&gt;&lt;p&gt;$put.blur(function (event) {&lt;br/&gt;    console.log(event);&lt;br/&gt;        $div.css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;            })&lt;br/&gt;})//失去焦点后触发事件&lt;/p&gt;&lt;p&gt;    参数同click；&lt;br/&gt;    焦点事件一般使用在input标签上，其他的标签一般得不到焦点。&lt;/p&gt;&lt;p&gt;&lt;span&gt;四、表单事件&lt;/span&gt;&lt;br/&gt;* submit()： 用户递交表单&lt;/p&gt;&lt;p&gt;$(&quot;.form&quot;).submit(function (event) {&lt;br/&gt;    alert(&quot;提交事件&quot;);&lt;br/&gt;    console.log(event);&lt;br/&gt;    //阻止系统默认事件&lt;br/&gt;    event.defaultPrevented();&lt;br/&gt;    return false;&lt;br/&gt;})&lt;/p&gt;&lt;p&gt;    submit事件绑定在form表单上，点击提交按钮时触发该事件，可以对系统默认的提交进行拦截。&lt;br/&gt;    event.defaultPrevented();//阻止系统提交数据&lt;/p&gt;&lt;p&gt;&lt;span&gt;五、其他事件&lt;/span&gt;&lt;br/&gt;* ready()：DOM加载完成后执行&lt;/p&gt;&lt;p&gt;    这个事件用来防止js报错，每次引入js都要使用，不在赘述。&lt;/p&gt;&lt;p&gt;* resize()：浏览器窗口的大小发生改变触发事件&lt;/p&gt;&lt;p&gt;$(window).resize(function () {&lt;br/&gt;    console.log($(window).width());&lt;br/&gt;   })&lt;br/&gt;   &lt;/p&gt;&lt;p&gt;    参数同click,这个事件需要绑定在window上才会生效，用于监控窗口的变化。&lt;/p&gt;&lt;p&gt;* scroll()：滚动条的位置发生变化&lt;br/&gt;* change()： 表单元素的值发生变化&lt;/p&gt;&lt;p&gt;$put.change(function () {&lt;br/&gt;    $div.css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;    });&lt;br/&gt;                &lt;br/&gt;})&lt;/p&gt;&lt;p&gt;    当表单元素如单选框、多选框、文本框等值发生变化时触发。&lt;/p&gt;&lt;p&gt;* unload() ：用户离开页面&lt;/p&gt;&lt;p&gt;$(document).unload(function () {&lt;br/&gt;    $div.css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;    });&lt;br/&gt;    console.log(&quot;likai&quot;);&lt;br/&gt;})&lt;/p&gt;&lt;p&gt;&lt;span&gt;六、通用的绑定事件和解绑方法&lt;/span&gt;&lt;br/&gt;* bind()：绑定&lt;/p&gt;&lt;p&gt;$(function(){&lt;br/&gt;    $('div').bind('mouseover click', function(event) {&lt;br/&gt;        alert($(this).html());&lt;br/&gt;    });&lt;br/&gt;});&lt;br/&gt;   &lt;/p&gt;&lt;p&gt;    参数：第一个参数为需要绑定的事件的名字，可以绑定多个事件，之间用空格隔开；第二个参数是处理函数。&lt;/p&gt;&lt;p&gt;* unbind():解绑&lt;/p&gt;&lt;p&gt;$(function(){&lt;br/&gt;    $('#div1').bind('mouseover click', function(event) {&lt;br/&gt;        // $(this).unbind();解绑所有事件&lt;br/&gt;        $(this).unbind('mouseover');解绑指定事件&lt;br/&gt;    });&lt;br/&gt;});&lt;/p&gt;&lt;p&gt;    参数同bind。&lt;/p&gt;&lt;p&gt;* on():绑定和委托都可用的方法&lt;/p&gt;&lt;p&gt;$(&quot;div&quot;).on(event,childSelector,data,function);&lt;br/&gt;//四个参数&lt;/p&gt;&lt;p&gt;$(function(){&lt;br/&gt;    $('div').on('mouseover click', function(event) {&lt;br/&gt;        $(this).css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;        });&lt;br/&gt;    });&lt;br/&gt;});&lt;/p&gt;&lt;p&gt;    参数：&lt;br/&gt;    event,需要绑定的事件，多个事件用空格隔开；&lt;br/&gt;    function：事件的处理方法。&lt;br/&gt;    childSelector：选择需要委托的元素，用于委托事件。&lt;br/&gt;    data：额外的传参。&lt;/p&gt;&lt;p&gt;* off():解绑&lt;/p&gt;&lt;p&gt;$(function(){&lt;br/&gt;    $('#div1').on('mouseover click', function(event) {&lt;br/&gt;        // $(this).off();解绑所有事件&lt;br/&gt;        $(this).off('mouseover');解绑指定事件&lt;br/&gt;    });&lt;br/&gt;});&lt;/p&gt;&lt;p&gt;* one():绑定一次自动解绑&lt;/p&gt;&lt;p&gt;如果需要触发事件一次后就自动失效，比如：按钮点击一次后 就失效使用这个方法。&lt;/p&gt;&lt;p&gt;$(function(){&lt;br/&gt;    $('div').one('mouseover click', function(event) {&lt;br/&gt;        $(this).css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;        });&lt;br/&gt;    });&lt;br/&gt;});&lt;/p&gt;&lt;p&gt;    注意：当一次性绑定多个事件时，多个事件相互是独立的，即如果有一个事件被触发，那么这个事件解绑，对另外没有被触发的事件没有影响。&lt;/p&gt;&lt;p&gt;&lt;span&gt;七、自定义和主动触发事件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;说明：对于系统没有提供的事件，可以自己定义并主动触发。&lt;/p&gt;&lt;p&gt;$div.bind(&quot;abc&quot;,function () {&lt;br/&gt;    $(this).css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;    });&lt;br/&gt;    &lt;br/&gt;})&lt;br/&gt;$div.trigger(&quot;abc&quot;);&lt;/p&gt;&lt;p&gt;    trigger():触发事件的方法；这种方式类似协程。&lt;/p&gt;&lt;p&gt;&lt;span&gt;八、事件的两大特征运用：&lt;/span&gt;&lt;br/&gt;1. 事件的冒泡：&lt;/p&gt;&lt;p&gt;    定义：一个元素标签如div,在上面触发某种事件，如单击；如果div上没有定义单击事件或者定义了单击事件，但返回值不是false，即没有阻止冒泡；那么事件会向父级传递，每一个定义了单击事件的父级都会被触发事件，直到到达document或window。&lt;/p&gt;&lt;p&gt;注意：冒泡是事件的固有属性（自定义不适用），适合所有的系统事件。&lt;/p&gt;&lt;p&gt;    作用： 允许多个事件被击中到父级处理，减少绑定次数，提高性能。&lt;/p&gt;&lt;p&gt;$(function(){&lt;br/&gt;    var $box1 = $('.father');&lt;br/&gt;    var $box2 = $('.son');&lt;br/&gt;    var $box3 = $('.grandson');&lt;br/&gt;    $box1.click(function() {&lt;br/&gt;        alert('father');&lt;br/&gt;    });&lt;br/&gt;    $box2.click(function() {&lt;br/&gt;        alert('son');&lt;br/&gt;    });&lt;br/&gt;    $box3.click(function(event) {&lt;br/&gt;        alert('grandson');&lt;br/&gt;       // event.stopPropagation();阻止冒泡&lt;/p&gt;&lt;p&gt;    });&lt;br/&gt;    $(document).click(function(event) {&lt;br/&gt;        alert('grandfather');&lt;br/&gt;    });&lt;br/&gt;})&lt;/p&gt;&lt;p&gt;......&lt;/p&gt;&lt;p&gt;&amp;lt;div class=&quot;father&quot;&amp;gt;&lt;br/&gt;    &amp;lt;div class=&quot;son&quot;&amp;gt;&lt;br/&gt;        &amp;lt;div class=&quot;grandson&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;br/&gt;    &amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;&lt;p&gt;    说明：上面代码界面，单击“grandson”的div，所有事件都会被触发；&lt;br/&gt;    如果要阻止事件冒泡，使用stopPropagation()；&lt;/p&gt;&lt;p&gt;扩展：合并阻止操作&lt;/p&gt;&lt;p&gt;event.stopPropagation();//阻止冒泡&lt;br/&gt;event.preventDefault();//阻止默认行为&lt;/p&gt;&lt;p&gt;// 合并写法：&lt;br/&gt;return false;&lt;/p&gt;&lt;p&gt;    实际开发中，一般把阻止冒泡和阻止默认行为合并起来写。&lt;/p&gt;&lt;p&gt;2. 事件委托&lt;/p&gt;&lt;p&gt;    定义：&lt;/p&gt;&lt;p&gt;    利用冒泡原理，将要处理相同事件的子元素的事件委托给父级，从而极大减少事件绑定的次数，提高性能。&lt;/p&gt;&lt;p&gt;    委托事件：&lt;/p&gt;&lt;p&gt;    delegate():&lt;/p&gt;&lt;p&gt;$(function(){&lt;br/&gt;    $list = $('list');&lt;br/&gt;    $list.delegate('li', 'click', function(event) {&lt;br/&gt;        $(this).css({background:'red'});&lt;br/&gt;    });&lt;br/&gt;})//给列表下面的每个li元素的事件委托给list列表。&lt;/p&gt;&lt;p&gt;    参数：第一个参数是需要委托的元素，采用css选择器的写法，默认从一级子元素开始；第二个参数时要委托的事件，可以是多个，之间用空格隔开，第三个参数是处理函数。&lt;/p&gt;&lt;p&gt;    event指触发事件的那个对象。&lt;/p&gt;&lt;p&gt;    on():&lt;/p&gt;&lt;p&gt;$(function(){&lt;br/&gt;    $list = $('list');&lt;br/&gt;    $list.on('click', 'li', function(event) {&lt;br/&gt;        $(this).css({background:'red'});&lt;br/&gt;    });&lt;br/&gt;})//给列表下面的每个li元素的事件委托给list列表。&lt;/p&gt;&lt;p&gt;    参数：&lt;br/&gt;        第一个是需要委托的事件，多个用空格隔开；&lt;br/&gt;        第二个是需要委托事件的子元素；&lt;br/&gt;        第三个是触发处理函数。&lt;/p&gt;&lt;p&gt;    one():委托触发一次自动取消委托&lt;/p&gt;&lt;p&gt;$(function(){&lt;br/&gt;    $('div').one('click',&quot;li&quot; function(event) {&lt;br/&gt;        $(this).css({&lt;br/&gt;        &quot;background&quot;: &quot;blue&quot;,&lt;br/&gt;        });&lt;br/&gt;    });&lt;br/&gt;});&lt;/p&gt;&lt;p&gt;    说明：参数用法和on事件一样。&lt;br/&gt;    取消委托&lt;/p&gt;&lt;p&gt;    undelegate():&lt;/p&gt;&lt;p&gt;$list.undelegate();//选择器找到委托对象取消委托&lt;/p&gt;&lt;p&gt;    使用undelegate（）方法取消委托，所有的子元素的委托都将被取消。&lt;/p&gt;&lt;p&gt;    off():&lt;/p&gt;&lt;p&gt;    $list.off(&quot;click&quot;,&quot;li&quot;);&lt;/p&gt;&lt;p&gt;总结：&lt;br/&gt;    每一个事件相当于一个协程，异步操作；&lt;br/&gt;    所有的事件并列处理，事件不要嵌套事件，否则会出现重复绑定。&lt;br/&gt;    可以进行事件委托尽量使用委托，减少系统资源消耗。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ps：本博客转自博主    《天宇之游》  ，地址：&lt;span class=&quot;text_gray&quot;&gt;&lt;a class=&quot;gray&quot; href=&quot;http://www.cnblogs.com/cwp-bg/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cwp-bg/&lt;/a&gt;&lt;/span&gt;  ，再次感谢。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Oct 2017 15:35:00 +0000</pubDate>
<dc:creator>牙齿有个缺缺</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GP1014336455/p/7679543.html</dc:identifier>
</item>
<item>
<title>Python通过future处理并发 - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/7679529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/7679529.html</guid>
<description>&lt;h2 id=&quot;toc_1&quot;&gt;future初识&lt;/h2&gt;
&lt;p&gt;通过下面脚本来对future进行一个初步了解：&lt;br/&gt;例子1：普通通过循环的方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; requests
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; POP20_CC =&lt;span&gt; (
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CN IN US ID BR PK NG BD RU JP MX PH VN ET EG DE IR TR CD FR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;).split()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; BASE_URL = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://flupy.org/data/flags&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; DEST_DIR = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;downloads/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; save_flag(img,filename):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     path =&lt;span&gt; os.path.join(DEST_DIR,filename)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     with open(path,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as fp:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        fp.write(img)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_flag(cc):
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}/{cc}/{cc}.gif&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(BASE_URL,cc=&lt;span&gt;cc.lower())
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     resp =&lt;span&gt; requests.get(url)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; resp.content
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; show(text):
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(text,end=&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    sys.stdout.flush()
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; download_many(cc_list):
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; cc &lt;span&gt;in&lt;/span&gt;&lt;span&gt; sorted(cc_list):
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         image =&lt;span&gt; get_flag(cc)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        show(cc)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         save_flag(image,cc.lower()+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.gif&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; len(cc_list)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(download_many):
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     t0 =&lt;span&gt; time.time()
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     count =&lt;span&gt; download_many(POP20_CC)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     elapsed = time.time()-&lt;span&gt;t0
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n{} flags downloaded in {:.2f}s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(msg.format(count,elapsed))
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     main(download_many)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例子2：通过future方式实现，这里对上面的部分代码进行了复用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; concurrent &lt;span&gt;import&lt;/span&gt;&lt;span&gt; futures
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; flags &lt;span&gt;import&lt;/span&gt;&lt;span&gt; save_flag, get_flag, show, main
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; MAX_WORKERS = 20
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; download_one(cc):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     image =&lt;span&gt; get_flag(cc)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    show(cc)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     save_flag(image, cc.lower()+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.gif&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cc
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; download_many(cc_list):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     workers =&lt;span&gt; min(MAX_WORKERS,len(cc_list))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    with futures.ThreadPoolExecutor(workers) as executor:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         res =&lt;span&gt; executor.map(download_one, sorted(cc_list))
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; len(list(res))
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     main(download_many)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分别运行三次，两者的平均速度：13.67和1.59s，可以看到差别还是非常大的。&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;future&lt;/h2&gt;
&lt;p&gt;future是concurrent.futures模块和asyncio模块的重要组件&lt;br/&gt;从python3.4开始标准库中有两个名为Future的类：concurrent.futures.Future和asyncio.Future&lt;br/&gt;这两个类的作用相同：两个Future类的实例都表示可能完成或者尚未完成的延迟计算。与Twisted中的Deferred类、Tornado框架中的Future类的功能类似&lt;/p&gt;
&lt;p&gt;注意：&lt;span&gt;通常情况下自己不应该创建future，而是由并发框架(concurrent.futures或asyncio)实例化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;原因：future表示终将发生的事情，而确定某件事情会发生的唯一方式是执行的时间已经安排好，因此只有把某件事情交给concurrent.futures.Executor子类处理时，才会创建concurrent.futures.Future实例。&lt;br/&gt;如：Executor.submit()方法的参数是&lt;span&gt;一个可调用的对象&lt;/span&gt;，调用这个方法后会为传入的可调用对象排定时间，&lt;span&gt;并返回一个future&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;客户端代码不能应该改变future的状态，并发框架在future表示的延迟计算结束后会改变期物的状态，我们无法控制计算何时结束。&lt;/p&gt;
&lt;p&gt;这两种future都有.done()方法，这个方法不阻塞，返回值是布尔值，指明future链接的可调用对象是否已经执行。客户端代码通常不会询问future是否运行结束，而是会等待通知。因此两个Future类都有&lt;span&gt;.add_done_callback()方法，这个方法只有一个参数，类型是可调用的对象，future运行结束后会调用指定的可调用对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.result()方法是在两个Future类中的作用相同：返回可调用对象的结果，或者重新抛出执行可调用的对象时抛出的异常。但是如果future没有运行结束，result方法在两个Futrue类中的行为差别非常大。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;对concurrent.futures.Future实例来说，调用.result()方法会阻塞调用方所在的线程，直到有结果可返回，此时，result方法可以接收可选的timeout参数，如果在指定的时间内future没有运行完毕，会抛出TimeoutError异常。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;而asyncio.Future.result方法不支持设定超时时间，在获取future结果最好使用yield from结构，但是concurrent.futures.Future不能这样做&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不管是asyncio还是concurrent.futures.Future都会有几个函数是返回future，其他函数则是使用future,在最开始的例子中我们使用的Executor.map就是在使用future，返回值是一个迭代器，迭代器的__next__方法调用各个future的result方法，因此我们得到的是各个futrue的结果，而不是future本身&lt;/p&gt;
&lt;p&gt;关于future.as_completed函数的使用，这里我们用了两个循环，一个用于创建并排定future,另外一个用于获取future的结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; concurrent &lt;span&gt;import&lt;/span&gt;&lt;span&gt; futures
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; flags &lt;span&gt;import&lt;/span&gt;&lt;span&gt; save_flag, get_flag, show, main
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; MAX_WORKERS = 20
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; download_one(cc):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     image =&lt;span&gt; get_flag(cc)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    show(cc)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     save_flag(image, cc.lower()+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.gif&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cc
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; download_many(cc_list):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     cc_list = cc_list[:5&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     with futures.ThreadPoolExecutor(max_workers=3&lt;span&gt;) as executor:
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         to_do =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; cc &lt;span&gt;in&lt;/span&gt;&lt;span&gt; sorted(cc_list):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             future =&lt;span&gt; executor.submit(download_one,cc)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            to_do.append(future)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Secheduled for {}:{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(msg.format(cc,future))
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         results =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; future &lt;span&gt;in&lt;/span&gt;&lt;span&gt; futures.as_completed(to_do):
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             res =&lt;span&gt; future.result()
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}result:{!r}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(msg.format(future,res))
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            results.append(res)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; len(results)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     main(download_many)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/997599/201710/997599-20171016232748740-283326519.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：Python代码是无法控制GIL，标准库中所有执行阻塞型IO操作的函数，在等待操作系统返回结果时都会释放GIL.运行其他线程执行，也正是因为这样，Python线程可以在IO密集型应用中发挥作用&lt;/p&gt;
&lt;p&gt;以上都是concurrent.futures启动线程，下面通过它启动进程&lt;/p&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;concurrent.futures启动进程&lt;/h2&gt;
&lt;p&gt;concurrent.futures中的ProcessPoolExecutor类把工作分配给多个Python进程处理，因此，如果需要做CPU密集型处理，使用这个模块能绕开GIL，利用所有的CPU核心。&lt;br/&gt;其原理是一个ProcessPoolExecutor创建了N个独立的Python解释器，N是系统上面可用的CPU核数。&lt;br/&gt;使用方法和ThreadPoolExecutor方法一样&lt;/p&gt;

</description>
<pubDate>Mon, 16 Oct 2017 15:28:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/7679529.html</dc:identifier>
</item>
<item>
<title>编程思想与生活经验 - 与你在巅峰相会</title>
<link>http://www.cnblogs.com/bfwbfw/p/7679485.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bfwbfw/p/7679485.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1，内聚&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;程序=数据+操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       =数据结构+算法（PASCAL之父Nicklaus Wirth）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       =对象+消息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对象是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对象就是保管好自己的东西，做好自己的事情的程序模块--------这就是内聚&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，依赖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个对象往往需要跟其他对象打交道，既包括获取依赖于另一对象，也包括仰赖其他对象的行为，一旦发生便称为该对象依赖另一对象。只要有一个依赖另一个的现象发生，则这两者之间存在耦合，比如妈妈和婴儿。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3，耦合&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;耦合的程度就是耦合度，也就是双方依赖的程度，妈妈和婴儿之间是强耦合，而我们与快递小哥之间为弱耦合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4，依赖倒置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;高层模块不应该依赖底层模块，都依赖与抽象。抽象不应该依赖于细节，细节应该依赖抽象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;举一个例子：&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;假设你要买一个IPhone，卖IPhone的老板让你拿一头猪跟他换，可是你并没有养猪，你只会编程。所以你找到一位养猪户，说给他做一个养猪的APP来换他一头猪，他说换猪可以，但是得用一条金项链来换——所以这里就出现了一连串的对象依赖，从而造成了严重的耦合灾难。解决这个问题的最好的办法就是，买卖双发都依赖于抽象——也就是货币——来进行交换，这样一来耦合度就大为降低了。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;5，控制反转&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们要区分两个角色，server 跟 Client，也就是服务方和客户方。提供服务端的一方称为服务方，请求服务的一方称为客户方。&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;12.084103512015&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;当我们使用开发框架时，开发框架就是作为服务方，而我们自己编写的业务应用就是客户方。当Client调用server时，这个叫做一般的控制；而当server调用Client时，就是我们所说的控制反转，同时我们也将这个调用称为“回调”。控制反转跟依赖倒置都是一种编程思想，依赖倒置着眼于调用的形式，而控制反转则着眼于程序流程的控制权。一般来说，程序的控制权属于server，而一旦控制权交到Client，就叫控制反转。比如你去下馆子，你是Client餐馆是server。你点菜，餐馆负责做菜，程序流程的控制权属于server；而如果你去自助餐厅，程序流程的控制权就转到Client了，也就是控制反转。&lt;/span&gt;&lt;/p&gt;

&lt;span&gt;总结出开发框架与类库的区别：使用开发框架时，框架掌握程序流程的控制权，而使用类库时，则是应用程序掌握程序流程的控制权。或者说，使用框架时，程序的主循环位于框架中，而使用类库时，程序的主循环位于应用程序之中。框架会回调应用程序，而类库则不会回调应用程序。&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;6，依赖注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A对象依赖于B对象，等价于A对象内部存在对B对象的“调用”，而前提是A对象内部拿到了B对象的引用。B对象的引用的来源无非有以下几种：A对象内部创建（无论是作为字段还是作为临时变量）、构造器注入、属性注入、方法注入。后面三种方式统称为“依赖注入”。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;

</description>
<pubDate>Mon, 16 Oct 2017 15:26:00 +0000</pubDate>
<dc:creator>与你在巅峰相会</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bfwbfw/p/7679485.html</dc:identifier>
</item>
</channel>
</rss>