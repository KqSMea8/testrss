<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>k8s 如何 Failover？- 每天5分钟玩转 Docker 容器技术（127） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8400717.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8400717.html</guid>
<description>&lt;p&gt;&lt;span&gt;上一节我们有 3 个 nginx 副本分别运行在 k8s-node1 和 k8s-node2 上。现在模拟 k8s-node2 故障，关闭该节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201802/775365-20180201192212125-1481977296.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;等待一段时间，Kubernetes 会检查到 k8s-node2 不可用，将 k8s-node2 上的 Pod 标记为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Unknown&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 状态，并在 k8s-node1 上新创建两个 Pod，维持总副本数为 3。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201802/775365-20180201192234468-688999447.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当 k8s-node2 恢复后，&lt;/span&gt;&lt;code&gt;&lt;span&gt;Unknown&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 Pod 会被删除，不过已经运行的 Pod 不会重新调度回 k8s-node2。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201802/775365-20180201192248640-1331998582.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;删除 &lt;/span&gt;&lt;code&gt;&lt;span&gt;nginx-deployment&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/775365/201802/775365-20180201192300484-1454719170.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一节我们学习如何控制 Pod 运行的位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;http://www.cnblogs.com/Users/wanglei/百度云同步盘/容器/images/480.png?v=1510821977521&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;strong&gt;书籍：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.《每天5分钟玩转Docker容器技术》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot; target=&quot;_blank&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 01 Feb 2018 23:21:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8400717.html</dc:identifier>
</item>
<item>
<title>我的2017——求职篇（四） - codingHeart</title>
<link>http://www.cnblogs.com/codingHeart/p/8380390.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codingHeart/p/8380390.html</guid>
<description>&lt;p&gt;　　这一次的面试邀请是在qq上沟通到的，他们公司的一个开发人员加的我qq，居然昵称就是.net，我特意看了下qq等级，应该是个私人号（可以看出来差不多是个对事情上心的人）。我跟他大致的聊了下，看了下他发的职位信息，感觉跟我的简历写的不是太合，于是发消息过去跟他再确认了下，“我没有精通mvc，linq，就了解过（跑过两小demo）而已，也只有一年的工作经验，您确定没找错人？”，他说，“有两个岗，发给我看的是个中高级岗，也有初级岗。”，中高级岗都是写的8k，初级岗那不得6k朝下了。于是我立马就接过话来，“我可以面中高级岗，有一个月的缓冲期就行。”，现在想想，自己也是单纯，什么都不会，就直接要面中高级岗，对方又不是傻子。&lt;/p&gt;
&lt;p&gt;　　我当时说话如此有底气的原因 一方面是前几次面试让我觉得这些公司的东西基本都不会太难，api+百度基本就够解决问题；另一方面是对自己的学习能力还是有一定的了解的，刚到 之前那家公司的的时候三周 就直接把js，sql，asp.net 全部捡起来做出一个三层的表格记录增删改查 加 分页的练习，顺便还把jq学了。（这个现在看起来小儿科，但对一个没入门的小白来说还是有点磨人的）。当然，我还是有点基础的，毕竟大学学的计算机。但做网站什么的真是张白纸。js就知道alert（“hello”）很好玩；html，css两年前做过一次课堂作业，放图片的表格，知道table，div，img；sql上个概论那本书（可能稍微好点）；asp.net我就知道有gridview，button几个控件的存在（后面发现我用控件 让我删了 得用html和ajax重新弄一个异步 不能刷新页面的出来）。&lt;/p&gt;
&lt;p&gt;　　可以看出来，就这么一两个星期，人的心态会自然而然的转变，底气足了不少。&lt;/p&gt;
&lt;p&gt;　　继续回到面试的事情上，对方表示 得看我的表现，具体到时候可以和他们经理谈，感觉也还算是对我挺客气了。接着 就发地址过来了，地图上搜了下路线，在南山区，当时想着应该是个很有科技气息的地方，地图上看着那边很多互联网公司，而且腾讯总部也在那边呢。当时还想着要顺路去 腾讯大厦 看看，所以觉得虽然不太合适 也还是可以去试试看的。&lt;/p&gt;
&lt;p&gt;　　第二天早上，天气不太好，下着雨，如果赶过去 因为只有网鞋的那种运动鞋，肯定是全湿，当时又脚上有伤口，其实都想打电话过去取消的，想着言而无信不太好，而且有腾讯大厦看呢，还是硬着头皮去了。&lt;/p&gt;
&lt;p&gt;　　到了的时候，这个南山区可不是我想象的样子，特别是地址上的那栋楼，看着有些破旧，而且周围快一圈的居民楼都是比它高的，隐隐约约的感觉像是作坊。但来都来了，自然是上去了。各种后门侧门也是让我找半天。问了个门卫，才找到上去的电梯。电梯里各种烟头，广告纸都有也就不多说了，等上去了，这也不是周末啊，居然都看不到几个人的，有些屋子都是堆的办公桌之类的杂物 。再朝里面走几步，可能是天气不好吧，阴暗的不行，还带些潮湿感。&lt;/p&gt;
&lt;p&gt;　　等我找到目标办公室，站在门口，隐约还有点厕所里的味道。一扇玻璃们，我从外边隔着‘灰色’玻璃朝里面看了眼，我再次拿出手机确认下具体位置。不得不惊叹，这员工办公的地方简直比我之前在广州450租来的单间都小啊，中间还放了几个莫名其妙的“大家伙”（不知道什么机器还是堆的柜子）占着地。我迟迟不敢进去，在外边来来回回的路过看了几遍，当然他们也没人理我。其实有想直接走了算了，面过了 我基本也不会考虑留下的，直接去看腾讯大厦得了吧。当时也不知道在想啥，居然最后还是进去了，主动敲了几下门，手有点凉，玻璃门敲得真费力啊（人多有些不好意思开口说话的）。没有前台，他们就望着我，直到我说昨天约了面试，才有个人站起来让我去旁边的办公室等他们经理。&lt;/p&gt;
&lt;p&gt;　　右转把门推开后，第一时间给人一种舒了口闷气的感觉，毕竟，这扇门外是7，8个人加各种办公器材挤在一块的寸步难行，门里边却看着有几分敞亮，虽然总觉得哪里不对劲，但也还算可以，迎面是书架靠着墙，右边有沙发，一个长桌，桌上有一套泡茶的器皿，左边是经理的办公区域，背靠书架，我走到办公桌 旁边坐下，杂乱摆放的烟灰缸，手表，笔，纸都还没来得及收拾好，侧边窗外也还有几分光景。这一切都不禁让我开始想着这个经理是个什么样的人。&lt;/p&gt;
&lt;p&gt;　　没等我想清楚，有人已经推门进来了。。。。&lt;/p&gt;
&lt;p&gt;　　可能是我世面见得不够吧，这个镜头感觉已经深深的留在了我的脑海里。&lt;/p&gt;
&lt;p&gt;　　大金链子 大金表，一手臂的纹身 肥头肥脑。嘴里叼了根烟 就朝我气势汹汹的走过来了。。。我都快懵逼了！！说实话，从小就老实巴交的我，很怕这种带“大哥气息”的人。但看着后面书架上也有几十本的书，想着读了书的人应该也粗鲁不到哪儿去，倒是缓解了下自己局促的情绪。&lt;/p&gt;
&lt;p&gt;　　几步就走到他座位上然后顺势一躺，转椅左右摇晃了几下才停稳，倒是有几分大哥的派头啊，嘴里的烟拿下后， 蘸烟灰的间隙让我自我介绍下，我把简历给他了，然后大致的按照简历的信息说了下情况，感觉他也只是走个流程，随便听听，注意力不在我这边的，或者是说他能一心两用。我说完了十多秒钟，他才把眼神从简历转向我这边看了一眼。接着就又开始问我会不会asp.net mvc，也不是很想说太多话，毕竟一张口，就要吸 朝我这边缭绕过来的烟雾，感觉有点不爽，你说是个妹子，我还能接受是吧（一不下心就yy了下。。）。我直接就回答说不会了，后面问了些什么现在也不是记得太清楚，就记得还问了个easyui里的一个方法吧，我特么当时连easyui是什么都不知道，之前公司项目里除了jq，根本全靠手撸好么，我还记得当时看了几个小时我那小师傅写的 那个固定（冻结）部分列的表格的原生js，头都要炸了也没太看出什么大的眉目。其实免得差不多的时候 心里也有点底儿，asp.net mvc不会，easyui不会，公司肯定是看不上的。所以他问我期望薪资多少的时候，我直接说了句：你看着给了吧（反正不是一路人）。显然，在这位大哥面前，我有这个胆子想，没这个胆子说出来啊。还是很畏畏缩缩的回应了下：“我具体也不清楚公司会让我做些什么样的事儿，这得看你们开了”。他会心的笑了下，我也不太明白什么意思，可能是：“就你这样的水平，还是算了吧。”&lt;/p&gt;
&lt;p&gt;　　让我回去等通知了。。。。。。。。不得不说 人还是有点惆怅的，毕竟被自己看不起的人看不起，也别是一番滋味。&lt;/p&gt;
&lt;p&gt;　　也不想多呆，我立马就起身准备离开了，带上他们公司那扇玻璃门的时候，我停了几秒钟，不禁也想回过头看看。如果说上次的回身是带着对美好时光的依恋，那这次，应该更多是对“所托非人”的感叹吧。这一群人大不了我太多，也算是正当风华吧。我就不信他没有进过经理的办公室，没有在回到座位的时候感受到心里的不爽。我倒不是说经理的办公室比员工办公的地方敞亮有什么问题，但放到这种情况下确实是引人深思的。我们都知道自己卖命在做什么，但好像都不太清楚自己在为谁卖命。毕竟我们大部分人的脑回路只能转到 给钱就好，谁给好像真的不重要。我也很想叫醒他们，就像此时此刻很想自己被叫醒一样，可谁又知道他们是不是 像此时的我一样 在装睡呢。&lt;/p&gt;
&lt;p&gt;　　我见过一个三端通吃能实现很多easyui控件的人工作三四年月薪6、7k的，也听过easyui控件都用不太利索的人出来没多久可以开口就拿到9、10k的。&lt;/p&gt;
&lt;p&gt;　　我也说不清 谁厉害。但我知道 谁惨。&lt;/p&gt;
&lt;p&gt;　　回去的时候出了太阳，心情却相当压抑，也就忘了去腾讯大厦看上一眼。&lt;/p&gt;
&lt;p&gt;　　待续。。。&lt;/p&gt;
</description>
<pubDate>Thu, 01 Feb 2018 15:57:00 +0000</pubDate>
<dc:creator>codingHeart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codingHeart/p/8380390.html</dc:identifier>
</item>
<item>
<title>Python简单爬虫Requests - HaoYu''</title>
<link>http://www.cnblogs.com/HaoYu-StudyNote/p/8401834.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HaoYu-StudyNote/p/8401834.html</guid>
<description>&lt;ol&gt;&lt;li&gt;首先添加库&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;          附配环境变量：安装环境变量 cmd==&amp;gt; 输入指令： &lt;span class=&quot;pln&quot;&gt;path&lt;span class=&quot;pun&quot;&gt;=%&lt;span class=&quot;pln&quot;&gt;path&lt;span class=&quot;pun&quot;&gt;%;&lt;span class=&quot;pln&quot;&gt;C&lt;span class=&quot;pun&quot;&gt;:&lt;span class=&quot;pln&quot;&gt;\Python（Python安装路径） 回车&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;          python2.7版本可能没有pip的话可以先到www.python.org/pypi/ez_setup 下载 ez_setup 0.9用 文件路径 输入指令：ez_setup.py 安装Script到Python目录下&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;          在https://pypi.python.org/pypi/setuptools#windows-simplified下载，然后在DOS中 运行 python ez_setup.py,(脚本会自动判断python脚本)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;          接下来装pip  在&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;https://pypi.python.org/pypi/pip#downloads 下载pip 然后在DOS中 运行python setup.py install #安装pip&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;          &lt;span&gt;注意：配置好环境变量很重要。（可以在计算机右键高级设置中设置系统PATH，记得用python安装目录，和下一层Script的目录，添加一个后面记得加分号）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;          用DOS进入Python/Script目录（如果Python在C盘直接cd目录，如果在其他盘先选盘（例如：f:）再用cd ../Python.Script目录）&lt;/p&gt;
&lt;p&gt;           运行命令  pip install requests   #下载安装Requests库&lt;/p&gt;
&lt;p&gt;                           pip install lxml &lt;/p&gt;
&lt;p&gt;          Requests和lxml库安完以后，现在把pycharm的interpreter设置成System Interpreter(添加路径选你的Python安装路径)&lt;/p&gt;
&lt;p&gt;           &lt;span&gt;好了，到这里我们的准备工作就做完了，开始最简单的Requests爬虫实战吧~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;# -*- coding: utf-8 -*-   防止中文乱码&lt;br/&gt;&lt;span&gt;                import requests  #引用requests库&lt;br/&gt;&lt;span&gt;                from lxml &lt;span&gt;import etree   #引用lxml下的etree&lt;br/&gt;                header ={&lt;span&gt;'User-Agent':&lt;span&gt;'Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:58.0) Gecko/20100101 Firefox/58.0'}   #先定义一个User-Agent 模仿浏览器访问网站&lt;br/&gt;                response = requests.get(&lt;span&gt;'https://www.douban.com/'&lt;span&gt;,&lt;span&gt;headers=header)   #这里的网址是目标爬虫网址，后面修改headers模仿浏览器访问&lt;span&gt;&lt;br/&gt;&lt;span&gt;                #print(response.content) #获取源代码&lt;br/&gt;                selector = etree.HTML(response.content)&lt;br/&gt;                 images = selector.xpath(&lt;span&gt;&quot;//div[@class='photo_wrap']/a[@class='photolst_photo']/img/@src&quot;)     # 用xpath获取指定HTML标签下面的元素，获取属性值用@属性名&lt;br/&gt;&lt;span&gt;                 for image &lt;span&gt;in images:&lt;br/&gt;                      name = image.split(&lt;span&gt;'/')[-&lt;span&gt;1]&lt;span&gt;&lt;br/&gt;                      &lt;span&gt;print(name)&lt;br/&gt;                      &lt;span&gt;with &lt;span&gt;open(&lt;span&gt;'E:\NewIMG&lt;span&gt;\\&lt;span&gt;'+name&lt;span&gt;, &lt;span&gt;'wb') &lt;span&gt;as file:    #with open(name,mode,encoding) as file: #&lt;span&gt;注意这里会有一个缩进  &lt;span&gt;name 表示路径（包括文件名），mode 分三种 只读，写入，追加，encoding：一般为utf-8或者gbk　　&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;                             file.write(requests.get(image&lt;span&gt;, &lt;span&gt;headers=header).content)      #file表示我们对文件的命名　　&lt;br/&gt;                             file.close()     #关闭文件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 01 Feb 2018 15:47:00 +0000</pubDate>
<dc:creator>HaoYu&amp;#39;&amp;#39;</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HaoYu-StudyNote/p/8401834.html</dc:identifier>
</item>
<item>
<title>关于oracle视图小结 - -北方-</title>
<link>http://www.cnblogs.com/lkyang/p/8401823.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lkyang/p/8401823.html</guid>
<description>&lt;p&gt;关于oracle的视图小记:&lt;br/&gt;一.&lt;br/&gt;视图:就是对SQL语句的封装,使用起来更方便.不易出错&lt;/p&gt;
&lt;p&gt;优点:&lt;br/&gt;　　1.简化数据操作:视图可以简化用户处理数据的方式&lt;br/&gt;　　2.着重于特定数据:不必要的数据或敏感的数据可以&lt;br/&gt;　　　　不出现在视图中(完成数据的筛选显示)&lt;br/&gt;　　3.安全性高:视图提供了一个简单而有有效的安全机制,可以定制不同用户&lt;br/&gt;　　　　对数据的访问权限&lt;br/&gt;　　4.向后兼容性:视图使用户在表的架构更改时为表创建向后兼容接口&lt;br/&gt;二视图分两种:&lt;br/&gt;　　注意:&lt;br/&gt;　　　　1.在创建与使用带检查约束是的视图时,&lt;br/&gt;　　　　　　with check option与with read only 不能共存&lt;br/&gt;　　　　2.with check option 作用范围包括(单个值,枚举,范围)&lt;br/&gt;　　　　3.with check option与with read only区别:&lt;br/&gt;　　　　　　with check option :只约束当前视图的条件字段不能被改变&lt;br/&gt;　　　　　　with read only :约束的所有字段都不能被改变&lt;br/&gt;　　第一种:简单的非物化的视图:&lt;br/&gt;　　　　就是纯粹的对SQL语句进行封装&lt;br/&gt;　　创建与修改视图的语法:&lt;br/&gt;　　　　　　create [or replace] [force] view view_name as SQL语句&lt;br/&gt;　　　　　　[with check option]&lt;br/&gt;　　　　　　[with read only]&lt;br/&gt;　　　　注;[]内是可选项&lt;br/&gt;　　　　1.or replace: 有就同名的视图,就替换(把原先的删除在新建一个),没有就直接新建一个视图&lt;br/&gt;　　　　2.force: 不管基表是否存在ORACLE都会自动创建该视图(为视图提供了向后兼容&lt;br/&gt;　　　　　　的接口,可以在没有某表时也能成功创建视图)&lt;br/&gt;　　　　3.subquery: 一条完整的select 语句,可以在该语句中定义别名&lt;br/&gt;　　　　4.with check option: 插入或修改的数据必须满足视图定义的约束&lt;br/&gt;　　　　5.with read only: 该视图上不能进行任何DML操作&lt;br/&gt;　　　　注:&lt;br/&gt;　　　　　　1&amp;gt;.4.5不能共存&lt;br/&gt;　　　　　　2&amp;gt;.:其实视图的修改就是将原来的视图删除再重新建一个名字一样的&lt;br/&gt;　　　　　　　　新视图&lt;br/&gt;　　　　删除视图:&lt;br/&gt;　　　　　　drop view 视图名;&lt;br/&gt;　　第二种:物化视图&lt;br/&gt;　　　　在内存中有存储空间,当效率要比去查表要快,相当于在内存中新建了一&lt;br/&gt;　　　　个表,是牺牲了内存去换取效率&lt;/p&gt;&lt;p&gt;　　　　创建物化视图的语法:&lt;br/&gt;　　　　　　create meterialized view 视图名字&lt;br/&gt;　　　　　　[build immediate | build deferred]&lt;br/&gt;　　　　　　refresh [fast|complete|force]&lt;br/&gt;　　　　　　[&lt;br/&gt;　　　　　　　　on [commit | demand] |start with (start_time) next (next_time)&lt;br/&gt;　　　　　　]&lt;br/&gt;　　　　　　sql语句&lt;/p&gt;&lt;p&gt;　　　　1.build immediate:是在创建视图的时候就生成数据&lt;br/&gt;　　　　2.build deferred:则在创建时不生成数据,以后根据需要在 生成数据&lt;br/&gt;　　　　　　1.2默认是1&lt;br/&gt;　　　　3.refresh&lt;br/&gt;　　　　　　1.fast:刷新采用增量刷新,只刷新上次以后进行的修改&lt;br/&gt;　　　　　　2.complete:对整个视图进行完全的刷新&lt;br/&gt;　　　　　　3.force:oracle会自动判断是用fast还是complete&lt;br/&gt;　　　　　　1.2.3默认3&lt;br/&gt;　　　　4.on [commit | demand]:刷新模式:&lt;br/&gt;　　　　　　demand:只需要手动刷新物化视图(默认)&lt;br/&gt;　　　　　　commit :在基表发生改变时自动刷新&lt;br/&gt;　　　　　　start with (start_time) next (next_time):&lt;br/&gt;　　　　　　　　start_time:开始刷新的时间&lt;br/&gt;　　　　　　　　next_time:每次刷新时间的间隔&lt;br/&gt;　　　　删除物化视图:&lt;br/&gt;　　　　　　drop meterialized view 物化视图名字&lt;br/&gt;　　物化视图的分类:&lt;br/&gt;　　　　1.创建时生成数据&lt;br/&gt;　　　　2.创建时不生成数据&lt;br/&gt;　　　　3.自动刷新数据&lt;br/&gt;　　　　4.手动刷新数据&lt;br/&gt;　　　　5.增量刷新&lt;br/&gt;　　　　注意:创建增量刷新视图前:要先为视图中用到的表创建物化视图日志&lt;br/&gt;　　　　例:&lt;br/&gt;　　　　--创建增量刷新的物化视图&lt;br/&gt;　　　　--首先要创建物化视图日志&lt;br/&gt;　　　　　　create materialized view log on dept with rowid&lt;br/&gt;　　　　　　create materialized view log on emp with rowid&lt;br/&gt;　　　　--创建物化视图&lt;br/&gt;　　　　　　create materialized view view_name&lt;br/&gt;　　　　　　refresh&lt;br/&gt;　　　　　　on commit&lt;br/&gt;　　　　　　as&lt;br/&gt;　　　　　　select e.* from emp e,dept d where d.deptno=e.deptno&lt;/p&gt;&lt;p&gt;　　　　物化视图日志中的字段含义:&lt;br/&gt;　　　　　　snaptime$$:用于表示刷新时间&lt;br/&gt;　　　　　　dmltype$$:用于表示DML操作类型,&lt;br/&gt;　　　　　　　　　　　I表示insert ,D表示delete&lt;br/&gt;　　　　　　　　　　　U表示update&lt;br/&gt;　　　　　　old_new$$:用于表示这个值是新值还是旧值&lt;br/&gt;　　　　　　　　　　　　N(ew)表示新值,O(ld)表示旧值&lt;br/&gt;　　　　　　　　　　　　U表示update操作&lt;br/&gt;　　　　　　change_vector$$:表示修改矢量,用来表示被修改的是哪个或哪几个字段,此列是raw类型&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　其实oracle采用的方式就是用每个bit位去映射一个列插入操作显示为:fe,&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　删除显示为:oo 更新操作根据更新的字段的位置而显示不同的值.&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　当我们手动刷新物化视图后,物化视图日志被清空,物化图更新&lt;/p&gt;
</description>
<pubDate>Thu, 01 Feb 2018 15:44:00 +0000</pubDate>
<dc:creator>-北方-</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lkyang/p/8401823.html</dc:identifier>
</item>
<item>
<title>Paramiko模块 - ﹏亦°洛轩づ</title>
<link>http://www.cnblogs.com/charles8866/p/8401788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charles8866/p/8401788.html</guid>
<description>&lt;p&gt;python 的paramiko 模块，改模块是基于ssh用于连接远程服务器并执行相关操作&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;SSHClient&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用于连接远程服务器并执行基本命令：&lt;/p&gt;
&lt;p&gt;基于用户名密码的连接：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; paramiko
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建SSH对象&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; ssh =&lt;span&gt; paramiko.SSHClient()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 允许连接不在know_hosts文件中的主机&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 连接服务器&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; ssh.connect(hostname=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=22, username=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, password=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行命令&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; stdin, stdout, stderr = ssh.exec_command(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取命令结果&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;标准输出只有在正确的情况下才会有输出，错误的情况下没有&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; res,err =&lt;span&gt; stdout.read(),stderr.read()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; result = res &lt;span&gt;if&lt;/span&gt; res &lt;span&gt;else&lt;/span&gt;&lt;span&gt; err
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result.decode())
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭连接&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; ssh.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果遇到这样的问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180201141845656-297490913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())&lt;/strong&gt;&lt;/span&gt;这个函数就能够能好的解决&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在linux中直接通过ssh去登录远程，会出现如下的问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180201142509343-1570168661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入yes之后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180201142622406-966138291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入密码就可以登录。&lt;/p&gt;
&lt;p&gt;在linux中如果有一个文件 /root/.ssh/known_hosts &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180201142328468-433660454.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 里面就有一个10.0.0.41的相关rsa信息，如果这个文件里有这个安全的签名认证，就可以直接输入密码连接，否则就需要自己做判断是否加入known_hosts&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())&lt;/strong&gt;就是解决了这个问题，自动添加认证&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这里，不能执行“top”命令，只能让他执行那种一次性执行完毕的命令&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; SFtpClient&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　ssh远程传文件命令：&lt;/p&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;    #r即使是目录也会传，p是会把文件的权限也传过去&lt;br/&gt;scp -rp -P52113 文件名 root@10.0.0.41:/tmp/&lt;br/&gt;查看文件内容，目录内容可以用：more ****&lt;/em&gt;
&lt;/pre&gt;
&lt;p&gt;用于连接远程服务器并执行上传和下载&lt;/p&gt;
&lt;p&gt;基于用户名密码上传下载&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; paramiko

transport &lt;/span&gt;= paramiko.Transport((&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.5.9&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 22&lt;span&gt;))
transport.connect(username&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, password=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

sftp &lt;/span&gt;=&lt;span&gt; paramiko.SFTPClient.from_transport(transport)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将location.py 上传至服务器 /tmp/test.py&lt;/span&gt;
sftp.put(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;笔记&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/tmp/test_from_win&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将remove_path 下载到本地 local_path&lt;/span&gt;
sftp.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/root/test.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fromlinux.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

transport.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; put()方法是上传文件，get()方法是下载文件&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面两种方式都是用了明文用户名密码，这个是很不安全的。所以可以用密钥去连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ssh密钥-----RSA非对称密钥验证&lt;/p&gt;
&lt;p&gt;公钥（public key）：是给别人的&lt;/p&gt;
&lt;p&gt;私钥（private key）&lt;/p&gt;
&lt;p&gt;10.0.0.31 ----------》10.0.0.41   这样就可以无密码连接&lt;/p&gt;
&lt;p&gt;私钥　　　　　　　　公钥&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在linux中：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a. linux中生成公钥私钥对：#&lt;span&gt;ssh-keygen&lt;/span&gt;(默认保存在/root/.ssh/id_rsa)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1307091/201802/1307091-20180201152114968-559765586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;私钥在id_rsa中，公钥在id_rsa.pub中&lt;/p&gt;
&lt;p&gt;b.将本地的公钥添加到远程机器的authorized_keys中，从而实现SSH无密码登录。&lt;span&gt;ssh-copy-id &quot;-p22 root@192.168.5.9&quot;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;c.利用ssh远程无密码登录：&lt;span&gt;ssh root@192.168.5.9 -p22&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在windows中：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; paramiko

private_key &lt;/span&gt;= paramiko.RSAKey.from_private_key_file(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id_rsa9.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建SSH对象&lt;/span&gt;
ssh =&lt;span&gt; paramiko.SSHClient()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 允许连接不在know_hosts文件中的主机&lt;/span&gt;
&lt;span&gt;ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 连接服务器&lt;/span&gt;
ssh.connect(hostname=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.5.12&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=22, username=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xiaoming&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, pkey=&lt;span&gt;private_key)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行命令&lt;/span&gt;
stdin, stdout, stderr = ssh.exec_command(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;df&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取命令结果&lt;/span&gt;
result =&lt;span&gt; stdout.read()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result.decode())
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭连接&lt;/span&gt;
ssh.close()
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
使用rz/sz命令可以将linux生成的公钥上传到windows上：sz ~/.ssh/id_rsa&lt;br/&gt;安装rz/sz命令：yum install lrzsz&lt;br/&gt;然后将得到的id_rsa放到项目当中就可以使用了&lt;/pre&gt;

</description>
<pubDate>Thu, 01 Feb 2018 15:32:00 +0000</pubDate>
<dc:creator>﹏亦&amp;#176;洛轩づ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/charles8866/p/8401788.html</dc:identifier>
</item>
<item>
<title>JavaScript基础：BOM的常见内置方法和内置对象 - 生命壹号</title>
<link>http://www.cnblogs.com/smyhvae/p/8401662.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smyhvae/p/8401662.html</guid>
<description>&lt;blockquote readability=&quot;5.375&quot;&gt;
&lt;p&gt;本文最初发表于&lt;a href=&quot;http://www.cnblogs.com/smyhvae/p/8401662.html&quot;&gt;博客园&lt;/a&gt;，并在&lt;a href=&quot;https://github.com/smyhvae/Web&quot;&gt;GitHub&lt;/a&gt;上持续更新&lt;strong&gt;前端的系列文章&lt;/strong&gt;。欢迎在GitHub上关注我，一起入门和进阶前端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;以下是正文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;bom的介绍&quot;&gt;BOM的介绍&lt;/h2&gt;
&lt;h3 id=&quot;javascript的组成&quot;&gt;JavaScript的组成&lt;/h3&gt;
&lt;p&gt;JavaScript基础分为三个部分：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;DOM&lt;/strong&gt;：文档对象模型，操作&lt;strong&gt;网页上的元素&lt;/strong&gt;的API。比如让盒子移动、变色、轮播图等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;BOM&lt;/strong&gt;：浏览器对象模型，操作&lt;strong&gt;浏览器部分功能&lt;/strong&gt;的API。比如让浏览器自动滚动。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;什么是bom&quot;&gt;什么是BOM&lt;/h3&gt;
&lt;p&gt;BOM：Browser Object Model，浏览器对象模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BOM的结构图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180201_2052.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图也可以看出：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;window对象是BOM的顶层(核心)对象&lt;/strong&gt;，所有对象都是通过它延伸出来的，也可以称为window的子对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;DOM越是BOM的一部分。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;window对象：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;window对象是JavaScript中的顶级对象&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;全局变量、自定义函数也是window对象的属性和方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;window对象下的属性和方法调用时，可以省略window。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面讲一下 &lt;strong&gt;BOM 的常见内置方法和内置对象&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;弹出系统对话框&quot;&gt;弹出系统对话框&lt;/h2&gt;
&lt;p&gt;比如说，&lt;code&gt;alert(1)&lt;/code&gt;是&lt;code&gt;window.alert(1)&lt;/code&gt;的简写，因为它是window的子方法。&lt;/p&gt;
&lt;p&gt;系统对话框有三种：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;at&quot;&gt;alert&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;co&quot;&gt;//不同浏览器中的外观是不一样的&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;confirm&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//兼容不好&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;prompt&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//不推荐使用&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;打开窗口关闭窗口&quot;&gt;打开窗口、关闭窗口&lt;/h2&gt;
&lt;p&gt;1、打开窗口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    window.open(url,target,param)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;参数解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;url：要打开的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;target：新窗口的位置。可以是：&lt;code&gt;_blank&lt;/code&gt; 、&lt;code&gt;_self&lt;/code&gt;、 &lt;code&gt;_parent&lt;/code&gt; 父框架。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;param：新窗口的一些设置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;返回值：新窗口的句柄。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;param&lt;/strong&gt;这个参数，可以填各种各样的参数（），比如：&lt;/p&gt;
&lt;ul readability=&quot;12.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;name：新窗口的名称，可以为空&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;featurse：属性控制字符串，在此控制窗口的各种属性，属性之间以逗号隔开。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;fullscreen= { yes/no/1/0 } 是否全屏，默认no&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;channelmode= { yes/no/1/0 } 是否显示频道栏，默认no&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;toolbar= { yes/no/1/0 } 是否显示工具条，默认no&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;location= { yes/no/1/0 } 是否显示地址栏，默认no。（有的浏览器不一定支持）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;directories = { yes/no/1/0 } 是否显示转向按钮，默认no&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;status= { yes/no/1/0 } 是否显示窗口状态条，默认no&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;menubar= { yes/no/1/0 } 是否显示菜单，默认no&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;scrollbars= { yes/no/1/0 } 是否显示滚动条，默认yes&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;resizable= { yes/no/1/0 } 是否窗口可调整大小，默认no&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;width=number 窗口宽度（像素单位）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;height=number 窗口高度（像素单位）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;top=number 窗口离屏幕顶部距离（像素单位）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;left=number 窗口离屏幕左边距离（像素单位）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;各个参数之间用逗号隔开就行，但我们最好是把它们统一放到json里。&lt;/p&gt;
&lt;p&gt;2、关闭窗口：window.close()&lt;/p&gt;
&lt;p&gt;（1）和（2）的代码举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;javascript:;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;点击我打开一个新的页面&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;javascript:;&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;点击我关闭本页面&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;//新窗口 = window.open(地址,是否开新窗口,新窗口的各种参数);&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementsByTagName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;a&quot;&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; a2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementsByTagName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;a&quot;&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;a1&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onclick&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//举例1： window.open(&quot;http://www.jd.com&quot;,&quot;_blank&quot;);&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; json &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;helloworld&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;fullscreen&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;no&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;location&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;no&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;width&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;100px&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;height&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;100px&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;top&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;100px&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;left&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;100px&quot;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;http://www.baidu.com&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;_blank&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; json)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//举例2&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;//关闭本页面&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;a2&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onclick&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;close&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;/body&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、新窗口相关：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;新窗口.moveTo(5,5)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新窗口.moveBy()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新窗口.resizeTo()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;window.resizeBy()&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; newWin &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;open&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;demo.html&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;_blank&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; json)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;newWin&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;moveTo&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;500&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;500&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;location对象&quot;&gt;location对象&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;window.location&lt;/code&gt;可以简写成location。location相当于浏览器地址栏，可以将url解析成独立的片段。&lt;/p&gt;
&lt;h3 id=&quot;location对象的属性&quot;&gt;location对象的属性&lt;/h3&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;href&lt;/strong&gt;：跳转&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;hash 返回url中#后面的内容，包含#&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;host 主机名，包括端口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hostname 主机名&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;pathname url中的路径部分&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;protocol 协议 一般是http、https&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;search 查询字符串&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;location.href属性举例&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例1：&lt;/strong&gt;点击盒子时，进行跳转。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;smyhvae&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; div &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;document&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getElementsByTagName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;div&quot;&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;div&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;onclick&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;location&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;href&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;http://www.baidu.com&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;//点击div时，跳转到指定链接&lt;/span&gt;
 &lt;span class=&quot;co&quot;&gt;//     window.open(&quot;http://www.baidu.com&quot;,&quot;_blank&quot;);  //方式二&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;&amp;lt;/body&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;举例2：5秒后自动跳转到百度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有时候，当我们访问一个不存在的网页时，会提示5秒后自动跳转到指定页面，此时就可以用到location。举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;at&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;location&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;href&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;http://www.baidu.com&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;5000&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;/script&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;location对象的方法&quot;&gt;location对象的方法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;location.assign()：改变浏览器地址栏的地址，并记录到历史中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设置location.href 就会调用assign()。一般使用location.href 进行页面之间的跳转。&lt;/p&gt;
&lt;h2 id=&quot;navigator对象&quot;&gt;navigator对象&lt;/h2&gt;
&lt;p&gt;window.navigator 的一些属性可以获取客户端的一些信息。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;navigator&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;userAgent&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;navigator&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;platform&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180201_2140.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;history对象&quot;&gt;history对象&lt;/h2&gt;
&lt;p&gt;1、历史记录管理&lt;/p&gt;
&lt;p&gt;2、后退：&lt;/p&gt;
&lt;p&gt;3、前进：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;history.forward()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;history.go(1)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用的不多。因为浏览器中已经自带了这些功能的按钮：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/20180201_2146.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;我的公众号&quot;&gt;我的公众号&lt;/h2&gt;
&lt;p&gt;想学习&lt;span&gt;&lt;strong&gt;代码之外的软技能&lt;/strong&gt;&lt;/span&gt;？不妨关注我的微信公众号：&lt;strong&gt;生命团队&lt;/strong&gt;（id：&lt;code&gt;vitateam&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;扫一扫，你将发现另一个全新的世界，而这将是一场美丽的意外：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.smyhvae.com/2016040102.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 01 Feb 2018 14:56:00 +0000</pubDate>
<dc:creator>生命壹号</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smyhvae/p/8401662.html</dc:identifier>
</item>
<item>
<title>TCP/IP详解 卷1 第二十章 TCP的成块数据流 - xcywt</title>
<link>http://www.cnblogs.com/xcywt/p/8401523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xcywt/p/8401523.html</guid>
<description>&lt;p&gt;1.&lt;span&gt;停止等待协议：&lt;/span&gt;是tcp保证传输可靠的重要途径，“停止等待”就是指发送完一个分组就停止发送，等待对方确认之后，才能继续发送下一个分组&lt;/p&gt;
&lt;p&gt;停止等待协议的优点是简单，缺点就是信道的利用率太低，一次只发送一个消息，信道大部分时间都是空闲的。&lt;/p&gt;

&lt;p&gt;2：&lt;span&gt;超时重传有一下三种情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）  分组丢失：发送方发出来了，接收方没有收到&lt;/p&gt;
&lt;p&gt;2）  确认丢失：接收方收到了，也发送了确认分组，但是确认分组丢失了&lt;/p&gt;
&lt;p&gt;3）  确认延时：确认分组没有丢失，由于传输太慢，发送方在规定时间内没有收到接收方发的确认分组。&lt;/p&gt;

&lt;p&gt;3.下面两个协议就是解决信道效率太低和增大吞吐量，以及流量控制：&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;连续ARQ协议：&lt;/span&gt;它是指发送方维护着一个窗口，这个窗口中不止有一个分组，而是有好几个分组。窗口的大小是由接收方返回的win值决定的。所以窗口大小 是动态变化的。只要在窗口中的分组都可以被发送，这就使得TCP一次不是只发送一个分组了。从而大大提高了信道利用率。并且它采用累积确认的方式，对于按序到达的最后一个分组进行确认。&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;滑动窗口协议&lt;/span&gt;：因为窗口不断往前走。该协议允许发送方在停止并等待确认前发送多个数据分组。不需要每发送一个就分组就停下来等待确认。所以可以加速数据的传输，还可以控制流量。&lt;/p&gt;
&lt;p&gt;3）累积确认：如果发送方发送了5个分组，接收端只收到了1 2 4 5 ，没有收到3，那么我的确认信息会是说明我期望下一个收到的组是第三个，此时发送方会将3 4 5都重发一遍。&lt;/p&gt;

&lt;h2&gt;20.1 引言&lt;/h2&gt;
&lt;p&gt;本章我们将介绍TCP所使用的被称为滑动窗口协议的另一种形式的流量控制方法。&lt;/p&gt;
&lt;p&gt;该协议允许发送方在停止并等待确认前可以连续发送多个分组。&lt;/p&gt;

&lt;h2&gt;20.2 正常数据流&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;经受时延的确认：&lt;/strong&gt;&lt;/span&gt;假设 A -&amp;gt; B，B要对A的数据进行确认，当有一个分组来的时候，B不立即确认，而是启动一个定时器（RFC规定要小于500ms，很多都是200ms），等待200ms，如果在这期间A又来了其他的数据就可以一起确认了 。或者A要发数据给B了，就顺带把之前的也确认了。&lt;/p&gt;
&lt;p&gt;比如下面这样，对1025的确认放到了跟2049一起。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/822287/201802/822287-20180201221411187-75629837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用滑动窗口协议，接收方不必确认每一个收到的分组。在TCP中，ACK是累积的—它们表示连接方已经正确收到了一直到确认号减1的所有字节。比如上面的2049，就表示我收到了2048个字节。&lt;/p&gt;

&lt;h2&gt;20.3 滑动窗口协议&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/822287/201802/822287-20180201221433500-225660853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如上面的例子，应该是右边发送数据给左边。左边进行确认。窗口往右移动。&lt;/p&gt;
&lt;p&gt;接收方通告的窗口称为提出的窗口（offered window）：上面的4 – 9&lt;/p&gt;
&lt;p&gt;说明接收方已经收到了3字节的数据，且通告窗口大小为6.&lt;/p&gt;
&lt;p&gt;当接收方确认数据后，这个滑动窗口不断的向右移动。下面用三个术语来描述窗口左右边沿的运动：&lt;/p&gt;
&lt;p&gt;1）  称窗口&lt;strong&gt;左边沿向右边沿靠近为&lt;span&gt;窗口合拢&lt;/span&gt;&lt;/strong&gt;。这种现象发生在数据被发送和确认时。&lt;/p&gt;
&lt;p&gt;2）  当窗口&lt;strong&gt;右边沿向右移动时将允许发送更多的数据，我们称之为&lt;span&gt;窗口张开&lt;/span&gt;&lt;/strong&gt;。这种现象发生在另一端的接收进程读取已经确认的数据，并释放了TCP的接收缓存时。&lt;span&gt;（就是接收方读取了缓冲区里面的数据的时候）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）&lt;/strong&gt; 当&lt;strong&gt;右边沿向左移动，称为&lt;span&gt;窗口收缩&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/822287/201802/822287-20180201221444640-461372373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果左边沿到达右边沿，则称其为一个零窗口。此时发送方不能发送任何数据。&lt;/p&gt;

&lt;h2&gt;20.4 窗口大小&lt;/h2&gt;
&lt;p&gt;由接收方提供的窗口的大小通常可以由接收进程控制，这将影响TCP的性能。&lt;/p&gt;
&lt;p&gt;插口API允许进程设置发送和接收缓存的大小。接收缓存的大小是该连接上所能通告的最大窗口大小。有一些应用程序通过修改插口缓存大小来增加性能。&lt;/p&gt;

&lt;h2&gt;20.5 PUSH标志&lt;/h2&gt;
&lt;p&gt;发送方使用该标志通知接收方将所收到的数据全部提交给接收进程。（这里的数据包括与PUSH一起传送的数据，以及接收方TCP已经为接收进程收到的其他数据）&lt;/p&gt;

&lt;p&gt;假设一个客户端发送数据给服务器，设置了PUSH标志：&lt;/p&gt;
&lt;p&gt;对客户端来说：客户进程通知TCP在向服务器发送一个报文段时不要因等待额外数据而使已提交数据在缓冲中滞留。&lt;/p&gt;
&lt;p&gt;对服务器来说：TCP收到一个设置了PUSH标志的报文时，它需要立即将这些数据递交给服务器进程而不能等待判断是否还会有额外的数据到达。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;目前大多数的API没有向应用程序提供通知其TCP设置PUSH的方法，很多实现程序任务PUSH已经过时了。一个好的TCP实现能够自动设置PUSH标志。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果待发送数据将清空发送缓存，则大多数的源于伯克利的实现能够自动设置PUSH标志。&lt;/p&gt;

&lt;h2&gt;20.6 慢启动&lt;/h2&gt;
&lt;p&gt;“慢启动”slow start算法：通过观察到新分组进入网络的速率应该与另一端返回确认的速率相同而进行工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;拥塞窗口（congestion window）：&lt;/span&gt;&lt;/strong&gt;当与另一个网络的主机建立TCP连接时，拥塞窗口被初始化为1个报文段（即另一端通告的报文段大小）。每收到一个ack，拥塞窗口就增加一个报文段（慢启动以报文段大小为单位进行增加）。&lt;/p&gt;
&lt;p&gt;发送方取拥塞窗口与通告窗口中的最小值作为发送上限。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;拥塞窗口是发送方用的流量控制，而通告窗口则的接收方用的流量控制。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最开始为1，确认一个后变成了2，就可以发送两个报文段了，当这两个被确认以后拥塞窗口就变成了4。这是一种&lt;strong&gt;&lt;span&gt;指数增加的关系&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当到达互联网的极限时，中间路由器开始丢弃分组，这就通知发送方它的拥塞窗口开的过大。&lt;/p&gt;

&lt;h2&gt;20.7 成块数据的吞吐量&lt;/h2&gt;
&lt;p&gt;通常发送一个分组的时间取决于两个因素：&lt;/p&gt;
&lt;p&gt;1）  传播延时：由光的有限速率、传输设备的等待时间引起（这个一般是固定的）&lt;/p&gt;
&lt;p&gt;2）  媒体速率的发送延时：媒体每秒可传输的比特数。（取决与 分组的大小。）&lt;/p&gt;
&lt;p&gt;假设A发数据给B，拥塞窗口慢慢增大，到最后，发送方和接收方的之间的管道被填满。此时无论拥塞窗口和通过窗口是多少，它都不能再容纳更多的数据。每当接收方在某一时间单位从网络上移去一个报文段，发送方就再发送一个报文段到网络上。但是不管有多少报文段填充了这个管道，返回路径上总是有相同数目的ack，这就是连接的理想稳定状态。&lt;/p&gt;

&lt;h3&gt;20.7.1 带宽时延乘积&lt;/h3&gt;
&lt;p&gt;如何设置窗口大小呢。下面是计算公式： &lt;span&gt;带宽 * RTT&lt;/span&gt; ，括号里面是单位。&lt;/p&gt;
&lt;p&gt;c a p a c i t y (bit) = b a n d w i d t h (b/s) × ro u n d-trip time ( s )&lt;/p&gt;
&lt;p&gt;一般称之为带宽时延乘积。这个值依赖于网络速度和两端的RTT。&lt;/p&gt;
&lt;p&gt;比如：一条穿越美国（RTT约为60ms）的T1电话线路（1544000 b/s）的带宽时延乘积为11580字节。&lt;strong&gt;&lt;span&gt;1544000 * 0.06 / 8&lt;/span&gt;&lt;/strong&gt; 就是字节了。&lt;/p&gt;
&lt;p&gt; 所以增加RTT和增加带宽都可以使管道容量增加。&lt;/p&gt;

&lt;h3&gt;20.7.2 拥塞&lt;/h3&gt;
&lt;p&gt;发送拥塞的两种情况：&lt;/p&gt;
&lt;p&gt;1）  数据到达一个大的管道并向一个较小的管道发送时便会发送拥塞。&lt;/p&gt;
&lt;p&gt;2）  当多个输入流到达一个路由器，而路由器的输出流小于这些输入流的总和时也会发送拥塞&lt;/p&gt;

&lt;h2&gt;20.8 紧急方式&lt;/h2&gt;
&lt;p&gt;urgent mode：它使一端可以告诉另一端有些具有某种方式的“紧急数据”已经放置在普通的数据流中。另一端被通知这个紧急数据已被放置在普通数据流中，由接收方决定如何处理。&lt;/p&gt;

&lt;p&gt;如何发送紧急数据：设置TCP首部中的两个字段来发出紧急数据。URG置为1，并且从一个16bit的紧急指针被置为一个正的偏移量，该偏移量必须与TCP首部中的序号字段相加，以便得出紧急数据的最后一个字节的序号。&lt;/p&gt;

&lt;p&gt;TCP本身对紧急数据知之甚少，没有办法指明紧急数据从数据流的何处开始。TCP通过连接传送的唯一信息就是紧急方式已经开始（URG置为1）和指向紧急数据最后一个字节的指针。其他的事情留给应用程序去处理。&lt;/p&gt;

</description>
<pubDate>Thu, 01 Feb 2018 14:18:00 +0000</pubDate>
<dc:creator>xcywt</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xcywt/p/8401523.html</dc:identifier>
</item>
<item>
<title>Asp.net core 2.0.1 Razor 的使用学习笔记（一） - 沉默种子</title>
<link>http://www.cnblogs.com/chonghanyu/p/8400214.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chonghanyu/p/8400214.html</guid>
<description>&lt;p&gt;环境：vs2017 版本：15.5.6&lt;/p&gt;
&lt;p&gt;这里说明下， Razor页面模式跟mvc出现了严重的不同。正如微软官方说的一样“Razor 页面是 ASP.NET Core MVC 的一个新功能，它可以使基于页面的编码方式更简单高效。”&lt;/p&gt;
&lt;p&gt;但就代码说没有什么不同几乎完全一样，但是存放的位置却有了根本的区别。个人研究分析的结果是：Razor页面模式其实是把mvc中的控制器化整为零了，即原来控制器中的操作代码被分布放到了各个页面的.cshtml.cs文件中了。这样一来由原来mvc中文件按类型分类变成了按功能分类，这样的好处就是每个页面形成了模块化，这个页面涉及的数据都在这里，便于维护，不用控制器、模型、视图来回切换了，给我的感觉多少有些像原来的web窗体的页面结构，当然化整为零后每个页面的操作不用全部去读取控制器，可能在性能有提升。&lt;/p&gt;
&lt;p&gt;同时，这种变化使代码功能单一，易于维护，更不易出现错误，所以还是值得一学的。 &lt;/p&gt;
&lt;p&gt;一、新建项目&lt;/p&gt;
&lt;p&gt;1、文件》新建》项目》Visual c#》.NET Core》ASP.NET Core Web应用程序（“.NET Framework” 4.6.1）&lt;/p&gt;
&lt;p&gt;2、依次选择“.NET Core”》“ASP.NET Core 2.0”，然后选择“Web 应用程序”（身份验证类型：个人用户账户）。&lt;/p&gt;
&lt;p&gt;二、修改数据库连接。引自“张不水”兄的研究成果。&lt;/p&gt;
&lt;p&gt;1、相对路径：&lt;/p&gt;
&lt;p&gt;修改appsettings.json文件中的&quot;ConnectionStrings&quot;（第3行）&lt;/p&gt;
&lt;p&gt;&quot;DefaultConnection&quot;: &quot;Data Source=(localdb)\\mssqllocaldb;AttachDbFilename=%CONTENTROOTPATH%\\App_Data\\aspnet123.mdf;Integrated Security=True;Connect Timeout=30;MultipleActiveResultSets=true”&lt;/p&gt;
&lt;p&gt;需注意的是：AttachDbFilename=%CONTENTROOTPATH%\\App_Data\\aspnet123.mdf;&lt;/p&gt;
&lt;p&gt;使用 ContentRootPath 是将文件放置在项目目录下而不是wwwroot目录下，这样更安全。&lt;/p&gt;
&lt;p&gt;ContentRootPath 用于包含应用程序文件。&lt;br/&gt;WebRootPath 用于包含Web服务性的内容文件。&lt;br/&gt;实际使用区别如下：&lt;/p&gt;
&lt;p&gt;ContentRoot: C:\MyApp\&lt;br/&gt;WebRoot: C:\MyApp\wwwroot\&lt;/p&gt;
&lt;p&gt;2、修改Startup.cs&lt;/p&gt;
&lt;p&gt;修改后的代码：&lt;/p&gt;
&lt;p&gt;①修改Startup方法为如下&lt;/p&gt;
&lt;pre&gt;
public Startup(IConfiguration configuration,IHostingEnvironment env)
        {
            Configuration = configuration;&lt;br/&gt;//新添加
            _env = env;
        }
&lt;/pre&gt;
&lt;p&gt;②添加public IHostingEnvironment _env { get; }&lt;/p&gt;
&lt;p&gt;③修改ConfigureServices方法&lt;/p&gt;
&lt;p&gt;注销掉原有的services.AddDbContext&lt;/p&gt;
&lt;p&gt;//添加修改（）声明变量conn并做相应处理&lt;br/&gt;string conn = Configuration.GetConnectionString(&quot;DefaultConnection&quot;);&lt;br/&gt;if (conn.Contains(&quot;%CONTENTROOTPATH%&quot;))&lt;br/&gt;{&lt;br/&gt;conn = conn.Replace(&quot;%CONTENTROOTPATH%&quot;, _env.ContentRootPath);&lt;br/&gt;}&lt;br/&gt;//修改默认的连接服务为conn&lt;br/&gt;services.AddDbContext&amp;lt;ApplicationDbContext&amp;gt;(options =&amp;gt;&lt;br/&gt;options.UseSqlServer(conn));&lt;/p&gt;
&lt;p&gt;修改完成后的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c9db4f3f-f465-4671-b3a7-5cf4fd6fa273')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_c9db4f3f-f465-4671-b3a7-5cf4fd6fa273&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c9db4f3f-f465-4671-b3a7-5cf4fd6fa273&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c9db4f3f-f465-4671-b3a7-5cf4fd6fa273',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c9db4f3f-f465-4671-b3a7-5cf4fd6fa273&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration, IHostingEnvironment env)
        {
            Configuration &lt;/span&gt;=&lt;span&gt; configuration;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新添加&lt;/span&gt;
            _env =&lt;span&gt; env;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新添加&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; IHostingEnvironment _env { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;services.AddDbContext&amp;lt;ApplicationDbContext&amp;gt;(options =&amp;gt;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    options.UseSqlServer(Configuration.GetConnectionString(&quot;DefaultConnection&quot;)));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加修改（）声明变量conn并做相应处理&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; conn = Configuration.GetConnectionString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DefaultConnection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (conn.Contains(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%CONTENTROOTPATH%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            {
                conn &lt;/span&gt;= conn.Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%CONTENTROOTPATH%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, _env.ContentRootPath);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改默认的连接服务为conn&lt;/span&gt;
            services.AddDbContext&amp;lt;ApplicationDbContext&amp;gt;(options =&amp;gt;&lt;span&gt;
                      options.UseSqlServer(conn));


            services.AddIdentity&lt;/span&gt;&amp;lt;ApplicationUser, IdentityRole&amp;gt;&lt;span&gt;()
                .AddEntityFrameworkStores&lt;/span&gt;&amp;lt;ApplicationDbContext&amp;gt;&lt;span&gt;()
                .AddDefaultTokenProviders();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add application services.&lt;/span&gt;
            services.AddTransient&amp;lt;IEmailSender, EmailSender&amp;gt;&lt;span&gt;();

            services.AddMvc();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
                app.UseBrowserLink();
                app.UseDatabaseErrorPage();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                app.UseExceptionHandler(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Home/Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            app.UseStaticFiles();

            app.UseAuthentication();

            app.UseMvc(routes &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                routes.MapRoute(
                    name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller=Home}/{action=Index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;3、手动在项目中添加“App_data”文件夹，并复制粘贴一个标准的内容为空的.mdf文件。&lt;/p&gt;
&lt;p&gt;为方便大家学习我这里为大家提供了&lt;a title=&quot;示例数据库&quot; href=&quot;http://files.cnblogs.com/files/chonghanyu/App_Data.rar&quot; target=&quot;_blank&quot;&gt;示例数据库&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Thu, 01 Feb 2018 14:16:00 +0000</pubDate>
<dc:creator>沉默种子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chonghanyu/p/8400214.html</dc:identifier>
</item>
<item>
<title>[搬运]  .NET Core 2.1中改进的堆栈信息 - 张很水</title>
<link>http://www.cnblogs.com/chenug/p/8401356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenug/p/8401356.html</guid>
<description>&lt;blockquote readability=&quot;1.6666666666667&quot;&gt;
&lt;p&gt;原文 : &lt;a href=&quot;https://www.ageofascent.com/2018/01/26/stack-trace-for-exceptions-in-dotnet-core-2.1/&quot;&gt;Stacktrace improvements in .NET Core 2.1&lt;/a&gt;&lt;br/&gt;作者 : &lt;a href=&quot;https://www.ageofascent.com/authors/ben-adams/&quot;&gt;Ben Adams&lt;/a&gt;&lt;br/&gt;译者 : &lt;a href=&quot;https://www.jianshu.com/u/910143584bd2&quot;&gt;张很水&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;. NET Core 2.1 现在具有可读的异步堆栈信息！使得异步、迭代器和字典 ( key not found ) 中的堆栈更容易追踪！&lt;/p&gt;
&lt;p&gt;这个大胆的主张意味着什么？&lt;/p&gt;
&lt;p&gt;要知道，为了确定调用 异步 和 迭代器方法的实际重载，（这在以前）从堆栈信息中跟踪几乎是不可能的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.Collections.Generic.KeyNotFoundException: The given key '0' was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Program.Sequence(Int32 start)+MoveNext()
   at Program.Sequence(Int32 start, Int32 end)+MoveNext()
   at Program.MethodAsync()
   at Program.MethodAsync(Int32 v0)
   at Program.MethodAsync(Int32 v0, Int32 v1)
   at Program.MethodAsync(Int32 v0, Int32 v1, Int32 v2)
   at Program.MethodAsync(Int32 v0, Int32 v1, Int32 v2, Int32 v3)
   at Program.Main(String[] args)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;问题-使堆栈信息可读&quot;&gt;问题: “使堆栈信息可读”&lt;/h3&gt;
&lt;p&gt;David Kean(&lt;a href=&quot;https://twitter.com/davkean&quot;&gt;@davkean&lt;/a&gt;) 于 2017 年 10 月 13 日在&lt;a href=&quot;https://github.com/dotnet/corefx/issues/24627&quot;&gt;dotnet/corefx#24627&lt;/a&gt; 提出 &lt;strong&gt;使堆栈信息可读&lt;/strong&gt; 的问题:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如今在 任务 (Task)、异步 (async) 和 等待 (await) 中普遍存在堆栈难以阅读的现象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于在 .NET 中输出异步的可阅读堆栈信息已经梦魂萦绕了5年...&lt;/p&gt;
&lt;p&gt;我直到 2017 年 10 月才意识到这个问题，好在 .NET Core 现在是完全开源的，所以我可以改变它。&lt;/p&gt;
&lt;p&gt;作为参考，请参阅文章底部的代码，它将会输出如下的异常堆栈：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.
   at System.ThrowHelper.ThrowKeyNotFoundException()
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Program.&amp;lt;Sequence&amp;gt;d__8.MoveNext()
   at Program.&amp;lt;Sequence&amp;gt;d__7.MoveNext()
   at Program.&amp;lt;MethodAsync&amp;gt;d__6.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Program.&amp;lt;MethodAsync&amp;gt;d__5.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Program.&amp;lt;MethodAsync&amp;gt;d__4.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Program.&amp;lt;MethodAsync&amp;gt;d__3.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Program.&amp;lt;MethodAsync&amp;gt;d__2.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
   at Program.&amp;lt;Main&amp;gt;d__1.MoveNext()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（为简洁起见，删除了行号，如 &lt;code&gt;in C:\Work\Exceptions\Program.cs:line 14&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;有时甚至可见更详细的胶水信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw() 
   at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
   at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) 
   at System.Runtime.CompilerServices.TaskAwaiter.ValidateEnd(Task task) 
   at System.Runtime.CompilerServices.TaskAwaiter.GetResult() 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟踪堆栈的一般用途是确定在源代码中发生错误的位置以及对应的路径。&lt;/p&gt;
&lt;p&gt;然而，现如今我们无法避免异步堆栈，同时还要面对很多无用的噪声（干扰）。&lt;/p&gt;
&lt;h3 id=&quot;pr-隐藏请求中的异常堆栈帧&quot;&gt;PR: “隐藏请求中的异常堆栈帧 ”&lt;/h3&gt;
&lt;p&gt;堆栈信息通常是从抛出异常的地方直接输出的。&lt;/p&gt;
&lt;p&gt;当异步函数抛出异常时，它会执行一些额外的步骤来确保响应，并且在延续执行（既定方法）之前会进行清理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3913171-add6cd5bdb8443ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;在异步函数抛出异常&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当这些额外的步骤被添加到调用堆栈中时，它们不会对我们确定堆栈信息有任何帮助，因为它们实际上是在出现异常 &lt;strong&gt;之后&lt;/strong&gt; 执行。&lt;/p&gt;
&lt;p&gt;所以它们是非常嘈杂和重复的，对于确定代码在哪里出现异常上并没有任何额外的价值。&lt;/p&gt;
&lt;p&gt;实际产生的调用堆栈和输出的不一致:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3913171-be349d0f420576a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;输出堆栈前&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在删除这些异常堆栈帧后（&lt;code&gt;隐藏请求中的异常堆栈帧&lt;/code&gt; &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14652&quot;&gt;dotnet/coreclr#14652&lt;/a&gt; ），跟踪堆栈开始变得平易近人：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Program.&amp;lt;Sequence&amp;gt;d__7.MoveNext()
   at Program.&amp;lt;Sequence&amp;gt;d__6.MoveNext()
   at Program.&amp;lt;MethodAsync&amp;gt;d__5.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Program.&amp;lt;MethodAsync&amp;gt;d__4.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Program.&amp;lt;MethodAsync&amp;gt;d__3.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Program.&amp;lt;MethodAsync&amp;gt;d__2.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Program.&amp;lt;MethodAsync&amp;gt;d__1.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
   at Program.&amp;lt;Main&amp;gt;d__0.MoveNext()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且输出的调用堆栈与实际的调用堆栈一致: &lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3913171-247414d00de0a170.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;一致的堆栈信息&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;pr-删除异步的-edi-边界&quot;&gt;PR: “删除异步的 Edi 边界”&lt;/h3&gt;
&lt;p&gt;异步中的异常使用 &lt;strong&gt;ExceptionDispatchInfo&lt;/strong&gt; 类传播，这意味着着在每个连接点都会有这样的边界信息：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--- End of stack trace from previous location where exception was thrown ---&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这只是让你知道两部分调用堆栈已经合并，并且有个过渡。&lt;/p&gt;
&lt;p&gt;它如此频繁地出现在异步中，增加了很多噪音，并没有任何附加价值。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;删除异步的 Edi 边界&lt;/code&gt; &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/15781&quot;&gt;dotnet/coreclr#15781&lt;/a&gt; 后 &lt;strong&gt;所有的&lt;/strong&gt; 堆栈信息变得有价值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Program.&amp;lt;Sequence&amp;gt;d__7.MoveNext()
   at Program.&amp;lt;Sequence&amp;gt;d__6.MoveNext()
   at Program.&amp;lt;MethodAsync&amp;gt;d__5.MoveNext()
   at Program.&amp;lt;MethodAsync&amp;gt;d__4.MoveNext()
   at Program.&amp;lt;MethodAsync&amp;gt;d__3.MoveNext()
   at Program.&amp;lt;MethodAsync&amp;gt;d__2.MoveNext()
   at Program.&amp;lt;MethodAsync&amp;gt;d__1.MoveNext()
   at Program.&amp;lt;Main&amp;gt;d__0.MoveNext()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;pr-处理迭代器和异步方法中的堆栈&quot;&gt;PR: “处理迭代器和异步方法中的堆栈”&lt;/h3&gt;
&lt;p&gt;在上一节中，堆栈已经是干净了，但是要确定是什么情况，还是很困难的一件事。&lt;/p&gt;
&lt;p&gt;堆栈中包含着由 C# 编译器创建的异步状态机的基础方法签名，而不仅仅是（你的）源代码产生的。&lt;/p&gt;
&lt;p&gt;你可以确定方法的名称，但是如果不深入挖掘，则无法确定所调用的实际重载。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;处理迭代器和异步方法中的堆栈&lt;/code&gt; &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/14655&quot;&gt;dotnet/coreclr#14655&lt;/a&gt; 之后，堆栈更接近原始来源：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Program.Sequence(Int32 start)+MoveNext()
   at Program.Sequence(Int32 start, Int32 end)+MoveNext()
   at Program.MethodAsync()
   at Program.MethodAsync(Int32 v0)
   at Program.MethodAsync(Int32 v0, Int32 v1)
   at Program.MethodAsync(Int32 v0, Int32 v1, Int32 v2)
   at Program.MethodAsync(Int32 v0, Int32 v1, Int32 v2, Int32 v3)
   at Program.Main(String[] args)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;pr-实现-keynotfoundexception-的堆栈追踪&quot;&gt;PR: “实现 KeyNotFoundException 的堆栈追踪”&lt;/h3&gt;
&lt;p&gt;因为有额外的奖励，我着手实现抛出 “ KeyNotFoundException ” 的堆栈追踪。&lt;/p&gt;
&lt;p&gt;Anirudh Agnihotry (&lt;a href=&quot;https://github.com/dotnet/coreclr/pull/15201&quot;&gt;@Anipik&lt;/a&gt;) 提出了 &lt;code&gt;实现 KeyNotFoundException 的堆栈追踪&lt;/code&gt;&lt;a href=&quot;https://github.com/dotnet/coreclr/pull/15201&quot;&gt;dotnet/coreclr#15201&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这意味着这个异常现在要告诉你哪个 key 找不到的信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.Collections.Generic.KeyNotFoundException: The given key '0' was not present in the dictionary.
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at Program.Sequence(Int32 start)+MoveNext()
   at Program.Sequence(Int32 start, Int32 end)+MoveNext()
   at Program.MethodAsync()
   at Program.MethodAsync(Int32 v0)
   at Program.MethodAsync(Int32 v0, Int32 v1)
   at Program.MethodAsync(Int32 v0, Int32 v1, Int32 v2)
   at Program.MethodAsync(Int32 v0, Int32 v1, Int32 v2, Int32 v3)
   at Program.Main(String[] args)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;支持的运行时以及相关进展&quot;&gt;支持的运行时以及相关进展&lt;/h3&gt;
&lt;p&gt;这些改进将在稍晚的时间发布到 Mono 上，并在下一个阶段发布。但是如果您使用的是较早的运行时版本 (.NET Core 1.0 - 2.0; .NET Framework 或 Mono) 想要获得一样的效果，需要使用 &lt;a href=&quot;https://github.com/benaadams/Ben.Demystifier&quot;&gt;Ben.Demystifier&lt;/a&gt; 提供的Nuget 包，并且在你的异常中使用 &lt;code&gt;.Demystify()&lt;/code&gt; 的方法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;catch (Exception e)
{
    Console.WriteLine(e.Demystify());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些改进将会产生与 C＃相得映彰的输出信息，最令人高兴的还是全都会被内置！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.
   at TValue System.Collections.Generic.Dictionary&amp;lt;TKey, TValue&amp;gt;.get_Item(TKey key)
   at IEnumerable&amp;lt;int&amp;gt; Program.Sequence(int start)+MoveNext()
   at IEnumerable&amp;lt;int&amp;gt; Program.Sequence(int start, int end)+MoveNext()
   at async Task&amp;lt;int&amp;gt; Program.MethodAsync()
   at async Task&amp;lt;int&amp;gt; Program.MethodAsync(int v0)
   at async Task&amp;lt;int&amp;gt; Program.MethodAsync(int v0, int v1)
   at async Task&amp;lt;int&amp;gt; Program.MethodAsync(int v0, int v1, int v2)
   at async Task&amp;lt;int&amp;gt; Program.MethodAsync(int v0, int v1, int v2, int v3)
   at async Task Program.Main(string[] args)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;.NET Core 2.1 将成为 .NET Core 的最佳版本，原因说不完，这只是变得更美好的一小步...&lt;/p&gt;
&lt;h4 id=&quot;上面提到的触发异常的代码及对应的堆栈信息&quot;&gt;上面提到的触发异常的代码及对应的堆栈信息&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;class Program
{
    static Dictionary&amp;lt;int, int&amp;gt; _dict = new Dictionary&amp;lt;int, int&amp;gt;();

    static async Task Main(string[] args)
    {
        try
        {
            var value = await MethodAsync(1, 2, 3, 4);
            Console.WriteLine(value);
        }
        catch (Exception e)
        {
            Console.WriteLine(e);
        }
    }

    static async Task&amp;lt;int&amp;gt; MethodAsync(int v0, int v1, int v2, int v3)
        =&amp;gt; await MethodAsync(v0, v1, v2);

    static async Task&amp;lt;int&amp;gt; MethodAsync(int v0, int v1, int v2)
        =&amp;gt; await MethodAsync(v0, v1);

    static async Task&amp;lt;int&amp;gt; MethodAsync(int v0, int v1)
        =&amp;gt; await MethodAsync(v0);

    static async Task&amp;lt;int&amp;gt; MethodAsync(int v0)
        =&amp;gt; await MethodAsync();

    static async Task&amp;lt;int&amp;gt; MethodAsync()
    {
        await Task.Delay(1000);

        int value = 0;
        foreach (var i in Sequence(0, 5))
        {
            value += i;
        }

        return value;
    }

    static IEnumerable&amp;lt;int&amp;gt; Sequence(int start, int end)
    {
        for (var i = start; i &amp;lt;= end; i++)
        {
            foreach (var item in Sequence(i))
            {
                yield return item;
            }
        }
    }

    static IEnumerable&amp;lt;int&amp;gt; Sequence(int start)
    {
        var end = start + 10;
        for (var i = start; i &amp;lt;= end; i++)
        {
            _dict[i] = _dict[i] + 1; // Throws exception
            yield return i;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 01 Feb 2018 13:24:00 +0000</pubDate>
<dc:creator>张很水</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenug/p/8401356.html</dc:identifier>
</item>
<item>
<title>正则表达式（轻松入门级） - MS-LY</title>
<link>http://www.cnblogs.com/MaShuai666/p/8401348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MaShuai666/p/8401348.html</guid>
<description>&lt;p&gt;前言：正则表达式又称为火星文，因为视觉上让人感觉很复杂。本文将会详细介绍正则表达式，初学者只要认真阅读过，定会有收获。&lt;/p&gt;
&lt;p&gt;1、正则的概念&lt;/p&gt;
&lt;p&gt;　　正则表达式（regular expression）是一个描述字符规则的对象。可以用来检查一个字符串是否含有某个子字符串，将匹配的子字符串替换或者从某个字符串中取出符合某个条件的子串等。&lt;/p&gt;
&lt;p&gt;　　为什么要用正则：前端往往有大量的表达数据校验工作，采用正则表达式会使得数据校验的工作量大大减轻。常用效果（邮箱、手机号、身份证号等等）。&lt;/p&gt;
&lt;p&gt;2、创建方式&lt;/p&gt;
&lt;p&gt;　　第一种方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过构造函数的方式&lt;/span&gt;
　　&lt;span&gt;var&lt;/span&gt; oReg = &lt;span&gt;new&lt;/span&gt; RegExp('study', 'i');
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　第二种方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过语法糖（简写）的形式&lt;/span&gt;
 　&lt;span&gt;var&lt;/span&gt; oReg = /study/i;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修饰符：&lt;/p&gt;
&lt;p&gt;　　i ：表示忽略大小写。&lt;/p&gt;
&lt;p&gt;　　g：表示全局匹配，查找所有匹配而非在找到第一个匹配后停止。&lt;/p&gt;
&lt;p&gt;　　m：多行匹配。&lt;/p&gt;
&lt;p&gt;3、正则对象方法&lt;/p&gt;
&lt;p&gt;　　test：检索字符串中指定的值。返回true或false。&lt;/p&gt;
&lt;p&gt;　　exec：用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果，如果未找到匹配，则返回值为null。&lt;/p&gt;
&lt;p&gt;　　下面我们来个举个列子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　//&lt;/span&gt;&lt;span&gt; 首先我来看test&lt;/span&gt;&lt;span&gt;
　　//&lt;/span&gt;&lt;span&gt;我们要在字符串str中找出符合Reg的规则的子字符串，符合则返回true，不符合则返回false&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; str = 'Good good study, Day day up! Good good study'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg1= /good/&lt;span&gt;ig;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg2= /goood/&lt;span&gt;ig;
    console.log(Reg1.test(str));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
    console.log(Reg2.test(str));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接下来我们再来看 exec&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果，如果未找到匹配，则返回值为null&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; str = 'Good good study, Day day up! Good good study'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg= /good/&lt;span&gt;ig;
    console.log(Reg.exec(str));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;Good&quot;, index: 0, input: &quot;Good good study, Day day up! Good good study&quot;]&lt;/span&gt;
    console.log(Reg.exec(str));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;good&quot;, index: 5, input: &quot;Good good study, Day day up! Good good study&quot;]&lt;/span&gt;
    console.log(Reg.exec(str));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;Good&quot;, index: 29, input: &quot;Good good study, Day day up! Good good study&quot;]&lt;/span&gt;
    console.log(Reg.exec(str));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;good&quot;, index: 34, input: &quot;Good good study, Day day up! Good good study&quot;]&lt;/span&gt;
    console.log(Reg.exec(str));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注：如果没有指定g修饰符，那么每次匹配都是从头开始匹配，如果指定g修饰符以后，下次匹配则从上次匹配的结束位置开始匹配。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4、字符串函数&lt;/p&gt;
&lt;p&gt;　　search：检索与正则表达式相匹配的值，返回字符串中第一个与正则表达式相匹配的子串的起始位置，如果没有找到则返回-1。&lt;/p&gt;
&lt;p&gt;　　match ：找到一个或多个正则表达式的匹配。&lt;/p&gt;
&lt;p&gt;　　replace：替换与正则表达式匹配的子串。&lt;/p&gt;
&lt;p&gt;　　split      ：把字符串分割为字符串数组。&lt;/p&gt;
&lt;p&gt;　　单看概念不容易理解，看看下面的小实列就一目了然&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　&lt;br/&gt;　　　var&lt;/span&gt; str = 'Good good study, Day day up! Good good study'&lt;span&gt;;
     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg= /study/&lt;span&gt;ig;
     console.log(str.search(Reg));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;
     console.log(str.match(Reg));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;study&quot;, &quot;study&quot;]&lt;/span&gt;
     console.log(str.replace(Reg,'aaaa'));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Good good aaaa, Day day up! Good good aaaa&lt;/span&gt;
     console.log(str.split(Reg));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;Good good &quot;, &quot;, Day day up! Good good &quot;, &quot;&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、正则表达式构成&lt;/p&gt;
&lt;p&gt;　　正则表达式是由普通字符（列如字符a到z）以及特殊字符（称为元字符）组成的文字模式。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。&lt;/p&gt;
&lt;p&gt;　　①元字符---限定符：&lt;/p&gt;
&lt;p&gt;　　*：匹配前面的子表达式零次或多次。&lt;/p&gt;
&lt;p&gt;　　+：匹配前面的子表达式一次或多次。&lt;/p&gt;
&lt;p&gt;　　？：匹配前面的子表达式零次或一次。&lt;/p&gt;
&lt;p&gt;　　{n}：匹配确定n次。&lt;/p&gt;
&lt;p&gt;　　{n,}：至少匹配n次。&lt;/p&gt;
&lt;p&gt;　　{n,m}：最少匹配n次且最多匹配m次。&lt;/p&gt;
&lt;p&gt;　　实列如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; str ='gd god good goood gooood'&lt;span&gt;;

     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg1 =/go*d/ig; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;*：匹配前面的子表达式零次或多次&lt;/span&gt;
     console.log(str.match(Reg1));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;gd&quot;, &quot;god&quot;, &quot;good&quot;, &quot;goood&quot;, &quot;gooood&quot;]&lt;/span&gt;


     &lt;span&gt;var&lt;/span&gt; Reg2 =/go+d/ig; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;+：匹配前面的子表达式一次或多次&lt;/span&gt;
     console.log(str.match(Reg2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;god&quot;, &quot;good&quot;, &quot;goood&quot;, &quot;gooood&quot;]&lt;/span&gt;


     &lt;span&gt;var&lt;/span&gt; Reg3 =/go?d/ig; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;？：匹配前面的子表达式零次或一次&lt;/span&gt;
     console.log(str.match(Reg3));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;gd&quot;, &quot;god&quot;]&lt;/span&gt;


     &lt;span&gt;var&lt;/span&gt; Reg4 =/go{2}d/ig; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{n}：匹配确定n次&lt;/span&gt;
     console.log(str.match(Reg4));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;good&quot;]&lt;/span&gt;


     &lt;span&gt;var&lt;/span&gt; Reg5 =/go{2,}d/ig; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{n,}：至少匹配n次&lt;/span&gt;
     console.log(str.match(Reg5));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;good&quot;, &quot;goood&quot;, &quot;gooood&quot;]&lt;/span&gt;
     

     &lt;span&gt;var&lt;/span&gt; Reg6 =/go{1,3}d/ig; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{n, m}：最少匹配n次且最多匹配m次&lt;/span&gt;
     console.log(str.match(Reg6));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;god&quot;, &quot;good&quot;, &quot;goood&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　②元字符---字符匹配符：&lt;/p&gt;
&lt;p&gt;　　字符匹配符用于匹配某个或某些字符。&lt;/p&gt;
&lt;p&gt;　　[xyz]：字符集合。匹配所包含的任意一个字符。&lt;/p&gt;
&lt;p&gt;　　[^xyz]：负值字符集合。匹配未包含的任意字符。&lt;/p&gt;
&lt;p&gt;　　[a-z]：字符范围。匹配指定范围内的任意字符。&lt;/p&gt;
&lt;p&gt;　　[^a-z]：负值字符范围。匹配任何不在指定范围内的任意字符。&lt;/p&gt;
&lt;p&gt;　　\d：匹配一个数字字符。&lt;/p&gt;
&lt;p&gt;　　\D：匹配一个非数字字符。&lt;/p&gt;
&lt;p&gt;　　\w：匹配包含下划线的任何单词字符。等价于[a-z0-9A-Z_]&lt;/p&gt;
&lt;p&gt;　　\W：匹配任何非单词字符。等价于[^a-z0-9A-Z_]&lt;/p&gt;
&lt;p&gt;　　\s：匹配任何空白字符。&lt;/p&gt;
&lt;p&gt;　　\S：匹配任何非空白字符。&lt;/p&gt;
&lt;p&gt;　　·：匹配除”\n”之外的任何单个字符。&lt;/p&gt;
&lt;p&gt;　　实列如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;84&quot;&gt;
&lt;pre&gt;
     &lt;span&gt;var&lt;/span&gt; str = 'aiod acd abd add aed afd ahd $%#@ 12345678 asdfghh'&lt;span&gt;;

     &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg1 = /a[abc]d/ig;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[xyz]：字符集合。匹配所包含的任意一个字符&lt;/span&gt;
     console.log(str.match(Reg1)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;acd&quot;, &quot;abd&quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg2 = /a[^abc]d/ig;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[^xyz]：负值字符集合。匹配未包含的任意字符&lt;/span&gt;
     console.log(str.match(Reg2)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;add&quot;, &quot;aed&quot;, &quot;afd&quot;, &quot;ahd&quot;, &quot;asd&quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg3 = /a[a-z]d/ig;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[a-z]：字符范围。匹配指定范围内的任意字符&lt;/span&gt;
     console.log(str.match(Reg3)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;acd&quot;, &quot;abd&quot;, &quot;add&quot;, &quot;aed&quot;, &quot;afd&quot;, &quot;ahd&quot;, &quot;asd&quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg4 = /a[^a-e]d/ig;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[^a-z]：负值字符范围。匹配任何不在指定范围内的任意字符&lt;/span&gt;
     console.log(str.match(Reg4)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;afd&quot;, &quot;ahd&quot;, &quot;asd&quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg5 = /\d+/ig;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  \d：匹配一个数字字符。&lt;/span&gt;
     console.log(str.match(Reg5));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;12345678&quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg6 = /\D+/ig;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    \D：匹配一个非数字字符&lt;/span&gt;
     console.log(str.match(Reg6));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;aiod acd abd add aed afd ahd $%#@ &quot;, &quot; asdfghh&quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg7 = /\w+/ig;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   \w：匹配包含数字,字母,下划线的任何单词字符,等价于[a-z0-9A-Z_]&lt;/span&gt;
     console.log(str.match(Reg7));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;aiod&quot;, &quot;acd&quot;, &quot;abd&quot;, &quot;add&quot;, &quot;aed&quot;, &quot;afd&quot;, &quot;ahd&quot;, &quot;12345678&quot;, &quot;asdfghh&quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg8 = /\W+/ig;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    \W：匹配任何非单词字符。等价于[^a-z0-9A-Z_]&lt;/span&gt;
     console.log(str.match(Reg8));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; $%#@ &quot;, &quot; &quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg9 = /\s+/ig;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    \s：匹配任何空白字符&lt;/span&gt;
     console.log(str.match(Reg9));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;, &quot; &quot;]&lt;/span&gt;

     &lt;span&gt;var&lt;/span&gt; Reg10 = /\S+/ig;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    \S：匹配任何非空白字符&lt;/span&gt;
     console.log(str.match(Reg10)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;aiod&quot;, &quot;acd&quot;, &quot;abd&quot;, &quot;add&quot;, &quot;aed&quot;, &quot;afd&quot;, &quot;ahd&quot;, &quot;$%#@&quot;, &quot;12345678&quot;, &quot;asdfghh&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　③元字符---定位符：&lt;/p&gt;
&lt;p&gt;　　定位符可以将一个正则表达式固定在一行的开始或结束，也可以创建只在单词内或只在单词的开始或结尾处出现的正则表达式。　　&lt;/p&gt;
&lt;p&gt;　　^：匹配输入字符串的开始位置。&lt;/p&gt;
&lt;p&gt;　　$：匹配输入字符串的结束位置。&lt;/p&gt;
&lt;p&gt;　　\b：匹配一个单词边界，也就是单词和空格间的位置。&lt;/p&gt;
&lt;p&gt;　　\B：匹配非单词边界。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ^：匹配输入字符串的开始位置。&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; str  ='123456'&lt;span&gt;;  
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg1  =/^\d+/&lt;span&gt;ig;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg2  =/\d/&lt;span&gt;ig;
    console.log(Reg1.test(str));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;$：匹配输入字符串的结束位置。&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; str ='abcd789'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Reg =/.+\d{3}$/&lt;span&gt;ig;
    console.log(Reg.test(str));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; \b：限定单词以什么开头和结尾，\B：限定单位不以什么开头和结尾&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; str = 'good ogoodm goods sgoods'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reg1 = /\bg\w+/&lt;span&gt;g;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reg2 = /\w+d\b/&lt;span&gt;g;
console.log(str.match(reg1));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;good&quot;, &quot;goods&quot;]&lt;/span&gt;
console.log(str.match(reg2));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;good&quot;]&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; reg3 = /\Bg\w+/&lt;span&gt;g;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reg4 = /\w+d\B/&lt;span&gt;g;
console.log(str.match(reg3));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;goodm&quot;, &quot;goods&quot;]&lt;/span&gt;
console.log(str.match(reg4));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;[&quot;ogood&quot;, &quot;good&quot;, &quot;sgood&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　④元字符---转义符&lt;/p&gt;
&lt;p&gt;　　\：用于匹配某些特殊字符（遇到特殊字符需要用反斜杠转义）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 特殊字符：. + * ? {} [] ^ $ \&lt;/span&gt;

    &lt;span&gt;var&lt;/span&gt; str = '++++++-*/%'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oReg = /\++/&lt;span&gt;g;
    console.log(str.match(oReg));//[&quot;++++++&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　⑤元字符---选择匹配符&lt;/p&gt;
&lt;p&gt;　　|：可以匹配多个规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 选择匹配符&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; str = 'gooqd gaawd gwwsd'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oReg = /g(ooq|aaw)d/&lt;span&gt;g;
console.log(str.match(oReg));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;gooqd&quot;, &quot;gaawd&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　接下来是常用简单型检测案例&lt;/p&gt;
&lt;p&gt;　　1、手机号检测&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; reg = /^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、检测中文&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字符串只能是中文&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; oReg = /^[\u2E80-\u9FFF]+$/;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3、身份证检测&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 18位身份证检测&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt; oReg = /^\d{17}[\dxX]$/;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、日期检测&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;日期检测&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt; oReg = /^\d{4}(\-|\/)\d{1,2}\1\d{1,2}$/;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5、去除首尾空格&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 去除首尾的空格&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; sVal =&lt;span&gt; oSpace.value;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oReg = /^\s+(\S*)\s+$/&lt;span&gt;;
console.log(sVal.replace(oReg, &lt;/span&gt;'$1'));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　6、检测文件格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测文件格式&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; oReg = /.+\.(jpg|jpeg|png|gif)$/i;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　7、检测邮编&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测邮编&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; oReg = /^\d{6}$/;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　8、过滤&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; str = '小明说小强是混蛋，小强说他不是混蛋'&lt;span&gt;;
str.replace(&lt;/span&gt;/混蛋/g, '**');
&lt;/pre&gt;&lt;/div&gt;



</description>
<pubDate>Thu, 01 Feb 2018 13:21:00 +0000</pubDate>
<dc:creator>MS-LY</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MaShuai666/p/8401348.html</dc:identifier>
</item>
</channel>
</rss>