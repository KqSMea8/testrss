<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>1.1 Python for macOS 安装与配置 - Joeric</title>
<link>http://www.cnblogs.com/Joeric07/p/9461777.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Joeric07/p/9461777.html</guid>
<description>&lt;p&gt;本文主要讲解在macOS系统下的Python3.7.0的配置与安装问题&lt;/p&gt;
&lt;p&gt;并调试好开发环境&lt;/p&gt;
&lt;p&gt;目标是编辑成功第一个python程序&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;下载最新版（3.7.0）Python&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　macOS系统自带python 不过是较低的版本（2.7.10）&lt;/p&gt;
&lt;p&gt;　　　　可以在终端中输入&quot;python&quot;来查询你的python版本&lt;/p&gt;
&lt;p&gt;            &lt;img src=&quot;https://images2018.cnblogs.com/blog/1459302/201808/1459302-20180811234153543-439673709.png&quot; alt=&quot;&quot; width=&quot;598&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　如图 输入&quot;python&quot;按回车&lt;/p&gt;
&lt;p&gt;　　　　蓝色部分即为当前python的版本&lt;/p&gt;

&lt;p&gt;　　　　下面介绍如何安装最新版本的python&lt;/p&gt;
&lt;p&gt;　　　　浏览器打开 https://www.python.org 是python的官方网站 纯英文&lt;/p&gt;
&lt;p&gt;            &lt;img src=&quot;https://images2018.cnblogs.com/blog/1459302/201808/1459302-20180811234401902-2070470758.png&quot; alt=&quot;&quot; width=&quot;595&quot; height=&quot;373&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　　　（注意：该网站可能会因为各种原因 打不开/打开慢/下载慢 请随意安装一个vpn进行科学上网即可）&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1459302/201808/1459302-20180811234957446-217529078.png&quot; alt=&quot;&quot; width=&quot;1085&quot; height=&quot;193&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　笔者安装的为app store中 vpn 搜索结果的第一个 vpn随时会被各种原因和谐 &lt;/p&gt;

&lt;p&gt;　　　　光标移动到Downloads下的Mac OS X下 旁边会有版本提示&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1459302/201808/1459302-20180811234554857-1076076103.png&quot; alt=&quot;&quot; width=&quot;717&quot; height=&quot;415&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　点击左边的&quot;Python3.7.0&quot;即可下载&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1459302/201808/1459302-20180811234741743-539995795.png&quot; alt=&quot;&quot; width=&quot;711&quot; height=&quot;347&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装最新版（3.7.0）Python&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1459302/201808/1459302-20180811235452119-371796817.png&quot; alt=&quot;&quot; width=&quot;712&quot; height=&quot;505&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　接下来为傻瓜式安装 点击&quot;继续&quot;即可&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1459302/201808/1459302-20180811235738395-2050623031.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;503&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　安装完成&lt;/p&gt;


&lt;p&gt;　　　　接下来 在终端中查看一下python的版本&lt;/p&gt;
&lt;p&gt;　　　　在终端中输入&quot;python3&quot;按回车&lt;/p&gt;
&lt;p&gt;　　　　（注意：不能缺少3）&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1459302/201808/1459302-20180812000611748-908964264.png&quot; alt=&quot;&quot; width=&quot;715&quot; height=&quot;460&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　目前 电脑里有python的2.7.10与3.7.0两个版本&lt;/p&gt;
&lt;p&gt;　　　　为了更方便地使用3.7.0 下面介绍如何在开发环境中配置&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;开发环境（Sublime Text 3）的安装与配置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　Sublime Text 3是一款免费的编译器&lt;/p&gt;
&lt;p&gt;　　　　https://www.sublimetext.com/3 官网在此&lt;/p&gt;
&lt;p&gt;　　　　请下载第三版（Sublime Text 3）&lt;/p&gt;

&lt;p&gt;　　　　现在介绍如何在开发环境中配置3.7.0&lt;/p&gt;
&lt;p&gt;　　　　打开Sublime Text 3&lt;/p&gt;
&lt;p&gt;　　　　在Tools -&amp;gt; Build System -&amp;gt; New Build System,输入以下内容：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&quot;cmd&quot;: [&quot;/usr/local/bin/python3&quot;, &quot;-u&quot;, &quot;$file&quot;],&lt;/p&gt;
&lt;p&gt;　　　　}&lt;/p&gt;
&lt;div readability=&quot;51&quot;&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1459302/201808/1459302-20180812001545992-1724173702.png&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;432&quot;/&gt;&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1459302/201808/1459302-20180812001612083-679539303.png&quot; alt=&quot;&quot; width=&quot;702&quot; height=&quot;198&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　快捷键command+s保存 可随意命名 但建议如图所示 保存位置请如图所示&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1459302/201808/1459302-20180812001752934-66272854.png&quot; alt=&quot;&quot; width=&quot;697&quot; height=&quot;463&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　保存成功后 即可使用3.7.0编写程序了&lt;/p&gt;

&lt;p&gt;　　　　在Tools -&amp;gt; Build System -&amp;gt; Build System中 选择Python3&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1459302/201808/1459302-20180812001957911-463923752.png&quot; alt=&quot;&quot; width=&quot;754&quot; height=&quot;788&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　可以理解为 选择python即为2.7.0版本&lt;/p&gt;
&lt;p&gt;　　　　选择python3即为3.7.0版本&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;编写第一个python程序&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　打开sublime text 3&lt;/p&gt;
&lt;p&gt;　　　　按上图选择python3编译环境&lt;/p&gt;
&lt;p&gt;　　　　在编译器的右下角 将文本模式改为python模式&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1459302/201808/1459302-20180812002549738-652683944.png&quot; alt=&quot;&quot; width=&quot;353&quot; height=&quot;662&quot;/&gt;　　　　　　　　　　　　　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1459302/201808/1459302-20180812002637000-937058489.png&quot; alt=&quot;&quot; width=&quot;418&quot; height=&quot;292&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　一切准备就绪了！&lt;/p&gt;
&lt;p&gt;　　　　事实上 我们每一次进行编写程序时 都需要检查一下这些配置情况&lt;/p&gt;
&lt;p&gt;　　　　接下来编写第一个python程序&lt;/p&gt;

&lt;p&gt;　　　　print(&quot;Hello World!&quot;)&lt;/p&gt;

&lt;p&gt;　　　　将上面的一行代码复制下来 粘贴到sublime里面就好&lt;/p&gt;
&lt;p&gt;　　　　以后的文章会介绍它的运作原理&lt;/p&gt;

&lt;p&gt;　　　　代码复制好后&lt;/p&gt;
&lt;p&gt;　　　　使用快捷键command+s将当前程序保存下来&lt;/p&gt;
&lt;p&gt;　　　　建议在桌面上单独创建一个文件夹来保存python程序&lt;/p&gt;
&lt;p&gt;　　　　保存好后 使用快捷键command+b来运行程序&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1459302/201808/1459302-20180812003125263-375415228.png&quot; alt=&quot;&quot; width=&quot;720&quot; height=&quot;1038&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 　　　　第一个程序完成了！&lt;/p&gt;
&lt;p&gt;　　　　无论是什么语言 第一个运行的总是“Hello World” 它对程序员来说 有着不小的意义&lt;/p&gt;
&lt;p&gt;　　　　无论以后会去完成多么艰巨的代码任务 都会从这一步开始&lt;/p&gt;




&lt;/div&gt;

</description>
<pubDate>Sat, 11 Aug 2018 16:39:00 +0000</pubDate>
<dc:creator>Joeric</dc:creator>
<og:description>python3.7.0 for macOS的安装与开发环境的配置</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Joeric07/p/9461777.html</dc:identifier>
</item>
<item>
<title>JVM(2)--一文读懂垃圾回收 - 公众号_苦逼的码农</title>
<link>http://www.cnblogs.com/kubidemanong/p/9461755.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubidemanong/p/9461755.html</guid>
<description>&lt;p&gt;与其他语言相比，例如c/c++，我们都知道，java虚拟机对于程序中产生的垃圾，虚拟机是会自动帮我们进行清除管理的，而像c/c++这些语言平台则需要程序员自己手动对内存进行释放。&lt;br/&gt;虽然这种自动帮我们回收垃圾的策略少了一定的灵活性，但却让代码编写者省去了很多工作，同时也提高了很多安全性。(因为像C/C++假如你创建了大量的对象，但却由于自己的疏忽忘了将他们进行释放，可能会造成内存溢出)。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;何为垃圾？&lt;/h3&gt;
&lt;p&gt;刚才说了，虚拟机会自动帮助我们进行垃圾的清除，那什么样的对象我们才可以称为是垃圾对象呢？&lt;br/&gt;假如你创建了一个对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Man m = new Man();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你用一个变量指向了这个对象，显然对于这个对象，你可以用变量m对这个对象进行利用，但过了一段时间，你执行了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;m = null;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并且也并没有新的变量来指向刚才创建的对象。此时对于这个没有任何变量指向的对象，你觉得它还有用处吗？&lt;br/&gt;显然，对于这种没有被变量指向的对象，它是一点卵用也没有的，它只能在&lt;strong&gt;堆&lt;/strong&gt;随风漂流。&lt;br/&gt;因此，对于这样的对象，我们就可以把它称为垃圾了，它早晚会被垃圾回收器给干掉。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;怎么知道它已经是垃圾对象了?&lt;/h3&gt;
&lt;p&gt;假如代码是你自己编写的，你可能知道这个对象啥时候应该被抛弃，你可以随时让它成为垃圾对象。&lt;br/&gt;但是，你毕竟是你，虚拟机则没那么智能。那虚拟机是如何知道的呢？&lt;br/&gt;上面已经说了，没有变量引用这个对象时，它就是垃圾对象了，基于这个原理，我们可以这样做啊：&lt;br/&gt;我们可以为这个对象设置一个计数器，初始值为0，假如有一个变量指向它，那么计数器就加1，如果这个变量不在指向它了，计数器就减1。那么我们就可以判断，如果这个计数器为0的话，那它就是垃圾对象了，否则就是有用的对象。&lt;br/&gt;对于这种方法，我们称之为&lt;strong&gt;引用计数法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;好吧，我们先来夸一夸&lt;strong&gt;引用计数法&lt;/strong&gt;这种方法：&lt;br/&gt;1.实现简单。&lt;br/&gt;2.效率高(一个if语句就能解决的问题想不高效都难)。&lt;br/&gt;&lt;strong&gt;不好意思，接下来得说说它那个致命的缺点&lt;/strong&gt;。&lt;br/&gt;实际上，对于这种引用计数的方法，假如它遇到&lt;strong&gt;对象互相引用&lt;/strong&gt;的话，是很难解决的。&lt;br/&gt;先看一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Man m1 = new Man();
Man m2 = new Man();
//互相引用
m1.instance = m2;//假设Man有instance这个属性
m2.instance = m1;
m1 = null;
m2 = null;
System.gc();//按道理对象应该被回收
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码m1和m2都指向null了，按道理两个对象已经是无用对象，应该被回收，但是，两个对象之间彼此有一个instance的属性互相牵引的对方，导致两个对象并没有被回收。&lt;br/&gt;这个缺点够致命吧？&lt;br/&gt;所以，虚拟机并没有采用这种&lt;strong&gt;引用计数&lt;/strong&gt;的方法。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;可达性分析&lt;/h4&gt;
&lt;p&gt;除了这种方法，我们还有其他的方法吗？&lt;br/&gt;答案是有的，必须得有啊。这种方法就是传说中的&lt;strong&gt;可达性分析&lt;/strong&gt;，(我靠，听名字是真的高级啊)。它的&lt;strong&gt;工作原理&lt;/strong&gt;是这样的：&lt;br/&gt;在程序开始时，会建立一个引用根节点(GC Roots)，并构建一个引用图。当需要判断谁是垃圾时，我们可以从这个根节点进行遍历，如果没有被遍历到的节点则是&lt;strong&gt;垃圾对象&lt;/strong&gt;，否则就是有用对象。如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/12/16529ca3f6a90edd?w=710&amp;amp;h=380&amp;amp;f=png&amp;amp;s=46373&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;这个方法可以解决循环相互引用的问题，但是这个方法并没有&lt;strong&gt;引用计数法&lt;/strong&gt;高效，毕竟要遍历图啊。&lt;br/&gt;&lt;strong&gt;总结下判断是否为垃圾对象的算法：&lt;/strong&gt;&lt;br/&gt;1.引用计数法。&lt;br/&gt;2.可达性分析。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;何时进行垃圾回收&lt;/h3&gt;
&lt;p&gt;可能有人会觉得这个问题很奇怪，觉得&lt;strong&gt;看到垃圾就回收&lt;/strong&gt;不是很好。对于这个我只能说：&lt;br/&gt;1.看到房间有一点垃圾你会马上扫？还是等到某个时间点或者当垃圾积累到一定的数量再扫？&lt;br/&gt;2.虚拟机可没那么智能可以马上识别这个对象是垃圾对象，它还得遍历所有对象才能知道有哪些是垃圾对象。&lt;br/&gt;所以说，你总不能几秒(我们假设几秒是贼短的时间）就让虚拟机遍历一下所有对象吧？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这里先说明一下，当垃圾回收器在进行垃圾回收的时候，为了保证垃圾回收不受干扰，是会暂停所有线程的，此时程序无法对外部的请求进行响应。(因为你想啊，当你在可达性分析的时候，那些引用关系还在不断着变化，那不很难受)。&lt;br/&gt;而且频繁的垃圾回收，对于有一些程序，是很影响用户体验的，例如你在玩游戏，系统动不动就停顿一下，怕你是要把这游戏给删了。&lt;br/&gt;所以说，垃圾回收是会等到内存被使用了一定的比例的时候，才会触发垃圾回收。至于这个比例是多少，这可能就是人为规定的了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;-&quot;&gt;怎么回收？&lt;/h3&gt;
&lt;p&gt;当我们标记好了哪些是垃圾，想要进行回收的时候，该怎么回收比较好呢？&lt;br/&gt;可能有一些人就觉得奇怪，这还不简单，看见它是垃圾，直接回收不就得了。&lt;br/&gt;其实这也不无道理，简单粗暴，直接回收。&lt;br/&gt;是的，确实有这样的算法，看哪些是被我们标记的垃圾，看见了就直接回收。这种算法我们称之为&lt;strong&gt;标记—清除算法&lt;/strong&gt;。&lt;br/&gt;&lt;strong&gt;标记-清除算法&lt;/strong&gt;工作原理：就是先标记出所有需要回收的对象，然后在统一回收所有被标记过的对象。&lt;br/&gt;不过，&lt;strong&gt;那些人&lt;/strong&gt;你可别得意啊，因为这种方法虽然简单暴力，但它有个致命的缺点就是：&lt;br/&gt;标记清除过后，会产生大量的&lt;strong&gt;不连续内存碎片&lt;/strong&gt;，如果不连续的碎片过多的话，，可能会导致有一些&lt;strong&gt;大的对象&lt;/strong&gt;存不进去。这样，会导致下面两个问题：&lt;/p&gt;
&lt;p&gt;1.有些内存浪费了。&lt;br/&gt;2.对象存不进去，会又一次触发垃圾回收。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复制算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了解决这种问题，另外一种算法出现了—-&lt;strong&gt;复制算法&lt;/strong&gt;。就是说，它会将可用的内存按容量划分成两块。然后每次只使用其中的一块，当这一块快用完的时候，就会触发垃圾回收，它会把还存活的对象全部复制到另外一块内存中去，然后把这块内存全部清理了。&lt;br/&gt;这样，就不会出现碎片问题了。&lt;br/&gt;居然帮我们解决了我们必须夸一下它：不仅帮我们解决了问题，而且实现上也简单、运行也高效。&lt;br/&gt;但是(凡事都有个但是的)，它也是有缺点的，缺点很明显，发现了没有。假如每次存活的对象都很少很少，那另外一块内存不是几乎没有用到？所以说，这种方法有可能导致另外一半内存几乎没用了。内存那么宝贵，这可是很严重的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优化策略&lt;/strong&gt;：可以告诉你，有研究显示，其实有98%的对象都是&lt;strong&gt;朝生夕死&lt;/strong&gt;的，也就是说，每次存活的对象确实很少很少。既然我们都知道存活的对象很少很少了，那我们干嘛还1：1的比例来分配？所以说，HotShot虚拟机是默认按8:1的比例来分配的。这样，就不会出现很多内存没用到的问题了。&lt;br/&gt;可能有人会说，万一占比为1/9的内存不够用了怎么办？不就没地方存那些活的对象？实际上，当内存不够用时，可以向其他地方借些内存来使用，例如&lt;strong&gt;老年代&lt;/strong&gt;里的内存。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这里说明一下新生代和老年代：说白了，新生代就是刚刚创建不久的对象，而老年代是已经活了挺久的对象。也就是说，有一些对象是确实活的比较久的，对于这种对象，我们另外给它分配内存来养老，而且垃圾回收时，我们不用每次都来这里查找有没垃圾对象，因为这些对象是垃圾的几率会比较小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;下面在简单介绍另外两种算法：&lt;/strong&gt;&lt;br/&gt;1.标记-整理算法：这种算法和&lt;strong&gt;标记-清除算法&lt;/strong&gt;类似，不过它把垃圾清除了之后，会让存活的对象往一个方向靠拢，以此来整理碎片。&lt;br/&gt;2.分代收集算法：所谓分代就是把对象分成类似上面说的老年代和新生代，在新手代一般每次垃圾回收时死的对象一般都会比较多，而老年代会比较少，基于这种关系，我们就可以采取不同的算法来针对了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结下垃圾回收的几种算法：&lt;/strong&gt;&lt;br/&gt;1.标记-清除算法。&lt;br/&gt;2.复制算法。&lt;br/&gt;3.标记-整理算法。&lt;br/&gt;4.分代收集算法。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;最后给大家几种垃圾回收器&lt;/h3&gt;
&lt;p&gt;对于垃圾的回收，你是想一边运行程序其他代码一边进行垃圾回收？还是想把垃圾全收好再来执行程序的其他代码？虽然说最终使用cpu的时间是一样，但两种方式还是有区别的。&lt;br/&gt;下面简单介绍几种垃圾回收器，看看他们都使用哪种方。&lt;br/&gt;&lt;strong&gt;(1).Serial收集器&lt;/strong&gt;&lt;br/&gt;serial(串行),看这个英文单词就知道这是一个单线程收集器。也就是说，它在进行垃圾回收时，必须暂停其他所有线程。显然，有时垃圾回收停顿的比较久的话，这对于用户来说是很难受的。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/12/16529ca9ce11d978?w=472&amp;amp;h=223&amp;amp;f=png&amp;amp;s=78973&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;(2).ParNew&lt;/strong&gt;&lt;br/&gt;这个收集器和Serial很类似，进行垃圾回收的时候，也是得暂停其他所有线程，不过，它可以多条线程工作进行垃圾回收。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/12/16529cace210a415?w=458&amp;amp;h=245&amp;amp;f=png&amp;amp;s=81608&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;(3).Parallel Scavenge收集器&lt;/strong&gt;&lt;br/&gt;parallel,并行的意思。也是可以多线程进行垃圾回收处理，但是它与ParNew不同。它会严格控制垃圾回收的时间与执行其他代码的时间之间的比例。我们来看一个名词：&lt;strong&gt;吞吐量&lt;/strong&gt;。&lt;br/&gt;吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。&lt;br/&gt;也就是说，Parallet Scavenge收集器会严格控制吞吐量，至于这个吞吐量是多少，这个可以人为设置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/12/16529cb073097129?w=458&amp;amp;h=245&amp;amp;f=png&amp;amp;s=81608&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;下面两个收集器重点介绍下&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;(4).CMS（Concurrent Mark Sweep）收集器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：&lt;br/&gt;1.初始标记（CMS initial mark）&lt;br/&gt;2.并发标记（CMS concurrent mark）&lt;br/&gt;3.重新标记（CMS remark）&lt;br/&gt;4.并发清除（CMS concurrent sweep）&lt;br/&gt;其中初始标记、重新标记这两个步骤仍然需要&lt;strong&gt;暂停其他线程&lt;/strong&gt;。但另外两个步骤可以和其他线程&lt;strong&gt;并发执行&lt;/strong&gt;。初始标记仅仅只是标记一下GCRoots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程 &lt;strong&gt;(说白了就是把整个图都遍历了，找出没有的对象)&lt;/strong&gt;，&lt;br/&gt;而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。&lt;br/&gt;由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程几乎是与与用户线程一起并发地执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/12/16529cb4c17c197b?w=477&amp;amp;h=234&amp;amp;f=png&amp;amp;s=90727&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(5).G1收集器&lt;/strong&gt;&lt;br/&gt;这个估计是最牛的收集器了。该收集器具有如下特点：&lt;br/&gt;1.并行与并发：G1能充分利用现代计算器多CPU,多核的硬件优势，可以使用并发或并行的方式来缩短让其他线程暂停的优势。&lt;br/&gt;2.分代收集：就是类似像分出新生代和老年代那样处理。&lt;br/&gt;3.空间整合：采用了&lt;strong&gt;复制算法&lt;/strong&gt;+&lt;strong&gt;标记-整合算法&lt;/strong&gt;的特点来回收垃圾。就是整体采用&lt;strong&gt;标记-整理算法&lt;/strong&gt;，局部采用&lt;strong&gt;复制算法&lt;/strong&gt;。&lt;br/&gt;4.可预测停顿：这个就牛了，就是说，它能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超过N毫秒。&lt;/p&gt;
&lt;p&gt;它的执行过程大体如下：&lt;br/&gt;1.初始标记。&lt;br/&gt;2.并发标记。&lt;br/&gt;3.最终标记。&lt;br/&gt;4.筛选回收。&lt;/p&gt;
&lt;p&gt;这个流程和CMS很相似，它也是在&lt;strong&gt;初始标记&lt;/strong&gt;和&lt;strong&gt;最终标记&lt;/strong&gt;需要暂停其他线程，但其他两个过程就可以和其他线程并发执行。&lt;br/&gt;刚才我们说了G1收集器哪些优点，例如&lt;strong&gt;可预测停顿&lt;/strong&gt;，这也使得&lt;strong&gt;筛选回收&lt;/strong&gt;，是可以预测停顿垃圾回收的时间的，也就是说，停顿的时间是用户自己可以控制的，这也使得一般情况下，在&lt;strong&gt;筛选回收&lt;/strong&gt;的时候，我们会暂停其他线程的执行，把所有时间都用到&lt;strong&gt;筛选回收&lt;/strong&gt;上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/8/12/16529cb849b14484?w=645&amp;amp;h=224&amp;amp;f=png&amp;amp;s=25815&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本次讲解到这里。&lt;br/&gt;&lt;strong&gt;完&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Sat, 11 Aug 2018 16:30:00 +0000</pubDate>
<dc:creator>公众号_苦逼的码农</dc:creator>
<og:description>与其他语言相比，例如c/c++，我们都知道，java虚拟机对于程序中产生的垃圾，虚拟机是会自动帮我们进行清除管理的，而像c/c++这些语言平台则需要程序员自己手动对内存进行释放。虽然这种自动帮我们回收</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubidemanong/p/9461755.html</dc:identifier>
</item>
<item>
<title>游北国风光，忆南国之乡 - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/9461680.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/9461680.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180811225245814-682284386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刚从床上爬起来准备看会儿书，一条感人消息就这么甩过来了，进了？省赛前，我一直在为学业考试和项目忙碌不停，然后还有电子实习，从报名那会儿开始，长达半年时间，我没有写过一题，所以，其实只能说上帝还是很眷顾我的，省赛那会儿做完以后，我就已经觉得省三应该都拿不到了吧，很绝望的说，其实对于一个从来没去过北方的孩子，对北方是无比的期待与向往，直到出成绩那会儿，喜极而泣，可能是我太菜了吧，虽然我知道这个比赛真的很水很水。。。于是乎，那也是我第一次去北方了吧，早早地提前了几天收拾好行李，那几天也是彻夜未眠呐，每天都在期望着和大佬们见面呢~~&lt;/p&gt;
&lt;p&gt;当晚就准备启程了，我们在车上有说有笑着，伴着欢声笑语，迎来了第二天清晨，从火车上望着外面的景色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180811225420735-300049805.png&quot; alt=&quot;&quot; width=&quot;473&quot; height=&quot;351&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原来这就是北方啊，一望无际的都是平原，想想我家那边，都是丘陵地带，既没有连绵的山脉，也没有广阔的平原，有的只是一些小山丘啥的，当然啦，这肯定激发了我的那一股儿好奇劲儿~~&lt;/p&gt;
&lt;p&gt;尾随着一路颠簸不停的，终于到了北京西站。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180811225444903-1065201134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们当然是一路奔着住宿的地方走啊走啊，也不知道负责人是怎么订房间的，直接就订到了东直门，一查，maye，二环，我心中莫名地有些恐慌，事实证明，二环的物价也忒贵了吧，一晚上1500一间，吃饭平均是30~50一餐(还是比较差的那种)，我当时莫名地对北京的物价有着莫名地惊讶，然后一路坐着地铁过去，路上达成了三个成就：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;上地铁被北京大妈挤出地铁&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;地铁关门的时候被门夹到&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;坐地铁坐反了方向&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一路颠簸流离，总算到了住处的地方，稍事休息整理了一下，正式开始了北游。&lt;/p&gt;

&lt;p&gt;还未来得及细品春娘的美貌，还没来得及与它相拥而诉，一股初夏的气息扑面而来，掩饰来时的羞涩，匆忙地投入怀里，柔情滋生了色彩，也许温柔总让人心醉迷离，也许热情总让人留恋不已，初夏的热情，柔碎了我那潮湿的记忆。&lt;br/&gt;好似一夜之间，树叶相约似的长大了许多，微风吹来，呼啦啦继续疯长，叶片在朝阳的照射下，神奇地活现，泛着粼粼的光。不经意的一瞥：满大街的裙裾摇曳！我不由得感叹：原来已是初夏。没有了冬日的严寒，也送走了晚春的狂风肆虐。夏，羞答答的温柔，不由得让人喜欢！&lt;/p&gt;
&lt;p&gt;初夏，是我最爱的时令，也许是刘瑞琦的那首《初夏》，也许是许嵩的那首《毁人不倦》，也许是那灌木丛中的木槿花，总之，这气候来的刚刚好。两年来，因为那句“初夏的雨点，落的太敷衍”而义无反顾疯狂地爱上了这短短的初夏。挹一口暖风熏得游人醉、咂一次绿荫来时路不减，这即是慵懒而热情的初夏。&lt;/p&gt;
&lt;p&gt;北京初夏傍晚的天空，就像五颜六色的水彩笔渲染出的暖色调。绚丽之余多了一股秀气。那墙角剥落的泥土，散落的时光。还有天边远去的惊鸿。几许回忆便瞬间抽空了心灵。让人有些许唏嘘，惆怅。亦如眼中的雾，化不开来。只能看清楚轮廓。&lt;/p&gt;
&lt;p&gt;初夏的北京天气格外的好，天特别蓝，万里无云，貌似传说中的雾霾天气完全与她无关一样！天气好，心情也很好，身处老北京的小巷子上，心旷神怡！ 街道比较宽敞、整洁，少了市区中心那份喧闹，反倒别有一番味道。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180811230643890-1567932104.jpg&quot; alt=&quot;&quot; width=&quot;384&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;
&lt;p&gt;登上长城，放眼望去，一切都显得那么美丽、雄伟。各个国家的人们像赶集似的聚拢到这里来。走着看着，突然看见了烽火台，台上像一座小塔，石砖坑坑洼洼，见证着历史的沧桑巨变，据说这烽火台是打仗时用来报信的。站在长城上，我居高临下，极目远眺，只见群山苍莽，气势雄伟，一直伸向远方，与碧空相连，显得磅礴无比，是谁创造出这样的人间奇迹？是我们中华民族的祖先！&lt;/p&gt;
&lt;p&gt;从下往上看，长城盘旋在山脊之上，顺山势而蜿蜒于群山之间。游人密密麻麻，附着在长城这个长长的飘带上。从只能过一个人的窄小的入口绕上去，我们就站在了长城上。长城如同陡峭的台阶，伸向远方，两边是垛口和了望孔。&lt;br/&gt;爬长城那才是真正的爬，石阶很陡，很滑，向上不能走而只能爬，人像猿猴一样，但远没有它们灵活。爬累了，就顺势坐下来休息，喝点水补充被阳光蒸发的水分，然后用被汗水模糊的眼睛欣赏周围的风景，因为爬的时候看到的只有灰灰的石砖。有上就有下，下的时候，有的人把着两边的护栏，慢慢溜下去；有的人用双手贴着地，向下蹭；有的人干脆向下跑，大有刹不住之势，很是让人担心。&lt;/p&gt;
&lt;p&gt;站在长城上，我浮想联翩：二千多年前，在那么恶劣的条件下，劳动人民到底是如何把这些砖块运到山上，将这些砖块砌成了如今我们所见到的如此坚实的城墙，实在是了不起！我们要弘扬中华民族吃苦耐劳、艰苦奋斗的精神，把祖国的各行各业建设得蒸蒸日上、欣欣向荣。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180811231254534-159734448.jpg&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;375&quot;/&gt;&lt;/p&gt;
&lt;p&gt;寻寻觅觅，故宫的灵魂，你究竟在哪里？我穿过金水桥，迈入太和殿，空气里仿佛充满了一双双怅望苍天的眼睛，里面满是压抑已久喷薄欲出的幽怨和权利驱使下的野心，还有关于两个王朝江山社稷的荣辱得失。但他们都不是故宫的灵魂。我继续寻找着，终于，在一个不起眼的角落，我找到了，找到了那个在故宫蛰伏已久的灵魂——传统文化。&lt;/p&gt;
&lt;p&gt;漫步在故宫，近距离的参观那些巍峨的宫殿，我才愕然发现，原来传统文化已经渗透进了故宫建筑的每一个角落、每一个细节。金水河上的五座金水桥，象征着“仁”、“义”、“礼”、“智”、“信”的儒家五德，而乾隆在斋宫的御笔“敬天”更是将“敬天畏人”的传统道德展露无余。传统文化，竟早已随着岁月的流逝，在故宫的空气里扩散开来，愈久弥香。&lt;/p&gt;
&lt;p&gt;触摸故宫的灵魂，感受到的是深深的震撼，震撼于传统文化的博大精深，也为其日益流失忧心忡忡。然而我坚信，作为炎黄子孙的我们，不会眼睁睁的看着民族精神葬送在自己手中。故宫，在见证了明清两代的盛衰荣辱之后，还必将见证传统文化的继承和发扬！&lt;/p&gt;
&lt;p&gt;故宫最美丽的莫过于在坤宁宫北面的御花园了。走进御花园，满眼看到的是苍松翠柏，奇花异石，亭台楼阁，水榭小桥，不时传来几声鸟叫或泉水的丁冬声;放眼望去，不时可见几座宫殿和厅山怪石的尖顶。这自然与人工的美妙结合，真可谓“天上人间”。抬头看天，低头看脚下的砖石，或是摸一摸朱漆大门上的门钉，或是檐上的木雕和中轴线上的种种图案。看看那些房梁，虽然我知道已经掉色的房梁也不是当年的房梁，但没有关系，至少雕塑还是。屋角的雕塑，精细，生动，有龙，有凤，男人工作的地方雕的狮子是双眼圆睁，而女眷们门前的却睁一只眼闭一只眼，是叫人莫管是非。要说文化，在这个巨大的四合院的建筑群里，难道不更在这些细小的雕刻上？那里才真正藏着过去岁月的灵魂，它们才见证了人世的冷暖，俯视了生命的起落，时光流逝，物是人非，这一刀一刀的刻印，正是最好的说明文，散文和传奇小说。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180811233455782-1304957072.jpg&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;433&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后海，是北京城里的一汪水儿，和它相通的还有前海和西海，连一块儿就叫什刹海。什刹海的南面，也有三个海，是南海，中海和北海，又称前三海。相对于这三海，什刹海也叫后三海，而后海就在其中。虽然它们都算不得大，每面水域不过数十公倾，但有了这几汪水儿，北京城就显得不干不燥了，也就有了赏荷泛舟的去处，四四方方的皇城才不至于拘谨，这整肃的皇气里面，也就跟着添了几分活泼的灵气。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180811233802865-1005777961.jpg&quot; alt=&quot;&quot; width=&quot;570&quot; height=&quot;423&quot;/&gt;&lt;/p&gt;
&lt;p&gt;去后海，最近便儿的走法儿，还是先到鼓楼，往南走一点儿就能看见烟袋斜街的牌楼。从这底下穿过去，沿街前行数百步即是。如果不急，还可以在街里流连一会儿，虽然几经历史变迁，这里早就不卖烟袋烟嘴儿鼻烟儿壶了，甚至文玩店、画店也已销声匿迹，但在这儿还是能寻到一些有意思的玩艺儿。比如买上一件印有奥&lt;span lang=&quot;EN-US&quot;&gt;X马红卫兵形象的&lt;span lang=&quot;EN-US&quot;&gt;T恤，或是白底儿蓝条的海魂衫，一只写着“抓革命，促生产”的洋磁儿缸，或是绣着“为人民服务”的绿色军挎，画着周璇的旧电影海报，以及斗彩的茶具，古色古香的陶笛，彩蝶大花儿的对襟盘扣儿小袄……这里不是东单王府井，不是大栅栏，潘家园，虎坊桥，要买大金大银，珍玩重器，名人字画，这里头没有，这里有的只是一个个小物件儿。这些小东西，虽不起眼儿，却能冷不丁地撞醒了浑浑沌沌的心，让人忽然间想起了特定的年代，甚至是自己当孩子的时候。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;烟袋斜街，不宽，约可五六人并行，看起来就像一个大胡同。但它的确是斜，因是往后海边儿上斜，所以又斜得好。到了小石碑胡同和鸦儿胡同交口儿左转，眼前忽然洞开的一片天高水阔，兼又风意顿生的，这便是后海了。&lt;/p&gt;
&lt;p&gt;首先映入眼帘的是一座小拱桥，它横跨在前海与后海的交接处，称银锭桥。若要把这两块儿水比作一只漂着的葫芦，那么这只葫芦须得横倒了，它的嘴儿就冲着故宫方向，上半截瘦些的是前海，下半截丰些的就是后海，而银锭桥就在这葫芦的细脖儿上。&lt;/p&gt;
&lt;p&gt;说是看后海，其实也都会看前海，说是游后海，又不如说逛后海。后海的水，再绿，再柔美，也不过是一片水，这样的水，望几眼也便收了底。后海真正的味道，我以为是在两岸上，这里有数不清的胡同，星罗棋布的名人故居，有老北京的风味小吃，也有时尚浪漫的酒吧。这味道若有颜色，它便是宫墙的红，琉璃瓦的黄，是烟柳的绿，高天的蓝，是青砖的灰，哨鸽的白。这味道若有声音，它就是黄包车上的铃铛声儿，地道的京韵京口儿，是悠扬明亮的胡琴儿，略带忧伤的萨克斯，还有当下春日里的微雨细浪，花摇风斜。哪怕是老人儿的清咳，小孩子的稚语，只要是星星点点的散落在后海的地界儿，便就有了别致的韵味。这味儿是京味儿，填了幽，洗了暄的，是带了从容，含了恬淡的。所以，它的深味足当得一个逛字，既说是逛，便能走回来，再走回去。既说是逛，便不是游，不是从这儿看过去，再不思来的一趟活儿。&lt;/p&gt;
&lt;p&gt;来后海，最好一个人，这并非缘于独处的安静，而是因为一个人实在有着大自由。这里可看的地方儿多，免不了走走停停，站站坐坐，若跟个伴儿，不是喊累叫饿，就是扯东扯西，难以由着自己的性儿来。不过当时我是大晚上去的后海，和几个小伙伴们约好的，也算是去酒吧结游寻兴，去体验一下老北京儿人的生活情调~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180811234435096-1378659898.jpg&quot; alt=&quot;&quot; width=&quot;561&quot; height=&quot;416&quot;/&gt;&lt;/p&gt;
&lt;p&gt;北大清华应该是我学生时代梦寐以求的学校，即使当年考不上，如今也要去看看！北京大学，原名燕京大学， 北京大学校园的主体继承自民国时代的燕京大学，所以又称“燕园”。成立于1920年的燕京大学就是由三所教会学校合并而成的，司徒雷登在短短的十几年时间内，使得燕京大学蜚声海内外，成为一代名校。 这其中建设有特色和高质量的校园是他办学思想的重要部分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180811234925329-181227856.jpg&quot; alt=&quot;&quot; width=&quot;621&quot; height=&quot;460&quot;/&gt;&lt;/p&gt;
&lt;p&gt;清华大学的前身清华学堂始建于1911年，因水木清华而得名，是清政府设立的留美预备学校，其建校的资金源于1908年美国退还的部分庚子赔款。1912年更名为清华学校。1928年更名为国立清华大学。1937年抗日战争全面爆发后南迁长沙，与北京大学、南开大学组建国立长沙临时大学，1938年迁至昆明改名为国立西南联合大学。1946年迁回清华园。1949年中华人民共和国成立，清华大学进入了新的发展阶段。1952年全国高等学校院系调整后成为多科性工业大学。1978年以来逐步恢复和发展为综合性的研究型大学。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180811234747193-582243653.jpg&quot; alt=&quot;&quot; width=&quot;613&quot; height=&quot;454&quot;/&gt;&lt;/p&gt;
&lt;p&gt;圆明园，在清帝150余年的创建和经营下，曾以其宏大的地域规模、杰出的营造技艺、精美的建筑景群、丰富的文化收藏和博大精深的民族文化内涵而享誉于世，被誉为“一切造园艺术的典范”，被 法国作家维克多雨果誉为“理想与艺术的典范”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180811235447205-352863802.jpg&quot; alt=&quot;&quot; width=&quot;571&quot; height=&quot;423&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然而，沉浸在喜悦中的我们，也不得不直面时光的飞逝。欢乐的时间总是薄如蝉翼，以至谁都不敢触碰离别的话题。在临别的前一天，莫名地有些伤感。&lt;/p&gt;
&lt;p&gt;又是一年北国的初春时节，春光温暖和煦。校园里的玉兰花傲然而开，干瘪的柳枝也渐渐充盈，透出点点绿芽。生命在经过一冬的沉寂过后，开始了新的轮回。我轻轻的合上那满载温馨的相册，将思念和感动深埋于心。窗外已是满园春色了，那勃发的绿意和涌动的暗香，催我奋进，伴我继续走上追梦的旅途。&lt;/p&gt;
</description>
<pubDate>Sat, 11 Aug 2018 16:05:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<og:description>前言 刚从床上爬起来准备看会儿书，一条感人消息就这么甩过来了，进了？省赛前，我一直在为学业考试和项目忙碌不停，然后还有电子实习，从报名那会儿开始，长达半年时间，我没有写过一题，所以，其实只能说上帝还是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/9461680.html</dc:identifier>
</item>
<item>
<title>精读《原则》，教你如何通过原则过上想要的人生（下篇） - 奶爸码农</title>
<link>http://www.cnblogs.com/wdsunny/p/9461636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wdsunny/p/9461636.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;做有意义的工作，发展有意义的人际关系&lt;br/&gt;-瑞·达利欧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上篇介绍了《原则》这本书里面的生活相关的原则，这里是传送门：&lt;a href=&quot;https://www.jianshu.com/p/c7e81a6e121e&quot; target=&quot;_blank&quot;&gt;上篇&lt;/a&gt;。这篇文章会继续介绍工作相关的原则。&lt;/p&gt;

&lt;hr/&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;235&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-96da8e94dafbe8ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-96da8e94dafbe8ae.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;235&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;152889&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;600&quot; data-height=&quot;898&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-2078172ee5d01442.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-2078172ee5d01442.jpeg&quot; data-original-width=&quot;600&quot; data-original-height=&quot;898&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;36382&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;目标到结果，需要经过组织/机构等运作达到，作者把机构视为机器，通过不断的实现更高、更大的目标而不断优化改进。在机器中，最为重要的是文化和人，两者相辅相成，因为优秀的文化会吸引优秀的人，而优秀的人又会创造出优秀的文化。&lt;/p&gt;

&lt;p&gt;瑞·达利欧不断强调创意择优，创意择优由以下几个部分组成&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;创意择优 = 极度求真 + 极度透明 + 可信度加权的决策&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现实是一切决策的基础，透明可以保证所有人都可以得到相同的信息用于决策，再根据可信度加权来进行决策，这样可以大大提高决策的成功性。&lt;/p&gt;

&lt;hr/&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;445&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-4bd9263bbba1d9e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-4bd9263bbba1d9e1.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;445&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;233039&quot;/&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;打造良好文化是公司成功的首要因素，作者提出了若干原则用于帮助打造良好文化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.相信极度求真和极度透明&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;385&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-03655f99586e46af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-03655f99586e46af.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;385&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;231160&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;隐藏事实也许让人在短期内更开心，但从长远看来无法让他们变得更聪明、更令人信赖。只有让人们知道可以信赖我们所说的每句话，这才是真正的资产。极度求真和极度透明的工作方式需要人们来适应，因为这需要和人的天性作斗争，但是一旦实施并且良好执行，这样的工作效率是极高的。&lt;br/&gt;为人正直，同时也要求他人保持正直，若不想当面议论别人，背地里也不要说，要批评别人就当面指出来。让每个人都有权了解合理之事，不设定障碍，将不可透明的事项减到最少。公司很多时候会担心信息的泄露或者内部出现不合规的操作，极度透明的方式往往会降低做错事的风险，因为在极度透明的情况下，做坏事更难，发现事实、解决纠纷更容易。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.做有意义的工作，发展有意义的人际关系&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;349&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-f8b57040b8d5d917.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-f8b57040b8d5d917.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;349&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;200437&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;做有意义的工作，发展有意义的人际关系&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;798&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-de883b2b2f70a4ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-de883b2b2f70a4ef.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;798&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;255784&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;在极度求真和极度透明的情况下，更容易培养有意义的人际关系，做出更有意义的工作，这样最终会让你的人生获得成功。成功的工作和人际关系，需要做到忠于共同的使命。同时不要太单纯，在努力让尽可能多的员工从事有意义的工作，发展有意义的人际关系同时，要知道总会有一定比例不关心公司，甚至做出有损集体利益的事情。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.打造允许犯错，但不容忍罔顾教训、一错再错的文化&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;245&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-f7d0a88e16c6f600.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-f7d0a88e16c6f600.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;245&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;145331&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;要求人们敢于犯错，以便从错误中学习，这样就会快速成长，也不会再犯大错。瑞·达利欧建立错误日志记录所有犯下的错误，系统化的解决。不要为自己的错误而懊恼，要珍爱它！记住在经历痛苦的时候反思，记住痛苦+反思=进步。&lt;br/&gt;没人可以客观的看待自己，因此一个人犯下最严重的错误，就是不能直面自己的错误。作者发明了痛苦按钮的工具，当某人经历痛苦，就让他把经历什么样的痛苦记录下来，以后再利用反思所用的问题进行回顾反思。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.求取共识并坚持&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;346&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-07c03819a4d748cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-07c03819a4d748cb.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;346&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;171587&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;让一个机构有效运作，其员工必须在多个层面保持一致-从共同的使命、如何对待彼此，到追求成功，明确每个人的职责。但是需要理解人和人存在很大的不同，因此需要大家不要回避分歧和问题，直面且积极解决小的矛盾，才会更好的维持长久的良好关系。&lt;/p&gt;
&lt;p&gt;求取共识需要大家保持开放心态，能够换位思考，理解对方得出结论的思维方式，同时也需要果断作出决断。在机构中，通常保持同步的方式通常有三个维度：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;KPI：公司/部门核心数据指标，例如营收、利润、增长率等等&lt;/li&gt;
&lt;li&gt;OKR：团队的目标、关键产出和行为&lt;/li&gt;
&lt;li&gt;IDP：个人的发展计划，通常可以结合团队OKR制定&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;5.做决策时要从观点的可信度出发&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;275&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-4813d9bebad49ecb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-4813d9bebad49ecb.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;275&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;178636&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;创意择优=极度现实+极度透明+可信度加权的决策&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;瑞·达利欧极力推行创意择优的方式，创意择优的方式包括三个方面的内容，缺一不可：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;极度现实：现实是成功的基础，需要大家认清现实的情况，才可以做出正确的决策&lt;/li&gt;
&lt;li&gt;极度透明：信息的共享及其关键，这部分内容要求客观，帮助大家理解更多的细节&lt;/li&gt;
&lt;li&gt;可信度加权的决策：决策权不是在某个人，而是由一群人共同产出，但是每个人可信度需要基于过往决策效果历史进行加权。如果某人在这个方面经常能够得出正确的预测，那么他的可信度应该大大提高&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这是一种极致理性的民主决策方式，不同于大多数人认为的一人一票制的绝对民主，因为那样往往会产生乌合之众的效果，群体的智慧是会远远低于某些个人，如果一人一票就好导致决策的失败，似乎美国总统特朗普就是个例子:)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.解决分歧&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;290&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-f455a1f757dc0f8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-f455a1f757dc0f8f.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;290&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;185239&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;解决分歧最重要的是要坚守原则，并且不要避免冲突要快速解决重要的问题，一旦做出决定，每个人都应该支持它，尽管有些人可能仍然不同意。要记住进化是对整体有利的，而不是对于个人。&lt;/p&gt;

&lt;hr/&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;784&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-ad4dfa09f6cb63c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-ad4dfa09f6cb63c2.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;784&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;453408&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;现代企业尤其是脑力劳动密集型的企业，人毫无疑问是关键性的因素，因此用对人及其重要。按照一个人进入公司的阶段：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;招聘合适的人&lt;br/&gt;用极高的标准来招聘员工，记得Facebook的CEO扎克伯格说过他招人的标准就是看是否你原意汇报给他。因此永远不要降低招聘的标准，A类员工会招揽A类员工，但是B类员工就会招揽到C类或D类的员工。&lt;/li&gt;
&lt;li&gt;让合适的人做合适的事情&lt;br/&gt;每个人性格、擅长的事情也不一样，因此让每个人找到合适的工作，这样才能最大化的发挥他们的才能。&lt;/li&gt;
&lt;li&gt;持续发展每个人&lt;br/&gt;为每个人制定发展计划，帮助他们找到未来成长的机会和空间，不断提供反馈，并且需要准确的提供客观评价。严厉的爱是最重要的爱，需要感激每一位能够客观地指出你自身不足的人，因为人往往存在盲点而且自负，很难客观的评论自身的不足，如果有一位领导可以指出你的不足，那么应该感激而不是愤怒。&lt;/li&gt;
&lt;li&gt;淘汰不合格的员工&lt;br/&gt;对于不能胜任的员工，需要及时进行辅导，安排改进计划，如果还是不能改善需要及时淘汰。因为不能胜任的员工会影响到团队的整体氛围，导致整个团队变得平庸，这就是所谓需要清理老白兔的道理。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;800&quot; data-height=&quot;956&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7755754-84c55525323d7b70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-84c55525323d7b70.png&quot; data-original-width=&quot;800&quot; data-original-height=&quot;956&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;543701&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;将自己和机构想象成为一个机器，基于原则把方法系统化，在更好层面俯视整个的机器的运作，进行调整以期达到最终的目标。不断把结果和你的目标进行对照，找出机器的问题，进行诊断，解决问题。&lt;br/&gt;在管理方面要避免通过命令的方式强迫下属做事，要确保双方达成共识。通过可以明确量化指标来进行评估。对待问题上要迎难而上，并且在分析问题需要非常具体，这里采用“5 why”方式，多问几个为什么，这样可以找到最根本的原因，触及到最痛的地方，这样才能有效的解决问题。&lt;br/&gt;管理者需要记住通常会因为以下5个原因而失败或未能达成目标：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;他们离问题太远。&lt;/li&gt;
&lt;li&gt;他们在辨别低素质、低质量方面能力欠缺。&lt;/li&gt;
&lt;li&gt;他们已经感受不到问题的严重性，因为他们对问题已经习惯了。&lt;/li&gt;
&lt;li&gt;他们对工作太自负，不愿意承认解决不了自己的问题。&lt;/li&gt;
&lt;li&gt;他们对承认失败的不利后果感到害怕。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;&lt;p&gt;瑞·达利欧这本原则总结了他关于人生和工作的原则，更为重要的是他提供一种以原则为基础的生活和思考方式。这是瑞·达利欧原则系列的上半部分，期待他的关于经济和投资的下半部分。&lt;/p&gt;
</description>
<pubDate>Sat, 11 Aug 2018 15:40:00 +0000</pubDate>
<dc:creator>奶爸码农</dc:creator>
<og:description>做有意义的工作，发展有意义的人际关系-瑞·达利欧 上篇介绍了《原则》这本书里面的生活相关的原则，这里是传送门：上篇。这篇文章会继续介绍工作相关的原则。 工作原则概述 目标到结果，需要经过组织</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wdsunny/p/9461636.html</dc:identifier>
</item>
<item>
<title>Java多线程学习总结之---多线程基础 - Marksmanbat</title>
<link>http://www.cnblogs.com/-Marksman/p/9322589.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/-Marksman/p/9322589.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1、线程相关概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1）、线程与进程的区别&lt;/p&gt;
&lt;p&gt;　　　　线程是操作系统调度的最小单元，也叫轻量级进程，而进程是操作系统中的应用程序，在进程中可以创建多个线程。&lt;/p&gt;
&lt;p&gt;　　2）、上下文切换 &lt;/p&gt;
&lt;p&gt;　　　　我们知道现代处理器都是多核的，几核处理器只能同时处理几个线程，多线程执行程序看起来是同时进行，实际上是CPU在多个线程之间快速切换执行，这中间就涉及到上下问切换，所谓的上下文切换就是指一个线程T被分配的时间片用完了之后，线程的信息被保存起来，CPU执行另外的线程，再到CPU读取线程T的信息并继续执行T的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、线程实现方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1)、继承Thread类&lt;/p&gt;
&lt;p&gt;　　　　由于类的单继承性，使用这种方式实现就无法再去继承其他的线程，有局限，耦合度高。　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.run();
        System.out.println(&lt;/span&gt;&quot;我继承了Thread类...&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2)、实现Runnable接口&lt;/p&gt;
&lt;p&gt;　　　　大多数都用这种方式实现，很灵活，重写run()方法即可，run() 方法没有返回值。&lt;/p&gt;
&lt;p&gt;　　3)、实现Callable接口&lt;/p&gt;
&lt;p&gt;　　　　若是想获取到线程的执行结果，那就用这种方式，它和实现Runnable接口的区别是要重写call()方法，call()方式是有返回值的，返回的Object是任务的执行结果，可以用Future接口的实现类FutureTask来接收，并调用get()方法获取到执行结果。另外call()方法可抛出异常，而run()方法是不能抛出异常的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public class&lt;span&gt; Test {&lt;/span&gt;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Thread thread1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread();
        thread1.start();

        Thread thread2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyRunnable());
        thread2.start();

        Callable callable &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyCallable();
        FutureTask&lt;/span&gt;&amp;lt;String&amp;gt; future = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;&amp;gt;&lt;span&gt;(callable);
        ExecutorService executorService &lt;/span&gt;=&lt;span&gt; Executors.newSingleThreadExecutor();
        executorService.submit(future);
        System.out.println(future.get());
        executorService.shutdown();
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyRunnable &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            System.out.println(&lt;/span&gt;&quot;我实现了Runnable接口...&quot;&lt;span&gt;);
        }
    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyCallable &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Callable{

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;我实现了Callable接口...&quot;&lt;span&gt;;
        }
    }
}&lt;p&gt;执行结果：&lt;br/&gt;　　&lt;/p&gt;&lt;/span&gt;我继承了Thread类...&lt;br/&gt;我实现了Runnable接口...&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;   我实现了Callable接口...&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3、线程状态 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　根据jdk中Thread类的State内部类，线程有6种状态，下次面试官问你线程有几种状态，你可以很有底气的回答：6种，如下左图，右图是线程状态之间的转换。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401002/201807/1401002-20180721161258690-1096239145.png&quot; alt=&quot;&quot; width=&quot;247&quot; height=&quot;330&quot;/&gt;                  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401002/201807/1401002-20180721172729480-1627719319.png&quot; alt=&quot;&quot; width=&quot;538&quot; height=&quot;329&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这里注意：线程在等待进入synchronzed方法或者synchronized块时的线程状态时BLOCKED，而在等待进入lock锁时的状态是WAITING或者TIME_WAITING，因为lock是用LockSupport实现的（源码还没研究）。&lt;/p&gt;
&lt;p&gt; 测试如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyService {

   public static synchronized void serviceMethod1(){&lt;br/&gt;　　　　try{&lt;br/&gt;　　　　　　&lt;/span&gt;System.out.println(Thread.currentThread().getName+&quot;进入了业务方法&quot;);&lt;br/&gt;　　　　　　Thread.sleep(millis: 1000);&lt;br/&gt;&lt;span&gt;　　　　} catch (Execption e){&lt;br/&gt;　　　　　　e.printStackTrace();&lt;br/&gt;　　　　}&lt;/span&gt;&lt;span&gt;　　&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　}&lt;/span&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; serviceMethod2(){&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;span&gt;        ReentrantLock reentrantLock &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
        reentrantLock.lock();
        System.out.println(Thread.currentThread().getName()&lt;/span&gt;+&quot;进入了业务方法&quot;&lt;span&gt;);&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;　　　　 try {&lt;br/&gt;　　　　　　Thread.sleep(1000);&lt;br/&gt;　　　　} catch (InterruptedException e) {&lt;br/&gt;　　　　　　e.printStackTrace();&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　　　}&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;span&gt;　　　　　　reentrantLock.unlock();&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;span&gt;　　　　}&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;span&gt;}&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyThread1 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        MyService.serviceMethod1();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyThread2 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        MyService.serviceMethod1();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyThread3 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        MyService.serviceMethod2();
}
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyThread4 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        MyService.serviceMethod2();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadStatusTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        test1();
        test2();
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){
        MyThread1 t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread1();
        t1.setName(&lt;/span&gt;&quot;a&quot;&lt;span&gt;);
        t1.start();

        MyThread2 t2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread2();
        t2.setName(&lt;/span&gt;&quot;b&quot;&lt;span&gt;);
        t2.start();

        System.out.println(&lt;/span&gt;&quot;t2的状态:&quot;+&lt;span&gt;t2.getState());
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2(){
        MyThread3 t3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread3();
        t3.setName(&lt;/span&gt;&quot;a&quot;&lt;span&gt;);
        t3.start();

        MyThread4 t4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread4();
        t4.setName(&lt;/span&gt;&quot;b&quot;&lt;span&gt;);
        t4.start();

        System.out.println(&lt;/span&gt;&quot;t4的状态:&quot;+&lt;span&gt;t4.getState());
    }
}&lt;p&gt;test1() 运行结果： &lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;　　a进入了业务方法&lt;br/&gt;　　t2的状态:RUNNABLE&lt;br/&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;　　b进入了业务方法&lt;p&gt;test2() 运行结果：&lt;br/&gt;&lt;/p&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　a进入了业务方法&lt;br/&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　t4的状态:RUNNABLE&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　b进入了业务方法&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4、常用方法 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1）、start() 启动线程的一种方式，线程调用start()方法后由NEW状态变为RUNNABLE状态中的READY状态，等待CPU分配时间片，它是Thread类的方法；&lt;/p&gt;
&lt;p&gt;　　2）、 run() 所需实现的逻辑写在run方法里，线程获得时间片后由READY状态变为RUNNING，并自动调用run()方法，当然run()方法也可以直接调用，那它就是普通方法，和线程无关；&lt;/p&gt;
&lt;p&gt;　　3）、sleep(...) 线程由RUNNABLE状态变为TIMED_WAITING状态，调用此方法会抛出InterruptedException异常，线程自己拥有系统资源，并等待时间到了，自己醒来，这是和wait()方法的主要区别；&lt;/p&gt;
&lt;p&gt;　　4）、wait()  notify()  notifyAll() 这三个都是Object类的方法，它们是配合使用的，调用wait()方法的线程状态由RUNNABLE中的RUNNING变为WAITING状态，并且此对象是不占有系统资源的，当调用notify()或notifyAll() 方法后线程又进入RUNNABLE中的READY状态，等待获取CPU时间片；&lt;/p&gt;
&lt;p&gt;　　5）、join(...) 等待线程对象销毁，线程状态由RUNNABLE变为WAITING或者TIMED_WAITING；&lt;/p&gt;
&lt;p&gt;　　6）、interrupt() 中断线程，线程状态变为TERMINATED；&lt;/p&gt;
&lt;p&gt;　　7）、yield() ，线程状态由RUNNING变为READY，即由运行中变为就绪状态，向处理器表示自己愿意放弃当前CPU资源（让出自己的执行时间），但放弃时间不确定，有可能刚刚放弃，马上又获得CPU时间片，所有此方法并不能保证其它线程一定执行，调用此方法的线程一定不执行，而是看CPU是否分配了时间片，并且它只会让优先级不低于当前线程的线程执行，优先级比它低的是没有机会执行的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、线程的优先级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　线程优先级为1-10（由低到高），默认优先级是5，优先级高的线程分配的时间片的数量要低于优先级低的，我们可以调用Thread.setPriority(int) 方法来为线程设置优先级，在设置线程优先级时应注意，争对频繁阻塞的，如休眠、IO、数据库等任务的线程应设置较高的优先级，对于偏重计算的，如需要较多的CPU时间或者偏运算的线程则应设置较低的优先级，确保处理器不会被独占。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、线程间的通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1）、&lt;em id=&quot;__mceDel&quot;&gt;volatile  synchronized&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　这两个关键字可以实现线程间的通讯，我们知道每个线程都有自己的工作内存，并且它们还有共享内存，线程对一个变量修改时会先从共享内存中读取这个变量到自己私有的工作内存中，若是一个普通变量则修改后刷新到主内存中的时机时随机的，若是volatile变量（可见性和有序性），这时另一个线程来读这个变量，则它会被立即刷新到主内存中去，让后面读取的线程能看到变化，这就实现了两个线程之间的通信。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1401002/201808/1401002-20180808174158273-632870215.png&quot; alt=&quot;&quot; width=&quot;318&quot; height=&quot;202&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　synchronized实现线程之间的同步，B线程必须等到A线程释放锁才能获得相应的资源，这是线程之间的一种通信方式。&lt;/p&gt;
&lt;p&gt;　　2）、等待通知机制 wait()  notify()  notifyAll()&lt;/p&gt;
&lt;p&gt;　　一个过程从一个线程开始，在另一个线程结束，前者是生产者，后者是消费者，生成者完成生产，通知消费者去消费，完成二者之间的通信。&lt;/p&gt;
&lt;p&gt;　　等待通知的相关方法有&lt;/p&gt;
&lt;p&gt;　　　　wait()：调用该方法的线程进入WAITING状态，只有被其他线程通知或者被中断才会返回，调用该方法后，会释放对象的锁；&lt;/p&gt;
&lt;p&gt;　　　　wait(long)：超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回；&lt;/p&gt;
&lt;p&gt;　　　　wait(long,int)：超时时间为long毫秒+int纳秒；&lt;/p&gt;
&lt;p&gt;　　　　notify()：通知一个在对象等待的线程，使其从wait()方法返回，而返回的前提时该线程获取了对象的锁；&lt;/p&gt;
&lt;p&gt;　　　　notifyAll()：通知所有等待在该对象上的线程。&lt;/p&gt;
&lt;p&gt;　　以上方法都来自java.lang.Object类中，所以只要是对象就可以调用它们。&lt;/p&gt;
&lt;p&gt;　　　　wait()、notify()和notifyAll()调用时需要注意：&lt;/p&gt;
&lt;p&gt;　　　　a、使用wait()、notify()和notifyAll()时需要先对调用对象加锁；&lt;/p&gt;
&lt;p&gt;　　　　b、调用wait()方法后，线程状态由RUNNING变为WAITING,并将当前线程放置到对象的等待队列；&lt;/p&gt;
&lt;p&gt;　　　　c、notify()或者notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或者notifyAll()的线程释放锁之后，等待线程才有机会从wait()返回；&lt;/p&gt;
&lt;p&gt;　　　　d、notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法将等待队列中所有的线程全部移到同步队列，被移动的线程状&lt;/p&gt;
&lt;p&gt;　　　　　　态由WAITING变为BLOCKED；&lt;/p&gt;
&lt;p&gt;　　　　e、从wait()方法返回的前提是获得了调用对象的锁。&lt;/p&gt;
&lt;p&gt;　　A线程调用wait() 方法会释放持有的对象监视器，进入等待状态，等B线程执行完了后，调用notify()或者notifyAll() 方法唤醒A线程&lt;/p&gt;
&lt;p&gt;　　3）、管道输入、输出流&lt;/p&gt;
&lt;p&gt;　　　　管道流专门用于线程之间的通信，和普通字符字节流的区别是它们操作的是内存而不是硬盘。&lt;/p&gt;
&lt;p&gt;　　　　主要有四种实现：字节流：PipedOutputStream、PipedInputStream&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　字符流：&lt;em id=&quot;__mceDel&quot;&gt;PipedWriter、PipedReader &lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 　   4）、join(...)&lt;/p&gt;
&lt;p&gt;　　　　当前存在线程A、B，若A执行了join()方法，意思就是：当前线程A等待B线程执行完成之后，才继续执行，即完成了A、B间的通信。&lt;/p&gt;
&lt;p&gt;　　5）、ThreadLocal&lt;/p&gt;
&lt;p&gt;　　　　ThreadLocal，即线程变量，是一个以ThreadLocal对象为键，任意对象为值的存储结构。可以通过set(T)方法来设置一个值，在当前线程下通过get()方法获取原先获取的值。&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;　　下面摘抄《Java并发编程的艺术》中的一段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Profiler {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final ThreadLocal&amp;lt;Long&amp;gt; TIME_THREADLOCAL = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;Long&amp;gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Long initialValue(){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; System.currentTimeMillis();
        }
    };
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final &lt;span&gt;void&lt;/span&gt;&lt;span&gt; begin(){
        TIME_THREADLOCAL.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(System.currentTimeMillis());
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final &lt;span&gt;long&lt;/span&gt;&lt;span&gt; end(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; System.currentTimeMillis() - TIME_THREADLOCAL.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;();
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws InterruptedException {
        Profiler.begin();
        TimeUnit.SECONDS.sleep(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cost: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+Profiler.end() +&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; mills&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt;);
    }
}&lt;p&gt;运行结果：&lt;br/&gt;Cost: 1005 mills&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 参考资料：&lt;em id=&quot;__mceDel&quot;&gt;《Java并发编程的艺术》&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　最后，如有写的不对或不好的地方，请指出，谢谢！&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 11 Aug 2018 15:38:00 +0000</pubDate>
<dc:creator>Marksmanbat</dc:creator>
<og:description>1、线程相关概念 1）、线程与进程的区别 线程是操作系统调度的最小单元，也叫轻量级进程，而进程是操作系统中的应用程序，在进程中可以创建多个线程。 2）、上下文切换 我们知道现代处理器都是多核的，几核处</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/-Marksman/p/9322589.html</dc:identifier>
</item>
<item>
<title>安装window下的redis，redis可视化管理工具（Redis Desktop Manager）安装，基础使用，实例化项目 - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/9090819.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/9090819.html</guid>
<description>&lt;p&gt;以下包括内容：&lt;/p&gt;
&lt;p&gt;一、redis下载安装，启动&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;二、Redis可视化管理工具（Redis Desktop Manager）安装&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;三、实例化项目&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、redis下载安装，启动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，redis官方下载地址：&lt;a href=&quot;https://redis.io/download&quot; target=&quot;_blank&quot;&gt;https://redis.io/download&lt;/a&gt;，redis 64位下载地址：&lt;a href=&quot;https://github.com/ServiceStack/redis-windows&quot; target=&quot;_blank&quot;&gt;https://github.com/ServiceStack/redis-windows&lt;/a&gt;，本人测试使用的是redis-64.3.0.503版本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、解压redis-64.3.0.503.zip，解压后的文件结构如下：&lt;/strong&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20171219090318125?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjM0MzI5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、修改redis.windows.conf文件，设置maxmemory 大小 &lt;/strong&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20171219091440982?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjM0MzI5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;设置redis密码 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://img-blog.csdn.net/20171219091155063?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjM0MzI5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、启动redis:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;redis-server.exe redis.windows.conf&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201805/900740-20180525213857253-1004007223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、测试，成功安装：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201805/900740-20180525214514046-1613095057.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 6、将redis加入到windows的服务中（都是两个-）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-server --service-install redis.windows.conf --loglevel verbose
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201805/900740-20180525215107622-1712402627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、安装成功&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201805/900740-20180525215036141-411132990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8、但是安装好之后，Redis并没有启动，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）启动命令如下：&lt;/p&gt;
&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;start&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;（2）停止命令：&lt;/p&gt;
&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;stop&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;（3）还可以安装多个实例&lt;/p&gt;
&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;install &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;name redisService1 &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;port &lt;span class=&quot;lit&quot;&gt;10001&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;L1&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;start &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;name redisService1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;L2&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;install &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;name redisService2 &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;port &lt;span class=&quot;lit&quot;&gt;10002&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;L3&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;start &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;name redisService2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;L4&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;install &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;name redisService3 &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;port &lt;span class=&quot;lit&quot;&gt;10003&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;L5&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;start &lt;span class=&quot;pun&quot;&gt;–&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;name redisService3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;（4）卸载命令：&lt;/p&gt;
&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;span class=&quot;pln&quot;&gt;redis&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;server &lt;span class=&quot;pun&quot;&gt;--&lt;span class=&quot;pln&quot;&gt;service&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;uninstall&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;二、Redis可视化管理工具（Redis Desktop Manager）安装&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、安装过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201805/900740-20180529223732249-856798621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201805/900740-20180529223825483-1208704894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201805/900740-20180529223913379-501197861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201805/900740-20180529224107425-1893009414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、基本操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先确定redis服务启动没有：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201808/900740-20180811230500101-1668058419.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;出现这样的就好了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 1、新建连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;confluence-embedded-file-wrapper&quot;&gt;自己起一个redis名字，随便取，输入redis的连接服务器密码，保存就好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201808/900740-20180811231849716-58935052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;自己之前设置的myKey，userInfo，username的值&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201808/900740-20180811230815743-32462400.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一条的值是，自己singlePointSystem系统（&lt;a href=&quot;https://github.com/saucxs/PointSingleSystem&quot; target=&quot;_blank&quot;&gt;https://github.com/saucxs/PointSingleSystem&lt;/a&gt;）的登录的时候，把成功的登录的结果存到redis服务器中，这样就不用每一次都从服务器里查询是否登录。&lt;/p&gt;
&lt;p&gt;样例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/900740/201808/900740-20180811234256644-1872287861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 11 Aug 2018 15:22:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<og:description>以下包括内容： 一、redis下载安装，启动 二、Redis可视化管理工具（Redis Desktop Manager）安装 三、实例化项目 一、redis下载安装，启动 1，redis官方下载地址：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/9090819.html</dc:identifier>
</item>
<item>
<title>WebGL绘制有端头的线 - 木的树</title>
<link>http://www.cnblogs.com/dojo-lzz/p/9461506.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dojo-lzz/p/9461506.html</guid>
<description>&lt;p&gt;　　关于WebGL绘制线原理不明白的小伙伴，可以看看我之前的文章&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/dojo-lzz/p/9219290.html&quot;&gt;WebGL绘制有宽度的线&lt;/a&gt;。这一篇我们主要来介绍端头的绘制，先看效果图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201808/412020-20180811221330458-699605154.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　端头一般被称为lineCap，主要有以下三种形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201808/412020-20180811221457829-1905375009.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　butt最简单等于没有端头，square一般是多出lineWidth/2的长度，round是一个以lineWidth/2为半径的圆。一般情况下绘制lineCap的思路都是添加额外的三角形，如一些开元库或者mapbox的方法，一般来说mapbox的方法已经可以了，但是我还是感觉顶点太多，甚至对square的情况都不愿意在增加两个顶点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201808/412020-20180811221751424-1409508421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　方法总是自己去探索的，在绘制宽度线中，我已经总结了自己的一套理论，将线距离映射成uv坐标的思路来绘制一些线的效果，那么在这里仍然沿着这种思路去思考。&lt;/p&gt;
&lt;p&gt;　　对于square来说只要在绘制顶点的时候，在线的开头和结尾分别做一定的偏移即可。对于round我们可以在suqare的基础上，在片元着色器中做一些判断，距离中心点距离大于lineWidth/2的像素全部抛弃掉。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201808/412020-20180811222814911-1778992368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　所以对于线起点和终点处顶点的位置在上一篇文章的基础上，做了沿着线方向的偏移&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; flag -1代表线起点, 1代表线终点；同时为了防止一些精度问题，同样使用纹理值来做一些判断，让真正的起点和终点做偏移，防止其中的一些小碎线段影响结果&lt;/span&gt;
'    vec2 vertical_offset = normal * lineWidth * realSide * 0.5;'&lt;span&gt;,
&lt;/span&gt;'    vec2 horizontal_offset = vec2(0.0, 0.0);'&lt;span&gt;,
&lt;/span&gt;'    if (flag == -1.0 &amp;amp;&amp;amp; (uv.x == 0.0 || uv.x == 1.0)) {'&lt;span&gt;,
&lt;/span&gt;'        horizontal_offset = -dir * lineWidth * 0.5;'&lt;span&gt;,
&lt;/span&gt;'    } else if (flag == 1.0 &amp;amp;&amp;amp; (uv.x == 0.0 || uv.x == 1.0)) {'&lt;span&gt;,
&lt;/span&gt;'        horizontal_offset = dir * lineWidth * 0.5;'&lt;span&gt;,
&lt;/span&gt;'    }'&lt;span&gt;,
&lt;/span&gt;'    if (useLineCap &amp;lt;= 0.0) {'&lt;span&gt;,
&lt;/span&gt;'        horizontal_offset.xy = vec2(0.0, 0.0);'&lt;span&gt;,
&lt;/span&gt;'        vUV.x = uv.x;'&lt;span&gt;,
&lt;/span&gt;'    }'&lt;span&gt;,
&lt;/span&gt;'    vec2 pos = currentP + vertical_offset + horizontal_offset;'&lt;span&gt;,
&lt;/span&gt;'    gl_Position = unproject(pos, finalPosition.z, finalPosition.w);',
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样的话我们就能绘制出square类型的lineCap。但是对于round仅仅这样做还不行，还需要在片元着色器中根据中心点做一次剔除。那么问题来了，经过偏移后如何知道圆心点的位置，在来根据像素距离来进行剔除。这时候就轮到上篇文章利用纹理坐标来表示线长度的思路了，上一篇中我们把路线长度映射成从0-1的uv坐标，那么对于端头来说，我们可以把超出的那一半线宽的像素映射成纹理坐标，可以想象这部分长度对于起点来说等于负的线长度，对应的纹理坐标就是负的纹理坐标；对于终点来说多出的这部分像素等于增加了的线长度，那么对应纹理坐标就是超过1的部分。那么接下来的问题就是如何把线上的像素长度对应于线的长度等于把像素与3d世界中的单位进行映射。&lt;/p&gt;
&lt;p&gt;　　如果对投影矩阵不是很了解的同学，最好看看我的这篇文章&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl02_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/dojo-lzz/p/7223364.html&quot;&gt;webgl开发第一道坎——矩阵与坐标变换&lt;/a&gt;，这里我们需要用到投影矩阵的中的元素&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201808/412020-20180811224510634-2113494509.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　resolution.x代表canvas显示元素的宽度，这里恐怕有些地方不太好理解。n其实是代表相机的近平面，我们先假设为1；那么pixelWidthRatio表示像素与3d单位的一个比值的一半。后面我们先暂时也假设finalPosition.w的值也为一，那么最终vPixelWidth的值表示每像素代表多少3d单位。但是由于视锥体的投影变换并不是线性的，所以这样得到的vPixelWidth并不适用视锥体中的所有地方。这时候我们回来看pixelWidthRatio有一个分母n代表近平面，finalPosition.w代表投影后的点距离相机坐标中的z值距离。w/n这里是想用线性来补充一部分非线性变换带来的影响，让vPixelWidth表示每像素代表多少3d单位这个结果尽量的准确。实际效果也确实可以达到预期。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
'    float aspect = resolution.x / resolution.y;', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 屏幕宽高比&lt;/span&gt;
'     float pixelWidthRatio = 1. / (resolution.x * projectionMatrix[0][0]);', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (r-l)/(2n*Width)&lt;/span&gt;
''&lt;span&gt;,
&lt;/span&gt;'    vColor = vec4( color, opacity );'&lt;span&gt;,
&lt;/span&gt;'    vUV = uv;'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'    vec4 finalPosition = transform(position);'&lt;span&gt;,
&lt;/span&gt;'    vec4 prevPos = transform(previous);'&lt;span&gt;,
&lt;/span&gt;'    vec4 nextPos = transform(next);'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'    vec2 currentP = project(finalPosition);'&lt;span&gt;,
&lt;/span&gt;'    vec2 prevP = project(prevPos);'&lt;span&gt;,
&lt;/span&gt;'    vec2 nextP = project(nextPos);'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,&lt;/span&gt;'    float pixelWidth = finalPosition.w * pixelWidthRatio;'&lt;span&gt;,
&lt;/span&gt;'    vPixelWidth = pixelWidth * 2.0;',
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在我们可以将端头多出的一半线宽的像素距离转化成线的距离，同时在转化成纹理单位。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
'    vec2 horizontal_offset = vec2(0.0, 0.0);'&lt;span&gt;,
&lt;/span&gt;'    if (flag == -1.0 &amp;amp;&amp;amp; (uv.x == 0.0 || uv.x == 1.0)) {'&lt;span&gt;,
&lt;/span&gt;'        horizontal_offset = -dir * lineWidth * 0.5;'&lt;span&gt;,
&lt;/span&gt;'        float radio = length(horizontal_offset) * vPixelWidth / repeat.x;',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; repeat.x代表线的距离长度&lt;/span&gt;
'        vUV.x -= radio;'&lt;span&gt;,
&lt;/span&gt;'    } else if (flag == 1.0 &amp;amp;&amp;amp; (uv.x == 0.0 || uv.x == 1.0)) {'&lt;span&gt;,
&lt;/span&gt;'        horizontal_offset = dir * lineWidth * 0.5;'&lt;span&gt;,
&lt;/span&gt;'        float radio = length(horizontal_offset) * vPixelWidth / repeat.x;'&lt;span&gt;,
&lt;/span&gt;'        vUV.x += radio;'&lt;span&gt;,
&lt;/span&gt;'    }',
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来我们可以在片元着色器中进行剔除工作。这里我们需要做几步工作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;纹理坐标转换成线的距离长度&lt;/li&gt;
&lt;li&gt;线的距离长度转换成像素单位&lt;/li&gt;
&lt;li&gt;对大于lineWidth/2长度的像素进行剔除&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
'varying float vPixelWidth;'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'void main() {'&lt;span&gt;,
&lt;/span&gt;''&lt;span&gt;,
&lt;/span&gt;'  vec4 c = vColor;'&lt;span&gt;,
&lt;/span&gt;'  float uvx = vUV.x * repeat.x;'&lt;span&gt;,
&lt;/span&gt;'  vec2 coord = vec2(0.0, 0.0);'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; '  float horizontal = 0.0;',&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; '  float vertical = 0.0;',&lt;/span&gt;
'  if (uvx &amp;lt; 0.0) {'&lt;span&gt;,
&lt;/span&gt;'    coord.x = abs(uvx) / vPixelWidth;'&lt;span&gt;,
&lt;/span&gt;'    coord.y = abs(vUV.y - 0.5) * lineWidth;'&lt;span&gt;,
&lt;/span&gt;'  } else if (uvx &amp;gt; repeat.x) {'&lt;span&gt;,
&lt;/span&gt;'    coord.x = abs(uvx - repeat.x) / vPixelWidth;'&lt;span&gt;,
&lt;/span&gt;'    coord.y = abs(vUV.y - 0.5) * lineWidth;'&lt;span&gt;,
&lt;/span&gt;'  }'&lt;span&gt;,
&lt;/span&gt;'  if (length(coord) &amp;gt; lineWidth * 0.5) {c.a = 0.0;}'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; '    float uvx = vUV.x * repeat.x;',&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; '    if (uvx &amp;lt; 0.0 || uvx &amp;gt; repeat.x) {c.x=1.0;c.y=0.0;c.z=0.0;c.a = 1.0;}',&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; '     if( c.a &amp;lt; alphaTest ) c.a = 0.0;',&lt;/span&gt;

'    gl_FragColor = c;'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; '     gl_FragColor.a *= step(vCounters,visibility);',&lt;/span&gt;
'}' ];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里我们需要用到varying变量对vPixelWidth进行差值。最终我们绘制出round的lineCap效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201808/412020-20180811230450737-1463888976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 11 Aug 2018 15:11:00 +0000</pubDate>
<dc:creator>木的树</dc:creator>
<og:description>关于WebGL绘制线原理不明白的小伙伴，可以看看我之前的文章WebGL绘制有宽度的线。这一篇我们主要来介绍端头的绘制，先看效果图。 端头一般被称为lineCap，主要有以下三种形式： butt最简单等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dojo-lzz/p/9461506.html</dc:identifier>
</item>
<item>
<title>DirectX11 With Windows SDK--16 利用几何着色器可选的流输出阶段帮助绘制多种分形 - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/9461074.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/9461074.html</guid>
<description>&lt;p&gt;在上一章，我们知道了如何使用几何着色器来重新组装图元，比如从一个三角形分裂成三个三角形。但是为了实现更高阶的分形，我们必须要从几何着色器拿到输出的顶点。这里我们可以使用可选的流输出阶段来拿到顶点集合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意: 本章末尾有大量的GIF动图！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;现在我们知道GPU可以写入纹理(textures)，例如深度/模板缓冲区以及后备缓冲区。当然，我们也可以通过渲染管线的流输出阶段让GPU将几何着色器输出的顶点集合写入到指定的顶点缓冲区(vertex buffer)。除此之外，我们还能够指定不进行光栅化以及后续的所有阶段，仅让顶点数据经过流输出阶段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180810093044735-1752743030.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在几何着色器中，最多四个流输出对象可以被设置，即几何着色器的入口函数中只允许设置四个流输出对象的参数。当多个流输出对象存在时，它们必须都要为&lt;code&gt;PointStream&lt;/code&gt;类模板，但允许模板参数不同。输出的顶点回流到顶点缓冲区后可以再次进行一遍新的渲染管线流程。&lt;/p&gt;
&lt;p&gt;上一章也提到，几何着色器的单次调用不能产出超过1024个标量。因此分配给所有流输出对象的标量总和不能超过1024。比如现在我有2个流输出对象，它们的结构体相同，容纳512个标量，那最多仅允许输出2个这样的顶点来分配给这2个流输出对象。&lt;/p&gt;

&lt;h2 id=&quot;id3d11devicecontextsosettargets方法--绑定流输出对应用于接收数据的顶点缓冲区&quot;&gt;ID3D11DeviceContext::SOSetTargets方法--绑定流输出对应用于接收数据的顶点缓冲区&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void ID3D11DeviceContext::SOSetTargets(
  UINT         NumBuffers,              // [In]顶点缓冲区数目
  ID3D11Buffer * const *ppSOTargets,    // [In]顶点缓冲区数组
  const UINT   *pOffsets                // [In]一个数组包含对每个顶点缓冲区的字节偏移量
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法多允许设置4个顶点缓冲区。&lt;/p&gt;
&lt;p&gt;每个要绑定到流输出阶段的缓冲区资源必须要在创建的时候额外设置&lt;code&gt;D3D11_BIND_STREAM_OUTPUT&lt;/code&gt;绑定标签。&lt;/p&gt;
&lt;p&gt;若偏移值设为-1，则会引起流输出缓冲区被追加到最后一个缓冲区的后面&lt;/p&gt;
&lt;p&gt;顶点缓冲区绑定到流输出阶段的输出槽0操作如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;UINT offset = 0;
md3dImmediateContext-&amp;gt;SOSetTargets(1, vertexBufferOut.GetAddressOf(), &amp;amp;offset);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们需要恢复默认的状态，则可以这样调用：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;ID3D11Buffer* nullBuffer = nullptr;
UINT offset = 0;
md3dImmediateContext-&amp;gt;SOSetTargets(1, &amp;amp;nullBuffer, &amp;amp;offset);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意: 如果使用的是当前绑定到输入装配阶段的顶点缓冲区，则绑定会失效。因为顶点缓冲区不可以同时被绑定到输入装配阶段和流输出阶段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为后续我们是将每一阶输出的顶点都保存下来，即便不需要交换顶点缓冲区，但也有可能出现同时绑定输入/输出的情况。一种合理的绑定顺序如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 先恢复流输出默认设置，防止顶点缓冲区同时绑定在输入和输出阶段
UINT stride = sizeof(VertexPosColor);
UINT offset = 0;
ID3D11Buffer * nullBuffer = nullptr;
md3dImmediateContext-&amp;gt;SOSetTargets(1, &amp;amp;nullBuffer, &amp;amp;offset);
// ...
md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosColorLayout.Get());
// ...
md3dImmediateContext-&amp;gt;SOSetTargets(1, vertexBufferOut.GetAddressOf(), &amp;amp;offset);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当渲染管线完成一次流输出后，我们就可以用下面的方法来获取绑定在流输出阶段上的顶点缓冲区（当然你本身持有该缓冲区的指针的话就不需要了）&lt;/p&gt;
&lt;h2 id=&quot;id3d11devicecontextsogettargets方法--获取绑定在流输出阶段的顶点缓冲区&quot;&gt;ID3D11DeviceContext::SOGetTargets方法--获取绑定在流输出阶段的顶点缓冲区&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void ID3D11DeviceContext::SOGetTargets(
  UINT         NumBuffers,          // [In]缓冲区数目
  ID3D11Buffer **ppSOTargets        // [Out]获取绑定流输出阶段的顶点缓冲区
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出的顶点缓冲区引用数会加1，最好是能够使用&lt;code&gt;ComPtr&lt;/code&gt;来承接顶点缓冲区，否则就要在结束的时候手工调用&lt;code&gt;Release&lt;/code&gt;方法，若忘记调用则会引发内存泄漏。&lt;/p&gt;
&lt;h2 id=&quot;id3d11devicecreategeometryshaderwithstreamoutput方法--创建带流输出阶段的几何着色器&quot;&gt;ID3D11Device::CreateGeometryShaderWithStreamOutput方法--创建带流输出阶段的几何着色器&lt;/h2&gt;
&lt;p&gt;接下来我们需要指定数据会流向哪个输出槽，首先我们需要填充结构体&lt;code&gt;D3D11_SO_DECLARATION_ENTRY&lt;/code&gt;，结构体声明如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;typedef struct D3D11_SO_DECLARATION_ENTRY {
  UINT   Stream;            // 输出流索引，从0开始
  LPCSTR SemanticName;      // 语义名
  UINT   SemanticIndex;     // 语义索引
  BYTE   StartComponent;    // 从第几个分量(xyzw)开始,只能取0-3
  BYTE   ComponentCount;    // 分量的输出数目，只能取1-4
  BYTE   OutputSlot;        // 输出槽索引，只能取0-3
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，语义名&lt;code&gt;SemanticName&lt;/code&gt;用于指定在几何着色器的流输出对象对应的结构体中该语义描述的成员，然后用语义索引&lt;code&gt;SemanticIndex&lt;/code&gt;指定存在同名语义下用索引值标记的唯一成员。&lt;/p&gt;
&lt;p&gt;然后&lt;code&gt;StartComponent&lt;/code&gt;和&lt;code&gt;ComponentCount&lt;/code&gt;用于控制该向量需要输出哪些分量。若&lt;code&gt;StartComponent&lt;/code&gt;为1，&lt;code&gt;ComponentCount&lt;/code&gt;为2，则输出的分量为&lt;code&gt;(y, z)&lt;/code&gt;，而要输出全部分量，则指定&lt;code&gt;StartCompnent&lt;/code&gt;为0, &lt;code&gt;ComponentCount&lt;/code&gt;为4.&lt;/p&gt;
&lt;p&gt;输出槽索引&lt;code&gt;OutputSlot&lt;/code&gt;用于指定选择绑定流输出的缓冲区数组中的某一元素。&lt;/p&gt;
&lt;p&gt;由于这里一个结构体只能指定某个输出流中的某一向量，所以通常我们需要像顶点输入布局那样传递一个数组来取出组合成特定顶点。&lt;/p&gt;
&lt;p&gt;比如说现在顶点着色器输入的顶点和流输出的顶点是一致的:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct VertexPosColor
{
    DirectX::XMFLOAT3 pos;
    DirectX::XMFLOAT4 color;
    static const D3D11_INPUT_ELEMENT_DESC inputLayout[2];
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入布局描述如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const D3D11_INPUT_ELEMENT_DESC VertexPosColor::inputLayout[2] = {
    { &quot;POSITION&quot;, 0, DXGI_FORMAT_R32G32B32_FLOAT, 0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
    { &quot;COLOR&quot;, 0, DXGI_FORMAT_R32G32B32A32_FLOAT, 0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;HLSL中的结构体如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct VertexPosColor
{
    float3 PosL : POSITION;
    float4 Color : COLOR;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;流输出的入口描述如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const D3D11_SO_DECLARATION_ENTRY posColorLayout[2] = {
    { 0, &quot;POSITION&quot;, 0, 0, 3, 0 },
    { 0, &quot;COLOR&quot;, 0, 0, 4, 0 }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里对应的是索引为0的流输出对象，输出给绑定在索引为0的输出槽的顶点缓冲区，先输出语义为POSITION的向量中的xyz分量，然后输出COLOR整个向量。这样一个输出的顶点就和原来的顶点一致了。&lt;/p&gt;
&lt;p&gt;接下来给出&lt;code&gt;ID3D11Device::CreateGeometryShaderWithStreamOutput&lt;/code&gt;方法的原型：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HRESULT ID3D11Device::CreateGeometryShaderWithStreamOutput(
  const void                       *pShaderBytecode,    // [In]编译好的着色器字节码
  SIZE_T                           BytecodeLength,      // [In]字节码长度
  const D3D11_SO_DECLARATION_ENTRY *pSODeclaration,     // [In]D3D11_SO_DECLARATION_ENTRY的数组
  UINT                             NumEntries,          // [In]入口总数
  const UINT                       *pBufferStrides,     // [In]一个数组包含了每个绑定到流输出的缓冲区中顶点字节大小
  UINT                             NumStrides,          // [In]上面数组的元素数目
  UINT                             RasterizedStream,    // [In]按索引指定哪个流输出对象用于传递到光栅化阶段
  ID3D11ClassLinkage               *pClassLinkage,      // [In]忽略
  ID3D11GeometryShader             **ppGeometryShader   // [Out]创建好的几何着色器
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不需要有流输出对象提供数据给光栅化阶段，则&lt;code&gt;RasterizedStream&lt;/code&gt;应当指定为&lt;code&gt;D3D11_SO_NO_RASTERIZED_STREAM&lt;/code&gt;。即便某一流输出对象传递了数据给光栅化阶段，它仍可以提供数据给某一绑定的缓冲区。&lt;/p&gt;
&lt;p&gt;当该着色器被绑定到渲染管线上，流输出阶段就会被激活。然后当渲染管线开始执行的时候，任何传递给几何着色器中的流输出对象的数据，都会基于语义名和语义索引尝试匹配输出布局。一旦发现有匹配的语义，该数据就会流向对应的缓冲区来创建完整的输出顶点集。&lt;/p&gt;
&lt;p&gt;下面是一个调用的例子:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const D3D11_SO_DECLARATION_ENTRY posColorLayout[2] = {
    { 0, &quot;POSITION&quot;, 0, 0, 3, 0 },
    { 0, &quot;COLOR&quot;, 0, 0, 4, 0 }
};

HR(device-&amp;gt;CreateGeometryShaderWithStreamOutput(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), posColorLayout, ARRAYSIZE(posColorLayout),
    &amp;amp;stridePosColor, 1, D3D11_SO_NO_RASTERIZED_STREAM, nullptr, mTriangleSOGS.GetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;由于现在的着色器多到令人发指，而且有没有很好的办法归类整合，故在下面用一张表列出所有绘制流程用到的着色器hlsl文件名称:&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;通过流输出得到分裂的三角形&lt;/td&gt;
&lt;td&gt;TriangleSO_VS&lt;/td&gt;
&lt;td&gt;TriangleSO_GS&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;通过流输出得到分形雪花&lt;/td&gt;
&lt;td&gt;SnowSO_VS&lt;/td&gt;
&lt;td&gt;SnowSO_GS&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;通过流输出得到分形球体&lt;/td&gt;
&lt;td&gt;SphereSO_VS&lt;/td&gt;
&lt;td&gt;SphereSO_GS&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;绘制分形三角形&lt;/td&gt;
&lt;td&gt;Triangle_VS&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;Triangle_PS&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;绘制分形雪花&lt;/td&gt;
&lt;td&gt;Snow_VS&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;Snow_PS&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;绘制分形球体&lt;/td&gt;
&lt;td&gt;Sphere_VS&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;Sphere_PS&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;绘制法向量&lt;/td&gt;
&lt;td&gt;Normal_VS&lt;/td&gt;
&lt;td&gt;Normal_GS&lt;/td&gt;
&lt;td&gt;Normal_PS&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;首先给出&lt;code&gt;Basic.fx&lt;/code&gt;文件的内容，要注意里面的常量缓冲区和之前有所变化:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &quot;LightHelper.hlsli&quot;

cbuffer CBChangesEveryFrame : register(b0)
{
    row_major matrix gWorld;
    row_major matrix gWorldInvTranspose;
}

cbuffer CBChangesOnResize : register(b1)
{
    row_major matrix gProj;
}

cbuffer CBNeverChange : register(b2)
{
    DirectionalLight gDirLight;
    Material gMaterial;
    row_major matrix gView;
    float3 gSphereCenter;
    float gSphereRadius;
    float3 gEyePosW;
}


struct VertexPosColor
{
    float3 PosL : POSITION;
    float4 Color : COLOR;
};

struct VertexPosHColor
{
    float4 PosH : SV_POSITION;
    float4 Color : COLOR;
};

struct VertexPosHLColor
{
    float4 PosH : SV_POSITION;
    float3 PosL : POSITION;
    float4 Color : COLOR;
};


struct VertexPosNormalColor
{
    float3 PosL : POSITION;
    float3 NormalL : NORMAL;
    float4 Color : COLOR;
};

struct VertexPosHWNormalColor
{
    float4 PosH : SV_POSITION;
    float3 PosW : POSITION;
    float3 NormalW : NORMAL;
    float4 Color : COLOR;
};

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实战1-绘制分形三角形&quot;&gt;实战1: 绘制分形三角形&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811171149522-1121949958.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过流输出阶段，一个三角形就分裂出了三个三角形，顶点的数目翻了3倍。若规定1阶分形三角形的顶点数为3，则N阶分形三角形的顶点数为&lt;span class=&quot;math inline&quot;&gt;\(3^{N}\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&quot;hlsl代码&quot;&gt;HLSL代码&lt;/h3&gt;
&lt;p&gt;首先是&lt;code&gt;TriangleSO_VS.hlsl&lt;/code&gt;，它负责将顶点直接传递给几何着色器。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// TriangleSO_VS.hlsl
#include &quot;Basic.fx&quot;

VertexPosColor VS(VertexPosColor pIn)
{
    return pIn;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后和上一章一样，&lt;code&gt;TriangleSO_GS.hlsl&lt;/code&gt;中的几何着色器将一个三角形分裂成三个三角形，并且输出的顶点类型和输入的顶点是一致的。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// TriangleSO_GS.hlsl
#include &quot;Basic.fx&quot;

[maxvertexcount(9)]
void GS(triangle VertexPosColor input[3], inout TriangleStream&amp;lt;VertexPosColor&amp;gt; output)
{
    //
    // 将一个三角形分裂成三个三角形，即没有v3v4v5的三角形
    //       v1
    //       /\
    //      /  \
    //   v3/____\v4
    //    /\xxxx/\
    //   /  \xx/  \
    //  /____\/____\
    // v0    v5    v2


    VertexPosColor vertexes[6];
    int i;
    [unroll]
    for (i = 0; i &amp;lt; 3; ++i)
    {
        vertexes[i] = input[i];
        vertexes[i + 3].Color = (input[i].Color + input[(i + 1) % 3].Color) / 2.0f;
        vertexes[i + 3].PosL = (input[i].PosL + input[(i + 1) % 3].PosL) / 2.0f;
    }

    [unroll]
    for (i = 0; i &amp;lt; 3; ++i)
    {
        output.Append(vertexes[i]);
        output.Append(vertexes[3 + i]);
        output.Append(vertexes[(i + 2) % 3 + 3]);

        output.RestartStrip();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来的&lt;code&gt;Triangle_VS.hlsl&lt;/code&gt;和&lt;code&gt;Triangle_PS.hlsl&lt;/code&gt;则是常规的三角形绘制:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Triangle_VS.hlsl
#include &quot;Basic.fx&quot;

VertexPosHColor VS(VertexPosColor pIn)
{
    row_major matrix worldViewProj = mul(mul(gWorld, gView), gProj);
    VertexPosHColor pOut;
    pOut.Color = pIn.Color;
    pOut.PosH = mul(float4(pIn.PosL, 1.0f), worldViewProj);
    return pOut;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Triangle_PS.hlsl
#include &quot;Basic.fx&quot;

float4 PS(VertexPosHColor pIn) : SV_Target
{
    return pIn.Color;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实战2-绘制分形雪花&quot;&gt;实战2: 绘制分形雪花&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811200638475-1077546894.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811200609974-1170475769.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在规定第一张图为一阶分形雪花，第二张为二阶分形雪花。观察二者之间的变化，可以发现前者的每一条直线变成了四条折线。其中每个尖锐角的度数都在60度，并且每条边的长度都应该是一致的。&lt;/p&gt;
&lt;h3 id=&quot;hlsl代码-1&quot;&gt;HLSL代码&lt;/h3&gt;
&lt;p&gt;和之前一样，&lt;code&gt;SnowSO_VS.hlsl&lt;/code&gt;中的顶点着色器阶段只用于顶点直传:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// SnowSO_VS.hlsl
#include &quot;Basic.fx&quot;

VertexPosNormalColor VS(VertexPosNormalColor pIn)
{
    return pIn;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后重点就在于&lt;code&gt;SnowSO_GS.hlsl&lt;/code&gt;的几何着色器了。这里先放出代码:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// SnowSO_GS.hlsl
#include &quot;Basic.fx&quot;

[maxvertexcount(5)]
void GS(line VertexPosColor input[2], inout LineStream&amp;lt;VertexPosColor&amp;gt; output)
{
    // 要求分形线段按顺时针排布
    // z分量必须相等，因为顶点没有提供法向量无法判断垂直上方向
    //                       v1
    //                       /\
    // ____________ =&amp;gt;  ____/  \____
    // i0         i1   i0  v0  v2  i1
    
    VertexPosColor v0, v1, v2;
    v0.Color = lerp(input[0].Color, input[1].Color, 0.25f);
    v1.Color = lerp(input[0].Color, input[1].Color, 0.5f);
    v2.Color = lerp(input[0].Color, input[1].Color, 0.75f);

    v0.PosL = lerp(input[0].PosL, input[1].PosL, 1.0f / 3.0f);
    v2.PosL = lerp(input[0].PosL, input[1].PosL, 2.0f / 3.0f);

    // xy平面求出它的垂直单位向量
    //     
    //     |
    // ____|_____
    float2 upDir = normalize(input[1].PosL - input[0].PosL).yx;
    float len = length(input[1].PosL.xy - input[0].PosL.xy);
    upDir.x = -upDir.x;

    v1.PosL = lerp(input[0].PosL, input[1].PosL, 0.5f);
    v1.PosL.xy += sqrt(3) / 6.0f * len * upDir;

    output.Append(input[0]);
    output.Append(v0);
    output.Append(v1);
    output.Append(v2);
    output.Append(input[1]);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现分形雪花每升一阶，需要绘制的顶点数就变成了上一阶的4倍。&lt;/p&gt;
&lt;p&gt;这里要求了z分量必须相等，因为使用的着色器仍把一切的顶点仍当做3D顶点来对待出来（当然你也可以写成2D的着色器）。&lt;/p&gt;
&lt;p&gt;然后开始具体分析从直线变折线的过程，可以看到因为顶点v1所在角的度数在60度，且v0, v1, v2构成等边三角形，故v0v2,&lt;br/&gt;v0v1和v1v2的边长是一致的。而且4条折线要求边长相等，故这里的i0v0和v2i1应当各占线段i0i1的1/3.&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;lerp&lt;/code&gt;函数是线性插值函数，数学公式如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathbf{p} = \mathbf{p}_0 + t(\mathbf{p}_1 - \mathbf{p}_0) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中t的取值范围在[0.0f, 1.0f]，并且操作对象p0和p1可以是标量，也可以是矢量，对矢量来说则是对每个分量都进行线性插值。&lt;/p&gt;
&lt;p&gt;当t = 0.5f时，描述的就是p0和p1的中值或中点。&lt;/p&gt;
&lt;p&gt;该函数很容易描述两点之间某一相对位置。&lt;/p&gt;
&lt;p&gt;由于我们规定了连续线段必须按顺时针排布，我们就可以利用向量i0i1逆时针旋转90度得到对应的突出方向向量，然后标准化，乘上相应的高度值即可得到顶点v1的位置。&lt;/p&gt;
&lt;p&gt;最后就是用于绘制的着色器代码:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Snow_VS.hlsl
#include &quot;Basic.fx&quot;

VertexPosHColor VS(VertexPosColor pIn)
{
    row_major matrix worldViewProj = mul(mul(gWorld, gView), gProj);
    VertexPosHColor pOut;
    pOut.Color = pIn.Color;
    pOut.PosH = mul(float4(pIn.PosL, 1.0f), worldViewProj);
    return pOut;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Snow_PS.hlsl
#include &quot;Basic.fx&quot;

float4 PS(VertexPosHColor pIn) : SV_Target
{
    return pIn.Color;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实战3-绘制分形圆球&quot;&gt;实战3: 绘制分形圆球&lt;/h2&gt;
&lt;p&gt;以下是一阶和二阶的分形圆球:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811205114934-2071592771.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811204931404-1212542141.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仔细观察可以看到，原先的一个三角形分裂出了四个三角形，即每升一阶，需要绘制的顶点数就变成了上一阶的4倍。&lt;/p&gt;
&lt;h3 id=&quot;hlsl代码-2&quot;&gt;HLSL代码&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SphereSO_VS.hlsl&lt;/code&gt;代码和&lt;code&gt;SphereSO_GS.hlsl&lt;/code&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// SphereSO_VS.hlsl
#include &quot;Basic.fx&quot;

VertexPosNormalColor VS(VertexPosNormalColor pIn)
{
    return pIn;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// SphereSO_GS.hlsl

#include &quot;Basic.fx&quot;

[maxvertexcount(12)]
void GS(triangle VertexPosNormalColor input[3], inout TriangleStream&amp;lt;VertexPosNormalColor&amp;gt; output)
{
    //
    // 将一个三角形分裂成四个三角形，但同时顶点v3, v4, v5也需要在球面上
    //       v1
    //       /\
    //      /  \
    //   v3/____\v4
    //    /\xxxx/\
    //   /  \xx/  \
    //  /____\/____\
    // v0    v5    v2
    
    VertexPosNormalColor vertexes[6];

    matrix viewProj = mul(gView, gProj);

    [unroll]
    for (int i = 0; i &amp;lt; 3; ++i)
    {
        vertexes[i] = input[i];
        vertexes[i + 3].Color = lerp(input[i].Color, input[(i + 1) % 3].Color, 0.5f);
        vertexes[i + 3].NormalL = normalize(input[i].NormalL + input[(i + 1) % 3].NormalL);
        vertexes[i + 3].PosL = gSphereCenter + gSphereRadius * vertexes[i + 3].NormalL;
    }
        
    output.Append(vertexes[0]);
    output.Append(vertexes[3]);
    output.Append(vertexes[5]);
    output.RestartStrip();

    output.Append(vertexes[3]);
    output.Append(vertexes[4]);
    output.Append(vertexes[5]);
    output.RestartStrip();

    output.Append(vertexes[5]);
    output.Append(vertexes[4]);
    output.Append(vertexes[2]);
    output.RestartStrip();

    output.Append(vertexes[3]);
    output.Append(vertexes[1]);
    output.Append(vertexes[4]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于v3, v4, v5也需要在球面上，我们还需要额外知道球的半径和球心位置。虽然说通过三角形三个顶点位置和法向量可以算出圆心和半径，但直接从常量缓冲区提供这两个信息会更方便一些。&lt;/p&gt;
&lt;p&gt;要计算诸如v3顶点所在位置，我们可以先求出它的法向量，将v0和v1的法向量相加取其单位向量即为v3的法向量，然后从圆心开始加上半径长度的法向量即可得到顶点v3的位置。&lt;/p&gt;
&lt;p&gt;剩下绘制圆的着色器代码如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Sphere_VS.hlsl
#include &quot;Basic.fx&quot;

VertexPosHWNormalColor VS(VertexPosNormalColor pIn)
{
    VertexPosHWNormalColor pOut;
    row_major matrix viewProj = mul(gView, gProj);
    pOut.PosW = mul(float4(pIn.PosL, 1.0f), gWorld).xyz;
    pOut.PosH = mul(float4(pOut.PosW, 1.0f), viewProj);
    pOut.NormalW = mul(pIn.NormalL, (float3x3) gWorldInvTranspose);
    pOut.Color = pIn.Color;
    return pOut;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// Sphere_PS.hlsl
#include &quot;Basic.fx&quot;

float4 PS(VertexPosHWNormalColor pIn) : SV_Target
{
    // 标准化法向量
    pIn.NormalW = normalize(pIn.NormalW);

    // 顶点指向眼睛的向量
    float3 toEyeW = normalize(gEyePosW - pIn.PosW);

    // 初始化为0 
    float4 ambient = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 diffuse = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 spec = float4(0.0f, 0.0f, 0.0f, 0.0f);

    // 只计算方向光
    ComputeDirectionalLight(gMaterial, gDirLight, pIn.NormalW, toEyeW, ambient, diffuse, spec);

    return pIn.Color * (ambient + diffuse) + spec;
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;basicfx.h的变化&quot;&gt;BasicFX.h的变化&lt;/h2&gt;
&lt;p&gt;首先是常量缓冲区的变化，新增了存储球心位置和半径信息：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct CBChangesEveryFrame
{
    DirectX::XMMATRIX world;
    DirectX::XMMATRIX worldInvTranspose;
};

struct CBChangesOnResize
{
    DirectX::XMMATRIX proj;
};

struct CBNeverChange
{
    DirectionalLight dirLight;
    Material material;
    DirectX::XMMATRIX view;
    DirectX::XMFLOAT3 sphereCenter;
    float sphereRadius;
    DirectX::XMFLOAT3 eyePos;
    float pad;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后是&lt;code&gt;BasicFX&lt;/code&gt;类的变化，其中法向量的绘制可以用于球体绘制的时候，具体实现可以回顾上一章。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class BasicFX
{
public:
    // 使用模板别名(C++11)简化类型名
    template &amp;lt;class T&amp;gt;
    using ComPtr = Microsoft::WRL::ComPtr&amp;lt;T&amp;gt;;

    // 初始化Basix.fx所需资源并初始化光栅化状态
    bool InitAll(ComPtr&amp;lt;ID3D11Device&amp;gt; device);
    // 是否已经初始化
    bool IsInit() const;

    template &amp;lt;class T&amp;gt;
    void UpdateConstantBuffer(const T&amp;amp; cbuffer);

    // 绘制三角形分形
    void SetRenderSplitedTriangle();
    // 绘制雪花
    void SetRenderSplitedSnow();
    // 绘制球体
    void SetRenderSplitedSphere();
    // 通过流输出阶段获取三角形分裂的下一阶分形
    void SetStreamOutputSplitedTriangle(ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferIn, ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferOut);
    // 通过流输出阶段获取雪花的下一阶分形
    void SetStreamOutputSplitedSnow(ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferIn, ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferOut);
    // 通过流输出阶段获取球的下一阶分形
    void SetStreamOutputSplitedSphere(ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferIn, ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferOut);

    // 绘制所有顶点的法向量
    void SetRenderNormal();

private:
    // objFileNameInOut为编译好的着色器二进制文件(.*so)，若有指定则优先寻找该文件并读取
    // hlslFileName为着色器代码，若未找到着色器二进制文件则编译着色器代码
    // 编译成功后，若指定了objFileNameInOut，则保存编译好的着色器二进制信息到该文件
    // ppBlobOut输出着色器二进制信息
    HRESULT CreateShaderFromFile(const WCHAR* objFileNameInOut, const WCHAR* hlslFileName, LPCSTR entryPoint, LPCSTR shaderModel, ID3DBlob** ppBlobOut);

private:
    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mTriangleSOVS;
    ComPtr&amp;lt;ID3D11GeometryShader&amp;gt; mTriangleSOGS;

    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mTriangleVS;
    ComPtr&amp;lt;ID3D11PixelShader&amp;gt; mTrianglePS;

    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mSphereSOVS;
    ComPtr&amp;lt;ID3D11GeometryShader&amp;gt; mSphereSOGS;

    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mSphereVS;
    ComPtr&amp;lt;ID3D11PixelShader&amp;gt; mSpherePS;
    
    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mSnowSOVS;
    ComPtr&amp;lt;ID3D11GeometryShader&amp;gt; mSnowSOGS;

    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mSnowVS;
    ComPtr&amp;lt;ID3D11PixelShader&amp;gt; mSnowPS;

    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; mNormalVS;
    ComPtr&amp;lt;ID3D11GeometryShader&amp;gt; mNormalGS;
    ComPtr&amp;lt;ID3D11PixelShader&amp;gt; mNormalPS;

    ComPtr&amp;lt;ID3D11InputLayout&amp;gt; mVertexPosColorLayout;        // VertexPosColor输入布局
    ComPtr&amp;lt;ID3D11InputLayout&amp;gt; mVertexPosNormalColorLayout;  // VertexPosNormalColor输入布局

    ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; md3dImmediateContext;       // 设备上下文

    std::vector&amp;lt;ComPtr&amp;lt;ID3D11Buffer&amp;gt;&amp;gt; mConstantBuffers;     // 常量缓冲区
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicfxinitall方法的变化&quot;&gt;BasicFX::InitAll方法的变化&lt;/h3&gt;
&lt;p&gt;现在着色器的创建按绘制类别进行分组：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;bool BasicFX::InitAll(ComPtr&amp;lt;ID3D11Device&amp;gt; device)
{
    if (!device)
        return false;

    const D3D11_SO_DECLARATION_ENTRY posColorLayout[2] = {
        { 0, &quot;POSITION&quot;, 0, 0, 3, 0 },
        { 0, &quot;COLOR&quot;, 0, 0, 4, 0 }
    };

    const D3D11_SO_DECLARATION_ENTRY posNormalColorLayout[3] = {
        { 0, &quot;POSITION&quot;, 0, 0, 3, 0 },
        { 0, &quot;NORMAL&quot;, 0, 0, 3, 0 },
        { 0, &quot;COLOR&quot;, 0, 0, 4, 0 }
    };

    UINT stridePosColor = sizeof(VertexPosColor);
    UINT stridePosNormalColor = sizeof(VertexPosNormalColor);

    ComPtr&amp;lt;ID3DBlob&amp;gt; blob;

    //
    // 流输出分裂三角形
    //
    HR(CreateShaderFromFile(L&quot;HLSL\\TriangleSO_VS.vso&quot;, L&quot;HLSL\\TriangleSO_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mTriangleSOVS.GetAddressOf()));
    // 创建顶点输入布局
    HR(device-&amp;gt;CreateInputLayout(VertexPosColor::inputLayout, ARRAYSIZE(VertexPosColor::inputLayout), blob-&amp;gt;GetBufferPointer(),
        blob-&amp;gt;GetBufferSize(), mVertexPosColorLayout.GetAddressOf()));
    HR(CreateShaderFromFile(L&quot;HLSL\\TriangleSO_GS.gso&quot;, L&quot;HLSL\\TriangleSO_GS.hlsl&quot;, &quot;GS&quot;, &quot;gs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateGeometryShaderWithStreamOutput(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), posColorLayout, ARRAYSIZE(posColorLayout),
        &amp;amp;stridePosColor, 1, D3D11_SO_NO_RASTERIZED_STREAM, nullptr, mTriangleSOGS.GetAddressOf()));
    
    //
    // 绘制分形三角形
    //
    HR(CreateShaderFromFile(L&quot;HLSL\\Triangle_VS.vso&quot;, L&quot;HLSL\\Triangle_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mTriangleVS.GetAddressOf()));
    HR(CreateShaderFromFile(L&quot;HLSL\\Triangle_PS.pso&quot;, L&quot;HLSL\\Triangle_PS.hlsl&quot;, &quot;PS&quot;, &quot;ps_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreatePixelShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mTrianglePS.GetAddressOf()));


    //
    // 流输出分形球体
    //
    HR(CreateShaderFromFile(L&quot;HLSL\\SphereSO_VS.vso&quot;, L&quot;HLSL\\SphereSO_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mSphereSOVS.GetAddressOf()));
    // 创建顶点输入布局
    HR(device-&amp;gt;CreateInputLayout(VertexPosNormalColor::inputLayout, ARRAYSIZE(VertexPosNormalColor::inputLayout), blob-&amp;gt;GetBufferPointer(),
        blob-&amp;gt;GetBufferSize(), mVertexPosNormalColorLayout.GetAddressOf()));
    HR(CreateShaderFromFile(L&quot;HLSL\\SphereSO_GS.gso&quot;, L&quot;HLSL\\SphereSO_GS.hlsl&quot;, &quot;GS&quot;, &quot;gs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateGeometryShaderWithStreamOutput(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), posNormalColorLayout, ARRAYSIZE(posNormalColorLayout),
        &amp;amp;stridePosNormalColor, 1, D3D11_SO_NO_RASTERIZED_STREAM, nullptr, mSphereSOGS.GetAddressOf()));
    
    //
    // 绘制球体
    //
    HR(CreateShaderFromFile(L&quot;HLSL\\Sphere_VS.vso&quot;, L&quot;HLSL\\Sphere_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mSphereVS.GetAddressOf()));
    HR(CreateShaderFromFile(L&quot;HLSL\\Sphere_PS.pso&quot;, L&quot;HLSL\\Sphere_PS.hlsl&quot;, &quot;PS&quot;, &quot;ps_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreatePixelShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mSpherePS.GetAddressOf()));
    

    //
    // 流输出分形雪花
    //
    HR(CreateShaderFromFile(L&quot;HLSL\\SnowSO_VS.vso&quot;, L&quot;HLSL\\SnowSO_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mSnowSOVS.GetAddressOf()));
    HR(CreateShaderFromFile(L&quot;HLSL\\SnowSO_GS.gso&quot;, L&quot;HLSL\\SnowSO_GS.hlsl&quot;, &quot;GS&quot;, &quot;gs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateGeometryShaderWithStreamOutput(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), posColorLayout, ARRAYSIZE(posColorLayout),
        &amp;amp;stridePosColor, 1, D3D11_SO_NO_RASTERIZED_STREAM, nullptr, mSnowSOGS.GetAddressOf()));

    //
    // 绘制雪花
    //
    HR(CreateShaderFromFile(L&quot;HLSL\\Snow_VS.vso&quot;, L&quot;HLSL\\Snow_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mSnowVS.GetAddressOf()));
    HR(CreateShaderFromFile(L&quot;HLSL\\Snow_PS.pso&quot;, L&quot;HLSL\\Snow_PS.hlsl&quot;, &quot;PS&quot;, &quot;ps_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreatePixelShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mSnowPS.GetAddressOf()));


    //
    // 绘制法向量
    //
    HR(CreateShaderFromFile(L&quot;HLSL\\Normal_VS.vso&quot;, L&quot;HLSL\\Normal_VS.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mNormalVS.GetAddressOf()));
    HR(CreateShaderFromFile(L&quot;HLSL\\Normal_GS.gso&quot;, L&quot;HLSL\\Normal_GS.hlsl&quot;, &quot;GS&quot;, &quot;gs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateGeometryShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mNormalGS.GetAddressOf()));
    HR(CreateShaderFromFile(L&quot;HLSL\\Normal_PS.pso&quot;, L&quot;HLSL\\Normal_PS.hlsl&quot;, &quot;PS&quot;, &quot;ps_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreatePixelShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, mNormalPS.GetAddressOf()));

    

    RenderStates::InitAll(device);
    device-&amp;gt;GetImmediateContext(md3dImmediateContext.GetAddressOf());

    // ******************
    // 设置常量缓冲区描述
    mConstantBuffers.assign(3, nullptr);
    D3D11_BUFFER_DESC cbd;
    ZeroMemory(&amp;amp;cbd, sizeof(cbd));
    cbd.Usage = D3D11_USAGE_DEFAULT;
    cbd.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
    cbd.CPUAccessFlags = 0;

    cbd.ByteWidth = Align16Bytes(sizeof(CBChangesEveryFrame));
    HR(device-&amp;gt;CreateBuffer(&amp;amp;cbd, nullptr, mConstantBuffers[0].GetAddressOf()));
    cbd.ByteWidth = Align16Bytes(sizeof(CBChangesOnResize));
    HR(device-&amp;gt;CreateBuffer(&amp;amp;cbd, nullptr, mConstantBuffers[1].GetAddressOf()));
    cbd.ByteWidth = Align16Bytes(sizeof(CBNeverChange));
    HR(device-&amp;gt;CreateBuffer(&amp;amp;cbd, nullptr, mConstantBuffers[2].GetAddressOf()));

    // 预先绑定各自所需的缓冲区
    md3dImmediateContext-&amp;gt;VSSetConstantBuffers(0, 1, mConstantBuffers[0].GetAddressOf());
    md3dImmediateContext-&amp;gt;VSSetConstantBuffers(1, 1, mConstantBuffers[1].GetAddressOf());
    md3dImmediateContext-&amp;gt;VSSetConstantBuffers(2, 1, mConstantBuffers[2].GetAddressOf());

    md3dImmediateContext-&amp;gt;GSSetConstantBuffers(0, 1, mConstantBuffers[0].GetAddressOf());
    md3dImmediateContext-&amp;gt;GSSetConstantBuffers(1, 1, mConstantBuffers[1].GetAddressOf());
    md3dImmediateContext-&amp;gt;GSSetConstantBuffers(2, 1, mConstantBuffers[2].GetAddressOf());

    md3dImmediateContext-&amp;gt;PSSetConstantBuffers(2, 1, mConstantBuffers[2].GetAddressOf());
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicfxsetrendersplitedtriangle方法--绘制分形三角形&quot;&gt;BasicFX::SetRenderSplitedTriangle方法--绘制分形三角形&lt;/h3&gt;
&lt;p&gt;由于新增了流输出的阶段，这里开始接下来的每一个用于绘制的方法都需要把流输出绑定的顶点缓冲区都解除绑定。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicFX::SetRenderSplitedTriangle()
{
    md3dImmediateContext-&amp;gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosColorLayout.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mTriangleVS.Get(), nullptr, 0);
    // 关闭流输出
    md3dImmediateContext-&amp;gt;GSSetShader(nullptr, nullptr, 0);
    ID3D11Buffer* bufferArray[1] = { nullptr };
    UINT offset = 0;
    md3dImmediateContext-&amp;gt;SOSetTargets(1, bufferArray, &amp;amp;offset);
    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    md3dImmediateContext-&amp;gt;PSSetShader(mTrianglePS.Get(), nullptr, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicfxsetrendersplitedsnow方法--绘制分形雪花&quot;&gt;BasicFX::SetRenderSplitedSnow方法--绘制分形雪花&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicFX::SetRenderSplitedSnow()
{
    md3dImmediateContext-&amp;gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_LINELIST);
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosColorLayout.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mSnowVS.Get(), nullptr, 0);
    // 关闭流输出
    md3dImmediateContext-&amp;gt;GSSetShader(nullptr, nullptr, 0);
    ID3D11Buffer* bufferArray[1] = { nullptr };
    UINT offset = 0;
    md3dImmediateContext-&amp;gt;SOSetTargets(1, bufferArray, &amp;amp;offset);
    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    md3dImmediateContext-&amp;gt;PSSetShader(mSnowPS.Get(), nullptr, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicfxsetrendersplitedsphere方法--绘制分形球体&quot;&gt;BasicFX::SetRenderSplitedSphere方法--绘制分形球体&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicFX::SetRenderSplitedSphere()
{
    md3dImmediateContext-&amp;gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosNormalColorLayout.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mSphereVS.Get(), nullptr, 0);
    // 关闭流输出
    md3dImmediateContext-&amp;gt;GSSetShader(nullptr, nullptr, 0);
    ID3D11Buffer* bufferArray[1] = { nullptr };
    UINT offset = 0;
    md3dImmediateContext-&amp;gt;SOSetTargets(1, bufferArray, &amp;amp;offset);
    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    md3dImmediateContext-&amp;gt;PSSetShader(mSpherePS.Get(), nullptr, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicfxsetstreamoutputsplitedtriangle方法--经过流输出保存下一阶分形三角形的顶点&quot;&gt;BasicFX::SetStreamOutputSplitedTriangle方法--经过流输出保存下一阶分形三角形的顶点&lt;/h3&gt;
&lt;p&gt;为了简化设置，这里还需要提供额外的输入缓冲区和输出缓冲区。为了防止出现顶点缓冲区同时被绑定到输入装配和流输出阶段的情况，需要先清空流输出绑定的顶点缓冲区，然后将用于输入的顶点缓冲区绑定到输入装配阶段，最后才是把输出的顶点缓冲区绑定到流输出阶段。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicFX::SetStreamOutputSplitedTriangle(ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferIn, ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferOut)
{
    // 先恢复流输出默认设置，防止顶点缓冲区同时绑定在输入和输出阶段
    UINT stride = sizeof(VertexPosColor);
    UINT offset = 0;
    ID3D11Buffer * nullBuffer = nullptr;
    md3dImmediateContext-&amp;gt;SOSetTargets(1, &amp;amp;nullBuffer, &amp;amp;offset);

    md3dImmediateContext-&amp;gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosColorLayout.Get());

    md3dImmediateContext-&amp;gt;IASetVertexBuffers(0, 1, vertexBufferIn.GetAddressOf(), &amp;amp;stride, &amp;amp;offset);

    md3dImmediateContext-&amp;gt;VSSetShader(mTriangleSOVS.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;GSSetShader(mTriangleSOGS.Get(), nullptr, 0);

    md3dImmediateContext-&amp;gt;SOSetTargets(1, vertexBufferOut.GetAddressOf(), &amp;amp;offset);
;
    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    md3dImmediateContext-&amp;gt;PSSetShader(nullptr, nullptr, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicfxsetstreamoutputsplitedsnow方法--经过流输出保存下一阶分形雪花的顶点&quot;&gt;BasicFX::SetStreamOutputSplitedSnow方法--经过流输出保存下一阶分形雪花的顶点&lt;/h3&gt;
&lt;p&gt;注意这里是用LineList而不是LineStrip方式。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicFX::SetStreamOutputSplitedSnow(ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferIn, ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferOut)
{
    // 先恢复流输出默认设置，防止顶点缓冲区同时绑定在输入和输出阶段
    UINT stride = sizeof(VertexPosColor);
    UINT offset = 0;
    ID3D11Buffer * nullBuffer = nullptr;
    md3dImmediateContext-&amp;gt;SOSetTargets(1, &amp;amp;nullBuffer, &amp;amp;offset);

    md3dImmediateContext-&amp;gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_LINELIST);
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosColorLayout.Get());
    md3dImmediateContext-&amp;gt;IASetVertexBuffers(0, 1, vertexBufferIn.GetAddressOf(), &amp;amp;stride, &amp;amp;offset);

    md3dImmediateContext-&amp;gt;VSSetShader(mSnowSOVS.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;GSSetShader(mSnowSOGS.Get(), nullptr, 0);

    md3dImmediateContext-&amp;gt;SOSetTargets(1, vertexBufferOut.GetAddressOf(), &amp;amp;offset);

    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    md3dImmediateContext-&amp;gt;PSSetShader(nullptr, nullptr, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicfxsetstreamoutputsplitedsphere方法--经过流输出保存下一阶分形球体的顶点&quot;&gt;BasicFX::SetStreamOutputSplitedSphere方法--经过流输出保存下一阶分形球体的顶点&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicFX::SetStreamOutputSplitedSphere(ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferIn, ComPtr&amp;lt;ID3D11Buffer&amp;gt; vertexBufferOut)
{
    // 先恢复流输出默认设置，防止顶点缓冲区同时绑定在输入和输出阶段
    UINT stride = sizeof(VertexPosNormalColor);
    UINT offset = 0;
    ID3D11Buffer * nullBuffer = nullptr;
    md3dImmediateContext-&amp;gt;SOSetTargets(1, &amp;amp;nullBuffer, &amp;amp;offset);

    md3dImmediateContext-&amp;gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexPosNormalColorLayout.Get());
    md3dImmediateContext-&amp;gt;IASetVertexBuffers(0, 1, vertexBufferIn.GetAddressOf(), &amp;amp;stride, &amp;amp;offset);

    md3dImmediateContext-&amp;gt;VSSetShader(mSphereSOVS.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;GSSetShader(mSphereSOGS.Get(), nullptr, 0);

    md3dImmediateContext-&amp;gt;SOSetTargets(1, vertexBufferOut.GetAddressOf(), &amp;amp;offset);

    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    md3dImmediateContext-&amp;gt;PSSetShader(nullptr, nullptr, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;gameapp类的变化&quot;&gt;GameApp类的变化&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;GameApp&lt;/code&gt;类的变化如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class GameApp : public D3DApp
{
public:
    enum class Mode { SplitedTriangle, SplitedSnow, SplitedSphere };
    
public:
    GameApp(HINSTANCE hInstance);
    ~GameApp();

    bool Init();
    void OnResize();
    void UpdateScene(float dt);
    void DrawScene();

private:
    bool InitResource();

    void ResetSplitedTriangle();
    void ResetSplitedSnow();
    void ResetSplitedSphere();


private:
    
    ComPtr&amp;lt;ID2D1SolidColorBrush&amp;gt; mColorBrush;               // 单色笔刷
    ComPtr&amp;lt;IDWriteFont&amp;gt; mFont;                              // 字体
    ComPtr&amp;lt;IDWriteTextFormat&amp;gt; mTextFormat;                  // 文本格式

    ComPtr&amp;lt;ID3D11Buffer&amp;gt; mVertexBuffers[7];                 // 顶点缓冲区数组
    int mVertexCounts[7];                                   // 顶点数目
    int mCurrIndex;                                         // 当前索引
    Mode mShowMode;                                         // 当前显示模式
    bool mIsWireFrame;                                      // 是否为线框模式
    bool mShowNormal;                                       // 是否显示法向量
    BasicFX mBasicFX;                                       // Basic特效管理类

    CBChangesEveryFrame mCBChangeEveryFrame;                // 该缓冲区存放每帧更新的变量
    CBChangesOnResize mCBOnReSize;                          // 该缓冲区存放仅在窗口大小变化时更新的变量
    CBNeverChange mCBNeverChange;                           // 该缓冲区存放不会再进行修改的变量
};

#endif&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gameappresetsplitedtriangle方法--重新建立包含1-7阶的分形三角形顶点的缓冲区&quot;&gt;GameApp::ResetSplitedTriangle方法--重新建立包含1-7阶的分形三角形顶点的缓冲区&lt;/h3&gt;
&lt;p&gt;首先我们只需要给1阶的顶点缓冲区使用指定三角形的三个顶点，然后后续阶数的顶点缓冲区就根据上一阶产出的顶点缓冲区进行&quot;绘制&quot;。经过6次调用后，里面的7个顶点缓冲区都应该被初始化完毕，后续绘制的时候只需要直接取用某一个顶点缓冲区即可。&lt;/p&gt;
&lt;p&gt;注意顶点缓冲区在创建的时候一定要加上&lt;code&gt;D3D11_BIND_STREAM_OUTPUT&lt;/code&gt;标签。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::ResetSplitedTriangle()
{
    // ******************
    // 初始化三角形
    // 设置三角形顶点
    VertexPosColor vertices[] =
    {
        { XMFLOAT3(-1.0f * 3, -0.866f * 3, 0.0f), XMFLOAT4(1.0f, 0.0f, 0.0f, 1.0f) },
        { XMFLOAT3(0.0f * 3, 0.866f * 3, 0.0f), XMFLOAT4(0.0f, 1.0f, 0.0f, 1.0f) },
        { XMFLOAT3(1.0f * 3, -0.866f * 3, 0.0f), XMFLOAT4(0.0f, 0.0f, 1.0f, 1.0f) }
    };
    // 设置顶点缓冲区描述
    D3D11_BUFFER_DESC vbd;
    ZeroMemory(&amp;amp;vbd, sizeof(vbd));
    vbd.Usage = D3D11_USAGE_DEFAULT;
    vbd.ByteWidth = sizeof vertices;
    vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER | D3D11_BIND_STREAM_OUTPUT;    // 需要额外添加流输出标签
    vbd.CPUAccessFlags = 0;
    // 新建顶点缓冲区
    D3D11_SUBRESOURCE_DATA InitData;
    ZeroMemory(&amp;amp;InitData, sizeof(InitData));
    InitData.pSysMem = vertices;
    HR(md3dDevice-&amp;gt;CreateBuffer(&amp;amp;vbd, &amp;amp;InitData, mVertexBuffers[0].ReleaseAndGetAddressOf()));

    
    // 三角形顶点数
    mVertexCounts[0] = 3;
    // 初始化所有顶点缓冲区
    for (int i = 1; i &amp;lt; ARRAYSIZE(mVertexBuffers); ++i)
    {
        vbd.ByteWidth *= 3;
        mVertexCounts[i] = mVertexCounts[i - 1] * 3;
        HR(md3dDevice-&amp;gt;CreateBuffer(&amp;amp;vbd, nullptr, mVertexBuffers[i].ReleaseAndGetAddressOf()));
        mBasicFX.SetStreamOutputSplitedTriangle(mVertexBuffers[i - 1], mVertexBuffers[i]);
        md3dImmediateContext-&amp;gt;Draw(mVertexCounts[i - 1], 0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gameappresetsplitedsnow方法--重新建立包含1-7阶的分形雪花顶点的缓冲区&quot;&gt;GameApp::ResetSplitedSnow方法--重新建立包含1-7阶的分形雪花顶点的缓冲区&lt;/h3&gt;
&lt;p&gt;由于绘制方式统一用LineList，初始阶段应当提供3条线段的6个顶点，虽然说每个顶点都被重复使用了2次。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::ResetSplitedSnow()
{
    // ******************
    // 雪花分形从初始化三角形开始，需要6个顶点
    // 设置三角形顶点
    float sqrt3 = sqrt(3.0f);
    VertexPosColor vertices[] =
    {
        { XMFLOAT3(-3.0f / 4, -sqrt3 / 4, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(0.0f, sqrt3 / 2, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(0.0f, sqrt3 / 2, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(3.0f / 4, -sqrt3 / 4, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(3.0f / 4, -sqrt3 / 4, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(-3.0f / 4, -sqrt3 / 4, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) }
    };
    // 将三角形宽度和高度都放大3倍
    for (int i = 0; i &amp;lt; ARRAYSIZE(vertices); ++i)
    {
        vertices[i].pos.x *= 3;
        vertices[i].pos.y *= 3;
    }

    // 设置顶点缓冲区描述
    D3D11_BUFFER_DESC vbd;
    ZeroMemory(&amp;amp;vbd, sizeof(vbd));
    vbd.Usage = D3D11_USAGE_DEFAULT;
    vbd.ByteWidth = sizeof vertices;
    vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER | D3D11_BIND_STREAM_OUTPUT;    // 需要额外添加流输出标签
    vbd.CPUAccessFlags = 0;
    // 新建顶点缓冲区
    D3D11_SUBRESOURCE_DATA InitData;
    ZeroMemory(&amp;amp;InitData, sizeof(InitData));
    InitData.pSysMem = vertices;
    HR(md3dDevice-&amp;gt;CreateBuffer(&amp;amp;vbd, &amp;amp;InitData, mVertexBuffers[0].ReleaseAndGetAddressOf()));

    // 顶点数
    mVertexCounts[0] = 6;
    // 初始化所有顶点缓冲区
    for (int i = 1; i &amp;lt; ARRAYSIZE(mVertexBuffers); ++i)
    {
        vbd.ByteWidth *= 4;
        mVertexCounts[i] = mVertexCounts[i - 1] * 4;
        HR(md3dDevice-&amp;gt;CreateBuffer(&amp;amp;vbd, nullptr, mVertexBuffers[i].ReleaseAndGetAddressOf()));
        mBasicFX.SetStreamOutputSplitedSnow(mVertexBuffers[i - 1], mVertexBuffers[i]);
        md3dImmediateContext-&amp;gt;Draw(mVertexCounts[i - 1], 0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gameappresetsplitedsphere方法--重新建立包含1-7阶的分形圆球顶点的缓冲区&quot;&gt;GameApp::ResetSplitedSphere方法--重新建立包含1-7阶的分形圆球顶点的缓冲区&lt;/h3&gt;
&lt;p&gt;这里不使用&lt;code&gt;Geometry&lt;/code&gt;类来构造一阶圆球，这里仅提供与外接正方体相交的六个顶点，包含八个三角形对应的24个顶点。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameApp::ResetSplitedSphere()
{
    VertexPosNormalColor basePoint[] = {
        { XMFLOAT3(0.0f, 2.0f, 0.0f), XMFLOAT3(0.0f, 1.0f, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(2.0f, 0.0f, 0.0f), XMFLOAT3(1.0f, 0.0f, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(0.0f, 0.0f, 2.0f), XMFLOAT3(0.0f, 0.0f, 1.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(-2.0f, 0.0f, 0.0f), XMFLOAT3(-1.0f, 0.0f, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(0.0f, 0.0f, -2.0f), XMFLOAT3(0.0f, 0.0f, -1.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
        { XMFLOAT3(0.0f, -2.0f, 0.0f), XMFLOAT3(0.0f, -1.0f, 0.0f), XMFLOAT4(1.0f, 1.0f, 1.0f, 1.0f) },
    };
    int indices[] = {0, 2, 1, 0, 3, 2, 0, 4, 3, 0, 1, 4, 1, 2, 5, 2, 3, 5, 3, 4, 5, 4, 1, 5};

    std::vector&amp;lt;VertexPosNormalColor&amp;gt; vertices;
    for (int pos : indices)
    {
        vertices.push_back(basePoint[pos]);
    }

    

    // 设置顶点缓冲区描述
    D3D11_BUFFER_DESC vbd;
    ZeroMemory(&amp;amp;vbd, sizeof(vbd));
    vbd.Usage = D3D11_USAGE_DEFAULT;
    vbd.ByteWidth = vertices.size() * sizeof(VertexPosNormalColor);
    vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER | D3D11_BIND_STREAM_OUTPUT;    // 需要额外添加流输出标签
    vbd.CPUAccessFlags = 0;
    // 新建顶点缓冲区
    D3D11_SUBRESOURCE_DATA InitData;
    ZeroMemory(&amp;amp;InitData, sizeof(InitData));
    InitData.pSysMem = vertices.data();
    HR(md3dDevice-&amp;gt;CreateBuffer(&amp;amp;vbd, &amp;amp;InitData, mVertexBuffers[0].ReleaseAndGetAddressOf()));

    // 顶点数
    mVertexCounts[0] = ARRAYSIZE(indices);
    // 初始化所有顶点缓冲区
    for (int i = 1; i &amp;lt; ARRAYSIZE(mVertexBuffers); ++i)
    {
        vbd.ByteWidth *= 4;
        mVertexCounts[i] = mVertexCounts[i - 1] * 4;
        HR(md3dDevice-&amp;gt;CreateBuffer(&amp;amp;vbd, nullptr, mVertexBuffers[i].ReleaseAndGetAddressOf()));
        mBasicFX.SetStreamOutputSplitedSphere(mVertexBuffers[i - 1], mVertexBuffers[i]);
        md3dImmediateContext-&amp;gt;Draw(mVertexCounts[i - 1], 0);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于篇幅过大，该类的其它方法就在此省略，具体细节可以查阅该章对应源码。来看一下动图感受一些这些酷炫的效果吧：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811215603121-922316780.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811215946924-615521366.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由于文件大小限制，这里分成两个部分：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811220300589-2129952589.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是带法向量的：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180811220857933-1803464726.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由于我现在找不到ID3D11DeviceContext::DrawAuto方法无法输出的原因，故在这里使用的依然是原来的Draw方法进行绘制。若有人能够在不使用FX11框架的情况下能够调用DrawAuto方法绘制到流输出，可以在下面评论我，并告诉我解决方案。&lt;/p&gt;
&lt;p&gt;除此之外，该项目使用图形调试器并退出的时候，会引发内存泄漏，而具体的泄漏对象估计是&lt;code&gt;ID3D11Query&lt;/code&gt;，然而我也没有办法直接拿到该接口对象来释放。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 11 Aug 2018 14:32:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<og:description>前言 在上一章，我们知道了如何使用几何着色器来重新组装图元，比如从一个三角形分裂成三个三角形。但是为了实现更高阶的分形，我们必须要从几何着色器拿到输出的顶点。这里我们可以使用可选的流输出阶段来拿到顶点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-Jun/p/9461074.html</dc:identifier>
</item>
<item>
<title>用华为eNSP模拟器配置Hybrid、Trunk和Access三种链路类型端口 - 陈林实验室</title>
<link>http://www.cnblogs.com/chenlinlab/p/9461361.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenlinlab/p/9461361.html</guid>
<description>&lt;p&gt;　　上一篇文章写到三层交换机实现多个VLAN之间互相通讯，有朋友提问要如何进行配置，可有案例分析。其实那天我在写的时候也有做过模拟，只是后来没有保存。今天重新模拟一次，并附上详细配置命令，希望能够帮助到大家。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;首先回忆下VLAN间数据传输的三种端口模式各自代表的含义：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Access 类型的端口只能属于1个VLAN，一般用于连接计算机的端口,也可以连接交换机和交换机。&lt;/p&gt;
&lt;p&gt;　　Trunk 类型的端口可以允许多个VLAN通过，可以接收和发送多个VLAN的报文，trunk口一般用于连接两台交换机，这样可以只用一条trunk连接实现多个vlan的扩展。对于trunk口发送出去的报文，只有默认vlan的报文不带vlan ID，其它vlan的报文都要带vlan ID（要不然，对端的交换机不知道该报文属于哪个vlan，无法处理，也就不能实现vlan跨交换机扩展了）。简而言之，trunk端口的设计目的就是通过一条连接实现多个vlan的跨交换机扩展。&lt;/p&gt;
&lt;p&gt;　　Hybrid 类型的端口可以实现比trunk端口更多的功能，trunk端口是hybrid端口的真子集。可以允许多个VLAN通过，可以接收和发送多个VLAN的报文，可以用于交换机之间连接，也可以用于连接用户的计算机。hybrid端口可以加入多个vlan，并可以设置该vlan的报文通过该端口发送是否带vlan ID（trunk端口不能设置，只有默认vlan的报文不带vlan ID进行发送）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下配合每个端口模式在eNSP模拟器上模拟的实验：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、Trunk+Access链路端口混合模式案例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295423/201808/1295423-20180811221457971-128592710.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　由于Access链路类型端口是单一VLAN，而且连接计算机的，所以跟Trunk链路类型端口合并成一个案例，节约大家学习时间。&lt;/p&gt;
&lt;p&gt;通过配置使都在vlan2的PC1和PC2互通，同vlan3的PC3和PC4互通。&lt;/p&gt;
&lt;p&gt;SwitchA配置命令：&lt;/p&gt;
&lt;p&gt;&amp;lt;Huawei&amp;gt;system-view&lt;br/&gt;[Huawei]sysname SwitchA&lt;br/&gt;[SwitchA]vlan batch 2 3 //批量创建VLAN，也可以分两次创建VLAN 2 VLAN 3&lt;br/&gt;[SwitchA]int vlanif 2&lt;br/&gt;[SwitchA-Vlanif2]ip address 192.168.100.1 255.255.255.0&lt;br/&gt;[SwitchA-Vlanif2]quit&lt;br/&gt;[SwitchA]int vlanif 3&lt;br/&gt;[SwitchA-Vlanif3]ip address 192.168.200.1 255.255.255.0&lt;br/&gt;[SwitchA-Vlanif3]quit&lt;br/&gt;[SwitchA] int G0/0/1&lt;br/&gt;[SwitchA-GigabitEthernet0/0/1]port link-type access //与连接PC1的端口链路类型设置为access&lt;br/&gt;[SwitchA-GigabitEthernet0/0/1]port default vlan 2 //将端口G0/0/1加入vlan 2&lt;br/&gt;[SwitchA-GigabitEthernet0/0/1]int G0/0/2 // 可以直接跳入G0/0/2 ，新手可以先quit到系统视图&lt;br/&gt;[SwitchA-GigabitEthernet0/0/2] port link-type access //与连接PC2端口链路类型设置为access&lt;br/&gt;[SwitchA-GigabitEthernet0/0/2] port default vlan 3 //将端口GE1/0/2加入vlan3&lt;br/&gt;[SwitchA] int G0/0/3&lt;br/&gt;[SwitchA-GigabitEthernet0/0/3] port link-type trunk //因为有vlan2 vlan3两个vlan，将交换机互联的端口链路类型设置为trunk&lt;br/&gt;[SwitchA-GigabitEthernet1/0/3] port trunk allow-pass vlan 2 3 //将端口G0/0/3加入vlan2和vlan 3&lt;br/&gt;SwitchB和SwitchA的配置差不多，大家参考SwitchA的配置文件。&lt;/p&gt;
&lt;p&gt;将PC1和PC2配置在一个网段，比如192.168.100.2/24和192.168.100.3/24，网关皆为192.168.100.1；&lt;br/&gt;将PC3和PC4配置在一个网段，比如192.168.200.2/24和192.168.200.3/24，网关皆为192.168.200.1；&lt;br/&gt;测试结果：PC1可以与PC2ping通，PC3可以与PC4ping通。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295423/201808/1295423-20180811221631406-940024354.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PC1 ping通 PC2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295423/201808/1295423-20180811221720744-1697938150.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PC3 ping通 PC4&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、Hybrid链路类型端口案例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　上篇文章有朋友提到Hybrid链路类型端口模式功能非常强大而且相当复杂，今天下午复习了下，确实在很多方面变现出它的先进性。&lt;/p&gt;
&lt;p&gt;使用Hybrid链路类型配置让PC3与PC1、PC2互通，PC1与PC2之间不通。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295423/201808/1295423-20180811221918094-1223402896.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;LSW1配置命令：&lt;/p&gt;
&lt;p&gt;&amp;lt;Huawei&amp;gt;system-view&lt;br/&gt;[Huawei]sysname LSW1&lt;br/&gt;[LSW1]vlan batch 2 3 99&lt;br/&gt;[LSW1]int g0/0/1&lt;br/&gt;[LSW1-GigabitEthernet0/0/1]undo port hybrid vlan 1&lt;br/&gt;[LSW1-GigabitEthernet0/0/1]port hybrid tagged vlan 99&lt;br/&gt;[LSW1-GigabitEthernet0/0/1]port hybird untagged vlan 2 3&lt;br/&gt;[LSW1-GigabitEthernet0/0/1]int g0/0/2&lt;br/&gt;[LSW1-GigabitEthernet0/0/2]undo port hybrid vlan 1&lt;br/&gt;[LSW1-GigabitEthernet0/0/2]port hybrid pvid vlan 2&lt;br/&gt;[LSW1-GigabitEthernet0/0/2]port hybird untagged vlan 2 99&lt;br/&gt;[LSW1-GigabitEthernet0/0/2]int g0/0/3&lt;br/&gt;[LSW1-GigabitEthernet0/0/3]undo port hybrid vlan 1&lt;br/&gt;[LSW1-GigabitEthernet0/0/3]port hybrid pvid vlan 3&lt;br/&gt;[LSW1-GigabitEthernet0/0/3]port hybird untagged vlan 3 99&lt;br/&gt;[LSW1-GigabitEthernet0/0/3]quit&lt;br/&gt;SwitchB和SwitchA的配置差不多，大家参考SwitchA的配置，再次不再累赘。&lt;/p&gt;
&lt;p&gt;PC1、PC2和PC3的IP地址分别顺序设置为192.168.1.1/24、192.168.1.2/24、192.168.1.3/24，网关不填。&lt;br/&gt;测试结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1295423/201808/1295423-20180811221848069-631050419.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;这里有必要对Hybrid原理解释一下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、pvid这个属性只针对进入该端口的！没有标签的！普通的！数据包有效，作用是将没有标签的普通数据包打上pvid中配置的标签号；&lt;/p&gt;
&lt;p&gt;　　2、hybrid属性中，tag是针对于端口的接收方向的（从该端口进来的流量允许带有这些vlan标签的通过），untag是针对端口的发送方向的（从该端口出去的流量去除这些vlan标签）；&lt;/p&gt;
&lt;p&gt;Hybird实例配置分析（非常有必要解释）：&lt;/p&gt;
&lt;p&gt;　　1、为了让我们更加简洁的理解hydrid的属性，首先在所有的端口上移除了vlan1这个默认有的vlan，假设为所有端口初始不属于任何vlan，都不能相互之间通信；&lt;/p&gt;
&lt;p&gt;　　2、pvid是当普通的主机数据帧进入交换机端口后被打上的vlan-tag的属性，在途中可以看出PC1、PC2、PC3的流量在进入交换机的时候分别会被打上vlan2、vlan3、vlan99的vlan标签；&lt;/p&gt;
&lt;p&gt;　　3、untag后面的vlan就是该端口属于的vlan，那么不难看出LSW1的G0/0/1属于vlan2、3，G0/0/2属于vlan2、99，G0/0/3属于vlan3、99，而untag的动作是在流量出端口去往主机的时候把vlan-tag全部去除，那么不难看出LSW1的G0/0/1将去除vlan2、3的标签，G0/0/2去除vlan2、1099的标签，G0/0/3去除vlan3、99的标签（还原成普通帧）。&lt;/p&gt;
&lt;p&gt;LSW2的G0/0/1属于vlan99，G0/0/2属于vlan99，在流量出端口的时候会去除vlan99的标签（还原成普通帧）。&lt;/p&gt;
&lt;p&gt;　　PC1与PC2之间的通信分析：当PC1发送arp去请求PC2的MAC地址的时候，PC1会将数据包广播发往LSW1的G0/0/2接口，LSW1收到后发现是个普通的不带标签的数据帧，于是根据接口的pvid给该帧打上vlan2的tag，然后往vlan2中进行泛洪，无奈G0/0/3端口只属于vlan3、99所以无法收到vlan2中的泛洪，故PC1与PC2通信失败。&lt;/p&gt;
&lt;p&gt;　　PC1与PC3之间的通信分析：PC1把帧给LSW1后在G0/0/2打上pvid vlan2的tag，从G0/0/1转发出去，同时untag掉这个帧vlan2的标签，LSW2从G0/0/1收到普通的帧后打上vlan99的tag后从G0/0/2转发给PC3（去掉vlan99的tag后转发给PC3），PC3回包给PC1过程：PC3把帧丢给LSW2的G0/0/2后被pvid打上vlan99的tag后，LSW2根据mac表和vlan信息将帧从G0/0/1口转发出去，！这里因为并没有untag属性所以转发的帧并不会去除任何vlan，而是以vlan99的帧从G0/0/1转发出去！（G0/0/1配置的tag vlan 99是为了让这个端口能转发vlan99的数据帧）当LSW1拿到LSW2发来的带有vlan99的tag的数据帧后，根据G0/0/1上配置的tag vlan99属性，放行vlan99的数据帧，然后根据mac表和vlan信息把帧丢给G0/0/2，由G0/0/2端口将vlan99的tag去除后转发给PC1，完成了PC1与PC3的整个通信过程。&lt;/p&gt;
&lt;p&gt;PC2与PC3的通信过程同理PC1与PC3。&lt;/p&gt;
&lt;p&gt;　　Hybrid确实有点复杂，不过它的功能非常强大，集合了Access和Trunk的优点，还能适合基于汇聚层设备做网关、MAC地址划分、IP子网划分地的配置。欢迎在下方留言提问，看下哪里不大了解的？&lt;/p&gt;
</description>
<pubDate>Sat, 11 Aug 2018 14:22:00 +0000</pubDate>
<dc:creator>陈林实验室</dc:creator>
<og:description>上一篇文章写到三层交换机实现多个VLAN之间互相通讯，有朋友提问要如何进行配置，可有案例分析。其实那天我在写的时候也有做过模拟，只是后来没有保存。今天重新模拟一次，并附上详细配置命令，希望能够帮助到大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenlinlab/p/9461361.html</dc:identifier>
</item>
<item>
<title>自定义Android控件，封装Arcgis for Android测距测面积工具控件 - 山顶洞洞人</title>
<link>http://www.cnblogs.com/sddman/p/9461279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sddman/p/9461279.html</guid>
<description>&lt;p&gt;控件的功能包括，测距、测面积、撤销、恢复、清除、完成六个功能。&lt;/p&gt;
&lt;p&gt;测距：在地图上绘制线段进行长度测量&lt;/p&gt;
&lt;p&gt;测面积：在地图上绘制一个面，进行面积测量&lt;/p&gt;
&lt;p&gt;撤销：撤销到上一步绘制，只能撤销未完成的测量&lt;/p&gt;
&lt;p&gt;恢复：恢复到下一步绘制，只能恢复未完成的测量&lt;/p&gt;
&lt;p&gt;清除：清空测量内容并结束测量，再次点击地图时不会进行测量&lt;/p&gt;
&lt;p&gt;完成：结束本次测量，本次测量将不能撤销和恢复，再次点击地图时将进行下一次长度测量或者面积测量&lt;/p&gt;
&lt;p&gt;项目地址：https://github.com/roomanl/ArcgisTool&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/1533987191989a9375cb6d1&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/153398739075078c64264b1&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;最简单的基本用法：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/1533987461621ad4577804b&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;注意：请不要在measureToolView.init(mMapView)之后给mMapView设置点击监听事件，不然会覆盖掉MeasureToolView的地图点击事件，如需要在地图点击之后做一些自己的操作，请看下面的高级用法。&lt;/p&gt;
&lt;p&gt;以上代码将会显示默认的控件样式，下图是默认样式&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p9.pstatp.com/large/pgc-image/1533987503756e8529003e7&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;MeasureToolView支持样式设置，可以设置成自己需要的样式，下图是自定义样式&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/15339875259938afde1867b&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;在界面设置属性&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/1533987557174c5e2db031e&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;java代码设置属性&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/1533987581169d425883642&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;设置地图点击回调&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/15339876143270490bf7af6&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;设置测量工具按钮点击回调&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/1533987642433e1184bd4ee&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;地图点击和测量按钮点击回调同时设置&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/153398767344776658fe3af&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;设置坐标参考系&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/153398770618429a6c6eeab&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;设置测量长度单位&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/1533988400026b856441bfa&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;设置测量面积单位&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/1533987729115355dde91d9&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;ArcGisZoomView控件均由调用ArcGisMeasure开放接口实现&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/1533987830169a4df4e37ff&quot; alt=&quot;自定义Android控件，封装Arcgis for Android测距测面积工具控件&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 11 Aug 2018 14:01:00 +0000</pubDate>
<dc:creator>山顶洞洞人</dc:creator>
<og:description>控件的功能包括，测距、测面积、撤销、恢复、清除、完成六个功能。 测距：在地图上绘制线段进行长度测量 测面积：在地图上绘制一个面，进行面积测量 撤销：撤销到上一步绘制，只能撤销未完成的测量 恢复：恢复到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sddman/p/9461279.html</dc:identifier>
</item>
</channel>
</rss>