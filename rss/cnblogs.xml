<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MySQL主从数据一致性问题修复 - unixfbi.com</title>
<link>http://www.cnblogs.com/pangguoping/p/8570849.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pangguoping/p/8570849.html</guid>
<description>&lt;p&gt;前面，我们使用&lt;code&gt;pt-table-checksum&lt;/code&gt; 可以检测出主从数据是否一致的问题。发现问题后，我们怎么解决这些问题，也是我们必须要会的技能。&lt;/p&gt;
&lt;p&gt;修复主从数据一致性问题，我们使用&lt;code&gt;pt-table-sync&lt;/code&gt;工具，和&lt;code&gt;pt-table-checksum&lt;/code&gt;一样，都需要提前安装&lt;code&gt;percona-tools&lt;/code&gt;工具包。怎么安装，我这里就不说了，请看我之前的文章。&lt;/p&gt;
&lt;p&gt;下面我们来演示一下主从数据一致性问题修复&lt;/p&gt;
&lt;h2 id=&quot;环境介绍&quot;&gt;1.环境介绍&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;192.168.199.230&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3306&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Master&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;192.168.199.131&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;3306&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Slave&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们这里已经创建好了主从复制环境，这里我就不演示了&lt;/p&gt;
&lt;h2 id=&quot;创建表和数据&quot;&gt;2.创建表和数据&lt;/h2&gt;
&lt;p&gt;我们是在Master实例上创建表和数据&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;root@localhost&lt;span class=&quot;ch&quot;&gt;:mysql3306&lt;/span&gt;.sock [db1]&amp;gt; &lt;span class=&quot;kw&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt; tb_2018 (
    -&amp;gt; &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; auto_increment,
    -&amp;gt; cname &lt;span class=&quot;dt&quot;&gt;varchar&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;32&lt;/span&gt;),
    -&amp;gt; ctime datetime,
    -&amp;gt; &lt;span class=&quot;kw&quot;&gt;primary&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;key&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt;)
    -&amp;gt; );
root@localhost&lt;span class=&quot;ch&quot;&gt;:mysql3306&lt;/span&gt;.sock [db1]&amp;gt; &lt;span class=&quot;kw&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;into&lt;/span&gt; tb_2018(cname,ctime) &lt;span class=&quot;kw&quot;&gt;values&lt;/span&gt; (&lt;span class=&quot;st&quot;&gt;'unixfbi'&lt;/span&gt;,now());   
&lt;span class=&quot;kw&quot;&gt;Query&lt;/span&gt; OK, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;row&lt;/span&gt; affected (&lt;span class=&quot;fl&quot;&gt;0.00&lt;/span&gt; sec)

root@localhost&lt;span class=&quot;ch&quot;&gt;:mysql3306&lt;/span&gt;.sock [db1]&amp;gt; &lt;span class=&quot;kw&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;into&lt;/span&gt; tb_2018(cname,ctime) &lt;span class=&quot;kw&quot;&gt;values&lt;/span&gt; (&lt;span class=&quot;st&quot;&gt;'MySQL'&lt;/span&gt;,now());  
&lt;span class=&quot;kw&quot;&gt;Query&lt;/span&gt; OK, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;row&lt;/span&gt; affected (&lt;span class=&quot;fl&quot;&gt;0.00&lt;/span&gt; sec)

root@localhost&lt;span class=&quot;ch&quot;&gt;:mysql3306&lt;/span&gt;.sock [db1]&amp;gt; &lt;span class=&quot;kw&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;into&lt;/span&gt; tb_2018(cname,ctime) &lt;span class=&quot;kw&quot;&gt;values&lt;/span&gt; (&lt;span class=&quot;st&quot;&gt;'JAVA'&lt;/span&gt;,now()); &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;让主从数据不一致&quot;&gt;3.让主从数据不一致&lt;/h2&gt;
&lt;p&gt;我们在从库上添加一条数据，让主从数据不一致。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;oot@localhost [db1]&amp;gt;insert &lt;span class=&quot;kw&quot;&gt;into&lt;/span&gt; tb_2018(cname,ctime) &lt;span class=&quot;kw&quot;&gt;values&lt;/span&gt; (&lt;span class=&quot;st&quot;&gt;'NET'&lt;/span&gt;,now());    
&lt;span class=&quot;kw&quot;&gt;Query&lt;/span&gt; OK, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;row&lt;/span&gt; affected (&lt;span class=&quot;fl&quot;&gt;0.02&lt;/span&gt; sec)
root@localhost [db1]&amp;gt;select * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; tb_2018;
+&lt;span class=&quot;co&quot;&gt;----+---------+---------------------+&lt;/span&gt;
| &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; | cname   | ctime               |
+&lt;span class=&quot;co&quot;&gt;----+---------+---------------------+&lt;/span&gt;
|  &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; | unixfbi | &lt;span class=&quot;dv&quot;&gt;2018-01-29&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;:43:01&lt;/span&gt; |
|  &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; | MySQL   | &lt;span class=&quot;dv&quot;&gt;2018-01-29&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;:43:10&lt;/span&gt; |
|  &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;JAVA&lt;/span&gt;    | &lt;span class=&quot;dv&quot;&gt;2018-01-29&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;:43:19&lt;/span&gt; |
|  &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; | NET     | &lt;span class=&quot;dv&quot;&gt;2018-01-29&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;:44:15&lt;/span&gt; |
+&lt;span class=&quot;co&quot;&gt;----+---------+---------------------+&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; (&lt;span class=&quot;fl&quot;&gt;0.00&lt;/span&gt; sec)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;验证主从数据是否一致&quot;&gt;4.验证主从数据是否一致&lt;/h2&gt;
&lt;p&gt;在Master实例上执行&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;# pt-table-checksum --nocheck-binlog-format --replicate=db1.&lt;span class=&quot;fu&quot;&gt;checksum&lt;/span&gt;   -h localhost -P3306 -u root -p unixfbi --ignore-databases=mysql --recursion-method=&lt;span class=&quot;st&quot;&gt;&quot;processlist&quot;&lt;/span&gt; 
Checking &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; all tables can be checksummed ...
Starting checksum ...
            TS ERRORS  DIFFS     ROWS  CHUNKS SKIPPED    TIME TABLE
&lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;-29T14:&lt;span class=&quot;dv&quot;&gt;45&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;44&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;0.496&lt;/span&gt; db1.&lt;span class=&quot;fu&quot;&gt;tb1&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;-29T14:&lt;span class=&quot;dv&quot;&gt;45&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;        &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;0.015&lt;/span&gt; db1.&lt;span class=&quot;fu&quot;&gt;tb_2018&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;-29T14:&lt;span class=&quot;dv&quot;&gt;45&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;0.264&lt;/span&gt; db2.&lt;span class=&quot;fu&quot;&gt;tb3&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;-29T14:&lt;span class=&quot;dv&quot;&gt;45&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;0.012&lt;/span&gt; db2.&lt;span class=&quot;fu&quot;&gt;tb4&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;-29T14:&lt;span class=&quot;dv&quot;&gt;45&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;0.013&lt;/span&gt; sys.&lt;span class=&quot;fu&quot;&gt;sys_config&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;-29T14:&lt;span class=&quot;dv&quot;&gt;45&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;0.013&lt;/span&gt; wbx3306.&lt;span class=&quot;fu&quot;&gt;t1&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;-29T14:&lt;span class=&quot;dv&quot;&gt;45&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;0.013&lt;/span&gt; wbx3306.&lt;span class=&quot;fu&quot;&gt;tp_1&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发现db1.tb_2018这个表里的数据已经不一致了。&lt;/p&gt;
&lt;h2 id=&quot;查看不一致信息&quot;&gt;5.查看不一致信息&lt;/h2&gt;
&lt;p&gt;执行&lt;code&gt;pt-table-sync&lt;/code&gt;命令之前一定要确保&lt;code&gt;checksum&lt;/code&gt;表的存在，也就是说必须先验证数据是否一致，才能执行&lt;code&gt;pt-table-sync&lt;/code&gt;命令。&lt;br/&gt;这里我们只是查看并打印解决不一致问题的语句，所以我们这里使用&lt;code&gt;pt-table-sync&lt;/code&gt;命令的&lt;code&gt;--print&lt;/code&gt;参数。修复不一致的问题，我们需要使用&lt;code&gt;--execute&lt;/code&gt;参数。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;# pt-table-sync --replicate=db1.&lt;span class=&quot;fu&quot;&gt;checksum&lt;/span&gt;  h=&lt;span class=&quot;fl&quot;&gt;192.168.199.230&lt;/span&gt;,u=root,p=unixfbi --print 
                                                            DELETE FROM `db1`.`tb_2018` WHERE `id`='&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;' LIMIT &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;/*percona-toolkit src_db:db1 src_tbl:tb_2018 src_dsn:h=192.168.199.230,p=...,u=root dst_db:db1 dst_tbl:tb_2018 dst_dsn:h=dev-hd-node3,p=...,u=root lock:1 transaction:1 changing_src:db1.checksum replicate:db1.checksum bidirectional:0 pid:42455 user:ruowei host:db-node1*/&lt;/span&gt;;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接打印出了解决主从数据不一致的语句。&lt;/p&gt;
&lt;h2 id=&quot;修复主从数据不一致问题&quot;&gt;6.修复主从数据不一致问题&lt;/h2&gt;
&lt;p&gt;这里我们需要使用pt-table-sync命令的&lt;code&gt;--execute&lt;/code&gt;参数&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;# pt-table-sync --replicate=db1.&lt;span class=&quot;fu&quot;&gt;checksum&lt;/span&gt;  h=&lt;span class=&quot;fl&quot;&gt;192.168.199.230&lt;/span&gt;,u=root,p=unixfbi --execute &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行修复命令后，我们再次检查看看数据是否一致。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;# pt-table-checksum --nocheck-binlog-format --replicate=db1.&lt;span class=&quot;fu&quot;&gt;checksum&lt;/span&gt;   -h localhost -P3306 -u root -p unixfbi --ignore-databases=mysql --recursion-method=&lt;span class=&quot;st&quot;&gt;&quot;processlist&quot;&lt;/span&gt; 
Checking &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; all tables can be checksummed ...
Starting checksum ...
            TS ERRORS  DIFFS     ROWS  CHUNKS SKIPPED    TIME TABLE
&lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;-29T15:&lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;44&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;0.016&lt;/span&gt; db1.&lt;span class=&quot;fu&quot;&gt;tb1&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;-29T15:&lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;0.015&lt;/span&gt; db1.&lt;span class=&quot;fu&quot;&gt;tb_2018&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;-29T15:&lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;0.013&lt;/span&gt; db2.&lt;span class=&quot;fu&quot;&gt;tb3&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;-29T15:&lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;0.012&lt;/span&gt; db2.&lt;span class=&quot;fu&quot;&gt;tb4&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;-29T15:&lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;0.012&lt;/span&gt; sys.&lt;span class=&quot;fu&quot;&gt;sys_config&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;-29T15:&lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;0.012&lt;/span&gt; wbx3306.&lt;span class=&quot;fu&quot;&gt;t1&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;-29T15:&lt;span class=&quot;dv&quot;&gt;13&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;       &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;   &lt;span class=&quot;fl&quot;&gt;0.013&lt;/span&gt; wbx3306.&lt;span class=&quot;fu&quot;&gt;tp_1&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发现没有显示数据不一致的问题。&lt;/p&gt;
&lt;p&gt;在从库上查看一下数据有什么变化：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;root@localhost [db1]&amp;gt;select * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; tb_2018;
+&lt;span class=&quot;co&quot;&gt;----+---------+---------------------+&lt;/span&gt;
| &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; | cname   | ctime               |
+&lt;span class=&quot;co&quot;&gt;----+---------+---------------------+&lt;/span&gt;
|  &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; | unixfbi | &lt;span class=&quot;dv&quot;&gt;2018-01-29&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;:43:01&lt;/span&gt; |
|  &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt; | MySQL   | &lt;span class=&quot;dv&quot;&gt;2018-01-29&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;:43:10&lt;/span&gt; |
|  &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;JAVA&lt;/span&gt;    | &lt;span class=&quot;dv&quot;&gt;2018-01-29&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;14&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;:43:19&lt;/span&gt; |
+&lt;span class=&quot;co&quot;&gt;----+---------+---------------------+&lt;/span&gt;
&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; (&lt;span class=&quot;fl&quot;&gt;0.00&lt;/span&gt; sec)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发现是把id=4的这条数据删除了，保证了和主库数据一致性的。&lt;/p&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.itpub.net/12679300/viewspace-1455303/&quot; class=&quot;uri&quot;&gt;http://blog.itpub.net/12679300/viewspace-1455303/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文出自 “&lt;a href=&quot;http://www.unixfbi.com/&quot;&gt;运维特工&lt;/a&gt;” 博客，转载请务必保留原文链接 和 &lt;a href=&quot;http://www.unixfbi.com/&quot; class=&quot;uri&quot;&gt;http://www.unixfbi.com&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 14 Mar 2018 15:33:00 +0000</pubDate>
<dc:creator>unixfbi.com</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pangguoping/p/8570849.html</dc:identifier>
</item>
<item>
<title>Spark ML源码分析之一 设计框架解读 - jicanghai</title>
<link>http://www.cnblogs.com/jicanghai/p/8570805.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jicanghai/p/8570805.html</guid>
<description>&lt;p&gt;本博客为作者原创，如需转载请注明http://www.cnblogs.com/jicanghai/p/8570805.html&lt;/p&gt;

&lt;p&gt;        在深入理解Spark ML中的各类算法之前，先理一下整个库的设计框架，是非常有必要的，优秀的框架是对复杂问题的抽象和解剖，对这种抽象的学习本身，就是加深框架所面对的问题的理解的一种有效途径。纷繁复杂的机器学习问题，经过优秀框架的解析，变得简单清晰起来。&lt;/p&gt;
&lt;p&gt;        基于面向对象语言的程序设计，本质上类似于搭积木，从一个最抽象、最简单的内容开始，一点一点的往上堆叠，形成一个对象的框架。比如Java中的Object，Python中的PyObject等等，这也是面向对象语言教给我们的一种解决问题的思路：剥洋葱，把外层非本质的表皮一个一个剥去，剩下的就是事物的本质与核心。&lt;/p&gt;
&lt;p&gt;        那么，机器学习问题的核心是什么呢？Spark ML给出的答案是，参数。所有的机器学习模型、算法，说到底都是对参数的学习。因此，在Spark ML框架中，最底层也是最抽象的类，就是Param，一个对象只要是能包含参数的，都可以叫做Param。&lt;/p&gt;
&lt;p&gt;        在param文件夹下，包含了对参数类及其子类的代码。参数类的子类，主要分成两种，第一种是数据类型类，包括IntParam，DoubleParam，顾名思义，这些参数包含了某种数据类型的数据，第二种是参数集合Params，表示其中包含了许多参数，这个类就很了不起了，从它开始衍生出了很多实用的参数，比如HasRegParam，表示其中包含了正则化的参数，再比如HasMaxIter，表示其中包含了最大迭代次数的参数。看，机器学习模型的积木已经帮我们准备好了，从参数的角度来抽象各类机器学习问题，可以按照是否包含某个参数，对机器学习模型和算法进行拆解，一个算法需要什么参数，就在定义时，像搭积木一样，把对应的参数包括进来就好了。&lt;/p&gt;
&lt;p&gt;        参数仅是静态的内容，如果要让这个对象有用，就需要让它具有一定的功能。最底层的具有功能性的类是PipelineStage，它实际上是一个Params，关于Pipeline的概念，我们稍后介绍，这里需要理解的是，虽然PipelineStage与Pipeline的名称很相似，但它们之间还隔了一层，完全不是一个层面上的东西。PipelineStage是一个抽象的阶段，它本身不具备任何功能，它的存在仅是为了给真正有功能的类一个公共的子类，与Param的其它子类相区分。&lt;/p&gt;
&lt;p&gt;        接下来就到了我们平时最常用的类，Transformer。一个类，只要它拥有将一个数据集转化成另外一个数据集的功能，它就是一个Transformer。注意，一个Transformer就是一个PipelineStage。&lt;/p&gt;
&lt;p&gt;        仅能完成数据转换，还不够，在机器学习中，最重要的事情是对数据的拟合，这里Estimator类正式登场，只要具有数据拟合的功能，即，只要能从数据中学习，就是Estimator，这个类里包含了我们最熟悉的一个函数，fit，是它赋予了所有Estimator从数据中学习的能力。&lt;/p&gt;
&lt;p&gt;        到这里，我们在机器学习中最常见的“模型”的概念，就已经呼之欲出了。Model类本质上是一个Transformer，这个很好理解，一个训练得到的模型，本身的任务就是做预测，做数据转化的。Model的独特之处在于，它是由Estimator的fit方法生成的，一个Estimator在经过对数据的学习之后，就产生了一个Model，而一个Model中除了一个指向生成自己的Estimator的“指针”之外，真的什么都没有。&lt;/p&gt;
&lt;p&gt;        这里我们再总结一下Transformer（简称T），Estimator（简称E），Model（简称M）三者之间的关系。T和E本质上都是PipelineStage，更本质的来说都是Param，而M本质上是一个T，但它是由E产生的，因此M是连接T和E之间的桥梁。&lt;/p&gt;
&lt;p&gt;        下面要介绍的就是Pipeline，我们知道很多机器学习的任务，都不是一步能完成的，比如做分类，我们要先对数据进行预处理，进行分类，然后再对分类结果进行处理，才能得到想要的结果。于是Spark ML提供了一个非常棒的抽象，流水线（Pipeline），它的引入能使得机器学习的各个任务能像流水线一样被顺序执行，因此能提供非常简洁优雅的编程接口。Pipeline本质上是一个E，它是由一个一个的PipelineStage组成的。通过上文我们知道，T和E都是PipelineStage，因此一个Pipeline中就包含了许多的T和E。由于Pipeline本质上是一个E，因此它在调用fit函数之后，会产生一个PipelineModel，这就是一个Model了。还记得Model的本质是Transformer吗？&lt;/p&gt;
&lt;p&gt;        我们知道，机器学习中的问题可以简单分为两类，监督学习和非监督学习，监督学习的一个特点就是，能够对某个事情做出“预测”，而非监督学习更多的是挖掘数据中的一些内在本质特点，不能做出预测，因此，为了将监督学习的本质提炼出来，设计了一个Predictor类。&lt;/p&gt;
&lt;p&gt;        能做出预测的类，需要有一些共同的参数，还记得刚才我们对于Param的分析吗？参数是区分各类机器学习算法的一种角度，PredictorParams就是有预测能力的监督学习模型拥有参数的一种抽象，而Predictor本质上是一个带有PredictorParams的Estimator，而每一个Estimator在调用fit函数之后都会产生一个Model，这里产生的就是一个PredictorModel，这是一个带有PredictorParams的Model。&lt;/p&gt;

&lt;p&gt;        好了，今天就写到这里。写作也是整理思路的一种很好的方式，在刚才的写作中，对Spark ML的设计思路又有了新的认识。由于本人才疏学浅，以上的理解不免会有纰漏，还请大家不吝赐教。下次将跟大家一起分析下具体算法的设计。&lt;/p&gt;
</description>
<pubDate>Wed, 14 Mar 2018 15:25:00 +0000</pubDate>
<dc:creator>jicanghai</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jicanghai/p/8570805.html</dc:identifier>
</item>
<item>
<title>网络游戏开发- 开场白 - 青城大兄弟</title>
<link>http://www.cnblogs.com/boxrice/p/8570730.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/boxrice/p/8570730.html</guid>
<description>&lt;p&gt;众所周知（&lt;strong&gt;mei ren zhi dao&lt;/strong&gt;），去年来到一家18线不知名的游戏公司，担任web后台开发的岗位。&lt;/p&gt;
&lt;p&gt;简单来说就是负责充钱啊，做报表啊，维护服务器啊之类的打杂的事情&lt;/p&gt;
&lt;p&gt;每天看到游戏组的同事在那边写代码 debug，眼浅的不得了。于是乎，下班回家，自己也开始来撸一下，游戏也是程序啊。&lt;/p&gt;
&lt;p&gt;同事们主要是用的Unity C++ lua，我一个也不会。。。。请教他们都只能问问思路。。。&lt;/p&gt;
&lt;p&gt;我打算用Egret来写客户端，asp.net core 来写服务器，中间通信使用websocket来完成&lt;/p&gt;
&lt;p&gt;本系列博客不间断更新，看工作忙闲程度吧&lt;/p&gt;
&lt;p&gt;&lt;em&gt;服务器主要内容：&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用.Net Core自带的Websocket类库完成，不依赖第三方包&lt;/li&gt;
&lt;li&gt;实现一个简单的连接池&lt;/li&gt;
&lt;li&gt;实现一个简单的定时任务模块&lt;/li&gt;
&lt;li&gt;实现一个简单的类似于Asp.Net Core Mvc的开发结构&lt;/li&gt;
&lt;li&gt;最后实现一个炸金花的棋牌游戏服务器&lt;/li&gt;
&lt;li&gt;约定和客户端使用的协议内容，选择一种序列化的方式（Json 二进制 protocol   ???? 待确定）&lt;/li&gt;
&lt;li&gt;主要使用技术ASp.Net Core Redis Mysql EFCore Log4Net&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;em&gt;客户端主要内容：&lt;/em&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;TypeScript的熟悉&lt;/li&gt;
&lt;li&gt;Egret引擎的基本应用&lt;/li&gt;
&lt;li&gt;Egret的EUI简单的应用&lt;/li&gt;
&lt;li&gt;Egret的Tween实现发牌动画&lt;/li&gt;
&lt;li&gt;Egret自带的Websocket框架实现通信&lt;/li&gt;
&lt;li&gt;发布Android Windows10 微信小游戏 H5等平台&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;希望我能坚持，当我说给我朋友说我要写一个这游戏的时候，他怎么都不信，毕竟我的座右铭是：&lt;strong&gt;世上无难事，只要肯放弃&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后我们打了一个100块钱的赌。哈哈&lt;/p&gt;
&lt;p&gt;之所以会选择写一段这样的开场白，或者算是立项之类的话，是因为上一任老板提到的一个词语 “&lt;strong&gt;仪式感&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;写上这么一段，也算是一个开始，放弃的时候，想到万一有园子里的大兄弟等着我更新呢？我不更新会不会给我寄刀片啊？？？&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/653862/201803/653862-20180314231730322-1808902276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 14 Mar 2018 15:18:00 +0000</pubDate>
<dc:creator>青城大兄弟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/boxrice/p/8570730.html</dc:identifier>
</item>
<item>
<title>详解MySQL数据类型 - 五月的仓颉</title>
<link>http://www.cnblogs.com/xrq730/p/8446246.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xrq730/p/8446246.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;原文地址http://www.cnblogs.com/xrq730/p/5260294.html，转载请注明出处，谢谢！&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很久没写文章，也有博友在我的有些文章中留言，希望我可以写一些文章，公司项目一直很忙，但是每天也尽量腾出一些时间写一些东西，主要针对工作中一些常用的知识点系统性的梳理（可能我们在工作中只是纯粹的使用而已，不会去进行总结、归纳）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文写的内容是MySQL数据类型，之前写MySQL系列文章的时候一直忽略的一个知识点，现在想来，我们学习一门语言，无非从两个方面入手：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;基本语法，有了语法，我们才可以组织逻辑&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;数据类型，即在特定场景下选择合适的数据类型，到底是用整型还是浮点型还是字符串，每种数据机构占多少字节，最大值是多少。这点只针对强类型的语言，像js这种弱类型的语言，是不需要考虑这一点的&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;希望通过一篇文章的梳理，可以把MySQL数据结构这块都归纳清楚。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;整型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先从最基本的数据类型整型说起，首先用一张表格归纳一下：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;数据类型&lt;/td&gt;
&lt;td&gt;字节数&lt;/td&gt;
&lt;td&gt;带符号最小值&lt;/td&gt;
&lt;td&gt;带符号最大值&lt;/td&gt;
&lt;td&gt;不带符号最小值&lt;/td&gt;
&lt;td&gt;不带符号最大值&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TINYINT&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;-128&lt;/td&gt;
&lt;td&gt;127&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;255&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SMALLINT&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;-32768&lt;/td&gt;
&lt;td&gt;32767&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;65535&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MEDIUMINT&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;-8388608&lt;/td&gt;
&lt;td&gt;8388607&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;16777215&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;INT&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;-2147483648&lt;/td&gt;
&lt;td&gt;2147483647&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;4294967295&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BIGINT&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;-9223372036854775808&lt;/td&gt;
&lt;td&gt;9223372036854775807&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;18446744073709551616&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;即使是带符号的BIGINT，其实也已经是一个天文数字了，什么概念，9223372036854775807我们随便举下例子：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;以byte为例可以表示8589934592GB--&amp;gt;8388608TB--&amp;gt;8192PB&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;以毫秒为例可以表示292471208年&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;所以从实际开发的角度，我们&lt;span&gt;&lt;strong&gt;一定要为合适的列选取合适的数据类型&lt;/strong&gt;&lt;/span&gt;，即到底用不用得到这种数据类型？举个例子：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;一个枚举字段明明只有0和1两个枚举值，选用TINYINT就足够了，但在开发场景下却使用了BIGINT，这就造成了资源浪费&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;简单计算一下，假使该数据表中有100W数据，那么总共浪费了700W字节也就是6.7M左右，如果更多的表这么做了，那么浪费的更多&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;要知道，&lt;span&gt;&lt;strong&gt;MySQL本质上是一个存储&lt;/strong&gt;&lt;/span&gt;，以Java为例，可以使用byte类型的地方使用了long类型问题不大，因为绝大多数的对象在程序中都是短命对象，方法执行完毕这块内存区域就被释放了，7个字节实际上不存在浪不浪费一说。但是MySQL作为一个存储，8字节的BIGINT放那儿就放那儿了，占据的空间是实实在在的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后举个例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;drop&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;exists&lt;/span&gt;&lt;span&gt; test_tinyint;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; test_tinyint (
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     num &lt;span&gt;tinyint&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; ) engine&lt;span&gt;=&lt;/span&gt;innodb charset&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test_tinyint &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;-&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test_tinyint &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行第7行的代码时候报错&quot;Out of range value for column 'num' at row 1&quot;，即很清楚的我们可以看到插入的数字范围越界了，这也同样反映出&lt;span&gt;&lt;strong&gt;MySQL中整型默认是带符号的&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把第3行的num字段定义改为&quot;num tinyint unsigned&quot;第7的插入就不会报错了，但是第6行的插入-100又报错了，因为无符号整型是无法表示负数的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;整型（N）形式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在开发中，我们会碰到有些定义整型的写法是int(11)，这种写法从我个人开发的角度看我认为是没有多大用，不过作为一个知识点做一下讲解吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;int(N)我们只需要记住两点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;无论N等于多少，int永远占4个字节&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;N表示的是显示宽度，不足的用0补足，超过的无视长度而直接显示整个数字，但这要整型设置了unsigned zerofill才有效&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;下面举个例子，写一段SQL：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;exists&lt;/span&gt;&lt;span&gt; test_int_width;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; test_int_width (
    a &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;),
    b &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;) unsigned,
    c &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;) unsigned zerofill,
    d &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;&lt;span&gt;) unsigned zerofill
) engine&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;innodb charset&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8;

&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test_int_width &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1111111111&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; test_int_width;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从上面的两点，我们应该预期结果应该是1,1,00001,1111111111&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们看一下结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201803/801753-20180314213714584-1231603237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不符合预期是吧，因为这个问题我也有过困扰，后来查了一下貌似是Navicat工具本身的问题，我们使用控制台就不会有这个问题了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201803/801753-20180314214003646-658653781.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不过实际工作场景中反正我是没有碰到过指定zerofill的，也不知道具体应用场景，如果有使用这种写法的朋友可以留言告知具体在哪种场景下用到了这种写法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;浮点型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;整型之后，下面是浮点型，在MySQL中浮点型有两种，分别为float、double，它们三者用一张表格总结一下：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;数据类型&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;字节数&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;备注&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;单精度浮点型&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;双精度浮点型&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;下面还是用SQL来简单看一下float和double型数据，以float为例，double同理：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;exists&lt;/span&gt;&lt;span&gt; test_float;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; test_float (
    num &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
) engine&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;innodb charset&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8;

&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test_float &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1.233&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test_float &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1.237&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test_float &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;10.233&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test_float &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;100.233&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test_float &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1000.233&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test_float &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;10000.233&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test_float &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;100000.233&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; test_float;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;显示结果为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201803/801753-20180310213611963-1316106814.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从这个结果我们总结一下float(M,D)、double(M、D)的用法规则：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;D表示浮点型数据小数点之后的精度，假如超过D位则四舍五入，即1.233四舍五入为1.23，1.237四舍五入为1.24&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;M表示浮点型数据总共的位数，D=2则表示总共支持五位，即小数点前只支持三位数，所以我们并没有看到1000.23、10000.233、100000.233这三条数据的插入，因为插入都报错了&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;当我们不指定M、D的时候，会按照实际的精度来处理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;定点型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;介绍完float、double两种浮点型，我们介绍一下定点型的数据类型decimal类型，有了浮点型为什么我们还需要定点型？写一段SQL看一下就明白了：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;exists&lt;/span&gt;&lt;span&gt; test_decimal;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; test_decimal (
    float_num &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;),
    double_num &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;),
    decimal_num &lt;/span&gt;&lt;span&gt;decimal&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
) engine&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;innodb charset&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8;

&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test_decimal &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1234567.66&lt;/span&gt;, &lt;span&gt;1234567899000000.66&lt;/span&gt;, &lt;span&gt;1234567899000000.66&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test_decimal &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;1234567.66&lt;/span&gt;, &lt;span&gt;12345678990000000.66&lt;/span&gt;, &lt;span&gt;12345678990000000.66&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201803/801753-20180314214228036-1606257947.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看到float、double类型存在精度丢失问题，即&lt;span&gt;&lt;strong&gt;写入数据库的数据未必是插入数据库的数据&lt;/strong&gt;&lt;/span&gt;，而decimal无论写入数据中的数据是多少，都不会存在精度丢失问题，这就是我们要引入decimal类型的原因，decimal类型常见于银行系统、互联网金融系统等对小数点后的数字比较敏感的系统中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后讲一下decimal和float/double的区别，个人总结主要体现在两点上：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;float/double在db中存储的是近似值，而decimal则是以字符串形式进行保存的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;decimal(M,D)的规则和float/double相同，但区别在float/double在不指定M、D时默认按照实际精度来处理而decimal在不指定M、D时默认为decimal(10, 0)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;日期类型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接着我们看一下MySQL中的日期类型，MySQL支持五种形式的日期类型：date、time、year、datetime、timestamp，用一张表格总结一下这五种日期类型：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;数据类型&lt;/td&gt;
&lt;td&gt;字节数&lt;/td&gt;
&lt;td&gt;格式&lt;/td&gt;
&lt;td&gt;备注&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;date&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;yyyy-MM-dd&lt;/td&gt;
&lt;td&gt;存储日期值&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;time&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;HH:mm:ss&lt;/td&gt;
&lt;td&gt;存储时分秒&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;year&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;yyyy&lt;/td&gt;
&lt;td&gt;存储年&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;yyyy-MM-dd HH:mm:ss&lt;/td&gt;
&lt;td&gt;存储日期+时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;timestamp&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;yyyy-MM-dd HH:mm:ss&lt;/td&gt;
&lt;td&gt;存储日期+时间，可作时间戳&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;下面我们还是用SQL来验证一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;exists&lt;/span&gt;&lt;span&gt; test_time;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; test_time (
    date_value date,
    time_value time,
    year_value &lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;,
    datetime_value &lt;/span&gt;&lt;span&gt;datetime&lt;/span&gt;&lt;span&gt;,
    timestamp_value &lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt;&lt;span&gt;
) engine&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;innodb charset&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8;

&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test_time &lt;span&gt;values&lt;/span&gt;(now(), now(), now(), now(), now());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看一下插入后的结果：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201803/801753-20180314220807482-608927767.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MySQL的时间类型的知识点比较简单，这里重点关注一下datetime与timestamp两种类型的区别：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;上面列了，datetime占8个字节，timestamp占4个字节&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;由于大小的区别，datetime与timestamp能存储的时间范围也不同，datetime的存储范围为1000-01-01 00:00:00——9999-12-31 23:59:59，timestamp存储的时间范围为19700101080001——20380119111407&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;datetime默认值为空，当插入的值为null时，该列的值就是null；timestamp默认值不为空，当插入的值为null的时候，mysql会取当前时间&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;datetime存储的时间与时区无关，timestamp存储的时间及显示的时间都依赖于当前时区&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在实际工作中，一张表往往我们会有两个默认字段，一个记录创建时间而另一个记录最新一次的更新时间，这种时候可以使用timestamp类型来实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
create_time &lt;span&gt;timestamp&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;current_timestamp&lt;/span&gt;&lt;span&gt; comment &quot;创建时间&quot;,
update_time &lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;current_timestamp&lt;/span&gt; &lt;span&gt;on&lt;/span&gt; &lt;span&gt;update&lt;/span&gt; &lt;span&gt;current_timestamp&lt;/span&gt;&lt;span&gt; comment &quot;修改时间&quot;,&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;char和varchar类型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后看一下常用到的字符型，说到MySQL字符型，我们最熟悉的应该就是char和varchar了，关于char和varchar的对比，我总结一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;char是固定长度字符串，其长度范围为0~255且与编码方式无关，无论字符实际长度是多少，都会按照指定长度存储，不够的用空格补足；varchar为可变长度字符串，在utf8编码的数据库中其长度范围为0~21844&lt;/li&gt;
&lt;li&gt;char实际占用的字节数即存储的字符所占用的字节数，varchar实际占用的字节数为存储的字符+1或+2或+3&lt;/li&gt;
&lt;li&gt;MySQL处理char类型数据时会将结尾的所有空格处理掉而varchar类型数据则不会&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关于第一点、第二点，稍后专门开一个篇幅解释，关于第三点，写一下SQL验证一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;exists&lt;/span&gt;&lt;span&gt; test_string;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; test_string (
    char_value &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;),
    varchar_value &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;)
) engine&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;innodb charset&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8;

&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test_string &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test_string &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt; a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt; a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test_string &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test_string &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt; a &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt; a &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用length函数来看一下结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201803/801753-20180314220942291-1765757687.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;验证了我们的结论，char类型数据并不会取最后的空格。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;varchar型数据占用空间大小及可容纳最大字符串限制探究&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接上一部分，我们这部分来探究一下varchar型数据实际占用空间大小是如何计算的以及最大可容纳的字符串为多少，首先要给出一个结论：&lt;span&gt;&lt;strong&gt;这部分和具体编码方式有关，且MySQL版本我现在使用的是5.7，当然5.0之后的都是可以的&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先写一段SQL创建表，utf8的编码格式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;exists&lt;/span&gt;&lt;span&gt; test_varchar;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; test_varchar (
    varchar_value &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100000&lt;/span&gt;&lt;span&gt;)
) engine&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;innodb charset&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行报错：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Column&lt;/span&gt; length too big &lt;span&gt;for&lt;/span&gt; &lt;span&gt;column&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;varchar_value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (&lt;span&gt;max&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;21845&lt;/span&gt;); &lt;span&gt;use&lt;/span&gt; BLOB &lt;span&gt;or&lt;/span&gt; &lt;span&gt;TEXT&lt;/span&gt;&lt;span&gt; instead&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;按照提示，我们把大小改为21845，执行依然报错：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Row size too large. The maximum row size &lt;span&gt;for&lt;/span&gt; the used &lt;span&gt;table&lt;/span&gt; type, &lt;span&gt;not&lt;/span&gt; counting BLOBs, &lt;span&gt;is&lt;/span&gt; &lt;span&gt;65535&lt;/span&gt;. This includes storage overhead, &lt;span&gt;check&lt;/span&gt; the manual. You have &lt;span&gt;to&lt;/span&gt; change &lt;span&gt;some&lt;/span&gt; columns &lt;span&gt;to&lt;/span&gt; &lt;span&gt;TEXT&lt;/span&gt; &lt;span&gt;or&lt;/span&gt;&lt;span&gt; BLOBs&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改为21844就不会有问题，因此在utf8编码下我们可以知道varchar(M)，M最大=21844。那么gbk呢：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;exists&lt;/span&gt;&lt;span&gt; test_varchar;
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; test_varchar (
    varchar_value &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100000&lt;/span&gt;&lt;span&gt;)
) engine&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;innodb charset&lt;span&gt;=&lt;/span&gt;&lt;span&gt;gbk;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;同样的报错：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Column&lt;/span&gt; length too big &lt;span&gt;for&lt;/span&gt; &lt;span&gt;column&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;varchar_value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (&lt;span&gt;max&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;32767&lt;/span&gt;); &lt;span&gt;use&lt;/span&gt; BLOB &lt;span&gt;or&lt;/span&gt; &lt;span&gt;TEXT&lt;/span&gt;&lt;span&gt; instead&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;把大小改为32766，也是和utf8编码格式一样的报错：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Row size too large. The maximum row size &lt;span&gt;for&lt;/span&gt; the used &lt;span&gt;table&lt;/span&gt; type, &lt;span&gt;not&lt;/span&gt; counting BLOBs, &lt;span&gt;is&lt;/span&gt; &lt;span&gt;65535&lt;/span&gt;. This includes storage overhead, &lt;span&gt;check&lt;/span&gt; the manual. You have &lt;span&gt;to&lt;/span&gt; change &lt;span&gt;some&lt;/span&gt; columns &lt;span&gt;to&lt;/span&gt; &lt;span&gt;TEXT&lt;/span&gt; &lt;span&gt;or&lt;/span&gt;&lt;span&gt; BLOBs&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可见gbk的编码格式下，varchar(M)最大的M=32765，那么为什么会有这样的区别呢，分点详细解释一下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;MySQL要求一个行的定义长度不能超过65535即64K&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对于未指定varchar字段not null的表，会有1个字节专门表示该字段是否为null&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;varchar(M)，当M范围为0&amp;lt;=M&amp;lt;=255时会专门有一个字节记录varchar型字符串长度，当M&amp;gt;255时会专门有两个字节记录varchar型字符串的长度，把这一点和上一点结合，那么65535个字节实际可用的为65535-3=65532个字节&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;所有英文无论其编码方式，都占用1个字节，但对于gbk编码，一个汉字占两个字节，因此最大M=65532/2=32766；对于utf8编码，一个汉字占3个字节，因此最大M=65532/3=21844，上面的结论都成立&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;举一反三，对于utfmb4编码方式，1个字符最大可能占4个字节，那么varchar(M)，M最大为65532/4=16383，可以自己验证一下&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;同样的，上面是表中只有varchar型数据的情况，&lt;span&gt;&lt;strong&gt;如果表中同时存在int、double、char这些数据，需要把这些数据所占据的空间减去，才能计算varchar(M)型数据M最大等于多少&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;varchar、text和blob&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后讲一讲text和blob两种数据类型，它们的设计初衷是为了存储大数据使用的，因为之前说了，MySql单行最大数据量为64K。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先说一下text，text和varchar是一组既有区别又有联系的数据类型，其联系在于&lt;span&gt;&lt;strong&gt;当varchar(M)的M大于某些数值时，varchar会自动转为text&lt;/strong&gt;&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;M&amp;gt;255时转为tinytext&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;M&amp;gt;500时转为text&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;M&amp;gt;20000时转为mediumtext&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;所以过大的内容varchar和text没有区别，同事varchar(M)和text的区别在于：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;单行64K即65535字节的空间，varchar只能用63352/65533个字节，但是text可以65535个字节全部用起来&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;text可以指定text(M)，但是M无论等于多少都没有影响&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;text不允许有默认值，varchar允许有默认值&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;varchar和text两种数据类型，使用建议是&lt;span&gt;&lt;strong&gt;能用varchar就用varchar而不用text（存储效率高）&lt;/strong&gt;&lt;/span&gt;，varchar(M)的M有长度限制，之前说过，如果大于限制，可以使用mediumtext（16M）或者longtext（4G）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至于text和blob，简单过一下就是&lt;span&gt;&lt;strong&gt;text存储的是字符串而blob存储的是二进制字符串&lt;/strong&gt;&lt;/span&gt;，简单说blob是用于存储例如图片、音视频这种文件的二进制数据的。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 14 Mar 2018 14:45:00 +0000</pubDate>
<dc:creator>五月的仓颉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xrq730/p/8446246.html</dc:identifier>
</item>
<item>
<title>angularjs promise详解 - 柴小智</title>
<link>http://www.cnblogs.com/chaixiaozhi/p/8570588.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chaixiaozhi/p/8570588.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、什么是Promise&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Promise是对象，代表了一个函数最终可能的返回值或抛出的异常，就是用来异步处理值的。&lt;/p&gt;
&lt;p&gt;Promise是一个构造函数，自己身上有all、reject、resolve这几个异步方式处理值的方法，原型上有then、catch等同样很眼熟的方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、为什么使用Promise&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有了&lt;code&gt;Promise&lt;/code&gt;对象，就可以把异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，&lt;code&gt;Promise&lt;/code&gt;对象提供了统一的接口，使得控制异步操作更加容易。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;对象有以下2个特点： &lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.对象的状态不受外界影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;对象代表一个异步操作，有三种状态：&lt;code&gt;Pending(进行中)&lt;/code&gt;、&lt;code&gt;Resolved(已完成)&lt;/code&gt;和&lt;code&gt;Rejected(已失败)&lt;/code&gt;。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。&lt;/p&gt;
&lt;p&gt;2.一旦状态改变，就不会再变，任何时候都可以得到这个结果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;对象的状态改变，只有两种可能：从&lt;code&gt;Pending&lt;/code&gt;变为&lt;code&gt;Resolved&lt;/code&gt;；从&lt;code&gt;Pending&lt;/code&gt;变为&lt;code&gt;Rejected&lt;/code&gt;。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、如何创建一个Promise&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先贴一段代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;define([
    &lt;/span&gt;'angularModule'&lt;span&gt;
],&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (app) {
    app.register.service(&lt;/span&gt;'httpRequestService', ['$http', '$q', &lt;span&gt;function&lt;/span&gt;&lt;span&gt; ($http, $q) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
            request: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (params) {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; deferred =&lt;span&gt; $q.defer();
                $http({
                    method : params.method,
                    url : params.url
                }).success(
                    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
                        deferred.resolve(data);
                    }
                ).error(
                    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
                        deferred.reject(data);
                    }
                );
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; deferred.promise;
            }
        }
    }])
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;strong&gt;讲一下$q服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;q服务是AngularJS中自己封装实现的一种Promise实现。&lt;/p&gt;
&lt;p&gt;要创建一个deferred对象，可以调用defer()方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; deferred = $q.defer();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;deffered上面暴露了三个方法，以及一个可以用于处理promise的promise属性。  //promise属性里面又包含了then、catch、finally三个方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180314213052759-2105846678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在Promise中，定义了三种状态：等待状态，完成状态，拒绝状态。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;deffered API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.deffered 对象的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.resolve(value)：在声明resolve()处，表明promise对象由pending状态转变为resolve。&lt;br/&gt;2.reject(reason)：在声明resolve()处，表明promise对象由pending状态转变为rejected。&lt;br/&gt;3.notify(value) ：在声明notify()处，表明promise对象unfulfilled状态，在resolve或reject之前可以被多次调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.deffered 对象属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;promise ：&lt;span&gt;最后返回的是一个新的deferred对象 promise 属性，而不是原来的deferred对象。&lt;/span&gt;这个新的Promise对象只能观察原来Promise对象的状态，而无法修改deferred对象的内在状态可以防止任务状态被外部修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.Promise API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当创建 deferred 实例时会创建一个新的 promise 对象,并可以通过 deferred.promise 得到该引用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;promise 对象的目的是在 deferred 任务完成时,允许感兴趣的部分取得其执行结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.promise 对象的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.then(errorHandler, fulfilledHandler, progressHandler)：then方法用来监听一个Promise的不同状态。errorHandler监听failed状态，fulfilledHandler监听fulfilled状态，progressHandler监听unfulfilled（未完成）状态。此外,notify 回调可能被调用 0到多次，提供一个进度指示在解决或拒绝（resolve和rejected）之前。&lt;/p&gt;
&lt;p&gt;2.catch(errorCallback) —— promise.then(null, errorCallback) 的快捷方式&lt;/p&gt;
&lt;p&gt;3.finally(callback) ——让你可以观察到一个 promise 是被执行还是被拒绝, 但这样做不用修改最后的 value值。 这可以用来做一些释放资源或者清理无用对象的工作,不管promise 被拒绝还是解决。 &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;q常用的几个方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;defer() 创建一个deferred对象，这个对象可以执行几个常用的方法，比如resolve,reject,notify等&lt;/li&gt;
&lt;li&gt;all() 传入Promise的数组，批量执行，返回一个promise对象&lt;/li&gt;
&lt;li&gt;when() 传入一个不确定的参数，如果符合Promise标准，就返回一个promise对象。 &lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;all&quot;&gt;all()方法&lt;/h3&gt;
&lt;p&gt;当批量的执行某些方法时，就可以使用这个方法。有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据。&lt;/p&gt;
&lt;p&gt;用Promise.all来执行，all接收一个数组参数，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，&lt;span&gt;等到它们都执行完后才会进到then里面&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是 下面的results。所以下面代码的输出结果就是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; funcA = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                console.log(&lt;/span&gt;&quot;funcA&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello,funA&quot;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; funcB = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                console.log(&lt;/span&gt;&quot;funcB&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello,funB&quot;&lt;span&gt;;
            }
            $q.all([funcA(),funcB()])
            .then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(result){
                console.log(result);
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行的结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;funcA
funcB
Array [ &lt;/span&gt;&quot;hello,funA&quot;, &quot;hello,funB&quot; ] 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;when&quot;&gt;when()方法&lt;/h3&gt;
&lt;p&gt;when方法中可以传入一个参数，这个参数可能是一个值，可能是一个符合promise标准的外部对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; funcA = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                console.log(&lt;/span&gt;&quot;funcA&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello,funA&quot;&lt;span&gt;;
            }
            $q.when(funcA())
            .then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(result){
                console.log(result);
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当传入的参数不确定时，可以使用这个方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
hello,funA
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;四、链式请求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过then()方法可以实现promise链式调用,因为then方法总是返回一个新的promise。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;runAsync1()
.then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
    console.log(data);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; runAsync2();
})
.then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
    console.log(data);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; runAsync3();
})
.then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
    console.log(data);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; runAsync1(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;做一些异步操作&lt;/span&gt;
        setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            console.log(&lt;/span&gt;'异步任务1执行完成'&lt;span&gt;);
            resolve(&lt;/span&gt;'随便什么数据1'&lt;span&gt;);
        }, &lt;/span&gt;1000&lt;span&gt;);
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;            
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; runAsync2(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;做一些异步操作&lt;/span&gt;
        setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            console.log(&lt;/span&gt;'异步任务2执行完成'&lt;span&gt;);
            resolve(&lt;/span&gt;'随便什么数据2'&lt;span&gt;);
        }, &lt;/span&gt;2000&lt;span&gt;);
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;            
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; runAsync3(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p = &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve, reject){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;做一些异步操作&lt;/span&gt;
        setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
            console.log(&lt;/span&gt;'异步任务3执行完成'&lt;span&gt;);
            resolve(&lt;/span&gt;'随便什么数据3'&lt;span&gt;);
        }, &lt;/span&gt;2000&lt;span&gt;);
    });
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;            
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1047894/201803/1047894-20180314221140084-1552346466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 14 Mar 2018 14:35:00 +0000</pubDate>
<dc:creator>柴小智</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chaixiaozhi/p/8570588.html</dc:identifier>
</item>
<item>
<title>记一次结合PHP多进程和socket.io解决问题的经历 - 编程人，在天涯</title>
<link>http://www.cnblogs.com/wujuntian/p/8570567.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wujuntian/p/8570567.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　公司是做棋牌游戏的。前段时间接到一个后台人工鉴定并处理通牌作弊玩家的需求，其中需要根据几个玩家的游戏ID查询并计算他们在某段时间内彼此之间玩牌输赢次数和输赢总额。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　牌局数据是存储在日志中心的，他们把牌局数据分成两个表来存储，一个表存储牌局概况数据，例如牌局时间、牌局ID、桌子ID、用户ID等信息，另一个表则存储每一个牌局的详情数据，例如，牌局有多少玩家参与，荷官在哪一轮发了什么牌，玩家每一轮都有什么动作等等。要想计算出几个玩家在某段时间之内玩牌输赢次数和输赢总额，就需要知道每一个牌局的详情数据，所以需要针对每一个玩家的游戏ID，先查询第一个表，查出所有牌局概况数据列表，然后遍历这个列表，根据每个牌局的牌局ID、桌子ID，从第二个表中查询每个牌局的详情数据，所有玩家的所有牌局详情数据都查询完成之后再进行统计。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　日志中心的同学给出了查询以上两个表的接口，其中牌局详情的查询接口一次只能查询一个牌局的数据（和他们使用的数据表设计有关）。刚开始我的做法是在js代码中遍历所有给出的玩家ID，先查询出每个玩家的牌局列表，然后使用第二层循环来调用接口请求每一个牌局的详情数据，但这样做的问题是，有些用户在某段时间内的牌局数量是很大的，尽管控制了查询时间段的最大范围，但还是出现了一个用户几千个牌局的情况，这就意味着浏览器需要几乎在同一时间内对同一个域名的服务器发出几千个请求，而浏览器是基于域名进行并发控制的，超过限制数量的请求会被阻塞，阻塞严重的时候经常导致页面变成空白，好长时间才恢复，得到查询结果。这样的体验显然是不行的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那怎么办呢？在老大的指导下，几经思虑，决定采用PHP多线程结合socket.io来完成这个任务。整体思路是这样的：首先js向PHP发起数据查询请求，PHP收到请求之后不是直接进行数据查询，而是在后台挂载一个进程去处理请求，然后返回一个确认状态值给js，这时js请求暂时结束了。这样做好处有二：其一，js请求的PHP接口是php-fpm运行的，使用php-fpm来fork多进程不太稳定，而使用php比较稳定；其二，可以避免数据查询过程时间太长导致超时。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　挂载进程代码示例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&lt;span&gt;&amp;lt;?php
$par = ['startTime' =&amp;gt; '', 'endTime' =&amp;gt; '', 'mids' =&amp;gt; $mid, ...];//牌局查询参数
$pKey = 'plog_proccess';//传给命令行的参数，作为进程标识，便于查询统计当前进程数量
$php = '/usr/local/php/bin/php';//php执行文件路径
$file = '/www/query.php';//牌局查询脚本文件
$cmd = $php.' '.$file.' '.$pKey.' '.base64_encode(serialize($par)).' &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;';//命令
system($cmd);//执行命令，挂载后台进程执行查询
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　接下来就要在进程运行的PHP脚本/www/query.php中进行数据查询了。首先遍历每一个玩家ID，查出每个玩家的所有牌局列表，然后遍历每个玩家的牌局列表，fork多个子进程进行每个牌局详情数据的查询了，一个子进程负责查询一个牌局的详情数据，并将数据写入文件中，代码示例如下：（注意：以下代码只是基本代码框架，无法直接运行）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&lt;span&gt;&amp;lt;?php
$pKey = $argv[1];
$par = unserialize(base64_decode($argv[2]));
$mids = $par['mids'];
$max_pnum = 100;//最大子进程数量，避免抢占了过多的资源

for($mids as $mid) {//遍历查询各个用户的牌局数据
        $list = ...;//这里进行当前用户牌局列表数据查询
        $num = count($list);//牌局总数
        $count = 0;//已有多少个牌局在查询
        
        while(true) {//fork多个子进程查询各个牌局的详情数据
                $s = &quot;ps aux|awk '&quot; . '/query.php/ &amp;amp;&amp;amp; /' . $pKey . '/ &amp;amp;&amp;amp; !/awk/' . &quot;'|wc -l&quot;;
                ob_start();
                system($s);
                $pNum = (int)ob_get_clean();//当前查询进程数量
                
                if($count &amp;gt;= $num) {//当前牌局列表都已经交给各个子进程查询了
                        if($pnum &amp;gt; 1) {//有子进程没有完成，稍等
                                sleep(3);
                                continue;
                        } else {//所有子进程都已经完成，退出while循环，回到for循环中查询下一个用户的牌局数据
                                break;
                        }
                } else if($pNum &amp;gt; $max_pnum) {//子进程数量超出限制，稍等
                        sleep(3);
                        continue;
                }
                
                $rs = $list[$count];//从牌局列表中取出一个牌局来进行牌局详情数据查询
                pcntl_signal(SIGCHLD, SIG_IGN);
                $pid = pcntl_fork();//fork一个子进程，子进程会从此位置开始执行
                if($pid &amp;lt; 0) {//子进程创建失败
                        //这里可以做一些日志记录
                        
                        exit(0);
                }
                if($pid) {//子进程创建成功（主进程逻辑）
                        $count ++;
                        
                } else if($pid == 0) {//进行牌局详情数据查询（子进程逻辑）
                        $pid = posix_setsid();//子进程ID
                        //这里根据$rs中的牌局数据进行牌局详情查询，并将得到的数据写入当前子进程专属文件（文件路径+文件名要唯一，可以使用时间戳、桌子ID和牌局ID组合表示）
                        
                        exit(0);//当前子进程任务完成，退出
                }
        }
}
exit(0);//查询完成，主进程退出
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这个PHP后台挂载进程执行完成之后，所有需要查询的牌局数据就已经全部写入文件中了。现在问题来了，PHP应该怎么把这些数据传给前端页面呢？我们知道http协议是单向协议，只能由前端向服务器主动发起请求，而服务器是无法主动把数据发送给前端的，那怎么办呢？使用socket.io!可以在所有子进程执行完成之后，通过socket.io使用当前sock连接通知js，js收到消息之后即发送请求给一个PHP接口，这个PHP接口的任务便是读取上述多进程在文件中写下的数据，返回给js进行页面渲染。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　关于socket.io，没有进行过多研究，使用的是公司框架封装好的，当然也可以使用原生的，简单教程地址：http://www.workerman.net/phpsocket_io，这里只是简单介绍一下思路。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　首先需要到上面这个地址中下载phpsocket，然后启动一个服务端，注意，只能在命令行中启动，同样可以作为一个后台挂载进程运行。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&lt;span&gt;&amp;lt;?php
require_once __DIR__ . '/socketio/vendor/autoload.php';
use Workerman\Worker;
use PHPSocketIO\SocketIO;

//创建socket.io服务器，监听2021端口
$io = new SocketIO(2021);

//向客户端发送消息，通知数据已查询完成
$io-&amp;gt;emit('hello', json_encode([1 =&amp;gt; 'hello', 'aaa' =&amp;gt; 'ewfewr']));

Worker::runAll();
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　然后在客户端js中监听这个消息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&lt;span&gt;&amp;lt;script src='https://cdn.bootcss.com/socket.io/2.0.3/socket.io.js'&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
var socket = io('http://127.0.0.1:2021');
socket.on('hello', function(par){
        //这里便是发送请求到PHP接口进行数据读取了
});
&amp;lt;/script&amp;gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　若是觉得使用原生socket.io麻烦，也可以使用封装好的ElephantIO。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当然，这里有个问题，就是写数据产生的文件会越来越多，可以在每次挂载进程进行写文件之前先把之前写的文件（已经没用了的）进行删除：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&lt;span&gt;function rmDataDir($dir) {
        if(!is_dir($dir)) return;
        
        $handle = opendir($dir);
        while($file = readdir($handle)) {
                if(in_array($file, ['.', '..'])) continue;
                
                $str = $dir . $file;
                if(is_dir($str)) {
                        rmDataDir($str . '/');
                } else {
                        unlink($str);
                }
        }
        closedir($handle);
        $arr = scandir($dir);//readdir()有时候没有识别完所有文件就返回false了。。。
        if(count($arr) &amp;lt;= 2) {//只有.和..的时候可以删除
                rmdir($dir);
        }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　同时，由于在这个功能中，每次发送查询数据请求的代价都是比较昂贵的，可以考虑在js中对查询过的数据进行缓存，例如，相同查询条件下相同用户ID，已经查询过的就不需要查询了，直接从js缓存中读取数据进行页面渲染就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　然而，尽管使用了PHP多进程，但是进行了很多的文件读写操作，磁盘IO也是很耗时间的，所以速度上并没有提升多少，只是不会再出现浏览器页面卡死的情况了。这个功能中关于速度的提升不知还有什么更好的方法呢？？？各位朋友，走过路过，别忘了给下建议哈~&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 14 Mar 2018 14:30:00 +0000</pubDate>
<dc:creator>编程人，在天涯</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wujuntian/p/8570567.html</dc:identifier>
</item>
<item>
<title>.NET Core 配置Configuration杂谈 - 晓晨Master</title>
<link>http://www.cnblogs.com/stulzq/p/8570496.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stulzq/p/8570496.html</guid>
<description>&lt;p&gt;.NET Core 在配置文件的操作上相对于.NET Framework做了不少改变，今天来聊一聊。关于Configuration的Package都是以&lt;code&gt;Microsoft.Extensions.Configuration&lt;/code&gt;开头的支持多种方式的配置，包括内存、Json文件、XML文件等等，今天我们主要用Json格式文件配置来演示。&lt;/p&gt;

&lt;p&gt;新建一个ConsoleApp（这里为了方便演示就用控制台程序来演示了，而不用ASP.NET Core），添加两个Package：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Install-Package Microsoft.Extensions.Configuration -Version 2.0.1
Install-Package Microsoft.Extensions.Configuration.Json -Version 2.0.1&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var builder = new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile(&quot;appsettings.json&quot;)；

var config = builder.Build();

//读取配置
Console.WriteLine(config[&quot;Alipay:AppId&quot;]);
Console.WriteLine(config[&quot;Alipay:PriviteKey&quot;]);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的Json文件内容如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;Alipay&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;AppId&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;20185555&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;PriviteKey&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;dasfdafafafa&quot;&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们通过&lt;code&gt;ConfigurationBuilder&lt;/code&gt;对象来创建&lt;code&gt;ConfigurationRoot&lt;/code&gt;对象，并用其来读取配置。&lt;code&gt;SetBasePath()&lt;/code&gt;方法是用来设置我们配置对象需要的配置文件的基础路径，比如我们将基础路径设置为&lt;code&gt;C:\ConsoleApp&lt;/code&gt;，那么他读取我们的配置文件&lt;code&gt;appsettings.json&lt;/code&gt;的路径将是&lt;code&gt;C:\ConsoleApp\appsettings.json&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201803/668104-20180314220855222-108948421.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们新建一个&lt;code&gt;appsettings.Test.json&lt;/code&gt;文件，添加如下内容:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;Alipay&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;AppId&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;20185555Testss&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;PriviteKey&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;dasfdafafafaTestss&quot;&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后修改一下代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var builder = new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile(&quot;appsettings.json&quot;)
    .AddJsonFile(&quot;appsettings.Test.json&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看见我们向&lt;code&gt;ConfigurationBuilder&lt;/code&gt;对象设置了两次Json文件，看一下运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201803/668104-20180314220830218-712352111.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以得出结论：读取配置的时候会选择最后添加的文件。&lt;/p&gt;
&lt;p&gt;那么我们前一个文件去哪了呢？我们的&lt;code&gt;ConfigurationRoot&lt;/code&gt;对象有一个&lt;code&gt;Providers&lt;/code&gt;属性存储了，我们添加的文件信息，我们可以遍历它：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;foreach (var provider in config.Providers)
{
    provider.TryGet(&quot;Alipay:AppId&quot;, out string val);

    Console.WriteLine(val);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201803/668104-20180314221208716-873029118.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出我们两个文件的值都被读取到了！&lt;/p&gt;

&lt;p&gt;我们的配置文件可能会被更改，那么我们如何获取最新的配置？我们在添加文件的时候可以将一个名为&lt;code&gt;reloadOnChange&lt;/code&gt;的参数设置为true，那么当我们的文件发生更改时，就会重新载入配置到内存中来，然后我们获取到的配置就行最新的。我们读取配置的时候并不是每次读取都是从文件里面读取，而是配置文件的所有配置信息都会被加载到内存中来，我们每次从内存读取就行了。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
var builder = new ConfigurationBuilder()
    .SetBasePath(Directory.GetCurrentDirectory())
    .AddJsonFile(&quot;appsettings.json&quot;)
    .AddJsonFile(&quot;appsettings.Test.json&quot;,true,reloadOnChange:true);

var config = builder.Build();

//读取配置
Console.WriteLine(config[&quot;Alipay:AppId&quot;]);
Console.WriteLine(config[&quot;Alipay:PriviteKey&quot;]);

Console.WriteLine(&quot;更改文件之后，按下任意键&quot;);
Console.ReadKey();

Console.WriteLine(&quot;change:&quot;);
Console.WriteLine(config[&quot;Alipay:AppId&quot;]);
Console.WriteLine(config[&quot;Alipay:PriviteKey&quot;]);

Console.ReadKey();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看一下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201803/668104-20180314221949129-1428170469.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今天就到这里了！&lt;/p&gt;
</description>
<pubDate>Wed, 14 Mar 2018 14:20:00 +0000</pubDate>
<dc:creator>晓晨Master</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stulzq/p/8570496.html</dc:identifier>
</item>
<item>
<title>【最新】Power BI混合现实应用Mixed Reality app预览版发布 - 数据之巅</title>
<link>http://www.cnblogs.com/asxinyu/p/Power_BI_MixedRealityApp.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/asxinyu/p/Power_BI_MixedRealityApp.html</guid>
<description>&lt;p&gt;2018年3月13日，Power BI在官方博客和Docs文档发布了Power BI for Mixed Reality应用预览版的消息，&lt;/p&gt;
&lt;p&gt;也就是可以以后在更虚拟的世界中来观察你的报表，想象一下HoloLens可以在你家里把报表任意摆放，很有意思。&lt;/p&gt;
&lt;p&gt;当然，&lt;span&gt;HoloLens的普及还有点慢，但也是未来的趋势。已经在windows 商店可以下载。参考下面2篇文章：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://powerbi.microsoft.com/en-us/blog/power-bi-for-mixed-reality-app-now-available-in-preview/&quot;&gt;https://powerbi.microsoft.com/en-us/blog/power-bi-for-mixed-reality-app-now-available-in-preview/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/power-bi/mobile-mixed-reality-app&quot;&gt;https://docs.microsoft.com/en-us/power-bi/mobile-mixed-reality-app&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载链接:&lt;a href=&quot;https://www.microsoft.com/zh-cn/store/p/power-bi-for-mixed-reality-preview/9nblgggzlxn1#system-requirements&quot;&gt;https://www.microsoft.com/zh-cn/store/p/power-bi-for-mixed-reality-preview/9nblgggzlxn1#system-requirements&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1.可以使用Windows经典视图和全息视图。可以在将你想要的仪表盘或者报表切换导全息视图。&lt;/p&gt;
&lt;p&gt;2.可以用拇指和食指进行操作，就是替代以前的鼠标操作。&lt;/p&gt;
&lt;p&gt;3.语音支持，比如可以使用“Follow me”，窗口跟随你的目光移动，等等，还支持“Dock”停留，“Remove”等命令。&lt;/p&gt;
&lt;p&gt;4.支持扫描报表二维码&lt;/p&gt;
&lt;p&gt;5.支持Windows 10、Windows 10 Mobil&lt;/p&gt;
&lt;p&gt;在编写这篇文章的过程中，已经看到高飞大神率先在公众号号发布了消息，链接如下:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://url.cn/5wC2mr2&quot;&gt;http://url.cn/5wC2mr2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/79603/201803/79603-20180314213132473-881296653.png&quot; alt=&quot;&quot; width=&quot;550&quot; height=&quot;304&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/79603/201803/79603-20180314212939309-217971634.png&quot; alt=&quot;&quot; width=&quot;549&quot; height=&quot;289&quot;/&gt; &lt;/p&gt;
</description>
<pubDate>Wed, 14 Mar 2018 13:37:00 +0000</pubDate>
<dc:creator>数据之巅</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/asxinyu/p/Power_BI_MixedRealityApp.html</dc:identifier>
</item>
<item>
<title>LVS-NAT模式的配置详解 - HappenLee</title>
<link>http://www.cnblogs.com/happenlee/p/8570197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/happenlee/p/8570197.html</guid>
<description>&lt;p&gt;由于实验室拟态存储的项目需要通过NAT模式来映射NFS服务器已实现负载均衡的目的，通过调研了多种负载均衡机制，笔者最终选择了&lt;strong&gt;LVS的NAT模式&lt;/strong&gt;来实现需求，接下来通过博客来记录一下LVS-NAT模式的配置流程。&lt;/p&gt;
&lt;h3 id=&quot;lvs服务的简介&quot;&gt;1.LVS服务的简介：&lt;/h3&gt;
&lt;blockquote readability=&quot;7.8664192949907&quot;&gt;
&lt;p&gt;&lt;strong&gt;LVS&lt;/strong&gt;是&lt;strong&gt;Linux Virtual Server&lt;/strong&gt;的简写，意即&lt;strong&gt;Linux虚拟服务器&lt;/strong&gt;，是一个虚拟的服务器集群系统，在1998年5月由&lt;a href=&quot;https://baike.baidu.com/item/%E7%AB%A0%E6%96%87%E5%B5%A9&quot;&gt;章文嵩&lt;/a&gt;先生主导开发。LVS集群实现了IP负载均衡技术和基于内容请求分发技术。调度器通过将请求均衡地转移到不同的服务器上执行，且可以屏蔽掉后台故障的服务器，从而将一组服务器构成一个高性能的、高可用的服务器集群，而这样的结构对客户端来说是完全透明的，所以无需修改客户端和服务器端的程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;LVS服务器可以让客户端将LVS服务器作为一个连接的单点，仅仅通过连接LVS服务器便可以得到后端一整个服务器集群的处理与存储能力，这样能够大大提高系统的扩展性与可用性，同时也能够提供服务的安全性，单一入侵一台服务器并不会破坏其他与该服务器隔离的服务。&lt;/p&gt;
&lt;h4 id=&quot;lvs的模式&quot;&gt;LVS的模式&lt;/h4&gt;
&lt;p&gt;LVS可以支持如下三种模式：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Virtual Server via Network Address Translation（VS/NAT）&lt;/strong&gt;&lt;br/&gt;通过网络地址转换，调度器重写请求报文的目标地址，根据预设的调度算法，将请求分派给后端的真实服务器；真实服务器的响应报文通过调度器时，报文的源地址被重写，再返回给客户，完成整个负载调度过程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Virtual Server via IP Tunneling（VS/TUN)&lt;/strong&gt;&lt;br/&gt;采用NAT技术时，由于请求和响应报文都必须经过调度器地址重写，当客户请求越来越多时，调度器的处理能力将成为瓶颈。为了解决这个问题，调度器把请求报 文通过IP隧道转发至真实服务器，而真实服务器将响应直接返回给客户，所以调度器只处理请求报文。由于一般网络服务应答比请求报文大许多，采用 VS/TUN技术后，集群系统的最大吞吐量可以提高10倍。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;Virtual Server via Direct Routing（VS/DR）&lt;/strong&gt;&lt;br/&gt;VS/DR通过改写请求报文的MAC地址，将请求发送到真实服务器，而真实服务器将响应直接返回给客户。同VS/TUN技术一样，VS/DR技术可极大地 提高集群系统的伸缩性。这种方法没有IP隧道的开销，对集群中的真实服务器也没有必须支持IP隧道协议的要求，但是要求调度器与真实服务器都有一块网卡连 在同一物理网段上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;鉴于ip安全的需求，这里我们需要分割LVS服务器与后端负载集群的ip地址，并且对于负载均衡集群的数目没有太大的需求，所以笔者选用了&lt;strong&gt;Virtual Server via Network Address Translation（VS/NAT)&lt;/strong&gt; 模式。&lt;/p&gt;
&lt;h3 id=&quot;系统环境&quot;&gt;2.系统环境：&lt;/h3&gt;
&lt;p&gt;如下图所示,这是&lt;strong&gt;LVS-NAT模式&lt;/strong&gt;下的系统结构图：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8552201-a6fbabca490d6faf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;LVS-NAT模式的结构图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;系统平台：&lt;strong&gt;Ubuntu 16.04 LTS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Load Balancer&lt;/strong&gt;: 双网卡&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;外网地址：219.223.199.164&lt;/li&gt;
&lt;li&gt;内网地址：192.168.1.30&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Real Server&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一共有五台机器，ip地址分别为192.168.1.21~25。这里笔者由于需要挂载NFS服务器并且串联CephFS集群，所以本身Real Server上已经运行着NFS的服务端，关于NFS服务器的搭建可以参考我之前的&lt;a href=&quot;https://www.jianshu.com/p/eced793e2ce0&quot;&gt;博文&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;load-balancer服务器的配置&quot;&gt;3.Load Balancer服务器的配置：&lt;/h3&gt;
&lt;p&gt;Load Balancer服务器的配置相对来说较为复杂，我们按部就班的走下这个流程：&lt;/p&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;ipvsadm&lt;/strong&gt;&lt;br/&gt;LVS依赖于ipvsadm来进行配置，所以我们首先先安装ipvsadm：&lt;/p&gt;
&lt;p&gt;sudo apt-get install ipvsadm&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;NAT模式下的ip转发&lt;/strong&gt;&lt;br/&gt;之后我们需要配置NAT模式下的ip转发，让通过Load Balancer的ip包能够转发到真正提供服务的Real Server之上进行处理：&lt;/p&gt;
&lt;p&gt;echo 1 &amp;gt;&amp;gt; /proc/sys/net/ipv4/ip_forward //在ipv4环境下可以进行ip转发&lt;br/&gt;sudo iptables -t nat -F //清除之前的iptable的规则&lt;br/&gt;sudo iptables -t nat -A POSTROUTING -s 192.168.1.0/24 -o ens160 -j MASQUERADE&lt;br/&gt;//这里的网卡需要选择外网ip,也就是219.223.199.164对应的ip地址&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;LVS-NAT模式的配置&lt;/strong&gt;&lt;br/&gt;这里我们采取全盘转发的机制，也就是不指定端口的方式，这种用法可能相对比较少见，但由于NFS服务依赖与rpcbind选择端口，所以提供的端口是随机的，为了简单起见，我们采取全盘转发的模式。&lt;/p&gt;
&lt;p&gt;sudo ipvsadm -A -t 219.223.199.164 -s wrr -p 30 //转发对应的ip,并且采取权重轮询的策略&lt;br/&gt;sudo ipvsadm -a -t 219.223.199.164 -r 192.168.1.21 -m -w 1&lt;br/&gt;sudo ipvsadm -a -t 219.223.199.164 -r 192.168.1.22 -m -w 1&lt;br/&gt;sudo ipvsadm -a -t 219.223.199.164 -r 192.168.1.23 -m -w 1&lt;br/&gt;sudo ipvsadm -a -t 219.223.199.164 -r 192.168.1.24 -m -w 1&lt;br/&gt;sudo ipvsadm -a -t 219.223.199.164 -r 192.168.1.25 -m -w 1　//依次添加对应的Real Server服务器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下图是通过ipvsadm配置好的转发机制：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8552201-a4d95766858d2b02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;ipvsadm的配置&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;real-server服务器的配置&quot;&gt;4.Real Server服务器的配置：&lt;/h3&gt;
&lt;p&gt;Real Server这里需要配置路由，将默认的网关改为Load Balancer 服务器的内网ip地址，来实现路由转发的效果。（&lt;strong&gt;笔者这里多提一句：这里如果采用双网卡机制很容易出现，TCP连接问题，也就是syn消息收不到ack响应，所以尽量将无关的网卡警用，以免路由配置的复杂。&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;route命令的配置&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    sudo route add -net 0.0.0.0 gw 192.168.1.30&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个命令需要在每台Real Server之上执行，否则其他Real Server没有办法接受到转发的ip数据包，会被Load Balance屏蔽，从而没有办法实现我们期待的负载均衡的结果。下图所示的是Real Server服务器路由转发配置的结果：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8552201-1cf64db7d24539c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Real Server的路由表&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;lvs-nat模式的测试&quot;&gt;5.LVS-NAT模式的测试：&lt;/h3&gt;
&lt;p&gt;由于实现了LVS全盘的ip地址转发，所以任何基于TCP的网络服务都可以通过Load Balancer转发给后端的Real Server来提供对外的服务，由于笔者主要是测试NFS服务的，所以我们先在Real Server之上启动对应的NFS服务：&lt;/p&gt;
&lt;p&gt;为了使NFS服务器能正常工作，需要启动rpcbind和nfs-kernel-server两个服务，并且rpcbind一定要先于nfs-kernel-server启动。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  sudo service rpcbind start
  sudo service nfs-kernel-server start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后我们便可以执行NFS客户端的挂载工作了，过载工作很简单，先建立一个挂载目录，然后通过mount命令挂载Load Balancer的外网ip:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  sudo mkdir /mnt/ceph
  sudo mount -t nfs 219.223.199.164:/mnt/cephfs /mnt/ceph&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后客户端对应的文件目录便挂载上对应Real Server上的文件系统了。（&lt;strong&gt;这里的NFS服务是笔者预先搭建好的，读者可以自行搭建自己所需的网络服务。&lt;/strong&gt;）&lt;br/&gt;如下图所示，我们挂载了远端219.223.199.164的NFS服务器，而实际的服务是由后端的Real Server来提供的：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8552201-e34907773694999b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;挂载了远端的NFS服务器&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小结&lt;/strong&gt;:梳理了一下在LVS-NAT模式之下的安装与配置。RedHat系列的发行版也是大同小异。这里调试一定需要有足够的耐心和毅力，需要去细致的排查，否则很容易出现问题。若有疏漏，望各位指点斧正。&lt;/p&gt;
</description>
<pubDate>Wed, 14 Mar 2018 13:16:00 +0000</pubDate>
<dc:creator>HappenLee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/happenlee/p/8570197.html</dc:identifier>
</item>
<item>
<title>Nginx负载均衡——扩展功能(NGINX Plus) - 米粒人生</title>
<link>http://www.cnblogs.com/minirice/p/8570157.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minirice/p/8570157.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文主要是介绍了NGINX Plus的相关功能，横跨了NGINX Plus R5/R6/R7/R9等各个不同版本的更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是nginx-plus&quot;&gt;什么是NGINX Plus？&lt;/h2&gt;
&lt;p&gt;顾名思义，就是Nginx的加强版或者扩展版。我们知道Nginx是开源的、免费的，但是NGINX Plus的很多功能就需要收费了。Nginx Plus 可以作为一个负载均衡器，一个web服务器，还可以作为一个内容缓存。既然是Nginx的加强版，那无疑功能会比Nginx更加强大。NGINX Plus在开源Nginx已有的功能基础上，提供了许多适合生产环境的专有功能，包括session一致性、实时更新API配置、有效的健康检查等。&lt;/p&gt;
&lt;h2 id=&quot;nginx-plus的版本更新&quot;&gt;NGINX Plus的版本更新&lt;/h2&gt;
&lt;p&gt;NGINX Plus R5 和更新的版本可以支持基于TCP应用的负载均衡(比如MySQL)。这就不仅仅限制于Http的负载均衡，而是大大扩充了Nginx作为负载均衡器的作用范围。R6中TCP负载均衡功能得到很大的扩充，加入了健康检查、动态更新配置、SSL终端等。等到了R7，TCP负载均衡功能就基本和Http负载均衡差不多了。z再到了R9，就可以支持UDP了。通过这些更新，NGINX Plus 远远超过了web应用的层面，成为了一款&lt;strong&gt;意义更为广泛的负载均衡器&lt;/strong&gt;。毕竟协议是基础层面的东西，支持的协议越多，应用面也越广。从最初的Http/SMTP到TCP再到UDP，NGINX Plus一步步的变得越来越强大。&lt;/p&gt;
&lt;p&gt;开源Nginx和NGINX Plus 都支持HTTP, TCP, 和UDP应用的负载均衡。但NGINX Plus 提供了一些企业级别的功能，这些功能是收费的，包括session一致性，健康检查，动态更新配置等。&lt;/p&gt;
&lt;h2 id=&quot;http负载均衡&quot;&gt;HTTP负载均衡&lt;/h2&gt;
&lt;p&gt;NGINX Plus对Http负载均衡做了很多功能优化，诸如HTTP 升级、长连接优化、内容压缩和响应缓存等。在NGINX Plus中Http负载均衡的实现也非常简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http {
    upstream my_upstream {
        server server1.example.com;
        server server2.example.com;
    }

    server {
        listen 80;
        location / {
            proxy_set_header Host $host;
            proxy_pass http://my_upstream;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过&lt;code&gt;proxy_set_header&lt;/code&gt; 指令来设置Host，而&lt;code&gt;proxy_pass&lt;/code&gt;将请求转发到上游的&lt;code&gt;my_upstream&lt;/code&gt;中。&lt;/p&gt;
&lt;h2 id=&quot;http长连接http-keepalives&quot;&gt;Http长连接(HTTP Keepalives)&lt;/h2&gt;
&lt;p&gt;HTTP协议是用的底层TCP协议来传输请求，接收响应的。HTTP1.1支持TCP的长连接或者重利用，以免反复的创建和销毁TCP连接所带来的开销。&lt;/p&gt;
&lt;p&gt;我们看看Http的长连接：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180314191517166?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjQxMjc4NTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;Http的长连接&quot;/&gt;&lt;/p&gt;
&lt;p&gt;NGINX是一个完全意义的反向代理，在长连接上也毫不含糊。它管理所以来从客户端到Nginx的长连接，同样也会管理从Nginx到上游服务器的长连接，二者是完全独立的。&lt;/p&gt;
&lt;p&gt;Nginx管理的长连接：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180314191654074?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjQxMjc4NTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;NGINX 将连接上游服务器的空闲连接做了“缓存”，并不直接关掉它们。如果有请求过来，NGINX先从缓存的活跃连接中去拿一个使用，而不是立马创建一个新的，如果缓存为空那么NGINX 再去新建一个连接。这种操作这降低了Nginx和上游服务器之间的延迟并减少的临时端口的利用率，所以NGINX能处理大的并发。这种技术加上别的负载均衡技术，有时候可以被称为&lt;strong&gt;连接池&lt;/strong&gt;，或者连接复用。&lt;/p&gt;
&lt;p&gt;为了配置闲置长连接缓存，你需要指定几个指令：&lt;code&gt;proxy_http_version,proxy_set_header,keepalive&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server {
    listen 80;
    location / {
        proxy_pass http://backend;
        proxy_http_version 1.1; # 只有Http1.1/2.0才能支持长连接
        proxy_set_header Connection &quot;&quot;;
    }
}

upstream backend {
    server webserver1;
    server webserver2;

    # maintain a maximum of 20 idle connections to each upstream server
    keepalive 20; # 闲置长连接缓存时间为20
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;tcp-和-udp的负载均衡&quot;&gt;TCP 和 UDP的负载均衡&lt;/h2&gt;
&lt;p&gt;作为对Http协议的扩展，NGINX Plus可以直接支持基于TCP和UDP协议的应用。基于TCP的如MySQL，支持UDP的如DNS 和RADIUS应用。对于TCP请求来说，NGINX Plus接收了客户端的TCP请求，然后再创建一个TCP请求对上游服务器发起访问。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;stream {
    upstream my_upstream {
        server server1.example.com:1234;
        server server2.example.com:2345;
    }

    server {
        listen 1123 [udp];
        proxy_pass my_upstream; #注意这里没有http://了
    }
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对TCP请求的支持出现在NGINX Plus R5，R6和R7版本主要是在优化这个功能，到R7时TCP请求的负载均衡已经强大到足够媲美Http负载均衡了，到了R9，则可以支持UDP了。这里先有个印象，后面会更加详细介绍TCP负载均衡功能。&lt;/p&gt;
&lt;h2 id=&quot;连接数限制connection-limiting&quot;&gt;连接数限制(Connection Limiting)&lt;/h2&gt;
&lt;p&gt;你还可以为负载均衡做连接数量限制。这里说的连接是指NGINX Plus发给上游服务器的Http/TCP/UDP请求连接(对于UDP则是会话)。有了连接数限制的功能，当上游服务器的Http/TCP连接数量，或者UDP的会话数量超过一定的值时，NGINX Plus就不再创建新的连接或者会话。客户端多出的请求连接可以被放进队列等候，也可以不被处理。可以通过&lt;strong&gt;&lt;code&gt;max_conns,queue&lt;/code&gt;&lt;/strong&gt;指令来实现这一点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;upstream backend {
    zone backends 64k;
    queue 750 timeout=30s;

    server webserver1 max_conns=250;
    server webserver2 max_conns=150;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;server&lt;/code&gt;指令表示webserver1 最多承载250个连接而webserver2 最多150个，多出来的可以放在队列queue当中等候。在队列queue中等候的连接数量和等候时间也是有限制的。当webserver1 和webserver2 连接数降低到各自最大连接数以下时，等候在队列queue中的连接随时就补上去。&lt;br/&gt;&lt;code&gt;queue 750 timeout=30s&lt;/code&gt;表示总共可以有750个连接排队等候，每个连接等候30s。&lt;/p&gt;
&lt;p&gt;Limiting connections 是十分有用的，可以为客户端提供可持续可预见的服务——不必因为某台server负载过大导致挂掉。一般来说一台server大概能承载多少负荷是可以通过某些手段测试出来的，因此把这个可承受的上线作为max_conns指令的值便可以保证server的相对安全。&lt;/p&gt;
&lt;h2 id=&quot;least-time-负载均衡算法&quot;&gt;Least Time 负载均衡算法&lt;/h2&gt;
&lt;p&gt;在NGINX Plus R6中增加了一种新的均衡算法——Least Time，将相应时间也考虑进去，算得上对Least Connections的扩展。&lt;/p&gt;
&lt;p&gt;这种算法同时考虑当前连接数和连接池里各个节点的平均响应时间。目的是使得当前请求选择当下&lt;strong&gt;响应更快、连接更少&lt;/strong&gt;的服务器，而不是选择响应更慢、连接更多的。&lt;/p&gt;
&lt;p&gt;当连接池的各个服务器节点有着明显不同的响应延时时，这种算法就要优于其他的几种(round-robin/ip-hash/lease connections)。一个典型的应用场景是，如果有两个分布在不同的地域的数据中心，那么本地的数据中心就要比异地的数据中心延时要少得多，这个时候就不能仅仅考虑当下连接数了，这个响应的延时也要被计入考量。Least Time算法就更倾向于选择本地的，当然这只是“更倾向于”的问题，并不能代替Nginx最基本的错误转移功能，哪怕本地的数据中心响应再快，如果它挂掉了Nginx Plus也能马上切换到远端数据中心。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20180314203403616?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjQxMjc4NTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“最少时间”可以有两种计算方式，一种是从请求发出到上流服务器接返回响应头部算的时间，另一种是从请求发出到接收到全部请求体的时间，分别以&lt;code&gt;header_time&lt;/code&gt;和&lt;code&gt;response_time&lt;/code&gt;来表示。&lt;/p&gt;
&lt;h2 id=&quot;session一致性session-persistence&quot;&gt;Session一致性(Session Persistence)&lt;/h2&gt;
&lt;p&gt;Session一致性问题除了可以通过指定ip-hash的均衡算法来实现，还有更为通用的实现方式，这是在NGINX Plus 中实现的。&lt;/p&gt;
&lt;p&gt;NGINX Plus可以识别用户Session，从而能够鉴别不同的客户端，并且可以将来自同一个客户端的请求发往同一个上游服务器。这在当应用保存了用户状态的情况下非常有用，可以避免负载均衡器按照某个算法将请求发到别的服务器上去。另外，在共享用户信息的集群服务器这种方式也非常有用。&lt;/p&gt;
&lt;p&gt;session一致性的要求同一个客户端每次的请求都选择同一个服务器，而负载均衡要求我们利用一种算法去服务器连接池里面去选择下一个，那么这两种矛盾的方式可以共存么？可以的，NGINX Plus按照如下的步骤决策到底选用哪一种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果request匹配某个Session一致性的规则，那么根据这个规则选取上游服务器；&lt;/li&gt;
&lt;li&gt;如果没有匹配上或者匹配的服务器无法使用，那么使用负载均衡算法选择上游服务器；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了能保证session一致性，Nginx Plus提供了sticky cookie，sticky learn和sticky route几种规则。&lt;/p&gt;
&lt;h4 id=&quot;sticky-cookie-规则&quot;&gt;sticky cookie 规则&lt;/h4&gt;
&lt;p&gt;对于 sticky cookie 规则，当客户端的&lt;strong&gt;第一个&lt;/strong&gt;请求选择了某个上游服务器，并从这个上游服务器返回响应时，NGINX Plus 为这个响应添加一个session cookie，用来鉴别这个上游服务器。当后面的请求再过来时，NGINX Plus取出这个cookie，分析是哪一台服务器，再把请求发往这台相同的服务器。&lt;/p&gt;
&lt;p&gt;使用指令&lt;code&gt;sticky cookie&lt;/code&gt;，配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;upstream backend {
    server webserver1;
    server webserver2;

    sticky cookie srv_id expires=1h domain=.example.com path=/; 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;cookie的名字就叫srv_id，用来“记住”是哪一个server；过期时间1h，domain为&lt;code&gt;.example.com&lt;/code&gt;；path为&lt;code&gt;/&lt;/code&gt;&lt;br/&gt;NGINX Plus在第一次响应中，插入一个名称为&lt;code&gt;srv_id&lt;/code&gt;的&lt;code&gt;cookie&lt;/code&gt;，用来“记住”这第一次请求是发个哪个上游的，后面的请求带上这个&lt;code&gt;cookie&lt;/code&gt;，同样再被NGINX Plus甄别一下，再发往同一个的服务器。这样就能保证session的一致了。&lt;/p&gt;
&lt;h4 id=&quot;sticky-route-规则&quot;&gt;sticky route 规则&lt;/h4&gt;
&lt;p&gt;和&lt;code&gt;sticky cookie&lt;/code&gt;规则类似，只不过“记住”上游服务器的方式不同而已。&lt;br/&gt;在客户端发起第一次请求时，接收它的服务器为其分配一个route，此后这个客户端发起的所有请求都要带上这个route信息，或者在cookie中或者在uri中。然后和server指令中的route参数做对比，决定选取哪个server。如果指定的服务器无法处理，那交给负载均衡算法去选择下一个服务器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;map $cookie_jsessionid $route_cookie {
    ~.+\.(?P&amp;lt;route&amp;gt;\w+)$ $route;
}

map $request_uri $route_uri {
    ~jsessionid=.+\.(?P&amp;lt;route&amp;gt;\w+)$ $route;
}

upstream backend {
    server backend1.example.com route=a;
    server backend2.example.com route=b;
    # select first non-empty variable; it should contain either 'a' or 'b'
    sticky route $route_cookie $route_uri;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，route在&lt;code&gt;JSESSIONID&lt;/code&gt;的&lt;code&gt;cookie&lt;/code&gt;中选择，如其包含a那么选择服务器&lt;code&gt;backend1&lt;/code&gt;；如其包含b则选择&lt;code&gt;backend2&lt;/code&gt;，如果都不包含那么在&lt;code&gt;$request_uri&lt;/code&gt; 中再做类似的选择，以此类推。&lt;/p&gt;
&lt;p&gt;不管是选哪种方式保持session一致，如果选择出的server无法使用，那么将会按照负载均衡算法(如round-robin)在服务器列表中的选择下一台server继续处理。&lt;/p&gt;
&lt;h2 id=&quot;实时健康检查active-health-checks&quot;&gt;实时健康检查(Active Health Checks)&lt;/h2&gt;
&lt;p&gt;前面提到过，Nginx有两大功能：一个是扩展，增加更多的server以满足更大的并发；二是检测失效server，以便及时排除。那么，如何定义一个“失效server”(failed server)就变得非常重要。这一节就是来讨论这个问题。这是NGINX Plus 才有的功能，并且是收费的。&lt;/p&gt;
&lt;p&gt;开源版本NGINX 可以提供简单的健康检查，并且可以自动做故障转移。但是如何定义一个上游server“失效”开源NGINX 却做的很简单。NGINX Plus为此提供了一个&lt;strong&gt;可以自定义的、综合式的评判标准&lt;/strong&gt;，除此之外NGINX Plus还可以平缓的添加新的服务器节点到集群当中。这个功能使得NGINX Plus可能甄别更为多元化的服务器错误，十分有效的增加了&lt;code&gt;HTTP/TCP/UDP&lt;/code&gt;应用的可靠性。&lt;br/&gt;这里要用到的指令有：&lt;code&gt;health_check,match&lt;/code&gt; 等指令:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;upstream my_upstream {
    zone my_upstream 64k;
    server server1.example.com slow_start=30s;
}

server {
    # ...
    location /health {
        internal;
        health_check interval=5s uri=/test.php match=statusok;
        proxy_set_header HOST www.example.com;
        proxy_pass http://my_upstream
    }
}

match statusok {
    # 在/test.php 做健康检查
    status 200;
    header Content-Type = text/html;
    body ~ &quot;Server[0-9]+ is alive&quot;;
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;health_check&lt;/code&gt; 中&lt;code&gt;interval=5s&lt;/code&gt;表示每隔5s检测一次；&lt;code&gt;uri=/test.php&lt;/code&gt;表示在&lt;code&gt;/test.php&lt;/code&gt;里进行健康检查，NGINX Plus自动发起uri的请求，uri可以自定义，你在里面具体执行检查的逻辑，比如mysql/redis这些是否正常，然后作出一定的响应；然后在match指令中，就通过一些规则来匹配&lt;code&gt;/test.php&lt;/code&gt;的响应。&lt;code&gt;/test.php&lt;/code&gt;的响应可以包括&lt;code&gt;status,header,body&lt;/code&gt;这些，供后面这些指令做匹配。全部检查通过，就算健康，server被标记为活跃；如果一项匹配未通过，比如&lt;code&gt;Content-Type = text/json&lt;/code&gt;或者&lt;code&gt;status = 201&lt;/code&gt;那都算检测失败，server不健康，被标记为不活跃。&lt;/p&gt;
&lt;h2 id=&quot;使用dns发现新的服务&quot;&gt;使用DNS发现新的服务&lt;/h2&gt;
&lt;p&gt;Nginx Plus一启动就会进行DNS解析并且自动永久缓存解析出的域名和IP，但是某些情形下需要重新解析下，这时候可以使用下面的指令来实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;resolver 127.0.0.11 valid=10s;

upstream service1 {
    zone service1 64k;
    server www.example.com  service=http resolve;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;127.0.0.11是默认的DNS服务器的地址，此例中NGINX Plus每10s中DNS服务器发起一次重新解析的请求。&lt;/p&gt;
&lt;h2 id=&quot;访问控制access-controls&quot;&gt;访问控制(Access Controls)&lt;/h2&gt;
&lt;p&gt;NGINX Plus Release 7主要给增加了TCP负载均衡的安全性。比如Access Controls和DDoS保护。&lt;br/&gt;你现在可以允许或者拒绝对做反向代理的或者做负载均衡的TCP服务器的访问，仅仅通过配置简单的IP或者一个IP范文就能实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server {
    # ...
    proxy_set_header Host www.example.cn;
    proxy_pass http://test;
    deny 72.46.166.10;
    deny 73.46.156.0/24;
    allow all;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个deny指令拒绝一个IP的访问，第二个拒绝一个IP范围，除去这两个剩下的都是被允许访问的。被拒绝访问的IP，会被返回403错误。&lt;/p&gt;
&lt;h2 id=&quot;连接数限制connection-limiting-1&quot;&gt;连接数限制(Connection Limiting)&lt;/h2&gt;
&lt;p&gt;使用NGINX Plus R7你可以限制客户端发往由NGINX Plus代理的TCP应用的请求数量，防止对TCP的请求数量过多。在你的应用中，可能一部分的比另一部分要慢一些。比如说，请求你的应用的某块，将会产生大量的MySQL请求，或者fork出一大堆的work进程。那么攻击者将会利用这点产生成千上万个请求，致使你的服务器负载过重而瘫痪。&lt;/p&gt;
&lt;p&gt;但是有了连接数限制功能，你可以通过配置&lt;code&gt;limit_conn my_limit_conn&lt;/code&gt;指令限制同一个客户端(IP)所能发起的最大请求数，以此将上述的攻击风险降到最低。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;stream {
    limit_conn_zone $binary_remote_addr zone=my_limit_conn:10m;
    # ...
    server {
        limit_conn my_limit_conn 1;
        # ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这条指令限定了每个IP同时只能有一个连接。&lt;/p&gt;
&lt;h2 id=&quot;带宽限制bandwidth-limiting&quot;&gt;带宽限制(Bandwidth Limiting)&lt;/h2&gt;
&lt;p&gt;R7 还新增了一项功能——限制每个连接的上传和下载的最大带宽。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server {
    # ...
    proxy_download_rate 100k;
    proxy_upload_rate  50k;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了这个配置，客户端最多只能以100kbytes/s的速度下载，以50kbytes/s的速度上传。因为客户端可以开多个连接，因此如果要限制总的上传/下载速度，同时还得限制下单个客户端的连接数。&lt;/p&gt;
&lt;h2 id=&quot;支持无缓冲的上传&quot;&gt;支持无缓冲的上传&lt;/h2&gt;
&lt;p&gt;这是在R6中增加的功能。你可以在R6和以后的版本中使用无缓冲的上传，意味Nginx Plus可以通过更大的Http请求比如上传。无缓冲的上传可以在这些请求一过来便进行上传，而不是像之前那样先是缓冲所有的上传内容，再将其转发给你上游服务器。&lt;/p&gt;
&lt;p&gt;默认情况下，Nginx 在上传时，接收到数据时会先放进缓冲区进行缓冲，以避免将资源和基于worker进程的后端脚本绑定，但是针对事件驱动的后端语言如Node.js，缓冲是几乎没有必要的。这个修改改进了服务器对上传大文件的响应性，因为应用可以一接收到数据就马上对做出响应，使得上传进度条变成实时的和准确的。同样，这个改进也减少了磁盘I/O。&lt;/p&gt;
&lt;h2 id=&quot;ssltls优化&quot;&gt;SSL/TLS优化&lt;/h2&gt;
&lt;p&gt;在R6中，可以在和上游的HTTPS 或者 uwSGI 服务器打交道时为客户端提供一个证书。这大大提高了安全性，尤其是在和不受保护网络上的安全服务进行通信的时候。R6 支持IMAP, POP3, 和SMTP的SSL/TLS 客户端认证。&lt;/p&gt;
&lt;h2 id=&quot;缓存优化&quot;&gt;缓存优化&lt;/h2&gt;
&lt;p&gt;proxy_cache 指令可以支持变量了，这个简单的改进以为着你可以定义几个基于磁盘的缓存，并且根据请求数据做自由的选择。当你打算创建巨大的内容缓存，并且将其保存到不同的磁盘时是非常有用的。&lt;/p&gt;
&lt;h2 id=&quot;api功能&quot;&gt;API功能&lt;/h2&gt;
&lt;p&gt;upstreem模块的一些指令，不光可以通过手动去修改，还可以通过restful api的方式去修改，并且马上自动更新。有了这个功能，NGINX Plus的一些功能，你都可以通过API的方式去改变。应用性得到很大提升。当然这也是收费的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;upstream backend {
    zone backends 64k;
    server 10.10.10.2:220 max_conns=250;
    server 10.10.10.4:220 max_conns=150;
}

server {
    listen 80;
    server_name www.example.org;

    location /api {
        api write=on;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了API，你就可以使用curl工具来动态修改配置了，比如用POST命令来增加一个集群的节点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ curl -iX POST -d '{&quot;server&quot;:&quot;192.168.78.66:80&quot;,&quot;weight&quot;:&quot;200&quot;,&quot;max_conns&quot;:&quot;150&quot;}' http://localhost:80/api/1/http/upstreams/backend/servers/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相当于添加了一个这样的配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;upstream backend {
    zone backends 64k;
    server 10.10.10.2:220 max_conns=250;
    server 10.10.10.4:220 max_conns=150;
    #此处是通过api添加的
    server 192.168.78.66:80 weight=200 max_conns=150;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需要修改一个节点配置，你可以用服务器节点在连接池中的自然顺序(从0开始)作为它们各自唯一的ID,然后使用PATCH/DELETE方法去操作它们：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ curl -iX PATCH -d '{&quot;server&quot;:&quot;192.168.78.55:80&quot;,&quot;weight&quot;:&quot;500&quot;,&quot;max_conns&quot;:&quot;350&quot;}' http://localhost:80/api/1/http/upstreams/backend/servers/2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这条命令是修改以上连接池中的第三个&lt;code&gt;server 192.168.78.66:80 max_conns=200;&lt;/code&gt;为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server 192.168.78.55:80 weight=500  max_conns=350;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要返回所有的节点信息，可以使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ curl -s http://localhost:80/api/1/http/upstreams/backend/servers/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回的是一个JSON字符串。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; {
      &quot;backup&quot;: false,
      &quot;down&quot;: false,
      &quot;fail_timeout&quot;: &quot;10s&quot;,
      &quot;id&quot;: 0,
      &quot;max_conns&quot;: 250,
      &quot;max_fails&quot;: 1,
      &quot;route&quot;: &quot;&quot;,
      &quot;server&quot;: &quot;10.10.10.2:220&quot;,
      &quot;slow_start&quot;: &quot;0s&quot;,
      &quot;weight&quot;: 1
      },
      {
      &quot;backup&quot;: false,
      &quot;down&quot;: false,
      &quot;fail_timeout&quot;: &quot;10s&quot;,
      &quot;id&quot;: 1,
      &quot;max_conns&quot;: 150,
      &quot;max_fails&quot;: 1,
      &quot;route&quot;: &quot;&quot;,
      &quot;server&quot;: &quot;10.10.10.4:220&quot;,
      &quot;slow_start&quot;: &quot;0s&quot;,
      &quot;weight&quot;: 1
      },
      {
      &quot;backup&quot;: false,
      &quot;down&quot;: false,
      &quot;fail_timeout&quot;: &quot;10s&quot;,
      &quot;id&quot;: 2,
      &quot;max_conns&quot;: 200,
      &quot;max_fails&quot;: 1,
      &quot;route&quot;: &quot;&quot;,
      &quot;server&quot;: &quot;192.168.78.66:80&quot;,
      &quot;slow_start&quot;: &quot;0s&quot;,
      &quot;weight&quot;: 200
      }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置的最佳实践&quot;&gt;配置的最佳实践&lt;/h2&gt;
&lt;p&gt;为不同个应用配置创建各自的目录和文件，并用&lt;code&gt;include&lt;/code&gt;指令再合并到一起是个非常好的习惯。标准的 NGINX Plus配置是将各个应用的配置文件放到各自的conf.d directory目录下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http {
    include /etc/nginx/conf.d/*.conf;
}
stream {
    include /etc/nginx/stream.d/*.conf;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;http 和 stream 模块的各自分属不同的目录，而在http 下的都是http请求的配置，stream 都是TCP/UDP请求的配置。没有统一的标准，主要是看开发者自己能便于识别和修改。&lt;/p&gt;
</description>
<pubDate>Wed, 14 Mar 2018 13:10:00 +0000</pubDate>
<dc:creator>米粒人生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minirice/p/8570157.html</dc:identifier>
</item>
</channel>
</rss>