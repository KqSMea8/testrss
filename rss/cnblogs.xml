<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>(三):C++分布式实时应用框架——系统管理模块 - smartguy</title>
<link>http://www.cnblogs.com/cdap/p/7877790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cdap/p/7877790.html</guid>
<description>
&lt;p&gt;　　上篇：&lt;a href=&quot;http://www.cnblogs.com/cdap/p/7809381.html&quot; target=&quot;_blank&quot;&gt;(二): 基于ZeroMQ的实时通讯平台&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　&lt;span&gt;　一个分布式实时系统集群动辄上百台机器，集群的规模已经限定这将是一个”封闭“的系统。你不可能再一台台去操作上百台机器，传统的人工运维方式早已不能满足当下需要，所有对集群或者集群中某个节点的操作都必需通过系统提供接口来完成。对于一个商用的分布式实时系统来说，如何应对突然出现的业务高峰；及时检测出集群中的故障节点并进行善后处理；对于集群内处理能力不同的节点进行负载均衡调节；系统因过大压力崩溃前进行过载保护；测试容器与运营容器同网测试的灰度发布能力等等。这些都是系统管理模块需要去解决的问题，也是一个系统能否商用，足够智能的关键指标。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1271768/201711/1271768-20171122105036336-1206688319.png&quot; alt=&quot;&quot; width=&quot;737&quot; height=&quot;454&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;系统管理模块分为服务(SmartService)和管理(SmartManger)两部分。SmartService基于RESTful的接口，来对外提供各类对集群的查询和操作接口，可以方便和各类管理终端（PC、iOS、Android）对接，实现界面管理。完善的框架还提供轻松的二次开发接口，方便定制系统专属接口。如：调整日志级别、单号码日志跟踪、集群配置管理、集群实时拓扑数据查询等等。几百台机器的集群，人工维护已不再现实，自动检测和自主运维已成为关键，SmartManger的自动负载管理功能就是用来完成这部分功能的。另外，系统管理模块是与状态中心、通讯平台相互配合工作的，三者缺一不可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面将详细介绍各个特色功能：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;一、&lt;/span&gt;自动负载管理&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;根据业务容器节点为上报的时延、类型、流量等信息，综合集群所有节点的信息，判断集群目前是否存在如下情况，并根据情况做出相应的应对动作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　1.  某个容器存在故障，不能正常处理业务——故障节点退网&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;2.  &lt;span&gt;某个容器处理能力不足，存在业务处理超时情况——对节点流量控制&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　3. &lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;某类容器处理能力不足，这类容器存在业务处理超时情况——对这类容器进行扩容器操作&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　4.  某类容器处理能力富余，这类容器的流量满足缩容条件——对这类容器进行缩容操作&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　5.  集群处理能力已达极限，可能出现系统崩溃的状况——对集群进行过载保护&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1271768/201711/1271768-20171122143422774-1321693712.gif&quot; alt=&quot;&quot; width=&quot;783&quot; height=&quot;489&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;二、故障节点自动退网&lt;/h3&gt;
&lt;p&gt;　&lt;span&gt;　在业务节点遇到不可恢复的故障不再能正常处理业务，系统管理模块将自动检出，并将故障节点退出业务集群，以保证集群正常运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1271768/201711/1271768-20171122143448352-1006197782.gif&quot; alt=&quot;&quot; width=&quot;783&quot; height=&quot;489&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 三、节点流量控制&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;当某个节点处理能力不足时，如这个节点在做日志跟踪时，系统管理模块可以根据节点处理能力减少发往该节点的消息数，做实时负载均衡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1271768/201711/1271768-20171122144001477-903226658.gif&quot; alt=&quot;&quot; width=&quot;785&quot; height=&quot;490&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h3&gt;四、动态扩缩容&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;当某类型业务容器处理能力不够时，系统可以自动进行在线扩容，扩容期间业务不受影响。当处理能力富余时，系统也会自动进行在线缩容，以让出资源给需要业务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1271768/201711/1271768-20171122144608805-1114658725.gif&quot; alt=&quot;&quot; width=&quot;780&quot; height=&quot;487&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;五、节点过载保护&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;当整个集群的处理能力已经达到极限时(不能再进行扩容操作)，为了防止系统崩溃，可以根据业务的情况进行过载保护，如：对初始鉴权请求进行丢弃处理。&lt;/span&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1271768/201711/1271768-20171122145052774-1574487853.gif&quot; alt=&quot;&quot; width=&quot;782&quot; height=&quot;489&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;六、灰度发布&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;系统支持灰度发布能力，可以让测试点节和正常业务节点同网运行，将让测试号码路由到测试节点进行处理，而不影响其它正常的号码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1271768/201711/1271768-20171122145831008-992680675.gif&quot; alt=&quot;&quot; width=&quot;785&quot; height=&quot;491&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;未完待续...&lt;/p&gt;

&lt;p&gt; 技术交流合作QQ群：436466587　欢迎讨论交流&lt;/p&gt;
</description>
<pubDate>Wed, 22 Nov 2017 07:05:00 +0000</pubDate>
<dc:creator>smartguy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cdap/p/7877790.html</dc:identifier>
</item>
<item>
<title>如何从零开始对接第三方登录(Java版)：QQ登录和微博登录 - 我是小茗同学</title>
<link>http://www.cnblogs.com/liuxianan/p/java-qq-weibo-login.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuxianan/p/java-qq-weibo-login.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://blog.haoji.me&quot;&gt;个人网站&lt;/a&gt;最近增加了&lt;a href=&quot;http://blog.haoji.me/comment-test.html&quot;&gt;评论功能&lt;/a&gt;，为了方便用户不用注册就可以评论，对接了QQ和微博这2大常用软件的一键登录，总的来说其实都挺简单的，可能会有一点小坑，但不算多，完整记录下来方便后来人快速对接。&lt;/p&gt;

&lt;p&gt;在真正开始对接之前，我们先来聊一聊后台的方案设计。既然是对接第三方登录，那就免不了如何将用户信息保存。首先需要明确一点的是，用户在第三方登录成功之后，我们能拿到的仅仅是一个代表用户唯一身份的ID（微博是真实&lt;code&gt;uid&lt;/code&gt;，QQ是加密的&lt;code&gt;openId&lt;/code&gt;）以及用来识别身份的&lt;code&gt;accessToken&lt;/code&gt;，当然还有昵称、头像、性别等有限资料，对接第三方登录的关键就是如何确定用户是合法登录，如果确定这次登录的和上次登录的是同一个人并且不是假冒的。其实这个并不用我们特别操心，就以微博登录为例，用户登录成功之后会回调一个code给我们，然后我们再拿code去微博那换取&lt;code&gt;accessToken&lt;/code&gt;，如果这个code是用户乱填的，那这一关肯定过不了，所以，前面的担心有点多余，哈哈。&lt;/p&gt;
&lt;p&gt;另外一个问题就是如何和现有用户系统打通，有的网站在用户已经登录成功之后还要用户输入手机号和验证码，或者要用户重新注册账号和密码来绑定第三方账户，感觉这种实现用户体验非常差，碰到这种网站我一般都是直接关掉，都已经登录了还让用户注册，什么鬼！由于我做的是评论功能，我并不希望评论用户和现有用户表打通，所以就不存在这件事了，如果想打通的话，我觉得无非就是登录成功之后默认往老用户表插入一条数据，然后和&lt;code&gt;OpenUser&lt;/code&gt;表关联起来，判断用户是否登录时把&lt;code&gt;OpenUser&lt;/code&gt;的鉴权也加进去就OK了。&lt;/p&gt;
&lt;p&gt;本文的后台以Java为例。&lt;/p&gt;
&lt;h2 id=&quot;数据库设计&quot;&gt;数据库设计&lt;/h2&gt;
&lt;p&gt;再来说说数据库设计，为了系统的扩展性，我有一个专门的&lt;code&gt;OpenUser&lt;/code&gt;表用来存放第三方登录用户，主要字段如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;openType&lt;/td&gt;
&lt;td&gt;第三方类型，比如&lt;code&gt;qq&lt;/code&gt;、&lt;code&gt;weibo&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;openId&lt;/td&gt;
&lt;td&gt;代表用户唯一身份的ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;accessToken&lt;/td&gt;
&lt;td&gt;调用接口需要用到的token，比如利用accessToken发表微博等，如果只是对接登录的话，这个其实没啥用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;expiredTime&lt;/td&gt;
&lt;td&gt;授权过期时间，第三方登录授权都是有过期时间的，比如3个月&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;nickname&lt;/td&gt;
&lt;td&gt;昵称&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;avatar&lt;/td&gt;
&lt;td&gt;头像&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这样设计理论上就可以无限扩展了。&lt;/p&gt;
&lt;h2 id=&quot;鉴权流程&quot;&gt;鉴权流程&lt;/h2&gt;
&lt;p&gt;这里我只是说说我的方案，把&lt;code&gt;accessToken&lt;/code&gt;写入cookie肯定是不安全的，因为&lt;code&gt;accessToken&lt;/code&gt;相当于是第三方网站的临时密码，被别人窃取了就可以随意拿来干坏事了。可以在用户登录成功之后我们自己生成一个token，这样的token即使泄露了顶多就是被人拿来随意评论，损失不大，但是如果accessToken被泄露了，以微博为例，人家可以利用这个&lt;code&gt;accessToken&lt;/code&gt;随意发微博、删微博、加关注等等，很危险。当然，如果不想token泄露的话也可以通过绑定IP等方式来限制。&lt;/p&gt;
&lt;p&gt;鉴权的话就是首先判断cookie中是否有我们自己的token，然后判断是否合法，合法再判断第三方授权是否已过期等等。&lt;/p&gt;

&lt;h2 id=&quot;实名认证&quot;&gt;实名认证&lt;/h2&gt;
&lt;p&gt;QQ登录我们对接的是QQ互联，地址：&lt;a href=&quot;https://connect.qq.com&quot; class=&quot;uri&quot;&gt;https://connect.qq.com&lt;/a&gt; ,首先需要注册成为开发者并实名认证，需要手持身份证照片，具体就不讲了。&lt;/p&gt;
&lt;h2 id=&quot;创建应用&quot;&gt;创建应用&lt;/h2&gt;
&lt;p&gt;进入&lt;a href=&quot;https://connect.qq.com/manage.html#/&quot;&gt;应用管理页面&lt;/a&gt;创建应用，根据实际需要是创建网站应用还是移动应用，我这里是网站应用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/352797/201711/352797-20171122145330915-1335830300.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/352797/201711/352797-20171122145403461-55151110.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/352797/201711/352797-20171122145420586-1337213765.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提交完之后会自动提交审核，基本上就是审核你的资料和备案的资料是否一致，所有资料必须和备案资料一模一样，否则审核不会通过：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/352797/201711/352797-20171122145434133-308064681.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，这些资料后面还是可以修改的。申请成功之后你会得到&lt;code&gt;appId&lt;/code&gt;和&lt;code&gt;appKey&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;引导用户登录&quot;&gt;引导用户登录&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://wiki.connect.qq.com/%E8%A7%86%E8%A7%89%E7%B4%A0%E6%9D%90%E4%B8%8B%E8%BD%BD&quot;&gt;这里&lt;/a&gt;可以下载一些视觉素材，在页面合适位置放一个QQ登录按钮，点击时引导用户进入授权页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/352797/201711/352797-20171122145457743-399341819.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 封装一个居中打开新窗口的方法&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;openWindow&lt;/span&gt;(url&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; width&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; height)
&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    width &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; width &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;600&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    height &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; height &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;400&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; left &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;screen&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;width&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; width) / &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; top &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;screen&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;height&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; height) / &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;window&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;open&lt;/span&gt;(url&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;_blank&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;toolbar=yes, location=yes, directories=no, status=no, menubar=yes, scrollbars=yes, resizable=no, copyhistory=yes, left=&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;left&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;, top=&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;top&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;, width=&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;width&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;, height=&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;height)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;qqLogin&lt;/span&gt;()
&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; qqAppId &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'424323422'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 上面申请得到的appid&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; qqAuthPath &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'http://www.test.com/auth'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 前面设置的回调地址&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; state &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'fjdslfjsdlkfd'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 防止CSRF攻击的随机参数，必传，登录成功之后会回传，最好后台自己生成然后校验合法性&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;openWindow&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;`https://graph.qq.com/oauth2.0/authorize?response_type=token&amp;amp;client_id=&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;${&lt;/span&gt;qqAppId&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;&amp;amp;redirect_uri=&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;encodeURIComponent&lt;/span&gt;(qqAuthPath)&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;&amp;amp;state=&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;${&lt;/span&gt;state&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后会打开一个授权页面，这个页面大家应该都熟悉：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/352797/201711/352797-20171122145508774-1595453873.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后到了这里我就碰到一个问题了，&lt;a href=&quot;http://wiki.connect.qq.com/%E4%BD%BF%E7%94%A8authorization_code%E8%8E%B7%E5%8F%96access_token&quot;&gt;官方文档&lt;/a&gt;写的是登录成功之后首先会回传一个code，然后再拿code调接口换取accessToken，然后我试了很多次也换过2个账号发现每次都是直接返回了accessToken，帮我省了一步了，不知道是什么情况，郁闷。&lt;/p&gt;
&lt;h2 id=&quot;拿到accesstoken&quot;&gt;拿到accessToken&lt;/h2&gt;
&lt;p&gt;现在假设我们都是直接拿到accessToken（因为我暂时还没搞明白QQ为啥会直接返回，跟文档说的不一样），但是授权回调时accessToken会被放在&lt;code&gt;#&lt;/code&gt;后面，URL地址中的hash值好像不会被传到后台（貌似是这样，如有不正确欢迎评论指正），所以只能写一个下面这样的临时页面：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * QQ鉴权&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param request&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param response&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@throws Exception&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/authqq&quot;&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;authQQ&lt;/span&gt;(HttpServletRequest request, HttpServletResponse response) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception
{
    &lt;span class=&quot;co&quot;&gt;// QQ登录有点特殊，参数放在#后面，后台无法获取#后面的参数，只能用JS做中间转换&lt;/span&gt;
    String html =   &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;!DOCTYPE html&amp;gt;&quot;&lt;/span&gt; +
                    &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;html lang=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;zh-cn&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;gt;&quot;&lt;/span&gt; +
                    &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;head&amp;gt;&quot;&lt;/span&gt; +
                    &lt;span class=&quot;st&quot;&gt;&quot;   &amp;lt;title&amp;gt;QQ登录重定向页&amp;lt;/title&amp;gt;&quot;&lt;/span&gt; +
                    &lt;span class=&quot;st&quot;&gt;&quot;   &amp;lt;meta charset=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;utf-8&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;/&amp;gt;&quot;&lt;/span&gt; +
                    &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;/head&amp;gt;&quot;&lt;/span&gt; +
                    &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;body&amp;gt;&quot;&lt;/span&gt; +
                    &lt;span class=&quot;st&quot;&gt;&quot;   &amp;lt;script type=&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;text/javascript&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&amp;gt;&quot;&lt;/span&gt; +
                    &lt;span class=&quot;st&quot;&gt;&quot;   location.href = location.href.replace('#', '&amp;amp;').replace('auth_qq', 'auth_qq_redirect');&quot;&lt;/span&gt; +
                    &lt;span class=&quot;st&quot;&gt;&quot;   &amp;lt;/script&amp;gt;&quot;&lt;/span&gt; +
                    &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;/body&amp;gt;&quot;&lt;/span&gt; +
                    &lt;span class=&quot;st&quot;&gt;&quot;&amp;lt;/html&amp;gt;&quot;&lt;/span&gt;;
    response.&lt;span class=&quot;fu&quot;&gt;getWriter&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;print&lt;/span&gt;(html);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;获取openid&quot;&gt;获取openId&lt;/h2&gt;
&lt;p&gt;根据accessToken调接口获取用户的openId，特别注意这个openId是相对于&lt;code&gt;QQ号+appId&lt;/code&gt;唯一的，换句话说同一个QQ号登录2个不同appId时获取到的openId是不同的。顺便说一句，QQ登录的相关接口做的还真够“随便”的，全部都是最简单的get请求，所以对接起来非常顺利。&lt;/p&gt;
&lt;p&gt;直接看代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 根据accessToken换取openId&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 错误示例：callback( {&quot;error&quot;:100016,&quot;error_description&quot;:&quot;access token check failed&quot;} );&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 正确示例：callback( {&quot;client_id&quot;:&quot;10XXXXX49&quot;,&quot;openid&quot;:&quot;CF2XXXXXXXX9F4C&quot;} );&lt;/span&gt;
String result = HttpsUtil.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;https://graph.qq.com/oauth2.0/me?access_token=&quot;&lt;/span&gt; + accessToken);
Map&amp;lt;String, Object&amp;gt; resp = &lt;span class=&quot;fu&quot;&gt;parseQQAuthResponse&lt;/span&gt;(result); &lt;span class=&quot;co&quot;&gt;// 这个方法就是把结果转Map&lt;/span&gt;

Integer errorCode = (Integer)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;error&quot;&lt;/span&gt;);
String errorMsg = (String)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;error_description&quot;&lt;/span&gt;);
String openId = (String)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;openid&quot;&lt;/span&gt;);
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(errorCode != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ErrorResult&lt;/span&gt;(errorCode, &lt;span class=&quot;st&quot;&gt;&quot;获取QQ用户openId失败：&quot;&lt;/span&gt;+errorMsg);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;获取用户头像昵称等信息&quot;&gt;获取用户头像昵称等信息&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 获取用户昵称、头像等信息，{ret: 0, msg: '', nickname: '', ...} ret不为0表示失败&lt;/span&gt;
result = HttpsUtil.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;https://graph.qq.com/user/get_user_info?access_token=&quot;&lt;/span&gt;+accessToken+&lt;span class=&quot;st&quot;&gt;&quot;&amp;amp;oauth_consumer_key=&quot;&lt;/span&gt;+appId+&lt;span class=&quot;st&quot;&gt;&quot;&amp;amp;openid=&quot;&lt;/span&gt;+openId);
resp = JsonUtil.&lt;span class=&quot;fu&quot;&gt;parseJsonToMap&lt;/span&gt;(result);

Integer ret = (Integer)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;ret&quot;&lt;/span&gt;);
String msg = (String)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;msg&quot;&lt;/span&gt;);
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(ret != &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ErrorResult&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;获取用户QQ信息失败：&quot;&lt;/span&gt;+msg);

&lt;span class=&quot;co&quot;&gt;// 用户昵称可能存在4个字节的utf-8字符，MySQL默认不支持，直接插入会报错，所以过滤掉&lt;/span&gt;
String nickname = StringUtil.&lt;span class=&quot;fu&quot;&gt;filterUtf8Mb4&lt;/span&gt;((String)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;nickname&quot;&lt;/span&gt;)).&lt;span class=&quot;fu&quot;&gt;trim&lt;/span&gt;(); &lt;span class=&quot;co&quot;&gt;// 这个方法可以自行百度&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// figureurl_qq_2=QQ的100*100头像，figureurl_2=QQ 100&amp;amp;100空间头像，QQ头像不一定有，空间头像一定有&lt;/span&gt;
String avatar = (String)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;figureurl_qq_2&quot;&lt;/span&gt;);
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(StringUtil.&lt;span class=&quot;fu&quot;&gt;isBlank&lt;/span&gt;(avatar)) avatar = (String)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;figureurl_2&quot;&lt;/span&gt;);
String gender = (String)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;gender&quot;&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;注意事项&quot;&gt;注意事项&lt;/h2&gt;
&lt;p&gt;到了这一步基本上涉及第三方的就结束了，是不是很简单？后面无非就是如何插入数据库、如何保存token、写入session等。&lt;/p&gt;
&lt;p&gt;有几点注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要注意数据库中是否已经有改用户，没有的添加，有的修改，不要重复添加了；&lt;/li&gt;
&lt;li&gt;QQ昵称昵称有各种奇奇怪怪的字符，包括emoji，MySQL默认没有开启&lt;code&gt;utf8mb4&lt;/code&gt;，直接插入会报错，所以需要过滤掉；&lt;/li&gt;
&lt;li&gt;需要做好对各种错误的兼容；&lt;/li&gt;
&lt;li&gt;接口会同时返回QQ头像和空间头像，QQ头像不一定有，空间头像一定有；&lt;/li&gt;
&lt;li&gt;回调地址必须和申请的域名一致，否则会报错。&lt;/li&gt;
&lt;li&gt;QQ互联有个特大的bug，有时候显示已登录但是点击授权管理一直报错，此时只需要退出重新登录即可；&lt;/li&gt;
&lt;li&gt;授权之后用户可能会在过期之前提前取消授权；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相关文档官网已经写得比较细了，但是比较乱：&lt;a href=&quot;http://wiki.connect.qq.com/&quot; class=&quot;uri&quot;&gt;http://wiki.connect.qq.com/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;实名认证-1&quot;&gt;实名认证&lt;/h2&gt;
&lt;p&gt;这个我就不具体讲了，登录 &lt;a href=&quot;http://open.weibo.com/&quot; class=&quot;uri&quot;&gt;http://open.weibo.com/&lt;/a&gt; 很容易找到相关入口，注册成为开发者，实名认证，一模一样的。&lt;/p&gt;
&lt;h2 id=&quot;创建应用-1&quot;&gt;创建应用&lt;/h2&gt;
&lt;p&gt;点击链接 &lt;a href=&quot;http://open.weibo.com/apps/new?sort=web&quot; class=&quot;uri&quot;&gt;http://open.weibo.com/apps/new?sort=web&lt;/a&gt; 创建web应用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/352797/201711/352797-20171122145541383-1653369945.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建成果后完善相关信息，主要是下面这些：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/352797/201711/352797-20171122145549852-75346843.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我就不一一介绍了，都看得懂。&lt;/p&gt;
&lt;p&gt;微博登录不需要网站一定要备案，但对网站本身有一定要求，不能弄一个空壳网站让人家去审核，肯定审核不通过的。&lt;/p&gt;
&lt;p&gt;有关微博的对接可以参考我好几年前写的一篇文章：&lt;a href=&quot;http://www.cnblogs.com/liuxianan/archive/2012/11/11/2765123.html&quot;&gt;【新手入门篇】新浪微博应用开发之Java入门篇&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;引导用户登录-1&quot;&gt;引导用户登录&lt;/h2&gt;
&lt;p&gt;微博&lt;a href=&quot;http://open.weibo.com/wiki/%E5%BE%AE%E5%8D%9A%E6%A0%87%E8%AF%86%E4%B8%8B%E8%BD%BD&quot;&gt;视觉素材下载&lt;/a&gt;在这里，页面合适位置放一个登录按钮：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;weiboLogin&lt;/span&gt;()
&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; weiboAppId &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'432432'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; weiboAuthPath &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'http://www.test.com/authweibo'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;openWindow&lt;/span&gt;(&lt;span class=&quot;vs&quot;&gt;`https://api.weibo.com/oauth2/authorize?client_id=&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;${&lt;/span&gt;weiboAppId&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;&amp;amp;response_type=code&amp;amp;redirect_uri=&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;at&quot;&gt;encodeURIComponent&lt;/span&gt;(weiboAuthPath)&lt;span class=&quot;sc&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;vs&quot;&gt;`&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;微博登录有一个好处，第一次登录需要授权，后面第二次登录时只会一闪而过自动就登录成功了，都不需要点一下，用户体验非常好，看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/352797/201711/352797-20171122145709821-739665277.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;获取accesstoken&quot;&gt;获取accessToken&lt;/h2&gt;
&lt;p&gt;登录成功会返回一个code，根据code换取accessToken：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;String params = &lt;span class=&quot;st&quot;&gt;&quot;client_id=&quot;&lt;/span&gt; + appId
        + &lt;span class=&quot;st&quot;&gt;&quot;&amp;amp;client_secret=&quot;&lt;/span&gt; + appSecret
        + &lt;span class=&quot;st&quot;&gt;&quot;&amp;amp;grant_type=authorization_code&quot;&lt;/span&gt;
        + &lt;span class=&quot;st&quot;&gt;&quot;&amp;amp;redirect_uri=&quot;&lt;/span&gt; + URLUtil.&lt;span class=&quot;fu&quot;&gt;encode&lt;/span&gt;(authPath)
        + &lt;span class=&quot;st&quot;&gt;&quot;&amp;amp;code=&quot;&lt;/span&gt; + code;
&lt;span class=&quot;co&quot;&gt;// 用code换取accessToken&lt;/span&gt;
String result = HttpsUtil.&lt;span class=&quot;fu&quot;&gt;post&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;https://api.weibo.com/oauth2/access_token&quot;&lt;/span&gt;, params);
Map&amp;lt;String, Object&amp;gt; resp = JsonUtil.&lt;span class=&quot;fu&quot;&gt;toObject&lt;/span&gt;(result, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; TypeReference&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt;(){});

Integer errorCode = (Integer)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;error_code&quot;&lt;/span&gt;);
String error = (String)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;error&quot;&lt;/span&gt;);
String errorMsg = (String)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;error_description&quot;&lt;/span&gt;);
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(errorCode != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; errorCode != &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ErrorResult&lt;/span&gt;(errorCode, error + (errorMsg==&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;?&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;:errorMsg));
String accessToken = (String)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;access_token&quot;&lt;/span&gt;);
String uid = (String)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;uid&quot;&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;// 这个uid就是微博用户的唯一用户ID，可以通过这个id直接访问到用户微博主页&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; expires = (Integer)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;expires_in&quot;&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;// 有效期，单位秒&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;获取用户头像等信息&quot;&gt;获取用户头像等信息&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 用uid和accessToken换取用户信息&lt;/span&gt;
String result = HttpsUtil.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;https://api.weibo.com/2/users/show.json?access_token=&quot;&lt;/span&gt;+accessToken+&lt;span class=&quot;st&quot;&gt;&quot;&amp;amp;uid=&quot;&lt;/span&gt;+uid);
Map&amp;lt;String, Object&amp;gt; resp = JsonUtil.&lt;span class=&quot;fu&quot;&gt;toObject&lt;/span&gt;(result, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; TypeReference&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt;(){});

errorCode = (Integer)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;error_code&quot;&lt;/span&gt;);
error = (String)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;error&quot;&lt;/span&gt;);
errorMsg = (String)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;error_description&quot;&lt;/span&gt;);
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(errorCode != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; errorCode != &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ErrorResult&lt;/span&gt;(errorCode, error + (errorMsg==&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;?&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;:errorMsg));

String nickname = (String)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;screen_name&quot;&lt;/span&gt;);
&lt;span class=&quot;co&quot;&gt;// 微博180*180高清头像&lt;/span&gt;
String avatar = (String)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;avatar_large&quot;&lt;/span&gt;);
String gender = (String)resp.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;gender&quot;&lt;/span&gt;);
gender = &lt;span class=&quot;st&quot;&gt;&quot;m&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(gender) ? &lt;span class=&quot;st&quot;&gt;&quot;男&quot;&lt;/span&gt; : (&lt;span class=&quot;st&quot;&gt;&quot;f&quot;&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(gender) ? &lt;span class=&quot;st&quot;&gt;&quot;女&quot;&lt;/span&gt; : &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此涉及第三方的东西都完了，剩下的就是用户自己保存到数据库、写入token、保存session、以及鉴权接口开发了。&lt;/p&gt;
&lt;h2 id=&quot;注意事项-1&quot;&gt;注意事项&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;微博接口都有频率限制，不过一般不会超过；&lt;/li&gt;
&lt;li&gt;需做好错误兼容；&lt;/li&gt;
&lt;li&gt;微博直接返回的uid，可以根据这个uid直达用户微博主页 &lt;a href=&quot;https://weibo.com/u/xxxxx&quot; class=&quot;uri&quot;&gt;https://weibo.com/u/xxxxx&lt;/a&gt; ，所以可以把用户头像链接到这里；&lt;/li&gt;
&lt;li&gt;其实也有现成的js-sdk，可以根据自己实际需要选择是否使用；&lt;/li&gt;
&lt;li&gt;嗯，我再想想还有没有，哦，对了，微博的接口是https，并且是post，需要注意；&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Wed, 22 Nov 2017 06:58:00 +0000</pubDate>
<dc:creator>我是小茗同学</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuxianan/p/java-qq-weibo-login.html</dc:identifier>
</item>
<item>
<title>卷积算法归纳总结(浅识） - 北冥大帝</title>
<link>http://www.cnblogs.com/minsons/p/7879047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minsons/p/7879047.html</guid>
<description>&lt;p&gt;归纳卷积神经网络的常用算法&lt;br/&gt;在卷积算法之前，是有很多图片分类和识别的机器学习算法，像SVM向量机的原理特别复杂，卷积算法还是比较易懂，一方面避免全连接带来的庞大参数，主要通过提取特征值，算法准确率也是最高的，几乎可以跟人工识别相提并论了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201711/1171146-20171122141806993-572353732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经典算法：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1，LeNet算法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LeNet&lt;/strong&gt;&lt;strong&gt;算法的流程是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Input –&amp;gt;conv2-&amp;gt;relu-&amp;gt;pool-&amp;gt;conv2-&amp;gt;relu-&amp;gt;pool-&amp;gt;CF-&amp;gt;softmax-&amp;gt;output&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201711/1171146-20171122141900821-1764649423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Input:输入; 矩阵为(w,h,c)  w:宽的像素；h:高的像素；c：通道&lt;/p&gt;
&lt;p&gt;Conv:卷积计算&lt;/p&gt;
&lt;p&gt;卷积就是把一个图层（w,h）&lt;/p&gt;
&lt;p&gt;Conv2：表示二维图的卷积&lt;/p&gt;
&lt;p&gt;一个图层可能是64*64,通过W过滤层为(6,6) &lt;strong&gt;通常有多个过滤层&lt;/strong&gt;，输出层为矩阵维度为64-6+1=59 ，即（59,59）&lt;/p&gt;
&lt;p&gt;以下面的图简单为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201711/1171146-20171122141922290-2090810833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Pool：是池化操作，可能翻译原因表述不一样，&lt;strong&gt;池化层是单层的&lt;/strong&gt;，池化层分为最大值池化和平均值池化；其实，也就是提取特征值最明显的值，最大值池化的效果相对来说更好，所以建议使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201711/1171146-20171122141939383-755778110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;FC：也就是全连接了，即WX+b=Y&lt;/p&gt;
&lt;p&gt;Softmax：归一化的处理，分类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201711/1171146-20171122141957930-1226210082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在conv2到pool过程中，还有一层no_linear_normal的操作，也是比较难懂，作用似乎没那么大，就被忽略了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2，AlexNet算法：&lt;/span&gt;&lt;br/&gt;其实就是一个leNet的变形，先来看一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201711/1171146-20171122142058665-1821278568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大体过程可分为：&lt;/p&gt;
&lt;p&gt;Input-&amp;gt;conv2-&amp;gt;pool-&amp;gt;conv2-&amp;gt;pool-&amp;gt;pool-&amp;gt;pool-&amp;gt;pool-&amp;gt;pool-&amp;gt;FC-&amp;gt;FC-&amp;gt;FC-&amp;gt;softmax&lt;/p&gt;
&lt;p&gt;当然中间还有一些relu激化函数就略过了，在激活函数前会通过LRN进行局部归一化，减少使用复杂的激化函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3，VGG-16 算法：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;VGG-16 跟VGG-19算法 主要是在层次多少区别，算法效果差不多，所以一般建议使用VGG-16&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201711/1171146-20171122142147024-903076633.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;VGG算法跟alexNet的最大不同是这个算法重点是conv2卷积多次，达到集中特征收集的目的&lt;/p&gt;
&lt;p&gt;==========================================================&lt;/p&gt;
&lt;p&gt;高效的算法：&lt;br/&gt;残差算法：&lt;span&gt;ResNet算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;卷积算法，流程都是通过多个过滤器进行特征值提取，中间的过程容易造成层次越多，原始特征丢失越严重，损失函数在逆向优化时梯度下降太快，所以需要加一些特征优化降低这个速度。对于一些神经深度越大的，这种算法越见优势。&lt;br/&gt;首先来一般的神经深度过程：&lt;br/&gt;Input –&amp;gt;linear-&amp;gt;rule-&amp;gt;linear-&amp;gt;relu-&amp;gt;a&lt;br/&gt;而resNet是加了一步&lt;br/&gt;Input –&amp;gt;linear-&amp;gt;rule-&amp;gt;linear-&amp;gt;？-&amp;gt;relu-&amp;gt;a&lt;br/&gt;运算过程：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201711/1171146-20171122142328102-1917383197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201711/1171146-20171122142335040-47592754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201711/1171146-20171122142342743-589293873.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来是：？&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201711/1171146-20171122142353618-1191455650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不是，这样网络越大，会增加错误几率，所以得保真：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201711/1171146-20171122142404461-358873192.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把上上步的a[L] 拿过来加进去求激活函数，这样就能保真。再看一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201711/1171146-20171122142416711-91061557.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;总体的流程如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201711/1171146-20171122142427352-500714612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;这不是真正的跳跃，而是把原先的a值拿来求激活函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Inception network 算法&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;其实是谷歌的一个卷积算法 googleNet，这个算法真的比较负责，当然他的深度可以很深，也可以通过增加卷积的conv2的层次，识别一张图片里的多个事物；首先，我们先来一张图：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201711/1171146-20171122142649336-1090280684.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;Previous layer是前一层 激活函数之后的&lt;br/&gt;然后进行conv2或者pool进行，然后把各个层的卷积组成一个大的卷积。&lt;br/&gt;有辅助卷积是可以识别出更多的物体。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201711/1171146-20171122142709149-1194396785.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;FaceNet算法 是人物识别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;人物识别通常可用于监控，或者关卡或者上班的脸谱识别，通过卷积然后根据卷积后的CF后的特征计算误差；通常会需要某个人物的十多张图片作为训练，然后再找其他的图片作为对比。&lt;/p&gt;
&lt;p&gt;自己本人图片的计算误差小于等于跟他人图片的误差&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1171146/201711/1171146-20171122142821899-1318772583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里只是作为学习的一个总结,具体实现要leNet-5,googleNet,inception Network, faceNet等关键词去githup搜索相应的开源代码去研究；这些都是开源出来的，至少你可以查到他的论文，不过几乎都是英文。这才原汁原味。&lt;/p&gt;

&lt;p&gt;参考：吴恩达视频教程&lt;/p&gt;
</description>
<pubDate>Wed, 22 Nov 2017 06:31:00 +0000</pubDate>
<dc:creator>北冥大帝</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minsons/p/7879047.html</dc:identifier>
</item>
<item>
<title>Qt----拖拽 - lgxZJ</title>
<link>http://www.cnblogs.com/lgxZJ/p/7879034.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lgxZJ/p/7879034.html</guid>
<description>&lt;p&gt;最近比较忙，今天此才有时间来继续学习下Qt。Qt的拖拽可以按字面意思分为&lt;strong&gt;拖&lt;/strong&gt;和&lt;strong&gt;拽&lt;/strong&gt;两部分。一般来说我们常见的拖拽分别由两个程序合作完成。例如我们经常把桌面的文件拖拽进其他目录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/11/22/5a14ee7508ea1.jpg&quot; alt=&quot;desktop-drag&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个拖拽在Qt中由两方合作完成，一个是桌面窗口另一个是目录窗口，桌面发起“拖”动作，目录窗口接受“放”动作。如果你细心观察还可以发现，在不同的情况下拖拽还可以产生不同的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/11/22/5a14f1acb7ecd.png&quot; alt=&quot;drag-copy&quot;/&gt;&lt;img src=&quot;https://i.loli.net/2017/11/22/5a14f27fca69c.png&quot; alt=&quot;drag-move&quot;/&gt;&lt;img src=&quot;https://i.loli.net/2017/11/22/5a14f2e71fac9.png&quot; alt=&quot;drag-link&quot;/&gt;&lt;/p&gt;
&lt;p&gt;拖拽方可以发起多个拖拽类型（复制、链接、移动等），接收方可以选择接受其中某个类型或者直接拒绝。除此之外，拖拽支持多种数据格式，并且还可以在同一个应用程序中进行（托和拽操作均由同一个exe发起）。我们通过一个示例程序来学习，这个程序包含以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内部发起拖拽。&lt;/li&gt;
&lt;li&gt;切换可接受的拖拽动作：移动、拷贝、链接。&lt;/li&gt;
&lt;li&gt;支持多种拖拽数据：image、html、text、color等。&lt;/li&gt;
&lt;li&gt;拖拽区域高亮。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;内部拖拽&quot;&gt;1. 内部拖拽&lt;/h2&gt;
&lt;p&gt;我们在主窗口内部放置了3个Label，分别可以用来演示3种不同数据类型的拖拽效果。如果鼠标左键在这几个标签区域内按下并且移动距离超过5个像素，我们就发起拖拽动作，可能的拖拽类型为：Copy、Move、Link。通过QDrag类我们就能发起一个拖拽动作，这个类还提供了&lt;code&gt;setPixmap()&lt;/code&gt;和&lt;code&gt;setHotSpot()&lt;/code&gt;函数类供我们自定义拖拽时的图像和位置，这里我们就不设置了。&lt;/p&gt;
&lt;p&gt;调用&lt;code&gt;QDrag::exec()&lt;/code&gt;就能进入拖拽的事件处理循环了，注意在Linux和Mac上，这个exec并不会阻塞全局的消息循环；在Windows上，它是阻塞的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void MainWindow::mousePressEvent(QMouseEvent *event)
{
    if (event-&amp;gt;button() &amp;amp; Qt::LeftButton) {
        m_dragStartPos = event-&amp;gt;pos();

        if (m_imageLabel-&amp;gt;geometry().contains(event-&amp;gt;pos()))
            m_dragLabel = m_imageLabel;
        else if (m_colorLabel-&amp;gt;geometry().contains(event-&amp;gt;pos()))
            m_dragLabel = m_colorLabel;
        else if (m_htmlLabel-&amp;gt;geometry().contains(event-&amp;gt;pos()))
            m_dragLabel = m_htmlLabel;
        else
            m_dragStartPos = QPoint();
    }

    QMainWindow::mousePressEvent(event);
}

void MainWindow::mouseMoveEvent(QMouseEvent *event)
{
    QDrag drag(this);

    if (m_dragStartPos.isNull())
        goto end;
    if ((event-&amp;gt;pos() - m_dragStartPos).manhattanLength() &amp;lt; 5)
        goto end;

    ...

    drag.exec(Qt::CopyAction | Qt::MoveAction | Qt::LinkAction);

end:
    QMainWindow::mouseMoveEvent(event);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;可接受拖拽类型切换&quot;&gt;2. 可接受拖拽类型切换&lt;/h2&gt;
&lt;p&gt;这个功能我们通过菜单来实现，因为同一时间只接受一种类型，因此这几个菜单要求必须互斥。互斥菜单这个概念我们在代码里选择使用QActionGroup，虽然自己实现切换也不麻烦，但是这样更快更方便。每个子菜单触发时会切换可接受拖拽类型，Qt提供了3种基本类型：Move、Copy、Link。拖拽显示时，Copy类型是一个&lt;code&gt;+&lt;/code&gt;号，Move类型是一个&lt;code&gt;→&lt;/code&gt;，Link类型是一个粗体的斜箭头：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void MainWindow::createMenus()
{
    auto menu = this-&amp;gt;menuBar()-&amp;gt;addMenu(tr(&quot;Acceptable Drags&quot;));

    auto copyAction = menu-&amp;gt;addAction(&quot;Only Copy&quot;,
                        this, SLOT(onlyAcceptCopyDrag()),
                        QKeySequence(Qt::CTRL + Qt::Key_C));
    copyAction-&amp;gt;setCheckable(true);
    copyAction-&amp;gt;setChecked(true);
    m_actionGroup.addAction(copyAction);

    auto moveAction = menu-&amp;gt;addAction(&quot;Only Move&quot;,
                        this, SLOT(onlyAcceptMoveDrag()),
                        QKeySequence(Qt::CTRL + Qt::Key_M));
    moveAction-&amp;gt;setCheckable(true);
    moveAction-&amp;gt;setChecked(false);
    m_actionGroup.addAction(moveAction);

    auto linkAction = menu-&amp;gt;addAction(&quot;Only Link&quot;,
                        this, SLOT(onlyAcceptLinkDrag()),
                        QKeySequence(Qt::CTRL + Qt::Key_L));
    linkAction-&amp;gt;setCheckable(true);
    linkAction-&amp;gt;setChecked(false);
    m_actionGroup.addAction(linkAction);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;多种拖拽数据类型&quot;&gt;3. 多种拖拽数据类型&lt;/h2&gt;
&lt;p&gt;我们在发起拖拽的时候设置传递的数据及类型，通过&lt;code&gt;QDrag::setMimeData()&lt;/code&gt;函数来设置传入的数据及类型。这个函数接受一个QMimeData类型的指针，这个类用MIME来区分数据类型。对于常见的类型它提供了方便的函数&lt;code&gt;setHtml()&lt;/code&gt;、&lt;code&gt;setColorData()&lt;/code&gt;等，我们只需要传入数据就可以了：html和texx类型的数据以字符串表示，Image和Color类型数据以QVariant表示；对于自定义类型，我们需要调用&lt;code&gt;setData()&lt;/code&gt;函数，同时传入MIME类型和对应的数据（因为使用简单，代码中没有演示）。数据获取则通过对应的&lt;code&gt;html()&lt;/code&gt;、&lt;code&gt;imageData()&lt;/code&gt;、&lt;code&gt;data()&lt;/code&gt;等函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void MainWindow::mouseMoveEvent(QMouseEvent *event)
{
    ...

    QMimeData* mimeData = new QMimeData();
    if (m_dragLabel == m_htmlLabel)
        mimeData-&amp;gt;setHtml(&quot;&amp;lt;html&amp;gt;This is a html page&amp;lt;/html&amp;gt;&quot;);
    if (m_dragLabel == m_colorLabel)
        mimeData-&amp;gt;setColorData(QVariant(QColor(Qt::cyan)));
    if (m_dragLabel == m_imageLabel)
        mimeData-&amp;gt;setImageData(QVariant(QPixmap(&quot;:/img/image.jpg&quot;)));
    drag.setMimeData(mimeData);

    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实个人觉得QMimeData不是很好用，没有获取当前类型的功能，只能约定好或者一个一个去尝试。&lt;/p&gt;
&lt;h2 id=&quot;拖拽区域高亮&quot;&gt;4. 拖拽区域高亮&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;当拖拽&lt;strong&gt;进入&lt;/strong&gt;窗口之中时，会触发&lt;code&gt;dragEnterEvent()&lt;/code&gt;事件，我们在这里高亮窗口背景；&lt;/li&gt;
&lt;li&gt;当我们&lt;strong&gt;接受&lt;/strong&gt;拖拽事件(通过&lt;code&gt;QDragEnterEvent::accept()&lt;/code&gt;或者&lt;code&gt;QDropEvent::acceptProposedAction()&lt;/code&gt;)后，窗口会收到&lt;code&gt;dragMoveEvent()&lt;/code&gt;事件。QDragMoveEvent事件包含一个&lt;code&gt;answerRect()&lt;/code&gt;函数，返回相对于窗口的当前拖拽范围，我们通过判断来选择是否绘制中心的高亮区域。有趣的是这个范围大小始终是&lt;code&gt;1x1&lt;/code&gt;，它被当成点来处理。&lt;/li&gt;
&lt;li&gt;当拖拽&lt;strong&gt;离开&lt;/strong&gt;窗口时，会触发&lt;code&gt;dragLeaveEvent()&lt;/code&gt;事件，我们进行重绘。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是该部分代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void MainWindow::dragEnterEvent(QDragEnterEvent *event)
{
    event-&amp;gt;setDropAction(m_acceptableDropAction);
    event-&amp;gt;accept();
    m_currentBkColor = m_dragEnteredColor;

    QWidget::dragEnterEvent(event);
}

void MainWindow::dragLeaveEvent(QDragLeaveEvent *event)
{
    m_currentBkColor = m_dragLeavedColor;

    repaint();
    QWidget::dragLeaveEvent(event);
}

void MainWindow::dragMoveEvent(QDragMoveEvent *event)
{
    if (m_acceptableRect.contains(event-&amp;gt;answerRect()))
        m_currentDragableAreaColor = m_highlightColor;
    else
        m_currentDragableAreaColor = m_unhighlightColor;

    repaint();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;运行结果&quot;&gt;5. 运行结果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/11/22/5a1514cd3787e.png&quot; alt=&quot;result-1&quot;/&gt;&lt;img src=&quot;https://i.loli.net/2017/11/22/5a1514f8c2c5a.png&quot; alt=&quot;result-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码详见&lt;a href=&quot;https://github.com/lgxZJ/Miscellaneous/tree/master/Qt/DragDrop&quot;&gt;链接&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Wed, 22 Nov 2017 06:29:00 +0000</pubDate>
<dc:creator>lgxZJ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lgxZJ/p/7879034.html</dc:identifier>
</item>
<item>
<title>.net core2.0下使用Identity改用dapper存储数据 - 进击的Jary</title>
<link>http://www.cnblogs.com/JinJi-Jary/p/7879024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JinJi-Jary/p/7879024.html</guid>
<description>&lt;p&gt;前言、&lt;/p&gt;
&lt;p&gt;　　已经好多天没写博客了，鉴于空闲无聊之时又兴起想写写博客，也当是给自己做个笔记。过了这么些天，我的文笔还是依然那么烂就请多多谅解了。今天主要是分享一下在使用.net core2.0下的实际遇到的情况。在使用webapi时用了identity做用户验证。官方文档是的是用EF存储数据来使用dapper，因为个人偏好原因所以不想用EF。于是乎就去折腾。改成使用dapper做数据存储。于是就有了以下的经验。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、使用Identity服务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　先找到&lt;strong&gt;&lt;span&gt;Startup.cs&lt;/span&gt; &lt;/strong&gt;这个类文件 找到 &lt;span&gt;ConfigureServices&lt;/span&gt; 方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
services.AddIdentity&amp;lt;&lt;span&gt;ApplicationUser&lt;/span&gt;, &lt;span&gt;ApplicationRole&lt;/span&gt;&amp;gt;().AddDefaultTokenProviders();//添加Identity&lt;br/&gt;services.AddTransient&amp;lt;&lt;span&gt;IUserStore&lt;/span&gt;&amp;lt;&lt;span&gt;ApplicationUser&lt;/span&gt;&amp;gt;, &lt;span&gt;CustomUserStore&lt;/span&gt;&amp;gt;();&lt;br/&gt;services.AddTransient&amp;lt;&lt;span&gt;IRoleStore&lt;/span&gt;&amp;lt;&lt;span&gt;ApplicationRole&lt;/span&gt;&amp;gt;, &lt;span&gt;CustomRoleStore&lt;/span&gt;&amp;gt;();&lt;br/&gt;&lt;span&gt;string&lt;/span&gt; connectionString = Configuration.GetConnectionString(&lt;span&gt;&quot;SqlConnectionStr&quot;&lt;/span&gt;);&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt;services.AddTransient&amp;lt;&lt;span&gt;SqlConnection&lt;/span&gt;&amp;gt;(e =&amp;gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;SqlConnection&lt;/span&gt;(connectionString));&lt;br/&gt;services.AddTransient&amp;lt;&lt;span&gt;DapperUsersTable&lt;/span&gt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后在 Configure 方法 的 app.UseMvc() 前加入下列代码，net core 1.0的时候是app.UseIdentity() 现在已经弃用改为以下方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用验证&lt;/span&gt;
app.UseAuthentication();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的 &lt;span&gt;&lt;strong&gt;ApplicationUser&lt;/strong&gt; &lt;/span&gt;是自定义的一个用户模型 具体是继承 &lt;span&gt;&lt;strong&gt;IdentityUser&lt;/strong&gt;&lt;/span&gt; 继承它的一些属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt;&lt;span&gt; ApplicationUser&lt;/span&gt; :&lt;span&gt;IdentityUser&lt;/span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AuthenticationType { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsAuthenticated { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的 &lt;strong&gt;&lt;span&gt;CustomUserStore&lt;/span&gt;&lt;/strong&gt; 是自定义提供用户的所有数据操作的方法的类它需要继承三个接口：&lt;strong&gt;&lt;span&gt;IUserStore&lt;/span&gt;&lt;/strong&gt;，&lt;span&gt;&lt;strong&gt;IUserPasswordStore&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;IUserEmailStore&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span data-ttu-id=&quot;e4f85-213&quot;&gt;&lt;span&gt;&lt;strong&gt;IUserStore&amp;lt;TUser&amp;gt;&lt;/strong&gt;&lt;/span&gt;接口是在用户存储中必须实现的唯一接口。 &lt;span data-ttu-id=&quot;e4f85-214&quot;&gt;它定义了用于创建、 更新、 删除和检索用户的方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;e4f85-213&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-214&quot;&gt;　　&lt;span data-ttu-id=&quot;e4f85-225&quot;&gt;&lt;strong&gt;&lt;span&gt;IUserPasswordStore&amp;lt;TUser&amp;gt;&lt;/span&gt;&lt;/strong&gt;接口定义实现以保持经过哈希处理的密码的方法。 &lt;span data-ttu-id=&quot;e4f85-226&quot;&gt;它包含用于获取和设置工作经过哈希处理的密码，以及用于指示用户是否已设置密码的方法的方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;e4f85-213&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-214&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-225&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-226&quot;&gt;　　&lt;span data-ttu-id=&quot;e4f85-238&quot;&gt;&lt;span&gt;&lt;strong&gt;IUserEmailStore&amp;lt;TUser&amp;gt;&lt;/strong&gt;&lt;/span&gt;接口定义实现以存储用户电子邮件地址的方法。 &lt;span data-ttu-id=&quot;e4f85-239&quot;&gt;它包含用于获取和设置的电子邮件地址和是否确认电子邮件的方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;e4f85-213&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-214&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-225&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-226&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-238&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-239&quot;&gt;　　这里跟.net core 1.0的实现接口方式有点不同。需要多实现 &lt;strong&gt;&lt;span&gt;IUserEmailStore&lt;/span&gt;&lt;/strong&gt; 才能不报错&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;e4f85-213&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-214&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-225&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-226&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-238&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-239&quot;&gt;　　具体代码如下。以供大家参考。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47.5&quot;&gt;&lt;img id=&quot;code_img_closed_70bfd06d-8e83-4ebb-905f-36c60db9c7f6&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_70bfd06d-8e83-4ebb-905f-36c60db9c7f6&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_70bfd06d-8e83-4ebb-905f-36c60db9c7f6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;90&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Identity;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; YepMarsCRM.Web.CustomProvider
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; This store is only partially implemented. It supports user creation and find methods.
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomUserStore : IUserStore&amp;lt;ApplicationUser&amp;gt;&lt;span&gt;,
        IUserPasswordStore&lt;/span&gt;&amp;lt;ApplicationUser&amp;gt;&lt;span&gt;,
        IUserEmailStore&lt;/span&gt;&amp;lt;ApplicationUser&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; DapperUsersTable _usersTable;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CustomUserStore(DapperUsersTable usersTable)
        {
            _usersTable &lt;/span&gt;=&lt;span&gt; usersTable;
        }

        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; createuser
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IdentityResult&amp;gt;&lt;span&gt; CreateAsync(ApplicationUser user,
            CancellationToken cancellationToken &lt;/span&gt;= &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(user));

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _usersTable.CreateAsync(user);
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IdentityResult&amp;gt;&lt;span&gt; DeleteAsync(ApplicationUser user,
            CancellationToken cancellationToken &lt;/span&gt;= &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(user));

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _usersTable.DeleteAsync(user);

        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
        {
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;ApplicationUser&amp;gt; FindByEmailAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; normalizedEmail, CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ApplicationUser&amp;gt; FindByIdAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; userId,
            CancellationToken cancellationToken &lt;/span&gt;= &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (userId == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(userId));
            Guid idGuid;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!Guid.TryParse(userId, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; idGuid))
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Not a valid Guid id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, nameof(userId));
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _usersTable.FindByIdAsync(idGuid);

        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ApplicationUser&amp;gt; FindByNameAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; userName,
            CancellationToken cancellationToken &lt;/span&gt;= &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(CancellationToken))
        {
            cancellationToken.ThrowIfCancellationRequested();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (userName == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(userName));

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _usersTable.FindByNameAsync(userName);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetEmailAsync(ApplicationUser user, CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(user));

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.FromResult(user.Email);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; GetEmailConfirmedAsync(ApplicationUser user, CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetNormalizedEmailAsync(ApplicationUser user, CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetNormalizedUserNameAsync(ApplicationUser user, CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetPasswordHashAsync(ApplicationUser user, CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(user));

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.FromResult(user.PasswordHash);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetUserIdAsync(ApplicationUser user, CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(user));

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.FromResult(user.Id.ToString());
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetUserNameAsync(ApplicationUser user, CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(user));

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.FromResult(user.UserName);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; HasPasswordAsync(ApplicationUser user, CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task SetEmailAsync(ApplicationUser user, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; email, CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task SetEmailConfirmedAsync(ApplicationUser user, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; confirmed, CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task SetNormalizedEmailAsync(ApplicationUser user, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; normalizedEmail, CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(user));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (normalizedEmail == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(normalizedEmail));

            user.NormalizedEmail &lt;/span&gt;=&lt;span&gt; normalizedEmail;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.FromResult&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task SetNormalizedUserNameAsync(ApplicationUser user, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; normalizedName, CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(user));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (normalizedName == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(normalizedName));

            user.NormalizedUserName &lt;/span&gt;=&lt;span&gt; normalizedName;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.FromResult&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task SetPasswordHashAsync(ApplicationUser user, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; passwordHash, CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(user));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (passwordHash == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(passwordHash));

            user.PasswordHash &lt;/span&gt;=&lt;span&gt; passwordHash;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.FromResult&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task SetUserNameAsync(ApplicationUser user, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; userName, CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;IdentityResult&amp;gt;&lt;span&gt; UpdateAsync(ApplicationUser user, CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _usersTable.UpdateAsync(user);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;CustomUserStore&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、使用使用dapper做数据存储&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-213&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-214&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-225&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-226&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-238&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-239&quot;&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span data-ttu-id=&quot;e4f85-213&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-214&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-225&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-226&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-238&quot;&gt;&lt;span data-ttu-id=&quot;e4f85-239&quot;&gt;接着就是使用dapper做数据存储。该类的方法都是通过 &lt;strong&gt;&lt;span&gt;CustomUserStore&lt;/span&gt;&lt;/strong&gt; 调用去操作数据库的。具体代码如下。根据实际的用户表去操作dapper即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_45944826-5e3d-4ca8-8c09-eb9359abe0eb&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_45944826-5e3d-4ca8-8c09-eb9359abe0eb&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_45944826-5e3d-4ca8-8c09-eb9359abe0eb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Identity;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data.SqlClient;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Dapper;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; YepMarsCRM.Enterprise.DataBase.Model;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; YepMarsCRM.Enterprise.DataBase.Data;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; YepMarsCRM.Web.CustomProvider
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DapperUsersTable
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; SqlConnection _connection;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Sys_AccountData _sys_AccountData;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DapperUsersTable(SqlConnection connection)
        {
            _connection &lt;/span&gt;=&lt;span&gt; connection;
            _sys_AccountData &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sys_AccountData();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Sys_Account ApplicationUserToAccount(ApplicationUser user)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Sys_Account
            {
                Id &lt;/span&gt;=&lt;span&gt; user.Id,
                UserName &lt;/span&gt;=&lt;span&gt; user.UserName,
                PasswordHash &lt;/span&gt;=&lt;span&gt; user.PasswordHash,
                Email &lt;/span&gt;=&lt;span&gt; user.Email,
                EmailConfirmed &lt;/span&gt;=&lt;span&gt; user.EmailConfirmed,
                PhoneNumber &lt;/span&gt;=&lt;span&gt; user.PhoneNumber,
                PhoneNumberConfirmed &lt;/span&gt;=&lt;span&gt; user.PhoneNumberConfirmed,
                LockoutEnd &lt;/span&gt;= user.LockoutEnd?&lt;span&gt;.DateTime,
                LockoutEnabled &lt;/span&gt;=&lt;span&gt; user.LockoutEnabled,
                AccessFailedCount &lt;/span&gt;=&lt;span&gt; user.AccessFailedCount,
            };
        }

        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; createuser
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IdentityResult&amp;gt;&lt;span&gt; CreateAsync(ApplicationUser user)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rows = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _sys_AccountData.InsertAsync(ApplicationUserToAccount(user));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rows &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; IdentityResult.Success;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; IdentityResult.Failed(&lt;span&gt;new&lt;/span&gt; IdentityError { Description = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Could not insert user {user.Email}.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IdentityResult&amp;gt;&lt;span&gt; DeleteAsync(ApplicationUser user)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;string sql = &quot;DELETE FROM Sys_Account WHERE Id = @Id&quot;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;int rows = await _connection.ExecuteAsync(sql, new { user.Id });&lt;/span&gt;

            &lt;span&gt;int&lt;/span&gt; rows = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _sys_AccountData.DeleteForPKAsync(ApplicationUserToAccount(user));

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rows &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; IdentityResult.Success;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; IdentityResult.Failed(&lt;span&gt;new&lt;/span&gt; IdentityError { Description = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Could not delete user {user.Email}.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
        }


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ApplicationUser&amp;gt;&lt;span&gt; FindByIdAsync(Guid userId)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SELECT *  FROM Sys_Account WHERE Id = @Id;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; _connection.QuerySingleOrDefaultAsync&amp;lt;ApplicationUser&amp;gt;(sql, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;
            {
                Id &lt;/span&gt;=&lt;span&gt; userId
            });
        }


        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ApplicationUser&amp;gt; FindByNameAsync(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; userName)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; sql = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SELECT * FROM Sys_Account WHERE UserName = @UserName;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; _connection.QuerySingleOrDefaultAsync&amp;lt;ApplicationUser&amp;gt;(sql, &lt;span&gt;new&lt;/span&gt;&lt;span&gt;
            {
                UserName &lt;/span&gt;=&lt;span&gt; userName
            });

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;var user = new ApplicationUser() { UserName = userName, Email = userName, EmailConfirmed = false };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;user.PasswordHash = new PasswordHasher&amp;lt;ApplicationUser&amp;gt;().HashPassword(user, &quot;test&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;return await Task.FromResult(user);&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IdentityResult&amp;gt;&lt;span&gt; UpdateAsync(ApplicationUser applicationUser)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user =&lt;span&gt; ApplicationUserToAccount(applicationUser);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _sys_AccountData.UpdateForPKAsync(user);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; IdentityResult.Success;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; IdentityResult.Failed(&lt;span&gt;new&lt;/span&gt; IdentityError { Description = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Could not update user {user.Email}.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;DapperUsersTable&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、使用UserManager、SignInManager验证操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　新建一个 &lt;strong&gt;&lt;span&gt;AccountController&lt;/span&gt;&lt;/strong&gt; 控制器 并在构造函数中获取 依赖注入的对象 &lt;strong&gt;&lt;span&gt;UserManager&lt;/span&gt;&lt;/strong&gt; 与 &lt;strong&gt;&lt;span&gt;SignInManager&lt;/span&gt;&lt;/strong&gt; 如下：&lt;em id=&quot;__mceDel&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;　　&lt;/em&gt;[&lt;span&gt;Authorize&lt;/span&gt;]&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt;&lt;span&gt; AccountController&lt;/span&gt; : &lt;span&gt;Controller&lt;/span&gt;
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;UserManager&lt;/span&gt;&amp;lt;&lt;span&gt;ApplicationUser&lt;/span&gt;&amp;gt;&lt;span&gt; _userManager;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;SignInManager&lt;/span&gt;&amp;lt;&lt;span&gt;ApplicationUser&lt;/span&gt;&amp;gt;&lt;span&gt; _signInManager;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ILogger _logger;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; AccountController(&lt;span&gt;UserManager&lt;/span&gt;&amp;lt;&lt;span&gt;ApplicationUser&lt;/span&gt;&amp;gt;&lt;span&gt; userManager,
            &lt;span&gt;SignInManager&lt;/span&gt;&lt;/span&gt;&amp;lt;&lt;span&gt;ApplicationUser&lt;/span&gt;&amp;gt;&lt;span&gt; signInManager,
            ILoggerFactory loggerFactory)
        {
            _userManager &lt;/span&gt;=&lt;span&gt; userManager;
            _signInManager &lt;/span&gt;=&lt;span&gt; signInManager;
            _logger &lt;/span&gt;= loggerFactory.CreateLogger&amp;lt;&lt;span&gt;AccountController&lt;/span&gt;&amp;gt;&lt;span&gt;();
        }&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;SignInManager&lt;/span&gt;&lt;/strong&gt; 是提供用户登录登出的API ，&lt;span&gt;&lt;strong&gt;UserManager&lt;/strong&gt;&lt;/span&gt; 是提供用户管理的API。&lt;/p&gt;
&lt;p&gt;　　接着来实现一下简单的登录登出。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 登录
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        [&lt;span&gt;HttpPost&lt;/span&gt;]
        [&lt;span&gt;AllowAnonymous&lt;/span&gt;]&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;Task&lt;/span&gt;&amp;lt;&lt;span&gt;IActionResult&lt;/span&gt;&amp;gt;&lt;span&gt; Login(&lt;span&gt;ReqLoginModel&lt;/span&gt; req)
        {&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; json = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;JsonResultModel&lt;/span&gt;&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ModelState.IsValid)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; _signInManager.PasswordSignInAsync(req.UserName, req.Password, isPersistent: &lt;span&gt;true&lt;/span&gt;, lockoutOnFailure: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.Succeeded)
                {&lt;/span&gt;
                    json.code = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    json.message &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    json.code &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;400&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    json.message &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.IsLockedOut)
                {
                    json.code &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;401&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    json.message &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;账户密码已错误3次，账户被锁定，请30分钟后再尝试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                }&lt;/span&gt;&lt;span&gt;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; errorMessges =&lt;span&gt; ModelState.GetErrorMessage();
                json.code &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;403&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                json.message &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, errorMessges);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; json.ToJsonResult();
        }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 登出
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [&lt;span&gt;HttpPost&lt;/span&gt;]&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;Task&lt;/span&gt;&amp;lt;&lt;span&gt;IActionResult&lt;/span&gt;&amp;gt;&lt;span&gt; LogOut()
        {&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _signInManager.SignOutAsync();&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; json = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;JsonResultModel&lt;/span&gt;&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;()
            {
                code &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                data &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
                message &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登出成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                remark &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty
            };&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; json.ToJsonResult();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、使用Identity配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;在 ConfigureServices 方法中加入&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
            services.Configure&amp;lt;&lt;span&gt;IdentityOptions&lt;/span&gt;&amp;gt;(options =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 密码配置&lt;/span&gt;
                options.Password.RequireDigit = &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否需要数字(0-9).&lt;/span&gt;
                options.Password.RequiredLength = &lt;span&gt;6&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置密码长度最小为6&lt;/span&gt;
                options.Password.RequireNonAlphanumeric = &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否包含非字母或数字字符。&lt;/span&gt;
                options.Password.RequireUppercase = &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否需要大写字母(A-Z).&lt;/span&gt;
                options.Password.RequireLowercase = &lt;span&gt;false&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否需要小写字母(a-z).
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;options.Password.RequiredUniqueChars = 6;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 锁定设置&lt;/span&gt;
                options.Lockout.DefaultLockoutTimeSpan = TimeSpan.FromMinutes(&lt;span&gt;30&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;账户锁定时长30分钟&lt;/span&gt;
                options.Lockout.MaxFailedAccessAttempts = &lt;span&gt;3&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10次失败的尝试将账户锁定
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;options.Lockout.AllowedForNewUsers = true;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户设置&lt;/span&gt;
                options.User.RequireUniqueEmail = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否Email地址必须唯一&lt;/span&gt;
&lt;span&gt;            });

            services.ConfigureApplicationCookie(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cookie settings&lt;/span&gt;
                options.Cookie.HttpOnly = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;options.Cookie.Expiration = TimeSpan.FromMinutes(30);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;30分钟&lt;/span&gt;
                options.Cookie.Expiration = TimeSpan.FromHours(&lt;span&gt;12&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;12小时&lt;/span&gt;
                options.LoginPath = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/Account/NotLogin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the LoginPath is not set here, ASP.NET Core will default to /Account/Login
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;options.LogoutPath = &quot;/api/Account/Logout&quot;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the LogoutPath is not set here, ASP.NET Core will default to /Account/Logout
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;options.AccessDeniedPath = &quot;/Account/AccessDenied&quot;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; If the AccessDeniedPath is not set here, ASP.NET Core will default to /Account/AccessDenied&lt;/span&gt;
                options.SlidingExpiration = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、其他&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;在实现的过程中遇到一些小状况。例如Identity不生效。是因为未在app.UseMvc() 之前使用造成的。 如果未登录会造成跳转。后来查看了.net core Identity 的源码后 发现 如果是ajax情况下 不会跳转而时 返回401的状态码页面。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后就是Idenetity的密码加密 是用 PasswordHasher 这个类去加密的。如果想用自己的加密方式。只能通过继承接口去更改原本的方式。然后大致说到这么些。也当是给自己做做笔记。做得不好请大家多给点意见。多多谅解。谢谢。&lt;/p&gt;
</description>
<pubDate>Wed, 22 Nov 2017 06:28:00 +0000</pubDate>
<dc:creator>进击的Jary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/JinJi-Jary/p/7879024.html</dc:identifier>
</item>
<item>
<title>想使用Docker容器？先看看这些注意事项 - 思考的犀牛</title>
<link>http://www.cnblogs.com/TestingOn/p/7878952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TestingOn/p/7878952.html</guid>
<description>&lt;p&gt;      Docker容器无疑是最近十年来最引人注目的技术之一，因为有了它，对我们思考设计、开发和运维软件的方式产生了非常有益的影响。&lt;/p&gt;
&lt;p&gt;      但是就像每一个开发工具一样，为了充分利用这些工具，需要注意一些使用中问题，Docker容器也是如此。下面是您需要关注的一些地方：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个进程，一个Docker容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     每个Docker容器的核心都是一个进程，尽管每个Docker容器可以使用多个进程，但是这种方法不值得推荐。为了提高效率，每个容器应该只有一个特定的目标进程。其中一个非常重要的原因是如果只使用一个进程的话想在其他项目中迁移使用该Docker将变得容易很多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bfDmzwGGAm7mof5jZicam5SrfJtMXobRCzyico6qcxcMPwNiaCyEaqXDcbSEiaSL48xYwjGkt7jbQtbLQOc4YSKvXg/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bfDmzwGGAm7mof5jZicam5SrfJtMXobRCzyico6qcxcMPwNiaCyEaqXDcbSEiaSL48xYwjGkt7jbQtbLQOc4YSKvXg/0?wx_fmt=png&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-w=&quot;300&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    尽管在容器中运行多个进程在技术上是可行的，但是单进程体系结构具有显著的优势，具体说来：&lt;/p&gt;
&lt;p&gt;      如果容器被隔离到一个单一的功能，水平调整容器会容易得多。 假设您需要另一个Tomcat容器，在其他地方迁移一个即可。但是，如果你的Tomcat容器也运行你的数据库服务，并且其它的数据也需要被迁移走，那么这就变得非常复杂。&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;更好的复用行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       如果一个容器只有一个功能，容器可以容易地重新用于其他项目。&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;易问题定位&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       开发人员能够在本地环境下解决那些在生产中的单个组件出现的问题，而不是从整个应用程序环境中定位问题来解决。  &lt;/p&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;strong&gt;使用磁盘进行数据存储&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;        在容器内部保存数据几乎没有什么用处，因为容器不断地被停止和销毁。无论什么时候需要存储数据，都要在磁盘上进行，因为磁盘可以在多个容器之间更安全地共享。磁盘是将数据存储在容器的可写层中的更好选择，因为使用磁盘不会增加容器的大小，并且磁盘的数据存在于给定容器的生命周期之外。&lt;/p&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;strong&gt;容器通信&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;        每当一个Docker容器需要与另一个容器通信时，传递信息最好使用名称或环境变量。Docker容器当然也有IP地址，但是无论何时启动和停止容器，都是不会依赖IP地址的。&lt;/p&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;strong&gt;以普通用户身份运行Docker&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;        默认情况下，Docker容器以root用户身份运行，众所周知，以root用户运行的容器完全可以控制主机系统。如果黑客访问容器内的“root”用户，他将获得对运行Docker的主机的root权限，为了避免这种情况，请始终以普通用户身份运行Docker容器。&lt;/p&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;strong&gt;注意容器的体积&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;        选择一个容器的主要原因之一是它的体积小。但是，如果你把它做得更大，它的主要优势就没了。当您在群集中部署数千个容器时，如果需要容器相互通信并定期更新容器，这是一个非常严重的问题。&lt;/p&gt;
&lt;p&gt;        所以需要确保只有所需的文件和库来运行对应的应用程序/进程。不要安装不必要的软件包或运行yum update等命令，将不需要的文件下载到新的映像层。&lt;/p&gt;
&lt;p&gt;        打个比方：一个冰箱中是无法装下一个大型集装箱的。&lt;/p&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;strong&gt;制定监测策略&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;        开发和部署Docker容器不是你的工作的结束。您需要持续监控已部署的容器以及整个系统的运行状况。选择合适的工具并制定一个策略来有效地监控您的Docker容器，以确保最短的停机时间，从而使客户满意。&lt;/p&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;strong&gt;Docker容器的安全问题&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;       只要Docker容器在本地开发环境中运行，就没有安全问题。因为测试环境是与外部连接隔离的，是无法确定在外部是否完全的。当您的Docker镜像部署在生产环境中时，因为需要处理外部网络访问，安全性自然成为一个问题。为了预防这个问题，首先需要确保Docker容器所在的主机被修补了最新的安全更新，其次Docker容器中也更新了安全补丁。&lt;/p&gt;
</description>
<pubDate>Wed, 22 Nov 2017 06:16:00 +0000</pubDate>
<dc:creator>思考的犀牛</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TestingOn/p/7878952.html</dc:identifier>
</item>
<item>
<title>六、VueJs 填坑日记之初识*.Vue文件 - 王 二 麻 子</title>
<link>http://www.cnblogs.com/xinhudong/p/7878899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xinhudong/p/7878899.html</guid>
<description>&lt;p&gt;上一篇博文中，我们将接口的地址通过webpack代理到了本地，解决了跨域的问题。在之前的文章中，我们一直对项目进行配置，并没有真正的切入正题，可能很多人还不明白我们要做什么？那么今天，我们就要开写代码了。忠心感谢FungLeo，是你们无私的奉献，才让我们有了学习的参考，以下是地址：&lt;br/&gt;本文转载：http://blog.csdn.net/fungleo/article/details/77575077&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;什么是*.vue文件&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;首先，我们用 vue-cli 脚手架搭建的项目，里面我们已经遇到了很多，如 index.vue 或者 App.vue 这一的文件了。这到底是个什么东西？如果是初次接触 vue 开发的同学，可能之前没有见过这个东西。*.vue 文件，是一个自定义的文件类型，用类似HTML的语法描述一个Vue组件。每个.vue文件包含三种类型的顶级语言块 &amp;lt;template&amp;gt;, &amp;lt;script&amp;gt; 和 &amp;lt;style&amp;gt;。这三个部分分别代表了 html,js,css。&lt;/p&gt;
&lt;p&gt;其中 &amp;lt;template&amp;gt; 和 &amp;lt;style&amp;gt; 是支持用预编译语言来写的。比如，在我们的项目中，我们就用了 scss 预编译，因此，我们是这样写的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;style lang=&quot;scss&quot;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;html 也有自己的预编译语言， vue 也是支持的，不过一般来说，我们前端人员还是比较中意 html 原生语言，所以，我就不过多阐述了。&lt;/p&gt;
&lt;p&gt;另外，我在 App.vue 文件中，已经用一句 @import &quot;./style/style&quot;; 将我们的样式给写到指定的地方去了。所以，在后面所有的我的文章中，是不会出现这个部分的内容的。所有样式，都会在 src/style/ 文件夹中对应的位置去写。我这样做的好处是，不需要重复的引入各种 scss 基础文件，并且做到了项目的样式代码的可管控。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;*.vue 文件代码解析&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;首先，我们来简单看一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;template&amp;gt;
        &amp;lt;div&amp;gt;
                &amp;lt;Header&amp;gt;&amp;lt;/Header&amp;gt;
                &amp;lt;div class=&quot;article_list&quot;&amp;gt;
                        &amp;lt;ul&amp;gt;
                                &amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;
                        &amp;lt;/ul&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;Footer&amp;gt;&amp;lt;/Footer&amp;gt;
        &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
import Header from '../components/header.vue'
import Footer from '../components/footer.vue'
export default {
        components: { Header, Footer },
        data () {
                return {
                        list: []
                }
        },
        created () {
                this.getData()
        },
        methods: {
                getData () {
                        this.$api.get('topics', null, r =&amp;gt; {
                                console.log(r)
                        })
                }
        }
}
&amp;lt;/script&amp;gt;
&amp;lt;style&amp;gt;
        .article_list {margin: auto;}
&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上就是一个简单的 *.vue 文件的基本结构。我们一部分一部分的来解释。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;template 部分&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;以下，我不再称呼它为 *.vue 文件了。改成为 vue 组件。首先，一个 vue 组件，他的 template 则代表它的 html 结构，相信大家可以理解了。但是需要注意的是，我们不是说把代码包裹在 &amp;lt;template&amp;gt;&amp;lt;/template&amp;gt; 中就可以了，而是必须在里面方置一个 html 标签来包裹所有的代码。 本例子中，我们采用了 &amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;标签。&lt;/p&gt;
&lt;p&gt;大家看到 &amp;lt;Header&amp;gt;&amp;lt;/Header&amp;gt; 这个代码的时候肯定很奇怪，这是个什么玩意儿。其实，这是一个自定义组件。我们在其他地方写好了一个组件，然后就可以用这种方式引入进来。同样 &amp;lt;Footer&amp;gt;&amp;lt;/Footer&amp;gt; 也是一个组件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;script 部分&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;首先，我们需要两个自定义组件，我们先引用进来。如下格式，比较好理解吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
import Header from '../components/header.vue'
import Footer from '../components/footer.vue'
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其次，除了引用的文件，我们将所有的代码包裹于如下的代码中间：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
export default {
    // 这里写你的代码，外面要包起来。
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们先引入了 Header 和 Footer 这两个组件的源文件，接下来，我们要把引用的组件给申明到 components 里面去。这样，我们就可以在 template 里面使用了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
components: { Header, Footer },
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;data是我们的数据。我们的演示代码，给了一个 list 的空数组数据。在 template 中，我们可以使用 this.list 来使用我们的数据。这个我们后面的文章中会讲到，这里不去深入，认识它就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
data () {
    return {
        list: []
    }
},
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;created 表示当我们的组件加载完成时，需要执行的内容。比如这里，我们就让组件在加载完成时，执行一个叫 this.getData() 的函数。另外created是vuejs中的勾子函数之一。（具体的勾子函数请参考附录）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
created () {
    this.getData()
},
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;methods是我们的这个组件的方法，也可以说是函数。比如，上面的代码就表示，我们的组件自定义了一个叫 getData() 的方法函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
methods: {
        getData () {
                this.$api.get('topics', null, r =&amp;gt; {
                        console.log(r)
                })
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多关于vue的语法解释请参见：https://cn.vuejs.org/v2/guide/syntax.html&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;style 部分&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;这里比较简单，就是针对我们的 template 里内容出现的 html 元素写一些样式。如下，我的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
&amp;lt;style&amp;gt;
.article_list {margin: auto;}
&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里，我们应该对 vue 组件文件有了一定的认知。后面的博文中，将会涉及到比较多的各种写法，因此，建议在阅读完本文后，花比较多的时间，去查看 vue 的官方文档。虽然文档你不一定能全部看懂，但要有一个大概的认识，否则下面的学习将会比较困难。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;附录&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;勾子，可以理解为vuejs的生命周期，而函数则是生命周期内各个阶段的事件方法。如下图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/441889/201711/441889-20171122140736618-1281560932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 22 Nov 2017 06:08:00 +0000</pubDate>
<dc:creator>王 二 麻 子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xinhudong/p/7878899.html</dc:identifier>
</item>
<item>
<title>迅雷玩客币解析 - 王的博客</title>
<link>http://www.cnblogs.com/cnblogs-wangzhipeng/p/7878748.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cnblogs-wangzhipeng/p/7878748.html</guid>
<description>&lt;p&gt;       目前家用带宽中下载带宽利用率比较高，而上载带宽利用率比较低，同时那些大型的网站对上载带宽资源需求较高，基于这种情况迅雷想出一个办法--`把家用带宽空闲的上载资源整合起来给那些缺少上载资源的客户`。于是迅雷推出玩客云计划，想以玩客云为基础来提升它的各项业务，虽说玩客云号称私有云，但是你加入玩客计划参与所谓的“挖矿”，来贡献你的存储和网络资源，它就不再是一个私有的东西了。&lt;/p&gt;
&lt;p&gt;       迅雷下载的p2p下载原理大家多少都懂，但有很多人只乐于获取不乐于分享（比如说本人），即便是迅雷猥琐的运行很多后台服务，但是我一关机你也玩不转。而玩客云终端作为一个私人硬件云服务器多半是常年在线，如此就多了一些24小时在线的活动节点，以后迅雷的下载速度因该会有所提升。因为你的玩客云服务器会不停的上传\下载，也就是所谓的贡献存储资源和上传资源。同时迅雷的星域CDN项目是为那些流量大户（比如直播网站）提供廉价而又更高效率的内容分发服务，那么玩客云终端可能也会称为CDN服务的边缘节点（以后会专门介绍以下CDN这个东西）。&lt;/p&gt;
&lt;p&gt;       所以玩客云服务用户群是迅雷现在生态圈中很重要的一环，&lt;span&gt;&lt;strong&gt;为了保障玩客云的生态良好发展和节点数不断的壮大， 迅雷借鉴了bitcoin的激励机制，推出玩客币对玩客云生态最下游的云节点散户们作为补贴&lt;/strong&gt;&lt;/span&gt;。这也是我相信参与玩客云会有一定的盈利的原因，毕竟迅雷按照正常思维不会自己砸自己的锅。而且玩客币有一点优于bitcoin，它是按照你贡献的资源为标准来向你分发货币，不存在白白挖矿的情况，雨露均沾，只要你贡献了资源多多少少都会有点收益。&lt;/p&gt;

&lt;p&gt;       那么玩客币会不会形成类似bitcoin的矿厂？我感觉这无所谓，对于迅雷来讲如果形成矿厂更开心，因为这样就保证玩客云更加的稳定。而同时为了保证越来越多的人加入玩客云，迅雷必须想办法保证“矿工”的收益，最直接的办法就是拉升玩客币的币价，拥抱市场。但玩客币能不能登上主流的交易平台吸引更多的资金？这是一个未知数，而以下几点是对于玩客币走向市场比较关键的地方：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;--评价一个虚拟货币如bitcoin、bch、ethereum、ltc等等，最先想到的就是它的代币产生机制，也可以称之为共识算法，那么玩客币的代币产生机制是什么样的？&lt;/li&gt;
&lt;li&gt;--玩客币是像bitcoin那样数量守恒还是不断的增发，这不仅仅是个技术问题，而是涉及到保值的问题？&lt;/li&gt;
&lt;li&gt;--玩客币技术和现在的主流数字货币技术相比有什么优点（当然，这点只有极少部分会关心）？&lt;/li&gt;
&lt;li&gt;--玩客币是否开源接受所有人审核？&lt;/li&gt;
&lt;li&gt;--玩客币的发展路线或者说是自我定位是怎么样的？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ps:这里可能会有人反对作者，因为迅雷已经声明了玩客币只能用于迅雷内部生态圈，不作为一种流通的数字货币。但本人不以为然，为了保障“矿工”的利益，玩客币无论主动或者被动也好，必须要拥抱市场才会有价值，才能更好的刺激矿工的积极性。&lt;/p&gt;
&lt;p&gt;      目前玩客云项目还不是那么的公开透明，我也没有在它的官网上找到类似白皮书的文档，倒是网少有分析称：玩客币钱包的文件结构类似于ehtereum钱包，那么玩客币可能是仿照ethereum也存在一定可能。基于以上作者在这里做一个不负责任的&lt;em&gt;&lt;strong&gt;猜测（注意仅仅是猜测，无法用于对玩客币真实价值衡量的参考）&lt;/strong&gt;&lt;/em&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;玩客币的产生是由迅雷采用中心化的方式，根据一段时间内玩客贡献的资源权重来分发的，至于发行的玩客币数量可能是动态的也可能是静态的。&lt;/li&gt;
&lt;li&gt;玩客账户上玩客币的数量是用类似ethereum的区块链技术来记载的，但是玩客币所谓的“挖矿”纯粹是贡献自己的资源，不参与区块的产生和区块共识。&lt;/li&gt;
&lt;li&gt;记录玩客资产的玩客链（姑且这么称呼）是由迅雷自己运维的私有链（ethereum早就开始商业化的研究了），自己的链自己的矿自己挖，然后根据你的贡献决定给你账户上打多少玩客币。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;      将大量的计算资源、电力投入来转换成hash算力来保证数字货币的安全，是现在很多主流数字货币的做法，但是我始终认为这时一种浪费，即便是必要的浪费也是一种浪费。玩客币则采用一种变相的工作量证明，根据你贡献多少资源来决定给予你多少奖励，这点比bitcoin单纯的追求hash算力是一个很大的进步。我们应该将这些算力资源用在更需要的地方，它这种盈利模式类似于ethereum 大力推广的DAPP模式--取之于民、用之于民、还之于民。&lt;/p&gt;
&lt;p&gt;　　个人认为如果玩客云终端可以和IOTA结合起来可能会有更大的发展空间，比如它可以利用IOTA的交易通道进行数据的加密传输，这样可以提高数据的安全性和匿名性，同时IOTA自带的代币体系也可以很好的保护玩客矿工的资产和利益。虽然玩客云不够公开透明，还存在种种疑点，但是玩客云和玩客币的思想还是值得肯定的。&lt;/p&gt;

</description>
<pubDate>Wed, 22 Nov 2017 05:38:00 +0000</pubDate>
<dc:creator>王的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cnblogs-wangzhipeng/p/7878748.html</dc:identifier>
</item>
<item>
<title>swizzle method 和消息转发机制的实际使用 - 大发写字的地方</title>
<link>http://www.cnblogs.com/DafaRan/p/7878226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DafaRan/p/7878226.html</guid>
<description>
&lt;p&gt; 我的工程结构，如图 1-0&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/994786/201711/994786-20171121190353274-603299479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　　　　　　　图  1-0&lt;/p&gt;

&lt;p&gt; 在看具体实现以前，先捋以下 实现思路。&lt;/p&gt;
&lt;p&gt; ViewController 中有一个-(void)Amethod;A方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
-(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)Amethod{
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Amethod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 1.swizzle method&lt;/p&gt;
&lt;p&gt;在ViewController 的 -(void)viewDidLoad中调用 Amentohd；运行输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/994786/201711/994786-20171122093856461-775760346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　                   　图 1-1&lt;/p&gt;
&lt;p&gt;创建一个ViewController 的Category，重写+(void)Load；方法（因为这个方法只会在类被加载时，调用一次。至于initialize，它们之间区别，参考 &lt;a href=&quot;http://www.jianshu.com/p/9368ce9bb8f9&quot; target=&quot;_blank&quot;&gt;iOS - + initialize 与 +load&lt;/a&gt;），在实现-(void)Bmethod;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
+(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)load{
     Class &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; = [self &lt;span&gt;class&lt;/span&gt;&lt;span&gt;];
    Method m3 &lt;/span&gt;=class_getInstanceMethod(&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, @selector(Amethod));
    Method m4  &lt;/span&gt;=class_getInstanceMethod(&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, @selector(Bmethod));
    method_exchangeImplementations(m3, m4);
    
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;-(void)Bmethod{&lt;/p&gt;
&lt;p&gt;    NSLog(@&quot;swizzle method succuess :Bmenthod&quot;);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;运行结果如下图1-2，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/994786/201711/994786-20171122095215680-351049200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　1-2&lt;/p&gt;
&lt;p&gt;这就是一个简单的交换方法的思路，如果你认真的看了上面的 参考文章，就会发现+(void)Load;是在所有类加载的时候执行的， 那么如果在这个方法里，执行过多操作，是会推延APP启动时间的。所以不要在里面做过多的操作。&lt;/p&gt;
&lt;p&gt;由于swizzle method is not atomic，不是线程安全的，所以你可以在dispatce_once 中完成swizzle。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
+(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)load{
            Class &lt;/span&gt;&lt;span&gt;class&lt;/span&gt; = [self &lt;span&gt;class&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; dispatch_once_t onceToken;
    dispatch_once(&lt;/span&gt;&amp;amp;onceToken, ^&lt;span&gt;{
        Method m3 &lt;/span&gt;=class_getInstanceMethod(&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, @selector(Amethod));
        Method m4  &lt;/span&gt;=class_getInstanceMethod(&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, @selector(Bmethod));&lt;br/&gt;/*下面代码的主要思路就是 主类有没有实现Amethod， 实现了，就交换Amenthod和Bmenthod，没实现就给她加上Amethod，但IMP和enconding type是Bmethod的。&lt;br/&gt;在加上Bmenthod，但IMP 和 encoding type是Amethod的。&lt;br/&gt;*/　&lt;/span&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;span&gt;        BOOL success &lt;/span&gt;= class_addMethod(&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, method_getName(m3), method_getImplementation(m4), method_getTypeEncoding(m4));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (success) {
            class_replaceMethod(&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, method_getName(m4), method_getImplementation(m3), method_getTypeEncoding(m3));
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        method_exchangeImplementations(m3, m4);
        }
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 以上，就是 简单的swizzle method。你也可以在Bmethod 中再次调用Bmethod。不会出现递归。动动脑子就知道了。&lt;/p&gt;
&lt;p&gt;2.消息转发 ： 有三种方法是去补救实现相应方法。也可以做多继承使用。&lt;/p&gt;
&lt;p&gt; 我们在ViewController 中声明一个 button ，但是不实现它的绑定方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    UIButton *pushA = [[UIButton alloc]initWithFrame:CGRectMake(&lt;span&gt;200&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;&lt;span&gt;)];
    [pushA setTitle:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;pusha&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; forState:(UIControlStateNormal)];
    [pushA addTarget:self action:@selector(pushA:) forControlEvents:(UIControlEventTouchUpInside)];
    [self.view addSubview:pushA];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在它的分类中，实现下面代码，当一个实例方法没有实现就会调用 +(BOOL)resolveInstanceMethod:(SEL)sel；相对应对还有类方法+(BOOL)resolveClassMethod:(SEL)sel；&lt;/p&gt;
&lt;p&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
+&lt;span&gt;(BOOL)resolveInstanceMethod:(SEL)sel{
    NSString &lt;/span&gt;*selectionString =&lt;span&gt; NSStringFromSelector(sel);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ([selectionString isEqualToString:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;pushA:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]) {
        class_addMethod(self, sel, (IMP)pushA, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v@:*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);// 在我之前关于YYModel的文中提到 Encoding type
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [super resolveInstanceMethod:sel];// 这里无论返回yes 还是NO ,如果方法没有实现都会调用第二种补救方式
}&lt;br/&gt;//函数的具体实现 也是IMP
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; pushA(&lt;span&gt;id&lt;/span&gt; self,SEL sel,UIButton *&lt;span&gt;sender){
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;动态添加方法%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,self);
    AViewController &lt;/span&gt;*vc = [AViewController &lt;span&gt;new&lt;/span&gt;&lt;span&gt;];
    AViewController &lt;/span&gt;*sourceVC =&lt;span&gt; self;
    [sourceVC.navigationController pushViewController:vc animated:YES];
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  上面是第一种 补救方法。第二种就是-(id)forwardingTargetForSelector:(SEL)aSelector；&lt;/p&gt;
&lt;p&gt;在ViewController 中在[self performSelector:@selector(Cmethod)];但不在Viewcontroller 中实现Cmenthod(关于 -(void)performSelector 还有很多方法，也会稍后添加)&lt;/p&gt;
&lt;p&gt;在分类中，添加转发方法，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
-(&lt;span&gt;id&lt;/span&gt;&lt;span&gt;)forwardingTargetForSelector:(SEL)aSelector{
    AViewController &lt;/span&gt;* avc = [AViewController &lt;span&gt;new&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ([avc respondsToSelector:aSelector]) {
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; avc;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; [super forwardingTargetForSelector:aSelector];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在AViewController实现 -(void)Cmenthod；就完成消息转发给另一个对象。&lt;/p&gt;
&lt;p&gt;第三种补救方式是- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector；配合- (void)forwardInvocation:(NSInvocation *)anInvocation&lt;/p&gt;
&lt;p&gt;使用，其中还要介绍NSInvocation 对象。还有 - (void)doesNotRecognizeSelector:(SEL)aSelector； 所以今天先到这，以后会补充&lt;/p&gt;

</description>
<pubDate>Wed, 22 Nov 2017 05:14:00 +0000</pubDate>
<dc:creator>大发写字的地方</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DafaRan/p/7878226.html</dc:identifier>
</item>
<item>
<title>互联网研发中负载均衡算法一点探索 - 杉枫</title>
<link>http://www.cnblogs.com/freedommovie/p/7878683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freedommovie/p/7878683.html</guid>
<description>&lt;p&gt;    负载均衡在线上服务中有着很重要作用，因为一台web服务比如tomcat，能够处理qps（每秒处理请求数）&lt;/p&gt;
&lt;p&gt;是有限的。那么就需要有有前端负载均衡服务将大的流量分发为多个后端服务进行处理。&lt;/p&gt;
&lt;p&gt;       负载均衡产品有硬件F5、有软件，早之前使用Apache较多，目前是使用Nginx多，Nginx架构实现简洁优&lt;/p&gt;
&lt;p&gt;雅性能高。LVS、HAProxy是著名软负载工具。说到LVS是由原淘宝章文蒿（目前在滴滴公司）博士领导开发，&lt;/p&gt;
&lt;p&gt;是到目前为止Linux内核中网络核心部分，也是国人开Linux内核最高贡献，章博士在国内技术圈封神，实至名&lt;/p&gt;
&lt;p&gt;归。当然国内对于Linux内核进行贡献代码人很多，以后有机会可以介绍下那些牛人。&lt;/p&gt;
&lt;p&gt;       硬件F5优点是负载均衡效果好、效率高，缺点是配置复杂，成本高。&lt;/p&gt;
&lt;p&gt;       Apache、Nginx可以进行软件负载，软件负载性能没有硬件负载性能高，但优势是配置灵活并且能知道&lt;/p&gt;
&lt;p&gt;后端负载情况，根据后端负载调整负载均衡配置。Nginx支持多种负载均衡算法，根据实际情况调整负载配置&lt;/p&gt;
&lt;p&gt;来满足业务需要。软件负载成本低效果也能满足线上性能需要，软件负载在互联网企业有着广泛用途。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/942404/201711/942404-20171122131113071-577524262.png&quot; alt=&quot;&quot; width=&quot;826&quot; height=&quot;362&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       web网站软件负载均衡过程是，用户请求打到负载均衡Apache、Nginx上，由Apache、Nginx转发到&lt;/p&gt;
&lt;p&gt;多个Tomcat服务，Tomcat上web服务接收到请求处理完返回给Apache或Nginx，Apache和Nginx将请求返&lt;/p&gt;
&lt;p&gt;回给前端浏览器，完成整个负载均衡过程。&lt;/p&gt;
&lt;p&gt;       nginx负载均衡算法：有轮训负载均衡算法，ip hash负载均衡算法，url hash负载均衡算法，轮训加权&lt;/p&gt;
&lt;p&gt;负载均衡算法，fair 负载算法按服务端相应时间来分配请求。&lt;/p&gt;
&lt;p&gt;       dubbo微服务本身也是通过软件负载来分配客户端请求，与web差异点是一：负载是在客户端进行处理&lt;/p&gt;
&lt;p&gt;而不是服务端。二是负载是负载请求次数而不是连接，因为当下微服务都是通过netty来实现长连接，负载&lt;/p&gt;
&lt;p&gt;是负载多个长连接对于每个连接中产生调用次数。&lt;/p&gt;
&lt;p&gt;       1、轮训算法：前端请求按时间顺序按顺序配置到后端服务器，如果是后台服务当掉，如果后台服务器&lt;/p&gt;
&lt;p&gt;当掉，则去掉有问题机器，对于用户请求无感知，用户不会知道已有服务掉线，也是实现服务高可用。&lt;/p&gt;
&lt;p&gt;       2、加权负载均衡算法：指定轮训权重，权重越大，给后端服务转发请求越多，这种配置用在后台服务&lt;/p&gt;
&lt;p&gt;器性能有好好差情况下，后台性能好机器配置高权重，后台性能差服务配置低权重，根据实际后台服务情况&lt;/p&gt;
&lt;p&gt;调整权重配置。&lt;/p&gt;
&lt;p&gt;       3、ip hash可以根据用户请求ip按照hash算法将请求分配到固定后端服务上，这样可以解决用户在动态&lt;/p&gt;
&lt;p&gt;服务上session共享问题，当前session共享也可以通过共同存储，比如将session存储到数据库或者将session&lt;/p&gt;
&lt;p&gt;存储到redis来解决session共享问题。&lt;/p&gt;
&lt;p&gt;        ip hash还有个好处就是在618、双11等电商大促高并发场景下，当用户请求超过系统能够处理负载，实&lt;/p&gt;
&lt;p&gt;现对用户排队，通过排队避免用户请求过多压垮系统。&lt;/p&gt;
&lt;p&gt;       4、url hash：按访问url hash将固定url访问，打到固定节点服务，这样可以根据url调整服务资源，最大&lt;/p&gt;
&lt;p&gt;化资源利用率。&lt;/p&gt;
&lt;p&gt;       5、fair负载均衡算法：根据服务端相应时间，来调整分配给每一台后端服务请求数量，这样可以更智能、&lt;/p&gt;
&lt;p&gt;合理、资源最大化使用实现负载调配。&lt;/p&gt;
&lt;p&gt;       负载均衡算法还要注意失效节点负载重新进行均匀分配，而不是对整个流量全部进行重新分配。避免突然&lt;/p&gt;
&lt;p&gt;给后台服务增加很多请求造成服务不可用。再有就是负载均衡算法成熟，要避免bug导致服务击穿，并且产生洪&lt;/p&gt;
&lt;p&gt;泛效应，将所有服务节点均打垮最终导致服务不可用。&lt;/p&gt;
&lt;p&gt;        对于每一个技术都要掌握原理，很好的去使用它，发挥它最大优势，勿在浮沙筑高台，希望对大家有帮助。&lt;/p&gt;
</description>
<pubDate>Wed, 22 Nov 2017 05:13:00 +0000</pubDate>
<dc:creator>杉枫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freedommovie/p/7878683.html</dc:identifier>
</item>
</channel>
</rss>