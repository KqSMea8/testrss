<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ElasticSearch+Logstash+Filebeat+Kibana集群日志管理分析平台搭建 - readygood</title>
<link>http://www.cnblogs.com/readygood/p/9955533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/readygood/p/9955533.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;在使用搜索引擎是你可能会觉得很简单方便，只需要在搜索栏输入想要的关键字就能显示出想要的结果。但在这简单的操作背后是搜索引擎复杂的逻辑和许多组件协同工作的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　搜索引擎的组件一般可分为两大类：索引组件和搜索组件。在搜索之前搜索引擎必须把可搜索的所有数据做整合处理并构建索引（倒排索引），将所有数据构建成能被搜索的格式并存储起来，这就成为索引组件；能根据用户搜索并能从索引组件构建的索引中查询出用户想要的结果的组件称为搜索组件。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　ElasticSearch就属于搜索组件的一种，并且它是一个分布式搜索服务器，在搭建ElasticSearch集群时最好有三台以上的服务器，因为它的数据都是分片存储的。Lucene是Apache提供的开源项目，是一个完全用Java编写的搜索引擎库。ElasticSearch使用Lucene作为内部的搜索索引构建库，使ElasticSearch集成了搜索引擎的两大核心组件。虽然用这两个组件可以完成索引构建并进行搜索操作，但成为完善的搜索引擎是不够的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于集群日志分析平台来说，还需要对大量应用服务的日志数据进行采集，并按需要的格式进行划分、存储、分析，这就要用到Logstash和Filebeat组件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Filebeat是一个非常轻量化的日志采集组件，Filebeat 内置的多种模块（auditd、Apache、NGINX、System 和 MySQL）可实现对常见日志格式的一键收集、解析和可视化。而Logstash是一个开源的服务器端数据处理管道，它可以同时从多个源中提取数据，对其进行转换，然后输出到指定位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在解决上面一系列问题后，搜索引擎还需要提供一个友善的用户界面来展示给用户，使用户能够进行傻瓜式的搜索操作，并且还能将搜索结果通过各种直观的方式展示在用户面前。这是就要用到Kibana组件。Kibana可以让ElasticSearch数据极为丰富的展现出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上面提到的组件除了Lucene库意外其他的都属于Elastic Stack家族的产品，在普遍的企业中都是采用这些组件构建成集群来分析处理大量的日志数据的。更多组件可访问&lt;a href=&quot;https://www.elastic.co/&quot; target=&quot;_blank&quot;&gt;Elastic官网站点&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;1.基本架构&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在本文示例中，以下面的结构来进行演示，图1：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181114224313761-497888189.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;304&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;在上图所示的架构的工作逻辑：Kibana将ElasticSearch集群提供的搜索内容进行可视化处理，并用多种方式展现给用户；ElasticSearch集群和其集成的Lucene用来完成对所有采集到的数据进行分析构建索引并提供搜索；而数据的来源则是通过Logstash和FileBeat采集自Nginx日志，Logstash将来自FileBeat的数据过滤并输出给ElasticSearch集群。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在集群达到一定规模后，大量的后端应用通过FileBeat采集到数据输出到Logstash会使Logstash Server称为性能瓶颈，因为Logstash是用Java程序开发的，很消耗内存，当数据处理量大后性能会大打折扣；所以可以在Logstash和FileBeat之间增加Redis，Redis专门用来做队列数据库，将在FieBeat中采集的数据平缓的输出到Logstash。如图2：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181114123051765-1059190329.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;287&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; &lt;span&gt;2.搭建ElasticSearch集群&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Linux版本：CentOS7.2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ElasticSearch：5.5.1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面先用图1的架构示例来构建集群，完成后再引入Redis来进行演示，当集群没有达到很庞大规模时引入Redis不会对集群性能有实质性的提升。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;由于ElasticSearch是用Java开发的，运行时依赖JDK环境，ElasticSearch集群所有节点上都需要装上JDK。在n2~n4节点上安装ElasticSearch和JDK：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y java-&lt;span&gt;1.8&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-openjdk java-&lt;span&gt;1.8&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-openjdk-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　在官网下载ElasticSearch，我这里安装的是ElasticSearch5.5.1版本，在官网下载rpm包直接安装：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rpm -ivh elasticsearch-&lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　ElasticSearch5的程序环境：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; /etc/elasticsearch/&lt;span&gt;elasticsearch.yml #主程序配置文件
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; /etc/elasticsearch/&lt;span&gt;jvm.options #java配置文件
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; /etc/elasticsearch/log4j2.properties #日志配置文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;主配合文件配置段：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;Cluster #集群配置段，需要设置ElasticSearch集群名称
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;Node #各节点配置段，要设置当前主机的主机名
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;Paths #各类路径配置段 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;Memory #内存配置段 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;Network #网络配置段 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;Discovery #
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;Gateway 
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; Various
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_097a6630-5c2e-4c36-a552-71d1935f9b77&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_097a6630-5c2e-4c36-a552-71d1935f9b77&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_097a6630-5c2e-4c36-a552-71d1935f9b77&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # ---------------------------------- Cluster -----------------------------------
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; # Use a descriptive name &lt;span&gt;for&lt;/span&gt;&lt;span&gt; your cluster:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; #cluster.name: my-&lt;span&gt;application
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;cluster.name: myels #集群名称，ElasticSearch是基于集群名和主机名来识别集群成员的
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; # ------------------------------------ Node ------------------------------------
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; # Use a descriptive name &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the node:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; #node.name: node-&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;node.name: n2 #本节点名
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;# Add custom attributes to the node:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#node.attr.rack: r1
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; # ----------------------------------- Paths ------------------------------------
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;# Path to directory where to store the data (separate multiple locations by comma):
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; #path.data: /path/to/&lt;span&gt;data
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; path.data: /els/&lt;span&gt;data #查询索引数据存放路径
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;# Path to log files:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; path.data: /els/&lt;span&gt;logs #日志路径
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; #path.logs: /path/to/&lt;span&gt;logs
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; # ----------------------------------- Memory -----------------------------------
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;# Lock the memory on startup:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; #bootstrap.memory_lock: &lt;span&gt;true&lt;/span&gt;&lt;span&gt; #是否开启时就划用所有内存
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;# Make sure that the heap size is set to about half the memory available
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;# on the system and that the owner of the process is allowed to use this
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;# limit.
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;# Elasticsearch performs poorly when the system is swapping the memory.
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; # ---------------------------------- Network -----------------------------------
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;# Set the bind address to a specific IP (IPv4 or IPv6):
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; #network.host: &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; network.host: &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.102&lt;/span&gt;&lt;span&gt; #监听地址，默认是本地
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; # Set a custom port &lt;span&gt;for&lt;/span&gt;&lt;span&gt; HTTP:
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; #http.port: &lt;span&gt;9200&lt;/span&gt;&lt;span&gt; #监听端口
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; # For &lt;span&gt;more&lt;/span&gt;&lt;span&gt; information, consult the network module documentation.
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; # --------------------------------- Discovery ----------------------------------
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;# Pass an initial list of hosts to perform discovery when new node is started:
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; # The default list of hosts is [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[::1]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; discovery.zen.&lt;span&gt;ping&lt;/span&gt;.unicast.hosts: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;] #为了安全起见，尽量将ElasticSearch节点的解析名配置进来（画圈圈）
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; # Prevent the &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;split brain&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; by configuring the majority of nodes (total number of master-eligible nodes / &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; discovery.zen.minimum_master_nodes: &lt;span&gt;2&lt;/span&gt;&lt;span&gt; #脑裂预防选项
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; # For &lt;span&gt;more&lt;/span&gt;&lt;span&gt; information, consult the zen discovery module documentation.
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; # ---------------------------------- Gateway -----------------------------------
&lt;span&gt;65&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; # Block initial recovery after a full cluster restart &lt;span&gt;until&lt;/span&gt;&lt;span&gt; N nodes are started:
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; #gateway.recover_after_nodes: &lt;span&gt;3&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; # For &lt;span&gt;more&lt;/span&gt;&lt;span&gt; information, consult the gateway module documentation.
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; # ---------------------------------- Various -----------------------------------
&lt;span&gt;73&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;# Require explicit names when deleting indices:
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;#
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; #action.destructive_requires_name: &lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ElasticSearch主配置&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　创建数据和日志目录并修改目录权限并启动ElasticSearch：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mkdir&lt;/span&gt; -pv /els/&lt;span&gt;{data,logs}
&lt;/span&gt;&lt;span&gt;chown&lt;/span&gt; -R elasticsearch.elasticsearch /els/&lt;br/&gt;systemctl start elasticsearch
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　启动时发生了错误：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181115135322402-1195431643.png&quot; alt=&quot;&quot; width=&quot;661&quot; height=&quot;148&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　查看 &lt;span class=&quot;cnblogs_code&quot;&gt;/var/log/messages&lt;/span&gt; 发现一条警告信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
elasticsearch: OpenJDK &lt;span&gt;64&lt;/span&gt;-Bit Server VM warning: If the number of processors is expected to increase from one, &lt;span&gt;then&lt;/span&gt; you should configure the number of parallel GC threads appropriately using -XX:ParallelGCThreads=N
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;这是因为JVM中的 &lt;span class=&quot;cnblogs_code&quot;&gt;ParallelGCThreads&lt;/span&gt; 参数未设置正确导致的，我修改了虚拟机的线程数后又出现了新的报错：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
elasticsearch: Exception &lt;span&gt;in&lt;/span&gt; thread &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ElasticsearchParseException[duplicate settings key [path.data] found at line number [&lt;span&gt;36&lt;/span&gt;], column number [&lt;span&gt;12&lt;/span&gt;], previous value [/els/data], current value [/els/logs]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　这个的大致意思就是路径冲突了，后来发现在主配置文件中我将 &lt;span class=&quot;cnblogs_code&quot;&gt;path.logs: /els/logs&lt;/span&gt; 写成了 &lt;span class=&quot;cnblogs_code&quot;&gt;path.data: /els/logs&lt;/span&gt; ，导致路径冲突。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;启动完成后可以看到9200和9300端口被监听：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181115143618935-1424569981.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;至此ElasticSearch集群就已经工作起来了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181115150020262-1371755066.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.安装Kibana&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在n1上安装Kibana：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rpm -ivh kibana-&lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;-x86_64.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;修改Kibana配置文件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim /etc/kibana/kibana.yml
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_f93173d9-56f3-48de-821d-79198f0bcfcd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f93173d9-56f3-48de-821d-79198f0bcfcd&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f93173d9-56f3-48de-821d-79198f0bcfcd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;# Kibana is served by a back end server. This setting specifies the port to use.
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; #server.port: &lt;span&gt;5601&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; server.port: &lt;span&gt;5601&lt;/span&gt;&lt;span&gt; #监听端口
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; # Specifies the address to &lt;span&gt;which&lt;/span&gt;&lt;span&gt; the Kibana server will bind. IP addresses and host names are both valid values.
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; # The default is &lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;which&lt;/span&gt;&lt;span&gt; usually means remote machines will not be able to connect.
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; # To allow connections from remote users, set this parameter to a non-&lt;span&gt;loopback address.
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; #server.host: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; server.host: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.29.101&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; #监听地址
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; # Enables you to specify a path to &lt;span&gt;mount&lt;/span&gt; Kibana at &lt;span&gt;if&lt;/span&gt;&lt;span&gt; you are running behind a proxy. This only affects
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;# the URLs generated by Kibana, your proxy is expected to remove the basePath value before forwarding requests
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; # to Kibana. This setting cannot end &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a slash.
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; #server.basePath: &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt; # The maximum payload size &lt;span&gt;in&lt;/span&gt; bytes &lt;span&gt;for&lt;/span&gt;&lt;span&gt; incoming server requests.
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; #server.maxPayloadBytes: &lt;span&gt;1048576&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; # The Kibana server&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s name.  This is used for display purposes.&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt; #server.name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;your-hostname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt; server.name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; #主机名
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; # The URL of the Elasticsearch instance to use &lt;span&gt;for&lt;/span&gt;&lt;span&gt; all your queries.
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; #elasticsearch.url: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://n2:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; elasticsearch.url: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://n2:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; #ElasticSearch地址
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; # When this setting&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s value is true Kibana uses the hostname specified in the server.host&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt; # setting. When the value of this setting is &lt;span&gt;false&lt;/span&gt;, Kibana uses the &lt;span&gt;hostname&lt;/span&gt;&lt;span&gt; of the host
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;# that connects to this Kibana instance.
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; #elasticsearch.preserveHost: &lt;span&gt;true&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt; # Kibana uses an index &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Elasticsearch to store saved searches, visualizations and
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; # dashboards. Kibana creates a new index &lt;span&gt;if&lt;/span&gt; the index doesn&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t already exist.&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt; #kibana.index: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.kibana&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;# The default application to load.
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; #kibana.defaultAppId: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;discover&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;# If your Elasticsearch is protected with basic authentication, these settings provide
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;# the username and password that the Kibana server uses to perform maintenance on the Kibana
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; # index at startup. Your Kibana users still need to authenticate with Elasticsearch, &lt;span&gt;which&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;# is proxied through the Kibana server.
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; #elasticsearch.username: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; #可以设置登录认证用户和密码
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; #elasticsearch.password: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt; # Enables SSL and paths to the PEM-&lt;span&gt;format SSL certificate and SSL key files, respectively.
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; # These settings enable SSL &lt;span&gt;for&lt;/span&gt;&lt;span&gt; outgoing requests from the Kibana server to the browser.
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; #server.ssl.enabled: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; #server.ssl.certificate: /path/to/your/&lt;span&gt;server.crt
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; #server.ssl.key: /path/to/your/&lt;span&gt;server.key
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt; # Optional settings that provide the paths to the PEM-&lt;span&gt;format SSL certificate and key files.
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;# These files validate that your Elasticsearch backend uses the same key files.
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; #elasticsearch.ssl.certificate: /path/to/your/&lt;span&gt;client.crt
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; #elasticsearch.ssl.key: /path/to/your/&lt;span&gt;client.key
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt; # Optional setting that enables you to specify a path to the PEM &lt;span&gt;file&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the certificate
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; # authority &lt;span&gt;for&lt;/span&gt;&lt;span&gt; your Elasticsearch instance.
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; #elasticsearch.ssl.certificateAuthorities: [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/path/to/your/CA.pem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; # To disregard the validity of SSL certificates, change this setting&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s value to &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;none&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;#elasticsearch.ssl.verificationMode: full
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; 
&lt;span&gt; 60&lt;/span&gt; # Time &lt;span&gt;in&lt;/span&gt; milliseconds to &lt;span&gt;wait&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; Elasticsearch to respond to pings. Defaults to the value of
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;# the elasticsearch.requestTimeout setting.
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; #elasticsearch.pingTimeout: &lt;span&gt;1500&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt; # Time &lt;span&gt;in&lt;/span&gt; milliseconds to &lt;span&gt;wait&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; responses from the back end or Elasticsearch. This value
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;# must be a positive integer.
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; #elasticsearch.requestTimeout: &lt;span&gt;30000&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt; # List of Kibana client-side headers to send to Elasticsearch. To send *no* client-&lt;span&gt;side
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;# headers, set this value to [] (an empty list).
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;#elasticsearch.requestHeadersWhitelist: [ authorization ]
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;# Header names and values that are sent to Elasticsearch. Any custom headers cannot be overwritten
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; # by client-&lt;span&gt;side headers, regardless of the elasticsearch.requestHeadersWhitelist configuration.
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;#elasticsearch.customHeaders: {}
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt; # Time &lt;span&gt;in&lt;/span&gt; milliseconds &lt;span&gt;for&lt;/span&gt; Elasticsearch to &lt;span&gt;wait&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; responses from shards. Set to &lt;span&gt;0&lt;/span&gt;&lt;span&gt; to disable.
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; #elasticsearch.shardTimeout: &lt;span&gt;0&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt; # Time &lt;span&gt;in&lt;/span&gt; milliseconds to &lt;span&gt;wait&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; Elasticsearch at Kibana startup before retrying.
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; #elasticsearch.startupTimeout: &lt;span&gt;5000&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt; # Specifies the path where Kibana creates the process ID &lt;span&gt;file&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; #pid.&lt;span&gt;file&lt;/span&gt;: /var/run/&lt;span&gt;kibana.pid
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt; # Enables you specify a &lt;span&gt;file&lt;/span&gt;&lt;span&gt; where Kibana stores log output.
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;#logging.dest: stdout
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt; # Set the value of this setting to &lt;span&gt;true&lt;/span&gt;&lt;span&gt; to suppress all logging output.
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; #logging.silent: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt; # Set the value of this setting to &lt;span&gt;true&lt;/span&gt;&lt;span&gt; to suppress all logging output other than error messages.
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; #logging.quiet: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt; # Set the value of this setting to &lt;span&gt;true&lt;/span&gt;&lt;span&gt; to log all events, including system usage information
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;# and all requests.
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; #logging.verbose: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt; # Set the interval &lt;span&gt;in&lt;/span&gt;&lt;span&gt; milliseconds to sample system and process performance
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; # metrics. Minimum is 100ms. Defaults to &lt;span&gt;5000&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; #ops.interval: &lt;span&gt;5000&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt; # The default locale. This locale can be used &lt;span&gt;in&lt;/span&gt;&lt;span&gt; certain circumstances to substitute any missing
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;# translations.
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; #i18n.defaultLocale: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;浏览器访问http://192.168.29.101:5601，显示如下，说明Kibana已经安装成功:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181115153608579-1754462410.png&quot; alt=&quot;&quot; width=&quot;559&quot; height=&quot;226&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.在n6上安装Nginx和Filebeat&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　前面已经将ElasticSearch搜索引擎最重要的部分搭建完成了，可以进行搜索和构建索引了。下面来部署数据采集的部分。我这里用Nginx来做演示，用Filebeat将Nginx的日志搜集并输出给ElasticSearch并构建索引提供搜索。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在n6节点安装Nginx和Filebeat：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
rpm -ivh filebeat-&lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;-&lt;span&gt;x86_64.rpm
&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y nginx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　配置Filebeat并启动：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vim /etc/filebeat/filebeat.yml
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_3280cc06-0fcc-4c50-b85e-19d79dd17042&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3280cc06-0fcc-4c50-b85e-19d79dd17042&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3280cc06-0fcc-4c50-b85e-19d79dd17042&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #=========================== Filebeat prospectors =============================
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;filebeat.prospectors:
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; # Each -&lt;span&gt; is a prospector. Most options can be set at the prospector level, so
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; # you can use different prospectors &lt;span&gt;for&lt;/span&gt;&lt;span&gt; various configurations.
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;# Below are the prospector specific configurations.
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; -&lt;span&gt; input_type: log
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;  # Paths that should be crawled and fetched. Glob based paths.
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;  paths:
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     #- /var/log&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.log
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;    - /var/log/nginx/access.log #指定要采集的日志文件路径
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;    #- c:\programdata\elasticsearch\logs\*
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;  # Exclude lines. A list of regular expressions to match. It drops the lines that are
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;  # matching any regular expression from the list.
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;  #exclude_lines: [&quot;^DBG&quot;]
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;  # Include lines. A list of regular expressions to match. It exports the lines that are
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;  # matching any regular expression from the list.
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;  #include_lines: [&quot;^ERR&quot;, &quot;^WARN&quot;]
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;  # Exclude files. A list of regular expressions to match. Filebeat drops the files that
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;  # are matching any regular expression from the list. By default, no files are dropped.
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;  #exclude_files: [&quot;.gz$&quot;]
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;  # Optional additional fields. These field can be freely picked
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;  # to add additional information to the crawled log files for filtering
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;  #fields:
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;  #  level: debug
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;  #  review: 1
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;  ### Multiline options
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;  # Mutiline can be used for log messages spanning multiple lines. This is common
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;  # for Java Stack Traces or C-Line Continuation
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; 
&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;  #multiline.pattern: ^\[
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;  # Defines if the pattern set under pattern should be negated or not. Default is false.
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;  #multiline.negate: false
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;  #multiline.match: after
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;#================================ General =====================================
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; 
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;# The name of the shipper that publishes the network data. It can be used to group
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;# all the transactions sent by a single shipper in the web interface.
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;#name:
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;# The tags of the shipper are included in their own field with each
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;# transaction published.
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;#tags: [&quot;service-X&quot;, &quot;web-tier&quot;]
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;# Optional fields that you can specify to add additional information to the
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;# output.
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;#fields:
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;#  env: staging
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;#================================ Outputs =====================================
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;# Configure what outputs to use when sending the data collected by the beat.
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;# Multiple outputs may be used.
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;#-------------------------- Elasticsearch output ------------------------------
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;output.elasticsearch:
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;  # Array of hosts to connect to.
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;  hosts: [&quot;n2:9200&quot;] #数据输出到ElasticSearch，填写集群其中的一个即可
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;  # Optional protocol and basic auth credentials.
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;  #protocol: &quot;https&quot;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;  #username: &quot;elastic&quot;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;  #password: &quot;changeme&quot;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;#----------------------------- Logstash output --------------------------------
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;#output.logstash:
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;  # The Logstash hosts
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;  #hosts: [&quot;localhost:5044&quot;]
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;  # Optional SSL. By default is off.
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;  # List of root certificates for HTTPS server verifications
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;  #ssl.certificate_authorities: [&quot;/etc/pki/root/ca.pem&quot;]
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;  # Certificate for SSL client authentication
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;  #ssl.certificate: &quot;/etc/pki/client/cert.pem&quot;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;  # Client Certificate Key
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;  #ssl.key: &quot;/etc/pki/client/cert.key&quot;
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;#================================ Logging =====================================
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;# Sets log level. The default log level is info.
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;# Available log levels are: critical, error, warning, info, debug
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;#logging.level: debug
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;# At debug level, you can selectively enable logging only for some components.
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;# To enable all selectors use [&quot;*&quot;]. Examples of other selectors are &quot;beat&quot;,
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;# &quot;publish&quot;, &quot;service&quot;.
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;#logging.selectors: [&quot;*&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
systemctl start filebeat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;在浏览器上访问n6节点，使Nginx生成日志文件，触发Filebeat将数据输出给ElasticSearch，然后访问n1节点的Kibana，配置索引模式构建索引。在Nginx被访问后会自动生成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181115165351748-1701705537.png&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;308&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181115170744999-1040493079.png&quot; alt=&quot;&quot; width=&quot;504&quot; height=&quot;322&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4.安装并配置Logstash&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在n5节点上安装Logstash，Logstash的运行依赖JDK环境，所以也需要安装JDK：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y java-&lt;span&gt;1.8&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-openjdk java-&lt;span&gt;1.8&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-openjdk-&lt;span&gt;devel
rpm &lt;/span&gt;-ivh logstash-&lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　Logstash的组件结构分为输入组件(Input plugin)、输出组件(Output plugin)、过滤组件(Filter plugin)，图示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181115173951449-890144058.png&quot; alt=&quot;&quot; width=&quot;589&quot; height=&quot;234&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　测试Logstash是否能正常运行时，为避免与root发生权限冲突，需要切换至logstash用户尝试启动Logstash：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;su&lt;/span&gt; - logstash -s /bin/bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;主配置文件为： &lt;span class=&quot;cnblogs_code&quot;&gt;/etc/logstash/logstash.yml&lt;/span&gt; ，基本上不需要做修改，但要修改n6节点上的Filebeat配置文件，将Filebeat的输出从ElasticSearch修改成向Logstash输出：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_dab0d82a-cb16-41d8-87ed-336f9f3dd5b7&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_dab0d82a-cb16-41d8-87ed-336f9f3dd5b7&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_dab0d82a-cb16-41d8-87ed-336f9f3dd5b7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
#----------------------------- Logstash output --------------------------------&lt;span&gt;
output.logstash:
  # The Logstash hosts
  #hosts: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost:5044&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  hosts: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n5:5044&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　在n5节点上编写Logstash过滤模块：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_cab72f3b-b359-4038-833f-6a84e965e9d8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cab72f3b-b359-4038-833f-6a84e965e9d8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cab72f3b-b359-4038-833f-6a84e965e9d8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;input { #定义数据输入来源，这里定义的是从Filebeat输入
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        beats {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 host =&amp;gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  #监听地址
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 port =&amp;gt; &lt;span&gt;5044&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;filter { #过滤模块，将输入的数据按某种定义的格式做处理切割
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;   grok { #由grok模块来过滤
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       match =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%{IPORHOST:clientip}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; #切割源message的格式                                                     
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;output { #将过滤后的数据输出到ElasticSearch
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        elasticsearch {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 hosts =&amp;gt; [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n2:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n2:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;n2:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 index =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logstash-nginxlog-%{+YYYY.MM.dd}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;在Kibana上重新查找便能看出已经将 &lt;span class=&quot;cnblogs_code&quot;&gt;clientip&lt;/span&gt; 切割出来了，这种的切割功能用Filebeat是没办法实现的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181115221001042-1290412814.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;104&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 14:13:00 +0000</pubDate>
<dc:creator>readygood</dc:creator>
<og:description>一、ELK搜索引擎原理介绍 在使用搜索引擎是你可能会觉得很简单方便，只需要在搜索栏输入想要的关键字就能显示出想要的结果。但在这简单的操作背后是搜索引擎复杂的逻辑和许多组件协同工作的结果。 搜索引擎的组</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/readygood/p/9955533.html</dc:identifier>
</item>
<item>
<title>标准化和归一化对机器学习经典模型的影响 - SongHL</title>
<link>http://www.cnblogs.com/songorz/p/9966397.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songorz/p/9966397.html</guid>
<description>&lt;h2&gt;归一化&lt;/h2&gt;
&lt;p&gt;归一化也称标准化，是处理数据挖掘的一项基础工作,使用归一化的原因大体如下：&lt;/p&gt;
&lt;p&gt;数据存在不同的评价指标，其量纲或量纲单位不同，处于不同的数量级。解决特征指标之间的可比性，经过归一化处理后，各指标处于同一数量级，便于综合对比。求最优解的过程会变得平缓，更容易正确收敛。即能提高梯度下降求最优解时的速度。提高计算精度。适合进行综合对比评价。&lt;/p&gt;
&lt;h3&gt;MinMaxScaler&lt;/h3&gt;
&lt;p&gt;线性归一化，也称为离差标准化，是对原始数据的线性变换，MinMax标准化方法的缺陷在当有新数据加入时，可能会导致X.max和X.min的值发生变化，需要重新计算。其转换函数如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20171013084706198&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;StandardScaler&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;标准差归一化&lt;/strong&gt;，也叫Z-score标准化，这种方法给予原始数据的均值（mean，μ）和标准差（standard deviation，σ）进行数据的标准化。经过处理后的数据符合标准正态分布，即均值为0，标准差为1，转化函数为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20171013085253015&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;MaxAbsScaler&lt;/h3&gt;
&lt;p&gt;原理与MinMaxScaler很像，只是数据会被规模化到[-1,1]之间。也就是特征中，所有数据都会除以最大值。这个方法对那些已经中心化均值维0或者稀疏的数据有意义。&lt;/p&gt;
&lt;h2&gt;模型&lt;/h2&gt;
&lt;p&gt;本次实验使用了5个模型，分别为Lasso、Redige、SVR、RandomForest、XGBoost。&lt;/p&gt;
&lt;h2&gt;方法：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;以不同方式划分数据集和测试集&lt;/li&gt;
&lt;li&gt;使用不同的归一化（标准化）方式&lt;/li&gt;
&lt;li&gt;使用不同的模型&lt;/li&gt;
&lt;li&gt;通过比较MSE（均方误差，mean-square error）的大小来得出结论&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;部分代码及结果&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

#data = pd.read_csv('路径')

data = data.sort_values(by='time',ascending=True)
data.reset_index(inplace=True,drop=True)

target = data['T1AOMW_AV']
del data['T1AOMW_AV']&lt;br/&gt;　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;数据处理&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;   去除缺失值&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 没有缺失值
All_NaN = pd.DataFrame(data.isnull().sum()).reset_index()
All_NaN.columns = ['name','times']
All_NaN.describe()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181115215848181-626177738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;所有数据中，干掉 方差小于1的属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
feature_describe_T = data.describe().T
std_feature = feature_describe_T[feature_describe_T['std']&amp;lt;1].index
feature = [column for column in data.columns if column not in std_feature]  # 筛选方差大于1的属性 
data = data[feature]

del data['time']
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
test_data = data[:5000]

data1 = data[5000:16060]
target1 = target[5000:16060]
data2 = data[16060:]
target2 = target[16060:]

import scipy.stats as stats
dict_corr = {
    'spearman' : [],
    'pearson' : [],
    'kendall' : [],
    'columns' : []
}

for i in data.columns:
    corr_pear,pval = stats.pearsonr(data[i],target)
    corr_spear,pval = stats.spearmanr(data[i],target)
    corr_kendall,pval = stats.kendalltau(data[i],target)
    
    dict_corr['pearson'].append(abs(corr_pear))
    dict_corr['spearman'].append(abs(corr_spear))
    dict_corr['kendall'].append(abs(corr_kendall))
    
    dict_corr['columns'].append(i)
    
# 筛选新属性  
dict_corr =pd.DataFrame(dict_corr)
new_fea = list(dict_corr[(dict_corr['pearson']&amp;gt;0.32) &amp;amp; (dict_corr['spearman']&amp;gt;0.48) &amp;amp; (dict_corr['kendall']&amp;gt;0.44)]['columns'].values)
# 选取原则，选取25%分位数 以上的相关性系数
dict_corr.describe()
len(new_fea)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181115215927866-553298576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;各种模型的测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;81&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from sklearn.linear_model import LinearRegression,Lasso,Ridge
from sklearn.preprocessing import MinMaxScaler,StandardScaler,MaxAbsScaler
from sklearn.metrics import mean_squared_error as mse
from sklearn.svm import SVR

mm = MinMaxScaler()
lr = Lasso(alpha=0.5)

lr.fit(mm.fit_transform(data1[new_fea]), target1)
lr_ans = lr.predict(mm.transform(data2[new_fea]))

print(&quot;LR : &quot;, mse(lr_ans,target2) )##lr
ridge = Ridge(alpha=0.5)
ridge.fit(mm.fit_transform(data1[new_fea]),target1)
ridge_ans = ridge.predict(mm.transform(data2[new_fea]))

print(&quot;ridge : &quot;,mse(ridge_ans,target2 ))#ridge
svr = SVR(kernel='rbf',C=100,epsilon=0.1).fit(mm.fit_transform(data1[new_fea]),target1)
svr_ans = svr.predict(mm.transform(data2[new_fea]))
print(&quot;svr : &quot;,mse(svr_ans,target2) )#svr
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(data[new_fea],target,test_size=0.25,random_state=12345)

ss = MaxAbsScaler()
ss_x_train = ss.fit_transform(X_train)
ss_x_test = ss.transform(X_test)

estimator_lr = Lasso(alpha=0.5).fit(ss_x_train,y_train)
predict_lr = estimator_lr.predict(ss_x_test)
print('Lssao:',mse(predict_lr,y_test))

estimator_rg = Ridge(alpha=0.5).fit(ss_x_train,y_train)
predict_rg = estimator_rg.predict(ss_x_test)
print('Ridge:',mse(predict_rg,y_test))

estimator_svr = SVR(kernel='rbf',C=100,epsilon=0.1).fit(ss_x_train,y_train)
predict_svr = estimator_svr.predict(ss_x_test)
print('SVR:',mse(predict_svr,y_test))

estimator_RF = RandomForestRegressor().fit(ss_x_train,y_train)
predict_RF = estimator_RF.predict(ss_x_test)
print('RF:',mse(predict_RF,y_test))

predict_XG  = xgb.XGBRegressor(learn_rate=0.1,n_estimators = 550,max_depth = 4,min_child_weight = 5,seed=0,subsample=0.7,gamma=0.1,reg_alpha=1,reg_lambda=1)
predict_XG.fit(ss_x_train,y_train)
predict_XG_ans=predict_XG.predict(ss_x_test)
print(&quot;predict_XG : &quot;, mse(predict_XG_ans,y_test))&lt;br/&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　结果：&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1417592/201811/1417592-20181115215718784-1692907952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 结论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于Lasso模型，使用MaxAbsScaler方式时，mse增大十分明显，且归一化后结果高于不进行归一化时;&lt;/li&gt;
&lt;li&gt;对于Redige模型，归一化结果也明显高于不归一化时的结果;&lt;/li&gt;
&lt;li&gt;对于SVR模型，不进行归一化时，其MSE会非常大;&lt;/li&gt;
&lt;li&gt;对于RandomForest和XGBoost来说，是否进行归一化对结果影响不大;&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Thu, 15 Nov 2018 14:04:00 +0000</pubDate>
<dc:creator>SongHL</dc:creator>
<og:description>归一化 归一化也称标准化，是处理数据挖掘的一项基础工作,使用归一化的原因大体如下： 数据存在不同的评价指标，其量纲或量纲单位不同，处于不同的数量级。解决特征指标之间的可比性，经过归一化处理后，各指标处</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songorz/p/9966397.html</dc:identifier>
</item>
<item>
<title>我与时间管理的故事 - 追梦子</title>
<link>http://www.cnblogs.com/pssp/p/9966121.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pssp/p/9966121.html</guid>
<description>&lt;p&gt;这是上家公司，在团队做的分享，还是挺有意思的，特此分享。&lt;/p&gt;
&lt;h2 id=&quot;初识树状文档&quot;&gt;初识树状文档&lt;/h2&gt;
&lt;p&gt;记得刚来团队那会, 每天早上有个站会, 站会的任务就是把今天要做的事情写到树状文档里面, 刚开始这样做我是不太认同的, 因为在以前的公司并没有这么做过, 在之前的公司最多也就是写写周报, 然而对于周报而言,当时我也是比较反感的, 因为那时觉得写这些东西根本没有多少意义,写这个就是为了给领导看的, 然而之前写了也没人给反馈, 所以导致那时我对写这些东西是十分的不认同&lt;/p&gt;
&lt;p&gt;然而不管认不认同吧, 既然团队有这个要求,也只好按照要求去写了, 记录的方式倒是很简单, 就是把要做的事情写到文档里面, 然后记录下这件事的状态, 一般用的状态是todo,done和cancel&lt;/p&gt;
&lt;p&gt;在我按照团队的要求记录了一段时间后就感到现在的记录方式和之前公司写周报的方式是很不一样的, 之前是每周五下班前把本周做的工作和下周的工作计划用微信发送给我们的Leader, 然后Leader汇总后发送给管理层, 而现在我们团队的做法让我觉得记录这些并不是为了给谁看而写, 而是为了帮我更好的理清我要做的事, 以及不会把要做的事情忘记&lt;/p&gt;
&lt;p&gt;当然, 让我能够在短时间内认同这一点, 还要感谢团队和亮哥开发的树状文档工具, 因为它的记录方式让我觉得是非常友好和方便的&lt;/p&gt;
&lt;p&gt;这样做的时间越久, 我就越坚信每天把要做的事情记录下来是很有意义的, 因为有了这些记录的内容,我们以后就可以很方便的进行查看, 尽管现在可能没有什么用, 但以后就说不定了&lt;/p&gt;
&lt;p&gt;比如: 前段时间亮哥code view了我半年前的一个项目代码, 里面有一段很难理解的代码, 然后亮哥问我那段代码是怎么回事, 然而由于时间太久, 导致现在让我去想我也想不出当时为什么那样写的, 然后我只好去查git, 但是当时git一次提交的内容太多了, 导致提交的信息也没能很好的解释清楚那段代码到底是做什么的, 后来通过拿git的提交时间, 在当时的任务列表里面找到了那段代码相关的解释, 不过可惜的是, 当时写的信息比较少, 所以也只是知道那段代码是为了解决某个bug才那样去写的&lt;/p&gt;
&lt;p&gt;所以说记录是很有必要的, 不过把内容记录的详细点也是很重要的, 不然就有可能发生像我前面说的那样&lt;/p&gt;
&lt;p&gt;另外因为每天记录了当天做的事情, 因此当团队需要写周报的话, 那基本上就不需要花多少时间去回忆做过的事情了,只需要把之前记录下来的整理和修改一下就可以了&lt;/p&gt;
&lt;h2 id=&quot;todo与四象限&quot;&gt;Todo与四象限&lt;/h2&gt;
&lt;p&gt;当你有过一段时间这样的记录后, 你会发现其实记录不仅仅是为了防止忘记还有什么事情没做, 更是为了让你知道你现在做到了哪&lt;/p&gt;
&lt;p&gt;想起某次分享会上, 亮哥对GTD也就是任务管理做了一次分享, 在那次分享之后, 我对记录和知识管理更加着迷, 那之后不久, 很偶然的, 我学了四象限, 它是用来区分任务的紧急程度的&lt;/p&gt;
&lt;p&gt;记得当时我做过一次关于四象限的分享, 那时我以为我会将四象限用上很长一段时间, 但那之后的一段时间里, 我发现在实际的工作中,我更多的是在自我挑选任务, 而不是根据任务的紧急程度去做事,因此我在使用四象限的过程中, 常常将所有事情都给放在了重要且紧急,或者不紧急但重要里面, 最后的结果就是, 我的四象限与Todo列表基本上没有什么区别了, 然后我就在想, 既然这样,那干脆还是使用原来的方式做个Todo列表好了, 于是四象限就这样被我抛弃了&lt;/p&gt;
&lt;p&gt;在放弃四象限后,我得出了几点, 很多时候你是无法控制住自己先去做哪些事情, 然后再去做哪些事情的, 尽管你可能知道某件事相对于另一件事来说更重要一些, 但是四象限根本就没有办法控制你不去做某件事情, 或者去做某件事, 也就是说如果一个人能够控制住自己, 那么就算是使用最简单的Todo列表也能很好的根据自己的价值观做出选择并加以执行, 相反如果不能控制住自己, 那么就算有四象限也将是一个虚设&lt;/p&gt;
&lt;p&gt;尽管我说我抛弃了四象限, 但这么说也不全对, 因为在某些情况下, 我还是会按照四象限推崇的以任务的重要程度来区分先后顺序, 只不过是我没有再去将任务分为4块, 对比使用四象限和现在的区别就在于, 现在使用任务的重要程度来区分先后顺序的比例减少了, 更多的是由自己当下发挥&lt;/p&gt;
&lt;p&gt;现在我使用任务的重要程度来区分先后顺序的常见惯例是, 我正在做某件事, 突然接到一个新任务, 那么这时我就会按照任务的重要和紧急程度来决定是否要放下手上的这件事而去做新接的任务&lt;/p&gt;
&lt;p&gt;不过我, 除了考虑任务的重要和紧急程度, 还会去想的一个问题就是, 如果现在不做这件事, 是否会影响之后任务的执行, 另外如果新接的这个任务能够在几分钟内完成或者这件事并不需要我来完成, 而是需要我转告给另一个同事, 那么这时我也会放下当前正在做的事情, 去做新接的任务&lt;/p&gt;
&lt;p&gt;不过当你真正做任务管理的时候, 你会发现我们除了考虑任务的重要紧急程度以外, 还有很多其他的方案可以选择, 并且如果你真的完全按照任务的重要和紧急程度去做, 也不见得就好, 因为任务的重要程度是会变化的, 也许某件事对于今年来说是重要的, 但有可能后来因为某些原因导致那件变得没有多少必要了, 所以留有一定的自由选择也是很有意义的&lt;/p&gt;
&lt;p&gt;在任务管理方面我主要使用的方法是, 收集, 记录, 整理, 执行, 当然, 如果要做的那件事很够在1,2分钟内就完成, 那么我就不会去记录, 而是直接把它做完&lt;/p&gt;
&lt;h2 id=&quot;时间记录法&quot;&gt;时间记录法&lt;/h2&gt;
&lt;p&gt;其实, 我除了每天会去写任务列表外, 还有一件比较重要的就是, 我会把每件事花费的时间记录下来&lt;/p&gt;
&lt;p&gt;记录的方式是参考的柳比歇夫的时间记录法, 柳比歇夫是一位苏联的昆虫学家, 但大多数人认识他的原因并不是因为他是昆虫学家, 而是因为他的时间记录法, 有本书叫做&amp;lt;奇特的一生&amp;gt;, 里面讲述了柳比歇夫56年如一日的通过记录每天的时间花费情况做统计, 然后将统计后的结果进行分析, 最后根据分析的结果去安排自己的时间&lt;/p&gt;
&lt;p&gt;时间记录法的规则很简单, 就是将每天做的事情和花费的时间记录下来, 这些记录下来的会被作为下一次计划任务时的一个参考, 如果是按照柳比歇夫的做法, 那么我们还需要定期对这些做过的事做一次回顾&lt;/p&gt;
&lt;p&gt;在使用时间记录法的一段时间后, 我通过记录的这些数据了解到自己在哪些方面浪费的时间比较多, 以及每天真正花在做事的时间上有多少, 当有一定的数据后, 我就可以算出平均每天有多少时间是有效的, 有效时间, 指的是, 抛除那些不可工作后的时间, 比如走路,喝水, 等&lt;/p&gt;
&lt;p&gt;当我知道了自己每天有多少有效时间后, 我就可以拿当天记录的数据与有效时间做个比较, 看是多了还是少了, 如果是少了, 那么就应该去看是在哪些地方花费的时间比较多, 并做好总结避免下次再出现这种情况&lt;/p&gt;
&lt;p&gt;通过时间记录法, 我们还可以了解到某类事情需要花费多少时间,比如之前我看某种类型的书籍需要花费3小时, 那么在下一次我要看类似书籍的时候就能够估计出一个大概的时间了, 如果我之前没有做过这方面的记录, 那么我就只能是瞎猜&lt;/p&gt;
&lt;p&gt;有了数据后, 我可以更合理的去安排下一次计划, 不至于将一天安排的过多或过少, 之所以可以更合理的去安排下一次的计划, 就在于我之前做过类似的事情, 并有相关的记录, 因此现在再去做类似的事情心里肯定是有个大体的数的&lt;/p&gt;
&lt;p&gt;时间记录法还有一个好处, 那就是你能够分析出, 你对某类事情的兴趣增减情况&lt;/p&gt;
&lt;h2 id=&quot;番茄工作法&quot;&gt;番茄工作法&lt;/h2&gt;
&lt;p&gt;在工作中, 我们常常会因为无法专注的去做某件事而苦恼, 那么这时可以考虑番茄工作法&lt;/p&gt;
&lt;p&gt;番茄工作法是一套工作流, 其目的是提高专注力, 以及合理的安排休息时间, 番茄工作法的原理是将一天分为多个番茄, 一般每个番茄为25分钟, 每做完一个番茄就休息5分钟, 一旦开始某个番茄, 就不能被中断, 如果被中断, 那么这个番茄将被作废, 需要重新开始, 在你准备使用番茄时, 需要确保你的时间不会被他人打扰, 如果无法确定那么就不要使用了&lt;/p&gt;
&lt;p&gt;不过在实际情况中, 往往25分钟是不可能的, 比如我在编程中, 往往一写就是几个小时, 比如5月1号的下午, 我从4点左右开始写某个东西, 结果一写就到晚上7点左右了, 当然长时间做电脑旁是不太好的, 但往往就控制不住自己, 比如写到一半多的时候, 就想着都快写完了, 干脆写完好了, 反正很多时候就是这样&lt;/p&gt;
&lt;p&gt;尽管说番茄工作法的时间分配并不适合我, 但是我依然喜欢番茄工作法, 因为虽然我可以长时间的去做某件事, 但是并不代表我可以始终专一的去做那件事, 时常在做那件事时, 做着做着就去弄了和它不相关的东西, 正因为有这一点, 我才认为说, 番茄工作法对我依然是有益的, 只是它和四象限一样我不需要完全去按照官方推荐的做法去执行而已&lt;/p&gt;
&lt;p&gt;另外它推荐的休息时间, 也是比较不错的, 因为长时间的工作真的不是太好, 尽管我现在还没有做到, 但我现在也在开始准备往这方面去考虑, 怎么安排会比较合适&lt;/p&gt;
&lt;p&gt;在你刚开始使用番茄工作法时, 可能会产生一些焦虑感, 容易让你去想现在还剩多少时间, 不过在你使用一段时间后, 焦虑感会逐渐消失, 当然这也可能是我个人情况, 如果你没有产生自然是好的, 如果产生了也不必惊慌&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;有一天你会发现, 不管我们如何做时间管理, 我们永远都不可能会有将任务做完的一天, 甚至会让你的事情变得越来越多,所以在装进杯子里面之前, 看看装进去的是什么, 不要为了装满杯子, 而把什么都往里面塞&lt;/p&gt;
&lt;p&gt;然后问问自己,需要那么多时间做什么, 因为如果你不知道你为什么要那么多时间, 那就是给你很多空闲的时间, 那也只会是浪费&lt;/p&gt;
&lt;p&gt;关于时间的分享就到这了, 最后我还想说的是:&lt;/p&gt;
&lt;p&gt;有时我们容易过早的去拒绝一些新鲜的事物, 但这样做的结果就是, 我们少了一种新的可能性, 在没有实际用过它之前, 我们往往不知道它到底有什么用, 或者说用还是不用它,对我们有什么改善, 然而如果你没有去用它, 是不太可能想明白的, 理性的做法是自己试验一段时间，看看是否真的有效&lt;/p&gt;
&lt;p&gt;给它一个公平的机会, 也给自己一个改变自己的机会, 不管现在你认为它是好的还是坏的&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 13:19:00 +0000</pubDate>
<dc:creator>追梦子</dc:creator>
<og:description>这是上家公司，在团队做的分享，还是挺有意思的，特此分享。 初识树状文档 记得刚来团队那会, 每天早上有个站会, 站会的任务就是把今天要做的事情写到树状文档里面, 刚开始这样做我是不太认同的, 因为在以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pssp/p/9966121.html</dc:identifier>
</item>
<item>
<title>详解C#泛型（二） - Minotauros</title>
<link>http://www.cnblogs.com/minotauros/p/9965997.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minotauros/p/9965997.html</guid>
<description>&lt;p&gt;　　一、自定义泛型方法（Generic Method），将类型参数用作参数列表或返回值的类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; MyFunc&amp;lt;T&amp;gt;() &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明具有一个类型参数的泛型方法&lt;/span&gt;
&lt;span&gt;{
    Type genericType &lt;/span&gt;= &lt;span&gt;typeof&lt;/span&gt;(T); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在泛型方法体内部获取类型参数的类型信息
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do…&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用泛型方法&lt;/span&gt;
MyFunc&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1.声明泛型方法时，可以在参数列表中使用这个类型参数：void MyFunc&amp;lt;T&amp;gt;(T obj) { }；此时在调用该泛型方法时可以省略类型参数的指定由编译器推断其类型，例如：MyFunc&amp;lt;int&amp;gt;(myNum)与MyFunc(myNum)完全等效；&lt;/p&gt;
&lt;p&gt;　　2.声明泛型方法时，可以在返回值类型中使用这个类型参数：T MyFunc&amp;lt;T&amp;gt;() { return default(T); }；编译器的类型推断功能不适用于仅在返回值类型中使用类型参数的情况，此种情况在调用时必须显式指定类型参数；&lt;/p&gt;
&lt;p&gt;　　3.声明泛型方法时，方法的参数列表和返回值可以指定相同或不相同的类型参数，如果不相同则一般参数列表的类型参数在前，返回值的类型参数在后：U MyFunc&amp;lt;T, U&amp;gt;(T obj) { return default(U); }，此时依然不能使用编译器的类型推断功能；如果相同，则在调用时可以使用编译器的类型推断功能省略类型参数的显式指定；&lt;br/&gt;类型参数数量的不同，可以构成重载方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; MyFunc() { }
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MyFunc&amp;lt;T&amp;gt;&lt;span&gt;() { }
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MyFunc&amp;lt;T, U&amp;gt;() { }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4.泛型方法中的类型参数也可以指定约束；&lt;/p&gt;
&lt;p&gt;　　5.在泛型类中声明的方法，方法的参数列表和返回值可以使用泛型类的类型参数作为类型；泛型方法可出现在泛型或具体类型中，只有当方法有属于自己的类型参数时才是泛型方法，在泛型类中声明泛型方法时，二者类型参数的占位符不可以相同：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; MyClass&amp;lt;T&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个泛型类，类型参数占位符为T&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MyFunc(T obj) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个非泛型方法，使用泛型类的类型参数T作为参数类型&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do…&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能声明泛型方法void MyFunc&amp;lt;T&amp;gt;，泛型方法的类型参数占位符不能与类的类型参数占位符相同&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; MyFunc&amp;lt;U&amp;gt;(T obj1, U obj2) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个泛型方法，类型参数占位符为U&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do…&lt;/span&gt;
&lt;span&gt;    }
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MyClass &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个具体类&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MyFunc&amp;lt;T&amp;gt;(T obj) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个泛型方法&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do…&lt;/span&gt;
&lt;span&gt;    }
}            &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　二、自定义泛型接口（Generic Interface），将类型参数用作参数列表或返回值的类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt; IMyInterface&amp;lt;T&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义具有一个类型参数的泛型接口&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MyFunc(T obj); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明参数为T的方法&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明泛型类继承自泛型接口&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyClass&amp;lt;T&amp;gt; : IMyInterface&amp;lt;T&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; MyFunc(T obj)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do…&lt;/span&gt;
&lt;span&gt;    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定类型参数为string类型，创角泛型类的实例赋值给泛型接口的变量&lt;/span&gt;
IMyInterface&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; iMyInterface = &lt;span&gt;new&lt;/span&gt; MyClass&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1.适用于泛型类的规则基本也适用于泛型接口；&lt;/p&gt;
&lt;p&gt;　　三、自定义泛型委托（Generic Delegate），将类型参数用作参数列表或返回值的类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; MyDelegate&amp;lt;T&amp;gt;(T obj); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义具有一个类型参数的泛型委托，参数列表中有一个参数&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; MyGenericFunc&amp;lt;T&amp;gt;(T obj) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个泛型方法，参数列表中有一个参数&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do…&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MyFunc(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do…&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明泛型委托的实例，指定类型参数为string类型，此时可匹配的方法签名为void myFunc(string str)&lt;/span&gt;
MyDelegate&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; myDelegate;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;赋值一个指定类型参数为string的泛型方法&lt;/span&gt;
myDelegate = MyGenericFunc&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个参数列表为string类型的具体方法&lt;/span&gt;
myDelegate += MyFunc;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1.泛型委托同泛型类一样，需要在实例化时指定类型参数的类型；&lt;/p&gt;
&lt;p&gt;　　2.泛型委托的实例同具体委托的实例一样，只需要方法的参数列表和返回值类型相同即可进行匹配，因此不管目标方法是指定了符合要求类型的泛型方法还是具体方法都可以进行匹配；　&lt;/p&gt;
&lt;p&gt;　　四、反射中的泛型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
Type myType = &lt;span&gt;typeof&lt;/span&gt;(MyClass&amp;lt;&amp;gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取未指定任何类型参数的开放式构造类的类型信息，多个类型参数时添加,：typeof(MyClass&amp;lt;,&amp;gt;)&lt;/span&gt;
myType = myType.MakeGenericType(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过类型信息的实例方法MakeGenericType()构建指定所有类型参数的封闭式构造类的类型信息，如未指定所有类型参数会抛出异常ArgumentException
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;也可以直接获取封闭式构造类的类型信息，当类型参数在一开始就确定时推荐使用此种方式
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;myType = typeof(MyClass&amp;lt;int&amp;gt;); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多个类型参数时需要同时指定：typeof(MyClass&amp;lt;int, string&amp;gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1.通过反射只可以获取未指定任何类型参数的开放式构造类的类型信息和指定所有类型参数的封闭式构造类的类型信息，即无法获取MyClass&amp;lt;int, &amp;gt;的类型信息；&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“推荐”按钮，您的认可是我写作的最大动力！&lt;/p&gt;
&lt;p&gt;作者：&lt;a title=&quot;Minotauros&quot; href=&quot;https://www.cnblogs.com/minotauros/&quot; target=&quot;_blank&quot;&gt;Minotauros&lt;/a&gt;&lt;br/&gt;出处：&lt;a title=&quot;https://www.cnblogs.com/minotauros/&quot; href=&quot;https://www.cnblogs.com/minotauros/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/minotauros/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;/p&gt;

</description>
<pubDate>Thu, 15 Nov 2018 12:54:00 +0000</pubDate>
<dc:creator>Minotauros</dc:creator>
<og:description>一、自定义泛型方法（Generic Method），将类型参数用作参数列表或返回值的类型： 1.声明泛型方法时，可以在参数列表中使用这个类型参数：void MyFunc&lt;T&gt;(T obj)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minotauros/p/9965997.html</dc:identifier>
</item>
<item>
<title>【安卓本卓】Android系统源码篇之（二）Source Insight - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/9965714.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/9965714.html</guid>
<description>&lt;p&gt; &lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        &lt;/strong&gt;“Source Insight（以下简称SI）是世界上最好的编辑器”，说这句话不知道会不会出门被打呢？-_- 中国古话说得好，“文无第一，武无第二”，所以不敢说SI是最好的，但是说是“最好的之一”绝对是妥妥的。它以丰富的语言支持、便捷的功能、快速的源码导航、实时的上下文显示、独立的符号数据库等众多优点，在全世界范围内广受程序员们的欢迎。本文将结合笔者的实际操作和学习，基于SI3.5做一些使用记录。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、SI简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       SI是一款面向项目开发的程序编辑器和代码浏览器，它提供了一个视图将分散在各个地方的代码汇合在一起形成一个虚拟的整体，供开发者方便地阅读和编辑，如下图所示。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181113185535538-682678704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;Body&quot;&gt;        Source Insight was designed to enhance your ability to understand and modify your program. Our company mission is to increase programming team productivity by clarifying source code, presenting information in a useful way, and allowing programmers to modify software in large, complex projects. ……Source Insight acts as an information server that surrounds your project’s source code. With it, you can have instant access to symbolic and textual information in your program.&lt;/p&gt;
&lt;p class=&quot;Body&quot;&gt;       该段英文摘自SI官方帮助文档，从这里可以看出SI的设计主旨是方便开发者查看和修改源码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、SI的优势&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        SI是如今最好用的语言编辑器之一，具有很多其他编辑器无法比拟的优点，比如下面几点。&lt;/p&gt;
&lt;p&gt;  1、支持语言种类多。&lt;/p&gt;
&lt;p&gt;        SI几乎支持所有的语言，如C、C++、C#、JAVA\、ASM、PAS、ASP、HTML等，而其它编辑器往往只支持其中某类或某几种语言，丰富性远不及SI。&lt;/p&gt;
&lt;p&gt;  2、拥有自己的数据库。&lt;/p&gt;
&lt;p&gt;        SI自动传创建并维护他自己高性能的符号数据库，包括函数、method、全局变量、结构、类、注释和功能源文件里定义的其它类型的符号等。我们可以通俗地理解为缓存，当需要再次查找某个符号时，就可以直接从数据库中查找，而不用在整个源码库中搜索，极大提高了效率。&lt;/p&gt;
&lt;p&gt;  3、显示丰富的程序相关信息。&lt;/p&gt;
&lt;p&gt;       SI提供了丰富多彩的窗口，为被选中的代码提供丰富的信息，如reference trees、class inheritance diagrams、call tress，symbol windows等。后面会专门介绍这些窗口的使用。&lt;/p&gt;
&lt;p&gt;  4、实时显示上下文信息。&lt;/p&gt;
&lt;p&gt;       SI提供了Context Window，当鼠标选择代码中的某个符号时，该window会实时显示选中符号的上下文信息。在下文中的Context Window会详细讲到。甚至在你编辑的时候，SI同时分析你的源码，提供实时的信息并进行分析。 &lt;/p&gt;
&lt;p&gt;  5、快速。&lt;/p&gt;
&lt;p&gt;        提供了快速和革新的访问源代码和源信息的能力，能以最快的速度对源代码导航和提供任何程序编辑器的源信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、创建项目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        &lt;/strong&gt;在SI窗口的顶部工具栏上依次点击 Project &amp;gt; New Project，即可开始创建一个新的项目了。之所以要特别介绍项目的创建过程，除了这是一个极常用的操作外，还有就是创建过程中有一些注意事项需要留心，笔者在使用过程中就曾经走过不少弯路。&lt;/p&gt;
&lt;p&gt;  1、项目命名及设置项目存储路径&lt;/p&gt;
&lt;p&gt;       这里需要注意的是，选择项目数据文件存储路径的时候，要选择你的源码所在的盘符，因为在后面添加源文件的时候，只能从这里设置的盘符中添加（不知道其它用户有没有碰到这个情况，笔者在两台机器上操作过，都是如此）。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181114215934809-765846843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  2、项目设置&lt;/p&gt;
&lt;p&gt;        这里就按照默认的选择就可以了，笔者就是这么做的。当然，这个要根据用户自己需要来选择了，看个人喜好。&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181114220037784-1823060746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  3、添加/删除项目文件&lt;/p&gt;
&lt;p&gt;       在这个界面上，可以看到左侧“Directory”这一栏的根节点，就是第一步中咱们选择的存储项目的盘符，如果你要添加的源文件不在这个盘符，就没法找到了。在该盘符下选择想要添加的文件，如蓝色部分“Android-8.0.0_r1”，这是Android 系统源码根目录，因为这里选择的是文件夹，所以点击右边的“Add Tree”来添加整个目录。如果选择的是文件，多个文件就选择“Add All”，单个文件就选择“Add”&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181114220334280-829319168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       添加时会给出对话框，表示正在添加。笔者添加的源码目录有4G以上，所以这时需要等待好几分钟的时间。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181114220434437-231551695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       添加完成以后，可以看到对话框提示，点击“确定”即可，此时可以继续添加项目文件。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181114221351408-1110464047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  4、完成项目创建&lt;/p&gt;
&lt;p&gt;      当不需要再添加文件了，点击“Close”按钮关闭该界面，即完成了项目的创建。此时显示的界面如下，左下区域显示的就是新建的项目，列表显示了项目中文件。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/472002/201811/472002-20181115193743389-665289277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       持续更新中......&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://baike.baidu.com/item/source%20insight/1833181&quot; target=&quot;_blank&quot;&gt;Source Insight 百度百科&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 11:54:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>Source Insight是当前世界上最好的程序编辑器之一，几乎支持所有的语言，拥有丰富且便捷的功能，快递的源码导航能力，实时显示的上下文信息，独立的符号数据库等特点，使得它在世界范围内广受程序员和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andy-songwei/p/9965714.html</dc:identifier>
</item>
<item>
<title>浅析微信支付：(余额提现)企业付款到微信用户零钱或银行卡账户 - YClimb</title>
<link>http://www.cnblogs.com/yclimb/p/9965698.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yclimb/p/9965698.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文是【浅析微信支付】系列文章的第十二篇，主要讲解在商户存在的提现、商户付款到微信用户零钱或者银行卡需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;浅析微信支付系列已经更新十二篇了哟～，没有看过的朋友们可以看一下哦。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/YESU2V5byxfM8z9YQXgnuA&quot;&gt;浅析微信支付：支付验收示例和验收指引&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/WmnsCnIrhN9STbvrNTQOiA&quot;&gt;浅析微信支付：如何使用沙箱环境测试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/XCR1Ts-uabuC573_vLb3Qg&quot;&gt;浅析微信支付：下载对账单和资金账单&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/IyWjWB__-VsqKO8SL0DL3Q&quot;&gt;浅析微信支付：申请退款、退款回调接口、查询退款&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你是做电商或者某些有福利返利的系统，基本上会遇到诸如 &lt;code&gt;余额提现&lt;/code&gt; 这类需求，主要就是平台向用户返利现金，积累到某一个门槛，可以领取到自己的余额账号、银行卡；或者是使用为用户发送现金红包的方式。&lt;/p&gt;
&lt;p&gt;接下来的两篇文章，会为大家描述在微信支付中，像用户付款的以上三种方式。&lt;/p&gt;
&lt;p&gt;以下为三种付款方式的必要条件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;商户号（或同主体其他非服务商商户号）已入驻90日&lt;/li&gt;
&lt;li&gt;商户号（或同主体其他非服务商商户号）有30天连续正常交易&lt;/li&gt;
&lt;li&gt;登录微信支付商户平台-产品中心，开通企业付款。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;企业付款到微信用户零钱&quot;&gt;企业付款到微信用户零钱&lt;/h3&gt;
&lt;p&gt;企业付款提供由商户直接付钱至用户微信零钱的能力，支持平台操作及接口调用两种方式，资金到账速度快，使用及查询方便。主要用来解决合理的商户对用户付款需求，比如：保险理赔、彩票兑换等等。&lt;/p&gt;
&lt;p&gt;如何开通？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;入驻成为商户：在线提交营业执照、身份证、银行账户等基本信息，快速提交申请；&lt;/li&gt;
&lt;li&gt;超级管理员开通：前往商户平台-产品中心-企业付款到零钱-申请开通；&lt;/li&gt;
&lt;li&gt;特殊要求：交易资金是即时入账到商户号基本户的商户，需要满足以下要求：需入驻满90天，连续交易30天。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所需资料：开通企业付款到零钱功能无需提供额外的材料。&lt;br/&gt;费用：试用期间免费使用。&lt;/p&gt;
&lt;h4 id=&quot;应用场景&quot;&gt;应用场景&lt;/h4&gt;
&lt;p&gt;企业付款为企业提供付款至用户零钱的能力，支持通过API接口付款，或通过微信支付商户平台（pay.weixin.qq.com）网页操作付款。&lt;/p&gt;
&lt;p&gt;以下为官方的解释：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=14_1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;抓重点，首先需要知道的是，开通了&lt;code&gt;运营账户&lt;/code&gt;的商户，付款时会从运营账户余额中扣除，这个一定要注意，以免金额不足时付款失败（可以使用主账户为运营账户充值，参考[交易中心]-[充值/转入]）。&lt;/p&gt;
&lt;p&gt;以下为特别需要注意的地方，为大家标记出来，设计系统时一定要参考一下，以免入坑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181115194658528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lDbGltYg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;企业付款到余额-1&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;接口链接&quot;&gt;接口链接&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;https://api.mch.weixin.qq.com/mmpaymkttransfers/promotion/transfers&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;是否需要证书&quot;&gt;是否需要证书&lt;/h4&gt;
&lt;p&gt;请求需要双向证书。&lt;/p&gt;
&lt;h4 id=&quot;调用接口&quot;&gt;调用接口&lt;/h4&gt;
&lt;p&gt;注意事项：&lt;br/&gt;◆ 当返回错误码为“SYSTEMERROR”时，请不要更换商户订单号，一定要使用原商户订单号重试，否则可能造成重复支付等资金风险。&lt;br/&gt;◆ XML具有可扩展性，因此返回参数可能会有新增，而且顺序可能不完全遵循此文档规范，如果在解析回包的时候发生错误，请商户务必不要换单重试，请商户联系客服确认付款情况。如果有新回包字段，会更新到此API文档中。&lt;br/&gt;◆ 因为错误代码字段err_code的值后续可能会增加，所以商户如果遇到回包返回新的错误码，请商户务必不要换单重试，请商户联系客服确认付款情况。如果有新的错误码，会更新到此API文档中。&lt;br/&gt;◆ 错误代码描述字段err_code_des只供人工定位问题时做参考，系统实现时请不要依赖这个字段来做自动化处理。&lt;/p&gt;
&lt;p&gt;PS：目前支持向指定微信用户的openid付款。&lt;/p&gt;
&lt;p&gt;官方文档如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=14_2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的传入参数，这里就不一一列举了，请大家参考一下官方文档，下面贴上具体的实现源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * [微信支付提现接口] - 保存调用的相关记录
 * @param payment 支付对象
 * @param wxPayConfig 微信支付单例对象
 * @return map
 *
 * @author yclimb
 * @date 2018/7/30
 */
public Map&amp;lt;String, String&amp;gt; saveWxPayTransfers(Payment payment, WXPayConfig wxPayConfig) throws Exception {
    // 支付前验证

    // 微信支付对象
    // WXPay wxPay = new WXPay(WXPayConfigImpl.getInstance());
    WXPay wxPay = new WXPay(wxPayConfig);

    // 微信退款接口
    Map&amp;lt;String, String&amp;gt; resultMap = wxPay.transfers(...);
    logger.info(&quot;saveWxPayTransfers:resultMap:&quot; + resultMap.toString());

    // 下单失败，进行处理
    if (WXPayConstants.FAIL.equals(resultMap.get(WXPayConstants.RETURN_CODE)) || WXPayConstants.FAIL.equals(resultMap.get(WXPayConstants.RESULT_CODE))) {

        // 处理结果返回，无需继续执行

        // 余额不足提醒
        if (WXPayCodeEnum.ERR_CODE_NOTENOUGH.getCode().equals(resultMap.get(WXPayConstants.ERR_CODE))) {
            // 发送余额不足的消息提醒
            
        }
    }

    // 付款记录修改 &amp;amp; 记录付款日志
    
    return resultMap;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上为调用的应用方法，下面为大家贴出微信接口调用代码 &lt;code&gt;imall.weixin.sdk.WXPay&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 作用：企业向微信用户个人付款&amp;lt;br&amp;gt;
 * 场景：企业付款为企业提供付款至用户零钱的能力，支持通过API接口付款，或通过微信支付商户平台（pay.weixin.qq.com）网页操作付款。
 * 接口文档地址：https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=14_2
 *
 * @param partner_trade_no 商户订单号
 * @param openid           用户openid
 * @param amount           企业付款金额
 * @param desc             企业付款描述信息
 * @param spbill_create_ip 该IP可传用户端或者服务端的IP
 * @return API返回数据
 * @throws Exception e
 */
public Map&amp;lt;String, String&amp;gt; transfers(String partner_trade_no, String openid, String amount, String desc, String spbill_create_ip) throws Exception {

    /** 构造请求参数数据 **/
    Map&amp;lt;String, String&amp;gt; data = new HashMap&amp;lt;&amp;gt;();

    // 商户订单号    partner_trade_no    是   10000098201411111234567890  String  商户订单号，需保持唯一性(只能是字母或者数字，不能包含有符号)
    data.put(&quot;partner_trade_no&quot;, partner_trade_no);
    // 用户openid openid  是   oxTWIuGaIt6gTKsQRLau2M0yL16E    String  商户appid下，某用户的openid
    data.put(&quot;openid&quot;, openid);
    // 校验用户姓名选项 check_name  是   FORCE_CHECK String  NO_CHECK：不校验真实姓名,FORCE_CHECK：强校验真实姓名
    data.put(&quot;check_name&quot;, &quot;NO_CHECK&quot;);
    // 金额   amount  是   10099   int 企业付款金额，单位为分
    data.put(&quot;amount&quot;, String.valueOf(new BigDecimal(amount).multiply(new BigDecimal(100)).setScale(2, BigDecimal.ROUND_HALF_UP).intValue()));
    // 企业付款描述信息 desc    是   理赔  String  企业付款操作说明信息。必填。
    data.put(&quot;desc&quot;, desc);
    // Ip地址 spbill_create_ip    是   192.168.0.1 String(32)  该IP同在商户平台设置的IP白名单中的IP没有关联，该IP可传用户端或者服务端的IP。
    data.put(&quot;spbill_create_ip&quot;, spbill_create_ip);

    /** 以下参数为非必填参数 **/

    /*// 设备号    device_info 否   013467007045764 String(32)  微信支付分配的终端设备号
    data.put(&quot;device_info&quot;, &quot;xxx&quot;);
    // 收款用户姓名   re_user_name    可选  王小王 String  收款用户真实姓名。(如果check_name设置为FORCE_CHECK，则必填用户真实姓名)
    data.put(&quot;re_user_name&quot;, &quot;xxx&quot;);*/

    // 微信调用接口
    Map&amp;lt;String, String&amp;gt; resultMap = this.transfers(data);

    WXPayUtil.getLogger().info(&quot;wxPay.transfers:&quot; + resultMap);

    return resultMap;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：推荐数据库中对于金额存储为数值单位，以分为单位来存储，1.1元可以储存为101，这样和微信对应，会方便很多。&lt;/p&gt;
&lt;p&gt;对于企业付款查询的接口，这里就不详细描述了，以下为具体的官方文档链接：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=14_3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要的朋友，根据文档进行接口查询即可，非高频接口。&lt;/p&gt;
&lt;h3 id=&quot;企业付款到银行卡&quot;&gt;企业付款到银行卡&lt;/h3&gt;
&lt;p&gt;企业付款到银行卡提供由商户直接付钱至指定银行卡账户的能力，支持平台操作及接口调用两种方式，资金到账速度快，使用及查询方便。主要用来解决合理的商户对用户付款需求，比如：保险理赔、彩票兑换等等。&lt;/p&gt;
&lt;p&gt;开通流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;入驻成为商户：在线提交营业执照、身份证、银行账户等基本信息，快速提交申请；&lt;/li&gt;
&lt;li&gt;超级管理员开通：前往商户平台-产品中心-企业付款到银行卡-申请开通；&lt;/li&gt;
&lt;li&gt;特殊要求：交易资金是即时入账到商户号基本户的商户，需要满足以下要求：需入驻满90天，连续交易30天。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所需资料：开通企业付款到银行卡功能无需提供额外的材料。&lt;br/&gt;费用：此功能需收取手续费，按照单笔金额收取，每笔收取0.1%,最低1元，最高25元。&lt;/p&gt;
&lt;h4 id=&quot;应用场景-1&quot;&gt;应用场景&lt;/h4&gt;
&lt;p&gt;微信支付已上线企业付款至银行卡功能。商户可以将商户号余额付款至指定的收款银行账户。通过指定收款银行账户户名、卡号，以及收款银行信息即可实现付款。&lt;/p&gt;
&lt;p&gt;官方文档地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=24_1&amp;amp;index=1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;功能说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;企业付款至银行卡只支持新资金流类型账户&lt;/li&gt;
&lt;li&gt;目前企业付款到银行卡支持17家银行，更多银行逐步开放中&lt;/li&gt;
&lt;li&gt;付款到账实效为1-3日，最快次日到账&lt;/li&gt;
&lt;li&gt;每笔按付款金额收取手续费，按金额0.1%收取，最低1元，最高25元,如果商户开通了运营账户，手续费和付款的金额都从运营账户出。如果没有开通，则都从基本户出。&lt;/li&gt;
&lt;li&gt;每个商户号每天可以出款100万，单商户给同一银行卡付款每天限额5万&lt;/li&gt;
&lt;li&gt;发票：在账户中心-发票信息页面申请开票的商户会按月收到发票（已申请的无需重复申请）。&lt;br/&gt;企业付款到银行卡发票与交易手续费发票为拆分单独开具。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;需要注意的是，微信支持的银行有限，具体的支持银行见如下链接：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=24_4&amp;amp;index=5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以肯定会出现不支持的银行，小伙伴们在开发的时候，可以在前后端控制用户选择提现银行来解决。&lt;/p&gt;
&lt;p&gt;平台上手动付款流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在产品中心，开通企业付款到个人银行卡功能&lt;/li&gt;
&lt;li&gt;进入交易中心-企业付款到银行卡页面进行付款&lt;/li&gt;
&lt;li&gt;指定收款银行账号、户名、收款方开户行，及付款金额信息，即可实现付款&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;接口链接-1&quot;&gt;接口链接&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;https://api.mch.weixin.qq.com/mmpaysptrans/pay_bank&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;是否需要证书-1&quot;&gt;是否需要证书&lt;/h4&gt;
&lt;p&gt;请求需要双向证书。&lt;/p&gt;
&lt;h4 id=&quot;调用接口-1&quot;&gt;调用接口&lt;/h4&gt;
&lt;p&gt;接口介绍：&lt;br/&gt;用于企业向微信用户银行卡付款&lt;br/&gt;目前支持接口API的方式向指定微信用户的银行卡付款。&lt;/p&gt;
&lt;p&gt;接口调用规则：&lt;br/&gt;◆ 单商户日限额——单日100w&lt;br/&gt;◆ 单次限额——单次5w&lt;br/&gt;◆ 单商户给同一银行卡单日限额——单日5w&lt;/p&gt;
&lt;p&gt;注意：重点来了，首先，收款方银行卡号&lt;code&gt;enc_bank_no&lt;/code&gt;、收款方用户名&lt;code&gt;enc_true_name&lt;/code&gt; 这两个入参是需要 &lt;code&gt;采用标准RSA算法，公钥由微信侧提供&lt;/code&gt; 得到的，所以还需要先拿到这个密钥，下面是官方文档地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://pay.weixin.qq.com/wiki/doc/api/tools/mch_pay.php?chapter=24_7&amp;amp;index=4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上文档详细介绍了如何得到具体的密钥方式，如果有看不明白的小伙伴，可以直接百度 &lt;code&gt;获取RSA加密公钥API&lt;/code&gt;，可以得到很多示例，这里我就不讲了。&lt;/p&gt;
&lt;p&gt;除入参和&lt;code&gt;企业付款到微信用户零钱&lt;/code&gt;有所不一致之外，其他方面都差不多，小伙伴们可以参考上面付款到零钱的接口来实现付款到银行卡接口。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;以上为&lt;code&gt;微信余额提现&lt;/code&gt;相关的解释和源码，小伙伴们一定要注意看看官方文档哦，具体的源码可以看作者的github，里面对每个方法有详细的注释。&lt;/p&gt;
&lt;p&gt;如果小伙伴有遇到解决不了的问题，可以关注作者微信公众号，加入讨论群中发出疑问，和小伙伴们一起解决哦～&lt;/p&gt;
&lt;p&gt;预告：下一篇文章会讲发放奖励的另一种方式 &lt;code&gt;商户平台-现金红包&lt;/code&gt;，敬请期待！！！&lt;/p&gt;
&lt;p&gt;​如果想要提前一览源码的小伙伴，可以先看看我的 github，地址如下：&lt;br/&gt;​&lt;br/&gt;​&lt;code&gt;​https://github.com/YClimb/wxpay-sdk/blob/master/README.md ​&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;关注作者微信公众号，点击下方&lt;code&gt;讨论群&lt;/code&gt;，扫码即可加入&lt;code&gt;微信支付讨论群&lt;/code&gt;与小伙伴一起探讨哦～&lt;/p&gt;
&lt;p&gt;到此本文就结束了，关注公众号查看更多推送！！！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180130111432962?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWUNsaW1i/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;关注我的公众号&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;</description>
<pubDate>Thu, 15 Nov 2018 11:50:00 +0000</pubDate>
<dc:creator>YClimb</dc:creator>
<og:description>本文是【浅析微信支付】系列文章的第十二篇，主要讲解在商户存在的提现、商户付款到微信用户零钱或者银行卡需求。 浅析微信支付系列已经更新十二篇了哟～，没有看过的朋友们可以看一下哦。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yclimb/p/9965698.html</dc:identifier>
</item>
<item>
<title>PHP加密解密 - itbsl</title>
<link>http://www.cnblogs.com/itbsl/p/9965209.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itbsl/p/9965209.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;为了保证网络传输数据的安全性，涉及敏感数据的传输，最好对数据预先加密，然后再在网络上进行传输，同时，还要保证数据在另一端是可解密的，并且还必须要通过钥匙(公钥或私钥)才能解密，没有钥匙(公钥或私钥)的人即使是拿到了加密过的数据也无法解密。&lt;/p&gt;
&lt;h2 id=&quot;对称加密&quot;&gt;对称加密&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在对称加密算法中常用的算法有：&lt;a href=&quot;https://baike.baidu.com/item/DES&quot;&gt;DES&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/3DES&quot;&gt;3DES&lt;/a&gt;、TDEA、&lt;a href=&quot;https://baike.baidu.com/item/Blowfish&quot;&gt;Blowfish&lt;/a&gt;、RC2、RC4、&lt;a href=&quot;https://baike.baidu.com/item/RC5&quot;&gt;RC5&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/IDEA&quot;&gt;IDEA&lt;/a&gt;、SKIPJACK、AES等。&lt;/p&gt;
&lt;h3 id=&quot;aes加密算法&quot;&gt;AES加密算法&lt;/h3&gt;
&lt;p&gt;密码学中的高级加密标准（Advanced Encryption Standard，AES），又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。这个标准用来替代原先的DES，已经被多方分析且广为全世界所使用。2006年，高级加密标准已然成为对称密钥加密中最流行的算法之一。&lt;/p&gt;
&lt;p&gt;PHP的OpenSSL扩展已经实现了AES加密算法，我们可以通过OpenSSL扩展提供的方法实现对数据的加密和解密,PHP在7.2版本已经完全移除了MCrypt加密，PHP手册在7.1迁移页面给出了替代方案,就是用OpenSSL取代MCrypt.&lt;/p&gt;
&lt;h4 id=&quot;php-aes实现&quot;&gt;PHP AES实现&lt;/h4&gt;
&lt;p&gt;PHP实现代码：&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;class AES
{
    //设置AES秘钥
    private static $aes_key = 'bUYJ3nTV6VBasdJF'; //此处填写前后端共同约定的秘钥

    /**
     * 加密
     * @param string $str    要加密的数据
     * @return bool|string   加密后的数据
     */
    static public function encrypt($str) {

        $data = openssl_encrypt($str, 'AES-128-ECB', self::$aes_key, OPENSSL_RAW_DATA);
        $data = base64_encode($data);

        return $data;
    }

    /**
     * 解密
     * @param string $str    要解密的数据
     * @return string        解密后的数据
     */
    static public function decrypt($str) {

        $decrypted = openssl_decrypt(base64_decode($str), 'AES-128-ECB', self::$aes_key, OPENSSL_RAW_DATA);
        return $decrypted;
    }


}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;非对称加密&quot;&gt;非对称加密&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;对称加密算法在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在非对称加密中使用的主要算法有：&lt;a href=&quot;https://baike.baidu.com/item/RSA&quot;&gt;RSA&lt;/a&gt;、&lt;a href=&quot;https://baike.baidu.com/item/Elgamal&quot;&gt;Elgamal&lt;/a&gt;、背包算法、Rabin、D-H、&lt;a href=&quot;https://baike.baidu.com/item/ECC&quot;&gt;ECC&lt;/a&gt;（椭圆曲线加密算法）等。&lt;/p&gt;
&lt;h3 id=&quot;rsa加密算法&quot;&gt;RSA加密算法&lt;/h3&gt;
&lt;p&gt;RSA是目前最有影响力的公钥加密算法，该算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但那时想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥，即公钥，而两个大素数组合成私钥。公钥是可发布的供任何人使用，私钥则为自己所有，供解密之用。&lt;/p&gt;
&lt;p&gt;解密者拥有私钥，并且将由私钥计算生成的公钥发布给加密者。加密都使用公钥进行加密，并将密文发送到解密者，解密者用私钥解密将密文解码为明文。&lt;/p&gt;
&lt;p&gt;以甲要把信息发给乙为例，首先确定角色：甲为加密者，乙为解密者。首先由乙随机确定一个KEY，称之为密匙，将这个KEY始终保存在机器B中而不发出来；然后，由这个 KEY计算出另一个KEY，称之为公匙。这个公钥的特性是几乎不可能通过它自身计算出生成它的私钥。接下来通过网络把这个公钥传给甲，甲收到公钥后，利用公钥对信息加密，并把密文通过网络发送到乙，最后乙利用已知的私钥，就对密文进行解码了。以上就是RSA算法的工作流程。&lt;/p&gt;
&lt;p&gt;算法实现过程为:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;随意选择两个大的质数p和q，p不等于q，计算N=pq。&lt;/li&gt;
&lt;li&gt;根据欧拉函数，不大于N且与N互质的整数個数為(p-1)(q-1)。&lt;/li&gt;
&lt;li&gt;选择一个整数e与(p-1)(q-1)互质，并且e小于(p-1)(q-1)。&lt;/li&gt;
&lt;li&gt;用以下这个公式计算d：d× e ≡ 1 (mod (p-1)(q-1))。&lt;/li&gt;
&lt;li&gt;将p和q的记录销毁。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上内容中，(N,e)是公钥，(N,d)是私钥。&lt;/p&gt;
&lt;h4 id=&quot;生成私钥和公钥&quot;&gt;生成私钥和公钥&lt;/h4&gt;
&lt;p&gt;生成私钥文件:&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;openssl genrsa -out rsa_private_key.pem 1024&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;利用私钥，生成公钥:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过生成的公钥和私钥就可以对数据进行加解密：&lt;/p&gt;
&lt;h4 id=&quot;php-rsa-实现&quot;&gt;PHP RSA 实现&lt;/h4&gt;
&lt;p&gt;PHP实现代码(公钥加密私钥解密)：&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;class RSA
{
    /**
     * @param string $str 要加密的数据
     * @param string $public_key 公钥
     * @return string
     */
    static public function encrypt($str, $public_key) {

        $encrypted = '';
        $pu_key = openssl_pkey_get_public($public_key);
        openssl_public_encrypt($str, $encrypted, $pu_key);//公钥加密

        $encrypted = base64_encode($encrypted);

        return $encrypted;
    }

    /**
     * 解密
     * @param string $str 要解密的数据
     * @param string $private_key 私钥
     * @return string
     */
    static public function decrypt($str, $private_key) {

        $decrypted = '';
        $pi_key =  openssl_pkey_get_private($private_key);
        openssl_private_decrypt(base64_decode($str), $decrypted, $pi_key);//私钥解密

        return $decrypted;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PHP实现代码(私钥加密公钥解密)：&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;class RSA
{
    static public function encrypt($str, private_key) {

        $encrypted = '';
        $pi_key = openssl_pkey_get_private($private_key);
        openssl_private_encrypt($data, $encrypted, $pi_key); //私钥加密
        
        $encrypted = base64_encode($encrypted);
        
        return $encrypted;
    }
    
    static public function decrypt($str, $public_key) {

        $decrypted = '';
        $pu_key = openssl_pkey_get_public($public_key);
        openssl_public_decrypt(base64_decode($str), $decrypted, $pu_key);//公钥解密
        
        return $decrypted;
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 15 Nov 2018 10:06:00 +0000</pubDate>
<dc:creator>itbsl</dc:creator>
<og:description>[TOC] 为了保证网络传输数据的安全性，涉及敏感数据的传输，最好对数据预先加密，然后再在网络上进行传输，同时，还要保证数据在另一端是可解密的，并且还必须要通过钥匙(公钥或私钥)才能解密，没有钥匙(公</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itbsl/p/9965209.html</dc:identifier>
</item>
<item>
<title>python面向对象入门：从代码复用开始 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9965110.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9965110.html</guid>
<description>&lt;p&gt;本文从代码复用的角度一步一步演示如何从python普通代码进化到面向对象，并通过代码去解释一些面向对象的理论。所以，本文前面的内容都是非面向对象的语法实现方式，只有在最结尾才给出了面向对象的简单语法介绍。各位道兄不妨一看，如果留下点笔墨指导，本人感激不尽。&lt;/p&gt;

&lt;h2 id=&quot;最初代码&quot;&gt;最初代码&lt;/h2&gt;
&lt;p&gt;3种动物牛Cow、羊Sheep、马Horse发出的声音各不相同，于是在同一个目录下建立三个模块文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ tree .
.
|-- cow.py
|-- horse.py
`-- sheep.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三个模块文件的内容都只定义了各自的speak()函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cow.py
def speak():
    print(&quot;a cow goes moooo!&quot;)

# sheep.py
def speak():
    print(&quot;a sheep goes baaaah!&quot;)

# horse.py
def speak():
    print(&quot;a horse goes neigh!&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后当前目录下在创建一个程序文件main.py，导入这三个模块文件，分别调用这三种动物的speak()函数，它们将发出不同声音：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# main.py
import cow,sheep,horse

cow.speak()
sheep.speak()
horse.speak()&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;让代码更具共性的两种基本方法&quot;&gt;让代码更具共性的两种基本方法&lt;/h2&gt;
&lt;p&gt;上面的cow.py、sheep.py和horse.py中，都是speak()函数，不同的是函数内容，确切地说是函数内容中print()输出的部分不同，它们输出的结构是&lt;code&gt;a 动物名 goes 叫声!&lt;/code&gt;。于是为了让代码更具共性，或者说复用性更高，可以将各模块文件中的动物名和叫声都变得通用化。&lt;/p&gt;
&lt;p&gt;目前来说，&lt;strong&gt;有两种最基本的方式可以让一段代码变得更共性、共通用化：使用参数或变量、使用额外的辅助函数&lt;/strong&gt;。当然，除此之外还有更多的方法，但目前来说这两种是最基本的，也是最容易理解的。&lt;/p&gt;

&lt;h3 id=&quot;使用参数变量让代码更具共性&quot;&gt;使用参数(变量)让代码更具共性&lt;/h3&gt;
&lt;p&gt;首先让动物名变得共性化。可以让speak()中的动物名使用一个参数来替代。例如名为self的参数变量(之所以使用self，是因为在面向对象中它有特殊含义，后文解释)，于是修改这三个模块文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cow.py
def speak(self):
    print(&quot;a %s goes moooo!&quot; % (self))

# sheep.py
def speak(self):
    print(&quot;a %s goes baaaah!&quot; % (self))

# horse.py
def speak(self):
    print(&quot;a %s goes neigh!&quot; %(self))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它们现在&lt;strong&gt;在动物名上和参数名上已经完全相同&lt;/strong&gt;，需要调用它们时，只需在函数调用处为他们传递不同的动物名即可。例如，在main.py中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import cow,sheep,horse

cow.speak(&quot;cow&quot;)
sheep.speak(&quot;sheep&quot;)
horse.speak(&quot;horse&quot;)&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;使用辅助函数让代码更具共性&quot;&gt;使用辅助函数让代码更具共性&lt;/h3&gt;
&lt;p&gt;除了参数(变量)，还可以定义额外的函数来上面的代码变得更具共性。例如，这三种动物的叫声，可以额外定义一个sound()函数描述它们。于是在前面的基础上继续修改这三个模块文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cow.py
def speak(self):
    print(&quot;a %s goes %s!&quot; % (self,sound()))

def sound():
    return &quot;moooo&quot;

# sheep.py
def speak(self):
    print(&quot;a %s goes %s!&quot; % (self,sound()))

def sound():
    return &quot;baaaah&quot;

# horse.py
def speak(self):
    print(&quot;a %s goes %s!&quot; % (self,sound()))

def sound():
    return &quot;neigh&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在main.py中，仍然可以使用之前的方式对这3个speak()进行调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import cow,sheep,horse

cow.speak(&quot;cow&quot;)
sheep.speak(&quot;sheep&quot;)
horse.speak(&quot;horse&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，这3个模块文件的speak()已经完完全全地共性化了。&lt;/p&gt;

&lt;h2 id=&quot;初步理解类和对象&quot;&gt;初步理解类和对象&lt;/h2&gt;
&lt;p&gt;所谓的类，就像是一个模板；所谓对象，就像是通过模板生成的具体的事物。类一般具有比较大的共性，对象一般是具体的，带有自己的特性。&lt;/p&gt;
&lt;p&gt;类与对象的关系，例如人类和人，鸟类和麻雀，交通工具和自行车。其中人类、鸟类、交通工具类都是一种类型称呼，它们中的任何一种都具有像模板一样的共性。例如人类的共性是能说话、有感情、双脚走路、能思考等等，而根据这个人类模板生成一个人，这个具体的人是人类的实例，是一个人类对象，每一个具体的人都有自己的说话方式、感情模式、性格、走路方式、思考能力等等。&lt;/p&gt;
&lt;p&gt;类与类的关系。有的类的范畴太大，模板太抽象，它们可以稍微细化一点，例如人类可以划分为男性人类和女性人类，交通工具类可以划分为烧油的、电动的、脚踏的。一个大类按照不同的种类划分，可以得到不同标准的小类。无论如何划分，小类总是根据大类的模板生成的，具有大类的共性，又具有自己的个性。&lt;/p&gt;
&lt;p&gt;在面向对象中，小类和大类之间的关系称之为继承，小类称之为子类，大类称之为父类。&lt;/p&gt;
&lt;p&gt;类具有属性，属性一般包括两类：像名词一样的属性，像动词一样的行为。例如，人类有父母(parent)，parent就是名词，人类能吃饭(eat)，eat这种行为就是动词。鸟类能飞(fly)，fly的行为就是动词，鸟类有翅膀(wing)，wing就是名词。对于面向对象来说，名词就是变量，动词行为就是方法(也就是子程序)。通常，变量和方法都成为类的属性。&lt;/p&gt;
&lt;p&gt;当子类继承了父类之后，父类有的属性，子类可以直接拥有。因为子类一般具有自己的个性，所以子类可以定义自己的属性，甚至修改从父类那里继承来的属性。例如，人类中定义的eat属性是一种非常抽象的、共性非常强的动词行为，如果女性人类继承人类，那么女性人类的eat()可以直接使用人类中的eat，也可以定义自己的eat(比如淑女地吃)覆盖从人类那里继承来的eat(没有形容词的吃)，女性人类还可以定义人类中没有定义的跳舞(dance)行为，这是女性人类的特性。子类方法覆盖父类方法，称之为方法的重写(override)，子类定义父类中没有的方法，称为方法的扩展(extend)。&lt;/p&gt;
&lt;p&gt;当通过类构造出对象后，对象是类的实例，是类的具体化，对象将也具备类的属性，且对象的属性都有各自的值。例如，student类具有成绩、班级等属性，对于一个实际的学生A对象来说，他有成绩属性，且这个成绩具有值，比如89分，班级也一样，比如2班，此外，学生B也有自己的成绩和班级以及对应的值。也就是说，根据类模板生成对象后，对象的各个属性都属于自己，不同对象的属性互不影响。&lt;/p&gt;
&lt;p&gt;无论是对象与类还是子类与父类，它们的关系都可以用一种&quot;is a&quot;来描述，例如&quot;自行车 is a 交通工具&quot;(对象与类的关系)、&quot;笔记本 is a 计算机&quot;(子类与父类的关系)。&lt;/p&gt;

&lt;h2 id=&quot;继承&quot;&gt;继承&lt;/h2&gt;
&lt;p&gt;回到上面的3个模块文件。它们具有共性的speak()和sound()，尽管sound()的返回内容各不相同，但至少函数名sound是相同的。&lt;/p&gt;
&lt;p&gt;可以将这3个文件中共性的内容抽取到同一个模块文件中，假设放进animal.py的文件中。animal.py文件的内容为(但这是错误的代码，稍后修改)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def speak(self):
    print(&quot;a %s goes %s!&quot; % (self,sound()))

def sound(): pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后修改cow.py、sheep.py和horse.py，使它们&quot;继承&quot;animal.py。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cow.py
import animal

def sound(): return &quot;moooo&quot;

# sheep.py
import animal

def sound(): return &quot;baaaah&quot;

# horse.py
import animal

def sound(): return &quot;neigh&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，这三个模块文件都没有了speak()，因为它们都借用它们的&quot;父类&quot;animal中的speak()。&lt;/p&gt;
&lt;p&gt;这表示horse、cow和sheep&quot;继承&quot;了animal，前三者为&quot;子类&quot;，后者为&quot;父类&quot;。&lt;/p&gt;
&lt;p&gt;但注意，这里不是真正的继承，因为python不支持非class对象的继承，所以没法通过非面向对象语法演示继承。但至少从代码复用的角度上来说，它和继承的功能是类似的。&lt;/p&gt;
&lt;p&gt;另外注意，前面animal.py文件是错误的，因为它的speak()函数中调用了sound()函数，但sound()函数在animal.py中是一个没任何用处的函数，仅仅只是代表这个animal具有sound()功能(表示类的一个属性)。而我们真正需要的sound()是可以调用cow、horse、sheep中的sound()，而不是animal自身的sound()。&lt;/p&gt;
&lt;p&gt;所以，在没有使用面向对象语法的情况下，改写一下animal.py文件，导入cow、horse、sheep，使得可以在&quot;父类&quot;的speak()中调用各个&quot;子类&quot;的sound()。再次说明，这里只是为了演示，这种编程方式是不规范的，在真正的面向对象语法中根本无需这些操作。&lt;/p&gt;
&lt;p&gt;以下是修改后的animal.py文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import cow,horse,sheep

def speak(self):
    print( &quot;a %s goes %s!&quot; % (self, eval(self + &quot;.sound()&quot;)) )

def sound(): 
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面使用eval函数，因为python不支持普通的变量名作为模块名来调用模块的属性sound()，所以使用eval先解析成cow或horse或sheep，再调用各自的sound()函数。如果不懂eval()的功能，可无视它。只需知道这是为了实现&lt;code&gt;self.sound()&lt;/code&gt;来调用self所对应变量的sound()函数。&lt;/p&gt;
&lt;p&gt;现在，在main.py中，使用下面的代码来调用speak()，得到的结果和前面是一样的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import cow,sheep,horse

cow.animal.speak(&quot;cow&quot;)
sheep.animal.speak(&quot;sheep&quot;)
horse.animal.speak(&quot;horse&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于不是真正的&quot;继承&quot;，所以这里只能通过模块的方式添加一层&lt;code&gt;animal.&lt;/code&gt;来调用speak()。&lt;/p&gt;
&lt;p&gt;虽然上面的代码变得&quot;人不人鬼不鬼&quot;(因为没有使用面向对象的语法)，但面向对象的基本目标达到了：共性的代码全部抽取出去，实现最大程度的代码复用。&lt;/p&gt;

&lt;h2 id=&quot;self是什么&quot;&gt;self是什么&lt;/h2&gt;
&lt;p&gt;在python的面向对象语法中，将会经常看见&lt;code&gt;self&lt;/code&gt;这个字眼。其实不仅python，各种动态类型的、支持面向对象的语言都使用self，例如perl、ruby也是如此。但是，self是约定俗成的词，并非是强制的，可以将self换成其它任何字符，这并不会出现语法错误。&lt;/p&gt;
&lt;p&gt;实际上，对于静态面向对象语言来说，用的更多的可能是this，比如java、c#、c++都使用this来表示实例对象自身。&lt;/p&gt;
&lt;p&gt;那么self到底是什么东西？&lt;/p&gt;
&lt;p&gt;在前文，为了将cow、sheep和horse模块中speak()函数中的动物名称变得共性，添加了一个self参数。之前的那段代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cow.py
def speak(self):
    print(&quot;a %s goes moooo!&quot; % (self))

# sheep.py
def speak(self):
    print(&quot;a %s goes baaaah!&quot; % (self))

# horse.py
def speak(self):
    print(&quot;a %s goes neigh!&quot; %(self))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当调用这三个函数时，分别传递各自的动物名作为参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import cow,sheep,horse

cow.speak(&quot;cow&quot;)
sheep.speak(&quot;sheep&quot;)
horse.speak(&quot;horse&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，对于cow来说，self是名为&quot;cow&quot;的动物，对于sheep来说，self是名为&quot;sheep&quot;的动物，对于horse来说，self是名为&quot;horse&quot;的动物。&lt;/p&gt;
&lt;p&gt;也就是说，self是各种动物对象，cow.speak()时是cow，sheep.speak()时是sheep，horse.speak()时是horse。这里的模块名变量和speak()的参数是一致的，这是我故意设计成这样的，因为面向对象语法中默认的行为和这是完全一样的，仅仅只是因为语法不同而写法不同。&lt;/p&gt;
&lt;p&gt;简而言之，self是各个动物对象自身。&lt;/p&gt;
&lt;p&gt;后来将cow、sheep和horse的speak()函数抽取到了animal中，仍然使用self作为speak()的参数。&lt;/p&gt;
&lt;p&gt;以下是animal.py文件中的speak()函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def speak(self):
    print( &quot;a %s goes %s!&quot; % (self, eval(self + &quot;.sound()&quot;)) )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当使用下面的方式去调用它时：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cow.animal.speak(&quot;cow&quot;)
sheep.animal.speak(&quot;sheep&quot;)
horse.animal.speak(&quot;horse&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;self是cow、是sheep、是horse，而不是animal。前面说了，在真正的面向对象语法中，中间的这一层animal是被省略的，这里之所以加上一层animal，完全是因为python的非面向对象语法中没办法实现继承。&lt;/p&gt;
&lt;p&gt;当真正使用面向对象语法的时候，self将表示实例对象自身。例如student类有name属性，当根据此类创建一个stuA对象，并使用&lt;code&gt;self.name&lt;/code&gt;时，表示&lt;code&gt;stuA.name&lt;/code&gt;，换句话说，self是stuA这个对象自身，&lt;code&gt;self.name&lt;/code&gt;是stuA对象自身的属性name，和另一个学生对象的&lt;code&gt;stuB.name&lt;/code&gt;无关。&lt;/p&gt;

&lt;h2 id=&quot;重写父类方法&quot;&gt;重写父类方法&lt;/h2&gt;
&lt;p&gt;前面的animal.py中定义了一个空代码体的sound()函数，在cow、sheep和horse中定义了属于自己叫声的sound()函数。这其实就是方法的重写(方法就是函数，只是在面向对象中称为方法)：父类定义了某个方法，子类修改和父类同名的方法。&lt;/p&gt;
&lt;p&gt;例如，新添加一个类mouse，重写animal的speak()方法，mouse的speak()方法中会叫两声，而不是其它动物一样只有一声。假设mouse类定义在mouse.py文件中，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import animal

def speak(self):
    animal.speak(self)
    print(sound())

def sound():
    return &quot;jijiji&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里重写了父类animal的speak()，并在mouse.speak()中调用了父类animal.speak()，再次基础上还叫了一声。&lt;/p&gt;
&lt;p&gt;为了让这段代码运行，需要在animal.py中导入mouse，但在真正面向对象语法中是不需要的，原因前面说了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# animal.py
import cow,horse,sheep,mouse

def speak(self):
    print( &quot;a %s goes %s!&quot; % (self, eval(self + &quot;.sound()&quot;)) )

def sound(): 
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在main.py中调用mouse.speak()即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import cow,sheep,horse,mouse

cow.animal.speak(&quot;cow&quot;)
sheep.animal.speak(&quot;sheep&quot;)
horse.animal.speak(&quot;horse&quot;)
mouse.speak(&quot;mouse&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照&quot;里氏替换原则&quot;：&lt;strong&gt;子类重写父类方法时，应该扩展父类的方法行为，而不是直接否定父类的方法代码并修改父类方法的代码&lt;/strong&gt;。这是一种编程原则，并非强制，但是经验所在，我们应当参考甚至尽量遵循这些伟人提出的原则。&lt;/p&gt;
&lt;p&gt;正如上面的mouse，speak()是在父类的speak()上扩展的。如果将mouse.speak()改为如下代码，则不符合里氏替换原则：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import animal

def speak(self):
    print(sound())
    print(sound())

def sound():
    return &quot;jijiji&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并非一定要遵循里氏替换原则，应该根据实际场景去考虑。比如上面的sound()方法，父类的sound()是一个空方法，仅仅只是声明为类的属性而存在。子类可以随意根据自己的类特性去定制sound()。&lt;/p&gt;
&lt;p&gt;再举一个扩展父类方法的例子。在父类中定义了一个clean()方法，用于清理、回收父类的一些信息。子类中也重写一个clean()方法，但这时应当确保子类的clean()中包含了调用父类的clean()方法，再定义属于子类独有的应当清理的一些信息。这就是父类方法的扩展，而不是父类方法的直接否定。因为子类并不知道父类的clean()会清理哪些信息，如果完全略过父类clean()，很可能本该被父类clean()清理的东西，子类没有去清理。&lt;/p&gt;

&lt;h2 id=&quot;真正面向对象的语法&quot;&gt;真正面向对象的语法&lt;/h2&gt;
&lt;p&gt;前面的所有内容都只是为了从代码复用的角度去演示如何从普通编程方式演变成面向对象编程。现在，简单介绍python面向对象编程的语法，实现前文的animal、horse、cow和sheep，由此来和前文的推演做个比较。关于面向对象，更多内容在后面的文章会介绍。&lt;/p&gt;
&lt;p&gt;使用class关键字定义类，就像定义函数一样。这里定义4个类，父类animal，子类cow、sheep、horse，子类继承父类。它们分别保存到animal.py、cow.py、sheep.py和horse.py文件中。&lt;/p&gt;
&lt;p&gt;animal.py文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 定义Animal类
class Animal():
    def speak(self):
        print( &quot;a %s goes %s!&quot; % (self, self.sound()) )
    def sound(self):
        pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;cow.py文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import animal

# 定义Cow类，继承自Animal
class Cow(animal.Animal):
    def sound(self):
        return &quot;moooo&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;sheep.py文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import animal

# 定义Sheep类，继承自Animal
class Sheep(animal.Animal):
    def sound(self):
        return &quot;baaaah&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;horse.py文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import animal

# 定义Horse类，继承自Animal
class Horse(animal.Animal):
    def sound(self):
        return &quot;neigh&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在main.py文件中生成这3个子类的实例，并通过实例对象去调用定义在父类的speak()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import cow,horse,sheep

# 生成这3个子类的实例对象
cowA = cow.Cow()
sheepA = sheep.Sheep()
horseA = horse.Horse()

# 通过实例对象去调用speak()方法
cowA.speak()
sheepA.speak()
horseA.speak()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a &amp;lt;cow.Cow object at 0x03341BD0&amp;gt; goes moooo!
a &amp;lt;sheep.Sheep object at 0x03341BF0&amp;gt; goes baaaah!
a &amp;lt;horse.Horse object at 0x03341F50&amp;gt; goes neigh!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果和想象中不一样，先别管结果。至少如果把&lt;code&gt;&amp;lt;xxx&amp;gt;&lt;/code&gt;换成对应的实例对象名称，就和前文的效果一样了。这个稍后再改。&lt;/p&gt;
&lt;p&gt;先看语法。&lt;/p&gt;
&lt;p&gt;使用class关键字声明类，类名一般首字母大写。如果要继承某个类，在类名的括号中指定即可，例如&lt;code&gt;class Cow(Animal)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因为Cow、Horse、Sheep类继承了Animal类，所以即使这3个子类没有定义speak()方法，也将拥有(继承)父类Animal的speak()方法。&lt;/p&gt;
&lt;p&gt;通过调用类，可以创建这个类的实例对象。例如上面&lt;code&gt;cowA=cow.Cow()&lt;/code&gt;，表示创建一个Cow()的对象，这个对象在内存中，赋值给了cowA变量。也即是说cowA引用了这个对象，是这个对象的唯一标识符。注意，cowA是变量，因为引用对象，所以可以称为对象变量。&lt;/p&gt;
&lt;p&gt;当调用&lt;code&gt;cowA.speak()&lt;/code&gt;时，首先查找speak()方法，因为没有定义在Cow类中，于是查找父类Animal，发现有speak()方法，于是调用父类的speak()方法。调用时，python会自动将cowA这个对象作为speak()的第一个参数，它将传递给Animal类中speak()的self参数，所以此时self表示cowA这个对象，&lt;code&gt;self.sound()&lt;/code&gt;表示&lt;code&gt;cowA.sound()&lt;/code&gt;，由于Cow类中定义了sound()，所以直接调用Cow类的sound()，而不会调用Animal中的sound()。&lt;/p&gt;
&lt;p&gt;和前面的推演代码复用的过程比较一下，不难发现面向对象的语法要轻便很多，它将很多过程自动化了。&lt;/p&gt;
&lt;p&gt;现在还有一个问题，上面的代码输出结果不是我们想要的。见下文。&lt;/p&gt;

&lt;h2 id=&quot;类的属性&quot;&gt;类的属性&lt;/h2&gt;
&lt;p&gt;为了让speak()输出对象名(如对象变量名cowA)，这并非一件简单的事。&lt;/p&gt;
&lt;p&gt;在python中，变量都是保存对象的，变量和数据对象之间是相互映射的，只要引用变量就会得到它的映射目标。如果这个对象具有&lt;code&gt;__name__&lt;/code&gt;属性，则直接引用该属性即可获取该变量的名称，很简单。&lt;/p&gt;
&lt;p&gt;但是很多对象并没有&lt;code&gt;__name__&lt;/code&gt;属性，比如自定义的类的对象实例，这时想要获取类的对象变量名，实非易事。有两个内置函数可以考虑：globals()函数和locals()函数，它们返回当前的全局变量和本地变量的字典。遍历它们并对字典的value和给定变量进行比较，即可获取想要的变量名key。&lt;/p&gt;
&lt;p&gt;但如果跨文件了，例如Animal类在一个文件，Cow类在一个文件，创建对象的代码又在另一个文件，它们的作用域都是各自独立的，想要在Animal类的方法speak()中获取Cow类的对象变量名cowA，python应该是没办法实现的(perl支持，且实现非常简单)。&lt;/p&gt;
&lt;p&gt;所以，只能使用另一种标识对象的方法：为类添加属性，例如name属性，然后在speak()中引用对象的这个name属性即可。&lt;/p&gt;
&lt;p&gt;修改animal.py文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Animal():
    def speak(self,name):
        self.name = name
        print( &quot;a %s goes %s!&quot; % (self.name, self.sound()) )
    def sound(self):
        pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，在main.py中调用speak()的时候，传递name参数即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import cow,horse,sheep

# 生成这3个子类的实例对象
cowA = cow.Cow()
sheepA = sheep.Sheep()
horseA = horse.Horse()

# 通过实例对象去调用speak()方法
cowA.speak(&quot;cowA&quot;)
sheepA.speak(&quot;sheepA&quot;)
horseA.speak(&quot;horseA&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a cowA goes moooo!
a sheepA goes baaaah!
a horseA goes neigh!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这正是期待的结果。&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 09:54:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>本文从代码复用的角度一步一步演示如何从python普通代码进化到面向对象，并通过代码去解释一些面向对象的理论。所以，本文前面的内容都是非面向对象的语法实现方式，只有在最结尾才给出了面向对象的简单语法介</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9965110.html</dc:identifier>
</item>
<item>
<title>机器学习经典模型简单使用及归一化（标准化）影响 - iTryagain</title>
<link>http://www.cnblogs.com/csu-lmw/p/9964855.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csu-lmw/p/9964855.html</guid>
<description>&lt;p&gt;俗话说的好，不动手就永远不知道该怎么做，上次一听说要做这个的时候人都懵了，听了几次似乎都摸不到门道，这次花了几天时间去写了写，总算是摸到了点门道。&lt;/p&gt;

&lt;h2&gt;数据集&lt;/h2&gt;
&lt;p&gt;这次用到的数据集是跟火电厂有关的，都是匿名特征，数据量为20160*170，做到最后发现只根据时间顺序就能做的比较好。&lt;/p&gt;
&lt;h2&gt;归一化&lt;/h2&gt;
&lt;p&gt;先来讲讲归一化。归一化也称标准化，是数据挖掘的一项基础工作,使用归一化的原因大体如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据存在不同的评价指标，&lt;strong&gt;其量纲或量纲单位不同&lt;/strong&gt;，处于不同的数量级。解决特征指标之间的可比性，经过归一化处理后，各指标处于同一数量级，便于综合对比。&lt;/li&gt;
&lt;li&gt;求最优解的过程会变得平缓，更容易正确收敛。即能提高梯度下降求最优解时的速度。&lt;/li&gt;
&lt;li&gt;提高计算精度。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;MinMaxScaler&lt;/h3&gt;
&lt;p&gt;线性归一化，也称为离差标准化，是对原始数据的线性变换，min-max标准化方法的缺陷在当有新数据加入时，可能会导致X.max和X.min的值发生变化，需要重新计算。其转换函数如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20171013084706198&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;StandardScaler&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;标准差归一化&lt;/strong&gt;，也叫Z-score标准化，这种方法给予原始数据的均值（mean，μ）和标准差（standard deviation，σ）进行数据的标准化。经过处理后的数据符合标准正态分布，即均值为0，标准差为1，转化函数为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20171013085253015&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;MaxAbsScaler&lt;/h3&gt;
&lt;p&gt;原理与MinMaxScaler很像，只是数据会被规模化到[-1,1]之间。也就是特征中，所有数据都会除以最大值。这个方法对那些已经中心化均值维0或者稀疏的数据有意义。&lt;/p&gt;
&lt;h2&gt;模型&lt;/h2&gt;
&lt;p&gt;本次实验使用了5个模型，分别为Lasso、Redige、SVR、RandomForest、XGBoost。&lt;/p&gt;
&lt;h2&gt;实验方式&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;以不同方式划分数据集和测试集&lt;/li&gt;
&lt;li&gt;使用不同的归一化（标准化）方式&lt;/li&gt;
&lt;li&gt;使用不同的模型&lt;/li&gt;
&lt;li&gt;通过比较MSE（均方误差，mean-square error）的大小来得出结论&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;部分代码及结果&lt;/h3&gt;
&lt;p&gt;数据预处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;按时间排序&lt;/span&gt;
sort_data = data.sort_values(by = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,ascending =&lt;span&gt; True)
sort_data.reset_index(inplace &lt;/span&gt;= True,drop =&lt;span&gt; True)
target &lt;/span&gt;= data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;T1AOMW_AV&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
sort_target &lt;/span&gt;= sort_data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;T1AOMW_AV&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;del&lt;/span&gt; data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;T1AOMW_AV&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;del&lt;/span&gt; sort_data[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;T1AOMW_AV&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.model_selection &lt;span&gt;import&lt;/span&gt;&lt;span&gt; train_test_split
test_sort_data &lt;/span&gt;= sort_data[16160&lt;span&gt;:]
test_sort_target &lt;/span&gt;= sort_target[16160&lt;span&gt;:]

_sort_data &lt;/span&gt;= sort_data[:16160&lt;span&gt;]
_sort_target &lt;/span&gt;= sort_target[:16160&lt;span&gt;]
sort_data1 &lt;/span&gt;= _sort_data[:(int)(len(_sort_data)*0.75&lt;span&gt;)]
sort_data2 &lt;/span&gt;= _sort_data[(int)(len(_sort_data)*0.75&lt;span&gt;):]
sort_target1 &lt;/span&gt;= _sort_target[:(int)(len(_sort_target)*0.75&lt;span&gt;)]
sort_target2 &lt;/span&gt;= _sort_target[(int)(len(_sort_target)*0.75&lt;span&gt;):]

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; scipy.stats as stats
dict_corr &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;spearman&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; : [],
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pearson&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; : [],
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kendall&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; : [],
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; : []
}

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data.columns:
    corr_pear,pval &lt;/span&gt;=&lt;span&gt; stats.pearsonr(sort_data[i],sort_target)
    corr_spear,pval &lt;/span&gt;=&lt;span&gt; stats.spearmanr(sort_data[i],sort_target)
    corr_kendall,pval &lt;/span&gt;=&lt;span&gt; stats.kendalltau(sort_data[i],sort_target)
    
    dict_corr[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pearson&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(abs(corr_pear))
    dict_corr[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;spearman&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(abs(corr_spear))
    dict_corr[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kendall&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(abs(corr_kendall))
    
    dict_corr[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(i)
    
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 筛选新属性  &lt;/span&gt;
dict_corr =&lt;span&gt;pd.DataFrame(dict_corr)
new_fea &lt;/span&gt;= list(dict_corr[(dict_corr[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pearson&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]&amp;gt;0.41) &amp;amp; (dict_corr[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;spearman&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]&amp;gt;0.45) &amp;amp; (dict_corr[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kendall&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]&amp;gt;0.29)][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;columns&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].values)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选取原则，选取25%分位数 以上的相关性系数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模型测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; sklearn.linear_model &lt;span&gt;import&lt;/span&gt;&lt;span&gt; LinearRegression,Lasso,Ridge
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.preprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MinMaxScaler,StandardScaler,MaxAbsScaler
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; mean_squared_error as mse
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.svm &lt;span&gt;import&lt;/span&gt;&lt;span&gt; SVR
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.ensemble &lt;span&gt;import&lt;/span&gt;&lt;span&gt; RandomForestRegressor
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xgboost as xgb
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;最大最小归一化&lt;/span&gt;
mm =&lt;span&gt; MinMaxScaler()

lr &lt;/span&gt;= Lasso(alpha=0.5&lt;span&gt;)
lr.fit(mm.fit_transform(sort_data1[new_fea]), sort_target1)
lr_ans &lt;/span&gt;=&lt;span&gt; lr.predict(mm.transform(sort_data2[new_fea]))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lr:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,mse(lr_ans,sort_target2))

ridge &lt;/span&gt;= Ridge(alpha=0.5&lt;span&gt;)
ridge.fit(mm.fit_transform(sort_data1[new_fea]),sort_target1)
ridge_ans &lt;/span&gt;=&lt;span&gt; ridge.predict(mm.transform(sort_data2[new_fea]))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ridge:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,mse(ridge_ans,sort_target2))

svr &lt;/span&gt;= SVR(kernel=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,C=100,epsilon=0.1&lt;span&gt;).fit(mm.fit_transform(sort_data1[new_fea]),sort_target1)
svr_ans &lt;/span&gt;=&lt;span&gt; svr.predict(mm.transform(sort_data2[new_fea]))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;svr:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,mse(svr_ans,sort_target2))

estimator_RF &lt;/span&gt;=&lt;span&gt; RandomForestRegressor().fit(mm.fit_transform(sort_data1[new_fea]),sort_target1)
predict_RF &lt;/span&gt;=&lt;span&gt; estimator_RF.predict(mm.transform(sort_data2[new_fea]))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;RF:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,mse(predict_RF,sort_target2))

bst &lt;/span&gt;= xgb.XGBRegressor(learning_rate=0.1, n_estimators=550, max_depth=4, min_child_weight=5, seed=&lt;span&gt;0,subsample&lt;/span&gt;=0.7, colsample_bytree=0.7, gamma=0.1, reg_alpha=1, reg_lambda=1&lt;span&gt;)
bst.fit(mm.fit_transform(sort_data1[new_fea]),sort_target1)
bst_ans &lt;/span&gt;=&lt;span&gt; bst.predict(mm.transform(sort_data2[new_fea]))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bst:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,mse(bst_ans,sort_target2))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
lr: 7.736200563088036&lt;span&gt;
ridge: &lt;/span&gt;3.264150764935616&lt;span&gt;
svr: &lt;/span&gt;3.505799850945091&lt;span&gt;
RF: &lt;/span&gt;0.24087179220636037&lt;span&gt;
bst: &lt;/span&gt;0.9945862722591914
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的这段代码测试的是最大最小归一化情况下的结果，测试其他标准化时只需要改动mm = &lt;span data-mce-=&quot;&quot;&gt;MinMaxScaler()，这段代码即可。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span data-mce-=&quot;&quot;&gt;实验结果及原因分析&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;经过多次测试，统计结果如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413964/201811/1413964-20181115171148887-1878773092.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过对比，可以发现，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于Lasso模型，使用MaxAbsScaler方式时，MSE增大十分明显，且归一化后结果高于不进行归一化时（可能是数据的问题），&lt;/li&gt;
&lt;li&gt;对于Redige模型，归一化结果也明显高于不归一化时的结果。&lt;/li&gt;
&lt;li&gt;对于SVR模型，不进行归一化时，其MSE会非常大，是因为svm实质上选择的是分割两类数据最远的超平面，由于错分类造成了影响，不进行归一化会造成对平面的影响，导致得到的划分平面不准确测试集成功率低。&lt;/li&gt;
&lt;li&gt;对于RandomForest和XGBoost来说，是否进行归一化对结果影响不大。&lt;span&gt;&lt;strong&gt;这也是树模型的一大特征。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Thu, 15 Nov 2018 09:32:00 +0000</pubDate>
<dc:creator>iTryagain</dc:creator>
<og:description>俗话说的好，不动手就永远不知道该怎么做，上次一听说要做这个的时候人都懵了，听了几次似乎都摸不到门道，这次花了几天时间去写了写，总算是摸到了点门道。 实验 数据集 这次用到的数据集是跟火电厂有关的，都是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/csu-lmw/p/9964855.html</dc:identifier>
</item>
<item>
<title>vue.js的项目实战 - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/9964905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/9964905.html</guid>
<description>&lt;p&gt;&lt;strong&gt;欢迎大家前往&lt;a href=&quot;https://cloud.tencent.com/developer/?fromSource=waitui&quot;&gt;腾讯云+社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.093023255814&quot;&gt;
&lt;p&gt;本文由&lt;a href=&quot;https://cloud.tencent.com/developer/user/531268&quot;&gt;蔡述雄&lt;/a&gt;发表于&lt;a href=&quot;https://cloud.tencent.com/developer/column/1930?fromSource=waitui&quot;&gt;云+社区专栏&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;需求背景&quot;&gt;需求背景&lt;/h2&gt;
&lt;p&gt;组件库是做UI和前端日常需求中经常用到的，把一个按钮，导航，列表之类的元素封装起来，方便日常使用，调用方法只需直接写上或者这样的代码就可以，是不是很方便呢，接下来我们将要完成以下页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1490871464533_919_1490871464762.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是我们组件库的首页，包含三个子页面，按钮页面、列表页面、导航页面；点击进去子页面会由路由来配置。先看我们的目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1490871479139_3267_1490871479277.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;pages目录存放我们的页面，包括首页和三个子页面；components目录存放我们的具体组件，包括按钮组件，箭头组件，列表组件和导航组件（组件和页面其实是一样的文件类型，只是由于功能不一样，我们就叫不同的称呼）&lt;/p&gt;
&lt;p&gt;先看路由配置的代码吧！&lt;/p&gt;
&lt;h2 id=&quot;路由配置&quot;&gt;路由配置&lt;/h2&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import Vue from 'vue'
import Router from 'vue-router'
// 引用页面模板-&amp;gt;供路由使用
import index from '../pages/index.vue'
import pageQuiButton from '../pages/pageQuiButton.vue'
import pageQuiList from '../pages/pageQuiList.vue'
import pageQuiNav from '../pages/pageQuiNav.vue'

Vue.use(Router)

export default new Router({
  routes: [
    {
      path: '/',
      name: 'index',
      component: index
    },
    {
      path: '/btn',
      name: 'btn',
      component: pageQuiButton
    },
    {
      path: '/list',
      name: 'list',
      component: pageQuiList
    },
    {
      path: '/nav',
      name: 'nav',
      component: pageQuiNav
    }
  ]
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了上一篇的分析之后，这里应该很容易看出来几个路由地址&lt;/p&gt;
&lt;p&gt;首页：&lt;code&gt;http://localhost:8080/#/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按钮子页：&lt;code&gt;http://localhost:8080/#/btn&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;列表子页：&lt;code&gt;http://localhost:8080/#/list&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;导航子页：&lt;code&gt;http://localhost:8080/#/nav&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;具体每一页的内容分别对应每一页的.vue文件，不知大家是否还记得入口页&lt;code&gt;App.vue&lt;/code&gt;，这个文件承载着一些公用的元素，还有就是一个路由容器，我们的首页&lt;code&gt;index.vue&lt;/code&gt;到时候也是挂载在路由容器中的，看看&lt;code&gt;App.vue&lt;/code&gt;的代码&lt;/p&gt;
&lt;h2 id=&quot;入口页app.vue&quot;&gt;入口页App.vue&lt;/h2&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;app&quot;&amp;gt;
    &amp;lt;h1 class=&quot;page-title&quot;&amp;gt;&amp;lt;a href=&quot;#/&quot;&amp;gt;开发组件库&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt;
    &amp;lt;router-view&amp;gt;&amp;lt;/router-view&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  export default {
    name: 'app'
}
&amp;lt;/script&amp;gt;

&amp;lt;style scoped&amp;gt;
  @import './assets/css/App.css';
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单分析一下入口页的代码，&lt;strong&gt;h1标签是一个公用元素&lt;/strong&gt;，也就是说到时候每个子页面都会带着这个h1，他的作用就是方便我们快速回到首页，子页面的内容会注入到&lt;code&gt;router-view&lt;/code&gt;中。这里值得关注的地方是style标签，我们可以在style标签里面直接写样式，也可以&lt;strong&gt;直接引入一个样式文件，scoped关键字表示这个样式是私有的&lt;/strong&gt;，也就是说，即使两个组件写着一样的&lt;code&gt;#app{}&lt;/code&gt;样式也不会冲突，程序会加上&lt;strong&gt;命名空间&lt;/strong&gt;，这也就是为什么在script标签中有个name参数。&lt;/p&gt;
&lt;h2 id=&quot;首页index.vue&quot;&gt;首页index.vue&lt;/h2&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;mod-module mod-parallel&quot;&amp;gt;
    &amp;lt;div class=&quot;img-list type-full&quot;&amp;gt;
      &amp;lt;div class=&quot;img-box&quot;&amp;gt;
        &amp;lt;p class=&quot;img-item&quot;&amp;gt;
          &amp;lt;a class=&quot;page-link&quot; href=&quot;#/btn&quot;&amp;gt;按钮&amp;lt;/a&amp;gt;
        &amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;img-box&quot;&amp;gt;
        &amp;lt;p class=&quot;img-item&quot;&amp;gt;
          &amp;lt;a class=&quot;page-link&quot; href=&quot;#/list&quot;&amp;gt;列表&amp;lt;/a&amp;gt;
        &amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;img-box&quot;&amp;gt;
        &amp;lt;p class=&quot;img-item&quot;&amp;gt;
          &amp;lt;a class=&quot;page-link&quot; href=&quot;#/nav&quot;&amp;gt;导航&amp;lt;/a&amp;gt;
        &amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style scoped&amp;gt;
 @import './css/index.css';
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首页的代码也是非常简单，和我们平时写html差不多，就是几个跳转链接跳到对应的子页面，程序运行的时候，会将&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;标签里面的内容都注入到App.vue页面中的&lt;code&gt;router-view&lt;/code&gt;标签中，从而实现无刷新的路由跳转。&lt;/p&gt;
&lt;p&gt;从下面的内容开始，我们的知识将会深入一些。我们先不急着看其他几个子页面，因为子页面里面只是引用对应的组件，所以我们先从组件开始入手。&lt;/p&gt;
&lt;h2 id=&quot;按钮组件quibutton.vue&quot;&gt;按钮组件quiButton.vue&lt;/h2&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;button class=&quot;qui-btn&quot;&amp;gt;
    &amp;lt;span&amp;gt;{{msg}}&amp;lt;/span&amp;gt;
  &amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  export default {
        data:function(){
            return {
                msg:'下载'
            }
        }
  }
&amp;lt;/script&amp;gt;
&amp;lt;style scoped&amp;gt;
  @import './css/reset.import.css';
  @import './css/qui-btn.import.css';
&amp;lt;/style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按钮组件很简单，就是一个正常的button标签，script标签中暴露这个组件的data属性（data是Vue的属性值，不是乱写的~~）。当按钮组件被初始化的时候，&lt;strong&gt;msg自定义属性会被绑定到&lt;span&gt;标签中的{{msg}}中&lt;/span&gt;&lt;/strong&gt;，两个花括号用来绑定属性，这种写法学过模版化前端代码的人应该都比较熟悉。这里需要注意一个地方，&lt;strong&gt;如果不是组件的话，正常data的写法可以直接写一个对象，比如data：{ msg ： ' 下载 ' }，但由于组件是会在多个地方引用的，JS中直接共享对象会造成引用传递，也就是说修改了msg后所有按钮的msg都会跟着修改，所以这里用function来每次返回一个对象实例。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这就是一个非常简单的按钮组件，结构、样式+文案。&lt;/p&gt;
&lt;p&gt;这时候问题来了，按钮中的文案我希望可以异化，不能每次都初始化一个叫做“下载”文案的按钮吧，希望可以以属性的方式来使用，比如这样子写就可以改变我们的按钮文案：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;qui-btn msg=&quot;确定&quot; class=&quot;small&quot;&amp;gt;&amp;lt;/qui-btn&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没问题，属性的接口暴露只需要写在prosp里面就可以了，如下所示修改下script标签的内容：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;script&amp;gt;
  export default {
    props: {
      msg: {
        default: '下载'
      }
    }
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把属性写在props里面，就可以暴露给其他页面调用了，在组件中，&lt;strong&gt;props是专门用来暴露组件的属性接口的&lt;/strong&gt;，这里给了一个默认值&lt;code&gt;‘下载’&lt;/code&gt;，后面我们要使用的话，只需要&lt;code&gt;&amp;lt;btn msg=&quot;确认&quot;&amp;gt;&amp;lt;/btn&amp;gt;&lt;/code&gt; 就可以修改按钮的默认文案了。&lt;/p&gt;
&lt;p&gt;我们在上一篇文章的开头就讲了Vue是数据驱动模式的，当我在btn结构写上&lt;code&gt;msg=&quot;确认&quot;&lt;/code&gt;的时候，对应script里面的msg属性就会自动修改了。&lt;/p&gt;
&lt;h2 id=&quot;按钮事件&quot;&gt;按钮事件&lt;/h2&gt;
&lt;p&gt;按钮总少不了点击事件吧，那在Vue中怎么绑定事件呢，用methods属性，看下代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;button class=&quot;qui-btn&quot; v-on:click=&quot;btnClickEvent&quot;&amp;gt;
    &amp;lt;span&amp;gt;{{msg}}&amp;lt;/span&amp;gt;
  &amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  export default {
    props: {
      msg: {
        default: '下载'
      }
    },
    methods: {    //绑定事件的关键代码
      btnClickEvent: function(){
        alert(this.msg);
      }
    }
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;methods属性中可以写任何的自定义函数，写完之后绑定的方式也很简单，在button上写关键字&lt;code&gt;v-on:click&lt;/code&gt;，把对应的事件写上就可以了，以上代码实现的就是点击按钮弹出按钮中的文案，&lt;code&gt;v-XXX&lt;/code&gt;是Vue里的一些关键字，叫做指令，我们后面会慢慢学到更多的指令；&lt;code&gt;v-on:click&lt;/code&gt;可以缩写为&lt;code&gt;@click&lt;/code&gt;，当然还有其他的事件比如&lt;code&gt;v-on:tab&lt;/code&gt;等等；&lt;/p&gt;
&lt;h2 id=&quot;使用按钮组件pagequibutton.vue&quot;&gt;使用按钮组件pageQuiButton.vue&lt;/h2&gt;
&lt;p&gt;现在我们大致做了一个按钮组件了，那么怎么调用它呢，去到我们的pageQuiButton子页面。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//pageQuiButton.vue
&amp;lt;template&amp;gt;
  &amp;lt;div id=&quot;pageQuiButton&quot;&amp;gt;
    &amp;lt;!--使用--&amp;gt;
    &amp;lt;qui-btn msg=&quot;确定&quot; class=&quot;small&quot;&amp;gt;&amp;lt;/qui-btn&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  import quiBtn from '../components/quiButton.vue' /*引用*/
  export default {
    name: 'pageQuiButton',
    components: {
      'qui-btn': quiBtn /*注册自定义标签*/
    }
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从script开始解析，首先引入我们的组件赋值给变量quiBtn，使用时候直接将quiBtn作为对象的一部分写进&lt;strong&gt;components属性&lt;/strong&gt;，这是Vue用来存储引用组件的关键字，同时对应我们自定义的标签 &lt;code&gt;&quot;qui-btn&quot;&lt;/code&gt;，完成这些操作之后，我们就可以在template中使用自定义的按钮组件&lt;code&gt;&amp;lt;qui-btn&amp;gt;&lt;/code&gt;上面也说了用msg属性来自定义按钮的文案。完成之后，我们就可以在页面中看到具体效果，点击按钮弹出对应的文案。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1490872991423_9914_1490872991543.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述我们将按钮事件写成默认的&lt;code&gt;alert(this.msg)&lt;/code&gt;，如果有些按钮想要异化怎么办。之前说了msg属性可以支持自定义，那么按钮的点击事件如何支持自定义呢？&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//pageQuiButton.vue
//监听子组件的事件
&amp;lt;qui-btn v-on:btnClickEvent=&quot;doSth&quot; msg=&quot;我可以点击&quot; &amp;gt;&amp;lt;/qui-btn&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码在引用组件的时候，注册了一个事件，这个btnClickEvent事件是之前我们在按钮组件中绑定到按钮的click事件中的，然后我们给这个事件一个自定义的方法doSth，同时，在script中声明这个自定义的方法如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//pageQuiButton.vue
//页面中引用子组件并监听子组件的事件
&amp;lt;script&amp;gt;
  import quiBtn from '../components/quiButton.vue'
  export default {
    name: 'pageQuiButton',
    components: {
      'qui-btn': quiBtn
    },
    methods: {
      doSth: function(){
        alert('你点击了组件的click:btnClickEvent');
      }
    }
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;专业一点的说，这种做法叫做监听，由引用方（暂且叫做父组件）监听子组件的内置方法；同时在子组件中，需要触发这个事件，以下是在子组件中的关键代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//quiButton.vue
//子组件中的代码
&amp;lt;script&amp;gt;
  export default {
    props: {
      msg: {
        default: '下载'
      }
    },
    methods: {
      btnClickEvent: function(){
        alert(&quot;先弹出默认的文案&quot;);
        this.$emit('btnClickEvent');//关键代码父组件触发自定义事件
      }
    }
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的关键代码就是&lt;code&gt;$emit&lt;/code&gt;，也叫触发机制，父组件监听，子组件触发。如果觉得绕，以下描述可能会比较好理解：&lt;strong&gt;小B（子组件）有一个电话号码（子组件注册的事件），有一天小B把电话号码告诉了小A（父组件），让小A打电话给他，于是小A就拨打了小B的电话号码（监听），这时候整个沟通流程没有结束，必须要小B接听了电话（触发），两人之间才算完成了打电话这件事情。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;完成这步之后，引用方（父组件）就可以给不同子组件调用不同的事件处理了：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;qui-btn v-on:btnClickEvent=&quot;doSth1&quot; msg=&quot;确定&quot; &amp;gt;&amp;lt;/qui-btn&amp;gt;
&amp;lt;qui-btn v-on:btnClickEvent=&quot;doSth2&quot; msg=&quot;取消&quot; &amp;gt;&amp;lt;/qui-btn&amp;gt;
&amp;lt;script&amp;gt;
/*这里只是简单展示*/
    methods: {
      doSth1: function(){
        alert('111');
      },
      doSth2: function(){
        alert('222');
      }
    }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;给按钮加图标&quot;&gt;给按钮加图标&lt;/h2&gt;
&lt;p&gt;有时候单纯的文案异化还不够，比如一些按钮是图标+文字类型的，而且图标还可能不一样，那应该怎么办呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1490873116729_7495_1490873116848.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果按钮组件的结构除了开发时候预设的那些dom结构之外，允许我们在调用的时候添加一些自己想要的结构，那是不是解决了呢，是的，Vue早就为我们考虑了这一点，他就是slot标签。&lt;/p&gt;
&lt;p&gt;下面给我们的按钮组件加上一段结构&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//quiButton.vue
&amp;lt;template&amp;gt;
  &amp;lt;button class=&quot;qui-btn&quot; v-on:click=&quot;btnClickEvent&quot;&amp;gt;
    &amp;lt;slot name=&quot;icon&quot;&amp;gt;&amp;lt;/slot&amp;gt;&amp;lt;!--重点在这里--&amp;gt;
    &amp;lt;span&amp;gt;{{msg}}&amp;lt;/span&amp;gt;
  &amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加入了关键字slot并赋予一个name值之后，我们再看看引用如何使用&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//pageQuiButton.vue
&amp;lt;qui-btn msg=&quot;下载&quot; class=&quot;with-icon&quot;&amp;gt;
  &amp;lt;img slot=&quot;icon&quot; class=&quot;ico&quot; src=&quot;xxx.png&quot; /&amp;gt;
&amp;lt;/qui-btn&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;img上有个关键字&lt;code&gt;slot=&quot;icon&quot;&lt;/code&gt;对应组件中的&lt;code&gt;name=&quot;icon&quot;&lt;/code&gt;，渲染的时候，会将img整个替换掉组件中的对应name的&lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt;标签，其实很好理解，slot的翻译是插槽的意思，相当于把img这块内容插到一个名叫icon的插槽里面去。&lt;/p&gt;
&lt;h2 id=&quot;中场休息一下&quot;&gt;中场休息一下&lt;/h2&gt;
&lt;p&gt;学到这里，我们已经学会了用props给按钮自定义文案，用on和emit给按钮自定义点击触发，用slot给按钮添加一些自定义结构。&lt;strong&gt;当你回头去翻文档的时候，你会发现props，事件，slot这三样刚好就是学习组件通讯中最最最关键的三个环节。将这三个环节以实际案例解析出来后，好像也没有那么难了吧~！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述我们已经讨论了如何制作一个按钮组件，以及如何使用我们的按钮组件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1490873224108_8909_1490873224225.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们通过制作一个导航组件，来了解Vue中对于for循环的巧妙使用。&lt;/p&gt;
&lt;h2 id=&quot;导航组件quinav.vue&quot;&gt;导航组件quiNav.vue&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://blog-10039692.file.myqcloud.com/1490873272900_1173_1490873273020.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们将完成这样一个导航组件，点击导航中的tab，可以给当前tab加上一个active类，同时切换底部的黄色滑条，并且输出当前tab的文案，同时支持自定义事件。&lt;/p&gt;
&lt;p&gt;由于在现实项目中，我们导航的tab个数是不定的，所以制作组件的时候，我们希望可以暴露一个属性来支持导航的tab个数，而tab的长相和应用其实是一样的，那么这时候我们可以用一个for循环来输出每一个tab。先看看关键代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//quiNav.vue
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;qui-nav nav-type-1&quot;&amp;gt;
    &amp;lt;a v-for=&quot;(item, index) in items&quot; &amp;gt;&amp;lt;!--关键代码v-for--&amp;gt;
      &amp;lt;span class=&quot;nav-txt&quot;&amp;gt;{{item.text}}&amp;lt;/span&amp;gt;
    &amp;lt;/a&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  export default {
    data:function(){
      return {
        items:[
          {
            text: '首页',
            active : true
          },
          {
            text: '列表',
            active : false
          },
          {
            text: '关于',
            active : false
          },
          {
            text: '招聘',
            active : false
          }
        ]
      }
    }
    }
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该段代码的关键地方在于a标签上&lt;code&gt;v-for&lt;/code&gt;关键字（还记得我们在前面说过的v-on绑定事件吗，v-XXX关键字是Vue预留的）可以把它理解为js中的for in 循环，items是我们在data里面定义的对象（还记得为什么data要写在function中返回吗？）。&lt;code&gt;v-for=&quot;(item,index) in items&quot;&lt;/code&gt;暴露了item和index两个接口，这是Vue提供的，代表items中的每一项以及该项对应的下标，接着我们就可以在标签中使用绑定&lt;code&gt;｛｛item.text｝｝&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;这段代码理解了之后，我们再延伸一个动态添加class的概念。我们希望每个tab都有默认的class类名(比如&lt;code&gt;nav-item&lt;/code&gt;类)，在点击每个tab的时候，当前tab添加active类，其他的tab删除这个active类。在Vue怎么实现呢？&lt;/p&gt;
&lt;h2 id=&quot;动态类名&quot;&gt;动态类名&lt;/h2&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//quiNav.vue
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;qui-nav nav-type-1&quot;&amp;gt;
    &amp;lt;a v-for=&quot;(item, index) in items&quot; :class=&quot;[commonClass,item.active ? activeClass : '']&quot; &amp;gt;
      &amp;lt;span class=&quot;nav-txt&quot;&amp;gt;{{item.text}}&amp;lt;/span&amp;gt;
    &amp;lt;/a&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  export default {
    data:function(){
      return {
        commonClass:'nav-item',
        activeClass:'active',
        items:[
            ...//数据
        ]
      }
    }
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在template中添加了一句关键代码&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;:class=&quot;[commonClass,item.active ? activeClass : '']&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;:class&lt;/code&gt;给组件绑定一个class属性（类似jQuery中的attr方法），这里的写法是缩写，他的全拼应该是v-bind:（又一个v-XXX写法）。注意到最前面有个冒号，&lt;code&gt;：class=XXX&lt;/code&gt;和&lt;code&gt;class=XXX&lt;/code&gt;的区别在于不带冒号的是静态的字符串绑定，带冒号的是动态的变量绑定。我们给class绑定了一个数组，这个数组带有变量，先看commonClass，这个变量在data中定义了，然后数组的第二个元素是一个JS的三元运算符：&lt;code&gt;item.active?activeClass:''&lt;/code&gt;，当每个item中的active值为true时，绑定activeClass变量对应的类，如果为false，则为空。最后的结果是当item.active为true时候，tab的class值为&lt;code&gt;'nav-item active'&lt;/code&gt;，当为false，就只有&lt;code&gt;'nav-item'&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;上面的代码可以理解的话，那么我们切换tab的active类，就转换为修改每个item里面的active的值（再次体现数据驱动）。&lt;/p&gt;
&lt;p&gt;那么问题来了，怎么去修改每个item里面的active值呢？没错，给每个tab绑定一个点击事件，当点击事件触发的时候，修改当前tab对应item的active值。于是代码变成了如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;qui-nav nav-type-1&quot;&amp;gt;
    &amp;lt;a v-for=&quot;(item, index) in items&quot; :class=&quot;[commonClass,item.active ? activeClass : '']&quot; v-on:click=&quot;navClickEvent(items,index)&quot; &amp;gt;
      &amp;lt;span class=&quot;nav-txt&quot;&amp;gt;{{item.text}}&amp;lt;/span&amp;gt;
    &amp;lt;/a&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
  export default {
    data:function(){
      return {
        commonClass:'nav-item',
        activeClass:'active',
        items:[
          {
            text: '首页',
            active : true
          },
          ......
        ]
      }
    },
    methods:{
      navClickEvent:function(items,index){
        /*默认切换类的动作*/
        items.forEach(function(el){
          el.active = false;
        });
        items[index].active = true;
        /*开放用户自定义的接口*/
        this.$emit('navClickEvent',items,index);
      }
    }
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们利用for循环给每个a标签绑定了一个click事件，对应methods中定义的navClickEvent，接收两个参数items和index（你也可以传人item和index，看个人代码喜好），然后当点击的时候，把items中的每个item.active置为false，把当前的tab的active值置为true，这样就可以动态切换active类了。最后再触发一次自定义事件（参考按钮制作自定义事件）。&lt;/p&gt;
&lt;p&gt;以上就是我们导航组件的内容了，回想下我们做了啥？&lt;strong&gt;for循环输出每个tab，为每个tab绑定动态的class类名，同时在点击事件中动态切换类（底部的小黄条其实是利用active类做的CSS）&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;回顾下我们这一篇章都学了什么内容。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;页面路由的配置&lt;/li&gt;
&lt;li&gt;按钮组件自定义属性props&lt;/li&gt;
&lt;li&gt;按钮组件自定义事件 $on $emit&lt;/li&gt;
&lt;li&gt;按钮组件自定义子块slot&lt;/li&gt;
&lt;li&gt;for循环实现导航组件&lt;/li&gt;
&lt;li&gt;动态类名&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上述内容已经基本上涵盖了组件的重要知识点，主要是父组件（页面）和子组件之间的调用和通讯（数据交互绑定），好好消耗一下我们会发现，其实Vue的总体逻辑思想和jQuery是一样的，毕竟最后都回归到javascript，只是由于代码设计角度的不同，我们可能看到和以前调用jQuery时候的写法不一致，但其实都有对方的影子在里面，相信理解了Vue的代码思想之后，以后我们学习React等其他类似的框架的时候，也会比较得心应手了。&lt;/p&gt;
&lt;p&gt;下一篇文章&lt;a href=&quot;https://www.qcloud.com/community/article/560608001490929432?fromSource=gwzcw.60073.60073.60073&quot;&gt;《包学会之浅入浅出Vue.js：结业篇》&lt;/a&gt;中，我们将会学习如何用多个组件来组成一个大的组件，也就是真正意义上的父子组件之间的关系。再忍耐一下，就可以出山了，新领域的大门就在前面，让我们大步往前跨吧。&lt;/p&gt;
&lt;p&gt;文末附上所有相关代码和官方文档地址~~~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://cn.vuejs.org/v2/guide/&quot; class=&quot;uri&quot;&gt;http://cn.vuejs.org/v2/guide/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.68571428571429&quot;&gt;
&lt;p&gt;&lt;strong&gt;相关阅读&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/edu/course-1128?fromSource=waitui&quot;&gt;【每日课程推荐】机器学习实战！快速入门在线广告业务及CTR相应知识&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;此文已由作者授权腾讯云+社区发布，更多原文请&lt;a href=&quot;https://cloud.tencent.com/developer/article/1020338?fromSource=waitui&quot;&gt;点击&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;搜索关注公众号「云加社区」，第一时间获取技术干货，关注后回复1024 送你一份技术课程大礼包！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;海量技术实践经验，尽在&lt;a href=&quot;https://cloud.tencent.com/developer?fromSource=waitui&quot;&gt;云加社区&lt;/a&gt;！&lt;/p&gt;
</description>
<pubDate>Thu, 15 Nov 2018 09:31:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<og:description>欢迎大家前往</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/9964905.html</dc:identifier>
</item>
</channel>
</rss>