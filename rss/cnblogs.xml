<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>web项目jsp出现The superclass javax.servlet.http.HttpServlet was not found on the Java Build Path错误 - DHL345</title>
<link>http://www.cnblogs.com/dhl345/p/7672406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dhl345/p/7672406.html</guid>
<description>&lt;p&gt;原因是Javaweb工程类中没有添加Tomcat运行时相关类导致。&lt;/p&gt;
&lt;p&gt;解决方式如下：&lt;br/&gt;出错的文件----&amp;gt;&amp;gt;build path----&amp;gt;&amp;gt;config build path----&amp;gt;&amp;gt;java build path----&amp;gt;&amp;gt;libraries----&amp;gt;&amp;gt;add library----&amp;gt;&amp;gt;server runtime----&amp;gt;&amp;gt;tomcat7.0  finish 就ok了!&lt;/p&gt;

&lt;p&gt;今天这个页面再次出现，这次解决没有进行tomcat的加载，而是在pom加了jar的依赖:&lt;/p&gt;
&lt;p&gt;          &amp;lt;dependency&amp;gt;&lt;br/&gt;            &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;&lt;br/&gt;            &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt;&lt;br/&gt;            &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt;&lt;br/&gt;        &amp;lt;/dependency&amp;gt;&lt;/p&gt;
&lt;p&gt;问题解决！&lt;/p&gt;
</description>
<pubDate>Sun, 15 Oct 2017 07:44:00 +0000</pubDate>
<dc:creator>DHL345</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dhl345/p/7672406.html</dc:identifier>
</item>
<item>
<title>1.ElasticSearch介绍及基本概念 - 刘耀</title>
<link>http://www.cnblogs.com/liu-yao/p/1ElasticSearch-jie-shao-ji-ji-ben-gai-nian.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liu-yao/p/1ElasticSearch-jie-shao-ji-ji-ben-gai-nian.html</guid>
<description>&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;/&gt;&lt;title&gt;1.ElasticSearch介绍及基本概念 - 刘耀 - 博客园&lt;/title&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/bundles/blog-common.css?v=ChDk9h03-S75WEqNhGvXkWireJ5cCWdK1xRM9NIXfnM1&quot;/&gt;&lt;link id=&quot;MainCss&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/SimpleMemory/bundle-SimpleMemory.css?v=EanP3quXYv9G0oFCmz4BNBHvmK7M_Si1iD1EpUHL_441&quot;/&gt;&lt;link id=&quot;mobile-style&quot; media=&quot;only screen and (max-width: 768px)&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/SimpleMemory/bundle-SimpleMemory-mobile.css?v=SoSogU6WD3slKzFtcquUsKw-B_2g9Jc5cKp-iy_FV9o1&quot;/&gt;&lt;link title=&quot;RSS&quot; type=&quot;application/rss+xml&quot; rel=&quot;alternate&quot; href=&quot;http://www.cnblogs.com/liu-yao/rss&quot;/&gt;&lt;link title=&quot;RSD&quot; type=&quot;application/rsd+xml&quot; rel=&quot;EditURI&quot; href=&quot;http://www.cnblogs.com/liu-yao/rsd.xml&quot;/&gt;&lt;link type=&quot;application/wlwmanifest+xml&quot; rel=&quot;wlwmanifest&quot; href=&quot;http://www.cnblogs.com/liu-yao/wlwmanifest.xml&quot;/&gt;&lt;/head&gt;&lt;body id=&quot;readabilityBody&quot;&gt;

&lt;div id=&quot;home&quot;&gt;

&lt;div id=&quot;main&quot;&gt;
&lt;div id=&quot;mainContent&quot;&gt;
&lt;div class=&quot;forFlow&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div id=&quot;topics&quot;&gt;
&lt;div class=&quot;post&quot;&gt;


&lt;div class=&quot;postBody&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;cnblogs-markdown&quot;&gt;

&lt;ol&gt;&lt;li&gt;一个采用RESTful API标准的高扩展性的和高可用性的实时性分析的全文搜索工具&lt;/li&gt;
&lt;li&gt;基于Lucene[开源的搜索引擎框架]构建&lt;/li&gt;
&lt;li&gt;ElasticSearch是一个面向文档类型的数据库&lt;/li&gt;
&lt;li&gt;es为非关系型数据，存储非结构化的数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;1.节点(node):&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;一个装有es的服务并且提供故障转移和扩展的服务器，&lt;/li&gt;
&lt;li&gt;单独一个es服务可以存储数据及搜索功能&lt;/li&gt;
&lt;li&gt;在集群中一个节点的名称必须是唯一的&lt;/li&gt;
&lt;li&gt;如果在集群中,通过节点名称进行管理&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_3&quot;&gt;2.集群(cluster):&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;集群就是有多个node组织在一起。共同工作分享整个数据具有负载均衡功能的集群&lt;/li&gt;
&lt;li&gt;集群里的节点协调工作，共享数据。&lt;/li&gt;
&lt;li&gt;集群里通过master节点进行集群管理工作&lt;/li&gt;
&lt;li&gt;集群里通过选举选出一个matser节点&lt;/li&gt;
&lt;li&gt;一个集群里只有一个matser节点&lt;/li&gt;
&lt;li&gt;每一个节点都有成为matser节点的可能&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_4&quot;&gt;3.索引(Index)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;索引就是一个拥有几分相似特征的文档集合&lt;/li&gt;
&lt;li&gt;相当于mysql里的database&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_5&quot;&gt;4.文档(Document)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;一个文档是一个可以被索引的基础信息单元&lt;/li&gt;
&lt;li&gt;相当于mysql里的行&lt;/li&gt;
&lt;li&gt;文档用json格式来表示&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_6&quot;&gt;5.类型(type)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;一个索引中，可以定义一种或者多种数据类型&lt;/li&gt;
&lt;li&gt;一个类型是你的索引的一个逻辑上的分类/分区&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_7&quot;&gt;6.字段(field)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;es里的最小单元 相当于数据的某一列&lt;/li&gt;
&lt;li&gt;类似于json里一个键&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_8&quot;&gt;7.分片(shards)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;es将索引分成若干份 每个部分是一个shards&lt;/li&gt;
&lt;li&gt;每一个shards存在不同的节点上&lt;/li&gt;
&lt;li&gt;一个节点上不能存在两个相同的shards&lt;/li&gt;
&lt;li&gt;每一个文档通过文档id进行hash来确定放在哪一个节点上&lt;/li&gt;
&lt;li&gt;每一个分片都相当于一个独立的Lucene实例&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_9&quot;&gt;8.副本(replicas)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;索引的一份或者多份拷贝&lt;/li&gt;
&lt;li&gt;容灾作用，防止主分片丢失后，副本分片会作为新的主分片，保证集群的数据完整性&lt;/li&gt;
&lt;li&gt;提供查询性能，query的时候，既可以查询主分片，也可以查询副本分片&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;关系型数据库Mysql&lt;/th&gt;
&lt;th&gt;非关系型数据库es&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;数据库 database&lt;/td&gt;
&lt;td&gt;索引 Index&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;表tables&lt;/td&gt;
&lt;td&gt;类型 type&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;数据行row&lt;/td&gt;
&lt;td&gt;文档 Documents&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;数据列Column&lt;/td&gt;
&lt;td&gt;字段 Fieid&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;img src=&quot;http://img.liuyao.me/15073561103841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;toc_12&quot;&gt;1.Gateway&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;gateway是ES数据存储的格式&lt;/li&gt;
&lt;li&gt;可以使用hdfs，本地，亚马逊的s3等多种存储方式&lt;/li&gt;
&lt;li&gt;存储索引信息,集群信息,mapping, 索引碎片信息,以及transaction logs&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_13&quot;&gt;2.Distributed Lucene Directory&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;Lucene框架 es就是基于Lucene框架开发的&lt;/li&gt;
&lt;li&gt;Lucene框架服发现等&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_14&quot;&gt;3.Index Module&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;创建索引的模块&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_15&quot;&gt;4.Search Module&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;搜索模块&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_16&quot;&gt;5.Mapping&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;相当于mysql里的schema&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_17&quot;&gt;6.river&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;从外部获取异构数据 来创建索引&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_18&quot;&gt;7.Discovery&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;节点启动后会互相ping 根据在es.yml配置文件里找到对应的端口&lt;/li&gt;
&lt;li&gt;进行开始选举，从各个节点任务的master中选，进行id字典排序，选择第一个&lt;/li&gt;
&lt;li&gt;如果各个节点上都没有认为的master， 那么就从所有节点中选择&lt;/li&gt;
&lt;li&gt;如果就一个节点 那么master就是她自己&lt;/li&gt;
&lt;li&gt;ES支持任意数目的集群,通过一个规则，只要所有的节点都遵循同样的规则，得到的信息都是对等的，选出来的主节点肯定是一致的. 但分布式系统的问题就出在信息不对等的情况，这时候很容易出现脑裂（Split-Brain）的问题，大多数解决方案就是设置一个quorum值，要求可用节点必须大于quorum（一般是超过半数节点），才能对外提供服务。而 Elasticsearch 中，这个quorum的配置就是 discovery.zen.minimum_master_nodes&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_19&quot;&gt;8.Scriptsing&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;脚本执行功能 对查询出来的数据进行处理&lt;/li&gt;
&lt;li&gt;支持多种语言&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_20&quot;&gt;9.3rdplugins&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;支持安装第三方插件&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_21&quot;&gt;10. transport&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;是支持的协议类型 默认使用http进行交互&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;



&lt;/div&gt;
&lt;div class=&quot;postDesc&quot;&gt;posted @ &lt;span id=&quot;post-date&quot;&gt;2017-10-15 15:44&lt;/span&gt; &lt;a href=&quot;http://www.cnblogs.com/liu-yao/&quot;&gt;刘耀&lt;/a&gt; 阅读(&lt;span id=&quot;post_view_count&quot;&gt;...&lt;/span&gt;) 评论() &lt;a href=&quot;https://i.cnblogs.com/EditPosts.aspx?postid=7672407&quot; rel=&quot;nofollow&quot;&gt;编辑&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/liu-yao/p/1ElasticSearch-jie-shao-ji-ji-ben-gai-nian.html#&quot; onclick=&quot;AddToWz(7672407);return false;&quot;&gt;收藏&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;/div&gt;
&lt;/div&gt;


&lt;/div&gt;


&lt;/div&gt;
&lt;/body&gt;</description>
<pubDate>Sun, 15 Oct 2017 07:44:00 +0000</pubDate>
<dc:creator>刘耀</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liu-yao/p/1ElasticSearch-jie-shao-ji-ji-ben-gai-nian.html</dc:identifier>
</item>
<item>
<title>[解读REST] 5.Web的需求 &amp; 推导REST - Blackheart</title>
<link>http://www.cnblogs.com/linianhui/p/rest_web-and-rest.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linianhui/p/rest_web-and-rest.html</guid>
<description>&lt;p&gt;衔接上文&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/rest_network-based-software-architecture-style.html&quot; target=&quot;_blank&quot;&gt;[解读REST] 4.基于网络应用的架构风格&lt;/a&gt;，上文总结了一些适用于基于网络应用的架构风格，以及其评估结果。在前文的基础上，本文介绍一下Web架构的需求，以及在对Web的关键协议进行设计和改进的过程中遇到的问题；以及在对基于网络应用的架构风格进行评估的过程中的领悟；结合Web的需求进而推导出REST这种架构风格，随后使用REST来指导Web架构的设计和改进工作。&lt;/p&gt;

&lt;p&gt;在本系列博客的第一篇博客&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/rest_origin-of-rest.html&quot; target=&quot;_blank&quot;&gt;[解读REST] 1.REST的起源&lt;/a&gt;中，Web之父Berners-Lee在世界上第一个网站写下的第一句话：“&lt;strong&gt;The WorldWideWeb (W3) is a wide-area &lt;a name=&quot;0&quot; href=&quot;http://info.cern.ch/hypertext/WWW/WhatIs.html&quot;&gt;hypermedia&lt;/a&gt; information retrieval initiative aiming to give universal access to a large universe of documents&lt;/strong&gt;.”，&lt;strong&gt;阐述了创建Web的目的在于形成一种链接众多文档的广域的超媒体信息检索系统，使得人类和机器都可以通过它来进行沟通和交流&lt;/strong&gt;。这个系统最初的目标用户是分散在世界各地的、通过互联网链接的各个大学和政府的高能物理研究实验室。他们的机器是不同类型的终端、工作站、服务器和超级计算机的大杂烩，所以他们的操作系统和文件格式也是一个大杂烩。构建一个这样的系统所面临的挑战是为这些信息文档提供统一的接口，使得这些信息可以在众多的平台上进行交流通信，以及当新的设备接入到这个系统时，可以进行增量的部署。&lt;/p&gt;
&lt;h2&gt;1.1 低门槛&lt;/h2&gt;
&lt;p&gt;参与为Web创建信息是自愿的，对于信息的创作者、阅读者以及应用开发者而已，Web都应该是“低门槛”，以方便Web的各类使用者接入Web系统。&lt;/p&gt;
&lt;p&gt;选择超媒体（比如最常见的超媒体HTML）作为用户界面(UI)，是因为其简单性和通用性。首先无论信息来源于何处，都能使用相同的界面进行呈现；其次超媒体的关系（链接）允许对其进行无限的链接构造，从而形成一个巨大的“网状结构”；对这个网状结构的文档的直接操作可以引导用户浏览整个应用。&lt;/p&gt;
&lt;p&gt;对于创作者而言，超媒体的创作语言也必须是简单的，能够使用现有的编辑工具来进行创建，无论是否链接到网络，都可以使用此超媒体格式来保存创作的内容。因此所有的协议都被定义为文本格式，以方便对通信进行观察和测试。&lt;/p&gt;
&lt;h2&gt;1.2 可扩展性&lt;/h2&gt;
&lt;p&gt;即使可以创建一个完美匹配用户需求的软件系统，那些需求也会随着时间而发生变化（唯一不变的事物就是变化其本身），如果一个系统想要像Web那样长寿，它就必须做好应对变化的准备。因此可扩展性可以使我们避免陷入已部署的系统的局限之中，避免受到遗留系统的束缚。&lt;/p&gt;
&lt;h2&gt;1.3 分布式超媒体&lt;/h2&gt;
&lt;p&gt;超媒体是由应用控制信息来定义的，这些信息内嵌在信息的表述之中。分布式超媒体系统允许在远程地点存储表达控制信息，因此分布式超媒体系统中的用户操作需要将大量的数据从其存储地移交到其使用地，所以Web的架构必须支持大粒度的数据移交。超媒体交互的可用性很容易影响到用户感知的性能（比如用户选择了一个链接，到链接的界面呈现之间的时间），因为Web的交互的信息是跨域整个互联网的，则Web的架构必须尽量的减少网络交互的次数以改善用户感知的性能。&lt;/p&gt;
&lt;h2&gt;1.4 互联网规模&lt;/h2&gt;
&lt;p&gt;Web的旨在形成一个互联网规模的分布式超媒体系统，这意味着它是不但是跨越地理上的分布，而且是跨越组织边界的（互联网是跨域组织边界的信息网络。于此相对的是可控的局域网，比如企业内部的私有网络）。信息服务的提供商必须满足无法控制的可伸缩性和独立部署这两方面的要求。&lt;/p&gt;
&lt;p&gt;大多数我们接触到的系统都存在一个隐含的假设，那就是这个系统是完全可控的。当一个系统在互联网上允许时，则无法满足这样的假设。无法控制的可伸缩性指的是架构元素可能会于其组织边界之外的元素进行通信，当它们遇到如下的情况时仍能正常运行：未曾预料到的负载、收到错误的数据或者恶意的数据等等。这一点适用于所有的架构元素，不能期望用户保持所有的服务的信息，也不能期望服务保持跨越多个请求的状态信息。架构元素在跨越多个组织边界进行通信时，其安全性也是不能忽视的，应该允许中间应用（比如防火墙）来检查其通信，并阻止安全策略不允许的交互。系统的参与者都应该假设其接收到的信息是不可信的，那么就需要架构能够提供认证和授权的机制，然而认证会降低可伸缩性，那么架构的默认操作应该是限制在一组定义好的安全操作中（这里的安全操作指的是不会对服务器造成危害的操作，因此并不需要进行认证）。&lt;/p&gt;
&lt;p&gt;多个组织边界也意味着系统应该可以应对新旧组件的共存，而不妨碍新组件使用它们的新功能。同时现有的架构元素在设计的时候需要考虑到以后会添加新功能，旧的实现也必须能够方便的识别出来，从而把这些遗留的行为封装起来，不会对新元素造成不利影响。对于Web这样的系统来说，强制要求架构中的所有组件都整齐划一的来部署是不现实的事情。&lt;/p&gt;
&lt;h2&gt;1.5 Web急速发展带来的问题&lt;/h2&gt;
&lt;p&gt;自从1990年Berners-Lee发布了第一个网站一来，到1993年末。Web的目标用户已经远远的超出最初计划的目标群体（高能物理研究实验室）了。延伸到了学校、个人主页和校园信息系统等等，Web迎来了指数级的增长。最早的HTTP0.9是一个非常简单的协议，是为单个请求响应设计的，新的站点越来越多的采用了图片作为网页的一部分，导致出现了不同的浏览模式。此时的Web架构已经无法满足这样的需求了，随后在IETF形成了三个工作小组HTTP,URI和HTML。&lt;strong&gt;这些工作组的主要任务是定义现有架构性通信的子集（早期Web中普遍的一致的实现），然后指定一组规范来解决这些问题。这些工作带来的挑战是如何把一组新功能引入到一个已经被广泛部署的系统中；以及如何确保新功能的引入不会对那些使得Web成功的架构属性带来不利的影响甚至是毁灭性的影响&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;1.6 解决之道&lt;/h2&gt;
&lt;p&gt;早期的Web基于一些可靠的设计原则：分离关注点、简单性、通用性，但是缺乏对于架构的描述和理论基础。可以使用一种架构风格来定义Web架构背后的设计原则，那么这些设计原则对于未来的架构而言就是可见的了。如同在之前的博客中解释道的那样，一种架构风格是一组已命名的架构元素之上的架构约束，由它会产生一组所期待的架构属性。而这组期望架构属性，则正是Web所期待的需求的体现。&lt;/p&gt;
&lt;p&gt;这个解决之道的第一步就是识别出来现有的（http1.0和http1.1开发之前）Web架构中的架构约束，这些架构约束负责产生出所期待的架构属性。&lt;/p&gt;
&lt;p&gt;第二步则是识别出在互联网规模的分布式超媒体系统中所期待的架构属性，然后选择会产生这些架构属性的架构约束，把这些架构约束添加到现有的架构风格之上，形成一种新的风格。&lt;/p&gt;
&lt;p&gt;第三步是使用新的架构风格作为指导，对修改和扩展Web架构的提议进行评估，看其是否存在冲突，如果存在冲突则表明这个提议违反了一个或多个Web背后的设计原则。&lt;/p&gt;
&lt;p&gt;修正后的协议规范是根据&quot;&lt;strong&gt;新的架构风格&lt;/strong&gt;&quot;的指导来编写的，最后通过修订后规范，开发实现它，然后进行部署。这些解决之道是源自于Fielding博士直接参与了Apache Http服务器的项目和libwww-perl客户端库，以及为网景的Navigator、Lynx和微软的IE的开发者提供建议得到的经验。&lt;/p&gt;

&lt;p&gt;上一小节提到的“&lt;strong&gt;新的架构风格&lt;/strong&gt;”就是专门为分布式超媒体系统设计的&lt;strong&gt;REST(Representational State Transfer=表述性状态移交)&lt;/strong&gt;，它由上一篇博客中描述的几中架构风格（&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/rest_network-based-software-architecture-style.html&quot; target=&quot;_blank&quot;&gt;[解读REST] 4.基于网络应用的架构风格&lt;/a&gt;）衍生而来，添加了一些额外的架构约束。Web架构的设计理论，是由一组应用于架构元素之上的架构约束组成的，当逐步将每个架构约束添加到这个架构风格上时，会对架构风格产生一些影响，通过检查这些影响，可以识别出来其产生的架构属性。这里就从一个”空风格“开始，它代表一个空的架构约束集合（即是一个没有明显边界的系统），而这也正是推导REST的起点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/168328/201710/168328-20171015105210699-1590417015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.1 客户端-服务器&lt;/h2&gt;
&lt;p&gt;首先添加一个&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/rest_network-based-software-architecture-style.html#auto_id_8&quot; target=&quot;_blank&quot;&gt;客户端-服务器&lt;/a&gt;风格：其背后的原则是分离关注点。通过分离分离用户界面和数据存储两个关注点，可以改善用户界面的&lt;strong&gt;可移植性&lt;/strong&gt;；同时可以简化服务器组件，改善系统的&lt;strong&gt;可伸缩性&lt;/strong&gt;。不过对于Web来说，最重要的则是这种分离使得组件可以&lt;strong&gt;独立部署&lt;/strong&gt;，从而支持跨域多个组织边界的&lt;strong&gt;互联网规模的需求&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/168328/201710/168328-20171015120056184-1703593565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.2 无状态&lt;/h2&gt;
&lt;p&gt;接下来在添加一个架构约束：通信必须在本质上是&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/rest_network-based-software-architecture-style.html#auto_id_11&quot; target=&quot;_blank&quot;&gt;无状态&lt;/a&gt;的。也就是说从客户端到服务器的每个请求都必须包含理解该请求所必须的所有信息，不能利用服务器存储会话的上下文信息，会话状态全部保存在客户端。这一约束可以&lt;strong&gt;改善可见性&lt;/strong&gt;（监视系统不必为了确定一个请求的全部性质而去查看请求之外的其他请求）；&lt;strong&gt;改善可靠性&lt;/strong&gt;（减轻了从局部故障中恢复的任务量）；&lt;strong&gt;改善可伸缩性&lt;/strong&gt;（服务端不必在多个请求直接保存状态，从而允许服务器迅速释放资源）。但是无状态也有相应的缺点，由于服务器不能保持会话状态数据，则会造成在每一次请求中发送大量重复的数据，可能会&lt;strong&gt;降低网络性能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/168328/201710/168328-20171015120111559-1738762618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.3 缓存&lt;/h2&gt;
&lt;p&gt;为了改善网络效率，添加了&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/rest_network-based-software-architecture-style.html#auto_id_6&quot; target=&quot;_blank&quot;&gt;缓存&lt;/a&gt;这个架构约束。它要求一个请求的响应中的数据被隐式或者显式的标记为可缓存或不可缓存，如果可缓存，则客户端可以为以后相同的请求重用这个响应的数据。缓存的好处在于可以消除一部分网络交互，从而&lt;strong&gt;提高效率、可伸缩性和用户感知的性能&lt;/strong&gt;。但是代价则是缓存中如果存在过期的旧数据，则会&lt;strong&gt;降低可靠性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/168328/201710/168328-20171015120122434-2107432236.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;早期的Web架构（1994年之前），是通过客户端-缓存-无状态-服务器这组架构约束来定义的&lt;/strong&gt;。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/168328/201710/168328-20171015112453137-643488456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说，1994年之前的Web架构设计基础理论聚焦的是在互联网上交换静态文档的无状态的客户端-服务器风格，通信信息仅包含了对非共享缓存初步支持，但是并没有限接口要求所有的资源提供一组一致的语义。相反，Web依赖一个公共的客户端-服务器的实现库（CERN的libwww）来维持Web应用的一致性。然而Web的实现者则早已超越了这组设计，除了静态的文档之外，还要求识别动态生成的响应，也以代理和共享缓存的形式开展了对中间件的开发工作，但是必须对现有的协议进行扩展，这样中间件才能可靠的通信。以下三个架构约束（&lt;strong&gt;统一接口，分层系统，按需代码&lt;/strong&gt;）则是早期Web架构的扩充，以便用来对新的Web架构的扩展和改进加以指导。&lt;/p&gt;
&lt;h2&gt;2.4 统一接口&lt;/h2&gt;
&lt;p&gt;REST区别于其他的基于网络的架构风格的核心特征是：强调组件之间要有一个统一的接口。通过在组件接口上应用通用性的原则，简化了整体的系统架构，也改善了交互的可见性。实现和它们所提供的服务是解耦的，这也促进了组件的独立可进化性。当然得到这些好处也是要付出代价的：统一接口降低了效率，因为信息都是使用标准的形式来移交的，而不是特定于应用需求的形式。REST接口被设计为可以高效的移交大粒度的超媒体数据，并对Web的场景情况做了优化，但是这也导致该接口对于其他形式的架构交互而言并不是最优的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/168328/201710/168328-20171015120139809-2129860356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了获得统一接口，需要多个架构约束来指导组件的行为，REST由四个接口架构约束来定义：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;资源的识别；&lt;/li&gt;
&lt;li&gt;通过表述来操作资源；&lt;/li&gt;
&lt;li&gt;自描述的信息；&lt;/li&gt;
&lt;li&gt;超媒体作为应用程序状态的引擎（HATEOAS）。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;2.5 分层系统&lt;/h2&gt;
&lt;p&gt;为了进一步满足互联网规模这个需求，添加了&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/rest_network-based-software-architecture-style.html#auto_id_9&quot; target=&quot;_blank&quot;&gt;分层系统&lt;/a&gt;这个架构约束。分层系统通过限制组件的行为（每个组件只能看到与其交互的相邻层），将架构分解成若干层级。通过将组件对整个系统的认知限制在单一的层级内，为整个系统的复杂性划分了边界，并且可以提高底层的独立性，也可以通过层级来封装遗留的旧组件，以免新的组件受到到旧的影响。中间件还可以支持负载均衡来&lt;strong&gt;改善系统的可伸缩性&lt;/strong&gt;。然而，分层系统会增加数据处理的开销和延迟，因此&lt;strong&gt;降低用户感知的性能&lt;/strong&gt;。不过对于一个支持缓存的架构来说，则可以通过在中间层使用共享缓存来弥补这一缺点。此外还可以通过这些中间层实施安全策略（比如防火墙）。&lt;/p&gt;
&lt;p&gt;分层系统和统一结构相结合后，产生了类似&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/rest_network-based-software-architecture-style.html#auto_id_3&quot; target=&quot;_blank&quot;&gt;统一管道和过滤器&lt;/a&gt;相似的架构属性。在REST中，中间件能够主动的转换消息的内容，因为这些消息是自描述的，并且其语义对于中间件而言是可见的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/168328/201710/168328-20171015142801121-781268193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.6 按需代码&lt;/h2&gt;
&lt;p&gt;为REST添加的最后一个架构约束是&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/rest_network-based-software-architecture-style.html#auto_id_19&quot; target=&quot;_blank&quot;&gt;按需代码&lt;/a&gt;。REST允许下载并执行applet（如今最广泛的是js脚本）代码，对客户端的功能进行扩展。这样则可以减少预先实现的功能的数目，简化客户端的开发，也&lt;strong&gt;改善了系统的可扩展性&lt;/strong&gt;。但是这样做&lt;strong&gt;降低了可见性（REST的连接器和组件并无法理解这些脚本），&lt;/strong&gt;因此按需代码只是REST的一个可选的架构约束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/168328/201710/168328-20171015143249293-1155599341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.7 推导小结&lt;/h2&gt;
&lt;p&gt;REST是由一组经过选择的架构约束组成的架构风格，通过这些架构约束产生了期待的架构属性。完整的REST的推导流程图如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/168328/201710/168328-20171015145753137-1836141909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;REST是对&lt;strong&gt;分布式超媒体系统&lt;/strong&gt;中的架构元素的一种抽象，REST忽略了组件的实现以及协议语法的细节（比如html,http的具体协议细节），以便聚焦于一下几个方面：组件的角色、组件之间的交互、组件对于重要数据元素的解释。&lt;/p&gt;
&lt;h2&gt;3.1 数据元素&lt;/h2&gt;
&lt;p&gt;在分布式对象风格中，所有的数据都被封装和隐藏在数据的处理组件中。于分布式对象不同的是，REST的关键特征在于其架构的数据元素的形式和状态。在分布式超媒体的特性中，当一个用户选择了一个链接后，该链接所指向的信息需要从其存储地移动到其使用地。对于一个分布式超媒体系统的架构师而言，他只能在三种选项中做出选择：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在数据所在地对数据进行呈现，并向接收者发送一个固定格式的镜像；&lt;/li&gt;
&lt;li&gt;把数据和呈现引擎封装起来，一起发送给接收者；&lt;/li&gt;
&lt;li&gt;发送原始数据可一些描述数据类型的元数据，让接收者自己去呈现。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;每一个选项都有其优缺点，第1个选项对应于传统的客户端-服务器风格，它把数据的呈现结果发送给接收者，这样可以简化其他组件对数据结构做出假设，并且简化了客户端的实现，但是也严重限制了接收者的功能，并且把绝大部分的负担都放在了发送者这一边，从来导致伸缩性的问题。第2个选项对应可移动对象风格，它支持对于信息的隐藏，同时还可以通过唯一的呈现引擎支持对数据的处理，但是这将会把接收者的功能限制在呈现引擎的范围之内，也会大量的增加需要移交的数据量。第3个选项允许发送者保持简单性和可伸缩性，但是它丧失了信息隐藏的优点，并且要求发送者和接收者都必须理解相同的数据类型。&lt;/p&gt;
&lt;p&gt;REST聚焦于&lt;strong&gt;分享对于数据类型的理解&lt;/strong&gt;，但是对其标准的操作接口做了限制。通过这样的方式，REST所采用的是这三个选项的一个混合体。REST通过一种数据格式来移交资源的表述来进行通信，这可以基于接收者的能力以及其所期待的格式以及内容中动态的选择所使用的数据格式。至于表述是否资源的原始格式相同，则被隐藏在了接口的背后。&lt;strong&gt;通过发送一个表述，可以获得近似移动对象风格的好处；这个表述由一个标准的数据格式的执行组成（供呈现引擎使用），因此获得了客户端-服务器风格的分离关注点的好处，而且不存在服务器的可伸缩性问题；表述允许通过一个通用的接口来隐藏信息，从而支持封装和服务的进化，并且可以通过按需代码来扩展功能。&lt;/strong&gt;REST的数据元素如下：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;数据元素　　&lt;/td&gt;
&lt;td&gt;实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;资源　　&lt;/td&gt;
&lt;td&gt;一个超文本引用所指向的概念性目标&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;资源标识符&lt;/td&gt;
&lt;td&gt;URL,URN&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;表述&lt;/td&gt;
&lt;td&gt;HTML，图片，音视频&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;表述元数据&lt;/td&gt;
&lt;td&gt;媒体类型，修改时间等&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;资源元数据&lt;/td&gt;
&lt;td&gt;source link,alterbates&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;控制数据&lt;/td&gt;
&lt;td&gt;cache-control等&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;REST对于信息的核心抽象是&lt;strong&gt;资源&lt;/strong&gt;：任何可以被命名的信息都能够作为一个资源，比如一个文档，一个图片，今天的天气情况等等。资源标识符则是对一个资源的唯一标识，由命名权威来为资源分配标识符，映射的语义同样由命名权威来负责。REST使用&lt;strong&gt;表述&lt;/strong&gt;来表述资源的当前状态或者预期状态，随后在各个组件之间移交该表述，通过这种方式在资源上执行各自操作，表述通常由数据以及描述数据的元数据组成。控制数据则是定义在组件之间交互的数据的用途以及其行为，比如控制缓存行为等。表述的数据格式成为媒体类型（media type），发送者可以把一个表述包含在一个响应之中，移交给接收者，接收者收到响应之后，根据消息中的控制数据和媒体类型的性质，对消息进行处理(比如呈现一个jpg的图片，执行一个js脚本等)。媒体类型的设计会之间影响到用户感知的性能，比如HTML支持增量呈现的话，浏览器就可以一边接收html，一遍呈现接收到的部分内容，而不必等到其完全接收完毕。&lt;/p&gt;
&lt;p&gt;由这些数据元素可以组成一个操作资源的通用接口，而无需关系其成员函数或者其处理软件是何种类型的。&lt;/p&gt;
&lt;h2&gt;3.2 连接器&lt;/h2&gt;
&lt;p&gt;REST使用多种不同类型的连接器来对资源和其表述进行封装，连接器代表了一个组件通信的抽象接口。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;连接器&lt;/td&gt;
&lt;td&gt;实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;客户&lt;/td&gt;
&lt;td&gt;libwww、libwww-perl、httpclient&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;服务器&lt;/td&gt;
&lt;td&gt;libwww、apache api&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;缓存&lt;/td&gt;
&lt;td&gt;浏览器缓存、CDN&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;解析器　&lt;/td&gt;
&lt;td&gt;DNS&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;隧道&lt;/td&gt;
&lt;td&gt;SSL&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所有的REST的交互都是无状态的。这就使得每个请求都包含理解该请求的全部信息，而不必查找其关联的请求。这一个约束得到了一下4点好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;连接器无需在请求之间保持应用状态，改善可伸缩性；&lt;/li&gt;
&lt;li&gt;允许对交互进行并行处理；&lt;/li&gt;
&lt;li&gt;允许中间件查看和理解单独的一个请求，并对其进行动态的安排（比如负载均衡）；&lt;/li&gt;
&lt;li&gt;强制了每个请求都包含可能会影响缓存的信息。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;主要的连接器是客户端和服务器，客户端发起请求，服务器监听请求并做出响应。其次是缓存连接器，它位于客户端和服务器接口处，用来复用可缓存的响应，比如浏览器缓存，和共享的CDN缓存。解析器负责把部分或者完整的资源标识符翻译成具体的网络地址信息，比如DNS把一个域名翻译成一个IP地址。隧道是一种简单的跨域连接边界的一种机制，比如SSL。&lt;/p&gt;
&lt;h2&gt;3.3 组件&lt;/h2&gt;
&lt;p&gt;REST的组件可以根据它们在整个应用中的角色来分类，比如：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;组件&lt;/td&gt;
&lt;td&gt;实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;来源服务器&lt;/td&gt;
&lt;td&gt;Apache,Ngnix,IIS&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;网关　　&lt;/td&gt;
&lt;td&gt;CGI，反向代理，SMTP网关&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;代理　　&lt;/td&gt;
&lt;td&gt;CERN代理，Fiddler&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;用户代理&lt;/td&gt;
&lt;td&gt;chrome,firefox,ie，httpclient&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;来源服务器是资源的命名权威所在地。网关则是前置在来源服务器的一个组件，用来执行数据转换（HTTP到SMTP的网关），安全增强、性能增强（负载均衡）等。代理和网关的差异在于这是客户选择的组件，必须调试http的时候使用的fiddler。用户代理是使用客户端连接器发起请求，并作为响应的最终接收者，一般而言是Web浏览器，或者网络爬虫。&lt;/p&gt;

&lt;p&gt;第3小节孤立的了解了REST的架构元素，这一小节则把这些元素组合起来，形成一个架构。&lt;/p&gt;
&lt;h2&gt;4.1 过程视图&lt;/h2&gt;
&lt;p&gt;过程视图的主要作用是展示数据在系统中的流动路径，得出组件之间的交互关系。下面是一个典型的REST的过程视图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/168328/201710/168328-20171015152543449-152603689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个用户代理处理三个并行的交互，用户代理的客户端连接器的缓存无法满足请求，则它根据每个资源标识符的属性和客户端的连接配置，把每个请求路由到资源的来源服务器：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;请求a被发送到一个本地代理，然后代理通过DNS查找到了一个网关，该网关把这个请求发送到了一个能满足该请求的来源服务器。&lt;/li&gt;
&lt;li&gt;请求b被之间发送到了一个来源服务器。&lt;/li&gt;
&lt;li&gt;请求c被发送到了一个SMTP的代理，这个代理之间把请求转换为了一个SMTP的请求，发给了一个邮件服务器。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;4.2 连接器视图&lt;/h2&gt;
&lt;p&gt;REST的连接器视图聚焦于组件之间的通信机制。客户端连接器检查资源标识符，以便为每一个请求选择一个合适的通信机制，比如标识符如果是一个本地资源，则链接到一个处理本地资源的代理组件。比如是一个GFW的资源时，链接到一个科学上网的代理（你懂的...）。REST并不限制通信的协议，比如上面的请求c把一个http的请求，转换为了邮件协议。&lt;/p&gt;
&lt;h2&gt;4.3 数据视图&lt;/h2&gt;
&lt;p&gt;数据视图展示的时信息在组件之间流动时的应用状态。REST把所有的控制状态都集中在表述之中，目的在于使服务器无需维护当前请求之外的客户端状态，从而改善服务器的可伸缩性。应用的下一个控制状态位于第一个请求的响应的表述之中，从一个表述迁移到下一个表述，因此这样的一系列表述可以构造出一个资源的有限状态机，即超媒体作为应用程序的状态引擎（HATEOAS）。&lt;/p&gt;

&lt;p&gt;本篇博客在前几篇的基础上，介绍了Web诞生的目标，以及在早期发展中遇到的问题，进而推导出了其解决之道，即专门为分布式超媒体系统设计的REST（表述性状态移交）架构风格。REST强调组件交互的可伸缩性、接口的通用性、组件的独立部署、以及减少交互延迟、增强安全性、封装遗留系统的组件等。下面一篇博客则描述下把REST落实到Web的架构设计，协议规范的制定，以及部署的过程中的经验和教训。如由错误之处，欢迎指正。&lt;/p&gt;

&lt;p&gt;世界上诞生的第一个网站：&lt;a href=&quot;http://info.cern.ch/&quot; target=&quot;_blank&quot;&gt;http://info.cern.ch/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;世界上诞生的第一个网站-模拟器：&lt;a href=&quot;http://line-mode.cern.ch/www/hypertext/WWW/TheProject.html&quot; target=&quot;_blank&quot;&gt;http://line-mode.cern.ch/www/hypertext/WWW/TheProject.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Web的生日：&lt;a href=&quot;http://home.cern/topics/birth-web&quot; target=&quot;_blank&quot;&gt;http://home.cern/topics/birth-web&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;理解本真的REST：&lt;a href=&quot;http://www.infoq.com/cn/articles/understanding-restful-style/&quot; target=&quot;_blank&quot;&gt;http://www.infoq.com/cn/articles/understanding-restful-style/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;架构风格与基于网络的软件架构设计-导读：&lt;a href=&quot;http://www.infoq.com/cn/articles/doctor-fielding-article-review&quot; target=&quot;_blank&quot;&gt;http://www.infoq.com/cn/articles/doctor-fielding-article-review&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;架构风格与基于网络的软件架构设计：&lt;a href=&quot;http://www.infoq.com/cn/minibooks/web-based-apps-archit-design&quot; target=&quot;_blank&quot;&gt;http://www.infoq.com/cn/minibooks/web-based-apps-archit-design&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Roy T. Fielding: Understanding the REST Style：&lt;a href=&quot;https://www.youtube.com/watch?v=w5j2KwzzB-0&quot; target=&quot;_blank&quot;&gt;https://www.youtube.com/watch?v=w5j2KwzzB-0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Roy T. Fielding: REST APIs must be hypertext-driven： &lt;a href=&quot;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&quot; target=&quot;_blank&quot;&gt;http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Evolution of HTTP：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP&quot; target=&quot;_blank&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Evolution_of_HTTP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;REST is not about APIs , Part 1：&lt;a href=&quot;https://www.nirmata.com/2013/10/01/rest-apis-part-1/&quot; target=&quot;_blank&quot;&gt;https://www.nirmata.com/2013/10/01/rest-apis-part-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;REST is not about APIs , Part 2：&lt;a href=&quot;https://www.nirmata.com/2013/11/12/rest-apis-part-2/&quot; target=&quot;_blank&quot;&gt;https://www.nirmata.com/2013/11/12/rest-apis-part-2/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 15 Oct 2017 07:44:00 +0000</pubDate>
<dc:creator>Blackheart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linianhui/p/rest_web-and-rest.html</dc:identifier>
</item>
<item>
<title>JavaScript面向对象基础与this指向问题 - 榆木疙瘩ii</title>
<link>http://www.cnblogs.com/wuhao752718372/p/7671071.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhao752718372/p/7671071.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  前  言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;         &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的程序语言经历了从“面向机器”、到“面向过程”、再到“面向对象”的一个过程。而JavaScript是一门基于对象的一门语言，它介于面向过程与面向对象之间。在学习JavaScript的过程中，OOP是非常重要的一环，下面我们来一起探讨一下JS中的面向对象吧！！！&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1 、OOP的基础问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;1.1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;什么是面向过程和面向对象？&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;面向过程：&lt;/strong&gt;专注于如何去解决一个问题的过程步骤。编程特点是由一个个的函数去实现每一步的过程步骤，没有类和对象的概念。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面向对象：&lt;/strong&gt;专注于由哪一个对象来解决这个问题。编程特点是出现了一个个的类，从类中拿到这个对象，由这个对象去解决具体的问题。&lt;/p&gt;
&lt;p&gt;对于调用者来说，面向过程需要调用者自己去实现各种函数。而面向对象，只需要告诉调用者对象中具体方法的功能，而不需要调用者了解方法中的实现细节。 &lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;1.2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;面向对象的三大特征&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;继承、封装、多态&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;1.3&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;类和对象的关系&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;① &lt;strong&gt;类&lt;/strong&gt;：一类具有相同特征(属性)和行为(方法)的集合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如：人类--&amp;gt;属性：身高、体重、性别     方法：吃饭、说话、走路&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② &lt;strong&gt;对象&lt;/strong&gt;：从类中，拿出具有确定属性值和方法的个体。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如：张三--&amp;gt;属性：身高180、体重180  方法：说话--&amp;gt;我叫张三，身高180&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③ &lt;strong&gt;类和对象的关系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类是抽象的，对象是具体的(类是对象的抽象化，对象是类的具体化)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类是一个抽象的概念，只能说类有属性和方法，但是不能给属性赋具体的值。比如说人类有姓名，但是不能说人类的姓名叫啥。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对象是一个具体的个例，是将类中的属性进行具体赋值而来的个体。比如说张三是人类的一个个体，可以说张三的姓名叫张三。也就是张三对人类的每一个属性进行了具体的赋值，那么张三就是由人类产生的一个对象。&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2、 JavaScript中的面向对象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2.1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;创建类和对象的步骤&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;①创建一个类(构造函数)：类名必须使用大驼峰法则，即每个单词的首字母必须大写。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; 类名(属性1){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;      &lt;span&gt;this&lt;/span&gt;.属性1 =&lt;span&gt; 属性1;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;      &lt;span&gt;this&lt;/span&gt;.方法 = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;方法中要调用自身属性，必须要使用this.属性&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;②通过类，实例化(new)出一个对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; 类名(属性1的具体值);
obj.属性;    调用属性
obj.方法();     调用方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③注意事项&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;通过类名，new出一个对象的过程，叫做“类的实例化”&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;类中的this，会在实例化的时候，指向新new出的对象。所以，this.属性 this.方法，实际上是将属性和方法绑定在即将new出的对象上面。&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;在类中，要调用自身属性，必须使用this.属性名、如果直接使用变量名，则无法访问对应的属性。&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;类名必须使用大驼峰法则，注意与普通函数的区别。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2.2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;两个重要属性constructor和instanceof&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;①&lt;strong&gt;constructor&lt;/strong&gt;：返回当前对象的构造函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;zhangsan.constructor = Person;   √&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②&lt;strong&gt;instanceof&lt;/strong&gt;：检测一个对象，是不是一个类的实例；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;lisi instanceof Person √   lisi是通过Person类new出的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;lisi instanceof Object √   所有对象都是Object的实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;Person instanceof Object √   函数本身也是对象&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、 JavaScript中的this指向问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在上一部分中，我们创建了一个类，并通过这个类new出了一个对象。 但是，这里面出现了大量的this。 很多同学就要懵逼了，this不是“这个”的意思吗？为什么我在函数里面写的this定义的属性，最后到了函数new出的对象呢？？&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;3.1&lt;/span&gt;&lt;span&gt;谁最终调用函数，this就指向谁！&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;① this指向谁，不应该考虑函数在哪声明，而应该考虑函数在哪调用！！&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;② this指向的，永远只可能是对象，不可能是函数！！&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;③ this指向的对象，叫做函数的上下文context，也叫函数的调用者。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;3.2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;this指向的规律(与函数的调用方式息息相关！)&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;① 通过函数名()调用的，this永远指向window&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
func(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; this---&amp;gt;window&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;【解释】 我们直接用一个函数名()调用，函数里面的this，永远指向window。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;② 通过对象.方法调用的，this指向这个对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 狭义对象&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
        name:&lt;/span&gt;&quot;obj&quot;&lt;span&gt;,
        func1 :func
    };
    obj.func1(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this---&amp;gt;obj&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;【解释】我们将func函数名，当做了obj这个对象的一个方法，然后使用对象名.方法名， 这时候函数里面的this指向这个obj对象。&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 广义对象&lt;/span&gt;
    document.getElementById(&quot;div&quot;).onclick = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.style.backgroundColor = &quot;red&quot;&lt;span&gt;;
}; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this---&amp;gt;div&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;【解释】对象打点调用还有一个情况，我们使用getElementById取到一个div控件，也是一种广义的对象，用它打点调用函数，则函数中的this指向这个div对象。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;③ 函数作为数组的一个元素，用数组下标调用，this指向这个数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; arr = [func,1,2,3&lt;span&gt;];
arr[&lt;/span&gt;0]();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; this---&amp;gt;arr&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;【解释】这个，我们把函数名，当做数组中的一个元素。使用数组下标调用，则函数中的this将指向这个数组arr。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;④ 函数作为window内置函数的回调函数使用，this指向window。比如setTimeout、setInterval等&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
setTimeout(func,1000);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; this---&amp;gt;window&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;setInterval(func,1000);&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;【解释】使用setTimeout、setInterval等window内置函数调用函数，则函数中的this指向window。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;⑤ 函数作为构造函数，使用new关键字调用，this指向新new出的对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj = &lt;span&gt;new&lt;/span&gt; func(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;this---&amp;gt;new出的新obj&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;【解释】这个就是第二部分我们使用构造函数new对象的语句，将函数用new关键字调用，则函数中的this指向新new出的对象。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;3.3&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;关于this问题的面试题&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; fullname = 'John Doe'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
　　fullname: &lt;/span&gt;'Colin Ihrig'&lt;span&gt;,
　　prop: {
　　　　fullname: &lt;/span&gt;'Aurelio De Rosa'&lt;span&gt;,
　　　　getFullname: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
　　　　　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fullname;
　　　　}
　　}
};
console.log(obj.prop.getFullname()); 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数的最终调用者 obj.prop &lt;/span&gt;
            
&lt;span&gt;var&lt;/span&gt; test =&lt;span&gt; obj.prop.getFullname;
console.log(test());  
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数的最终调用者 test()  this-&amp;gt; window&lt;/span&gt;
&lt;span&gt;            
obj.func &lt;/span&gt;=&lt;span&gt; obj.prop.getFullname;
console.log(obj.func()); 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数最终调用者是obj&lt;/span&gt;
            
&lt;span&gt;var&lt;/span&gt; arr = [obj.prop.getFullname,1,2&lt;span&gt;];
arr.fullname &lt;/span&gt;= &quot;JiangHao&quot;&lt;span&gt;;
console.log(arr[&lt;/span&gt;0&lt;span&gt;]());
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数最终调用者数组&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;好了，这篇博客，我们了解了什么是面向对象、类和对象的关系、JS中声明类与对象的步骤，以及重点讲解的this指向问题！ 希望能够帮助大家真正的理解了this的认知，下面我会继续给大家分享关于面向对象方面的问题。多谢大家的支持！！！&lt;/p&gt;

</description>
<pubDate>Sun, 15 Oct 2017 06:59:00 +0000</pubDate>
<dc:creator>榆木疙瘩ii</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhao752718372/p/7671071.html</dc:identifier>
</item>
<item>
<title>随身Wifi http代理 - 逐日</title>
<link>http://www.cnblogs.com/zhuri/p/7671060.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuri/p/7671060.html</guid>
<description>[unable to retrieve full-text content]需求来源： 1.平板或手机是个封闭系统无法给wifi设置代理 2.需要利用filllder进行抓包，内容篡改等实验 拥有硬件资源：PC机器 + 小米随身wifi 方案1： NtBind Dns + Nginx 基本原理：域名劫持 + 反向代理 + 正向代理 部署图： 说明： 1.因为小米wifi与本</description>
<pubDate>Sun, 15 Oct 2017 06:55:00 +0000</pubDate>
<dc:creator>逐日</dc:creator>
<dc:identifier>http://www.cnblogs.com/zhuri/p/7671060.html</dc:identifier>
</item>
<item>
<title>“跟着西瓜去学习”之--模型评估与选择 - zutterhao</title>
<link>http://www.cnblogs.com/zutterhao/p/7639196.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zutterhao/p/7639196.html</guid>
<description>&lt;p&gt;在上一节的绪论里主要介绍了一些机器学习里面比较基础的概念定义，帮助大家了解下机器学习方面的名词，算是个基础的入门。同样的在这节我们将讲到一些为后面的学习打基础的内容。其中的许多概念还是挺耐人寻味，需要好好理解的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简介：&lt;/span&gt;这一节主要是介绍机器学习中模型的评估与选择，大家都知道，所谓的机器学习，其本质就是在训练样本上学习出一个恰当的模型，然后将模型应用在需要用来预测或计算的新样本上。我们也知道，对于不同的问题，我们需要建立的模型是不同的，一个好的模型对于问题的解决起到了非常大的作用。但是当我们遇到一个具体的问题的时候，我们该怎么选择模型呢？或者说我们怎么知道我们选择的模型好不好呢？这就需要我们对选择的模型建立一个评估的机制来评判模型的好坏。下面将介绍一些概念和评估方法。&lt;/p&gt;
&lt;h2&gt;1.经验误差与过拟合&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;错误率（error rate）&lt;/span&gt;：分类错误样本数占样本总数的比例。如m个样本中有a个样本分类错误，那么错误率E = a / m。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;精度（accuracy）&lt;/span&gt;:分类正确样本数占样本总数的比例。精度=1 - 错误率。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;误差（error）&lt;/span&gt;:学习器的实际预测输出与样本的真实输出直接的差异。在训练集上的误差称为“&lt;span&gt;训练误差（training error）&lt;/span&gt;”或者“&lt;span&gt;经验误差（empirical error）&lt;/span&gt;”。在新样本上的误差称为“&lt;span&gt;泛化误差（generalization error）&lt;/span&gt;”。相比于训练误差，我们更希望模型有更小的泛化误差，因为模型的目的是为了预测新的样本。所以如果一个模型有很小的训练误差，甚至训练误差为0，但是泛化误差很大的话，这个模型也不是一个好的模型。&lt;/p&gt;
&lt;p&gt;我们希望学习器能够学习到样本的“普遍规律”，这样才可以在遇到新的样本的时候做出正确的判断。但是训练不当的时候会出现“过拟合”和“欠拟合”的问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;过拟合（overfitting）&lt;/span&gt;:通俗一点地来说过拟合就是模型把数据学习的太彻底，以至于把噪声数据的特征也学习到了，这样就会导致在后期测试的时候不能够很好地识别数据，即不能正确的分类，模型泛化能力太差。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171008232518684-1105858756.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171008232528949-32424017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左图是我们的训练数据，右图是我们训练出来的模型，显然我们的曲线过于复杂，不符合样本的真实分布。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;欠拟合（underfitting）&lt;/span&gt;:欠拟合与过拟合相对，就是模型没有很好地捕捉到数据特征，不能够很好地拟合数据。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171008232841574-1988881362.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171008232851168-1243203555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左图是我们的数据，右图是训练出来的模型，很显然我们的模型学习的过于简单，没有将数据的曲线表现出来。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我们需要注意一点：&lt;span&gt;针对过拟合我们会采取很多方法来抑制。但是过拟合是无法避免的，所有我们能做的只是“缓解”。&lt;strong&gt;因为我们面临的问题大多是NP难甚至更难，但是有效的学习算法必然是在多项式时间内完成的，也就是P问题，因为NP不等于P，所以过拟合不可避免&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2.评估方法&lt;/h2&gt;
&lt;p&gt;       我们前面讲到了，对于我们选择的一个模型我们需要去评估这个模型的好坏。用来评估的数据集合我们叫做“&lt;span&gt;测试集（testing set）&lt;/span&gt;”，在测试集上得到的误差叫做“&lt;span&gt;测试误差（testing error）&lt;/span&gt;”,我们把测试误差当作是泛化误差的一个近似。由于我们在训练中是无法得到泛化的数据的，所以这些测试集是从样本真实分布中独立同分布采样得到的。那么测试集要满足什么条件呢？直观上我们可以想到，我们的目的是为了使得泛化性能更好，所以选取的&lt;strong&gt;测试集要尽可能的与训练集互斥&lt;/strong&gt;，即测试样本尽量不要在训练集中出现，未在训练过程中使用过。举一个简单的类比例子来解释下为什么要这么做：比方说老师教授一门课，我们每个学生都当做一个学习器，平时的作业题看作是训练集，用于训练我们的解题能力。期末考试题就当作是测试集，来测试我们学习效果的好坏。可以想到，如果期末考试题都是没有做过的题目，那么考察的效果肯定比较好，学的好的学生就能得到更高的分数，学生之间学习效果的差异性就表现出来了；而如果拿作业原题来考察的话，大部分同学都能考的很好，却并不代表着他们都学的很好。从这个例子中我们可以比较形象的理解为什么测试集要这么选。&lt;/p&gt;
&lt;p&gt;　　我们知道，用于训练一个学习器，我们的数据是有限的，对于一个包含有m个样例的数据集D={（x&lt;sub&gt;1&lt;/sub&gt;,y&lt;sub&gt;1&lt;/sub&gt;），（x&lt;sub&gt;2&lt;/sub&gt;,y2）......（x&lt;sub&gt;m&lt;/sub&gt;,y&lt;sub&gt;m&lt;/sub&gt;）}。我们既要训练又要测试，那么该怎么通过这个数据集来分别产生训练集S和测试集T呢？下面介绍几种常用的方法：&lt;/p&gt;
&lt;h3&gt;2.1 留出法（hold-out）&lt;/h3&gt;
&lt;p&gt;　　第一种方法叫做&lt;span&gt;留出法&lt;span&gt;，这个方法比较的简单粗暴，它直接将数据集划分为两个互斥的集合，一个作为训练集S，一个作为测试集T。比如D有1000个数据，将其中700个作为训练集S，另外300个作为测试集T。但是这里的700和300可不是随便的划分的。我们要保证&lt;strong&gt;样本比例相似，&lt;/strong&gt;从采样的角度来看就叫做&lt;span&gt;分层采样（stratified samping）&lt;/span&gt;，比如说数据集D中有500个正样本，500个负样本，正负样本比例为1：1，那么我们的训练集S和测试集T中应该正负样本比例也为1:1。这种想法也可以通过上面的例子来理解：老师同时教授几何和函数，它们在课程中同等重要，那么平时的训练量也是一半一半，考试的时候也是一半一半的出题。而不会出现平时大量的练习函数，考试疯狂的考察几何的情况。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　留出法存在一个问题就是即使在保证分层采样的前提下，不同的划分导致不同的训练集和测试集，模型评估结果就会有差别。解决方法是&lt;strong&gt;进行多次的随机划分，重复实验取平均值&lt;/strong&gt;。留出法存在的另一个问题在与训练集和测试集比例的问题：如果训练集包含大多数样本，T比较下，无法准确的评估模型；如果测试集T多包含一些样本，S和T差别过大会降低评估结果的保真性。这里常见的做法是：&lt;strong&gt;将大约2/3 ~ 4/5的样本用于训练，剩余样本用于测试。&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;2.2 交叉验证法（cross validation）&lt;/h3&gt;
&lt;p&gt;　　交叉验证法首先将数据集D分为k个大小相似的互斥子集，即D = D&lt;sub&gt;1&lt;/sub&gt; ∪ D&lt;sub&gt;2&lt;/sub&gt; ∪.....∪ D&lt;sub&gt;k&lt;/sub&gt;,D&lt;sub&gt;i&lt;/sub&gt; ∩ D&lt;sub&gt;j&lt;/sub&gt; = 空集。每个子集都保持数据分布的一致性，即从D中通过分层采样得到。分割完毕之后，我们选取其中K-1个作为训练集，剩余的那个子集作为测试集。我们轮流把第k个子集作为训练集，这样便得到了k组训练/测试集，我们经过k次训练和测试，最终返回k个测试结果的均值。通常也把交叉验证法称作“k折验证法”。k通常取 5，10 20等。为了更形象理解，我们还拿上课的例子来解释。数据集D就是我们的题库，然后老师根据考试大纲把题库组成了k份试卷，这里每份试卷的题型分布和题量都是差不多的，然后把其中的k-1份试卷作为训练，1份作为期末考试。唯一的区别可能是我们考试不会考k次而已。这样是不是比较好理解一点呢？&lt;/p&gt;
&lt;p&gt;　　类比一下留出法我们就会发现，我们的子集分割也会出现多种的分割方式，不同的分割得到的k个子集也是不一样的。参照前面的方法，我们同样可以通过多次随机分割取平均值的方法来实现。比如我们随机分割p次，最终得到的方法为&lt;span&gt;“p次k折交叉验证”&lt;span&gt;。这里还得说下这个方法的特例情况，也就是当k=m时，每一个样例作为一个子集，这种方法被称作“&lt;span&gt;留一法（Leave-One-Out,简称LOO）&lt;/span&gt;”，这种方法实际上跟用整个数据集D训练出来的模型很相似，评估结果也比较准确。但是存在一个巨大的问题：&lt;strong&gt;当数据集样本数量非常大时（一百万），计算的开销也是非常巨大的，这个是不能接受的&lt;/strong&gt;。我们可以看到“&lt;span&gt;没有免费午餐定理&lt;/span&gt;”在这里也同样的适用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.3 自助法（bootstrap sampling）&lt;/h3&gt;
&lt;p&gt;　　在留出法和交叉验证法中，我们实际训练所使用的训练集都是要小于数据集D的，这样会引入一些由于训练样本规模不同而导致的评估误差。自助法便是针对于这个问题的：对于给定的有m个训练样本的数据集D，我们对其进行采样产生训练集D'。产生的方法如下：每次随机从D中挑选一个样本，拷贝放入D'中，然后挑选的样本重新放入D中，这个样本下次还有可能被选到。此步骤重复m次之后我们便得到了有m个数据的训练集D‘，然后将D\D'（在D中而不在D'中的数据）作为测试集。自助法在&lt;strong&gt;数据集较小，难以有效划分训练集和测试集时很有用&lt;/strong&gt;。但是会带来一个问题，它改变了数据的原始分布（D和D'不一样），引入了估计误差。所以在&lt;strong&gt;数据量足够的情况下，留出法和交叉验证法更加常用&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;3.性能度量&lt;/h2&gt;
&lt;p&gt;衡量模型泛化能力的评价标准就是&lt;span&gt;性能度量（performance measure）&lt;/span&gt;.&lt;/p&gt;
&lt;h3&gt;3.1 错误率和精度&lt;/h3&gt;
&lt;p&gt;对于数据集D，错误率为分类错误样本数占样本总数的比例:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171014160735074-1313135288.png&quot; alt=&quot;&quot; width=&quot;291&quot; height=&quot;69&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里 I(x) = 0 如果x=0;I(x) = 1 如果x != 0;&lt;/p&gt;
&lt;p&gt;对应的精度为分类正确样本数占样本总数的比例:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171014160758465-1866636216.png&quot; alt=&quot;&quot; width=&quot;302&quot; height=&quot;89&quot;/&gt;&lt;/p&gt;

&lt;p&gt;更一般性的，对于数据分布D和概率密度p(.),错误率和精度分别可以描述为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171014160821371-1320442308.png&quot; alt=&quot;&quot; width=&quot;351&quot; height=&quot;74&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171014160830887-199057676.png&quot; alt=&quot;&quot; width=&quot;355&quot; height=&quot;85&quot;/&gt;&lt;/p&gt;
&lt;p&gt;p(x)为x的概率。&lt;/p&gt;
&lt;h3&gt;3.2 查准率，查全率和F1&lt;/h3&gt;
&lt;p&gt;对于二分类问题，可以将样例根据&lt;strong&gt;真实类别&lt;/strong&gt;和&lt;strong&gt;学习器预测类别&lt;/strong&gt;分为：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;真正例（true positive，TP）&lt;/span&gt;:真实类别为真，预测类别为真；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假正例（false positive,FP）&lt;/span&gt;:真实类别为假，预测类别为真；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;真反例（true negative,TN）&lt;/span&gt;:真实类别为假，预测类别为假；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假反例（false negative,FN）&lt;/span&gt;:真实类别为真，预测类别为假。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171014161728934-1415513276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查准率(precision)&lt;/span&gt; P:&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171014161821902-1207601451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;查准率表示的是“&lt;strong&gt;检索出来的信息有多大的比例是用户感兴趣的&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查全率（recall）&lt;/span&gt;R:&lt;/p&gt;
&lt;p&gt;            &lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171014162222980-32347275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查全率表示的是“&lt;strong&gt;用户感兴趣的信息有多少被检索出来了&lt;/strong&gt;”。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171014162451215-481127740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查准率和查全率是一对矛盾的度量，查准率高时查全率往往较低；而查全率较高时查准率往往较低。我们以查准率为纵轴，查全率为横轴作图的话就可以得到查准率-查全率曲线，简称“P-R曲线”：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171014163326543-89164033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在P-R图中，如果一个曲线完全将另一个曲线包住，则性能更优，如图中的A要优于C。如果发生交叉的话则很难判断孰优孰劣，于是便设计一个能够综合考虑查准率和查全率的性能度量。&lt;span&gt;“平衡点”（Break-Even Point,BEP）&lt;/span&gt;便是这样一个度量，他是&lt;strong&gt;&quot;查准率=查全率&quot;&lt;/strong&gt;的取值。则可以判断出上图中性能A &amp;gt; B &amp;gt; C。但是更加常用的是F1度量：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171014164247684-1550456265.png&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;71&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们赋予P和R同样大小的权重，但是在有些应用中，对于查准率和查全率的重视程度有所不同。那么F1度量的一般形式为F&lt;sub&gt;β&lt;/sub&gt;,定义为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171014164531387-406503996.png&quot; alt=&quot;&quot; width=&quot;232&quot; height=&quot;71&quot;/&gt;&lt;/p&gt;
&lt;p&gt;F1是基于查准率与查全率的调和平均定义的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171014165107809-529124581.png&quot; alt=&quot;&quot; width=&quot;181&quot; height=&quot;64&quot;/&gt;&lt;/p&gt;
&lt;p&gt;F&lt;sub&gt;β&lt;/sub&gt;是加权调和平均：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171014165338715-1171278272.png&quot; alt=&quot;&quot; width=&quot;202&quot; height=&quot;51&quot;/&gt;&lt;/p&gt;
&lt;p&gt;β = 1时为标准F1,β &amp;gt; 1查全率有更大影响，β&amp;lt;1查准率有更大影响。&lt;/p&gt;
&lt;h3&gt;3.3 ROC和AUC&lt;/h3&gt;
&lt;p&gt;ROC全称“&lt;span&gt;受试者工作特征”（Receiver Operating Characteristic）&lt;/span&gt;曲线。与P-R曲线不同，ROC曲线的纵轴是“真正例率”（True Positive Rate,TPR）,横轴是“假正例率”（False Positive Rate,FPR）。定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171014171031762-595294083.png&quot; alt=&quot;&quot; width=&quot;245&quot; height=&quot;148&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显示ROC曲线的图称为“&lt;span&gt;ROC图&lt;/span&gt;”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171014171316887-1875616381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是现实任务中是用有限个测试样例来绘制ROC图，所以无法做到平滑，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171014171414902-1797122876.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们通过ROC曲线来进行性能度量时，与P-R图一样，如果被一个曲线完全包住另一个曲线，则这个曲线对应的性能更好。如果两个曲线发生相交则很难判断孰优孰劣。此时我们可以通过&lt;span&gt;AUC（Area Under ROC Curve）&lt;/span&gt;判断，即&lt;strong&gt;ROC曲线下面积&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;4.偏差与方差&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;偏差（bias）&lt;/span&gt;：度量学习算法的期望预测与真实结果的偏离程度，刻画学习算法本身的拟合能力。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方差（variance）&lt;/span&gt;:度量同样大小的训练集的变动所导致的学习性能的变化，刻画了数据扰动所造成的影响。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;噪声（noise）&lt;/span&gt;：表达了在当前的任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习本身的难度。&lt;/p&gt;
&lt;p&gt;泛化误差：     &lt;strong&gt;E(f;D)  = bias&lt;sup&gt;2&lt;/sup&gt;(x) + var(x) + ε&lt;sup&gt;2&lt;/sup&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面的图可以很好的刻画偏差和方差的区别：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171015135910012-824145385.png&quot; alt=&quot;&quot; width=&quot;426&quot; height=&quot;401&quot;/&gt;&lt;/p&gt;
&lt;p&gt;bias描述的是在训练集上的表现，即模型预测值与真实值的差别，简单点说就是如果在训练集上的bias越低那么拟合的越好，相应的模型会更加复杂，会带来过拟合的风险。&lt;/p&gt;
&lt;p&gt;variance则描述的是在测试集上的表现，简单点说也就是在测试集上variance越低越好，相应的模型会更加简单，会导致欠拟合的发生。&lt;/p&gt;
&lt;p&gt;由上可以看到偏差和方差是有冲突的,这个称为偏差-方差窘境（bias-variance dilemma）.下面的图可以反映出这个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1228291/201710/1228291-20171015141028152-539731614.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，在训练集上并不是训练的越好，模型也就越好，关于这个内容后面还会再讲。&lt;/p&gt;
&lt;p&gt;第二章的内容大概就讲这么多，主要讲了模型的评估与选择方面的内容，这个也是为我们之后的学习奠定一个基础，包括：误差分析，评估方法，性能度量，偏差与方差，其实很多东西还可以展开的非常广，可以细细的去品味。本章作业题的答案后续会补充上。&lt;/p&gt;

















</description>
<pubDate>Sun, 15 Oct 2017 06:17:00 +0000</pubDate>
<dc:creator>zutterhao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zutterhao/p/7639196.html</dc:identifier>
</item>
<item>
<title>Mysql 学习之EXPLAIN作用 - 小禾点点</title>
<link>http://www.cnblogs.com/jalja/p/7670712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jalja/p/7670712.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;&lt;span&gt;一、MYSQL的索引&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;索引（Index）:帮助Mysql高效获取数据的一种数据结构。用于提高查找效率，可以比作字典。可以简单理解为排好序的快速查找的数据结构。&lt;br/&gt;索引的作用：便于查询和排序（所以添加索引会影响where 语句与 order by 排序语句）。&lt;br/&gt;在数据之外，数据库还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用数据。这样就可以在这些数据结构上实现高级查找算法。这些数据结构就是索引。&lt;br/&gt;索引本身也很大，不可能全部存储在内存中，所以索引往往以索引文件的形式存储在磁盘上。&lt;br/&gt;我们平时所说的索引，如果没有特别指明，一般都是B树索引。（聚集索引、复合索引、前缀索引、唯一索引默认都是B+树索引），除了B树索引还有哈希索引。&lt;/p&gt;
&lt;p&gt;优点：A、提高数据检索效率，降低数据库的IO成本&lt;br/&gt;B、通过索引列对数据进行排序，降低了数据排序成本，降低了CPU的消耗。&lt;br/&gt;缺点：A、索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引也是占用空间的。&lt;br/&gt;B、对表进行INSERT、UPDATE、DELETE操作时，MYSQL不仅会更新数据，还要保存一下索引文件每次更新添加了索引列字段的相应信息。&lt;br/&gt;在实际的生产环境中我们需要逐步分析，优化建立最优的索引，并要优化我们的查询条件。&lt;/p&gt;
&lt;p&gt;索引的分类：1、单值索引 一个索引只包含一个字段，一个表可以有多个单列索引。&lt;br/&gt;2、唯一索引 索引列的值必须唯一，但允许有空值。&lt;br/&gt;3、复合索引 一个索引包含多个列&lt;br/&gt;一张表建议建立5个之内的索引&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;语法：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建 1、CREATE [UNIQUE] INDEX indexName ON myTable (columnName(length));&lt;br/&gt;         2、ALTER myTable Add [UNIQUE] INDEX [indexName] ON (columnName(length));&lt;br/&gt;删除：DROP INDEX [indexName] ON myTable;&lt;br/&gt;查看： SHOW INDEX FROM table_name\G;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;二、EXPLAIN 的作用&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;EXPLAIN :模拟Mysql优化器是如何执行SQL查询语句的，从而知道Mysql是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; explain &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; tb_user;
&lt;/span&gt;+----+-------------+---------+------+---------------+------+---------+------+------+-------+
| id | select_type | table   | type | possible_keys | key  | key_len | &lt;span&gt;ref&lt;/span&gt;  | rows | Extra |
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
|  &lt;span&gt;1&lt;/span&gt; | SIMPLE      | tb_user | ALL  | NULL          | NULL | NULL    | NULL |    &lt;span&gt;1&lt;/span&gt; | NULL  |
+----+-------------+---------+------+---------------+------+---------+------+------+-------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;(一)id列：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)、id 相同执行顺序由上到下
mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; explain  
    &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; tb_order tb1
    &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; tb_product tb2 &lt;span&gt;ON&lt;/span&gt; tb1.tb_product_id &lt;span&gt;=&lt;/span&gt;&lt;span&gt; tb2.id
    &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;LEFT&lt;/span&gt; &lt;span&gt;JOIN&lt;/span&gt; tb_user tb3 &lt;span&gt;ON&lt;/span&gt; tb1.tb_user_id &lt;span&gt;=&lt;/span&gt;&lt;span&gt; tb3.id;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+--------+---------------+---------+---------+---------------------------+------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; type   &lt;span&gt;|&lt;/span&gt; possible_keys &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref                       &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; Extra &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+--------+---------------+---------+---------+---------------------------+------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; tb1   &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;                      &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; tb2   &lt;span&gt;|&lt;/span&gt; eq_ref &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; product.tb1.tb_product_id &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; tb3   &lt;span&gt;|&lt;/span&gt; eq_ref &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; product.tb1.tb_user_id    &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+--------+---------------+---------+---------+---------------------------+------+-------+&lt;/span&gt;
&lt;span&gt;
(&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)、如果是子查询，id序号会自增，id值越大优先级就越高，越先被执行。
mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; EXPLAIN
    &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tb_product tb1 &lt;span&gt;where&lt;/span&gt; tb1.id &lt;span&gt;=&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt; tb_product_id &lt;span&gt;from&lt;/span&gt;  tb_order tb2 &lt;span&gt;where&lt;/span&gt; id &lt;span&gt;=&lt;/span&gt; tb2.id &lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; type  &lt;span&gt;|&lt;/span&gt; possible_keys &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref   &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; Extra       &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; tb1   &lt;span&gt;|&lt;/span&gt; const &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; const &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;        &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SUBQUERY    &lt;span&gt;|&lt;/span&gt; tb2   &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;   &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------+-------+---------------+---------+---------+-------+------+-------------+&lt;/span&gt;
(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;)、id 相同与不同，同时存在

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt; EXPLAIN 
    &lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;(&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; tb_order tb1 &lt;span&gt;where&lt;/span&gt; tb1.id &lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;) s1,tb_user tb2 &lt;span&gt;where&lt;/span&gt; s1.tb_user_id &lt;span&gt;=&lt;/span&gt;&lt;span&gt; tb2.id;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+------------+--------+---------------+---------+---------+-------+------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt; type   &lt;span&gt;|&lt;/span&gt; possible_keys &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref   &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; Extra &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+------------+--------+---------------+---------+---------+-------+------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;derived2&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; system &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;     &lt;span&gt;|&lt;/span&gt; tb2        &lt;span&gt;|&lt;/span&gt; const  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; const &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; DERIVED     &lt;span&gt;|&lt;/span&gt; tb1        &lt;span&gt;|&lt;/span&gt; const  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; const &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+------------+--------+---------------+---------+---------+-------+------+-------+&lt;/span&gt;
derived2：衍生表   2表示衍生的是id&lt;span&gt;=&lt;/span&gt;2的表 tb1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（二）select_type列：数据读取操作的操作类型&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　1、SIMPLE:简单的select 查询，SQL中不包含子查询或者UNION。&lt;br/&gt;　　2、PRIMARY:查询中包含复杂的子查询部分，最外层查询被标记为PRIMARY&lt;br/&gt;　　3、SUBQUERY:在select 或者WHERE 列表中包含了子查询&lt;br/&gt;　　4、DERIVED:在FROM列表中包含的子查询会被标记为DERIVED(衍生表)，MYSQL会递归执行这些子查询，把结果集放到零时表中。&lt;br/&gt;　　5、UNION:如果第二个SELECT 出现在UNION之后，则被标记位UNION；如果UNION包含在FROM子句的子查询中，则外层SELECT 将被标记为DERIVED&lt;br/&gt;　　6、UNION RESULT:从UNION表获取结果的select&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（三）table列：该行数据是关于哪张表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（四）type列：访问类型  由好到差system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; range &amp;gt; index &amp;gt; ALL&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、system:表只有一条记录(等于系统表),这是const类型的特例，平时业务中不会出现。&lt;br/&gt;　　2、const:通过索引一次查到数据，该类型主要用于比较primary key 或者unique 索引，因为只匹配一行数据，所以很快;如果将主键置于WHERE语句后面，Mysql就能将该查询转换为一个常量。&lt;br/&gt;　　3、eq_ref:唯一索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或者唯一索引扫描。&lt;br/&gt;　　4、ref:非唯一索引扫描，返回匹配某个单独值得所有行，本质上是一种索引访问，它返回所有匹配某个单独值的行，就是说它可能会找到多条符合条件的数据，所以他是查找与扫描的混合体。&lt;br/&gt;　　5、range：只检索给定范围的行，使用一个索引来选着行。key列显示使用了哪个索引。一般在你的WHERE 语句中出现between 、&amp;lt; 、&amp;gt; 、in 等查询，这种给定范围扫描比全表扫描要好。因为他只需要开始于索引的某一点，而结束于另一点，不用扫描全部索引。&lt;br/&gt;　　6、index：FUll Index Scan 扫描遍历索引树(扫描全表的索引，从索引中获取数据)。&lt;br/&gt;　　7、ALL 全表扫描 从磁盘中获取数据 百万级别的数据ALL类型的数据尽量优化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（五）possible_keys列:&lt;/span&gt;&lt;/strong&gt;显示可能应用在这张表的索引，一个或者多个。查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;（六）keys列:&lt;/span&gt;&lt;/strong&gt;实际使用到的索引。如果为NULL，则没有使用索引。查询中如果使用了覆盖索引，则该索引仅出现在key列表中。覆盖索引：select 后的 字段与我们建立索引的字段个数一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（七）ken_len列:&lt;/span&gt;&lt;/strong&gt;表示索引中使用的字节数，可通过该列计算查询中使用的索引长度。在不损失精确性的情况下，长度越短越好。key_len 显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出来的。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;（八）ref列&lt;/span&gt;&lt;/strong&gt;:显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。&lt;br/&gt;&lt;strong&gt;&lt;span&gt;（九）rows列(每张表有多少行被优化器查询)&lt;/span&gt;&lt;/strong&gt;:根据表统计信息及索引选用的情况，大致估算找到所需记录需要读取的行数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（十）Extra列：扩展属性，但是很重要的信息。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;1&lt;/span&gt;&lt;span&gt;、 Using filesort(文件排序)：mysql无法按照表内既定的索引顺序进行读取。
 mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt; order_number &lt;span&gt;from&lt;/span&gt; tb_order &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; order_money;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+----------+------+---------------+------+---------+------+------+----------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; Extra          &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+----------+------+---------------+------+---------+------+------+----------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; tb_order &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using filesort &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+----------+------+---------------+------+---------+------+------+----------------+&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)
说明：order_number是表内的一个唯一索引列，但是order &lt;/span&gt;&lt;span&gt;by&lt;/span&gt;&lt;span&gt; 没有使用该索引列排序，所以mysql使用不得不另起一列进行排序。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、Using &lt;span&gt;temporary&lt;/span&gt;:Mysql使用了临时表保存中间结果，常见于排序order &lt;span&gt;by&lt;/span&gt; 和分组查询 &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt;。

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt; order_number &lt;span&gt;from&lt;/span&gt; tb_order &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; order_money;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+----------+------+---------------+------+---------+------+------+---------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; Extra                           &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+----------+------+---------------+------+---------+------+------+---------------------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; tb_order &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;temporary&lt;/span&gt;; Using filesort &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+----------+------+---------------+------+---------+------+------+---------------------------------+&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;、Using &lt;span&gt;index&lt;/span&gt;&lt;span&gt; 表示相应的select 操作使用了覆盖索引，避免访问了表的数据行，效率不错。
如果同时出现Using &lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt; ，表明索引被用来执行索引键值的查找。
如果没有同时出现using &lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt; 表明索引用来读取数据而非执行查找动作。
mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt; order_number &lt;span&gt;from&lt;/span&gt; tb_order &lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; order_number;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+----------+-------+--------------------+--------------------+---------+------+------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; type  &lt;span&gt;|&lt;/span&gt; possible_keys      &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;                &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; Extra       &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+----------+-------+--------------------+--------------------+---------+------+------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; tb_order &lt;span&gt;|&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; index_order_number &lt;span&gt;|&lt;/span&gt; index_order_number &lt;span&gt;|&lt;/span&gt; &lt;span&gt;99&lt;/span&gt;      &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;index&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+----------+-------+--------------------+--------------------+---------+------+------+-------------+&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;、Using &lt;span&gt;where&lt;/span&gt;&lt;span&gt; 查找
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;、Using &lt;span&gt;join&lt;/span&gt;&lt;span&gt; buffer ：表示当前sql使用了连接缓存。
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;、impossible &lt;span&gt;where&lt;/span&gt; ：&lt;span&gt;where&lt;/span&gt;&lt;span&gt; 字句 总是false ，mysql 无法获取数据行。
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;、&lt;span&gt;select&lt;/span&gt;&lt;span&gt; tables optimized away：
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;、&lt;span&gt;distinct&lt;/span&gt;：
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 下一章：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/jalja/p/7670728.html&quot;&gt;Mysql 学习之EXPLAIN实战&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 15 Oct 2017 05:38:00 +0000</pubDate>
<dc:creator>小禾点点</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jalja/p/7670712.html</dc:identifier>
</item>
<item>
<title>使用Canvas制作时钟动画 - omoc</title>
<link>http://www.cnblogs.com/omoc/p/7670634.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/omoc/p/7670634.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　复习Javascript到Canvas的知识点，看到一个使用Canvas绘制的静态时钟例子，便想将其变成动态显示系统时间的时钟动画。另外再配上数字显示的时钟，一个小的时钟模块的诞生了！目前的界面还比较粗糙，只有简单的界面和动画效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;演示观看地址：&lt;a title=&quot;时钟Demo&quot; href=&quot;http://htmlpreview.github.io/?https://github.com/omocc/Demo/blob/master/%E6%97%B6%E9%92%9Fdemo/clock.html&quot; target=&quot;_blank&quot;&gt;http://htmlpreview.github.io/?https://github.com/omocc/Demo/blob/master/%E6%97%B6%E9%92%9Fdemo/clock.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个时钟包括两个部分，动画圆盘时钟和数字时钟。首先是使用超时调用setTimeout（）方法做一个循环动画的效果以显示时间。先看数字时钟的代码，比较简单，圆盘时钟的做法也是模仿数字时钟做的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; ntimeoutId = setTimeout(ntimeOut,0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ntimeOut() {
    clearTimeout(ntimeoutId);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; now = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hours =&lt;span&gt; now.getHours().toString(),
        minutes &lt;/span&gt;=&lt;span&gt; now.getMinutes().toString(),
        seconds &lt;/span&gt;=&lt;span&gt; now.getSeconds().toString();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; time = hours+&quot; : &quot;+minutes+&quot; : &quot;+&lt;span&gt;seconds;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timediv = document.getElementById(&quot;time&quot;&lt;span&gt;);
    timediv.innerHTML &lt;/span&gt;=&lt;span&gt; time;
    ntimeoutId &lt;/span&gt;= setTimeout(ntimeOut, 1000&lt;span&gt;);
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　1、首先是设定一个超时调用以首次调用方法来显示系统当前时间，时间之所以设置为0，是为了没有延迟地显示时间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、每次循环之前清除前一次的超时调用（为什么要这样做，我也还不清楚？？？可能是为了内存性能相关，注释了以后程序也能正常执行。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3、取得当前系统时间，并按照一定的字符串格式保存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4、为了动态显示在页面中，在Html页面中定义了一个空的div元素，以存放该时间字符串。使用DOM操作将其添加到div元素中即可动态显示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　5、通过不停循环超时调用，就可以动态显示数字时钟了， 同过开发者工具也可以看到div元素里的动态变化。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　接下来就是制作圆盘时钟动画，圆盘和数值的刻画都比较简单，只要使用context.arc（）方法和context.fillText（）方法即可。下面是其源代码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;　　　　 context.beginPath();
        context.restore();
        context.translate(&lt;/span&gt;0,0&lt;span&gt;);
        context.clearRect(&lt;/span&gt;0,0,300,300&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制时钟内外边框&lt;/span&gt;
        context.arc(150,150,149,0,2 * Math.PI,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        context.moveTo(&lt;/span&gt;295,150&lt;span&gt;);
        context.arc(&lt;/span&gt;150,150,145,0,2 * Math.PI,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

        context.font &lt;/span&gt;= &quot;bold 18px Arial&quot;&lt;span&gt;;
        context.textAlign &lt;/span&gt;= &quot;center&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制时钟表盘数值&lt;/span&gt;
        context.fillText(&quot;12&quot;,150,25&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;3&quot;,285,150&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;6&quot;,150,290&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;9&quot;,15,150&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;1&quot;,215,45&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;2&quot;,265,95&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;4&quot;,265,225&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;7&quot;,95,275&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;5&quot;,215,275&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;8&quot;,35,225&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;10&quot;,35,95&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;11&quot;,75,45&lt;span&gt;);

        context.stroke();
        context.closePath();&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;接下来就是指针的绘制了，指针的绘制中参考高程中的做法，使用变换操作context.translate（）方法改变原点，再绘制路径成为指针会方便很多。另一个绘制指针的难点是弧度的计算，当然这就是数学问题了。下面先看源代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;　　　　 //&lt;/span&gt;&lt;span&gt;绘制指针&lt;/span&gt;
&lt;span&gt;        context.save();
        context.translate(&lt;/span&gt;150,150&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;时针&lt;/span&gt;
        context.moveTo(0,0&lt;span&gt;);
        hour(hours);

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; hour(thour) {
            context.save();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newhour = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(thour&amp;gt;12&lt;span&gt;) {
                newhour &lt;/span&gt;= thour-12&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                newhour &lt;/span&gt;=&lt;span&gt; thour;
            }
            context.rotate((&lt;/span&gt;2*Math.PI/12)*newhour);
            context.lineTo(0,-80&lt;span&gt;);
            context.restore();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分针&lt;/span&gt;
        context.moveTo(0,0&lt;span&gt;);
        minute(minutes);

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; minute(tminute) {
            context.save();
            context.rotate((&lt;/span&gt;2*Math.PI/12)*tminute/5&lt;span&gt;);
            context.lineTo(&lt;/span&gt;0,-110&lt;span&gt;);
            context.restore();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;秒针&lt;/span&gt;
        context.moveTo(0,0&lt;span&gt;);
        second(seconds);

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; second(tsecond) {
            context.save();
            context.fillStyle &lt;/span&gt;= &quot;#fff&quot;&lt;span&gt;;
            context.rotate((&lt;/span&gt;2*Math.PI/12)*tsecond/5&lt;span&gt;);
            context.lineTo(&lt;/span&gt;0,-120&lt;span&gt;);
            context.restore();
        }
        
        context.stroke();&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　在绘制指针中，每种指针都使用了函数来改变每次指针绘制的弧度来实现指针转动的动画效果。对于时针，则将二十四小时制转化为十二小时制，每次转动30°即可。分针和秒针则是转为0到11进行转动，简单的数学问题，相信大家都是比我厉害的，当时我还纠结了一阵子。在每个函数中都有使用context.save（）方法和context.restore（）方法，是为了保存和复原初始化时的路径，不然指针都要跑偏啦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所有工作基本准备就绪了，接下来只要将钟盘和指针都放在超时调用中即可，但仍然有些问题需要注意的，比如说钟盘和指针的原点设置不同，要注意使用保存和复原来还原初始化时候的路径，不然钟盘和指针都要跑偏了。另外要注意的是，使用Canvas制作动画，每次的动画循环都是要清空画布重新绘制，不然指针一直转转转，转成一朵花的样子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　完整的圆盘时钟代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;86&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示指针时间&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; drawing = document.getElementById(&quot;drawing&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(drawing.getContext) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; context = drawing.getContext(&quot;2d&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rtimeoutId = setTimeout(roudClock,0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; roudClock() {
        clearTimeout(rtimeoutId);

        context.beginPath();
        context.restore();
        context.translate(&lt;/span&gt;0,0&lt;span&gt;);
        context.clearRect(&lt;/span&gt;0,0,300,300&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制时钟内外边框&lt;/span&gt;
                context.arc(150,150,149,0,2 * Math.PI,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        context.moveTo(&lt;/span&gt;295,150&lt;span&gt;);
        context.arc(&lt;/span&gt;150,150,145,0,2 * Math.PI,&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

        context.font &lt;/span&gt;= &quot;bold 18px Arial&quot;&lt;span&gt;;
        context.textAlign &lt;/span&gt;= &quot;center&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制时钟表盘数值&lt;/span&gt;
                context.fillText(&quot;12&quot;,150,25&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;3&quot;,285,150&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;6&quot;,150,290&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;9&quot;,15,150&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;1&quot;,215,45&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;2&quot;,265,95&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;4&quot;,265,225&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;7&quot;,95,275&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;5&quot;,215,275&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;8&quot;,35,225&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;10&quot;,35,95&lt;span&gt;);
        context.fillText(&lt;/span&gt;&quot;11&quot;,75,45&lt;span&gt;);

        context.stroke();
        context.closePath();
        
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; now = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; hours =&lt;span&gt; now.getHours(),
            minutes &lt;/span&gt;=&lt;span&gt; now.getMinutes(),
            seconds &lt;/span&gt;=&lt;span&gt; now.getSeconds();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制指针&lt;/span&gt;
&lt;span&gt;        context.save();
        context.translate(&lt;/span&gt;150,150&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;时针&lt;/span&gt;
                context.moveTo(0,0&lt;span&gt;);
        hour(hours);

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; hour(thour) {
            context.save();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newhour = 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(thour&amp;gt;12&lt;span&gt;) {
                newhour &lt;/span&gt;= thour-12&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                newhour &lt;/span&gt;=&lt;span&gt; thour;
            }
            context.rotate((&lt;/span&gt;2*Math.PI/12)*newhour);
                        context.lineTo(0,-80&lt;span&gt;);
            context.restore();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分针&lt;/span&gt;
        　　 context.moveTo(0,0&lt;span&gt;);
        minute(minutes);

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; minute(tminute) {
            context.save();
            context.rotate((&lt;/span&gt;2*Math.PI/12)*tminute/5&lt;span&gt;);
            context.lineTo(&lt;/span&gt;0,-110&lt;span&gt;);
            context.restore();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;秒针&lt;/span&gt;
                context.moveTo(0,0&lt;span&gt;);
        second(seconds);

        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; second(tsecond) {
            context.save();
            context.fillStyle &lt;/span&gt;= &quot;#fff&quot;&lt;span&gt;;
            context.rotate((&lt;/span&gt;2*Math.PI/12)*tsecond/5&lt;span&gt;);
            context.lineTo(&lt;/span&gt;0,-120&lt;span&gt;);
            context.restore();
        }
        
        context.stroke();
        context.restore();
        context.translate(&lt;/span&gt;0,0&lt;span&gt;);
        context.save();
        rtimeoutId &lt;/span&gt;= setTimeout(roudClock,1000&lt;span&gt;);
    }    
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;最后总结我在这次Demo的练习中遇到的几点问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1、画布重绘问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在指针动画循环的时候，前一个路径都没有方法清除，造成每一次循环都留下印记。尝试了小范围地使用clearRect（）方法，结果发现只能在范围内清除了表盘和数字的内容，指针依然会留下痕迹。后来通过搜索，得到的答案是使用Canvas制作动画一定是要进行重绘的，在新绘制内容前要清空画布内容，每一次的动画变化都要清空一次。重绘的方法可以参考一下链接，我使用的是clearRect（）方法清空整个画布。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考方法链接：&lt;a href=&quot;http://blog.csdn.net/u010484625/article/details/46046217&quot; target=&quot;_blank&quot;&gt;http://blog.csdn.net/u010484625/article/details/46046217&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2、save（）方法和restore（）方法的使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因为我的钟盘和指针的原点设定不同，所以在进行重绘后，钟盘的原点会改变为指针的原点，因此要利用save（）方法和restore（）方法改变。除了这个地方也有其他一些地方需要用到，适合操作以后改变了设定，但后续操作需要用原设定的情况。注意的是这两个方法只会保存和恢复设定，而不是内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3、translate（）方法的使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　translate（）方法是属于变换操作中的，可改变画布的原点，默认画布的原点在画布的左上角。使用这个方法可以更轻易地绘制指针的路径，当然还有一些其他需要用的地方，我还没有接触到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4、setTimeout（）方法的使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用超时调用是比间歇调用更好的方法，使用超时调用可以模拟间歇调用。通过在超时调用传入的函数中再添加超时调用就可以很好地模仿循环。还可以在函数中根据一些条件限定循环的次数和时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5、对应当前时间，弧度的使用方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这就是数学问题，我在这个问题纠结了好一会儿，没有拐过弯来，明白其中的原理就不是技术上的难题了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　6、对于时间重复取得和重复使用方法的问题&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于代码中还存在有重复代码的情况，我还没有想到更好的方法减少冗余。例如在获取时间上，在两个超时调用中均有重复定义，但若是把他们放在全局中，则没有了动画效果，只是显示加载完成后的那个静态时间。另外的是指针的函数设定中有重复的部分，是否可以合为一个函数方法再进行调用呢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　欢迎大家提出想法，对于不足的地方提出建议，一起来交流。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 15 Oct 2017 04:47:00 +0000</pubDate>
<dc:creator>omoc</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/omoc/p/7670634.html</dc:identifier>
</item>
<item>
<title>JAVA提高四：反射基本应用 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/7668417.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/7668417.html</guid>
<description>&lt;p&gt;&lt;span&gt;在前面一节《http://www.cnblogs.com/pony1223/p/7659210.html》，我们学习了JAVA的反射的相关知识，那么本节我们对前面所学习的知识做一个应用相关的学习。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、利用反射创建集合ArrayList 并添加元素&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们前面学习了那么反射相关的知识，那么我们究竟如何用呢？其实本身反射多于框架的设计,如果不做框架或者底层开发是不会去涉及太多反射的知识，那么假如我们有一个需求为：动态通过配置去创建Collection的集合，该如何去做呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们回顾下集合类相关的知识点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201710/401339-20171014195829730-87609637.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;粗线圈出的Set和List接口是Collection接口派生出的两个子接口，它们分别代表了无序集合和有序集合，阴影部分HashSet和ArrayList是两个主要的实现类，经常使用到的就是这两个。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本知识：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Collection包含了List和Set两大主要分支。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;(01) List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;List的实现类有LinkedList, &lt;strong&gt;ArrayList&lt;/strong&gt;, Vector, Stack。&lt;/p&gt;
&lt;p&gt;********************************************************************************************************************&lt;/p&gt;
&lt;p&gt;LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。&lt;/p&gt;
&lt;p&gt;LinkedList 实现 List 接口，能对它进行队列操作。&lt;/p&gt;
&lt;p&gt;LinkedList 实现 Deque 接口，即能将LinkedList当作双端队列使用。&lt;/p&gt;
&lt;p&gt;LinkedList 实现了Cloneable接口，即覆盖了函数clone()，能克隆。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;LinkedList 实现java.io.Serializable接口，这意味着LinkedList支持序列化，能通过序列化去传输。&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;LinkedList 是非同步的。&lt;br/&gt;********************************************************************************************************************&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;strong&gt;ArrayList 是一个数组队列，相当于动态数组。与Java中的数组相比，它的容量能动态增长。它继承于AbstractList，实现了List, RandomAccess, Cloneable, java.io.Serializable这些接口。&lt;/strong&gt;&lt;br/&gt;ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。&lt;br/&gt;ArrayList 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在ArrayList中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较List的“快速随机访问”和“通过Iterator迭代器访问”的效率。&lt;br/&gt;ArrayList 实现了Cloneable接口，即覆盖了函数clone()，能被克隆。&lt;br/&gt;ArrayList 实现java.io.Serializable接口，这意味着ArrayList支持序列化，能通过序列化去传输。&lt;br/&gt;********************************************************************************************************************&lt;br/&gt;&lt;strong&gt;Vector 是矢量队列，它是JDK1.0版本添加的类。继承于AbstractList，实现了List, RandomAccess, Cloneable这些接口。&lt;/strong&gt;&lt;br/&gt;Vector 继承了AbstractList，实现了List；所以，它是一个队列，支持相关的添加、删除、修改、遍历等功能。&lt;br/&gt;Vector 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在Vector中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。&lt;br/&gt;Vector 实现了Cloneable接口，即实现clone()函数。它能被克隆。&lt;br/&gt;********************************************************************************************************************&lt;br/&gt;&lt;strong&gt;Stack是栈。它的特性是：先进后出(FILO, First In Last Out)。&lt;/strong&gt;&lt;br/&gt;java工具包中的Stack是继承于Vector(矢量队列)的，由于Vector是通过数组实现的，这就意味着，Stack也是通过数组实现的，而非链表。当然，我们也可以将LinkedList当作栈来使用！&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;********************************************************************************************************************&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;区别：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Vector和ArrayList不同，Vector中的操作是线程安全的。&lt;br/&gt;ArrayList与Vector的区别在于:&lt;br/&gt;1在扩展上,arraylist变成(150%+1),Vector变成(200%)。&lt;br/&gt;2Arraylist不是线程安全的,而Vector是线程安全的;&lt;/p&gt;
&lt;p&gt;ArrayList 和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，都允许直接序号索引元素，但是插入数据要设计到数组元素移动等内存操作，所以索引数据快插入数据慢，Vector由于使用了synchronized方法（线程安全）所以性能上比ArrayList要差，LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项的前后项即可，所以插入数度较快！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(02) Set是一个无序不允许有重复元素的集合。&lt;/strong&gt;&lt;br/&gt;Set的实现类有&lt;strong&gt;HastSet&lt;/strong&gt;和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; (03)List 和 Set 的区别是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;List&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;有序的、可重复的、按索引位置排序 （这点类似于数组）&lt;/strong&gt;&lt;br/&gt;实现类&lt;br/&gt;ArrayList 数组实现&lt;br/&gt;1.代表长度可变的数组&lt;br/&gt;2.允许对元素进行快速的随机访问（根据索引进行访问）&lt;br/&gt;3.向ArrayList中插入和删除元素的速度较慢，需要移动大量的元素&lt;br/&gt;LinkedList 双向链表实现&lt;br/&gt;1.插入和删除元素的速度较快（不需要移动元素）&lt;br/&gt;2.随机访问的速度相对较慢，随机访问的含义是根据索引定位特定位置的元素&lt;br/&gt;3.提供addFirst(0 addLast() getFirst() getLast（） removeFirst()和removeLast()方法，使LinkedList可以作为堆栈，队列和双向队列使用&lt;br/&gt;&lt;strong&gt;Set&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;无序的、不可重复的、&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;实现类&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;HashSet 哈希算法实现&lt;/strong&gt;、底层是HashMap实现，用到了key的部分。&lt;br/&gt;1. 按照哈希算法存取集合中的对象，具有很好的存取和查找性能&lt;br/&gt;2. 当向集合中加入一个对象时，Hashset会调用对象的hashCode()方法获得哈希码，然后根据哈希码进一步计算对象在集合中的存放位置&lt;br/&gt;3. 在java.lang.Object中定义了hashCode()和equals()方法，在最原始的Object中定义的equals()方法是按照内存地址比较对象是否相等，因此对于Object而言，如果equals方法的结果为true，则说明两个引用实际上引用相同的对象，这两个引用的哈希码必然也相同&lt;br/&gt;为保证HashSet能够正常工作，要求两个对象用equals()方法比较的结果为true时，他们的哈希码也相同&lt;br/&gt;如果用户定义的类覆盖了Object的equals方法而没有覆盖hashCode方法，会导致当equals方法结果为true时，对象的哈希码并不相同，这样会使hashSet无法正常工作，用户本意是作为同一个对象引用处理，但是由于没有覆盖hashCode()方法，导致哈希码不同，hashSet将作为不同对象处理。&lt;/p&gt;&lt;p&gt;SortedSet&lt;br/&gt;排序的set&lt;br/&gt;实现类&lt;br/&gt;TreeSet,在HashSet的基础上维护了一个双向链表，&lt;br/&gt;1.排序的依据对象实现实现了Comparable接口，或者是构造时传入Comparator比较器。像Integer，Double和String他们自己都实现了Compareble接口&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再回顾了Collection 的集合知识后，我们知道平时我们创建Collection 集合都通过子类如：ArrayList  HashSet 直接通过NEW来创建的.那么现在我们不采用new的方式，因为客户即可能使用ArrayList 也可能是用的HashSet 的，应该是客户端来决定，因此我们采用反射的方式来进行，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study.javaenhance;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Properties;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; study.javaenhance.util.ReflectPoint;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReflectTest2 
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先,为了方便客户端自己定义采用ArrayList,还是HashSet 为此我们定义一个配置文件为config.properties
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.加载读取config.properties&lt;/span&gt;
        InputStream inputstream = ReflectTest2.&lt;span&gt;class&lt;/span&gt;.getResourceAsStream(&quot;config.properties&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.properties 存放读取的值&lt;/span&gt;
        Properties properties = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
        properties.load(inputstream);
        inputstream.close();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.从Properties中获取值 反射进行,加载类&lt;/span&gt;
        Class clazz = Class.forName(properties.getProperty(&quot;className&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.解析类&lt;/span&gt;
        Collection collections =&lt;span&gt; (Collection) clazz.newInstance();
        
        ReflectPoint pt1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ReflectPoint(3,3&lt;span&gt;);
        ReflectPoint pt2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ReflectPoint(5,5&lt;span&gt;);
        ReflectPoint pt3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ReflectPoint(3,3&lt;span&gt;);    
        
        collections.add(pt1);
        collections.add(pt2);
        collections.add(pt3);
        collections.add(pt1);
        
        
        System.out.println(collections.size());
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;config.properties 配置的值为：className=java.util.ArrayList&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;最后输出的结果为4；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们将配置修改为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;config.properties 配置的值为：className=java.util.HashSet&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个时候的结果将取决于ReflectPoint 这个类即添加的这个类是否实现了equals 和 hashcode 方法，如果没有实现，那么按照默认Object中的equals方法来比较结果为false即不是同一个元素，那么pt1 和 pt3 不相等，因此在hashset 不算重复的元素，因此这个时候结果为3，但是如果实现了equals方法和hashcode 方法，那么这个时候，如果实现比较的方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; prime = 31&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; result = 1&lt;span&gt;;
        result &lt;/span&gt;= prime * result +&lt;span&gt; x;
        result &lt;/span&gt;= prime * result +&lt;span&gt; y;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt; ==&lt;span&gt; obj)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getClass() !=&lt;span&gt; obj.getClass())
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ReflectPoint other =&lt;span&gt; (ReflectPoint) obj;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x !=&lt;span&gt; other.x)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (y !=&lt;span&gt; other.y)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;那么这个时候输出的结果为2，可以看见差异性还是有的，那么arrayList hashset 区别是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ArrayList是一组有序的集合，当对象被添加到ArrayList时，对象会先找到第一个空缺的地方，记住，放进去的是对象的引用，不是对象本身，接下来，第二个对象依次在第二个位置增加，如果发现有相同的对象，也是按照顺序放进去，也就是说，在这个有序集合里，每有一个对象就会放入一个引用，可能出现多个引用指向同一个对象的情况，但没有关系.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashSet，当放入对象时，首先查看里面是否有这样一个对象，如果有，则不放，如果没有才会放入，如果真的很想放进去这个对象，除非将已经存在的对象删除。所以，使用ArrayList的返回的size是4，而使用HashSet的时候返回size的值是3，也就是说，使用Hashset的时候，最后一个pt1没有放进去因为已经存在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那下面还有一个问题，pt1和pt3是否相同的，因为具有相同的属性。默认的两个独立的对象，如果我们想让他们相同，必须自己去写equals方法，所以我们覆盖equals方法和hashCode方法.此时返回的长度为2，因为此时pt1和pt3是相同的点，没有被添加到HashSet当中.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;HashSet内部添加元素的时候,因为要对于重复的元素不能添加进来，通常的做法的是：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果想查找一个集合中是否含有某个对象，大概的程序代码怎么写呢？你通常是逐一的取出每个元素与要查找的对象进行比较，当发现某个元素与要查找的对象进行equals方法比较的结果相等时，则停止继续查找并返回肯定的信息，否则，返回否定的信息，如果一个集合中有个很多个元素，比如说有一万个元素进行比较，也效率是非常差劲的。有人发明了一种哈希算法来提高效率，这种方式将集合分为若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每个组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储在某个区域。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashSet的做法是哈希算法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;HashSet就是采用哈希算法存储对象的集合&lt;/strong&gt;，他内部采用对某个数组n进行取余的方法对哈希码进行分组和划分对象的存储区域，Object类中定义了一个HashCode方法返回每个java对象的哈希码，&lt;strong&gt;当从HashSet集合中查找到某个对象时。Java系统首先调用对象的hashCode方法获得该对象的哈希码，然后根据哈希码找到对应的存储区域，最后取出该存储区域的每个元素与该对象进行equals方法的比较，这样不用遍历集合中的所有元素就可以得到结论&lt;/strong&gt;，可见，HashSet集合具有很好的对象检索性能，但是。HashSet集合存储对象的效率相对要低些，因为向HashSet集合中添加对象的时候，首先要计算出来对象的哈希码和根据这个哈希码来确定对象在集合中的存放位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为了保证一个类的实例对象可能在HashSet正常存储，要求这个类的两个实例对象用equals方法比较的结果相等时，他们的哈希码也必须相等。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果一个类的hashcode方法没有遵循上述要求，那么当这个类的两个实例对象用equals方法比较的结果相等时，他们本来应该无法被同时的存储进Set集合中，但是他们因为hash值得不同结果存储进了HashSet集合中，由于他们的hashCode方法的返回值不同，第二个对象首先按照哈希码计算可能会被放进与第一个对象不同的区域中，这样，他就不可能与第一个对象进行equals比较了，也就可能被存储进hashSet集合中了，Object类中的hashCode方法不能满足对象被存入到HashSet中的要求，因为它的返回值是通过对象的内存地址推算出来的，同一个对象在程序运行期间的任何时候返回的哈希码都是始终不变的，所以只要是两个不同的实例对象，即使他们的queals方法比较结果相等，他们默认的hashCode方法的返回值是不同的。只要将例子中使用的ArrayList集合改为使用HashSet集合就可以看到这种错误的效果了。【不要覆写equals 和 hashcode 的时候的效果就是hashset中存放了3个元素,或者覆写了equals而不覆写hashcode的时候效果也是一样的，明明是equals相等的两个元素却方进去了】 因此特别注意：覆写的时候hashcode 和 equals 两个方法要同时覆写.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;非常重要的注意点：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;strong&gt;&lt;span&gt;（1）通常来说，一个类的两个实例对象用equals方法比较的结果相等的时候，他们的哈希码也必须相等，但反之则不成立，即equals方法比较结果不相等的对象可以有相同的哈希码，或者说哈希码相同的两个对象的equals方法比较的结果可以不等，例如，字符串BB和Aa的equals方法比较的结果肯定不相等，但是他们的hashCode方法返回值相等。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;strong&gt;&lt;span&gt;（2）当一个对象被存储到HashSet集合中以后，就不能修改这个对象中的某些参与计算哈希码的字段了，否则，对象修改以后的哈希码与最初存储金集合的哈希码就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从Hash集合中单独的删除当前的对象，从而造成内存泄漏。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;strong&gt;&lt;span&gt;关于第二点我们看一个例子如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先,为了方便客户端自己定义采用ArrayList,还是HashSet 为此我们定义一个配置文件为config.properties
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.加载读取config.properties&lt;/span&gt;
        InputStream inputstream = ReflectTest2.&lt;span&gt;class&lt;/span&gt;.getResourceAsStream(&quot;config.properties&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.properties 存放读取的值&lt;/span&gt;
        Properties properties = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
        properties.load(inputstream);
        inputstream.close();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.从Properties中获取值 反射进行,加载类&lt;/span&gt;
        Class clazz = Class.forName(properties.getProperty(&quot;className&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.解析类&lt;/span&gt;
        Collection collections =&lt;span&gt; (Collection) clazz.newInstance();
        
        ReflectPoint pt1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ReflectPoint(3,3&lt;span&gt;);
        ReflectPoint pt2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ReflectPoint(5,5&lt;span&gt;);
        ReflectPoint pt3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ReflectPoint(3,3&lt;span&gt;);    
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ReflectPoint类重写了hashCode方法---算法依据x,y。&lt;/span&gt;
        collections.add(pt1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;放入&lt;/span&gt;
        collections.add(pt2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;放入&lt;/span&gt;
        collections.add(pt3);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hashCode比较后，和pt1在同一区域；比较equals发现相同，舍弃pt3这个引用&lt;/span&gt;
        collections.add(pt1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hashCode比较后，和pt1在同一区域；比较equals发现相同，舍弃&lt;/span&gt;
        System.out.println(&quot;初始大小,  size= &quot;+collections.size());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2   最终放入collections 了2个元素&lt;/span&gt;
&lt;span&gt;        collections.remove(pt1);
        System.out.println(&lt;/span&gt;&quot;删除一个元素后大小,  size= &quot;+collections.size());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除了pt1 大小为1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p0&quot;&gt; &lt;/p&gt;
&lt;p&gt;上面是我们期望的结果，但是如果我们不遵循第二条，即在删除前加上下面这一个语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
pt1.y=4;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改参与进行hashCode运算的 y值，则pt3此时的hashCode和上面放入collections时的hashCode是不相等的。
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这将导致Java系统无法在collections中检索到。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那么将会出现在删除后的大小结果还是2而不是1;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先,为了方便客户端自己定义采用ArrayList,还是HashSet 为此我们定义一个配置文件为config.properties
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.加载读取config.properties&lt;/span&gt;
        InputStream inputstream = ReflectTest2.&lt;span&gt;class&lt;/span&gt;.getResourceAsStream(&quot;config.properties&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.properties 存放读取的值&lt;/span&gt;
        Properties properties = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
        properties.load(inputstream);
        inputstream.close();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.从Properties中获取值 反射进行,加载类&lt;/span&gt;
        Class clazz = Class.forName(properties.getProperty(&quot;className&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4.解析类&lt;/span&gt;
        Collection collections =&lt;span&gt; (Collection) clazz.newInstance();
        
        ReflectPoint pt1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ReflectPoint(3,3&lt;span&gt;);
        ReflectPoint pt2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ReflectPoint(5,5&lt;span&gt;);
        ReflectPoint pt3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ReflectPoint(3,3&lt;span&gt;);    
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ReflectPoint类重写了hashCode方法---算法依据x,y。&lt;/span&gt;
        collections.add(pt1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;放入&lt;/span&gt;
        collections.add(pt2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;放入&lt;/span&gt;
        collections.add(pt3);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hashCode比较后，和pt1在同一区域；比较equals发现相同，舍弃pt3这个引用&lt;/span&gt;
        collections.add(pt1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;hashCode比较后，和pt1在同一区域；比较equals发现相同，舍弃&lt;/span&gt;
        System.out.println(&quot;初始大小,  size= &quot;+collections.size());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2   最终放入collections 了2个元素&lt;/span&gt;
        pt1.y = 4&lt;span&gt;;
        collections.remove(pt1);
        System.out.println(&lt;/span&gt;&quot;删除一个元素后大小,  size= &quot;+collections.size());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除了pt1 大小却还是2 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;上面的代码，将会发生内存泄漏，因为认为删除掉了其实没有删除掉。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原则上：只有类的实例对象要给采用哈希算法进行存储和检索时，这个类才需要按照要求覆盖hashCode方法。即使程序可能暂时不会用到当前类的hashCode方法，但是为它提供一个hashCode方法也不会有什么不好，没准以后什么时候又用到这个方法了，所以通常要求hashCode方法和equals方法一并被同时覆盖。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 如果还是无法理解 hashcode 和 equals 可以看一下这篇文章：一次性搞清楚equals和hashCode,&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、用类加载器的方式管理资源和配置文件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面一小节，讲到用反射实现创建ArrayList的时候有一个配置文件叫config.properties，那么它是怎么配加载的呢？这一节我们来学习一下： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.加载读取config.properties&lt;/span&gt;
        
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 1.采用的是Class 中的getResourceAsStream方法去加载配置文件,此时默认配置文件的路就是和类名的class在同一级目录
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;InputStream inputstream = ReflectTest2.class.getResourceAsStream(&quot;config.properties&quot;);&lt;/span&gt;
        
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 2.使用类加载器加载配置文件.类加载器默认都是从classPath的根目录去读取文件，而config.properties不在根目录下
         * 我们之需要加载classpath的路径就可以了,注意不要在前面加上&quot;/&quot;,本身类加载器默认就是从根目录下加载
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;InputStream inputstream = ReflectTest2.class.getClassLoader().getResourceAsStream(&quot;study/javaenhance/config.properties&quot;);&lt;/span&gt;
        
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 3.使用Class 提供的加载配置文件的方法因为其默认是从当前class文件的路径查找的是一个相对路径，也可以从指定其从绝对路径查找
         * 这个时候需要在前面加上/
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        
        InputStream inputstream &lt;/span&gt;= ReflectTest2.&lt;span&gt;class&lt;/span&gt;.getResourceAsStream(&quot;/study/javaenhance/config.properties&quot;&lt;span&gt;);
        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面三种方式都是可以的，加载资源文件和加载类一样，都是采用的类加载器进行的加载.上面说的对classpath 进行加载时指的你自己配置的classpath路径，可以查看项目目录下面的.classpath文件中看到，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/401339/201710/401339-20171015110548824-38744618.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、内省以及内省操作JAVABean&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 上面我们讲解了反射的基本应用，下面我们在来看一个JDK的反射应用，内省操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.什么内省?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内省(Introspector)是Java 语言对JavaBean类属性、事件的一种缺省处理方法。例如类 A 中有属性 name, 那我们可以通过 getName,setName 来得到其值或者设置新的值。通过 getName/setName 来访问 name 属性，这就是默认的规则.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Java 中提供了一套 API 用来访问某个属性的 getter/setter 方法，通过这些 API 可以使你不需要了解这个规则（但你最好还是要搞清楚），这些 API 存放于包 java.beans 中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2).直接通过属性的描述器java.beans.PropertyDescriptor类，来访问属性的getter/setter 方法;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study.javaenhance;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.beans.PropertyDescriptor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; study.javaenhance.util.ReflectPoint;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IntroSpectorTest 
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception 
    {
        
        ReflectPoint pt1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ReflectPoint(3,5&lt;span&gt;);
        
        System.out.println(pt1.getX());
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 那么上面的getX 就可以得到返回的值,那么其底层是怎么实现的呢？同样setX 为什么可以实现呢？
         * 这就是JDK 底层的内省操作，用于可以访问到javaBean对象的get 和 set 方法.
         * 思考：如果我们要访问getX 方法,不采用JDK API 底层内省帮我们实现的getX方法，我们该怎么做，那么我们肯定会用到反射
         * 反射的应用之一：JDK 的内省操作
         * 要通过反射获取到getX方法,那么需要经过&quot;x&quot;--&amp;gt;&quot;X&quot;--&amp;gt;&quot;getX&quot;--&amp;gt;MethodGetX  这样一个流程，那么这个流程比较麻烦
         * 于是可以利用内省中的PropertyDescriptor 类帮我们实现.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;get实现 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.通过要获取的set get方法的属性 和 Class 来得到PropertyDescriptor&lt;/span&gt;
        PropertyDescriptor propertyDescriptor = &lt;span&gt;new&lt;/span&gt; PropertyDescriptor(&quot;x&quot;,ReflectPoint.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.通过PropertyDescriptor 中的方法来获取set 和 get 方法&lt;/span&gt;
        Method methodGetX =&lt;span&gt; propertyDescriptor.getReadMethod();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.invoke 调用,因为get方法没有参数所以传入空&lt;/span&gt;
        Object object = methodGetX.invoke(pt1, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以看到我们没有直接用对象的get方法也获取到了其值,其实这就是JDK底部内省的默认实现方法内省操作&lt;/span&gt;
&lt;span&gt;        System.out.println(object);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;set的实现&lt;/span&gt;
        PropertyDescriptor propertyDescriptor2 = &lt;span&gt;new&lt;/span&gt; PropertyDescriptor(&quot;x&quot;,ReflectPoint.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        Method methodSetX &lt;/span&gt;=&lt;span&gt; propertyDescriptor.getWriteMethod();
        methodSetX.invoke(pt1,&lt;/span&gt;7&lt;span&gt;);
        System.out.println(pt1.getX());
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3).通过类 Introspector 来获取某个对象的 BeanInfo 信息，然后通过 BeanInfo 来获取属性的描述器（ PropertyDescriptor ），通过这个属性描述器就可以获取某个属性对应的 getter/setter 方法，然后我们就可以通过反射机制来调用这些方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study.javaenhance;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.beans.BeanInfo;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.beans.IntrospectionException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.beans.Introspector;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.beans.PropertyDescriptor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationTargetException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; study.javaenhance.util.ReflectPoint;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IntroSpectorTest 
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception 
    {
        
        ReflectPoint pt1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ReflectPoint(3,5&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(pt1.getX());&lt;/span&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 那么上面的getX 就可以得到返回的值,那么其底层是怎么实现的呢？同样setX 为什么可以实现呢？
         * 这就是JDK 底层的内省操作，用于可以访问到javaBean对象的get 和 set 方法.
         * 思考：如果我们要访问getX 方法,不采用JDK API 底层内省帮我们实现的getX方法，我们该怎么做，那么我们肯定会用到反射
         * 反射的应用之一：JDK 的内省操作
         * 要通过反射获取到getX方法,那么需要经过&quot;x&quot;--&amp;gt;&quot;X&quot;--&amp;gt;&quot;getX&quot;--&amp;gt;MethodGetX  这样一个流程，那么这个流程比较麻烦
         * 于是可以利用内省中的PropertyDescriptor 类帮我们实现.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;get实现 &lt;/span&gt;
        String propertyName = &quot;x&quot;&lt;span&gt;;
        Object retValue &lt;/span&gt;=&lt;span&gt; getProperty(pt1, propertyName);
        System.out.println(retValue);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;set的实现&lt;/span&gt;
        Object value = 7&lt;span&gt;;
        setProperty(pt1, propertyName, value);
        System.out.println(pt1.getX());
        
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setProperty(Object pt1, String propertyName,
            Object value) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IntrospectionException,
            IllegalAccessException, InvocationTargetException
    {
        
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;PropertyDescriptor propertyDescriptor2 = new PropertyDescriptor(propertyName,pt1.getClass());&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        BeanInfo beanInfo &lt;/span&gt;=&lt;span&gt; Introspector.getBeanInfo(pt1.getClass());
        PropertyDescriptor[] pd &lt;/span&gt;=&lt;span&gt; beanInfo.getPropertyDescriptors();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (PropertyDescriptor propertyDescriptor : pd)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(propertyDescriptor.getName().equals(propertyName))
            {
                Method methodSetX &lt;/span&gt;=&lt;span&gt; propertyDescriptor.getWriteMethod();
                methodSetX.invoke(pt1,value);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object getProperty(Object pt1,
            String propertyName) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IntrospectionException,
            IllegalAccessException, InvocationTargetException 
    {
        BeanInfo beanInfo &lt;/span&gt;=&lt;span&gt; Introspector.getBeanInfo(pt1.getClass());
        PropertyDescriptor[] pd &lt;/span&gt;=&lt;span&gt; beanInfo.getPropertyDescriptors();
        Object retVal &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (PropertyDescriptor propertyDescriptor : pd)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(propertyDescriptor.getName().equals(propertyName))
            {
                Method methodGetX &lt;/span&gt;=&lt;span&gt; propertyDescriptor.getReadMethod();
                retVal &lt;/span&gt;=&lt;span&gt; methodGetX.invoke(pt1);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; retVal;
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;//1.通过要获取的set get方法的属性 和 Class 来得到PropertyDescriptor
        PropertyDescriptor propertyDescriptor = new PropertyDescriptor(propertyName,pt1.getClass());
        //2.通过PropertyDescriptor 中的方法来获取set 和 get 方法
        Method methodGetX = propertyDescriptor.getReadMethod();
        //3.invoke 调用,因为get方法没有参数所以传入空
        return methodGetX.invoke(pt1, null);
        //可以看到我们没有直接用对象的get方法也获取到了其值,其实这就是JDK底部内省的默认实现方法内省操作
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.我们又通常把javabean的实例对象称之为值对象 （Value Object）,因为这些bean中通常只有一些信息字段和存储方法，没有功能性方法。一个JavaBean类可以不当JavaBean用，而当成普通类 用。JavaBean实际就是一种规范，当一个类满足这个规范，这个类就能被其它特定的类调用。一个类被当作javaBean使用时，JavaBean的 属性是根据方法名推断出来的，它根本看不到java类内部的成员变量(javabean的成员变量通常都是私有private的)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.除了反射用到的类需要引入外，内省需要引入的类如下所示，它们都属于java.beans包中的类，自己写程序的时候也不能忘了引入相应的包或者类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;import java.beans.BeanInfo;&lt;br/&gt;import java.beans.IntrospectionException;&lt;br/&gt;import java.beans.Introspector;&lt;br/&gt;import java.beans.PropertyDescriptor;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、BeanUtils工具包操作JavaBean&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;下面讲解一些开源的工具类Beanutils,需要额外下载的，commons-beanutils.jar，要使用它还必须导入commons-logging.jar包，不然会出异常；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;案例一：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {     
        Point point &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point(2, 5&lt;span&gt;);     
        String proName &lt;/span&gt;= &quot;x&quot;&lt;span&gt;;     
        BeanUtils.setProperty(point, proName, &lt;/span&gt;&quot;8&quot;&lt;span&gt;);     
        System.out.println(point.getX());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 8     &lt;/span&gt;
        System.out.println(BeanUtils.getProperty(point, proName));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 8     &lt;/span&gt;
        System.out.println(BeanUtils.getProperty(point, proName).getClass().getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt; java.lang.String     &lt;/span&gt;
&lt;span&gt;        
        BeanUtils.setProperty(point, proName, &lt;/span&gt;8&lt;span&gt;);     
       System.out.println(BeanUtils.getProperty(point, proName).getClass().getName());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; java.lang.String     &lt;/span&gt;
&lt;span&gt;   }     
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们看到虽然属性x的类型是Integer，但是我们设置的时候无论是Integer还是String，BeanUtils的内部都是当成String来处理的。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;案例二：BeanUtils支持javabean属性的级联操作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {     
    Point point &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point(2, 5);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在point中加一个属性 private Date birth = new Date();并产生setter/getter方法     &lt;/span&gt;
    String proName = &quot;birth&quot;&lt;span&gt;;     
    Date date&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();     
    date.setTime(&lt;/span&gt;10000&lt;span&gt;);     
    BeanUtils.setProperty(point, proName, date);     
    System.out.println(BeanUtils.getProperty(point, proName));     
         
    BeanUtils.setProperty(point, &lt;/span&gt;&quot;birth.time&quot;, 10000&lt;span&gt;);     
    System.out.println(BeanUtils.getProperty(point, &lt;/span&gt;&quot;birth.time&quot;));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10000     &lt;/span&gt;
&lt;span&gt;}     
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;之所以可以 BeanUtils.setProperty(point, &quot;birth.time&quot;, 10000);这样写，那是因为Date类中有getTime()和setTime()方法，即Date类中相当于有time这个属性。   &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;案例三：BeanUtils和PropertyUtils对比&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {     
    Point point &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point(2, 5&lt;span&gt;);     
    String proName &lt;/span&gt;= &quot;x&quot;&lt;span&gt;;     
    BeanUtils.setProperty(point, proName, &lt;/span&gt;&quot;8&quot;&lt;span&gt;);     
    System.out.println(BeanUtils.getProperty(point, proName));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8     &lt;/span&gt;
    System.out.println(BeanUtils.getProperty(point, proName).getClass().getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java.lang.String     
         
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; PropertyUtils.setProperty(point, proName, &quot;8&quot;);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;exception:argument type mismatch     &lt;/span&gt;
    PropertyUtils.setProperty(point, proName, 8&lt;span&gt;);     
    System.out.println(PropertyUtils.getProperty(point, proName));&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;8     &lt;/span&gt;
    System.out.println(PropertyUtils.getProperty(point, proName).getClass().getName());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;java.lang.Integer     &lt;/span&gt;
&lt;span&gt;}     
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;BeanUtils它以字符串的形式对javabean进行转换，而PropertyUtils是以原本的类型对javabean进行操作。如果类型不对，就会有argument type mismatch异常。  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;理解了相应的原理，那些现成的工具用起来就会更舒服，如Beanutils与 PropertyUtils工具。这两个工具设置属性的时候一个主要区别是PropertyUtils.getPropety方法获得的属性值的类型为该 属性本来的类型，而BeanUtils.getProperty则是将该属性的值转换成字符串后才返回。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考资料：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;张孝祥Java基础增强&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 15 Oct 2017 04:16:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/7668417.html</dc:identifier>
</item>
<item>
<title>[js高手之路]打造通用的匀速运动框架 - ghostwu</title>
<link>http://www.cnblogs.com/ghostwu/p/7670033.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ghostwu/p/7670033.html</guid>
<description>&lt;p&gt;
&lt;textarea class=&quot;playcode&quot;&gt;
&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
        img {
            border: none;
            opacity: 0.3;
            filter: alpha(opacity:30);
            position: absolute;
            left: 200px;
        }

        #box {
            width: 150px;
            height: 300px;
            background: red;
            position: absolute;
            left: -150px;
            top: 50px;
        }

        #box div {
            width: 28px;
            height: 100px;
            position: absolute;
            right: -28px;
            top: 100px;
            background: green;
        }
    &amp;lt;/style&amp;gt;
    &amp;lt;script&amp;gt;
        window.onload = function () {
            var oImg = document.getElementById(&quot;img&quot;),
                oBox = document.getElementById(&quot;box&quot;),
                timer = null;

            oImg.onmouseover = function () {
                animate(this, 'opacity', 100, 10);
            }
            oImg.onmouseout = function () {
                animate(this, 'opacity', 30, -10);
            }

            oBox.onmouseover = function () {
                animate(this, 'left', 0, 10);
            }

            oBox.onmouseout = function () {
                animate(this, 'left', -150, -10);
            }

            function animate(obj, attr, target, speed) {
                clearInterval(timer);
                var cur = 0;
                timer = setInterval(function () {
                    if (attr == 'opacity') {
                        cur = css(obj, 'opacity') * 100;
                    } else {
                        cur = parseInt(css(obj, attr));
                    }

                    if (cur == target) {
                        clearInterval(timer);
                    } else {
                        if (attr == 'opacity') {
                            obj.style.opacity = ( cur + speed ) / 100;
                            obj.style.filter = &quot;alpha(opacity:&quot; + (cur + speed) + &quot;)&quot;;
                        } else {
                            obj.style[attr] = cur + speed + &quot;px&quot;;
                        }
                    }
                }, 30);
            }

            function css(obj, attr) {
                if (obj.currentStyle) {
                    return obj.currentStyle[attr];
                } else {
                    return getComputedStyle(obj, false)[attr];
                }
            }
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div id=&quot;box&quot;&amp;gt;
    &amp;lt;div&amp;gt;分享到&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;img src=&quot;http://images2017.cnblogs.com/blog/253192/201710/253192-20171015095909480-1867777993.png&quot; alt=&quot;&quot; id=&quot;img&quot;/&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/textarea&gt;&lt;br/&gt;&lt;button class=&quot;start&quot;&gt;run code&lt;/button&gt;&lt;/p&gt;&lt;p&gt;移动到 分享到，然后迅速又移动到图片上， 这个时候你会发现 分享到 停下来了，这就不符合逻辑了! 按道理来说，鼠标移动到图片上，相当于触发了 “分享到” 的mouseout( 鼠标移出事件 )，那么  &quot;分享到&quot; 这个时候要隐藏，并不是停止。 为什么会这样呢？因为这两个运动共享了一个定时器，当鼠标移动到图片上，开启定时器的时候，把“分享到”的定时器给停了。那么再做多物体运动的时候，我们就要把定时器拆分，每个对象都要有一个定时器，怎么做呢？ 非常简单，不要定义一个简单的timer变量，我们只要把timer加在obj对象上，那么每个对象都有一个timer属性，就达到定时器的分离效果了&lt;/p&gt;&lt;div readability=&quot;107&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('571051e4-6a62-4459-8847-bab7b133f9ac')&quot; readability=&quot;43&quot;&gt;&lt;img id=&quot;code_img_closed_571051e4-6a62-4459-8847-bab7b133f9ac&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_571051e4-6a62-4459-8847-bab7b133f9ac&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('571051e4-6a62-4459-8847-bab7b133f9ac',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_571051e4-6a62-4459-8847-bab7b133f9ac&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;!doctype html&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;html lang=&quot;en&quot;&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &amp;lt;head&amp;gt;
&lt;span&gt; 4&lt;/span&gt;     &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
&lt;span&gt; 5&lt;/span&gt;     &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;style&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        img {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            border: none;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             opacity: 0.3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             filter: alpha(opacity:30&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            position: absolute;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            left: 200px;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        #box {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            width: 150px;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            height: 300px;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            background: red;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            position: absolute;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             left: -&lt;span&gt;150px;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            top: 50px;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        #box div {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            width: 28px;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            height: 100px;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            position: absolute;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             right: -&lt;span&gt;28px;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            top: 100px;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            background: green;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &amp;lt;/style&amp;gt;
&lt;span&gt;33&lt;/span&gt;     &amp;lt;script&amp;gt;
&lt;span&gt;34&lt;/span&gt;         window.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; oImg = document.getElementById(&quot;img&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 oBox = document.getElementById(&quot;box&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;             oImg.onmouseover = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 animate(&lt;span&gt;this&lt;/span&gt;, 'opacity', 100, 10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             oImg.onmouseout = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 animate(&lt;span&gt;this&lt;/span&gt;, 'opacity', 30, -10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;             oBox.onmouseover = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 animate(&lt;span&gt;this&lt;/span&gt;, 'left', 0, 10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;             oBox.onmouseout = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                 animate(&lt;span&gt;this&lt;/span&gt;, 'left', -150, -10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;function&lt;/span&gt;&lt;span&gt; animate(obj, attr, target, speed) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                clearInterval(obj.timer);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; cur = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 obj.timer = setInterval(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (attr == 'opacity'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                         cur = css(obj, 'opacity') * 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                         cur =&lt;span&gt; parseInt(css(obj, attr));
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (cur ==&lt;span&gt; target) {
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;                        clearInterval(obj.timer);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;                     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (attr == 'opacity'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;                             obj.style.opacity = ( cur + speed ) / 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                             obj.style.filter = &quot;alpha(opacity:&quot; + (cur + speed) + &quot;)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;                             obj.style[attr] = cur + speed + &quot;px&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;                 }, 30&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt;             &lt;span&gt;function&lt;/span&gt;&lt;span&gt; css(obj, attr) {
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (obj.currentStyle) {
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj.currentStyle[attr];
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; getComputedStyle(obj, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)[attr];
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;     &amp;lt;/script&amp;gt;
&lt;span&gt;85&lt;/span&gt; &amp;lt;/head&amp;gt;
&lt;span&gt;86&lt;/span&gt; &amp;lt;body&amp;gt;
&lt;span&gt;87&lt;/span&gt; &amp;lt;div id=&quot;box&quot;&amp;gt;
&lt;span&gt;88&lt;/span&gt;     &amp;lt;div&amp;gt;分享到&amp;lt;/div&amp;gt;
&lt;span&gt;89&lt;/span&gt; &amp;lt;/div&amp;gt;
&lt;span&gt;90&lt;/span&gt; &amp;lt;img src=&quot;./img/h4.jpg&quot; alt=&quot;&quot; id=&quot;img&quot;/&amp;gt;
&lt;span&gt;91&lt;/span&gt; &amp;lt;/body&amp;gt;
&lt;span&gt;92&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;至此，我们就完成了多物体运动与不同样式的修改&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、让animate函数支持多个样式同时改变&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;p&gt;oBox.onmouseover = function(){&lt;br/&gt;　　animate( this, { &quot;width&quot; : 500, &quot;height&quot; : 400 }, 10 );&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;oBox是一个div元素，animate各参数的意思：&lt;/p&gt;
&lt;p&gt;this: 当前div元素&lt;/p&gt;
&lt;p&gt;{width : 500, &quot;height&quot; : 400 } : 把宽度变成500, 高度变成400，这两个样式要在同一时间完成，&lt;/p&gt;
&lt;p&gt;10: 样式每次在原来的基础上变化10（如width初始值200--&amp;gt; 210, 220, 230.....）&lt;/p&gt;
&lt;p&gt;完整的同时运动变化 代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c4451de2-d2d4-4b1d-b80d-86f41eb6c987')&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_c4451de2-d2d4-4b1d-b80d-86f41eb6c987&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c4451de2-d2d4-4b1d-b80d-86f41eb6c987&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c4451de2-d2d4-4b1d-b80d-86f41eb6c987',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c4451de2-d2d4-4b1d-b80d-86f41eb6c987&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;!doctype html&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;html lang=&quot;en&quot;&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &amp;lt;head&amp;gt;
&lt;span&gt; 4&lt;/span&gt;     &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
&lt;span&gt; 5&lt;/span&gt;     &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;style&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    div {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        width: 200px;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        height: 200px;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        background: red;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &amp;lt;/style&amp;gt;
&lt;span&gt;13&lt;/span&gt;     &amp;lt;script&amp;gt;
&lt;span&gt;14&lt;/span&gt;         window.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; oBox = document.getElementById(&quot;box&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             oBox.onmouseover = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;                animate( this, { &quot;width&quot; : 500, &quot;height&quot; : 500 }, 10 );&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 animate( &lt;span&gt;this&lt;/span&gt;, { &quot;width&quot; : 500, &quot;height&quot; : 400 }, 10&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;function&lt;/span&gt;&lt;span&gt; animate(obj, attr, speed) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                clearInterval(obj.timer);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; cur = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 obj.timer = setInterval(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; attr ) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (key == 'opacity'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                             cur = css(obj, 'opacity') * 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                             cur =&lt;span&gt; parseInt(css(obj, key));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; target =&lt;span&gt; attr[key];
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (cur ==&lt;span&gt; target) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                            clearInterval(obj.timer);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; (key == 'opacity'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                                 obj.style.opacity = ( cur + speed ) / 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                                 obj.style.filter = &quot;alpha(opacity:&quot; + (cur + speed) + &quot;)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                                 obj.style[key] = cur + speed + &quot;px&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 }, 30&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;function&lt;/span&gt;&lt;span&gt; css(obj, attr) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (obj.currentStyle) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj.currentStyle[attr];
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; getComputedStyle(obj, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)[attr];
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     &amp;lt;/script&amp;gt;
&lt;span&gt;55&lt;/span&gt; &amp;lt;/head&amp;gt;
&lt;span&gt;56&lt;/span&gt; &amp;lt;body&amp;gt;
&lt;span&gt;57&lt;/span&gt;     &amp;lt;div id=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;span&gt;58&lt;/span&gt; &amp;lt;/body&amp;gt;
&lt;span&gt;59&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;请自行展开这段代码，这段代码能够同时运动，但是有一个问题：&lt;/p&gt;
&lt;p&gt;div的初始宽度与高度（ width : 200, height : 200）&lt;/p&gt;
&lt;p&gt;变化步长一样( 10 )&lt;/p&gt;
&lt;p&gt;变化时间一样( 每30毫秒变化一次 )&lt;/p&gt;
&lt;p&gt;目标( width: 500, height : 400 )&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你能想到什么问题吗？( 两个人在同一起跑线上，速度一样， 时间一样，但是要同时到达不同的目标，一个500, 一个400 )&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答案是很明显的，肯定是目标近的( height : 400 )那个先到达，然后把对象上的定时器关了，另一个目标更远的( width: 500 )肯定到达不了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可以在这句代码下面，输出当前的值和目标值：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;var target = attr[key];&lt;/p&gt;
&lt;p&gt;console.log( key, cur, target );&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;输出来的结果是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/253192/201710/253192-20171015103200246-1405749340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/253192/201710/253192-20171015103219809-662622549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 从上图可以看出，height已经达到了400px，但是width停在了410px,为什么不是400px ? 因为width = 400的时候， 就是( cur == 500 ) 相当于( 400 == 500 ) 不成立，所以执行了else语句，width = cur + 10 = 400 + 10 = 410，然后height到达400px停止了定时器，所以width停在了410px.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么我们怎么解决这个问题呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实也好办，就是height = 400的时候 不要把定时器关了，应该等width = 500的时候再关闭定时器，不就在同一时间，完成了同时到达目标的效果吗？&lt;/p&gt;
&lt;p&gt;修改后的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('49b3b686-82df-4475-bc4a-5f71f466c1ec')&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_49b3b686-82df-4475-bc4a-5f71f466c1ec&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_49b3b686-82df-4475-bc4a-5f71f466c1ec&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('49b3b686-82df-4475-bc4a-5f71f466c1ec',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_49b3b686-82df-4475-bc4a-5f71f466c1ec&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;!doctype html&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;html lang=&quot;en&quot;&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &amp;lt;head&amp;gt;
&lt;span&gt; 4&lt;/span&gt;     &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
&lt;span&gt; 5&lt;/span&gt;     &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;style&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    div {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        width: 200px;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        height: 200px;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        background: red;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &amp;lt;/style&amp;gt;
&lt;span&gt;13&lt;/span&gt;     &amp;lt;script&amp;gt;
&lt;span&gt;14&lt;/span&gt;         window.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; oBox = document.getElementById(&quot;box&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             oBox.onmouseover = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 animate( &lt;span&gt;this&lt;/span&gt;, { &quot;width&quot; : 500, &quot;height&quot; : 400 }, 10&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;function&lt;/span&gt;&lt;span&gt; animate(obj, attr, speed) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                clearInterval(obj.timer);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; cur = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 obj.timer = setInterval(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; bFlag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; ( &lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; attr ) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (key == 'opacity'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                             cur = css(obj, 'opacity') * 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                             cur =&lt;span&gt; parseInt(css(obj, key));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; target =&lt;span&gt; attr[key];
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (cur !=&lt;span&gt; target) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                             bFlag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; (key == 'opacity'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                                 obj.style.opacity = ( cur + speed ) / 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                                 obj.style.filter = &quot;alpha(opacity:&quot; + (cur + speed) + &quot;)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                                 obj.style[key] = cur + speed + &quot;px&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( bFlag ) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                        clearInterval( obj.timer );
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 }, 30&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;function&lt;/span&gt;&lt;span&gt; css(obj, attr) {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (obj.currentStyle) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj.currentStyle[attr];
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; getComputedStyle(obj, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)[attr];
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     &amp;lt;/script&amp;gt;
&lt;span&gt;57&lt;/span&gt; &amp;lt;/head&amp;gt;
&lt;span&gt;58&lt;/span&gt; &amp;lt;body&amp;gt;
&lt;span&gt;59&lt;/span&gt;     &amp;lt;div id=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;span&gt;60&lt;/span&gt; &amp;lt;/body&amp;gt;
&lt;span&gt;61&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;声明一个变量，每次变化完一次( width, height )样式 把bFlag = true， 只要在for循环中有一个没有到达目标，bFlag的值都是false，这样就不会关闭定时器。当两个都到达目标，才关闭定时器.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、顺序运动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 如样式变化，按顺序来，不是同时变化， 如：&lt;/p&gt;
&lt;p&gt;oBox.onmouseover = function(){&lt;br/&gt;//回调函数： 把函数当做参数传递给另一个函数&lt;br/&gt;　　animate( this, { 'width' : 500 }, 10, function(){&lt;br/&gt;　　　　animate( this, { 'height' : 500 }, 10 );&lt;br/&gt;　　} );&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;当把width变成500px的时候，如果传递了回调函数， 再接着执行回调函数里面的运动&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改后的完整代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7498707d-8319-4b59-9a01-503e506fa629')&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_7498707d-8319-4b59-9a01-503e506fa629&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7498707d-8319-4b59-9a01-503e506fa629&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7498707d-8319-4b59-9a01-503e506fa629',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7498707d-8319-4b59-9a01-503e506fa629&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;!DOCTYPE html&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;html&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &amp;lt;head lang=&quot;en&quot;&amp;gt;
&lt;span&gt; 4&lt;/span&gt;     &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
&lt;span&gt; 5&lt;/span&gt;     &amp;lt;title&amp;gt;通用的匀速运动框架 - by ghostwu&amp;lt;/title&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;style&amp;gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        div {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            width: 200px;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            height: 200px;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            background: red;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &amp;lt;/style&amp;gt;
&lt;span&gt;13&lt;/span&gt;     &amp;lt;script&amp;gt;
&lt;span&gt;14&lt;/span&gt;         window.onload = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; oBox = document.getElementById(&quot;box&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             oBox.onmouseover = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;回调函数： 把函数当做参数传递给另一个函数&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 animate( &lt;span&gt;this&lt;/span&gt;, { 'width' : 500 }, 10, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     animate( &lt;span&gt;this&lt;/span&gt;, { 'height' : 500 }, 10&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                } );
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;function&lt;/span&gt;&lt;span&gt; animate(obj, attr, speed, fn ) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                clearInterval(obj.timer);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; cur = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 obj.timer = setInterval(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; bFlag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; attr) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (key == 'opacity'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                             cur = css(obj, 'opacity') * 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                             cur =&lt;span&gt; parseInt(css(obj, key));
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; target =&lt;span&gt; attr[key];
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (cur !=&lt;span&gt; target) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                             bFlag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; (key == 'opacity'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                                 obj.style.opacity = ( cur + speed ) / 100&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                                 obj.style.filter = &quot;alpha(opacity:&quot; + (cur + speed) + &quot;)&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                                 obj.style[key] = cur + speed + &quot;px&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (bFlag) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                        clearInterval(obj.timer);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                         fn &amp;amp;&amp;amp;&lt;span&gt; fn.call( obj );
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                 }, 30&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;function&lt;/span&gt;&lt;span&gt; css(obj, attr) {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (obj.currentStyle) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj.currentStyle[attr];
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; getComputedStyle(obj, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)[attr];
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     &amp;lt;/script&amp;gt;
&lt;span&gt;63&lt;/span&gt; &amp;lt;/head&amp;gt;
&lt;span&gt;64&lt;/span&gt; &amp;lt;body&amp;gt;
&lt;span&gt;65&lt;/span&gt; &amp;lt;div id=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;span&gt;66&lt;/span&gt; &amp;lt;/body&amp;gt;
&lt;span&gt;67&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;/div&gt;</description>
<pubDate>Sun, 15 Oct 2017 02:56:00 +0000</pubDate>
<dc:creator>ghostwu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ghostwu/p/7670033.html</dc:identifier>
</item>
</channel>
</rss>