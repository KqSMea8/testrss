<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>第21天 常用模块二 - 沉沦的罚</title>
<link>http://www.cnblogs.com/huwentao/p/9803809.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huwentao/p/9803809.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;介绍的模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;pickle
shelve
json
xml&lt;br/&gt;configparser&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 人生三问&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;span readability=&quot;6&quot;&gt;&lt;strong&gt;序列化是什么&lt;/strong&gt;&lt;br/&gt;　　序列化就是将内存中数据格式转换成中间对象，存储到硬盘上面或者是传输到网络上面。
　　反序列化就是将硬盘或者网络中传输的中间对象转换成内存中数据格式的过程。&lt;p&gt;&lt;strong&gt;为什么要有序列化&lt;/strong&gt;&lt;br/&gt;1. 为了持久化存储文件&lt;br/&gt;　　数据是为了使用的，当我们的电脑断电之后数据就丢失是一件让人无法忍受的事情，因此我们要存储文件，存储的&lt;br/&gt;方式有两种，一种就是自己打开文件写入文件，一种就是使用模块给我们存储文件。　&lt;br/&gt;2. 为了跨平台进行交互&lt;br/&gt;　　之前我们在写atm程序的时候，为了持久保存信息都是自己通过open打开文件，然后将我们自己的数据转换成字符串的形式&lt;br/&gt;写入文件中，当我们需要的时候重新按照一定的格式翻译成我们想要的样子展现给我们。这样做不仅麻烦，而且跨平台性很差，因为&lt;br/&gt;无论我们把数据传给谁，我们都要告诉对方我这个数据是怎么存储的，你要怎么去获取，可能对方就算是获取了你的数据，也不一定&lt;br/&gt;用它的语言去得到想要的值，或者说需要花费很长的时间去解析你的数据才能真正得到想要的数据。&lt;br/&gt;　　为了解决这样的问题，有了序列化。&lt;br/&gt;　　一天，有一个人告诉大家，以后你们都不要随便的存储数据了，都按照我的格式来存储，也都按照我的格式来解析好了，因此&lt;br/&gt;网络上就出现了各式各样的序列化操作方法。归根结底就是一种通用的标准来来存储数据，方便其他人进行解析的。&lt;br/&gt;&lt;strong&gt;怎么使用序列化&lt;/strong&gt;&lt;br/&gt;　　序列化的方法有很多种，python中自带的有pickle, shelve模块，通用的模块有xml和json。接下来我来详细的&lt;br/&gt;介绍一下怎么使用这几个模块。 &lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;模块一：pickel&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;方法1： dumps和loads&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pickle
user &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 32&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 序列化  将内存中的格式转换成字节流之后存储到文件中&lt;/span&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a.kle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
    f.write(pickle.dumps(user))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反序列化 将文件中的字节流读取到内存转换成想要的格式&lt;/span&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a.kle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
    res &lt;/span&gt;=&lt;span&gt; pickle.loads(f.read())
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(res)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法2： dump和load&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; dump和load封装了文件的write和read方法&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 使得模块使用起来更加的方便&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 序列化&lt;/span&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
    pickle.dump(user, f)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反序列化&lt;/span&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(pickle.load(f))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;模块二：shevel&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; shelve   
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; shelve只有一个open函数&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 打开文件，文件可以存在也可以不存在，&lt;/span&gt;
f = shelve.open(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shelve.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, writeback=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在关闭之前可读可写参数writeback=True代表的是否可以进行修改&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; f['user'] = {'name': 'hu'}&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(f[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
f[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;通用的模块&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;模块三：json&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
json是什么？&lt;br/&gt;json是一种轻量级的数据交换语言。简单清晰的层次结构使得它更易于人们的阅读以及机器的解析。能够有效的提高网络传输速率。
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
js中的数据类型和python中数据类型的一一转换关系

js中的数据类型                python中的数据类型
{}                            dict
[]                            list
int/float                     int/float
string&quot;&quot;双引号                str
true/false                    True/False
null                          None


json格式的语法规范：
    最外层通常是一个字典或者列表
    字符串要用双引号
    你可以在里面套用任意多的层次
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法一：dumps, loads&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 和pickle的使用方法是一样的，如果是dumps和loads要通过f.write和f.readfang方法辅助&lt;br/&gt;import&lt;/span&gt;&lt;span&gt; json
user &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;hu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 123&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 序列化&lt;/span&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
    f.write(json.dumps(user))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 反序列化&lt;/span&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(json.loads(f.read()))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法二：dump, load&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
    json.dump(user, f)

with open(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(json.load(f))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;模块四：xml&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;xml是什么
    xml是一种可扩展的标记语言，它制定了一种文本内容的书写规范，使得计算机能够很轻松的识别这些数据。用于多个平台之间&lt;br/&gt;的数据交换。和json类似。

xml语法标准&lt;br/&gt;　　1. xml的每一个标签必须有一个结束标签&lt;br/&gt;　　2. 标签可以嵌套使用&lt;br/&gt;　　3. 所有的属性必须有值&lt;br/&gt;　　4. 所有的值必须是加上双引号    &lt;br/&gt;　　5. 一个标签中可以同时表示起始和结束标签 eg:&amp;lt;百度百科词条/&amp;gt;&lt;br/&gt;eg:标签是由&lt;br/&gt;　　&amp;lt;a&amp;gt;&lt;br/&gt;　　　　&amp;lt;b name=&quot;hu&quot;&amp;gt;&lt;br/&gt;　　　　&amp;lt;b/&amp;gt;&lt;br/&gt;　　&amp;lt;a/&amp;gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
xml.etree.ElementTree as ET
tree = ET.parse('b.xml')
root = tree.getroot()
tree的方法：
步骤一：获得根标签
    parse     解析一个xml文档获得一个对象
    getroot   根据获得得对象获得当前xml文档的跟标签
步骤二：根据根标签找子标签
    iter      全xml文档去寻找标签
    find      找到当前层的一个标签
    findall   找到当前层的所有标签
    getchildren   获得当前标签的儿子标签
步骤三：找到子标签更改标签的内容：   
    text       标签文本，必须是叶子节点
    attrib     属性值
    set()      设置属性
步骤四：删除该标签
    remove     删除当前节点
步骤五：添加标签
    创建节点：
        year2 = ET.Element('year2')
        # 设置节点的text
        year2.text = '新年'
        # 设置节点的属性
        year2.attrib = {'updated': 'yes'}
        
步骤六：一系列操作完成之后写入文件：
    tree.write() 
    ET.dump()  把xml对象转换成一个文本   
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;案例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_351d1363-f728-4223-8cdf-0bf11ce0e1ab&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_351d1363-f728-4223-8cdf-0bf11ce0e1ab&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_351d1363-f728-4223-8cdf-0bf11ce0e1ab&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
&amp;lt;data&amp;gt;
    &amp;lt;country name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Liechtenstein&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;rank updated=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;2&amp;lt;/rank&amp;gt;
        &amp;lt;year&amp;gt;2008&amp;lt;/year&amp;gt;
        &amp;lt;gdppc&amp;gt;141100&amp;lt;/gdppc&amp;gt;
        &amp;lt;neighbor name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Austria&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; direction=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
        &amp;lt;neighbor name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Switzerland&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; direction=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;W&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;/country&amp;gt;
    &amp;lt;country name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Singapore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;rank updated=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;5&amp;lt;/rank&amp;gt;
        &amp;lt;year&amp;gt;2011&amp;lt;/year&amp;gt;
        &amp;lt;gdppc&amp;gt;59900&amp;lt;/gdppc&amp;gt;
        &amp;lt;neighbor name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Malaysia&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; direction=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;N&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;/country&amp;gt;
    &amp;lt;country name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Panama&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;rank updated=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;69&amp;lt;/rank&amp;gt;
        &amp;lt;year&amp;gt;2011&amp;lt;/year&amp;gt;
        &amp;lt;gdppc&amp;gt;13600&amp;lt;/gdppc&amp;gt;
        &amp;lt;neighbor name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Costa Rica&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; direction=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;W&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
        &amp;lt;neighbor name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Colombia&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; direction=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;/country&amp;gt;
&amp;lt;/data&amp;gt;&lt;span&gt;

xml数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;xml文件内容&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;方法一：parse获得根标签&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xml.etree.ElementTree as ET
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解析xml文档为一颗树，如果此时报错，说明xml文档有问题，到xml格式化网站进行格式化就可以了&lt;/span&gt;
tree = ET.parse(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b.xml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据一棵树先得到树根（也就是根标签）&lt;/span&gt;
root = tree.getroot()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法二：遍历当前一层标签&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181163/201810/1181163-20181017165903395-134124521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 遍历xml文档&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; child &lt;span&gt;in&lt;/span&gt;&lt;span&gt; root:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;=====》&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, child.tag, child.attrib, child.attrib[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; for i in child:&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     print(i.tag, i.attrib, i.text)&lt;/span&gt;
&lt;span&gt;    
结果:
&lt;/span&gt;=====》 country {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Liechtenstein&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;} Liechtenstein
&lt;/span&gt;=====》 country {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Singapore&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;} Singapore
&lt;/span&gt;=====》 country {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Panama&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;} Panama
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;方法三：iter全文档查找当前标签&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# iter方法代表全文档查看标签名为year的节点，然后循环遍历&lt;br/&gt;for&lt;/span&gt; node &lt;span&gt;in&lt;/span&gt; root.iter(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获得当前节点的标签名，属性和文本&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(node.tag, node.attrib, node.text)
    
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 结果：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; year {} 2008&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; year {} 2011&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; year {} 2011&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法四：修改节点的值以及添加属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; node &lt;span&gt;in&lt;/span&gt; root.iter(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把年加一&lt;/span&gt;
    new_year = int(node.text) + 1
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 然后重新赋值给当前节点&lt;/span&gt;
    node.text =&lt;span&gt; str(new_year)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 给节点node设置了两个属性值，updatted='yes', 'version' = 1.0&lt;/span&gt;
    node.set(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;updated&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    node.set(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把这棵树重新写入文件中&lt;/span&gt;
tree.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b.xml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法五：删除节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; # rank的值如果大于50，就删除当前country节点&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; # 查找当前层内的所有country节点&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; for country in root.findall('country'):&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     # 查抄当前country节点下的rank节点并返回他的值&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     rank = int(country.find('rank').text)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     # 如果rank的值大于50， 则删除&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     if rank &amp;gt; 50:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;         root.remove(country)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法六：添加节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; country &lt;span&gt;in&lt;/span&gt; root.findall(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;country&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; year &lt;span&gt;in&lt;/span&gt; country.findall(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果大于2000则添加节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; int(year.text) &amp;gt; 2000&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个节点，tag = 'year2'&lt;/span&gt;
            year2 = ET.Element(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;year2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置节点的text&lt;/span&gt;
            year2.text = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;新年&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置节点的属性&lt;/span&gt;
            year2.attrib = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;updated&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把创建好的节点加入&lt;/span&gt;
&lt;span&gt;            country.append(year2)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 然后写入xml文件中            &lt;/span&gt;
tree.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b.xml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法七：创建一个xml文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过Element创建一个节点&lt;/span&gt;
new_xml = ET.Element(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;namelist&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过SubElement创建子节点&lt;/span&gt;
name = ET.SubElement(new_xml, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, attrib={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;enrolled&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})
age &lt;/span&gt;= ET.SubElement(new_xml, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, attrib={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;checked&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})
sex &lt;/span&gt;= ET.SubElement(new_xml, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
sex.text &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过Element创建一个节点&lt;/span&gt;
name2 = ET.SubElement(new_xml, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, attrib={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;enrolled&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})
age &lt;/span&gt;= ET.SubElement(new_xml, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, attrib={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;enrolled&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;no&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})
age.text &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成文档对象&lt;/span&gt;
et =&lt;span&gt; ET.ElementTree(new_xml)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把生成的文档对象写入到text文件中&lt;/span&gt;
et.write(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text.xml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, xml_declaration=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印生成的格式对象&lt;/span&gt;
ET.dump(new_xml)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;模块五：configparser&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
配置文件解析模块
配置文件的格式：
    1. 分区section
    2. 选项option
    eg: 下面的格式有两个分区有是三个选项
        [user_list]  # 以[]包含的就是分区
            username = hu   # key=value形式的是选项   
            password = 123
        [db]
            file_path = 'C://user'
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
config = configparser.ConfigParser()
config.read('')
查看：
1. 查section
    config.sections()
2. 查options
    config.items()
    config.options()
    config.get('section', 'k1')
    config.getint('section', 'k1')
    config.getfloat('section', 'k1')
    config.getboolean('section', 'k1')

删除：
1. 删除section
    config.remove_section()
2. 删除option
    config.remove_option()

添加：
1. 添加section
    config.add_section()
2. 添加option
    config.set()

写入：
    config.write()
&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;案例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;配置文件内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_474abd19-06c0-4c0b-b17f-755de45bc0e4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_474abd19-06c0-4c0b-b17f-755de45bc0e4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_474abd19-06c0-4c0b-b17f-755de45bc0e4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注释1&lt;/span&gt;
&lt;span&gt;; 注释2

[section1]
k1 &lt;/span&gt;=&lt;span&gt; v1
k2:v2
user&lt;/span&gt;=&lt;span&gt;egon
age&lt;/span&gt;=18&lt;span&gt;
is_admin&lt;/span&gt;=&lt;span&gt;true
salary&lt;/span&gt;=31&lt;span&gt;

[section2]
k1 &lt;/span&gt;= v1
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;conf.cfg&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;查看方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
# config = configparser.ConfigParser().read(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conf.cfg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

config &lt;/span&gt;=&lt;span&gt; configparser.ConfigParser()
config.read(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conf.cfg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

# 查
print(config.sections())
print(config.items(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;section1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
print(config.options(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;section1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
print(config.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;section1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
print(config.getint(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;section1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
print(config.getfloat(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;section1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
# print(config.getboolean(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;section1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;is_admin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

# 改
# config.remove_section(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;section2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  # 删除的是整个分区
config.remove_option(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;section2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
print(config.has_section(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;section2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
print(config.has_option(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;section2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sje&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
# config.add_section(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
config.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
config.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
config.write(open(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;conf.cfg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 17 Oct 2018 15:29:00 +0000</pubDate>
<dc:creator>沉沦的罚</dc:creator>
<og:description>介绍的模块 人生三问 模块一：pickel 方法1： dumps和loads 方法2： dump和load 模块二：shevel 通用的模块 模块三：json 方法一：dumps, loads 方法二</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huwentao/p/9803809.html</dc:identifier>
</item>
<item>
<title>详解C#委托和事件（二） - Minotauros</title>
<link>http://www.cnblogs.com/minotauros/p/9806229.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minotauros/p/9806229.html</guid>
<description>&lt;p&gt;　　一、当我们使用关键字delegate声明一个自定义委托类型时，实际上是声明了一个该名称的类类型，继承自抽象类System.MulticastDelegate，还包含实例方法Invoke、BeginInvoke、EndInvoke：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; MyDelegate();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/839833/201810/839833-20181017182753667-1949993034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中的构造函数中第二个参数是native int类型的，这个是什么呢？我们接着看：&lt;/p&gt;
&lt;p&gt;　　我们知道在C#中任何方法都可以直接赋值给签名一致的委托实例，这个过程看似并不合理，按理来说C#中不支持直接获取函数的指针，其实这里是由编译器进行了取址操作，查看IL代码可知：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　MyDelegate myDelegate = myObj.MyFunc;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/839833/201810/839833-20181017184430357-1715186993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到由编译器为我们进行了构建委托实例的过程，而且这里调用了ldftn命令将实例方法MyFunc()的native int类型的非托管指针推到栈中，从而将该方法的指针传到委托的构造函数中；&lt;/p&gt;
&lt;p&gt;　　由于上面的构造函数存在C#中不支持的函数指针类型void()，所以不能在运行时使用Activator类中的方法创建委托实例，但在委托基类Delegate中存在静态方法CreateDelegate()调用非托管代码用于动态创建委托实例，命名空间System.Reflection中的方法信息类MethodInfo的实例方法CreateDelegate()也提供了类似的方式以在运行时动态构建委托实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    Type delegateType = &lt;span&gt;typeof&lt;/span&gt;(MyDelegate);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里以可访问到的委托类型举例&lt;/span&gt;
    Delegate @delegate = Delegate.CreateDelegate(delegateType, myObj, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyFunc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@delegate = typeof(MyClass).GetMethod(&quot;MyFunc&quot;).CreateDelegate(delegateType, myObj);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加其它委托实例&lt;/span&gt;
    @delegate =&lt;span&gt; Delegate.Combine(@delegate, otherDelegate);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用委托&lt;/span&gt;
&lt;span&gt;    @delegate.DynamicInvoke();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当指定的委托类型可访问时，可以将委托实例显式转换为指定的委托类型后使用()或Invoke()正常调用
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;MyDelegate myDelegate = @delegate as MyDelegate;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;myDelegate();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对委托实例或方法的+、+=操作实际上也是调用基类Delegate中的静态方法Combine()并将合成后的委托强制转换为原类型后返回，-、-=操作则是调用静态方法Remove()；&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/839833/201810/839833-20181017225333874-761076689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　二、委托的异步调用：通过委托类型的实例方法BeginInvoke开启子线程并在该子线程中执行委托实例中的方法，以此种方式调用的委托实例中有且只能有一个方法，如果包含多个方法，会抛出异常ArgumentException：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　myDelegate.BeginInvoke(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其中第一个参数为AsyncCallback类型的回调函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果需要异步调用一个委托实例中方法列表中的所有方法，需要先获取方法列表，再依次进行异步调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　Delegate[] delegates =&lt;span&gt; myDelegate.GetInvocationList();
　　&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; delegates.Length; i++&lt;span&gt;)
　　{
　　　　(delegates[i] &lt;/span&gt;&lt;span&gt;as&lt;/span&gt; MyDelegate).BeginInvoke(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
　　}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　三、当调用委托时，如果方法列表中某个方法内引发异常且未在该方法体内捕获时，该异常将传递给委托的调用方，并且不再调用方法列表中的后面的方法，因此在方法体内捕获异常显得尤为重要；&lt;/p&gt;
&lt;p&gt;　　四、泛型中的委托：自定义泛型委托（Generic Delegate），将类型参数用作参数列表或返回值的类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　&lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; MyDelegate&amp;lt;T&amp;gt;(T obj); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明具有一个类型参数的泛型委托，参数列表中有一个参数&lt;/span&gt;
　　&lt;span&gt;void&lt;/span&gt; MyGenericFunc&amp;lt;T&amp;gt;(T obj) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明一个泛型方法，参数列表中有一个参数&lt;/span&gt;
&lt;span&gt;　　{
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do…&lt;/span&gt;
&lt;span&gt;　　}
　　&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MyFunc(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; str)
　　{
　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do…&lt;/span&gt;
&lt;span&gt;　　}
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明泛型委托的实例，指定类型参数为string类型，此时可匹配的方法签名为void myFunc(string str)&lt;/span&gt;
　　MyDelegate&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; myDelegate;
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;赋值一个指定类型参数为string的泛型方法&lt;/span&gt;
　　myDelegate = MyGenericFunc&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;;
　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加一个参数列表为string类型的具体方法&lt;/span&gt;
　　myDelegate += MyFunc;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　※泛型委托同泛型类一样，需要在实例化时指定类型参数的类型；&lt;/p&gt;
&lt;p&gt;　　※泛型委托的实例同具体委托的实例一样，只需要方法的参数列表和返回值类型相同即可进行匹配，因此不管目标方法是指定了符合要求类型的泛型方法还是具体方法都可以进行匹配；&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“推荐”按钮，您的认可是我写作的最大动力！&lt;/p&gt;
&lt;p&gt;作者：&lt;a title=&quot;Minotauros&quot; href=&quot;https://www.cnblogs.com/minotauros/&quot; target=&quot;_blank&quot;&gt;Minotauros&lt;/a&gt;&lt;br/&gt;出处：&lt;a title=&quot;https://www.cnblogs.com/minotauros/&quot; href=&quot;https://www.cnblogs.com/minotauros/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/minotauros/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。&lt;/p&gt;

</description>
<pubDate>Wed, 17 Oct 2018 14:57:00 +0000</pubDate>
<dc:creator>Minotauros</dc:creator>
<og:description>一、当我们使用关键字delegate声明一个自定义委托类型时，实际上是声明了一个该名称的类类型，继承自抽象类System.MulticastDelegate，还包含实例方法Invoke、BeginIn</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minotauros/p/9806229.html</dc:identifier>
</item>
<item>
<title>Spring入门学习笔记（4）——JDBC的使用 - NinWoo</title>
<link>http://www.cnblogs.com/NinWoo/p/9807730.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NinWoo/p/9807730.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;spring-jdbc框架概览&quot;&gt;Spring JDBC框架概览&lt;/h2&gt;
&lt;p&gt;使用传统的JDBC连接数据库，需要编写不必要的代码来处理异常、打开和关闭数据库连接等变得非常麻烦。然而，Spring JDBC Framework从打开连接、准备和执行SQL语句、处理异常、处理事务以及最后关闭连接开始，负责所有低级别的细节。&lt;/p&gt;
&lt;p&gt;因此，您需要做的就是定义连接参数并指定要执行的SQL语句，并在从数据库获取数据的同时为每个迭代执行所需的工作。&lt;/p&gt;
&lt;p&gt;Spring JDBC提供了几种方法和相应不同的类来与数据库进行接口。我将采用经典且最流行的方法来使用框架的JdbcTemplate类。这是管理所有数据库通信和异常处理的中心框架类。&lt;/p&gt;
&lt;h3 id=&quot;jdbctemplate类&quot;&gt;JdbcTemplate类&lt;/h3&gt;
&lt;p&gt;JDBC模板类执行SQL查询、更新语句、存储过程调用、对结果集执行迭代，并提取返回的参数值。它还捕获JDBC异常，并将其转换为org.springframework.dao中定义的通用的、信息更丰富的包。&lt;/p&gt;
&lt;p&gt;一旦配置好，JdbcTemplate类的实例就是线程安全的。因此，您可以配置JdbcTemplate的一个实例，然后将这个共享引用安全地注入多个DAOs。&lt;/p&gt;
&lt;p&gt;在使用JDBC模板类时，一个常见的做法是在Spring配置文件中配置一个数据源，然后将这个共享数据源bean注入到DAO类中，然后在数据源的setter中创建JdbcTemplate。&lt;/p&gt;
&lt;h3 id=&quot;配置数据源&quot;&gt;配置数据源&lt;/h3&gt;
&lt;p&gt;让我们在数据库测试中创建一个数据库表Student。我们假设您正在使用MySQL数据库，如果您使用任何其他数据库，那么您可以相应地更改DDL和SQL查询。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE Student(
   ID   INT NOT NULL AUTO_INCREMENT,
   NAME VARCHAR(20) NOT NULL,
   AGE  INT NOT NULL,
   PRIMARY KEY (ID)
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在需要为JDBC模板提供一个DataSource,以便它可以进行配置获取数据库权限：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id = &quot;dataSource&quot; 
   class = &quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&amp;gt;
   &amp;lt;property name = &quot;driverClassName&quot; value = &quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
   &amp;lt;property name = &quot;url&quot; value = &quot;jdbc:mysql://localhost:3306/TEST&quot;/&amp;gt;
   &amp;lt;property name = &quot;username&quot; value = &quot;root&quot;/&amp;gt;
   &amp;lt;property name = &quot;password&quot; value = &quot;password&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数据访问对象data-access-objectdao&quot;&gt;数据访问对象（Data Access Object,DAO)&lt;/h3&gt;
&lt;p&gt;DAO表示数据访问对象，通常用于数据库交互。DAOs的存在是为了提供一种向数据库读写数据的方法，它们应该通过应用程序的其他部分访问它们的接口来公开此功能。&lt;/p&gt;
&lt;p&gt;Spring中的DAO支持使得以一致的方式使用JDBC、Hibernate、JPA或JDO等数据访问技术变得很容易。&lt;/p&gt;
&lt;h3 id=&quot;执行sql命令&quot;&gt;执行SQL命令&lt;/h3&gt;
&lt;p&gt;让我们看看如何使用SQL和JDBCTemplate对象对数据库表执行CRUD(创建、读取、更新和删除)操作。&lt;/p&gt;
&lt;p&gt;org.springframework.jdbc.core.JdbcTemplate是JDBC核心包中的中心类。它简化了JDBC的使用，有助于避免常见错误。它执行核心JDBC工作流，让应用程序代码提供SQL并提取结果。这个类执行SQL查询或更新，在resultset上发起迭代，捕获JDBC异常，并将它们转换为org.springframework.dao中定义的更通用的、更有用的异常。&lt;/p&gt;
&lt;p&gt;注：JdbcTemplate是线程安全的，关于线程安全，将会在后续的文章中加以介绍。&lt;/p&gt;
&lt;p&gt;下面介绍使用到的方法，完整信息见&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html&quot;&gt;Spring JdbcTemplate API Reference&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;example&quot;&gt;Example&lt;/h4&gt;
&lt;p&gt;以下项目我使用Maven进行构建，创建Maven项目，更新pom.xml文件为以下内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;top.ninwoo.spring&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;build-demo&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;!-- Spring依赖 --&amp;gt;
        &amp;lt;!-- 1.Spring核心依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.1.7.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-beans&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.1.7.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.1.7.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- 2.Spring dao依赖 --&amp;gt;
        &amp;lt;!-- spring-jdbc包括了一些如jdbcTemplate的工具类 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.1.7.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-tx&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.1.7.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- 3.Spring web依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.1.7.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.1.7.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- 4.Spring test依赖：方便做单元测试和集成测试 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;6.0.6&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;StudentDAO.java : 定义Student数据接口&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public interface StudentDAO {
   /** 
      * This is the method to be used to initialize
      * database resources ie. connection.
   */
   public void setDataSource(DataSource ds);
   
   /** 
      * This is the method to be used to create
      * a record in the Student table.
   */
   public void create(String name, Integer age);
   
   /** 
      * This is the method to be used to list down
      * a record from the Student table corresponding
      * to a passed student id.
   */
   public Student getStudent(Integer id);
   
   /** 
      * This is the method to be used to list down
      * all the records from the Student table.
   */
   public List&amp;lt;Student&amp;gt; listStudents();
   
   /** 
      * This is the method to be used to delete
      * a record from the Student table corresponding
      * to a passed student id.
   */
   public void delete(Integer id);
   
   /** 
      * This is the method to be used to update
      * a record into the Student table.
   */
   public void update(Integer id, Integer age);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Student.java ： Student类&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Student {
   private Integer age;
   private String name;
   private Integer id;

   public void setAge(Integer age) {
      this.age = age;
   }
   public Integer getAge() {
      return age;
   }
   public void setName(String name) {
      this.name = name;
   }
   public String getName() {
      return name;
   }
   public void setId(Integer id) {
      this.id = id;
   }
   public Integer getId() {
      return id;
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;StudentMapper.java ： 将数据库条目映射到Student对象,关于RowMapper接口的介绍将在文末进行补充。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class StudentMapper implements RowMapper&amp;lt;Student&amp;gt; {
   public Student mapRow(ResultSet rs, int rowNum) throws SQLException {
      Student student = new Student();
      student.setId(rs.getInt(&quot;id&quot;));
      student.setName(rs.getString(&quot;name&quot;));
      student.setAge(rs.getInt(&quot;age&quot;));
      
      return student;
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个函数接口，因此可以用作lambda表达式或方法引用的赋值目标。&lt;/p&gt;
&lt;p&gt;RowMapper必须实现mapRow方法来映射ResultSet中的每一行数据。这个方法不应该调用ResultSet上的next();它只应该映射当前行的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Nullable
T mapRow(java.sql.ResultSet rs,
                   int rowNum)
            throws java.sql.SQLException&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Parameters:
rs - the ResultSet to map (pre-initialized for the current row)
rowNum - the number of the current row
Returns:
the result object for the current row (may be null)
Throws:
java.sql.SQLException - if a SQLException is encountered getting column values (that is, there's no need to catch SQLException)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;StudentJDBCTemplate.java ： Student数据接口的具体实现&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class StudentJDBCTemplate implements StudentDAO {
   private DataSource dataSource;
   private JdbcTemplate jdbcTemplateObject;
   
   public void setDataSource(DataSource dataSource) {
      this.dataSource = dataSource;
      this.jdbcTemplateObject = new JdbcTemplate(dataSource);
   }
   public void create(String name, Integer age) {
      String SQL = &quot;insert into Student (name, age) values (?, ?)&quot;;
      jdbcTemplateObject.update( SQL, name, age);
      System.out.println(&quot;Created Record Name = &quot; + name + &quot; Age = &quot; + age);
      return;
   }
   public Student getStudent(Integer id) {
      String SQL = &quot;select * from Student where id = ?&quot;;
      Student student = jdbcTemplateObject.queryForObject(SQL, 
         new Object[]{id}, new StudentMapper());
      
      return student;
   }
   public List&amp;lt;Student&amp;gt; listStudents() {
      String SQL = &quot;select * from Student&quot;;
      List &amp;lt;Student&amp;gt; students = jdbcTemplateObject.query(SQL, new StudentMapper());
      return students;
   }
   public void delete(Integer id) {
      String SQL = &quot;delete from Student where id = ?&quot;;
      jdbcTemplateObject.update(SQL, id);
      System.out.println(&quot;Deleted Record with ID = &quot; + id );
      return;
   }
   public void update(Integer id, Integer age){
      String SQL = &quot;update Student set age = ? where id = ?&quot;;
      jdbcTemplateObject.update(SQL, age, id);
      System.out.println(&quot;Updated Record with ID = &quot; + id );
      return;
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造函数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JdbcTemplate()&lt;/li&gt;
&lt;li&gt;JdbcTemplate(javax.sql.DataSource dataSource)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;update:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public int update(java.lang.String sql,
                  @Nullable
                  java.lang.Object... args)
           throws DataAccessException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;queryForObject&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;T&amp;gt; T queryForObject(java.lang.String sql,
                               java.lang.Object[] args,
                               RowMapper&amp;lt;T&amp;gt; rowMapper)
                        throws DataAccessException&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;MainApp.java ： 主函数&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import java.util.List;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.tutorialspoint.StudentJDBCTemplate;

public class MainApp {
   public static void main(String[] args) {
      ApplicationContext context = new ClassPathXmlApplicationContext(&quot;Beans.xml&quot;);

      StudentJDBCTemplate studentJDBCTemplate = 
         (StudentJDBCTemplate)context.getBean(&quot;studentJDBCTemplate&quot;);
      
      System.out.println(&quot;------Records Creation--------&quot; );
      studentJDBCTemplate.create(&quot;Zara&quot;, 11);
      studentJDBCTemplate.create(&quot;Nuha&quot;, 2);
      studentJDBCTemplate.create(&quot;Ayan&quot;, 15);

      System.out.println(&quot;------Listing Multiple Records--------&quot; );
      List&amp;lt;Student&amp;gt; students = studentJDBCTemplate.listStudents();
      
      for (Student record : students) {
         System.out.print(&quot;ID : &quot; + record.getId() );
         System.out.print(&quot;, Name : &quot; + record.getName() );
         System.out.println(&quot;, Age : &quot; + record.getAge());
      }

      System.out.println(&quot;----Updating Record with ID = 2 -----&quot; );
      studentJDBCTemplate.update(2, 20);

      System.out.println(&quot;----Listing Record with ID = 2 -----&quot; );
      Student student = studentJDBCTemplate.getStudent(2);
      System.out.print(&quot;ID : &quot; + student.getId() );
      System.out.print(&quot;, Name : &quot; + student.getName() );
      System.out.println(&quot;, Age : &quot; + student.getAge());
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns = &quot;http://www.springframework.org/schema/beans&quot;
   xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
   xsi:schemaLocation = &quot;http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd &quot;&amp;gt;

   &amp;lt;!-- Initialization for data source --&amp;gt;
   &amp;lt;bean id=&quot;dataSource&quot; 
      class = &quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&amp;gt;
      &amp;lt;property name = &quot;driverClassName&quot; value = &quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
      &amp;lt;property name = &quot;url&quot; value = &quot;jdbc:mysql://localhost:3306/TEST&quot;/&amp;gt;
      &amp;lt;property name = &quot;username&quot; value = &quot;root&quot;/&amp;gt;
      &amp;lt;property name = &quot;password&quot; value = &quot;password&quot;/&amp;gt;
   &amp;lt;/bean&amp;gt;

   &amp;lt;!-- Definition for studentJDBCTemplate bean --&amp;gt;
   &amp;lt;bean id = &quot;studentJDBCTemplate&quot; 
      class = &quot;com.tutorialspoint.StudentJDBCTemplate&quot;&amp;gt;
      &amp;lt;property name = &quot;dataSource&quot; ref = &quot;dataSource&quot; /&amp;gt;    
   &amp;lt;/bean&amp;gt;
      
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;------Records Creation--------
Created Record Name = Zara Age = 11
Created Record Name = Nuha Age = 2
Created Record Name = Ayan Age = 15
------Listing Multiple Records--------
ID : 1, Name : Zara, Age : 11
ID : 2, Name : Nuha, Age : 2
ID : 3, Name : Ayan, Age : 15
----Updating Record with ID = 2 -----
Updated Record with ID = 2
----Listing Record with ID = 2 -----
ID : 2, Name : Nuha, Age : 20&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 17 Oct 2018 14:53:00 +0000</pubDate>
<dc:creator>NinWoo</dc:creator>
<og:description>[TOC] Spring JDBC框架概览 使用传统的JDBC连接数据库，需要编写不必要的代码来处理异常、打开和关闭数据库连接等变得非常麻烦。然而，Spring JDBC Framework从打开连接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NinWoo/p/9807730.html</dc:identifier>
</item>
<item>
<title>Kafka 温故(一)：Kafka背景及架构介绍 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/9807585.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/9807585.html</guid>
<description>&lt;p&gt;Kafka是分布式发布-订阅消息系统。它最初由LinkedIn公司开发，使用Scala语言编写，之后成为Apache项目的一部分。&lt;strong&gt;Kafka是一个分布式的，可划分的，多订阅者，冗余备份的持久性的日志服务。&lt;/strong&gt;它主要用于处理活跃的流式数据（实时性的计算）。&lt;/p&gt;
&lt;p&gt;在大数据系统中，常常会碰到一个问题，整个大数据是由各个子系统组成，数据需要在各个子系统中高性能，低延迟的不停流转。传统的企业消息系统并不是非常适合大规模的数据处理。为了已在同时搞定在线应用（消息）和离线应用（数据文件，日志）Kafka就出现了。Kafka可以起到两个作用：&lt;/p&gt;
&lt;p&gt;1.降低系统组网复杂度。&lt;br/&gt;2.降低编程复杂度，各个子系统不在是相互协商接口，各个子系统类似插口插在插座上，Kafka承担高速数据总线的作用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.同时为发布和订阅提供高吞吐量。&lt;/strong&gt;据了解，Kafka每秒可以生产约25万消息（50 MB），每秒处理55万消息（110 MB）。&lt;br/&gt;&lt;strong&gt;2.可进行持久化操作。&lt;/strong&gt;将消息持久化到磁盘，因此可用于批量消费，例如ETL，以及实时应用程序。通过将数据持久化到硬盘以及replication防止数据丢失。&lt;br/&gt;&lt;strong&gt;3.分布式系统，易于向外扩展，可以和ZooKeeper结合。&lt;/strong&gt;所有的producer、broker和consumer都会有多个，均为分布式的。无需停机即可扩展机器。&lt;br/&gt;&lt;strong&gt;4.消息被处理的状态是在consumer端维护，而不是由server端维护&lt;/strong&gt;。当失败时能自动平衡。&lt;br/&gt;&lt;strong&gt;5.支持online和offline的场景。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181017221901434-1068566842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以通过消息队列做系统之间的通信，即系统之间的相互协调和调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意：使用消息队列和SOA架构的区别？&lt;br/&gt;          1.SOA是直接调用的（可以通过RPC和HTTPClient来直接调用）&lt;br/&gt;          2.使用消息队列是通过消息的传递，来完成两个系统之间的整合和调用&lt;/p&gt;
&lt;p&gt;&lt;span&gt;带来的好处：&lt;/span&gt;&lt;br/&gt;1.解耦合&lt;br/&gt;      使用了消息队列后，两个系统之间没有直接的调用关系，只是通过消息的传递来交互，两个系统之间没有侵入性。&lt;/p&gt;
&lt;p&gt;2.提高系统的响应速度&lt;/p&gt;
&lt;p&gt;       例子：订单处理&lt;br/&gt;      &lt;br/&gt;        订单支付成功的方法(){&lt;br/&gt;                1、修改订单状态&lt;br/&gt;                2、计算会员积分&lt;br/&gt;                3、通知物流进行配送&lt;br/&gt;      }&lt;br/&gt;    注： &lt;br/&gt;           1.原来系统中这个三个步骤要同时处理后再返回，这样比较耗时；&lt;br/&gt;           2.现在可以先处理用户最关心的，最急需看到的修改订单状态成功信息，这样可以先处理&quot;修改订单状态&quot;,然后立刻返回给用户，&lt;br/&gt;              后面的“计算会员积分”，“通知物流进行配送”，放入消息队列中交给后面的系统继续处理。&lt;br/&gt;&lt;strong&gt;冗余&lt;/strong&gt;&lt;br/&gt;      有些情况下，处理数据的过程会失败。除非数据被持久化，否则将造成丢失。消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的&quot;插入-获取-删除&quot;范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩展性&lt;/strong&gt;&lt;br/&gt;     因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。不需要改变代码、不需要调节参数。扩展就像调大电力按钮一样简单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;灵活性 &amp;amp; 峰值处理能力&lt;/strong&gt;&lt;br/&gt;      在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见；如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可恢复性&lt;/strong&gt;&lt;br/&gt;系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;顺序保证&lt;/strong&gt;&lt;br/&gt;在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。Kafka保证一个Partition内的消息的有序性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓冲&lt;/strong&gt;&lt;br/&gt;在任何重要的系统中，都会有需要不同的处理时间的元素。例如，加载一张图片比应用过滤器花费更少的时间。消息队列通过一个缓冲层来帮助任务最高效率的执行———写入队列的处理会尽可能的快速。该缓冲有助于控制和优化数据流经过系统的速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步通信&lt;/strong&gt;&lt;br/&gt;很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;消息队列的分类：点对点，发布/订阅&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 1.点对点&lt;br/&gt;       消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息&lt;/p&gt;
&lt;p&gt;  注意（缺点）：&lt;/p&gt;
&lt;p&gt;           1.消息被消费以后，queue中不再有存储，所以消费者不可肯消费到已经被消费的消息。&lt;/p&gt;
&lt;p&gt;           2.queue中支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费。&lt;br/&gt; &lt;br/&gt;          （当一个系统消费了该个消息后，其他的系统不能再消费了）&lt;/p&gt;
&lt;p&gt; 2.发布/订阅（最常用的）&lt;br/&gt;        &lt;strong&gt; 消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅的消费者消费。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181017222136931-565359623.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;   1.RabbitMQ：支持的协议多，非常重量级消息队列，对路由(Routing)，负载均衡(Load balance)或者数据持久化都有很好的支持。&lt;/p&gt;
&lt;p&gt;    2.ZeroMQ：号称最快的消息队列系统，尤其针对大吞吐量的需求场景，擅长的高级/复杂的队列，但是技术也复杂，并且只提供非持久性的队列。&lt;/p&gt;
&lt;p&gt;    3.ActiveMQ（JMS的实现）：Apache下的一个子项，类似ZeroMQ，能够以代理人和点对点的技术实现队列 。&lt;/p&gt;
&lt;p&gt;    4.Redis：是一个key-Value的NOSql数据库，但也支持MQ功能，数据量较小，性能优于RabbitMQ，数据超过10K就慢的无法忍受。&lt;/p&gt;
&lt;p&gt;        &lt;br/&gt;  &lt;span&gt;  注：消息队列不可能是单点的，也需要集群。这样就涉及到了，负载均衡和消息的持久化&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160314214943602&quot; alt=&quot;&quot; width=&quot;786&quot; height=&quot;750&quot;/&gt;&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;《百知教育》apache kafka&lt;/p&gt;
</description>
<pubDate>Wed, 17 Oct 2018 14:26:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<og:description>一.Kafka简介 Kafka是分布式发布-订阅消息系统。它最初由LinkedIn公司开发，使用Scala语言编写，之后成为Apache项目的一部分。Kafka是一个分布式的，可划分的，多订阅者，冗余</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/9807585.html</dc:identifier>
</item>
<item>
<title>SpringBoot(三)通过properties实现多个数据库环境自动切换配置 - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/9761969.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/9761969.html</guid>
<description>&lt;div class=&quot;bodyCustomClass&quot; readability=&quot;28.671081677704&quot;&gt;
&lt;blockquote readability=&quot;9.2759381898455&quot;&gt;
&lt;p&gt;前面的文章已经介绍了&lt;a href=&quot;https://www.cnblogs.com/toutou/p/9675218.html&quot; target=&quot;_blank&quot;&gt;CentOS部署SpringBoot项目从0到1&lt;/a&gt;的详细过程，包括Linux安装ftp、Tomcat以及Java jdk的全部过程。这篇文章主要介绍关于springboot如何通过多个properties实现数据库环境部署时自动切换配置的两种方式，部署时切换方式和打包时Maven控制方式。&lt;/p&gt;
&lt;p&gt;关于springboot基础矿建搭建有疑问的。可以看我之前的一篇文章。&lt;a href=&quot;https://www.cnblogs.com/toutou/p/9650939.html&quot; target=&quot;_blank&quot;&gt;详解intellij idea搭建SpringBoot&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;h2 id=&quot;_nav_0&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;环境介绍&lt;/h2&gt;
&lt;p&gt;正常来讲，一个软件的开发上线的流程大部分都是分为三个环境，依次是开发、测试、上线。&lt;/p&gt;
&lt;div class=&quot;li_dot_style&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;开发环境（dev)：&lt;/p&gt;
开发环境是指的是咱们本地跑的环境。&lt;/div&gt;
&lt;div class=&quot;li_dot_style&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;测试环境(qa)：&lt;/p&gt;
一般是克隆一份生产环境的配置，qa即test。&lt;/div&gt;
&lt;div class=&quot;li_dot_style&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;生产环境（prod）&lt;/p&gt;
正式提供对外服务的，即是真实环境。&lt;/div&gt;
&lt;p&gt;关于三个环境的切换已然标准化了，这里只是一笔带过一下，因为下文中的配置文件会跟三个环境有关联。相信所有人都不会对这三个环境陌生的。&lt;/p&gt;
&lt;p&gt;今天主要讲讲关于springboot如何通过多个properties实现数据库环境部署时自动切换配置的两种方式，部署时切换方式和打包时Maven控制方式。首先介绍部署时切换的方式。&lt;/p&gt;
&lt;h2 id=&quot;_nav_1&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;部署时切换&lt;/h2&gt;
&lt;p&gt;1.1 配置dev和qa环境数据，以备测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201810/506684-20181011103438471-1561385679.png&quot; alt=&quot;SpringBoot(三)通过properties实现多个数据库环境自动切换配置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.2 新增properties文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201810/506684-20181011103444909-765892810.png&quot; alt=&quot;SpringBoot(三)通过properties实现多个数据库环境自动切换配置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图：在application.properties文件的同级目录依次创建application-dev.properties，application-qa.properties，application-pro.properties这三个配置文件，dev、qa和prod分别对应上文&quot;环境介绍&quot;中的三个环境。&lt;/p&gt;
&lt;p&gt;1.3 配置各个properties文件&lt;/p&gt;
&lt;p&gt;在application.properties中添加配置切换选项，例如切换到dev环境的配置为：&lt;code&gt;spring.profiles.active=dev&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;依次在application-dev.properties，application-qa.properties，application-pro.properties配置相关datasource连接信息。&lt;/p&gt;
&lt;p&gt;例如application-dev.properties配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring.datasource.url=jdbc:mysql://127.0.0.1:3306/mytest
spring.datasource.username=root
spring.datasource.password=***********
spring.datasource.driver-class-name=com.mysql.jdbc.Driver&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201810/506684-20181011103452860-565566032.png&quot; alt=&quot;SpringBoot(三)通过properties实现多个数据库环境自动切换配置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.4 本地环境&lt;/p&gt;
&lt;p&gt;当设置application.properties中&lt;code&gt;spring.profiles.active=dev&lt;/code&gt;时，则此时启动连接的是dev环境。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201810/506684-20181011103501010-1470198163.png&quot; alt=&quot;SpringBoot(三)通过properties实现多个数据库环境自动切换配置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，此时运行得到的结果与配置文件一致，是dev环境的数据。&lt;/p&gt;
&lt;p&gt;1.5 部署测试环境&lt;/p&gt;
&lt;p&gt;部署测试环境，关于部署有不了解的可以看看&lt;a href=&quot;https://www.cnblogs.com/toutou/p/9675218.html&quot; target=&quot;_blank&quot;&gt;《CentOS部署SpringBoot项目从0到1》&lt;/a&gt;，部署时切换到qa环境。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java -jar zuche-0.0.1-SNAPSHOT.jar --spring.profiles.active=qa --server.port=2008&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201810/506684-20181011103508610-975650804.png&quot; alt=&quot;SpringBoot(三)通过properties实现多个数据库环境自动切换配置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到日志中显示的内容与预期一致，spring.profiles.active设置为qa, 端口设置为2008。&lt;/p&gt;
&lt;p&gt;运行效果如下图，部署以后连接的qa环境。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201810/506684-20181011103515228-553820550.png&quot; alt=&quot;SpringBoot(三)通过properties实现多个数据库环境自动切换配置&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;_nav_2&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;Maven控制打包时切换&lt;/h2&gt;
&lt;p&gt;2.1 设置项目对象模型pom.xml&lt;/p&gt;
&lt;p&gt;2.1.1 添加profiles到pom.xml中，profiles节点是和build同级的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;profiles&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;dev&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;env&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;dev&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;env&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;activation&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;activeByDefault&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;activeByDefault&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;activation&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;qa&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;env&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;qa&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;env&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;prod&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;env&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;prod&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;env&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;profile&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;profiles&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;activation&lt;/code&gt;表示的是可以用这样的命令来触发profile，&lt;code&gt;true&lt;/code&gt;表示dev是默认的profile, 这样本地直接ide启动项目的时候就是连接的dev环境。&lt;/p&gt;
&lt;p&gt;2.1.2 添加filters节点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;src/main/resources/application-${env}.properties&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201810/506684-20181011103524045-1467158072.png&quot; alt=&quot;SpringBoot(三)通过properties实现多个数据库环境自动切换配置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.2 更新application.properties。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spring.profiles.active=@env@&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意@env@中的env可以理解为一个变量,需要与2.1.2中设置的${env}对应上。&lt;/p&gt;
&lt;p&gt;2.3 添加Maven打包命令&lt;/p&gt;
&lt;p&gt;&lt;code&gt;clean package -P qa -D maven.test.skip=true&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201810/506684-20181011103537378-1311279716.png&quot; alt=&quot;SpringBoot(三)通过properties实现多个数据库环境自动切换配置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;-D maven.test.skip=true&lt;/code&gt;不执行测试用例，也不编译测试用例类。&lt;/p&gt;
&lt;p&gt;2.4 执行Maven命令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201810/506684-20181011103543593-504563381.png&quot; alt=&quot;SpringBoot(三)通过properties实现多个数据库环境自动切换配置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看jar包的application.properties文件的spring.profiles.active，看Maven命令是否生效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201810/506684-20181011103550243-69653470.png&quot; alt=&quot;SpringBoot(三)通过properties实现多个数据库环境自动切换配置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，spring.profiles.active=qa&lt;/p&gt;
&lt;p&gt;2.5 部署Tomcat&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java -jar zuche-0.0.1-SNAPSHOT.jar --server.port=2008&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201810/506684-20181011103604296-873701854.png&quot; alt=&quot;SpringBoot(三)通过properties实现多个数据库环境自动切换配置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Maven打包时已经设置了qa环境，部署命令中不需要再指明qa环境。&lt;/p&gt;
&lt;h2 id=&quot;_nav_4&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;博客总结&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本文通篇讲的主要是围绕springboot部署jar包的两种方式，至于war包，以后有时间再说说。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.0030211480363&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;请叫我头头哥&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/toutou/&lt;/a&gt;&lt;br/&gt;关于作者：专注于基础平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/%E8%AF%B7%E5%8F%AB%E6%88%91%E5%A4%B4%E5%A4%B4%E5%93%A5&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 17 Oct 2018 14:20:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>前面的文章已经介绍了CentOS部署SpringBoot项目从0到1的详细过程，包括Linux安装ftp、Tomcat以及Java jdk的全部过程。这篇文章主要介绍关于springboot如何通过多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toutou/p/9761969.html</dc:identifier>
</item>
<item>
<title>react系列（五）在React中使用Redux - liuyongjia</title>
<link>http://www.cnblogs.com/liuyongjia/p/9807525.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyongjia/p/9807525.html</guid>
<description>&lt;p&gt;上一篇展示了Redux的基本使用，可以看到Redux非常简单易用，不限于React，也可以在Angular、Vue等框架中使用，只要需要Redux的设计思想的地方，就可以使用它。&lt;br/&gt;这篇主要讲解在React中使用Redux，首先是安装。&lt;/p&gt;
&lt;h2 id=&quot;安装react-redux&quot;&gt;安装React Redux&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;yarn add redux
yarn add react-redux&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有两个概念：&lt;br/&gt;1.容器组件（Container Components）&lt;br/&gt;2.展示组件（Presentational Components）&lt;/p&gt;
&lt;h3 id=&quot;展示组件&quot;&gt;展示组件&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;更关注数据展示，所以会写一些DOM嵌套和CSS&lt;/li&gt;
&lt;li&gt;通常不依赖Redux，直接从props中获取数据&lt;/li&gt;
&lt;li&gt;通常没有state，偶尔会用state来保存一些展示状态，如class等&lt;/li&gt;
&lt;li&gt;交互也通过props回调发起，不直接发起action&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;容器组件&quot;&gt;容器组件&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;通常作为数据源，做数据分发工作&lt;/li&gt;
&lt;li&gt;依赖Redux&lt;/li&gt;
&lt;li&gt;通过和store交互进行数据变更&lt;/li&gt;
&lt;li&gt;通过react-redux生成&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在我们的项目中，一般来说，会编写很多展示组件，少量的容器组件来包裹这些展示组件。&lt;br/&gt;接下来写一个简单的计数器应用，先来划分容器组件和展示组件。&lt;br/&gt;计数器有三个按钮，加、减、重置；一个展示区。&lt;br/&gt;由于按钮既要触发action，又要负责展示，所以需要做成混合组件。&lt;br/&gt;先来编写展示组件，就是显示一下当前计数。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import React from 'react';
const Counter = ({
    count
}) =&amp;gt; (
    &amp;lt;p&amp;gt;当前计数为：&amp;lt;span style={{color: 'red'}}&amp;gt;count&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt;
)

export default Counter;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般来说，容器组件就是通过store.subscribe传入回调，订阅store的变化，再去把值通过props传入各个组件中。&lt;br/&gt;在react-redux中实现了connect方法，它生成一个高阶组件，就是前面提到的容器组件。这个方法做了性能优化避免不必要的重复渲染，建议使用该方法。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mapStateToProps是一个Function，用来监听Redux Store的变化，将store的值，映射为对应的props属性。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const mapStateToProps = ({count}) =&amp;gt; {count};
// 或者
const mapStateToProps2 = (state) =&amp;gt; {
    count: state.count
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来生成一个容器组件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { connect } from 'react-redux';

const ConnectCounter = connect(
  mapStateToProps
)(Counter);

export default ConnectCounter;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来是按钮组件,按钮组件既需要展示，又有数据交互，做成混合组件。&lt;br/&gt;由于，需要dispatch，所以需要给connect传入第二个参数。&lt;br/&gt;mapDispatchToProps可以是Object或者Function。用来将dispatch映射到props上。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const mapDispatchToProps = dispatch =&amp;gt; {
    return {
        plus: () =&amp;gt; dispatch({
            type: 'PLUS'
        })
    }
}
// 或者结合上篇提到的bindActionCreators合成一个对象
function plus() {
  return {
    type: &quot;PLUS&quot;
  };
}

function minus() {
  return {
    type: &quot;MINUS&quot;
  };
}

const mapDispatchToProps2 = dispatch =&amp;gt; {
    return bindActionCreators({ plus, minus }, dispatch)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;import React from 'react';

let Button = ({plus, minus}) =&amp;gt; {
    return (
        &amp;lt;&amp;gt;
            &amp;lt;button onClick={plus}&amp;gt;{'plus'}&amp;lt;/button&amp;gt;
            &amp;lt;button onClick={minus}&amp;gt;{'minus'}&amp;lt;/button&amp;gt;
        &amp;lt;/&amp;gt;
    )
};

Button = connect(()=&amp;gt;{}, mapDispatchToProps2)(Button);
export default Button;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，提供一个Provider用来提供全局store。完整例子在&lt;a href=&quot;https://codesandbox.io/s/r46w78292o&quot;&gt;这里-codesandbox&lt;/a&gt;。&lt;br/&gt;感谢阅读。&lt;/p&gt;
</description>
<pubDate>Wed, 17 Oct 2018 14:09:00 +0000</pubDate>
<dc:creator>liuyongjia</dc:creator>
<og:description>上一篇展示了Redux的基本使用，可以看到Redux非常简单易用，不限于React，也可以在Angular、Vue等框架中使用，只要需要Redux的设计思想的地方，就可以使用它。 这篇主要讲解在Rea</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyongjia/p/9807525.html</dc:identifier>
</item>
<item>
<title>开源项目福利-github开源项目免费使用Azure PipeLine - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/9806814.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/9806814.html</guid>
<description>&lt;p&gt;微软收购Github后,很多人猜想微软可能会砍掉VSTS,然而事实VSTS并没有砍掉,关于Azure Devops的详细信息可以查看 &lt;a href=&quot;https://www.cnblogs.com/yanxiaodi/p/9625378.html&quot;&gt;这篇博客&lt;/a&gt;,如果想查看原文也可以从链接里提供的原始地址里查看.&lt;/p&gt;
&lt;p&gt;今天要介绍的是做Azure devops的ci部分:&lt;code&gt;Azure Pipeline&lt;/code&gt;. VSTS升级到Azure Devops之后对开源开发者带来的重大利好消息就是Github开源项目可以免费,无限时和并行运行10个CI/CD作业.&lt;/p&gt;
&lt;p&gt;下面将简要介绍Azure PipeLine以及如何把Azure PipeLine以Github结合,实现自动化构建.&lt;/p&gt;
&lt;h2 id=&quot;azure-pipeline简介&quot;&gt;Azure PipeLine简介&lt;/h2&gt;
&lt;p&gt;PipeLine字面含义是管道,流水线,正如其字面含义.Azure PipeLine可以把一个构建任务拆分成若干部分,然后串联起来构成一个流水线作业.根据具体构建业务不同,一个PipeLine可能只包含一两个步骤,也有可能十几个甚至几十个步骤.Azure PipeLine类似于Jenkins PipeLine,与传统自动构建相比优点在于结构非常清析,构建流水线中的某个环节出现问题很容易定位到(使用过传统Jenkins自由式任务的同学可能会体会到,对于一些复杂的构建任务一旦出现问题,排查起来非常头疼,面对着复杂的控制台输出让人痛不欲生).当然本节并不会介绍非常复杂的构建知识,而是一个入门教程,以供广大开源作者和爱好者快速搭建一个流水线构建.&lt;/p&gt;
&lt;p&gt;Azure Pipeline 目前支持&lt;code&gt;Node.js, Python, Java, PHP, Ruby, C/C++, .NET, Android, and iOS&lt;/code&gt;,非常令人欣喜的是Azure PipeLine并不需要你具有专业的Devops知识甚至即便你完全不了解Devops也能很方便,快速的搭建一个PipeLine作业.因此,不要犹豫,也不要担心,果断尝试一下.&lt;/p&gt;
&lt;h2 id=&quot;azure-pipeline与github集成快速搭建一个pipeline作业.&quot;&gt;Azure PipeLine与Github集成,快速搭建一个PipeLine作业.&lt;/h2&gt;
&lt;p&gt;读者阅读本文可以没有任何自动构建或者Devops开发经验,但是前提必须要有一个Github账户和一个Microsoft账户,这两种账户都可以免费注册,并且也不是很复杂.由于本要已经有账户了,因此后面的教程中都假定是已经登陆了github账户和Microsoft账户.&lt;/p&gt;
&lt;h3 id=&quot;创建一个github项目&quot;&gt;创建一个Github项目&lt;/h3&gt;
&lt;p&gt;对于如何在github创建一个项目,这里不再赘述,读者可以查看相关文章或者Github帮助来获得相关方面知识.我这里使用我的github仓库里一个名为 &lt;code&gt;gitShow&lt;/code&gt;的.net项目(读者可以上传一个.net项目也可以是支持的其它项目(java,python,nodejs等)到github仓库,不用担心项目类型不一样,我们不需要动手写一行代码便可以利用Azure PipeLine强大的功能创建一个简单的自动构建流水线作业.我的项目结构如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017204845678-1273456631.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;在azure-devops里创建一个azure-pipeline项目&quot;&gt;在Azure Devops里创建一个Azure PipeLine项目&lt;/h3&gt;
&lt;p&gt;我们在浏览器输入&lt;code&gt;dev.azure.com&lt;/code&gt;就会进入azure devops界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017210240156-71160542.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你没有登陆,看到的界面可能和上面不一样,登陆以后,如果你没有创建任何组织,左边不会有任何组织列表信息,这时候界面会提示你创建一个组织,你也可以点击&lt;code&gt;add organization&lt;/code&gt;来创建一个组织,组织相当于一个团队,一个组织里面可以包含若干个项目.&lt;/p&gt;
&lt;p&gt;点击左侧的任意一个组织进入组织,我进入的是截图里面的最后一个,当然这无所谓,你可以进入任意一个组织.&lt;/p&gt;
&lt;p&gt;这是一个空的组织,页面会提示我们创建一个项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017210737948-1926688384.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们输入项目名称,这时候创建项目按钮激活,我们点击它便可以创建一个项目.&lt;/p&gt;
&lt;p&gt;过一会一个空的项目就生成了,这时候页面又会提示你创建一个流水线作业&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017210944147-1175004152.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击'New PipeLine'按钮就会进入流水线作业创建页面&lt;/p&gt;
&lt;p&gt;此时页面会提示你选择仓库来源,我们选择&lt;code&gt;Github&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017211137088-1616702240.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个与Github连接会出现授权选择,这里不要点击&lt;code&gt;Authorize&lt;/code&gt;,而是点击下面的&lt;code&gt;Install our app from the GitHub Marketplace&lt;/code&gt;链接,进入到插件安装页面,这时候会让你选择一个组织,根据你的组织不同,这里出现的内容也不相同,选择一个自己有权限的组织即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017211918547-1700731708.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击组织名,进入到仓库选择页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017212007172-1948654202.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以选择所有仓库或者是指定仓库,我这里选择的是所有仓库,然后点击'Install'按钮,过数秒后,会进入一个页面让你选择&lt;code&gt;Microsoft账户&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017212141387-1328243982.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击账户名即可&lt;/p&gt;
&lt;p&gt;这时候,如果你选择的是所有,则会把所有的github仓库都罗列出来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017212249437-1239229019.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我这里选择&lt;code&gt;GitShow&lt;/code&gt;项目,此时Azure Devops平台就会对项目进行智能分析,然后让你选择项目类型(也可能没有这一步,直接进入PipeLine代码界面),这里Azure Devops自动为我们生成了PipeLine 脚本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017212449866-1636161252.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们点击左上角&lt;code&gt;Run&lt;/code&gt;按钮运行PipeLine脚本,这一步是等待时间最长的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017212623472-518490719.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中我们可以看到PipeLine的执行状态,有&lt;code&gt;对勾&lt;/code&gt;标识的为已成功执行的步骤,带有&lt;code&gt;三角&lt;/code&gt;标识的为当前正在执行的步骤,带有&lt;code&gt;钟表&lt;/code&gt;标识的为待执行的步骤.等待所有的步骤标识都变成了对勾,整个PipeLine就执行完成了&lt;/p&gt;
&lt;p&gt;如果项目最终构建成功,则会出现一个大的&lt;code&gt;绿色对勾&lt;/code&gt;标识整个项目构建成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017212953364-1633648937.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们点击其中某个步骤,就可以看到当前步骤构建的详细cli输出信息,类似于Jenkins cli输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017213857424-51742259.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;在github项目页面显示azure-pipeline构建状态徽标&quot;&gt;在github项目页面显示Azure PipeLine构建状态徽标&lt;/h3&gt;
&lt;p&gt;如果项目每次构建我们都跳到Azure devops界面去查看,显然太麻烦了,很多时候我们可能只关心构建状态,只要构建成功我们便不再看详细信息,如果失败了再进入构建页面查看构建详细信息.实际上很多开源项目都会有一个构建状态徽标显示在项目页面里,便于直接查看项目的构建状态.下面我们就介绍如何自己的github项目添加一个Azure PipeLine构建状态徽标&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017214425329-1849462946.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图,我们点击左侧导航栏里的&lt;code&gt;PipeLines&lt;/code&gt;按钮,然后点击&lt;code&gt;Builds&lt;/code&gt;按钮,出现如下界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017214629224-521616058.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们点击&lt;code&gt;...&lt;/code&gt;符号,在弹出的下拉列表里选择&lt;code&gt;Status Badge&lt;/code&gt;,出现如下界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017214843159-1138908971.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最面下是markdown样例链接,我们复制它.然后我们再转到github,打开自己的项目页,然后点击&lt;code&gt;README.md&lt;/code&gt;文件进行编辑(如果读者的项目里没有此文件可以添加一个,注意名称必须是README.md,添加非常简单,如果没有github会提示你添加一个,按照提示添加即可),我们把复制的内容添加到&lt;code&gt;README.md&lt;/code&gt;里&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017215215393-318796360.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点击保存,返回到项目首页,就可以看到刚添加的构建状态徽标啦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017215318153-2035457652.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上状态是实时更新的,我们修改一下源代码,故意制造些错误,待Azure PipeLine构建完成后,显示在Github页面的状态就会更新啦&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017215932363-276129460.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这极大地提升了开源项目的协作效率,如果有用户提交进来代码,代码审阅者可以先看一下构建状态是成功还是失败,如果失败了可以直接让代码提交者先把项目构建成功,然后再提交,减少不必要的重复的手动构建工作.&lt;/p&gt;
&lt;p&gt;以上显示状态徽标只是个简单的示例,读者还可以参考其它开源项目的布局,把自己的布局设计的更大方美观&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201810/811801-20181017220441120-1338708190.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于Azure PipeLine刚刚推出,这里仅仅是进行初步尝试,实际工作中靠自动生成的脚本可能还是远远不够的,需要我们根据自己的项目情况来定制流水线构建方案.但是做为一个开源项目自动构建方案已经够用了.以后有时间会分享更多结合.net 平台的Devops的知识.希望大家多交流,也希望专家大佬们批评指正,多提意见.&lt;/p&gt;
</description>
<pubDate>Wed, 17 Oct 2018 14:09:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>微软收购Github后,很多人猜想微软可能会砍掉VSTS,然而事实VSTS并没有砍掉,关于Azure Devops的详细信息可以查看</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tylerzhou/p/9806814.html</dc:identifier>
</item>
<item>
<title>docker工具链概述 - Net_win</title>
<link>http://www.cnblogs.com/guodf/p/9807477.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guodf/p/9807477.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/machine/overview/&quot;&gt;官方参考文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​ 本文主要介绍docker是什么，有什么，以及工具链的概述。&lt;/p&gt;
&lt;p&gt;​ docker是一个比较新容器技术，当然容器技术并不是什么新技术，如果你没有接触过容器的概念，可能你有种一夜之间容器遍天下的感觉。 我最早接触docker也是2015前后，一次偶然的机会去尝试cloud foundry，便得知了容器是何物，遇见docker后甚是喜爱，因为工作环境一直不得尝试，所以一直不能深入的去研究它，今天的docker与几年前相比已经有了很大的变化，各种工具链都相对完善，技术也相对成熟，随着微服务的诞生，docker的应用场景更是被发挥的淋漓尽致，如果你没有赶上又丑又庞大的企业级应用，那么此刻短小精悍的微服务时代你可以尽情体验一番。&lt;/p&gt;
&lt;h2 id=&quot;docker名词解释&quot;&gt;docker名词解释&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;docker官方解释为docker引擎，一个集client与server一身的容器技术。&lt;/li&gt;
&lt;li&gt;docker镜像，比如一个系统iso文件，通常被叫做镜像，它只是一个静态文件而已。&lt;/li&gt;
&lt;li&gt;docker容器，当一个iso文件被安装硬盘上后就成一个系统，你可以将这个iso安装到多个硬盘上，那么每个系统就对应着docker容器的概念，或者你也可以理解成实例，容器（实例）是动态的而镜像是静态的。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;docker简介&quot;&gt;docker简介&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;docker是一个容器化技术，用来管理容器，那么作为容器，它可以容纳一个或多个程序。&lt;/li&gt;
&lt;li&gt;docker容器是一个独立程序，什么叫独立的程序，它可以打包你的程序并与系统内的其它程序之间隔离，隔离边界就是docker容器本身。&lt;/li&gt;
&lt;li&gt;docker容器是一个可以执行的完整的整体，创建docker容器的时候，docker会打包你在容器内要运行的程序以及程序的所有依赖&lt;em&gt;（当然这不是自动的，docker需要你明确指出你的程序依赖什么）&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;docker容器是一个跨平台应用，docker容器可以运行在unix/linux/win等平台&lt;em&gt;（但是win容器与unix/linux不兼容，docker最初只支持linux内核）&lt;/em&gt;，docker容器不依赖你的当前系统，只依赖docker引擎本身&lt;em&gt;（docker引擎是docker的简称）&lt;/em&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;docker-machine简介&quot;&gt;docker-machine简介&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;docker-machine用来创建docker运行环境，你可以使用docker-machine创建基于的docker运行环境，这里的驱动是指多种虚拟机环境，比如：virtualbox，vm，hyper-v等，&lt;a href=&quot;(https://docs.docker.com/machine/drivers/)&quot;&gt;更多驱动类型在这里&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;docker-machine用来管理docker运行环境，如果你在上一步中创建了多种驱动类型的docker运行环境，那么docker-machine可以来管理这些docker运行环境，比如查看环境信息，比如删除、修改环境，比如在指定的docker运行环境中执行shell命令等。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;docker-compose简介&quot;&gt;docker-compose简介&lt;/h2&gt;
&lt;p&gt;docker-compose主要用来创建docker容器，可能你要问，既然docker可以创建容器为什么还要docker-compose呢？&lt;/p&gt;
&lt;p&gt;举个例子：使用shell命令创建一个文件夹，并在文件夹内创建一个文件，只需要执行两条shell命令即可，如果让你在另外的很多机器上也做同样的操作呢？难道你要每个机器都手动输入命令吗？答案是否定的，你肯定想到的是使用shell脚本解决问题，将创建文件夹和创建文件的命令写入脚本中并将脚本分发到不同的机器上运行。没错docker-compose就是用来干这个的，你可以将需要创建的一个或多个容器写入一个docker-compose支持的脚本中。&lt;/p&gt;
&lt;p&gt;其实docker-compose支持的是一个yml扩展的文件，这里记录了你要创建的一个或多个容器的配置信息，这样就可以将yml文件分发到不同的机器上并通过docker-compoe创建容器。&lt;/p&gt;
&lt;h2 id=&quot;docker-swarm简介&quot;&gt;docker swarm简介&lt;/h2&gt;
&lt;p&gt;docker swarm用来管理docker集群，当我们来部署一个服务的时候，我们通常会考虑服务会不会因为特殊情况终止运行，为了避免特殊情况导致的服务终止，通常一个常用的办法就是监控，如果服务意外终止我们就重新启动它，这也是docker swarm要做的事，除此之外docker swarm还会将服务部署到任意一集群节点中，保证服务始终可用。&lt;/p&gt;
&lt;h3 id=&quot;docker-service简介&quot;&gt;docker service简介&lt;/h3&gt;
&lt;p&gt;docker service用来创建docker服务，那么什么是docker 服务，假如你要部署一个docker容器，你通常可以运行docker run命令，如果此时在一个docker集群中，那么该命令只会在运行命令的机器上创建一个容器，如果你要部署的是docker容器的多个实例，那么docker service就是来解决这个问题的，你只需要通过docker service run命令就可以在集群的任意节点上部署你的容器实例，你也可以指定需要运行的容器实例个数，这通常只需设置指定的参数就行了。&lt;/p&gt;
&lt;h3 id=&quot;docker-stack简介&quot;&gt;docker stack简介&lt;/h3&gt;
&lt;p&gt;此时，我还不是特别明白docker stack的作用，从官网的介绍我理解为&lt;code&gt;docker compose&lt;/code&gt; + &lt;code&gt;docker swarm&lt;/code&gt;，这个解释似乎有点牵强，暂时先这么理解吧，毕竟docker stack在docker swarm环境下才有意义，以后理解了在更新这段简介。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;​ docker中的一些工具及感念大概也就这么多，这里只是简单的介绍了一下，如果你是新手那么这篇文章一定对你有很多的帮助，因为我也是这么走过来的，不期望自己的文章多高深，只希望能你让你快速的理解docker是什么。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回顾一下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ docker是一个集client与server一身的容器化技术，你可以通过docker命令来创建一些docker容器，你也可通过docker compose命令来批量创建一些docker容器，如果你的环境足够大，那么docker swarm可以让你对docker的管理更加方便，docker service可以让你创建可靠的服务实例，docker stack可以让你更方便的部署docker容器。&lt;/p&gt;
</description>
<pubDate>Wed, 17 Oct 2018 14:03:00 +0000</pubDate>
<dc:creator>Net_win</dc:creator>
<og:description>docker工具链概述 [TOC]</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guodf/p/9807477.html</dc:identifier>
</item>
<item>
<title>javascript基础修炼（8）——指向FP世界的箭头函数 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/9807398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/9807398.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201810/08/7fbdb9e104af8f41e3671d6d7a1af685.jpg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201810/08/98a73576fb4dbd393699707b7dacb795.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一.-箭头函数&quot;&gt;一. 箭头函数&lt;/h2&gt;
&lt;p&gt;箭头函数是&lt;code&gt;ES6&lt;/code&gt;语法中加入的新特性，而它也是许多开发者对&lt;code&gt;ES6&lt;/code&gt;仅有的了解，每当面试里被问到关于&lt;em&gt;“&lt;code&gt;ES6&lt;/code&gt;里添加了哪些新特性？”&lt;/em&gt;这种问题的时候，几乎总是会拿箭头函数来应付。箭头函数，&lt;code&gt;=&amp;gt;&lt;/code&gt;，没有自己的&lt;code&gt;this&lt;/code&gt; , &lt;code&gt;arguments&lt;/code&gt; , &lt;code&gt;super&lt;/code&gt; , &lt;code&gt;new.target&lt;/code&gt; ，&lt;strong&gt;“书写简便，没有this”&lt;/strong&gt;在很长一段时间内涵盖了大多数开发者对于箭头函数的全部认知（当然也包括我自己），如果只是为了简化书写，把&lt;code&gt;=&amp;gt;&lt;/code&gt;按照&lt;code&gt;function&lt;/code&gt;关键字来解析就好了，何必要弄出一个跟普通函数特性不一样的符号呢？答案就是：&lt;strong&gt;函数式编程（Functional Programming）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果你了解&lt;code&gt;javascript&lt;/code&gt;这门语言就知道，它是没有类这个东西的，&lt;code&gt;ES6&lt;/code&gt;新加入的&lt;code&gt;Class&lt;/code&gt;关键字，也不过是语法糖而已，我们不断被要求使用&lt;strong&gt;面向对象编程&lt;/strong&gt;的思想来使用&lt;code&gt;javascript&lt;/code&gt;，定义很多类，用复杂的原型链机制去模拟类，是因为更多的开发者能够习惯这种描述客观世界的方式，&lt;strong&gt;《你不知道的javascript》&lt;/strong&gt;中就明确指出原型链的机制其实只是实现了一种&lt;strong&gt;功能委托机制&lt;/strong&gt;，即便不使用面向对象中的概念去描述它，这也是一种合乎逻辑的语言设计方案，并不会造成巨大的认知障碍。但需要明确的是，&lt;strong&gt;面向对象&lt;/strong&gt;并不是&lt;code&gt;javascript&lt;/code&gt;唯一的使用方式。&lt;/p&gt;
&lt;p&gt;当然我也是接触到&lt;strong&gt;【函数式编程】&lt;/strong&gt;的思想后才意识到，我并不是说&lt;strong&gt;【函数式编程】&lt;/strong&gt;优于&lt;strong&gt;【面向对象】&lt;/strong&gt;，每一种编程思想都有其适用的范围，但它的确向我展示了另一种对编程的认知方式，而且在流程控制的清晰度上，它的确比&lt;strong&gt;面向对象&lt;/strong&gt;更棒，它甚至让我开始觉得，这才是&lt;code&gt;javascript&lt;/code&gt;该有的打开方式。&lt;/p&gt;
&lt;p&gt;如果你也曾以为&lt;strong&gt;【函数式编程】&lt;/strong&gt;就是&lt;em&gt;“用箭头函数把函数写的精简一些”&lt;/em&gt;，如果你也被各种复杂的&lt;code&gt;this&lt;/code&gt;绑定弄的晕头转向，那么就一起来看看这个胖箭头指向的新世界——&lt;code&gt;Functional Programming&lt;/code&gt;吧!&lt;/p&gt;
&lt;h2 id=&quot;二.-更贴近本能的思维方式&quot;&gt;二. 更贴近本能的思维方式&lt;/h2&gt;
&lt;p&gt;假如有这样一个题目：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201810/08/d656dd9730c3b129380abfcf4b2eb0e6.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在传统编程中，你的编码过程大约是这样：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let resolveYX = (x) =&amp;gt; 3*x*x + 2*x + 1;
let resolveZY = (y) =&amp;gt; 4*y*y*y + 5*y*y + 6;
let resolveRZ = (z) =&amp;gt; (2*z*z - 4)/3;
let y = resolveYX（2）；
let z = resolveZY(y);
let result = resolveRZ(z);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们大多时候采用的方式是把程序的执行细节用程序语言描述出来。但是如果你把这道题拿给一个不懂编程的学生来做，就会发现大多数时候他们的做法会是下面的样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201810/08/c788dee397a991b377dfb1a240fa28e0.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先对方程进行合并和简化，最后再代入数值进行计算得到结果就可以了。有没有发现事实上你自己在不写代码的时候也是这样做的，因为你很清楚那些中间变量对于得到正确的结果来说没有什么意义，而这样解题效率更高，&lt;strong&gt;尤其是当前面的环节和后面的环节可以抵消掉某些互逆的运算时，这样合并的好处可想而知&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而今天的主角&lt;strong&gt;【函数式编程】&lt;/strong&gt;，可以看做是这种思维方式在程序设计中的应用，&lt;em&gt;我并不建议非数学专业的作者从范畴论的角度去解释函数式编程，因为术语运用的准确性会造成难以评估的影响，很可能达不到技术交流的目的，反而最终误人子弟&lt;/em&gt;。&lt;/p&gt;
&lt;h2 id=&quot;三.-函数式编程&quot;&gt;三. 函数式编程&lt;/h2&gt;
&lt;p&gt;假如对某个需求的实现，需要传入&lt;code&gt;x&lt;/code&gt;，然后经历3个步骤后得到一个答案&lt;code&gt;y&lt;/code&gt;，你会怎样来实现呢？&lt;/p&gt;
&lt;h3 id=&quot;传统代码的实现&quot;&gt;3.1 传统代码的实现&lt;/h3&gt;
&lt;p&gt;这样一个需求在传统编程中最容易想到的就是链式调用：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function Task(value){
    this.value = value;
}

Task.prototype.step = function(fn){
    let _newValue = fn(this.value);
    return new Task(_newValue);
}
 
y = (new Task(x)).step(fn1).step(fn2).step(fn3);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你或许在&lt;code&gt;jQuery&lt;/code&gt;中经常见到这样的用法，或者你已经意识到上面的函数实际上就是&lt;code&gt;Promise&lt;/code&gt;的简化原型（关于&lt;code&gt;Promise&lt;/code&gt;相关的知识可以看&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/9709477.html&quot;&gt;《javascript基础修炼（7）——Promise，异步，可靠性》&lt;/a&gt;这篇文章），只不过我们把每一步骤包裹在了&lt;code&gt;Task&lt;/code&gt;这个容器里，每个动作执行完以后返回一个新的&lt;code&gt;Task&lt;/code&gt;容器，里面装着上一个步骤返回的结果。&lt;/p&gt;
&lt;h3 id=&quot;函数式代码推演&quot;&gt;3.2 函数式代码推演&lt;/h3&gt;
&lt;p&gt;在&lt;strong&gt;【函数式编程】&lt;/strong&gt;，我们不再采用程序语言按照步骤来复现一个业务逻辑，而是换一个更为抽象的角度，用数学的眼光看待所发生的事情。那么上面的代码实际上所做的事情就是：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;通过一系列变换操作，讲一个数据集&lt;code&gt;x&lt;/code&gt;变成了数据集&lt;code&gt;y&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有没有一点似曾相识的感觉？没错，这就是我们熟知的【方程】,或者【映射】:&lt;br/&gt;$$&lt;br/&gt;y=f(x)&lt;br/&gt;$$&lt;br/&gt;我们将原来的代码换个样子，就更容易看出来了：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function prepare(){
    return function (x){
        return (new Task(x)).step(fn1).step(fn2).step(fn3);
    }    
}

let f = prepare();
let y = f(x);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中，通过高阶函数&lt;code&gt;prepare( )&lt;/code&gt;将原来的函数改变为一个延迟执行的，等待接收一个参数&lt;code&gt;x&lt;/code&gt;并启动一系列处理流程的新函数。再继续进行代码转换，再来看一下&lt;strong&gt;f(x)&lt;/strong&gt;执行到即将结束时的暂态状况：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//fn2Result是XX.step(fn2)执行完后返回的结果(值和方法都包含在Task容器中)
fn2Result.step(fn3);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的语句中，实际上变量只有&lt;code&gt;fn2Result&lt;/code&gt;，&lt;strong&gt;step()&lt;/strong&gt;方法和&lt;strong&gt;fn10&lt;/strong&gt;都是提前定义好的，那么用函数化的思想来进行类比，这里也是实现了一个数据集&lt;code&gt;x1&lt;/code&gt;到数据集&lt;code&gt;y1&lt;/code&gt;的映射，所以它也可以被抽象为&lt;strong&gt;y = f ( x )&lt;/strong&gt;的模式：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//先生成一个用于生成新函数的高阶函数，来实现局部调用
let goStep = function(fn){
    return function(params){
        let value = fn(params.value);
        return new Task(value);
    }
}
//fn2Result.step(fn3)这一句将被转换为如下形式
let requireFn2Result = goStep(fn3);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处的&lt;code&gt;requireFn2Result( )&lt;/code&gt;方法，只接受一个由前置步骤执行结束后得到的暂态结果，然后将其关键属性&lt;code&gt;value&lt;/code&gt;传入&lt;code&gt;fn3&lt;/code&gt;进行运算并传回一个支持继续链式调用的容器。我们来对代码进行一下转换：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function prepare(){
    return function (x){
        let fn2Result = (new Task(x)).step(fn1).step(fn2); 
        return requireFn2Result(fn2Result);
    }    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同理继续来简化前置步骤:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//暂时先忽略函数声明的位置
let requireFn2Result = goStep(fn3);
let requireFn1Result = goStep(fn2);
let requireInitResult = goStep(fn1);

function prepare(){
    return function (x){
        let InitResult = new Task(x);
        return requireFn2Result(requireFn1Result(requireInitResult(InitResult)));
    }    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然已经这样了，索性再向前一步，把&lt;code&gt;new Task(x)&lt;/code&gt;也函数化好了：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let createTask = function(x){
    return new Task(x);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;函数化的代码&quot;&gt;3.3 函数化的代码&lt;/h3&gt;
&lt;p&gt;或许你已经被上面的一系列转化弄得晕头转向，我们暂停一下，来看看函数化后的代码变成了什么样子:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function prepare(){
    return function (x){
        return requireFn2Result(requireFn1Result(requireInitResult(createTask(x))));
    }    
}
let f = prepare();
let y = f(x);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的编码模式将核心业务逻辑在空间上放在一起，而把具体的实现封装起来，让开发者更容易看到一个需求实现过程的全貌。&lt;/p&gt;
&lt;h3 id=&quot;休息一下&quot;&gt;3.4 休息一下&lt;/h3&gt;
&lt;p&gt;不知道你是否有注意到，在中间环节的组装过程中，其实并没有任何&lt;strong&gt;真实的数据&lt;/strong&gt;出现，我们只使用了暂态的抽象数据来帮助我们写出&lt;strong&gt;映射方法f&lt;/strong&gt;的细节，而随后&lt;em&gt;暂态的数据&lt;/em&gt;又被新的函数取代，逐级迭代，直到暂态数据最终指向了最外层函数的形参，你可以重新审视一下上面的推演过程来体会函数式编程带来的变化，这个点是非常重要的。&lt;/p&gt;
&lt;h3 id=&quot;进一步抽象&quot;&gt;3.5 进一步抽象&lt;/h3&gt;
&lt;p&gt;3.3节中函数化的代码中，存在一个很长的嵌套调用，如果业务逻辑步骤过多，那么这行代码会变得很长，同时也很难阅读，我们需要通过一些手段将这些中间环节的函数展开为一种扁平化的写法。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
*定义一个工具函数compose,接受两个函数作为参数，返回一个新函数
*新函数接受一个x作为入参，然后实现函数的迭代调用。
*/
var compose = function (f, g) {
    return function (x) {
        return f(g(x));
    }
};
/**
*升级版本的compose函数，接受一组函数，实现左侧函数包裹右侧函数的形态
*/
let composeEx = function (...args) {
    return (x)=&amp;gt;args.reduceRight((pre,cur)=&amp;gt;cur(pre),x);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看不懂的同学需要补补基础课了，需要注意的是&lt;strong&gt;工具函数返回的仍然是一个函数&lt;/strong&gt;，我们使用上面的工具函数来重写一下3.3小节中的代码:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let pipeline = composeEx(requireFn2Result,requireFn1Result,requireInitResult,createTask);
function prepare(){
    return function (x){
        return pipeline(x);
    }    
}
let f = prepare();
let y = f(x);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还要继续？必须的，希望你还没有抓狂。代码中我们先执行&lt;code&gt;prepare( )&lt;/code&gt;方法来得到一个新函数&lt;code&gt;f&lt;/code&gt;，&lt;code&gt;f&lt;/code&gt;执行时接收一个参数&lt;code&gt;x&lt;/code&gt;，然后把&lt;code&gt;x&lt;/code&gt;传入pipeline方法，并返回&lt;code&gt;pipeline(x)&lt;/code&gt;。我们来进行一下对比：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//prepare执行后得到的新函数
let f = x =&amp;gt; pipeline(x);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或许你已经发现了问题所在，这里的&lt;code&gt;f&lt;/code&gt;函数相当于&lt;code&gt;pipeline&lt;/code&gt;方法的代理，但这个代理什么额外的动作都没有做，相当于只是在函数调用栈中凭空增加了一层，但是执行了相同的动作。如果你能够理解这一点，就可以得出下面的转化结果：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let f = pipeline;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是很神奇？顺便提一下，它的术语叫做&lt;code&gt;point free&lt;/code&gt;,当你深入学习&lt;strong&gt;【函数式编程】&lt;/strong&gt;时就会接触到。&lt;/p&gt;
&lt;h3 id=&quot;完整的转换代码&quot;&gt;3.6 完整的转换代码&lt;/h3&gt;
&lt;p&gt;我们再进行一些简易的抽象和整理，然后得到完整的流程:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let composeEx = (...args) =&amp;gt; (x) =&amp;gt; args.reduceRight((pre,cur) =&amp;gt;cur(pre),x);
let getValue = (obj) =&amp;gt; obj.value;
let createTask = (x) =&amp;gt; new Task(x);
/*goStep执行后得到的函数也满足前面提到的“let f=(x)=&amp;gt;g(x)”的形式，可以将其pointfree化.
let goStep = (fn)=&amp;gt;(params)=&amp;gt;composeEx(createTask, fn, getValue)(params);
let requireFn2Result = goStep(fn3);
*/
let requireFn2Result = composeEx(createTask,fn3,getValue);
let requireFn1Result = composeEx(createTask,fn2,getValue);
let requireInitResult = composeEx(createTask,fn1,getValue);
let pipeline = composeEx(requireFn2Result,requireFn1Result,requireInitResult,createTask);
let f = pipeline;
let y = f(x);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到我们定义完方法后，像搭积木一样把它们组合在一起，就得到了一个可以实现目标功能的函数。&lt;/p&gt;
&lt;h3 id=&quot;为什么它看起来变得更复杂了&quot;&gt;3.7 为什么它看起来变得更复杂了&lt;/h3&gt;
&lt;p&gt;如果只看上面的示例，的确是这样的，上面的示例只是为了&lt;strong&gt;展示函数式编程让代码向着怎样一个方向去变化&lt;/strong&gt;而已，而并没有展示出函数式编程的优势，这种转变和一个&lt;code&gt;jQuery&lt;/code&gt;开发者刚开始使用诸如&lt;code&gt;angular&lt;/code&gt;,&lt;code&gt;vue&lt;/code&gt;,&lt;code&gt;React&lt;/code&gt;框架时感受到的强烈不适感是很相似的，毕竟思想的转变是非常困难的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面向对象编程&lt;/strong&gt;写出的代码看起来就像是一个巨大的关系网和逻辑流程图，比如连续读其中10行代码，你或许能够很清晰地看到某个步骤执行前和执行后程序的状态，但是却很难看清整体的业务逻辑流程；而&lt;strong&gt;函数式编程&lt;/strong&gt;正好是相反的，你可以在短短的10行代码中看到整个业务流程，当你想去深究某个具体步骤时，再继续展开，另一方面，关注&lt;strong&gt;数据和函数组合&lt;/strong&gt;可以将你从复杂的&lt;code&gt;this&lt;/code&gt;和对象的关系网中解放出来。&lt;/p&gt;
&lt;h2 id=&quot;四.-两个主角&quot;&gt;四. 两个主角&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;数据&lt;/strong&gt;和&lt;strong&gt;函数&lt;/strong&gt;是&lt;strong&gt;【函数式编程】&lt;/strong&gt;中的两大核心概念，它为我们提供了用数学的眼光看世界的独特视角，同时它也更程序员该有的思维模式——设计程序，而不是仅仅是复现业务逻辑：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;程序设计 = 数据结构 + 算法   Vs   函数式编程 = 数据 + 函数    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但为了更加安全有效地使用，它们和传统编程中的同名概念相比多了一些限制。&lt;/p&gt;
&lt;h3 id=&quot;函数vs纯函数&quot;&gt;函数Vs纯函数&lt;/h3&gt;
&lt;p&gt;函数式编程中所传递和使用的函数，被要求为&lt;strong&gt;【纯函数】&lt;/strong&gt;。纯函数需要满足如下两个条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只依赖自己的参数&lt;/li&gt;
&lt;li&gt;执行过程没有副作用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么纯函数只能依赖自己的参数？因为只有这样，我们才不必在对函数进行传递和组合的时候小心翼翼，生怕在某个环节弄丢了&lt;code&gt;this&lt;/code&gt;的指向，如果&lt;code&gt;this&lt;/code&gt;直接报错还好，如果指向了错误的数据，程序本身在运行时也不会报错，这种情况的调试是非常令人头疼的，除了逐行运行并检查对应数据的状态，几乎没什么高效的方法。面向对象的编程中，我们不得不使用很多&lt;code&gt;bind&lt;/code&gt;函数来绑定一个函数的&lt;code&gt;this&lt;/code&gt;指向，而&lt;strong&gt;纯函数&lt;/strong&gt;就不存在这样的问题。来看这样两个函数：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;var a = 1;
function inc(x){
    return a + x;
}
function pureInc(x){
    let a = 1;
    return x + a;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于&lt;code&gt;inc&lt;/code&gt;这个函数来说，改变外部条件a的值就会造成&lt;code&gt;inc&lt;/code&gt;函数对于同样的入参得到不同的结果的情况，换言之在入参确定为3的前提下，每次执行&lt;code&gt;inc(3)&lt;/code&gt;得到的结果是不确定的，所以它是不纯的。而&lt;code&gt;pureInc&lt;/code&gt;函数就不依赖于外界条件的变化，&lt;code&gt;pureInc(3)&lt;/code&gt;无论执行多少次，无论外界参数如何变化，其输出结果都是确定的。&lt;/p&gt;
&lt;p&gt;在面向对象的编程中，我们写的函数通常都不是纯函数，因为编程中或多或少都需要在不同的函数中共享一些标记状态的变量，我们更倾向与将其放在更高层的作用域里，通过&lt;strong&gt;标识符的右查询会沿作用域链寻找&lt;/strong&gt;的机制来实现数据共享。&lt;/p&gt;
&lt;p&gt;什么是函数的副作用呢？一个函数执行过程对产生了外部可观察的变化那么就说这个函数是有副作用的。最常见的情况就是函数接受一个对象作为参数，但是在函数内部对其进行了修改，&lt;code&gt;javascript&lt;/code&gt;中函数在传递对象参数时会将其地址传入调用的函数，所以函数内部所做的修改也会同步反应到函数外部，这种副作用会在函数组合时造成最终数据的不可预测性，因为有关某个对象的函数都有可能得到不确定的输出。&lt;/p&gt;
&lt;h3 id=&quot;数据vs不可变数据&quot;&gt;数据Vs不可变数据&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;javascript&lt;/code&gt;中的对象很强大也很灵活，可并不是所有的场景中我们都需要这种灵活性。来看这样一个例子：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let a = {
    name:'tony'
}
let b = a;
modify(b);
console.log(a.name);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们无法确定上面的输出结果，因为&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;这两个标识符指向了堆中的相同的地址，可外界无法知道在&lt;code&gt;modify函数&lt;/code&gt;中是否对&lt;code&gt;b&lt;/code&gt;的属性做出了修改。有些场景中为了使得逻辑过程更加可靠，我们不希望后续的操作和处理对最原始的数据造成影响，这个时候我们很确定需要拿到一个数据集的复制（比如拿到表格的总数据，在实现某些过滤功能的时候，通常需要留存一个表格数据的备份，以便取消过滤时可以恢复原貌），这就引出了老生常谈的&lt;strong&gt;深拷贝和浅拷贝&lt;/strong&gt;的话题。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;【深拷贝】是一种典型的防御性编程，因为在浅拷贝的机制下，修改对象属性的时候会影响到所有指向它的标识符，从而造成不可预测的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;javascript&lt;/code&gt;中，常见的&lt;strong&gt;深拷贝&lt;/strong&gt;都是通过递归来实现的，然后利用语言特性做出一些代码层面的优化，例如各个第三方库中的&lt;code&gt;extend( )&lt;/code&gt;方法或者&lt;code&gt;deepClone( )&lt;/code&gt;。可是当一个结构很深或者复杂度很高时，深拷贝的耗时就会大幅增加，有的时候我们关注的可能只是数据结构中的一部分，也就是说新老对象中很大一部分数据是一致的，可以共享的，但深拷贝过程中忽视了这种情况而简单粗暴地对整个对象进行递归遍历和克隆。&lt;/p&gt;
&lt;p&gt;事实上&lt;strong&gt;【深拷贝】&lt;/strong&gt;并不是防御性编程的唯一方法，&lt;code&gt;Facebook&lt;/code&gt;的&lt;code&gt;Immutable.js&lt;/code&gt;就用&lt;strong&gt;不可变数据&lt;/strong&gt;的思路来解决这个问题，它将对象这种引用值变得更像原始值（&lt;code&gt;javascript&lt;/code&gt;中的原始值创建后是不能修改的）。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//Immutable.js官网示例
 var map1 = Immutable.Map({ a: 1, b: 2, c: 3 });
 var map2 = map1.set('b', 50);
 map1.get('b'); // 2
 map2.get('b'); // 50&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以查看&lt;a href=&quot;https://facebook.github.io/immutable-js/&quot;&gt;【Immutable.js官方文档】&lt;/a&gt;来了解如何使用它，通常它是结合&lt;code&gt;React&lt;/code&gt;全家桶一起使用的。如果你对其实现原理感兴趣，可以查看&lt;a href=&quot;https://juejin.im/post/5b9b30a35188255c6418e67c&quot;&gt;《深入探究Immutable.js的实现机制》&lt;/a&gt;一文或者查看其他资料，来了解一下&lt;strong&gt;Hash树&lt;/strong&gt;和&lt;strong&gt;Trie树&lt;/strong&gt;是如何作为Immutable的算法基础而被应用的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当标识符指向不变的数据，当函数没有副作用，就可以大胆广泛地使用函数式编程了&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;四.-前端的学习路线&quot;&gt;四. 前端的学习路线&lt;/h2&gt;
&lt;ul readability=&quot;16.187169312169&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;javascript基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你能够很清楚&lt;code&gt;高阶函数&lt;/code&gt;，&lt;code&gt;柯里化&lt;/code&gt;，&lt;code&gt;反柯里化&lt;/code&gt;这些关键词的含义和一般用途，并且至少了解&lt;code&gt;Array&lt;/code&gt;的&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;reduce&lt;/code&gt;方法做了什么事情，那么就可以进行下一步。否则就需要好好复习一下&lt;code&gt;javascript&lt;/code&gt;的基础知识。在&lt;code&gt;javascript&lt;/code&gt;中进行函数式编程会反复涉及到这些基本技术的运用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;《javascript函数式编程指南》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;地址：https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/&lt;/p&gt;
&lt;p&gt;这是一本来自于&lt;strong&gt;gitbook&lt;/strong&gt;的翻译版的非常棒的开源电子书，这本书很棒，但是如果将函数式编程的相关知识分为初中高级的话，这本书似乎只涵盖了初级和高级，而省略了中级的部分，当内容涉及到范畴论和代数结构的时候，理解难度会突然一下变得很大。当你读不懂的时候可以先停下来，用下一个资料进行过渡，然后回过头来再继续阅读后续的部分。&lt;/p&gt;
&lt;p&gt;同时提一句，翻译者@胡子大哈也是之前提及的那本著名的&lt;strong&gt;《React小书》&lt;/strong&gt;的主要作者。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;Ramda.js官网博文集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;地址：https://ramdajs.com/&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Ramda.js&lt;/code&gt;为&lt;code&gt;javascript&lt;/code&gt;提供了一系列函数式编程的工具函数，但官网的&lt;strong&gt;《Thinking In Ramda》&lt;/strong&gt;系列教程，是非常好的中级教程，结合&lt;code&gt;Ramda&lt;/code&gt;的API进行讲解，让开发者更容易理解函数式编程，它正好弥补了前一个资料中没有中级教程的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Ramda.js的API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不得不说很多前端开发者都是从&lt;strong&gt;API&lt;/strong&gt;开始学习函数式编程的，但很快就会发现学了和没学差不多，因为没有理论基础，你很难知道该去使用它。就好像给了你最顶尖的工具，你也没法一次性就做出好吃的牛排，因为你不会做。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Rx.js和Immutable.js&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事实上笔者自己也还没有进行到这个阶段的学习，&lt;code&gt;Rx.js&lt;/code&gt;是隶属于&lt;code&gt;Angular&lt;/code&gt;全家桶的，&lt;code&gt;Immutable.js&lt;/code&gt;是隶属于&lt;code&gt;React&lt;/code&gt;全家桶的，即使在自己目前的工作中没有直接使用到，你也应该了解它们。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.2687074829932&quot;&gt;
&lt;p&gt;&lt;strong&gt;代数结构的理论基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://github.com/fantasyland/fantasy-land&quot; class=&quot;uri&quot;&gt;https://github.com/fantasyland/fantasy-land&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当你具备了基本的使用能力，想要更上一层楼的时候，就需要重新整合函数式编程的理论体系。这个项目用于解释函数式编程的理论基础中各类术语及相关用途。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;五.-小结&quot;&gt;五. 小结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;【函数式编程】&lt;/strong&gt;为我们展现了&lt;code&gt;javascript&lt;/code&gt;语言的另一种灵活性。&lt;/p&gt;
&lt;p&gt;开发人员会发现自己可以从更宏观地角度来观察整个业务流程，而不是往返于业务逻辑和实现细节之间。&lt;/p&gt;
&lt;p&gt;测试人员会发现它很容易进行单元测试，不仅因为它的纯函数特性，也因为数据和动作被分离了。&lt;/p&gt;
&lt;p&gt;游戏玩家会发现它和自己在《我的世界》里用方块来搭建世界就是这样子的。&lt;/p&gt;
&lt;p&gt;工程师会发现它和对照零件图纸编写整个加工流水线的工艺流程时就是这样做的。&lt;/p&gt;
&lt;p&gt;数学家会说用数学的思维是可以描述世界的（如果你接触过数学建模应该会更容易明白）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【函数式编程】&lt;/strong&gt;让开发者理解程序设计这件事本质是是一种设计，是一种创造行为，和其他通过组合功能单元而得到更强大的功能单元的行为没有本质区别。&lt;/p&gt;
</description>
<pubDate>Wed, 17 Oct 2018 13:53:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>一. 箭头函数 箭头函数是 语法中加入的新特性，而它也是许多开发者对 仅有的了解，每当面试里被问到关于 “ 里添加了哪些新特性？” 这种问题的时候，几乎总是会拿箭头函数来应付。箭头函数， ，没有自己的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/9807398.html</dc:identifier>
</item>
<item>
<title>c语言数字图像处理（六）：二维离散傅里叶变换 - GoleBeetle</title>
<link>http://www.cnblogs.com/GoldBeetle/p/9807399.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GoldBeetle/p/9807399.html</guid>
<description>&lt;h2&gt;基础知识&lt;/h2&gt;
&lt;h3&gt;复数表示&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;C = R + jI&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;极坐标：C = |C|(cosθ + jsinθ)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;欧拉公式：C = |C|e&lt;sup&gt;jθ&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有关更多的时域与复频域的知识可以学习复变函数与积分变换，本篇文章只给出DFT公式，性质，以及实现方法&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二维离散傅里叶变换(DFT)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181017211845913-467299431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中f(x,y)为原图像，F(u,v)为傅里叶变换以后的结果，根据欧拉公式可得，每个F(u,v)值都为复数，由实部和虚部组成&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;代码示例&lt;/span&gt;&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; dft(&lt;span&gt;short&lt;/span&gt;** in_array, &lt;span&gt;double&lt;/span&gt;** re_array, &lt;span&gt;double&lt;/span&gt;** im_array, &lt;span&gt;long&lt;/span&gt; height, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; width)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;double&lt;/span&gt;&lt;span&gt; re, im, temp;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; height; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; width; j++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             re = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             im = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;; x &amp;lt; height; x++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; y = &lt;span&gt;0&lt;/span&gt;; y &amp;lt; width; y++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     temp = (&lt;span&gt;double&lt;/span&gt;)i * x / (&lt;span&gt;double&lt;/span&gt;)height + 
&lt;span&gt;13&lt;/span&gt;                            (&lt;span&gt;double&lt;/span&gt;)j * y / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)width;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     re += in_array[x][y] * cos(-&lt;span&gt;2&lt;/span&gt; * pi *&lt;span&gt; temp);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     im += in_array[x][y] * sin(-&lt;span&gt;2&lt;/span&gt; * pi *&lt;span&gt; temp);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             
&lt;span&gt;19&lt;/span&gt;             re_array[i][j] =&lt;span&gt; re;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             im_array[i][j] =&lt;span&gt; im;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dft done\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;傅里叶谱&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181017213010186-639485487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;相角&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181017213029805-1479513811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;功率谱&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181017213210517-1791243761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;傅里叶变换频谱图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181017213319460-1007574918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181017213340415-2031601227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于上面得两幅图案，在区间[0, M-1]中，变换数据由两个在点M/2处碰面的背靠背的半个周期组成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181017213536810-1535982847.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;针对显示和滤波的目的，在该区间中有一个完整的变换周期更加方便，因为完整周期中数据是连续的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181017213712760-976868422.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们希望得到上图所示的图案&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;傅里叶变换的平移性质&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181017213854660-1884928505.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此对每个f(x, y)项乘以(-1)&lt;sup&gt;x+y&lt;/sup&gt;可达目的&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;代码示例&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fre_spectrum(&lt;span&gt;short&lt;/span&gt; **in_array, &lt;span&gt;short&lt;/span&gt; **out_array, &lt;span&gt;long&lt;/span&gt; height, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; width)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;double&lt;/span&gt;&lt;span&gt; re, im, temp;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; move;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; height; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; width; j++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             re = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             im = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;; x &amp;lt; height; x++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; y = &lt;span&gt;0&lt;/span&gt;; y &amp;lt; width; y++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     temp = (&lt;span&gt;double&lt;/span&gt;)i * x / (&lt;span&gt;double&lt;/span&gt;)height + 
&lt;span&gt;14&lt;/span&gt;                            (&lt;span&gt;double&lt;/span&gt;)j * y / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)width;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     move = (x + y) % &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt; ? &lt;span&gt;1&lt;/span&gt; : -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     re += in_array[x][y] * cos(-&lt;span&gt;2&lt;/span&gt; * pi * temp) *&lt;span&gt; move;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     im += in_array[x][y] * sin(-&lt;span&gt;2&lt;/span&gt; * pi * temp) *&lt;span&gt; move;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             
&lt;span&gt;21&lt;/span&gt;             out_array[i][j] = (&lt;span&gt;short&lt;/span&gt;)(sqrt(re*re + im*im) / sqrt(width*&lt;span&gt;height));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (out_array[i][j] &amp;gt; &lt;span&gt;0xff&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 out_array[i][j] = &lt;span&gt;0xff&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (out_array[i][j] &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 out_array[i][j] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;  &lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;执行结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181017214125012-2099881661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181017214151601-454079785.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;旋转性质&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181017214319491-1352951890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181017214329006-2070659479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即f(x, y)旋转一个角度，F(u, v)旋转相同的角度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181017214417341-1238722155.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 二维离散傅里叶反变换&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1371185/201810/1371185-20181017214632174-1575480782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;代码示例&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; idft(&lt;span&gt;double&lt;/span&gt;** re_array, &lt;span&gt;double&lt;/span&gt;** im_array, &lt;span&gt;short&lt;/span&gt;** out_array, &lt;span&gt;long&lt;/span&gt; height, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; width)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;double&lt;/span&gt;&lt;span&gt; real, temp;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; height; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; width; j++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             real = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;; x &amp;lt; height; x++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; y = &lt;span&gt;0&lt;/span&gt;; y &amp;lt; width; y++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     temp = (&lt;span&gt;double&lt;/span&gt;)i * x / (&lt;span&gt;double&lt;/span&gt;)height + 
&lt;span&gt;12&lt;/span&gt;                            (&lt;span&gt;double&lt;/span&gt;)j * y / (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)width;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;                     real += re_array[x][y] * cos(&lt;span&gt;2&lt;/span&gt; * pi * temp) -
&lt;span&gt;15&lt;/span&gt;                             im_array[x][y] * sin(&lt;span&gt;2&lt;/span&gt; * pi *&lt;span&gt; temp);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             
&lt;span&gt;19&lt;/span&gt;             out_array[i][j] = (&lt;span&gt;short&lt;/span&gt;)(real / sqrt(width*&lt;span&gt;height));
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (out_array[i][j] &amp;gt; &lt;span&gt;0xff&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 out_array[i][j] = &lt;span&gt;0xff&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (out_array[i][j] &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 out_array[i][j] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;idft done\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;经验证，图像经傅里叶变换，然后再反变换以后可恢复原图&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;改进&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;本篇文章只是按照二维离散傅里叶变换公式进行了实现，在测试的过程中发现，执行速度真的是非常慢，算法时间复杂度O(n&lt;sup&gt;4&lt;/sup&gt;)，等以后有时间再对这段代码进行优化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 17 Oct 2018 13:53:00 +0000</pubDate>
<dc:creator>GoleBeetle</dc:creator>
<og:description>基础知识 复数表示 C = R + jI 极坐标：C = |C|(cosθ + jsinθ) 欧拉公式：C = |C|ejθ 有关更多的时域与复频域的知识可以学习复变函数与积分变换，本篇文章只给出DF</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GoldBeetle/p/9807399.html</dc:identifier>
</item>
</channel>
</rss>