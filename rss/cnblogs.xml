<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>自定义滚动条样式-transition无效 - chenby</title>
<link>http://www.cnblogs.com/dh-dh/p/9592347.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dh-dh/p/9592347.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;需求是自定义滚动条样式，然后2秒内无操作隐藏滚动条。&lt;/p&gt;
&lt;p&gt;2s内隐藏比较麻烦，不能用css实现，只能监听容器的touch事件，然后给滚动条加个&lt;code&gt;opacity: 0&lt;/code&gt;的class。&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.class::-webkit-scrollbar{
   width: 10px;
   -webkit-transition: all 1s;
   transition: all 1s;
}
.class::-webkit-scrollbar-thumb{
     border-radius:  5px;
     background-color: gray;
}
.class.hide::-webkit-scrollbar{
    opacity: 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要在touch事件触发2s后给container加上.hide的class。为了实现过渡效果，我加了&lt;code&gt;transition: all 1s&lt;/code&gt;。然而并没有用&lt;/p&gt;
&lt;blockquote readability=&quot;1.8421052631579&quot;&gt;
&lt;p&gt;stackoverflow上也有相关提问 &lt;a href=&quot;https://stackoverflow.com/questions/19230289/use-transition-on-webkit-scrollbar&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/19230289/use-transition-on-webkit-scrollbar&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;解决&quot;&gt;解决&lt;/h2&gt;
&lt;p&gt;事实证明，scrollbar上面是不允许用transition的。&lt;br/&gt;Short answer: No, it's not possible to use transition on a ::-webkit-scrollbar&lt;/p&gt;
&lt;p&gt;不过网友给了很多hack方案。&lt;br/&gt;我下面介绍一种。如果不想听可以直接看例子：&lt;a href=&quot;https://codepen.io/waterplea/pen/dVMopv&quot; class=&quot;uri&quot;&gt;https://codepen.io/waterplea/pen/dVMopv&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;解决原理&quot;&gt;解决原理&lt;/h2&gt;
&lt;p&gt;简单来说就是在元素上加transition，而不是在scrollbar伪类上。&lt;br/&gt;利用-webkit-scrollbar-thumb的color继承自该元素，该元素transition color的时候，滚动条的color也会transition。剩下的就是用color实现一个滚动条了。&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.class::-webkit-scrollbar-thumb{
     border-radius:  5px;
     box-shadow: inset 0 0 0 5px; // 用box-shadow模拟滚动条
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.class {
   -webkit-transition: all 1s;
   transition: all 1s;
}
.class.hide {
    color: transparent!important;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果该元素有文字咋办？&lt;br/&gt;我们用该元素的color属性做滚动条的颜色，那该元素的字体就要换个了。&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.class {
 text-shadow: 0 0 #fff;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用text-shadow指定字体颜色。&lt;/p&gt;
&lt;p&gt;over！&lt;/p&gt;
</description>
<pubDate>Wed, 05 Sep 2018 07:26:00 +0000</pubDate>
<dc:creator>chenby</dc:creator>
<og:description>问题 需求是自定义滚动条样式，然后2秒内无操作隐藏滚动条。 2s内隐藏比较麻烦，不能用css实现，只能监听容器的touch事件，然后给滚动条加个 的class。 需要在touch事件触发2s后给con</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dh-dh/p/9592347.html</dc:identifier>
</item>
<item>
<title>JVM系列之一：Java虚拟机 - 以墨为码</title>
<link>http://www.cnblogs.com/black-Lr/p/9592195.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/black-Lr/p/9592195.html</guid>
<description>&lt;p&gt;&lt;strong&gt;什么是Java虚拟机？&lt;/strong&gt;&lt;br/&gt;      Java虚拟机，从字面上来看，像是某种机器，但Java虚拟机之所以被称之为“虚拟”的，是因为它是由一个规范来定义的抽象计算机，所以在我们说Java虚拟机的时候，可能指的是如下三种不同的东西：&lt;br/&gt;    　　&lt;strong&gt;抽象规范&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;    　　一个具体的实现&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;    　　一个运行中的虚拟机实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; Java虚拟机的生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　当启动一个Java程序时，一个虚拟机实例也就诞生了。该程序关闭退出时，虚拟机实例也就随之消亡。Java虚拟机通过调用某个初始类的main()方法作为Java程序运行的起点。在Java虚拟机内容，有两种线程，&lt;strong&gt;守护线程&lt;/strong&gt;和&lt;strong&gt;非守护线程&lt;/strong&gt;。守护线程一般为虚拟机自己使用，比如垃圾收集线程，非守护线程比如运行main()的线程。当程序中所有非守护线程终止时，则虚拟机实例自动退出。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java虚拟机的体系结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在Java虚拟机规范中，一个虚拟机实例的行为按照子系统、内存区、数据类型以及指令几个术语来描述。每个Java虚拟机都有一个类装载子系统，它根据全限定名来装入系统，同样，每个Java虚拟机都有一个执行引擎，它负责执行那些包含在被装载类的方法中的指令。&lt;/p&gt;
&lt;p&gt;　　                                                           &lt;img src=&quot;https://images2018.cnblogs.com/blog/1194154/201808/1194154-20180827094313418-1916539128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当Java虚拟机运行一个程序时，它需要内存来存储许多东西，比如，字节码、对象、局部变量、运算的中间结果等。某些运行时数据区由程序中所有线程共享，还有一些只能由一个线程拥有。每个虚拟机都有一个方法区和一个堆，他们是由该虚拟机中所有线程共享的。当虚拟机装载一个class文件时，会把类型信息存入方法区，程序运行时虚拟机会把运行时创建的对象存入堆中。&lt;/p&gt;
&lt;p&gt;　　每当一个新线程创建的时候，它都将获得它自己的PC寄存器和一个Java栈，若线程正在执行一个Java方法（非本地方法）,那么PC计数器的值总是指示下一条将被执行的指令，Java栈则包含线程中Java方法的调用状态----包括它的局部变量，被调用时传进来的参数、它的返回值、计算的中间结果等。本地方法调用，则是以某种依赖于具体实现的方式存储在本地方法栈中，也可能是寄存器和其他某些与特定实现相关的内存区。&lt;/p&gt;
&lt;p&gt;　　Java栈是由许多栈帧或者说帧组成，一个栈帧包含一个Java方法的调用状态。当线程调用一个Java方法时，虚拟机压入一个新的栈帧到栈中，方法返回后此栈帧弹出并抛弃。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　数据类型可分为两类：基本类型和引用类型，基本类型持有原始值，引用类型持有引用值。Java基本类型的值域在任何地方都是一致的，比如一个long类型在任何虚拟机中都是64位二进制补码表示的有符号整数。&lt;/p&gt;
&lt;p&gt;                                             &lt;img src=&quot;https://images2018.cnblogs.com/blog/1194154/201808/1194154-20180827155514300-528803402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　注意：boolean有些特别，虽然boolean也是基本类型，但是在编译为字节码时，它会用int或者byte来表示boolean，false表示为整数0，true为整数1。另外boolean数组是被当做byte数组类访问的。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;                       &lt;img src=&quot;https://images2018.cnblogs.com/blog/1194154/201808/1194154-20180827160548674-214628905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字长的考量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Java虚拟机中，最基本的数据单元就是字，虚拟机实现者最少选择32位作为字长，或者选择更为高效的字长。通常根据底层主机平台的指针长度来选择字长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类装载器子系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Java虚拟机中有两种类装载器：启动类装载器和用户自定义装载器。前者是Java虚拟机实现的一部分，后者是Java程序的一部分。不同类装载器放在虚拟机内部的不同命名空间中。&lt;/p&gt;
&lt;p&gt;　　ClassLoader中定义的方法为程序提供了访问类装载器机制的接口。每一个被装载的类型，Java虚拟机都会为它创建一个java.lang.Class类的实例来代表该类型。用户自定义的类装载器以及Class类的实例都放在内存中的堆区，而装载的类型信息则都位于方法区。&lt;/p&gt;
&lt;p&gt;　　类装载器除了要定位和导入二进制class文件外，还需要负责导入类的正确性，分配变量和初始化内存，解析符号引用等。这些动作必须严格按照以下步骤进行：&lt;/p&gt;
&lt;p&gt;　　1、装载 -------- 查找并载入二进制数据&lt;/p&gt;
&lt;p&gt;　　2、连接 -------- 执行验证，准备，已经解析（可选）&lt;/p&gt;
&lt;p&gt;　　　　验证： 确保被导入类型的正确性&lt;/p&gt;
&lt;p&gt;　　　　准备：为类变量分配内存，并将其初始化为默认值&lt;/p&gt;
&lt;p&gt;　　　　解析：把类型中的符号引用转换为直接引用&lt;/p&gt;
&lt;p&gt;　　3、初始化 -------- 把类变量初始化为正确的初始值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在Java虚拟机中，关于被装载类型的信息存储在一个逻辑上被称为方法区的内存中。当虚拟机装载某个类型时，首先使用类装载器定位相应的class文件，然后读入class文件 ------- 一个线性二进制数据流，然后将它传输到虚拟机中。之后虚拟机提取出其中的类型信息存入方法区，同时该类中的静态变量也是存储在方法区中。&lt;/p&gt;
&lt;p&gt;　　所有线程都共享方法区，所以它们对方法区的访问必须为线程安全的，比如，如果两个线程同时都企图访问名为Lava的类，而此类尚未装载进虚拟机，那么，这时只应该有一个线程去装载它，另一个只能等待。&lt;/p&gt;
&lt;p&gt;　　方法区大小不是固定的，可以根据需要自己调整。同样方法区也不必是连续的，方法区可以在同一个堆中自由分配，也可以由程序员指定方法区的初始大小的最大尺寸和最小尺寸等。&lt;/p&gt;
&lt;p&gt;　　方法区也可以被垃圾收集，虚拟机允许用户定义的类装载器来动态扩展Java程序（反射）,因此一些类也会成为程序“不再引用”的类。当某个类不再被引用时，Java虚拟机可以卸载此类。&lt;/p&gt;
&lt;p&gt;　　对应每个装载的类型，虚拟机会在方法区存储以下类型信息：&lt;/p&gt;
&lt;p&gt;　　　&lt;strong&gt;　此类的全限定名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　此类的直接超类全限定名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　此类是类类型还是接口类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　此类的访问修饰符　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　任何直接超类的全限定名的有序列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　除以上列出的基本类型信息，虚拟机还得为每个装载的类型存储以下信息&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;该类型的常量池　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　字段信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　方法信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　除了常量以外所有类的(静态)变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　一个到类的ClassLoader引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　一个到Class类的引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Java程序运行时创建的所有类实例和数组都放在同一个堆中，而一个Java虚拟机实例中只有存在一个堆空间，因此所有线程都将共享这个堆。由于每一个Java程序独占一个堆空间，因此所有的线程将共享这个堆。但是同一个程序的多个线程却共享着同一个空间，此种情况下，需要考虑多线程访问对象（堆数据）的同步问题。&lt;/p&gt;
&lt;p&gt;　　Java虚拟机有一条在堆中分配新对象的指令，却没有释放内存的指令。正如我们无法用Java代码去明确释放一个对象一样，字节码中也没有相关功能。需要虚拟机自己负责决定如何已及何时开始垃圾收集。程序本身也不需要关心何时回收，通常虚拟机把这个任务交给垃圾收集器。&lt;/p&gt;
&lt;p&gt;　　Java虚拟机规范并没有规定Java对象在堆中是如何表示的。对象的内部表示影响整个堆以及垃圾收集器的设计，它由虚拟机的实现者决定。&lt;/p&gt;
&lt;p&gt;　　一种可能的堆空间设计为，把堆分为两个部分：一个句柄池，一个对象池，而一个对象引用则是指向句柄池的本地指针。句柄池分为两个部分：一个指向对象实例变量的指针，一个指向方法区类型的指针。这种设计的有点为有利于堆碎片的整理，缺点为每次访问对象都要经过两次指针的传递。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194154/201808/1194154-20180830161352450-1473048109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　另一种设计是使对象指针直接指向一组数据，而该数据包括对象的实例以及方法区中的类数据指针。此设计优缺点与上一中方法正好相反。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194154/201808/1194154-20180830161638749-1214190075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　虚拟机必须要能通过对象的引用获取到类(类型)数据：在程序运行时需要转换某个对象引用为另一种类型时，虚拟机需要检查这种转换是否被允许，及被转换的对象是否确定是被引用的类型以及它的超类。比如程序执行instanceof()时，虚拟机都需要查看被引用数据的对象的类数据。最后，当程序中调用某个实例方法时，虚拟机必须进行动态绑定。&lt;/p&gt;
&lt;p&gt;　　不管虚拟机的实现是用了什么样的对象表示法，每个对象都可能有一个方法表，因为方法表可以加快调用实例的速度。但是Java虚拟机的实现规范中并未要求必须使用方法表，所有并不是所有实现都会使用它。而且为每一个对象都建一个方法表会占用更多的内存，所以该方案只适用于内存足够的系统。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194154/201808/1194154-20180830173437496-1233735546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图中展示了一种把方法表和对象引用联系起来的方式，每个对象都包含一个指向特殊数据结构的指针，这个数据结构位于方法区，它包括两部分：&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;一个指向方法区对应类数据的指针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　此对象的方法表：方法表是一个指针数组，其中每一项都是一个“实例方法的指针”，方法表指向的实例方法数据包括以下信息：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　此方法的操作数栈和局部变量区的大小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　此方法的字节码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　异常表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 方法表中包含方法指针，指向类或其超类声明的方法数据：也就是说方法表中所指向的方法可能是此类声明的，也可能是继承下来的。&lt;/p&gt;
&lt;p&gt;　　堆上的对象数据中还有一个逻辑部分，那就是对象锁，这是一个互斥对象。虚拟机上每个对象都有一个对象锁，被用于协调多个线程访问同一个对象的同步。在任何时刻，只能由一个线程“拥有”这个对象锁，因此只有这个线程能访问此对象的数据，其他想访问此对象的线程只能等待，直到拥有此锁的线程释放锁。（&lt;em&gt;某个线程拥有一个对象锁后，可以继续对此锁追加请求。需要注意的是，请求几次，对应地需要释放几次，比如一个线程请求了三次锁，在它释放三次锁之前，他一直“拥有”此锁&lt;/em&gt;）。很多对象在其生命周期内没有被任何线程加锁，所以锁数据不是必须存在的，只有在第一次加锁的时候才会分配锁数据，这时虚拟机需要用某种方法来联系对象数据和对应的锁数据，比如把锁数据放在一个以对象地址为索引的搜索树中。&lt;/p&gt;
&lt;p&gt;　　除了实现锁所需要的数据外，每个Java对象逻辑上与实现等待集合的数据相关联。等待集合和通知方法联合使用，每个类都从Object继承三个等待方法（三个名为wait()的重载方法）和两个通知方法(notify()和notifyAll())。当某个线程在一个对象上调用等待方法时，虚拟机就阻塞这个线程，并把它放到相应的等待集合中，直到另一个线程在同一个对象上调用通知方法，虚拟机才会在某个时刻唤醒一个或多个等待集合中被阻塞的线程。&lt;/p&gt;
&lt;p&gt;　　最后一种数据类型 ------- 可以作为堆中某个对象映像的一部分，是与垃圾收集器有关的数据。垃圾收集器必须以某种方式跟踪引用的每个对象。此任务不可避免需要附加一些数据给这些对象，数据类型需要根据垃圾收集器的算法而定。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;数组的内部表示&lt;/strong&gt;，数据也拥有一个与它们的类相关联的Class类实例。同样也在堆中表示，与其他对象一样，数组也拥有一个与它们的类相关联的Class类实例，所有具有相同维度和类型的数组都是同一个类的实例。而不管长度是多少。&lt;/p&gt;
&lt;p&gt;　　数组类的名称由两部分组成：每一维用一个方括号表示&quot;[&quot;，用字符或字符串表示元素类型，比如，类型为int的一维数组“[1”,元素类型为byte的三维数组为“[[[B”，类型为Object的二维数组为&quot;[[Ljava/lang/Object&quot;。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194154/201809/1194154-20180903151658773-525609609.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　程序计数器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　对于每一个运行中的Java程序而言，其中的每一个线程都有它自己的PC寄存器，它是在该线程启动时创建的，PC寄存器的大小是一个字长。当线程执行某个Java方法时，PC寄存器的内容总是下一条将被执行的&quot;地址&quot;。 这里“地址”可以是一个本地指针，也可以是方法字节码中相对于该方法起始的偏移量。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Java栈&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　每当启动一个线程，Java虚拟机都会为它分配一个Java栈。Java栈以帧的形式为单位保存线程的运行状态，虚拟机只会对栈执行两种操作：以帧为单位的压栈和出栈。&lt;/p&gt;
&lt;p&gt;　　　　每当线程调用一个Java方法时，虚拟机都会在该线程的Java栈中压入一个新帧。当前使用的栈帧被称为当前帧，在执行这个方法时，它使用这个帧来存储参数，局部变量，中间运算结果等等数据。&lt;/p&gt;
&lt;p&gt;　　　　Java方法可以由两种方式完成，一种是通过return返回，一种是抛出异常终止。不管以哪种方式返回，虚拟机都会将当前栈帧弹出Java栈然后释放掉。此外，Java栈上的所有数据都是此线程私有的。任何线程不可访问另一个线程的栈数据。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;栈帧&lt;/strong&gt;　　&lt;/p&gt;
&lt;p&gt;　　　　栈帧有三部分组成：局部变量区，操作数栈和帧数据区　　&lt;/p&gt;
&lt;p&gt;　　　　当虚拟机调用一个Java方法时，它从对于类的类型信息得到此方法的局部变量区和操作数栈的大小，并据此分配栈帧内存，然后压入Java栈中。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;局部变量区&lt;/strong&gt;：Java栈帧的局部变量区被组织为一个字长为单位、从0开始计数的数组。字节码通过从0开始的索引来使用其中的数据。类型为int，float，reference和returnAddress的值在数组中只占据一项，类型byte，short和char的值存入数组前将被转换为int，因而同样占据一项，类型为long和double的值在数组中占据连续的两项。&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/1194154/201809/1194154-20180903162534942-1263961075.png&quot; alt=&quot;&quot;/&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/1194154/201809/1194154-20180903162551156-361183244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1194154/201809/1194154-20180903162626406-1884582595.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　需要注意的是，在runInstanceMethod()中，局部变量的第一个参数是一个reference引用类型，这个参数this用于表示对象本身，对于任何一个实例方法this都是隐含加入的。&lt;/p&gt;
&lt;p&gt; 　　　　&lt;strong&gt;操作数栈&lt;/strong&gt;：和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。但是和前者的区别是，它不是通过索引来访问的，而是通过标注的栈操作---压栈和出栈来访问的。&lt;/p&gt;
&lt;p&gt; 　　　　不同于程序计数器，Java虚拟机没有寄存器，程序计数器也无法被程序指令直接访问，Java虚拟机指令是从操作数栈中而不是寄存器中取得操作数的，因此它的运行方式是基于栈的而不是基于寄存器的。下图演示了两个局部变量相加的过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194154/201809/1194154-20180903163622500-257088005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　　　&lt;strong&gt;帧数据区&lt;/strong&gt;：除了局部变量和操作数栈外，Java栈帧还需要一些数据来支持常量池的解析，正常方法的返回以及异常派发机制。这些信息都存储在Java帧栈的帧数据区中。&lt;/p&gt;
&lt;p&gt;　　　　Java中大多数指令都涉及到常量池入口。有些指令仅仅是从常量池中取出数据压入Java栈（这些数据包括int，long，float，double和String），还有些指令使用常量池中的数据来指示要实例化的类或数组、要访问的字段或者要调用的方法。&lt;/p&gt;
&lt;p&gt;　　　　当虚拟机需要使用到常量池中的数据时，它会通过帧数据区中指向常量池的指针来访问他它。常量池中对于类型、字段和方法的引用在开始的时候都是符号。当虚拟机在常量池中搜索的时候，如果遇到的类型、字段和方法仍然是符号，虚拟机这时才会去解析。&lt;/p&gt;
&lt;p&gt;　　　　Java栈可能的实现方式：一种可能的方式，从堆中分配每一个帧，例如，下面考虑下面的类&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194154/201809/1194154-20180904102450573-930493315.png&quot; alt=&quot;&quot; width=&quot;440&quot; height=&quot;229&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　　　下图显示了addAndPrint()方法的三次快照。在这个Java虚拟机实现中，每个帧都单独从堆中分配。为了调用方法addTowTypes()，方法addAndPrint()首先把1和88.88压入它的操作数栈中，然后调用addTowTypes()方法。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194154/201809/1194154-20180904103033638-608722752.png&quot; alt=&quot;&quot; width=&quot;449&quot; height=&quot;339&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　调用addTowTypes()的指令指向一项常量池的数据，因此在常量池中查找这些数据，这期间有必要还需进行解析。&lt;/p&gt;
&lt;p&gt;　　　　解析后的常量池数据将指向方法区中对应的addTwoTypes()的信息。虚拟机需要利用这些信息来确定addTwoTypes()的局部变量区和操作数栈的大小。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;本地方法栈：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　前面所有运行时数据区都是在Java虚拟机规范中明确定义的，不过程序运行时可能还会使用到一些与本地方法相关的数据区。当某个线程调用一个本地方法时，它就进去了一个全新的并且不受虚拟机限制的世界。&lt;/p&gt;
&lt;p&gt;　　　　当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈中。但它调用的是本地方法，虚拟就就会保持Java栈不变，不再在线程的Java栈中压入新的帧，虚拟机只是简单的动态链接并直接调用使用本地方法。&lt;/p&gt;
&lt;p&gt;　　　　下面展示了线程调用本地方法的过程：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1194154/201809/1194154-20180904104957495-2106472333.png&quot; alt=&quot;&quot; width=&quot;494&quot; height=&quot;365&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　我们首先调用两个方法，然后在这两个方法中的第二个方法中调用一个本地方法，导致虚拟机使用一个本地方法栈，假设这是一个C语言栈，期间有两个C函数，第一个C函数被第二个Java方法调用，而后第一个C函数调用第二个C函数，第二个C函数又调用一个Java方法。之后第二个C函数又通过本地方法接口回调一个Java方法，最终这个Java方法又调用一个Java方法。&lt;/p&gt;
&lt;p&gt;　　　　与其他运行时内存区一样，本地方法栈所占用的内存区也不是固定大小的，它可以根据需要动态扩展或者收缩。某些实现也允许用户或者程序员指定内存区初始大小以及最大最小。&lt;/p&gt;
&lt;p&gt;　　　　&lt;em&gt;参考：深入理解Java虚拟机第二版&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 05 Sep 2018 07:05:00 +0000</pubDate>
<dc:creator>以墨为码</dc:creator>
<og:description>什么是Java虚拟机？ Java虚拟机，从字面上来看，像是某种机器，但Java虚拟机之所以被称之为“虚拟”的，是因为它是由一个规范来定义的抽象计算机，所以在我们说Java虚拟机的时候，可能指的是如下三</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/black-Lr/p/9592195.html</dc:identifier>
</item>
<item>
<title>【人工神经网络基础】为什么神经网络选择了“深度”？ - wuliytTaotao</title>
<link>http://www.cnblogs.com/wuliytTaotao/p/9590633.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuliytTaotao/p/9590633.html</guid>
<description>&lt;p&gt;　　现在提到“神经网络”和“深度神经网络”，会觉得两者没有什么区别，神经网络还能不是“深度”（deep）的吗？我们常用的 Logistic regression 就可以认为是一个不含隐含层的输出层激活函数用 sigmoid（logistic） 的神经网络，显然 Logistic regression 就不是 deep 的。不过，现在神经网络基本都是 deep 的，即包含多个隐含层。Why？&lt;/p&gt;
&lt;h2&gt;1. universality approximation theorem（通用近似定理）&lt;/h2&gt;
&lt;p&gt;　　任何连续的函数 $f: R^N \to R^M$ 都可以用只有一个隐含层的神经网络表示。（隐含层神经元足够多）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1351564/201809/1351564-20180905103846945-1686918414.png&quot; alt=&quot;&quot; width=&quot;368&quot; height=&quot;352&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图 1：仅含一个隐含层的神经网络示意图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　一个神经网络可以看成是一个从输入到输出的映射，那么既然仅含一个隐含层的神经网络可以表示任何连续的函数，为什么还要多个隐含层的神经网络？&lt;/p&gt;
&lt;h2&gt;2. why deep？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;　　&quot;Yes, shallow network can represent any function. &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　However, using deep structure is more effective.&quot;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以把仅含一个隐含层的神经网络结构叫做 shallow 的，把包含多个隐藏层的神经网络结构叫做 deep 的。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　李宏毅教授在他的机器学习视频中，提出一种叫做 Modularization（模块化）的解释。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1351564/201809/1351564-20180905112027006-1438467116.png&quot; alt=&quot;&quot; width=&quot;731&quot; height=&quot;441&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图 2：Modularization&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在多层神经网络中，第一个隐含层学习到的特征是最简单的，之后每个隐含层使用前一层得到的特征进行学习，所学到的特征变得越来越复杂。 如图 3 和 4 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1351564/201809/1351564-20180905114058927-38801686.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图 3：不同level的特征-1&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　low level 中每一个特征在 high level 或多或少被使用，这样对于每一个 high level 特征，只需要训练一套 low level 特征。是的，low level 特征被共用了，相当于将提取 low level 特征单独成立了一个模块，供高层调用。对于每一个 high level 特征，不需要每次都将 low level 特征训练一遍。这就是 deep 的好处。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1351564/201809/1351564-20180905120721939-673961479.png&quot; alt=&quot;&quot; width=&quot;645&quot; height=&quot;334&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 4：不同level特征-2&lt;/p&gt;
&lt;p&gt;　　在比较深度神经网络和仅含一个隐含层神经网络的效果时，需要控制两个网络的 trainable 参数数量相同，不然没有可比性。李宏毅教授在他的机器学习视频中&lt;a title=&quot;Conversational Speech Transcription Using Context-Dependent Deep Neural Networks&quot; href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.368.3047&amp;amp;rep=rep1&amp;amp;type=pdf&quot; target=&quot;_blank&quot;&gt;举例&lt;/a&gt;，相同参数数量下，deep 表现更好；这也就意味着，达到相同的效果，deep 的参数会更少。&lt;/p&gt;
&lt;p&gt;　　不否认，理论上仅含一个隐含层的神经网络完全可以实现深度神经网络的效果，但是训练难度要大于深度神经网络。&lt;/p&gt;
&lt;p&gt;　　实际上，在深度神经网络中，一个隐含层包含的神经元也不少了，比如 AlexNet 和 VGG-16 最后全连接层的 4096 个神经元。在 deep 的同时，fat 也不是说不需要，只是没有像只用一层隐含层那么极端，每个隐含层神经元的个数也是我们需要调节的超参数之一。&lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a title=&quot;Why deep？&quot; href=&quot;https://www.bilibili.com/video/av10590361/?p=22&quot; target=&quot;_blank&quot;&gt;李宏毅机器学习&lt;/a&gt;&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.google.com/url?sa=t&amp;amp;rct=j&amp;amp;q=&amp;amp;esrc=s&amp;amp;source=web&amp;amp;cd=1&amp;amp;cad=rja&amp;amp;uact=8&amp;amp;ved=2ahUKEwj71IKw5aLdAhWEWrwKHbqPCjAQFjAAegQIAxAB&amp;amp;url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FUniversal_approximation_theorem&amp;amp;usg=AOvVaw0ex0ckev2K9jqf5Ou2oBSw&quot; target=&quot;_blank&quot;&gt;Universal approximation theorem - Wikipedia&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 05 Sep 2018 06:01:00 +0000</pubDate>
<dc:creator>wuliytTaotao</dc:creator>
<og:description>现在提到“神经网络”和“深度神经网络”，会觉得两者没有什么区别，神经网络还能不是“深度”（deep）的吗？我们常用的 Logistic regression 就可以认为是一个不含隐含层的输出层激活函数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuliytTaotao/p/9590633.html</dc:identifier>
</item>
<item>
<title>移动端适配大法 - 嵘么么</title>
<link>http://www.cnblogs.com/rongmm/p/9591619.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rongmm/p/9591619.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前端代码的编写永远逃不过“兼容”二词，从前PC时代，因为IE的傲娇，导致程序猿们一直在兼容IE的道路上挣扎，如今移动设备的普及，仿佛让我们看到了希望，仿佛马上就要摆脱IE了，可是！一波还未平息，一波又来侵袭~移动端确实不用考虑IE了，各种CSS新特性也用的爽到飞起，但一座大山压了过来，那就是分辨率的适配，移动端由于展示区域比较小，因此对于页面在不同分辨率手机上的展示细节也要求更加严格，这时像PC端有些固定宽高的布局方式显然不适应，我们被要求对于不同大小手机页面能自适应，真是非常有（tong）趣（ku）呢&lt;br/&gt;话不多说，下面就总结了一些移动端常用的适配手法：&lt;/p&gt;
&lt;h2 id=&quot;一百分比&quot;&gt;一、百分比&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;：只要求宽度随屏幕自适应，比如文字块&lt;br/&gt;百分比在PC端自适应上也经常用到，着实相当好用，但它一般用于宽度自适应的设置，高度设置百分比时，要求其父类元素有明确高度。&lt;/p&gt;
&lt;h3 id=&quot;利用百分比实现填充全屏&quot;&gt;1、利用百分比实现填充全屏&lt;/h3&gt;
&lt;p&gt;为了让元素设置height：100%生效，并且正好为窗口高度，则需要给html和body元素以及它所有的父元素都设置高度100%。&lt;br/&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html style=&quot;height: 100%;&quot;&amp;gt;
  &amp;lt;body style=&quot;height: 100%;&quot;&amp;gt;
    &amp;lt;div  class=&quot;wrap&quot; style=&quot;height: 100%; width:100%&quot;&amp;gt;
        填充全屏啦
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用height: 100%;时需要注意的一些事项&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Margins 和 padding 会让你的页面出现滚动条，也许这是你不希望的。&lt;/li&gt;
&lt;li&gt;如果你的元素实际高度大于你设定的百分比高度，那元素的高度会自动扩展。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;写到这里我突然想插个题外话，对于absolute定位的元素，用height：100%显然也是无效的，因为此时它已经脱离了文档流，此时它的高度由自身内容撑开。这是如果我希望它填满父盒子，怎么做？这里有个黑魔法，设置它的top,left,bottom,right均为0，这时盒子就会被拉伸至填满父盒子。&lt;/p&gt;
&lt;h3 id=&quot;利用百分比实现宽高比固定&quot;&gt;2、利用百分比实现宽高比固定&lt;/h3&gt;
&lt;p&gt;有时，我们希望宽度自适应，高度随宽度变化而变化，并有固定的宽高比。&lt;br/&gt;让我们缕缕，用height百分比显然不行，height百分比是以父元素高度为基准的，而我们需要以宽度为基准来设置高度。&lt;br/&gt;所以这里可以用到padding-top或者padding-bottom，padding是以父元素的width为基准的。我们可以设置元素的height：0，然后用padding-bottom将元素撑开，以实现固定宽高比。&lt;/p&gt;
&lt;h2 id=&quot;二rem&quot;&gt;二、rem&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;：对于图片等对高度自适应有要求的场景&lt;br/&gt;rem单位：以页面根字体的大小，也就是html元素字体的大小为基准，例如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;html{
    font-size:16px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么1rem等于16px。&lt;br/&gt;所以使用时，我们只要让根字体大小随屏幕大小自适应，那页面中所有使用rem单位来设置宽高的元素，大小也会随屏幕大小自适应了。&lt;br/&gt;根据不同屏幕大小设置根字体大小有两种方法：&lt;/p&gt;
&lt;h3 id=&quot;css方法设置rem&quot;&gt;1、css方法设置rem&lt;/h3&gt;
&lt;p&gt;利用媒体查询，根据不同的屏幕大小进行设置，缺点就是一般只列举一些代表性的屏幕大小，自适应不能充分覆盖所有范围&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;html{
    font-size:10px
} 
@media screen and (min-width:321px) and (max-width:375px){
    html{
        font-size:11px
    }   
} 
@media screen and (min-width:376px) and (max-width:414px){
    html{
        font-size:12px
    }
} 
@media screen and (min-width:415px) and (max-width:639px){
    html{
        font-size:15px
    }
} 
@media screen and (min-width:640px) and (max-width:719px){
    html{
        font-size:20px
    }
} 
@media screen and (min-width:720px) and (max-width:749px){
    html{
        font-size:22.5px
    }
} 
@media screen and (min-width:750px) and (max-width:799px){
    html{
        font-size:23.5px
    }
} 
@media screen and (min-width:800px){
    html{
        font-size:25px
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;js方法设置rem&quot;&gt;2、JS方法设置rem&lt;/h3&gt;
&lt;p&gt;利用JS设置根字体大小，所以若改变发生在渲染完成之后，则会引起回流，导致闪屏现象。因此使用这种方法时，应将JS代码放入head头部中并且在CSS引入之前。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(function (doc, win) {
  var docEl = doc.documentElement,
    resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
    recalc = function () {
      var clientWidth = docEl.clientWidth;
      if (!clientWidth) return;
      docEl.style.fontSize = 20 * (clientWidth / 375) + 'px';
    };
  recalc(); 
  if (!doc.addEventListener) return;
  win.addEventListener(resizeEvt, recalc, false);
})(document, window); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面clientWidth为实际屏幕的宽度，而375为设计稿基于的参考屏幕宽度，20则是当实际屏幕宽度等于参考屏幕宽度时，1rem的大小。代码的关键参数20和375是这样设置的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;a) 由于提供的设计稿现在基本都是以iPhone6/7/8为参考的，宽度为750px，dpr为2，所以计算rem时的参考屏幕宽度可以设置为375。&lt;/li&gt;
&lt;li&gt;b) 由于chrome的最小字体是12px，又为了计算方便，所以可以设置1rem的大小为20px&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;应用过程中，比如我们拿到了一个750的设计稿，那么首先，将设计稿里的数值除以2，得到按手机屏幕大小布局的数值（这也是375的由来）。然后，再除以20就可以将设计稿中的px转化为rem了。&lt;/p&gt;
&lt;h2 id=&quot;三媒体查询&quot;&gt;三、媒体查询&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;使用场景：&lt;/strong&gt;一般利用媒体查询来进行特殊处理，比如&lt;br/&gt;1、iphoneX这类全屏的适配&lt;br/&gt;2、在适配dpr为3的iPhone Plus或者pad横屏等超级大屏时，需要根据业务需求设置临界值，然后展示不同内容或者替换不同分辨率图片（也就是常说的2倍图、3倍图的使用）等&lt;/p&gt;
&lt;h2 id=&quot;四vwvh&quot;&gt;四、vw、vh&lt;/h2&gt;
&lt;p&gt;vw是以屏幕宽度为基准的百分比单位，1vw=1% * deviceWidth&lt;br/&gt;vh是以屏幕高度为基准的百分比单位，1v=1% * deviceHeight&lt;br/&gt;vw,vh确实很好用，但是目前使用时仍需考虑兼容性的问题，在国内一些手机自带浏览器里（比如华为）会失效，并且据说碰上X5内核时也容易踩坑 。&lt;/p&gt;
</description>
<pubDate>Wed, 05 Sep 2018 05:39:00 +0000</pubDate>
<dc:creator>嵘么么</dc:creator>
<og:description>前端代码的编写永远逃不过“兼容”二词，从前PC时代，因为IE的傲娇，导致程序猿们一直在兼容IE的道路上挣扎，如今移动设备的普及，仿佛让我们看到了希望，仿佛马上就要摆脱IE了，可是！一波还未平息，一波又</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/rongmm/p/9591619.html</dc:identifier>
</item>
<item>
<title>Spring – 缓存抽象 - 仍是少年</title>
<link>http://www.cnblogs.com/ashleyboy/p/9591604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ashleyboy/p/9591604.html</guid>
<description>&lt;h2&gt;Spring缓存抽象概述&lt;/h2&gt;
&lt;p&gt;Spring框架自身并没有实现缓存解决方案，但是从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口，提供对缓存功能的声明，能够与多种流行的缓存实现集成。&lt;/p&gt;
&lt;p&gt;Cache接口为缓存的组件规范定义，包含缓存的各种操作集合；&lt;/p&gt;
&lt;p&gt;Cache接口下Spring提供了各种xxxCache的实现：如RedisCache，EhCacheCache , ConcurrentMapCache等；&lt;/p&gt;
&lt;p&gt;CacheManager接口为缓存管理器规范，简单来说就是用于存放cache，Spring默认也提供了一些列管理器的实现。&lt;/p&gt;
&lt;p&gt;Spring缓存抽象提供了5个注解用来声明缓存规则：&lt;/p&gt;
&lt;p&gt;@Cacheable：能够根据方法的请求参数对其结果进行缓存，多用于查询&lt;/p&gt;
&lt;p&gt;@CachePut: 执行方法，并缓存结果&lt;/p&gt;
&lt;p&gt;@CacheEvict:清空缓存&lt;/p&gt;
&lt;p&gt;@Caching:能够同时应用多个缓存注解功能&lt;/p&gt;
&lt;p&gt;@CacheConfig: 用于抽取缓存的公共配置（类级别）&lt;/p&gt;
&lt;p&gt;以上5个注解除了@CacheConfig注解是类级别的注解，其余4个注解在类和方法上均可以使用，作用在类上表示对该类下所有方法生效，作用的方法上只对该方法生效，且只能用于public修饰的符方法，protected或者private修饰的方法不适用。&lt;/p&gt;
&lt;h2&gt;@Cacheable注解&lt;/h2&gt;
&lt;p&gt;@Cacheable注解的作用是Spring在调用该方法之前，首先在缓存中查找方法的返回值，默认的key是根据参数值生成，如果存在，直接返回缓存中的值，否则执行该方法，并将返回值保存到缓存中&lt;/p&gt;
&lt;h3&gt;@Cacheable运行流程：&lt;/h3&gt;
&lt;p&gt;  1.方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取；&lt;/p&gt;
&lt;p&gt;           （CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建。&lt;/p&gt;
&lt;p&gt;  2.去Cache中查找缓存的内容，使用一个key，默认就是方法的参数值；&lt;/p&gt;
&lt;p&gt;           key是按照某种策略生成的；默认是使用keyGenerator生成的，               &lt;/p&gt;
&lt;p&gt;　　   Spring默认加载的是SimpleCacheManage，SimpleKeyGenerator生成key的默认策略是：&lt;/p&gt;
&lt;p&gt;                       如果没有参数；key=new SimpleKey()&lt;/p&gt;
&lt;p&gt;                       如果有一个参数：key=参数的值&lt;/p&gt;
&lt;p&gt;                       如果有多个参数：key=new SimpleKey(params)&lt;/p&gt;
&lt;p&gt;  3.没有查到缓存就调用目标方法；&lt;/p&gt;
&lt;p&gt;  4.将目标方法返回的结果，放进缓存中&lt;/p&gt;
&lt;h3&gt;@Cacheable属性说明：&lt;/h3&gt;
&lt;p&gt;　　1.acheNames/value：该属性值必须提供，指定缓存组件的名字，将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存；&lt;/p&gt;
&lt;p&gt; 　　　　 如：cacheNames = &quot;product&quot;或者cacheNames = {&quot;product1&quot;,&quot;product2&quot;}&lt;/p&gt;
&lt;p&gt;　　2.key：缓存数据使用的key，不指定key则默认是使用方法参数的值该属性值支持SpEL表达式&lt;/p&gt;
&lt;p&gt;       3.cacheManager：指定缓存管理器；或者cacheResolver指定获取解析器&lt;/p&gt;
&lt;p&gt;       4.condition：指定符合条件的情况下才缓存&lt;/p&gt;
&lt;p&gt;　　5.unless:否定缓存；当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判断&lt;/p&gt;
&lt;p&gt;                  unless = &quot;#result == null&quot;&lt;/p&gt;
&lt;p&gt;                   unless = &quot;#a0==2&quot;:如果第一个参数的值是2，结果不缓存；&lt;/p&gt;
&lt;p&gt;　　6.sync：是否使用异步模式&lt;/p&gt;
&lt;p&gt;使用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Cacheable(cacheNames = &quot;product&quot;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认key为参数，多个参数SimpleKey [arg1,arg2]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Cacheable(cacheNames = &quot;product&quot;,key = &quot;#root.methodName+'['+#id+']'&quot;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Cacheable(cacheNames = &quot;product&quot;,keyGenerator = &quot;myKeyGenerator&quot;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Cacheable(cacheNames = &quot;product&quot;,key = &quot;#root.methodName+'['+#id+']'&quot;,condition=&quot;#a0&amp;gt;10&quot;,unless = &quot;#a0==11&quot;) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;带条件的缓存满足condition=true缓存，满足unless=true则不缓存 &lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Product getProductById(Long id){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    Product product =&lt;span&gt;productMapper.getProductById(id);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;   System.out.println(product);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; product;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定key属性值&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; @Cacheable(cacheNames =&quot;product&quot;, key=&quot;#id&quot;)    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;”#+参数名”的形式，直接使用参数名
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//@Cacheable(cacheNames =&quot;product&quot;, key=&quot;#a0&quot;)    //”#a+参数位置”的形式&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; Product getProductById(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     xxxx
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; @Cacheable(cacheNames =&quot;product&quot;, key=&quot;# productcondition.productId&quot;&lt;span&gt;)    
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;或者
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@Cacheable(cacheNames =&quot;product&quot;, key=&quot;#a0.productId&quot;)    &lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Product getProduct (Product productcondition) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     xxxx
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;自定义Key生成器&lt;/h3&gt;
&lt;p&gt;除了通过SPEL表达式之外，还可以通过自定义key生成器的方式，Spring缓存模块提供了org.springframework.cache.interceptor.KeyGenerator接口用于缓存key的生成声明，因此我们可以自定义一个MyKeyGenerator类并实现了KeyGenerator接口 ，使用如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyCacheConfig {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     @Bean(&quot;myKeyGenerator&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; KeyGenerator keyGenerator(){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; KeyGenerator(){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object generate(Object target, Method method, Object... params) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; method.getName()+&quot;[&quot;+ Arrays.asList(params).toString()+&quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该方法测试用，关于缓存key的生成方式，网上有很多种策略。&lt;/p&gt;
&lt;p&gt;使用时只需要修改注解的key属性即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; @Cacheable(cacheNames = &quot;product&quot;,keyGenerator = &quot;myKeyGenerator&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;  @CachePut&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;@CachePut注解的作用简单的说一句话：既调用方法，又缓存数据。@cachePut和@Cacheable两个注解都可以用于填充缓存，但使用上略有点差异，@Cacheable注解的执行流程是先在按key在缓存中查找，存在则返回，不存在则执行目标方法，并缓存目标方法的结果。而@CachePut并不会检查缓存，总是先执行目标方法，并将目标方法的结果保存到缓存中。实际中比如执行到更新操作时，则希望将最新的数据更新到缓存，如果该方法返回异常，将不再执行保存缓存的逻辑。&lt;/p&gt;
&lt;h3&gt;@CachePut属性说明&lt;/h3&gt;
&lt;p&gt;@CachePut注解属性与@CachePut类似，并没有增加其他属性&lt;/p&gt;
&lt;p&gt;使用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @CachePut(value=&quot;product&quot;,key = &quot;#result.productId&quot;,condition = &quot;#result!=null&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;  Product updateProduct(Product product){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; productMapper.updateProduct(product);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     System.out.println(&quot;影响行数：&quot;+&lt;span&gt;count);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(count&amp;gt;0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; product;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;@CacheEvict注解&lt;/h2&gt;
&lt;p&gt;该注解的作用根据指定的key或者是allEntries属性值移除缓存中特性的键值对。&lt;/p&gt;
&lt;h3&gt;@CacheEvict属性说明&lt;/h3&gt;
&lt;p&gt;与@Cacheable相比@CacheEvict注解提供了另外两个属性：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;allEntries：表示是否清空所有缓存内容，默认false，如果该值为true则清空指定cacheNames缓存块下所有内容，如果指定了allEntries为true，那么再zhidingkey值将没有意义&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;beforeInvocation：是否在执行方法前请空缓存，默认值为false,如果该值为true则在调用目标方法前执行清空缓存，为false的情况下，如果目标方法抛出异常，则不再执行清空缓存逻辑&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@CacheEvict(value=&quot;product&quot;,key=&quot;#id&quot;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;@CacheEvict(value=&quot;product&quot;,allEntries = true) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清楚所有缓存&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; @CacheEvict(value=&quot;product&quot;,allEntries = &lt;span&gt;true&lt;/span&gt;,beforeInvocation = &lt;span&gt;true&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;清楚所有缓存&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; deleteProductById(Long id) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    productMapper.deleteProductById(id);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;@Caching注解&lt;/h2&gt;
&lt;p&gt;该注解是一个分组注解，作用是可以同时应用多个其他注解，该注解提供了3个属性cacheable，put，evict分别用于组合@Cacheable、@CachePut、@CacheEvict三个注解&lt;/p&gt;
&lt;p&gt;使用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Caching(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         cacheable = {@Cacheable(value=&quot;product&quot;,key=&quot;#productName&quot;&lt;span&gt;)},
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         put =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 @CachePut(value=&quot;product&quot;,key=&quot;#result.productId&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 @CachePut(value=&quot;product&quot;,key=&quot;#result.productName&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;  Product getProductByName(String productName){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     Product product =&lt;span&gt;productMapper.getProductByName(productName);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;return&lt;/span&gt;&lt;span&gt; product;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当@Cacheing同时含有CachePut注解和Cacheable注解时，仍然会先执行目标方法。（并不是按@Cacheable的执行过程，先检查缓存，存在则返回）&lt;/p&gt;
&lt;h2&gt;@CacheConfig&lt;/h2&gt;
&lt;p&gt;是一个类级别的注解，允许共享缓存的名称、KeyGenerator、CacheManager 和CacheResolver&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; @CacheConfig(cacheNames = &quot;product&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProductService {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在类上使用该注解，指定cacheNames属性值，则类中方法上的注解将默认继承了该属性值，如果方法上注解使用和了@CacheConfig向同的属性，则以方法上的为准。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @CacheConfig(cacheNames = &quot;product&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProductService {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ProductMapper productMapper;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     @Cacheable(cacheNames = &quot;product1&quot;,key = &quot;#root.methodName+'['+#id+']'&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Product getProductById(Long id){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;        Product product =&lt;span&gt;productMapper.getProductById(id);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;       System.out.println(product);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; product;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面@Cacheable和@CacheConfig都指定了属性值cacaeNames，实际以方法上注解指定的为准。&lt;/p&gt;

&lt;p&gt;Spring缓存抽象的关键原理就是使用spring AOP，通过切面实现了在方法调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。&lt;/p&gt;
</description>
<pubDate>Wed, 05 Sep 2018 05:35:00 +0000</pubDate>
<dc:creator>仍是少年</dc:creator>
<og:description>Spring缓存抽象概述 Spring框架自身并没有实现缓存解决方案，但是从3.1开始定义了org.springframework.cache.Cache和org.springframework.ca</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ashleyboy/p/9591604.html</dc:identifier>
</item>
<item>
<title>小程序多业务线融合【完整分包业务接入】 - 大转转FE</title>
<link>http://www.cnblogs.com/zhuanzhuanfe/p/9591475.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuanzhuanfe/p/9591475.html</guid>
<description>&lt;h3 id=&quot;应用场景&quot;&gt;应用场景&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;同一个主体（公司、部门）下有多个小程序&lt;/li&gt;
&lt;li&gt;这些小程序，由一个主小程序和后来新建的多条业务线构成（每条业务线拥有独立的小程序）&lt;/li&gt;
&lt;li&gt;各业务线的小程序需要挂载到主程序下面，因为需要主程序导流&lt;/li&gt;
&lt;li&gt;同时各业务线自己的小程序也照常发布更新&lt;/li&gt;
&lt;li&gt;==&lt;strong&gt;一套代码，通过打包命令，来生成独立包和分包&lt;/strong&gt;==（分包生成完需要拷贝到主程序的subPages目录下）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;项目概述&quot;&gt;项目概述&lt;/h3&gt;
&lt;p&gt;我的这条业务线叫欢乐送（项目名为enjoy_given），是转转旗下一个免费的以物换物平台&lt;/p&gt;
&lt;p&gt;因为我们这条业务线小程序是用mpvue构建的（整个项目也是通过mpvue的cli生成的），所以后面相关配置都是以mpvue为例，如果是wepy项目基本也大同小异。&lt;/p&gt;
&lt;p&gt;下面就是我们的目录结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img1.zhuanstatic.com/common/img/%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20180827212018.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;src目录下的几个js文件需要专门介绍下：&lt;/p&gt;
&lt;p&gt;src/App.vue 是小程序的入口文件，里面定义的是小程序的生命周期&lt;/p&gt;
&lt;p&gt;src/main.js 里面初始化通用业务、定义小程序页面路径和全局变量&lt;/p&gt;
&lt;p&gt;src/vars.js 存放整个项目的全局变量&lt;/p&gt;
&lt;p&gt;src/baseInstall.js 基础方法装配逻辑（如：给vue对象挂载登录、统计逻辑、识别渠道号等）&lt;/p&gt;
&lt;h3 id=&quot;分包配置概述&quot;&gt;分包配置概述&lt;/h3&gt;
&lt;ul readability=&quot;13&quot;&gt;&lt;li readability=&quot;6.5&quot;&gt;
&lt;p&gt;首先要配置source和appid&lt;/p&gt;
&lt;p&gt;作为分包时，这两个参数都要统一采用主包参数（建议通过webpack配置来实现）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;source：是每条业务线登录、注册、和接口访问时用的标识，用来区分该用户来自于哪条业务线&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;appid：微信分配的小程序appid&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么要配置这两参数：因为不配置没法登录&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;页面路径问题&lt;/p&gt;
&lt;p&gt;作为分包时，所有页面的跳转路径都要加主包的跳转前缀（建议通过包装跳转方法navigateTo、redirectTo、reLaunch、navigateBack实现，建议配合webpack统一处理）&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;当新业务线作为分包接入主程序时，页面跳转路径前需要统一加一个前缀&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如：独立小程序首页路径为 /pages/content/index/main&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作为分包时，主程序分配的包为/subPages/enjoy_given&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那么分包业务线首页路径为: /subPages/enjoy_given/pages/content/index/main&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;wxss引用路径问题&lt;/p&gt;
&lt;p&gt;不要用使根目录引入方式（建议采用webpack或者shell脚本来完成）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因为在分包状态下，用根目录访问方式会直接访问主程序的根目录，文件是不存在的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;图片路径问题&lt;/p&gt;
&lt;p&gt;所有图片路径统一采用cdn资源访问方式，不要引用本地图片&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;对于分包的main.js和App.vue入口文件不执行的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以通过抽离基础业务装配方法，对于每一个从主包跳到分包页面的入口分别引入，后面会细说&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;对于小程序内的h5页面拉起小程序页面&lt;/p&gt;
&lt;p&gt;在打开webview时候，要加入一个标志位，或者prefix，告诉h5页面，当前处于分包当中，打开的小程序path要加前缀&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;分享路径问题，在路径前面也要加入路径前缀&lt;/p&gt;
&lt;p&gt;可以通过一个通用的分享方法，进行统一处理，后面会细说&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;小程序的所有页面都需要在主包入口文件（app.vue）注册，每新增页面都要注册&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这个是坑，尤其新增页面时，会很容易忽略这个问题，这里要特别强调下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;分包接入需要注意的地方&quot;&gt;分包接入需要注意的地方&lt;/h5&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;storage命名问题，为了避免和主程序或者其他业务线小程序发生冲突（建议采用 zz_业务名_xxx, 我们业务名是enjoy_given，简称eg，如： zz_eg_address， zz指的就是转转）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;登录问题，推荐和主程序使用同样的cookie名称，这样可以通用一套用户信息，免得双方各维护一套，还能避免重复授权。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支付问题，保证下单时和支付时，cookie中的参数保持一致&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;调试，可以找主程序那边要个主程序的测试包，把生成的代码(dist目录下的内容)拷贝到主程序包的 subPages/业务名/ 下面&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;例如我们的目录是 subPages/enjoy_given/（目录结构同上）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;一套代码通过不同打包命令生成对应的程序包独立包和分包&quot;&gt;一套代码，通过不同打包命令生成对应的程序包（独立包和分包）&lt;/h3&gt;
&lt;p&gt;package.json中scripts&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;scripts&quot;: {
    &quot;dev&quot;: &quot;node build/dev-server.js&quot;,
    &quot;start&quot;: &quot;node build/dev-server.js&quot;,
    &quot;build&quot;: &quot;rimraf dist &amp;amp;&amp;amp; node build/build.js&quot;,
    &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;,
    &quot;build_subPkg&quot;: &quot;node build/build-subpkg.js &amp;amp;&amp;amp; sh ./scripts/path-replace.sh&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;独立小程序(调试) npm run dev
独立小程序(构建) npm run build
主程序分包(构建) npm run build_subPkg&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;为什么没有主程序分包测试&quot;&gt;为什么没有主程序分包（测试）&lt;/h5&gt;
&lt;p&gt;因为我们无论是构建测试分包还是构建正式分包，都要把生成dist下的代码拷贝到主程序的subPages/enjoy_given/目录下，成本基本是一样的，所以，就没有写构件分包的命令&lt;/p&gt;
&lt;h3 id=&quot;分包webpack配置&quot;&gt;分包webpack配置&lt;/h3&gt;
&lt;p&gt;因为需要兼容独立小程序和分包业务，webpack我们建议分开配置&lt;/p&gt;
&lt;p&gt;我们对测试环境和正式环境分别配置了webpack，&lt;strong&gt;通过对webpack配置替换全局变量，直接修改项目的全局参数&lt;/strong&gt;。&lt;br/&gt;通过npm命令动态执行替换。&lt;/p&gt;
&lt;p&gt;为了分开配置，我们拷贝了一份build.js更名为build-subpkg.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;scripts&quot;: {
    ...,
    &quot;build_subPkg&quot;: &quot;node build/build-subpkg.js &amp;amp;&amp;amp; sh ./scripts/path-replace.sh&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;build_subPkg命令就是读取的build-subpkg.js文件&lt;br/&gt;build.js和build-subpkg.js中99%的内容都一样，只有一行不一样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var webpackConfig = require('./webpack.prod.conf')
变更为
var webpackConfig = require('./webpack.subpkg.prod.conf')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以下一步就是创建webpack.subpkg.prod.conf文件&lt;br/&gt;webpack.subpkg.prod.conf由webpack.prod.conf拷贝而来，里面依旧99%的内容一致&lt;/p&gt;
&lt;p&gt;// webpack.prod.conf&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
var config = require('../config')
var env = config.build.env
...
var webpackConfig = merge(baseWebpackConfig, {
    ...
    plugins: [
        new webpack.DefinePlugin({
            'process.env': env,
            'app.source': env.APP_SOURCE,
            'app.udeskDebug': env.UDESK_DEBUG,
            'app.id': env.APP_ID,
            'app.pathPrefix': env.APP_PATH_RREFIX,
            'app.isUseCrazyFormId': env.IS_USE_CRAZY_FORMD_ID
        }),
        ...
    ]
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;// webpack.subpkg.prod.conf&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
var config = require('../config')
var env = config.build.env
...
var webpackConfig = merge(baseWebpackConfig, {
    ...
    plugins: [
        new webpack.DefinePlugin({
            'process.env': env,
            'app.source': env.APP_SUB_PKG_SOURCE,
            'app.udeskDebug': env.UDESK_DEBUG,
            'app.id': env.APP_SUB_PKG_ID,
            'app.pathPrefix': env.APP_SUB_PKG_PATH_RREFIX,
            'app.isUseCrazyFormId': env.IS_USE_CRAZY_FORMD_ID
        }),
        ...
    ]
})&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;DefinePlugin插件是用来进行全局替换的&lt;br/&gt;如：'process.env': '&quot;hahaha&quot;', 指的就是全局process.env替换为&quot;hahaha&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;里面通过定义多个全局变量，实现打包时，通过不同的命令替换对应环境下的全局变量&lt;br/&gt;我们看一下../config/index.js中的文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var path = require('path')

module.exports = {
  build: {
    env: require('./prod.env'),
    ...
  },
  dev: {
    env: require('./dev.env'),
    ...
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;引入了dev.env.js和prod.env.js&lt;/p&gt;
&lt;p&gt;以prod.env.js为例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = {
  // 环境
  NODE_ENV: '&quot;production&quot;',
  // 欢乐送独立小程序source
  APP_SOURCE: '114',
  // 欢乐送分包小程序source
  APP_SUB_PKG_SOURCE: '103',
  // 欢乐送独立程序appid
  APP_ID: '&quot;wxaaaaaaaaaaaaaaa&quot;',
  // 欢乐送分包程序appid
  APP_SUB_PKG_ID: '&quot;wxbbbbbbbbbbbbbbbb&quot;',
  // udesk测试标志位
  UDESK_DEBUG: false,
  // 欢乐送独立小程序页面路径前缀
  APP_PATH_RREFIX: '&quot;&quot;',
  // 欢乐送分包小程序页面路径前缀
  APP_SUB_PKG_PATH_RREFIX: '&quot;/subPages/enjoy_given&quot;',
  // 是否启用crazyFormId
  IS_USE_CRAZY_FORMD_ID: true
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们再来看一下存放全局变量的文件src/vars.js（上面项目截图中有）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 小程序常量
export default {
  ...
  // 小程序版本号
  version: '1.3.5',
  // 小程序appid
  appId: app.id,
  // 小程序source（由webpack根据不同环境统一替换）
  source: app.source,
  // 路径前缀
  pathPrefix: app.pathPrefix,
  // 是否启用CrazyFormId
  isUseCrazyFormId: app.isUseCrazyFormId
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;var webpackConfig = merge(baseWebpackConfig, {
    ...
    plugins: [
        new webpack.DefinePlugin({
            'process.env': env,
            'app.source': env.APP_SUB_PKG_SOURCE,
            'app.udeskDebug': env.UDESK_DEBUG,
            'app.id': env.APP_SUB_PKG_ID,
            'app.pathPrefix': env.APP_SUB_PKG_PATH_RREFIX,
            'app.isUseCrazyFormId': env.IS_USE_CRAZY_FORMD_ID
        }),
        ...
    ]
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在打包完成后，全局变量文件中的&quot;app.xxx&quot;会被webpack中的同名变量替换掉&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如vars.js中 appId: app.id的app.id会被替换，独立小程序时该值为&quot;wxaaaaaaaaaaaaaaa&quot;，作为分包业务时，该值为&quot;wxbbbbbbbbbbbbbb&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样整个替换全局变量的流程就跑完了&lt;/p&gt;
&lt;h3 id=&quot;作为分包接入主程序中自己的main.js和app.vue都不会执行&quot;&gt;==作为分包，接入主程序中，自己的main.js和App.vue都不会执行==&lt;/h3&gt;
&lt;p&gt;这个是大坑，因为很多通用业务的初始化如登录、cookie、统计都是在这里完成的。&lt;/p&gt;
&lt;h5 id=&quot;解决方案&quot;&gt;解决方案&lt;/h5&gt;
&lt;p&gt;把基础功能的装配业务（如在录、统计、识别渠道号等逻辑）从main.js中抽离到另一个文件，我这里叫baseInstall.js。&lt;br/&gt;里面我还加入了对query的处理，比如渠道号channel和微信入口scene。&lt;/p&gt;
&lt;p&gt;那这样的话，src/main.js就会变得非常简单,&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import Vue from 'vue'
import App from './App'
import baseInstall from './baseInstall'
App.mpType = 'app'
baseInstall.init()  // ！！！最关键就是这行代码！！！
const app = new Vue(App)
app.$mount()

export default {
  config: {
    pages: [
      '^pages/content/index/main',            // 首页
      ...
    ],
    window: {
      ...
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;里面最关键的是baseInstall.init()这行代码&lt;/p&gt;
&lt;p&gt;下面我们来看看baseInstall.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 通用业务装配初始化
...
async function init (opts) {
  let options = opts
  ...
  // 获取指定渠道号
  const channel = options.channel || options.c || ''
  // 设置渠道号
  if (channel) {
    VARS.channel = channel.indexOf('waeg_') === 0 ? channel : ('waeg_' + channel)
  }
  ...
  if (!VARS.baseInstallFlag) {
    // 为了避免重复装备，通过标志位进行区分
    VARS.baseInstallFlag = true
    ...
    // 登录配置
    ZZLogin.config({
      source: VARS.source
    })
    ZZLogin.install()
    Navigator.install()
    // 统计
    LeStatic.config({
      appid: VARS.source,
      pageTypePrefix (currentRoute) {
        return 'waeg_'
      }
    }).install()
    ...
  }
  // 写入cookie
  cookie.set({
    channelid: VARS.channel,
    fromShareUid: VARS.shareUid
  })

  return options
}

export default {
  init
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;为什么要用vars.baseinstallflag标志位&quot;&gt;为什么要用VARS.baseInstallFlag标志位&lt;/h5&gt;
&lt;p&gt;因为，在分包时候是不执行main.js的，实际场景，会从主包的业务直接跳转到分包的一些页面。&lt;/p&gt;
&lt;p&gt;由于没有固定入口，所以在这些页面中都要加入baseInstall.js的引入，为了避免重复装配，才会设置这个标志位。&lt;/p&gt;
&lt;h5 id=&quot;为什么要把这些业务抽离&quot;&gt;为什么要把这些业务抽离&lt;/h5&gt;
&lt;p&gt;baseInstall.init里面涵盖了所有启动小程序时需要初始化的业务&lt;/p&gt;
&lt;p&gt;前面也提到了在作为分包时，自己的App.vue和main.js是不会执行的。&lt;/p&gt;
&lt;p&gt;那怎么办，这样，就在所有的页面中，在onLoad的生命周期中加入baseInstall.init方法。&lt;br/&gt;,所以我们抽离肯定是为了更方便的复用了。&lt;/p&gt;
&lt;p&gt;以首页为例（pages/content/index/index.vue）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import baseInstall from '@/baseInstall'

export default {
    ...
    async onLoad (options) {
        options = await baseInstall.init(options)
        ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;用async/await是因为baseInstall.init中部分逻辑用到了异步请求&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;因为主程序不会读取main.js所以所有的分包页面路径都要统一在主程序中注册&quot;&gt;因为主程序不会读取main.js，所以，所有的分包页面路径，都要统一在主程序中注册&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：每新增一个页面，都要在主程序中注册。也就是新增一个页面，就要通知主程序那边，在他们的文件里统一注册&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;页面路径&quot;&gt;页面路径&lt;/h3&gt;
&lt;p&gt;在分包中，所有页面路径访问要加入前缀&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如：原来访问/pages/content/index/main就可以了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;但是分包的访问路径为：&lt;strong&gt;/subPages/enjoy_given&lt;/strong&gt;/pages/content/index/main&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;解决方案-1&quot;&gt;解决方案：&lt;/h5&gt;
&lt;p&gt;以包装的navigateTo为例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;async navigateTo (route) {
    route.url = VARS.pathPrefix + (route.url.indexOf('/') === 0 ? '' : '/') + route.url // 这里做前缀处理
    console.log('[Navigator] navigateTo:', route)
    ...
    wx.navigateTo(route)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面需不需要加前缀，都是由全局变量VARS中的pathPrefix来决定&lt;/p&gt;
&lt;p&gt;而pathPrefix是在打包过程中由webpack根据打包命令动态替换的&lt;/p&gt;
&lt;h3 id=&quot;图片访问路径问题&quot;&gt;图片访问路径问题&lt;/h3&gt;
&lt;p&gt;图片访问路径统一采用cdn的资源访问路径，不要用本地访问路径，要不然在分包路径中是有问题的，同时也会增加程序包的体积&lt;/p&gt;
&lt;h3 id=&quot;wxss路径问题&quot;&gt;wxss路径问题&lt;/h3&gt;
&lt;p&gt;用mpvue生成的wxss文件,里面会把通用的vendor.wxss引入，但是引入路径是根路径，作为分包，直接引入根路径，会去访问主包的路径，导致文件无法找到。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@import &quot;/static/css/vendor.wxss&quot;; //在分包中用根路径是无法找到文件的
._button,._input[type=button],._input[type=reset],._input[type=submit],._textarea{-webkit-appearance:none}._button:after{border:none}page{background-color:#fff}...&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;解决方案-2&quot;&gt;解决方案&lt;/h5&gt;
&lt;p&gt;通过shell脚本对文件进行批量替换&lt;br/&gt;scripts/path-replace.sh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/sh
sed -i &quot;_bak&quot; &quot;s/\/static\/css\/vendor\.wxss/\/subPages\/enjoy_given\/static\/css\/vendor\.wxss/g&quot; `grep &quot;\/static\/css\/vendor\.wxss&quot; -rl ./dist/static/css/pages/**/*.wxss ./dist/static/css/pages/*/*/*.wxss`&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段shell脚本的目的就是把./dist/static/css/pages/下所有的wxss文件中的/static/css/vendor.wxss替换成/subPages/huanlesong/static/css\vendor.wxss&lt;/p&gt;
&lt;p&gt;替换完成后，路径变更ok&lt;br/&gt;生成正式包的时候，用npm run build_subPkg就ok了&lt;/p&gt;
&lt;h3 id=&quot;分享路径问题&quot;&gt;分享路径问题&lt;/h3&gt;
&lt;p&gt;主程序和独立小程序分享出来的路径也是一样的，处理方式和跳转类似。&lt;/p&gt;
&lt;h5 id=&quot;解决方案-3&quot;&gt;解决方案&lt;/h5&gt;
&lt;p&gt;建议通过通用方法统一处理，我们的做法是，在页面的onShareAppMessage中加入通用方法Share.getFinalShareInfo&lt;/p&gt;
&lt;p&gt;以首页分享为例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import Share from '@/lib/share'
export default {
    ...
    onShareAppMessage () {
        ...
        return Share.getFinalShareInfo({
            title: 'xxx',
            path: `/pages/content/index/main`,
            imageUrl: 'xxxx'
        })
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分享时统一调用Share.getFinalShareInfo方法&lt;/p&gt;
&lt;p&gt;我们再来看下share.js&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export default class Share {
    static getFinalShareInfo (shareInfo) {
        ...
        // 路径前缀处理
        shareInfo.path = VARS.pathPrefix + (shareInfo.path.indexOf('/') === 0 ? '' : '/') + shareInfo.path
        ...
        return shareInfo
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样整个分包业务就配置完成了。是不是很麻烦~&lt;/p&gt;
&lt;p&gt;当初和主程序融合时候确实踩了很多坑，这里我把解决方案和大家分享下&lt;/p&gt;
&lt;p&gt;如果有更好的解决方案，也希望一起交流：）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1203274/201809/1203274-20180905123705939-111388889.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 05 Sep 2018 04:39:00 +0000</pubDate>
<dc:creator>大转转FE</dc:creator>
<og:description>应用场景 同一个主体（公司、部门）下有多个小程序 这些小程序，由一个主小程序和后来新建的多条业务线构成（每条业务线拥有独立的小程序） 各业务线的小程序需要挂载到主程序下面，因为需要主程序导流 同时各业</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuanzhuanfe/p/9591475.html</dc:identifier>
</item>
<item>
<title>关于扁平化视觉设计趋势的一些小分享 - 网易云</title>
<link>http://www.cnblogs.com/163yun/p/9591472.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/163yun/p/9591472.html</guid>
<description>&lt;p&gt;本文来自&lt;a href=&quot;https://sq.163yun.com/blog?tag=M_tg_181_65&quot; target=&quot;_self&quot;&gt;网易云社区&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;作者：刘戈&lt;/p&gt;
&lt;p&gt;作为视觉设计师来说，能设计出一款赏心悦目、走在设计潮流前线而又有自己品牌设计基因的产品是每个人心目中的追求。如果提到当今移动产品UI设计风格趋势时，相信不少设计师心目中的答案是扁平化设计。无可否认，在2013年扁平化设计风格全面普及以来至今，扁平化依旧是移动产品设计的主流方向，但众多产品使用扁平化设计的同时会使得产品之间的视觉差异越来越小，设计师如何把自己的产品设计做得与众不同，让自己产品于同类竞品中脱颖而出就变得尤为关键，这要求设计师时刻要保持设计上的创新，而创新的基础则是要先正确了解好当前行业内设计的主流趋势。&lt;/p&gt;
&lt;p&gt;本文结合自己的工作经验简单分享下当前移动产品扁平化视觉的一些趋势，主要由“质感、色彩、文字、图标、内容展示、动效、手势、品牌应用”几点分析，如果有说得不正确的地方欢迎大家指正，也希望对扁平化设计有兴趣的同学私底下与我多多交流，大家相互学习.&lt;/p&gt;

&lt;p&gt;质感&lt;/p&gt;
&lt;p&gt;1，极致扁平： &lt;/p&gt;
&lt;p&gt;趋向使用更轻量、简洁的方式设计界面，去除所有质感，追求极致扁平设计是当下一个设计潮流，界面内只关注核心内容，抛开任何无关的设计元素，排除了视觉干扰，同时也使界面风格变得更加现代、优雅，工具及内容展示类产品特别适合于此种风格。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180905122532fe5282c1-804e-486b-b216-9338095c9dcd.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;2，弱质感:  &lt;/p&gt;
&lt;p&gt;过度扁平的设计对于内容比较复杂的产品来说并不利于视觉层级的表现，所以现在很多产品的视觉设计融入了轻微质感元素，既丰富了细节，同时也使内容层级更加清晰直观。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201809051225456ad2bb9f-9d65-43d8-bce9-de685c8aefd4.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;色彩  &lt;/p&gt;
&lt;p&gt;配色以简洁为主，界面中的颜色比例对比之前更加精简，更倾向于用更少的颜色进行设计，充分利用颜色对比度去突出重要的内容信息，提高视觉冲击力并强调产品关键功能，同时也可以为产品体验营造氛围，提升产品的品牌辨识度。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201809051225596b1e0fed-dcad-40cc-9a60-370bf6ffeb2f.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;文字    &lt;/p&gt;
&lt;p&gt;文字信息作为内容的重要载体之一，一直是偏平化设计排版的重要环节。现在更多产品的文字设计更加趋向于使用单一字体，通过字体自身样式（加粗、中等、细体、斜体）去划分内容层次，有助于优化浏览体验，打造更加简洁、优雅的界面，增强产品的品牌属性。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180905122613416454ef-3e62-453a-8296-0ed8e39b3e6d.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;偏向选用无衬线字体设计，字体线条清晰、笔触统一，避免过多的装饰性细节。IOS9专门针对中文字体做了设计调整，使用新的“苹方”字体，字体形态更粗，边角更圆润。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201809051226254f238b0b-6dca-49eb-b398-b0d85a551409.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;图标  &lt;/p&gt;
&lt;p&gt;图标是产品功能的重要标识，同时也是塑造产品品牌设计风格的核心基因之一。图标设计必须注重好辨识度与创意的平衡，太抽象的图标影响用户认知，不利于操作，太普通的图标则比较中规中距，视觉上没有亮点。扁平化的图标主要以“线、面”两个基础元素不断地进行多种组合表现，不同的组合能产生不同的质感风格，在视觉呈现上具有一定的差异化。  &lt;/p&gt;
&lt;p&gt;1，纯线条形式：  &lt;/p&gt;
&lt;p&gt;线条式图标在当今设计中被广泛应用，线条的提炼对于以前越来越精简，同时更注重细节呈现  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180905122645b004d24a-ba41-43e5-b11f-bcc07e3b2965.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;2，“线+面”组合形式：  &lt;/p&gt;
&lt;p&gt;通过线与面的搭配，让图标在保持扁平风格基础的同时融入拟物化元素，贴近实际，丰富细节。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180905122700ed45bad0-e83b-432e-8d7c-073767fb4b8b.png&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;3，剪影形式：    &lt;/p&gt;
&lt;p&gt;现代设计趋势的剪影图标更加讲求色彩的对比度，同时也可以通过对形体不同的面进行拼色搭配达到拟物效果，让图标与现实物件联系起来，减少用户认知成本。      &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201809051227144f0a73b7-c6db-4bb1-9a69-5230bcbe6415.png&quot; alt=&quot;&quot;/&gt;    &lt;/p&gt;
&lt;p&gt;另外，图标设计上考虑触发后的效果，可以加强情感化元素，给用户带来轻松愉悦的视觉感观。    &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180905122728c2424702-6cbd-41b2-878b-a1b419e809f8.png&quot; alt=&quot;&quot;/&gt;    &lt;/p&gt;
&lt;p&gt;内容展示    &lt;/p&gt;
&lt;p&gt;扁平化视觉设计的核心是追求纯粹的内容信息本质，  过往界面会使用线条分隔各种区域内容，但是这样的处理会显得界面比较拥挤，同时整体信息排列也比较散乱，使用卡片的形式呈现内容，并通过适当的留白间隔，可以减少线条等元素对内容造成的视觉干扰，可以创造出更干净、清晰的界面，让用户更专注于内容，提高了易用性。    &lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/2018090512274032680338-7be3-40de-86b0-f31a67cebabd.png&quot; alt=&quot;&quot;/&gt;     融入一些平面排版元素（如杂志版式），可让界面更加高端、文艺    &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/2018090512275680814235-51c8-44cd-894f-53681cee488c.png&quot; alt=&quot;&quot;/&gt;    &lt;/p&gt;

&lt;p&gt;动效&lt;/p&gt;
&lt;p&gt;在产品使用过程中，操作动效通过视觉上的反馈可以把用户的注意力吸引到特定区域，减少用户对产品的思考，促进了任务参与。此外，产品动效在情感上可取悦用户，让用户在操作过程中感到惊喜，有利于塑造品牌设计基因&lt;/p&gt;
&lt;p&gt;流行的动效设计是以交互思想作为核心准则去设计，以“轻”为主，视觉呈现上要把握好合适的度，不能太刻意地随意添加，因为多而复杂的动效既影响了性能，也使操作过程变得更为复杂，极大降低了效率。一般来说，动效设计比较适合于用在产品核心功能操作、切换、使用反馈上，也可以用在产品特性介绍上。&lt;/p&gt;
&lt;p&gt;1，操作反馈的动效设计，让产品的使用体验更加轻松愉悦，促进了用户的参与度，并且交互层次更“轻”&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180905122810f8ea6c6e-1dc7-4ef4-8ea7-2b8f0b6ed6f1.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;   &lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180905122942717bab44-bf01-419b-beec-f752162ee657.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2，案例中启动页通过动效的使用，让用户在等待过程中不再枯燥，同时也体现了品牌设计基因。&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180905123000c30bc258-0c8f-4f06-89e7-99804a2e0189.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    &lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/2018090512301308c1be72-bb52-452b-918f-e29bacd2e1a5.gif&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;手势&lt;/p&gt;
&lt;p&gt;随着IOS、安卓智能手机的普及，用户对手势操作也有了一定的认知，产品结合手势运用能大幅度提升效率，给用户呈现更简洁、直观的体验。&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180905123033d2c8e6a5-d69e-401e-98db-c66cd54eefd3.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;   &lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201809051230339cd8c4f7-f25b-482e-8509-bf13849f09fa.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;品牌应用&lt;/p&gt;
&lt;p&gt;品牌设计是个比较大的概念，色彩、版式、质感等设计元素都可以是品牌设计中的一种。这里说的品牌应用是指在产品界面中应用到的一些品牌延伸设计，比如依据品牌定制的图形、动效等等，这些设计元素可以让用户对产品品牌有更深刻的认识，以达到品牌推广目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180905123053b539bbc8-cb3d-4dfb-b1ff-987d8e79d3e0.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结：  &lt;/p&gt;
&lt;p&gt;了解设计趋势对后面的视觉设计工作有重要帮助，它能让设计师形成“审美标准”，让具体的设计工作更加有效率，但设计趋势毕竟是带主观的分析结果，具体的产品视觉呈现还要综合产品需求定位、交互、市场运营等等因素，所以视觉设计师在设计中要学会灵活运用，不能一味照搬，选取最符合自己产品的设计方法才能更好地包装产品，突出品牌设计基因，并不断地加以优化去加深品牌设计对用户的影响。&lt;/p&gt;
&lt;p&gt;建议：&lt;/p&gt;
&lt;p&gt;1，作为视觉设计师，除了工作之外应该要多注重生活中的发现，要善于发现美。  &lt;/p&gt;
&lt;p&gt;2，当看到一个很棒的设计效果，除了收藏之外，更应该多想一下为什么。  &lt;/p&gt;
&lt;p&gt;3，工作之外视觉设计师应该勤做设计尝试，注重自我提升，不要依赖产品项目提升自己。  &lt;/p&gt;
&lt;p&gt;4，时刻了解设计行情与资讯，关注产品的最新动态，设计不是闭门造车。  &lt;/p&gt;
&lt;p&gt;5，优秀视觉设计师要有更好的发散思维，懂得针对当前流行的设计手法加以优化提炼，形成自己独树一帜的设计文化去引领潮流。&lt;/p&gt;


&lt;p&gt;网易云大礼包&lt;a href=&quot;https://www.163yun.com/gift?tag=M_tg_181_65&quot;&gt;：https://www.163yun.com/gift&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来自网易云社区，经作者刘戈授权发布&lt;/p&gt;
&lt;p&gt;相关文章：&lt;br/&gt;【推荐】 &lt;a href=&quot;https://www.cnblogs.com/163yun/p/9558669.html&quot;&gt;认识用户访谈&lt;/a&gt;&lt;br/&gt;【推荐】 &lt;a href=&quot;https://www.jianshu.com/p/e90fb1177448&quot;&gt;流式断言器AssertJ介绍&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 05 Sep 2018 04:35:00 +0000</pubDate>
<dc:creator>网易云</dc:creator>
<og:description>本文来自网易云社区 作者：刘戈 作为视觉设计师来说，能设计出一款赏心悦目、走在设计潮流前线而又有自己品牌设计基因的产品是每个人心目中的追求。如果提到当今移动产品UI设计风格趋势时，相信不少设计师心目中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/163yun/p/9591472.html</dc:identifier>
</item>
<item>
<title>ES基础知识与高频考点梳理 - kjz</title>
<link>http://www.cnblogs.com/kjz-jenny/p/9591432.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kjz-jenny/p/9591432.html</guid>
<description>&lt;ul&gt;&lt;li&gt;变量类型
&lt;ul&gt;&lt;li&gt;JS的数据类型分类和判断&lt;/li&gt;
&lt;li&gt;值类型和引用类型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;原型与原型链(继承)
&lt;ul&gt;&lt;li&gt;原型和原型链的定义&lt;/li&gt;
&lt;li&gt;继承写法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;作用域和闭包
&lt;ul&gt;&lt;li&gt;执行上下文&lt;/li&gt;
&lt;li&gt;this&lt;/li&gt;
&lt;li&gt;闭包是什么&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;异步
&lt;ul&gt;&lt;li&gt;同步VS异步&lt;/li&gt;
&lt;li&gt;异步和单线程&lt;/li&gt;
&lt;li&gt;前端异步的场景&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ES6/7新标准的考查
&lt;ul&gt;&lt;li&gt;箭头函数&lt;/li&gt;
&lt;li&gt;module&lt;/li&gt;
&lt;li&gt;class&lt;/li&gt;
&lt;li&gt;set和map&lt;/li&gt;
&lt;li&gt;promise&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;变量类型&quot;&gt;变量类型&lt;/h2&gt;
&lt;p&gt;JavaScript是一种弱类型脚本语言，所谓弱类型指的是定义变量时，不需要什么类型，在程序运行过程中会自动判断类型&lt;/p&gt;
&lt;h3 id=&quot;ecmascript中定义了6种原始类型&quot;&gt;ECMAScript中定义了6种原始类型&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;boolean&lt;/li&gt;
&lt;li&gt;string&lt;/li&gt;
&lt;li&gt;number&lt;/li&gt;
&lt;li&gt;undefined&lt;/li&gt;
&lt;li&gt;null&lt;/li&gt;
&lt;li&gt;symbol&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;题目类型判断用到哪些方法&quot;&gt;题目：类型判断用到哪些方法？&lt;/h3&gt;
&lt;h4 id=&quot;typeof&quot;&gt;typeof&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;typeof xxx&lt;/code&gt;得到的值有一下类型：&lt;code&gt;undefined、boolean、number、string、object、function、symbol&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;typeof null&lt;/code&gt;结果是&lt;code&gt;object&lt;/code&gt;，实际这是&lt;code&gt;typeof&lt;/code&gt;的一个&lt;code&gt;bug&lt;/code&gt;，&lt;code&gt;null&lt;/code&gt;是原始值，非引用类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typeoof [1,2]&lt;/code&gt;结果是&lt;code&gt;object&lt;/code&gt;，结果中没有这一项，引用类型除了&lt;code&gt;function&lt;/code&gt;其他的全部都是object&lt;/li&gt;
&lt;li&gt;&lt;code&gt;typeof Symbol()&lt;/code&gt;用&lt;code&gt;typeof&lt;/code&gt;获取&lt;code&gt;symbol&lt;/code&gt;类型的值得到的是&lt;code&gt;symbol&lt;/code&gt;，这是&lt;code&gt;ES6&lt;/code&gt;新增的知识点&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;instanceof&quot;&gt;instanceof&lt;/h4&gt;
&lt;p&gt;用于实例和构造函数的对应。例如判断一个变量是否是数组，使用&lt;code&gt;typeof&lt;/code&gt;无法判断,但可以使用[1,2] instanceof Array来判断。因为,&lt;code&gt;[1,2]&lt;/code&gt;是数组,它的构造函数就是Array：同理&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Foo(name) {
    this.name = name
}
var foo = new Foo('bar')
console.log(foo instanceof Foo) // true&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;constructor&quot;&gt;constructor&lt;/h4&gt;
&lt;h4 id=&quot;object.prototype.tostring.call&quot;&gt;object.prototype.toString.call()&lt;/h4&gt;
&lt;h3 id=&quot;题目值类型和引用类型的区别&quot;&gt;题目：值类型和引用类型的区别&lt;/h3&gt;
&lt;h4 id=&quot;值类型vs引用类型&quot;&gt;值类型VS引用类型&lt;/h4&gt;
&lt;p&gt;除了原始类型，ES还有引用类型，上文提到的typeof识别出来的类型中,只有object和function是引用类型，其他都是值类型&lt;/p&gt;
&lt;p&gt;根据JavaScript中的变量类型传递方式，又分为&lt;code&gt;值类型&lt;/code&gt;和&lt;code&gt;引用类型&lt;/code&gt;&lt;br/&gt;值类型包括：&lt;code&gt;Boolean、string、number、undefined、null&lt;/code&gt;;&lt;br/&gt;引用类型包括：object类的所有，如Date、Array、function等。&lt;br/&gt;在参数传递方式上，值类型是按值传递，引用类型是按地址传递&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 值类型
var a = 10
var b = a
b = 20
console.log(a)  // 10
console.log(b)  // 20&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码中，a b都是值类型，两者分别修改赋值，相互之间没有任何影响。再看引用类型的例子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 引用类型
var a = {x: 10, y: 20}
var b = a
b.x = 100
b.y = 200
console.log(a)  // {x: 100, y: 200}
console.log(b)  // {x: 100, y: 200}...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码中，a b都是引用类型。在执行了b = a之后，修改b的属性值，a的也跟着变化。因为a和b都是引用类型，指向了同一个内存地址，即两者引用的是同一个值，因此b修改属性时，a的值随之改动。&lt;br/&gt;再借助题目进一步讲解一下。&lt;/p&gt;
&lt;h4 id=&quot;题目说出下面代码的执行结果并分析其原因&quot;&gt;题目：说出下面代码的执行结果，并分析其原因。&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function foo(a){
    a = a * 10;
}
function bar(b){
    b.value = 'new';
}
var a = 1;
var b = {value: 'old'};
foo(a);
bar(b);
console.log(a); // 1
console.log(b); // value: new...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过代码执行，会发现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;a的值没有发生改变&lt;/li&gt;
&lt;li&gt;b的值发生了改变&lt;br/&gt;这就是因为&lt;code&gt;Number&lt;/code&gt;类型的&lt;code&gt;a&lt;/code&gt;是按值传递的，而&lt;code&gt;Object&lt;/code&gt;类型的&lt;code&gt;b&lt;/code&gt;是按地址传递的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;** JS 中这种设计的原因是：**按值传递的类型，复制一份存入栈内存，这类类型一般不占用太多内存，而且按值传递保证了其访问速度。按共享传递的类型，是复制其引用，而不是整个复制其值（C 语言中的指针），保证过大的对象等不会因为不停复制内容而造成内存的浪费。...&lt;/p&gt;
&lt;p&gt;引用类型经常会在代码中按照下面的写法使用，或者说容易不知不觉中造成错误！&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var obj = {
    a: 1,
    b: [1,2,3]
}
var a = obj.a
var b = obj.b
a = 2
b.push(4)
console.log(obj, a, b)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然obj本身是个引用类型的变量（对象），但是内部的a和b一个是值类型一个是引用类型，a的赋值不会改变obj.a，但是b的操作却会反映到obj对象上。&lt;/p&gt;
&lt;h2 id=&quot;原型和原型链&quot;&gt;原型和原型链&lt;/h2&gt;
&lt;p&gt;JavaScript 是基于原型的语言，原型理解起来非常简单，但却特别重要，下面还是通过题目来理解下JavaScript 的原型概念。&lt;/p&gt;
&lt;h3 id=&quot;题目如何理解javascript的原型&quot;&gt;题目：如何理解JavaScript的原型&lt;/h3&gt;
&lt;p&gt;对于这个问题，可以从下面这几个要点来理解和回答，下面几条必须记住并且理解&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.每一个函数数据类型（函数、类）都天生自带一个prototype属性，prototype的属性值是一个对象数据类型的；&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;&lt;li&gt;prototype 属性中天生自带一个constructor属性，属性值是当前原型所属的类；&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;3.每一个对象数据类型值（对象、数组、arguments...）天生自带一个__proto__属性，属性值指向当前实例所属类的原型；&lt;/li&gt;
&lt;li&gt;4.所有的函数数据类型（普通函数、类（内置的、自定义））都是Function的一个实例；Function是所有函数的基类；&lt;/li&gt;
&lt;li&gt;5.所有的对象数据类型（实例、prototype、对象）都是Object的一个实例；Object是所有对象数据类型的基类；&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 要点一：自由扩展属性
var obj = {}; obj.a = 100;
var arr = []; arr.a = 100;
function fn () {}
fn.a = 100;
// 要点二：__proto__
console.log(obj.__proto__);
console.log(arr.__proto__);
console.log(fn.__proto__);
// 要点三：函数有 prototype
console.log(fn.prototype)
// 要点四：引用类型的 __proto__ 属性值指向它的构造函数的 prototype 属性值
console.log(obj.__proto__ === Object.prototype)...&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;原型&quot;&gt;原型&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 构造函数
function Foo(name, age) {
    this.name = name
}
Foo.prototype.alertName = function () {
    alert(this.name)
}
// 创建示例
var f = new Foo('zhangsan')
f.printName = function () {
    console.log(this.name)
}
// 测试
f.printName()
f.alertName()...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行printName时很好理解，但是执行alertName时发生了什么？这里再记住一个重点 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__（即它的构造函数的prototype）中寻找，因此f.alertName就会找到Foo.prototype.alertName。...&lt;/p&gt;
&lt;p&gt;那么如何判断这个属性是不是对象本身的属性呢？使用hasOwnProperty，常用的地方是遍历一个对象的时候。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var item
for (item in f) {
    // 高级浏览器已经在 for in 中屏蔽了来自原型的属性，但是这里建议大家还是加上这个判断，保证程序的健壮性
    if (f.hasOwnProperty(item)) {
        console.log(item)
    }
}...&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;题目如何理解js的原型链&quot;&gt;题目：如何理解JS的原型链&lt;/h3&gt;
&lt;h4 id=&quot;原型链&quot;&gt;原型链&lt;/h4&gt;
&lt;p&gt;还是接着上面的示例，如果执行f.toString()时，又发生了什么？&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 测试
f.printName()
f.alertName()
f.toString()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;f&lt;/code&gt;本身没有&lt;code&gt;toString()&lt;/code&gt;，并且&lt;code&gt;f.__proto__&lt;/code&gt;（即&lt;code&gt;Foo.prototype&lt;/code&gt;）中也没有&lt;code&gt;toString&lt;/code&gt;。这个问题还是得拿出刚才那句话——当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的&lt;code&gt;__proto__&lt;/code&gt;（即它的构造函数的&lt;code&gt;prototype&lt;/code&gt;）中寻找。&lt;/p&gt;
&lt;p&gt;如果在&lt;code&gt;f.__proto__&lt;/code&gt;中没有找到&lt;code&gt;toString&lt;/code&gt;，那么就继续去&lt;code&gt;f.__proto__.__proto__&lt;/code&gt;中寻找，因为&lt;code&gt;f.__proto__&lt;/code&gt;就是一个普通的对象而已嘛！...&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;f.__proto__&lt;/code&gt;即&lt;code&gt;Foo.prototype&lt;/code&gt;，没有找到&lt;code&gt;toString&lt;/code&gt;，继续往上找&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f.__proto__.__proto__&lt;/code&gt;即&lt;code&gt;Foo.prototype.__proto__&lt;/code&gt;。&lt;code&gt;Foo.prototype&lt;/code&gt;就是一个普通的对象，因此&lt;code&gt;Foo.prototype.__proto__&lt;/code&gt;就是&lt;code&gt;Object.prototype&lt;/code&gt;，在这里可以找到&lt;code&gt;toString...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;因此&lt;code&gt;f.toString&lt;/code&gt;最终对应到了&lt;code&gt;Object.prototype.toString&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样一直往上找，你会发现是一个链式的结构，所以叫做“原型链”。如果一直找到最上层都没有找到，那么就宣告失败，返回undefined。最上层是什么 —— &lt;code&gt;Object.prototype.__proto__ === null&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;原型中的this&quot;&gt;原型中的this&lt;/h4&gt;
&lt;p&gt;所有从原型或更高级原型中得到、执行的方法，其中的&lt;code&gt;this&lt;/code&gt;在执行时，就指向了当前这个触发事件执行的对象。因此&lt;code&gt;printName&lt;/code&gt;和&lt;code&gt;alertName&lt;/code&gt;中的&lt;code&gt;this&lt;/code&gt;都是&lt;code&gt;f&lt;/code&gt;。&lt;/p&gt;
</description>
<pubDate>Wed, 05 Sep 2018 04:23:00 +0000</pubDate>
<dc:creator>kjz</dc:creator>
<og:description>知识点梳理目录列表 变量类型 JS的数据类型分类和判断 值类型和引用类型 原型与原型链(继承) 原型和原型链的定义 继承写法 作用域和闭包 执行上下文 this 闭包是什么 异步 同步VS异步 异步和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kjz-jenny/p/9591432.html</dc:identifier>
</item>
<item>
<title>从壹开始前后端分离 [ Vue2.0+.NET Core2.1] 十六 ║  Vue前篇：ES6初体验 &amp; 模块化编程 - 老张的哲学</title>
<link>http://www.cnblogs.com/laozhang-is-phi/p/9585766.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laozhang-is-phi/p/9585766.html</guid>
<description>&lt;p&gt;昨天说到了《&lt;a id=&quot;post_title_link_9580807&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9580807.html&quot;&gt;从壹开始前后端分离 [ Vue2.0+.NET Core2.1] 十五 ║ Vue前篇：JS对象&amp;amp;字面量&amp;amp;this&lt;/a&gt;》，通过总体来看，好像大家对这一块不是很感兴趣，嗯~~这一块确实挺枯燥的，不能直接拿来代码跑一下那种，不过还是得说下去，继续加油吧！如果大家对昨天的小demo练习的话，相信现在已经对JS的面向对象写法很熟悉了，如果嵌套字面量定义函数，如何使用this关键字指向。今天呢，主要说一下ES6中的一些特性技巧，然后简单说一下模块化的问题，好啦，开始今天的讲解~&lt;/p&gt;
&lt;p&gt;还是老规矩，一言不合就是上代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
str1 = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello JS!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
function fun1() {
 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; str1 = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Hello C#!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
}
fun1();
alert(str1);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大家猜猜，最后会弹出来哪一句话？&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180904160205840-526354903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这些定义网上一大堆，不过还是粘出来，大家可以统一看一下，简单了解了解：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ECMAScript 6是JavaScript语言的下一代标准，在2015年6月正式发布。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。&lt;/p&gt;
&lt;p&gt;标准的制定者有计划，以后每年发布一次标准，使用年份作为标准的版本。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。也就是说，ES6就是ES2015，下一年应该会发布小幅修订的ES2016。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、有哪些新的变化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编程语言JavaScript是ECMAScript的实现和扩展，由ECMA（一个类似W3C的标准组织）参与进行标准化。ECMAScript定义了：&lt;/p&gt;
&lt;p&gt;ECMAScript标准不定义HTML或CSS的相关功能，也不定义类似DOM（文档对象模型）的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API&quot;&gt;Web API&lt;/a&gt;，这些都在独立的标准中进行定义。ECMAScript涵盖了各种环境中JS的使用场景，无论是浏览器环境还是类似&lt;a href=&quot;http://nodejs.org/&quot;&gt;node.js&lt;/a&gt;的非浏览器环境。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、ECMAScript和JavaScript的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版。&lt;/p&gt;
&lt;p&gt;该标准从一开始就是针对JavaScript语言制定的，但是之所以不叫JavaScript，有两个原因。一是商标，Java是Sun公司的商标，根据授权协议，只有Netscape公司可以合法地使用JavaScript这个名字，且JavaScript本身也已经被Netscape公司注册为商标。二是想体现这门语言的制定者是ECMA，不是Netscape，这样有利于保证这门语言的开放性和中立性。&lt;/p&gt;
&lt;p&gt;因此，ECMAScript和JavaScript的关系是，前者是后者的规格，后者是前者的一种实现&lt;/p&gt;


&lt;p&gt;这里先说下，作用域的问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、ES6之前，JavaScript 并没有块级作用域，所谓的块，就是大括号里面的语句所组成的代码块&lt;/strong&gt;，比如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function blog(bl) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (bl) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; foo = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Blog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }
    console.log(foo);
}

blog(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;=&amp;gt; Blog&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、虽然变量变量foo 位于 &lt;code&gt;if&lt;/code&gt; 语句的代码块中，但是 JavaScript 并没有块级作用域的概念，因此被添加到了当前的执行环境 - 即函数中，在函数内都可以访问到。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;因此：&lt;/strong&gt;var 定义的变量是&lt;strong&gt;函数级作用域&lt;/strong&gt;，作用范围是在函数开始阶段和函数执行完成之前内都是存在的；&lt;/p&gt;
&lt;p&gt;　　　并且如果该函数内部还存在匿名函数等特殊函数,这个 var 出的变量在匿名函数中任然可以用; &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3、在ES出现后，定义了一个新的命名方式 let &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
function Blog(&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;) {
        let foo &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Blog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        console.log(foo);
    }
}
Blog(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里会报错 Uncaught ReferenceError: foo is not defined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180904161930765-73761473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;因此，使用 let，上述问题完全解决，let出的变量作用域是 &lt;strong&gt;块作用域&lt;/strong&gt;，在离开某一代码块,该变量就会被销毁不存在&lt;/p&gt;
&lt;p&gt;应当尽可能的避免用 var，用 let 来代替，除非你需要用到变量提升。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt; 4、随着面向对象思维的出现，JS也出现了常量的定义 const&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;const 与 let 的基本用法相同，定义的变量都具有块级作用域，也不会发生变量提升。不同的地方在于，const 定义的变量，只能赋值一次。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;const&lt;/span&gt; foo=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Blog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
function Blog(&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;) {
         foo &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Vue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        console.log(foo);
    }
}
Blog(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里会报错 Identifier 'foo' has already been declared&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180904162432237-1958992495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此const多用作不发生变化的变量定义，比如定义月份，或者，星期等:&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; &lt;span&gt;months = [];&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;还记得昨天的那个小demo么，今天再说一个地方&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
    data: {
        books: &lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,
        price: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
        bookObj: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
    },
　　 bind() {&lt;span&gt;//&lt;strong&gt;注意！&lt;/strong&gt;ES6 中，可以使用这种方法简写函数，等价于 bind: function () {
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; that = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;普通函数
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;$(&quot;.ok&quot;).click(function () {&lt;br/&gt;　　　　 //    console.log(this);//这个时候，this，就是 .ok 这个Html标签
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    var bookItem = that.data.bookObj;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    var _parice = $(bookItem).data(&quot;price&quot;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    var _book = $(bookItem).data(&quot;book&quot;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    that.data.books += _book + &quot;,&quot;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    that.data.price += parseInt(_parice);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    that.show();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;});

　　　　 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;箭头函数&lt;/span&gt;
        $(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).click(() =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bookItem = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.data.bookObj;//在箭头函数中，this指向的是定义函数时所在的对象
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _parice = $(bookItem).data(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; _book = $(bookItem).data(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;book&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data.books += _book + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.data.price +=&lt;span&gt; parseInt(_parice);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.show();
            $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.bg,.popupbox&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).hide();

        });
    },
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;在普通的click函数中 this 指向对象  $(&quot;.ok&quot;) ，因此，我们如果想要获取定义的对象中的数据（obj.data），那我们只能在 click 方法前，就去用一个 that 自定义变量来保存这个 this ，&lt;/p&gt;
&lt;p&gt;但是在箭头函数中就不一样了，this &lt;span&gt;始终指向定义函数时所在的对象（就是 obj 对象）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是不是更方便些！&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Vue中，也经常使用 vue实例，或者this来获取相应的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
    el:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    data:{
        tasks:[]
    },
    mounted(){
        axios.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/tasks&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        .then(function (response) {
            vm.tasks &lt;/span&gt;=&lt;span&gt; response.data;//使用Vue实例
        })
    },
    mounted2(){
           axios.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/tasks&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            .then(response &lt;/span&gt;=&amp;gt; &lt;span&gt;this&lt;/span&gt;.tasks =&lt;span&gt; response.data);//箭头函数 this 
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;1、 在ES6中，可以像C#那样定义默认参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
function buyBook(price, count = &lt;span&gt;0.9&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; price *&lt;span&gt; count;
}
buyBook(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;甚至可以将方法的值赋给参数&lt;/span&gt;
function buyBook(price, count =&lt;span&gt;GetCount()){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; price *&lt;span&gt; count;
}
function GetCount(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
}

buyBook(&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、不仅如此，还可以快速获取参数值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ES6之前是这样的&lt;/span&gt;
&lt;span&gt;function add(a,b,c){
    let total &lt;/span&gt;= a + b +&lt;span&gt; c;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; total;
}
add(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ES6你可以这么操作，提供了 rest 参数来访问多余变量&lt;/span&gt;
&lt;span&gt;function sum(...num) {
    let total &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num.length; i++&lt;span&gt;) {
        total &lt;/span&gt;= total +&lt;span&gt; num[i];
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; total;
}
sum(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;1、字符串表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在之前我们都是这样使用字符串表达式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id is &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + bid+ &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; + aid + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://localhost:5000/api/values/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + id
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在ES6中我们有了新语法，在反引号包裹的字符串中，使用${NAME}语法来表示模板字符:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; name = `id &lt;span&gt;is&lt;/span&gt;&lt;span&gt; ${aid} ${bid}`
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url = `http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:5000/api/values/${id}`//注意是反引号，英文输入下下的，Tab键上边的那个&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、还有就是多行表达式的写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;之前我们都是这么写的&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; roadPoem = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;这个是一个段落&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;换了一行&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;增加了些内容&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;dddddddddd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
 
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;但是在ES6中，可以使用反引号&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; roadPoem =&lt;span&gt; `这个是一个段落
   换了一行
    增加了些内容,
    dddddddddd
    结尾,`
 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt; 1、什么是模块化开发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 模块化开发是基于一定的语法规范，通过代码书写设计，使代码耦合度降低，模块化的意义在于最大化的设计重用，以最少的模块、零部件，更快速的满足更多的个性化需求。因为有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。&lt;/p&gt;
&lt;p&gt;用阮一峰大神的说法就是：&lt;/p&gt;
&lt;blockquote readability=&quot;7.7884297520661&quot;&gt;
&lt;p&gt;今天的Web网页越来越像桌面程序，网页上加载的javascript也越来越复杂，前端工程师不得不开始用软件工程的思维去管理自己的代码。Javascript模块化编程，已经成为一个非常迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。但是，Javascript不是一种模块化编程语言，它不支持&quot;类&quot;（class），更别提&quot;模块&quot;（module）了。（正在制定中的&lt;a href=&quot;http://en.wikipedia.org/wiki/ECMAScript&quot; target=&quot;_blank&quot;&gt;ECMAScript标准&lt;/a&gt;第六版将正式支持&quot;类&quot;和&quot;模块&quot;，但还需要很长时间才能投入实用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 就这样，Node.js 就出现了，一个用来开发服务器端的js框架，基于commonJs的模块化。当然中间还有CMD，AMD（这个东西我还需要慢慢研究下）；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、模块化在代码中是如何体现的呢&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、首先我们先看看普通的定义一个类是如何写的&lt;/p&gt;
&lt;p&gt;新建一个index.js 文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {
    constructor(homework&lt;/span&gt;=&lt;span&gt; []) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.homework=&lt;span&gt; homework;
    }

    study() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.homework);
    }
}

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; st = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Student ([
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;blog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;api&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;vue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
]);

st.study();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后新建一个index.html页面，引用该js文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以得到结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180904191813041-336063679.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;这是一个很简单的，定义一个Student 类，然后定义一个方法，通过传递一个数组参数，来实例化。&lt;/p&gt;
&lt;p&gt;这样虽然很简单，但是却无法复用，无法作为一个零件来使用。而且如果有一个地方要修改，多处都需要修改，这个面向对象的思想，没有发挥出来；&lt;/p&gt;
&lt;p&gt;这个时候你可能会说，把这个拆成两个问题，就可以复用了，嗯~试试&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;2、我们把这两个文件分开&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新建一个Student.js ，定义处理Student类；然后新建一个main.js方法，来调用实例化该类，就可以使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180904191544947-352172339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在 index.html 页面里去引用这两个文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;body&amp;gt;

    &amp;lt;script src=&lt;span&gt;&quot;S&lt;/span&gt;&lt;span&gt;tudent.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;当然结果是一样的，这样虽然实现了分隔开，也可以去不同的地方调用；&lt;/p&gt;
&lt;p&gt;但是，从上文中你也看的出，如果不是自己写的代码，一般不太容易看的明白，到底是什么意思，直观性不是很好，我们将无法看到彼此间的关联（main.js 加载 Student.js),&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;3、我们用模块的写法设计这个调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ES6 模块不是对象，而是通过&lt;code&gt;export&lt;/code&gt;命令显式指定输出的代码，再通过&lt;code&gt;import&lt;/code&gt;命令输入。&lt;/p&gt;
&lt;p&gt;我们直接修改之前的代码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201809/1468246-20180904192713756-2099233545.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后在 index.html 页面中，只需要引用 &amp;lt;script src=&quot;main.js&quot;&amp;gt;&amp;lt;/script&amp;gt; 就行&lt;/p&gt;

&lt;p&gt;4、因为浏览器现在还不能直接运行模块化代码，所以我们需要打包，打包工具有很多，比如 webpack&lt;/p&gt;
&lt;p&gt;注意：这里用到打包概念，之后会讲到，这里就先略过，以后会讲到，步骤是&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;首先安装&lt;strong&gt;npm，&lt;/strong&gt;或者阿里镜像 &lt;strong&gt;cnpm&lt;/strong&gt;（npm其实是Node.js的包管理工具，这个在我们之后的Node.js环境配置中，自动随带安装）&lt;br/&gt;全局安装 rollup.js   &lt;strong&gt;&lt;span&gt;$ cnpm install --global rollup&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;cd 当前文件夹 &lt;strong&gt;$ rollup main.js --format iife --output bundle.js &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;然后只需要引用生成的  &amp;lt;script src=&quot;bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;5、这里我因为测试，已经生成好了，打包出来的bundle.js 是这样的，是不是兜兜转转又回到了之前的写法，其实ES6的模块开发，就是导入的代码块儿&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(function () {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;use strict&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TaskCollection {
        constructor(tasks &lt;/span&gt;=&lt;span&gt; []) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tasks =&lt;span&gt; tasks;
        }

        dump() {
            console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tasks);
        }
    }


    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; tc = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TaskCollection([
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;blog&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;api&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;vue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    ]);

    tc.dump();

}());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 总结来说：模块化的好处和问题&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;可维护性&lt;/p&gt;
&lt;p&gt;灵活架构，焦点分离&lt;/p&gt;
&lt;p&gt;方便模块间组合、分解&lt;/p&gt;
&lt;p&gt;方便单个模块功能调试、升级&lt;/p&gt;
&lt;p&gt;多人协作互不干扰&lt;/p&gt;
&lt;p&gt;可测试性，可分单元测试；&lt;/p&gt;
&lt;p&gt;性能损耗&lt;/p&gt;
&lt;p&gt;系统分层，调用链会很长&lt;/p&gt;
&lt;p&gt;模块间通信,模块间发送消息会很耗性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 其实说白了，就是JS在作为一个开发语言来说，越来越靠近了后端服务器语言。&lt;/p&gt;


&lt;p&gt;这里是一个特别特别简单的关于ES6的留言板，大家可以看一看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h2&amp;gt;简易留言板&amp;lt;/h2&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; placeholder=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入内容&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; size=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;留言&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;msg-div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script&amp;gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;let 定义块级变量&lt;/span&gt;
        let oBtn = document.getElementById(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;btn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        let msg &lt;/span&gt;= document.getElementById(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;msg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        let content &lt;/span&gt;= document.getElementById(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;msg-div&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        oBtn.onclick &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
            let ovalue &lt;/span&gt;=&lt;span&gt; msg.value;
            let ali &lt;/span&gt;= document.createElement(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ES6模板字符串
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多行表达式&lt;/span&gt;
            ali.innerHTML = `${ovalue}&amp;lt;span style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color:red;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;  
                                删除&lt;/span&gt;&amp;lt;/span&amp;gt;&lt;span&gt;`;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; aspan = content.getElementsByTagName(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (aspan.length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                content.insertBefore(ali, aspan[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                content.appendChild(ali);
            }
            msg.value &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; oSpan = content.getElementsByTagName(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; oSpan.length; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ES6箭头函数&lt;/span&gt;
                oSpan[i].onclick =&lt;span&gt; function () {
                    content.removeChild(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parentNode);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意this的指向&lt;/span&gt;
&lt;span&gt;                };
            }
        };
    &lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过这两天的学习，大家了解到了，JS的一些特性和变化：嵌套字面量的定义，面向对象的封装，类和模块化的使用，ES6的日益成熟，通过打包进行发布等等，都能表现出JS在向一个服务器端语言快速迈进的冲动，也是极大的推动了，MVVM的到来，从而实现像Node.js 这种，可以脱离浏览器环境也能运行的不一样视角。好啦，关于JS高阶，这两讲已经差不多了，当然还有其他的，大家可以自行学习了解，其实这两篇都懂的化，已经差不多了，明天咱们就开始正式进入Vue入门篇，通过引用Vue.js 实现栗子。&lt;/p&gt;

</description>
<pubDate>Wed, 05 Sep 2018 04:01:00 +0000</pubDate>
<dc:creator>老张的哲学</dc:creator>
<og:description>缘起 昨天说到了《从壹开始前后端分离 [ Vue2.0+.NET Core2.1] 十五 ║ Vue前篇：JS对象&amp;字面量&amp;this》，通过总体来看，好像大家对这一块不是很感兴趣，嗯~</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laozhang-is-phi/p/9585766.html</dc:identifier>
</item>
<item>
<title>在国企的日子(第一章 面试) - 心灵之火</title>
<link>http://www.cnblogs.com/dgcjiayou/p/9591231.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgcjiayou/p/9591231.html</guid>
<description>&lt;p&gt;我叫雷刚，别看我的名字很刚，其实我只是一个程序员，我的性格稍偏内向，但是我的一颗澎湃的青春荷尔蒙的心经常在提醒我，我今年27岁了，我知道我该需要什么了，每当夜深人静的时候，我时常在思考，我为什么而活，应该怎么活？&lt;/p&gt;
&lt;p&gt;我已经离职有2个月了，我不太想找工作，反正这3年上班，一个人过日子存了一点，除了吃饭平时也花不了几个钱，其实我现在对钱不是特别感兴趣，我反而对自己后面要走的路很焦虑，我做java开发是不是就这样一直做下去，行么？可能孤单的时间太长，自己反而磨练出一种能耐，就是抗寂寞，抗无聊，我可以一整天在家看一部20集的电视剧，直到看完为此，也可以一整天坐在网吧，玩一个游戏玩到电脑弹出框提示续费为此，没错，这就是我平时业余的屌丝生活。&lt;/p&gt;
&lt;p&gt;2天前，我象征性的在网上刷新了下简历，投了几家甚至连公司名都没看完的公司，因为我感觉继续这样下去，我要完了，所以我需要和外界沟通那么一点点，唉，什么公司无所谓啦，薪资差不多就行啦，看缘分吧。我觉得很奇怪，怎么没公司打我电话，我刚还看了下邮箱的，里面空空如也。按照这两个月的生活规律，都是晚上2点睡觉，早上11点起床，早餐和中餐一起，等下去楼下吃个盖码饭，然后坐公交去市中心广场游荡下，去人多的地方吸点阳气，看看人来人往，看看美女，然后也许找个游戏厅，也许找个网吧坐几个小时不好说。&lt;/p&gt;
&lt;p&gt;今天的盖码饭不合我胃口，也许昨晚睡觉太晚了，电视剧看完后，后面又看了部片，大概半个小时吧，早上起床身体有点虚，不好吃就不吃呗，我的生活从来没有勉强二字，等下去市中心美食街看到什么想吃什么就吃什么。“老板，微信付款了啊”，我喊了句，走向公交站，挺好，最近2个月从来没有挤过公交，位置大把，感觉挺开心的。这时手机铃声响了起来，我从裤兜里面拿出手机，接听，“喂，您好！”，我接电话一贯如此，陌生电话不管谁，都是这句话。这个时候电话那边传来一个女声，声音绵绵的，蛮好听的，&lt;/p&gt;
&lt;p&gt;“请问是雷先生吗？”，&lt;/p&gt;
&lt;p&gt;“是的，请问你是哪里”？&lt;/p&gt;
&lt;p&gt;“我们是H集团有限公司，前两天看到你在我们公司投的简历，我们这边技术经理看了你的简历，初步觉得挺合适的，请问你今天有时间方便来下公司面谈吗？”&lt;/p&gt;
&lt;p&gt;我正好无聊透顶，心想坐公交出去逛逛也挺好。我就满口答应道，&lt;/p&gt;
&lt;p&gt;“可以，请问你们地址是在哪里？”&lt;/p&gt;
&lt;p&gt;“好的，好的，我回头把地址发你邮箱和手机各发一份，你注意查收下，我们这边下午1点半上班，你过来就是”。&lt;/p&gt;
&lt;p&gt;“好的，就这样，我会按时来的”。&lt;/p&gt;
&lt;p&gt;刚挂了电话，擦，立马就收到了短信，这个短信来的好快啊，我看了下，地址离这里大概有20个公交站，现在差不多12点，等会车，坐车过去1个小时左右吧，到那里顺便休息下差不多了。这是2个月来的第一次面试，我能感觉到我的生活要开始进入规律化了。&lt;/p&gt;
&lt;p&gt;………….&lt;/p&gt;
&lt;p&gt;按照指定地点下车后，问了个报刊亭的大妈，知道H集团公司就在附近，我绕过了2条马路，大概走了10分钟，看到一排排红色的房子井井有条有条的排成2排，全部都是3层的楼房，每个房子墙上右上角分别写了1栋，2栋这些字眼，我粗略的数了下估计有10多栋吧，这完全是个产业区啊，和我以前上班的高楼大厦完全不一样啊，我看到下面人来人往的，有的穿着类似工厂那种工作服似的，我怀着好奇的心走向指定地点，8栋3楼504，这里没有电梯，我直接爬楼到了3楼，里面一间间的房间紧紧的挨着，走廊好长，但是非常安静，这种地方倒挺适合程序员写代码的，我心里暗暗的想，我走到504房间，看到里面有2个女孩坐在电脑旁不停的敲字，键盘发出的哒哒的声音伴有那么一种节奏感，显得她们的工作是那么专业熟练，我轻轻的敲了敲房门，&lt;/p&gt;
&lt;p&gt;“你好，我是来面试java的”，我轻轻的喊了声，生怕打断他们的工作。&lt;/p&gt;
&lt;p&gt;“请稍等啊，我马上出来”，没想里面还有间小房子，一个声音从里面的房子传来。&lt;/p&gt;
&lt;p&gt;一会儿，一个穿蓝裙子长头发身材稍微有点胖胖的女孩从里面走出来，手里拿了几张纸，看年纪，大概20几岁出头左右。&lt;/p&gt;
&lt;p&gt;“你是雷刚雷先生吧，我是上午和你电话联系的，我叫贾珍珍”，她微微笑道，这个时候我才看清楚她的面貌，脸蛋微圆，相貌甚甜，大大的眼睛漆黑光亮，嘴角正带着笑意，说实话挺和蔼可亲的。&lt;/p&gt;
&lt;p&gt;“嗯，嗯，我是雷刚”，我答道。&lt;/p&gt;
&lt;p&gt;“请跟我来这房间，你先填下表格，这里有张试卷，你也先做下，做好了叫我”，说完她带着我到了隔壁一个房间，里面是个会议室，1个10人左右的长方形会议桌摆在中间，我找了个位置坐了下来，她把2张纸放到我面前。&lt;/p&gt;
&lt;p&gt;“你稍等，我给你倒杯水”，她微微笑道。&lt;/p&gt;
&lt;p&gt;“谢谢，辛苦了”，我应道。&lt;/p&gt;
&lt;p&gt;我看了她给的2张纸，一张是资料表，另外一张是个试卷，按照常规，我先用最快的速度填下资料，这个时候她进来把倒好的水递给我，我伸手去接过来，近距离下我闻到她身上一阵淡淡的香水味，这个时候我觉得与其说她微胖，不如说丰满更加体贴。&lt;/p&gt;
&lt;p&gt;“做好了来隔壁房间叫我哦”，她轻轻的把门关上。&lt;/p&gt;
&lt;p&gt;我开始填资料表，无非就是就是姓名，年龄，籍贯，健康情况，紧急联系人电话这些，我用最快的时间填完，下面还有毕业学校，项目经历这些，我打开手机，找个里面的简历，花了2分钟抄完了，资料表总算填完了。我记得我刚毕业那年，每次面试都要填这个资料表，有时候一天面试3，4家，要填3，4次，那个时候特别厌烦填这个鬼东西，简直浪费时间。不过，今天貌似心情还不错，花了几分钟就填完了。我拿起试卷，稍微看了下，心里苦笑道，面试宝典，又是面试宝典的题目，这个面试宝典从3年前到现在，依然没变，依然还是那些题目，我嗖嗖的拿起笔就往下写，简直振笔疾书啊，这些题目倒背如流啊，说实话，有些题目是什么意思我都没深入去研究，但是，我就是知道答案，事情就是这么神奇。话不多说，开始写起来。&lt;/p&gt;
&lt;p&gt;第1题：String 和StringBuffer的区别。&lt;/p&gt;
&lt;p&gt;答：String字符串常量，不可变，StringBuffer字符串变量，可变。执行速度StringBuffer比String快。&lt;/p&gt;
&lt;p&gt;第2题：final, finally, finalize的区别。&lt;/p&gt;
&lt;p&gt;答：final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。finally是异常处理语句结构的一部分，表示总是执行。finalize是垃圾收集时的其他资源回收。&lt;/p&gt;
&lt;p&gt;第3题：HashMap和Hashtable的区别。&lt;/p&gt;
&lt;p&gt;HashMap允许空（null）键值（key）,非线程安全。Hashtable不允许空键，线程安全的。&lt;/p&gt;
&lt;p&gt;第4题：jsp有哪些内置对象?。&lt;/p&gt;
&lt;p&gt;答：request，response，pageContext，session， application，out，config，page，exception。&lt;/p&gt;
&lt;p&gt;……….&lt;/p&gt;
&lt;p&gt;感谢面试宝典的题目，感谢葵花宝典给我信心，一个都不少，全是里面的。后面还有2个选择题，是关于子类继承父类，方法覆盖，向上转型相关的题目，相对没什么难度。我舒了口气，伸展了下腰，放松放松，翻开背面，尼玛的，最恶心的题目果然来了。&lt;/p&gt;
&lt;p&gt;第20题：你为什么要离开上家公司？ &lt;/p&gt;
&lt;p&gt;说实话，我个人是很清楚出这种题目的人大多连他自己都不清楚想要什么样的答案，说白了，就是真的没题目找个题目来凑数的，你信不信，反正我是信了。话虽然如此，但是这个题目不可能空着啊，还是要写点东西，虽然我们都知道马云说过员工辞职的原因无非就那两点，但是这样写也不太好啊。还有，像这些话我肯定不会写的，比如工作太辛苦了，自己不适应，人际关系复杂，管理混乱，公司不重视人才，没有年终奖，公司打压我等等。那应该怎么写呢？我在思索着，应该写个理由既不损害原来公司的光辉形象(毕竟原来的公司现在还在开，总不能说倒闭了吧)，也不能影响到个人的人格品质之类，突然灵感乍现，我微微一笑，毫不犹豫的写上，寻找更大的舞台。&lt;/p&gt;
&lt;p&gt;填完2张纸后，我拿起走向隔壁的房间，轻轻敲了下房门，说道“我填完了”。&lt;/p&gt;
&lt;p&gt;“好的，你在里面等我下，我就过来”，贾珍珍在里面说道。&lt;/p&gt;
&lt;p&gt;我又回到会议室坐下，等待这位身上有淡淡香味的美女来到。&lt;/p&gt;
&lt;p&gt;过了一会，贾珍珍来到，我站起来礼貌的打招呼，并把填好的纸张给她递过去。她微笑的示意叫我坐下，其实看起来年级我应该比她还大那么点点，但是说实话，我还是有那么一点点拘束感，我这个人就是这样，在女的面前，尤其是那种活泼点的女孩面前就是放不开，我甚至有时候怀疑自己如果有个美女来引诱我的话，我应该比较容易上钩。&lt;/p&gt;
&lt;p&gt;贾珍珍坐下来看了下我递过去的资料表，然后和答题纸一起放到桌子一边，微笑的说道着：&lt;/p&gt;
&lt;p&gt;“我是这里的人事经理，主要负责人事招聘这块的工作，我先和你稍微介绍下我们这里吧，你可能来的时候应该感觉这里面和你之前上班应该有些不同，我们这里不是纯正意义上的软件开发公司，我们这里是属于电力行业下面的一个部门，主要负责集团公司内部的系统开发和日常维护，简单来说，我们是国企性质”。&lt;/p&gt;
&lt;p&gt;“嗯”，我应道，说实话，我投了个连公司名称都没看清楚的简历，居然还是个国企。&lt;/p&gt;
&lt;p&gt;贾珍珍是属于那种在工作上很主动很活泼的女孩，她那双名明眸的眼睛一直看着我，我都有点不好意思了，她好像看穿了我的一些心思似的，接着说道：&lt;/p&gt;
&lt;p&gt;“你可以方便介绍下自己之前的经历吗？我想了解下你之前的工作经历”，&lt;/p&gt;
&lt;p&gt;“嗯，好的，我叫雷刚，我是xx人，大学毕业后一直在xx公司做java软件开发工程师，在公司主要负责一些日常业务的开发工作，在公司3年里面一共做了2个项目……………”，我巴拉巴拉用了3分钟简单描述了之前的工作经验。&lt;/p&gt;
&lt;p&gt;“嗯，好的，感觉你还是个比较踏实的人，我想问下，你现在成家了吗？” 贾珍珍看着我继续问道。&lt;/p&gt;
&lt;p&gt;“没咧，我还年轻，早着呢”，我打趣的回应。&lt;/p&gt;
&lt;p&gt;“嗯，是的，男人是应该以事业为重，搞软件开发这个行业的大多数都是30几岁结婚的很多”。&lt;/p&gt;
&lt;p&gt;我听到这话，我心里在想，我傻啊，我要是真的碰到好的女孩，喜欢双方合适的女孩，再早几年结婚我都愿意，我自己都很清楚，越到后面好的女孩就越少。&lt;/p&gt;
&lt;p&gt;“嗯，嗯，我周围搞这行大多认识的朋友都是差不多这个年纪成家的”，我也笑着回应。&lt;/p&gt;
&lt;p&gt;“你平时工作业余下班后和周末一般干些什么呀”？ 贾珍珍好像对我的私生活挺感兴趣的。&lt;/p&gt;
&lt;p&gt;我心里在想，我最近半年的业余生活都是看电视剧，看片，玩游戏，偶尔约朋友出去爬爬山，基本都是一个人过日子。但是显得我是个有上进心的男人，不想让这双一直看着我充满期待的眼神失望，我挺了挺腰板，说道：&lt;/p&gt;
&lt;p&gt;“我平时一般在家自己做饭吃，然后看些专业书籍，提升下自己的能力，周末出去爬爬山，锻炼下身体。&lt;/p&gt;
&lt;p&gt;“哇，还会自己做饭啊，挺不错啊”，我也不知道贾珍珍是真夸奖我还是职场上的话，不过说实话，我在家还是偶尔做做饭的，主要想吃什么就做什么，方便。&lt;/p&gt;
&lt;p&gt;然后贾珍珍又问了些我家庭相关，个人兴趣的，生活习惯的相关的话题，双方聊的倒都挺随意，整个过程，我被这个身材饱满，有淡淡香味的女人一直在询问，尽是些个人平时都不太关注的事情。&lt;/p&gt;
&lt;p&gt;大概聊了20分钟吧，贾珍珍站起来说道：&lt;/p&gt;
&lt;p&gt;“你稍等下，我叫下我们的项目经理和你聊下具体技术”，我也表示礼貌站起来，微笑的看着她走出会议室，心里默默的想，这个女人如果和我谈恋爱的话，我愿意试试。说实话，不嫌丢人，我长这么大了，还没谈过恋爱，我现在需要的就是主动向我发起猛攻，来对我嘘寒问暖的女孩，我继续意淫着。&lt;/p&gt;
&lt;p&gt;过了一会，进来一个人，大汗淋漓，圆滚滚的肚子上上下下颠动，一眼瞄过去，大概35到40之间，乌黑的头发稍微有点少，但是遮住半片脑袋瓜子绝对够用了，一进来就喊，请问是雷刚吧，我站起来应道，“是的”。&lt;/p&gt;
&lt;p&gt;“请跟去另外房间吧，项目经理刚开完会，我带你去找他”，说完，带我从走廊一直往前走，说实话，我也不知道他是干啥的，也没多问，跟着他一直往前走就是，一直走到走廊的尽头，看到两边的房子里面一排排坐满了人，感觉有点熟悉的味道，我估计这些应该都是开发人员了吧，终于走到尽头，带我进到另外一个小房间，我进去一看，也是会议室，比刚才那个稍微小点，我进去找个位置坐下，他说了声，“稍微等下”，刚才出去了。&lt;/p&gt;
&lt;p&gt;又一会后，进来一个人，瘦瘦高高的，说实话，长的还挺帅气的，一看就是平时很注意穿着，喜欢修边幅的那种人，估计也就30多岁吧，挺精神的，腰板挺的很直，走路还略带风，我真能感觉到有风吹过。&lt;/p&gt;
&lt;p&gt;“我叫李明，是这里的项目经理”，他边说边伸过手来和我握手，我连忙迎过去，能感觉他的手掌很宽很有力。&lt;/p&gt;
&lt;p&gt;“刚才带你来的是我们的网管，请坐”，他微笑道。&lt;/p&gt;
&lt;p&gt;我们坐下。&lt;/p&gt;
&lt;p&gt;“刚才听我们人事小妹子说你挺优秀的，对你的评价也挺高”，我谦虚的应到，“过奖了”。&lt;/p&gt;
&lt;p&gt;“然后我这边主要想了解下你之前工作中用到的一些相关技术，你稍微聊聊吧”。&lt;/p&gt;
&lt;p&gt;“嗯，我是做java开发的，这3年用到的技术有这些，前端用到jquery，easy ui, bootstrap这些都用到过，像node.js这些自己也自学过，后台主要是java为主，都是java那一套东西，我们做项目用的最多的是springmvc,mybatis这些，分布式缓存redis, rabbitmq用过，也有项目用过springcloud，数据库方面主要还是mysql为主，oracle也有项目用到过“，我巴拉巴拉一堆连我自己都明显感觉到没有组织力的语言段落，反正想到什么就说什么。&lt;/p&gt;
&lt;p&gt;“你工作3年了，如果你自己独立开发一个项目，你自己能去服务器部署吗？”，&lt;/p&gt;
&lt;p&gt;“可以的，我自己之前在公司自己搭建平台，自己发包到linux服务器，自己去维护“，&lt;/p&gt;
&lt;p&gt;“嗯，那你们之前的服务器做集群是怎么做的？“，&lt;/p&gt;
&lt;p&gt;“我们一般用的是nginx反向代理+多台tomcat,nginx做了高可用的“，我回答道。&lt;/p&gt;
&lt;p&gt;“嗯，我看你的简历你自己给项目做个性能优化，我想了解下你是怎么做的？”&lt;/p&gt;
&lt;p&gt;“性能优化这块分3块，前端优化，主要做页面性能优化延迟加载，资源合并压缩，后端优化主要做服务组装，业务缓存，数据库主要是分库分表，慢SQL优化，大概这些”。说实话，这些我差不多快忘记了，希望他不要问的太细，要不然就呜呜了。&lt;/p&gt;
&lt;p&gt;“你之前写过需求文档吗？“，他问道。&lt;/p&gt;
&lt;p&gt;“写过一点，有些项目是我一个人去跟的，所以有些需求需要从我这边出去“。&lt;/p&gt;
&lt;p&gt;“嗯，那你觉得需求文档有什么作用呢？“&lt;/p&gt;
&lt;p&gt;“我觉得需求文档是一个沟通传递作用，大家都按照文档去做事，同时，需求文档也是一个合同，按照合同办事，不可抵赖，同时也可以存档，让后面的人知道这个项目的大概从头到尾的情况”。&lt;/p&gt;
&lt;p&gt;“嗯，挺好，你们之前项目加班多吗”，&lt;/p&gt;
&lt;p&gt;我知道，他问这个问题其实就是想问，你讨厌加班吗？你对加班有抵触吗？&lt;/p&gt;
&lt;p&gt;我微微一笑。&lt;/p&gt;
&lt;p&gt;“加班是做软件这个行不可避免的，一般赶进度合理情况下都是正常的，我们做技术的，有时候在想着一个事情，不希望有断层，就算自己在家也要把它弄出去心里才舒服”。&lt;/p&gt;
&lt;p&gt;“嗯，嗯，是的，是这样的，不过我们公司基本不要求加班，因为加班要申请，加班会有加班费”，他很满足的说道。&lt;/p&gt;
&lt;p&gt;然后就是一些技术细节的相关问题，大概问了2，3个，其中有个多线程方面的知识点，我回答的不太够好，说实话，这些平时项目用到的地方真不多，所以对这方面的知识点不是感触很深。&lt;/p&gt;
&lt;p&gt;和项目经理聊的时间不多，也就10分钟左右吧，我看到出他应该很忙，因为在聊的过程中，我明锐的眼睛看到他一起看过2次手表，估计他还有事情在等着他吧。&lt;/p&gt;
&lt;p&gt;最后，他站起来说，我们这边先到这里，我还有事情要去处理，非常感谢你过来，然后双方握手，他走出去后，人事贾珍珍进来，还是那个微笑的表情，说道，&lt;/p&gt;
&lt;p&gt;“雷先生，辛苦了，今天你先回去吧，我们这边这两天会有消息通知你，谢谢你过来”，&lt;/p&gt;
&lt;p&gt;最后还问了句，“离这里远不远”，&lt;/p&gt;
&lt;p&gt;“不远，坐公交半个小时左右”，我站起来她带我走出走廊，最后在下楼地方，我们说了声再见，她往回走了，看着她走远的背影，我心里不知道怎么回事，突然有种失落的感觉。&lt;/p&gt;
</description>
<pubDate>Wed, 05 Sep 2018 03:41:00 +0000</pubDate>
<dc:creator>心灵之火</dc:creator>
<og:description>我叫雷刚，别看我的名字很刚，其实我只是一个程序员，我的性格稍偏内向，但是我的一颗澎湃的青春荷尔蒙的心经常在提醒我，我今年27岁了，我知道我该需要什么了，每当夜深人静的时候，我时常在思考，我为什么而活，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgcjiayou/p/9591231.html</dc:identifier>
</item>
</channel>
</rss>