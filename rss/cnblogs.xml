<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Javascript高级编程学习笔记（三）—— JS中的数据类型（1） - 巽秋</title>
<link>http://www.cnblogs.com/lhyxq/p/10058785.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lhyxq/p/10058785.html</guid>
<description>&lt;p&gt; 前一段时间由于事情比较多，所以笔记耽搁了一段时间，从这一篇开始我会尽快写完这个系列。&lt;/p&gt;
&lt;p&gt;文章中有什么不足之处，还望各位大佬指出。&lt;/p&gt;

&lt;p&gt;上一篇中我写了有关JS引入的Script标签相关的东西。&lt;/p&gt;
&lt;p&gt;那么这一篇，我们可以正式进入JS的世界了，emmm&lt;/p&gt;
&lt;p&gt;前面的东西应该比较基础，大佬们不喜勿喷。&lt;/p&gt;

&lt;p&gt;首先学习一门语言，最开始不出意外的话应该是先了解这门语言由什么类型的数据组成，毕竟语言都是建立在这些数据类型的基础之上的。&lt;/p&gt;
&lt;p&gt;在介绍数据类型之前，我先大概说一下 typeof 操作符，这是JS中判断一个变量的数据类型的操作符，它的返回值是一个数据类型的字符串。&lt;/p&gt;

&lt;p&gt;下面我将先例举一下，typeof 的一些值的说明，以免大家对后面的内容产生疑问。&lt;/p&gt;
&lt;p&gt;1. typeof null === “object” 在JS中NULL被认为是空对象的引用，所以 typeof null 的值为“object”&lt;/p&gt;
&lt;p&gt;2. 在一些低版本浏览器中，typeof 对正则表达式的结果为“function” ，其它情况下对正则表达式使用 typeof 的返回值为“object”&lt;/p&gt;
&lt;p&gt;3.对未声明的变量使用 typeof 的返回值为 “undefined”&lt;/p&gt;
&lt;p&gt;4.对未初始化的变量使用 typeof 的返回值为 “undefined”&lt;/p&gt;
&lt;p&gt;PS. 若使用未声明的变量浏览器会报错，但是如果对未声明的变量使用 typeof 浏览器不会报错，并且会返回“undefined”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于第三点和第四点，为了将未声明，和未初始化加以区别，所以我们最好在声明变量时显示地初始化变量，这样就能通过 typeof 来判断一个变量到底是未声明，还是未初始化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面正式开始介绍。。。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;Undefined类型&lt;/h2&gt;
&lt;p&gt;该类型只有一个值 那就是 undefined&lt;/p&gt;
&lt;p&gt;未经初始化的变量会默认取得该值&lt;/p&gt;
&lt;p&gt;对于undefined类型，需要注意的就是，不要显式地将变量初始化为undefined，这样你就不能判断这个变量是否已经声明。&lt;/p&gt;
&lt;p&gt;原因在上方，已做出说明&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = undefiend;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即对于undefined不推荐上方的这种使用方式。&lt;/p&gt;
&lt;p&gt;这一类型的主要作用是用于比较，即判断数据的合法性，是这一类型最常见的作用&lt;/p&gt;

&lt;h2&gt;Null类型&lt;/h2&gt;
&lt;p&gt;这一类型与Undefined类型一样，都只有一个值，那就是null&lt;/p&gt;
&lt;p&gt;与undefined的区别在于，typeof 对于null 的返回值并不是 “null” 而是 “object”，因为null 在JS的逻辑中，通常代表一个空对象。&lt;/p&gt;
&lt;p&gt;而null本身代表的也是一个指向空对象的指针，所以typeof的返回值为“object”&lt;/p&gt;
&lt;p&gt;除此而外，有一个需要注意的地方就是，undefined派生自null，所以在ECMA-262的标准中，规定对于两者的相等性测试应该返回 true&lt;/p&gt;
&lt;p&gt;即,如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201812/1467672-20181203101714039-1967483022.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的相等，是指 == （相等操作符）因为相等操作符要遵守的规则中，做出规定 undefined等于null（其余规则将在后面的文章中提到）&lt;/p&gt;
&lt;p&gt;而对于全等操作符 === 虽然 undefined和null被规定为值相等，但是两者的类型不同，一个是Undefined类型，另一个是Null类型，所以全等操作符的返回值为false&lt;/p&gt;
&lt;p&gt;并且与Undefined不同的是，JS中推荐将一切用于报存对象的变量初始化为null，因为这样做不仅能体现null是一个指向空对象的指针，还能对undefined加以区分&lt;/p&gt;

&lt;h2&gt;Boolean类型&lt;/h2&gt;
&lt;p&gt;该类型只有两个值，ture、false。&lt;/p&gt;
&lt;p&gt;要注意的是Boolean的true和false与数字的0和1没有必然联系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201812/1467672-20181203103554495-1310345863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果说二者有什么联系的话，那么只能是两者经过类型转换后的值相等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201812/1467672-20181203103724056-2111077620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里全等和相等的具体区别在后面的文章中会有所介绍&lt;/p&gt;
&lt;p&gt;需要注意的是true和false是区分大小写的，比如True代表的就是一个普通的变量，而true代表的就是boolean中的一个值&lt;/p&gt;
&lt;p&gt;虽然boolean类型只有两个值，但是其它所有的类型都有与Boolean值等价的值&lt;/p&gt;
&lt;p&gt;可以通过Boolean（）转型函数将其它类型的值转换为boolean&lt;/p&gt;
&lt;p&gt;转换规则如下：&lt;/p&gt;
&lt;p&gt;数据类型            转换为true的值           转换为false的值&lt;/p&gt;
&lt;p&gt;Boolean                      true                          false&lt;/p&gt;
&lt;p&gt;String                  任意非空字符串           “”（空字符串）&lt;/p&gt;
&lt;p&gt;Number           任何非零值包括无穷         0和NaN&lt;/p&gt;
&lt;p&gt;Object                       任何对象                       无&lt;/p&gt;
&lt;p&gt;Undefined                    无                         undefined&lt;/p&gt;
&lt;p&gt;Null                              无                                null&lt;/p&gt;

&lt;p&gt;以上规则对于流控制语句同样适用&lt;/p&gt;
&lt;p&gt;因为 if 等流控制语句会自动执行Boolean类型转换&lt;/p&gt;

&lt;h2&gt;Number类型&lt;/h2&gt;
&lt;p&gt;该类型使用IEEE754格式（二进制浮点数运算标准）来表示整数和浮点数值。&lt;/p&gt;
&lt;p&gt;在此基础上JS定义了不同数值字面量的格式&lt;/p&gt;
&lt;h3&gt;整数值&lt;/h3&gt;
&lt;p&gt;十进制：&lt;/p&gt;
&lt;p&gt;默认的数值类型&lt;/p&gt;
&lt;p&gt;var a = 55;&lt;/p&gt;
&lt;p&gt;八进制：&lt;/p&gt;
&lt;p&gt;第一位必须为0，后面为八进制数据序列（0~7）&lt;/p&gt;
&lt;p&gt;若超出范围JS将忽略前导零，将后面的数字当作十进制解析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201812/1467672-20181203110439844-1369532608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是八进制在严格模式下是无效的，支持的JS引擎会抛出错误&lt;/p&gt;
&lt;p&gt;十六进制：&lt;/p&gt;
&lt;p&gt;以0x开头（a~f 可大写可小写），对于超出范围的值js会抛出错误&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201812/1467672-20181203110746540-715748108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在进行运算时，八进制和十六进制最终都将被转为十进制，就如上面两张图所示&lt;/p&gt;
&lt;p&gt; PS 鉴于JS中数值保存的方式可以保存 +0 -0 两者被认为相等&lt;/p&gt;

&lt;h3&gt; 浮点数值&lt;/h3&gt;
&lt;p&gt;对于浮点数值，即该数值中包含一个小数点，并且小数点后至少有一位数字。&lt;/p&gt;
&lt;p&gt;虽然小数点前面可以没有整数，但不推荐这种写法 如：.4&lt;/p&gt;
&lt;p&gt;在此基础上由于保存小数所需要的空间是保存整数值的两倍，因此如果小数点后没有数字，或者该小数表示的就是一个整数（1.000）JS会将该值转为整数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201812/1467672-20181203111851733-1956176265.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于极大或极小的数可以使用科学技术法来表示，即&lt;/p&gt;
&lt;p&gt;3.15e7&lt;/p&gt;
&lt;p&gt;所表示的值为3.15*10^7&lt;/p&gt;
&lt;p&gt;在默认情况下，JS会将小数点后带有6个0以上的浮点数值转为科学记数法表示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201812/1467672-20181203112308486-1324436401.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除此而外，浮点数的精度为17位小数，但是计算时的准确度远不如整数&lt;/p&gt;
&lt;p&gt;比如大名鼎鼎的0.1加0.2的问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201812/1467672-20181203112535211-1008960461.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是IEEE754的通病，并非JS特有，只要使用该标准的语言都会有这样的舍入误差&lt;/p&gt;
&lt;p&gt;所以我们不能测试特定的浮点数数值，不然很可能会出现问题&lt;/p&gt;
&lt;p&gt;如 if（a+b===0.3）&lt;/p&gt;
&lt;h3&gt;数值范围&lt;/h3&gt;
&lt;p&gt;JS所能保存的最小数值保存在Number.MIN_VALUE 中大多数浏览器中，该值为5e-324&lt;/p&gt;
&lt;p&gt;最大值保存在Number.MIN_VALUE中 大多数浏览器中该值为 1.7976931348623157e+308&lt;/p&gt;
&lt;p&gt;超出这个范围就会转为Infinity，该值无法用于计算，如果计算的值返回了Infinity那么将不能参与下一次的运算&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201812/1467672-20181203113507891-630778294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果Infinity参与了运算，具体情况视操作符而定，后面的文章会讲到&lt;/p&gt;
&lt;p&gt;判断一个值是否为Infinity，可以使用isFinite（）函数进行判断&lt;/p&gt;

&lt;h3&gt;NaN&lt;/h3&gt;
&lt;p&gt; 这中类型是一个特殊的值，（Not a Number）即’不是一个数字‘&lt;/p&gt;
&lt;p&gt;用于表示，本来要返回一个数值，但返回的不是一个数值的情况，这样就可以避免抛出错误了，从而避免影响代码的运行。&lt;/p&gt;
&lt;p&gt;NaN有两个特点，首先任何涉及NaN的操作都会返回NaN&lt;/p&gt;
&lt;p&gt;其次，NaN与任何值都不相等，包括NaN本身&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201812/1467672-20181203140036371-2044544255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了判断NaN这一值，JS提供了isNaN（）函数，&lt;/p&gt;
&lt;p&gt;该函数接收任何值，函数会尝试将该值转为数值，任何不能转为数值的值都会返回true&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201812/1467672-20181203140431940-1005073619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于对对象的转换，跟Number()方法的规则一致&lt;/p&gt;
&lt;p&gt;下方将会介绍&lt;/p&gt;

&lt;h3&gt;数值转换&lt;/h3&gt;
&lt;p&gt;有三个方法可以将非数值转换为数值&lt;/p&gt;
&lt;p&gt;Number（）可用于任意数据类型&lt;/p&gt;
&lt;p&gt;parseInt（）专用于字符串转数值&lt;/p&gt;
&lt;p&gt;parseFloat（）专用于字符串转数值&lt;/p&gt;

&lt;p&gt;Number（）：&lt;/p&gt;
&lt;p&gt;对于Boolean类型 true 转为 1 ，false 转为 0&lt;/p&gt;
&lt;p&gt;对于Number类型 仅仅是值的传入和传出，不做处理&lt;/p&gt;
&lt;p&gt;对于Null类型 返回0&lt;/p&gt;
&lt;p&gt;对于Undefined类型 返回NaN&lt;/p&gt;
&lt;p&gt;对于String类型 ：&lt;/p&gt;
&lt;p&gt;1.只包含数字，将其转为十进制数值，忽略前导零&lt;/p&gt;
&lt;p&gt;2.包含有效的浮点数格式，将其转为浮点数，同样会忽略前导零&lt;/p&gt;
&lt;p&gt;3.包含有效的十六进制的格式，转为十进制数字&lt;/p&gt;
&lt;p&gt;4.空字符串转为 0&lt;/p&gt;
&lt;p&gt;5.不是上述中的任意一种转为NaN&lt;/p&gt;
&lt;p&gt;对于Object类型：&lt;/p&gt;
&lt;p&gt;首先调用对象的Valueof（）方法，若其返回值按照上方的规则可以转为数字，那么返回转换后的数字（包括NaN），如不能返回数字则调用&lt;strong&gt;&lt;em&gt;值&lt;/em&gt;&lt;/strong&gt;的toString（）进行转换，规则同上，若仍不能转为数字则报错，能转换则返回转换后的数字（包括NaN）&lt;/p&gt;
&lt;p&gt;例子如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201812/1467672-20181203150846512-1129270195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在看一下如果将toString’改为返回一个对象看看是否会报错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201812/1467672-20181203151030750-122101057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该报错的大概意思为，不能将该对象转换为原始数据类型&lt;/p&gt;

&lt;p&gt;parseInt（）&lt;/p&gt;
&lt;p&gt;由于Number（）的处理较为复杂且有些不合理，所以将字符串转为整数时最好使用parseInt（）&lt;/p&gt;
&lt;p&gt;转换规则如下：&lt;/p&gt;
&lt;p&gt;1.若第一个字符不是数字或者正负号则返回NaN&lt;/p&gt;
&lt;p&gt;2.若满足1则继续解析下一个字符，直到不为数字为止，然后以这一部分数字作为十进制的值返回&lt;/p&gt;
&lt;p&gt;如 “123lhy” 则返回123&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1467672/201812/1467672-20181203151932243-1481364744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除此而外，该函数还能够解析八进制和16进制，对于八进制由于会产生歧义，所以最好使用第二个参数，来设置转换使用的基数，即使用多少进制&lt;/p&gt;
&lt;p&gt;Number.parseInt('123',16);&lt;/p&gt;

&lt;p&gt;parseFloat() &lt;/p&gt;
&lt;p&gt;解析规则与parseInt（）类似&lt;/p&gt;
&lt;p&gt;遇到第一个无效的浮点数位停止&lt;/p&gt;
&lt;p&gt;需要注意的地方在于该方法只解析十进制数，也不提供第二个参数设置基数&lt;/p&gt;
&lt;p&gt;除此而外如果数值可以解析为整数，那么会返回一个整数&lt;/p&gt;


&lt;h6&gt; &lt;/h6&gt;
&lt;h6&gt;由于时间的限制，今天先介绍这四种类型，明天介绍剩下的String类型以及Object类型&lt;/h6&gt;
</description>
<pubDate>Mon, 03 Dec 2018 07:32:00 +0000</pubDate>
<dc:creator>巽秋</dc:creator>
<og:description>JS数据类型</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lhyxq/p/10058785.html</dc:identifier>
</item>
<item>
<title>Angular 个人深究（五）【外部包引用 Leaflet 简单实用】 - WangKane</title>
<link>http://www.cnblogs.com/primadonna/p/10058627.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/primadonna/p/10058627.html</guid>
<description>&lt;p&gt;最近在Angular项目中，用到了地图，由于种种原因放弃了百度地图api使用，最后选择了leaflet，简单介绍一下。&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍：&lt;/h2&gt;
&lt;p&gt;Leaflet 是一个为移动设备设计的交互式地图的开源的 javascript库， 并只有38k，包含了大多数开发者需要的地图特点。&lt;/p&gt;
&lt;h2 id=&quot;准备下载-leaflet-文件&quot;&gt;准备：下载 leaflet 文件&lt;/h2&gt;
&lt;p&gt;访问： &lt;a href=&quot;https://leafletjs.com/download.html&quot;&gt;Leaflet下载官网&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;在单一的html页面中使用leaflet&quot;&gt;在单一的HTML页面中使用Leaflet&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;创建一个文件夹 leaflet_test&lt;/li&gt;
&lt;li&gt;文件夹下创建一个index.html&lt;/li&gt;
&lt;li&gt;将上述下载的leaflet文件放到leaflet_test文件夹下&lt;/li&gt;
&lt;li&gt;在index.html插入如下代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hmtl&quot;&gt;
&lt;code&gt;&amp;lt;!-- 引入 文件 --&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./leaflet.css&quot; /&amp;gt;
&amp;lt;script src=&quot;./leaflet.js&quot;&amp;gt; &amp;lt;/script&amp;gt;
&amp;lt;!-- 增加地图高度 --&amp;gt;
&amp;lt;style&amp;gt;
#mapDiv { height: 300px; }
&amp;lt;/style&amp;gt;
&amp;lt;!-- 创建一个 地图的div id 必须有 但是自定义 --&amp;gt;
&amp;lt;div id=&quot;mapDiv&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
        //到 mapbox 官网注册并创建下面的access token都是免费的，不过有5w次的浏览限制
        var url = 'https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1Ijoia2FuZXdhbmciLCJhIjoiY2pwM2UxNHNkMGF1MzNwc2FtMnNhdXJsMCJ9.KZpCBtizDeltZO6JhGc6_w';
        //初始化 地图
        var leafletMap = L.map('mapDiv').setView([41, 123], 5);
        //将图层加载到地图上，并设置最大的聚焦还有map样式
        L.tileLayer(url, {
                maxZoom: 18,
                id: 'mapbox.streets'
        }).addTo(leafletMap);
        //增加一个marker ，地图上的标记，并绑定了一个popup，默认打开
        L.marker([41, 123]).addTo(leafletMap)
                .bindPopup(&quot;&amp;lt;b&amp;gt;Hello world!&amp;lt;/b&amp;gt;&amp;lt;br /&amp;gt;I am a popup.&quot;).openPopup();
        //增加一个圈，设置圆心、半径、样式
        L.circle([41, 123], 500, {
                color: 'red',
                fillColor: '#f03',
                fillOpacity: 0.5
        }).addTo(leafletMap).bindPopup(&quot;I am a circle.&quot;);
        //增加多边形
        L.polygon([
                [41, 123],
                [39, 121],
                [41, 126]
        ]).addTo(leafletMap).bindPopup(&quot;I am a polygon.&quot;);
        //为点击地图的事件 增加popup
        var popup = L.popup();
        function onMapClick(e) {
                popup
                        .setLatLng(e.latlng)
                        .setContent(&quot;You clicked the map at &quot; + e.latlng.toString())
                        .openOn(leafletMap);
        }
        leafletMap.on('click', onMapClick);
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;上述代码可直接使用，下面先上效果图，再解释代码的含义&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1272875/201812/1272875-20181203152725644-1139823415.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码解释：
&lt;ul&gt;&lt;li&gt;1.引入Leaflet css 与js 文件，官网要求，css在前 js在后。不过我简单试过没啥变化。&lt;/li&gt;
&lt;li&gt;2.增加 地图css样式，设置高度，这个官网要求必须的。&lt;strong&gt;&lt;em&gt;不设置会不显示地图&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;创建装地图的div 记住这个div的 id&lt;/li&gt;
&lt;li&gt;开始创建地图，我们先去准备一个 &lt;a href=&quot;https://baike.baidu.com/item/%E7%93%A6%E7%89%87%E5%9C%B0%E5%9B%BE/8006049?fr=aladdin&quot;&gt;瓦片图层&lt;/a&gt; 本文使用的是 &lt;a href=&quot;https://www.mapbox.com/&quot;&gt;mapbox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;到 map box上注册账号，登录后 创建一个access token，copy到代码url accesstoken后面，使用我的也好使&lt;/li&gt;
&lt;li&gt;初始化map 使用 L.map('mapDiv').setView([51.505, -0.09], 13),其中[51.505, -0.09]地理位置，13是变焦的大小&lt;/li&gt;
&lt;li&gt;将图层加到map上。其中url是图层的资源的url，maxZoom 是最大的聚焦【mapbox官网最大的也是18了】，id 是 地图的样式并不是我们平常认识的id，本文选择了 street 的map&lt;/li&gt;
&lt;li&gt;mapbox 支持的地图样式,共6个默认的（默认提供的，可以自己创建上传）
&lt;ul&gt;&lt;li&gt;Mapbox Incidents V1 [id=mapbox.mapbox-incidents-v1]&lt;/li&gt;
&lt;li&gt;Mapbox Statellite[mapbox.satellite]&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;加标记、加圆圈、加多边形，再为地图每个位置点击增加事件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;至此，简单的应用就完成了。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;在单一页面中使用中国各种地图&quot;&gt;在单一页面中使用中国各种地图&lt;/h2&gt;
&lt;p&gt;为什么单独说，因为leaflet提供了一个插件 &lt;a href=&quot;https://github.com/htoooth/Leaflet.ChineseTmsProviders&quot;&gt;Leaflet.ChineseTmsProviders&lt;/a&gt;可以访问 &lt;a href=&quot;https://github.com/htoooth/Leaflet.ChineseTmsProviders/tree/master/src&quot;&gt;github&lt;/a&gt;主页查看。下面我们看看如何使用它。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;准备去github上下载插件的js文件 &lt;a href=&quot;https://github.com/htoooth/Leaflet.ChineseTmsProviders/tree/master/src&quot;&gt;github下载&lt;/a&gt;，下载后同样放到与leaflet包同一路径下&lt;/li&gt;
&lt;li&gt;上一下插件代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;L.TileLayer.ChinaProvider = L.TileLayer.extend({

    initialize: function(type, options) { // (type, Object)
        var providers = L.TileLayer.ChinaProvider.providers;

        var parts = type.split('.');

        var providerName = parts[0];
        var mapName = parts[1];
        var mapType = parts[2];

        var url = providers[providerName][mapName][mapType];
        options.subdomains = providers[providerName].Subdomains;

        L.TileLayer.prototype.initialize.call(this, url, options);
    }
});

L.TileLayer.ChinaProvider.providers = {
    TianDiTu: {
        Normal: {
            Map: &quot;http://t{s}.tianditu.cn/DataServer?T=vec_w&amp;amp;X={x}&amp;amp;Y={y}&amp;amp;L={z}&quot;,
            Annotion: &quot;http://t{s}.tianditu.cn/DataServer?T=cva_w&amp;amp;X={x}&amp;amp;Y={y}&amp;amp;L={z}&quot;
        },
        Satellite: {
            Map: &quot;http://t{s}.tianditu.cn/DataServer?T=img_w&amp;amp;X={x}&amp;amp;Y={y}&amp;amp;L={z}&quot;,
            Annotion: &quot;http://t{s}.tianditu.cn/DataServer?T=cia_w&amp;amp;X={x}&amp;amp;Y={y}&amp;amp;L={z}&quot;
        },
        Terrain: {
            Map: &quot;http://t{s}.tianditu.cn/DataServer?T=ter_w&amp;amp;X={x}&amp;amp;Y={y}&amp;amp;L={z}&quot;,
            Annotion: &quot;http://t{s}.tianditu.cn/DataServer?T=cta_w&amp;amp;X={x}&amp;amp;Y={y}&amp;amp;L={z}&quot;
        },
        Subdomains: ['0', '1', '2', '3', '4', '5', '6', '7']
    },

    GaoDe: {
        Normal: {
            Map: 'http://webrd0{s}.is.autonavi.com/appmaptile?lang=zh_cn&amp;amp;size=1&amp;amp;scale=1&amp;amp;style=8&amp;amp;x={x}&amp;amp;y={y}&amp;amp;z={z}'
        },
        Satellite: {
            Map: 'http://webst0{s}.is.autonavi.com/appmaptile?style=6&amp;amp;x={x}&amp;amp;y={y}&amp;amp;z={z}',
            Annotion: 'http://webst0{s}.is.autonavi.com/appmaptile?style=8&amp;amp;x={x}&amp;amp;y={y}&amp;amp;z={z}'
        },
        Subdomains: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;]
    },

    Google: {
        Normal: {
            Map: &quot;http://www.google.cn/maps/vt?lyrs=m@189&amp;amp;gl=cn&amp;amp;x={x}&amp;amp;y={y}&amp;amp;z={z}&quot;
        },
        Satellite: {
            Map: &quot;http://www.google.cn/maps/vt?lyrs=s@189&amp;amp;gl=cn&amp;amp;x={x}&amp;amp;y={y}&amp;amp;z={z}&quot;
        },
        Subdomains: []
    },

    Geoq: {
        Normal: {
            Map: &quot;http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineCommunity/MapServer/tile/{z}/{y}/{x}&quot;,
            Color: &quot;http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetColor/MapServer/tile/{z}/{y}/{x}&quot;,
            PurplishBlue: &quot;http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetPurplishBlue/MapServer/tile/{z}/{y}/{x}&quot;,
            Gray: &quot;http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetGray/MapServer/tile/{z}/{y}/{x}&quot;,
            Warm: &quot;http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetWarm/MapServer/tile/{z}/{y}/{x}&quot;,
            Cold: &quot;http://map.geoq.cn/ArcGIS/rest/services/ChinaOnlineStreetCold/MapServer/tile/{z}/{y}/{x}&quot;
        },
        Subdomains: []

    }
};

L.tileLayer.chinaProvider = function(type, options) {
    return new L.TileLayer.ChinaProvider(type, options);
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;更改index.html文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;script src=&quot;./leaflet.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;./leaflet.css&quot; /&amp;gt;
&amp;lt;script src=&quot;leaflet.ChineseTmsProviders.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;style&amp;gt;
//#mapDiv { height: 300px; }
.test { height: 300px; }
&amp;lt;/style&amp;gt;
&amp;lt;div id=&quot;mapDiv&quot; class='test'&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    //插件把 定义了多个国内的瓦片图层，我们只需要通过提供的方法访问到相应的图层即可
    //从插件代码可以看出 需要传入 providerName.mapName.mapType 从插件代码中查找所需要的值
    var test = L.tileLayer.chinaProvider('Geoq.Normal.Map', {
        maxZoom: 18,
        minZoom: 5
    });
    //此处可以定义多个图层，并可以再页面中进行选择
    var baseLayers = {&quot;测试地图&quot;:test}
    
    var map = L.map(&quot;mapDiv&quot;, {
        center: [41.80, 123.43],
        zoom: 7,
        layers: [test],
        zoomControl: false
    });
    L.control.layers(baseLayers, null).addTo(map);
    L.control.zoom({
        zoomInTitle: '放大',
        zoomOutTitle: '缩小'
    }).addTo(map);
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;上结果图，这次只是使用插件没有其他功能。中心点是沈阳市。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1272875/201812/1272875-20181203152909097-369397521.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;leaflet-画线装饰插件&quot;&gt;Leaflet 画线装饰插件&lt;/h2&gt;
&lt;p&gt;本次开发使用了另一个插件&lt;a href=&quot;https://github.com/bbecquet/Leaflet.PolylineDecorator&quot;&gt;polylineDecorator.js&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;index.html&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//如下代码需要上一节的代码
    var arrow = L.polyline([[41.80, 123.43], [41.07, 123.00]], {opacity: 1,color: 'firebrick'}).bindPopup('I am red:').addTo(map);//
    var arrow2 = L.polyline([[41.80, 123.43], [40.13, 124.37]], {opacity: 1,color: 'lightgreen'}).bindPopup('I am green:').addTo(map);
    var arrow3 = L.polyline([[41.07, 123.00], [40.13, 124.37]], {opacity: 1,color: 'lightgreen'}).bindPopup('I am green:').addTo(map);
    
    var arrowHead = L.polylineDecorator(arrow, {
        patterns: [
            {offset: '30%' ,endOffset:'90%',repeat: 1000, symbol: L.Symbol.arrowHead({pixelSize: 10, polygon: false,pathOptions: {stroke: true,weight:2,color: 'firebrick'}})}
        ]
    }).addTo(map);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;上图：在一条线上增加了一个箭头，还有很多的装饰，可访问github主页查看example 的代码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1272875/201812/1272875-20181203152940895-1583964180.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;在-angular中使用-leaflet.js&quot;&gt;在 angular中使用 leaflet.js&lt;/h2&gt;
&lt;p&gt;由于leaflet是 javascript库，而angular 使用的typescript 语言，这就存在一个问题。经过查询，发现了ts的一个功能。.d.ts文件的使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：如下内容，仅做介绍了，在我们的项目中是成功的引入了leaflet了，如果不好使，请大家自行查询一下吧。推荐一个介绍文章&lt;/strong&gt; &lt;a href=&quot;https://www.cnblogs.com/silin6/p/7793753.html&quot;&gt;JavaScript 和 TypeScript 交叉口&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在项目的根目录下创建文件【angular框架中是 src下】 index.d.ts&lt;/p&gt;
&lt;p&gt;文件内容：&lt;/p&gt;
&lt;pre class=&quot;typescript&quot;&gt;
&lt;code&gt;declare var L:any; //leaflet&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然在angular.json需要引入相关的 leaflet的js文件&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;在projects-&amp;gt;architect-&amp;gt;build-&amp;gt;options-&amp;gt;scripts中加入leaflet.js的路径&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关的内容请查阅angular相关的介绍 &lt;a href=&quot;https://github.com/angular/angular-cli/wiki/stories&quot;&gt;Angular Cli Stories&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 07:30:00 +0000</pubDate>
<dc:creator>WangKane</dc:creator>
<og:description>Leaflet 使用 最近在Angular项目中，用到了地图，由于种种原因放弃了百度地图api使用，最后选择了leaflet，简单介绍一下。 介绍： Leaflet 是一个为移动设备设计的交互式地图的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/primadonna/p/10058627.html</dc:identifier>
</item>
<item>
<title>零基础学习 Python 之字符串 - Rocky0429</title>
<link>http://www.cnblogs.com/Rocky0429/p/10058700.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rocky0429/p/10058700.html</guid>
<description>&lt;h3 id=&quot;初识字符串&quot;&gt;初识字符串&lt;/h3&gt;
&lt;p&gt;维基百科对于字符串的定义式：字符串是由零个或者多个字符组成的有限串行。你之前学会敲的第一行 print 代码里的 “Hello World”，就是一个字符串。字符串的本质就是一串字符，不管是中文还是英文抑或是空格等特殊字符都可以作为字符串来看待。&lt;/p&gt;
&lt;p&gt;在 Python 里，字符串和上一篇文章( 零基础学习 Python 之数字与运算 )里讲到的数字一样，都是一种对象类型，字符串类型用 str 表示，用英文的单引号或双引号括起来。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 'good good study'
'good good study'
&amp;gt;&amp;gt;&amp;gt; &quot;day day up&quot;
'day day up'&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字符串与变量&quot;&gt;字符串与变量&lt;/h3&gt;
&lt;p&gt;上面我说到字符串和数字都是一种对象类型，那么在上篇文章中我们说数字可以有变量指向它，那么字符串当然也可以。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; string = 'Hello World'
&amp;gt;&amp;gt;&amp;gt; string
'Hello World'
&amp;gt;&amp;gt;&amp;gt; print(string)
Hello World&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字符串连接&quot;&gt;字符串连接&lt;/h3&gt;
&lt;p&gt;如果我有两个字符串，分别是 'Hello' 和 'World'，那么我想得到 'Hello World' 那可咋整？别怕，Python 里提供了特别简单的办法，那就是相加，就是你们知道的那个加减乘除的那个加。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a = 'Hello'
&amp;gt;&amp;gt;&amp;gt; b = 'World'
&amp;gt;&amp;gt;&amp;gt; a + b
'HelloWorld'
&amp;gt;&amp;gt;&amp;gt; a + ' ' + b
'Hello World'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是相加只是限同种类型的，比如字符串和字符串相加，数字和数字相加，字符串和数字不可以，会报错。&lt;/p&gt;
&lt;p&gt;这里再多说一点，字符串其实还可以乘，看下面的例子就知道怎么用了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; string = 'Python'
&amp;gt;&amp;gt;&amp;gt; string * 3
'PythonPythonPython'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就至此为止了，减和除你们就不用想了。&lt;/p&gt;
&lt;h3 id=&quot;python-转义字符&quot;&gt;Python 转义字符&lt;/h3&gt;
&lt;p&gt;什么时候能用到转义字符呢？下面我们看一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 'what's your name'
 File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1
   'what's your name'
         ^
SyntaxError: invalid syntax&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么会报错呢？眼尖的朋友们可能已经看出来了，字符串里有三个单引号，这样解释器就尴尬了，不知道单引号包裹的到底是谁，所以只好报错了。那么有什么解决办法呢？一种是用 双引号包裹整个字符串，另一个就是要用到我们接下来要说的转义字符了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; &quot;what's your name&quot;
&quot;what's your name&quot;
&amp;gt;&amp;gt;&amp;gt; 'what\'s your name'
&quot;what's your name&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面给大家放一张常用转义字符的图片，感兴趣的朋友们可以去试试，在交互环境中都是可操作的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181101110010756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM0ODY0MTQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;原始字符串&quot;&gt;原始字符串&lt;/h3&gt;
&lt;p&gt;原始字符串就是字符串里的每个字母都是自己原汁原味的，我们 \n 就是 \n ，不是换行符。一种方法就是用上述的转译字符，此外在这还有一种方法，就是在字符串前面加个 r：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; string = &quot;c:\now&quot;
&amp;gt;&amp;gt;&amp;gt; print(string)
c:
ow
&amp;gt;&amp;gt;&amp;gt; print(r'c:\now')
c:\now&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;索引-切片&quot;&gt;索引 &amp;amp; 切片&lt;/h3&gt;
&lt;p&gt;我们在本篇文章刚开始的时候字符串由多个字符构成，那么在 Python 中如何操作每个字符，这里就用到索引和切片。&lt;/p&gt;
&lt;p&gt;索引的话其实是起的一个比较高端的名字，其实就是编号，就像考完试的名次一样，这个不是 Python 所特有的，其他的编程语言也是这么叫。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; string = 'I love Python'
&amp;gt;&amp;gt;&amp;gt; string[0]
'I'
&amp;gt;&amp;gt;&amp;gt; string[5]
'e'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要想得到第一个字符，就用 string[0]，以后依次类推，它和我们现实中的排名不同的是，它是从 0 开始的，你还记得么？空格等特殊的也是字符，所以它们也是有编号的，这是正向的表示，在 Python 中，字符串的索引还可以倒着表示，从最后一个开始 分别是 -1，-2，-3.....&lt;/p&gt;
&lt;p&gt;然后人总是不满足的，我可以通过索引一个一个的找出字符来，那我想找其中的一个子串怎么办？这时候我们的切片就闪亮登场了。如果我想得到 love 这个子串怎么办？具体的操作请见下面的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; string = 'I love Python'
&amp;gt;&amp;gt;&amp;gt; string[2:6]
'love'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为 l 的索引是 2，e 的索引是5，所以我们可以看出来切片的作用区间是左闭右开的，即[2, 6)。这里还有一点要说的是，字符串的切片对原字符串没有影响，不会改变它。&lt;/p&gt;
&lt;p&gt;切片还有很多有意思的操作，可以切的多姿多彩：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; string = 'I love Python'
&amp;gt;&amp;gt;&amp;gt; a = string[3:]  #得到从3号到最后的字符串
&amp;gt;&amp;gt;&amp;gt; a
'ove Python'
&amp;gt;&amp;gt;&amp;gt; b = string[:8] #得到从第1个字符到第7个字符
&amp;gt;&amp;gt;&amp;gt; b
'I love P'
&amp;gt;&amp;gt;&amp;gt; c = string[:] #得到所有的字符
&amp;gt;&amp;gt;&amp;gt; c
'I love Python'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是觉得很有意思呢？切片的写法还有很多，比如如果是倒序的话我该怎么在切片里表示？有兴趣的可以自己去尝试。&lt;/p&gt;
&lt;h3 id=&quot;字符串格式化输出&quot;&gt;字符串格式化输出&lt;/h3&gt;
&lt;p&gt;Python 中的格式化和我们所熟知的对磁盘中的分区进行初始化是不一样的概念，我们这里说的是对字符串的格式化，所谓字符串的格式化就是我们先定义一个模板，然后在这个模板的一处或者几处地方留出空位来，然后在那些空位上填上符合设定条件的字符串，并显示结果，这些留出来的空位我们称为占位符。下面我用具体的例子来说明。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 'I love %s' #这里的 %s 就是一个占位符
'I love %s'
&amp;gt;&amp;gt;&amp;gt; 'I love %s' %'Python'
'I love Python'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法是原先很常用的一种方法，现在用的更多的是 format() 方法，下面我来展示具体的用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 'I love {0} and {1}'.format('C++','Python')
'I love C++ and Python'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 format 里面 {0}，{1} 就成了占位符，然后不要忘了字符串和 format 中间那个很重要的英文句号。&lt;/p&gt;
&lt;h3 id=&quot;常用的字符串方法&quot;&gt;常用的字符串方法&lt;/h3&gt;
&lt;p&gt;字符串里的方法有很多，可以通过 dir(str）查看，这么多的方法我不会在这一一介绍，如果想使用的话，可以使用 help() 查看，这里仅仅列举几个常用的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;find()：检测字符串是否包含特定字符，如果包含，则返回开始的索引；否则，返回-1。&lt;/li&gt;
&lt;li&gt;index()：检测字符串是否包含指定字符，如果包含，则返回开始的索引值，否则，提示错误.&lt;/li&gt;
&lt;li&gt;count(str1,start,end)：返回str1在string中指定索引范围内[start, end)出现的次数。&lt;/li&gt;
&lt;li&gt;replace(str1,count)：将str1中的str1替换成str2，如果指定count，则不超过count次。&lt;/li&gt;
&lt;li&gt;replace(str1,count)：将str1中的str1替换成str2，如果指定count，则不超过count次。&lt;/li&gt;
&lt;li&gt;split(‘分界符’,maxsplit)：maxSplit默认值为-1，表示根据定界符分割所有能分割的，返回值为列表，如果 maxsplit有指定值，则仅分割 maxsplit 个子字符串。&lt;/li&gt;
&lt;li&gt;strip():去掉字符串左右两边的空白字符。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; string = 'i love python'
&amp;gt;&amp;gt;&amp;gt; string.find('ov') #检查 str 是否在 string 里面
3
&amp;gt;&amp;gt;&amp;gt; string.index('l')
2
&amp;gt;&amp;gt;&amp;gt; string.count('i',0,5)
1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我这里就随便演示了前三个，当然字符串的方法不只这些，这些函数在交互模式里很好实现，如果没事的话可以随时看几个，在交互模式里按照我上面的样子自己动手试试，这样在用到某个方法的时候才能想起来有，否则的话再自己去写很多代码去实现本身就存在的方法，很是浪费时间。&lt;/p&gt;
&lt;h3 id=&quot;写在最后&quot;&gt;写在最后&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;更多内容，欢迎关注公众号「Python空间」，期待和你的交流。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 07:22:00 +0000</pubDate>
<dc:creator>Rocky0429</dc:creator>
<og:description>初识字符串 维基百科对于字符串的定义式：字符串是由零个或者多个字符组成的有限串行。你之前学会敲的第一行 print 代码里的 “Hello World”，就是一个字符串。字符串的本质就是一串字符，不管</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Rocky0429/p/10058700.html</dc:identifier>
</item>
<item>
<title>理解OpenShift（2）：网络之 DNS（域名服务） - SammyLiu</title>
<link>http://www.cnblogs.com/sammyliu/p/10056035.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sammyliu/p/10056035.html</guid>
<description>&lt;p&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/sammyliu/p/10013461.html&quot;&gt;理解OpenShift（1）：网络之 Router 和 Route&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/sammyliu/p/10056035.html%20&quot; target=&quot;_blank&quot;&gt;理解OpenShift（2）：网络之 DNS（域名服务）&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;OpenShift 集群中，至少有三个地方需要用到 DNS：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一是Pod 中的应用通过域名访问外网的时候，需要DNS来解析外网的域名&lt;/li&gt;
&lt;li&gt;二是在集群内部（pod 中或者宿主机上）通过服务的域名来访问集群内服务的时候，这也是通常所说的服务发现功能，需要通过服务域名来先发现（获取其IP地址）再使用该服务&lt;/li&gt;
&lt;li&gt;三是从集群外部通过域名访问部署在OpenShift pod 中的服务的时候，需要DNS来解析服务的外网域名&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文就从这三点出发，解释 OpenShift 是如何实现这三种DNS功能的。&lt;/p&gt;
&lt;h2&gt;1. OpenShift 中的DNS 相关组件及其配置&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201812/697113-20181203144749548-1572501271.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.1 Pod 中的 DNS 配置&lt;/h3&gt;
&lt;p&gt;在Linux 系统上，当一个应用通过域名连接远端主机时，DNS 解析会通过系统调用来进行，比如 &lt;code&gt;getaddrinfo()。&lt;/code&gt;和任何Linux 操作系统一样，Pod 的 DNS 定义在 resolv.conf 文件中，其示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sh&lt;/span&gt;-&lt;span&gt;4.2&lt;/span&gt;$ &lt;span&gt;cat&lt;/span&gt; /etc/&lt;span&gt;resolv.conf 
nameserver &lt;/span&gt;&lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.9&lt;/span&gt;&lt;span&gt;
search dev.svc.cluster.local svc.cluster.local cluster.local exampleos.com
options ndots:&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;nameserver&lt;/strong&gt; 字段是 pod 所在的宿主机的主网卡的IP 地址。也就是说 pod 中发起的所有DNS 查询请求都会被转发到运行在宿主机的 53 端口上的DNS服务器上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;search&lt;/strong&gt; 字段指定当解析一个非FQDN域名时被附加的搜索域（search domain）列表。其解释如下：&lt;/li&gt;
&lt;/ul&gt;&lt;div readability=&quot;11.609942638623&quot;&gt;域名（Domain Name）分为两种，一种是绝对域名（Absolute Domain Name，也称为 Fully-Qualified Domain Name，简称 FQDN），另一种是相对域名（Relative Domain Name，也称为 Partially Qualified Domain Name，简称PQDN）。FQDN 是完整域名，它能够唯一地在DNS名字空间中确定一个记录。比如最高级别的域名A包括子域名B它又包括子域名C，那么FQDN 是 C.B.A.，比如&lt;a href=&quot;http://cs.widgetopia.edu&quot;&gt;cs.widgetopia.edu&lt;/a&gt;.。 有时候我们也会使用PQDN，它是不完全的、模糊的。&lt;/div&gt;
&lt;div readability=&quot;11.20325203252&quot;&gt;FQDN 能被直接到 DNS 名字服务器中查询；而 PQDN 需要先转化为FQDN 再进行查询。其做法是将 PQDN 附加一个搜索域名（search domain）来生成一个 FQDN。在域名系统中，域名结尾是否是『.』被用来区分 FQDN 和 PQDN。比如 &lt;a href=&quot;http://apple.com&quot;&gt;apple.com&lt;/a&gt;. 表示一个Apple公司的 FQDN，而 apple 则表示一个 PQDN，它的FQDN 可能是 &lt;a href=&quot;http://apple.cs.widgetopia.edu&quot;&gt;apple.cs.widgetopia.edu&lt;/a&gt;.；&lt;a href=&quot;http://apple.com&quot;&gt;apple.com&lt;/a&gt; 仍然是一个 PQDN，它的FQDN 可能是 &lt;a href=&quot;http://apple.com.cs.widgetopia.edu&quot;&gt;apple.com.cs.widgetopia.edu&lt;/a&gt;.。&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;options ndots:5&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;默认地，许多DNS 解析器如果发现被解析的域名中有任何的点（.）就把它当做一个 FQDN 来解析；如果域名中没有任何点，就把它当做 PQDN 来处理，并且会加上系统的默认domain name 和最后的点，来组成 FQDN。如果没有指定默认的 domain name （通过 domain 字段）或查询失败，则会将 search 字段的第一个值当做默认domain name，如果解析不成功，则依次往下试，直到有一个成功或者全部失败为止。&lt;/p&gt;
&lt;p&gt;这个行为是通过 options ndots 来指定的，其默认值为1，这意味着只要被解析域名中有任何一个点（.），那么它就会被当做 FQDN，而不会附加任何 search domain，直接用来查询。OpenShift 环境中，这个值被设置为 5。这意味着，只要被解析域名中包含不超过五个点，该域名就会被当做PQDN，然后挨个使用 search domain，来组装成 FQDN 来做DNS查询。如果全部不成功过，则会尝试将它直接作为 FQDN 来解析。&lt;/p&gt;

&lt;p&gt;因此，这某些场景中，pod 中的DNS 查询速度会降低应用的性能。解决方法主要有两种，要么直接使用 FQDN，要么减小 ndots 的值，具体请查看 Kubernetes 和 DNS 的有关文档。&lt;/p&gt;
&lt;h3&gt;1.2 Pod 所在宿主机上的 DNS 配置及服务&lt;/h3&gt;
&lt;h4&gt;1.2.1 resolv.conf 文件&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@node2 cloud-user]# &lt;span&gt;cat&lt;/span&gt; /etc/&lt;span&gt;resolv.conf
# nameserver updated by &lt;/span&gt;/etc/NetworkManager/dispatcher.d/&lt;span&gt;99&lt;/span&gt;-origin-dns.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;
# Generated by NetworkManager
search cluster.local exampleos.com
nameserver &lt;/span&gt;&lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.9&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在部署环境时，会在每个节点上部署 /etc/NetworkManager/dispatcher.d/99-origin-dns.sh 文件。每当节点上的 NetworkManager 服务启动时，该文件会被运行。它的任务包括：&lt;/p&gt;

&lt;ul&gt;&lt;li dir=&quot;ltr&quot;&gt;创建 dnsmasq 配置文件 :
&lt;ul&gt;&lt;li dir=&quot;ltr&quot;&gt;node-dnsmasq.conf （在我的 3.11 版本环境上没有创建该文件，见下文分析）&lt;/li&gt;
&lt;li dir=&quot;ltr&quot;&gt;origin-dns.conf  &lt;/li&gt;
&lt;li dir=&quot;ltr&quot;&gt;origin-upstream-dns.conf&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li dir=&quot;ltr&quot;&gt;当 NetworkManager 服务启动时启动 dnsmasq 服务&lt;/li&gt;
&lt;li dir=&quot;ltr&quot;&gt;设置宿主机的所有默认路由 IP 为 Dnsmasq 的侦听IP&lt;/li&gt;
&lt;li dir=&quot;ltr&quot;&gt;修改 /etc/resolv.conf，设置搜索域，以及将宿主机的默认 IP 作为 nameserver&lt;/li&gt;
&lt;li dir=&quot;ltr&quot;&gt;创建 /etc/origin/node/resolv.conf&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是说，宿主机上的 DNS 请求也会转到本机上的 53 端口。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1.2.2 dnsmasq 及其配置&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;宿主机上的 53 端口上，dnsmasq 服务在route 默认路由的所有IP的53端口上侦听。其中一个负责接受并处理宿主机上所有pod 中以及宿主机上的所有DNS查询服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;p&gt;tcp 0 0 10.128.2.1:53 0.0.0.0:* LISTEN 906/dnsmasq&lt;br/&gt;tcp 0 0 172.17.0.1:53 0.0.0.0:* LISTEN 906/dnsmasq&lt;br/&gt;tcp 0 0 172.22.122.9:53 0.0.0.0:* LISTEN 906/dnsmasq&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这些 IP 地址和默认路由IP 地址是符合的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;10.128&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;      &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;         &lt;span&gt;255.252&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;     U     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;&lt;span&gt; tun0&lt;br/&gt;&lt;/span&gt;&lt;span&gt;172.17&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;      &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;         &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;     U     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;&lt;span&gt; docker0
&lt;/span&gt;&lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.0&lt;/span&gt;    &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;         &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;   U     &lt;span&gt;100&lt;/span&gt;    &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;&lt;span&gt; eth0
&lt;/span&gt;&lt;span&gt;172.30&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;      &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;         &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;     U     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt; tun0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dnsmasq 服务的配置目录为 /etc/dnsmasq.d。其中有两个配置文件（具体含义请查阅有关文档）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@node2 dnsmasq.d]# &lt;span&gt;cat&lt;/span&gt; origin-&lt;span&gt;dns.conf 
no&lt;/span&gt;-&lt;span&gt;resolv
domain&lt;/span&gt;-&lt;span&gt;needed
no&lt;/span&gt;-&lt;span&gt;negcache
max&lt;/span&gt;-cache-ttl=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
enable&lt;/span&gt;-&lt;span&gt;dbus
dns&lt;/span&gt;-forward-max=&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;
cache&lt;/span&gt;-size=&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;
bind&lt;/span&gt;-&lt;span&gt;dynamic
min&lt;/span&gt;-port=&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;
except&lt;/span&gt;-interface=&lt;span&gt;lo
# End of config&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文件 origin-upstream-dns.conf 中定义了上游（upstream） DNS 名字服务器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@node2 dnsmasq.d]# &lt;span&gt;cat&lt;/span&gt; origin-upstream-&lt;span&gt;dns.conf 
server&lt;/span&gt;=&lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.3&lt;/span&gt;&lt;span&gt;
server&lt;/span&gt;=&lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.2&lt;/span&gt;&lt;span&gt;
server&lt;/span&gt;=&lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些上游服务器的地址是从 DHCP 服务器中获取到的（我的OpenShift 环境搭建在OpenStack虚拟机中。前两个地址是OpenStack neutron 网络的 DNSmasq 地址，最后一个是单独搭建的 bind9  DNS 服务器地址）。&lt;/p&gt;
&lt;p&gt;在早期版本中（我的OpenShift版本是 3.11），还有一个配置文件 node-dnsmasq.conf ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
server=/&lt;span&gt;in&lt;/span&gt;-addr.arpa/&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;
server=/cluster.local/&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这意味着所有以 cluster.local 和 in-addr.arpa 结尾的域名，都会被转到 127.0.0.1:53 上被解析。而其它的解析请求，会被转到在 origin-upstream-dns.conf  中定义的上游 DNS 服务器。&lt;/p&gt;
&lt;p&gt;我的3.11版本环境中并没有生成该文件。从代码 &lt;a href=&quot;https://github.com/openshift/origin/blob/master/pkg/dns/dnsmasq.go&quot; target=&quot;_blank&quot;&gt;https://github.com/openshift/origin/blob/master/pkg/dns/dnsmasq.go&lt;/a&gt; 看，OpenShift 中的 dnsmasq 在启动时会自动添加这两条记录：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201812/697113-20181203111323748-75293614.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;而 dnsIP 和 dnsDomain 应该是在 /etc/origin/node/node-config.yaml 中的如下配置：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dnsBindAddress: &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt;&lt;span&gt;
dnsDomain: cluster.local&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从 dnsmasq 日志中也能看到相关记录：&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Dec  &lt;span&gt;3&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;57&lt;/span&gt; dnsmasq[&lt;span&gt;29595&lt;/span&gt;]: using nameserver &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;#&lt;span&gt;53&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; domain &lt;span&gt;in&lt;/span&gt;-&lt;span&gt;addr.arpa
Dec  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;10&lt;/span&gt;:&lt;span&gt;57&lt;/span&gt; dnsmasq[&lt;span&gt;29595&lt;/span&gt;]: using nameserver &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;#&lt;span&gt;53&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; domain cluster.local
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的分析可见，在 node 节点上的 dnsmasq，其实只是一个DNS 查询转发器（转到上游DNS 服务器或者本机上的 SkyDns）和结果缓存器，它本身并不保存域名的原始记录。&lt;/p&gt;
&lt;/div&gt;
&lt;h4&gt;1.2.3 SkyDNS 及其配置&lt;/h4&gt;
&lt;p&gt;关于 SkyDNS：它是一个开源的构建在 etcd 之上的分布式服务宣告（announcement）和发现（discovery）服务。它利用 DNS 查询来发现可用的服务。社区版本的 SkyDns 将记录保存在 etcd 中，但是OpenShift 并不是这么实现的。从其代码 &lt;a href=&quot;https://github.com/openshift/origin/blob/master/pkg/dns/&quot; target=&quot;_blank&quot;&gt;https://github.com/openshift/origin/blob/master/pkg/dns/&lt;/a&gt; 看，SkyDns 应该是调用 OpenShift API 服务来获取主机名、IP地址等信息，然后组装成标准 DNS 记录并返回。 &lt;/p&gt;
&lt;p&gt;在 127.0.0.1:53 上，包装在 openshift 进程中的 SkyDNS 在侦听。&lt;/p&gt;
&lt;div readability=&quot;22.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tcp        &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt;            &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*               LISTEN      &lt;span&gt;17182&lt;/span&gt;/openshift 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Node 节点上的 SkyDN 要么从cache 中直接回答 DNS 查询，要么调用 OpenShift API 服务来获取数据。&lt;/p&gt;
&lt;h3&gt;1.3 Master 节点上的 DNS 服务&lt;/h3&gt;
&lt;p&gt;resolv.conf 文件同Node 节点上的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@master1 cloud-user]# &lt;span&gt;cat&lt;/span&gt; /etc/&lt;span&gt;resolv.conf 
# nameserver updated by &lt;/span&gt;/etc/NetworkManager/dispatcher.d/&lt;span&gt;99&lt;/span&gt;-origin-dns.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;
# Generated by NetworkManager
search cluster.local haihangyun.cn exampleos.com
nameserver &lt;/span&gt;&lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dnsmasq 在多个IP 地址的 53 端口上侦听，为本机上的以及本机上Pod 中的DNS查询服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
udp        &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;10.128&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt;           &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*                           &lt;span&gt;866&lt;/span&gt;/&lt;span&gt;dnsmasq         
udp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;172.17&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt;           &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*                           &lt;span&gt;866&lt;/span&gt;/&lt;span&gt;dnsmasq         
udp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.5&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*                           &lt;span&gt;866&lt;/span&gt;/dnsmasq 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和 Node 节点不同，Master 节点上有两个SkyDns 进程。一个在 127.0.0.1:53 侦听，负责本机上的集群内服务的DNS查询，因为 Master 节点同时承担 node 节点的角色：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;udp        &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;:&lt;span&gt;53&lt;/span&gt;            &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*                           &lt;span&gt;11700&lt;/span&gt;/openshift 
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Dec  &lt;span&gt;3&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;50&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt; dnsmasq[&lt;span&gt;10607&lt;/span&gt;]: using nameserver &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;#&lt;span&gt;53&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; domain cluster.local
Dec  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;50&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt; dnsmasq[&lt;span&gt;10607&lt;/span&gt;]: using nameserver &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;#&lt;span&gt;53&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; domain &lt;span&gt;in&lt;/span&gt;-addr.arpa
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一个是在所有网卡的 8053 端口上侦听，这是因为Master 还具有 master api 角色：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
udp        &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;8053&lt;/span&gt;            &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:*                           &lt;span&gt;15096&lt;/span&gt;/openshift 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于这个 SkyDns 进程的作用尚不清楚，还需进一步研究。从已有资料上看看，所有节点上都需要安装 SkyDns，并组成一个分布式集群。因为 Master 节点上的 53 端口被另一个 SkyDns 进程占用，因此换到了端口8053。&lt;/p&gt;
&lt;h2&gt;2. DNS 查询流程&lt;/h2&gt;
&lt;h3&gt;2.1 pod 内的应用通过域名访问外网服务器的DNS查询流程&lt;/h3&gt;
&lt;p&gt;流程示意图如最上面图中的 &lt;span&gt;&lt;strong&gt;1 和 2.1&lt;/strong&gt;&lt;/span&gt; 部分所示。&lt;/p&gt;
&lt;p&gt;dnsmasq 日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Nov &lt;span&gt;21&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt; dnsmasq[&lt;span&gt;17788&lt;/span&gt;]: using nameserver &lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.3&lt;/span&gt;#&lt;span&gt;53&lt;/span&gt;&lt;span&gt;
Nov &lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt; dnsmasq[&lt;span&gt;17788&lt;/span&gt;]: using nameserver &lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.2&lt;/span&gt;#&lt;span&gt;53&lt;/span&gt;&lt;span&gt;
Nov &lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt; dnsmasq[&lt;span&gt;17788&lt;/span&gt;]: using nameserver &lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.4&lt;/span&gt;#&lt;span&gt;53&lt;/span&gt;&lt;span&gt;
Nov &lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt; dnsmasq[&lt;span&gt;17788&lt;/span&gt;]: query[A] www.sina.com from &lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.13&lt;/span&gt;&lt;span&gt;
Nov &lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt; dnsmasq[&lt;span&gt;17788&lt;/span&gt;]: forwarded www.sina.com to &lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.4&lt;/span&gt;&lt;span&gt;
Nov &lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt; dnsmasq[&lt;span&gt;17788&lt;/span&gt;]: forwarded www.sina.com to &lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.2&lt;/span&gt;&lt;span&gt;
Nov &lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt; dnsmasq[&lt;span&gt;17788&lt;/span&gt;]: forwarded www.sina.com to &lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.3&lt;/span&gt;&lt;span&gt;
Nov &lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;03&lt;/span&gt;:&lt;span&gt;49&lt;/span&gt; dnsmasq[&lt;span&gt;17788&lt;/span&gt;]: reply spool.grid.sinaedge.com is &lt;span&gt;124.228&lt;/span&gt;.&lt;span&gt;42.248&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;能看到 node 上的 dnsmasq 直接将查询请求转发给上游 DNS 名字服务器。因为存在多个名字服务器，所以是依次查询，直到成功为止。从日志看，其查询顺序和配置文件中的顺序是相反的。&lt;/p&gt;
&lt;h3&gt;2.2 Pod 内应用通过服务域名查找其IP 地址&lt;/h3&gt;
&lt;p&gt;流程示意图如上图中的 &lt;span&gt;&lt;strong&gt;1 + 2.2 + 3&lt;/strong&gt;&lt;/span&gt; 部分所示。&lt;/p&gt;
&lt;p&gt;日志实例：&lt;/p&gt;
&lt;p&gt;（1）从一个 pod 中 ping registry-console服务的域名 registry-console.default.svc.cluster.local。&lt;/p&gt;
&lt;p&gt;（2）Node宿主机（IP 地址为 172.22.122.13）上的 dnsmasq 收到该查询。&lt;/p&gt;
&lt;p&gt;（3）dnsmasq 将查询转到 127.0.0.1:53 上的 SkyDns 服务。&lt;/p&gt;
&lt;p&gt;（4）SkyDNS 做查询。SkyDNS 能接收的域名格式：&amp;lt;prefix&amp;gt;.&amp;lt;service_name&amp;gt;.&amp;lt;namespace&amp;gt;.(svc|endpoints|pod).&amp;lt;base&amp;gt;，这意味着它支持查询服务（svc）、端点（endpoints）和 pod 的 DNS信息。&lt;/p&gt;
&lt;p&gt;查询结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@node2 cloud-user]# nsenter -t &lt;span&gt;4216&lt;/span&gt; -&lt;span&gt;n dig mybank.dev.svc.cluster.local          &lt;/span&gt;&lt;span&gt;

;; QUESTION SECTION:
;mybank.dev.svc.cluster.local.  IN      A

&lt;span&gt;;; ANSWER SECTION:
mybank.dev.svc.cluster.local. &lt;/span&gt;&lt;/span&gt;&lt;span&gt;30 IN     A       172.30.162.172&lt;/span&gt;&lt;span&gt;

;; Query &lt;/span&gt;&lt;span&gt;time&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt; msec
;; SERVER: &lt;/span&gt;&lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.9&lt;/span&gt;#&lt;span&gt;53&lt;/span&gt;(&lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.9&lt;/span&gt;&lt;span&gt;)
;; WHEN: Mon Dec &lt;/span&gt;&lt;span&gt;03&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;43&lt;/span&gt;:&lt;span&gt;01&lt;/span&gt; CST &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;
;; MSG SIZE  rcvd: &lt;/span&gt;&lt;span&gt;62&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dnsmasq 日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Dec  &lt;span&gt;3&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt; dnsmasq[&lt;span&gt;29595&lt;/span&gt;]: query[A] mybank.dev.svc.cluster.local from &lt;span&gt;10.128&lt;/span&gt;.&lt;span&gt;2.128&lt;/span&gt;&lt;span&gt;
Dec  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt; dnsmasq[&lt;span&gt;29595&lt;/span&gt;]: forwarded mybank.dev.svc.cluster.local to &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
Dec  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt; dnsmasq[&lt;span&gt;29595&lt;/span&gt;]: reply mybank.dev.svc.cluster.local is &lt;span&gt;172.30&lt;/span&gt;.&lt;span&gt;162.172&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）其它实验：查询服务的所有端点&lt;/p&gt;
&lt;p&gt;查询结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@node2 cloud-user]# nsenter -t &lt;span&gt;4216&lt;/span&gt; -&lt;span&gt;n dig jenkins.dev.endpoints.cluster.local&lt;/span&gt;&lt;span&gt;

;; QUESTION SECTION:
;jenkins.dev.endpoints.cluster.local. IN        A

;; ANSWER SECTION:
&lt;span&gt;jenkins.dev.endpoints.cluster.local. &lt;/span&gt;&lt;/span&gt;&lt;span&gt;30 IN A    10.128.2.81
jenkins.dev.endpoints.cluster.local. 30 IN A    10.131.1.70&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dnsmasq 日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Dec  &lt;span&gt;3&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt; dnsmasq[&lt;span&gt;29595&lt;/span&gt;]: query[A] jenkins.dev.endpoints.cluster.local from &lt;span&gt;10.128&lt;/span&gt;.&lt;span&gt;2.128&lt;/span&gt;&lt;span&gt;
Dec  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt; dnsmasq[&lt;span&gt;29595&lt;/span&gt;]: forwarded jenkins.dev.endpoints.cluster.local to &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
Dec  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt; dnsmasq[&lt;span&gt;29595&lt;/span&gt;]: reply jenkins.dev.endpoints.cluster.local is &lt;span&gt;10.128&lt;/span&gt;.&lt;span&gt;2.81&lt;/span&gt;&lt;span&gt;
Dec  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;48&lt;/span&gt; dnsmasq[&lt;span&gt;29595&lt;/span&gt;]: reply jenkins.dev.endpoints.cluster.local is &lt;span&gt;10.131&lt;/span&gt;.&lt;span&gt;1.70&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（6）查询 pod&lt;/p&gt;
&lt;p&gt;待查询的pod域名的格式为 &amp;lt;IP_with_dashes&amp;gt;.&amp;lt;namespace&amp;gt;.pod.&amp;lt;base&amp;gt;，SkyDns 会返回其IP 地址，但我没明白这么做的场景和价值，也许是确认pod是否存在？&lt;/p&gt;
&lt;p&gt;查询结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@node2 cloud-user]# nsenter -t &lt;span&gt;4216&lt;/span&gt; -n dig &lt;span&gt;172&lt;/span&gt;-&lt;span&gt;30&lt;/span&gt;-&lt;span&gt;162&lt;/span&gt;-&lt;span&gt;172&lt;/span&gt;&lt;span&gt;.dev.pod.cluster.local&lt;/span&gt;&lt;span&gt;

;; QUESTION SECTION:
;&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;-&lt;span&gt;30&lt;/span&gt;-&lt;span&gt;162&lt;/span&gt;-&lt;span&gt;172&lt;/span&gt;&lt;span&gt;.dev.pod.cluster.local. IN A

&lt;span&gt;;; ANSWER SECTION:
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;172-30-162-172.dev.pod.cluster.local. 30 IN A   172.30.162.172&lt;/span&gt;&lt;span&gt;

;; Query &lt;/span&gt;&lt;span&gt;time&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt; msec
;; SERVER: &lt;/span&gt;&lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.9&lt;/span&gt;#&lt;span&gt;53&lt;/span&gt;(&lt;span&gt;172.22&lt;/span&gt;.&lt;span&gt;122.9&lt;/span&gt;&lt;span&gt;)
;; WHEN: Mon Dec &lt;/span&gt;&lt;span&gt;03&lt;/span&gt; &lt;span&gt;13&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt;:&lt;span&gt;05&lt;/span&gt; CST &lt;span&gt;2018&lt;/span&gt;&lt;span&gt;
;; MSG SIZE  rcvd: &lt;/span&gt;&lt;span&gt;70&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dnsmasq 日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Dec  &lt;span&gt;3&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;24&lt;/span&gt; dnsmasq[&lt;span&gt;29595&lt;/span&gt;]: query[A] &lt;span&gt;172&lt;/span&gt;-&lt;span&gt;30&lt;/span&gt;-&lt;span&gt;162&lt;/span&gt;-&lt;span&gt;172&lt;/span&gt;.dev.pod.cluster.local from &lt;span&gt;10.128&lt;/span&gt;.&lt;span&gt;2.128&lt;/span&gt;&lt;span&gt;
Dec  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;24&lt;/span&gt; dnsmasq[&lt;span&gt;29595&lt;/span&gt;]: forwarded &lt;span&gt;172&lt;/span&gt;-&lt;span&gt;30&lt;/span&gt;-&lt;span&gt;162&lt;/span&gt;-&lt;span&gt;172&lt;/span&gt;.dev.pod.cluster.local to &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;
Dec  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;24&lt;/span&gt; dnsmasq[&lt;span&gt;29595&lt;/span&gt;]: reply &lt;span&gt;172&lt;/span&gt;-&lt;span&gt;30&lt;/span&gt;-&lt;span&gt;162&lt;/span&gt;-&lt;span&gt;172&lt;/span&gt;.dev.pod.cluster.local is &lt;span&gt;172.30&lt;/span&gt;.&lt;span&gt;162.172&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（7）对比 FQDN 和 PQDN&lt;/p&gt;
&lt;p&gt;这个 PQDN 被加上了搜索域名再进行查询，能返回正确的IP地址：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@node2 cloud-user]# nsenter -t &lt;span&gt;4216&lt;/span&gt; -n &lt;span&gt;ping&lt;/span&gt;&lt;span&gt; mybank.dev.svc
PING mybank.dev.svc.cluster.local (&lt;/span&gt;&lt;span&gt;172.30&lt;/span&gt;.&lt;span&gt;162.172&lt;/span&gt;) &lt;span&gt;56&lt;/span&gt;(&lt;span&gt;84&lt;/span&gt;) bytes of data.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而这个 FQDN 被直接做DNS查询，结果查询失败，未能获取IP地址：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@node2 cloud&lt;/span&gt;-user]# nsenter -t &lt;span&gt;4216&lt;/span&gt; -n &lt;span&gt;ping&lt;/span&gt;&lt;span&gt; mybank.dev.svc.
&lt;/span&gt;&lt;span&gt;ping&lt;/span&gt;: mybank.dev.svc.: Name or service not known
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.3 从外网通过服务域名访问pod 中运行的服务&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697113/201812/697113-20181203140527170-517444920.png&quot; alt=&quot;&quot; width=&quot;622&quot; height=&quot;314&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看出，该过程中只涉及到外部DNS将服务的公共域名解析为 OpenShift Router 所在节点的公网地址，后面 HAProxy 作为代理，直接通过 IP 访问pod，并将结果返回客户端。&lt;/p&gt;

&lt;p&gt;参考文档：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;感谢您的阅读，欢迎关注我的微信公众号：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibOaboJGeVrQ0AUssQnVy7JrP5s60LoYIoptAaIbdnibrvFicwaib4FkYOYfESztzEX9054Ug7WBnSyAmyOaG6qvsA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; data-ratio=&quot;0.9665271966527197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibOaboJGeVrQ0AUssQnVy7JrP5s60LoYIoptAaIbdnibrvFicwaib4FkYOYfESztzEX9054Ug7WBnSyAmyOaG6qvsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;239&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 07:12:00 +0000</pubDate>
<dc:creator>SammyLiu</dc:creator>
<og:description>理解OpenShift（1）：网络之 Router 和 Route 理解OpenShift（2）：网络之 DNS（域名服务） OpenShift 集群中，至少有三个地方需要用到 DNS： 一是Pod</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sammyliu/p/10056035.html</dc:identifier>
</item>
<item>
<title>Python面向对象中super用法与MRO机制 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/10058594.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/10058594.html</guid>
<description>&lt;p&gt;　　最近在研究django rest_framework的源码，老是遇到super，搞得一团蒙，多番查看各路大神博客，总算明白了一点，今天做一点总结。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1）让代码维护更加简单&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Python是一门面向对象的语言，定义类时经常用到继承的概念，既然用到继承就少不得要在子类中引用父类的属性，我们可以通过“父类名.属性名”的方式来调用，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
&lt;/span&gt;&lt;span&gt;    def&lt;/span&gt;&lt;span&gt; fun(self):
&lt;/span&gt;&lt;span&gt;        print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A.fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
&lt;/span&gt;&lt;span&gt;    def&lt;/span&gt;&lt;span&gt; fun(self):
        A.fun(self)
&lt;/span&gt;&lt;span&gt;        print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B.fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述代码中，我们在子类B中调用了父类A的方法，这时候如果我们改变了A类的类名也只需要在B类中修改一下就好了，但是如果有几十上百个类继承了A类呢？一旦A类类名改了，我们就要分别到那几十上百个子类中修改，不但要改继承时用到的A类名，调用A类方法时用到的A类名也要改，繁琐的很，用super就好多了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
&lt;/span&gt;&lt;span&gt;    def&lt;/span&gt;&lt;span&gt; fun(self):
&lt;/span&gt;&lt;span&gt;        print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A.fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
&lt;/span&gt;&lt;span&gt;    def&lt;/span&gt;&lt;span&gt; fun(self):
        super().fun()
&lt;/span&gt;&lt;span&gt;        print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B.fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这时候，就算A类类名改了，也只需要在子类声明继承关系时修改就好了，简单得大多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）解决多继承带来的重复调用（菱形继承）、查找顺序（MRO）问题&lt;/strong&gt;&lt;br/&gt;　　上面说到的例子是单继承，用“父类名.属性”的方法调用出来代码维护时繁琐一点也并无不可，但Python是的继承机制是多继承，还是用这种方法来调用父类属性就会就回带来许多问题。假如有A、B、C、D这4个类，继承关系如下，我们要在各子类方法中显式调用父类的方法（姑且不考虑是否符合需求）：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1539768/201812/1539768-20181203145611915-2005229364.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图1&lt;/p&gt;
&lt;p&gt;　　用“父类名.属性名” 的方式调用，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
&lt;/span&gt;&lt;span&gt;    def&lt;/span&gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;        print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A.fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
&lt;/span&gt;&lt;span&gt;    def&lt;/span&gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(self):
        A.&lt;/span&gt;&lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(self)
&lt;/span&gt;&lt;span&gt;        print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B.fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; C(A):
&lt;/span&gt;&lt;span&gt;    def&lt;/span&gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(self):
        A.&lt;/span&gt;&lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(self)
&lt;/span&gt;&lt;span&gt;        print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C.fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; D(B , C):
&lt;/span&gt;&lt;span&gt;    def&lt;/span&gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(self):
        B.&lt;/span&gt;&lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(self)
        C.&lt;/span&gt;&lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(self)
&lt;/span&gt;&lt;span&gt;        print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D.fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

D()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果为：&lt;/p&gt;
&lt;p&gt;　　A.fun&lt;br/&gt;　　B.fun&lt;br/&gt;　　A.fun&lt;br/&gt;　　C.fun&lt;br/&gt;　　D.fun&lt;br/&gt;　　可见，A类被实例化了两次。这就是多继承带来的重复调用（菱形继承）的问题。使用super可以很好的解决这一问题：&lt;br/&gt;　　A.fun&lt;br/&gt;　　C.fun&lt;br/&gt;　　B.fun&lt;br/&gt;　　D.fun&lt;br/&gt;　　那么，为什么输出是A-&amp;gt;C-&amp;gt;B-&amp;gt;D呢？这就涉及到Python继承中的MRO（Method Resolution Order）：方法解析顺序。&lt;/p&gt;

&lt;p&gt;　　事实上，在每个类声明之后，Python都会自动为创建一个名为“__mro__”的内置属性，这个属性就是Python的MRO机制生成的，该属性是一个tuple，定义的是该类的方法解析顺序（继承顺序），当用super调用父类的方法时，会按照__mro__属性中的元素顺序去挨个查找方法。我们可以通过“类名.__mro__”或“类名.mro()”来查看上面代码中D类的__mro__属性值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(D.&lt;span&gt;__mro__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(D.mro())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果为：&lt;/p&gt;
&lt;p&gt;　　(&amp;lt;class '__main__.D'&amp;gt;, &amp;lt;class '__main__.B'&amp;gt;, &amp;lt;class '__main__.C'&amp;gt;, &amp;lt;class '__main__.A'&amp;gt;, &amp;lt;class 'object'&amp;gt;)&lt;br/&gt;　　[&amp;lt;class '__main__.D'&amp;gt;, &amp;lt;class '__main__.B'&amp;gt;, &amp;lt;class '__main__.C'&amp;gt;, &amp;lt;class '__main__.A'&amp;gt;, &amp;lt;class 'object'&amp;gt;]&lt;br/&gt;　　一个是tuple，一个list，但本质上是一个东西。这个顺序是怎么生成的呢？在Python新式类中（Python3中也只存在新式类了），采用的是C3算法（可不是广度优先，更不是深度优先）。我们通过如下图所示的继承关系来简单介绍C3算法（箭头指向父类）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1539768/201812/1539768-20181203145957255-31915685.png&quot; alt=&quot;&quot;/&gt;图2&lt;/p&gt;
&lt;p&gt;　　当要生成F的继承顺序时，C3算法过程如下：首先将入度（指向该节点的箭头数量）为零的节点放入列表，并将F节点及与F节点有关的箭头从上图树中删除；继续找入度为0的节点，找到D和E，左侧优先，故而现将D放入列表，并从上图树中删除D，这是列表中就有了F、D。继续找入度为0的节点，有A和E满足，左侧优先，所以是A，将A从上图中取出放入列表，列表中顺序为F、D、E；接下来入度为0的节点只剩下E，取出E放入列表；只剩下B和C节点，且入度都为0，但左侧优先，二先将B放入列表，然后才是后才是C；不过别忘了，Python所有类都有一个共同的父类，那就是object类，所以，最好还会把object放入列表末尾。最终生成列表中元素顺序为：F-&amp;gt;D-&amp;gt;A-&amp;gt;E-&amp;gt;B-&amp;gt;C-&amp;gt;object。我们用代码验证一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A(object):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(object):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; C(object):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; D(A,B):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; E(B, C):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; F(D, E):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;(F.&lt;span&gt;__mro__&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果为：&lt;/p&gt;
&lt;p&gt;　　(&amp;lt;class '__main__.F'&amp;gt;, &amp;lt;class '__main__.D'&amp;gt;, &amp;lt;class '__main__.A'&amp;gt;, &amp;lt;class '__main__.E'&amp;gt;, &amp;lt;class '__main__.B'&amp;gt;, &amp;lt;class '__main__.C'&amp;gt;, &amp;lt;class 'object'&amp;gt;)&lt;br/&gt;　　所以，图1中的继承顺序为什么是D-&amp;gt;B-&amp;gt;C-&amp;gt;A就好解释了。但还没弄清楚图1用super实现的代码输出顺序的问题，所以，我们还要继续看super的用法。&lt;/p&gt;

&lt;p&gt;　　super是一个类（不是方法），实例化之后得到的是一个代理的对象，而不是得到了父类，并且我们使用这个代理对象来调用父类或者兄弟类的方法。使用格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
super([type[, object-&lt;span&gt;or&lt;/span&gt;-type]])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　将这个格式展开来就有一下几种传参方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;super()
super(type , obj)
super(type_1 , type_2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，可没有super(type)这种方式。下面说说上面三种传参方式。&lt;/p&gt;
&lt;h2&gt;4.1 super(type , obj)&lt;/h2&gt;
&lt;p&gt;　　先说super(type , obj)，这个方式要传入两个常数，第一个参数type必须是一个类名，第二个参数是一个该类的实例化对象，不过可以不是直接的实例化对象，该类的子类的实例化对象也行。在上文中已经说到，super会按照__mro__属性中的顺序去查找方法，super(type , obj)两个参数中type作用是定义在__mro__数组中的那个位置开始找，obj定义的是用哪个类的__mro__元素。我们用代码来说明，将图2的代码各个类中添加一个fun方法，继承关系不变，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A.fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B.fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; C(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C.fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; D(A,B):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D.fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; E(B, C):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E.fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; F(D, E):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; fun(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F.fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后尝试super(type , obj)两个参数的不同组合，看看输出结果。&lt;/p&gt;
&lt;p&gt;　　先让obj都为F类的实例，尝试不同type下的输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
super(E , F()).fun() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出结果：B.fun&lt;/span&gt;
super(D , F()).fun() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出结果：A.fun&lt;/span&gt;
super(F , F()).fun() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出结果：D.fun&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再回顾一下__mro__的顺序：F-&amp;gt;D-&amp;gt;A-&amp;gt;E-&amp;gt;B-&amp;gt;C-&amp;gt;object，发现规律没？调用的都是type对应的类在__mro__顺序中的下一个类的fun方法。所以，我们可以通过type参数来指定调用父类的范围。&lt;/p&gt;
&lt;p&gt;　　再让type保持不变，obj尝试不同的实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
super(B , F()).fun() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出结果：C.fun&lt;/span&gt;
super(B , E()).fun() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出结果：C.fun&lt;/span&gt;
super(B , B()).fun() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这是错误的，会报错&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　发现规律了吗？上面这个类继承关系太简单，可能规律并不明显。事实上，obj参数指定的是用那个类的__mro__属性。&lt;/p&gt;
&lt;h2&gt;4.2 super()&lt;/h2&gt;
&lt;p&gt;　　super()事实上是懒人版的super(type , obj)，这种方式只能用在类体内部，Python会自动把两个参数填充上，type指代当前类，obj指导当前类的实例对象，相当于super(__class__ , self)。所以，以下三种代码是完全等效的：&lt;br/&gt;　　代码一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(self):
        super().&lt;/span&gt;&lt;span&gt;fun&lt;/span&gt;&lt;span&gt;()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B.fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　代码二：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(self):
        super(B , self).&lt;/span&gt;&lt;span&gt;fun&lt;/span&gt;&lt;span&gt;()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B.fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　代码三：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B(A):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(self):
        super(&lt;/span&gt;&lt;span&gt;__class__&lt;/span&gt; , self).&lt;span&gt;fun&lt;/span&gt;&lt;span&gt;()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B.fun&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4.3 super(type_1 , type_2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　当super传入的两个参数都是类名是，type_2必须是type_1的子类。功能上与super(type , obj)有什么不同呢？我们继续上一小节的代码输出测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(super(F , F())) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出结果为：&amp;lt;super: &amp;lt;class 'F'&amp;gt;, &amp;lt;F object&amp;gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(super(F , F)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出结果为：&amp;lt;super: &amp;lt;class 'F'&amp;gt;, &amp;lt;F object&amp;gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果是一样的，那你就以为super(type_1 , type_2)与super(type , obj)一样吗？看下面输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(super(F , F()).fun()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出结果为：D.fun&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(super(F , F).fun()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 报错：TypeError: fun() missing 1 required positional argument: 'self'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所以，super(type_1 , type_2)与super(type , obj)有区别，在看一下下列输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(super(F , F()).fun)&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出结果：&amp;lt;bound method D.fun of &amp;lt;__main__.F object at 0x000001BD44A98B38&amp;gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(super(F , F).fun) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出结果：&amp;lt;function D.fun at 0x000001BD44A9EE18&amp;gt;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(D.fun) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出结果：&amp;lt;function D.fun at 0x000001BD44A9EE18&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所以，当super传入的两个传输都是类时，得到的就是一个指向继承顺序下的类的代理，并未绑定实例，要调用D类的fun方法，还需传入实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(super(F , F).fun(F())) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出结果：D.fun&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　所以，当super传入的两个参数都是类的时候，最好只用来调用类的静态方法或者类方法。静态方法、类方法、实例方法在我的上一篇博文中已详细讲述了。&lt;/p&gt;

&lt;p&gt;　　最好，在实际写代码时，最好不要用诸如super(self.__class__, self) 的写法，容易导致异常，super 的第一个参数尽量为当前的类。至此，super的总结就结束了。&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 07:10:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>1. 引言 最近在研究django rest_framework的源码，老是遇到super，搞得一团蒙，多番查看各路大神博客，总算明白了一点，今天做一点总结。 2. 为什么要用super 1）让代码维</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenhuabin/p/10058594.html</dc:identifier>
</item>
<item>
<title>SVD（奇异值分解）Python实现 - EndlessCoding</title>
<link>http://www.cnblogs.com/endlesscoding/p/10058532.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/endlesscoding/p/10058532.html</guid>
<description>&lt;blockquote readability=&quot;6.5418719211823&quot;&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;在&lt;a href=&quot;https://www.cnblogs.com/endlesscoding/p/10033527.html&quot;&gt;《SVD（奇异值分解）小结 》&lt;/a&gt;中分享了SVD原理，但其中只是利用了&lt;span&gt;numpy.linalg.svd&lt;/span&gt;函数应用了它，并没有提到如何自己编写代码实现它，在这里，我再分享一下如何自已写一个&lt;span&gt;SVD函数&lt;/span&gt;。但是这里会利用到SVD的原理，如果大家还不明白它的原理，可以去看看&lt;a href=&quot;https://www.cnblogs.com/endlesscoding/p/10033527.html&quot;&gt;《SVD（奇异值分解）小结 》&lt;/a&gt;，或者自行百度/google。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;svd原理简单回顾&quot;&gt;1.1 SVD原理简单回顾&lt;/h2&gt;
&lt;p&gt;有一个&lt;span class=&quot;math inline&quot;&gt;\(m \times n\)&lt;/span&gt;的实数矩阵&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;，我们可以将它分解成如下的形式&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ A = U\Sigma V^T \tag{1-1} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(V\)&lt;/span&gt;均为单位正交阵，即有&lt;span class=&quot;math inline&quot;&gt;\(UU^T=I\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(VV^T=I\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt;称为&lt;code&gt;左奇异矩阵&lt;/code&gt;，&lt;span class=&quot;math inline&quot;&gt;\(V\)&lt;/span&gt;称为&lt;code&gt;右奇异矩阵&lt;/code&gt;，&lt;span class=&quot;math inline&quot;&gt;\(\Sigma\)&lt;/span&gt;仅在主对角线上有值，我们称它为&lt;code&gt;奇异值&lt;/code&gt;，其它元素均为0。上面矩阵的维度分别为&lt;span class=&quot;math inline&quot;&gt;\(U \in \mathbf{R}^{m\times m},\ \Sigma \in \mathbf{R}^{m\times n}\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(\ V \in \mathbf{R}^{n\times n}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;正常求上面的&lt;span class=&quot;math inline&quot;&gt;\(U,V,\Sigma\)&lt;/span&gt;不便于求，我们可以利用如下性质&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ AA^T=U\Sigma V^TV\Sigma^TU^T=U\Sigma \Sigma^TU^T \tag{1-2} \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ A^TA=V\Sigma^TU^TU\Sigma V^T=V\Sigma^T\Sigma V^T \tag{1-3} \]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;svd算法&quot;&gt;1.2 SVD算法&lt;/h2&gt;
&lt;p&gt;据&lt;span&gt;1.1小节&lt;/span&gt;，对式（1-3）和式（1-4）做特征值分解，即可得到奇异值分解的结果。但是样分开求存在一定的问题，由于做特征值分解的时候，特征向量的正负号并不影响结果，比如，我们利用式（1-3）和（1-4）做特征值分解&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ AA^T\mathbf{u}_i = \sigma_i \mathbf{u}_i\quad \text{or} \quad AA^T(-\mathbf{u}_i) = \sigma_i (-\mathbf{u}_i)\\ A^TA\mathbf{v}_i = \sigma_i \mathbf{v}_i\quad \text{or} \quad A^TA(-\mathbf{v}_i) = \sigma_i (-\mathbf{v}_i) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果在计算过程取，取上面的&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{u}_i\)&lt;/span&gt;组成左奇异矩阵&lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt;，取&lt;span class=&quot;math inline&quot;&gt;\(-\mathbf{v}_i\)&lt;/span&gt;组成右奇异矩阵&lt;span class=&quot;math inline&quot;&gt;\(V\)&lt;/span&gt;，此时&lt;span class=&quot;math inline&quot;&gt;\(A\ne U\Sigma V^T\)&lt;/span&gt;。因此求&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{v}_i\)&lt;/span&gt;时，要根据&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{u}_i\)&lt;/span&gt;来求，这样才能保证&lt;span class=&quot;math inline&quot;&gt;\(A= U\Sigma V^T\)&lt;/span&gt;。因此，我们可以得出如下1.1计算SVD的算法。它主要是先做特性值分解，再根据特征值分解得到的左奇异矩阵&lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt;间接地求出部分的右奇异矩阵&lt;span class=&quot;math inline&quot;&gt;\(V'\in \mathbf{R}^{m\times n}\)&lt;/span&gt;。&lt;/p&gt;
&lt;div readability=&quot;5.9175257731959&quot;&gt;
&lt;p&gt;&lt;a name=&quot;#alg1.1&quot;&gt;算法1.1：SVD&lt;/a&gt;&lt;/p&gt;
&lt;span&gt;输入：&lt;/span&gt;样本数据&lt;br/&gt;&lt;span&gt;输出：&lt;/span&gt;左奇异矩阵，奇异值矩阵，右奇异矩阵&lt;br/&gt;&lt;/div&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;计算特征值：&lt;/strong&gt; 特征值分解&lt;span class=&quot;math inline&quot;&gt;\(AA^T\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(A \in \mathbf{R}^{m\times n}\)&lt;/span&gt;为原始样本数据&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ AA^T=U\Sigma \Sigma^TU^T \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;得到左奇异矩阵&lt;span class=&quot;math inline&quot;&gt;\(U \in \mathbf{R}^{m \times m}\)&lt;/span&gt;和奇异值矩阵&lt;span class=&quot;math inline&quot;&gt;\(\Sigma' \in \mathbf{R}^{m \times m}\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;间接求部分右奇异矩阵：&lt;/strong&gt; 求&lt;span class=&quot;math inline&quot;&gt;\(V' \in \mathbf{R}^{m \times n}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;利用&lt;span class=&quot;math inline&quot;&gt;\(A=U\Sigma'V'\)&lt;/span&gt;可得&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ V' = (U\Sigma')^{-1}A = (\Sigma')^{-1}U^TA \tag{1-4} \]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;返回&lt;span class=&quot;math inline&quot;&gt;\(U,\ \Sigma',\ V'\)&lt;/span&gt;，分别为&lt;span&gt;左奇异矩阵，奇异值矩阵，右奇异矩阵。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;这里得到的&lt;span class=&quot;math inline&quot;&gt;\(\Sigma'\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(V'\)&lt;/span&gt;与式（1-2）所得到的&lt;span class=&quot;math inline&quot;&gt;\(\Sigma,\ V\)&lt;/span&gt;有区别，它们的维度不一样。&lt;span class=&quot;math inline&quot;&gt;\(\Sigma'\)&lt;/span&gt;是只取了前&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;个奇异值形成的对角方阵，即&lt;span class=&quot;math inline&quot;&gt;\(\Sigma' \in \mathbf{R}^{m \times m}\)&lt;/span&gt;；&lt;span class=&quot;math inline&quot;&gt;\(V'\)&lt;/span&gt;不是一个方阵，它只取了&lt;span class=&quot;math inline&quot;&gt;\(V \in \mathbf{R}^{m \times n}\)&lt;/span&gt;的前&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt;行（假设&lt;span class=&quot;math inline&quot;&gt;\(m &amp;lt; n\)&lt;/span&gt;），即有&lt;span class=&quot;math inline&quot;&gt;\(V' = V(:m,\cdot)\)&lt;/span&gt;。这样一来，我们同样有类似式（1-1）的数学关系成立，即&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ A = U\Sigma' (V')^T\tag{1-5} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们可以利用此关系重建原始数据。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以下代码的运行环境为&lt;code&gt;python3.6&lt;/code&gt;+&lt;code&gt;jupyter5.4&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;svd实现过程&quot;&gt;2.1 SVD实现过程&lt;/h2&gt;
&lt;h3 id=&quot;读取数据&quot;&gt;读取数据&lt;/h3&gt;
&lt;p&gt;这里面的数据集大家随便找一个数据就好，如果有需要我的数据集，可以下在面留言。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import numpy as np
import pandas as pd
from scipy.io import loadmat

# 读取数据，使用自己数据集的路径。
train_data_mat = loadmat(&quot;../data/train_data2.mat&quot;)
train_data = train_data_mat[&quot;Data&quot;]
print(train_data.shape)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;特征值分解&quot;&gt;特征值分解&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 数据必需先转为浮点型，否则在计算的过程中会溢出，导致结果不准确
train_dataFloat = train_data / 255.0
# 计算特征值和特征向量
eval_sigma1,evec_u = np.linalg.eigh(train_dataFloat.dot(train_dataFloat.T))&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;计算右奇异矩阵&quot;&gt;计算右奇异矩阵&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#降序排列后，逆序输出
eval1_sort_idx = np.argsort(eval_sigma1)[::-1]
# 将特征值对应的特征向量也对应排好序
eval_sigma1 = np.sort(eval_sigma1)[::-1]
evec_u = evec_u[:,eval1_sort_idx]
# 计算奇异值矩阵的逆
eval_sigma1 = np.sqrt(eval_sigma1)
eval_sigma1_inv = np.linalg.inv(np.diag(eval_sigma1))
# 计算右奇异矩阵
evec_part_v = eval_sigma1_inv.dot((evec_u.T).dot(train_dataFloat))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的计算出的&lt;span&gt;evec_u, eval_sigma1, evec_part_v&lt;/span&gt;分别为左奇异矩阵，所有奇异值，右奇异矩阵。&lt;/p&gt;
&lt;h2 id=&quot;svd降维后重建数据&quot;&gt;2.2 SVD降维后重建数据&lt;/h2&gt;
&lt;p&gt;取不同个数的奇异值，重建图片，计算出均方误差，如图2-1所示。从图中可以看出，随着奇异值的增加，均方误差（MSE）在减小，且奇异值和的比率正快速上升，在100维时，奇异值占总和的53%。&lt;/p&gt;
&lt;div&gt;&lt;img alt=&quot;fig2-1&quot; src=&quot;http://pi0fg1b4u.bkt.clouddn.com//blog/img/exp2_svd1.svg&quot;/&gt;&lt;br/&gt;&lt;span&gt;图2-1 奇值分解维度和均方误差变化图&lt;/span&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 均方误差MSE有如下计算公式&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \text{MSE} = \frac{1}{n}\left((y_1-y_1')^2+(y_2-y_2')^2+\cdots+(y_n-y_n')^2\right) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们平时听到的&lt;span class=&quot;math inline&quot;&gt;\(\text{RMSE}=\sqrt{\text{MSE}}\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将图和10、50、100维的图进行比较，如图2-2所示。在直观上，100维时，能保留较多的信息，此时能从图片中看出车辆形状。&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img alt=&quot;fig2-2&quot; src=&quot;http://pi0fg1b4u.bkt.clouddn.com//blog/img/exp2_svd2.svg&quot;/&gt;&lt;p&gt;图2-2 原图与降维重建后的图比较&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;SVD与特征值分解（EVD）&lt;/span&gt;非常类似，应该说EVD只是SVD的一种特殊怀况。我们可以通过它们在实际的应用中返过来理解&lt;span&gt;特征值/奇异值&lt;/span&gt;的含义：特征值/奇异值代表着数据的信息量，它的值越大，信息越多。&lt;/p&gt;
&lt;p&gt;最近作业是真的多呀，冒着生命危险来分享，希望能给大家带来帮助😄&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 07:02:00 +0000</pubDate>
<dc:creator>EndlessCoding</dc:creator>
<og:description>注： 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/endlesscoding/p/10058532.html</dc:identifier>
</item>
<item>
<title>javascript之模块加载方案 - 覃</title>
<link>http://www.cnblogs.com/BillyQin/p/10058454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BillyQin/p/10058454.html</guid>
<description>&lt;h2 id=&quot;前言&quot; data-source-line=&quot;1&quot;&gt;前言&lt;/h2&gt;
&lt;p data-source-line=&quot;2&quot;&gt;主要学习一下四种模块加载规范:&lt;/p&gt;
&lt;ol data-source-line=&quot;3&quot;&gt;&lt;li&gt;AMD&lt;/li&gt;
&lt;li&gt;CMD&lt;/li&gt;
&lt;li&gt;CommonJS&lt;/li&gt;
&lt;li&gt;ES6 模块&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;历史&quot; data-source-line=&quot;8&quot;&gt;历史&lt;/h2&gt;
&lt;p data-source-line=&quot;9&quot;&gt;&lt;a href=&quot;https://github.com/seajs/seajs/issues/588&quot; target=&quot;_blank&quot;&gt;前端模块化开发那点历史&lt;/a&gt;&lt;/p&gt;

&lt;p data-source-line=&quot;14&quot;&gt;requirejs 为全局添加了 define 函数，你只要按照这种约定的方式书写这个模块即可。&lt;/p&gt;
&lt;pre data-source-line=&quot;16&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;define(&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function &lt;span class=&quot;hljs-params&quot;&gt;() {
    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre data-source-line=&quot;27&quot;&gt;
&lt;code class=&quot;hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;43&quot;&gt;以上示例代码&lt;a href=&quot;https://requirejs.org/docs/api.html&quot; target=&quot;_blank&quot;&gt;来源&lt;/a&gt;于require.js官网&lt;/p&gt;
&lt;p data-source-line=&quot;45&quot;&gt;demo代码详见 &lt;a href=&quot;https://github.com/BillyQin/jsModule/tree/master/requireJs&quot; target=&quot;_blank&quot;&gt;https://github.com/BillyQin/jsModule/tree/master/requireJs&lt;/a&gt;&lt;/p&gt;

&lt;blockquote data-source-line=&quot;47&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;require.js 为全局添加了define 函数，按照这种约定方式写即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;49&quot;&gt;这个约定方式就是AMD（The Asyncchronous Module Definition）&lt;/p&gt;
&lt;p data-source-line=&quot;51&quot;&gt;所以AMD规范就是定义了怎么写define函数。只要按照这个规范来写模块和依赖，require.js就能正确解析。&lt;/p&gt;
&lt;h2 id=&quot;seajs&quot; data-source-line=&quot;53&quot;&gt;sea.js&lt;/h2&gt;
&lt;p data-source-line=&quot;54&quot;&gt;demo代码详见 &lt;a href=&quot;https://github.com/BillyQin/jsModule/tree/master/seaJs&quot; target=&quot;_blank&quot;&gt;https://github.com/BillyQin/jsModule/tree/master/seaJs&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;cmd&quot; data-source-line=&quot;55&quot;&gt;CMD&lt;/h2&gt;
&lt;p data-source-line=&quot;56&quot;&gt;同样的道理，CMD就是Sea.js对模块定义对规范化产出。&lt;/p&gt;
&lt;p data-source-line=&quot;58&quot;&gt;所以CMD的内容就是描述该如何定义模块，如何引入模块，如何导出模块。只要按照这个规范来写模块和依赖，sea.js就能正确解析。&lt;/p&gt;
&lt;h3 id=&quot;amd-和-cmd&quot; data-source-line=&quot;60&quot;&gt;AMD 和 CMD&lt;/h3&gt;
&lt;ol data-source-line=&quot;61&quot;&gt;&lt;li&gt;AMD 推崇依赖前置，CMD推崇依赖就近&lt;/li&gt;
&lt;li&gt;对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。&lt;/li&gt;
&lt;/ol&gt;&lt;ul data-source-line=&quot;64&quot;&gt;&lt;li&gt;AMD 是将需要使用的模块先加载完再执行代码&lt;/li&gt;
&lt;li&gt;CMD 是在 require 的时候才去加载模块文件，加载完再接着执行。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;commonjs&quot; data-source-line=&quot;67&quot;&gt;&lt;a href=&quot;http://javascript.ruanyifeng.com/nodejs/module.html&quot; target=&quot;_blank&quot;&gt;CommonJS&lt;/a&gt;&lt;/h3&gt;
&lt;p data-source-line=&quot;68&quot;&gt;AMD 和 CMD 都是用于浏览器的模块规范，而在&lt;a href=&quot;http://nodejs.cn/api/modules.html&quot; target=&quot;_blank&quot;&gt;服务端(node)&lt;/a&gt;，则采用CommonJS。&lt;/p&gt;
&lt;p data-source-line=&quot;70&quot;&gt;CommonJS和sea.js一样，require的时候才去加载模块文件，加载完再接着执行。&lt;/p&gt;
&lt;p data-source-line=&quot;72&quot;&gt;demo代码详见 &lt;a href=&quot;https://github.com/BillyQin/jsModule/tree/master/commonJs&quot; target=&quot;_blank&quot;&gt;https://github.com/BillyQin/jsModule/tree/master/commonJs&lt;/a&gt;&lt;/p&gt;
&lt;blockquote data-source-line=&quot;74&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;为什么浏览器中不支持 CommonJS 语法呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;76&quot;&gt;这是因为浏览器环境中并没有 module、 exports、 require 等环境变量。&lt;/p&gt;
&lt;h3 id=&quot;es6&quot; data-source-line=&quot;78&quot;&gt;ES6&lt;/h3&gt;
&lt;p data-source-line=&quot;79&quot;&gt;es6定义了新的模块加载方案。&lt;/p&gt;
&lt;pre data-source-line=&quot;81&quot;&gt;
&lt;code class=&quot;hljs&quot;/&gt;
&lt;/pre&gt;
&lt;pre data-source-line=&quot;87&quot;&gt;
&lt;code class=&quot;hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;92&quot;&gt;和require.js(AMD)一致，将需要使用的模块加载完再执行代码。&lt;/p&gt;
&lt;h3 id=&quot;es6-和-commonjs的差异&quot; data-source-line=&quot;94&quot;&gt;ES6 和 CommonJS的差异&lt;/h3&gt;
&lt;ol data-source-line=&quot;95&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;CommonJS模块输出值的拷贝， ES6输出值的引用。 CommonJS模块输出值的拷贝, 也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;CommonJS是运行时加载，ES6是编译时输出接口。 CommonJS加载的是一个对象，就是module.exports属性。该对象只有在脚本运行完成后才会生成。而es6模块不是对象，对外接口只是一种静态定义，在代码静态解析阶段就会生成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;babel&quot; data-source-line=&quot;102&quot;&gt;Babel&lt;/h2&gt;
&lt;p data-source-line=&quot;103&quot;&gt;&lt;a href=&quot;https://www.babeljs.cn/repl/&quot; target=&quot;_blank&quot;&gt;es6语法在线转换&lt;/a&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;105&quot;&gt;在浏览器不支持es6的时候，如果要使用es6的语法，一般都会在项目里加入babel。&lt;/p&gt;
&lt;pre data-source-line=&quot;108&quot;&gt;
&lt;code class=&quot;hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;116&quot;&gt;转换后&lt;/p&gt;
&lt;pre data-source-line=&quot;118&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;Object.defineProperty(exports, &lt;span class=&quot;hljs-string&quot;&gt;&quot;__esModule&quot;, {
  &lt;span class=&quot;hljs-keyword&quot;&gt;value: &lt;span class=&quot;hljs-literal&quot;&gt;true
});
&lt;span class=&quot;hljs-keyword&quot;&gt;var firstName = &lt;span class=&quot;hljs-string&quot;&gt;'Michael';
&lt;span class=&quot;hljs-keyword&quot;&gt;var lastName = &lt;span class=&quot;hljs-string&quot;&gt;'Jackson';
&lt;span class=&quot;hljs-keyword&quot;&gt;var year = &lt;span class=&quot;hljs-number&quot;&gt;1958;

exports.firstName = firstName;
exports.lastName = lastName;
exports.year = year;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;webpack&quot; data-source-line=&quot;131&quot;&gt;webpack&lt;/h2&gt;
&lt;p data-source-line=&quot;133&quot;&gt;Babel 只是把 ES6 模块语法转为 CommonJS 模块语法，而浏览器不支持CommonJs。这时候webpack出动。&lt;/p&gt;
&lt;blockquote data-source-line=&quot;135&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;浏览器不支持CommonJs的本质是因为浏览器环境中并没有 module、 exports、 require 等环境变量。 webpack 打包后的文件之所以在浏览器中能运行，就是靠模拟了这些变量的行为。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;webpack怎么模拟呢&quot; data-source-line=&quot;138&quot;&gt;webpack怎么模拟呢？&lt;/h4&gt;
&lt;pre data-source-line=&quot;140&quot;&gt;
&lt;code class=&quot;hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;154&quot;&gt;模拟后:&lt;/p&gt;
&lt;pre data-source-line=&quot;155&quot;&gt;
&lt;code class=&quot;hljs&quot;/&gt;
&lt;/pre&gt;
&lt;p data-source-line=&quot;168&quot;&gt;整个CommonJs项目改写后&lt;/p&gt;
&lt;pre data-source-line=&quot;171&quot;&gt;
&lt;code class=&quot;hljs&quot;/&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参考&quot; data-source-line=&quot;230&quot;&gt;参考&lt;/h3&gt;
</description>
<pubDate>Mon, 03 Dec 2018 06:52:00 +0000</pubDate>
<dc:creator>覃</dc:creator>
<og:description>前言 主要学习一下四种模块加载规范: 历史 前端模块化开发那点历史 require.js requirejs 为全局添加了 define 函数，你只要按照这种约定的方式书写这个模块即可。 以上示例代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BillyQin/p/10058454.html</dc:identifier>
</item>
<item>
<title>iOS开发简记（9）：APPStore审核 - jonlan</title>
<link>http://www.cnblogs.com/jonlan/p/10058398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jonlan/p/10058398.html</guid>
<description>&lt;p&gt;&quot;觅知音&quot;这个APP的第一个版本从提交审核到上架，历时三个星期，其中遇到一些审核上的问题，它的处理或许能帮助到遇到同样问题的小伙伴们，所以这里列举出来，这三个星期如何跟苹果的审核团队“斗智斗勇”。&lt;/p&gt;
&lt;h4&gt;（1）Guideline 2.1 - Information Needed&lt;/h4&gt;
&lt;p&gt;这是问题的标题，问题下面还详细列举了需要你确认的各个事项。&lt;/p&gt;
&lt;p&gt;简单来说，如果你不确认，审核就会一直中断；如果你重新提交APP，那就进到下一次审核，会再次遇到这个问题，而且进审的时间会延长。&lt;/p&gt;
&lt;p&gt;所以，最好的办法是，先不要重新提交APP，并且，在Resolution Center中，详细确认每个事项。比如，我是这样确认的：&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1.1.6 包含虚假信息、功能或者误导性元数据&lt;br/&gt;–我仔细检查了“元数据”，并没有发现这样的数据。慎重起见，我还是把“关键词”删除了一些，避免误导。&lt;/p&gt;
&lt;p&gt;2.3.0 与 2.3.1：热更新、App 动态开关、重定向赌博、彩票网站&lt;br/&gt;–这个APP没有热更新，也没有后台开头，更不会有涉黄涉赌或彩票类的内容。&lt;/p&gt;
&lt;p&gt;3.1.1 使用苹果的内购机制来完成应用内购买&lt;br/&gt;–这个APP没有内置购买，至少现在是没有的。&lt;/p&gt;
&lt;p&gt;4.3 与其他应用重复&lt;br/&gt;–我开发前搜索过类似idea的产品，并没有发现，所以才进行了开发。&lt;/p&gt;
&lt;p&gt;5.2.1 缺乏提供 App 的相关资质&lt;br/&gt;–这个APP没有使用歌曲、视频或其它需要版本授权的资源，APP中的语音均为用户制作，APP也作了使用条款的说明。&lt;/p&gt;
&lt;p&gt;5.3.4 没有在相关地区提供 App 的执照与权限&lt;br/&gt;–未发现这个APP有这个问题。&lt;/p&gt;
&lt;p&gt;以上为逐条可能违规的说明。&lt;/p&gt;
&lt;p&gt;总的来说，这个APP的初衷并不会有违背“不良表现”的地方。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;原本，这个问题不允许加速，只能在解决中心中及时回复，但是，如果等待了几天在Resolution Center中也看不到苹果的回复的话，还是可以到“contact us”那里，去要求加速的，关键要在加速理由中详细描述原因，比如使用上面对各个事项的解释，并在最前面与最后面，加上这样的两段话：&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;一周前我的APP被拒了，其中一个理由是”Guideline 2.1 - Information Needed”，并要求我确认是否有违规，我直接在Resolution Center中进行了回复（确认没有违规），但一个周过去了，还是没有进到“In Review”的状态，我担心是不是我的确认不够明确，所以在再次确认一下。以下为逐条确认的内容：&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;请您加速它的审核吧，或者回复我，让我知道是哪里卡住了，谢谢。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;注意，不管是加速申请，还是在Resolution Center中回复，都可以直接使用中文。&lt;/p&gt;
&lt;h4&gt;（2）Guideline 5.2.5 - Legal - Intellectual Property&lt;/h4&gt;
&lt;p&gt;Your app is too similar to Siri, which creates a misleading association with Apple products.&lt;/p&gt;
&lt;p&gt;Next Steps&lt;/p&gt;
&lt;p&gt;To resolve this issue, please review your app design and revise it to differentiate it from existing iOS and watchOS apps.&lt;/p&gt;
&lt;p&gt;这个问题，是因为“觅知音”的主页面中，有一个图标跟siri的图标很像。所以，解决办法就是换一个图标，重新提交APP。&lt;/p&gt;
&lt;h4&gt;Guideline 1.2 - Safety - User Generated Content&lt;/h4&gt;
&lt;p&gt;Your app enables the display of user-generated content but does not have the proper precautions in place.&lt;/p&gt;
&lt;p&gt;Next Steps&lt;/p&gt;
&lt;p&gt;To resolve this issue, please revise your app to implement all of the following precautions:&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Require that users agree to terms (EULA) and these terms must make it clear that there is no tolerance for objectionable content or abusive users&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;A mechanism for users to flag objectionable content&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;The developer must act on objectionable content reports within 24 hours by removing the content and ejecting the user who provided the offending content&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里都是UGC（用户生产内容）的问题，苹果已经给出了解决办法，但我们要正确理解。&lt;/p&gt;
&lt;p&gt;针对第一条，也就是“使用条款”，容易解决。客户端增加在首次启动时，弹出一个“使用条款”的说明框，告诉用户如果录音并发送就意味着同意以下条款，然后列举几个条款，比如不能发布任何不良内容之类。如此就能解决这个问题。&lt;/p&gt;
&lt;p&gt;第二点是说，要能让用户标识“不良信息”。第三点是说，开发者要能在24小时内处理不良信息。&lt;/p&gt;
&lt;p&gt;一开始，我的理解是：“证明我能随时处理不良信息就可以了”，于是，我在解决中心中回复：“服务端有这样的操作，能及时处理不良信息，请参考我的载图。” 并且在附件中提供了服务后端的管理界面的截图。&lt;/p&gt;
&lt;p&gt;但是，这个回复并未起作用，因为再次打回时，这个问题再次提到–参考下一条违规。&lt;/p&gt;
&lt;h4&gt;Guideline 1.2 - Safety - User Generated Content&lt;/h4&gt;
&lt;p&gt;Your app enables the display of user-generated content but does not have the proper precautions in place.&lt;/p&gt;
&lt;p&gt;Next Steps&lt;/p&gt;
&lt;p&gt;To resolve this issue, please revise your app to implement all of the following precautions:&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;A method for filtering objectionable content&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;A mechanism for users to flag objectionable content&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;A mechanism for users to block abusive users&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;The developer must act on objectionable content reports within 24 hours by removing the content and ejecting the user who provided the offending content&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这一次打回，苹果显然担心我不能正确理解，所以提供了联系的方式–让我留下联系方式：Request a phone call from App Review…&lt;/p&gt;
&lt;p&gt;当然，我留下了我的联系电话，但是很可惜我错过了苹果的来电（白天的一个来电）。于是，苹果的审核团队，很友好地在Resolution Center，再次回复我，说联系不上我，让我主动联系他们，并留了他们的联系方式。于是，在苹果说的联系时间段内，我给美国打了电话，但听完一通英文提示后，嘀的一声，让我留言。我当然是狠狠地挂掉电话了！&lt;/p&gt;
&lt;p&gt;然后，我回复联系不上他们，让他们再次联系我，并再次留下电话号码。&lt;/p&gt;
&lt;p&gt;在等待苹果再次联系这段时间内，我做了一些正确的处理（这个在之后得到证实），针对苹果回复的问题，逐条来处理：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;A method for filtering objectionable content&lt;br/&gt;要有办法过滤不良信息，这个问题的解决，只需要证明服务后台有这个能力即可，我提供了管理后台的“删除语音”与“禁言”的截图，这个问题得到解决。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;A mechanism for users to flag objectionable content&lt;br/&gt;提供机制让用户标识不良信息，实际就是“举报”。我在APP上提供了“举报”的功能，并且是举报某条语音，比如“有不当的政治言论”之类，这个问题得到解决。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;A mechanism for users to block abusive users&lt;br/&gt;提供办法过滤不良信息，实际就是“黑名单”。我在APP上提供了一个“黑名单”的功能，拉黑某人就看不到他发布的信息，这个问题就得到了解决。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;The developer must act on objectionable content reports within 24 hours by removing the content and ejecting the user who provided the offending content&lt;br/&gt;同样，提供管理后台的对应截图，这个问题就得到了解决。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上，“A mechanism for users to block abusive users”，这一点我一开始理解错了，一直在解释后台已经帮用户阻止不良信息了。而正确的做法是，在客户端提供一个“黑名单”的功能即可。&lt;/p&gt;
&lt;p&gt;修改了这些问题后，再次提交APP。两三天后，周末，早上8点左右，苹果来了一个电话，我激动地接通，苹果的客服很友好，大概说“既然您已经理解并修改了，那就没有什么问题了”。&lt;/p&gt;
&lt;p&gt;挂掉电话后，“觅知音”这个APP便已经过审了。之后，“觅知音”连续发布了几个版本，都是两三天就过审，最快的时候是半天就过审（而且，内容改过还比较多），感觉苹果的审核速度比几年前快了好多好多。&lt;/p&gt;
&lt;p&gt;另外，应该注意，对于审核的回复，我们务必把握机会，详细地解释APP的行为。如果有不明白的地方，也应该积极地询问，苹果的审核团队还是很友好的。&lt;/p&gt;
&lt;p&gt;以上是“觅知音”这个APP在提审过程遇到问题，希望能帮助到小伙伴们。最后，欢迎大家试用这个APP：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;地址：https://itunes.apple.com/cn/app/%E5%A4%A9%E6%B6%AF%E4%BD%95%E5%A4%84%E8%A7%85%E7%9F%A5%E9%9F%B3/id1439297254?mt=8&amp;amp;from=groupmessage&amp;amp;isappinstalled=0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或在AppStore搜索“觅知音”或“天涯何处”，下载安装。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 06:44:00 +0000</pubDate>
<dc:creator>jonlan</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jonlan/p/10058398.html</dc:identifier>
</item>
<item>
<title>【.NET Core项目实战-统一认证平台】第九章 授权篇-使用Dapper持久化IdentityServer4 - 金焰的世界</title>
<link>http://www.cnblogs.com/jackcao/p/10058274.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackcao/p/10058274.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;上篇文章介绍了&lt;code&gt;IdentityServer4&lt;/code&gt;的源码分析的内容，让我们知道了&lt;code&gt;IdentityServer4&lt;/code&gt;的一些运行原理，这篇将介绍如何使用dapper来持久化&lt;code&gt;Identityserver4&lt;/code&gt;，让我们对&lt;code&gt;IdentityServer4&lt;/code&gt;理解更透彻，并优化下数据请求，减少不必要的开销。&lt;/p&gt;
&lt;p&gt;.netcore项目实战交流群（637326624），有兴趣的朋友可以在群里交流讨论。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在进行数据持久化之前，我们要了解&lt;code&gt;Ids4&lt;/code&gt;是如何实现持久化的呢？&lt;code&gt;Ids4&lt;/code&gt;默认是使用内存实现的&lt;code&gt;IClientStore、IResourceStore、IPersistedGrantStore&lt;/code&gt;三个接口，对应的分别是&lt;code&gt;InMemoryClientStore、InMemoryResourcesStore、InMemoryPersistedGrantStore&lt;/code&gt;三个方法，这显然达不到我们持久化的需求，因为都是从内存里提取配置信息，所以我们要做到&lt;code&gt;Ids4&lt;/code&gt;配置信息持久化，就需要实现这三个接口，作为优秀的身份认证框架，肯定已经帮我们想到了这点啦，有个EFCore的持久化实现，GitHub地址&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4.EntityFramework&quot; class=&quot;uri&quot;&gt;https://github.com/IdentityServer/IdentityServer4.EntityFramework&lt;/a&gt;，是不是万事大吉了呢？拿来直接使用吧，使用肯定是没有问题的，但是我们要分析下实现的方式和数据库结构，便于后续使用dapper来持久化和扩展成任意数据库存储。&lt;/p&gt;
&lt;p&gt;下面以&lt;strong&gt;IClientStore接口&lt;/strong&gt;接口为例，讲解下如何实现数据持久化的。他的方法就是通过clientId获取Client记录,乍一看很简单，不管是用内存或数据库都可以很简单实现。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Task&amp;lt;Client&amp;gt; FindClientByIdAsync(string clientId);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要看这个接口实际用途，就可以直接查看这个接口被注入到哪些方法中，最简单的方式就是&lt;code&gt;Ctrl+F&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;，通过查找会发现，Client实体里有很多关联记录也会被用到，因此我们在提取Client信息时需要提取他对应的关联实体，那如果是数据库持久化，那应该怎么提取呢？这里可以参考&lt;code&gt;IdentityServer4.EntityFramework&lt;/code&gt;项目，我们执行下客户端授权如下图所示，您会发现能够正确返回结果，但是这里执行了哪些SQL查询呢？&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201812/1529926-20181203142637556-807629900.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从EFCore实现中可以看出来，就一个简单的客户端查询语句，尽然执行了10次数据库查询操作（可以使用SQL Server Profiler查看详细的SQL语句），这也是为什么使用IdentityServer4获取授权信息时奇慢无比的原因。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public Task&amp;lt;Client&amp;gt; FindClientByIdAsync(string clientId)
{
    var client = _context.Clients
        .Include(x =&amp;gt; x.AllowedGrantTypes)
        .Include(x =&amp;gt; x.RedirectUris)
        .Include(x =&amp;gt; x.PostLogoutRedirectUris)
        .Include(x =&amp;gt; x.AllowedScopes)
        .Include(x =&amp;gt; x.ClientSecrets)
        .Include(x =&amp;gt; x.Claims)
        .Include(x =&amp;gt; x.IdentityProviderRestrictions)
        .Include(x =&amp;gt; x.AllowedCorsOrigins)
        .Include(x =&amp;gt; x.Properties)
        .FirstOrDefault(x =&amp;gt; x.ClientId == clientId);
    var model = client?.ToModel();

    _logger.LogDebug(&quot;{clientId} found in database: {clientIdFound}&quot;, clientId, model != null);

    return Task.FromResult(model);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这肯定不是实际生产环境中想要的结果，我们希望是尽量一次连接查询到想要的结果。其他2个方法类似，就不一一介绍了，我们需要使用dapper来持久化存储，减少对服务器查询的开销。&lt;/p&gt;
&lt;p&gt;特别需要注意的是，在使用&lt;code&gt;refresh_token&lt;/code&gt;时,有个有效期的问题，所以需要通过可配置的方式设置定期清除过期的授权信息，实现方式可以通过数据库作业、定时器、后台任务等，使用&lt;code&gt;dapper&lt;/code&gt;持久化时也需要实现此方法。&lt;/p&gt;

&lt;p&gt;下面就开始搭建Dapper的持久化存储，首先建一个&lt;code&gt;IdentityServer4.Dapper&lt;/code&gt;类库项目，来实现自定义的扩展功能，还记得前几篇开发中间件的思路吗？这里再按照设计思路回顾下，首先我们考虑需要注入什么来解决&lt;code&gt;Dapper&lt;/code&gt;的使用，通过分析得知需要一个连接字符串和使用哪个数据库，以及配置定时删除过期授权的策略。&lt;/p&gt;
&lt;p&gt;新建&lt;code&gt;IdentityServerDapperBuilderExtensions&lt;/code&gt;类，实现我们注入的扩展,代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using IdentityServer4.Dapper.Options;
using System;
using IdentityServer4.Stores;

namespace Microsoft.Extensions.DependencyInjection
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-12-03
    /// 使用Dapper扩展
    /// &amp;lt;/summary&amp;gt;
    public static class IdentityServerDapperBuilderExtensions
    {
        /// &amp;lt;summary&amp;gt;
        /// 配置Dapper接口和实现(默认使用SqlServer)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;builder&quot;&amp;gt;The builder.&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;storeOptionsAction&quot;&amp;gt;存储配置信息&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static IIdentityServerBuilder AddDapperStore(
            this IIdentityServerBuilder builder,
            Action&amp;lt;DapperStoreOptions&amp;gt; storeOptionsAction = null)
        {
            var options = new DapperStoreOptions();
            builder.Services.AddSingleton(options);
            storeOptionsAction?.Invoke(options);
            builder.Services.AddTransient&amp;lt;IClientStore, SqlServerClientStore&amp;gt;();
            builder.Services.AddTransient&amp;lt;IResourceStore, SqlServerResourceStore&amp;gt;();
            builder.Services.AddTransient&amp;lt;IPersistedGrantStore, SqlServerPersistedGrantStore&amp;gt;();
            return builder;
        }

        /// &amp;lt;summary&amp;gt;
        /// 使用Mysql存储
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;builder&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static IIdentityServerBuilder UseMySql(this IIdentityServerBuilder builder)
        {
            builder.Services.AddTransient&amp;lt;IClientStore, MySqlClientStore&amp;gt;();
            builder.Services.AddTransient&amp;lt;IResourceStore, MySqlResourceStore&amp;gt;();
            builder.Services.AddTransient&amp;lt;IPersistedGrantStore, MySqlPersistedGrantStore&amp;gt;();
            return builder;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整体框架基本确认了，现在就需要解决这里用到的几个配置信息和实现。&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;DapperStoreOptions需要接收那些参数？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如何使用dapper实现存储的三个接口信息？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;首先我们定义下配置文件，用来接收数据库的连接字符串和配置清理的参数并设置默认值。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;namespace IdentityServer4.Dapper.Options
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-12-03
    /// 配置存储信息
    /// &amp;lt;/summary&amp;gt;
    public class DapperStoreOptions
    {
        /// &amp;lt;summary&amp;gt;
        /// 是否启用自定清理Token
        /// &amp;lt;/summary&amp;gt;
        public bool EnableTokenCleanup { get; set; } = false;

        /// &amp;lt;summary&amp;gt;
        /// 清理token周期（单位秒），默认1小时
        /// &amp;lt;/summary&amp;gt;
        public int TokenCleanupInterval { get; set; } = 3600;

        /// &amp;lt;summary&amp;gt;
        /// 连接字符串
        /// &amp;lt;/summary&amp;gt;
        public string DbConnectionStrings { get; set; }

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上图所示，这里定义了最基本的配置信息，来满足我们的需求。&lt;/p&gt;
&lt;p&gt;下面开始来实现客户端存储，&lt;code&gt;SqlServerClientStore&lt;/code&gt;类代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Dapper;
using IdentityServer4.Dapper.Mappers;
using IdentityServer4.Dapper.Options;
using IdentityServer4.Models;
using IdentityServer4.Stores;
using Microsoft.Extensions.Logging;
using System.Data.SqlClient;
using System.Threading.Tasks;

namespace IdentityServer4.Dapper.Stores.SqlServer
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-12-03
    /// 实现提取客户端存储信息
    /// &amp;lt;/summary&amp;gt;
    public class SqlServerClientStore: IClientStore
    {
        private readonly ILogger&amp;lt;SqlServerClientStore&amp;gt; _logger;
        private readonly DapperStoreOptions _configurationStoreOptions;

        public SqlServerClientStore(ILogger&amp;lt;SqlServerClientStore&amp;gt; logger, DapperStoreOptions configurationStoreOptions)
        {
            _logger = logger;
            _configurationStoreOptions = configurationStoreOptions;
        }

        /// &amp;lt;summary&amp;gt;
        /// 根据客户端ID 获取客户端信息内容
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;clientId&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;Client&amp;gt; FindClientByIdAsync(string clientId)
        {
            var cModel = new Client();
            var _client = new Entities.Client();
            using (var connection = new SqlConnection(_configurationStoreOptions.DbConnectionStrings))
            {
                //由于后续未用到，暂不实现 ClientPostLogoutRedirectUris ClientClaims ClientIdPRestrictions ClientCorsOrigins ClientProperties,有需要的自行添加。
                string sql = @&quot;select * from Clients where ClientId=@client and Enabled=1;
               select t2.* from Clients t1 inner join ClientGrantTypes t2 on t1.Id=t2.ClientId where t1.ClientId=@client and Enabled=1;
               select t2.* from Clients t1 inner join ClientRedirectUris t2 on t1.Id=t2.ClientId where t1.ClientId=@client and Enabled=1;
               select t2.* from Clients t1 inner join ClientScopes t2 on t1.Id=t2.ClientId where t1.ClientId=@client and Enabled=1;
               select t2.* from Clients t1 inner join ClientSecrets t2 on t1.Id=t2.ClientId where t1.ClientId=@client and Enabled=1;
                      &quot;;
                var multi = await connection.QueryMultipleAsync(sql, new { client = clientId });
                var client = multi.Read&amp;lt;Entities.Client&amp;gt;();
                var ClientGrantTypes = multi.Read&amp;lt;Entities.ClientGrantType&amp;gt;();
                var ClientRedirectUris = multi.Read&amp;lt;Entities.ClientRedirectUri&amp;gt;();
                var ClientScopes = multi.Read&amp;lt;Entities.ClientScope&amp;gt;();
                var ClientSecrets = multi.Read&amp;lt;Entities.ClientSecret&amp;gt;();

                if (client != null &amp;amp;&amp;amp; client.AsList().Count &amp;gt; 0)
                {//提取信息
                    _client = client.AsList()[0];
                    _client.AllowedGrantTypes = ClientGrantTypes.AsList();
                    _client.RedirectUris = ClientRedirectUris.AsList();
                    _client.AllowedScopes = ClientScopes.AsList();
                    _client.ClientSecrets = ClientSecrets.AsList();
                    cModel = _client.ToModel();
                }
            }
            _logger.LogDebug(&quot;{clientId} found in database: {clientIdFound}&quot;, clientId, _client != null);

            return cModel;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面涉及到几个知识点，第一&lt;code&gt;dapper&lt;/code&gt;的高级使用，一次性提取多个数据集，然后逐一赋值，&lt;strong&gt;需要注意的是sql查询顺序和赋值顺序需要完全一致&lt;/strong&gt;。第二是&lt;code&gt;AutoMapper&lt;/code&gt;的实体映射，最后封装的一句代码就是&lt;code&gt;_client.ToModel();&lt;/code&gt;即可完成，这与这块使用还不是很清楚，可学习相关知识后再看，详细的映射代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;
using System.Collections.Generic;
using System.Security.Claims;
using AutoMapper;

namespace IdentityServer4.Dapper.Mappers
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-12-03
    /// 客户端实体映射
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;seealso cref=&quot;AutoMapper.Profile&quot; /&amp;gt;
    public class ClientMapperProfile : Profile
    {
        public ClientMapperProfile()
        {
            CreateMap&amp;lt;Entities.ClientProperty, KeyValuePair&amp;lt;string, string&amp;gt;&amp;gt;()
                .ReverseMap();

            CreateMap&amp;lt;Entities.Client, IdentityServer4.Models.Client&amp;gt;()
                .ForMember(dest =&amp;gt; dest.ProtocolType, opt =&amp;gt; opt.Condition(srs =&amp;gt; srs != null))
                .ReverseMap();

            CreateMap&amp;lt;Entities.ClientCorsOrigin, string&amp;gt;()
                .ConstructUsing(src =&amp;gt; src.Origin)
                .ReverseMap()
                .ForMember(dest =&amp;gt; dest.Origin, opt =&amp;gt; opt.MapFrom(src =&amp;gt; src));

            CreateMap&amp;lt;Entities.ClientIdPRestriction, string&amp;gt;()
                .ConstructUsing(src =&amp;gt; src.Provider)
                .ReverseMap()
                .ForMember(dest =&amp;gt; dest.Provider, opt =&amp;gt; opt.MapFrom(src =&amp;gt; src));

            CreateMap&amp;lt;Entities.ClientClaim, Claim&amp;gt;(MemberList.None)
                .ConstructUsing(src =&amp;gt; new Claim(src.Type, src.Value))
                .ReverseMap();

            CreateMap&amp;lt;Entities.ClientScope, string&amp;gt;()
                .ConstructUsing(src =&amp;gt; src.Scope)
                .ReverseMap()
                .ForMember(dest =&amp;gt; dest.Scope, opt =&amp;gt; opt.MapFrom(src =&amp;gt; src));

            CreateMap&amp;lt;Entities.ClientPostLogoutRedirectUri, string&amp;gt;()
                .ConstructUsing(src =&amp;gt; src.PostLogoutRedirectUri)
                .ReverseMap()
                .ForMember(dest =&amp;gt; dest.PostLogoutRedirectUri, opt =&amp;gt; opt.MapFrom(src =&amp;gt; src));

            CreateMap&amp;lt;Entities.ClientRedirectUri, string&amp;gt;()
                .ConstructUsing(src =&amp;gt; src.RedirectUri)
                .ReverseMap()
                .ForMember(dest =&amp;gt; dest.RedirectUri, opt =&amp;gt; opt.MapFrom(src =&amp;gt; src));

            CreateMap&amp;lt;Entities.ClientGrantType, string&amp;gt;()
                .ConstructUsing(src =&amp;gt; src.GrantType)
                .ReverseMap()
                .ForMember(dest =&amp;gt; dest.GrantType, opt =&amp;gt; opt.MapFrom(src =&amp;gt; src));

            CreateMap&amp;lt;Entities.ClientSecret, IdentityServer4.Models.Secret&amp;gt;(MemberList.Destination)
                .ForMember(dest =&amp;gt; dest.Type, opt =&amp;gt; opt.Condition(srs =&amp;gt; srs != null))
                .ReverseMap();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using AutoMapper;

namespace IdentityServer4.Dapper.Mappers
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-12-03
    /// 客户端信息映射
    /// &amp;lt;/summary&amp;gt;
    public static class ClientMappers
    {
        static ClientMappers()
        {
            Mapper = new MapperConfiguration(cfg =&amp;gt; cfg.AddProfile&amp;lt;ClientMapperProfile&amp;gt;())
                .CreateMapper();
        }

        internal static IMapper Mapper { get; }

        public static Models.Client ToModel(this Entities.Client entity)
        {
            return Mapper.Map&amp;lt;Models.Client&amp;gt;(entity);
        }

        public static Entities.Client ToEntity(this Models.Client model)
        {
            return Mapper.Map&amp;lt;Entities.Client&amp;gt;(model);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就完成了从数据库里提取客户端信息及相关关联表记录，只需要一次连接即可完成，奈斯，达到我们的要求。接着继续实现其他2个接口,下面直接列出2个类的实现代码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SqlServerResourceStore.cs&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Dapper;
using IdentityServer4.Dapper.Mappers;
using IdentityServer4.Dapper.Options;
using IdentityServer4.Models;
using IdentityServer4.Stores;
using Microsoft.Extensions.Logging;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Threading.Tasks;
using System.Linq;

namespace IdentityServer4.Dapper.Stores.SqlServer
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-12-03
    /// 重写资源存储方法
    /// &amp;lt;/summary&amp;gt;
    public class SqlServerResourceStore : IResourceStore
    {
        private readonly ILogger&amp;lt;SqlServerResourceStore&amp;gt; _logger;
        private readonly DapperStoreOptions _configurationStoreOptions;

        public SqlServerResourceStore(ILogger&amp;lt;SqlServerResourceStore&amp;gt; logger, DapperStoreOptions configurationStoreOptions)
        {
            _logger = logger;
            _configurationStoreOptions = configurationStoreOptions;
        }

        /// &amp;lt;summary&amp;gt;
        /// 根据api名称获取相关信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;ApiResource&amp;gt; FindApiResourceAsync(string name)
        {
            var model = new ApiResource();
            using (var connection = new SqlConnection(_configurationStoreOptions.DbConnectionStrings))
            {
                string sql = @&quot;select * from ApiResources where Name=@Name and Enabled=1;
                       select * from ApiResources t1 inner join ApiScopes t2 on t1.Id=t2.ApiResourceId where t1.Name=@name and Enabled=1;
                    &quot;;
                var multi = await connection.QueryMultipleAsync(sql, new { name });
                var ApiResources = multi.Read&amp;lt;Entities.ApiResource&amp;gt;();
                var ApiScopes = multi.Read&amp;lt;Entities.ApiScope&amp;gt;();
                if (ApiResources != null &amp;amp;&amp;amp; ApiResources.AsList()?.Count &amp;gt; 0)
                {
                    var apiresource = ApiResources.AsList()[0];
                    apiresource.Scopes = ApiScopes.AsList();
                    if (apiresource != null)
                    {
                        _logger.LogDebug(&quot;Found {api} API resource in database&quot;, name);
                    }
                    else
                    {
                        _logger.LogDebug(&quot;Did not find {api} API resource in database&quot;, name);
                    }
                    model = apiresource.ToModel();
                }
            }
            return model;
        }

        /// &amp;lt;summary&amp;gt;
        /// 根据作用域信息获取接口资源
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;scopeNames&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;IEnumerable&amp;lt;ApiResource&amp;gt;&amp;gt; FindApiResourcesByScopeAsync(IEnumerable&amp;lt;string&amp;gt; scopeNames)
        {
            var apiResourceData = new List&amp;lt;ApiResource&amp;gt;();
            string _scopes = &quot;&quot;;
            foreach (var scope in scopeNames)
            {
                _scopes += &quot;'&quot; + scope + &quot;',&quot;;
            }
            if (_scopes == &quot;&quot;)
            {
                return null;
            }
            else
            {
                _scopes = _scopes.Substring(0, _scopes.Length - 1);
            }
            string sql = &quot;select distinct t1.* from ApiResources t1 inner join ApiScopes t2 on t1.Id=t2.ApiResourceId where t2.Name in(&quot; + _scopes + &quot;) and Enabled=1;&quot;;
            using (var connection = new SqlConnection(_configurationStoreOptions.DbConnectionStrings))
            {
                var apir = (await connection.QueryAsync&amp;lt;Entities.ApiResource&amp;gt;(sql))?.AsList();
                if (apir != null &amp;amp;&amp;amp; apir.Count &amp;gt; 0)
                {
                    foreach (var apimodel in apir)
                    {
                        sql = &quot;select * from ApiScopes where ApiResourceId=@id&quot;;
                        var scopedata = (await connection.QueryAsync&amp;lt;Entities.ApiScope&amp;gt;(sql, new { id = apimodel.Id }))?.AsList();
                        apimodel.Scopes = scopedata;
                        apiResourceData.Add(apimodel.ToModel());
                    }
                    _logger.LogDebug(&quot;Found {scopes} API scopes in database&quot;, apiResourceData.SelectMany(x =&amp;gt; x.Scopes).Select(x =&amp;gt; x.Name));
                }
            }
            return apiResourceData;
        }

        /// &amp;lt;summary&amp;gt;
        /// 根据scope获取身份资源
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;scopeNames&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;IEnumerable&amp;lt;IdentityResource&amp;gt;&amp;gt; FindIdentityResourcesByScopeAsync(IEnumerable&amp;lt;string&amp;gt; scopeNames)
        {
            var apiResourceData = new List&amp;lt;IdentityResource&amp;gt;();
            string _scopes = &quot;&quot;;
            foreach (var scope in scopeNames)
            {
                _scopes += &quot;'&quot; + scope + &quot;',&quot;;
            }
            if (_scopes == &quot;&quot;)
            {
                return null;
            }
            else
            {
                _scopes = _scopes.Substring(0, _scopes.Length - 1);
            }
            using (var connection = new SqlConnection(_configurationStoreOptions.DbConnectionStrings))
            {
                //暂不实现 IdentityClaims
                string sql = &quot;select * from IdentityResources where Enabled=1 and Name in(&quot; + _scopes + &quot;)&quot;;
                var data = (await connection.QueryAsync&amp;lt;Entities.IdentityResource&amp;gt;(sql))?.AsList();
                if (data != null &amp;amp;&amp;amp; data.Count &amp;gt; 0)
                {
                    foreach (var model in data)
                    {
                        apiResourceData.Add(model.ToModel());
                    }
                }
            }
            return apiResourceData;
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取所有资源实现
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;Resources&amp;gt; GetAllResourcesAsync()
        {
            var apiResourceData = new List&amp;lt;ApiResource&amp;gt;();
            var identityResourceData = new List&amp;lt;IdentityResource&amp;gt;();
            using (var connection = new SqlConnection(_configurationStoreOptions.DbConnectionStrings))
            {
                string sql = &quot;select * from IdentityResources where Enabled=1&quot;;
                var data = (await connection.QueryAsync&amp;lt;Entities.IdentityResource&amp;gt;(sql))?.AsList();
                if (data != null &amp;amp;&amp;amp; data.Count &amp;gt; 0)
                {

                    foreach (var m in data)
                    {
                        identityResourceData.Add(m.ToModel());
                    }
                }
                //获取apiresource
                sql = &quot;select * from ApiResources where Enabled=1&quot;;
                var apidata = (await connection.QueryAsync&amp;lt;Entities.ApiResource&amp;gt;(sql))?.AsList();
                if (apidata != null &amp;amp;&amp;amp; apidata.Count &amp;gt; 0)
                {
                    foreach (var m in apidata)
                    {
                        sql = &quot;select * from ApiScopes where ApiResourceId=@id&quot;;
                        var scopedata = (await connection.QueryAsync&amp;lt;Entities.ApiScope&amp;gt;(sql, new { id = m.Id }))?.AsList();
                        m.Scopes = scopedata;
                        apiResourceData.Add(m.ToModel());
                    }
                }
            }
            var model = new Resources(identityResourceData, apiResourceData);
            return model;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SqlServerPersistedGrantStore.cs&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Dapper;
using IdentityServer4.Dapper.Mappers;
using IdentityServer4.Dapper.Options;
using IdentityServer4.Models;
using IdentityServer4.Stores;
using Microsoft.Extensions.Logging;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Linq;
using System.Threading.Tasks;

namespace IdentityServer4.Dapper.Stores.SqlServer
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-12-03
    /// 重写授权信息存储
    /// &amp;lt;/summary&amp;gt;
    public class SqlServerPersistedGrantStore : IPersistedGrantStore
    {
        private readonly ILogger&amp;lt;SqlServerPersistedGrantStore&amp;gt; _logger;
        private readonly DapperStoreOptions _configurationStoreOptions;

        public SqlServerPersistedGrantStore(ILogger&amp;lt;SqlServerPersistedGrantStore&amp;gt; logger, DapperStoreOptions configurationStoreOptions)
        {
            _logger = logger;
            _configurationStoreOptions = configurationStoreOptions;
        }

        /// &amp;lt;summary&amp;gt;
        /// 根据用户标识获取所有的授权信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;subjectId&quot;&amp;gt;用户标识&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;IEnumerable&amp;lt;PersistedGrant&amp;gt;&amp;gt; GetAllAsync(string subjectId)
        {
            using (var connection = new SqlConnection(_configurationStoreOptions.DbConnectionStrings))
            {
                string sql = &quot;select * from PersistedGrants where SubjectId=@subjectId&quot;;
                var data = (await connection.QueryAsync&amp;lt;Entities.PersistedGrant&amp;gt;(sql, new { subjectId }))?.AsList();
                var model = data.Select(x =&amp;gt; x.ToModel());

                _logger.LogDebug(&quot;{persistedGrantCount} persisted grants found for {subjectId}&quot;, data.Count, subjectId);
                return model;
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// 根据key获取授权信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;key&quot;&amp;gt;认证信息&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;PersistedGrant&amp;gt; GetAsync(string key)
        {
            using (var connection = new SqlConnection(_configurationStoreOptions.DbConnectionStrings))
            {
                string sql = &quot;select * from PersistedGrants where [Key]=@key&quot;;
                var result = await connection.QueryFirstOrDefaultAsync&amp;lt;Entities.PersistedGrant&amp;gt;(sql, new { key });
                var model = result.ToModel();

                _logger.LogDebug(&quot;{persistedGrantKey} found in database: {persistedGrantKeyFound}&quot;, key, model != null);
                return model;
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// 根据用户标识和客户端ID移除所有的授权信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;subjectId&quot;&amp;gt;用户标识&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;clientId&quot;&amp;gt;客户端ID&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task RemoveAllAsync(string subjectId, string clientId)
        {
            using (var connection = new SqlConnection(_configurationStoreOptions.DbConnectionStrings))
            {
                string sql = &quot;delete from PersistedGrants where ClientId=@clientId and SubjectId=@subjectId&quot;;
                await connection.ExecuteAsync(sql, new { subjectId, clientId });
                _logger.LogDebug(&quot;remove {subjectId} {clientId} from database success&quot;, subjectId, clientId);
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// 移除指定的标识、客户端、类型等授权信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;subjectId&quot;&amp;gt;标识&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;clientId&quot;&amp;gt;客户端ID&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;type&quot;&amp;gt;授权类型&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task RemoveAllAsync(string subjectId, string clientId, string type)
        {
            using (var connection = new SqlConnection(_configurationStoreOptions.DbConnectionStrings))
            {
                string sql = &quot;delete from PersistedGrants where ClientId=@clientId and SubjectId=@subjectId and Type=@type&quot;;
                await connection.ExecuteAsync(sql, new { subjectId, clientId });
                _logger.LogDebug(&quot;remove {subjectId} {clientId} {type} from database success&quot;, subjectId, clientId, type);
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// 移除指定KEY的授权信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task RemoveAsync(string key)
        {
            using (var connection = new SqlConnection(_configurationStoreOptions.DbConnectionStrings))
            {
                string sql = &quot;delete from PersistedGrants where [Key]=@key&quot;;
                await connection.ExecuteAsync(sql, new { key });
                _logger.LogDebug(&quot;remove {key} from database success&quot;, key);
            }
        }

        /// &amp;lt;summary&amp;gt;
        /// 存储授权信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;grant&quot;&amp;gt;实体&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task StoreAsync(PersistedGrant grant)
        {
            using (var connection = new SqlConnection(_configurationStoreOptions.DbConnectionStrings))
            {
                //移除防止重复
                await RemoveAsync(grant.Key);
                string sql = &quot;insert into PersistedGrants([Key],ClientId,CreationTime,Data,Expiration,SubjectId,Type) values(@Key,@ClientId,@CreationTime,@Data,@Expiration,@SubjectId,@Type)&quot;;
                await connection.ExecuteAsync(sql, grant);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用dapper提取存储数据已经全部实现完，接下来我们需要实现定时清理过期的授权信息。&lt;/p&gt;
&lt;p&gt;首先定义一个清理过期数据接口&lt;code&gt;IPersistedGrants&lt;/code&gt;，定义如下所示。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;
using System.Threading.Tasks;

namespace IdentityServer4.Dapper.Interfaces
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-12-03
    /// 过期授权清理接口
    /// &amp;lt;/summary&amp;gt;
    public interface IPersistedGrants
    {
        /// &amp;lt;summary&amp;gt;
        /// 移除指定时间的过期信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;dt&quot;&amp;gt;过期时间&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        Task RemoveExpireToken(DateTime dt);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们来实现下此接口，详细代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Dapper;
using IdentityServer4.Dapper.Interfaces;
using IdentityServer4.Dapper.Options;
using Microsoft.Extensions.Logging;
using System;
using System.Data.SqlClient;
using System.Threading.Tasks;

namespace IdentityServer4.Dapper.Stores.SqlServer
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-12-03
    /// 实现授权信息自定义管理
    /// &amp;lt;/summary&amp;gt;
    public class SqlServerPersistedGrants : IPersistedGrants
    {
        private readonly ILogger&amp;lt;SqlServerPersistedGrants&amp;gt; _logger;
        private readonly DapperStoreOptions _configurationStoreOptions;

        public SqlServerPersistedGrants(ILogger&amp;lt;SqlServerPersistedGrants&amp;gt; logger, DapperStoreOptions configurationStoreOptions)
        {
            _logger = logger;
            _configurationStoreOptions = configurationStoreOptions;
        }


        /// &amp;lt;summary&amp;gt;
        /// 移除指定的时间过期授权信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;dt&quot;&amp;gt;Utc时间&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task RemoveExpireToken(DateTime dt)
        {
            using (var connection = new SqlConnection(_configurationStoreOptions.DbConnectionStrings))
            {
                string sql = &quot;delete from PersistedGrants where Expiration&amp;gt;@dt&quot;;
                await connection.ExecuteAsync(sql, new { dt });
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有个清理的接口和实现，我们需要注入下实现&lt;code&gt;builder.Services.AddTransient&amp;lt;IPersistedGrants, SqlServerPersistedGrants&amp;gt;();&lt;/code&gt;，接下来就是开启后端服务来清理过期记录。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using IdentityServer4.Dapper.Interfaces;
using IdentityServer4.Dapper.Options;
using Microsoft.Extensions.Logging;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace IdentityServer4.Dapper.HostedServices
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-12-03
    /// 清理过期Token方法
    /// &amp;lt;/summary&amp;gt;
    public class TokenCleanup
    {
        private readonly ILogger&amp;lt;TokenCleanup&amp;gt; _logger;
        private readonly DapperStoreOptions _options;
        private readonly IPersistedGrants _persistedGrants;
        private CancellationTokenSource _source;

        public TimeSpan CleanupInterval =&amp;gt; TimeSpan.FromSeconds(_options.TokenCleanupInterval);

        public TokenCleanup(IPersistedGrants persistedGrants, ILogger&amp;lt;TokenCleanup&amp;gt; logger, DapperStoreOptions options)
        {
            _options = options ?? throw new ArgumentNullException(nameof(options));
            if (_options.TokenCleanupInterval &amp;lt; 1) throw new ArgumentException(&quot;Token cleanup interval must be at least 1 second&quot;);

            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _persistedGrants = persistedGrants;
        }

        public void Start()
        {
            Start(CancellationToken.None);
        }

        public void Start(CancellationToken cancellationToken)
        {
            if (_source != null) throw new InvalidOperationException(&quot;Already started. Call Stop first.&quot;);

            _logger.LogDebug(&quot;Starting token cleanup&quot;);

            _source = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);

            Task.Factory.StartNew(() =&amp;gt; StartInternal(_source.Token));
        }

        public void Stop()
        {
            if (_source == null) throw new InvalidOperationException(&quot;Not started. Call Start first.&quot;);

            _logger.LogDebug(&quot;Stopping token cleanup&quot;);

            _source.Cancel();
            _source = null;
        }

        private async Task StartInternal(CancellationToken cancellationToken)
        {
            while (true)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    _logger.LogDebug(&quot;CancellationRequested. Exiting.&quot;);
                    break;
                }

                try
                {
                    await Task.Delay(CleanupInterval, cancellationToken);
                }
                catch (TaskCanceledException)
                {
                    _logger.LogDebug(&quot;TaskCanceledException. Exiting.&quot;);
                    break;
                }
                catch (Exception ex)
                {
                    _logger.LogError(&quot;Task.Delay exception: {0}. Exiting.&quot;, ex.Message);
                    break;
                }

                if (cancellationToken.IsCancellationRequested)
                {
                    _logger.LogDebug(&quot;CancellationRequested. Exiting.&quot;);
                    break;
                }

                ClearTokens();
            }
        }

        public void ClearTokens()
        {
            try
            {
                _logger.LogTrace(&quot;Querying for tokens to clear&quot;);

                //提取满足条件的信息进行删除
                _persistedGrants.RemoveExpireToken(DateTime.UtcNow);
            }
            catch (Exception ex)
            {
                _logger.LogError(&quot;Exception clearing tokens: {exception}&quot;, ex.Message);
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using IdentityServer4.Dapper.Options;
using Microsoft.Extensions.Hosting;
using System.Threading;
using System.Threading.Tasks;

namespace IdentityServer4.Dapper.HostedServices
{
    /// &amp;lt;summary&amp;gt;
    /// 金焰的世界
    /// 2018-12-03
    /// 授权后端清理服务
    /// &amp;lt;/summary&amp;gt;
    public class TokenCleanupHost : IHostedService
    {
        private readonly TokenCleanup _tokenCleanup;
        private readonly DapperStoreOptions _options;

        public TokenCleanupHost(TokenCleanup tokenCleanup, DapperStoreOptions options)
        {
            _tokenCleanup = tokenCleanup;
            _options = options;
        }

        public Task StartAsync(CancellationToken cancellationToken)
        {
            if (_options.EnableTokenCleanup)
            {
                _tokenCleanup.Start(cancellationToken);
            }
            return Task.CompletedTask;
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {
            if (_options.EnableTokenCleanup)
            {
                _tokenCleanup.Stop();
            }
            return Task.CompletedTask;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是实现一个定时任务很简单呢？功能完成别忘了注入实现，现在我们使用dapper持久化的功能基本完成了。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; builder.Services.AddSingleton&amp;lt;TokenCleanup&amp;gt;();
 builder.Services.AddSingleton&amp;lt;IHostedService, TokenCleanupHost&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在前面客户端授权中，我们增加dapper扩展的实现，来测试功能是否能正常使用，且使用&lt;code&gt;SQL Server Profiler&lt;/code&gt;来监控下调用的过程。可以从之前文章中的源码&lt;code&gt;TestIds4&lt;/code&gt;项目中，实现持久化的存储，改造注入代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.AddIdentityServer()
    .AddDeveloperSigningCredential()
    //.AddInMemoryApiResources(Config.GetApiResources())  
    //.AddInMemoryClients(Config.GetClients());
    .AddDapperStore(option=&amp;gt; {
        option.DbConnectionStrings = &quot;Server=192.168.1.114;Database=mpc_identity;User ID=sa;Password=bl123456;&quot;;
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，现在可以配合网关来测试下客户端登录了，打开&lt;code&gt;PostMan&lt;/code&gt;，启用本地的项目，然后访问之前配置的客户端授权地址，并开启SqlServer监控，查看运行代码。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201812/1529926-20181203142711604-2115922153.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问能够得到我们预期的结果且查询全部是dapper写的Sql语句。且定期清理任务也启动成功，会根据配置的参数来执行清理过期授权信息。&lt;/p&gt;

&lt;p&gt;这里Mysql重写就不一一列出来了，语句跟sqlserver几乎是完全一样，然后调用&lt;code&gt;.UseMySql()&lt;/code&gt;即可完成mysql切换,我花了不到2分钟就完成了Mysql的所有语句和切换功能，是不是简单呢？接着测试Mysql应用，代码如下。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.AddIdentityServer()
                .AddDeveloperSigningCredential()
                //.AddInMemoryApiResources(Config.GetApiResources())
                //.AddInMemoryClients(Config.GetClients());
                .AddDapperStore(option=&amp;gt; {
                    option.DbConnectionStrings = &quot;Server=*******;Database=mpc_identity;User ID=root;Password=*******;&quot;;
                }).UseMySql();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1529926/201812/1529926-20181203142729446-950825013.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以返回正确的结果数据，扩展Mysql实现已经完成，如果想用其他数据库实现，直接按照我写的方法扩展下即可。&lt;/p&gt;

&lt;p&gt;本篇我介绍了如何使用&lt;code&gt;Dapper&lt;/code&gt;来持久化&lt;code&gt;Ids4&lt;/code&gt;信息，并介绍了实现过程，然后实现了&lt;code&gt;SqlServer&lt;/code&gt;和&lt;code&gt;Mysql&lt;/code&gt;两种方式，也介绍了使用过程中遇到的技术问题，其实在实现过程中我发现的一个缓存和如何让授权信息立即过期等问题，这块大家可以一起先思考下如何实现，后续文章中我会介绍具体的实现方式，然后把缓存迁移到&lt;code&gt;Redis&lt;/code&gt;里。&lt;/p&gt;
&lt;p&gt;下一篇开始就正式介绍Ids4的几种授权方式和具体的应用，以及如何在我们客户端进行集成，如果在学习过程中遇到不懂或未理解的问题，欢迎大家加入QQ群聊&lt;code&gt;637326624&lt;/code&gt;与作者联系吧。&lt;/p&gt;
</description>
<pubDate>Mon, 03 Dec 2018 06:28:00 +0000</pubDate>
<dc:creator>金焰的世界</dc:creator>
<og:description></og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jackcao/p/10058274.html</dc:identifier>
</item>
<item>
<title>外观模式 门面模式 Facade  创建型 设计模式（十三） - noteless</title>
<link>http://www.cnblogs.com/noteless/p/10058164.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noteless/p/10058164.html</guid>
<description>&lt;p&gt;外观模式（FACADE）&lt;/p&gt;
&lt;p&gt;又称为门面模式&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181203141147342-1829044847.png&quot;&gt;&lt;img title=&quot;image_5c04c84e_d32&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181203141148359-457923837.png&quot; alt=&quot;image_5c04c84e_d32&quot; width=&quot;865&quot; height=&quot;478&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;意图&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;为子系统中的一组接口提供一个一致的界面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Facade模式定义了一个高层接口，这一接口使得这一子系统更加易于使用。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;意图解析&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;随着项目的持续发展，系统基本上都是会往功能更全面的方向发展，那么也就意味着我们的系统将会变得更加复杂。&lt;/p&gt;
&lt;p&gt;系统会被划分为多个单独的子系统，每个子系统完成一部分功能，通过分工协作完成全部功能。&lt;/p&gt;
&lt;p&gt;一个子系统也可能进一步拆分为更小的几个子系统。&lt;/p&gt;

&lt;p&gt;程序中的文件将会越来越多，相互关联也会变得更加复杂&lt;/p&gt;
&lt;p&gt;当使用一个功能的时候，作为客户端&lt;/p&gt;
&lt;p&gt;你需要弄清楚相关类之间的关系，以及正确的调用顺序。&lt;/p&gt;

&lt;p&gt;比如下图中&lt;/p&gt;
&lt;p&gt;你需要自己识别有哪些子系统，涉及哪些相关的类和方法，你需要自己保证顺序（如果功能调用依赖顺序的话）&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181203141148810-414507572.png&quot;&gt;&lt;img title=&quot;image_5c04c84e_5ec&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181203141149037-821006651.png&quot; alt=&quot;image_5c04c84e_5ec&quot; width=&quot;509&quot; height=&quot;488&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;如同在医院里面，病人需要自己去排队挂号化验，跟每个流程的工作人员进行协作&lt;/p&gt;
&lt;p&gt;如同在工厂里面，需要生产一个桌子，你亲自用机器生产桌子腿，自己使用机器生产桌面...&lt;/p&gt;
&lt;p&gt;如同你去其他公司洽谈业务，你单独跟每个相关业务的人员进行联系沟通&lt;/p&gt;

&lt;p&gt;你肯定想得到，如果有一个中间人为你代劳&lt;/p&gt;
&lt;p&gt;不需要面对林林总总的子系统、部门、人员...&lt;/p&gt;
&lt;p&gt;当你需要某种服务时，只需要告诉这个中间人就好了&lt;/p&gt;
&lt;p&gt;这个想法就是外观模式&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181203141149229-36024418.png&quot;&gt;&lt;img title=&quot;image_5c04c84e_38cc&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181203141149427-1806895789.png&quot; alt=&quot;image_5c04c84e_38cc&quot; width=&quot;512&quot; height=&quot;570&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;有了facade，你就不需要跟每个子系统进行单独的交流了&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如同在医院里面，对于VIP，有专人代替你挂号.....&lt;/p&gt;
&lt;p&gt;如同在工厂里面，有一个控制台机器，你选择产品，控制台下发命令安排其他的机器生产具体产品&lt;/p&gt;
&lt;p&gt;如同你去其他公司洽谈业务，有一个接口人负责与你对接，他们那边的事情都通过这个人进行安排&lt;/p&gt;

&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181203141149661-1506450990.png&quot;&gt;&lt;img title=&quot;image_5c04c84e_22f4&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181203141149858-2128650931.png&quot; alt=&quot;image_5c04c84e_22f4&quot; width=&quot;594&quot; height=&quot;232&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;外观模式的意图含义，如同他的名字一样，“建筑物的正面”&lt;/p&gt;
&lt;p&gt;面对一个复杂的大楼，当你在正面远远望去，也就只能看到正面&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在外观模式中，形容一个庞大的复杂的系统的一个直观的界面&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;借助于Facade模式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;从原来的“客户端需要跟多个子系统进行交互”，&lt;/span&gt;&lt;span&gt;转变为&lt;/span&gt;&lt;span&gt;“只与Facade进行交互”&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将客户端与子系统进行解耦，&lt;span&gt;&lt;strong&gt;降低了耦合性，也降低了使用的复杂度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;21&quot;&gt;
&lt;h3&gt;&lt;span&gt;代码示例&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;“关好门窗，防火防盗”这句话有没有听过？&lt;/p&gt;
&lt;p&gt;回想一下，当你早上准备出门离开家时，你会做什么？&lt;/p&gt;
&lt;p&gt;假设你会关水、关灯、关门窗。&lt;/p&gt;
&lt;p&gt;我们创建三个类，水 灯 窗，模拟离开家的场景  &lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; facade;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Water {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; turnOn() {
        System.out.println(&lt;/span&gt;&quot;打开水龙头...&quot;&lt;span&gt;);
    }   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; turnOff() {
        System.out.println(&lt;/span&gt;&quot;关闭水龙头...&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; facade;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Light {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; turnOn() {
        System.out.println(&lt;/span&gt;&quot;开灯...&quot;&lt;span&gt;);
    } 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; turnOff() {
        System.out.println(&lt;/span&gt;&quot;关灯...&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; facade;
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Window {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; open() {
        System.out.println(&lt;/span&gt;&quot;开窗...&quot;&lt;span&gt;);
    } 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; close() {
        System.out.println(&lt;/span&gt;&quot;关窗...&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;p&gt;&lt;strong&gt;测试代码&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181203141150135-200465343.png&quot;&gt;&lt;img title=&quot;image_5c04c84f_e57&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181203141150335-74472955.png&quot; alt=&quot;image_5c04c84f_e57&quot; width=&quot;507&quot; height=&quot;579&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;上面的测试代码Test作为客户端程序，可以看得出来，他直接跟Water Light Window三个类的对象进行交互&lt;/p&gt;
&lt;p&gt;他需要调用相关的方法&lt;/p&gt;
&lt;p&gt;也就是说Test 作为客户端对于“离家”这一系统的内部逻辑是了如指掌的---&amp;gt;需要断水、关灯、关窗&lt;/p&gt;
&lt;p&gt;他也清楚每个类的方法&lt;/p&gt;
&lt;p&gt;一方面增加了耦合性，另一方面将子系统的内部细节暴露出来&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;优化重构&lt;/span&gt;&lt;/h4&gt;
&lt;/div&gt;
&lt;p&gt;试想下，如果你家是智能家居，有一个控制台Facade，或者说有一个手机App&lt;/p&gt;
&lt;p&gt;他可以控制整个家庭的设备&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; facade;
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Facade {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Water water = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Water();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Light light = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Light();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Window window = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Window();
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; leaveHome(){
        water.turnOff();
        light.turnOff();
        window.close();
    }
     
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; backHome(){
        light.turnOn();
        window.open();
    }
 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181203141150518-397025967.png&quot;&gt;&lt;img title=&quot;image_5c04c84f_780b&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181203141150735-843267340.png&quot; alt=&quot;image_5c04c84f_780b&quot; width=&quot;510&quot; height=&quot;367&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;通过这个控制台，客户端程序不再需要了解子系统的内部细节，他也不清楚每个类到底有哪些方法&lt;/p&gt;
&lt;p&gt;所有的交互都是通过Facade来完成的&lt;/p&gt;
&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;结构&lt;/span&gt;&lt;/h3&gt;
&lt;div&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181203141150908-2048266470.png&quot;&gt;&lt;img title=&quot;image_5c04c84f_7b08&quot; src=&quot;https://img2018.cnblogs.com/blog/897393/201812/897393-20181203141151322-1033174577.png&quot; alt=&quot;image_5c04c84f_7b08&quot; width=&quot;188&quot; height=&quot;243&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Facade 外观角色&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;客户端调用角色，知晓子系统的所有功能与职责&lt;/p&gt;
&lt;p&gt;通常，Facade会将所有的请求转发委派到子系统中去，也就是说该角色没有实际的业务、&lt;/p&gt;

&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;SubSystem子系统角色&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以同时有一个或者多个子系统&lt;/p&gt;
&lt;p&gt;注意   :子系统并不是说一个单独的类，而是一个类的集合，这些类根据逻辑功能点被组织在一起  &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;子系统并不知道Facade的存在，对于子系统来说，Facade也就只是一个客户端程序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;外观模式的结构比较简单，类似一个“封装”提取的过程&lt;/p&gt;
&lt;p&gt;他的&lt;span&gt;&lt;strong&gt;根本原则为迪米特法则&lt;/strong&gt;&lt;/span&gt;，也就是“&lt;span&gt;&lt;strong&gt;不要和陌生人说话&lt;/strong&gt;&lt;/span&gt;”，尽可能少的与其他的对象进行交互&lt;/p&gt;
&lt;p&gt;通过外观模式，做到了子系统只与外观对象交互&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;门面类个数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在门面模式中，通常只需要一个门面类，并且这个门面类只有一个实例&lt;/p&gt;
&lt;p&gt;换句话说他很可能是一个单例&lt;/p&gt;
&lt;p&gt;但是并不是说整个系统中只能有一个门面类&lt;/p&gt;
&lt;p&gt;门面类的个数要根据系统中子系统的个数以及业务逻辑的情况&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;当你&lt;span&gt;&lt;strong&gt;需要为一个复杂的子系统提供一个简单的接口时或者希望子系统能够更加独立时&lt;/strong&gt;&lt;/span&gt;，可以考虑使用外观模式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;借助于外观模式，可以实现客户端与子系统的解耦，减少客户端对子系统的依赖性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一旦完成解耦，就意味着子系统有良好的独立性，也能拥有更好的扩展性&lt;/p&gt;
&lt;p&gt;因为独立了，就意味着单独的子系统修改不会影响其他系统&lt;/p&gt;
&lt;p&gt;而且，&lt;span&gt;&lt;strong&gt;在多层次结构的系统中，可以使用Facade模式进行层与层之间的交互，将层与层之间的耦合性降低，使他们仅仅通过facade进行交互&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;总之一句话，降低了使用子系统的复杂程度，降低了耦合程度，满足迪米特法则----不要和陌生人说话 &lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;对客户端屏蔽了子系统的组件&lt;/p&gt;
&lt;p&gt;仅仅通过Facade，&lt;span&gt;&lt;strong&gt;大大减少了客户端所需要处理的对象的数目&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;对于外观模式，&lt;span&gt;&lt;strong&gt;如果是子系统发生变化，Facade则极有可能需要面临修改，这不符合开闭原则&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;外观模式（门面模式）就如同我们开篇的图片一样，作为公司前台&lt;/p&gt;
&lt;p&gt;接待来访宾客，一切事宜都有她来协调安排组织。&lt;/p&gt;
&lt;p&gt;在OOP中，这个“前台”不仅是一个子系统的“正面”看到的样子，而且还强调了她的全权负责&lt;/p&gt;
&lt;p&gt;她提供所有的业务需要的相关方法，尽管内部调用都是子系统中的方法，她提供简单一致的交流沟通形式 &lt;/p&gt;
&lt;p&gt;理解了迪米特法则，那么就比较容易理解外观模式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;外观模式重点在于提供一个“简化”“封装”后的操作控制台，让你更容易操作整个系统，他几乎不会涉及子系统的内部逻辑&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;否则，门面对象将与子系统的业务逻辑耦合，增加了耦合度。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Mon, 03 Dec 2018 06:21:00 +0000</pubDate>
<dc:creator>noteless</dc:creator>
<og:description>外观模式又称为门面模式Facade是一种简单的设计模式，但是他背后的思想为迪米特原则，理解门面模式更有助于理解迪米特原则--不要和陌生人说话的原则，可以降低系统的耦合程度，本文介绍了外观模式的意图，结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/noteless/p/10058164.html</dc:identifier>
</item>
</channel>
</rss>