<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【大数据实战】Logstash采集-&gt;Kafka-&gt;ElasticSearch检索 - Supernova-x</title>
<link>http://www.cnblogs.com/snova/p/9203425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snova/p/9203425.html</guid>
<description>&lt;p&gt; 　&lt;span&gt;Logstash的官网地址为：&lt;a title=&quot;https://www.elastic.co/cn/products/logstash&quot; href=&quot;https://www.elastic.co/cn/products/logstash&quot; target=&quot;_blank&quot;&gt;https://www.elastic.co/cn/products/logstash&lt;/a&gt;，以下是官方对Logstash的描述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180620194100925-1301768085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;&lt;strong&gt;Logstash是与Flume类似，也是一种数据采集工具，区别在于组件和特性两大方面&lt;/strong&gt;。常用的数据采集工具有Sqoop、Flume、Logstash，计划将单独写一篇博文论述它们之间的区别，所以这里就不赘述，感兴趣可关注后期的博文。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 　&lt;span&gt;Kafka的官网是：&lt;a title=&quot;http://kafka.apache.org/&quot; href=&quot;http://kafka.apache.org/&quot; target=&quot;_blank&quot;&gt;http://kafka.apache.org/&lt;/a&gt;，官方的介绍如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180621201952741-986157758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;总结来说，&lt;/strong&gt;Kafka是一个分布式消息队列，具有生产者和消费者的功能，它依赖Zookeeper集群来保存meta数据，根据Topic来归类存储的消息，Kafka集群由多个实例组成，每个实例称为broker。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　ElasticSearch是一个分布式的搜索和数据分析引擎&lt;/strong&gt;&lt;span&gt;。它的官网是：&lt;/span&gt;&lt;a title=&quot;https://www.elastic.co/cn/products/elasticsearch&quot; href=&quot;https://www.elastic.co/cn/products/elasticsearch&quot; target=&quot;_blank&quot;&gt;https://www.elastic.co/cn/products/elasticsearch&lt;/a&gt;&lt;span&gt;，官方对ElasticSearch的描述如下，通过官方的描述能够对ElasticSearch有一个整体的了解。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180620123325999-2000082661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 3.1 小项目介绍&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　在VM的linux本地logserver目录下存有模拟数据data.log，启动一个logstash监视Linux的logserver目录的data.log日志文件，当日志文件发生了修改，将日志文件采集到Kafka消息队列的名为logs的Topic中，另启动一个logstash将Kafka的消息采集到ElashticSearch，使用ElasticSearch检索数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180621230057959-24485728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 3.2 开发环境&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　系统环境： VM中存在三台Linux机器（bigdata12，bigdata14，bigdata15）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　软件环境：kafka_2.11-0.9.0.1、z&lt;/span&gt;&lt;span&gt;ookeeper-3.4.10、&lt;/span&gt;&lt;span&gt;elasticsearch-2.4.4、&lt;/span&gt;&lt;span&gt;logstash-2.3.1&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 3.3 环境准备&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　1. 首先在三台机器开启zookeeper&lt;/strong&gt;，各机器运行zkServer.sh start，Linux下查看是否有然后使用zkServer.sh status查看zookeeper的状态，如果看到leader和follower角色的出现就代表运行正常。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;2. 三台启动&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Kafka，&lt;/strong&gt;到kafka目录下，运行 nohup bin/kafka-server-start.sh conf/serverproperties.conf。使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;3. 使用&lt;span&gt;非root用户&lt;/span&gt;启动elasticsearch&lt;/strong&gt;，使用非root用户进入elasticsearch目录执行： bin/elasticsearch -d&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;&lt;strong&gt;【&lt;/strong&gt;注意&lt;/span&gt;】&lt;/span&gt;，必须是非root用户，否则会报错。如果没有，就创建一个用户。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    例如创建一个用户为zhou的话，执行：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 (1) 添加用户：useradd bigdata，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 (2) 为用户添加密码 ：echo 123456 | passwd --stdin zhou，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 (3) 将zhou添加到sudoers： echo &quot;bigdata ALL = (root) NOPASSWD:ALL&quot; | tee /etc/sudoers.d/zhou&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 (4) 修改权限： chmod 0440 /etc/sudoers.d/zhou&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 (5) 从root切换成zhou： su - zhou &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 (6) 然后再执行启动elasticsearch命令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;span&gt;&lt;strong&gt;4. 检查进程运行情况&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 在Linux环境下执行jps命令查看进程是否正常启动，每台机器查看是否有以下进程&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622131442540-1308421967.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　在elasticsearch安装了head的前提下，在windows环境开启浏览器，在地址栏输入http://ip地址:9200/_plugin/head ，例如，根据我的配置，输入了http://192.168.243.11:9200/_plugin/head。出现以下界面，表示Elasticsearch启动正常&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622131625079-1412265303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;在以上环节确认后，就代表环境启动运行正常，可以进行正常开发程序。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt; 3.4 开发&lt;/h2&gt;
&lt;h3&gt; 3.4.1 编写logstash配置&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　在&lt;strong&gt;bigdata12&lt;/strong&gt;机器中进入logstash的conf目录：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　vi dataTokafka.conf&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;input {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;  file {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         codec =&amp;gt;&lt;span&gt; plain {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         charset =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     path =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/root/logserver/supernova.log&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     discover_interval =&amp;gt; 5
&lt;span&gt; 8&lt;/span&gt;     start_position =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;beginning&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;output {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    kafka {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;           topic_id =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;supernova&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;           codec =&amp;gt;&lt;span&gt; plain {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;           format =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%{message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;           charset =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;           bootstrap_servers =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bigdata12:9092,bigdata14:9092,bigdata15:9092&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　在&lt;strong&gt;bigdata14&lt;/strong&gt;机器中进入logstash的conf目录：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 vi dataToElastic.conf&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;input {
  kafka {
    type &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;supernova&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    auto_offset_reset &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;smallest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    codec &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;plain&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    group_id &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;elas2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    topic_id &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;supernova&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    zk_connect &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bigdata12:2181,bigdata14:2181,bigdata15:2181&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }
}
filter {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [type] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;supernova&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {
    mutate {
      split &lt;/span&gt;=&amp;gt; { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
      add_field &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%{message[0]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%{message[1]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%{message[2]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%{message[3]}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
     }
     remove_field &lt;/span&gt;=&amp;gt; [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ]
   }
  }
}
output {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [type] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;supernova&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; {
    elasticsearch {
      index &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;supernova&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      codec &lt;/span&gt;=&amp;gt;&lt;span&gt; plain {
        charset &lt;/span&gt;=&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-16BE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      }
      hosts &lt;/span&gt;=&amp;gt; [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bigdata12:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bigdata14:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bigdata15:9200&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　3.4.2 运行&lt;/h3&gt;
&lt;p&gt;　&lt;span&gt;(1) 在bigdata12机器中，使用3.4.1中的dataTokakfa.conf启动logstash。执行：bin/logstash -f conf/dataTokakfa.conf，监听supernova.log文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　(2) 在bigdata14机器中，使用3.4.1中的dataToElastic.conf启动logstach。执行：bin/logstash -f conf/dataToElastic.conf，将Kafka数据采集到Elasticsearch。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　(3) 为了便于观察，在bigdata15机器中，启动kafka消费者，查看Topic中的数据。执行：bin/kafka-console-consumer.sh --zookeeper bigdata11:2181 --from-beginning --topic logs，用于消费Kafka中Topic名为logs的消息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　(4) 编辑修改Logstash监听的supernova.log文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　启动】：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622133049180-880159036.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 【修改】在bigdata15中修改了数据（右下角窗口）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622133301282-643947044.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;【监视过程】：bigdata15中（右上），kafka的consumer消费到了supernova.log文件中的数据，在bigdata14中，可以看到将数据传至ElasticSearch的数据（左下）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622133348629-1723201415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【ElasticSeach结果】&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　可以看到Elastic集群中，产生了一个supernova的type（类似关系数据库中的table）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622133538587-721097567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 【查看ElasticSearch数据】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622211019392-1670534924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;　3.4.2 ElasticSearch检索&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;    使用Junit单元测试的方法来编写测试方法，代码如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　EalsticSearch.java&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; novaself;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.action.search.SearchResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.client.Client;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.client.transport.TransportClient;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.common.settings.Settings;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.common.transport.InetSocketTransportAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.index.query.QueryBuilders;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.search.SearchHit;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.elasticsearch.search.SearchHits;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Before;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Iterator;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Supernova
 * @date 2018/06/22
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ElasticSearch  {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Client client;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取客户端
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Before
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; getClient() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ElasticSearch服务默认端口9300&lt;/span&gt;
        Settings settings =&lt;span&gt; Settings.settingsBuilder()
                .put(&lt;/span&gt;&quot;cluster.name&quot;, &quot;bigdata&quot;&lt;span&gt;).build();
        client &lt;/span&gt;=&lt;span&gt; TransportClient.builder().settings(settings).build()
                .addTransportAddress(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InetSocketTransportAddress(
                        InetAddress.getByName(&lt;/span&gt;&quot;bigdata12&quot;), 9300&lt;span&gt;))
                .addTransportAddress(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InetSocketTransportAddress(
                        InetAddress.getByName(&lt;/span&gt;&quot;bigdata14&quot;), 9300&lt;span&gt;))
                .addTransportAddress(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InetSocketTransportAddress(
                        InetAddress.getByName(&lt;/span&gt;&quot;bigdata15&quot;), 9300&lt;span&gt;));
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 词条查询: 用户名中有&quot;新&quot;字的数据
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testTermQuery(){
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * termQuery词条查询: 只匹配指定字段中含有该词条的文档
         * 查询user字段为超新星的记录
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        SearchResponse response &lt;/span&gt;= client.prepareSearch(&quot;supernova&quot;&lt;span&gt;)
                .setTypes(&lt;/span&gt;&quot;supernova&quot;&lt;span&gt;)
                .setQuery(QueryBuilders.termQuery(&lt;/span&gt;&quot;user&quot;,&quot;新&quot;&lt;span&gt;))
                .get();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取结果集对象、命中数&lt;/span&gt;
        SearchHits hits =&lt;span&gt; response.getHits();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用迭代器遍历数据&lt;/span&gt;
        Iterator&amp;lt;SearchHit&amp;gt; iter =&lt;span&gt; hits.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(iter.hasNext()){
            SearchHit hit &lt;/span&gt;=&lt;span&gt; iter.next();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以Json格式输出&lt;/span&gt;
            String result =&lt;span&gt; hit.getSourceAsString();
            System.out.println(result);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭客户端&lt;/span&gt;
&lt;span&gt;        client.close();
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 模糊查询: 星期四的数据
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testWildcardQuery() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
         * wildcardQuery模糊查询,time字段中包含&quot;四&quot;的数据
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        SearchResponse response &lt;/span&gt;= client.prepareSearch(&quot;supernova&quot;&lt;span&gt;)
                .setTypes(&lt;/span&gt;&quot;supernova&quot;&lt;span&gt;)
                .setQuery(QueryBuilders.wildcardQuery(&lt;/span&gt;&quot;time&quot;,&quot;四&quot;&lt;span&gt;))
                .get();


        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取结果集对象、命中数&lt;/span&gt;
        SearchHits hits =&lt;span&gt; response.getHits();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用迭代器遍历数据&lt;/span&gt;
        Iterator&amp;lt;SearchHit&amp;gt; iter =&lt;span&gt; hits.iterator();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(iter.hasNext()){
            SearchHit hit &lt;/span&gt;=&lt;span&gt; iter.next();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以Json格式输出&lt;/span&gt;
            String result =&lt;span&gt; hit.getSourceAsString();
            System.out.println(result);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭客户端&lt;/span&gt;
&lt;span&gt;        client.close();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;【检索结果】：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  词条查询：testTermQuery( )方法的运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622223520972-2129699292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;模糊查询：testWildcardQuery ( )方法的运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1424242/201806/1424242-20180622223640656-1909214688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 22 Jun 2018 14:45:00 +0000</pubDate>
<dc:creator>Supernova-x</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snova/p/9203425.html</dc:identifier>
</item>
<item>
<title>Web自动化测试环境搭建1（基于firefox火狐浏览器） - 韬哥（NickJiang）</title>
<link>http://www.cnblogs.com/nickjiang/p/9215587.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nickjiang/p/9215587.html</guid>
<description>&lt;p&gt;　　自动化测试是时代趋势，因此很多测试人员开始研究自动化测试，web自动化测试化测试并不难，但是很多人都是被挡在了环境搭建这一步，后面学习激情全无，这里，韬哥手把手教大家搭建火狐浏览器下的自动化测试环境（基于java）。&lt;/p&gt;
&lt;p&gt;　　为什么搭建自动化测试环境难呢，因为环境要求高，selenium版本，驱动文件版本，浏览器版本这中间有适配问题，如果没注意这些版本信息，就可能导致web自动化程序就跑不起来。&lt;/p&gt;
&lt;p&gt;　　下面将为大家演示selenium 3.x下的火狐自动化自动化环境搭建：&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;1.准备selenium 3.5.1，maven下的依赖信息如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.seleniumhq.selenium&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;selenium-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.5.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;2.准备火狐驱动文件geckodriver.exe&lt;/span&gt;（从selenium 3.0开始火狐浏览器的自动化就需要驱动文件来驱动了），这里准备的驱动文件版本为0.19.0，大家可以自己去selenium官网下载，或者直接使用老师给大家分享的网盘地址去下载【链接：https://pan.baidu.com/s/1oN8tg66cobM7yX-T6GKuFw 密码：9rb7】&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416840/201806/1416840-20180622212109028-174916272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　另外大家记得把火狐浏览器的版本更换为56（并且&lt;span&gt;禁止浏览器更新功能&lt;/span&gt;，防止浏览器后台自动更新版本，至于怎么禁止，很简单的事情，pls自行百度），因为根据geckodriver的change log建议，0.19.0版本的驱动最好是适配：Firefox 55.0 （或更高）+ Selenium 3.5（或更高），这就是为什么上面为什么用selenium3.5.1。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416840/201806/1416840-20180622213517757-525073017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　以下为大家整理火狐的各版本下载链接：【http://ftp.mozilla.org/pub/firefox/releases/】，或者大家可以直接去我的网盘下载：【链接：https://pan.baidu.com/s/1xMBkf_ViIV_RyFGN2V-Qaw 密码：eyo6】&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416840/201806/1416840-20180622214137069-743808051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;3.验证代码&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; web.demo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.WebDriver;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.openqa.selenium.firefox.FirefoxDriver;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.testng.annotations.AfterClass;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.testng.annotations.BeforeClass;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.testng.annotations.Test;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;火狐的自动化测试环境搭建
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; NickJiang
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FirefoxAuto {
    WebDriver driver;
    @BeforeClass
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(){
        System.setProperty(&lt;/span&gt;&quot;webdriver.gecko.driver&quot;, &quot;src/test/resources/geckodriver.exe&quot;&lt;span&gt;);
        driver &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FirefoxDriver();
    }
    
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test(){
        driver.get(&lt;/span&gt;&quot;http://www.baidu.com&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;打开网站等待3秒后再关闭&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;3000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
    }
    
    @AfterClass
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; teardown(){
        driver.quit();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;驱动文件存放目录：src/test/resources/geckodriver.exe，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416840/201806/1416840-20180622213104498-1686966173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;4.效果如下，意味着环境搞定：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1416840/201806/1416840-20180622213147997-1849763189.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 至此，基于java+selenium 3.x的火狐自动化测试环境就准备好了。java+selenium 2.x 后面会择时为大家补充。下一篇将为大家带来chrome下自动化环境搭建。&lt;/p&gt;

</description>
<pubDate>Fri, 22 Jun 2018 13:46:00 +0000</pubDate>
<dc:creator>韬哥（NickJiang）</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nickjiang/p/9215587.html</dc:identifier>
</item>
<item>
<title>机器学习基本概念 - 大雄的学习人生</title>
<link>http://www.cnblogs.com/codernie/p/9215365.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codernie/p/9215365.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;Machine Learning：&lt;/strong&gt;A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一什么是机器学习what&quot;&gt;一、什么是机器学习？（What）&lt;/h3&gt;
&lt;p&gt;上面的概念那面有些抽象，要理解什么是机器学习，其实可以类比于人类的学习。假设一个场景：父母教三岁大的孩子认识什么是西瓜。首先父母要给孩子看西瓜，然后告诉孩子这个是西瓜。这个过程抽象成下面这张流程图：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12275140-0193df47d07fda6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;what is machine learning.png&quot;/&gt;&lt;br/&gt;孩子的学习过程是通过一些观察，然后加上自我总结，就逐渐拥有了识别什么是西瓜的技能。&lt;br/&gt;与之相类似，机器学习就是通过对数据的“学习”，从而拥有某些特定技能的过程。（那技能是什么呢？技能是某种表现的增进，例如我通过天天练习投篮，逐渐命中率达到一定水准，我就拥有了投篮技能。）&lt;/p&gt;
&lt;h3 id=&quot;二为什么要使用机器学习why&quot;&gt;二、为什么要使用机器学习？（Why）&lt;/h3&gt;
&lt;p&gt;对于不同的问题，我们选择机器学习的原因不同，这些问题按照对于人类的难易来说，可以分为两类：&lt;br/&gt;&lt;strong&gt;1.很简单的问题：&lt;/strong&gt;&lt;br/&gt;例如：识别手写的数字是几，这对于人类来说是一个极易的问题，那为什么我们还要使用机器学习呢？因为通过机器学习的方式，&lt;strong&gt;我们可以让机器来帮我们做这些“单调乏味”的工作&lt;/strong&gt;，让机器掌握识别手写数字的技能之后，我们就能让他们帮我们来分拣信件。如果把这项技能再进一步，让机器掌握识别并理解地址信息，我们甚至可以用机器来分拣快递。&lt;br/&gt;&lt;strong&gt;2.很复杂的问题：&lt;/strong&gt;&lt;br/&gt;例如：根据用户信息，给不同的用户推荐不同的广告。对于人类来说，这几乎是不可能的问题，因为不同的用户有不同的特征，怎么从这些海量的特征中判断每一个用户的喜好是什么呢？并且用户的喜好可能还在发生变化，举个通俗一点的例子，比如某些用户去年还喜欢吃西瓜，今年就讨厌西瓜了。因此，&lt;strong&gt;从海量的数据中去人为的总结规律有很大的局限性，而使用机器学习的方式使得这类问题变得简单。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;三什么时候可以使用机器学习when&quot;&gt;三、什么时候可以使用机器学习？（When）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.存在某些隐含的模式（underlying pattern）可以被学习到。&lt;/strong&gt;&lt;br/&gt;举一个反例：预测某个婴儿下一次哭是奇数分钟哭，还是偶数分钟哭。这几乎是一个随机事件，所以不存在任何隐含的模式，因此也就不能使用机器学习的方式来解答。&lt;br/&gt;&lt;strong&gt;2.不是很容易总结规律的问题。&lt;/strong&gt;&lt;br/&gt;如果规律很容易总结，那当然就不用使用机器学习了，直接代码实现即可。&lt;br/&gt;&lt;strong&gt;3.有相关的数据。&lt;/strong&gt;&lt;br/&gt;举一个反例：预测世界末日什么时候到来。显然，因为我们没有世界末日发生的相关数据，所以这个问题也无法用机器学习的方式来解答。&lt;/p&gt;
&lt;h3 id=&quot;四机器学习的组成&quot;&gt;四、机器学习的组成&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/12275140-94b1082fb08d8e73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;machine learning combination.png&quot;/&gt;&lt;br/&gt;上图可以看作是整个机器学习过程的组成。&lt;br/&gt;首先从我们的数据出发，它们的具体形式是x到y的映射，比如我们的问题是预测某套房子的房价。那么我的X包括房子面积、房子楼层、是否是电梯房等等特征，Y就是房子的价格。正因为存在某种规律，才使得我们获得的数据按照训练集的每一个x对应唯一一个y。我们用 f 来表示这个X到Y的映射关系(即隐含规律)。&lt;br/&gt;那么如何去求得这个 f 呢？一般地，我们首先会把范围扩大到一个假设集合（称作 H ），比如我们假设房子价格与它的所有特征都是呈线性关系，那么这个假设集合就是一个线性假设集，那如何在这个无限大的假设集 H 中找到我们想要得到的 f 呢，那就需要通过机器学习演算法来实现，我们用 A 表示这个算法。&lt;br/&gt;那这样我们就能求得 f 了吗？答案是否定的，因为很多时候由于数据噪声等原因，我们无法获得一个精确的 f ,而只能获得某一个映射关系 g ，使得 g 最接近这个 f，我们把这个 g 称为最终预测。&lt;br/&gt;&lt;strong&gt;一般地，机器学习为了求得隐含的规律，在假设集合上通过演算法对训练集进行“训练”，使求得的预测规律最接近隐含规律。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;五机器学习数据挖掘人工智能统计学的关系&quot;&gt;五、机器学习、数据挖掘、人工智能、统计学的关系&lt;/h3&gt;
&lt;h5 id=&quot;机器学习&quot;&gt;机器学习：&lt;/h5&gt;
&lt;p&gt;利用数据计算出一个近似隐含规律的预测规律。&lt;/p&gt;
&lt;h5 id=&quot;数据挖掘&quot;&gt;数据挖掘：&lt;/h5&gt;
&lt;p&gt;利用海量的数据去寻找一些有意思的数据特征、规律。&lt;br/&gt;&lt;strong&gt;机器学习与数据挖掘的关系：&lt;/strong&gt;&lt;br/&gt;如果数据挖掘的目标是去寻找数据间的隐含规律，那么数据挖掘和机器学习做的事情是一样的。但是传统的数据挖掘总是着眼于大数据的高效计算。（比如分布式计算框架）&lt;/p&gt;
&lt;h5 id=&quot;人工智能&quot;&gt;人工智能：&lt;/h5&gt;
&lt;p&gt;让计算机做(模拟)一些像人一样的智能行为。&lt;br/&gt;&lt;strong&gt;机器学习与人工智能的关系：&lt;/strong&gt;&lt;br/&gt;机器学习是实现人工智能的一种途径，除此之外，还有一些其他的方式可以实现人工智能。&lt;/p&gt;
&lt;h5 id=&quot;统计学&quot;&gt;统计学：&lt;/h5&gt;
&lt;p&gt;利用数据对一些未知的过程做预测。&lt;br/&gt;&lt;strong&gt;机器学习与统计学的关系：&lt;/strong&gt;&lt;br/&gt;统计学的很多知识都可以被借鉴到机器学习中，但是机器学习中也有很多算法不是基于统计学的规律的。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;br/&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=nQvpFSMPhr0&amp;amp;list=PLXVfgk9fNX2I7tB6oIINGBmW50rrmFTqf&amp;amp;index=1&quot;&gt;《机器学习基石》【林轩田】(来源于Youtube)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Jun 2018 12:37:00 +0000</pubDate>
<dc:creator>大雄的学习人生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/codernie/p/9215365.html</dc:identifier>
</item>
<item>
<title>我是如何用redis做实时订阅推送的 - 我是林林</title>
<link>http://www.cnblogs.com/linlinismine/p/9214299.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linlinismine/p/9214299.html</guid>
<description>&lt;p&gt;      &lt;strong&gt;前阵子开发了公司领劵中心的项目，这个项目是以redis作为关键技术落地的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      先说一下领劵中心的项目吧，这个项目就类似京东app的领劵中心，当然图是截取京东的，公司的就不截了。。。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://images2018.cnblogs.com/blog/905730/201806/905730-20180622150051254-473108734.png&quot; alt=&quot;&quot; width=&quot;266&quot; height=&quot;472&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;  其中有一个功能叫做领劵的订阅推送。什么是领劵的订阅推送？就是用户订阅了该劵的推送，在可领取前的一分钟就要把提醒信息推送到用户的app中。本来这个订阅功能应该是消息中心那边做的，但他们说这个短时间内做不了。所以让我这个负责优惠劵的做了-.-!。具体方案就是到具体的推送时间点了，coupon系统调用消息中心的推送接口，把信息推送出去。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;     下们我们分析一下这个功能的业务情景。公司目前注册用户6000W+，是哪家就不要打听了。。。比如有一张无门槛的优惠劵下单立减20元，那么抢这张劵的人就会比较多，我们保守估计10W+，百万级别不好说。我们初定为20W万人，那么这20W条推送信息要在一分钟推送完成！并且一个用户是可以订阅多张劵的。所以我们知道了这个订阅功能的有两个突出的难点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt; 1、推送的实效性：推送慢了，用户会抱怨没有及时通知他们错过了开抢时机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;     2、推送的体量大：爆款的神劵，人人都想抢！&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      然而推送体量又会影响到推送的实效性。这真是一个让人头疼的问题！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;     那就让我们把问题一个个解决掉吧！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;     推送的实效性的问题：当用户在领劵中心订阅了某个劵的领取提醒后，在后台就会生成一条用户的订阅提醒记录，里面记录了在哪个时间点给用户发送推送信息。所以问题就变成了系统如何快速实时选出哪些要推送的记录！&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;    方案1：MQ的延迟投递。MQ虽然支持消息的延迟投递但尺度太大1s 5s 10s 30s 1m，用来做精确时间点投递不行！并且用户执行订阅之后又取消订阅的话，要把发出去的MQ消息delete掉这个操作有点头大，短时间内难以落地！并且用户可以取消之后再订阅，这又涉及到去重的问题。所以MQ的方案否掉。&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;   方案2：传统定时任务。这个相对来说就简单一点，用定时任务是去db里面load用户的订阅提醒记录，从中选出当前可以推送的记录。但有句话说得好任何脱离实际业务的设计都是耍流氓~。下面我们就分析一下传统的定时任务到底适不适合我们的这个业务!&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;能否支持多机同时跑&lt;/td&gt;
&lt;td&gt;一般不能，同一时刻只能单机跑。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;存储数据源&lt;/td&gt;
&lt;td&gt;一般是mysql或者其它传统数据库，并且是单表存储&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;频率&lt;/td&gt;
&lt;td&gt;支持秒、分、时、天，一般不能太快&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;        &lt;strong&gt;总上所述我们就知道了一般传统的定时任务存在以下缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       1、性能瓶颈。只有一台机在处理，在大体量数据面前力不从心！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       2、实效性差。定时任务的频率不能太高，太高会业务数据库造成很大的压力！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       3、单点故障。万一跑的那台机挂了，那整个业务不可用了-。- 这是一个很可怕的事情！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;        所以传统定时任务也不太适合这个业务。。。 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;   那我们是不是就束手无策了呢？其实不是的! 我们只要对传统的定时任务做一个简单的改造！就可以把它变成可以同时多机跑,并且实效性可以精确到秒级，并且拒绝单点故障的定时任务集群！这其中就要借助我们的强大的redis了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案3：定时任务集群&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     首先我们要定义定时任务集群要解决的三个问题！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     1、&lt;/strong&gt;&lt;strong&gt;实效性要高&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;     2、吞吐量要大&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;     3、服务要稳定，不能有单点故障 &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     下面是整个定时任务集群的架构图。&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;img src=&quot;https://images2018.cnblogs.com/blog/905730/201806/905730-20180622165043391-1952143442.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;400&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt; 架构很简单：我们把用户的订阅推送记录存储到redis集群的sortedSet队列里面,并且以提醒用户提醒时间戳作为score值，然后在我们个每业务server里面起一个定时器频率是秒级，我的设定就是1s，然后经过负载均衡之后从某个队列里面获取要推送的用户记录进行推送。下面我们分析以下这个架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    1、性能：除去带宽等其它因素，基本与机器数成线性相关。机器数量越多吞吐量越大，机器数量少时相对的吞吐量就减少。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    2、实效性：提高到了秒级，效果还可以接受。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    3、单点故障？不存在的！除非redis集群或者所有server全挂了。。。。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;    这里解析一下为什么用redis？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    第一redis 可以作为一个高性能的存储db，性能要比MySQL好很多，并且支持持久化，稳定性好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    第二redis &lt;/strong&gt;&lt;strong&gt;SortedSet队列天然支持以时间作为条件排序，完美满足我们选出要推送的记录。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    ok~既然方案已经有了那如何在一天时间内把这个方案落地呢？是的我设计出这个方案到基本编码完成，时间就是一天。。。 因为时间太赶鸟。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     首先我们以user_id作为key，然后mod队列数hash到redis SortedSet队列里面。为什么要这样呢，因为如果用户同时订阅了两张劵并且推送时间很近，这样的两条推送就可以合并成一条~，并且这样hash也相对均匀&lt;/strong&gt;。下面是部分代码的截图：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/905730/201806/905730-20180622193616161-1305837647.png&quot; alt=&quot;&quot; width=&quot;563&quot; height=&quot;36&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;  然后要决定队列的数量，一般正常来说我们有多少台处理的服务器就定义多少条队列。因为队列太少，会造成队列竞争，太多可能会导致记录得不到及时处理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    然而最佳实践是队列数量应该是可动态配置化的，因为线上的集群机器数是会经常变的。大促的时候我们会加机器是不是，并且业务量增长了，机器数也是会增加是不是~。所以我是借用了淘宝的diamond进行队列数的动态配置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/905730/201806/905730-20180622195406550-1920335557.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;71&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    我们每次从队列里面取多少条记录也是可以动态配置的 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/905730/201806/905730-20180622195640651-1006475124.png&quot; alt=&quot;&quot; width=&quot;531&quot; height=&quot;50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;   这样就可以随时根据实际的生产情况调整整个集群的吞吐量~。  所以我们的定时任务集群还是具有一个特性就是支持动态调整~。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;   最后一个关键组件就是负载均衡了。这个是非常重要的！因为这个做得不好就会可能导致多台机竞争同时处理一个队列，影响整个集群的效率！在时间很紧的情况下我就用了一个简单实用的利用redis一个自增key 然后 mod 队列数量算法。这样就很大程度上就保证不会有两台机器同时去竞争一条队列~.&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/905730/201806/905730-20180622200223808-1322979237.png&quot; alt=&quot;&quot; width=&quot;853&quot; height=&quot;50&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;最后我们算一下整个集群的吞吐量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     10（机器数） * 2000（一次拉取数） = 20000。然后以MQ的形式把消息推送到消息中心，发MQ是异步的，算上其它处理0.5s。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     其实发送20W的推送也就是10几s的事情。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;ok~ 到这里我们整个定时任务集群就差不多基本落地好了。如果你问我后面还有什么可以完善的话那就是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    1、加监控， 集群怎么可以木有监控呢，万一出问题有任务堆积怎么办~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    2、加上可视化界面。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    3、最好有智能调度，增加任务优先级。优先级高的任务先运行嘛。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    4、资源调度，万一机器数量不够，力不从心，优先保证重要任务执行。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;     目前项目已上前线，运行平稳~。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;      &lt;/strong&gt;&lt;/p&gt;


</description>
<pubDate>Fri, 22 Jun 2018 12:35:00 +0000</pubDate>
<dc:creator>我是林林</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linlinismine/p/9214299.html</dc:identifier>
</item>
<item>
<title>移动端常见问题处理 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/8955331.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/8955331.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　本文将详细介绍移动web开发中的常见问题&lt;/p&gt;

&lt;h3&gt;Input&lt;/h3&gt;
&lt;p&gt;【光标颜色】&lt;/p&gt;
&lt;p&gt;　　默认情况下，光标颜色与字体颜色color相同，但也可以通过caret-color属性来单独设置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
caret-&lt;span&gt;color: auto;
caret&lt;/span&gt;-&lt;span&gt;color: transparent;
caret&lt;/span&gt;-&lt;span&gt;color: currentColor;
caret&lt;/span&gt;-&lt;span&gt;color: red;
caret&lt;/span&gt;-&lt;span&gt;color: #5729e9;
caret&lt;/span&gt;-color: rgb(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
caret&lt;/span&gt;-color: hsla(&lt;span&gt;228&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;%, &lt;span&gt;24&lt;/span&gt;%, &lt;span&gt;0.8&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　但是，IOS的光标不支持caret-color，与字体颜色无关，默认为紫蓝色。所以，尽量不要设置蓝色或紫色背景，否则光标看不清楚&lt;/p&gt;
&lt;p&gt;【光标高度】&lt;/p&gt;
&lt;p&gt;　　input域的光标高度与行高line-height相同，所以不要设置太高的行高，可以通过设置上下padding来撑开高度&lt;/p&gt;
&lt;p&gt;【放大】&lt;/p&gt;
&lt;p&gt;　　IOS下，input获取焦点时会放大，meta设置user-scalable=no，可取消放大效果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width=device-width, initial-scale=1, user-scalable=no, shrink-to-fit=no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【自动大写】&lt;/p&gt;
&lt;p&gt;　　一般地，IOS下默认开启键盘的首字母自动大写功能，这样输入英文的时候，首字母便会自动大写&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/cap1.png&quot; alt=&quot;大写&quot; width=&quot;640&quot; height=&quot;590&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　但是，有些时候并不希望一直是首字母大写的。比如用户名这个字段，如果字段本身就是区分大小写的，首字母自动大写往往会给用户带来麻烦。可以通过在表单元素上可以通过设置&lt;code&gt;autocapitalize=&quot;off&quot;&lt;/code&gt;来关闭&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;input type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; autocapitalize=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;off&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【圆角】&lt;/p&gt;
&lt;p&gt;　　IOS下，input域只显示底边框时，会出现两个底部底边圆角效果，设置border-radius:0即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
border-radius:&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【自动保存】&lt;/p&gt;
&lt;p&gt;　　input域默认会开启自动保存功能，可以使用autocomplete=&quot;off&quot;属性将其关闭&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;input autocomplete=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;off&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　要特别注意的是，如果使用react框架，需要将autocomplete替换为autoComplete这种小驼峰形式&lt;/p&gt;
&lt;p&gt;【轮廓outline】&lt;/p&gt;
&lt;p&gt;　　android浏览器下，input域处于焦点状态时，默认会有一圈淡黄色的轮廓outline效果&lt;/p&gt;
&lt;p&gt;　　通过设置outline:none可将其去除&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
outline: none
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【虚拟键盘】&lt;/p&gt;
&lt;p&gt;　　IOS弹出虚拟键盘不影响可视区域大小，而android手机弹出虚拟键盘时会影响。所以，最好将包含input域的页面高度设为固定&lt;/p&gt;
&lt;p&gt;　　在页面初始化时，获取页面高度&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
// app.js
&lt;span&gt;  componentDidMount() {
    const { setWrapSize } = this&lt;span&gt;.props
    const { clientHeight, clientWidth } =&lt;span&gt; document.documentElement
    setWrapSize({ clientHeight, clientWidth })
    window.addEventListener('orientationchange', this&lt;span&gt;.setSize)
  }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后通过行间样式，将此高度设置到包含input域的页面上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
// BaseFullScreen
&amp;lt;Wrap className={className} style={{ height: `${wrapHeight}px` }} {...rest}&amp;gt;{children}&amp;lt;/Wrap&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;522&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;样式&lt;/h3&gt;
&lt;p&gt;【点击背景】&lt;/p&gt;
&lt;p&gt;　　在移动端，点击可点击元素时，android下会出现淡蓝色背景，IOS下会出现灰色背景&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/bg.gif&quot; alt=&quot;bg&quot; width=&quot;160&quot; height=&quot;151&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　可以通过-webkt-tap-hightlight-color属性的设置，取消点击时出现的背景效果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
*&lt;span&gt; {
  &lt;/span&gt;-webkit-tap-highlight-color: rgba(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【appearance】&lt;/p&gt;
&lt;p&gt;　　使用appearance:none主要用来去除表单类元素的中浏览器内置样式，如去除data类型input域的叉叉，去除number类型input域的上下箭头等&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
-webkit-appearance: none;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【禁止选中】&lt;/p&gt;
&lt;p&gt;　　有时不希望用户在网站上选择文本，或许是出于版权的原因，如电子书网站。通常使用js来实现&lt;/p&gt;
&lt;p&gt;　　另一个方案就是，将-webkit-user-select设为none&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
-webkit-user-&lt;span&gt;select&lt;/span&gt;：none;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【禁止文字缩放】&lt;/p&gt;
&lt;p&gt;　　部分手机上，切换横竖屏时，会缩放字体。使用如下设置，可以禁止文字缩放&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
* &lt;span&gt;{
  &lt;/span&gt;-webkit-text-size-adjust:&lt;span&gt;100&lt;/span&gt;%&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【文本渲染】&lt;/p&gt;
&lt;p&gt;　　使用text-rendering:optimizeLegibility属性，可以让浏览器在绘制文本时将着重考虑易读性，而不是渲染速度和几何精度.它会使字间距和连字有效&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
text-rendering: optimizeLegibility;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该属性在移动设备上会造成比较明显的性能问题&lt;/p&gt;
&lt;p&gt;【文本平滑显示】&lt;/p&gt;
&lt;p&gt;　　-webkit-font-smoothing属性可以用来控制字体的像素显示是否平滑&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;none 关闭抗锯齿，字体边缘犀利。
antialiased 字体像素级平滑，在深色背景上会让文字看起来更细了
subpixel&lt;/span&gt;-antialiased 字体亚像素级平滑，主要为了在非视网膜设备下更好的显示
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
body { -webkit-font-smoothing: antialiased; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【轮廓outline】&lt;/p&gt;
&lt;p&gt;　　input、textarea等表单类标签，在获取焦点的情况下，在andriod系统下，会出现淡黄色轮廓outline，使用outline:none将其去除&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
outline: none
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【placeholder】&lt;/p&gt;
&lt;p&gt;　　placeholder默认是浅灰色，如果input域是浅灰色背景，则这时placeholder的文本与背景颜色相近，无法清晰显示，就需要设置placeholder的颜色&lt;/p&gt;
&lt;p&gt;　　可以通过伪元素来进行设置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;::placeholder {
    color: #fff;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【清除按钮圆角】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;input,button{
  &lt;/span&gt;-webkit-&lt;span&gt;appearance:none;
  border&lt;/span&gt;-radius:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;【滚动回弹】&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;　　-webkit-overflow-scrolling 属性控制元素在移动设备上是否使用滚动回弹效果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;auto 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止
touch 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;body {
  &lt;/span&gt;-webkit-overflow-&lt;span&gt;scrolling: touch;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;【1倍行高】&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;　　设置line-height:1，即行高为1时，有的页面会出现文字显示不全的情况，所以行高设置一定要大于1&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;1像素边框&lt;/h3&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;　　由于retina屏的原因，1px 的 border 会显示成两个物理像素，所以看起来会感觉很粗，这是一个移动端开发常见的问题&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;　　解决方案有很多，但都有自己的优缺点&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;　　1、0.5px 边框&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;　　从iOS 8开始，iOS 浏览器支持 0.5px 的 border，但是在 Android 上是不支持的，0.5px 会被认为是 0px，所以这种方法，兼容性很差&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;　　2、背景渐变&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;　　CSS3 有了渐变背景，可以通过渐变背景实现 1px 的 border，实现原理是设置 1px 的渐变背景，50% 有颜色，50% 是透明的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@mixin commonStyle() {
  background&lt;/span&gt;-size: &lt;span&gt;100&lt;/span&gt;% 1px,1px &lt;span&gt;100&lt;/span&gt;% ,&lt;span&gt;100&lt;/span&gt;% 1px, 1px &lt;span&gt;100&lt;/span&gt;%&lt;span&gt;;
  background&lt;/span&gt;-repeat: no-&lt;span&gt;repeat;
  background&lt;/span&gt;-&lt;span&gt;position: top, right top,  bottom, left top;
}
@mixin border($border&lt;/span&gt;-&lt;span&gt;color) {
  @include commonStyle();
  background&lt;/span&gt;-image:linear-gradient(180deg, $border-color, $border-color &lt;span&gt;50&lt;/span&gt;%, transparent &lt;span&gt;50&lt;/span&gt;%&lt;span&gt;),
  linear&lt;/span&gt;-gradient(270deg, $border-color, $border-color &lt;span&gt;50&lt;/span&gt;%, transparent &lt;span&gt;50&lt;/span&gt;%&lt;span&gt;),
  linear&lt;/span&gt;-gradient(0deg, $border-color, $border-color &lt;span&gt;50&lt;/span&gt;%, transparent &lt;span&gt;50&lt;/span&gt;%&lt;span&gt;),
  linear&lt;/span&gt;-gradient(90deg, $border-color, $border-color &lt;span&gt;50&lt;/span&gt;%, transparent &lt;span&gt;50&lt;/span&gt;%&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3、伪类 + transform&lt;/p&gt;
&lt;p&gt;　　这类方法的实现原理是用伪元素高度设置为1px，然后用 transform缩小到原来的一半&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div {
  position: relative;
  &lt;/span&gt;&amp;amp;&lt;span&gt;::after {
    position: absolute;
    left: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    right: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    height: 1px;
    transform: scaleY(.&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
    content: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;;
  }
`&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;布局&lt;/h3&gt;
&lt;p&gt;【vh】&lt;/p&gt;
&lt;p&gt;　　页面使用vh来控制元素高度的时候，在安卓端浏览器虚拟键盘弹出时，导致视口高度改变，以至于vh的取值改变&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正常模式下&lt;/span&gt;
100vh =&lt;span&gt; document.documentElement.clientHeight;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 安卓端弹出虚拟键盘情况下&lt;/span&gt;
100vh = document.documentElement.clientHeight - 虚拟键盘的高度;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这种情况导致了在虚拟键盘弹出时，页面中使用vh定高的元素的大小被压缩，造成布局错位以及文字溢出&lt;/p&gt;
&lt;p&gt;　　所以，最好将包含input域的页面高度设为固定&lt;/p&gt;
&lt;p&gt;【100%与100vh】&lt;/p&gt;
&lt;p&gt;　　100vh指的是视口，即屏幕高度的100%，不仅包括浏览器可视高度，还包括浏览器地址栏高度。而100%高度，是页面高度的100%&lt;/p&gt;
&lt;p&gt;　　所以，在全屏情况下，100vh等于100%高度，否则，100vh大于100%高度&lt;/p&gt;
&lt;p&gt;【高度无效】&lt;/p&gt;
&lt;p&gt;　　在IOS下，设置height:100%，如果父级的flex值为1，而没有设置具体高度，则100%高度设置无效&lt;/p&gt;
&lt;p&gt;　　处理方法是，在父级通过计算来设置具体高度height，如height: calc(100% - 100px)&lt;/p&gt;

&lt;h3&gt;事件&lt;/h3&gt;
&lt;p&gt;【鼠标事件】&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;522&quot;&gt;　　由于移动设备没有鼠标，所以与电脑端有一些不同之处&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;524&quot;&gt;　　1、不支持dblclick双击事件。在移动设备中双击浏览器窗口会放大画面&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;526&quot;&gt;　　2、单击元素会触发mousemove事件&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;　　3、两个手指放在屏幕上且页面随手指移动而滚动时会触发mousewheel和scroll事件&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;【touch事件】&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;　　新版的chrome下，不支持直接给document和body设置touch事件，所以下列代码无效&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
document.addEventListener(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;touchstart&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, function(e) {
  e.preventDefault();
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;图片&lt;/h3&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;【SVG】&lt;/p&gt;
&lt;p&gt;　　SVG图片由于其矢量的性质，缩放不失真，则代码量较少，大量地应用在小图标上。但在使用的过程中，有一些要注意的地方&lt;/p&gt;
&lt;p&gt;　　1、在伪类中添加SVG，在IOS下svg不显示&lt;/p&gt;
&lt;p&gt;　　2、在页面中添加SVG，在android的微信中下会出现设置透明度opacity的元素有的不显示的情况，所以尽量不设置透明度&lt;/p&gt;
&lt;p&gt;　　3、在mask属性中设置SVG，可以通过background-color给SVG变换颜色&lt;/p&gt;
&lt;p&gt;【base64】&lt;/p&gt;
&lt;p&gt;　　要特别注意的是，图片变化base64格式之后，再添加查询字符串，会报错&lt;/p&gt;
&lt;p&gt;【缓存】&lt;/p&gt;
&lt;p&gt;　　移动端更改同名图片无法清除缓存。所以，还是要在图片命名上做文章&lt;/p&gt;

&lt;h3&gt;meta&lt;/h3&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;【shrink-to-fit=no】&lt;/p&gt;
&lt;p class=&quot;code-line&quot; data-line=&quot;528&quot;&gt;　　IOS9+系统下，使用Viewport元标记&quot;width=device-width&quot;会导致页面缩小以适应溢出视口边界的内容。可以通过添加&quot;shrink-to-fit=no&quot;到meta标签来覆盖此行为，增加的值将阻止页面缩放以适应视口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no，shrink-to-fit=no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【页面缩放】&lt;/p&gt;
&lt;p&gt;　　在meta标签中设置了禁止缩放user-scalable=no，可以实现在IOS下input域焦点状态时放大被禁止的效果。但是，仍然无法阻止页面整体的缩放&lt;/p&gt;
&lt;p&gt; 【识别规则】&lt;/p&gt;
&lt;p&gt;　　1、打电话&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tel:0755-10086&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;打电话给:&lt;span&gt;0755&lt;/span&gt;-&lt;span&gt;10086&lt;/span&gt;&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、发短信，&lt;span lang=&quot;EN-US&quot;&gt;winphone系统无效&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sms:10086&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;发短信给: &lt;span&gt;10086&lt;/span&gt;&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　3、跳转到地图&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iosamap://viewMap?sourceApplication=yukapril&amp;amp;poiname=国宏宾馆&amp;amp;lat=39.905592&amp;amp;lon=116.33604&amp;amp;dev=0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;高德地图&amp;lt;/a&amp;gt;
&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;androidamap://viewMap?sourceApplication=yukapril&amp;amp;poiname=国宏宾馆&amp;amp;lat=39.905592&amp;amp;lon=116.33604&amp;amp;dev=0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;高德&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、写邮件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mailto:peun@foxmail.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;peun@foxmail.com&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5、禁止识别&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;format-detection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;telephone=no,email=no,address=no&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【爬虫】&lt;/p&gt;
&lt;p&gt;　　 robots(网页搜索引擎索引方式)：对应&lt;span lang=&quot;EN-US&quot;&gt;一组使用逗号&lt;span lang=&quot;EN-US&quot;&gt;(,)分割的值，通常取值：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;none：搜索引擎将忽略此网页，等同于noindex，nofollow；
noindex：搜索引擎不索引此网页；nofollow：搜索引擎不继续通过此网页的链接索引搜索其它的网页；
all：搜索引擎将索引此网页与继续通过此网页的链接索引，等同于index，follow；
index：搜索引擎索引此网页；follow：搜索引擎继续通过此网页的链接索引搜索其它的网页；&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用下列代码，则网页会被搜索引擎忽略&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;robots&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【添加到主屏幕】&lt;/p&gt;
&lt;p&gt;　　在IOS下，在head元素底部，使用下列代码可以实现添加到主屏幕的功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apple-mobile-web-app-capable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apple-mobile-web-app-status-bar-style&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apple-mobile-web-app-title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Weather PWA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apple-touch-icon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;images/icons/icon-152x152.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【QQ浏览器】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 全屏模式&lt;/span&gt;
&amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x5-fullscreen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 强制竖屏&lt;/span&gt;
&amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x5-orientation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;portrait&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 强制横屏&lt;/span&gt;
&amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x5-orientation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;landscape&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 应用模式&lt;/span&gt;
&amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;x5-page-mode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【UC浏览器】&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 全屏模式&lt;/span&gt;
&amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;full-screen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 强制竖屏&lt;/span&gt;
&amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;screen-orientation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;portrait&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 强制横屏&lt;/span&gt;
&amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;screen-orientation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;landscape&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 应用模式&lt;/span&gt;
&amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;browsermode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 22 Jun 2018 12:28:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/8955331.html</dc:identifier>
</item>
<item>
<title>[Abp 源码分析]三、依赖注入 - myzony</title>
<link>http://www.cnblogs.com/myzony/p/9215066.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/myzony/p/9215066.html</guid>
<description>&lt;h2 id=&quot;简要介绍&quot;&gt;0.简要介绍&lt;/h2&gt;
&lt;p&gt;在 Abp 框架里面，无时无刻不存在依赖注入，关于依赖注入的作用与好处我就不在这里多加赘述了，网上有很多解释的教程。在 &lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/myzony/archive/2018/06/15.html&quot;&gt;[Abp 源码分析]一、Abp 框架启动流程分析&lt;/a&gt;&lt;/strong&gt; 里面已经说过，Abp 本身在框架初始化的时候我们就可以看到它使用 Castle Windsor 将 Asp.Net Core 自带的 IServiceProvider 替换掉了。&lt;/p&gt;
&lt;h2 id=&quot;大体结构&quot;&gt;1.大体结构&lt;/h2&gt;
&lt;p&gt;在 Abp 框架当中，它的依赖注入相关的类型基本上都放在 Abp 项目的 &lt;strong&gt;Dependency&lt;/strong&gt; 文件夹里面，下图是他们之间的依赖关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1203160/201806/1203160-20180622184107261-404576665.png&quot; alt=&quot;假装有图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码解析&quot;&gt;2 代码解析&lt;/h2&gt;
&lt;h3 id=&quot;基本实现&quot;&gt;2.1 基本实现&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;IIocManager&lt;/code&gt; 是直接继承 &lt;code&gt;IIocRegistrar&lt;/code&gt; 与 &lt;code&gt;IIocResolver&lt;/code&gt; 的一个接口，通过名称我们就可以看出来他们的作用，&lt;code&gt;IIocRegistrar&lt;/code&gt; 内部提供了组件注册的方法定义，而 &lt;code&gt;IIocResolver&lt;/code&gt; 内部则是提供了解析已经注入的组件方法。在 &lt;code&gt;IIocManager&lt;/code&gt; 本身则是封装了一个 Castle Windsor 的 Ioc 容器，定义如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// This interface is used to directly perform dependency injection tasks.
/// &amp;lt;/summary&amp;gt;
public interface IIocManager : IIocRegistrar, IIocResolver, IDisposable
{
    /// &amp;lt;summary&amp;gt;
    /// Reference to the Castle Windsor Container.
    /// &amp;lt;/summary&amp;gt;
    IWindsorContainer IocContainer { get; }

    /// &amp;lt;summary&amp;gt;
    /// Checks whether given type is registered before.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;type&quot;&amp;gt;Type to check&amp;lt;/param&amp;gt;
    new bool IsRegistered(Type type);

    /// &amp;lt;summary&amp;gt;
    /// Checks whether given type is registered before.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;Type to check&amp;lt;/typeparam&amp;gt;
    new bool IsRegistered&amp;lt;T&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们来看看 IIocManager 的具体实现。&lt;/p&gt;
&lt;p&gt;方法虽然看起来挺多，不过更多的只是在 Castle Windsor 上面进行了一层封装而已，可以看到 &lt;code&gt;Register()&lt;/code&gt; 这个注册方法在其内部也是直接调用的 &lt;code&gt;IWindsorContainer.Register()&lt;/code&gt; 来进行注入。&lt;/p&gt;
&lt;p&gt;那么 Abp 为什么还要再包装一层呢，因为对外开放的你在使用的时候都使用的是 IIocManager 提供的注册方法，那么你需要替换 DI 框架的时候可以很快捷的替换掉整个依赖注入框架而不会影响现有代码。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void Register(Type type, DependencyLifeStyle lifeStyle = DependencyLifeStyle.Singleton)
{
    IocContainer.Register(ApplyLifestyle(Component.For(type), lifeStyle));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;规约注入&quot;&gt;2.2 规约注入&lt;/h3&gt;
&lt;p&gt;我们重点说一说它的规约注入，什么是规约注入？&lt;/p&gt;
&lt;p&gt;在上面的类图当中，可以看到有一个 &lt;code&gt;IConventionalDependencyRegistrar&lt;/code&gt; 接口，并且该接口还拥有四个实现，我们以 &lt;code&gt;BasicConventionalRegistrar&lt;/code&gt; 类为例子看看里面做了什么操作。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// This class is used to register basic dependency implementations such as &amp;lt;see cref=&quot;ITransientDependency&quot;/&amp;gt; and &amp;lt;see cref=&quot;ISingletonDependency&quot;/&amp;gt;.
/// &amp;lt;/summary&amp;gt;
public class BasicConventionalRegistrar : IConventionalDependencyRegistrar
{
    public void RegisterAssembly(IConventionalRegistrationContext context)
    {
        //Transient
        context.IocManager.IocContainer.Register(
            Classes.FromAssembly(context.Assembly)
                .IncludeNonPublicTypes()
                .BasedOn&amp;lt;ITransientDependency&amp;gt;()
                .If(type =&amp;gt; !type.GetTypeInfo().IsGenericTypeDefinition)
                .WithService.Self()
                .WithService.DefaultInterfaces()
                .LifestyleTransient()
            );

        //Singleton
        context.IocManager.IocContainer.Register(
            Classes.FromAssembly(context.Assembly)
                .IncludeNonPublicTypes()
                .BasedOn&amp;lt;ISingletonDependency&amp;gt;()
                .If(type =&amp;gt; !type.GetTypeInfo().IsGenericTypeDefinition)
                .WithService.Self()
                .WithService.DefaultInterfaces()
                .LifestyleSingleton()
            );

        //Windsor Interceptors
        context.IocManager.IocContainer.Register(
            Classes.FromAssembly(context.Assembly)
                .IncludeNonPublicTypes()
                .BasedOn&amp;lt;IInterceptor&amp;gt;()
                .If(type =&amp;gt; !type.GetTypeInfo().IsGenericTypeDefinition)
                .WithService.Self()
                .LifestyleTransient()
            );
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;BasicConventionalRegistrar&lt;/code&gt; 内部，他会扫描传入的程序集，并且根据类型所继承的接口来进行自动注入，所以 Abp 定义了两个辅助注入接口，叫做&lt;code&gt;ITransientDependency&lt;/code&gt; 和 &lt;code&gt;ISingletonDependency&lt;/code&gt;，并且在下面还注入了拦截器。&lt;/p&gt;
&lt;p&gt;这样的话，我们自己就不需要频繁的使用 &lt;code&gt;IIocManager.Register()&lt;/code&gt; 方法来手动注入，只需要在自己的实现类或者接口上面，继承上述两个接口之一即可。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;IocManager&lt;/code&gt; 内部维护了一个集合 &lt;code&gt;_conventionalRegistrars&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// List of all registered conventional registrars.
/// &amp;lt;/summary&amp;gt;
private readonly List&amp;lt;IConventionalDependencyRegistrar&amp;gt; _conventionalRegistrars;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个集合就是已经存在的规约注册器，在 &lt;code&gt;AbpKernelModule&lt;/code&gt; 的预加载方法里面就使用 &lt;code&gt;AddConventionalRegistrar()&lt;/code&gt; 方法来添加了 &lt;code&gt;BasicConventionalRegistrar&lt;/code&gt; 注册器。代码在 AbpKernelModule.cs 的 45 行：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public override void PreInitialize()
{
    IocManager.AddConventionalRegistrar(new BasicConventionalRegistrar());
    
    // 其他代码
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后每当程序调用 &lt;code&gt;IIocManager.RegisterAssemblyByConvention(Assembly assembly)&lt;/code&gt; 方法的时候，就会根据传入的 Assembly 来循环调用存放在集合里面注册器的 &lt;code&gt;RegisterAssembly()&lt;/code&gt; 方法，当然你也可以随时定义一个 Registrar ，注册约定你也可以自己来编写。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void RegisterAssemblyByConvention(Assembly assembly, ConventionalRegistrationConfig config)
{
    var context = new ConventionalRegistrationContext(assembly, this, config);

    foreach (var registerer in _conventionalRegistrars)
    {
        registerer.RegisterAssembly(context);
    }

    if (config.InstallInstallers)
    {
        IocContainer.Install(FromAssembly.Instance(assembly));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注：一般来说，每个模块都会在它的 &lt;code&gt;Initialize&lt;/code&gt; 方法当中调用 IocManager.RegisterAssemblyByConvention()，将自己传入该方法当中来注入当前模块程序集所有符合规约的组件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里值得注意的是 &lt;code&gt;RegisterAssemblyByConvention()&lt;/code&gt; 方法还有一个重载 &lt;code&gt;RegisterAssemblyByConvention(Assembly assembly, ConventionalRegistrationConfig config)&lt;/code&gt;，他将会传入一个 &lt;code&gt;ConventionalRegistrationConfig&lt;/code&gt; 对象，该对象只有一个 &lt;code&gt;bool InstallInstallers&lt;/code&gt; 属性，主要是在注册的时候告诉 Abp 框架是否使用该程序集内部的 &lt;code&gt;IWindsorInstaller&lt;/code&gt; 接口规则。&lt;/p&gt;
&lt;h3 id=&quot;初始化过程&quot;&gt;2.3 初始化过程&lt;/h3&gt;
&lt;p&gt;呐，首先呢在我们初始化 &lt;code&gt;AbpBootstrapper&lt;/code&gt; 的时候，就已经创建好了我们的 &lt;code&gt;IocManager&lt;/code&gt; 实例，我们可以来到 AbpBootstrapper.cs 的构造函数有以下代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public IIocManager IocManager { get; }

private AbpBootstrapper([NotNull] Type startupModule, [CanBeNull] Action&amp;lt;AbpBootstrapperOptions&amp;gt; optionsAction = null)
{
    Check.NotNull(startupModule, nameof(startupModule));

    var options = new AbpBootstrapperOptions();
    optionsAction?.Invoke(options);

    if (!typeof(AbpModule).GetTypeInfo().IsAssignableFrom(startupModule))
    {
        throw new ArgumentException($&quot;{nameof(startupModule)} should be derived from {nameof(AbpModule)}.&quot;);
    }

    StartupModule = startupModule;

    IocManager = options.IocManager;
    PlugInSources = options.PlugInSources;

    _logger = NullLogger.Instance;

    if (!options.DisableAllInterceptors)
    {
        AddInterceptorRegistrars();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到在 new 了一个 &lt;code&gt;AbpBootstrapperOptions&lt;/code&gt; 对象，并且在第 17 行将 options 创建好的 &lt;code&gt;IocManager&lt;/code&gt; 赋值给 &lt;code&gt;AbpBootstrapper&lt;/code&gt; 本身的 &lt;code&gt;IocManager&lt;/code&gt; 属性。&lt;/p&gt;
&lt;p&gt;那么在 options 内部是如何创建 IIocManager 的呢？&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public AbpBootstrapperOptions()
{
    IocManager = Abp.Dependency.IocManager.Instance;
    PlugInSources = new PlugInSourceList();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到他直接是使用的 IocManager 这个类所提供的一个静态实例。&lt;/p&gt;
&lt;p&gt;也就是在 IocManager 类里面他有一个静态构造函数：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;static IocManager()
{
    Instance = new IocManager();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是这种操作，之后在 IocManager 的构造函数里面呢就将自己再注册到了 Castle Windsor 的容器里面，这样其他的组件就可以直接注入使用 &lt;code&gt;IIocManager&lt;/code&gt; 了。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public IocManager()
{
    IocContainer = new WindsorContainer();
    _conventionalRegistrars = new List&amp;lt;IConventionalDependencyRegistrar&amp;gt;();

    //Register self!
    IocContainer.Register(
        Component.For&amp;lt;IocManager, IIocManager, IIocRegistrar, IIocResolver&amp;gt;().UsingFactoryMethod(() =&amp;gt; this)
        );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以回顾一下在替换 Asp.Net Core 自身的 Ioc 容器的时候，在使用的 &lt;code&gt;CreateServiceProvider&lt;/code&gt; 就是 Castle Windsor 提供的 &lt;code&gt;IocContainer&lt;/code&gt; 对象，该对象就是我们上文在 &lt;code&gt;AbpBootstrapperOptions&lt;/code&gt; 里面创建的静态实例。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static IServiceProvider AddAbp&amp;lt;TStartupModule&amp;gt;(this IServiceCollection services, [CanBeNull] Action&amp;lt;AbpBootstrapperOptions&amp;gt; optionsAction = null)
    where TStartupModule : AbpModule
{
    var abpBootstrapper = AddAbpBootstrapper&amp;lt;TStartupModule&amp;gt;(services, optionsAction);

    ConfigureAspNetCore(services, abpBootstrapper.IocManager);

    return WindsorRegistrationHelper.CreateServiceProvider(abpBootstrapper.IocManager.IocContainer, services);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;初始化流程图&quot;&gt;3.初始化流程图&lt;/h2&gt;
&lt;p&gt;总的来说呢，整个 Abp 框架的依赖注入相关的初始化流程图就像这样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1203160/201806/1203160-20180622185358265-180799248.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Jun 2018 10:54:00 +0000</pubDate>
<dc:creator>myzony</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/myzony/p/9215066.html</dc:identifier>
</item>
<item>
<title>MySQL组复制技术(4)：配置多主模型的组复制 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9215013.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9215013.html</guid>
<description>&lt;p&gt;在这一篇，我演示的是如何配置MySQL组复制的多主模型(multi-primary)。在配置上，多主模型的组复制和单主模型基本没区别。&lt;/p&gt;
&lt;p&gt;本文仅为搭建和维护多主模型组复制抛块小砖，若对其间涉及的术语和理论有所疑惑，可参看：&lt;/p&gt;
&lt;p&gt;使用组复制技术，必须要了解它的要求和局限性。见：&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9197442.html&quot;&gt;组复制的要求和局限性&lt;/a&gt;。&lt;/p&gt;


&lt;p&gt;MySQL组复制支持单主模型和多主模型，它们都能保证MySQL数据库的高可用。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;单主模型下：
&lt;ul&gt;&lt;li&gt;只有一个主节点，该主节点负责所有的写操作，其他节点作为slave节点提供读取服务(会自动设置为read-only)。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;在主节点故障，单主模型会自动选举新的主节点。选举后，剩余节点将指向该节点。但是，客户端还是会有部分请求路由到故障的主节点上，因此需要想办法解决这样的问题。这不是MySQL该考虑解决的问题，而是客户端应用程序、数据库中间件(常见的：ProxySQL、MySQL Router、mycat、amoeba、cobar等)该解决的问题。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;只要&lt;strong&gt;非自愿离组&lt;/strong&gt;的故障节点(自愿、非自愿离组，请参见&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9203154.html&quot; title=&quot;MySQL组复制(2)：单主模型的组复制&quot;&gt;配置单主模型的组复制&lt;/a&gt;)不超过大多数，组复制就不会被阻塞。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多主模型下：
&lt;ul&gt;&lt;li&gt;没有master和slave的概念。所有的节点都可以读、写数据。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;因为所有节点都能提供读写服务，所以性能较之单主模型要好一些。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;配置多主模型的工作方式，比单主模型的限制更多。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;节点非自愿故障后，除了影响一点性能，不会对组复制造成影响。除非故障的节点数过多，使得剩余在线节点达不到&quot;大多数&quot;的要求。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以下是单主模型组复制的配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[mysqld]
datadir=/data
socket=/data/mysql.sock

server-id=100                      # 必须
gtid_mode=on                       # 必须
enforce_gtid_consistency=on        # 必须
log-bin=/data/master-bin           # 必须
binlog_format=row                  # 必须
binlog_checksum=none               # 必须
master_info_repository=TABLE       # 必须
relay_log_info_repository=TABLE    # 必须
relay_log=/data/relay-log          # 必须，如果不给，将采用默认值
log_slave_updates=ON               # 必须
sync-binlog=1                      # 建议
log-error=/data/error.log
pid-file=/data/mysqld.pid

transaction_write_set_extraction=XXHASH64         # 必须
loose-group_replication_group_name=&quot;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&quot;  # 必须
loose-group_replication_start_on_boot=off        # 建议设置为OFF
loose-group_replication_member_weigth = 40   # 非必需，mysql 5.7.20才开始支持该选项
loose-group_replication_local_address=&quot;ABCDEFGHIJK&quot;   # 必须，下一行也必须
loose-group_replication_group_seeds=&quot;abcdefg&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中每一行什么意思，我在&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9203154.html#blog2.1&quot; title=&quot;单主模型的配置文件&quot;&gt;单主模型组复制&lt;/a&gt;中做了非常详细的解释。&lt;/p&gt;
&lt;p&gt;多主模型和单主模型的配置文件基本相同，除了需要加入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;group_replication_enforce_update_everywhere_checks=ON  # 非必需，但强烈建议
group_replication_single_primary_mode=OFF  # 必须，表示关闭单主模型，即使用多主&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注释权重行，因为多主模型下没有master的概念，所以无需选举的权重值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# loose-group_replication_member_weigth = 40&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外，除非业务依赖于默认的&lt;code&gt;repeatable read&lt;/code&gt;，否则建议将事务隔离级别设置为&lt;code&gt;read committed&lt;/code&gt;，且不能设置为&lt;code&gt;serializable&lt;/code&gt;级别(强制要求)。所以，如果允许，还可以加上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;transaction_isolation = 'read-committed' &lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;本文打算配置5个节点的多主模型复制组。&lt;/p&gt;
&lt;p&gt;具体环境细节如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;s1&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;CentOS 7&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;MySQL 5.7.22&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.100.21&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.100.21&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;全新实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;s2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;CentOS 7&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;MySQL 5.7.22&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.100.22&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.100.22&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;全新实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;s3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;CentOS 7&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;MySQL 5.7.22&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.100.23&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.100.23&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;全新实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;s4&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;CentOS 7&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;MySQL 5.7.22&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.100.24&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.100.24&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;全新实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;s5&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;CentOS 7&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;MySQL 5.7.22&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.100.25&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;192.168.100.25&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;全新实例&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;每个节点向外提供MySQL服务和组内通信都使用同一个接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.修改主机名，添加DNS解析。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为组内每个节点都使用主机名进行解析其他成员的地址，所以必须配置好主机名，并保证每个节点都能正确解析主机名。&lt;/p&gt;
&lt;p&gt;在s1上执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hostnamectl set-hostname s1.longshuai.com
hostnamectl -H 192.168.100.22 set-hostname s2.longshuai.com
hostnamectl -H 192.168.100.23 set-hostname s3.longshuai.com
hostnamectl -H 192.168.100.24 set-hostname s4.longshuai.com
hostnamectl -H 192.168.100.25 set-hostname s5.longshuai.com

cat &amp;gt;&amp;gt;/etc/hosts&amp;lt;&amp;lt;eof
    192.168.100.21 s1.longshuai.com
    192.168.100.22 s2.longshuai.com
    192.168.100.23 s3.longshuai.com
    192.168.100.24 s4.longshuai.com
    192.168.100.25 s5.longshuai.com
eof

scp /etc/hosts 192.168.100.22:/etc
scp /etc/hosts 192.168.100.23:/etc
scp /etc/hosts 192.168.100.24:/etc
scp /etc/hosts 192.168.100.25:/etc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.提供配置文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下是s1节点配置文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[mysqld]
datadir=/data
socket=/data/mysql.sock

server-id=100                      # 必须
gtid_mode=on                       # 必须
enforce_gtid_consistency=on        # 必须
log-bin=/data/master-bin           # 必须
binlog_format=row                  # 必须
binlog_checksum=none               # 必须
master_info_repository=TABLE       # 必须
relay_log_info_repository=TABLE    # 必须
relay_log=/data/relay-log          # 必须，如果不给，将采用默认值
log_slave_updates=ON               # 必须
sync-binlog=1                      # 建议
log-error=/data/error.log
pid-file=/data/mysqld.pid


transaction_isolation = 'read-committed'   # 建议项

transaction_write_set_extraction=XXHASH64         # 必须
loose-group_replication_group_name=&quot;aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa&quot;  # 必须
loose-group_replication_enforce_update_everywhere_checks=ON  # 非必需，但强烈建议
loose-group_replication_single_primary_mode=OFF  # 必须，关闭单主模型，即使用多主
loose-group_replication_start_on_boot=off        # 建议设置为OFF
loose-group_replication_local_address=&quot;192.168.100.21:20001&quot;   # 必须
# 下一行也必须，这里我将所有节点都添加到种子节点列表中
loose-group_replication_group_seeds=&quot;192.168.100.21:20001,192.168.100.22:20002,192.168.100.23:20003,192.168.100.24:20004,192.168.100.25:20005&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;s2、s3、s4和s5节点的配置文件和s1类似，但&lt;code&gt;server_id&lt;/code&gt;和&lt;code&gt;loose-group_replication_local_address&lt;/code&gt;必须改成各节点对应的值。&lt;/p&gt;
&lt;p&gt;s2的配置(未包括和s1相同的配置)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server_id=110
loose-group_replication_local_address=&quot;192.168.100.22:20002&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;s3的配置(未包括和s1相同的配置)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server_id=120
loose-group_replication_local_address=&quot;192.168.100.23:20003&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;s4的配置(未包括和s1相同的配置)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server_id=130
loose-group_replication_local_address=&quot;192.168.100.24:20004&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;s5的配置(未包括和s1相同的配置)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server_id=140
loose-group_replication_local_address=&quot;192.168.100.25:20005&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置结束后，启动mysqld实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;systemctl start mysqld&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3.创建复制用户，并设置恢复通道&quot;group_replication_recovery&quot;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我这里将s1作为组内的第一个节点。所以只需在s1上创建复制用户即可，以后其他节点加入组时，会将该操作复制走。&lt;/p&gt;
&lt;p&gt;在s1上执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; create user repl@'192.168.100.%' identified by 'P@ssword1!';
mysql&amp;gt; grant replication slave on *.* to repl@'192.168.100.%';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置恢复阶段的异步复制通道：&lt;/p&gt;
&lt;p&gt;在s1上执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; change master to 
            master_user='repl',
            master_password='P@ssword1!'
            for channel 'group_replication_recovery';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：后面的操作中，如果没有明确指定在s2、s3、s4和s5上执行，那么都是在s1上执行的。有些操作是不允许在多个节点上都执行的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.在s1上安装组复制插件，并引导创建复制组。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装组复制插件，在s1上执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; install plugin group_replication soname 'group_replication.so';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以s1节点组的引导节点，在s1上执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; set @@global.group_replication_bootstrap_group=on;
mysql&amp;gt; start group_replication;
mysql&amp;gt; set @@global.group_replication_bootstrap_group=off;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完上面的语句后，本实验所需的复制组就已经被节点s1创建了。以后s2-s5节点就可以陆续地加入到组中。&lt;/p&gt;
&lt;p&gt;在其他节点加组之前，先看下组中的节点s1是否已ONLINE。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; select * from performance_schema.replication_group_members\G
*************************** 1. row ***************************
CHANNEL_NAME: group_replication_applier
   MEMBER_ID: a659234f-6aea-11e8-a361-000c29ed4cf4
 MEMBER_HOST: s1.longshuai.com
 MEMBER_PORT: 3306
MEMBER_STATE: ONLINE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.向组中加入新节点：s2、s3、s4、s5。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在s2、s3、s4和s5上都执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;change master to 
            master_user='repl',
            master_password='P@ssword1!'
            for channel 'group_replication_recovery';

install plugin group_replication soname 'group_replication.so';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后依次在s2、s3、s4和s5上执行下面的语句开启组复制功能，开启该功能后，将自动加入到组中。但注意，要依次执行，在每个start语句返回成功后再去下一个节点执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;start group_replication;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;6.查看组中成员s1、s2、s3、s4、s5是否全都ONLINE。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在任意一个节点上执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; select * from performance_schema.replication_group_members\G
*************************** 1. row ***************************
CHANNEL_NAME: group_replication_applier
   MEMBER_ID: 22e55db0-7604-11e8-b72d-000c29b06c3c
 MEMBER_HOST: s5.longshuai.com
 MEMBER_PORT: 3306
MEMBER_STATE: ONLINE
*************************** 2. row ***************************
CHANNEL_NAME: group_replication_applier
   MEMBER_ID: a5165443-6aec-11e8-a8f6-000c29827955
 MEMBER_HOST: s2.longshuai.com
 MEMBER_PORT: 3306
MEMBER_STATE: ONLINE
*************************** 3. row ***************************
CHANNEL_NAME: group_replication_applier
   MEMBER_ID: a659234f-6aea-11e8-a361-000c29ed4cf4
 MEMBER_HOST: s1.longshuai.com
 MEMBER_PORT: 3306
MEMBER_STATE: ONLINE
*************************** 4. row ***************************
CHANNEL_NAME: group_replication_applier
   MEMBER_ID: ba505889-6aec-11e8-a864-000c29b0bec4
 MEMBER_HOST: s3.longshuai.com
 MEMBER_PORT: 3306
MEMBER_STATE: ONLINE
*************************** 5. row ***************************
CHANNEL_NAME: group_replication_applier
   MEMBER_ID: bf12fe97-6aec-11e8-a909-000c29e55287
 MEMBER_HOST: s4.longshuai.com
 MEMBER_PORT: 3306
MEMBER_STATE: ONLINE
5 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;多主模型下，所有节点都可以进行读、写操作。但请注意，组复制的几个要求：表必须为innodb表(虽然创建myisam表不报错，但修改数据会报错)、每个表必须有主键、不能有级联的外键等。&lt;/p&gt;
&lt;p&gt;在任意节点上执行以下写操作进行测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create database mut_gr;
create table mut_gr.t1(id int primary key);
insert into mut_gr.t1 values(1),(2),(3),(4);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在任意节点上继续执行写操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;insert into mut_gr.t1 values(5);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看数据是否都已同步到各节点上。&lt;/p&gt;


&lt;p&gt;关于组复制更多维护操作，比如如何重启组、如何安全退组、如何重新加组等等，还是请参看&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9203154.html&quot; title=&quot;MySQL组复制(2)：单主模型的组复制&quot;&gt;单主模型的组复制&lt;/a&gt;，它们的维护是类似的，所以本文就不对重复内容做赘述了。&lt;/p&gt;
</description>
<pubDate>Fri, 22 Jun 2018 10:30:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9215013.html</dc:identifier>
</item>
<item>
<title>CentOS7 手动部署flannel并启用vxlan - ZisZ</title>
<link>http://www.cnblogs.com/ZisZ/p/9212820.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZisZ/p/9212820.html</guid>
<description>&lt;p&gt;本以为docker准备妥当之后，就可以直接上k8s了，结果yum install kubernetes，报错：Error: docker-ce conflicts with docker-1.9.1 .....&lt;/p&gt;
&lt;p&gt;这才想起来，自己的docker不是从centos官方源获取的，而是用了docker的源安装docker-ce，参见上一遍&lt;a href=&quot;https://www.cnblogs.com/ZisZ/p/8962194.html&quot; target=&quot;_blank&quot;&gt;docker的部署文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;centos官方源提供的k8s在版本1.2，配套docker 1.9，而我用的docker-ce在版本18.03，经查&lt;a href=&quot;https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG-1.8.md#external-dependencies&quot; target=&quot;_blank&quot;&gt;k8s的changelog&lt;/a&gt;，至少要到1.8才能支持到docker 17.03，然后到1.11，都未提到过docker 18；&lt;/p&gt;
&lt;p&gt;但参考了较新的k8s部署教程，已经有k8s 1.10配套docker-ce 18.03的&lt;a href=&quot;https://www.kubernetes.org.cn/4041.html&quot; target=&quot;_blank&quot;&gt;先例&lt;/a&gt;，可以一试；&lt;/p&gt;

&lt;p&gt;参考了现网已有的大部分k8s部署教程，大都太流程化，不够细致；&lt;/p&gt;
&lt;p&gt;安装k8s通常会提到flannel，它提供容器的跨主机通信支持，已经涉及到SDN的领域，这一篇对&lt;a href=&quot;https://www.hi-linux.com/posts/30481.html&quot; target=&quot;_blank&quot;&gt;flannel的部署及原理介绍&lt;/a&gt;特别值得读一下；&lt;/p&gt;
&lt;p&gt;考虑到k8s需要用最新版，flannel也就用最新版，不通过yum安装了，于是自己动手部署了flannel，把从细节收获的信息记下来，提供一个不一样的视角；&lt;/p&gt;

&lt;p&gt;----以下是正文----&lt;/p&gt;
&lt;h2&gt;依赖 &lt;/h2&gt;
&lt;p&gt;flannel依赖etcd提供配置管理；为简化，我只使用了一个单点的etcd，没有组etcd集群；&lt;/p&gt;
&lt;h2&gt;部署flannel &lt;/h2&gt;
&lt;p&gt;下载flannel，从github找到最新的发布版，我下到的是0.10.0；&lt;a href=&quot;https://github.com/coreos/flannel/releases&quot; target=&quot;_blank&quot;&gt;https://github.com/coreos/flannel/releases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解压后，得到一个二进制文件flanneld，一个脚本mk-docker-opts.sh，以及一个README.md；最后这个文件忽略就行了，其它两个放到/usr/bin下；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mv&lt;/span&gt; flanneld /usr/&lt;span&gt;bin
&lt;/span&gt;&lt;span&gt;mv&lt;/span&gt; mk-docker-opts.&lt;span&gt;sh&lt;/span&gt; /usr/bin
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;flanneld服务配置 &lt;/h2&gt;
&lt;p&gt;添加systemd的service管理文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# &lt;span&gt;cat&lt;/span&gt; /usr/lib/systemd/system/&lt;span&gt;flanneld.service 
[Unit]
Description&lt;/span&gt;=&lt;span&gt;flannel
Before&lt;/span&gt;=&lt;span&gt;docker.service

[Service]
ExecStart&lt;/span&gt;=/usr/bin/&lt;span&gt;flanneld

[Install]
WantedBy&lt;/span&gt;=multi-&lt;span&gt;user.target
RequiredBy&lt;/span&gt;=docker.service
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;flanneld环境变量配置 &lt;/h2&gt;
&lt;p&gt;环境变量的管理也仿照上一篇对docker的环境变量管理，添加了一个&lt;a href=&quot;https://wiki.archlinux.org/index.php/Systemd#Drop-in_files&quot; target=&quot;_blank&quot;&gt;Drop-in file&lt;/a&gt;： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# cat&lt;/span&gt; /etc/systemd/system/flanneld.service.d/&lt;span&gt;flannel.conf 
[Service]
Environment&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FLANNELD_ETCD_ENDPOINTS=http://xxxx:2379&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
Environment&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FLANNELD_ETCD_PREFIX=/flannel/network&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;flannel的环境变量全都是参数加上“FLANNELD_”前缀，见&lt;a href=&quot;https://github.com/coreos/flannel/blob/master/Documentation/configuration.md#environment-variables&quot; target=&quot;_blank&quot;&gt;flanneld环境变量说明&lt;/a&gt;；&lt;/p&gt;
&lt;h2&gt;启动flanneld&lt;/h2&gt;
&lt;p&gt;查看环境变量是否生效，然后启动flanneld：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
systemctl daemon-&lt;span&gt;reload

systemctl show flanneld &lt;/span&gt;--property Environment&lt;p&gt;systemctl start flanneld
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看启动日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
systemctl status flanneld -l
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发现报错了：Couldn't fetch network config: 100: Key not found&lt;/p&gt;
&lt;p&gt;想起来etcd里还没写入网络配置信息呢；&lt;/p&gt;
&lt;h2&gt;flanneld网络配置 &lt;/h2&gt;
&lt;p&gt;docker默认用172.17.0.0/16这个段，我想换个段，以明确知道是在使用flanneld提供的网络，于是就用了172.10.0.0/16&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
etcdctl mk /flannel/network/config &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&quot;Network&quot;:&quot;172.10.0.0/16&quot;, &quot;SubnetMin&quot;: &quot;172.10.1.0&quot;, &quot;SubnetMax&quot;: &quot;172.10.254.0&quot;}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为flannel一直在尝试从etcd读配置信息，所以不需要重启flanneld，再看启动日志，flanneld已经获取到想要的子网地址了；&lt;/p&gt;
&lt;p&gt;此时，在/run/flannel/subnet.env位置会生成这个host所分配到的子网信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# &lt;span&gt;cat&lt;/span&gt; /run/flannel/subnet.&lt;span&gt;env&lt;/span&gt;&lt;span&gt;
FLANNEL_NETWORK&lt;/span&gt;=&lt;span&gt;172.10&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;16&lt;/span&gt;&lt;span&gt;
FLANNEL_SUBNET&lt;/span&gt;=&lt;span&gt;172.10&lt;/span&gt;.&lt;span&gt;63.1&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;&lt;span&gt;
FLANNEL_MTU&lt;/span&gt;=&lt;span&gt;1472&lt;/span&gt;&lt;span&gt;
FLANNEL_IPMASQ&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而这个文件正是mk-docker-opts.sh脚本的输入文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# /usr/bin/mk-docker-opts.&lt;span&gt;sh&lt;/span&gt; -&lt;span&gt;c
# &lt;/span&gt;&lt;span&gt;cat&lt;/span&gt; /run/docker_opts.&lt;span&gt;env&lt;/span&gt;&lt;span&gt; 
DOCKER_OPTS&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; --bip=172.10.63.1/24 --ip-masq=true --mtu=1472&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时看一下etcd，多了一条信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# etcdctl get /flannel/network/subnets/&lt;span&gt;172.10&lt;/span&gt;.&lt;span&gt;63.0&lt;/span&gt;-&lt;span&gt;24&lt;/span&gt;&lt;span&gt;
{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PublicIP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;xxxxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看一下主机网卡&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
# ip a |&lt;span&gt;grep&lt;/span&gt;&lt;span&gt; flannel
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;: flannel0: &amp;lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;1472&lt;/span&gt; qdisc pfifo_fast state UNKNOWN qlen &lt;span&gt;500&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看一下网卡详情&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
# ip -&lt;span&gt;d link show dev flannel0
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;: flannel0: &amp;lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;1472&lt;/span&gt; qdisc pfifo_fast state UNKNOWN mode DEFAULT qlen &lt;span&gt;500&lt;/span&gt;&lt;span&gt;
    link&lt;/span&gt;/none  promiscuity &lt;span&gt;0&lt;/span&gt;&lt;span&gt; 
    tun &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;flanneld vxlan网络配置&lt;/h2&gt;
&lt;p&gt;推荐Kernel 3.9以上的主机启用vxlan网络（来源记不清了），CentOS7的内核已经到3.10，可以支持；&lt;/p&gt;
&lt;p&gt;修改网络配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
etcdctl set /flannel/network/config &lt;span&gt;'&lt;/span&gt;&lt;span&gt;{&quot;Network&quot;:&quot;172.10.0.0/16&quot;, &quot;SubnetMin&quot;: &quot;172.10.1.0&quot;, &quot;SubnetMax&quot;: &quot;172.10.254.0&quot;, &quot;Backend&quot;: {&quot;Type&quot;: &quot;vxlan&quot;}}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启flanneld：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
systemctl restart flanneld
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看启动日志，已经能看到在使用vxlan backend了；&lt;/p&gt;
&lt;p&gt;看一下/run/flannel/subnet.env文件，发现子网没变，但是MTU变了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# &lt;span&gt;cat&lt;/span&gt; /run/flannel/subnet.&lt;span&gt;env&lt;/span&gt;&lt;span&gt; 
FLANNEL_NETWORK&lt;/span&gt;=&lt;span&gt;172.10&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;16&lt;/span&gt;&lt;span&gt;
FLANNEL_SUBNET&lt;/span&gt;=&lt;span&gt;172.10&lt;/span&gt;.&lt;span&gt;63.1&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;&lt;span&gt;
FLANNEL_MTU&lt;/span&gt;=&lt;span&gt;1450&lt;/span&gt;&lt;span&gt;
FLANNEL_IPMASQ&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再看一下etcd&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# etcdctl get /flannel/network/subnets/&lt;span&gt;172.10&lt;/span&gt;.&lt;span&gt;63.0&lt;/span&gt;-&lt;span&gt;24&lt;/span&gt;&lt;span&gt;
{&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PublicIP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BackendType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vxlan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BackendData&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VtepMAC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;e2:73:8e:db:83:56&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再看一下主机网卡&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
# ip a|&lt;span&gt;grep&lt;/span&gt;&lt;span&gt; flannel
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;: flannel.&lt;span&gt;1&lt;/span&gt;: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;1450&lt;/span&gt; qdisc noqueue state UNKNOWN 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再看一下网卡详情&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
# ip -d link show dev flannel.&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;145&lt;/span&gt;: flannel.&lt;span&gt;1&lt;/span&gt;: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu &lt;span&gt;1450&lt;/span&gt;&lt;span&gt; qdisc noqueue state UNKNOWN mode DEFAULT 
    link&lt;/span&gt;/ether e2:&lt;span&gt;73&lt;/span&gt;:8e:db:&lt;span&gt;83&lt;/span&gt;:&lt;span&gt;56&lt;/span&gt; brd ff:ff:ff:ff:ff:ff promiscuity &lt;span&gt;0&lt;/span&gt;&lt;span&gt; 
    vxlan &lt;/span&gt;&lt;span&gt;id&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; local &lt;span&gt;10.10&lt;/span&gt;.&lt;span&gt;10.127&lt;/span&gt; dev bond0 srcport &lt;span&gt;32768&lt;/span&gt; &lt;span&gt;65000&lt;/span&gt; dstport &lt;span&gt;8472&lt;/span&gt; nolearning ageing &lt;span&gt;300&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Docker使用flannel网络&lt;/h2&gt;
&lt;p&gt;再重新生成一次docker_opts.env：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# /usr/bin/mk-docker-opts.sh -&lt;span&gt;c
# cat /run/docker_opts.env&lt;span&gt; 
DOCKER_OPTS=&quot; --bip=172.10.63.1/24 --ip-masq=true --mtu=1450&quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改/lib/systemd/system/docker.service：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
EnvironmentFile=/run/docker_opts.&lt;span&gt;env # 新加&lt;/span&gt;&lt;span&gt;
ExecStart&lt;/span&gt;=/usr/bin/dockerd $DOCKER_OPTS
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启docker服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
systemctl daemon-&lt;span&gt;reload
systemctl restart docker&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看bridge网络的信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# docker network &lt;span&gt;ls&lt;/span&gt; |&lt;span&gt;grep&lt;/span&gt;&lt;span&gt; bridge
d5ad3f19dc63        bridge              bridge              local
# docker network inspect d5ad3f19dc63 &lt;/span&gt;| &lt;span&gt;grep&lt;/span&gt;&lt;span&gt; Subnet
                    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Subnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;172.10.63.1/24&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就已经是在flannel提供的网段内了；&lt;/p&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;p&gt;然后在另一台主机上也照做一遍，分别启动一个container，互ping一下，测试通过；&lt;/p&gt;
</description>
<pubDate>Fri, 22 Jun 2018 09:40:00 +0000</pubDate>
<dc:creator>ZisZ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZisZ/p/9212820.html</dc:identifier>
</item>
<item>
<title>初探nodejs，学习使用gulp管理前端文件 - Dupont</title>
<link>http://www.cnblogs.com/surfing/p/9214564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/surfing/p/9214564.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1、安装node.js&lt;/strong&gt;（&lt;a class=&quot;external-link&quot; href=&quot;https://nodejs.org/en/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://nodejs.org/en/&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;安装后使用node -v查看版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/179511/201806/179511-20180622172723572-216151838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;node安装完之后会顺带安装npm&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ps：&lt;/strong&gt;npm其实是Node.js的包管理工具（package manager）为啥我们需要一个包管理工具呢？因为我们在Node.js上开发时，会用到很多别人写的JavaScript代码。如果我们要使用别人写的某个包，每次都根据名称搜索一下官方网站，下载代码，解压，再使用，非常繁琐。于是一个集中管理的工具应运而生：大家都把自己开发的模块打包后放到npm官网上，如果要使用，直接通过npm安装就可以直接用，不用管代码存在哪，应该从哪下载。更重要的是，如果我们要使用模块A，而模块A又依赖于模块B，模块B又依赖于模块X和模块Y，npm可以根据依赖关系，把所有依赖的包都下载下来并管理起来。&lt;/p&gt;
&lt;p&gt;同样用npm -v查看版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/179511/201806/179511-20180622172804879-548028048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、安装gulp插件：npm install -g gulp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/179511/201806/179511-20180622172831576-1686498387.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、本地创建一个项目文件并用gulp管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     1&amp;gt;在D盘创建要给空文件夹Gulp_Test 。Win+R打开命令窗口并定位到当前项目目录，然后输入指令：npm init 回车（有git的童鞋在文件夹里直接右键 git bash here也可），命令执行期间会提示输入一些关于项目的描述信息，非必填一路回车即可。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/179511/201806/179511-20180622173002033-44128812.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;完成之后文件夹中会生成一个package.json文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2&amp;gt;执行以下命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;//本地安装: npm install gulp --save-dev (gulp插件)&lt;/p&gt;
&lt;p&gt;//本地安装: npm install gulp-concat --save-dev (合并插件)&lt;/p&gt;
&lt;p&gt;//本地安装：npm install gulp-uglify --save-dev (压缩插件)&lt;/p&gt;

&lt;p&gt;至此，所有准备工作已就绪，开始管理我们的项目吧。&lt;/p&gt;
&lt;p&gt; （1）在项目根目录创建一个名为gulpfile.js的js文件&lt;/p&gt;
&lt;p&gt;（2）在根目录新建js文件夹，并在文件夹中新建两个js文件，代码如下：&lt;/p&gt;
&lt;div&gt; 
&lt;p&gt;&lt;strong&gt;index.js:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('6e7ab8a4-1120-4edf-b0a2-a8cf31a7d797')&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_6e7ab8a4-1120-4edf-b0a2-a8cf31a7d797&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6e7ab8a4-1120-4edf-b0a2-a8cf31a7d797&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('6e7ab8a4-1120-4edf-b0a2-a8cf31a7d797',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6e7ab8a4-1120-4edf-b0a2-a8cf31a7d797&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; index=&lt;span&gt;{}; 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; index=&lt;span&gt;{ 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;test:function(argument){ 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; console.log(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;} 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;} 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; index.test();
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;main.js:&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;16&quot;&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d3e54bd7-09d6-464c-ae6f-88424455175f')&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_d3e54bd7-09d6-464c-ae6f-88424455175f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d3e54bd7-09d6-464c-ae6f-88424455175f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d3e54bd7-09d6-464c-ae6f-88424455175f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d3e54bd7-09d6-464c-ae6f-88424455175f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; main =&lt;span&gt; {}; 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; main.test=&lt;span&gt;function(argument){ 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; console.log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;main test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;} 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; main.test();
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;（3）在根目录创建build文件夹，用来存放打包后的文件&lt;/p&gt;
&lt;p&gt;（4）编辑第（1）步创建的gulpfile.js文件，内容如下:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3eecf66f-8efb-45c9-bed6-99aaec8d9f8b')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_3eecf66f-8efb-45c9-bed6-99aaec8d9f8b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3eecf66f-8efb-45c9-bed6-99aaec8d9f8b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3eecf66f-8efb-45c9-bed6-99aaec8d9f8b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3eecf66f-8efb-45c9-bed6-99aaec8d9f8b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; fs = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; gulp = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gulp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;gulp自身 &lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; uglify= require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gulp-uglify&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入压缩组件&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; concat = require(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gulp-concat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引入合并组建&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; gulp.task(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;taskName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, function() { 
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到src目录下的所有文件夹中的所有js文件&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; gulp.src(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;js/*.js&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; .pipe(uglify())&lt;span&gt;//&lt;/span&gt;&lt;span&gt;压缩 &lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; .pipe(concat(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;all.min.js&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入到all.min.js中 &lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; .pipe(gulp.dest(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./build&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指定目录 &lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; .on(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, callback);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束事件回调&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}); 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查文件体积&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;function callback() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; path = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./build/all.min.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; exists =&lt;span&gt; fs.existsSync(path);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;exists) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; states =&lt;span&gt; fs.statSync(path);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; console.log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file size:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + Math.ceil(states.size / &lt;span&gt;1024&lt;/span&gt;) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;PS：taskName为变量，任务名。可以定义多个task，并根据glup+taskName执行不同的task&lt;/p&gt;
&lt;p&gt;（5）执行gulp命令 ：gulp taskName&lt;/p&gt;
&lt;p&gt;（6）执行成功之后检查build文件是否有all.min.js生成&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 22 Jun 2018 09:33:00 +0000</pubDate>
<dc:creator>Dupont</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/surfing/p/9214564.html</dc:identifier>
</item>
<item>
<title>windows下3D文字 - Lightning_S</title>
<link>http://www.cnblogs.com/song-jw/p/9214499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/song-jw/p/9214499.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;简单概述&quot;&gt;&lt;strong&gt;简单概述&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;需要在每一帧的视频图像上面添加3D文字，文字可以自由移动位置，变换各种字体属性，还能进行一些简单动画。然后把处理好的视频图像传个下一个步骤去处理。做的过程中参考了GitHub上的一个开源项目,这个项目有一点内存泄露，需要修改一下。我们的项目主要思路利用opengl+freetype实现，首先使用freetype生成文字的3d顶点，然后使用曲面细分，生成更细致的顶点数据，接着计算顶点的法线，便于后面光照计算。渲染过程，首先把视频图像纹理绘制，然后开启混合，画上3d文字，这些都离屏渲染到一个Framebuffer,使用&lt;code&gt;glBlitFramebuffer&lt;/code&gt;转移到 draw Framebuffer上，最后使用&lt;code&gt;glReadPixels&lt;/code&gt;读取渲染后的图像数据。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;一文字与图像的融合&quot;&gt;&lt;strong&gt;一、文字与图像的融合&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;开始是先绘制的图像纹理，然后切换shader program，开启混合：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
glEnable(GL_BLEND);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果在vs和mingw环境下都是只有视频图像，没有文字，接着我改了一下先绘制文字后面绘制视频图像，开启这种混合：&lt;code&gt;glBlendFunc(GL_ONE_MINUS_DST_ALPHA, GL_DST_ALPHA);&lt;/code&gt;,在vs和mingw都可以显示正常了。目前还没搞清楚为什么前一种情况，文字没有融合进去。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;二离屏渲染&quot;&gt;&lt;strong&gt;二、离屏渲染&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;项目中很多过程都是在cpu里面实现的，所以我们需要把3d文字进行离屏渲染，然后从GPU里面读到内存，这会消耗一定的性能。因为文字的字体大小可变，当放大时候，如果不进行抗锯齿处理，文字会很难看。生成read framebuffer和draw framebuffer,绘制后读取图像数据。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;66&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;//生成两个fbo&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;enum&lt;/span&gt; {color , depth, buffer_count};
GLuint back_buffers[buffer_count];
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; msaa_level = &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;;
glGenFramebuffers(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &amp;amp;m_backfbo);
glBindFramebuffer(GL_FRAMEBUFFER, m_backfbo);
glGenRenderbuffers(buffer_count, back_buffers);
glBindRenderbuffer(GL_RENDERBUFFER, back_buffers[color]);
glRenderbufferStorage(GL_RENDERBUFFER, GL_RGBA8, m_canvasWidth, m_canvasHeight);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER,back_buffers[color]);

glBindRenderbuffer(GL_RENDERBUFFER, back_buffers[depth]);
glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT, m_canvasWidth,m_canvasHeight);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, back_buffers[depth]);

GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (status != GL_FRAMEBUFFER_COMPLETE)
    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;st&quot;&gt;&quot;frame buffer status fail&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;;

GLuint render_buffers[buffer_count];
glGenFramebuffers(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &amp;amp;m_renderfbo);
glBindFramebuffer(GL_FRAMEBUFFER, m_renderfbo);
glGenRenderbuffers(buffer_count, render_buffers);
glBindRenderbuffer(GL_RENDERBUFFER, render_buffers[color]);
glRenderbufferStorageMultisample(GL_RENDERBUFFER, msaa_level, GL_RGBA8, m_canvasWidth, m_canvasHeight);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, render_buffers[color]);
glBindRenderbuffer(GL_RENDERBUFFER, render_buffers[depth]);
glRenderbufferStorageMultisample(GL_RENDERBUFFER, msaa_level,
    GL_DEPTH_COMPONENT24, m_canvasWidth, m_canvasHeight);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, render_buffers[depth]);

status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (status != GL_FRAMEBUFFER_COMPLETE)
    std::cout &amp;lt;&amp;lt; &lt;span class=&quot;st&quot;&gt;&quot;frame buffer status fail&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;;
&lt;span class=&quot;co&quot;&gt;//....after draw&lt;/span&gt;

glBindFramebuffer(GL_READ_FRAMEBUFFER, m_renderfbo);
glBindFramebuffer(GL_DRAW_FRAMEBUFFER, m_backfbo);
glBlitFramebuffer(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, m_canvasWidth, m_canvasHeight, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, m_canvasWidth, m_canvasHeight, GL_COLOR_BUFFER_BIT, GL_NEAREST);
glBindFramebuffer(GL_FRAMEBUFFER, m_backfbo);
glReadPixels(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, m_canvasWidth, m_canvasHeight, GL_RGBA, GL_UNSIGNED_BYTE, offscreen_image); &lt;span class=&quot;co&quot;&gt;//get offscreen image&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后效果如下：&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/song-jw/1240422/o_text_pic.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 22 Jun 2018 09:23:00 +0000</pubDate>
<dc:creator>Lightning_S</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/song-jw/p/9214499.html</dc:identifier>
</item>
</channel>
</rss>