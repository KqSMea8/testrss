<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>致青春————愿我们都能变成更好的自己 - YJLAugus</title>
<link>http://www.cnblogs.com/yjlblog/p/8186406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yjlblog/p/8186406.html</guid>
<description>&lt;h4 id=&quot;致青春愿我们都能变成更好的自己&quot;&gt;致青春————愿我们都能变成更好的自己&lt;/h4&gt;
&lt;p&gt;每天都会疲惫和沮丧，却仍然保持战斗力。以为我知道，只有努力奔向更好的地方，才会遇见更好的你&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/yjlblog/1110802/o_574e9258d109b3de3a992445c7bf6c81800a4cfd.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看见海鸟与风许愿，少年永远平安幸福有人疼爱。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/yjlblog/1110802/o_3423.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;忽然想起，在那个非主流的qq头像和写满小秘密的qq空间还很流行的中学时代，程满满曾经写下这样一条个性状态，她说：&lt;/p&gt;
&lt;p&gt;我爱你，和你无关，对吗？爱一个人爱到奋不顾身，爱到忘记自己，爱到愿意为他做所有看起来荒谬不可能的事，多年之后仍不后悔那段漫长痛苦的暗恋日子和傻傻的自己。对于一个渺小的女孩子来说，最后就算没在一起，也是一件很酷的事情了吧。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/yjlblog/1110802/o_4545.jpg&quot;/&gt;&lt;br/&gt;尤其让人心痛的是，你那么好，你却不知道&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/yjlblog/1110802/o_1231231.jpg&quot;/&gt;&lt;br/&gt;总有一天，你会站到最亮的地方，活成自己曾经渴望的模样。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/yjlblog/1110802/o_1428045092_iwQufgWQ.jpg&quot;/&gt;&lt;br/&gt;真正喜欢一个人的感觉，应该是“我怕来不及我要 抱着你”。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/yjlblog/1110802/o_q231.jpg&quot;/&gt;&lt;br/&gt;你我都应感激尚且单身的日子，才能有这么一段修炼自己的时间，去慢慢变成更好的我们。&lt;/p&gt;
</description>
<pubDate>Wed, 03 Jan 2018 15:44:00 +0000</pubDate>
<dc:creator>YJLAugus</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yjlblog/p/8186406.html</dc:identifier>
</item>
<item>
<title>多域名解析及延伸知识点 - CaiYongji</title>
<link>http://www.cnblogs.com/takeurhand/p/8186407.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/takeurhand/p/8186407.html</guid>
<description>&lt;p&gt;我们想象一下，用户输入网址进行HTTP请求，DNS服务器找到域名对应的IP地址，连接IP地址对应的服务器，那么服务器是如何知道用户是通过A域名还是B域名找到自己的呢？&lt;br/&gt;本文旨在通过通信协议的例子让你更加深入了解HTTP以及一些小技巧，包括反向代理，HTTP报文，三次握手，DNS解析，DNS污染/劫持，HTTPS等。需要注意的是，本文碎片化的知识点实际上涵盖了很多方向和领域，大家可以针对自己的爱好进行有深度的涉猎。&lt;/p&gt;
&lt;p&gt;从实际应用到理论支持，我们由&quot;深&quot;入&quot;浅&quot;，透过现象寻找本质。&lt;/p&gt;

&lt;p&gt;反向代理的作用就是作为中间层来访问内网站点，防止了直接将内容服务器暴露给外网，起到了安全防护的作用，也同样可以实现负载均衡、限流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/678094/201801/678094-20180103234124440-1622301852.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看一下Nginx上多域名配置的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server
{
    listen 80;
    server_name A.com;
    location / {
        proxy_pass http://localhost:11111;
    }
}
server
{
    listen 80;
    server_name B.com;
    location / {
        proxy_pass http://localhost:22222;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上代码所示，A/B域名分别对应主机11111/22222端口。&lt;br/&gt;可以看出，反向代理Nginx可以获取到HTTP请求中的域名。由此可以推断出DNS解析并不是单纯的将域明转换成IP地址。那么我们看一下HTTP报文是什么样子。&lt;/p&gt;

&lt;p&gt;我们打开Chrome监控HTTP请求，可以看到下图所示：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/678094/201801/678094-20180103234133237-2025520601.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中request中Host属性在整个HTTP请求中始终存在，并且不可更改，这也就是Nginx反向代理服务器所判断域名的依据。&lt;/p&gt;
&lt;p&gt;HTTP的Request和Response的全部属性如下图所示：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/678094/201801/678094-20180103234144049-1826772391.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;HTTP协议(应用层)是基于TCP协议(传输层)的，并非从属关系。HTTP通信同样需要三次握手。&lt;br/&gt;举个例子：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;A：请求通话。(SYN)&lt;br/&gt;B：请求通话。收到。(SYN+ACK)&lt;br/&gt;A：收到。(ACK)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/678094/201801/678094-20180103234150596-2009908892.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中SYN代表同步，ACK代表确认。三次握手本身的设计就像是一个君子协议，之所以进行三次握手而非两次握手是为了解决网络延迟所造成的重新分组问题(可以理解为聊天过程中网络延迟导致的答非所问)。&lt;br/&gt;三次握手与项目管理中的沟通模型一样：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/678094/201801/678094-20180103234156612-213035266.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;细细体会，现实沟通中的&quot;传递信息&quot;，&quot;告知收悉&quot;，&quot;反馈信息&quot;和三次握手是一样的。&lt;/p&gt;

&lt;p&gt;DNS服务器是key-value(域名-IP地址)对应的缓存服务器，当HTTP请求中host记录不在本地缓存时，向根(root)服务器转移解析请求。&lt;/p&gt;
&lt;h4 id=&quot;dns劫持&quot;&gt;DNS劫持&lt;/h4&gt;
&lt;p&gt;劫持DNS服务器，进而修改其解析结果。&lt;/p&gt;
&lt;h4 id=&quot;dns污染&quot;&gt;DNS污染&lt;/h4&gt;
&lt;p&gt;对DNS查询进行入侵检测，发现与黑名单上匹配的请求，该服务器就伪装成DNS服务器，给查询者返回虚假结果。它利用了UDP协议是无连接不可靠性。&lt;/p&gt;
&lt;p&gt;DNS解析、CDN加速、VPN网关，这些通信层的东西面涉及到很多知识，我就不过多阐述了。我只说一点，大多数成熟的黑客技术都是基于互联网&lt;strong&gt;协议&lt;/strong&gt;的。&lt;/p&gt;

&lt;p&gt;HTTPS中的s代表secure，也可以理解为&lt;code&gt;HTTPS = HTTP + SSL&lt;/code&gt;。&lt;br/&gt;HTTP默认80端口，HTTPS默认443端口。同时，HTTPS对传输的数据进行加密。&lt;br/&gt;更直观的感受是，访问HTTPS站点需要确认服务器的公钥和加密的证书，进而保证了数据传输的安全。&lt;/p&gt;
&lt;p&gt;通信协议层的东西比较散，我并没有在上下文中进行较强的因果逻辑推断，因而显得知识点比较碎片化。通信层的东西本身和编程关系不大，但这些容易被程序员忽略的知识，往往像是一个纽带一样连接编程概念中的各个知识体系。希望本文对你有所帮助。&lt;/p&gt;
</description>
<pubDate>Wed, 03 Jan 2018 15:43:00 +0000</pubDate>
<dc:creator>CaiYongji</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/takeurhand/p/8186407.html</dc:identifier>
</item>
<item>
<title>Siamese Network理解 - 笨兔勿应</title>
<link>http://www.cnblogs.com/bentuwuying/p/8186364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bentuwuying/p/8186364.html</guid>
<description>&lt;p&gt;提起siamese network一般都会引用这两篇文章： &lt;/p&gt;
&lt;p&gt;《Learning a similarity metric discriminatively, with application to face verification》和《 Hamming Distance Metric Learning》。&lt;/p&gt;
&lt;p&gt;本文主要通过论文《Learning a Similarity Metric Discriminatively, with Application to Face Verification》来理解siamese网络。&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Siamese网络是一种相似性度量方法，当类别数多，但每个类别的样本数量少的情况下可用于类别的识别、分类等。传统的用于区分的分类方法是需要确切的知道每个样本属于哪个类，需要针对每个样本有确切的标签。而且相对来说标签的数量是不会太多的。当类别数量过多，每个类别的样本数量又相对较少的情况下，这些方法就不那么适用了。其实也很好理解，对于整个数据集来说，我们的数据量是有的，但是对于每个类别来说，可以只有几个样本，那么用分类算法去做的话，由于每个类别的样本太少，我们根本训练不出什么好的结果，所以只能去找个新的方法来对这种数据集进行训练，从而提出了siamese网络。siamese网络从数据中去学习一个相似性度量，用这个学习出来的度量去比较和匹配新的未知类别的样本。这个方法能被应用于那些类别数多或者整个训练样本无法用于之前方法训练的分类问题。&lt;/p&gt;
&lt;h2 id=&quot;主要思想&quot;&gt;主要思想&lt;/h2&gt;
&lt;p&gt;主要思想是通过一个函数将输入映射到目标空间，在目标空间使用简单的距离（欧式距离等）进行对比相似度。在训练阶段去最小化来自相同类别的一对样本的损失函数值，最大化来自不同类别的一堆样本的损失函数值。给定一组映射函数&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202163818009?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;,其中参数为W，我们的目的就是去找一组参数W。使得当&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202163910877?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;和&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202163955253?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;属于同一个类别的时候，相似性度量&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202164115060?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;是一个较小的值，当&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202164143910?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;和&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202164207847?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;属于不同的类别的时候，相似性度量&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202164231629?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;较大。这个系统是用训练集中的成对样本进行训练。当&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202164258723?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;和&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202164317266?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;来自相同类别的时候，最小化损失函数&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202164806102?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;，当&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202164837209?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;和&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202164858041?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;来自不同类别的时候，最大化&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202164918647?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;。这里的&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202164941288?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;除了需要可微外不需要任何的前提假设，因为针对成对样本输入，这里两个相同的函数G，拥有一份相同的参数W，即这个结构是对称的，我们将它叫做siamese architecture。 &lt;br/&gt;在这篇论文中，作者用这个网络去做面部识别，比较两幅图片是不是同一个人，而且这个网络的一个优势是可以去区分那些新的没有经过训练的类别的样本。&lt;/p&gt;
&lt;p&gt;Siamese也算是降维方法的一种。常见的降维方法有PCA、LDA、Kernel-PCA、MDS、LLE、LB、ISOmap、FA等不做具体介绍。&lt;/p&gt;
&lt;h2 id=&quot;网络结构&quot;&gt;网络结构&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202162540980?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt; &lt;br/&gt;上图是论文中的网络结构图，左右两边两个网络是完全相同的网络结构，它们共享相同的权值W，输入数据为一对图片（X1,X2,Y）,其中Y=0表示X1和X2属于同一个人的脸，Y=1则表示不为同一个人。即相同对为（X1,X2,0）,欺骗对为（X1,X2’,1）针对两个不同的输入X1和X2，分别输出低维空间结果为&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202165039679?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;和&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202165104616?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;，它们是由&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202165128070?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;和&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202165144669?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;经过网络映射得到的。然后将得到的这两个输出结果使用能量函数&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202165205373?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;进行比较。 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202165228358?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;损失函数定义&quot;&gt;损失函数定义&lt;/h2&gt;
&lt;p&gt;我们假设损失函数只和输入和参数有关，那么我们损失函数的形式为： &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202162649258?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt; &lt;br/&gt;其中&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202162835528?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;是第i个样本，是由一对图片和一个标签组成的，其中LG是只计算相同类别对图片的损失函数，LI是只计算不相同类别对图片的损失函数。P是训练的样本数。通过这样分开设计，可以达到当我们要最小化损失函数的时候，可以减少相同类别对的能量，增加不相同对的能量。很简单直观的方法是实现这个的话，我们只要将LG设计成单调增加，让LI单调递减就可以了，但是我们要保证一个前提就是，不相同的图片对距离肯定要比相同图片对的距离小，那么就是要满足： &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202162908557?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt; &lt;br/&gt;所以论文中用了一个 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202162934029?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt; &lt;br/&gt;作为总的损失函数，可以满足这个condition1。论文中进行了各种假设的证明已经单调性的证明，这里不再重复。 &lt;br/&gt;最后给出一个精确的对单个样本的损失函数： &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202165705598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt; &lt;br/&gt;其中 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202163016043?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt; &lt;br/&gt;,Q是一个常量。 &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202163032887?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;上图说明了收敛性。&lt;/p&gt;
&lt;h2 id=&quot;总结思想&quot;&gt;总结思想&lt;/h2&gt;
&lt;p&gt;其实讲了这么多，主要思想就是三点： &lt;br/&gt;1、输入不再是单个样本，而是一对样本，不再给单个的样本确切的标签，而且给定一对样本是否来自同一个类的标签，是就是0，不是就是1 &lt;br/&gt;2、设计了两个一模一样的网络，网络共享权值W，对输出进行了距离度量，可以说l1、l2等。 &lt;br/&gt;3、针对输入的样本对是否来自同一个类别设计了损失函数，损失函数形式有点类似交叉熵损失： &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202165807340?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt; &lt;br/&gt;最后使用获得的损失函数，使用梯度反传去更新两个网络共享的权值W。&lt;/p&gt;
&lt;h2 id=&quot;优点&quot;&gt;优点&lt;/h2&gt;
&lt;p&gt;这个网络主要的优点是淡化了标签，使得网络具有很好的扩展性，可以对那些没有训练过的类别进行分类，这点是优于很多算法的。而且这个算法对一些小数据量的数据集也适用，变相的增加了整个数据集的大小，使得数据量相对较小的数据集也能用深度网络训练出不错的效果。&lt;/p&gt;
&lt;h2 id=&quot;实验设计&quot;&gt;实验设计&lt;/h2&gt;
&lt;p&gt;实验的时候要注意，输入数据最好打乱，由于这样去设计数据集后，相同类的样本对肯定比不相同的样本对数量少，在进行训练的时候最后将两者的数据量设置成相同数量。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文解释的只是最早提出的siamese网络结构，提出的是一种网络结构思想，具体的使用的网络形式完全可以自己定义。包括损失函数，相似度距离的定义等。比如将损失函数的&lt;img title=&quot;&quot; src=&quot;http://img.blog.csdn.net/20170202165859325?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc3hmMTA2MTkyNjk1OQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;用hige loss代替等。 &lt;br/&gt;《Hamming Distance Metric Learning》这篇论文对siamese进一步改进，提出了一个triple net，主要贡献是将成对样本改成了三个样本，输入由（X1,X2,Y）变成了（X1，X2，X1’），表示X1和X1’是相同类别的样本，X1和x2是不同样本的类别。 &lt;br/&gt;《Learning to Compare Image Patches via Convolutional Neural Networks》这篇论文写得也很好，将两个网络进行合并，输入的成对标签直接同时输入同一个网络。&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Shicoder/DeepLearning_Demo/tree/master/siamese_tf_mnist&quot; target=&quot;_blank&quot;&gt;使用tensorflow在mnist上实现的siamese net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/norouzi/hdml&quot; target=&quot;_blank&quot;&gt;参考文献2的官方code&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;[1] &lt;a href=&quot;http://yann.lecun.com/exdb/publis/pdf/chopra-05.pdf&quot; target=&quot;_blank&quot;&gt;S. Chopra, R. Hadsell, and Y. LeCun. Learning a similarity metric discriminatively, with application to face verification. In Computer Vision and Pattern Recognition, 2005. CVPR 2005. IEEE Computer Society Conference on, volume 1, pages 539–546. IEEE, 2005.&lt;/a&gt; &lt;br/&gt;[2] &lt;a href=&quot;http://www.cs.toronto.edu/~norouzi/research/papers/hdml.pdf&quot; target=&quot;_blank&quot;&gt;Mohammad Norouzi, David J. Fleet, Ruslan Salakhutdinov, Hamming Distance Metric Learning, Neural Information Processing Systems (NIPS), 2012.&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 03 Jan 2018 15:26:00 +0000</pubDate>
<dc:creator>笨兔勿应</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bentuwuying/p/8186364.html</dc:identifier>
</item>
<item>
<title>UWP Windows历史上最漂亮的UWP框架出炉！！！ - 星期八再娶你</title>
<link>http://www.cnblogs.com/hupo376787/p/8186228.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hupo376787/p/8186228.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;UWP Windows历史上最漂亮的UWP框架出炉！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;本框架基于微软的开源项目WTS开发，并在其基础上增加了FDS（流畅设计元素，高光、亚克力等）、多语言系统、沉浸式体验（扩展内容到标题栏）&lt;/p&gt;
&lt;p&gt;同时又保留了WTS的强大扩展性，你可以添加你所需要的页面，来快速定制自己个性化的App。&lt;/p&gt;

&lt;p&gt;先看图，有图有真相！（点开图看原图更清晰）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Light Mode:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/298986/201801/298986-20180103214519643-1369810260.jpg&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;645&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/298986/201801/298986-20180103214542440-1036620968.jpg&quot; alt=&quot;&quot; width=&quot;1200&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Dark mode:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/298986/201801/298986-20180103214550753-712797184.jpg&quot; alt=&quot;&quot; width=&quot;1200&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;简介：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0、App.xaml(.cs)&lt;/p&gt;
&lt;p&gt;　　启动App的引导，包含了类似C语言的Main()函数一样&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、ShellPage.xaml(.cs)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　App的运行壳，修改其xaml可同意定制App的外观，同时包含了左侧导航菜单，右侧的Content。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这二者都运用了Fluent Design System元素，所以App才显得这么漂亮&lt;/span&gt;😜&lt;/p&gt;
&lt;p&gt;2、MainPage.xaml(.cs)&lt;/p&gt;
&lt;p&gt;　　主界面，即打开App要呈现给用户的界面&lt;/p&gt;
&lt;p&gt;3、FirstRunDialog.xaml(.cs)&lt;/p&gt;
&lt;p&gt;　　第一次运行时展现给用户的信息，比如介绍一下你的App。可以通过修改资源文件中的FirstRun_Body.Text来实现&lt;/p&gt;
&lt;p&gt;4、WhatsNewDialog.xaml(.cs)&lt;/p&gt;
&lt;p&gt;　　后续每次更新提供的更新日志等，可以通过修改资源文件中的AfterUpdate_Body.Text来实现&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、SettingsPage.xaml(.cs)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　设置面板，我增加了多语言选项，你基于本框架，还可以添加更多的语言。但是不要忘记在strings文件夹添加对应的资源文件&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;当然，光上面介绍的页面不能够满足对用户层面的需要，那么你可以使用WTS向导，添加需要的页面/功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/298986/201801/298986-20180103220553424-5428939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在你添加了新的页面后，进入ShellPage.xaml.cs中，添加上对应的代码，实现菜单导航。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　 private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PopulateNavItems()
        {
            _primaryItems.Clear();
            _secondaryItems.Clear();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO WTS: Change the symbols for each item as appropriate for your app
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; More on Segoe UI Symbol icons: &lt;/span&gt;&lt;span&gt;https://docs.microsoft.com/windows/uwp/style/segoe-ui-symbol-font&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Or to use an IconElement instead of a Symbol see &lt;/span&gt;&lt;span&gt;https://github.com/Microsoft/WindowsTemplateStudio/blob/master/docs/projectTypes/navigationpane.md&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Edit String/en-US/Resources.resw: Add a menu item title for each page&lt;/span&gt;
            _primaryItems.Add(ShellNavigationItem.FromType&amp;lt;MainPage&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Shell_Main&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.GetLocalized(), Symbol.Document));

            _secondaryItems.Add(ShellNavigationItem.FromType&lt;/span&gt;&amp;lt;SettingsPage&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Shell_Settings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.GetLocalized(), Symbol.Setting));
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在拓展内容到标题栏的时候，需要区分一下桌面版和手机版代码略不同&lt;/p&gt;
&lt;p&gt;手机版不需要设置标题栏，所以需要把标题栏所在的那一行行高设置为0（必选），并且进入全屏模式（可选）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　　if&lt;/span&gt; (!Windows.Foundation.Metadata.ApiInformation.IsTypePresent(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Windows.UI.ViewManagement.StatusBar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Hide default title bar.&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; coreTitleBar =&lt;span&gt; CoreApplication.GetCurrentView().TitleBar;
                coreTitleBar.ExtendViewIntoTitleBar &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                UpdateTitleBarLayout(coreTitleBar);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set XAML element as a draggable region.&lt;/span&gt;
&lt;span&gt;                Window.Current.SetTitleBar(AppTitleBar);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; view =&lt;span&gt; ApplicationView.GetForCurrentView();
                view.TitleBar.ButtonBackgroundColor &lt;/span&gt;=&lt;span&gt; Colors.Transparent;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register a handler for when the size of the overlaid caption control changes.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; For example, when the app moves to a screen with a different DPI.&lt;/span&gt;
                coreTitleBar.LayoutMetricsChanged +=&lt;span&gt; CoreTitleBar_LayoutMetricsChanged;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register a handler for when the title bar visibility changes.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; For example, when the title bar is invoked in full screen mode.&lt;/span&gt;
                coreTitleBar.IsVisibleChanged +=&lt;span&gt; CoreTitleBar_IsVisibleChanged;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                rowTitleBar.Height &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; GridLength(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; view =&lt;span&gt; ApplicationView.GetForCurrentView();
                view.TryEnterFullScreenMode();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还有一点必须注意的是，AppTitleBar背景色必须设置透明，否则标题栏不能移动双击等操作，切记！！！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;Grid x:Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AppTitleBar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Background=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Transparent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关于设置里面的多语言，我选择了存储在本地&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; comboBoxLanguage_SelectionChanged(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, SelectionChangedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; temp =&lt;span&gt; comboBoxLanguage.SelectedItem.ToString();
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;[] tempArr = temp.Split(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            ApplicationData.Current.LocalSettings.Values[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strCurrentLanguage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = tempArr[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你也可以存储在RoamSettings里面来漫游设置，这样可以实现设置跨Win 10平台。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;注意：本框架最低系统要求是创意者更新Build15063（Creators Update），目标系统是秋季创意者更新Build16299（Fall Creators Update）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;项目开源地址：&lt;a href=&quot;https://github.com/hupo376787/A-Beautiful-UWP-Frame.git&quot; target=&quot;_blank&quot;&gt;https://github.com/hupo376787/A-Beautiful-UWP-Frame.git&lt;/a&gt;&lt;/p&gt;



&lt;p&gt; 👇&lt;/p&gt;
&lt;p&gt; 👇&lt;/p&gt;
&lt;p&gt; 👇&lt;/p&gt;
&lt;p&gt; 👇&lt;/p&gt;
&lt;p&gt; 👇&lt;/p&gt;
&lt;p&gt; 👇&lt;/p&gt;
&lt;p&gt; 👇&lt;/p&gt;
&lt;p&gt; 👇&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;彩&lt;/span&gt;&lt;span&gt;蛋&lt;/span&gt;&lt;/span&gt;：敢不敢把ShellPage.xaml中的最外层的Grid fcu:Background 画笔刷子换成 &lt;span&gt;SystemControlBackgroundAccentRevealBorderBrush &lt;/span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/298986/201801/298986-20180103222623581-1670387484.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 03 Jan 2018 14:42:00 +0000</pubDate>
<dc:creator>星期八再娶你</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hupo376787/p/8186228.html</dc:identifier>
</item>
<item>
<title>Mysql 索引优化分析 - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/8146439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/8146439.html</guid>
<description>&lt;p&gt;为什么你写的sql查询慢？为什么你建的索引常失效？通过本章内容，你将学会MySQL性能下降的原因，索引的简介，索引创建的原则，explain命令的使用，以及explain输出字段的意义。助你了解索引，分析索引，使用索引，从而写出更高性能的sql语句。还在等啥子？撸起袖子就是干！&lt;/p&gt;
&lt;h2 id=&quot;案例分析&quot;&gt;案例分析&lt;/h2&gt;
&lt;p&gt;我们先简单了解一下&lt;strong&gt;非关系型数据库&lt;/strong&gt;和&lt;strong&gt;关系型数据库&lt;/strong&gt;的区别。&lt;br/&gt;MongoDB是NoSQL中的一种。NoSQL的全称是Not only SQL，非关系型数据库。它的特点是&lt;strong&gt;性能高&lt;/strong&gt;，&lt;strong&gt;扩张性强&lt;/strong&gt;，&lt;strong&gt;模式灵活&lt;/strong&gt;，在高并发场景表现得尤为突出。但目前它还只是关系型数据库的补充，它在数据的一致性，数据的安全性，查询的复杂性问题上和关系型数据库还存在一定差距。&lt;br/&gt;MySQL是关系性数据库中的一种，&lt;strong&gt;查询功能强&lt;/strong&gt;，&lt;strong&gt;数据一致性高&lt;/strong&gt;，&lt;strong&gt;数据安全性高&lt;/strong&gt;，&lt;strong&gt;支持二级索引&lt;/strong&gt;。但性能方面稍逊与MongoDB，特别是百万级别以上的数据，很容易出现查询慢的现象。这时候需要分析查询慢的原因，一般情况下是程序员sql写的烂，或者是没有键索引，或者是索引失效等原因导致的。&lt;br/&gt;公司ERP系统数据库主要是MongoDB（最接近关系型数据的NoSQL），其次是Redis，MySQL只占很少的部分。现在又重新使用MySQL，归功于阿里巴巴的奇门系统和聚石塔系统。考虑到订单数量已经是百万级以上，对MySQL的性能分析也就显得格外重要。&lt;/p&gt;
&lt;p&gt;我们先通过两个简单的例子来入门。后面会详细介绍各个参数的作用和意义。&lt;br/&gt;说明：需要用到的sql已经放在了github上了，喜欢的同学可以点一下star，哈哈。&lt;a href=&quot;https://github.com/ITDragonBlog/daydayup/tree/master/MySQL/&quot; class=&quot;uri&quot;&gt;https://github.com/ITDragonBlog/daydayup/tree/master/MySQL/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;场景一订单导入通过交易号避免重复导单&quot;&gt;场景一：订单导入，通过交易号避免重复导单&lt;/h3&gt;
&lt;p&gt;业务逻辑：订单导入时，为了避免重复导单，一般会通过交易号去数据库中查询，判断该订单是否已经存在。&lt;/p&gt;
&lt;h4 id=&quot;最基础的sql语句&quot;&gt;最基础的sql语句&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; itdragon_order_list &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; transaction_id = &lt;span class=&quot;ot&quot;&gt;&quot;81X97310V32236260E&quot;&lt;/span&gt;;
+&lt;span class=&quot;co&quot;&gt;-------+--------------------+-------+------+----------+--------------+----------+------------------+-------------+-------------+------------+---------------------+&lt;/span&gt;
| &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt;    | transaction_id     | gross | net  | stock_id | order_status | descript | finance_descript | create_type | order_level | input_user | input_date          |
+&lt;span class=&quot;co&quot;&gt;-------+--------------------+-------+------+----------+--------------+----------+------------------+-------------+-------------+------------+---------------------+&lt;/span&gt;
| &lt;span class=&quot;dv&quot;&gt;10000&lt;/span&gt; | 81X97310V32236260E |   &lt;span class=&quot;fl&quot;&gt;6.6&lt;/span&gt; | &lt;span class=&quot;fl&quot;&gt;6.13&lt;/span&gt; |        &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; |           &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt; | ok       | ok               | auto        |           &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; | itdragon   | &lt;span class=&quot;dv&quot;&gt;2017-08-18&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;17&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;:01:49&lt;/span&gt; |
+&lt;span class=&quot;co&quot;&gt;-------+--------------------+-------+------+----------+--------------+----------+------------------+-------------+-------------+------------+---------------------+&lt;/span&gt;

mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; itdragon_order_list &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; transaction_id = &lt;span class=&quot;ot&quot;&gt;&quot;81X97310V32236260E&quot;&lt;/span&gt;;
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+------+---------------+------+---------+------+------+----------+-------------+&lt;/span&gt;
| &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; | select_type | &lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt;               | &lt;span class=&quot;kw&quot;&gt;partitions&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; | possible_keys | &lt;span class=&quot;kw&quot;&gt;key&lt;/span&gt;  | key_len | &lt;span class=&quot;fu&quot;&gt;ref&lt;/span&gt;  | &lt;span class=&quot;kw&quot;&gt;rows&lt;/span&gt; | filtered | Extra       |
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+------+---------------+------+---------+------+------+----------+-------------+&lt;/span&gt;
|  &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; | SIMPLE      | itdragon_order_list | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;       | &lt;span class=&quot;kw&quot;&gt;ALL&lt;/span&gt;  | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;          | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;    | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt; |    &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; |    &lt;span class=&quot;fl&quot;&gt;33.33&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;Using&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; |
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+------+---------------+------+---------+------+------+----------+-------------+&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询的本身没有任何问题，在线下的测试环境也没有任何问题。可是，功能一旦上线，查询慢的问题就迎面而来。几百上千万的订单，用全表扫描？啊？哼!&lt;br/&gt;怎么知道该sql是全表扫描呢？通过explain命令可以清楚MySQL是如何处理sql语句的。打印的内容分别表示：&lt;br/&gt;&lt;strong&gt;id&lt;/strong&gt; : 查询序列号为1。&lt;br/&gt;&lt;strong&gt;select_type&lt;/strong&gt; : 查询类型是简单查询，简单的select语句没有union和子查询。&lt;br/&gt;&lt;strong&gt;table&lt;/strong&gt; : 表是 itdragon_order_list。&lt;br/&gt;&lt;strong&gt;partitions&lt;/strong&gt; : 没有分区。&lt;br/&gt;&lt;strong&gt;type&lt;/strong&gt; : 连接类型，all表示采用全表扫描的方式。&lt;br/&gt;&lt;strong&gt;possible_keys&lt;/strong&gt; : 可能用到索引为null。&lt;br/&gt;&lt;strong&gt;key&lt;/strong&gt; : 实际用到索引是null。&lt;br/&gt;&lt;strong&gt;key_len&lt;/strong&gt; : 索引长度当然也是null。&lt;br/&gt;&lt;strong&gt;ref&lt;/strong&gt; : 没有哪个列或者参数和key一起被使用。&lt;br/&gt;&lt;strong&gt;Extra&lt;/strong&gt; : 使用了where查询。&lt;br/&gt;因为数据库中只有三条数据，所以rows和filtered的信息作用不大。这里需要重点了解的是type为ALL，全表扫描的性能是最差的，假设数据库中有几百万条数据，在没有索引的帮助下会异常卡顿。&lt;/p&gt;
&lt;h4 id=&quot;初步优化为transaction_id创建索引&quot;&gt;初步优化：为transaction_id创建索引&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;unique&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;index&lt;/span&gt; idx_order_transaID &lt;span class=&quot;kw&quot;&gt;on&lt;/span&gt; itdragon_order_list (transaction_id);
mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; itdragon_order_list &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; transaction_id = &lt;span class=&quot;ot&quot;&gt;&quot;81X97310V32236260E&quot;&lt;/span&gt;;
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+-------+--------------------+--------------------+---------+-------+------+----------+-------+&lt;/span&gt;
| &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; | select_type | &lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt;               | &lt;span class=&quot;kw&quot;&gt;partitions&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt;  | possible_keys      | &lt;span class=&quot;kw&quot;&gt;key&lt;/span&gt;                | key_len | &lt;span class=&quot;fu&quot;&gt;ref&lt;/span&gt;   | &lt;span class=&quot;kw&quot;&gt;rows&lt;/span&gt; | filtered | Extra |
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+-------+--------------------+--------------------+---------+-------+------+----------+-------+&lt;/span&gt;
|  &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; | SIMPLE      | itdragon_order_list | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;       | const | idx_order_transaID | idx_order_transaID | &lt;span class=&quot;dv&quot;&gt;453&lt;/span&gt;     | const |    &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; |      &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;  |
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+-------+--------------------+--------------------+---------+-------+------+----------+-------+&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里创建的索引是唯一索引，而非普通索引。&lt;br/&gt;唯一索引打印的type值是const。表示通过索引一次就可以找到。即找到值就结束扫描返回查询结果。&lt;br/&gt;普通索引打印的type值是ref。表示非唯一性索引扫描。找到值还要继续扫描，直到将索引文件扫描完为止。(这里没有贴出代码)&lt;br/&gt;显而易见，const的性能要远高于ref。并且根据业务逻辑来判断，创建唯一索引是合情合理的。&lt;/p&gt;
&lt;h4 id=&quot;再次优化覆盖索引&quot;&gt;再次优化：覆盖索引&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; transaction_id &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; itdragon_order_list &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; transaction_id = &lt;span class=&quot;ot&quot;&gt;&quot;81X97310V32236260E&quot;&lt;/span&gt;;
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+-------+--------------------+--------------------+---------+-------+------+----------+-------------+&lt;/span&gt;
| &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; | select_type | &lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt;               | &lt;span class=&quot;kw&quot;&gt;partitions&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt;  | possible_keys      | &lt;span class=&quot;kw&quot;&gt;key&lt;/span&gt;                | key_len | &lt;span class=&quot;fu&quot;&gt;ref&lt;/span&gt;   | &lt;span class=&quot;kw&quot;&gt;rows&lt;/span&gt; | filtered | Extra       |
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+-------+--------------------+--------------------+---------+-------+------+----------+-------------+&lt;/span&gt;
|  &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; | SIMPLE      | itdragon_order_list | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;       | const | idx_order_transaID | idx_order_transaID | &lt;span class=&quot;dv&quot;&gt;453&lt;/span&gt;     | const |    &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; |      &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;Using&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;index&lt;/span&gt; |
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+-------+--------------------+--------------------+---------+-------+------+----------+-------------+&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里将&lt;code&gt;select * from&lt;/code&gt; 改为了 &lt;code&gt;select transaction_id from&lt;/code&gt; 后&lt;br/&gt;Extra 显示 Using index，表示该查询使用了覆盖索引，这是一个非常好的消息，说明该sql语句的性能很好。若提示的是Using filesort(使用内部排序)和Using temporary(使用临时表)则表明该sql需要立即优化了。&lt;br/&gt;根据业务逻辑来的，查询结构返回transaction_id 是可以满足业务逻辑要求的。&lt;/p&gt;
&lt;h3 id=&quot;场景二订单管理页面通过订单级别和订单录入时间排序&quot;&gt;场景二，订单管理页面，通过订单级别和订单录入时间排序&lt;/h3&gt;
&lt;p&gt;业务逻辑：优先处理订单级别高，录入时间长的订单。&lt;br/&gt;既然是排序，首先想到的应该是order by， 还有一个可怕的 Using filesort 等着你。&lt;/p&gt;
&lt;h4 id=&quot;最基础的sql语句-1&quot;&gt;最基础的sql语句&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; itdragon_order_list &lt;span class=&quot;kw&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; order_level,input_date;
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+------+---------------+------+---------+------+------+----------+----------------+&lt;/span&gt;
| &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; | select_type | &lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt;               | &lt;span class=&quot;kw&quot;&gt;partitions&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; | possible_keys | &lt;span class=&quot;kw&quot;&gt;key&lt;/span&gt;  | key_len | &lt;span class=&quot;fu&quot;&gt;ref&lt;/span&gt;  | &lt;span class=&quot;kw&quot;&gt;rows&lt;/span&gt; | filtered | Extra          |
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+------+---------------+------+---------+------+------+----------+----------------+&lt;/span&gt;
|  &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; | SIMPLE      | itdragon_order_list | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;       | &lt;span class=&quot;kw&quot;&gt;ALL&lt;/span&gt;  | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;          | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;    | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt; |    &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; |      &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;Using&lt;/span&gt; filesort |
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+------+---------------+------+---------+------+------+----------+----------------+&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先，采用全表扫描就不合理，还使用了文件排序Using filesort，更加拖慢了性能。&lt;br/&gt;MySQL在4.1版本之前文件排序是采用双路排序的算法，由于两次扫描磁盘，I/O耗时太长。后优化成单路排序算法。其本质就是用空间换时间，但如果数据量太大，buffer的空间不足，会导致多次I/O的情况。其效果反而更差。与其找运维同事修改MySQL配置，还不如自己乖乖地建索引。&lt;/p&gt;
&lt;h4 id=&quot;初步优化为order_levelinput_date-创建复合索引&quot;&gt;初步优化：为order_level,input_date 创建复合索引&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;index&lt;/span&gt; idx_order_levelDate &lt;span class=&quot;kw&quot;&gt;on&lt;/span&gt; itdragon_order_list (order_level,input_date);
mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; itdragon_order_list &lt;span class=&quot;kw&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; order_level,input_date;
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+------+---------------+------+---------+------+------+----------+----------------+&lt;/span&gt;
| &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; | select_type | &lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt;               | &lt;span class=&quot;kw&quot;&gt;partitions&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; | possible_keys | &lt;span class=&quot;kw&quot;&gt;key&lt;/span&gt;  | key_len | &lt;span class=&quot;fu&quot;&gt;ref&lt;/span&gt;  | &lt;span class=&quot;kw&quot;&gt;rows&lt;/span&gt; | filtered | Extra          |
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+------+---------------+------+---------+------+------+----------+----------------+&lt;/span&gt;
|  &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; | SIMPLE      | itdragon_order_list | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;       | &lt;span class=&quot;kw&quot;&gt;ALL&lt;/span&gt;  | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;          | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;    | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt; |    &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; |      &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;Using&lt;/span&gt; filesort |
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+------+---------------+------+---------+------+------+----------+----------------+&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建复合索引后你会惊奇的发现，和没创建索引一样？？？都是全表扫描，都用到了文件排序。是索引失效？还是索引创建失败？我们试着看看下面打印情况&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; order_level,input_date &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; itdragon_order_list &lt;span class=&quot;kw&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; order_level,input_date;
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+&lt;/span&gt;
| &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; | select_type | &lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt;               | &lt;span class=&quot;kw&quot;&gt;partitions&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt;  | possible_keys | &lt;span class=&quot;kw&quot;&gt;key&lt;/span&gt;                 | key_len | &lt;span class=&quot;fu&quot;&gt;ref&lt;/span&gt;  | &lt;span class=&quot;kw&quot;&gt;rows&lt;/span&gt; | filtered | Extra       |
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+&lt;/span&gt;
|  &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; | SIMPLE      | itdragon_order_list | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;       | &lt;span class=&quot;kw&quot;&gt;index&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;          | idx_order_levelDate | &lt;span class=&quot;dv&quot;&gt;68&lt;/span&gt;      | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt; |    &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; |      &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;Using&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;index&lt;/span&gt; |
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+-------+---------------+---------------------+---------+------+------+----------+-------------+&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将&lt;code&gt;select * from&lt;/code&gt; 换成了 &lt;code&gt;select order_level,input_date from&lt;/code&gt; 后。type从all升级为index，表示（full index scan）全索引文件扫描，Extra也显示使用了覆盖索引。可是不对啊！！！！检索虽然快了，但返回的内容只有order_level和input_date 两个字段，让业务同事怎么用？难道把每个字段都建一个复合索引？&lt;br/&gt;MySQL没有这么笨，可以使用force index 强制指定索引。在原来的sql语句上修改 &lt;code&gt;force index(idx_order_levelDate)&lt;/code&gt; 即可。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; itdragon_order_list &lt;span class=&quot;kw&quot;&gt;force&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;index&lt;/span&gt;(idx_order_levelDate) &lt;span class=&quot;kw&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; order_level,input_date;
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+-------+---------------+---------------------+---------+------+------+----------+-------+&lt;/span&gt;
| &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; | select_type | &lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt;               | &lt;span class=&quot;kw&quot;&gt;partitions&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt;  | possible_keys | &lt;span class=&quot;kw&quot;&gt;key&lt;/span&gt;                 | key_len | &lt;span class=&quot;fu&quot;&gt;ref&lt;/span&gt;  | &lt;span class=&quot;kw&quot;&gt;rows&lt;/span&gt; | filtered | Extra |
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+-------+---------------+---------------------+---------+------+------+----------+-------+&lt;/span&gt;
|  &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; | SIMPLE      | itdragon_order_list | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;       | &lt;span class=&quot;kw&quot;&gt;index&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;          | idx_order_levelDate | &lt;span class=&quot;dv&quot;&gt;68&lt;/span&gt;      | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt; |    &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; |      &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;  |
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+-------+---------------+---------------------+---------+------+------+----------+-------+&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;再次优化订单级别真的要排序么&quot;&gt;再次优化：订单级别真的要排序么？&lt;/h4&gt;
&lt;p&gt;其实给订单级别排序意义并不大，给订单级别添加索引意义也不大。因为order_level的值可能只有，低，中，高，加急，这四种。对于这种重复且分布平均的字段，排序和加索引的作用不大。&lt;br/&gt;我们能否先固定 order_level 的值，然后再给 input_date 排序？如果查询效果明显，是可以推荐业务同事使用该查询方式。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;mysql&amp;gt; &lt;span class=&quot;kw&quot;&gt;explain&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; itdragon_order_list &lt;span class=&quot;kw&quot;&gt;where&lt;/span&gt; order_level=&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;by&lt;/span&gt; input_date;
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+------+---------------------+---------------------+---------+-------+------+----------+-----------------------+&lt;/span&gt;
| &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; | select_type | &lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt;               | &lt;span class=&quot;kw&quot;&gt;partitions&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; | possible_keys       | &lt;span class=&quot;kw&quot;&gt;key&lt;/span&gt;                 | key_len | &lt;span class=&quot;fu&quot;&gt;ref&lt;/span&gt;   | &lt;span class=&quot;kw&quot;&gt;rows&lt;/span&gt; | filtered | Extra                 |
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+------+---------------------+---------------------+---------+-------+------+----------+-----------------------+&lt;/span&gt;
|  &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; | SIMPLE      | itdragon_order_list | &lt;span class=&quot;kw&quot;&gt;NULL&lt;/span&gt;       | &lt;span class=&quot;fu&quot;&gt;ref&lt;/span&gt;  | idx_order_levelDate | idx_order_levelDate | &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;       | const |    &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; |      &lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;Using&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;index&lt;/span&gt; condition |
+&lt;span class=&quot;co&quot;&gt;----+-------------+---------------------+------------+------+---------------------+---------------------+---------+-------+------+----------+-----------------------+&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和之前的sql比起来，type从index 升级为 ref(非唯一性索引扫描)。索引的长度从68变成了5，说明只用了一个索引。ref也是一个常量。Extra 为Using index condition 表示自动根据临界值，选择索引扫描还是全表扫描。总的来说性能远胜于之前的sql。&lt;/p&gt;
&lt;p&gt;上面两个案例只是快速入门，我们需严记一点：优化是基于业务逻辑来的。绝对不能为了优化而擅自修改业务逻辑。如果能修改当然是最好的。&lt;/p&gt;
&lt;h2 id=&quot;索引简介&quot;&gt;索引简介&lt;/h2&gt;
&lt;p&gt;官方定义：索引（Index） 是帮助MySQL高效获取数据的数据结构。&lt;br/&gt;大家一定很好奇，索引为什么是一种数据结构，它又是怎么提高查询的速度？我们拿最常用的二叉树来分析索引的工作原理。看下面的图片：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/806956/201801/806956-20180103215956799-1078068423.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建索引的优势&lt;br/&gt;1 提高数据的检索速度，降低数据库IO成本：使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度。&lt;br/&gt;2 降低数据排序的成本，降低CPU消耗：索引之所以查的快，是因为先将数据排好序，若该字段正好需要排序，则真好降低了排序的成本。&lt;/p&gt;
&lt;p&gt;创建索引的劣势&lt;br/&gt;1 占用存储空间：索引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上。&lt;br/&gt;2 降低更新表的速度：表的数据发生了变化，对应的索引也需要一起变更，从而减低的更新速度。否则索引指向的物理数据可能不对，这也是索引失效的原因之一。&lt;br/&gt;3 优质索引创建难：索引的创建并非一日之功，也并非一直不变。需要频繁根据用户的行为和具体的业务逻辑去创建最佳的索引。&lt;/p&gt;
&lt;h2 id=&quot;索引分类&quot;&gt;索引分类&lt;/h2&gt;
&lt;p&gt;我们常说的索引一般指的是BTree（多路搜索树）结构组织的索引。其中还有聚合索引，次要索引，复合索引，前缀索引，唯一索引，统称索引，当然除了B+树外，还有哈希索引（hash index）等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单值索引&lt;/strong&gt;：一个索引只包含单个列，一个表可以有多个单列索引&lt;br/&gt;&lt;strong&gt;唯一索引&lt;/strong&gt;：索引列的值必须唯一，但允许有空值&lt;br/&gt;&lt;strong&gt;复合索引&lt;/strong&gt;：一个索引包含多个列，实际开发中推荐使用&lt;br/&gt;实际开发中推荐使用复合索引，并且单表创建的索引个数建议不要超过五个&lt;/p&gt;
&lt;p&gt;基本语法：&lt;br/&gt;创建：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;create&lt;/span&gt; [&lt;span class=&quot;kw&quot;&gt;unique&lt;/span&gt;] &lt;span class=&quot;kw&quot;&gt;index&lt;/span&gt; indexName &lt;span class=&quot;kw&quot;&gt;on&lt;/span&gt; tableName (columnName...)
&lt;span class=&quot;kw&quot;&gt;alter&lt;/span&gt; tableName &lt;span class=&quot;kw&quot;&gt;add&lt;/span&gt; [&lt;span class=&quot;kw&quot;&gt;unique&lt;/span&gt;] &lt;span class=&quot;kw&quot;&gt;index&lt;/span&gt; [indexName] &lt;span class=&quot;kw&quot;&gt;on&lt;/span&gt; (columnName...)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;&lt;span class=&quot;kw&quot;&gt;drop&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;index&lt;/span&gt; [indexName] &lt;span class=&quot;kw&quot;&gt;on&lt;/span&gt; tableName&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;show &lt;span class=&quot;kw&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;from&lt;/span&gt; tableName&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;哪些情况需要建索引：&lt;br/&gt;1 主键，唯一索引&lt;br/&gt;2 经常用作查询条件的字段需要创建索引&lt;br/&gt;3 经常需要排序、分组和统计的字段需要建立索引&lt;br/&gt;4 查询中与其他表关联的字段，外键关系建立索引&lt;/p&gt;
&lt;p&gt;哪些情况不要建索引：&lt;br/&gt;1 表的记录太少，百万级以下的数据不需要创建索引&lt;br/&gt;2 经常增删改的表不需要创建索引&lt;br/&gt;3 数据重复且分布平均的字段不需要创建索引，如 true,false 之类。&lt;br/&gt;4 频发更新的字段不适合创建索引&lt;br/&gt;5 where条件里用不到的字段不需要创建索引&lt;/p&gt;
&lt;h2 id=&quot;性能分析&quot;&gt;性能分析&lt;/h2&gt;
&lt;h3 id=&quot;mysql-自身瓶颈&quot;&gt;MySQL 自身瓶颈&lt;/h3&gt;
&lt;p&gt;MySQL自身参见的性能问题有磁盘空间不足，磁盘I/O太大，服务器硬件性能低。&lt;br/&gt;1 CPU：CPU 在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候&lt;br/&gt;2 IO：磁盘I/O 瓶颈发生在装入数据远大于内存容量的时候&lt;br/&gt;3 服务器硬件的性能瓶颈：top,free,iostat 和 vmstat来查看系统的性能状态&lt;/p&gt;
&lt;h3 id=&quot;explain-分析sql语句&quot;&gt;explain 分析sql语句&lt;/h3&gt;
&lt;p&gt;使用explain关键字可以模拟优化器执行sql查询语句，从而得知MySQL 是如何处理sql语句。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;+&lt;span class=&quot;co&quot;&gt;----+-------------+-------+------------+------+---------------+-----+---------+------+------+----------+-------+&lt;/span&gt;
| &lt;span class=&quot;kw&quot;&gt;id&lt;/span&gt; | select_type | &lt;span class=&quot;kw&quot;&gt;table&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;partitions&lt;/span&gt; | &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; | possible_keys | &lt;span class=&quot;kw&quot;&gt;key&lt;/span&gt; | key_len | &lt;span class=&quot;fu&quot;&gt;ref&lt;/span&gt;  | &lt;span class=&quot;kw&quot;&gt;rows&lt;/span&gt; | filtered | Extra |
+&lt;span class=&quot;co&quot;&gt;----+-------------+-------+------------+------+---------------+-----+---------+------+------+----------+-------+&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;id&quot;&gt;id&lt;/h4&gt;
&lt;p&gt;select 查询的序列号，包含一组可以重复的数字，表示查询中执行sql语句的顺序。一般有三种情况：&lt;br/&gt;第一种：id全部相同，sql的执行顺序是由上至下；&lt;br/&gt;第二种：id全部不同，sql的执行顺序是根据id大的优先执行；&lt;br/&gt;第三种：id既存在相同，又存在不同的。先根据id大的优先执行，再根据相同id从上至下的执行。&lt;/p&gt;
&lt;h4 id=&quot;select_type&quot;&gt;select_type&lt;/h4&gt;
&lt;p&gt;select 查询的类型，主要是用于区别普通查询，联合查询，嵌套的复杂查询&lt;br/&gt;&lt;strong&gt;simple&lt;/strong&gt;：简单的select 查询，查询中不包含子查询或者union&lt;br/&gt;&lt;strong&gt;primary&lt;/strong&gt;：查询中若包含任何复杂的子查询，最外层查询则被标记为primary&lt;br/&gt;&lt;strong&gt;subquery&lt;/strong&gt;：在select或where 列表中包含了子查询&lt;br/&gt;&lt;strong&gt;derived&lt;/strong&gt;：在from列表中包含的子查询被标记为derived（衍生）MySQL会递归执行这些子查询，把结果放在临时表里。&lt;br/&gt;&lt;strong&gt;union&lt;/strong&gt;：若第二个select出现在union之后，则被标记为union，若union包含在from子句的子查询中，外层select将被标记为：derived&lt;br/&gt;&lt;strong&gt;union result&lt;/strong&gt;：从union表获取结果的select&lt;/p&gt;
&lt;h4 id=&quot;partitions&quot;&gt;partitions&lt;/h4&gt;
&lt;p&gt;表所使用的分区，如果要统计十年公司订单的金额，可以把数据分为十个区，每一年代表一个区。这样可以大大的提高查询效率。&lt;/p&gt;
&lt;h4 id=&quot;type&quot;&gt;type&lt;/h4&gt;
&lt;p&gt;这是一个非常重要的参数，连接类型，常见的有：all , index , range , ref , eq_ref , const , system , null 八个级别。&lt;br/&gt;性能从最优到最差的排序：system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; range &amp;gt; index &amp;gt; all&lt;br/&gt;对java程序员来说，若保证查询至少达到range级别或者最好能达到ref则算是一个优秀而又负责的程序员。&lt;br/&gt;&lt;strong&gt;all&lt;/strong&gt;：（full table scan）全表扫描无疑是最差，若是百万千万级数据量，全表扫描会非常慢。&lt;br/&gt;&lt;strong&gt;index&lt;/strong&gt;：（full index scan）全索引文件扫描比all好很多，毕竟从索引树中找数据，比从全表中找数据要快。&lt;br/&gt;&lt;strong&gt;range&lt;/strong&gt;：只检索给定范围的行，使用索引来匹配行。范围缩小了，当然比全表扫描和全索引文件扫描要快。sql语句中一般会有between，in，&amp;gt;，&amp;lt; 等查询。&lt;br/&gt;&lt;strong&gt;ref&lt;/strong&gt;：非唯一性索引扫描，本质上也是一种索引访问，返回所有匹配某个单独值的行。比如查询公司所有属于研发团队的同事，匹配的结果是多个并非唯一值。&lt;br/&gt;&lt;strong&gt;eq_ref&lt;/strong&gt;：唯一性索引扫描，对于每个索引键，表中有一条记录与之匹配。比如查询公司的CEO，匹配的结果只可能是一条记录，&lt;br/&gt;&lt;strong&gt;const&lt;/strong&gt;：表示通过索引一次就可以找到，const用于比较primary key 或者unique索引。因为只匹配一行数据，所以很快，若将主键至于where列表中，MySQL就能将该查询转换为一个常量。&lt;br/&gt;&lt;strong&gt;system&lt;/strong&gt;：表只有一条记录（等于系统表），这是const类型的特列，平时不会出现，了解即可&lt;/p&gt;
&lt;h4 id=&quot;possible_keys&quot;&gt;possible_keys&lt;/h4&gt;
&lt;p&gt;显示查询语句可能用到的索引(一个或多个或为null)，不一定被查询实际使用。仅供参考使用。&lt;/p&gt;
&lt;h4 id=&quot;key&quot;&gt;key&lt;/h4&gt;
&lt;p&gt;显示查询语句实际使用的索引。若为null，则表示没有使用索引。&lt;/p&gt;
&lt;h4 id=&quot;key_len&quot;&gt;key_len&lt;/h4&gt;
&lt;p&gt;显示索引中使用的字节数，可通过key_len计算查询中使用的索引长度。在不损失精确性的情况下索引长度越短越好。key_len 显示的值为索引字段的最可能长度，并非实际使用长度，即key_len是根据表定义计算而得，并不是通过表内检索出的。&lt;/p&gt;
&lt;h4 id=&quot;ref&quot;&gt;ref&lt;/h4&gt;
&lt;p&gt;显示索引的哪一列或常量被用于查找索引列上的值。&lt;/p&gt;
&lt;h4 id=&quot;rows&quot;&gt;rows&lt;/h4&gt;
&lt;p&gt;根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数，值越大越不好。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Using filesort&lt;/strong&gt;： 说明MySQL会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序” 。出现这个就要立刻优化sql。&lt;br/&gt;&lt;strong&gt;Using temporary&lt;/strong&gt;： 使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序 order by 和 分组查询 group by。 出现这个更要立刻优化sql。&lt;br/&gt;&lt;strong&gt;Using index&lt;/strong&gt;： 表示相应的select 操作中使用了覆盖索引（Covering index），避免访问了表的数据行，效果不错！如果同时出现Using where，表明索引被用来执行索引键值的查找。如果没有同时出现Using where，表示索引用来读取数据而非执行查找动作。&lt;br/&gt;覆盖索引（Covering Index） ：也叫索引覆盖，就是select 的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select 列表中的字段，而不必根据索引再次读取数据文件。&lt;br/&gt;&lt;strong&gt;Using index condition&lt;/strong&gt;： 在5.6版本后加入的新特性，优化器会在索引存在的情况下，通过符合RANGE范围的条数 和 总数的比例来选择是使用索引还是进行全表遍历。&lt;br/&gt;&lt;strong&gt;Using where&lt;/strong&gt;： 表明使用了where 过滤&lt;br/&gt;&lt;strong&gt;Using join buffer&lt;/strong&gt;： 表明使用了连接缓存&lt;br/&gt;&lt;strong&gt;impossible where&lt;/strong&gt;： where 语句的值总是false，不可用，不能用来获取任何元素&lt;br/&gt;&lt;strong&gt;distinct&lt;/strong&gt;： 优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作。&lt;/p&gt;
&lt;h4 id=&quot;filtered&quot;&gt;filtered&lt;/h4&gt;
&lt;p&gt;一个百分比的值，和rows 列的值一起使用，可以估计出查询执行计划(QEP)中的前一个表的结果集，从而确定join操作的循环次数。小表驱动大表，减轻连接的次数。&lt;/p&gt;
&lt;p&gt;通过explain的参数介绍，我们可以得知:&lt;br/&gt;1 表的读取顺序(id)&lt;br/&gt;2 数据读取操作的操作类型(type)&lt;br/&gt;3 哪些索引被实际使用(key)&lt;br/&gt;4 表之间的引用(ref)&lt;br/&gt;5 每张表有多少行被优化器查询(rows)&lt;/p&gt;
&lt;h2 id=&quot;性能下降的原因&quot;&gt;性能下降的原因&lt;/h2&gt;
&lt;p&gt;从程序员的角度&lt;br/&gt;1 查询语句写的不好&lt;br/&gt;2 没建索引，索引建的不合理或索引失效&lt;br/&gt;3 关联查询有太多的join&lt;br/&gt;从服务器的角度&lt;br/&gt;1 服务器磁盘空间不足&lt;br/&gt;2 服务器调优配置参数设置不合理&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;1 索引是排好序且快速查找的数据结构。其目的是为了提高查询的效率。&lt;br/&gt;2 创建索引后，查询数据变快，但更新数据变慢。&lt;br/&gt;3 性能下降的原因很可能是索引失效导致。&lt;br/&gt;4 索引创建的原则，经常查询的字段适合创建索引，频繁需要更新的数据不适合创建索引。&lt;br/&gt;5 索引字段频繁更新，或者表数据物理删除容易造成索引失效。&lt;br/&gt;6 擅用 explain 分析sql语句&lt;br/&gt;7 除了优化sql语句外，还可以优化表的设计。如尽量做成单表查询，减少表之间的关联。设计归档表等。&lt;/p&gt;
&lt;p&gt;到这里，MySQL的索引优化分析就结束了，有什么不对的地方，大家可以提出来。如果觉得不错可以点一下推荐。&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;MySQL order by排序优化： &lt;a href=&quot;http://blog.51cto.com/ustb80/1073352&quot; class=&quot;uri&quot;&gt;http://blog.51cto.com/ustb80/1073352&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Jan 2018 14:11:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itdragon/p/8146439.html</dc:identifier>
</item>
<item>
<title>前端学数据结构之树 - 小火柴的蓝色理想</title>
<link>http://www.cnblogs.com/xiaohuochai/p/8184989.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuochai/p/8184989.html</guid>
<description>&lt;h2&gt;前面的话&lt;/h2&gt;
&lt;p&gt;　　前面介绍过一种非顺序数据结构是&lt;a href=&quot;https://www.cnblogs.com/xiaohuochai/p/8183020.html#anchor2&quot; target=&quot;_blank&quot;&gt;散列表&lt;/a&gt;，本文将详细介绍另一种非顺序数据结构——树，它对于存储需要快速查找的数据非常有用&lt;/p&gt;

&lt;h3&gt;数据结构&lt;/h3&gt;
&lt;p&gt;　　树是一种分层数据的抽象模型。现实生活中最常见的树的例子是家谱，或是公司的组织架构图&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree1.png&quot; alt=&quot;tree1&quot; width=&quot;807&quot; height=&quot;465&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部的第一个 节点）以及零个或多个子节点&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree2.png&quot; alt=&quot;tree2&quot; width=&quot;715&quot; height=&quot;411&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　位于树顶部的节点叫作根节点（11）。它没有父节点。树中的每个元素都叫作节点，节点分为内部节点和外部节点。至少有一个子节点的节点称为内部节点（7、5、9、15、13和20是内部节点）。没有子元素的节点称为外部节点或叶节点（3、6、8、10、12、14、18和25是叶节点）。&lt;/p&gt;
&lt;p&gt;　　一个节点可以有祖先和后代。一个节点（除了根节点）的祖先包括父节点、祖父节点、曾祖父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。例如，节点5的祖先有节点7和节点11，后代有节点3和节点6。&lt;/p&gt;
&lt;p&gt;　　有关树的另一个术语是子树。子树由节点和它的后代构成。例如，节点13、12和14构成了上图中树的一棵子树。&lt;/p&gt;
&lt;p&gt;　　节点的一个属性是深度，节点的深度取决于它的祖先节点的数量。比如，节点3有3个祖先节点（5、7和11），它的深度为3。&lt;/p&gt;
&lt;p&gt;　　树的高度取决于所有节点深度的最大值。一棵树也可以被分解成层级。根节点在第0层，它的子节点在第1层，以此类推。上图中的树的高度为3（最大高度已在图中表示——第3层）&lt;/p&gt;

&lt;h3&gt;二叉树&lt;/h3&gt;
&lt;p&gt;　　二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。这些定义有助于我们写出更高效的向/从树中插入、查找和删除节点的算法。二叉树在计算机科学中的应用非常广泛。&lt;/p&gt;
&lt;p&gt;　　二叉搜索树（BST）是二叉树的一种，但是它只允许你在左侧节点存储（比父节点）小的值，在右侧节点存储（比父节点）大（或者等于）的值。上面的图中就展现了一棵二叉搜索树&lt;/p&gt;
&lt;p&gt;【创建BinarySearchTree类】&lt;/p&gt;
&lt;p&gt;　　现在开始创建自己的BinarySearchTree类。首先，声明它的结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function BinarySearchTree() {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Node = function(key){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{1} &lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.left = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; 
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.right = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  };
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{2}&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下图展现了二叉搜索树数据结构的组织方式：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree3.png&quot; alt=&quot;tree3&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　和链表一样，将通过指针来表示节点之间的关系（术语称其为边）。在双向链表中，每个节点包含两个指针，一个指向下一个节点，另一个指向上一个节点。对于树，使用同样的方式（也使用两个指针）。但是，一个指向左侧子节点，另一个指向右侧子节点。因此，将声明一个Node类来表示树中的每个节点（行{1}）。值得注意的一个小细节是，不同于将节点本身称作节点或项，我们将会称其为键。键是树相关的术语中对节点的称呼。&lt;/p&gt;
&lt;p&gt;　　我们将会遵循和LinkedList类中相同的模式，这表示也将声明一个变量以控制此数据结构的第一个节点。在树中，它不再是头节点，而是根元素（行{2}）。然后，我们需要实现一些方法。下面是将要在树类中实现的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;insert(key)：向树中插入一个新的键。
search(key)：在树中查找一个键，如果节点存在，则返回true；如果不存在，则返回 &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;。
inOrderTraverse：通过中序遍历方式遍历所有节点。
preOrderTraverse：通过先序遍历方式遍历所有节点。
postOrderTraverse：通过后序遍历方式遍历所有节点。
min：返回树中最小的值&lt;/span&gt;/&lt;span&gt;键。
max：返回树中最大的值&lt;/span&gt;/&lt;span&gt;键。
remove(key)：从树中移除某个键。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【insert】&lt;/p&gt;
&lt;p&gt;　　下面的代码是用来向树插入一个新键的算法的第一部分：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.insert =&lt;span&gt; function(key){ 
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newNode = &lt;span&gt;new&lt;/span&gt; Node(key); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{1} &lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (root === &lt;span&gt;null&lt;/span&gt;){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{2}     &lt;/span&gt;
    root =&lt;span&gt; newNode;   
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {     
    insertNode(root,newNode); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{3}   &lt;/span&gt;
&lt;span&gt;  } 
}; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　要向树中插入一个新的节点（或项），要经历三个步骤&lt;/p&gt;
&lt;p&gt;　　第一步是创建用来表示新节点的Node类实例（行{1}）。只需要向构造函数传递我们想用来插入树的节点值，它的左指针和右指针的值会由构造函数自动设置为null&lt;/p&gt;
&lt;p&gt;　　第二步要验证这个插入操作是否为一种特殊情况。这个特殊情况就是我们要插入的节点是树的第一个节点（行{2}）。如果是，就将根节点指向新节点&lt;/p&gt;
&lt;p&gt;　　第三步是将节点加在非根节点的其他位置。这种情况下，需要一个私有的辅助函数（行{3}），函数定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; insertNode =&lt;span&gt; function(node, newNode){   
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newNode.key &amp;lt; node.key){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{4}     &lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (node.left === &lt;span&gt;null&lt;/span&gt;){   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{5}       &lt;/span&gt;
      node.left = newNode;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{6}    &lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {       
      insertNode(node.left, newNode); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{7}     &lt;/span&gt;
&lt;span&gt;    }   
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {     
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.right === &lt;span&gt;null&lt;/span&gt;){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{8}       &lt;/span&gt;
      node.right = newNode;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{9}     &lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {      
      insertNode(node.right, newNode); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{10}     &lt;/span&gt;
&lt;span&gt;    }   
  } 
}; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　insertNode函数会帮助我们找到新节点应该插入的正确位置。下面是这个函数实现的步骤&lt;/p&gt;
&lt;p&gt;　　1、如果树非空，需要找到插入新节点的位置。因此，在调用insertNode方法时要通过参数传入树的根节点和要插入的节点&lt;/p&gt;
&lt;p&gt;　　2、如果新节点的键小于当前节点的键（现在，当前节点就是根节点）（行{4}），那么需要检查当前节点的左侧子节点。如果它没有左侧子节点（行{5}），就在那里插入新的节点。如果有左侧子节点，需要通过递归调用insertNode方法（行{7}）继续找到树的下一层。在这里，下次将要比较的节点将会是当前节点的左侧子节点&lt;/p&gt;
&lt;p&gt;　　3、如果节点的键比当前节点的键大，同时当前节点没有右侧子节点（行{8}），就在那里插入新的节点（行{9}）。如果有右侧子节点，同样需要递归调用insertNode方法，但是要用来和新节点比较的节点将会是右侧子节点&lt;/p&gt;
&lt;p&gt;　　考虑下面的情景：我们有一个新的树，并且想要向它插入第一个值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; tree = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinarySearchTree(); 
tree.insert(&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这种情况下，树中有一个单独的节点，根指针将会指向它。源代码的行{2}将会执行。现在，来考虑下图所示树结构的情况：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree4.png&quot; alt=&quot;tree4&quot; width=&quot;614&quot; height=&quot;381&quot;/&gt;&lt;/div&gt;

&lt;p&gt;　　创建上图所示的树的代码如下，它们接着上面一段代码（插入了键为11的节点）之后输入执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
tree.insert(&lt;span&gt;7&lt;/span&gt;&lt;span&gt;); 
tree.insert(&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;&lt;span&gt;);
tree.insert(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;); 
tree.insert(&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;); 
tree.insert(&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&lt;span&gt;); 
tree.insert(&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;); 
tree.insert(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;); 
tree.insert(&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;&lt;span&gt;); 
tree.insert(&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;); 
tree.insert(&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;); 
tree.insert(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;); 
tree.insert(&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;); 
tree.insert(&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　同时我们想要插入一个值为6的键，执行下面的代码： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
tree.insert(&lt;span&gt;6&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面的步骤将会被执行&lt;/p&gt;
&lt;p&gt;　　1、树不是空的，行{3}的代码将会执行。insertNode方法将会被调用（root, key[6]）&lt;/p&gt;
&lt;p&gt;　　2、算法将会检测行{4}（key[6] &amp;lt; root[11]为真），并继续检测行{5}（node.left[7]不是null），然后将到达行{7}并调用insertNode（node.left[7], key[6]）&lt;/p&gt;
&lt;p&gt;　　3、将再次进入insertNode方法内部，但是使用了不同的参数。它会再次检测行{4}（key[6] &amp;lt; node[7]为真），然后再检测行{5}（node.left[5]不是null），接着到达行{7}，调用insertNode（node.left[5], key[6]）&lt;/p&gt;
&lt;p&gt;　　4、将再一次进入insertNode方法内部。它会再次检测行{4}（key[6] &amp;lt; node[5]为假）， 然后到达行{8}（node.right是null——节点5没有任何右侧的子节点），然后将会执行行{9}， 在节点5的右侧子节点位置插入键6&lt;/p&gt;
&lt;p&gt;　　5、然后，方法调用会依次出栈，代码执行过程结束&lt;/p&gt;
&lt;p&gt;　　这是插入键6后的结果：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree5.png&quot; alt=&quot;tree5&quot; width=&quot;637&quot; height=&quot;393&quot;/&gt;&lt;/div&gt;

&lt;h3&gt;树的遍历&lt;/h3&gt;
&lt;p&gt;　　遍历一棵树是指访问树的每个节点并对它们进行某种操作的过程。但是我们应该怎么去做呢？应该从树的顶端还是底端开始呢？从左开始还是从右开始呢？访问树的所有节点有三种方式：中序、先序和后序。下面将详细介绍这三种遍历方式的用法和实现&lt;/p&gt;
&lt;p&gt;【中序遍历】&lt;/p&gt;
&lt;p&gt;　　中序遍历是一种以上行顺序访问BST所有节点的遍历方式，也就是以从最小到最大的顺序访问所有节点。中序遍历的一种应用就是对树进行排序操作。我们来看它的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.inOrderTraverse =&lt;span&gt; function(callback){               
  inOrderTraverseNode(root, callback); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{1} &lt;/span&gt;
}; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　inOrderTraverse方法接收一个回调函数作为参数。回调函数用来定义我们对遍历到的每个节点进行的操作（这也叫作访问者模式）。由于我们在BST中最常实现的算法是递归，这里使用了一个私有的辅助函数，来接收一个节点和对应的回调函数作为参数（行{1}）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; inOrderTraverseNode =&lt;span&gt; function (node, callback) { 
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node !== &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{2}&lt;/span&gt;
    inOrderTraverseNode(node.left, callback); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{3} &lt;/span&gt;
    callback(node.key); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{4} &lt;/span&gt;
    inOrderTraverseNode(node.right, callback); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{5}&lt;/span&gt;
&lt;span&gt;  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　要通过中序遍历的方法遍历一棵树，首先要检查以参数形式传入的节点是否为null（这就是停止递归继续执行的判断条件——行{2}——递归算法的基本条件）。然后，递归调用相同的函数来访问左侧子节点（行{3}）。接着对这个节点进行一些操作（callback），然后再访问右侧子节点（行{5}）&lt;/p&gt;
&lt;p&gt;　　试着在之前展示的树上执行下面的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
function printNode(value){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{6}&lt;/span&gt;
&lt;span&gt;  console.log(value);
}
tree.inOrderTraverse(printNode);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{7}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　但首先，需要创建一个回调函数（行{6}）。要做的是在浏览器的控制台上输出节点的值。然后，调用inOrderTraverse方法并将回调函数作为参数传入（行{7}）。当执行上面的代码后，下面的结果将会在控制台上输出（每个数字将会输出在不同的行）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;6&lt;/span&gt; &lt;span&gt;7&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; &lt;span&gt;9&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;11&lt;/span&gt; &lt;span&gt;12&lt;/span&gt; &lt;span&gt;13&lt;/span&gt; &lt;span&gt;14&lt;/span&gt; &lt;span&gt;15&lt;/span&gt; &lt;span&gt;18&lt;/span&gt; &lt;span&gt;20&lt;/span&gt; &lt;span&gt;25&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面的图描绘了inOrderTraverse方法的访问路径：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree6.png&quot; alt=&quot;tree6&quot; width=&quot;662&quot; height=&quot;402&quot;/&gt;&lt;/div&gt;
&lt;p&gt;【先序遍历】&lt;/p&gt;
&lt;p&gt;　　先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构化的文档。下面来看实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.preOrderTraverse =&lt;span&gt; function(callback){ 
  preOrderTraverseNode(root, callback);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　preOrderTraverseNode方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; preOrderTraverseNode =&lt;span&gt; function (node, callback) { 
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    callback(node.key); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{1} &lt;/span&gt;
    preOrderTraverseNode(node.left, callback); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{2} &lt;/span&gt;
    preOrderTraverseNode(node.right, callback); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{3}&lt;/span&gt;
&lt;span&gt;  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　先序遍历和中序遍历的不同点是，先序遍历会先访问节点本身（行{1}），然后再访问它的左侧子节点（行{2}），最后是右侧子节点（行{3}），而中序遍历的执行顺序是：{2}、{1}和{3}&lt;/p&gt;
&lt;p&gt;　　下面是控制台上的输出结果（每个数字将会输出在不同的行）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;7&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;6&lt;/span&gt; &lt;span&gt;9&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;15&lt;/span&gt; &lt;span&gt;13&lt;/span&gt; &lt;span&gt;12&lt;/span&gt; &lt;span&gt;14&lt;/span&gt; &lt;span&gt;20&lt;/span&gt; &lt;span&gt;18&lt;/span&gt; &lt;span&gt;25&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面的图描绘了preOrderTraverse方法的访问路径： &lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree7.png&quot; alt=&quot;tree7&quot; width=&quot;625&quot; height=&quot;443&quot;/&gt;&lt;/div&gt;
&lt;p&gt;【后序遍历】&lt;/p&gt;
&lt;p&gt;　　后序遍历则是先访问节点的后代节点，再访问节点本身。后序遍历的一种应用是计算一个目录和它的子目录中所有文件所占空间的大小。下面来看它的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.postOrderTraverse =&lt;span&gt; function(callback){ 
  postOrderTraverseNode(root, callback);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　postOrderTraverseNode方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; postOrderTraverseNode =&lt;span&gt; function (node, callback) { 
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    postOrderTraverseNode(node.left, callback); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{1} &lt;/span&gt;
    postOrderTraverseNode(node.right, callback); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{2} &lt;/span&gt;
    callback(node.key);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{3}&lt;/span&gt;
&lt;span&gt;  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个例子中，后序遍历会先访问左侧子节点（行{1}），然后是右侧子节点（行{2}），最后是父节点本身（行{3}）&lt;/p&gt;
&lt;p&gt;　　中序、先序和后序遍历的实现方式是很相似的，唯一不同的是行{1}、{2}和{3} 的执行顺序。下面是控制台的输出结果（每个数字将会输出在不同行）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;6&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;9&lt;/span&gt; &lt;span&gt;7&lt;/span&gt; &lt;span&gt;12&lt;/span&gt; &lt;span&gt;14&lt;/span&gt; &lt;span&gt;13&lt;/span&gt; &lt;span&gt;18&lt;/span&gt; &lt;span&gt;25&lt;/span&gt; &lt;span&gt;20&lt;/span&gt; &lt;span&gt;15&lt;/span&gt; &lt;span&gt;11&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree8.png&quot; alt=&quot;tree8&quot; width=&quot;635&quot; height=&quot;389&quot;/&gt;&lt;/div&gt;

&lt;h3&gt;树的搜索&lt;/h3&gt;
&lt;p&gt;　　在树中，有三种经常执行的搜索类型：1、最小值；2、最大值；3、搜索特定的值。下面将详细介绍这三种搜索类型&lt;/p&gt;
&lt;p&gt;【最值】&lt;/p&gt;
&lt;p&gt;　　使用下面的树作为示例：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree9.png&quot; alt=&quot;tree9&quot; width=&quot;611&quot; height=&quot;375&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　如果看一眼树最后一层最左侧的节点，会发现它的值为3，这是这棵树中最小的键。如果再看一眼树最右端的节点（同样是树的最后一层），会发现它的值为25，这是这棵树中最大的键。这条信息在我们实现搜索树节点的最小值和最大值的方法时能给予我们很大的帮助&lt;/p&gt;
&lt;p&gt;　　首先来看寻找树的最小键的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.min =&lt;span&gt; function() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; minNode(root); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{1}&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　min方法将会暴露给用户。这个方法调用了minNode方法（行{1}）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; minNode =&lt;span&gt; function (node) { 
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (node){
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (node &amp;amp;&amp;amp; node.left !== &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{2} &lt;/span&gt;
      node = node.left;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{3}&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node.key;
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{4}&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　minNode方法允许我们从树中任意一个节点开始寻找最小的键。我们可以使用它来找到一棵树或它的子树中最小的键。因此，我们在调用minNode方法的时候传入树的根节点（行{1}），因为我们想要找到整棵树的最小键。在minNode内部，我们会遍历树的左边（行{2}和行{3}）直到找到树的最下层（最左端）&lt;/p&gt;
&lt;p&gt;　　以相似的方式，可以实现max方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.max =&lt;span&gt; function() {   
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; maxNode(root); 
}; 
 
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; maxNode =&lt;span&gt; function (node) {   
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (node){     
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (node &amp;amp;&amp;amp; node.right !== &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{5}       &lt;/span&gt;
      node =&lt;span&gt; node.right;     
    } 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node.key;   
  }   
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; 
}; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　要找到最大的键，我们要沿着树的右边进行遍历（行{5}）直到找到最右端的节点。 因此，对于寻找最小值，总是沿着树的左边；而对于寻找最大值，总是沿着树的右边&lt;/p&gt;
&lt;p&gt;【特定值】&lt;/p&gt;
&lt;p&gt;　　下面来看搜索特定值的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.search =&lt;span&gt; function(key){   
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; searchNode(root, key); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{1} &lt;/span&gt;
&lt;span&gt;}; 
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; searchNode =&lt;span&gt; function(node, key){ 
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node === &lt;span&gt;null&lt;/span&gt;){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{2}     &lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;   
  } 
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key &amp;lt; node.key){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{3}     &lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; searchNode(node.left, key);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{4} &lt;/span&gt;
  } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key &amp;gt; node.key){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{5}     &lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; searchNode(node.right, key); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{6} &lt;/span&gt;
  } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {     
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{7}   &lt;/span&gt;
&lt;span&gt;  } 
}; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们要做的第一件事，是声明search方法。和BST中声明的其他方法的模式相同，我们将会使用一个辅助函数（行{1}）。searchNode方法可以用来寻找一棵树或它的任意子树中的一个特定的值。这也是为什么在行{1}中调用它的时候传入树的根节点作为参数。&lt;/p&gt;
&lt;p&gt;　　在开始算法之前，先要验证作为参数传入的node是否合法（不是null）。如果是null的话，说明要找的键没有找到，返回false。如果传入的节点不是null，需要继续验证。如果要找的键比当前的节点小（行{3}），那么继续在左侧的子树上搜索（行{4}）。如果要找的键比当前的节点大，那么就从右侧子节点开始继续搜索（行{6}），否则就说明要找的键和当前节点的键相等，就返回true来表示找到了这个键（行{7}）。&lt;/p&gt;
&lt;p&gt;　　可以通过下面的代码来测试这个方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
console.log(tree.search(&lt;span&gt;1&lt;/span&gt;) ? &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Key 1 found.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; : &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Key 1 not found.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); &lt;br/&gt;console.log(tree.search(&lt;span&gt;8&lt;/span&gt;) ? &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Key 8 found.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; : &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Key 8 not found.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Value &lt;span&gt;1&lt;/span&gt;&lt;span&gt; not found. 
Value &lt;/span&gt;&lt;span&gt;8&lt;/span&gt; found.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面来详细介绍查找1这个键的时候方法是如何执行的&lt;/p&gt;
&lt;p&gt;　　1、调用searchNode方法，传入根节点作为参数（行{1}）。（node[root[11]]）不是null（行{2}），因此我们执行到行{3}&lt;/p&gt;
&lt;p&gt;　　2、（key[1]&amp;lt;node[11]）为ture（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[7],key[1]）作为参数&lt;/p&gt;
&lt;p&gt;　　3、（node[7]）不是null（{2}），因此继续执行行{3}&lt;/p&gt;
&lt;p&gt;　　4、（key[1]&amp;lt;node[7]）为ture（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[5],key[1]）作为参数&lt;/p&gt;
&lt;p&gt;　　5、（node[5]）不是null（行{2}），因此继续执行行{3}&lt;/p&gt;
&lt;p&gt;　　6、（key[1]&amp;lt;node[5]）为ture（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[3],key[1]）作为参数&lt;/p&gt;
&lt;p&gt;　　7、（node[3]）不是null（行{2}），因此来到行{3}&lt;/p&gt;
&lt;p&gt;　　8、（key[1]&amp;lt;node[3]）为真（行{3}），因此来到行{4}并再次调用searchNode方法，传入（null,key[1]）作为参数。null被作为参数传入是因为node[3]是一个叶节点（它没有子节点，所以它的左侧子节点的值为null）&lt;/p&gt;
&lt;p&gt;　　9、节点（null）的值为null（行{2}，这时要搜索的节点为null），因此返回false&lt;/p&gt;
&lt;p&gt;　　10、然后，方法调用会依次出栈，代码执行过程结束&lt;/p&gt;
&lt;p&gt;　　下面再来查找值为8的节点：&lt;/p&gt;
&lt;p&gt;　　1、调用searchNode方法，传入root作为参数（行{1}）。（node[root[11]]）不是null（行{2}），因此我们来到行{3}&lt;/p&gt;
&lt;p&gt;　　2、（key[8]&amp;lt;node[11]）为真（行{3}），因此执行到行{4}并再次调用searchNode方法，传入（node[7],key[8]）作为参数。（node[7]）不是null，因此来到行{3}&lt;/p&gt;
&lt;p&gt;　　3、（key[8]&amp;lt;node[7]）为假（行{3}），因此来到行{5}&lt;/p&gt;
&lt;p&gt;　　4、（key[8]&amp;gt;node[7]）为真（行{5}），因此来到行{6}并再次调用searchNode方法，传入（node[9],key[8]）作为参数。（node[9]）不是null（行{2}），因此来到行{3}&lt;/p&gt;
&lt;p&gt;　　5、（key[8]&amp;lt;node[9]）为真（行{3}），因此来到行{4}并再次调用searchNode方法，传入（node[8],key[8]）作为参数。（node[8]）不是null（行{2}），因此来到行{3}&lt;/p&gt;
&lt;p&gt;　　6、（key[8]&amp;lt;node[8]）为假（行{3}），因此来到行{5}&lt;/p&gt;
&lt;p&gt;　　7、（key[8]&amp;gt;node[8]）为假（行{5}），因此来到行{7}并返回true，因为node[8]就是要找的键&lt;/p&gt;
&lt;p&gt;　　8、然后，方法调用会依次出栈，代码执行过程结束&lt;/p&gt;
&lt;p&gt;【移除一个节点】&lt;/p&gt;
&lt;p&gt;　　先创建这个remove方法，使它能够在树的实例上被调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;this&lt;/span&gt;.remove =&lt;span&gt; function(key){
  root &lt;/span&gt;= removeNode(root, key); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{1}&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个方法接收要移除的键并且它调用了removeNode方法，传入root和要移除的键作为参数（行{1}）。要注意的是，root被赋值为removeNode方法的返回值&lt;/p&gt;
&lt;p&gt;　　removeNode方法的复杂之处在于我们要处理不同的运行场景，当然也包括它同样是通过递归来实现的。下面来看removeNode方法的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; removeNode =&lt;span&gt; function(node, key){ 
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node === &lt;span&gt;null&lt;/span&gt;){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{2}     &lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;   
  } 
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key &amp;lt; node.key){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{3}     &lt;/span&gt;
    node.left = removeNode(node.left, key); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{4} &lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; node; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{5} &lt;/span&gt;
  } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key &amp;gt; node.key){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{6}    &lt;/span&gt;
    node.right = removeNode(node.right, key); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{7}     &lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; node; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{8} &lt;/span&gt;
  } &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;键等于node.key 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一种情况——一个叶节点     &lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (node.left === &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; node.right === &lt;span&gt;null&lt;/span&gt;){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{9}      &lt;/span&gt;
      node = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{10}       &lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; node; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{11}     &lt;/span&gt;
&lt;span&gt;    } 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二种情况——一个只有一个子节点的节点     &lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (node.left === &lt;span&gt;null&lt;/span&gt;){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{12}       &lt;/span&gt;
      node = node.right; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{13}&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; node; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{14} &lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (node.right === &lt;span&gt;null&lt;/span&gt;){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{15}       &lt;/span&gt;
      node = node.left; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{16}       &lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; node; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{17}     &lt;/span&gt;
&lt;span&gt;    } 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第三种情况——一个有两个子节点的节点     &lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; aux = findMinNode(node.right); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{18}     &lt;/span&gt;
    node.key = aux.key; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{19}     &lt;/span&gt;
    node.right = removeNode(node.right, aux.key); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{20}     &lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; node; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{21}   &lt;/span&gt;
&lt;span&gt;  } 
}; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面来看行{2}，如果正在检测的节点是null，那么说明键不存在于树中，所以返回null。然后要做的第一件事，就是在树中找到要移除的节点。因此，如果要找的键比当前节点的值小（行{3}），就沿着树的左边找到下一个节点（行{4}）。如果要找的键比当前节点的值大（行{6}），那么就沿着树的右边找到下一个节点（行{7}）。如果找到了要找的键（键和node.key相等），就需要处理三种不同的情况&lt;/p&gt;
&lt;p&gt;　　findMinNode方法如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; findMinNode =&lt;span&gt; function(node){   
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (node &amp;amp;&amp;amp; node.left !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {     
    node &lt;/span&gt;=&lt;span&gt; node.left;   
  }   
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node; 
}; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1、移除一个叶节点&lt;/p&gt;
&lt;p&gt;　　第一种情况是该节点是一个没有左侧或右侧子节点的叶节点——行{9}。在这种情况下，要做的就是给这个节点赋予null值来移除它（行{9}）。但是仅仅赋一个null值是不够的，还需要处理指针。在这里，这个节点没有任何子节点，但是它有一个父节点，需要通过返回null来将对应的父节点指针赋予null值（行{11}）&lt;/p&gt;
&lt;p&gt;　　现在节点的值已经是null了，父节点指向它的指针也会接收到这个值，这也是我们要在函数中返回节点的值的原因。父节点总是会接收到函数的返回值。另一种可行的办法是将父节点和节点本身都作为参数传入方法内部&lt;/p&gt;
&lt;p&gt;　　如果回头来看方法的第一行代码，会发现我们在行{4}和行{7}更新了节点左右指针的值，同样也在行{5}和行{8}返回了更新后的节点。下图展现了移除一个叶节点的过程：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree10.png&quot; alt=&quot;tree10&quot; width=&quot;711&quot; height=&quot;437&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　2、移除有一个左侧或右侧子节点的节点&lt;/p&gt;
&lt;p&gt;　　现在来看第二种情况，移除有一个左侧子节点或右侧子节点的节点。这种情况下，需要跳过这个节点，直接将父节点指向它的指针指向子节点。如果这个节点没有左侧子节点（行{12}），也就是说它有一个右侧子节点。因此我们把对它的引用改为对它右侧子节点的引用（行{13}）并返回更新后的节点（行{14}）。如果这个节点没有右侧子节点，也是一样——把对它的引用改为对它左侧子节点的引用（行{16}）并返回更新后的值（行{17}）&lt;/p&gt;
&lt;p&gt;　　下图展现了移除只有一个左侧子节点或右侧子节点的节点的过程：&lt;/p&gt;
&lt;div readability=&quot;118.5&quot;&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree11.png&quot; alt=&quot;tree11&quot; width=&quot;589&quot; height=&quot;363&quot;/&gt;　
&lt;p&gt;　　3、移除有两个子节点的节点&lt;/p&gt;
&lt;p&gt;　　现在是第三种情况，也是最复杂的情况，那就是要移除的节点有两个子节点——左侧子节点和右侧子节点。要移除有两个子节点的节点，需要执行四个步骤。(1)当找到了需要移除的节点后，需要找到它右边子树中最小的节点（它的继承者——行{18}）；(2)然后，用它右侧子树中最小节点的键去更新这个节点的值（行{19}）。通过这一步，改变了这个节点的键，也就是说它被移除了；(3)但是，这样在树中就有两个拥有相同键的节点了，这是不行的。要继续把右侧子树中的最小节点移除，毕竟它已经被移至要移除的节点的位置了（行{20}）；(4)最后，向它的父节点返回更新后节点的引用（行{21}）&lt;/p&gt;
&lt;p&gt;　　findMinNode方法的实现和min方法的实现方式是一样的。唯一不同之处在于，在min方法中只返回键，而在findMinNode中返回了节点。下图展现了移除有两个子节点的节点的过程：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree12.png&quot; alt=&quot;tree12&quot; width=&quot;646&quot; height=&quot;356&quot;/&gt;&lt;/div&gt;
&lt;p&gt;【完整代码】&lt;/p&gt;
&lt;p&gt;　　二叉搜索树BST的完整代码如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function BinarySearchTree() {

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Node =&lt;span&gt; function(key){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.left = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.right = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.insert =&lt;span&gt; function(key){

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newNode = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(key);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;special case - first element&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (root === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            root &lt;/span&gt;=&lt;span&gt; newNode;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            insertNode(root,newNode);
        }
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; insertNode =&lt;span&gt; function(node, newNode){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newNode.key &amp;lt;&lt;span&gt; node.key){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.left === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                node.left &lt;/span&gt;=&lt;span&gt; newNode;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                insertNode(node.left, newNode);
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.right === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                node.right &lt;/span&gt;=&lt;span&gt; newNode;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                insertNode(node.right, newNode);
            }
        }
    };

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getRoot =&lt;span&gt; function(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
    };

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.search =&lt;span&gt; function(key){

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; searchNode(root, key);
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; searchNode =&lt;span&gt; function(node, key){

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key &amp;lt;&lt;span&gt; node.key){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; searchNode(node.left, key);

        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (key &amp;gt;&lt;span&gt; node.key){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; searchNode(node.right, key);

        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;element is equal to node.item&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    };

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.inOrderTraverse =&lt;span&gt; function(callback){
        inOrderTraverseNode(root, callback);
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; inOrderTraverseNode =&lt;span&gt; function (node, callback) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            inOrderTraverseNode(node.left, callback);
            callback(node.key);
            inOrderTraverseNode(node.right, callback);
        }
    };

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.preOrderTraverse =&lt;span&gt; function(callback){
        preOrderTraverseNode(root, callback);
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; preOrderTraverseNode =&lt;span&gt; function (node, callback) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            callback(node.key);
            preOrderTraverseNode(node.left, callback);
            preOrderTraverseNode(node.right, callback);
        }
    };

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.postOrderTraverse =&lt;span&gt; function(callback){
        postOrderTraverseNode(root, callback);
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; postOrderTraverseNode =&lt;span&gt; function (node, callback) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            postOrderTraverseNode(node.left, callback);
            postOrderTraverseNode(node.right, callback);
            callback(node.key);
        }
    };

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.min =&lt;span&gt; function() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; minNode(root);
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; minNode =&lt;span&gt; function (node) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (node){
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (node &amp;amp;&amp;amp; node.left !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                node &lt;/span&gt;=&lt;span&gt; node.left;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node.key;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    };

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.max =&lt;span&gt; function() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; maxNode(root);
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; maxNode =&lt;span&gt; function (node) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (node){
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (node &amp;amp;&amp;amp; node.right !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                node &lt;/span&gt;=&lt;span&gt; node.right;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node.key;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    };

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.remove =&lt;span&gt; function(element){
        root &lt;/span&gt;=&lt;span&gt; removeNode(root, element);
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; findMinNode =&lt;span&gt; function(node){
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (node &amp;amp;&amp;amp; node.left !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            node &lt;/span&gt;=&lt;span&gt; node.left;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; removeNode =&lt;span&gt; function(node, element){

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (element &amp;lt;&lt;span&gt; node.key){
            node.left &lt;/span&gt;=&lt;span&gt; removeNode(node.left, element);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;

        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (element &amp;gt;&lt;span&gt; node.key){
            node.right &lt;/span&gt;=&lt;span&gt; removeNode(node.right, element);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;

        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;element is equal to node.item

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;handle 3 special conditions
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1 - a leaf node
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2 - a node with only 1 child
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3 - a node with 2 children

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;case 1&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (node.left === &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; node.right === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                node &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;case 2&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (node.left === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                node &lt;/span&gt;=&lt;span&gt; node.right;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;

            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (node.right === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                node &lt;/span&gt;=&lt;span&gt; node.left;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;case 3&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; aux =&lt;span&gt; findMinNode(node.right);
            node.key &lt;/span&gt;=&lt;span&gt; aux.key;
            node.right &lt;/span&gt;=&lt;span&gt; removeNode(node.right, aux.key);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
        }
    };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;自平衡树&lt;/h3&gt;
&lt;p&gt;　　二叉树BST存在一个问题：取决于添加的节点数，树的一条边可能会非常深；也就是说，树的一条分支会有很多层，而其他的分支却只有几层，如下图所示：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree13.png&quot; alt=&quot;tree13&quot; width=&quot;620&quot; height=&quot;569&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　这会在需要在某条边上添加、移除和搜索某个节点时引起一些性能问题。为了解决这个问题，有一种树叫作阿德尔森-维尔斯和兰迪斯树（AVL树）。AVL树是一种自平衡二叉搜索树，意思是任何一个节点左右两侧子树的高度之差最多为1。也就是说这种树会在添加或移除节点时尽量试着成为一棵完全树&lt;/p&gt;
&lt;p&gt;　　AVL树是一种自平衡树。添加或移除节点时，AVL树会尝试自平衡。任意一个节点（不论深度）的左子树和右子树高度最多相差1。添加或移除节点时，AVL树会尽可能尝试转换为完全树。&lt;/p&gt;
&lt;p&gt;　　在AVL树中插入或移除节点和BST完全相同。然而，AVL树的不同之处在于我们需要检验它的平衡因子，如果有需要，则将其逻辑应用于树的自平衡。&lt;/p&gt;
&lt;p&gt;　　下面的代码是向AVL树插入新节点的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; insertNode =&lt;span&gt; function(node, element) {   
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {     
    node &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(element);   
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (element &amp;lt;&lt;span&gt; node.key) {     
    node.left &lt;/span&gt;=&lt;span&gt; insertNode(node.left, element); 
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.left !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {       
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 确认是否需要平衡 {1}     &lt;/span&gt;
&lt;span&gt;    }   
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (element &amp;gt;&lt;span&gt; node.key) {    
    node.right &lt;/span&gt;=&lt;span&gt; insertNode(node.right, element); 
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.right !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {       
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 确认是否需要平衡 {2}    &lt;/span&gt;
&lt;span&gt;    }   
  }   
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node; 
}; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然而，插入新节点时，还要检查是否需要平衡树（行{1}和行{2}）。 &lt;/p&gt;
&lt;p&gt;【计算平衡因子】&lt;/p&gt;
&lt;p&gt;　　在AVL树中，需要对每个节点计算右子树高度（hr）和左子树高度（hl）的差值，该值 （hr－hl）应为0、1或-1。如果结果不是这三个值之一，则需要平衡该AVL树。这就是平衡因子的概念&lt;/p&gt;
&lt;p&gt;　　下图举例说明了一些树的平衡因子（所有的树都是平衡的）：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree14.png&quot; alt=&quot;tree14&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　计算节点高度的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; heightNode =&lt;span&gt; function(node) {   
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node  === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {     
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;; 
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Math.max(heightNode(node.left),     
    heightNode(node.right)) &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;   
  } 
}; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因此，向左子树插入新节点时，需要计算其高度；如果高度大于1（即不为-1、0和1之一）， 就需要平衡左子树。代码如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 替换insertNode方法的行{1} &lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; ((heightNode(node.left) - heightNode(node.right)) &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {   
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 旋转 {3} &lt;/span&gt;
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　向右子树插入新节点时，应用同样的逻辑，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 替换insertNode方法的行{2} &lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; ((heightNode(node.right) - heightNode(node.left)) &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {   
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 旋转 {4} &lt;/span&gt;
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【AVL旋转】&lt;/p&gt;
&lt;p&gt;　　向AVL树插入节点时，可以执行单旋转或双旋转两种平衡操作，分别对应四种场景： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;、右-&lt;span&gt;右（RR）：向左的单旋转
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;、左-&lt;span&gt;左（LL）：向右的单旋转
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;、左-&lt;span&gt;右（LR）：向右的双旋转
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;、右-左（RL）：向左的双旋转 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　下面来依次看看它们是如何工作的&lt;/p&gt;
&lt;p&gt;　　右-右（RR）：向左的单旋转。如下图所示：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree15.png&quot; alt=&quot;tree15&quot; width=&quot;830&quot; height=&quot;319&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　假设向AVL树插入节点90，这会造成树失衡（节点50 -Y高度为+2），因此需要恢复树的平衡。下面是执行的操作：&lt;/p&gt;
&lt;p&gt;　　1、与平衡操作相关的节点有三个（X、Y、Z），将节点X置于节点Y（平衡因子为-2）所在的位置（行{1}）&lt;/p&gt;
&lt;p&gt;　　2、节点X的右子树保持不变&lt;/p&gt;
&lt;p&gt;　　3、将节点Y的右子节点置为节点X的左子节点Z（行{2}）&lt;/p&gt;
&lt;p&gt;　　4、将节点X的左子节点置为节点Y（行{3}）&lt;/p&gt;
&lt;p&gt;　　下面的代码举例说明了整个过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; rotationRR =&lt;span&gt; function(node) {   
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tmp = node.right;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {1}   &lt;/span&gt;
  node.right = tmp.left; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {2}   &lt;/span&gt;
  tmp.left = node;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {3}   &lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt;&lt;span&gt; tmp; 
}; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　左-左（LL）：向右的单旋转。如下图所示： &lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree16.png&quot; alt=&quot;tree16&quot; width=&quot;796&quot; height=&quot;318&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　假设向AVL树插入节点5，这会造成树失衡（节点50 -Y高度为+2），需要恢复树的平衡。下面是我们执行的操作：&lt;/p&gt;
&lt;p&gt;　　1、与平衡操作相关的节点有三个（X、Y、Z），将节点X置于节点Y（平衡因子为+2）所在的位置（行{1}）&lt;/p&gt;
&lt;p&gt;　　2、节点X的左子树保持不变&lt;/p&gt;
&lt;p&gt;　　3、将节点Y的左子节点置为节点X的右子节点Z（行{2}）&lt;/p&gt;
&lt;p&gt;　　4、将节点X的右子节点置为节点Y（行{3}）&lt;/p&gt;
&lt;p&gt;　　下面的代码举例说明了整个过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; rotationLL =&lt;span&gt; function(node) {   
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tmp = node.left;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {1}   &lt;/span&gt;
  node.left = tmp.right; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {2}   &lt;/span&gt;
  tmp.right = node;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {3}   &lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt;&lt;span&gt; tmp; 
}; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　左-右（LR）：向右的双旋转。如下图所示： &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree17.png&quot; alt=&quot;tree17&quot; width=&quot;751&quot; height=&quot;331&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　假设向AVL树插入节点35，这会造成树失衡（节点50 -Y高度为+2），需要恢复树的平衡。下面是执行的操作：&lt;/p&gt;
&lt;p&gt;　　1、将节点X置于节点Y（平衡因子为+2）所在的位置&lt;/p&gt;
&lt;p&gt;　　2、将节点Y的左子节点置为节点X的右子节点&lt;/p&gt;
&lt;p&gt;　　3、将节点Z的右子节点置为节点X的左子节点&lt;/p&gt;
&lt;p&gt;　　4、将节点X的右子节点置为节点Y&lt;/p&gt;
&lt;p&gt;　　5、将节点X的左子节点置为节点Z&lt;/p&gt;
&lt;p&gt;　　基本上，就是先做一次RR旋转，再做一次LL旋转。下面的代码举例说明了整个过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; rotationLR =&lt;span&gt; function(node) {   
  node.left &lt;/span&gt;=&lt;span&gt; rotationRR(node.left);   
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rotationLL(node); 
}; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　右-左（RL）：向左的双旋转。如下图所示： &lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://pic.xiaohuochai.site/blog/dataStructureTree18.png&quot; alt=&quot;tree18&quot; width=&quot;736&quot; height=&quot;318&quot;/&gt;&lt;/div&gt;
&lt;p&gt;　　假设向AVL树插入节点75，这会造成树失衡（节点70 -Y高度为-2），需要恢复树的平衡。下面是我们执行的操作：&lt;/p&gt;
&lt;p&gt;　　1、将节点X置于节点Y（平衡因子为-2）所在的位置&lt;/p&gt;
&lt;p&gt;　　2、节点Z的左子节点置为节点X的右子节点&lt;/p&gt;
&lt;p&gt;　　3、将节点Y的右子节点置为节点X的左子节点&lt;/p&gt;
&lt;p&gt;　　4、将节点X的左子节点置为节点Y&lt;/p&gt;
&lt;p&gt;　　5、将节点X的右子节点置为节点Z&lt;/p&gt;
&lt;p&gt;　　基本上，就是先做一次LL旋转，再做一次RR旋转。下面的代码举例说明了整个过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; rotationRL =&lt;span&gt; function(node) {   
  node.right &lt;/span&gt;=&lt;span&gt; rotationLL(node.right);   
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rotationRR(node); 
}; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　确认树需要平衡后，就需要对每种情况分别应用正确的旋转&lt;/p&gt;
&lt;p&gt;　　向左子树插入新节点，且节点的值小于其左子节点时，应进行LL旋转。否则，进行LR旋转。该过程的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 替换insertNode方法的行{1} &lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; ((heightNode(node.left) - heightNode(node.right)) &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;){   
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 旋转 {3}   &lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (element &amp;lt;&lt;span&gt; node.left.key){     
    node &lt;/span&gt;=&lt;span&gt; rotationLL(node);   
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {     
    node &lt;/span&gt;=&lt;span&gt; rotationLR(node);   
  } 
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　向右子树插入新节点，且节点的值大于其右子节点时，应进行RR旋转。否则，进行RL旋转。 该过程的代码如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 替换insertNode方法的行{2} &lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; ((heightNode(node.right) - heightNode(node.left)) &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;){   
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 旋转 {4}   &lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (element &amp;gt;&lt;span&gt; node.right.key){    
    node &lt;/span&gt;=&lt;span&gt; rotationRR(node);   
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {     
    node &lt;/span&gt;=&lt;span&gt; rotationRL(node);   
  } 
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;【完整代码】&lt;/p&gt;
&lt;p&gt;　　AVL树的完整代码如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function AVLTree() {

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Node =&lt;span&gt; function(key){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.left = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.right = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getRoot =&lt;span&gt; function(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; heightNode =&lt;span&gt; function(node) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.max(heightNode(node.left), heightNode(node.right)) + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rotationLL =&lt;span&gt; function(node) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tmp =&lt;span&gt; node.left;
        node.left &lt;/span&gt;=&lt;span&gt; tmp.right;
        tmp.right &lt;/span&gt;=&lt;span&gt; node;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tmp;
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rotationRR =&lt;span&gt; function(node) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tmp =&lt;span&gt; node.right;
        node.right &lt;/span&gt;=&lt;span&gt; tmp.left;
        tmp.left &lt;/span&gt;=&lt;span&gt; node;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tmp;
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rotationLR =&lt;span&gt; function(node) {
        node.left &lt;/span&gt;=&lt;span&gt; rotationRR(node.left);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rotationLL(node);
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rotationRL =&lt;span&gt; function(node) {
        node.right &lt;/span&gt;=&lt;span&gt; rotationLL(node.right);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rotationRR(node);
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; insertNode =&lt;span&gt; function(node, element) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            node &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(element);

        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (element &amp;lt;&lt;span&gt; node.key) {

            node.left &lt;/span&gt;=&lt;span&gt; insertNode(node.left, element);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.left !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((heightNode(node.left) - heightNode(node.right)) &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (element &amp;lt;&lt;span&gt; node.left.key){
                        node &lt;/span&gt;=&lt;span&gt; rotationLL(node);
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        node &lt;/span&gt;=&lt;span&gt; rotationLR(node);
                    }
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (element &amp;gt;&lt;span&gt; node.key) {

            node.right &lt;/span&gt;=&lt;span&gt; insertNode(node.right, element);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.right !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((heightNode(node.right) - heightNode(node.left)) &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;){

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (element &amp;gt;&lt;span&gt; node.right.key){
                        node &lt;/span&gt;=&lt;span&gt; rotationRR(node);
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        node &lt;/span&gt;=&lt;span&gt; rotationRL(node);
                    }
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
    };

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.insert =&lt;span&gt; function(element) {
        root &lt;/span&gt;=&lt;span&gt; insertNode(root, element);
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; parentNode;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; nodeToBeDeleted;

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; removeNode =&lt;span&gt; function(node, element) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        parentNode &lt;/span&gt;=&lt;span&gt; node;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (element &amp;lt;&lt;span&gt; node.key) {
            node.left &lt;/span&gt;=&lt;span&gt; removeNode(node.left, element);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            nodeToBeDeleted &lt;/span&gt;=&lt;span&gt; node;
            node.right &lt;/span&gt;=&lt;span&gt; removeNode(node.right, element);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node === parentNode) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;remove node&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (nodeToBeDeleted !== &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; element ===&lt;span&gt; nodeToBeDeleted.key) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nodeToBeDeleted ===&lt;span&gt; parentNode) {
                    node &lt;/span&gt;=&lt;span&gt; node.left;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tmp =&lt;span&gt; nodeToBeDeleted.key;
                    nodeToBeDeleted.key &lt;/span&gt;=&lt;span&gt; parentNode.key;
                    parentNode.key &lt;/span&gt;=&lt;span&gt; tmp;
                    node &lt;/span&gt;=&lt;span&gt; node.right;
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do balancing&lt;/span&gt;

            &lt;span&gt;if&lt;/span&gt; (node.left === undefined) node.left = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.right === undefined) node.right = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((heightNode(node.left) - heightNode(node.right)) === &lt;span&gt;2&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (element &amp;lt;&lt;span&gt; node.left.key) {
                    node &lt;/span&gt;=&lt;span&gt; rotationLR(node);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    node &lt;/span&gt;=&lt;span&gt; rotationLL(node);
                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((heightNode(node.right) - heightNode(node.left)) === &lt;span&gt;2&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (element &amp;gt;&lt;span&gt; node.right.key) {
                    node &lt;/span&gt;=&lt;span&gt; rotationRL(node);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    node &lt;/span&gt;=&lt;span&gt; rotationRR(node);
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
    };

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.remove =&lt;span&gt; function(element) {
        parentNode &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        nodeToBeDeleted &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        root &lt;/span&gt;=&lt;span&gt; removeNode(root, element);
    };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　尽管AVL树是自平衡的，其插入或移除节点的性能并不总是最好的。更好的选择是红黑树。红黑树可以高效有序地遍历其节点&lt;/p&gt;
&lt;p&gt;【红黑树】&lt;/p&gt;
&lt;p&gt;　　红黑树的完整代码如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function RedBlackTree() {

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Colors =&lt;span&gt; {
        RED: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
        BLACK: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Node =&lt;span&gt; function (key, color) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.left = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.right = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.color =&lt;span&gt; color;

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.flipColor =&lt;span&gt; function(){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.color ===&lt;span&gt; Colors.RED) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.color =&lt;span&gt; Colors.BLACK;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.color =&lt;span&gt; Colors.RED;
            }
        };
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; root = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getRoot =&lt;span&gt; function () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isRed =&lt;span&gt; function(node){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;node){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; node.color ===&lt;span&gt; Colors.RED;
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; flipColors =&lt;span&gt; function(node){
        node.left.flipColor();
        node.right.flipColor();
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rotateLeft =&lt;span&gt; function(node){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; temp =&lt;span&gt; node.right;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (temp !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            node.right &lt;/span&gt;=&lt;span&gt; temp.left;
            temp.left &lt;/span&gt;=&lt;span&gt; node;
            temp.color &lt;/span&gt;=&lt;span&gt; node.color;
            node.color &lt;/span&gt;=&lt;span&gt; Colors.RED;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp;
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rotateRight =&lt;span&gt; function (node) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; temp =&lt;span&gt; node.left;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (temp !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            node.left &lt;/span&gt;=&lt;span&gt; temp.right;
            temp.right &lt;/span&gt;=&lt;span&gt; node;
            temp.color &lt;/span&gt;=&lt;span&gt; node.color;
            node.color &lt;/span&gt;=&lt;span&gt; Colors.RED;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp;
    };

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; insertNode =&lt;span&gt; function(node, element) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(element, Colors.RED);
        }

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newRoot =&lt;span&gt; node;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (element &amp;lt;&lt;span&gt; node.key) {

            node.left &lt;/span&gt;=&lt;span&gt; insertNode(node.left, element);

        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (element &amp;gt;&lt;span&gt; node.key) {

            node.right &lt;/span&gt;=&lt;span&gt; insertNode(node.right, element);

        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            node.key &lt;/span&gt;=&lt;span&gt; element;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isRed(node.right) &amp;amp;&amp;amp; !&lt;span&gt;isRed(node.left)) {
            newRoot &lt;/span&gt;=&lt;span&gt; rotateLeft(node);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isRed(node.left) &amp;amp;&amp;amp;&lt;span&gt; isRed(node.left.left)) {
            newRoot &lt;/span&gt;=&lt;span&gt; rotateRight(node);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isRed(node.left) &amp;amp;&amp;amp;&lt;span&gt; isRed(node.right)) {
            flipColors(node);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newRoot;
    };

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.insert =&lt;span&gt; function(element) {
        root &lt;/span&gt;=&lt;span&gt; insertNode(root, element);
        root.color &lt;/span&gt;=&lt;span&gt; Colors.BLACK;
    };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 03 Jan 2018 14:05:00 +0000</pubDate>
<dc:creator>小火柴的蓝色理想</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohuochai/p/8184989.html</dc:identifier>
</item>
<item>
<title>HTTPS加密流程超详解（二） - real王一</title>
<link>http://www.cnblogs.com/realwy/p/8185368.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/realwy/p/8185368.html</guid>
<description>&lt;p&gt;上篇文章介绍了如何简单搭建一个环境帮助我们分析，今天我们就进入正题，开始在这个环境下分析。&lt;/p&gt;
&lt;p&gt;我们使用IE浏览器访问Web服务器根目录的test.txt文件并抓包，可以抓到如下6个包（前面的TCP三次握手在此略过）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1209573/201801/1209573-20180103193835846-1645181801.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用服务器私钥解密后的包是这个样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1209573/201801/1209573-20180103194037456-315743093.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们就结合这6个包来分析一下一个完整的HTTPS加解密流程。&lt;/p&gt;
&lt;h2 id=&quot;第1包&quot;&gt;第1包&lt;/h2&gt;
&lt;p&gt;Client Hello是TLS握手的第一步，客户端会将一个随机数、支持的加密套件、压缩算法等信息发送给服务器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1209573/201801/1209573-20180103194051596-1845838089.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;第2包&quot;&gt;第2包&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Server Hello，用来响应客户端的Client Hello，里面同样包含一个32字节的随机数，以及服务端选择的加密套件和压缩算法。&lt;/li&gt;
&lt;li&gt;Certificate，服务端会把自己的证书发送给客户端，用来证明自己的身份，证书里面包含一个公钥，供后面的密钥交换使用。（客户端也可以发送证书证明身份，但是比较少见，我们这里就没有客户端证书）。&lt;/li&gt;
&lt;li&gt;Server Hello Done，用以表示服务端的密钥交换过程已经结束。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1209573/201801/1209573-20180103194125487-1385661758.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;第3包&quot;&gt;第3包&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Client Key Exchange，包含一个使用服务器公钥加密的预主密钥PreMasterSecret，解密后可以用来生成密钥。&lt;/li&gt;
&lt;li&gt;Change Cipher Spec，表明握手协议已经完成。&lt;/li&gt;
&lt;li&gt;Finished，表示握手结束，这条消息已经被协商好的密钥加密，也可以起到确认密钥的作用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1209573/201801/1209573-20180103194138362-1496563080.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解密后的Finish消息如下，这里面包含一个Verify Data，是利用PRF函数算出来的，这个函数接下来会介绍，这里我们只需要知道函数的输入参数有：（1）两个hash值，是之前所有握手消息的MD5和SHA1；（2）MasterSecret，由PreMasterSecret生成；（3）finished_label，服务端使用“server finished”，客户端使用“client finished”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1209573/201801/1209573-20180103194151893-902190842.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来重点介绍下密钥的生成（下面代码中的加解密函数使用了&lt;strong&gt;OpenSSL&lt;/strong&gt;库）：&lt;/p&gt;
&lt;h3 id=&quot;解密encrypted-premastersecret&quot;&gt;解密Encrypted PreMasterSecret&lt;/h3&gt;
&lt;p&gt;刚才说到PreMasterSecret被服务器的公钥加密了，所以需要使用服务器的私钥解密，直接上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FILE * priv_fp = fopen(&quot;C:\\Users\\hello\\Desktop\\server.key&quot;,&quot;r&quot;);//server.key为之前生成的服务器私钥文件
if (priv_fp == NULL)
{
    printf(&quot;read key error\n&quot;);
    return -1;
}

RSA *rsa = PEM_read_RSAPrivateKey(priv_fp, NULL, NULL, NULL);
if (rsa == NULL)
{
    printf(&quot;read key error\n&quot;);
    return -1;
}

len = RSA_private_decrypt(128, encrypted_premaster, premaster, rsa, RSA_PKCS1_PADDING);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以解密出来48字节的PreMasterSecret：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1209573/201801/1209573-20180103194210846-545697021.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;密钥生成&quot;&gt;密钥生成&lt;/h3&gt;
&lt;p&gt;密钥生成要使用一个很重要的伪随机函数，Pseudo-random Fuction（PRF），PRF函数原理如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1209573/201801/1209573-20180103194225346-714343142.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该函数有3个输入，其中Secret相当于密钥；Label是一个标识符，不同场合会使用不同的字符串，比如“server finished”、&quot;master secret&quot;等；Seed是一个种子值，比如客户端和服务器的随机数。&lt;/p&gt;
&lt;p&gt;该函数的代码实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static int tls_prf(Data *secret,char *usage,Data *rnd1,Data *rnd2,Data *out)
{
    int r,_status;
    Data *md5_out=0,*sha_out=0;
    Data *seed;
    UCHAR *ptr;
    Data *S1=0,*S2=0;
    int i,S_l;

    if(r=r_data_alloc(&amp;amp;md5_out,MAX(out-&amp;gt;len,16)))
        return -1;
    if(r=r_data_alloc(&amp;amp;sha_out,MAX(out-&amp;gt;len,20)))
        return -1;
    if(r=r_data_alloc(&amp;amp;seed,strlen(usage)+rnd1-&amp;gt;len+rnd2-&amp;gt;len))
        return -1;
    ptr=seed-&amp;gt;data;
    memcpy(ptr,usage,strlen(usage)); ptr+=strlen(usage);
    memcpy(ptr,rnd1-&amp;gt;data,rnd1-&amp;gt;len); ptr+=rnd1-&amp;gt;len;
    memcpy(ptr,rnd2-&amp;gt;data,rnd2-&amp;gt;len); ptr+=rnd2-&amp;gt;len;    

    S_l=secret-&amp;gt;len/2 + secret-&amp;gt;len%2;

    if(r=r_data_alloc(&amp;amp;S1,S_l))
        return -1;
    if(r=r_data_alloc(&amp;amp;S2,S_l))
        return -1;

    memcpy(S1-&amp;gt;data,secret-&amp;gt;data,S_l);
    memcpy(S2-&amp;gt;data,secret-&amp;gt;data + (secret-&amp;gt;len - S_l),S_l);

    if(r=tls_P_hash
        (S1,seed,EVP_get_digestbyname(&quot;MD5&quot;),md5_out))
        return -1;
    if(r=tls_P_hash(S2,seed,EVP_get_digestbyname(&quot;SHA1&quot;),sha_out))
        return -1;


    for(i=0;i&amp;lt;out-&amp;gt;len;i++)
        out-&amp;gt;data[i]=md5_out-&amp;gt;data[i] ^ sha_out-&amp;gt;data[i];

    _status=0;
abort:
    r_data_destroy(&amp;amp;md5_out);
    r_data_destroy(&amp;amp;sha_out);
    r_data_destroy(&amp;amp;seed);
    r_data_destroy(&amp;amp;S1);
    r_data_destroy(&amp;amp;S2);
    return(_status);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PRF要使用一个扩展函数（P_hash），原理图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1209573/201801/1209573-20180103194238096-730472662.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该函数的代码实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static int tls_P_hash(Data *secret,Data *seed,const EVP_MD *md,Data *out)
{
    UCHAR *ptr=out-&amp;gt;data;
    int left=out-&amp;gt;len;
    int tocpy;
    UCHAR *A;
    UCHAR _A[20],tmp[20];
    unsigned int A_l,tmp_l;
    HMAC_CTX hm;

    A=seed-&amp;gt;data;
    A_l=seed-&amp;gt;len;

    while(left){
        HMAC_Init(&amp;amp;hm,secret-&amp;gt;data,secret-&amp;gt;len,md);
        HMAC_Update(&amp;amp;hm,A,A_l);
        HMAC_Final(&amp;amp;hm,_A,&amp;amp;A_l);
        A=_A;

        HMAC_Init(&amp;amp;hm,secret-&amp;gt;data,secret-&amp;gt;len,md);
        HMAC_Update(&amp;amp;hm,A,A_l);
        HMAC_Update(&amp;amp;hm,seed-&amp;gt;data,seed-&amp;gt;len);
        HMAC_Final(&amp;amp;hm,tmp,&amp;amp;tmp_l);

        tocpy=MIN(left,tmp_l);
        memcpy(ptr,tmp,tocpy);
        ptr+=tocpy;
        left-=tocpy;
    }

    HMAC_cleanup(&amp;amp;hm);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;了解了PRF函数后，就可以使用它做密钥生成（密钥扩展）了，下图完整阐述了密钥生成过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1209573/201801/1209573-20180103194248721-787063444.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;密钥生成代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tls_prf(&amp;amp;pre_master_secret, &quot;master secret&quot;, &amp;amp;random1, &amp;amp;random2, &amp;amp;master_secret);

tls_prf(&amp;amp;master_secret, &quot;key expansion&quot;, &amp;amp;random2, &amp;amp;random1, &amp;amp;key_block);

for (int i=0; i&amp;lt;16; i++)
{
    client_write_key[i] = key_block.data[40+i];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次调用PRF函数，使用PreMasterSecret、&quot;master secret&quot;和两个随机数（上述服务器和客户端各一个）作为输入参数，输出为一个48字节的主密钥MasterSecret：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1209573/201801/1209573-20180103194259237-115270203.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二次调用PRF函数，MasterSecret、&quot;key expansion&quot;和两个随机数作为输入参数，输出为一个Key_block，从41字节开始的16个字节为Client Write key，接下来16个字节为Server Write key，这两个就是接下来双方通信使用的RC4密钥：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1209573/201801/1209573-20180103194309299-893390284.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;第4包&quot;&gt;第4包&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Change Cipher Spec，表明握手协议已经完成。&lt;/li&gt;
&lt;li&gt;Finished，表示握手结束，这条消息已经被协商好的密钥加密。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1209573/201801/1209573-20180103194320940-1512083239.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;第56包&quot;&gt;第5、6包&lt;/h2&gt;
&lt;p&gt;接下来就是传输应用层的信息了，这些信息使用之前协商好的密钥（Client Write key、Server Write key）加密，以客户端为例，解密代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;EVP_CIPHER_CTX ctx;
EVP_CIPHER_CTX_init(&amp;amp;ctx);
int rv, outl;
rv = EVP_DecryptInit_ex(&amp;amp;ctx, EVP_rc4(), NULL, client_write_key, iv);//初始向量IV为0
EVP_DecryptUpdate(&amp;amp;ctx, out, &amp;amp;outl, ciphertext, ciphertextlen);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解密后的最后20个字节为MAC校验，这里使用的是SHA1算法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1209573/201801/1209573-20180103194330487-943659271.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解密后的客户端数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1209573/201801/1209573-20180103194338049-2142301304.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同理，解密后的服务端数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1209573/201801/1209573-20180103194357549-1918139016.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，一个完整的HTTPS加解密流程就结束了，过程还是比较简单，只是如果自己实现的话一些细节会比较让人头疼，给出代码可以少走一些弯路，至于更复杂的加密套件，这里就不再介绍，流程应该差不太多，有兴趣的朋友可以研究一下。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://www.360doc.com/content/16/0320/21/30136251_543905971.shtml&quot; class=&quot;uri&quot;&gt;http://www.360doc.com/content/16/0320/21/30136251_543905971.shtml&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Jan 2018 11:52:00 +0000</pubDate>
<dc:creator>real王一</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/realwy/p/8185368.html</dc:identifier>
</item>
<item>
<title>通过2-3-4树理解红黑树 - 枕边书</title>
<link>http://www.cnblogs.com/zhenbianshu/p/8185345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhenbianshu/p/8185345.html</guid>
<description>&lt;p&gt;红黑树是数据结构中比较复杂的一种，最近与它交集颇多，于是花了一周的空闲时间跟它死磕，终于弄明白并实现了红黑树。写文总结一下，希望能给试图理解红黑树的同学一些灵感，也让我能记得更深刻。&lt;/p&gt;
&lt;p&gt;在研究红黑树时吃了不少苦头，原因有二：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;红黑树的插入和删除非常复杂，很多人并没有理解或完全实现，或实现了的没有任何注释，让人很难参考；&lt;/li&gt;
&lt;li&gt;网络上红黑树的理解方式较为单一，一般是 &lt;code&gt;双黑、caseN&lt;/code&gt; 法，而插入和删除的情况很多，每种都有对应的处理方式，如果死记硬背的话，再过一段时间再回忆各种情况可能就一头雾水了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;网络上讲红黑树的实现多来源于《算法导论》一书，直接讲红黑树的实现，需要处理颜色和高度两种属性约束，比较晦涩。本文通过红黑树的等同—— 2-3-4树，避开颜色属性约束，也弱化了高度的影响，以另一种方式去理解红黑树，虽然并不能完全降低它的复杂度，但自认为较之普遍实现，更易记一些。&lt;/p&gt;
&lt;p&gt;文章最前面先放上红黑树的实现源码，代码在 Github 上，一开始实现时使用我最熟练的 PHP，后续添加了 Java 版，代码都可以直接运行。源码链接：&lt;a href=&quot;https://github.com/zhenbianshu/DataStructureAndAlgorithm&quot;&gt;&lt;strong&gt;&lt;code&gt;GitHub-枕边书-RBTree&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;，欢迎&lt;code&gt;star&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;文章欢迎转载，请注明出处：http://www.cnblogs.com/zhenbianshu/p/8185345.html。&lt;/p&gt;
&lt;hr/&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;红黑树是一种结点带有颜色属性的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9&quot;&gt;二叉查找树&lt;/a&gt;，但它在二叉查找树之外，还有以下要求：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;节点是红色或黑色。&lt;/li&gt;
&lt;li&gt;根是黑色。&lt;/li&gt;
&lt;li&gt;所有叶子都是黑色（叶子是NIL节点）。&lt;/li&gt;
&lt;li&gt;每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）&lt;/li&gt;
&lt;li&gt;从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下图就是一个典型的红黑树：&lt;/p&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/819496/201801/819496-20180103193521440-1612942831.png&quot; alt=&quot;&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;但实现上我省略了其中的 Nil 结点，一般如下图，大家理解时也可以忽略它们。&lt;/p&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/819496/201801/819496-20180103193539737-260894910.png&quot; alt=&quot;&quot;/&gt;&lt;/h3&gt;
&lt;h3 id=&quot;toc_5&quot;&gt;优势和用途&lt;/h3&gt;
&lt;p&gt;我们知道二叉查找树在不停地添加或删除结点后，可能会导致结点情况如下：&lt;/p&gt;
&lt;h3 id=&quot;toc_6&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/819496/201801/819496-20180103193551440-1435476180.png&quot; alt=&quot;&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;这种情况下，二叉查找树的查找效率最坏会降低为 &lt;code&gt;O(n)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而红黑树由于在插入和删除结点时都会进行变色旋转等操作，在符合红黑树条件的情况下，即使一边子树全是黑色结点，另一边子树全是红黑相间，两子树的高度差也不会超过一半。一棵有 n 个结点的红黑树高度至多为 &lt;code&gt;2log(n+1)&lt;/code&gt;，查找效率最坏为 &lt;code&gt;O(log(n))&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所以红黑树常被用于需求查找效率稳定的场景，如 Linux 中内核使用它管理内存区域对象、Java8 中 HashMap 的实现等，所以了解红黑树也很有意义。&lt;/p&gt;
&lt;p&gt;下面介绍一下红黑树的等同 2-3-4树。&lt;/p&gt;
&lt;hr/&gt;
&lt;h3 id=&quot;toc_8&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;2-3-4树是四阶的 B树(Balance Tree)，它的结构有以下限制：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;所有叶子节点都拥有相同的深度。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;节点只能是 2-节点、3-节点、4-节点之一。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;2-节点：包含 1 个元素的节点，有 2 个子节点；&lt;/li&gt;
&lt;li&gt;3-节点：包含 2 个元素的节点，有 3 个子节点；&lt;/li&gt;
&lt;li&gt;4-节点：包含 3 个元素的节点，有 4 个子节点；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;元素始终保持排序顺序，整体上保持二叉查找树的性质，即父结点大于左子结点，小于右子结点；而且结点有多个元素时，每个元素必须大于它左边的和它的左子树中元素。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下图是一个典型的 2-3-4树（来自维基百科）：&lt;/p&gt;
&lt;h3 id=&quot;toc_9&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/819496/201801/819496-20180103193607612-403302618.png&quot; alt=&quot;&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;2-3-4树的查询操作像普通的二叉搜索树一样，非常简单，但由于其结点元素数不确定，在一些编程语言中实现起来并不方便，实现一般使用它的等同——红黑树。&lt;/p&gt;
&lt;h3 id=&quot;toc_10&quot;&gt;对应红黑树&lt;/h3&gt;
&lt;p&gt;至于为什么说红黑树是 2-3-4树的一种等同呢，这是因为 2-3-4树的每一个结点都对应红黑树的一种结构，所以每一棵 2-3-4树也都对应一棵红黑树，下图是 2-3-4树不同结点与红黑树子树的对应。&lt;/p&gt;
&lt;h3 id=&quot;toc_11&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/819496/201801/819496-20180103193633831-1494601217.png&quot; alt=&quot;&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;而上文中的 2-3-4树也可以转换成一棵红黑树：&lt;/p&gt;
&lt;h3 id=&quot;toc_12&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/819496/201801/819496-20180103193647346-2000126888.png&quot; alt=&quot;&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;由红黑树的性质5，和 2-3-4树的性质1，为了便于理解红黑树和 2-3-4树的对应关系，我们可以&lt;code&gt;把红黑树从根结点到叶子结点的黑色结点个数定义为高度&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;红黑树和 2-3-4树的结点添加和删除都有一个基本规则：避免子树高度变化，因为无论是 2-3-4树还是红黑树，一旦子树高度有变动，势必会影响其他子树进行调整，所以我们在插入和删除结点时尽量通过子树内部调整来达到平衡，2-3-4树实现平衡是通过结点的旋转和结点元素数变化，红黑树是通过结点旋转和变色。&lt;/p&gt;
&lt;p&gt;下面来对照着 2-3-4树说一下红黑树结点的添加和删除：&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;2-3-4树中结点添加需要遵守以下规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;插入都是向最下面一层插入；&lt;/li&gt;
&lt;li&gt;升元：将插入结点由 2-结点升级成 3-结点，或由 3-结点升级成 4-结点；&lt;/li&gt;
&lt;li&gt;向 4-结点插入元素后，需要将中间元素提到父结点升元，原结点变成两个 2-结点，再把元素插入 2-结点中，如果父结点也是 4-结点，则递归向上层升元，至到根结点后将树高加1；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而将这些规则对应到红黑树里，就是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新插入的结点颜色为&lt;code&gt;红色&lt;/code&gt;，这样才可能不会对红黑树的高度产生影响。&lt;/li&gt;
&lt;li&gt;2-结点对应红黑树中的单个黑色结点，插入时直接成功（对应 2-结点升元）。&lt;/li&gt;
&lt;li&gt;3-结点对应红黑树中的&lt;code&gt;黑+红&lt;/code&gt;子树，插入后将其修复成 &lt;code&gt;红+黑+红&lt;/code&gt; 子树（对应 3-结点升元）；&lt;/li&gt;
&lt;li&gt;4-结点对应红黑树中的&lt;code&gt;红+黑+红&lt;/code&gt;子树，插入后将其修复成&lt;code&gt;红色祖父+黑色父叔+红色孩子&lt;/code&gt;子树，然后再把祖父结点当成新插入的红色结点递归向上层修复，直至修复成功或遇到 root 结点；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;toc_14&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/819496/201801/819496-20180103193702643-1375531970.png&quot; alt=&quot;&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;如上图所示，虽然向红黑树中插入了一个新结点，但由于旋转和变色，子树的高度保持不变。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;红黑树的删除要比插入要复杂一些，我们还是类比 2-3-4树来讲：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查找最近的叶子结点中的元素替代被删除元素，删除替代元素后，从替代元素所处叶子结点开始处理；&lt;/li&gt;
&lt;li&gt;降元：4-结点变 3-结点，3-结点变 2-结点；&lt;/li&gt;
&lt;li&gt;2-结点中只有一个元素，所以借兄弟结点中的元素来补充删除后的造成的空结点；&lt;/li&gt;
&lt;li&gt;当兄弟结点中也没有多个元素可以补充时，尝试将父结点降元，失败时向上递归，至到子树降元成功或到 root 结点树高减1；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将这些规则对应到红黑树中即：&lt;/p&gt;
&lt;h3 id=&quot;toc_16&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/819496/201801/819496-20180103193715581-889626605.png&quot; alt=&quot;&quot;/&gt;&lt;/h3&gt;
&lt;p&gt;如上图，删除的要点是 &lt;code&gt;找到替代结点&lt;/code&gt;，如果替代结点是黑色，递归向上依次判断侄子结点、父结点是否可以补充被删除的黑色，整体思想就是将删除一个黑色结点造成的影响局限在子树内处理。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;当然实现过程中调试也占了很大一部分，我使用了两项方法帮助调试：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于插入多个结点时，无法确定是处理哪个结点时出了问题，于是我给红黑树类添加了 &lt;code&gt;debug&lt;/code&gt; 属性，用二分法设置此属性来找到问题结点；&lt;/li&gt;
&lt;li&gt;给红黑树类添加了 &lt;code&gt;printTree()&lt;/code&gt; 方法，实时打印树结构，确定代码问题再分析；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于红黑树相对其他树实在较为复杂，只通过思考就完全理解不太现实，还需要自己去试着画，试着实现，我画了 5 张 A4 纸的正反面才算理解了红黑树，即便如此，在写这篇文章时还发现了代码中的可优化点。&lt;/p&gt;
&lt;p&gt;而且代码实现比画图还略复杂，理论中的一个&lt;code&gt;旋转&lt;/code&gt;就包含了 &lt;code&gt;左旋/右旋/先左旋再右旋/先右旋再左旋&lt;/code&gt; 几种情况，虽然有一定规律，还是自己实现一下印象最深刻。&lt;/p&gt;
&lt;p&gt;关于本文有什么问题可以在下面留言交流，如果您觉得本文对您有帮助，可以点击下面的 &lt;strong&gt;&lt;code&gt;推荐&lt;/code&gt;&lt;/strong&gt; 支持一下我，博客一直在更新，欢迎 &lt;strong&gt;&lt;code&gt;关注&lt;/code&gt;&lt;/strong&gt; 。&lt;/p&gt;
</description>
<pubDate>Wed, 03 Jan 2018 11:39:00 +0000</pubDate>
<dc:creator>枕边书</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhenbianshu/p/8185345.html</dc:identifier>
</item>
<item>
<title>Elastic 技术栈之 Filebeat - 静默虚空</title>
<link>http://www.cnblogs.com/jingmoxukong/p/8185321.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingmoxukong/p/8185321.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;Beats 是安装在服务器上的数据中转代理。&lt;/p&gt;
&lt;p&gt;Beats 可以将数据直接传输到 Elasticsearch 或传输到 Logstash 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.elastic.co/guide/en/beats/libbeat/current/images/beats-platform.png&quot; alt=&quot;Beats Platform&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Beats 有多种类型，可以根据实际应用需要选择合适的类型。&lt;/p&gt;
&lt;p&gt;常用的类型有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Packetbeat：&lt;/strong&gt;网络数据包分析器，提供有关您的应用程序服务器之间交换的事务的信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Filebeat：&lt;/strong&gt;从您的服务器发送日志文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Metricbeat：&lt;/strong&gt;是一个服务器监视代理程序，它定期从服务器上运行的操作系统和服务收集指标。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Winlogbeat：&lt;/strong&gt;提供Windows事件日志。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6.2953020134228&quot;&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更多 Beats 类型可以参考：&lt;a href=&quot;https://www.elastic.co/guide/en/beats/libbeat/current/community-beats.html&quot;&gt;community-beats&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于本人工作中只应用了 FileBeat，所以后面内容仅介绍 FileBeat 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;filebeat-的作用&quot;&gt;FileBeat 的作用&lt;/h3&gt;
&lt;p&gt;相比 Logstash，FileBeat 更加轻量化。&lt;/p&gt;
&lt;p&gt;在任何环境下，应用程序都有停机的可能性。 Filebeat 读取并转发日志行，如果中断，则会记住所有事件恢复联机状态时所在位置。&lt;/p&gt;
&lt;p&gt;Filebeat带有内部模块（auditd，Apache，Nginx，System和MySQL），可通过一个指定命令来简化通用日志格式的收集，解析和可视化。&lt;/p&gt;
&lt;p&gt;FileBeat 不会让你的管道超负荷。FileBeat 如果是向 Logstash 传输数据，当 Logstash 忙于处理数据，会通知 FileBeat 放慢读取速度。一旦拥塞得到解决，FileBeat 将恢复到原来的速度并继续传播。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/images/filebeat.png&quot; alt=&quot;Beats design&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;Unix / Linux 系统建议使用下面方式安装，因为比较通用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-6.1.1-linux-x86_64.tar.gz
tar -zxf filebeat-6.1.1-linux-x86_64.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;3.0909090909091&quot;&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更多内容可以参考：&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-installation.html&quot;&gt;filebeat-installation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;配置&quot;&gt;配置&lt;/h2&gt;
&lt;h3 id=&quot;配置文件&quot;&gt;配置文件&lt;/h3&gt;
&lt;p&gt;首先，需要知道的是：&lt;code&gt;filebeat.yml&lt;/code&gt; 是 filebeat 的配置文件。配置文件的路径会因为你安装方式的不同而变化。&lt;/p&gt;
&lt;p&gt;Beat 所有系列产品的配置文件都基于 &lt;a href=&quot;http://www.yaml.org/&quot;&gt;YAML&lt;/a&gt; 格式，FileBeat 当然也不例外。&lt;/p&gt;
&lt;p&gt;filebeat.yml 部分配置示例：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode yaml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;fu&quot;&gt;filebeat:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;prospectors:&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;type:&lt;/span&gt; log
      &lt;span class=&quot;fu&quot;&gt;paths:&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; /var/log/*.log
      &lt;span class=&quot;fu&quot;&gt;multiline:&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;pattern:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'^['&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;match:&lt;/span&gt; after&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5.0555555555556&quot;&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更多 filebeat 配置内容可以参考：&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/configuring-howto-filebeat.html&quot;&gt;配置 filebeat&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多 filebeat.yml 文件格式内容可以参考：&lt;a href=&quot;https://www.elastic.co/guide/en/beats/libbeat/6.1/config-file-format.html&quot;&gt;filebeat.yml 文件格式&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;重要配置项&quot;&gt;重要配置项&lt;/h3&gt;
&lt;h4 id=&quot;filebeat.prospectors&quot;&gt;filebeat.prospectors&lt;/h4&gt;
&lt;p&gt;（文件监视器）用于指定需要关注的文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode yaml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;fu&quot;&gt;filebeat.prospectors:&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;type:&lt;/span&gt; log
  &lt;span class=&quot;fu&quot;&gt;enabled:&lt;/span&gt; true
  &lt;span class=&quot;fu&quot;&gt;paths:&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; /var/log/*.log&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;output.elasticsearch&quot;&gt;output.elasticsearch&lt;/h4&gt;
&lt;p&gt;如果你希望使用 filebeat 直接向 elasticsearch 输出数据，需要配置 output.elasticsearch 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode yaml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;fu&quot;&gt;output.elasticsearch:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;hosts:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;192.168.1.42:9200&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;output.logstash&quot;&gt;output.logstash&lt;/h4&gt;
&lt;p&gt;如果你希望使用 filebeat 向 logstash输出数据，然后由 logstash 再向elasticsearch 输出数据，需要配置 output.logstash。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相比于向 elasticsearch 输出数据，个人更推荐向 logstash 输出数据。&lt;/p&gt;
&lt;p&gt;因为 logstash 和 filebeat 一起工作时，如果 logstash 忙于处理数据，会通知 FileBeat 放慢读取速度。一旦拥塞得到解决，FileBeat 将恢复到原来的速度并继续传播。这样，可以减少管道超负荷的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode yaml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;fu&quot;&gt;output.logstash:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;hosts:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;127.0.0.1:5044&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;]&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此外，还需要在 logstash 的配置文件（如 logstash.conf）中指定 beats input 插件：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode yaml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;input &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  beats {
    port =&amp;gt; 5044 &lt;span class=&quot;co&quot;&gt;# 此端口需要与 filebeat.yml 中的端口相同&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;
}

&lt;span class=&quot;co&quot;&gt;# The filter part of this file is commented out to indicate that it is&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# optional.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# filter {&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# }&lt;/span&gt;

output &lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;
  elasticsearch {
    &lt;span class=&quot;fu&quot;&gt;hosts =&amp;gt; &quot;localhost:&lt;/span&gt;9200&quot;
    manage_template =&amp;gt; false
    index =&amp;gt; &quot;%{[@metadata][beat]&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;-%&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;[@metadata][version]&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;-%&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;+YYYY.MM.dd&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    document_type =&amp;gt; &quot;&lt;/span&gt;%&lt;span class=&quot;kw&quot;&gt;{&lt;/span&gt;[@metadata][type]&lt;span class=&quot;kw&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot; &lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;  }&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;setup.kibana&quot;&gt;setup.kibana&lt;/h4&gt;
&lt;p&gt;如果打算使用 Filebeat 提供的 Kibana 仪表板，需要配置 setup.kibana 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode yaml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;fu&quot;&gt;setup.kibana:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;host:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;localhost:5601&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;setup.template.settings&quot;&gt;setup.template.settings&lt;/h4&gt;
&lt;p&gt;在 Elasticsearch 中，&lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/reference/6.1/indices-templates.html&quot;&gt;索引模板&lt;/a&gt;用于定义设置和映射，以确定如何分析字段。&lt;/p&gt;
&lt;p&gt;在 Filebeat 中，setup.template.settings 用于配置索引模板。&lt;/p&gt;
&lt;p&gt;Filebeat 推荐的索引模板文件由 Filebeat 软件包安装。如果您接受 filebeat.yml 配置文件中的默认配置，Filebeat在成功连接到 Elasticsearch 后自动加载模板。&lt;/p&gt;
&lt;p&gt;您可以通过在 Filebeat 配置文件中配置模板加载选项来禁用自动模板加载，或加载自己的模板。您还可以设置选项来更改索引和索引模板的名称。&lt;/p&gt;
&lt;blockquote readability=&quot;6.1185185185185&quot;&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更多内容可以参考：&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-template.html&quot;&gt;filebeat-template&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如无必要，使用 Filebeat 配置文件中的默认索引模板即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;setup.dashboards&quot;&gt;setup.dashboards&lt;/h4&gt;
&lt;p&gt;Filebeat 附带了示例 Kibana 仪表板。在使用仪表板之前，您需要创建索引模式 &lt;code&gt;filebeat- *&lt;/code&gt;，并将仪表板加载到Kibana 中。为此，您可以运行 &lt;code&gt;setup&lt;/code&gt; 命令或在 &lt;code&gt;filebeat.yml&lt;/code&gt; 配置文件中配置仪表板加载。&lt;/p&gt;
&lt;p&gt;为了在 Kibana 中加载 Filebeat 的仪表盘，需要在 &lt;code&gt;filebeat.yml&lt;/code&gt; 配置中启动开关：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;setup.dashboards.enabled: true&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;2.9310344827586&quot;&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更多内容可以参考：&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/configuration-dashboards.html&quot;&gt;configuration-dashboards&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;命令&quot;&gt;命令&lt;/h2&gt;
&lt;p&gt;filebeat 提供了一系列命令来完成各种功能。&lt;/p&gt;
&lt;p&gt;执行命令方式：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;./filebeat&lt;/span&gt; COMMAND&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;13.866812227074&quot;&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更多内容可以参考：&lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/command-line-options.html&quot;&gt;command-line-options&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;个人认为命令行没有必要一一掌握，因为绝大部分功能都可以通过配置来完成。且通过命令行指定功能这种方式要求每次输入同样参数，不利于固化启动方式。&lt;/p&gt;
&lt;p&gt;最重要的当然是启动命令 run 了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt; 指定配置文件启动&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode sh&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;./filebeat&lt;/span&gt; run -e -c filebeat.yml -d &lt;span class=&quot;st&quot;&gt;&quot;publish&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;./filebeat&lt;/span&gt; -e -c filebeat.yml -d &lt;span class=&quot;st&quot;&gt;&quot;publish&quot;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;# run 可以省略&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;模块&quot;&gt;模块&lt;/h2&gt;
&lt;p&gt;Filebeat 提供了一套预构建的模块，让您可以快速实施和部署日志监视解决方案，并附带示例仪表板和数据可视化。这些模块支持常见的日志格式，例如Nginx，Apache2和MySQL 等。&lt;/p&gt;
&lt;h3 id=&quot;运行模块的步骤&quot;&gt;运行模块的步骤&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;配置 elasticsearch 和 kibana&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;output.elasticsearch:
  hosts: [&quot;myEShost:9200&quot;]
  username: &quot;elastic&quot;
  password: &quot;elastic&quot;
setup.kibana:
  host: &quot;mykibanahost:5601&quot;
  username: &quot;elastic&quot; 
  password: &quot;elastic&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;username 和 password 是可选的，如果不需要认证则不填。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;初始化环境&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;执行下面命令，filebeat 会加载推荐索引模板。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./filebeat setup -e&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;指定模块&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;执行下面命令，指定希望加载的模块。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./filebeat -e --modules system,nginx,mysql&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;2.3456790123457&quot;&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更多内容可以参考： &lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/configuration-filebeat-modules.html&quot;&gt;配置 filebeat 模块&lt;/a&gt; | &lt;a href=&quot;https://www.elastic.co/guide/en/beats/filebeat/current/filebeat-modules.html&quot;&gt;filebeat 支持模块&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;Filebeat 有两个主要组件：&lt;/p&gt;
&lt;p&gt;harvester：负责读取一个文件的内容。它会逐行读取文件内容，并将内容发送到输出目的地。&lt;/p&gt;
&lt;p&gt;prospector：负责管理 harvester 并找到所有需要读取的文件源。比如类型是日志，prospector 就会遍历制定路径下的所有匹配要求的文件。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode yaml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;fu&quot;&gt;filebeat.prospectors:&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;type:&lt;/span&gt; log
  &lt;span class=&quot;fu&quot;&gt;paths:&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; /var/log/*.log
    &lt;span class=&quot;kw&quot;&gt;-&lt;/span&gt; /var/path2/*.log&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Filebeat保持每个文件的状态，并经常刷新注册表文件中的磁盘状态。状态用于记住 harvester 正在读取的最后偏移量，并确保发送所有日志行。&lt;/p&gt;
&lt;p&gt;Filebeat 将每个事件的传递状态存储在注册表文件中。所以它能保证事件至少传递一次到配置的输出，没有数据丢失。&lt;/p&gt;
&lt;h2 id=&quot;资料&quot;&gt;资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.elastic.co/guide/en/beats/libbeat/current/index.html&quot;&gt;Beats 官方文档&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Jan 2018 11:30:00 +0000</pubDate>
<dc:creator>静默虚空</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jingmoxukong/p/8185321.html</dc:identifier>
</item>
<item>
<title>appium对博客园APP进行自动化测试 - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/8185172.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/8185172.html</guid>
<description>&lt;p&gt;前两天，&lt;a href=&quot;http://www.cnblogs.com/zhangmumu&quot;&gt;zhangmumu&lt;/a&gt; 同学开发了博客园 Android 版APP：&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/zhangmumu/p/8146725.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/zhangmumu/p/8146725.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比官方的好用，官方的APP首页打开很慢。我刚好在用 appium，顺便对该APP写了个简单的自动化测试，供测试同学学习。&lt;/p&gt;

&lt;h3 id=&quot;下载与安装&quot;&gt;下载与安装&lt;/h3&gt;
&lt;p&gt;下载App 并安装到手机。&lt;br/&gt;&lt;a href=&quot;https://files.cnblogs.com/files/zhangmumu/cnblogs.apk&quot; class=&quot;uri&quot;&gt;https://files.cnblogs.com/files/zhangmumu/cnblogs.apk&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;获取apppackage和appactivity&quot;&gt;获取appPackage和appActivity&lt;/h3&gt;
&lt;p&gt;参考&lt;a href=&quot;http://www.cnblogs.com/fnng/p/7350900.html&quot;&gt;appium测试之获取appPackage和appActivity&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最终，得到的APP信息如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;appPackage：com.cnblogs.xamarinandroid&lt;/li&gt;
&lt;li&gt;appActivity：md522127645c21675e531a6ac609ef72b2a.SplashScreenActivity&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;定位控件&quot;&gt;定位控件&lt;/h3&gt;
&lt;p&gt;参考，&lt;a href=&quot;http://www.cnblogs.com/fnng/category/695788.html&quot;&gt;Appium-desktop安装与使用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/311516/201801/311516-20180103184818299-1622385611.png&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;编写测试脚本&quot;&gt;编写测试脚本&lt;/h3&gt;
&lt;p&gt;通过 python + appium + unittest 编写appium自动化测试。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; appium &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; webdriver
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; time &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; sleep
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; appium.webdriver.common.touch_action &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; TouchAction
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; selenium.webdriver.common.keys &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Keys
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; unittest 

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SearchTest(unittest.TestCase):

    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; setUp(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):
        desired_caps &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {}
        desired_caps[&lt;span class=&quot;st&quot;&gt;'automationName'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Appium'&lt;/span&gt;
        desired_caps[&lt;span class=&quot;st&quot;&gt;'deviceName'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'PRO_5'&lt;/span&gt;
        desired_caps[&lt;span class=&quot;st&quot;&gt;'platformName'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Android'&lt;/span&gt;
        desired_caps[&lt;span class=&quot;st&quot;&gt;'platformVersion'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'7.0'&lt;/span&gt;
        desired_caps[&lt;span class=&quot;st&quot;&gt;'noReset'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;
        desired_caps[&lt;span class=&quot;st&quot;&gt;&quot;appPackage&quot;&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;com.cnblogs.xamarinandroid&quot;&lt;/span&gt;
        desired_caps[&lt;span class=&quot;st&quot;&gt;&quot;appActivity&quot;&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;md522127645c21675e531a6ac609ef72b2a.SplashScreenActivity&quot;&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.driver &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; webdriver.Remote(&lt;span class=&quot;st&quot;&gt;'http://localhost:4723/wd/hub'&lt;/span&gt;, desired_caps)
        sleep(&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)

    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; test_case(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):
        driver &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.driver
        &lt;span class=&quot;co&quot;&gt;# 点击搜索按钮&lt;/span&gt;
        driver.find_element_by_accessibility_id(&lt;span class=&quot;st&quot;&gt;&quot;搜索&quot;&lt;/span&gt;).click()

        &lt;span class=&quot;co&quot;&gt;# 搜索框&lt;/span&gt;
        search_src_text &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; driver.find_element_by_id(&lt;span class=&quot;st&quot;&gt;&quot;com.cnblogs.xamarinandroid:id/search_src_text&quot;&lt;/span&gt;)
        search_src_text.click()
        &lt;span class=&quot;co&quot;&gt;# 输入搜索关键字“appium”&lt;/span&gt;
        driver.keyevent(&lt;span class=&quot;dv&quot;&gt;29&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# a&lt;/span&gt;
        driver.keyevent(&lt;span class=&quot;dv&quot;&gt;44&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# p&lt;/span&gt;
        driver.keyevent(&lt;span class=&quot;dv&quot;&gt;44&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# p&lt;/span&gt;
        driver.keyevent(&lt;span class=&quot;dv&quot;&gt;37&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# i&lt;/span&gt;
        driver.keyevent(&lt;span class=&quot;dv&quot;&gt;49&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# u&lt;/span&gt;
        driver.keyevent(&lt;span class=&quot;dv&quot;&gt;41&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;# m&lt;/span&gt;
        sleep(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
        &lt;span class=&quot;co&quot;&gt;# 回车搜索&lt;/span&gt;
        driver.keyevent(&lt;span class=&quot;dv&quot;&gt;66&lt;/span&gt;)  
        driver.keyevent(&lt;span class=&quot;dv&quot;&gt;66&lt;/span&gt;)
    
    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; tearDown(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;):
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.driver.quit()


&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'__main__'&lt;/span&gt;:
    unittest.main()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;操作步骤：打开 APP ，点击搜索按钮，搜索“appium”关键字。&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/311516/201801/311516-20180103185454299-889189976.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，再次感谢 zhangmumu 开发的博客完APP。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.testclass.net/appium/&quot;&gt;更多Appium 教程&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Jan 2018 10:53:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fnng/p/8185172.html</dc:identifier>
</item>
</channel>
</rss>