<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>流式大数据计算实践（6）----Storm简介&amp;使用&amp;安装 - 未分配微服务</title>
<link>http://www.cnblogs.com/orange911/p/10006833.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/orange911/p/10006833.html</guid>
<description>&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;1、这一文开始进入Storm流式计算框架的学习&lt;/p&gt;
&lt;h2&gt;二、Storm简介&lt;/h2&gt;
&lt;p&gt;1、Storm与Hadoop的区别就是，Hadoop是一个离线执行的作业，执行完毕就结束了，而Storm是可以源源不断的接受数据源，不停的对数据进行处理，而数据就行水流一样不停的流进来，经过处理，再将结果存入数据库或者做其他用途&lt;/p&gt;
&lt;p&gt;2、基础概念&lt;/p&gt;
&lt;p&gt;（1）Tuple（元组）：数据流传递的基本单元，相当于数据的流动通过Tuple作为对象来传递&lt;/p&gt;
&lt;p&gt;（2）Spout（龙卷）：相当于数据源，通过重写nextTuple()方法，源源不断的将数据流入我们的处理框架&lt;/p&gt;
&lt;p&gt;（3）Bolt（闪电）：处理数据的节点，通过重写execute()方法，接收Spout送出的数据，并进行任意的业务处理，处理完毕还可以将数据继续流入下一个Bolt，组成一条链&lt;/p&gt;
&lt;p&gt;（4）Topology（拓扑）：连接以上各个组件，使其组成一个拓扑结构，比如将多个Bolt组成一条数据链&lt;/p&gt;
&lt;p&gt;3、举例说明：比如我们现在要统计一下《战争与和平》这本书的每个英文单词出现的数量&lt;/p&gt;
&lt;p&gt;（1）编写Spout代码，将书的内容源源不断的通过句子输入到我们的体系中&lt;/p&gt;
&lt;p&gt;（2）编写多个Bolt来处理数据，比如第一个Bolt专门来将句子切分成单词，第二个Bolt专门来统计每个单词出现的数量，每个Bolt之间通过定义Bolt来流动数据，比如统计的Bolt，定义一个二元元组（单词，数量），第一个值就是具体的单词，第二个值就是这个单词出现的数量&lt;/p&gt;
&lt;p&gt;（3）通过Topology将以上组件连接成一个完整的系统&lt;/p&gt;
&lt;h2&gt;三、Storm安装&lt;/h2&gt;
&lt;p&gt;1、下载Storm的tar.gz包，并解压&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;tar&lt;/span&gt; zxvf /work/soft/installer/apache-storm-&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、修改配置文件&lt;/p&gt;
&lt;p&gt;（1）storm.ymal，分别配置我们的Zookeeper集群（前文中已经搭建好了）的各个节点和nimbus节点的高可用性，避免单点故障，我们的环境有两个机器，所以都写上&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
vim /work/soft/apache-storm-&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/conf/&lt;span&gt;storm.yaml

 storm.zookeeper.servers:
     &lt;/span&gt;- &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;storm1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
     - &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;storm2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
 
 nimbus.seeds: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;storm1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;storm2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、输入python检查一下机器是否安装了python，如果没有则安装python，安装完毕再执行python，发现可以进入，然后ctrl+D退出即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
apt-get &lt;span&gt;install&lt;/span&gt; python-minimal
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、启动Storm集群，通过以下命令分别启动nimbus、supervisor和控制台UI，nohup可以当SSH客户端关闭时，不会将进程杀死，后缀加一个&amp;amp;，可以理解为让进程在后台运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
nohup /work/soft/apache-storm-&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/bin/storm nimbus &amp;amp;&lt;span&gt;
nohup &lt;/span&gt;/work/soft/apache-storm-&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/bin/storm supervisor &amp;amp;&lt;span&gt;
nohup &lt;/span&gt;/work/soft/apache-storm-&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/bin/storm ui &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、通过jps命令查看进程是否正常启动，如果看到config_value，说明还没启动完毕，稍等一下就好了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354244/201811/1354244-20181129100245765-1347185865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354244/201811/1354244-20181129100321891-1294132046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、打开8080端口，可以看到控制台，正常运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354244/201811/1354244-20181129100411901-540309810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;四、Storm代码编写&lt;/h2&gt;
&lt;p&gt;我们根据以上的思路写一个简单的单词统计任务，我们先放在开发环境上面跑代码，是不需要Storm集群环境的，等我们写好代码并在本地跑通后，就可以搭建Storm集群，在集群上面跑了，关于单词统计的代码网上很容易找到，下面阐述一下实现的思路，可以对照着以下文字来看代码，更好理解&lt;/p&gt;
&lt;p&gt;1、创建一个maven工程，引入以下依赖，由于我这里的思路是：通过Rabbitmq获取消息数据，Storm进行数据流处理，将结果存储为Json格式并存入HBase。所以我需要引入如下依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- HBase --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.hbase&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;hbase-client&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;&lt;span&gt;2.1&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- Storm --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.storm&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;storm-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;&lt;span&gt;1.0&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- Json --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.json&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;json&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;&lt;span&gt;20140107&lt;/span&gt;&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- RabbitMQ --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.rabbitmq&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;amqp-client&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;&lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、因为要使用HBase，所以参照上文的操作，还要将Hadoop的配置文件拷贝到项目中。环境搭建好后，开始编写代码&lt;/p&gt;
&lt;p&gt;3、首先编写Spout，也就是数据的来源，创建一个类实现IRichSpout接口，并重写nextTuple()方法，在这个方法里实现数据的生产，比如读取数据库（RDS或NoSQL），从消息队列获取数据（Kafka、RabbitMQ），将输出的数据定义成Tuple（元组），通过重写declareOutputFields()方法，定义元组的key和数量，然后在nextTuple()方法中将元组的内容通过emit()方法传递到下一个组件&lt;/p&gt;
&lt;p&gt;4、编写Bolt，也就是数据的处理者，创建一个类实现IRichBolt接口，并重写execute(Tuple tuple)方法，这个方法就是处理数据的逻辑了，在这里可以编写各种代码对接收到的Tuple进行处理，处理完毕后，和Spout一样，可以将数据通过定义Tuple的方式传递到下一个组件，每个Bolt会对数据进行特定的处理，然后传递给下一个Bolt，这样就可以组成一条数据流的处理链&lt;/p&gt;
&lt;p&gt;5、编写Topology，拓扑将上面编写的组件连接起来，组成一个拓扑图，数据就在这个拓扑图里面持续的“流动”，永不停歇，拓扑也是程序的入口，所以创建一个主函数，在主函数里面创建一个TopologyBuilder对象，通过setSpout()、setBolt()方法将上面的组件连接起来，连接的方式涉及到Storm的八种Grouping策略&lt;/p&gt;
&lt;p&gt;（1）Shuffle Grouping（随机分组）：最常用的分组方式，将Tuple平均随机分配到各个Bolt里面&lt;/p&gt;
&lt;p&gt;（2）Fields Grouping（字段分组）：根据指定字段进行分组，比如我们按照word字段进行分组，相同word值的Tuple会被分配到同一个Bolt里面&lt;/p&gt;
&lt;p&gt;（3）All Grouping（广播分组）：所有的Bolt都可以收到Tuple&lt;/p&gt;
&lt;p&gt;（4）None Grouping（无分组）：将Tuple随机分配到各个Bolt里面&lt;/p&gt;
&lt;p&gt;（5）Global Grouping（全局分组）：将Tuple分配到task id值最低的task里面&lt;/p&gt;
&lt;p&gt;（6）Direct Grouping（直接分组）：生产者Bolt决定消费者Bolt可以接受的Tuple&lt;/p&gt;
&lt;p&gt;（7）Local or Shuffle Grouping（本地或者随机分组）：Bolt在同一进程或存在多个task，元组会随机分配这些task&lt;/p&gt;
&lt;p&gt;（8）Custom Grouping （自定义分组）：通过实现CustomStreamGrouping接口来定义自定义分组&lt;/p&gt;
&lt;p&gt;6、通过TopologyBuilder连接好各个组件后，就可以提交任务了，提交任务分两种方式：本地提交和集群提交&lt;/p&gt;
&lt;p&gt;（1）本地提交：提交到开发环境中，不需要安装Storm环境，只需要引入Storm的依赖包即可，使用LocalCluster类的submitTopology方法提交任务&lt;/p&gt;
&lt;p&gt;（2）集群提交：提交到Storm集群中，使用StormSubmitter类的submitTopology方法提交任务&lt;/p&gt;
&lt;h2&gt;五、提交jar包到集群&lt;/h2&gt;
&lt;p&gt;1、首先我们要修改一下pom文件，将之前引入的storm-core依赖里面加&amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;，目的是storm-core这个依赖排除掉，因为这个依赖只是本地测试调试依赖的，集群中不需要这个依赖，如果不加会报错，还要记得修改拓扑的代码，使用StormSubmitter类来提交&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.storm&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;storm-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;&lt;span&gt;1.0&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、通过编译器将我们的maven项目打包成jar&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mvn clean &lt;span&gt;install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、将jar包拷贝到集群的集群里面，因为我们的代码使用到了HBase，所以要记得把项目中的配置文件夹也拷贝过来（core-site.xml、hbase-site.xml、hdfs-site.xml），jar是扫描不到jar包里的配置文件的，把配置文件放到与jar包同级目录下即可&lt;/p&gt;
&lt;p&gt;4、执行命令将jar包提交到集群中运行，命令后面要记得指定主函数的全包名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
nohup /work/soft/apache-storm-&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;/bin/storm jar /work/jar/mytest.jar com.orange.heatmap.Main &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、进入8080控制台，可以看到我们刚才提交的拓扑，点击进去可以查看运行的状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354244/201811/1354244-20181129115132891-1360076019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 29 Nov 2018 07:45:00 +0000</pubDate>
<dc:creator>未分配微服务</dc:creator>
<og:description>一、前言 1、这一文开始进入Storm流式计算框架的学习 二、Storm简介 1、Storm与Hadoop的区别就是，Hadoop是一个离线执行的作业，执行完毕就结束了，而Storm是可以源源不断的接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/orange911/p/10006833.html</dc:identifier>
</item>
<item>
<title>jQuery获取或设置元素的宽度和高度 - 曹庆军</title>
<link>http://www.cnblogs.com/cqj98k/p/10038765.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cqj98k/p/10038765.html</guid>
<description>&lt;p&gt;jQuery获取或设置元素的宽度和高度：&lt;/p&gt;
&lt;p&gt;可使用以下3种方法：&lt;/p&gt;
&lt;p&gt;1，jQuery width() 和 height() 方法；&lt;/p&gt;
&lt;p&gt;2，innerWidth() 和 innerHeight() 方法；&lt;/p&gt;
&lt;p&gt;3，outerWidth() 和 outerHeight()方法。&lt;/p&gt;

&lt;p&gt;jQuery width() 和 height() 方法，innerWidth() 和 innerHeight() 方法，outerWidth() 和 outerHeight() 方法的区别如下：&lt;/p&gt;
&lt;p&gt;一、jQuery width() 和 height() 方法&lt;br/&gt;width() 方法设置或返回元素的宽度（不包括内边距、边框或外边距）。&lt;br/&gt;height() 方法设置或返回元素的高度（不包括内边距、边框或外边距）。&lt;/p&gt;

&lt;p&gt;二、jQuery innerWidth() 和 innerHeight() 方法&lt;br/&gt;innerWidth() 方法设置或返回元素的宽度（包括内边距）。&lt;br/&gt;innerHeight() 方法设置或返回元素的高度（包括内边距）。&lt;/p&gt;

&lt;p&gt;三、jQuery outerWidth() 和 outerHeight() 方法&lt;br/&gt;outerWidth() 方法设置或返回元素的宽度（包括内边距和边框）。&lt;br/&gt;outerHeight() 方法设置或返回元素的高度（包括内边距和边框）。&lt;/p&gt;
</description>
<pubDate>Thu, 29 Nov 2018 07:45:00 +0000</pubDate>
<dc:creator>曹庆军</dc:creator>
<og:description>jQuery获取或设置元素的宽度和高度： 可使用以下3种方法： 1，jQuery width() 和 height() 方法； 2，innerWidth() 和 innerHeight() 方法； 3</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cqj98k/p/10038765.html</dc:identifier>
</item>
<item>
<title>vue 双向数据绑定的实现学习（一） - adouwt</title>
<link>http://www.cnblogs.com/adouwt/p/9928278.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adouwt/p/9928278.html</guid>
<description>&lt;h4&gt;前言：本系列学习笔记从以下几个点展开&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;什么是双向数据绑定&lt;/li&gt;
&lt;li&gt;双向数据绑定的好处&lt;/li&gt;
&lt;li&gt;怎么实现双向数据绑定&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;实现双向数据数据绑定需要哪些知识点
&lt;ul&gt;&lt;li&gt;数据劫持&lt;/li&gt;
&lt;li&gt;发布订阅模式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 先看看我们要实现的目标是什么，如下动图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201811/1102860-20181109091950949-1966986286.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;0、什么是双向数据绑定&lt;/h2&gt;
&lt;p&gt;　　单向数据绑定：把Model 绑定到View上,当我们用js修改模型 Model 时候，视图View上对应的内容也会改动，这就是 &lt;strong&gt;数据动，页面动 。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;双向数据绑定：简言之 &lt;strong&gt;数据动 页面动，页面动，数据动, &lt;/strong&gt;典型的应用就是在做表单时候，输入框的内容改动后，跟该输入框的value 的值改动。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201811/1102860-20181108112933178-859763298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看vue 官网上的这个V-model  的演示案例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201811/1102860-20181108113759534-1012847823.gif&quot; alt=&quot;&quot; width=&quot;828&quot; height=&quot;401&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1、双向数据绑定的好处&lt;/h2&gt;
&lt;p&gt;　　要说出这个好处的时候，也只有在实际场景中才能对应的显示出来。比如我们需要实时显示数据，我们一边说话，一边实时显示我们说的话的文字内容，等等。这让我想起了去年参加云栖大会，台上的大佬一边说话，下面的字幕实时更新。（当然实现这个技术有很多技术点，我们不讨论这个内容，小编也才疏学浅，搞不懂）&lt;/p&gt;
&lt;p&gt;以上的都是废话，我们直接看看怎么实现这个双向数据绑定。&lt;/p&gt;
&lt;h2&gt;一、实现原理&lt;/h2&gt;
&lt;p&gt;　　Vue实现双向数据绑定的原理：数据劫持 + 发布订阅模式（有的也称为观察者模式）&lt;/p&gt;
&lt;p&gt;　　数据劫持的核心技术： Object.defineProperty()&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;*&lt;span&gt;*vue 3.0 已经用的不是这个技术了，采用是 原生的 Proxy，据说速度能够提升100%，截张尤大的ppt，** 2018-11-21 修改本篇笔记&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201811/1102860-20181121094605374-1127407257.png&quot; alt=&quot;&quot; width=&quot;436&quot; height=&quot;410&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（香菇，刚研究会一点，就立马变了，这就是前端世界）,Proxy 的方式将会在本系列笔记结束后，再记录这个技术点的使用&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二、数据劫持的方法 Object.defineProperty()&lt;/h2&gt;
&lt;p&gt;　　先上一个参照代码，它长这个样子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; book =&lt;span&gt; {
 _year: &lt;/span&gt;&lt;span&gt;2004&lt;/span&gt;&lt;span&gt;,
 edition: &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
};
Object.defineProperty(book, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, {
 &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;: function(){&lt;br/&gt;　　　console.log('访问year了,返回_year')
 　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._year;
 },
 &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;: function(newValue){
 　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newValue &amp;gt; &lt;span&gt;2004&lt;/span&gt;&lt;span&gt;) {
 　　　　&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._year =&lt;span&gt; newValue;&lt;br/&gt;　　　　　console.log('重新设置_year了，并返回edition')
 　　　　&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.edition += newValue - &lt;span&gt;2004&lt;/span&gt;&lt;span&gt;;
 　　}
 }
});
book.year &lt;/span&gt;= &lt;span&gt;2005&lt;/span&gt;&lt;span&gt;;
alert(book.edition); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; ---摘自 JavaScript高级程序设计&lt;/p&gt;
&lt;p&gt;　　Object.defineProperty() 的具体介绍，我们本文不做具体展开，查看我这里的一篇文章，&lt;span&gt;&lt;em&gt;Object.defineProperty&lt;/em&gt;&lt;/span&gt;。 我们这里先要知道这么一个事情。这个方法要传入三个参数，传入的数据对象data，属性key，描述符对象。其中，描述符（descriptor）对象的属 性必须是：configurable、enumerable、writable 和 value。设置其中的一或多个值，可以修改 对应的特性值。我们需要用的是这访问器属性。当我们在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用 setter 函数并传入新值，这个函数负责决定如何处理数据。上文代码上的 &lt;span&gt;&lt;strong&gt;get 方法，在读取属性时调用的函数，set方法，在写入属性时调用的函数。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201811/1102860-20181108163755284-415857342.gif&quot; alt=&quot;&quot; width=&quot;651&quot; height=&quot;407&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、发布订阅者模式&lt;/h2&gt;
&lt;p&gt;　　我画了一个图，来理解这个模式，如下图：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1102860/201811/1102860-20181109115550997-623993100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;代码解释：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_0ad7f677-9c6c-473a-a66a-3967f73d3e0b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0ad7f677-9c6c-473a-a66a-3967f73d3e0b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0ad7f677-9c6c-473a-a66a-3967f73d3e0b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面封装一个单例模式，内容是发布订阅模式&lt;/span&gt;
let event =&lt;span&gt; {
    eventList: [],
    listener: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (key, fn) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.eventList[key]) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有订阅过此类消息，创建一个缓存列表&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.eventList[key] =&lt;span&gt; [];
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eventList[key].push(fn)
    },
    trigger: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        let key &lt;/span&gt;= Array.prototype.shift.call(arguments); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; marry&lt;/span&gt;
        let fns = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eventList[key];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!fns || fns.length == 0) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有订阅 则返回&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0, fn; fn = fns[i++&lt;span&gt;];) {
            fn.apply(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用 event.listen 里面的 fn 方法，通过apply将当前执行的对象指向当前的this，arguments 传进 fn 函数&lt;/span&gt;
&lt;span&gt;        }
    },
    remove: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; (key, fn) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取消订阅&lt;/span&gt;
        let fns = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eventList[key];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;fns) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;fn) {
            fns &lt;/span&gt;&amp;amp;&amp;amp; (fns.length = 0&lt;span&gt;)
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let l = fns.length-1; l&amp;gt;=0; l--&lt;span&gt;) {
                let _fn &lt;/span&gt;=&lt;span&gt; fns[l];
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( _fn ===&lt;span&gt; fn) {
                    fns.splice(l, &lt;/span&gt;1&lt;span&gt;)
                }
            }
        }
    },
    install: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (obj) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i === 'install'&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
            }
            obj[i] &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;[i];
        }
    }
}


let testMsg &lt;/span&gt;=&lt;span&gt; {}
event.install(testMsg)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上面方法 就会将event的方法 浅拷贝给 testMsg, 这样testMsg就有 event的方法和属性&lt;/span&gt;
testMsg.listener('rich', fn1 = (name) =&amp;gt;&lt;span&gt; {
    console.log(`${name}知道你有钱了`)
})
testMsg.listener(&lt;/span&gt;'borrowMoney', fn2 =  (name) =&amp;gt;&lt;span&gt; {
    console.log(`${name}想问你借钱`)
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; listen方法将事件 放进队列&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; testMsg.remove('rich', fn1) // 取消订阅&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; trigger方法，处理事件队列的方法，调用listen的函数的里面的回调函数 fn&lt;/span&gt;
testMsg.trigger('rich', '张三'&lt;span&gt;)
testMsg.trigger(&lt;/span&gt;'rich', '张三2'&lt;span&gt;)
testMsg.trigger(&lt;/span&gt;'borrowMoney', '李四'&lt;span&gt;)
testMsg.trigger(&lt;/span&gt;'borrowMoney', '李四2'&lt;span&gt;)



&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代码总结：&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 订阅的事件具有对应的key&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过listener方法，将具体的事件队列保存到 eventList ，可以理解为缓存列表也可以是事件队列；&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行trigger 方法，将事件队列拿出来执行调用&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; remove 方法根据对应的key值，删除对应的订阅事件&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 模式总结：封装一个单例event， 执行installEvent方法，将想要event对象拷贝到某个对象中去，&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 发布者trigger方法，监听者listen方法 ，trigger 发布一个东西，listen立马知道你要发布的东西&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;四、实现分解&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;主函数入口
&lt;ul&gt;&lt;li readability=&quot;0.5&quot;&gt;　　
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function Myvue (options) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$options =&lt;span&gt; options
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$el =&lt;span&gt; document.querySelector(options.el);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$data =&lt;span&gt; options.data;
    Object.keys(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$data).forEach(key =&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.$prop =&lt;span&gt; key;
    })
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.init()
}
Myvue.prototype.init &lt;/span&gt;=&lt;span&gt; function () {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听数据变化&lt;/span&gt;
    observer(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$data);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得值
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; let value = this.$data[this.$prop];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不经过模板编译直接 通知订阅者更新dom
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; new Watcher(this,this.$prop,value =&amp;gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     console.log(`watcher ${this.$prop}的改动，要有动静了`)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     this.$el.textContent = value
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; }) 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通知模板编译来执行页面上模板变量替换&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt; Compile(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;主函数调用
&lt;ul&gt;&lt;li readability=&quot;-1&quot;&gt;　　
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;
    &lt;span&gt;const&lt;/span&gt; vm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Myvue({
        el: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        data: {
            name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vue 双向数据绑定test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;监听器&lt;/li&gt;
&lt;li&gt;订阅者&lt;/li&gt;
&lt;li&gt;模板编译器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 未完待续，错误之处，敬请指出,共同进步！&lt;/p&gt;
&lt;p&gt;下一篇 vue 双向数据绑定的实现学习（二）-监听器的实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章参考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;a href=&quot;https://www.cnblogs.com/beevesnoodles/p/9844854.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/beevesnoodles/p/9844854.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;a href=&quot;https://github.com/youngwind/blog/issues/87&quot; target=&quot;_blank&quot;&gt;https://github.com/youngwind/blog/issues/87&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;a href=&quot;https://juejin.im/post/5a9108b6f265da4e7527b1a4&quot; target=&quot;_blank&quot;&gt;https://juejin.im/post/5a9108b6f265da4e7527b1a4&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 29 Nov 2018 07:26:00 +0000</pubDate>
<dc:creator>adouwt</dc:creator>
<og:description>前言：本系列学习笔记从以下几个点展开 什么是双向数据绑定 双向数据绑定的好处 怎么实现双向数据绑定 实现双向数据数据绑定需要哪些知识点 数据劫持 发布订阅模式 实现双向数据数据绑定需要哪些知识点 数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/adouwt/p/9928278.html</dc:identifier>
</item>
<item>
<title>Android通知栏介绍与适配总结（上篇） - 网易云</title>
<link>http://www.cnblogs.com/163yun/p/10038542.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/163yun/p/10038542.html</guid>
<description>&lt;p&gt;此文已由作者黎星授权网易云社区发布。&lt;/p&gt;
&lt;p&gt;欢迎访问&lt;a href=&quot;https://sq.163yun.com/blog?tag=M_tg_851_65&quot;&gt;网易云社区&lt;/a&gt;，了解更多网易技术产品运营经验。&lt;/p&gt;

&lt;p&gt;由于历史原因，Android在发布之初对通知栏Notification的设计相当简单，而如今面对各式各样的通知栏玩法，谷歌也不得不对其进行更新迭代调整，增加新功能的同时，也在不断地改变样式，试图迎合更多人的口味。本文总结了Android通知栏的版本迭代过程，在通知栏开发过程中所遇到的各种各样的坑，以及一些解决技巧，特别的，对于大众期盼的Android 7.0的到来，通知栏又会发生怎样的改变呢？接下来一一进行介绍。&lt;/p&gt;


&lt;p&gt;首先来看一张各个Android版本通知栏消息的全家福。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201808280938219a7e1e18-1357-4512-848d-fb991ce4951a.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://nos.netease.com/knowledge/03b29905-8847-4d01-ba05-e4a7d2975ecf&quot;&gt;点击查看大图&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Android通知栏从最初的Android1.1系统一直到如今的7.X版本，发生了翻天覆地的变化。从图中可以看出，1.X-2.2版本的通知栏采用了白色背景和黑色字体；2.3-4.X版本，默认背景变成了黑色，而主标题采用白色字体，内容为灰色字体。从Android5.0开始，又更改为白色背景和黑色字体。当然，这只是原生的Android系统通知栏默认颜色，许多厂商对每个Android的版本都尝试了各式各样的修改，在此不一一介绍。&lt;/p&gt;

&lt;p&gt;下面分别介绍每个版本的更新和修改记录。&lt;/p&gt;

&lt;h2&gt;Android 1.X 修改记录&lt;a href=&quot;https://arstechnica.com/gadgets/2016/10/building-android-a-40000-word-history-of-googles-mobile-os/8/#h1&quot;&gt;^1&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Android 1.X版本也就是第一个Android诞生的版本。从Android1.1版本开始，提供基本的通知栏消息功能，包含小图标、主标题、副标题和时间这四个元素。右上角有一个清除通知栏消息的按钮。需要说明的是，Android从一开始就提供了清除通知栏消息的功能并且保留至今，而iOS到现在都没有提供清除按钮。&lt;/p&gt;

&lt;h2&gt;Android 2.X 修改记录&lt;a href=&quot;https://arstechnica.com/gadgets/2016/10/building-android-a-40000-word-history-of-googles-mobile-os/10/#2.0eclair&quot;&gt;^2&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Android 2.X版本的通知栏消息功能上并未发生变化，右上角的“clear notifications”缩减为了“clear”。2.2版本以前沿用了1.5的通知栏样式，从2.3版本开始重新设计，改成了暗色背景。&lt;/p&gt;

&lt;h2&gt;Android 3.X 修改记录&lt;a href=&quot;https://arstechnica.com/gadgets/2016/10/building-android-a-40000-word-history-of-googles-mobile-os/16/#honeycomb&quot;&gt;^3&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Android 3.X版本是专为Pad而设计的系统。通知栏消息带来了一些新的功能。&lt;/p&gt;

&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;非永久的通知栏消息的右边增加了“X”按钮，点击后该条通知可以立即清除。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;增加了RemoteControlClient，即远程控制媒体应用的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;增加了LargeIcon，可以使用大图展示通知栏消息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Android 4.1 修改记录&lt;a href=&quot;http://www.androidpolice.com/2012/07/04/getting-to-know-android-4-1-part-2-the-glorious-new-notifications-size-matters/&quot;&gt;^4&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Android 4.1版本的通知栏在3.X版本的基础上进行了大量修改。增加了不少新功能。&lt;/p&gt;

&lt;h3&gt;通知栏样式&lt;/h3&gt;
&lt;p&gt;Android 4.1通知栏最大的变化就是增加了丰富多样的Style样式。通过设置样式，可以展示更大区域的通知消息，如展示大图和多行文字，也可以展示类似邮箱收发信的样式，同时支持自定义按钮并增加点击事件。但需要注意的是，只有最顶部的那条通知栏消息可以默认展示Style样式，其他消息默认是以普通样式展示。Style可以通过Notification.Builder.setStyle(Style)进行设置。具体支持的样式有：&lt;/p&gt;

&lt;h4&gt;Notification.BigPictureStyle&lt;/h4&gt;
&lt;p&gt;大图样式，即除了普通的通知栏消息内容外，可以在通知栏消息下方展示一张大图，最大高度支持256dp。&lt;/p&gt;

&lt;h4&gt;Notification.BigTextStyle&lt;/h4&gt;
&lt;p&gt;多行文字样式，可以支持多行文字的展示。经测试，在不同手机上能够支持的行数不一样，测试过的机子，最大支持12行。&lt;/p&gt;

&lt;h4&gt;Notification.InboxStyle&lt;/h4&gt;
&lt;p&gt;收件箱样式。支持展示具有一串消息内容的会话样式，适用于短信、邮件、IM等。&lt;/p&gt;

&lt;h3&gt;通知栏按钮&lt;/h3&gt;
&lt;p&gt;通知栏消息不管是普通样式还是Style样式，都支持两个按钮同时出现在一条通知栏消息的底部，通过这两个按钮，可以自定义一系列动作，包括回复信息和邮件，点赞等。通过Notification.Builder.addAction(Action)添加按钮。&lt;/p&gt;

&lt;h3&gt;通知栏优先级&lt;/h3&gt;
&lt;p&gt;Android 4.1通知栏增加了优先级的配置，优先级高的消息可以展示在最上方。谷歌设计优先级的初衷是根据不同的优先级来防止用户整天被各种莫名其妙的通知栏消息骚扰，重要的通知则应该适当提高优先级，使得用户可以快速地看到并回应，不重要的通知则降低优先级，防止用户被打扰。优先级一共有5个级别，分别是：&lt;/p&gt;
&lt;pre&gt;
// 默认优先级
public static final int PRIORITY_DEFAULT = 0;
// 低优先级
public static final int PRIORITY_LOW = -1;
// 最低优先级
public static final int PRIORITY_MIN = -2;
// 高优先级
public static final int PRIORITY_HIGH = 1;
// 最高优先级
public static final int PRIORITY_MAX = 2;
&lt;/pre&gt;
&lt;h2&gt;Android 4.3 修改记录&lt;a href=&quot;https://developer.android.com/about/versions/android-4.3.html&quot;&gt;^6&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Android 4.3通知栏没有发生大的变化。主要增加了两个小功能。&lt;/p&gt;

&lt;h2&gt;Android 5.X 修改记录&lt;a href=&quot;https://developer.android.com/about/versions/android-5.0-changes.html#BehaviorNotifications&quot;&gt;^7&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Android 5.X系统相较于以前的版本，可以说是一个真正可以和iOS抗衡的系统。材料设计给Android系统注入了新的活力，相应的通知栏消息也相较于上一个版本进行了改版。所发生的变化有：&lt;/p&gt;

&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通知栏修改为白色背景，暗色字体，以适应材料设计风格。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;系统会忽略所有non-alpha通道的图标，包括按钮图标和主图标。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以通过setColor()方法在图标后设置一个背景色。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通知消息的声音将通过STREAM_RING或者STREAM_NOTIFICATION控制，以前是通过STREAM_MUSIC控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;锁屏状态下，可以控制通知栏消息的隐私程度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;移除了RemoteControlClient，更改为NotificationCompat.MediaStyle实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;增加了Heads-up通知，即通过状态栏浮动窗口展示通知消息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Android 6.X 修改记录&lt;a href=&quot;https://developer.android.com/about/versions/marshmallow/android-6.0-changes.html&quot;&gt;^8&lt;/a&gt;&lt;/h2&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;移除了Notification.setLatestEventInfo()方法，通过持有Notification.Builder，然后使用build()方法可以更新同一个通知栏实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;允许用户控制应用通知的优先级。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;加入了免打扰模式（Do Not Disturb）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;增加了getActiveNotifications()方法获取当前展示的通知消息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Android 7.X 修改记录&lt;/h2&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通知栏样式全面改版，小图标在左上角，大图标在右边，小图标、App应用名、副标题、数量和时间在第一行，第二行是主标题，第三行是内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;增加了Notification.DecoratedCustomViewStyle()和Notification.DecoratedMediaCustomViewStyle()，帮助更好的装饰带有RemoteViews的通知栏消息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;需要动态设置Builder.setShowWhen(true)才会显示时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;支持Action的直接回复，通过RemoteInput实现，且回复的消息内容支持立即添加到通知栏。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持通知消息组，相似的消息在达到一定数量后会按照消息组来显示。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;增加了NotificationManager.areNotificationsEnabled告知应用是否开启了通知权限。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;魅族5.X手机，大图显示问题&lt;/h2&gt;
&lt;h3&gt;问题详情&lt;/h3&gt;
&lt;p&gt;Flyme系统对原生Android源码做了修改，采用BigPictureStyle方式显示大图通知栏的时候，消息与大图重合了，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180828093844dee3d5e5-439d-4d75-aae8-ef2f9a20105f.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;p&gt;首先说一下为什么会有解决方案。展示大图这个功能开发完成后，拿去给产品演示。碰巧产品的机型就是一魅族手机T_T，结果当然是不能接受的，然后又一个巧合的事情出现了，那就是产品的手机里，京东App推了一条带大图的广告，他们居然能够解决这个问题！于是，我开始研究解决方案。&lt;/p&gt;

&lt;p&gt;首先，通过BigPictureStyle来实现大图功能肯定是走不通的，因为事实就摆着行不通的嘛。京东的App肯定是通过RemoteViews来实现的。于是，开始走弯路，尝试通过RemoteViews来展示大图。但是谷歌规定，自定义布局展示的通知栏消息最大高度是64dp。那么，京东的App是怎么实现的？在尝试了各种方法以后，最后又是通过投机取巧的方式解决了问题：&lt;/p&gt;
&lt;pre&gt;
private void showBigPictureNotificationWithMZ(Context context) {
    NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    Notification.Builder builder = new Notification.Builder(context);
    Notification notification = generateNotification(builder);
    notification.bigContentView = mRemoteViews;
    notificationManager.notify(notifyId, notification);
}
&lt;/pre&gt;
&lt;p&gt;需要先生成Notification的实例，然后手动给notification.bigContentView赋值，再notify，就可以了&lt;/p&gt;

&lt;h2&gt;顶部状态栏(StatusBar)小图标显示异常&lt;/h2&gt;
&lt;h3&gt;问题详情&lt;/h3&gt;
&lt;p&gt;当通知来的时候，如果不在通知栏浏览，会在顶部状态栏出现一个向上翻滚动画的通知消息，这条通知消息左边是一个小图标。部分系统这个小图标显示异常，是一个纯灰色的正方形，如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180828093901b939eff5-555f-43c6-adcd-b0e925892ca3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;p&gt;首先产生灰色图标的原因就是5.0系统引入了材料设计，谷歌强制使用带有alpha通道的图标，并且RGB的alpha值必须是0(实测不为0也是可以的，但系统会忽略所有RGB值)。因此，使用JPG的图片是不行的，最好的代替方案就是一张背景透明的PNG图片。&lt;/p&gt;

&lt;h2&gt;Android 7.X机型，通知栏小图标显示成灰色&lt;/h2&gt;
&lt;h3&gt;问题详情&lt;/h3&gt;
&lt;p&gt;这个问题跟第二个有点类似，在7.0系统及以上，有部分应用的小图标是灰色的，大图可以正常显示。碰巧的是，显示异常的小图标，颜色都是灰色的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/2018082809400925217427-3cb7-4f0f-9b36-eb437841c8d1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;p&gt;与&lt;a href=&quot;http://ks-test.hz.netease.com/blog?id=7728#%E5%B0%8F%E5%9B%BE%E6%A0%87%E6%98%BE%E7%A4%BA%E5%BC%82%E5%B8%B8&quot;&gt;小图标显示异常解决方案&lt;/a&gt;类似，将小图标替换为透明背景的PNG图片。&lt;/p&gt;

&lt;h2&gt;RemoteViews显示异常&lt;/h2&gt;
&lt;h3&gt;问题详情&lt;/h3&gt;
&lt;p&gt;由于系统提供的通知栏消息类型有时候不能满足要求，部分通知栏消息采用自定义RemoteViews来实现。采用RemoteViews，特别是手动生成Bitmap然后直接传给一个自定义Layout，再通过setContentView方式设置通知栏消息时，会存在各种各样的坑。&lt;/p&gt;

&lt;p&gt;Android通知栏的背景色有几种情况，白色、暗色、暗色透明和黑色。如果生成的Bitmap带背景色，这个背景色就很难选择。如果选择黑色背景，那么在白色通知栏的机型上就很难看。因此不能完全在各个系统上面完美展示出来。如果不带背景色，那么字体颜色也面临同样的困惑。试想，如果在白色的背景上显示白色的文字，用户看到白茫茫一片，是什么感受？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180828094025084a632c-d400-4c8f-b56e-183e00755d3d.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另一方面，大部分厂商对原生的Android系统都会有各种各样的改造，通知栏的样式也不例外。如果按照原生的样式来设计，那么在大部分国内厂商的机子上显示都和正常的普通通知栏消息不一样。例如华为6.0系统的机子，原生系统的时间线在右上角，华为的在左边，这样会给用户带来错觉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180828094043583e7a78-4376-4d2b-b9d6-1c0a5c17b0ec.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;p&gt;详见&lt;a href=&quot;http://ks-test.hz.netease.com/blog?id=7728#RemoteViews%E9%80%82%E9%85%8D&quot;&gt;RemoteViews适配&lt;/a&gt;一节。&lt;/p&gt;

&lt;h2&gt;大尺寸小图标在部分机型上显示不正确&lt;/h2&gt;
&lt;h3&gt;问题详情&lt;/h3&gt;
&lt;p&gt;这个问题主要在部分机型的4.X系统上遇见，小图标大小没有按照24dp裁剪，而是采用了桌面图标一样的大小96dp。具体适配不正常的机型有HTC Desire 820、Lenovo A320T。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201808280940570adb8bf3-6533-487a-bee3-5ed8e8163fb5.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;p&gt;按照标准来，小图标大小为24dp，大图标为桌面icon图标大小96dp。具体可参考&lt;a href=&quot;http://iconhandbook.co.uk/reference/chart/android/&quot;&gt;这里&lt;/a&gt;&lt;a href=&quot;http://iconhandbook.co.uk/reference/chart/android/&quot;&gt;^14&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;部分机型不支持Style&lt;/h2&gt;
&lt;p&gt;具体机型见下图以及后面统计的表格。顺便提下，小米是其中之一，不知道他们为什么不支持额外的这些Style。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/20180828094115c03c3aac-d17c-4627-8da4-7e9a02797627.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://nos.netease.com/knowledge/3a2b8173-17b3-4d2c-9ef4-6bfabbbf7fd1&quot;&gt;点击查看大图&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;通知栏更新频率&lt;/h2&gt;
&lt;h3&gt;问题详情&lt;/h3&gt;
&lt;p&gt;每个应用基本都有自更新的逻辑，App开机的时候提示用户升级，点击升级按钮后在Notification出现一个下载带进度条的通知。应用一般是在开启一个工作线程在后台下载，然后在下载的过程中通过回调更新通知栏中的进度条。我们知道，下载进度的快慢是不可控的，如果每次下载中的回调都去更新通知栏，那么可能几百毫秒、几十毫秒、甚至几毫秒就更新一次通知栏，应用可能就会ANR，甚至崩溃。&lt;/p&gt;

&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;p&gt;控制通知栏更新频率，一般控制在0.5s或者1s就可以了。在某一个更新时间间隔内下载的进度回调直接丢弃，需要注意的是下载完成的回调，需要实时回调通知栏消息显示下载完成。&lt;/p&gt;

&lt;h2&gt;恶心的后台通知和“守护”通知&lt;/h2&gt;
&lt;h3&gt;问题详情&lt;/h3&gt;
&lt;p&gt;这个坑我不愿多介绍，只说结果。但凡存在后台通知或者“守护”通知的应用，在7.0系统以后都会原形毕露。还没有适配7.0的应用，可长点心儿吧~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201808280941339bf64522-36bb-408d-abf2-0a3028eeb686.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201808280941332ea5f8a6-8da2-4ca5-b332-1b6bcd827f29.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;p&gt;请弃坑。&lt;/p&gt;

&lt;h2&gt;小米推送SDK接入问题&lt;/h2&gt;
&lt;h3&gt;问题详情&lt;/h3&gt;
&lt;p&gt;为了提升推送到达，考拉接入了小米推送的SDK。小米推送分为通知栏消息和透传消息，通知栏消息属于系统级推送，在MIUI的机子上可以在进程被杀死的情况下也能收到应用推送。然而有个问题，小米认为应用在前台时，不会回调任何方法；小米认为应用在后台的时候，收到通知栏消息的同时，会回调onNotificationMessageArrived方法。这时候就要小心翼翼地处理这条消息了。因为如果你的应用前后台判断逻辑和小米的不一样，那么就有可能小米帮你发了一条通知栏消息，你自己又发了一遍，造成通知栏消息的重复发送(这个坑考拉踩过T_T)。另一方面，在7.0系统的机子上，主标题和小图标的颜色是可以改变的，目前小米推送SDK没有开放这个接口供调用方定制。&lt;/p&gt;

&lt;h3&gt;解决方案&lt;/h3&gt;
&lt;p&gt;目前只能解决第一个问题——前后台判断的问题。应用是否在后台可以根据以下代码进行判断。在Android 5.0以上，可以通过ActivityManager.RunningAppProcessInfo判断，Android 5.0及以下版本通过ActivityManager.RunningTaskInfo判断。经测试，这个方案在Android 4.4以上结果是可以完全匹配的。&lt;/p&gt;

&lt;pre&gt;
public static boolean isAppInBackgroundInternal(Context context) {
    ActivityManager manager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
    if (Build.VERSION.SDK_INT &amp;gt; Build.VERSION_CODES.LOLLIPOP) {
        List&amp;lt;ActivityManager.RunningAppProcessInfo&amp;gt; runningProcesses = manager.getRunningAppProcesses();
        if (!ListUtils.isEmpty(runningProcesses)) {
            for (ActivityManager.RunningAppProcessInfo runningProcess : runningProcesses) {
                if (runningProcess.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) {
                    return false;
                }
            }
        }
    } else {
        List&amp;lt;ActivityManager.RunningTaskInfo&amp;gt; task = manager.getRunningTasks(1);
        if (!ListUtils.isEmpty(task)) {
            ComponentName info = task.get(0).topActivity;
            if (null != info) {
                return !isKaolaProcess(info.getPackageName());
            }
        }
    }
    return true;
}
&lt;/pre&gt;

&lt;h2&gt;RemoteViews适配&lt;/h2&gt;
&lt;p&gt;由于系统自带的通知栏消息样式不能完全满足产品们脑洞大开的需求，有时候我们需要自定义布局样式展示通知栏消息。Android系统可以将自定义布局通过setContent(7.X系统推荐使用setCustomContentView)设置到Notification.Builder中，来实现样式的更变。setContent方法需要传入一个RemoteViews对象，它是一个普通的数据类型，不是View，作用是供其他进程展示视图。RemoteViews只支持4种基本的布局&lt;a href=&quot;https://developer.android.com/guide/topics/appwidgets/index.html#CreatingLayout&quot;&gt;^9&lt;/a&gt;:&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;FrameLayout&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LinearLayout&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RelativeLayout&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GridLayout&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些布局下面只支持几种视图控件:&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;AnalogClock&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Button&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Chronometer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ImageButton&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ImageView&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ProgressBar&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TextView&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ViewFlipper&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ListView&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GridView&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;StackView&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AdapterViewFlipper&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只能通过上述组合生成一个RemoteViews。&lt;/p&gt;

&lt;h3&gt;自定义布局与视图&lt;/h3&gt;
&lt;p&gt;除了上面提到的布局与控件，有没有办法自定义布局与视图呢？我们知道，任何一个View，都可以生成一个Bitmap对象，支持的视图控件里有ImageView，可以通过ImageView.setBitmapResource()将自定义视图设置到一个ImageView中，然后再随便放到一个布局上，就可以实现通知栏消息的任意布局。理想是美好的，但现实是残酷的。使用这种方式自定义的布局，会存在与原生的通知栏消息样式不一致的可能，包括小图标/大图标的大小，字体的大小与颜色，时间的显示方式(不同版本的时间显示位置和样式都不一样)。下面解决一个最关键，也最致命的问题——字体颜色。如果字体颜色和背景颜色一样，那这条通知栏消息就没法看了，如&lt;a href=&quot;http://ks-test.hz.netease.com/blog?id=7728#RemoteViews%E6%98%BE%E7%A4%BA%E5%BC%82%E5%B8%B8&quot;&gt;RemoteViews显示异常&lt;/a&gt;一节介绍的一样。&lt;/p&gt;

&lt;p&gt;解决字体颜色和背景颜色一样的问题有三种解决方案，分别是：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;背景色固定不透明，字体颜色与背景色形成反差。（360和京东的做法）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;背景色透明，字体颜色采用系统原生的notification_style。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;背景色透明，通过特殊方式拿到通知栏字体颜色和字体大小。&lt;img src=&quot;https://nos.netease.com/cloud-website-bucket/201808280941554524c5d4-e0cd-4658-942c-c3529898a301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;其中，第一种方案简单，能够兼容所有厂商机型。例如京东固定背景色为黑色，字体为红色。这种方式的唯一缺陷是样式上不能与普通通知栏消息重合，在白色背景的通知栏上极为显眼。第二种方式，通过阅读源码可知，系统的通知栏标题和内容采用的颜色分别是@android:color/primary_text_dark和@android:color/secondary_text_dark，但踩过坑之后发现并非所有的机型默认都是这两个颜色，有可能获取不到值。因此这种方案只能作为参考，不能用于实际环境中。最后详细介绍一下第三种方式。&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;https://sq.163yun.com/blog/article/192705627588341760?tag=M_tg_851_65&quot; target=&quot;_self&quot;&gt;&lt;span&gt;Android通知栏介绍与适配总结（上篇）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关阅读：&lt;a href=&quot;https://sq.163yun.com/blog/article/192710644351221760?tag=M_tg_851_65&quot; target=&quot;_self&quot;&gt;&lt;span&gt;Android通知栏介绍与适配总结（下篇）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.163yun.com/free?tag=M_tg_851_65&quot;&gt;免费领取验证码、内容安全、短信发送、直播点播体验包及云服务器等套餐&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;更多网易技术、产品、运营经验分享请&lt;a href=&quot;https://sq.163yun.com/blog?tag=M_tg_851_65&quot;&gt;&lt;span&gt;点击&lt;/span&gt;&lt;/a&gt;。&lt;/p&gt;


&lt;p&gt;相关文章：&lt;br/&gt;【推荐】 &lt;a href=&quot;https://www.cnblogs.com/zyfd/p/9767417.html&quot;&gt;探一探快应用的虚实&lt;/a&gt;&lt;br/&gt;【推荐】 &lt;a href=&quot;https://www.jianshu.com/p/5048d6b52a00&quot;&gt;从整理看视觉设计（网易云课堂我的学习中心－微专业视觉优化）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 29 Nov 2018 07:21:00 +0000</pubDate>
<dc:creator>网易云</dc:creator>
<og:description>此文已由作者黎星授权网易云社区发布。 欢迎访问网易云社区，了解更多网易技术产品运营经验。 由于历史原因，Android在发布之初对通知栏Notification的设计相当简单，而如今面对各式各样的通知</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/163yun/p/10038542.html</dc:identifier>
</item>
<item>
<title>搭建redis-sentinel(哨兵机制)集群 - lol霖</title>
<link>http://www.cnblogs.com/lihonglin2016/p/10037808.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lihonglin2016/p/10037808.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;redis怎么才能做到高可用&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;对于redis主从架构，slave可以对应多个本身可以保障高可用，但是对于一个master节点，如果宕机，整个缓存系统就无法进行写的操作，显然整个系统会无法做到高可用
sentinel哨兵可以监测master节点是否正常运行（会自动识别出所有的slave信息），如果出现宕机，则会在对应的slave节点中通过投票的方式来选取一个slave节点作为新的master节点，&lt;br/&gt;旧的master节点恢复之后会被接管成为新的master节点的slave节点。同时sentinel哨兵节点本身也是集群的方式部署来保障自身的高可用，并且一个sentinel是可以同时监听多个master节点&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对于sentinel哨兵节点的一些核心概念：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;1、sdown和odown转换机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sdown和odown两种失败状态&lt;/p&gt;
&lt;p&gt;sdown是主观宕机，就一个哨兵如果自己觉得一个master宕机了，那么就是主观宕机&lt;/p&gt;
&lt;p&gt;odown是客观宕机，如果quorum数量的哨兵都觉得一个master宕机了，那么就是客观宕机&lt;/p&gt;
&lt;p&gt;sdown达成的条件很简单，如果一个哨兵ping一个master，超过了is-master-down-after-milliseconds指定的毫秒数之后，就主观认为master宕机&lt;/p&gt;
&lt;p&gt;sdown到odown转换的条件很简单，如果一个哨兵在指定时间内，收到了quorum指定数量的其他哨兵也认为那个master是sdown了，那么就认为是odown了，客观认为master宕机&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、哨兵集群的自动发现机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;哨兵互相之间的发现，是通过redis的pub/sub系统实现的，每个哨兵都会往__sentinel__:hello这个channel里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在&lt;/p&gt;
&lt;p&gt;每隔两秒钟，每个哨兵都会往自己监控的某个master+slaves对应的__sentinel__:hello channel里发送一个消息，内容是自己的host、ip和runid还有对这个master的监控配置&lt;/p&gt;
&lt;p&gt;每个哨兵也会去监听自己监控的每个master+slaves对应的__sentinel__:hello channel，然后去感知到同样在监听这个master+slaves的其他哨兵的存在&lt;/p&gt;
&lt;p&gt;每个哨兵还会跟其他哨兵交换对master的监控配置，互相进行监控配置的同步&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、slave配置的自动纠正&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;哨兵会负责自动纠正slave的一些配置，比如slave如果要成为潜在的master候选人，哨兵会确保slave在复制现有master的数据; 如果slave连接到了一个错误的master上，比如故障转移之后，那么哨兵会确保它们连接到正确的master上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、slave-&amp;gt;master选举算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个master被认为odown了，而且majority哨兵都允许了主备切换，那么某个哨兵就会执行主备切换操作，此时首先要选举一个slave来&lt;/p&gt;
&lt;p&gt;会考虑slave的一些信息&lt;/p&gt;
&lt;p&gt;（1）跟master断开连接的时长&lt;br/&gt;（2）slave优先级&lt;br/&gt;（3）复制offset&lt;br/&gt;（4）run id&lt;/p&gt;
&lt;p&gt;如果一个slave跟master断开连接已经超过了down-after-milliseconds的10倍，外加master宕机的时长，那么slave就被认为不适合选举为master&lt;/p&gt;
&lt;p&gt;(down-after-milliseconds * 10) + milliseconds_since_master_is_in_SDOWN_state&lt;/p&gt;
&lt;p&gt;接下来会对slave进行排序&lt;/p&gt;
&lt;p&gt;（1）按照slave优先级进行排序，slave priority越低，优先级就越高&lt;br/&gt;（2）如果slave priority相同，那么看replica offset，哪个slave复制了越多的数据，offset越靠后，优先级就越高&lt;br/&gt;（3）如果上面两个条件都相同，那么选择一个run id比较小的那个slave&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、quorum和majority&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每次一个哨兵要做主备切换，首先需要quorum数量的哨兵认为odown，然后选举出一个哨兵来做切换，这个哨兵还得得到majority哨兵的授权，才能正式执行切换&lt;/p&gt;
&lt;p&gt;如果quorum &amp;lt; majority，比如5个哨兵，majority就是3，quorum设置为2，那么就3个哨兵授权就可以执行切换&lt;/p&gt;
&lt;p&gt;但是如果quorum &amp;gt;= majority，那么必须quorum数量的哨兵都授权，比如5个哨兵，quorum是5，那么必须5个哨兵都同意授权，才能执行切换&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、configuration epoch&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;哨兵会对一套redis master+slave进行监控，有相应的监控的配置&lt;/p&gt;
&lt;p&gt;执行切换的那个哨兵，会从要切换到的新master（salve-&amp;gt;master）那里得到一个configuration epoch，这就是一个version号，每次切换的version号都必须是唯一的&lt;/p&gt;
&lt;p&gt;如果第一个选举出的哨兵切换失败了，那么其他哨兵，会等待failover-timeout时间，然后接替继续执行切换，此时会重新获取一个新的configuration epoch，作为新的version号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、configuraiton传播&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;哨兵完成切换之后，会在自己本地更新生成最新的master配置，然后同步给其他的哨兵，就是通过之前说的pub/sub消息机制&lt;/p&gt;
&lt;p&gt;这里之前的version号就很重要了，因为各种消息都是通过一个channel去发布和监听的，所以一个哨兵完成一次新的切换之后，新的master配置是跟着新的version号的&lt;/p&gt;
&lt;p&gt;其他的哨兵都是根据版本号的大小来更新自己的master配置的&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1redis安装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解压完成后可以看到INSTALL和README.md文件，查看以获取更多有用信息。&lt;/p&gt;
&lt;p&gt;在README文件中可以获取到软件的安装步骤。以下安装步骤基于此。&lt;/p&gt;
&lt;p&gt;#step1 进入文件夹，执行编译命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ redis-3.2.8]# make
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#step2 为了后面开发测试的方便，把启动脚本，配置文件，日志文件统一放到redis目录下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@ redis-3.2.8]# mkdir /usr/local/redis
[root@ redis-3.2.8]# mkdir /usr/local/redis/logs
[root@ redis-3.2.8]# mkdir /usr/local/redis/bin
[root@ redis-3.2.8]# mkdir /usr/local/redis/conf&lt;br/&gt;[root@ redis-3.2.8]# mkdir /etc/sentinel&lt;br/&gt;[root@ redis-3.2.8]# mkdir -p /var/sentinel/26377&lt;br/&gt;[root@ redis-3.2.8]# mkdir -p /var/sentinel/26378&lt;br/&gt;[root@ redis-3.2.8]# mkdir -p /var/sentinel/26379
[root@ redis-3.2.8]# cp redis.conf sentinel.conf /usr/local/redis/conf/
[root@ src]# cp redis-server redis-sentinel redis-cli /usr/local/redis/bin/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;#step3 开启Redis服务,检测其可用性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ bin]# redis-server ../conf/redis.conf 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到日志信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/322522/201811/322522-20181129132407424-1021035321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
其中有3个警告
&lt;/pre&gt;
&lt;p&gt;第一个警告：The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.&lt;/p&gt;
&lt;p&gt;意思是：TCP  backlog设置值，511没有成功，因为 /proc/sys/net/core/somaxconn这个设置的是更小的128.&lt;/p&gt;
&lt;p&gt;第二个警告：overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to/etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.&lt;/p&gt;
&lt;p&gt;意思是：overcommit_memory参数设置为0！在内存不足的情况下，后台程序save可能失败。建议在文件 /etc/sysctl.conf 中将overcommit_memory修改为1。&lt;/p&gt;
&lt;p&gt;第三个警告：you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix thisissue run the command 'echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain thesetting after a reboot. Redis must be restarted after THP is disabled.&lt;/p&gt;
&lt;p&gt;意思是：你使用的是透明大页，可能导致redis延迟和内存使用问题。执行 echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled 修复该问题。&lt;/p&gt;
&lt;p&gt;临时解决方法：&lt;/p&gt;
&lt;p&gt;  echo 511 &amp;gt; /proc/sys/net/core/somaxconn&lt;/p&gt;
&lt;p&gt;  echo &quot;vm.overcommit_memory=1&quot; &amp;gt; /etc/sysctl.conf&lt;/p&gt;
&lt;p&gt;  echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled。&lt;/p&gt;
&lt;p&gt;永久解决方法：&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
vim /etc/sysctl.conf&lt;br/&gt;net.core.somaxconn = 512&lt;br/&gt;vm.overcommit_memory = 1&lt;p&gt;kernel.mm.transparent_hugepage.enabled = never
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Redis server使用默认端口6379启动成功。&lt;/p&gt;
&lt;p&gt;#step4 修改配置文件，使其以后台服务方式运行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
#what?局域网内本机IP。
#我是部署到同一机器上所以IP都一样，端口不同
bind 127.0.0.1
#修改默认端口，避免被恶意脚本扫描。
port 9999
loglevel debug
logfile /usr/local/redis/logs/redis.log.9999
#为服务设置安全密码
requirepass redispass&lt;br/&gt;#以守护进程方式运行
daemonize yes
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;#step5 重新启动redis。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@ bin]# redis-cli -p 9999 -&lt;span&gt;a redispass shutdown
我使用脚本启动方式
  启动脚本 redis_init_script 位于位于Redis的 &lt;/span&gt;/utils/&lt;span&gt; 目录下，redis_init_script脚本代码如下：&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;sh&lt;/span&gt;&lt;span&gt;
#
# Simple Redis init.d script conceived to work on Linux systems
# as it does use of the &lt;/span&gt;/&lt;span&gt;proc filesystem.
 
#redis服务器监听的端口
REDISPORT&lt;/span&gt;=&lt;span&gt;9999&lt;/span&gt;&lt;span&gt;
 
#服务端所处位置
EXEC&lt;/span&gt;=/usr/local/bin/redis-&lt;span&gt;server
 
#客户端位置
CLIEXEC&lt;/span&gt;=/usr/local/bin/redis-&lt;span&gt;cli
 
#redis的PID文件位置，需要修改
PIDFILE&lt;/span&gt;=/var/run/&lt;span&gt;redis_${REDISPORT}.pid
 
#redis的配置文件位置，需将${REDISPORT}修改为文件名
CONF&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/etc/redis/${REDISPORT}.conf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
 
&lt;span&gt;case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt;
    start)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ -&lt;span&gt;f $PIDFILE ]
        &lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
                &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$PIDFILE exists, process is already running or crashed&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Starting Redis server...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                $EXEC $CONF
        &lt;/span&gt;&lt;span&gt;fi&lt;/span&gt;&lt;span&gt;
        ;;
    stop)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ ! -&lt;span&gt;f $PIDFILE ]
        &lt;/span&gt;&lt;span&gt;then&lt;/span&gt;
                &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$PIDFILE does not exist, process is not running&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                PID&lt;/span&gt;=$(&lt;span&gt;cat&lt;/span&gt;&lt;span&gt; $PIDFILE)
                &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Stopping ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                $CLIEXEC &lt;/span&gt;-&lt;span&gt;p $REDISPORT shutdown
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; [ -x /proc/&lt;span&gt;${PID} ]
                &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;
                    &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Waiting for Redis to shutdown ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
                    &lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
                &lt;span&gt;done&lt;/span&gt;
                &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis stopped&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;fi&lt;/span&gt;&lt;span&gt;
        ;;
    &lt;/span&gt;*&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Please use start or stop as first argument&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        ;;
&lt;/span&gt;&lt;span&gt;esac&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以根据你自己端口进行修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mkdir /etc/&lt;span&gt;redis
cp redis.conf &lt;/span&gt;/etc/redis/9999&lt;span&gt;.conf
将启动脚本复制到&lt;/span&gt;/etc/&lt;span&gt;init.d目录下，本例将启动脚本命名为redisd（通常都以d结尾表示是后台自启动服务）。&lt;/span&gt;&lt;span&gt;
cp redis_init_script &lt;/span&gt;/etc/init.d/redis_9999
&lt;/pre&gt;
&lt;pre&gt;
./redis_9999 start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2开启主从复制（master-slave）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;主从模式的两个重要目的，提升系统可靠性和读写分离提升性能。&lt;/p&gt;
&lt;p&gt;这里通过修改端口的方式，再启动端口为9997和9998的服务作为备（从）机。&lt;/p&gt;
&lt;p&gt;备机启动需要修改配置文件部分属性（在9999配置的基础上）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
port 9997
logfile /usr/local/redis/logs/redis.log.9997
#指定master ip port
slaveof 127.0.0.1 9999
#认证master时需要的密码。必须和master配置的requirepass 保持一致
masterauth redispass&lt;br/&gt;requirepass redispass
protected-mode no
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从机9998配置同理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
port 9998
logfile /usr/local/redis/logs/redis.log.9998
slaveof 127.0.0.1 9999
masterauth redispass&lt;br/&gt;requirepass redispass
protected-mode no
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;开启从机服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@ bin]# ./redis_9997 start
[root@ bin]# ./redis_9998 start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看slave 9998日志（省略部分信息），可以看出，slave在启动时成功连接master，并接收到了104字节的同步数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;6472&lt;/span&gt;:S &lt;span&gt;30&lt;/span&gt; Mar &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;17.206&lt;/span&gt; * Connecting to MASTER &lt;span&gt;127.0.0.1&lt;/span&gt;:&lt;span&gt;9999&lt;/span&gt;
&lt;span&gt;6472&lt;/span&gt;:S &lt;span&gt;30&lt;/span&gt; Mar &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;17.206&lt;/span&gt; * MASTER &amp;lt;-&amp;gt; SLAVE &lt;span&gt;sync&lt;/span&gt;&lt;span&gt; started
&lt;/span&gt;&lt;span&gt;6472&lt;/span&gt;:S &lt;span&gt;30&lt;/span&gt; Mar &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;17.223&lt;/span&gt; * MASTER &amp;lt;-&amp;gt; SLAVE &lt;span&gt;sync&lt;/span&gt;: receiving &lt;span&gt;104&lt;/span&gt;&lt;span&gt; bytes from master
&lt;/span&gt;&lt;span&gt;6472&lt;/span&gt;:S &lt;span&gt;30&lt;/span&gt; Mar &lt;span&gt;11&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;:&lt;span&gt;17.223&lt;/span&gt; * MASTER &amp;lt;-&amp;gt; SLAVE &lt;span&gt;sync&lt;/span&gt;: Finished with success
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;redis做一个基准的压测&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;你如果要对自己刚刚搭建好的redis做一个基准的压测，测一下你的redis的性能和QPS（query per second）&lt;/p&gt;
&lt;p&gt;redis自己提供的redis-benchmark压测工具，是最快捷最方便的，当然啦，这个工具比较简单，用一些简单的操作和场景去压测&lt;/p&gt;
&lt;p&gt;1、对redis读写分离架构进行压测，单实例写QPS+单实例读QPS&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
redis-&lt;span&gt;3.2&lt;/span&gt;.&lt;span&gt;8&lt;/span&gt;/&lt;span&gt;src

.&lt;/span&gt;/redis-benchmark -h &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;

-c &amp;lt;clients&amp;gt; Number of parallel connections (default &lt;span&gt;50&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;-n &amp;lt;requests&amp;gt; Total number of requests (default &lt;span&gt;100000&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;-d &amp;lt;size&amp;gt; Data size of SET/GET value &lt;span&gt;in&lt;/span&gt; bytes (default &lt;span&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据你自己的高峰期的访问量，在高峰期，瞬时最大用户量会达到10万+，-c 100000，-n 10000000，-d 500&lt;/p&gt;
&lt;p&gt;1、QPS，自己不同公司，不同服务器，自己去测试，跟生产环境还有区别&lt;/p&gt;
&lt;p&gt;生产环境，大量的网络请求的调用，网络本身就有开销，你的redis的吞吐量就不一定那么高了&lt;/p&gt;
&lt;p&gt;QPS的两个杀手：一个是复杂操作，lrange，挺多的; value很大，2 byte，我之前用redis做大规模的缓存&lt;/p&gt;
&lt;p&gt;做商品详情页的cache，可能是需要把大串数据，拼接在一起，作为一个json串，大小可能都几k，几个byte&lt;/p&gt;
&lt;p&gt;2、水平扩容redis读节点，提升度吞吐量&lt;/p&gt;
&lt;p&gt;就按照上一节课讲解的，再在其他服务器上搭建redis从节点，单个从节点读请QPS在5万左右，两个redis从节点，所有的读请求打到两台机器上去，承载整个集群读QPS在10万+&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3 sentinel模式故障自动迁移&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Master-slave主从复制避免了数据丢失带来的灾难性后果。&lt;/p&gt;
&lt;p&gt;但是单点故障仍然存在，在运行期间master宕机需要停机手动切换。&lt;/p&gt;
&lt;p&gt;Sentinel很好的解决了这个问题，当Master-slave模式中的Master宕机后，能够自主切换，选择另一个可靠的redis-server充当master角色，使系统仍正常运行。&lt;/p&gt;
&lt;p&gt;一般来说sentinel server需要大于等于3个。&lt;/p&gt;
&lt;p&gt;这里通过修改端口的方式开启3个sentinel server。修改配置文件sentinel.conf部分属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
#服务运行端口号
port 26379&lt;br/&gt;sentinel monitor mumaster 1270.0.0.1 9999 2
#mymaster为指定的master服务器起一个别名
#master IP和端口号
#2的含义：当开启的sentinel server认为当前master主观下线的（+sdown）数量达到2时，则sentinel server认为当前master客观下线（+odown）系统开始自动迁移。2的计算（建议）：&lt;br/&gt;#sentinel server数量的大多数，至少为count（sentinel server）/2 向上取整。2&amp;gt;3/2（主观下线与客观下线？）
#master别名和认证密码。这就提醒了用户，在master-slave系统中，各服务的认证密码应该保持一致。
sentinel auth-pass mymaster redispass
#以守护进程方式运行
daemonize yes
logfile /usr/local/redis/logs/sentinel.log.26379
protected-mode no
sentinel down-after-milliseconds mymaster 6000
sentinel failover-timeout mymaster 18000
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（多开服务只需要在以上配置基础上修改端口号，其它保持不变 port 26378/port 26377）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开启Sentinel服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
redis-sentinel /etc/sentinel/26377.conf
redis-sentinel /etc/sentinel/26378.conf
redis-sentinel /etc/sentinel/26379.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动之后可以看到日志信息，每个哨兵都能去监控到对应的redis master，并能够自动发现对应的slave，哨兵之间，互相会自动进行发现，用的就是之前说的pub/sub，消息发布和订阅channel消息系统和机制&lt;/p&gt;
&lt;p&gt;检查哨兵状态&lt;br/&gt;redis-cli -h 127.0.0.1 -p 26377 -a &quot;redispass&quot;&lt;/p&gt;
&lt;p&gt;sentinel master mymaster&lt;br/&gt;SENTINEL slaves mymaster&lt;br/&gt;SENTINEL sentinels mymaster&lt;/p&gt;
&lt;p&gt;SENTINEL get-master-addr-by-name mymaster&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
哨兵节点相关配置
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1、哨兵节点的增加和删除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;增加sentinal，会自动发现&lt;/p&gt;
&lt;p&gt;删除sentinal的步骤&lt;/p&gt;
&lt;p&gt;（1）停止sentinal进程&lt;br/&gt;（2）SENTINEL RESET *，在所有sentinal上执行，清理所有的master状态&lt;br/&gt;（3）SENTINEL MASTER mastername，在所有sentinal上执行，查看所有sentinal对数量是否达成了一致&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、slave的永久下线&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让master摘除某个已经下线的slave：SENTINEL RESET mastername，在所有的哨兵上面执行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、slave切换为Master的优先级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;slave-&amp;gt;master选举优先级：slave-priority，值越小优先级越高&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、基于哨兵集群架构下的安全认证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个slave都有可能切换成master，所以每个实例都要配置两个指令&lt;/p&gt;
&lt;p&gt;master上启用安全认证，requirepass&lt;br/&gt;master连接口令，masterauth&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sentinal，sentinel auth-pass &amp;lt;master-group-name&amp;gt; &amp;lt;pass&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5、容灾演练&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过哨兵看一下当前的master：SENTINEL get-master-addr-by-name mymaster&lt;/p&gt;
&lt;p&gt;把master节点kill -9掉，pid文件也删除掉&lt;/p&gt;
&lt;p&gt;查看sentinal的日志，是否出现+sdown字样，识别出了master的宕机问题; 然后出现+odown字样，就是指定的quorum哨兵数量，都认为master宕机了&lt;/p&gt;
&lt;p&gt;（1）三个哨兵进程都认为master是sdown了&lt;br/&gt;（2）超过quorum指定的哨兵进程都认为sdown之后，就变为odown&lt;br/&gt;（3）哨兵1是被选举为要执行后续的主备切换的那个哨兵&lt;br/&gt;（4）哨兵1去新的master（slave）获取了一个新的config version&lt;br/&gt;（5）尝试执行failover&lt;br/&gt;（6）投票选举出一个slave区切换成master，每隔哨兵都会执行一次投票&lt;br/&gt;（7）让salve，slaveof noone，不让它去做任何节点的slave了; 把slave提拔成master; 旧的master认为不再是master了&lt;br/&gt;（8）哨兵就自动认为之前的master变成slave，将投票出的slave变成master &lt;br/&gt;（9）哨兵去探查了一下之前的master(变成来salve)的状态，认为它sdown了 &lt;/p&gt;

&lt;p&gt;故障恢复，再将旧的master重新启动，查看是否被哨兵自动切换成slave节点&lt;/p&gt;
&lt;p&gt;查看到结果将9999 切换为slave节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;容灾演练日志
Sentinel ID is ea82430cf7f6d452eb22bbf29b92fcf001c734c8
&lt;/span&gt;3010:X 21 Nov 22:37:31.405 # +monitor master mymaster 127.0.0.1 9999 quorum 2
3010:X 21 Nov 23:01:12.589 # +sdown master mymaster 127.0.0.1 9999
3010:X 21 Nov 23:01:12.642 # +odown master mymaster 127.0.0.1 9999 #quorum 3/2           &lt;span&gt;-&lt;/span&gt;&lt;span&gt;- 进入ODOWN状态时。有三个哨兵认为master当机了&lt;/span&gt;
3010:X 21 Nov 23:01:12.642 # +&lt;span&gt;new&lt;/span&gt;-epoch 7                                                &lt;span&gt;-- 当前配置版本被更新时。
&lt;/span&gt;3010:X 21 Nov 23:01:12.642 # +&lt;span&gt;try&lt;/span&gt;-failover master mymaster 127.0.0.1 9999                &lt;span&gt;-- 尝试故障转移，正等待其他sentinel的选举。
&lt;/span&gt;3010:X 21 Nov 23:01:12.658 # +vote-&lt;span&gt;for&lt;/span&gt;-leader ea82430cf7f6d452eb22bbf29b92fcf001c734c8 7 &lt;span&gt;-- 投票给领导
&lt;/span&gt;3010:X 21 Nov 23:01:12.668 # edace82644513417b676ee6eced3184771d6361d voted &lt;span&gt;for&lt;/span&gt; ea82430cf7f6d452eb22bbf29b92fcf001c734c8 7
3010:X 21 Nov 23:01:12.668 # 7e68a54266703cbf429f5c6512a50a39ab94b943 voted &lt;span&gt;for&lt;/span&gt; ea82430cf7f6d452eb22bbf29b92fcf001c734c8 7
3010:X 21 Nov 23:01:12.716 # +elected-leader master mymaster 127.0.0.1 9999              &lt;span&gt;-- 被选举为去执行failover的时候。
&lt;/span&gt;3010:X 21 Nov 23:01:12.716 # +failover-state-select-slave master mymaster 127.0.0.1 9999 &lt;span&gt;-- 开始要选择一个slave当选新master时。
&lt;/span&gt;3010:X 21 Nov 23:01:12.792 # +selected-slave slave 127.0.0.1:9998 127.0.0.1 9998 @ mymaster 127.0.0.1 9999 &lt;span&gt;-- 找到了port:9998一个适合的slave来担当新master
                              -- 当把选择为新master的slave的身份进行切换的时候。
&lt;/span&gt;3010:X 21 Nov 23:01:12.792 * +failover-state-send-slaveof-noone slave 127.0.0.1:9998 127.0.0.1 9998 @ mymaster 127.0.0.1 9999 
                              &lt;span&gt;-- 等待提升 9998 为新的master
&lt;/span&gt;3010:X 21 Nov 23:01:12.851 * +failover-state-wait-promotion slave 127.0.0.1:9998 127.0.0.1 9998 @ mymaster 127.0.0.1 9999
3010:X 21 Nov 23:01:13.699 # +promoted-slave slave 127.0.0.1:9998 127.0.0.1 9998 @ mymaster 127.0.0.1 9999        &lt;span&gt;-- 提升 9998 master
&lt;/span&gt;3010:X 21 Nov 23:01:13.699 # +failover-state-reconf-slaves master mymaster 127.0.0.1 9999                         &lt;span&gt;-- Failover状态变为reconf-slaves状态时
&lt;/span&gt;3010:X 21 Nov 23:01:13.749 * +slave-reconf-sent slave 127.0.0.1:9997 127.0.0.1 9997 @ mymaster 127.0.0.1 9999     &lt;span&gt;-- 重新配置 9997为slave
&lt;/span&gt;3010:X 21 Nov 23:01:14.770 # -odown master mymaster 127.0.0.1 9999                                                &lt;span&gt;-- 离开ODOWN状态时。
                             -- inprog 9997 slave被重新配置为9998的master的slave，但数据复制还未发生时。
&lt;/span&gt;3010:X 21 Nov 23:01:14.770 * +slave-reconf-inprog slave 127.0.0.1:9997 127.0.0.1 9997 @ mymaster 127.0.0.1 9999 
                             &lt;span&gt;-- done   9997 slave被重新配置为9998的master的slave,并且数据复制已经与master同步时。
&lt;/span&gt;3010:X 21 Nov 23:01:14.770 * +slave-reconf-done slave 127.0.0.1:9997 127.0.0.1 9997 @ mymaster 127.0.0.1 9999
3010:X 21 Nov 23:01:14.841 # +failover-end master mymaster 127.0.0.1 9999                                        &lt;span&gt;-- 故障转移结束
&lt;/span&gt;3010:X 21 Nov 23:01:14.841 # +&lt;span&gt;switch&lt;/span&gt;-master mymaster 127.0.0.1 9999 127.0.0.1 9998                               &lt;span&gt;-- master由9999 替换为 9998&lt;/span&gt;
3010:X 21 Nov 23:01:14.841 * +slave slave 127.0.0.1:9997 127.0.0.1 9997 @ mymaster 127.0.0.1 9998                &lt;span&gt;-- 检测到9997slave并添加进slave列表时
&lt;/span&gt;3010:X 21 Nov 23:01:14.842 * +slave slave 127.0.0.1:9999 127.0.0.1 9999 @ mymaster 127.0.0.1 9998                &lt;span&gt;-- 检测到9999slave
&lt;/span&gt;3010:X 21 Nov 23:01:44.849 # +sdown slave 127.0.0.1:9999 127.0.0.1 9999 @ mymaster 127.0.0.1 9998                &lt;span&gt;-- 进入SDOWN状态时;
&lt;/span&gt;3010:X 21 Nov 23:04:19.457 # -sdown slave 127.0.0.1:9999 127.0.0.1 9999 @ mymaster 127.0.0.1 9998                &lt;span&gt;-- 离开SDOWN状态时&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 29 Nov 2018 07:20:00 +0000</pubDate>
<dc:creator>lol霖</dc:creator>
<og:description>对于sentinel哨兵节点的一些核心概念： 1、sdown和odown转换机制 sdown和odown两种失败状态 sdown是主观宕机，就一个哨兵如果自己觉得一个master宕机了，那么就是主观宕</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lihonglin2016/p/10037808.html</dc:identifier>
</item>
<item>
<title>【OC底层】AssociatedObject 关联对象 - 这酸爽！</title>
<link>http://www.cnblogs.com/xgao/p/10038495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xgao/p/10038495.html</guid>
<description>&lt;h2&gt;如何实现给分类“添加成员变量”？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;默认情况下，因为分类底层结构的限制，不能添加成员变量到分类中。但可以通过关联对象来间接实现&lt;/li&gt;
&lt;li&gt;关联对象提供了以下API&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　1&amp;gt; 添加关联对象&lt;/p&gt;
&lt;p&gt;　　void objc_setAssociatedObject(id object, const void * key,&lt;br/&gt;　　id value, objc_AssociationPolicy policy)&lt;/p&gt;
&lt;p&gt;　　2&amp;gt; 获得关联对象&lt;/p&gt;
&lt;p&gt;　　id objc_getAssociatedObject(id object, const void * key)&lt;/p&gt;
&lt;p&gt;　　3&amp;gt; 移除所有的关联对象&lt;/p&gt;
&lt;p&gt;　　void objc_removeAssociatedObjects(id object)&lt;/p&gt;

&lt;h2&gt;key的常见用法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/319764/201811/319764-20181129150610427-1393201989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;objc_AssociationPolicy修饰符&lt;/h2&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/319764/201811/319764-20181129150651032-88429199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;给分类添加属性实例&lt;/h2&gt;
&lt;p&gt;假如已经有一个 XGPerson的类，现在我们需要扩展这个类，并且添加一个 age 属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;XGPerson.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分类属性是不会生成 get\set 方法的，如果不重写这两个方法，就无法正常使用属性&lt;/span&gt;
&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; XGPerson (Test)

@property (nonatomic,assign) &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;XGPerson+Test.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#import&lt;/span&gt; &amp;lt;objc/runtime.h&amp;gt;

&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; XGPerson (Test)


&lt;/span&gt;- (&lt;span&gt;void&lt;/span&gt;)setAge:(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)age{
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; @selector(age) 这个参数只要传一个地址指针就可以&lt;/span&gt;
&lt;span&gt;    objc_setAssociatedObject(self, @selector(age), @(age), OBJC_ASSOCIATION_ASSIGN);
}

&lt;/span&gt;- (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)age{
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 隐式参数
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; _cmd = @selectior(age)&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; [objc_getAssociatedObject(self, _cmd) intValue];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        XGPerson* p1 =&lt;span&gt; [[XGPerson alloc]init];
        p1.name &lt;/span&gt;= &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;p1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        p1.age &lt;/span&gt;= &lt;span&gt;18&lt;/span&gt;&lt;span&gt;;
        
        XGPerson&lt;/span&gt;* p2 =&lt;span&gt; [[XGPerson alloc]init];
        p2.name &lt;/span&gt;= &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;p2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        p2.age &lt;/span&gt;= &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
        
        NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;p1Name:%@  p1Age:%i----p2Name:%@  p2Age:%i&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,p1.name,p1.age,p2.name,p2.age);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;11&lt;/span&gt;-&lt;span&gt;29&lt;/span&gt; &lt;span&gt;14&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;38.666084&lt;/span&gt;+&lt;span&gt;0800&lt;/span&gt; 关联对象(增加分类属性)[&lt;span&gt;1923&lt;/span&gt;:&lt;span&gt;87124&lt;/span&gt;] p1Name:p1  p1Age:&lt;span&gt;18&lt;/span&gt;----p2Name:p2  p2Age:&lt;span&gt;20&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;关联对象的原理&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;实现关联对象技术的核心对象有&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;AssociationsManager&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　AssociationsHashMap&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　ObjectAssociationMap&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　ObjcAssociation&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; objc4源码解读：objc-references.mm&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/319764/201811/319764-20181129151227563-546752244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关联对象存储结构图&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/319764/201811/319764-20181129151354163-1660090179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;关联对象并不是存储在被关联对象本身内存中&lt;/li&gt;
&lt;li&gt;关联对象存储在全局的统一的一个AssociationsManager中&lt;/li&gt;
&lt;li&gt;设置关联对象为nil，就相当于是移除关联对象&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Thu, 29 Nov 2018 07:15:00 +0000</pubDate>
<dc:creator>这酸爽！</dc:creator>
<og:description>如何实现给分类“添加成员变量”？ 默认情况下，因为分类底层结构的限制，不能添加成员变量到分类中。但可以通过关联对象来间接实现 关联对象提供了以下API 1&gt; 添加关联对象 void objc_s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xgao/p/10038495.html</dc:identifier>
</item>
<item>
<title>接口文档管理神器RAP2安装和部署 - 自由早晚乱余生</title>
<link>http://www.cnblogs.com/operationhome/p/10038469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/operationhome/p/10038469.html</guid>
<description>&lt;h2 id=&quot;一-rap2&quot;&gt;一 RAP2&lt;/h2&gt;
&lt;p&gt;RAP2是在RAP1基础上重做的新项目，它包含两个组件(对应两个Github Repository)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;rap2-delos: 后端数据API服务器，基于Koa + MySQLlink&lt;/li&gt;
&lt;li&gt;rap2-dolores: 前端静态资源，基于React link&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;什么是RAP？&lt;/p&gt;
&lt;p&gt;rap是一款API 文档管理工具，在 RAP 中，可以定义接口的 URL、请求 &amp;amp; 响应细节格式等等。同时 RAP 还提供 MOCK 服务、测试服务等自动化工等工具，帮助开发团队高效开发。&lt;/p&gt;
&lt;p&gt;git 地址：&lt;/p&gt;
&lt;p&gt;https://github.com/thx/rap2-dolores&lt;/p&gt;
&lt;p&gt;https://github.com/thx/rap2-delos&lt;/p&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;强大的 GUI 界面工具 ，完全可视化可编辑的管理工具。&lt;/li&gt;
&lt;li&gt;完善的 MOCK 服务，文档定义好后接口就已准备就绪，可方便的 mock 调用接口&lt;/li&gt;
&lt;li&gt;庞大的用户群 ，RAP 在阿里巴巴广泛使用，也有许多著名的公司在用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;界面截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/tomcat%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/rap0.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二-rap2-安装需要的环境&quot;&gt;二 RAP2 安装需要的环境&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Node.js 8.9.4+&lt;/li&gt;
&lt;li&gt;MySQL 5.7+&lt;/li&gt;
&lt;li&gt;Redis 4.0+&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下的安装步骤都是基于Centos 7 进行安装&lt;/p&gt;
&lt;h3 id=&quot;node.js-安装&quot;&gt;2. 1 Node.js 安装：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;#centos：
curl -sL https://rpm.nodesource.com/setup_8.x | bash -
yum  install  -y nodejs
# Using Ubuntu
curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -
sudo apt-get install -y nodejs

# Using Debian, as root
curl -sL https://deb.nodesource.com/setup_8.x | bash -
apt-get install -y nodejs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;yum 安装会比较慢，因为服务器是在国外。&lt;/p&gt;
&lt;p&gt;如果上面的安装不成功的，我们可以使用二进制包安装。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget  https://nodejs.org/dist/latest-v8.x/node-v8.14.0-linux-x86.tar.gz
tar -zxvf node-v8.14.0-linux-x64.tar.gz
mv   node-v8.14.0-linux-x64  /opt/node
ln -s /opt/node/bin/node  /usr/bin/node
ln -s /opt/node/bin/npm  /usr/bin/npm&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置淘宝镜像源&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
# 要是国内的服务器，需要配置 npm 国内镜像
# 编辑 ~/.npmrc 加入下面内容(当前用户目录下）
registry = https://registry.npm.taobao.org&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装 pm2&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm  install -g pm2&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mysql-5.7-安装&quot;&gt;2. 2 Mysql 5.7+ 安装&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;rpm包安装：

在centos7上要先移除mariadb
yum -y remove mariadb*

wget  https://dev.mysql.com/get/Downloads/MySQL-5.7/mysql-5.7.24-1.el7.x86_64.rpm-bundle.tar

tar  -xvf  mysql-5.7.24-1.el7.x86_64.rpm-bundle.tar
安装依赖：
yum install libaio.so.1*
yum install perl
安装mysql
rpm -ivh mysql-community-common-5.7.24-1.el7.x86_64.rpm
rpm -ivh mysql-community-libs-5.7.24-1.el7.x86_64.rpm
rpm -ivh mysql-community-client-5.7.24-1.el7.x86_64.rpm
rpm -ivh mysql-community-server-5.7.24-1.el7.x86_64.rpm

启动：
systemctl  start  mysqld

获取密码：
cat  /var/log/mysqld.log  |grep  'generated'
登录之后会要求我们更改密码：
alter user 'root'@'localhost' identified by '123456';
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;redis-安装见文章&quot;&gt;2 .3 Redis &lt;a href=&quot;https://www.cnblogs.com/operationhome/p/9752935.html&quot;&gt;安装见文章&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;redis 建议不配置密码，并绑定127.0.0.1 ，只能本地访问&lt;br/&gt;安装好之后，并以后台任务运行。&lt;/p&gt;
&lt;h3 id=&quot;后端-rap2-delos-安装&quot;&gt;2. 4 后端 rap2-delos 安装&lt;/h3&gt;
&lt;p&gt;安装git&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum  install  -y git  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建数据库 RAP2_DELOS_APP&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;登陆数据库创建 RAP2_DELOS_APP

CREATE DATABASE IF NOT EXISTS RAP2_DELOS_APP DEFAULT CHARSET utf8 COLLATE utf8_general_ci;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;rap2-delos 安装&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 下载源代码
git clone https://github.com/thx/rap2-delos.git
# 切换目录
cd  rap2-delos
# 安装依赖包
npm install
# 安装 TypeScript 编译包
npm install typescript -g
# 编辑测试配置文件（注意这里只是为了测试）
注意这个文件路径   rap2-delos/src/config/config.dev.js

修改的内容（大约在11行左右开始）：
将数据库配置成我们的数据库名称和路径和用户和密码
dialect: 'mysql',
host: 'localhost',
port: 3306,
username: 'root',
password: '123456',
database: 'RAP2_DELOS_APP',

# 构建
注意：在 rap2-delos  主目录下操作
npm run build

# 初始化数据库（一定要在根目录执行哦（rap2-delos/））
npm run create-db

创建成功了会有提示 “Run create-db finished successfully.”
# 执行mocha测试用例和js代码规范检查
npm run check

# 启动开发模式的服务器 监视并在发生代码变更时自动重启
npm run dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正常启动：&lt;br/&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/tomcat%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/rap3.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果出现下面的错误就是端口被占用了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/tomcat%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/rap2.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 编辑正式配置文件（配置正式数据库）
rap2-delos/dist/config/config.prod.js  (注意这次修改的配置文件的目录和上面那次目录不一样的。)
修改的内容（大约在12行左右开始）：
将数据库配置成我们的数据库名称和路径和用户和密码
dialect: 'mysql',
host: process.env.MYSQL_URL || 'localhost',
port: (process.env.MYSQL_PORT &amp;amp;&amp;amp; parseInt(process.env.MYSQL_PORT)) || 3306,
username: process.env.MYSQL_USERNAME || 'root',
password: process.env.MYSQL_PASSWD || '123456',
database: process.env.MYSQL_SCHEMA || 'RAP2_DELOS_APP',



#  启动正式（生产）模式
npm start 

#  查看服务状态和日志
pm2  list 
pm2  logs  rap-server-delos &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试是否正常：&lt;br/&gt;ip:8080&lt;br/&gt;显示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;RAP2后端服务已启动，请从前端服务(rap2-dolores)访问。 RAP2 back-end server is started, please visit via front-end service (rap2-dolores)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示正常&lt;/p&gt;
&lt;h3 id=&quot;前端-rap2-delos-安装&quot;&gt;2. 5 前端 rap2-delos 安装&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# 拉取代码
git clone https://github.com/thx/rap2-dolores.git
# 切换目录
cd  rap2-dolores
# 初始化
npm install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面这步可以不做，直接配置正式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 开发模式配置**(开发配置可以不做)
    配置文件路径：/src/config/config.dev.js
    module.exports = {
      serve: 'http://127.0.0.1:8080',
      keys: ['some secret hurr'],
      session: {
        key: 'koa:sess'
      }
    }
    更改serve  字段
    改成我们的后端访问地址。 注意加 http://
    
    # test cases 测试用例
    npm run test
    
    # will watch &amp;amp; serve automatically 会自动监视改变后重新编译
    npm run dev&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正式配置，必须配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 正式配置
配置文件路径：/src/config/config.prod.js
module.exports = {
  serve: 'http://127.0.0.1:8080',
  keys: ['some secret hurr'],
  session: {
    key: 'koa:sess'
  }
}
更改serve  字段
改成我们的后端访问地址，访问地址直接使用ip，不要使用127.0.0.1。 注意加 http://,

#  编译React生产包
npm run build

#  安装serve
npm install -g serve

# 运行 
serve -s ./build -p 80
-p 为指定端口
# 后台运行
nohup  serve -s ./build -p 80  &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问 ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/tomcat%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/rap2%E5%AE%89%E8%A3%85.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;出现这个即意味着安装成功。&lt;/p&gt;
&lt;h3 id=&quot;三-注意事项&quot;&gt;三 注意事项：&lt;/h3&gt;
&lt;h4 id=&quot;错误一&quot;&gt;错误一&lt;/h4&gt;
&lt;p&gt;在安装依赖的时候&lt;br/&gt;因为我是二进制安装的node，所以有权限问题，最好是yum安装nodejs 这样权限问题就不存在了。&lt;br/&gt;或者我们给我们的目录可写的权限&lt;/p&gt;
&lt;p&gt;错误截图：&lt;br/&gt;&lt;img src=&quot;https://djxblog.oss-cn-shenzhen.aliyuncs.com/picture/tomcat%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/rap4.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;错误二&quot;&gt;错误二&lt;/h4&gt;
&lt;p&gt;yum 安装nodejs ，会总报网络错误，我们可以多次运行 yum install -y nodejs&lt;/p&gt;
&lt;h4 id=&quot;错误三&quot;&gt;错误三&lt;/h4&gt;
&lt;p&gt;如果我们打开界面是一直在加载的话，那么就是我们在配置的时候使用的是127.0.0.1:8080，我们需要使用的是对应的内网ip。例如：192.168.1.190&lt;/p&gt;
</description>
<pubDate>Thu, 29 Nov 2018 07:14:00 +0000</pubDate>
<dc:creator>自由早晚乱余生</dc:creator>
<og:description>一 RAP2 RAP2是在RAP1基础上重做的新项目，它包含两个组件(对应两个Github Repository)。 rap2 delos: 后端数据API服务器，基于Koa + MySQLlink</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/operationhome/p/10038469.html</dc:identifier>
</item>
<item>
<title>iOS多线程GCD的使用 - 鸿鹄当高远</title>
<link>http://www.cnblogs.com/jukaiit/p/10038213.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jukaiit/p/10038213.html</guid>
<description>&lt;div readability=&quot;288.5&quot;&gt;

&lt;p&gt;学习 GCD 之前，先来了解 GCD 中两个核心概念：&lt;strong&gt;任务&lt;/strong&gt;和&lt;strong&gt;队列&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;任务&lt;/strong&gt;：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在 GCD 中是放在 block 中的。执行任务有两种方式：&lt;strong&gt;同步执行（sync）&lt;/strong&gt;和&lt;strong&gt;异步执行（async）&lt;/strong&gt;。两者的主要区别是：&lt;strong&gt;是否等待队列的任务执行结束，以及是否具备开启新线程的能力。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;同步执行（sync）&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。&lt;/li&gt;
&lt;li&gt;只能在当前线程中执行任务，不具备开启新线程的能力。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步执行（async）&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。&lt;/li&gt;
&lt;li&gt;可以在新的线程中执行任务，具备开启新线程的能力。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个简单例子：你要打电话给小明和小白。&lt;br/&gt;同步执行就是，你打电话给小明的时候，不能同时打给小白，等到给小明打完了，才能打给小白（等待任务执行结束）。而且只能用当前的电话（不具备开启新线程的能力）。&lt;br/&gt;而异步执行就是，你打电话给小明的时候，不等和小明通话结束，还能直接给小白打电话，不用等着和小明通话结束再打（不用等待任务执行结束）。除了当前电话，你还可以使用其他所能使用的电话（具备开启新线程的能力）。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：&lt;strong&gt;异步执行（async）&lt;/strong&gt;虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关（下面会讲）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;队列（Dispatch Queue）&lt;/strong&gt;：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图：&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1478&quot; data-height=&quot;518&quot;&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1877784-01267bd211719167.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1877784-01267bd211719167.png&quot; data-original-width=&quot;1478&quot; data-original-height=&quot;518&quot; data-original-format=&quot;&quot; data-original-filesize=&quot;55025&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;队列(Dispatch Queue).png&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;在 GCD 中有两种队列：&lt;strong&gt;串行队列&lt;/strong&gt;和&lt;strong&gt;并发队列&lt;/strong&gt;。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：&lt;strong&gt;执行顺序不同，以及开启线程数不同。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;串行队列（Serial Dispatch Queue）&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;每次只有一个任务被执行。让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发队列（Concurrent Dispatch Queue）&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;可以让多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：&lt;strong&gt;并发队列&lt;/strong&gt;的并发功能只有在异步（dispatch_async）函数下才有效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两者具体区别如下两图所示。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1478&quot; data-height=&quot;600&quot;&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1877784-4faca27116209f35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1877784-4faca27116209f35.png&quot; data-original-width=&quot;1478&quot; data-original-height=&quot;600&quot; data-original-format=&quot;&quot; data-original-filesize=&quot;45921&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;串行队列.png&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1482&quot; data-height=&quot;738&quot;&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1877784-97f3931d1b187b11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1877784-97f3931d1b187b11.png&quot; data-original-width=&quot;1482&quot; data-original-height=&quot;738&quot; data-original-format=&quot;&quot; data-original-filesize=&quot;60231&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;并发队列.png&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;GCD 的使用步骤其实很简单，只有两步。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个队列（串行队列或并发队列）&lt;/li&gt;
&lt;li&gt;将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下边来看看队列的创建方法/获取方法，以及任务的创建方法。&lt;/p&gt;
&lt;h2&gt;3.1 队列的创建方法/获取方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;可以使用&lt;code&gt;dispatch_queue_create&lt;/code&gt;来创建队列，需要传入两个参数，第一个参数表示队列的唯一标识符，用于 DEBUG，可为空，Dispatch Queue 的名称推荐使用应用程序 ID 这种逆序全程域名；第二个参数用来识别是串行队列还是并发队列。&lt;code&gt;DISPATCH_QUEUE_SERIAL&lt;/code&gt;表示串行队列，&lt;code&gt;DISPATCH_QUEUE_CONCURRENT&lt;/code&gt;表示并发队列。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;/&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;对于串行队列，GCD 提供了的一种特殊的串行队列：&lt;strong&gt;主队列（Main Dispatch Queue）&lt;/strong&gt;。
&lt;ul&gt;&lt;li&gt;所有放在主队列中的任务，都会放到主线程中执行。&lt;/li&gt;
&lt;li&gt;可使用&lt;code&gt;dispatch_get_main_queue()&lt;/code&gt;获得主队列。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;/&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;对于并发队列，GCD 默认提供了&lt;strong&gt;全局并发队列（Global Dispatch Queue）&lt;/strong&gt;。
&lt;ul&gt;&lt;li&gt;可以使用&lt;code&gt;dispatch_get_global_queue&lt;/code&gt;来获取。需要传入两个参数。第一个参数表示队列优先级，一般用&lt;code&gt;DISPATCH_QUEUE_PRIORITY_DEFAULT&lt;/code&gt;。第二个参数暂时没用，用&lt;code&gt;0&lt;/code&gt;即可。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;/&gt;
&lt;/pre&gt;
&lt;h2&gt;3.2 任务的创建方法&lt;/h2&gt;
&lt;p&gt;GCD 提供了同步执行任务的创建方法&lt;code&gt;dispatch_sync&lt;/code&gt;和异步执行任务创建方法&lt;code&gt;dispatch_async&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;虽然使用 GCD 只需两步，但是既然我们有两种队列（串行队列/并发队列），两种任务执行方式（同步执行/异步执行），那么我们就有了四种不同的组合方式。这四种不同的组合方式是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;同步执行 + 并发队列&lt;/li&gt;
&lt;li&gt;异步执行 + 并发队列&lt;/li&gt;
&lt;li&gt;同步执行 + 串行队列&lt;/li&gt;
&lt;li&gt;异步执行 + 串行队列&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;实际上，刚才还说了两种特殊队列：全局并发队列、主队列。全局并发队列可以作为普通并发队列来使用。但是主队列因为有点特殊，所以我们就又多了两种组合方式。这样就有六种不同的组合方式了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;同步执行 + 主队列&lt;/li&gt;
&lt;li&gt;异步执行 + 主队列&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;那么这几种不同组合方式各有什么区别呢，这里为了方便，先上结果，再来讲解。你可以直接查看表格结果，然后跳过&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;4. GCD的基本使用&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;区别&lt;/th&gt;
&lt;th&gt;并发队列&lt;/th&gt;
&lt;th&gt;串行队列&lt;/th&gt;
&lt;th&gt;主队列&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;同步(sync)&lt;/td&gt;
&lt;td&gt;没有开启新线程，串行执行任务&lt;/td&gt;
&lt;td&gt;没有开启新线程，串行执行任务&lt;/td&gt;
&lt;td&gt;主线程调用：死锁卡住不执行&lt;br/&gt;其他线程调用：没有开启新线程，串行执行任务&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;异步(async)&lt;/td&gt;
&lt;td&gt;有开启新线程，并发执行任务&lt;/td&gt;
&lt;td&gt;有开启新线程(1条)，串行执行任务&lt;/td&gt;
&lt;td&gt;没有开启新线程，串行执行任务&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;下边我们来分别讲讲这几种不同的组合方式的使用方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;先来讲讲并发队列的两种执行方式。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;4.1 同步执行 + 并发队列&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;输出结果：&lt;br/&gt;2018-02-23 20:34:55.095932+0800 YSC-GCD-demo[19892:4996930] currentThread---&amp;lt;NSThread: 0x60400006bbc0&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:34:55.096086+0800 YSC-GCD-demo[19892:4996930] syncConcurrent---begin&lt;br/&gt;2018-02-23 20:34:57.097589+0800 YSC-GCD-demo[19892:4996930] 1---&amp;lt;NSThread: 0x60400006bbc0&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:34:59.099100+0800 YSC-GCD-demo[19892:4996930] 1---&amp;lt;NSThread: 0x60400006bbc0&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:35:01.099843+0800 YSC-GCD-demo[19892:4996930] 2---&amp;lt;NSThread: 0x60400006bbc0&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:35:03.101171+0800 YSC-GCD-demo[19892:4996930] 2---&amp;lt;NSThread: 0x60400006bbc0&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:35:05.101750+0800 YSC-GCD-demo[19892:4996930] 3---&amp;lt;NSThread: 0x60400006bbc0&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:35:07.102414+0800 YSC-GCD-demo[19892:4996930] 3---&amp;lt;NSThread: 0x60400006bbc0&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:35:07.102575+0800 YSC-GCD-demo[19892:4996930] syncConcurrent---end&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从&lt;code&gt;同步执行 + 并发队列&lt;/code&gt;中可看到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有任务都是在当前线程（主线程）中执行的，没有开启新的线程（&lt;code&gt;同步执行&lt;/code&gt;不具备开启新线程的能力）。&lt;/li&gt;
&lt;li&gt;所有任务都在打印的&lt;code&gt;syncConcurrent---begin&lt;/code&gt;和&lt;code&gt;syncConcurrent---end&lt;/code&gt;之间执行的（&lt;code&gt;同步任务&lt;/code&gt;需要等待队列的任务执行结束）。&lt;/li&gt;
&lt;li&gt;任务按顺序执行的。按顺序执行的原因：虽然&lt;code&gt;并发队列&lt;/code&gt;可以开启多个线程，并且同时执行多个任务。但是因为本身不能创建新线程，只有当前线程这一个线程（&lt;code&gt;同步任务&lt;/code&gt;不具备开启新线程的能力），所以也就不存在并发。而且当前线程只有等待当前队列中正在执行的任务执行完毕之后，才能继续接着执行下面的操作（&lt;code&gt;同步任务&lt;/code&gt;需要等待队列的任务执行结束）。所以任务只能一个接一个按顺序执行，不能同时被执行。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;4.2 异步执行 + 并发队列&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;可以开启多个线程，任务交替（同时）执行。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;输出结果：&lt;br/&gt;2018-02-23 20:36:41.769269+0800 YSC-GCD-demo[19929:5005237] currentThread---&amp;lt;NSThread: 0x604000062d80&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:36:41.769496+0800 YSC-GCD-demo[19929:5005237] asyncConcurrent---begin&lt;br/&gt;2018-02-23 20:36:41.769725+0800 YSC-GCD-demo[19929:5005237] asyncConcurrent---end&lt;br/&gt;2018-02-23 20:36:43.774442+0800 YSC-GCD-demo[19929:5005566] 2---&amp;lt;NSThread: 0x604000266f00&amp;gt;{number = 5, name = (null)}&lt;br/&gt;2018-02-23 20:36:43.774440+0800 YSC-GCD-demo[19929:5005567] 3---&amp;lt;NSThread: 0x60000026f200&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 20:36:43.774440+0800 YSC-GCD-demo[19929:5005565] 1---&amp;lt;NSThread: 0x600000264800&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 20:36:45.779286+0800 YSC-GCD-demo[19929:5005567] 3---&amp;lt;NSThread: 0x60000026f200&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 20:36:45.779302+0800 YSC-GCD-demo[19929:5005565] 1---&amp;lt;NSThread: 0x600000264800&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 20:36:45.779286+0800 YSC-GCD-demo[19929:5005566] 2---&amp;lt;NSThread: 0x604000266f00&amp;gt;{number = 5, name = (null)}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;异步执行 + 并发队列&lt;/code&gt;中可以看出：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;除了当前线程（主线程），系统又开启了3个线程，并且任务是交替/同时执行的。（&lt;code&gt;异步执行&lt;/code&gt;具备开启新线程的能力。且&lt;code&gt;并发队列&lt;/code&gt;可开启多个线程，同时执行多个任务）。&lt;/li&gt;
&lt;li&gt;所有任务是在打印的&lt;code&gt;syncConcurrent---begin&lt;/code&gt;和&lt;code&gt;syncConcurrent---end&lt;/code&gt;之后才执行的。说明当前线程没有等待，而是直接开启了新线程，在新线程中执行任务（&lt;code&gt;异步执行&lt;/code&gt;不做等待，可以继续执行任务）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;接下来再来讲讲串行队列的两种执行方式。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;4.3 同步执行 + 串行队列&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;输出结果为：&lt;br/&gt;2018-02-23 20:39:37.876811+0800 YSC-GCD-demo[19975:5017162] currentThread---&amp;lt;NSThread: 0x604000079400&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:39:37.876998+0800 YSC-GCD-demo[19975:5017162] syncSerial---begin&lt;br/&gt;2018-02-23 20:39:39.878316+0800 YSC-GCD-demo[19975:5017162] 1---&amp;lt;NSThread: 0x604000079400&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:39:41.879829+0800 YSC-GCD-demo[19975:5017162] 1---&amp;lt;NSThread: 0x604000079400&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:39:43.880660+0800 YSC-GCD-demo[19975:5017162] 2---&amp;lt;NSThread: 0x604000079400&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:39:45.881265+0800 YSC-GCD-demo[19975:5017162] 2---&amp;lt;NSThread: 0x604000079400&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:39:47.882257+0800 YSC-GCD-demo[19975:5017162] 3---&amp;lt;NSThread: 0x604000079400&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:39:49.883008+0800 YSC-GCD-demo[19975:5017162] 3---&amp;lt;NSThread: 0x604000079400&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:39:49.883253+0800 YSC-GCD-demo[19975:5017162] syncSerial---end&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;同步执行 + 串行队列&lt;/code&gt;可以看到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（&lt;code&gt;同步执行&lt;/code&gt;不具备开启新线程的能力）。&lt;/li&gt;
&lt;li&gt;所有任务都在打印的&lt;code&gt;syncConcurrent---begin&lt;/code&gt;和&lt;code&gt;syncConcurrent---end&lt;/code&gt;之间执行（&lt;code&gt;同步任务&lt;/code&gt;需要等待队列的任务执行结束）。&lt;/li&gt;
&lt;li&gt;任务是按顺序执行的（&lt;code&gt;串行队列&lt;/code&gt;每次只有一个任务被执行，任务一个接一个按顺序执行）。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;4.4 异步执行 + 串行队列&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;输出结果为：&lt;br/&gt;2018-02-23 20:41:17.029999+0800 YSC-GCD-demo[20008:5024757] currentThread---&amp;lt;NSThread: 0x604000070440&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:41:17.030212+0800 YSC-GCD-demo[20008:5024757] asyncSerial---begin&lt;br/&gt;2018-02-23 20:41:17.030364+0800 YSC-GCD-demo[20008:5024757] asyncSerial---end&lt;br/&gt;2018-02-23 20:41:19.035379+0800 YSC-GCD-demo[20008:5024950] 1---&amp;lt;NSThread: 0x60000026e100&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 20:41:21.037140+0800 YSC-GCD-demo[20008:5024950] 1---&amp;lt;NSThread: 0x60000026e100&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 20:41:23.042220+0800 YSC-GCD-demo[20008:5024950] 2---&amp;lt;NSThread: 0x60000026e100&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 20:41:25.042971+0800 YSC-GCD-demo[20008:5024950] 2---&amp;lt;NSThread: 0x60000026e100&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 20:41:27.047690+0800 YSC-GCD-demo[20008:5024950] 3---&amp;lt;NSThread: 0x60000026e100&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 20:41:29.052327+0800 YSC-GCD-demo[20008:5024950] 3---&amp;lt;NSThread: 0x60000026e100&amp;gt;{number = 3, name = (null)}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;异步执行 + 串行队列&lt;/code&gt;可以看到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开启了一条新线程（&lt;code&gt;异步执行&lt;/code&gt;具备开启新线程的能力，&lt;code&gt;串行队列&lt;/code&gt;只开启一个线程）。&lt;/li&gt;
&lt;li&gt;所有任务是在打印的&lt;code&gt;syncConcurrent---begin&lt;/code&gt;和&lt;code&gt;syncConcurrent---end&lt;/code&gt;之后才开始执行的（&lt;code&gt;异步执行&lt;/code&gt;不会做任何等待，可以继续执行任务）。&lt;/li&gt;
&lt;li&gt;任务是按顺序执行的（&lt;code&gt;串行队列&lt;/code&gt;每次只有一个任务被执行，任务一个接一个按顺序执行）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下边讲讲刚才我们提到过的特殊队列：&lt;strong&gt;主队列&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主队列：GCD自带的一种特殊的&lt;strong&gt;串行队列&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;所有放在主队列中的任务，都会放到主线程中执行&lt;/li&gt;
&lt;li&gt;可使用&lt;code&gt;dispatch_get_main_queue()&lt;/code&gt;获得主队列&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;我们再来看看主队列的两种组合方式。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;4.5 同步执行 + 主队列&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;同步执行 + 主队列&lt;/code&gt;在不同线程中调用结果也是不一样，在主线程中调用会出现死锁，而在其他线程中则不会。&lt;/p&gt;
&lt;h3&gt;4.5.1 在主线程中调用&lt;code&gt;同步执行 + 主队列&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;互相等待卡住不可行&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;输出结果&lt;br/&gt;2018-02-23 20:42:36.842892+0800 YSC-GCD-demo[20041:5030982] currentThread---&amp;lt;NSThread: 0x600000078a00&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:42:36.843050+0800 YSC-GCD-demo[20041:5030982] syncMain---begin&lt;br/&gt;(lldb)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;同步执行 + 主队列&lt;/code&gt;可以惊奇的发现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在主线程中使用&lt;code&gt;同步执行 + 主队列&lt;/code&gt;，追加到主线程的任务1、任务2、任务3都不再执行了，而且&lt;code&gt;syncMain---end&lt;/code&gt;也没有打印，在XCode 9上还会报崩溃。这是为什么呢？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这是因为我们在主线程中执行&lt;code&gt;syncMain&lt;/code&gt;方法，相当于把&lt;code&gt;syncMain&lt;/code&gt;任务放到了主线程的队列中。而&lt;code&gt;同步执行&lt;/code&gt;会等待当前队列中的任务执行完毕，才会接着执行。那么当我们把&lt;code&gt;任务1&lt;/code&gt;追加到主队列中，&lt;code&gt;任务1&lt;/code&gt;就在等待主线程处理完&lt;code&gt;syncMain&lt;/code&gt;任务。而&lt;code&gt;syncMain&lt;/code&gt;任务需要等待&lt;code&gt;任务1&lt;/code&gt;执行完毕，才能接着执行。&lt;/p&gt;
&lt;p&gt;那么，现在的情况就是&lt;code&gt;syncMain&lt;/code&gt;任务和&lt;code&gt;任务1&lt;/code&gt;都在等对方执行完毕。这样大家互相等待，所以就卡住了，所以我们的任务执行不了，而且&lt;code&gt;syncMain---end&lt;/code&gt;也没有打印。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要是如果不在主线程中调用，而在其他线程中调用会如何呢？&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;4.5.2 在其他线程中调用&lt;code&gt;同步执行 + 主队列&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;不会开启新线程，执行完一个任务，再执行下一个任务&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;输出结果：&lt;br/&gt;2018-02-23 20:44:19.377321+0800 YSC-GCD-demo[20083:5040347] currentThread---&amp;lt;NSThread: 0x600000272fc0&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 20:44:19.377494+0800 YSC-GCD-demo[20083:5040347] syncMain---begin&lt;br/&gt;2018-02-23 20:44:21.384716+0800 YSC-GCD-demo[20083:5040132] 1---&amp;lt;NSThread: 0x60000006c900&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:44:23.386091+0800 YSC-GCD-demo[20083:5040132] 1---&amp;lt;NSThread: 0x60000006c900&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:44:25.387687+0800 YSC-GCD-demo[20083:5040132] 2---&amp;lt;NSThread: 0x60000006c900&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:44:27.388648+0800 YSC-GCD-demo[20083:5040132] 2---&amp;lt;NSThread: 0x60000006c900&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:44:29.390459+0800 YSC-GCD-demo[20083:5040132] 3---&amp;lt;NSThread: 0x60000006c900&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:44:31.391965+0800 YSC-GCD-demo[20083:5040132] 3---&amp;lt;NSThread: 0x60000006c900&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:44:31.392513+0800 YSC-GCD-demo[20083:5040347] syncMain---end&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在其他线程中使用&lt;code&gt;同步执行 + 主队列&lt;/code&gt;可看到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有任务都是在主线程（非当前线程）中执行的，没有开启新的线程（所有放在&lt;code&gt;主队列&lt;/code&gt;中的任务，都会放到主线程中执行）。&lt;/li&gt;
&lt;li&gt;所有任务都在打印的&lt;code&gt;syncConcurrent---begin&lt;/code&gt;和&lt;code&gt;syncConcurrent---end&lt;/code&gt;之间执行（&lt;code&gt;同步任务&lt;/code&gt;需要等待队列的任务执行结束）。&lt;/li&gt;
&lt;li&gt;任务是按顺序执行的（主队列是&lt;code&gt;串行队列&lt;/code&gt;，每次只有一个任务被执行，任务一个接一个按顺序执行）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么现在就不会卡住了呢？&lt;br/&gt;因为&lt;code&gt;syncMain 任务&lt;/code&gt;放到了其他线程里，而&lt;code&gt;任务1&lt;/code&gt;、&lt;code&gt;任务2&lt;/code&gt;、&lt;code&gt;任务3&lt;/code&gt;都在追加到主队列中，这三个任务都会在主线程中执行。&lt;code&gt;syncMain 任务&lt;/code&gt;在其他线程中执行到追加&lt;code&gt;任务1&lt;/code&gt;到主队列中，因为主队列现在没有正在执行的任务，所以，会直接执行主队列的&lt;code&gt;任务1&lt;/code&gt;，等&lt;code&gt;任务1&lt;/code&gt;执行完毕，再接着执行&lt;code&gt;任务2&lt;/code&gt;、&lt;code&gt;任务3&lt;/code&gt;。所以这里不会卡住线程。&lt;/p&gt;
&lt;h2&gt;4.6 异步执行 + 主队列&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;只在主线程中执行任务，执行完一个任务，再执行下一个任务。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;输出结果：&lt;br/&gt;2018-02-23 20:45:49.981505+0800 YSC-GCD-demo[20111:5046708] currentThread---&amp;lt;NSThread: 0x60000006d440&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:45:49.981935+0800 YSC-GCD-demo[20111:5046708] asyncMain---begin&lt;br/&gt;2018-02-23 20:45:49.982352+0800 YSC-GCD-demo[20111:5046708] asyncMain---end&lt;br/&gt;2018-02-23 20:45:51.991096+0800 YSC-GCD-demo[20111:5046708] 1---&amp;lt;NSThread: 0x60000006d440&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:45:53.991959+0800 YSC-GCD-demo[20111:5046708] 1---&amp;lt;NSThread: 0x60000006d440&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:45:55.992937+0800 YSC-GCD-demo[20111:5046708] 2---&amp;lt;NSThread: 0x60000006d440&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:45:57.993649+0800 YSC-GCD-demo[20111:5046708] 2---&amp;lt;NSThread: 0x60000006d440&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:45:59.994928+0800 YSC-GCD-demo[20111:5046708] 3---&amp;lt;NSThread: 0x60000006d440&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:46:01.995589+0800 YSC-GCD-demo[20111:5046708] 3---&amp;lt;NSThread: 0x60000006d440&amp;gt;{number = 1, name = main}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;异步执行 + 主队列&lt;/code&gt;可以看到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（虽然&lt;code&gt;异步执行&lt;/code&gt;具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中）。&lt;/li&gt;
&lt;li&gt;所有任务是在打印的syncConcurrent---begin和syncConcurrent---end之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。&lt;/li&gt;
&lt;li&gt;任务是按顺序执行的（因为主队列是&lt;code&gt;串行队列&lt;/code&gt;，每次只有一个任务被执行，任务一个接一个按顺序执行）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;弄懂了难理解、绕来绕去的&lt;strong&gt;队列+任务&lt;/strong&gt;之后，我们来学习一个简单的东西：&lt;strong&gt;5. GCD 线程间的通信&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在iOS开发过程中，我们一般在主线程里边进行UI刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;输出结果：&lt;br/&gt;2018-02-23 20:47:03.462394+0800 YSC-GCD-demo[20154:5053282] 1---&amp;lt;NSThread: 0x600000271940&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 20:47:05.465912+0800 YSC-GCD-demo[20154:5053282] 1---&amp;lt;NSThread: 0x600000271940&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 20:47:07.466657+0800 YSC-GCD-demo[20154:5052953] 2---&amp;lt;NSThread: 0x60000007bf80&amp;gt;{number = 1, name = main}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;可以看到在其他线程中先执行任务，执行完了之后回到主线程执行主线程的相应操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;6.1 GCD 栅栏方法：dispatch_barrier_async&lt;/h2&gt;
&lt;ul&gt;&lt;li readability=&quot;-2&quot;&gt;我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于&lt;code&gt;栅栏&lt;/code&gt;一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到&lt;code&gt;dispatch_barrier_async&lt;/code&gt;方法在两个操作组间形成栅栏。&lt;br/&gt;&lt;code&gt;dispatch_barrier_async&lt;/code&gt;函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在&lt;code&gt;dispatch_barrier_async&lt;/code&gt;函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。具体如下图所示：&lt;br/&gt;&lt;div class=&quot;image-package&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1478&quot; data-height=&quot;758&quot;&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1877784-4d6d77fafd3ad007.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1877784-4d6d77fafd3ad007.png&quot; data-original-width=&quot;1478&quot; data-original-height=&quot;758&quot; data-original-format=&quot;&quot; data-original-filesize=&quot;70540&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;dispatch_barrier_async.png&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;输出结果：&lt;br/&gt;2018-02-23 20:48:18.297745+0800 YSC-GCD-demo[20188:5059274] 1---&amp;lt;NSThread: 0x600000079d80&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 20:48:18.297745+0800 YSC-GCD-demo[20188:5059273] 2---&amp;lt;NSThread: 0x600000079e00&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 20:48:20.301139+0800 YSC-GCD-demo[20188:5059274] 1---&amp;lt;NSThread: 0x600000079d80&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 20:48:20.301139+0800 YSC-GCD-demo[20188:5059273] 2---&amp;lt;NSThread: 0x600000079e00&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 20:48:22.306290+0800 YSC-GCD-demo[20188:5059274] barrier---&amp;lt;NSThread: 0x600000079d80&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 20:48:24.311655+0800 YSC-GCD-demo[20188:5059274] barrier---&amp;lt;NSThread: 0x600000079d80&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 20:48:26.316943+0800 YSC-GCD-demo[20188:5059273] 4---&amp;lt;NSThread: 0x600000079e00&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 20:48:26.316956+0800 YSC-GCD-demo[20188:5059274] 3---&amp;lt;NSThread: 0x600000079d80&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 20:48:28.320660+0800 YSC-GCD-demo[20188:5059273] 4---&amp;lt;NSThread: 0x600000079e00&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 20:48:28.320649+0800 YSC-GCD-demo[20188:5059274] 3---&amp;lt;NSThread: 0x600000079d80&amp;gt;{number = 4, name = (null)}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;dispatch_barrier_async&lt;/code&gt;执行结果中可以看出：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;6.2 GCD 延时执行方法：dispatch_after&lt;/h2&gt;
&lt;p&gt;我们经常会遇到这样的需求：在指定时间（例如3秒）之后执行某个任务。可以用 GCD 的&lt;code&gt;dispatch_after&lt;/code&gt;函数来实现。&lt;br/&gt;需要注意的是：&lt;code&gt;dispatch_after&lt;/code&gt;函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，&lt;code&gt;dispatch_after&lt;/code&gt;函数是很有效的。&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;输出结果：&lt;br/&gt;2018-02-23 20:53:08.713784+0800 YSC-GCD-demo[20282:5080295] currentThread---&amp;lt;NSThread: 0x60000006ee00&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 20:53:08.713962+0800 YSC-GCD-demo[20282:5080295] asyncMain---begin&lt;br/&gt;2018-02-23 20:53:10.714283+0800 YSC-GCD-demo[20282:5080295] after---&amp;lt;NSThread: 0x60000006ee00&amp;gt;{number = 1, name = main}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看出：在打印&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;asyncMain---begin&lt;/code&gt;之后大约 2.0 秒的时间，打印了&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;after---&amp;lt;NSThread: 0x60000006ee00&amp;gt;{number = 1, name = main}&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;6.3 GCD 一次性代码（只执行一次）：dispatch_once&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了 GCD 的&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;dispatch_once&lt;/code&gt;函数。使用&lt;br/&gt;&lt;code&gt;dispatch_once&lt;/code&gt;函数能保证某段代码在程序运行过程中只被执行1次，并且即使在多线程的环境下，&lt;code&gt;dispatch_once&lt;/code&gt;也可以保证线程安全。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;h2&gt;6.4 GCD 快速迭代方法：dispatch_apply&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;通常我们会用 for 循环遍历，但是 GCD 给我们提供了快速迭代的函数&lt;code&gt;dispatch_apply&lt;/code&gt;。&lt;code&gt;dispatch_apply&lt;/code&gt;按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果是在串行队列中使用&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;dispatch_apply&lt;/code&gt;，那么就和 for 循环一样，按顺序同步执行。可这样就体现不出快速迭代的意义了。&lt;br/&gt;我们可以利用并发队列进行异步执行。比如说遍历 0~5 这6个数字，for 循环的做法是每次取出一个元素，逐个遍历。&lt;code&gt;dispatch_apply&lt;/code&gt;可以 在多个线程中同时（异步）遍历多个数字。&lt;br/&gt;还有一点，无论是在串行队列，还是异步队列中，dispatch_apply 都会等待全部任务执行完毕，这点就像是同步操作，也像是队列组中的&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;dispatch_group_wait&lt;/code&gt;方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;输出结果：&lt;br/&gt;2018-02-23 22:03:18.475499+0800 YSC-GCD-demo[20470:5176805] apply---begin&lt;br/&gt;2018-02-23 22:03:18.476672+0800 YSC-GCD-demo[20470:5177035] 1---&amp;lt;NSThread: 0x60000027b8c0&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 22:03:18.476693+0800 YSC-GCD-demo[20470:5176805] 0---&amp;lt;NSThread: 0x604000070640&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 22:03:18.476704+0800 YSC-GCD-demo[20470:5177037] 2---&amp;lt;NSThread: 0x604000276800&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 22:03:18.476735+0800 YSC-GCD-demo[20470:5177036] 3---&amp;lt;NSThread: 0x60000027b800&amp;gt;{number = 5, name = (null)}&lt;br/&gt;2018-02-23 22:03:18.476867+0800 YSC-GCD-demo[20470:5177035] 4---&amp;lt;NSThread: 0x60000027b8c0&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 22:03:18.476867+0800 YSC-GCD-demo[20470:5176805] 5---&amp;lt;NSThread: 0x604000070640&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 22:03:18.477038+0800 YSC-GCD-demo[20470:5176805] apply---end&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为是在并发队列中异步执行任务，所以各个任务的执行时间长短不定，最后结束顺序也不定。但是&lt;code&gt;apply---end&lt;/code&gt;一定在最后执行。这是因为&lt;code&gt;dispatch_apply&lt;/code&gt;函数会等待全部任务执行完毕。&lt;/p&gt;
&lt;h2&gt;6.5 GCD 队列组：dispatch_group&lt;/h2&gt;
&lt;p&gt;有时候我们会有这样的需求：分别异步执行2个耗时任务，然后当2个耗时任务都执行完毕后再回到主线程执行任务。这时候我们可以用到 GCD 的队列组。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用队列组的&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;dispatch_group_async&lt;/code&gt;先把任务放到队列中，然后将队列放入队列组中。或者使用队列组的&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;dispatch_group_enter、dispatch_group_leave&lt;/code&gt;组合 来实现&lt;br/&gt;&lt;code&gt;dispatch_group_async&lt;/code&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;调用队列组的&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;dispatch_group_notify&lt;/code&gt;回到指定线程执行任务。或者使用&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;dispatch_group_wait&lt;/code&gt;回到当前线程继续向下执行（会阻塞当前线程）。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;6.5.1 dispatch_group_notify&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;监听 group 中任务的完成状态，当所有的任务都执行完成后，追加任务到 group 中，并执行任务。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;输出结果：&lt;br/&gt;2018-02-23 22:05:03.790035+0800 YSC-GCD-demo[20494:5183349] currentThread---&amp;lt;NSThread: 0x604000072040&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 22:05:03.790237+0800 YSC-GCD-demo[20494:5183349] group---begin&lt;br/&gt;2018-02-23 22:05:05.792721+0800 YSC-GCD-demo[20494:5183654] 1---&amp;lt;NSThread: 0x60000026f280&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 22:05:05.792725+0800 YSC-GCD-demo[20494:5183656] 2---&amp;lt;NSThread: 0x60000026f240&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 22:05:07.797408+0800 YSC-GCD-demo[20494:5183656] 2---&amp;lt;NSThread: 0x60000026f240&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 22:05:07.797408+0800 YSC-GCD-demo[20494:5183654] 1---&amp;lt;NSThread: 0x60000026f280&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 22:05:09.798717+0800 YSC-GCD-demo[20494:5183349] 3---&amp;lt;NSThread: 0x604000072040&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 22:05:11.799827+0800 YSC-GCD-demo[20494:5183349] 3---&amp;lt;NSThread: 0x604000072040&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 22:05:11.799977+0800 YSC-GCD-demo[20494:5183349] group---end&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从&lt;code&gt;dispatch_group_notify&lt;/code&gt;相关代码运行输出结果可以看出：&lt;br/&gt;当所有任务都执行完成之后，才执行&lt;code&gt;dispatch_group_notify&lt;/code&gt;block 中的任务。&lt;/p&gt;
&lt;h3&gt;6.5.2 dispatch_group_wait&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;暂停当前线程（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;输出结果：&lt;br/&gt;2018-02-23 22:10:16.939258+0800 YSC-GCD-demo[20538:5198871] currentThread---&amp;lt;NSThread: 0x600000066780&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 22:10:16.939455+0800 YSC-GCD-demo[20538:5198871] group---begin&lt;br/&gt;2018-02-23 22:10:18.943862+0800 YSC-GCD-demo[20538:5199137] 2---&amp;lt;NSThread: 0x600000464b80&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 22:10:18.943861+0800 YSC-GCD-demo[20538:5199138] 1---&amp;lt;NSThread: 0x604000076640&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 22:10:20.947787+0800 YSC-GCD-demo[20538:5199137] 2---&amp;lt;NSThread: 0x600000464b80&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 22:10:20.947790+0800 YSC-GCD-demo[20538:5199138] 1---&amp;lt;NSThread: 0x604000076640&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 22:10:20.948134+0800 YSC-GCD-demo[20538:5198871] group---end&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从&lt;code&gt;dispatch_group_wait&lt;/code&gt;相关代码运行输出结果可以看出：&lt;br/&gt;当所有任务执行完成之后，才执行&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;dispatch_group_wait&lt;/code&gt;之后的操作。但是，使用&lt;code&gt;dispatch_group_wait&lt;/code&gt;会阻塞当前线程。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;6.5.3 dispatch_group_enter、dispatch_group_leave&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;dispatch_group_enter&lt;/code&gt;标志着一个任务追加到 group，执行一次，相当于 group 中未执行完毕任务数+1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dispatch_group_leave&lt;/code&gt;标志着一个任务离开了 group，执行一次，相当于 group 中未执行完毕任务数-1。&lt;/li&gt;
&lt;li&gt;当 group 中未执行完毕任务数为0的时候，才会使&lt;code&gt;dispatch_group_wait&lt;/code&gt;解除阻塞，以及执行追加到&lt;code&gt;dispatch_group_notify&lt;/code&gt;中的任务。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;输出结果：&lt;br/&gt;2018-02-23 22:14:17.997667+0800 YSC-GCD-demo[20592:5214830] currentThread---&amp;lt;NSThread: 0x604000066600&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 22:14:17.997839+0800 YSC-GCD-demo[20592:5214830] group---begin&lt;br/&gt;2018-02-23 22:14:20.000298+0800 YSC-GCD-demo[20592:5215094] 1---&amp;lt;NSThread: 0x600000277c80&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 22:14:20.000305+0800 YSC-GCD-demo[20592:5215095] 2---&amp;lt;NSThread: 0x600000277c40&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 22:14:22.001323+0800 YSC-GCD-demo[20592:5215094] 1---&amp;lt;NSThread: 0x600000277c80&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 22:14:22.001339+0800 YSC-GCD-demo[20592:5215095] 2---&amp;lt;NSThread: 0x600000277c40&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 22:14:24.002321+0800 YSC-GCD-demo[20592:5214830] 3---&amp;lt;NSThread: 0x604000066600&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 22:14:26.002852+0800 YSC-GCD-demo[20592:5214830] 3---&amp;lt;NSThread: 0x604000066600&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 22:14:26.003116+0800 YSC-GCD-demo[20592:5214830] group---end&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从&lt;code&gt;dispatch_group_enter、dispatch_group_leave&lt;/code&gt;相关代码运行结果中可以看出：当所有任务执行完成之后，才执行 dispatch_group_notify 中的任务。这里的&lt;code&gt;dispatch_group_enter、dispatch_group_leave&lt;/code&gt;组合，其实等同于&lt;code&gt;dispatch_group_async&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;6.6 GCD 信号量：dispatch_semaphore&lt;/h2&gt;
&lt;p&gt;GCD 中的信号量是指&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;Dispatch Semaphore&lt;/strong&gt;，是持有计数的信号。类似于过高速路收费站的栏杆。可以通过时，打开栏杆，不可以通过时，关闭栏杆。在&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;Dispatch Semaphore&lt;/strong&gt;中，使用计数来完成这个功能，计数为0时等待，不可通过。计数为1或大于1时，计数减1且不等待，可通过。&lt;br/&gt;&lt;strong&gt;Dispatch Semaphore&lt;/strong&gt;提供了三个函数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;dispatch_semaphore_create&lt;/code&gt;：创建一个Semaphore并初始化信号的总量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dispatch_semaphore_signal&lt;/code&gt;：发送一个信号，让信号总量加1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dispatch_semaphore_wait&lt;/code&gt;：可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：信号量的使用前提是：想清楚你需要处理哪个线程等待（阻塞），又要哪个线程继续执行，然后使用信号量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Dispatch Semaphore 在实际开发中主要用于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;保持线程同步，将异步执行任务转换为同步执行任务&lt;/li&gt;
&lt;li&gt;保证线程安全，为线程加锁&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;6.6.1 Dispatch Semaphore 线程同步&lt;/h3&gt;
&lt;p&gt;我们在开发中，会遇到这样的需求：异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于，将将异步执行任务转换为同步执行任务。比如说：AFNetworking 中 AFURLSessionManager.m 里面的&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;tasksForKeyPath:&lt;/code&gt;方法。通过引入信号量的方式，等待异步执行任务结果，获取到 tasks，然后再返回该 tasks。&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;&gt;- (&lt;span class=&quot;hljs-built_in&quot;&gt;NSArray *)tasksForKeyPath:(&lt;span class=&quot;hljs-built_in&quot;&gt;NSString *)keyPath {
    __block &lt;span class=&quot;hljs-built_in&quot;&gt;NSArray *tasks = &lt;span class=&quot;hljs-literal&quot;&gt;nil;
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(&lt;span class=&quot;hljs-number&quot;&gt;0);
    [&lt;span class=&quot;hljs-keyword&quot;&gt;self.session getTasksWithCompletionHandler:^(&lt;span class=&quot;hljs-built_in&quot;&gt;NSArray *dataTasks, &lt;span class=&quot;hljs-built_in&quot;&gt;NSArray *uploadTasks, &lt;span class=&quot;hljs-built_in&quot;&gt;NSArray *downloadTasks) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;if ([keyPath isEqualToString:&lt;span class=&quot;hljs-built_in&quot;&gt;NSStringFromSelector(&lt;span class=&quot;hljs-keyword&quot;&gt;@selector(dataTasks))]) {
            tasks = dataTasks;
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if ([keyPath isEqualToString:&lt;span class=&quot;hljs-built_in&quot;&gt;NSStringFromSelector(&lt;span class=&quot;hljs-keyword&quot;&gt;@selector(uploadTasks))]) {
            tasks = uploadTasks;
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if ([keyPath isEqualToString:&lt;span class=&quot;hljs-built_in&quot;&gt;NSStringFromSelector(&lt;span class=&quot;hljs-keyword&quot;&gt;@selector(downloadTasks))]) {
            tasks = downloadTasks;
        } &lt;span class=&quot;hljs-keyword&quot;&gt;else &lt;span class=&quot;hljs-keyword&quot;&gt;if ([keyPath isEqualToString:&lt;span class=&quot;hljs-built_in&quot;&gt;NSStringFromSelector(&lt;span class=&quot;hljs-keyword&quot;&gt;@selector(tasks))]) {
            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:&lt;span class=&quot;hljs-string&quot;&gt;@&quot;@unionOfArrays.self&quot;];
        }

        dispatch_semaphore_signal(semaphore);
    }];

    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);

    &lt;span class=&quot;hljs-keyword&quot;&gt;return tasks;
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面，我们来利用 Dispatch Semaphore 实现线程同步，将异步执行任务转换为同步执行任务。&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;输出结果：&lt;br/&gt;2018-02-23 22:22:26.521665+0800 YSC-GCD-demo[20642:5246341] currentThread---&amp;lt;NSThread: 0x60400006bc80&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 22:22:26.521869+0800 YSC-GCD-demo[20642:5246341] semaphore---begin&lt;br/&gt;2018-02-23 22:22:28.526841+0800 YSC-GCD-demo[20642:5246638] 1---&amp;lt;NSThread: 0x600000272300&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 22:22:28.527030+0800 YSC-GCD-demo[20642:5246341] semaphore---end,number = 100&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从 Dispatch Semaphore 实现线程同步的代码可以看到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;semaphore---end&lt;/code&gt;是在执行完&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;number = 100;&lt;/code&gt;之后才打印的。而且输出结果 number 为 100。&lt;br/&gt;这是因为&lt;code&gt;异步执行&lt;/code&gt;不会做任何等待，可以继续执行任务。&lt;code&gt;异步执行&lt;/code&gt;将任务1追加到队列之后，不做等待，接着执行&lt;code&gt;dispatch_semaphore_wait&lt;/code&gt;方法。此时 semaphore == 0，当前线程进入等待状态。然后，异步任务1开始执行。任务1执行到&lt;code&gt;dispatch_semaphore_signal&lt;/code&gt;之后，总信号量，此时 semaphore == 1，&lt;code&gt;dispatch_semaphore_wait&lt;/code&gt;方法使总信号量减1，正在被阻塞的线程（主线程）恢复继续执行。最后打印&lt;code&gt;semaphore---end,number = 100&lt;/code&gt;。这样就实现了线程同步，将异步执行任务转换为同步执行任务。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;6.6.2 Dispatch Semaphore 线程安全和线程同步（为线程加锁）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;线程安全&lt;/strong&gt;：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。&lt;/p&gt;
&lt;p&gt;若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程同步&lt;/strong&gt;：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。&lt;/p&gt;
&lt;p&gt;举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。&lt;/p&gt;
&lt;p&gt;下面，我们模拟火车票售卖的方式，实现 NSThread 线程安全和解决线程同步问题。&lt;/p&gt;
&lt;p&gt;场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。&lt;/p&gt;
&lt;h4&gt;6.6.2.1 非线程安全（不使用 semaphore）&lt;/h4&gt;
&lt;p&gt;先来看看不考虑线程安全的代码：&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;输出结果（部分）：&lt;br/&gt;2018-02-23 22:25:35.789072+0800 YSC-GCD-demo[20712:5258914] currentThread---&amp;lt;NSThread: 0x604000068880&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 22:25:35.789260+0800 YSC-GCD-demo[20712:5258914] semaphore---begin&lt;br/&gt;2018-02-23 22:25:35.789641+0800 YSC-GCD-demo[20712:5259176] 剩余票数：48 窗口：&amp;lt;NSThread: 0x60000027db80&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 22:25:35.789646+0800 YSC-GCD-demo[20712:5259175] 剩余票数：49 窗口：&amp;lt;NSThread: 0x60000027e740&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 22:25:35.994113+0800 YSC-GCD-demo[20712:5259175] 剩余票数：47 窗口：&amp;lt;NSThread: 0x60000027e740&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 22:25:35.994129+0800 YSC-GCD-demo[20712:5259176] 剩余票数：46 窗口：&amp;lt;NSThread: 0x60000027db80&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 22:25:36.198993+0800 YSC-GCD-demo[20712:5259176] 剩余票数：45 窗口：&amp;lt;NSThread: 0x60000027db80&amp;gt;{number = 3, name = (null)}&lt;br/&gt;...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看到在不考虑线程安全，不使用 semaphore 的情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。&lt;/p&gt;
&lt;h4&gt;6.6.2.2 线程安全（使用 semaphore 加锁）&lt;/h4&gt;
&lt;p&gt;考虑线程安全的代码：&lt;/p&gt;
&lt;pre class=&quot;hljs objectivec&quot;&gt;
&lt;code class=&quot;objectivec&quot;/&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;输出结果为：&lt;br/&gt;2018-02-23 22:32:19.814232+0800 YSC-GCD-demo[20862:5290531] currentThread---&amp;lt;NSThread: 0x6000000783c0&amp;gt;{number = 1, name = main}&lt;br/&gt;2018-02-23 22:32:19.814412+0800 YSC-GCD-demo[20862:5290531] semaphore---begin&lt;br/&gt;2018-02-23 22:32:19.814837+0800 YSC-GCD-demo[20862:5290687] 剩余票数：49 窗口：&amp;lt;NSThread: 0x6040002709c0&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 22:32:20.017745+0800 YSC-GCD-demo[20862:5290689] 剩余票数：48 窗口：&amp;lt;NSThread: 0x60000046c640&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 22:32:20.222039+0800 YSC-GCD-demo[20862:5290687] 剩余票数：47 窗口：&amp;lt;NSThread: 0x6040002709c0&amp;gt;{number = 3, name = (null)}&lt;br/&gt;...&lt;br/&gt;2018-02-23 22:32:29.024817+0800 YSC-GCD-demo[20862:5290689] 剩余票数：4 窗口：&amp;lt;NSThread: 0x60000046c640&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 22:32:29.230110+0800 YSC-GCD-demo[20862:5290687] 剩余票数：3 窗口：&amp;lt;NSThread: 0x6040002709c0&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 22:32:29.433615+0800 YSC-GCD-demo[20862:5290689] 剩余票数：2 窗口：&amp;lt;NSThread: 0x60000046c640&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 22:32:29.637572+0800 YSC-GCD-demo[20862:5290687] 剩余票数：1 窗口：&amp;lt;NSThread: 0x6040002709c0&amp;gt;{number = 3, name = (null)}&lt;br/&gt;2018-02-23 22:32:29.840234+0800 YSC-GCD-demo[20862:5290689] 剩余票数：0 窗口：&amp;lt;NSThread: 0x60000046c640&amp;gt;{number = 4, name = (null)}&lt;br/&gt;2018-02-23 22:32:30.044960+0800 YSC-GCD-demo[20862:5290687] 所有火车票均已售完&lt;br/&gt;2018-02-23 22:32:30.045260+0800 YSC-GCD-demo[20862:5290689] 所有火车票均已售完&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看出，在考虑了线程安全的情况下，使用&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;code&gt;dispatch_semaphore&lt;/code&gt;&lt;br/&gt;机制之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p&gt;作者：行走的少年郎&lt;br/&gt;链接：https://www.jianshu.com/p/2d57c72016c6&lt;br/&gt;來源：简书&lt;br/&gt;简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。&lt;/p&gt;</description>
<pubDate>Thu, 29 Nov 2018 07:11:00 +0000</pubDate>
<dc:creator>鸿鹄当高远</dc:creator>
<og:description>1. GCD 简介 Grand Central Dispatch（GCD）是异步执行任务的技术之一。一般将应用程序中记述的线程管理用的代码在系统级中实现。开发者只需要定义想执行的任务并追加到适当的Di</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jukaiit/p/10038213.html</dc:identifier>
</item>
<item>
<title>使用 EOLINKER 进行接口测试的最佳路径 (下) - 隔壁王书</title>
<link>http://www.cnblogs.com/dc20181010/p/10038307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dc20181010/p/10038307.html</guid>
<description>&lt;p&gt;本文为 《使用 EOLINKER 进行接口测试的最佳路径》 下半部分文章，主要介绍测试脚本如何执行和报告生成，以及测试项目人员如何协作。还没看过上篇文章请戳&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/dc20181010/p/10021643.html&quot;&gt;使用 EOLINKER 进行接口测试的最佳路径（上）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;本文内容&quot;&gt;本文内容&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;测试脚本执行及报告：讲述如何在 EOLINKER 上执行接口测试脚本，及如何查看和下载测试报告。&lt;/li&gt;
&lt;li&gt;测试项目人员协作：讲述如何在 EOLINKER 上进行多人的测试项目协作。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;测试脚本执行及报告&quot;&gt;1.测试脚本执行及报告&lt;/h2&gt;
&lt;h3 id=&quot;测试用例执行&quot;&gt;1. 测试用例执行&lt;/h3&gt;
&lt;p&gt;EOLINKER 的测试用例执行分两种：【用例集列表测试执行】 和 【单例列表测试执行】；&lt;/p&gt;
&lt;p&gt;先来看下在 【用例集列表测试执行】&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图中标示1说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;测试全部-并行：表示并行执行用例集列表中所有的用例集&lt;/li&gt;
&lt;li&gt;测试全部-串行：表示并行执行用例集列表中所有的用例集&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;图中标示2说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用例集列表操作按钮-测试：表示只执行该条用例集。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/FndOJR7WFVCy1Ihm2mzTz3iF4t2S&quot; alt=&quot;测试项目模块管理/用例集列表页面&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试项目模块管理/用例集列表页面&lt;/p&gt;
&lt;p&gt;再来看下，在 【单例列表中测试执行】&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图中标示1说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;测试全部：表示执行单例列表下所有的单个用例。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;图中标示2说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单例列表操作按钮-测试：表示只执行该条单个用例。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/Fk_ohNRrRZ_XL2K2UEcCCIbBmlFk&quot; alt=&quot;i单例列表页面&quot;/&gt;&lt;br/&gt;单例列表页面&lt;/p&gt;
&lt;h3 id=&quot;测试报告查看&quot;&gt;2. 测试报告查看&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.执行用例集列表测试全部后的测试报告，可以查看：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有用例集执行完的总耗时&lt;/li&gt;
&lt;li&gt;成功率&lt;/li&gt;
&lt;li&gt;单个用例测试结果及测试耗时&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/FqpL1OYDTmtwhCzY1HVjhjXO8VaP&quot; alt=&quot;执行用例集列表测试全部后的测试报告&quot;/&gt;&lt;br/&gt;执行用例集列表测试全部后的测试报告&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.执行用例集列表操作按钮-测试后的测试报告，可以查看：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前置用例测试结果;&lt;/li&gt;
&lt;li&gt;当前用例集执行完的总耗时;&lt;/li&gt;
&lt;li&gt;单个用例测试结果及测试耗时;&lt;/li&gt;
&lt;li&gt;请求信息和请求头部信息;&lt;/li&gt;
&lt;li&gt;返回信息和返回头部信息;&lt;/li&gt;
&lt;li&gt;返回头部校验规则;&lt;/li&gt;
&lt;li&gt;返回结果校验规则;&lt;/li&gt;
&lt;li&gt;实际返回;&lt;/li&gt;
&lt;li&gt;如果测试失败，会显示失败原因信息;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/Fp4VXckUKHfEqzVj6F-Oa4oZEtxi&quot; alt=&quot;image (11).png&quot;/&gt;&lt;br/&gt;执行用例集列表操作按钮-测试后的测试报告&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.执行单例列表的测试全部后的测试报告，和执行用例集列表操作按钮-测试后的测试报告一样&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.执行单例列表操作按钮-测试后的测试报告，可以查看：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;请求信息和请求头部信息&lt;/li&gt;
&lt;li&gt;返回信息和返回头部信息&lt;/li&gt;
&lt;li&gt;返回头部校验规则&lt;/li&gt;
&lt;li&gt;返回结果校验规则&lt;/li&gt;
&lt;li&gt;实际返回&lt;/li&gt;
&lt;li&gt;如果测试失败，会显示 失败原因信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/Fmoz0KPwATN9SCM48hYrWTHv0rVI&quot; alt=&quot;image (12).png&quot;/&gt;&lt;br/&gt;执行单例列表操作按钮-测试后的测试报告&lt;/p&gt;
&lt;h3 id=&quot;定时执行&quot;&gt;3. 定时执行&lt;/h3&gt;
&lt;p&gt;回顾前面说的：如果你想指定一批测试用例脚本在你设定的时间自动跑，并把测试结果发送到你指定的邮箱，这个需要升级到企业版本才能用，如果你已经拥有企业版本，你可以打开  &lt;strong&gt;定时任务&lt;/strong&gt; 页面先行查看。&lt;/p&gt;
&lt;p&gt;定时执行，我们可以添加测试用例在指定的时间执行，并把测试结果发送到你指定的邮箱。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/FlmuqX14jD-W4rqEBEsB-zaIN-j1&quot; alt=&quot;wechat定时任务1.gif&quot;/&gt;&lt;br/&gt;定时执行测试用例&lt;/p&gt;
&lt;h3 id=&quot;测试报告下载&quot;&gt;4. 测试报告下载&lt;/h3&gt;
&lt;p&gt;在用例集页面，执行测试全部后，点 &lt;strong&gt;【下载测试报告】&lt;/strong&gt; ，下载自己要下的报告，报告格式是 HTML 的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/FgJa4vw6M57vuVhW7CgzX6CVPARm&quot; alt=&quot;cnodejs下载.jpg&quot;/&gt;&lt;br/&gt;下载测试报告&lt;/p&gt;
&lt;h2 id=&quot;人员协作&quot;&gt;2.人员协作&lt;/h2&gt;
&lt;p&gt;人员协作适用于多人协作的工作模式，这个时候需要对不同的角色分配不同的权限进行管理。&lt;/p&gt;
&lt;h3 id=&quot;免费版这里我们可以设置只读-读写-项目负责人等权限&quot;&gt;1.免费版：这里我们可以设置只读/ 读写/ 项目负责人等权限&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;只读：只能查看项目内容，不可编辑。&lt;/li&gt;
&lt;li&gt;读写：可以查看项目内容，可以编辑。&lt;/li&gt;
&lt;li&gt;项目负责人：可以可以查看项目内容，可以编辑，可以对人员权限进行管理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/FrSOOeJa9F3s-aFq4vD_HnFlNDb8&quot; alt=&quot;添加协作人员.gif&quot;/&gt;&lt;br/&gt;免费版添加协作人员&lt;/p&gt;
&lt;h3 id=&quot;企业版在这个版本里我们可以对所有成员进行自定义角色的权限分配&quot;&gt;2.企业版：在这个版本里，我们可以对所有成员进行自定义角色的权限分配&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://static.cnodejs.org/FqdEu4tvBZ4xKUh68QjbCmM2Ir8n&quot; alt=&quot;image (13).png&quot;/&gt;&lt;br/&gt;企业版，自定义角色&lt;/p&gt;
&lt;h2 id=&quot;本文总结&quot;&gt;本文总结&lt;/h2&gt;
&lt;p&gt;本文主要是介绍怎么用 EOLINKER 执行测试脚本和如何获取测试报告，以及如何进行多人的协作，结合上篇文章介绍的如何设计项目目录结构，如何编写接口测试脚本，统一起来就构成了一个完整的接口测试项目架构。简而言之，EOLINKER 在手，测试不愁。&lt;/p&gt;
</description>
<pubDate>Thu, 29 Nov 2018 06:51:00 +0000</pubDate>
<dc:creator>隔壁王书</dc:creator>
<og:description>本文为 《使用 EOLINKER 进行接口测试的最佳路径》 下半部分文章，主要介绍测试脚本如何执行和报告生成，以及测试项目人员如何协作。还没看过上篇文章请戳</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dc20181010/p/10038307.html</dc:identifier>
</item>
<item>
<title>PC逆向之代码还原技术,第六讲汇编中除法代码还原以及原理第一讲,除数是2的幂 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/10038308.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/10038308.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;一丶除法简介&quot;&gt;一丶除法简介&lt;/h2&gt;
&lt;p&gt;除法,在汇编中是 DIV 指令 跟 IDIV指令,跟乘法一样.指令周期时间长.所以也必须进行优化.&lt;br/&gt;但是除法的优化有很多原理.也就是很复杂. 逆向工作人员.也要搞清楚除法才算是真正的入了逆向的的小门.&lt;br/&gt;除法搞不定.以后代码还原.等等.自己根本还原不了.有人说 可以使用IDA静态分析工具. F5插件. 我可以告诉你&lt;br/&gt;F5搞不定除法的.会给你还原的乱七八糟.还不如看汇编.所以这也是我们必须搞定的.&lt;/p&gt;
&lt;h2 id=&quot;二丶简介除法原理&quot;&gt;二丶简介除法原理&lt;/h2&gt;
&lt;p&gt;除法原理是由数学上来决定的.也就是说.优化是按照数学公式来定的.这也早就了.不管你是VC6.0写的程序&lt;br/&gt;还是VS2017等更高版本写的程序.都不会有很大变化.原因是.这种优化已经是最优的优化了.除非数学上有很大&lt;br/&gt;变动.(不可能的.如果有就是数学界的一大震动)否则不会改变的.还有一种情况就是.CPU越来越好.优化的时候&lt;br/&gt;使用了新指令了. 新指令进行优化.不过占很小一部分.因为如果都是新指令优化.那么这个程序就没法兼容以前系统了&lt;/p&gt;
&lt;h3 id=&quot;搞明白数学中的向上取整-向下取整.-以及程序中的向零取整.&quot;&gt;1.搞明白数学中的向上取整 向下取整. 以及程序中的向零取整.&lt;/h3&gt;
&lt;p&gt;首先画出一个坐标系,如下:&lt;/p&gt;
&lt;p&gt;-∞ 0 +∞&lt;br/&gt;&amp;lt;-------------*------------------&amp;gt;&lt;br/&gt;向下取整:&lt;br/&gt;向下取整就是往负无穷方向接近 x的数值. 不大于x的最大整数. 例如x为3.5 那么往负无穷接近,不大于&lt;br/&gt;3.5的最大整数是多少. 是3.&lt;br/&gt;-3.5向下取整就是-4 向上取整就是-3&lt;br/&gt;在C语言中是 floor函数. 向下取整也称为地板取整&lt;/p&gt;
&lt;p&gt;向上取整:&lt;br/&gt;向上取整就是往正无穷接近 x的数值. 不小于x的最大整数. 例如3.5 向上取整就是4&lt;br/&gt;向上取整在C语言中是ceil()函数.也成为天花板取整&lt;br/&gt;向零取整:&lt;br/&gt;向零取整就很简单了.可以理解为 正数是向下取整, 负数是向上取整.反正靠近0就可以.&lt;br/&gt;向零取整是计算机整数除法规定的.计算机会使用这种除法.也称为截断除法.&lt;br/&gt;疑问?&lt;br/&gt;为什么要学习取整.虽说取整很简单.原因是在计算机中.除法都是向零取整的除法.&lt;br/&gt;例如我们上面说过的向下取整. 假设: a为被除数 b为除数 那么&lt;/p&gt;
&lt;p&gt;公式: ⌊-a/b⌋ ≠ -⌊a/b⌋&lt;br/&gt;我们可以带入计算:&lt;br/&gt;-7 / 2 = -3.5 向下取整 = -4&lt;br/&gt;-⌊7/2⌋ = -3 首先计算出 7 / 2 = 3.5 向下取整则是3 外面有个负号 所以是-3&lt;/p&gt;
&lt;p&gt;向上取整问题:&lt;br/&gt;向上取整是一样的.结果也是不一样.&lt;br/&gt;公式: ⌈-a/b⌉ ≠ -⌈a/b⌉&lt;br/&gt;一样代入&lt;br/&gt;⌈-7/2⌉ = -3&lt;br/&gt;-⌈7/2⌉ = -4&lt;br/&gt;向零取整:&lt;br/&gt;计算机中的除法就是整数除法,就是向零取整.&lt;br/&gt;[-a / b] = [a / -b] = -[a / b]&lt;br/&gt;我们可以代入公式:&lt;br/&gt;[-7 / 2] = -3&lt;br/&gt;[7 / -2] = -3&lt;br/&gt;-[7 / 2] = -3&lt;br/&gt;所以三个公式是一样的.&lt;br/&gt;所以必须要了解取整.&lt;/p&gt;
&lt;h3 id=&quot;除法的扩展知识&quot;&gt;2.除法的扩展知识&lt;/h3&gt;
&lt;p&gt;除法的扩展知识:&lt;/p&gt;
&lt;p&gt;　　在整数的除法中,只有能整除和不能整除的两种情况则会产生余数.&lt;/p&gt;
&lt;p&gt;设 a = 被除数 b = 除数 c = 商 r = 余数&lt;/p&gt;
&lt;p&gt;那么可以得到下面的公式:&lt;/p&gt;
&lt;p&gt;除法原型:&lt;/p&gt;
&lt;p&gt;a / b = c .... r&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;6  / 4 = 1 ...2&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;|r| &amp;lt; |b| 　　　　: 余数的绝对值,绝对会小于除数的. 比如 6 / 4 = 1 .... 2 那么 余数2 不关是正数还是负数,绝对都是绝对会小于除数的,也就是4&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;a = q * b + r 　　　 : 求被除数,被除数是商*除数+余数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;b = (a - r)/c　　　 : 求除数,除数等于 被除数-余数 / 商&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;q = (a - r)/b　　　　 : 求商: 被除数 - 余数 / 除数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;r = a - (q * b) : 求余数 被除数 - (商 * 除数)&lt;br/&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;h2 id=&quot;三丶除法的代码还原.&quot;&gt;三丶除法的代码还原.&lt;/h2&gt;
&lt;p&gt;有了以上的公式支撑.那么我们则可以进行除法的代码还原的学习了.&lt;/p&gt;
&lt;h3 id=&quot;除数为2的一次方&quot;&gt;1.除数为2的一次方&lt;/h3&gt;
高级代码:&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;
int main(int argc, char* argv[])
{

    int nValue = 10;
    scanf(&quot;%d&quot;,&amp;amp;nValue); //防止变量nValue优化成常量. 所以不让他优化

    int nTemp = nValue / 2; //常量是2的一次方  重要代码

    scanf(&quot;%d&quot;,&amp;amp;nTemp);//防止优化
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Debug下的汇编&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.text:00401280                 mov     eax, [ebp+var_4]
.text:00401283                 cdq
.text:00401284                 sub     eax, edx           重要代码
.text:00401286                 sar     eax, 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实如果是2的1次方,Debug跟Release下.都会产生代码定式.&lt;/p&gt;
&lt;p&gt;代码定式:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   mov reg,[ebp - ?];  获得被除数  reg存放的是被除数的值
   cdq                 符号扩展. 被除数是负数,那么 扩展符号位之后 edx = 0xFFFFFFFF 也就是-1 否则就是0
   sub eax,edx         调整符号位,被除数是正数,那么此条语句执行完相当于没制定. 被除数是负数. 则会形成  (被除数 - 1) 因为是负数.所以被除数是补码形式存在
   sar eax,1           sar相当于向下取整. sar是有符号右移,右移一位就是 / 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码定式可以进行总结:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   mov eax,[ebp - ?]
   cdq
   sub eax,edx
   sar eax, B&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还原方法:&lt;br/&gt;除数的还原 = 2^b次方&lt;br/&gt;被除数的还原: = 被除数就是eax 如果是补码,则是负数. 且cdq之后 edx肯定是 0xFF... 也就是-1&lt;br/&gt;还原原理:&lt;br/&gt;设a 是被除数&lt;br/&gt;设b 是除数&lt;br/&gt;则有下面公式:&lt;br/&gt;b &amp;gt; 0 则有下面公式&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201811/1197364-20181128164431694-1199614812.png&quot;/&gt;&lt;br/&gt;b &amp;lt; 0 则有下面的公式&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201811/1197364-20181128164511696-916283189.png&quot;/&gt;&lt;br/&gt;关于证明我就不说了.具体可以看下 钱林松的 &amp;lt;&amp;lt;C++反汇编与逆向分析技术揭秘&amp;gt;&amp;gt;这本书.&lt;br/&gt;有了以上公式,那么上面的汇编代码则能看明白了.&lt;br/&gt;假设:&lt;br/&gt;7 / 2 = 3..1 这个是数学上的公式.&lt;br/&gt;7 / 2 = 3 这个是计算机中的整数除法.向零取整.&lt;br/&gt;根据以上公式, b &amp;gt; 0. b是除数. 也就是2, 它的大于0的. 所以我们使用第一条公式.&lt;/p&gt;
&lt;p&gt;向下取整(a / b) = 向上取整 ( (a - b + 1) / b); 或者使用&lt;br/&gt;向上取整(a / b) = 向下取整 ((a + b -1) / b);&lt;br/&gt;带入公式可以得出:&lt;/p&gt;
&lt;p&gt;向上取整((7 - 2 + 1) / 2) = 3; 结果就是对的.&lt;br/&gt;向下取整((7 + 2 - 1) / 2) = 3; 结果也是对的.&lt;br/&gt;那么汇编定力我们就能看明白.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   mov eax,[ebp - ?]
   cdq                   
   sub eax,edx              调整商,被除数是负数.那么商也是负数.
   sar eax, n               向下取整&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代入公式:&lt;/p&gt;
&lt;p&gt;向下取整((eax + eax - edx(-1 or 0)) / 2^n)&lt;br/&gt;b &amp;gt; 0,那么使用第一条公式即可. 被除数是正数. 那么edx就是0&lt;/p&gt;
&lt;p&gt;向下取整((10 + 2^n - 0) / 2^1)&lt;br/&gt;= (10 + 2 - 0) / 2&lt;br/&gt;= 12 / 2&lt;br/&gt;= 6&lt;br/&gt;= 向下取整(6)&lt;br/&gt;= 5 商&lt;br/&gt;所以不懂公式,那么直接进行最笨的方法,记下来.怎么还原即可.&lt;/p&gt;
&lt;p&gt;总结:&lt;br/&gt;除数为2的一次方&lt;br/&gt;汇编定式:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   mov eax,[ebp - ?]
   cdq
   sub eax,edx
   sar eax, n&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还原方法: a + b - 1 (-1 or 0)&lt;/p&gt;
&lt;p&gt;向下取整(eax + 2^n - edx) / 2^n) 根据公式还原.&lt;/p&gt;
&lt;p&gt;不使用公式:&lt;/p&gt;
&lt;p&gt;除数: 2^n&lt;br/&gt;被除数: eax&lt;br/&gt;商:&lt;br/&gt;被除数为正:&lt;br/&gt;eax / 2^n&lt;br/&gt;被除数为负数:&lt;br/&gt;(eax -1) / 2^n次方.&lt;/p&gt;
&lt;h3 id=&quot;除数为2的幂&quot;&gt;2.除数为2的幂&lt;/h3&gt;
&lt;p&gt;高级代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int main(int argc, char* argv[])
{
    int nValue = 16;
    scanf(&quot;%d&quot;,&amp;amp;nValue);// 防止优化.核心代码不是这个

    int nTemp = nValue / 8;  //核心代码 一会观看反汇编

    scanf(&quot;%d&quot;,&amp;amp;nTemp); //防止优化
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Debug下的汇编跟Release汇编一样,Release有流水线优化代码.去掉则会跟Debug下汇编一样.&lt;br/&gt;产生以下汇编代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.text:00401040                 mov     eax, [ebp+var_4]    获得被除数
.text:00401043                 cdq                         符号扩展 eax,edx 被除数为正, edx = 0, 否则 edx = -1
.text:00401044                 and     edx, 7              位与运算.被除数为正数,此条指令没用,因为edx = 0. 0 &amp;amp; 7还是0 被除数为负数 edx结果为7
.text:00401047                 add     eax, edx            (eax + edx)/2^n edx = 0 则被除数是0   edx = -1 则被除数是负数. 且公式会有改变  (eax + 7) / 2^n
.text:00401049                 sar     eax, 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们观看这个代码可以产生代码定式:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.text:00401040                 mov     eax, [ebp+var_4]    
.text:00401043                 cdq                         
.text:00401044                 and     edx, b            
.text:00401047                 add     eax, edx            
.text:00401049                 sar     eax, n&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除数的还原: (2^n - 1) == b 那么被除数就是2^n次方&lt;br/&gt;主要是还原除数.&lt;br/&gt;被除数就是eax,判断正负看是否是补码就可以.&lt;/p&gt;
&lt;h2 id=&quot;四丶除法第一讲总结&quot;&gt;四丶除法第一讲总结&lt;/h2&gt;
&lt;p&gt;今天主要就是讲了两个除法的还原.除法很多.但是鉴于篇幅.一个博客只更新两个.便于以后复习,也便于&lt;br/&gt;自己的理解.&lt;/p&gt;
&lt;h3 id=&quot;除数是2的一次方&quot;&gt;1.除数是2的一次方&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;   mov eax,[ebp - ?]
   cdq
   sub eax,edx
   sar eax, n&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除数进行还原: 2^n&lt;br/&gt;被除数: eax eax是补码,则商为负,则 sub eax,edx会执行. 被除数为负数 edx = -1 正数为0&lt;br/&gt;sub eax,edx也是判断被除数是否为正负数.而进行的无分支优化.&lt;br/&gt;除法原理:&lt;br/&gt;b &amp;gt; 0 也就是除数大于0&lt;br/&gt;使用公式:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201811/1197364-20181128164431694-1199614812.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果代入公式则是: 向下取整((eax + 2^n - edx) / 2^n) 或者使用 向上取整((a - 2^n + edx) / 2^n);&lt;/p&gt;
&lt;p&gt;b &amp;lt; 0 则有下面的公式&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1197364/201811/1197364-20181128164511696-916283189.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;除数为2的幂总结&quot;&gt;2.除数为2的幂总结:&lt;/h3&gt;
&lt;p&gt;代码定式:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.text:00401040                 mov     eax, [ebp+var_4]    
.text:00401043                 cdq                         
.text:00401044                 and     edx, b            
.text:00401047                 add     eax, edx            
.text:00401049                 sar     eax, n&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除数的还原: 如果: (2^n - 1) == b 那么被除数就是2^n次方&lt;br/&gt;主要是还原除数.&lt;br/&gt;被除数就是eax,判断正负看是否是补码就可以.&lt;/p&gt;
</description>
<pubDate>Thu, 29 Nov 2018 06:51:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<og:description>[toc] 一丶除法简介 除法,在汇编中是 DIV 指令 跟 IDIV指令,跟乘法一样.指令周期时间长.所以也必须进行优化. 但是除法的优化有很多原理.也就是很复杂. 逆向工作人员.也要搞清楚除法才算</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/10038308.html</dc:identifier>
</item>
</channel>
</rss>