<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>学好数据结构和算法 —— 线性表 - Mr.yang.localhost</title>
<link>http://www.cnblogs.com/mr-yang-localhost/p/9863897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mr-yang-localhost/p/9863897.html</guid>
<description>&lt;h2&gt;线性表&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;线性表表示一种线性结构的数据结构，顾名思义就是数据排成像一条线一样的结构，每个线性表上的数据只有前和后两个方向。比如：数组、链表、栈和队列都是线性表，今天我们分别来看看这些线性数据结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181031234032119-804718253.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;数组&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;数组是一种线性表数据结构，用&lt;span&gt;一组连续的内存空间来存储一组具有相同类型&lt;/span&gt;的数据。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存分布：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181103171856139-305193903.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;随机访问&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;连续内存空间存储相同类型的数据，这个特性支持了数组的随机访问特性，相同类型的数据占用的空间是固定的假设为data_size，第n个元素的地址可以根据公式计算出来：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;amp;a[n] = $a[0] + n * data_size&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;其中：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;amp;a[n]：第n个元素的地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a[0]：第0个元素的地址（数组的地址）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;data_size：数组存储的元素的类型大小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以访问数组里指定下标的任何一个元素，都可以直接访问对应的地址，不需要遍历数组，时间复杂度为O(1)。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;插入/删除低效&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;为了保证内存的连续性，插入或删除数据时如果不是在数组末尾操作，就需要做数据的搬移工作，数据搬移会使得数组插入和删除时候效率低下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;向数组里插入一个元素有三种情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、向末尾插入一个元素，此时的时间复杂度为O(1)，对应最好时间复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、向数组开头插入一个元素，需要将所有元素依次向后挪一个位置，然后将元素插入开头位置，此时时间复杂度为O(n)，对应最坏时间复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、向数组中间位置插入一个元素，此时每个位置插入元素的概率都是一样的为1/n，平均复杂度为（1+2+3+…+n）/n = O(n)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果数组元素是没有顺序的（或不需要保证元素顺序），向数组中间位置插入一个元素x，只需要将插入位置的元素放到数组的末尾，然后将x插入，这时候不需要搬移元素，时间复杂度仍为O(1)，如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181102085059550-1166474746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样地，删除数据的时候，从开头删除，需要将后面n-1个元素往前搬移，对应的时间复杂度为O(n)；从末尾删除时间复杂度为O(1)；平均时间复杂度也是O(n)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果不需要保证数据的连续性，有两种方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、可以将末尾的数据搬移到删除点插入，删除末尾那个元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、删除的时候做标记，并不正真删除，等数组空间不够的时候，再进行批量删除搬移操作&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;Java的ArrayList&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　很多编程语言都针对数组进行了封装，比如Java的ArrayList，可以将数组的很多操作细节封装起来（插入删除的搬移数据或动态扩容），可以参考ArrayList的扩容数据搬移方法，ArrayList默认size是10，如果空间不够了会先按1.5倍扩容（如果还不够就可能会用到最大容量）。所以在使用的时候如果事先知道数组的大小，可以一次性申请，这样可以免去自动扩容的性能损耗。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么时候选择使用编程语言帮我们封装的数组，什么时候直接使用数组呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、Java ArrayList不支持基本数据类型，需要封装为Integer、Long类才能使用。Autoboxing、Unboxing有一定的性能消耗。如果比较关注性能可以直接使用数组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、使用前已经能确认数据大小，并且操作比较简单可以使用数组&lt;/p&gt;
&lt;h2&gt;链表&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;比起数组，链表不需要连续内存空间，它通过指针将一组分别独立的内存空间串起来形成一条“链条”。&lt;span&gt;链表有很多种，如：单链表、双向链表、循环链表和双向循环链表。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　链表内存分布：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181103173637667-485639833.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;单链表&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如下图所示，链表的每一项我们称为&lt;span&gt;&lt;strong&gt;结点（node）&lt;/strong&gt;&lt;/span&gt;，为了将所有结点连接起来形成链表，结点除了需要记录数据之外，还需要记录下一个结点的地址，记录下一个结点地址的指针我们叫做&lt;strong&gt;&lt;span&gt;后继指针（next）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;，第一个结点和最后一个结点比较特殊，第一个结点没有next指针指向它，称为&lt;span&gt;&lt;strong&gt;头结点&lt;/strong&gt;&lt;/span&gt;，最后一个结点next指针没有指向任何元素，称为&lt;span&gt;&lt;strong&gt;尾结点&lt;/strong&gt;&lt;span&gt;。头结点用来记录链表的基地址，有了它就可以顺着链子往下搜索每一个元素，如果遇到next指向null表示到达了链表的末尾。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181103172917032-1019525493.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在数组里插入或删除数据需要保证内存空间的连续性，需要做数据的搬移，但是链表里数据内存空间是独立的，插入删除只需要改变指针指向即可，所以链表的插入删除非常高效。如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181103173350117-164120734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;双向链表&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;单向链表每个结点只知道自己下一个结点是谁，是一条单向的“链条”，而在双向链表里每个结点既知道下一个结点，还知道前一个结点，相比单链表，双向链表每个结点多了一个前驱指针（prev）指向前一个结点的地址，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181103174105179-2139583123.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为每个结点要额外的空间来保存前驱结点的地址，所以相同数据情况下，双向链表比单链表占用的空间更多。双向链表在找前驱结点时间复杂度为O(1)，插入删除都比单链表高效，典型的空间换时间的例子。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;循环链表&lt;/h3&gt;
&lt;p&gt;　　将一个单链表首尾相连就形成了一个环，这就是循环链表，循环链表里尾结点不在是null，而是指向头结点。当数据具有环形结构时候就可以使用循环链表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181104093821053-1725884755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;双向循环链表&lt;/h3&gt;
&lt;p&gt;　　与循环链表类似，尾结点指向头结点，同时每个结点除了保存自身数据，分别有一个前驱指针和后继指针，就形成了双向循环链表：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181104093054232-2123621829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;插入/删除比较&lt;/h3&gt;
&lt;h4&gt;在链表里插入数据(new_node)&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1、在P结点后插入数据&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
new_node-&amp;gt;next = p-&amp;gt;&lt;span&gt;next;
p&lt;/span&gt;-&amp;gt;next = new_node
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;此时时间复杂度为O(1)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、在P结点前插入数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要找到P结点的前驱结点，然后转化为在P的前驱结点之后插入数据。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;单链表需要从头遍历，当满足条件 pre-&amp;gt;next = p时，转化为再pre结点后插入数据，此时时间复杂度为O(n)遍；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;双链表只需要通过p-&amp;gt;pre即可找到前驱结点，时间复杂度为O(1)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、在值等于某个值的结点前/后插入数据&lt;/p&gt;
&lt;p&gt;需要遍历整个链表，找到这个值，然后在它前/后插入数据，此时时间复杂度为O(n)&lt;/p&gt;
&lt;h4&gt;在链表里删除数据&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;1、删除P结点下一个结点&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
p-&amp;gt;next = p-&amp;gt;next-&amp;gt;next;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接将p后继结点指针指向p下下一个结点。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、删除P结点前一个结点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;找到P结点前驱结点的前驱结点N，然后转化为删除N的后继结点&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;单链表需要遍历找到结点N，遍历时间复杂度为O(n)，然后删除N的一个后继结点，时间复杂度为O(1)，所以总的时间复杂度为O(n)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;双向链表直接找到结点N：p-&amp;gt;pre-&amp;gt;pre-&amp;gt;next = p，时间复杂度为O(1)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;3、在值等于某个值的结点前/后删除数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要遍历整个链表，找到这个值，然后在它前/后删除数据，此时时间复杂度为O(n)&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;栈&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;栈是一种后进者先出，先进者后出的线性数据结构，只允许在一端插入/删除数据。栈可以用数组来实现，也可以用链表来实现，用数组实现的叫顺序栈，用链表来实现是叫链式栈。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;栈的数组实现&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;数组来实现栈，插入和删除都发生在数组的末尾，所以不需要进行数据的搬移，但是如果发生内存不够需要进行扩容的时候，仍然需要进行数据搬移&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('44e3f223-dea5-4e2d-b4e9-bf9af75c9c96')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_44e3f223-dea5-4e2d-b4e9-bf9af75c9c96&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_44e3f223-dea5-4e2d-b4e9-bf9af75c9c96&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('44e3f223-dea5-4e2d-b4e9-bf9af75c9c96',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_44e3f223-dea5-4e2d-b4e9-bf9af75c9c96&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testStack() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         StringStack stack = &lt;span&gt;new&lt;/span&gt; StringStack(10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             stack.push(&quot;hello&quot; +&lt;span&gt; i);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(stack.push(&quot;dd&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         String item = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; ((item = stack.pop()) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            System.out.println(item);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StringStack {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String[] items;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; StringStack(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.items = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[n];
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.count = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.size =&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; push(String item) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.count == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.size) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.items[count++] =&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String pop() {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.count == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.items[--&lt;span&gt;count];
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getCount() {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getSize() {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;栈的链表实现&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;链表的实现有个小技巧，倒着创建一个链表来模拟栈结构，最后添加到链表的元素作为链表的头结点，如图：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181104175907294-1272057019.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('22587ee0-048b-4d0f-8d35-7398f83a1293')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_22587ee0-048b-4d0f-8d35-7398f83a1293&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_22587ee0-048b-4d0f-8d35-7398f83a1293&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('22587ee0-048b-4d0f-8d35-7398f83a1293',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_22587ee0-048b-4d0f-8d35-7398f83a1293&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LinkStack {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node top;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; push(String item) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Node node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(item);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(top == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             top =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         node.next =&lt;span&gt; top;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         top =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String pop() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (top == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         String name =&lt;span&gt; top.getName();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         top =&lt;span&gt; top.next;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node next;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node(String name) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;数组实现的是一个固定大小的栈，当内存不够的时候，可以按照数组扩容方式实现栈的扩容，或是依赖于动态扩容的封装结构来实现栈的动态扩容。出栈的时间复杂度都是O(1)，入栈会有不同，如果是数组实现栈需要扩容，最好时间复杂度（不需要扩容的时候）是O(1)，最坏时间复杂度是O(n)，插入数据的时候，栈刚好满了需要进行扩容，假设扩容为原来的两倍，此时时间复杂度是O(n)，每n次时间复杂度为O(1)夹杂着一次时间复杂度为O(n)的扩容，那么均摊时间复杂度就是O(1)。&lt;/p&gt;
&lt;h3&gt;栈的应用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;函数调用栈&lt;/li&gt;
&lt;li&gt;java的拦截器&lt;/li&gt;
&lt;li&gt;表达式求解&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;队列&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;队列与栈类似，支持的操作也很相似，不过队列是先进先出的线性数据结构。日常生活中常常需要进行的排队就是队列，排在前面的人优先。队列支持两个操作：入队 enqueue 从队尾添加一个元素；出队 dequeue 从对列头部取一个元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和栈一样，队列也有顺序队列和链式队列分别对应数组实现的队列和链表实现的队列。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;数组实现队列&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;数组实现的队列是固定大小的队列，当队列内存不足时候，统一搬移数据整理内存。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('faed0325-c476-4c1b-b9f9-44462aab1f76')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_faed0325-c476-4c1b-b9f9-44462aab1f76&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_faed0325-c476-4c1b-b9f9-44462aab1f76&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('faed0325-c476-4c1b-b9f9-44462aab1f76',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_faed0325-c476-4c1b-b9f9-44462aab1f76&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ArrayQueue {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String[] items;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; head = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tail = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ArrayQueue(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.items = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[n];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.capacity =&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * 入队列（从队列尾部入）
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; enqueue(String item) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列满了&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.tail == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.capacity) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对列头部不在起始位置&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.head == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;搬移数据&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = head; i &amp;lt; tail; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 items[i - head] =&lt;span&gt; items[i];
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.tail = tail -&lt;span&gt; head;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.head = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         items[tail++] =&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;     * 出队列（从队列头部出）
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String dequeue() {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.head == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tail) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.items[head++&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;链表实现队列&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;链表尾部入队，从头部出队，如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181104180404960-1318024913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c9eeea3b-60ab-4afd-9fb1-bbcf76ab734c')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_c9eeea3b-60ab-4afd-9fb1-bbcf76ab734c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c9eeea3b-60ab-4afd-9fb1-bbcf76ab734c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c9eeea3b-60ab-4afd-9fb1-bbcf76ab734c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c9eeea3b-60ab-4afd-9fb1-bbcf76ab734c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LinkQueue {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node head;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node tail;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LinkQueue() { }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * 入队列
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; enqueue(String item) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         Node node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(item);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列为空&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.tail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.tail =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.head =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.tail.next =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.tail =&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;     * 出队列
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String dequeue() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列为空&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.head == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         String name = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.head.getName();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.head = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.head.next;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.head == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.tail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Node {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node next;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Node(String name) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;循环队列&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;数组实现队列时，当队列满了，头部出队时候，会发生数据搬移，但是如果是一个首尾相连的环形结构，如下图，头部有空间，尾部到达7位置，再添加元素时候，tail到达环形的第一个位置（下标为0）不需要搬移数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201811/1042079-20181104231210577-1676306683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为空的判定条件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;head = tail&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;队列满了的判定条件：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;当head = 0，tail = 7&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当head = 1，tail = 0&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当head = 4，tail = 3&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;head = （tail + 1）% 8&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3baa9454-9827-4e55-b59d-e84099f1724e')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_3baa9454-9827-4e55-b59d-e84099f1724e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3baa9454-9827-4e55-b59d-e84099f1724e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3baa9454-9827-4e55-b59d-e84099f1724e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3baa9454-9827-4e55-b59d-e84099f1724e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CircleQueue {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String[] items;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; head = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tail = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; CircleQueue(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.items = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[n];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.capacity =&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * 入队列（从队列尾部入）
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; enqueue(String item) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列满了&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.head == (&lt;span&gt;this&lt;/span&gt;.tail + 1)% &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.capacity) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         items[tail] =&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         tail = (tail + 1) % &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.capacity;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     * 出队列（从队列头部出）
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String dequeue() {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列为空&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.head == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tail) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         String item = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.items[head];
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         head = (head + 1) % &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.capacity;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img id=&quot;code_img_opened_8fec87a3-e41f-453c-b79b-237594b17ead&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('8fec87a3-e41f-453c-b79b-237594b17ead',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div id=&quot;cnblogs_code_open_8fec87a3-e41f-453c-b79b-237594b17ead&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CircleQueue {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String[] items;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; head = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tail = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; CircleQueue(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.items = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String[n];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.capacity =&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * 入队列（从队列尾部入）
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; item
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; enqueue(String item) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列满了&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.head == (&lt;span&gt;this&lt;/span&gt;.tail + 1)% &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.capacity) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         items[tail++] =&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     * 出队列（从队列头部出）
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String dequeue() {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列为空&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.head == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tail) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.items[head++&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;阻塞队列&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;阻塞队列是指当头部没有元素的时候（对应队列为空），出队会阻塞直到有元素为止；或者队列满了，尾部不能再插入数据，直到有空闲位置了再插入。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;并发队列&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;线程安全的队列叫并发队列。dequeue和enqueue加锁或者使用CAS实现高效的并发。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 04 Nov 2018 15:40:00 +0000</pubDate>
<dc:creator>Mr.yang.localhost</dc:creator>
<og:description>线性表 线性表表示一种线性结构的数据结构，顾名思义就是数据排成像一条线一样的结构，每个线性表上的数据只有前和后两个方向。比如：数组、链表、栈和队列都是线性表，今天我们分别来看看这些线性数据结构。 数组</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mr-yang-localhost/p/9863897.html</dc:identifier>
</item>
<item>
<title>Paxos算法——前世 - 宁静方能致远</title>
<link>http://www.cnblogs.com/qing1376/p/9906631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing1376/p/9906631.html</guid>
<description>&lt;p&gt;    Paxos算法是基于消息传递且具有高度容错特性的一致性算法。我们将从一个简单的问题开始，逐步的改进我们的设计方案，最终得到Paxos，一个可以在逆境下工作的协议。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;一、客户端-服务器模型&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    我们从最小的分布式系统开始，在这个系统中，只有两个结点，客户端结点与服务端结点，客户端结点能够操作（存储或更新）远程服务器结点上的数据。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;算法1.1  朴素的客户端/服务器算法：客户端每次向服务器发送一条命令。&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    在存在消息丢失的消息传递模型中，该算法却不能很好的工作，客户端不能确认消息是否正确的被服务器所接受。因此我们需要对其进行一些小的改进。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;算法1.2 待确认的客户端/服务器算法&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    1.客户端向服务端发送一条请求命令消息。&lt;/p&gt;
&lt;p&gt;    2.服务端接受请求并回复确认信息。&lt;/p&gt;
&lt;p&gt;    3.客户端在一定的时间范围内，没有收到服务器端发送的请求确认信息的回复，则重新发送命令请求信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;该算法描述了，客户端在发送一条请求命令后，在收到服务端的确认回复前，是不会发送下一条请求命令。&lt;/li&gt;
&lt;li&gt;客户端在发送的过程中消息可能丢失，服务端在回复的确认消息时，消息也可能丢失，对于服务端确认消息的丢失情况，在到达一定超时时间后，客户端未收到确认回复，会重新发送消息，此时该消息已经被服务器端处理，所以我们需要有一种机制能够保证消息的幂等性。例如给消息加上序列号。&lt;/li&gt;
&lt;li&gt;该算法可以很容易的扩展到多服务器端的场景，客户端发送命令请求给每一个服务器端，当收到所有服务器的确认消息，就可以认为这条命令执行成功。&lt;/li&gt;
&lt;li&gt;如何处理多个客户端的场景？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    基于可变消息延迟模型我们可以得出如下定理，即消息的延迟时间是不定的，同一对结点的消息发送的时间延迟也是不同的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;定理1.1  如果算法在多个客户端与服务端运行，服务器收到的命令顺序可能是不同的，这会导致不一致的状态。&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;   &lt;/strong&gt;&lt;/em&gt;&lt;strong&gt; &lt;/strong&gt;假设在如下的场景中，存在客户端c1，c2 ，服务端 s1，s2.  服务端s1，s2存在相同的值x = 0。 如果此时 c1，向服务器s1，s2 发送 x = x + 1. 在同一时刻 c2 向服务器 s1，s2 发送 x = 2*x. 假设c1 先于 c2 到达 s1 ，则此时s1的状态值x为 2， 而 c2 先于 c1 到达 s2 ， 则此时 s2 的状态值x为 1. 导致集群的状态不一致。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;定义1.1  （状态复制）对于一组结点，如果所有结点都以相同的顺序执行命令序列 c1，c2，c3，c4……，则这组结点实现了状态复制&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;状态复制是分布式系统的基本特征&lt;/li&gt;
&lt;li&gt;因为单个系统天然实现状态复制，可以令单个服务器系统实现序列化器，自动对请求进行排序来分发命令，从而实现状态复制。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;算法1.3 借助单一的串行化器实现状态复制&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;    1. 所有的客户端将请求命令发送到串行化器&lt;/p&gt;
&lt;p&gt;    2.串行化器逐个处理客户端请求，并将客户端请求逐个发送给所有服务器&lt;/p&gt;
&lt;p&gt;    3.当串行化器接受到所有服务器的确认消息时，它将返回给对应客户端命令执行成功的消息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个想法有时也被成为主从复制。&lt;/li&gt;
&lt;li&gt;改算法存在单点故障。串行化器&lt;/li&gt;
&lt;li&gt;我们是否可以构造一个更分布式的方法来解决状态复制的问题。去掉串行化器。任何时刻最多只有一个结点可以发送请求命令，是否可以采用互斥或各自加锁的思想？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;算法 1.4 两阶段锁&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    阶段 1  ：&lt;/p&gt;
&lt;p&gt;          客户端向所有服务器请求获取锁&lt;/p&gt;
&lt;p&gt;    阶段 2: &lt;/p&gt;
&lt;p&gt;          if   客户端获得所有服务器的加锁请求 &lt;/p&gt;
&lt;p&gt;               客户端以可靠的方式向所有服务器发送命令请求，释放锁&lt;/p&gt;
&lt;p&gt;          else &lt;/p&gt;
&lt;p&gt;               客户端释放已经获取的锁，休眠一段时间，进入阶段 1 &lt;/p&gt;

&lt;ul&gt;&lt;li&gt;算法 1.4 是否能够很好的应对结点崩溃呢？在该算法中要求所有的服务器结点都必须能够正常的工作&lt;/li&gt;
&lt;li&gt;如果仅获取部分服务器的锁能否工作，获得过半数服务器的锁是否就足够了？&lt;/li&gt;
&lt;li&gt;如果超过两个以上的客户端试图获取超过半数服务器的锁，怎么应对死锁的问题，是否需要释放已经获取的服务器锁，如果客户端在释放锁之前就发生了故障，怎么办，是否需要一个与锁不同的概念。&lt;/li&gt;
&lt;/ul&gt;






</description>
<pubDate>Sun, 04 Nov 2018 15:29:00 +0000</pubDate>
<dc:creator>宁静方能致远</dc:creator>
<og:description>Paxos算法是基于消息传递且具有高度容错特性的一致性算法。我们将从一个简单的问题开始，逐步的改进我们的设计方案，最终得到Paxos，一个可以在逆境下工作的协议。 一、客户端-服务器模型 我们从最小的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qing1376/p/9906631.html</dc:identifier>
</item>
<item>
<title>netty源码解解析(4.0)-1 核心架构 - 自带buff</title>
<link>http://www.cnblogs.com/brandonli/p/9906508.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/brandonli/p/9906508.html</guid>
<description>&lt;p&gt;netty是java开源社区的一个优秀的网络框架。使用netty，我们可以迅速地开发出稳定，高性能，安全的，扩展性良好的服务器应用程序。netty封装简化了在服务器开发领域的一些有挑战性的问题：jdk nio的使用；多线程并发；扩展性。它还提供了多种应用层协议的支持：http/https/websock, protobuf, 自定义协议， 简化了服务器协议的开发。&lt;/p&gt;
&lt;p&gt;netty是一个基于事件驱动的框架，它把事件分成两种类型：输入事件(inbound)和输出事件(outbound)， 整个框架都是围绕事件处理进行设计的，以下是netty的核心架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/895062/201811/895062-20181104230105450-843583970.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;上图中涉及到了netty的六个核心对象:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Channel&lt;/strong&gt;: 一个I/O操作的对象，所有的inbound事件都是由Channel产生，outbound事件最终都会有Channel处理(如果outbound事件没有被用户注册的handler丢弃的话)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ChannelPipeline&lt;/strong&gt;: 有一个ChannelPipeline实例属于一个Channel实例，它是事件传播的管道，从Channel实例接收inbound事件，把outbound事件提交给Channel。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ChannelHandlerContext&lt;/strong&gt;: 这是一个双向链表结构，它的多个实例组成了一个双向链表，并有ChannelPipeline负责维护。 在ChannelPipeline的默认实现中，这个链默认添加了Head和Tail节点， Head节点同时实现ChannelOutboundHandler和ChannelInboundHandler接口，Head节点比较特殊，它会最终把事件交给Channel处理。Tail节点实现了ChannelInboundHandler接口，使用Channel触发的inbound事件会首先传到这里处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ChannelHandler&lt;/strong&gt;: 这里是netty的扩展接口，也是真正实现服务器通讯协议和业务功能功能的地方。ChannelHandler有两种类型：处理输入事件的ChannelinboundHandler和处理输出事件的ChannelOutboundHandler。用户的ChannelHandler要实现这两个接口中的任意一个或全部。当用户向ChannelPipeline注册自己的ChannelHandler时，ChannelPipleline会创建一个相应的ChannelHandlerContext实例，并让这个实例持有用户注册的ChannelHandler实例。然后把这个实例添加到双向链表中。用户注册的ChannelHandler的类型决定了这个实例的类型，进而决定了这个实例能够处理的事件类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EventLoopGroup&lt;/strong&gt;: 在Channel上执行I/O的线程组，netty把这个线程组中的线程定义为I/O线程，后面会讲到，有些特定的事件必须在I/O线程中处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EventExecutorGroup&lt;/strong&gt;: 用来执行ChannelHandlerContext和ChannelHandler中回调方法的线程。在用户向ChannelPipeline中注册一个ChannelHanlder时，如果指定了一个EventExecutorGroup，那么它和它对应的ChannelHandlerContext都会在指定的EventExecutorGroup执行，否则，在Channel的EventLoopGroup中执行。&lt;/p&gt;

&lt;p&gt;以上是netty核心架构中的核心核心对象，netty提供的所有能力都是通过对这些核心对象的扩展实现的。例如:&lt;/p&gt;
&lt;p&gt;NioSocketChannel和NioServerSocketChannel扩展了Channel, NioEventLoopGroup扩展了EventLoopGroup, netty通过这一组扩展实现了对JDK NIO的封装。&lt;/p&gt;
&lt;p&gt;ProtoBufDecoer和ProtoBufEncoder扩展ChannelHandler实现了对potobuf协议的支持。&lt;/p&gt;
&lt;p&gt;HttpObjectDecoder和HttpObjectEncoder扩展ChannelHandler实现了对http协议的支持。&lt;/p&gt;
&lt;p&gt;此外开发者还可通过对EventLoopGroup和EventExecutorGroup扩展实现不一样的线程模型，满足特定业务场景的需求。&lt;/p&gt;
&lt;p&gt;还可以对ChannelPipleline和ChannelHandlerContext扩展实现自定义的事件传递和处理流程。&lt;/p&gt;

</description>
<pubDate>Sun, 04 Nov 2018 15:05:00 +0000</pubDate>
<dc:creator>自带buff</dc:creator>
<og:description>netty是java开源社区的一个优秀的网络框架。使用netty，我们可以迅速地开发出稳定，高性能，安全的，扩展性良好的服务器应用程序。netty封装简化了在服务器开发领域的一些有挑战性的问题：jdk</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/brandonli/p/9906508.html</dc:identifier>
</item>
<item>
<title>解开Future的神秘面纱之获取结果 - 猫毛·波拿巴</title>
<link>http://www.cnblogs.com/longfurcat/p/9906437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longfurcat/p/9906437.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在前面的两篇博文中，已经介绍利用FutureTask任务的执行流程，以及利用其实现的cancel方法取消任务的情况。本篇就来介绍下，线程任务的结果获取。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用get方法获取程序运行结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;我们知道利用Future接口的最重要的操作就是要获取任务的结果，而此操作对应的方法就是get。但是问题来了，如果我调用get方法的时候，任务还没有完成呢？答案就是，等它完成，当前线程将被阻塞，直到任务完成（&lt;span&gt;&lt;strong&gt;注意，这里说的完成，指的是任务结束，因为异常而结束也算&lt;/strong&gt;&lt;/span&gt;），get方法返回。主线程（&lt;span&gt;&lt;strong&gt;不是执行任务的线程&lt;/strong&gt;&lt;/span&gt;）才被唤醒，然后继续运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181104194821870-455650189.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;293&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;灵活的get方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;有人可能会问，如果我调用get方法的时候，任务离完成还需要很长时间，那么我主线程不是会浪费一些时间？是的，如果主线程比较忙的话，这样确实主线程的效率。不过还有一个有参的get方法，此方法以等待时长为参数，如果时长结束，任务还没完成，主线程将继续执行，然后会在之后的某个时间再来获取任务结果。（&lt;span&gt;&lt;strong&gt;当然如果主线程依赖这个任务结果才能继续执行，那么只能老老实实地等了&lt;/strong&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181104195310516-642052330.png&quot; alt=&quot;&quot; width=&quot;583&quot; height=&quot;345&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FutureTask的阻塞模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;要想了解get方法的具体实现，必须先弄清楚，它是如何阻塞的。前篇博文已经提到，FutureTask有类型为WaitNode字段waiters，实际上这个waiters引用的是一个以WaitNode为节点的单向链表的头节点。如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181104203628576-1941963329.png&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;waitNode类代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; final &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WaitNode {
    &lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt; Thread thread; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程&lt;/span&gt;
    &lt;span&gt;volatile&lt;/span&gt; WaitNode next; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下一个节点
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数获取当前执行线程的引用&lt;/span&gt;
    WaitNode() { thread =&lt;span&gt; Thread.currentThread(); }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;WaitNode保留线程引用的作用是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;答案是用于任务完成后唤醒等待线程。当FutureTask执行完callable的run方法后，将执行finishCompletion方法通知所有等待线程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; finishCompletion() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历等待节点&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (WaitNode q; (q = waiters) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将FutureTask的waiters引用置null&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (UNSAFE.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;, waitersOffset, q, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) { 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;唤醒所有等待线程&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出节点对应的线程&lt;/span&gt;
                Thread t =&lt;span&gt; q.thread;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    q.thread &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    LockSupport.unpark(t); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;唤醒对应线程&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取下一个节点&lt;/span&gt;
                WaitNode next =&lt;span&gt; q.next;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                q.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; unlink to help gc&lt;/span&gt;
                q =&lt;span&gt; next;
            }
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用钩子函数done，此为空方法，子类可根据需求进行实现&lt;/span&gt;
&lt;span&gt;    done();

    callable &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;       
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;线程的阻塞方式——park和unPark&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　park/unPark也是用于控制线程等待状态的。我们熟悉的，用于控制线程等待状态的还有wait/notify。wait/notify是某个对象的条件队列，要阻塞线程，或者说要加入等待队列，必须先获取对象的锁。&lt;/p&gt;
&lt;p&gt;       与wait()/notify不同的是，park和unpark直接操作线程，无需获取对象的锁，&lt;strong&gt;个人认为&lt;/strong&gt;&lt;span&gt;这是这里使用park/unPark，而不是wait/notifyAll的原因，因为获取锁需要额外的开销&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;get方法的具体实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下是FutureTask中get方法的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; V &lt;span&gt;get&lt;/span&gt;&lt;span&gt;() throws InterruptedException, ExecutionException {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前任务状态&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; state;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是NEW或者COMPLETING，也就是还没有结束，就调用awaitDone进行阻塞&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (s &amp;lt;=&lt;span&gt; COMPLETING)
        s &lt;/span&gt;= awaitDone(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;0L&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意，这里的参数，表示非超时等待，如果任务未结束，程序将一直卡在这里
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果awaitDone返回，也就是任务已经结束，根据任务状态，返回结果&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; report(s);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下是get方法中调用到的awaitDone的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; awaitDone(boolean timed, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nanos) throws InterruptedException {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据超时时间，计算结束时间点&lt;/span&gt;
    final &lt;span&gt;long&lt;/span&gt; deadline = timed ? System.nanoTime() + nanos : &lt;span&gt;0L&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待节点&lt;/span&gt;
    WaitNode q = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否加入等待队列&lt;/span&gt;
    boolean queued = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里并不是通过自旋，使方法无法返回。而是利用自旋CAS, 改变状态。如果成功，一次就够了&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果此线程被中断，把从节点从等待队列中移除&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted()) {
            removeWaiter(q);
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
        }

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; state;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果状态大于COMPLETING，也就是任务已结束，返回任务状态&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (s &amp;gt;&lt;span&gt; COMPLETING) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (q != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                q.thread &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (s == COMPLETING) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; cannot time out yet&lt;/span&gt;
            Thread.&lt;span&gt;yield&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次循环，q是null，创建节点&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (q == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            q &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WaitNode();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果还未加入等待队列，就加入&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;queued)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;q.next = waiters 表达式的返回值 是左侧的值，也就是waiters
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;意思是，如果当前对象的waiters的值是waiters, 就将他赋值为q&lt;/span&gt;
            queued = UNSAFE.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, waitersOffset,
                                                 q.next &lt;/span&gt;=&lt;span&gt; waiters, q); 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是超时等待，则调用parkNanos, 线程将在指定时间后被唤醒&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (timed) {
            nanos &lt;/span&gt;= deadline -&lt;span&gt; System.nanoTime();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nanos &amp;lt;= &lt;span&gt;0L&lt;/span&gt;&lt;span&gt;) {
                removeWaiter(q);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; state;
            }
            LockSupport.parkNanos(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, nanos);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是超时等待，且已经加入等待队列，这时候利用park将当前线程挂起&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            LockSupport.park(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很多人可能会觉得这个循环体，看着有点迷糊，我刚开始也看得头大。但是我们可以根据几种情境，来查看这几种情境下代码的执行情况。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：第二个for循环内，第二个if-else块是一个大块，每次只执行一个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;几种执行情境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、当前线程成功加入等待队列，且被阻塞，一段时间后任务完成，线程被唤醒&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181104221820076-1800432781.png&quot; alt=&quot;&quot; width=&quot;526&quot; height=&quot;443&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、当前线程加入队列后，还没被阻塞，任务就已经完成了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181104221103059-1222612202.png&quot; alt=&quot;&quot; width=&quot;555&quot; height=&quot;366&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、因为其他线程加入等待队列的影响，当前线程未能加入等待队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里说明一下，如果其他线程在此线程之前，比较接近的时间，加入了等待队列，由于内存可见性的原因，当前线程看到的waiters值没有及时改变，故与其实际值不同，CAS操作就将失败。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么一定要CAS成功？&lt;/strong&gt;答案是，如果不成功，出现线程安全问题，链表的结构就会一塌糊涂。这里不细谈。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201811/1313132-20181104222414443-266709163.png&quot; alt=&quot;&quot; width=&quot;509&quot; height=&quot;417&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据任务状态获取结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　我们已经知道，FutureTask有一个Object字段的outcome，也就是任务执行的结果。当任务完成后，会将结果赋值给它。以下是FutureTask的run方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务开始执行后，设置FutureTask的runner字段，指明执行它的线程&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (state != NEW ||!UNSAFE.compareAndSwapObject(&lt;span&gt;this&lt;/span&gt;, runnerOffset,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, Thread.currentThread()))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取具体任务&lt;/span&gt;
        Callable&amp;lt;V&amp;gt; c =&lt;span&gt; callable;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; state ==&lt;span&gt; NEW) {
            V result;
            boolean ran; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;任务是否已被运行完&lt;/span&gt;
            &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;运行任务&lt;/span&gt;
                result =&lt;span&gt; c.call();
                ran &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
                result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果运行任务过程中出现异常，则ran=false 表示没有运行完成&lt;/span&gt;
                ran = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置异常 =&amp;gt; 将任务状态设置为异常，并将异常信息赋值给outcome, 也就是任务结果
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个方法会调用finishCompletion&lt;/span&gt;
&lt;span&gt;                setException(ex);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果运行完成，把结果赋值给outcome&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ran)
                &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;(result); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个方法会调用finishCompletion&lt;/span&gt;
&lt;span&gt;        }
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;既然线程已经&quot;完成&quot;当前任务，就放弃引用，防止影响它执行其他任务&lt;/span&gt;
        runner = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;; 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新获取任务状态&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; state;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;gt;=&lt;span&gt; INTERRUPTING)
            handlePossibleCancellationInterrupt(s);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由前文可知，当任务&quot;完成&quot;的时候，获取结果的线程将被唤醒。回到get方法，它将获取到任务的状态，并根据任务状态获取结果。也就是report方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; V report(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; s) throws ExecutionException {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取结果&lt;/span&gt;
    Object x =&lt;span&gt; outcome;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果任务正常完成&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (s ==&lt;span&gt; NORMAL)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;强制转换为对应类型并返回&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (V)x;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果任务状态为CANCELLED、INTERRUPTING、INTERRUPTED表明是通过cacel方法取消了
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回已取消异常&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (s &amp;gt;=&lt;span&gt; CANCELLED)
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancellationException();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是因为异常中断的话，抛出具体异常信息&lt;/span&gt;
    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExecutionException((Throwable)x);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 04 Nov 2018 14:54:00 +0000</pubDate>
<dc:creator>猫毛&amp;#183;波拿巴</dc:creator>
<og:description>前言 在前面的两篇博文中，已经介绍利用FutureTask任务的执行流程，以及利用其实现的cancel方法取消任务的情况。本篇就来介绍下，线程任务的结果获取。 利用get方法获取程序运行结果 我们知道</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longfurcat/p/9906437.html</dc:identifier>
</item>
<item>
<title>对项目开发流程的思考和小结 - zzzzou</title>
<link>http://www.cnblogs.com/zzzlw/p/9906334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzzlw/p/9906334.html</guid>
<description>&lt;h3 id=&quot;最近在项目开发中遇到的问题&quot;&gt;最近在项目开发中遇到的问题&lt;/h3&gt;
&lt;p&gt;1、对要开发的产品的最终形态没有明确的了解，没有明确的目的性，导致多次返工，重新设计&lt;br/&gt;2、没有明确的开发顺序，开发的模块东一块西一块不流畅不连贯,导致模块之间耦合太高，代码散落多处难以继续开发和维护，&lt;br/&gt;3、没有系统设计结构图，没有区分数据层面、控制层面、业务层面、展示层面、交互层面、界面层面，不能随时了解当下的开发位置和进度，无法预计后续开发的时间和下一个合适的开发位置。&lt;br/&gt;4、代码写的过分冗余，不够优美，主要是因为没有写伪代码来说明一个函数中每一部分的逻辑以及逻辑上下的关系&lt;br/&gt;5、代码写的过分硬编码，不够抽象，当发现要抽象的时候，需要重新修改之前的编码&lt;br/&gt;6、没有考虑数据交互的结构设计，数据结构设计应该单独拎出来作为单独函数封装以便后续扩展&lt;br/&gt;7、花过多的时间在界面设计上，时间浪费在过多的样式调整上。&lt;br/&gt;8、每次编码没有写上测试的内容，开发进度被多次延误，不能保证代码的正确性，基础性的bug过多。&lt;br/&gt;仔细的梳理流程后，大致整理了如下几个步骤。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;第一部分分析和规划设计&quot;&gt;第一部分、分析和规划设计&lt;/h3&gt;
&lt;p&gt;如下2步，需要画图、笔记、文字记录、演算、推理、画流程图、画架构图&lt;/p&gt;
&lt;p&gt;1、选型、明确产品界面、交互设计、功能设计、模块区分，寻找相仿的产品上手体验、操作，感知功能的使用和交互的体验，目的是为了了解即将要做的产品有大致的模型,对产品模型了解的越细致越好&lt;/p&gt;
&lt;p&gt;2、分离架构，对产品从各个维度分离架构，从功能，目录，逻辑拆分，抽象，业务流的明确，数据流的流向，交互体验的设计，从整体拆分成局部，针对每个局部再继续拆分，从局部整合成系统，考虑整体和局部之间的相互影响关系&lt;/p&gt;
&lt;p&gt;循环这2步，最终得到一个产品系统，应该对产品系统非常了解，从整体到局部，从需求到逻辑，端到端的数据流向，交互体验设计，数据库表结构设计&lt;/p&gt;
&lt;h3 id=&quot;第二部分实施&quot;&gt;第二部分、实施&lt;/h3&gt;
&lt;p&gt;3、文档编写，按照系统的各个区域和子系统，编写对应的文档注释，说明此子系统的功能、大致逻辑、含有的接口。&lt;br/&gt;此外，流程应该按照先数据库层面 --&amp;gt; 逻辑控制层面 --&amp;gt; 数据展示层面 --&amp;gt; 交互体验层面 --&amp;gt; 界面设计层面的顺序来规划和思考。&lt;br/&gt;同时考虑扩展性的问题，子系统是否可插拔，组件之间是否强依赖，必要的时候完成架构层面大的抽象。&lt;br/&gt;文档需要大概明确此子系统模块的测试结果是什么，提前演算模块的测试步骤和结果，后续细化的代码必须要通过此测试要求。&lt;/p&gt;
&lt;p&gt;4、明确每一个子系统和组件需要使用到的工具、框架、第三方库、以及重要的语法或者类设计、或者编程技巧、或者设计模式等等。&lt;/p&gt;
&lt;p&gt;5、开发顺序确认，明确这个系统的各个部分的开发顺序，独立的子系统先开发，耦合依赖强烈的系统最后开发，简单的先开发，难的后开发。 规划好开发进度计划。&lt;br/&gt;先开发数据库层面的代码，再开发数据控制层面，再开发数据交互层面，再是数据展示，交互体验设计，界面开发应该放到最后，界面开发最花时间。&lt;/p&gt;
&lt;p&gt;6、伪代码编写，使用中文表达逻辑，加上必要的编程语法混合表达。&lt;br/&gt;伪代码的编写是必须的，而且伪代码要写到可以直接演算出代码结果的程度，即可以通过编写伪代码来几乎100%的确定是否符合模块测试的要求。&lt;br/&gt;伪代码必须要完成数据交互的结构设计&lt;br/&gt;伪代码必须要对函数有明确的定义和解释，可以说明此函数的作用&lt;/p&gt;
&lt;p&gt;7、编码，编码必须符合伪代码的逻辑，编码应该多次测试，慢步前进。&lt;br/&gt;注意编码的版本控制&lt;br/&gt;编码应该尽量保持优美的逻辑和语法使用&lt;br/&gt;编码的变量命名应该特别注意&lt;br/&gt;每一次的编码应该最低按照一个函数单元，即最小编码单位是一个函数，一旦决定编码，就至少完成一个函数单元，或者取消本次函数的编写。&lt;br/&gt;每个函数的完成，都必须要达到伪代码对此函数的定义和解释，注意高内聚和低耦合的问题。&lt;br/&gt;如果没有高内聚，要适当拆分逻辑和代码&lt;br/&gt;如果没有低耦合，要适当抽象代码，合并其他同类函数&lt;/p&gt;
&lt;p&gt;8、代码review，优化代码&lt;/p&gt;
&lt;p&gt;以上每一步，如果出现重大问题和困难，应该向上返回寻找解决方案，因为这些顺序有强烈的依赖性，所以向上找到源头重新设计规划。&lt;br/&gt;也正因为步骤之间的顺序强依赖性，后一步都强烈依赖于前一步，所以前面的步骤必须打好基础，才可以减少返工重新设计和规划的问题。&lt;br/&gt;不是每一步都必须要做到完美，也不是每一个项目都需要使用到每一步，就像PMP一样，是一个套路，需要合理按需使用，但是整体的规划到实施的逻辑是要保证的。&lt;br/&gt;多按照这种套路来完成目的，大部分的事件都在锻炼思考和规划设计能力，编码只是最后实现的一块而已。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;1、开发最小单元应该是一个函数&lt;br/&gt;2、慢步前进，多做测试&lt;br/&gt;3、先有数据，再有逻辑&lt;br/&gt;4、不要花太多时间在界面上&lt;br/&gt;5、伪代码非常重要，必须要写&lt;br/&gt;6、文档注释非常重要，必须要写&lt;br/&gt;7、数据库设计永远是第一步，每次修改、规划设计、增加功能、维护、都首先考虑数据库&lt;br/&gt;所有的代码都围绕着数据库的数据进行设计、开发&lt;br/&gt;8、编码应该是最后的实现手段，应该是最后的环节&lt;br/&gt;9、多思考，少编码，思考的越多，错误越少。&lt;br/&gt;10、适当的冗余和抽象&lt;/p&gt;
</description>
<pubDate>Sun, 04 Nov 2018 14:44:00 +0000</pubDate>
<dc:creator>zzzzou</dc:creator>
<og:description>最近在项目开发中遇到的问题 1、对要开发的产品的最终形态没有明确的了解，没有明确的目的性，导致多次返工，重新设计 2、没有明确的开发顺序，开发的模块东一块西一块不流畅不连贯,导致模块之间耦合太高，代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzzlw/p/9906334.html</dc:identifier>
</item>
<item>
<title>国内开源社区巨作AspectCore-Framework入门 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/9906349.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/9906349.html</guid>
<description>&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;前些天和张队(善友),lemon(浩洋),斌哥(项斌)等MVP大咖一块儿吃饭,大家聊到了lemon名下的AOP这个项目,我这小白听得一脸懵逼,后面回来做了一下功课,查了下资料,在lemon的Github上把这个项目学习了一下,收获颇丰,让我这个没有接触过AOP的Coder叹为观止,陷入了对lemon的深深崇拜,在这里把学习的新的体会分享给大家.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。&lt;/p&gt;
&lt;p&gt;有点深奥, 举个栗子&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224013955-233693881.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224014268-626447140.png&quot; alt=&quot;image&quot; width=&quot;63&quot; height=&quot;48&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果说之前做的一个系统专门给内部的服务提供接口的,因为是在内网中访问,所以就没有加上认证服务,现在这个系统要公开出来,同样的那套接口要给外部系统服务了,那么此时,就要进行认证,认证通过才能获取接口的数据.&lt;/p&gt;
&lt;p&gt;传统的做法是,修改每一个接口.这样就会造成代码改动过大,很恐怖.&lt;/p&gt;

&lt;p&gt;这个时候AOP就可以登场了,我们可以在这一类服务的前面,加上一个一系列上一刀,在切出来的裂缝里面插入认证方法.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224014847-1491667678.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224015171-2119034888.png&quot; alt=&quot;image&quot; width=&quot;604&quot; height=&quot;294&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然而,怎么插入这个切面是关键.AOP 实现会采用一些常见方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用预处理器（如 C++ 中的预处理器）添加源代码。&lt;/li&gt;
&lt;li&gt;使用后处理器在编译后的二进制代码上添加指令。&lt;/li&gt;
&lt;li&gt;使用特殊编译器在编译时添加代码。&lt;/li&gt;
&lt;li&gt;在运行时使用代码拦截器拦截执行并添加所需的代码。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是常见还是后处理和代码拦截两种方式&lt;/p&gt;
&lt;ul readability=&quot;6.6210826210826&quot;&gt;&lt;li readability=&quot;6.8264462809917&quot;&gt;
&lt;p&gt;后处理，或者叫 静态织入&lt;/p&gt;
&lt;p&gt;指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强或静态织入。&lt;/p&gt;
&lt;p&gt;在dotnet 中一般在编译时通过在MSBiuld执行自定义的Build Task来拦截编译过程，在生成的程序集里插入自己的IL。&lt;/p&gt;
&lt;p&gt;dotnet 框架代表： &lt;a href=&quot;https://www.postsharp.net/aop.net&quot;&gt;PostSharp&lt;/a&gt;&lt;/p&gt;

&lt;/li&gt;
&lt;li readability=&quot;6.3994082840237&quot;&gt;
&lt;p&gt;代码拦截，或者叫 动态代理&lt;/p&gt;
&lt;p&gt;在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强或动态代理。&lt;/p&gt;
&lt;p&gt;在dotnet 中一般在运行时通过Emit技术生成动态程序集和动态代理类型从而对目标方法进行拦截。&lt;/p&gt;
&lt;p&gt;dotnet 框架代表： &lt;a href=&quot;https://github.com/castleproject/Core/blob/master/docs/dynamicproxy-introduction.md&quot;&gt;Castle DynamicProxy&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/dotnetcore/AspectCore-Framework&quot;&gt;AspectCore&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;引用&lt;/em&gt;&lt;/span&gt;&lt;a title=&quot;https://github.com/dotnetcore/AspectCore-Framework/blob/master/docs/0.AOP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.md&quot; href=&quot;https://github.com/dotnetcore/AspectCore-Framework/blob/master/docs/0.AOP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.md&quot;&gt;&lt;span&gt;&lt;em&gt;https://github.com/dotnetcore/AspectCore-Framework/blob/master/docs/0.AOP%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.md&lt;/em&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我这里直接应用AOP Demo中的一段代码来说说这个拦截.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomInterceptor : AbstractInterceptor
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Task Invoke(AspectContext context, AspectDelegate next)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Before service call&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next(context);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service threw an exception!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;After service call&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码中,其实执行到 await next(context)的时候,才会真正去调用那个被拦截的方法.&lt;/p&gt;
&lt;p&gt;这样,我们就可以灵活地在代码调用前,调用后做我们想做的事情了.甚至可以把代码包在一个try…catch...中来捕获异常.&lt;/p&gt;

&lt;p&gt;新建一个web应用程序后,从 Nuget 安装 &lt;code&gt;AspectCore.Extensions.DependencyInjection&lt;/code&gt; 包.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
PM&amp;gt;   Install-Package AspectCore.Extensions.DependencyInjection
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后.我们就可以来定义我们的拦截器了,我定义了一个这样的拦截器.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Invoke(AspectContext context, AspectDelegate next)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; logger = context.ServiceProvider.GetService&amp;lt;ILogger&amp;lt;AuthenticateInterceptor&amp;gt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; apiRequest =&lt;span&gt; (ApiRequest) context.Parameters.FirstOrDefault();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (apiRequest == &lt;span&gt;null&lt;/span&gt; || apiRequest.Name != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    logger.LogWarning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unauthorized&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                logger.LogInformation(apiRequest.Message);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next(context);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                logger&lt;/span&gt;?.LogWarning(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service threw an exception!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                logger.LogInformation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Finished service call&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当ApiRequest为空或者Name不等于admin的时候之家返回并记录未授权.&lt;/p&gt;
&lt;p&gt;否则,调用该调用的方法并记录ApiRequest中的Message.&lt;/p&gt;
&lt;p&gt;然后,我定义一个UserService.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; AspceptCoreDemo
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IUserService
    {
        String GetUserName(ApiRequest req);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserService : IUserService
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetUserName(ApiRequest req)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (req == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The User Name is {req.Name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; req.Name;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Controler中调用注入UserServce并调用该Service.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; AspceptCoreDemo.Controllers
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ControllerBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IUserService _userService;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ValuesController(IUserService userService)
        {
            _userService &lt;/span&gt;=&lt;span&gt; userService;
        }

        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Post(ApiRequest req)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _userService.GetUserName(req);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注册IUserservice并在&lt;code&gt;ConfigureServices&lt;/code&gt;中配置创建代理类型的容器:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; &lt;span&gt;IServiceProvider&lt;/span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddSingleton&lt;/span&gt;&amp;lt;IUserService, UserService&amp;gt;&lt;span&gt;();
            services.AddMvc();
            services.AddDynamicProxy(config &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                config.Interceptors.AddTyped&lt;/span&gt;&amp;lt;AuthenticateInterceptor&amp;gt;&lt;span&gt;();
            });

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; &lt;span&gt;services.BuildAspectInjectorProvider();&lt;/span&gt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是红色背景处,默认的ConfigureService返回类型是空的,我们要修改成为返回类型是IServiceProvider.&lt;/p&gt;

&lt;p&gt;我们在上面的ConfigureService配置的AuthenticateInterceptor默认情况下是全局的,即这里的IUserService它会拦截,当然如果新增了一个IRoleServce它也是会拦截的.&lt;/p&gt;
&lt;p&gt;我把程序运行起来用PostMan访问Api进行测试.下图是Post的数据和返回结果.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224016254-112870544.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224016893-1114921484.png&quot; alt=&quot;image&quot; width=&quot;673&quot; height=&quot;291&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说明接口是正常工作的,成功地把传过去的Name原样返回.&lt;/p&gt;
&lt;p&gt;那么拦截器有没有生效呢?我看看CMD的输出.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224017133-1099194467.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224018394-1964980047.png&quot; alt=&quot;image&quot; width=&quot;668&quot; height=&quot;137&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果我们修改一下Name不等于Admin,预期应该是返回空,并且日志打印出未授权,是不是这样呢?&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224019001-1470864175.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224019706-1484359376.png&quot; alt=&quot;image&quot; width=&quot;676&quot; height=&quot;309&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224019923-570865010.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224020565-135938875.png&quot; alt=&quot;image&quot; width=&quot;676&quot; height=&quot;99&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;完美,与预期完全相同.&lt;/p&gt;
&lt;p&gt;可以发现,这正是我们在拦截器中所作的工作,说明拦截器对该UserService生效了.&lt;/p&gt;

&lt;p&gt;如果我们不想对所有Servce或是Method都拦截,只拦截指定的Servce或者Method呢?&lt;/p&gt;
&lt;p&gt;其实,我们是可以配置全局拦截器的作用域的.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
services.AddDynamicProxy(config =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支持通配符,只对IRole开头的Servce有效&lt;/span&gt;
                config.Interceptors.AddTyped&amp;lt;AuthenticateInterceptor&amp;gt;(Predicates.ForService(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IRole*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我用以上方法配置为该过滤器只对IRole开头的Servce有效,那么,当我们让问IUserServce时,该拦截器肯定是不会生效的,事实是不是这样呢?&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224021132-184437157.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224021836-1153902737.png&quot; alt=&quot;image&quot; width=&quot;673&quot; height=&quot;305&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;即使Name不是admin,结果也返回了,说明确实是没有生效的.&lt;/p&gt;
&lt;p&gt;还可以用以下方法指定过滤器作用于的Method.&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支持通配符,只对Name结尾的方法有效&lt;/span&gt;
config.Interceptors.AddTyped&amp;lt;AuthenticateInterceptor&amp;gt;(Predicates.ForMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;忽略配置有两种方法&lt;/p&gt;
&lt;p&gt;一种是为Service或者Method打上&lt;span&gt;[NonAspect]&lt;/span&gt; 标签,那个过滤器就不会对该处生效了.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IUserService
    {
        [NonAspect]
        String GetUserName(ApiRequest req);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时,即使Name不等于Admin,也是有结果返回会的.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224022415-3016207.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1293736/201811/1293736-20181104224023077-780369200.png&quot; alt=&quot;image&quot; width=&quot;565&quot; height=&quot;247&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说明此时配置器对GetUserName方法确实没有生效.&lt;/p&gt;

&lt;p&gt;另外一种是 全局忽略配置，亦支持通配符：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
services.AddDynamicProxy(config =&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;App1命名空间下的Service不会被代理&lt;/span&gt;
    config.NonAspectPredicates.AddNamespace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后一级为App1的命名空间下的Service不会被代理&lt;/span&gt;
    config.NonAspectPredicates.AddNamespace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*.App1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ICustomService接口不会被代理&lt;/span&gt;
    config.NonAspectPredicates.AddService(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ICustomService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后缀为Service的接口和类不会被代理&lt;/span&gt;
    config.NonAspectPredicates.AddService(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;命名为Query的方法不会被代理&lt;/span&gt;
    config.NonAspectPredicates.AddMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后缀为Query的方法不会被代理&lt;/span&gt;
    config.NonAspectPredicates.AddMethod(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*Query&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对拦截器中有get和set权限的属性标记&lt;code&gt;[AspectCore.Injector.FromContainerAttribute]&lt;/code&gt;特性，即可自动注入该属性.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[NonAspect]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthenticateInterceptor : AbstractInterceptor
    {
       &lt;span&gt; [FromContainer]
        &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; ILogger&amp;lt;AuthenticateInterceptor&amp;gt; Logger { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;/span&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;; }&lt;/span&gt;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Invoke(AspectContext context, AspectDelegate next)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; apiRequest =&lt;span&gt; (ApiRequest) context.Parameters.FirstOrDefault();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (apiRequest == &lt;span&gt;null&lt;/span&gt; || apiRequest.Name != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    Logger.LogWarning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unauthorized&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                Logger.LogInformation(apiRequest.Message);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next(context);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                Logger&lt;/span&gt;?.LogWarning(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service threw an exception!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                Logger.LogInformation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Finished service call&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以拦截器上下文&lt;code&gt;AspectContext&lt;/code&gt;可以获取当前Scoped的&lt;code&gt;ServiceProvider&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;利用该ServiceProvider来对依赖项赋值.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[NonAspect]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthenticateInterceptor : AbstractInterceptor
    {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Invoke(AspectContext context, AspectDelegate next)
        {
            &lt;/span&gt;
&lt;/pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; logger = context.ServiceProvider.GetService&amp;lt;ILogger&amp;lt;AuthenticateInterceptor&amp;gt;&amp;gt;&lt;/span&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;();&lt;/span&gt;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; apiRequest =&lt;span&gt; (ApiRequest) context.Parameters.FirstOrDefault();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (apiRequest == &lt;span&gt;null&lt;/span&gt; || apiRequest.Name != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;admin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    logger.LogWarning(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unauthorized&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
                logger.LogInformation(apiRequest.Message);
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next(context);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                logger&lt;/span&gt;?.LogWarning(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service threw an exception!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
            {
                logger.LogInformation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Finished service call&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本文只是对AsceptCore最简单的一套流程end to end 地进行了叙述,这还只是AsceptCore的冰山一角.在此向开发处如此牛逼AOP框架的小伙致敬!!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/6af89bc8gw1f8tys9l7h5j20a00a0wfd.jpg&quot; alt=&quot;â€œè§£é”å§¿åŠ¿â€çš„å›¾ç‰‡æœç´¢ç»“æžœ&quot;/&gt;&lt;/p&gt;

&lt;p&gt;欢迎访问&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://github.com/dotnetcore/AspectCore-Framework/blob/master/docs/1.%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.md&quot; href=&quot;https://github.com/dotnetcore/AspectCore-Framework/blob/master/docs/1.%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.md&quot;&gt;https://github.com/dotnetcore/AspectCore-Framework/blob/master/docs/1.%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解锁更多新姿势!!!&lt;/p&gt;

&lt;p&gt;本博客Demo地址&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://github.com/liuzhenyulive/AspceptCoreDemo&quot; href=&quot;https://github.com/liuzhenyulive/AspceptCoreDemo&quot; target=&quot;_blank&quot;&gt;https://github.com/liuzhenyulive/AspceptCoreDemo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;AsceptCore地址&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://github.com/dotnetcore/AspectCore-Framework/blob/master/docs/1.%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.md&quot; href=&quot;https://github.com/dotnetcore/AspectCore-Framework/blob/master/docs/1.%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.md&quot;&gt;https://github.com/dotnetcore/AspectCore-Framework&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 04 Nov 2018 14:40:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<og:description>前些天和张队(善友),lemon(浩洋),斌哥(项斌)等MVP大咖一块儿吃饭,大家聊到了lemon名下的AOP这个项目,我这小白听得一脸懵逼,后面回来做了一下功课,查了下资料,在lemon的Githu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/9906349.html</dc:identifier>
</item>
<item>
<title>python装饰器 - 旦复旦兮</title>
<link>http://www.cnblogs.com/ChinacloudTech/p/9906240.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ChinacloudTech/p/9906240.html</guid>
<description>&lt;p&gt;&lt;span class=&quot;tag blue label&quot;&gt;Python，装饰器&lt;/span&gt;&lt;/p&gt;

&lt;h3 class=&quot;xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;装饰器&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;装饰器的形成过程：最简单的装饰器，一个参数的装饰器，万能参数&lt;br/&gt;装饰器函数的作用：不想改变函数的调用方式，但是还是想在原来的函数前后添加功能。（在不修改原函数及其调用方式的情况下对原函数功能进行扩展）&lt;br/&gt;timmer（）是装饰器函数，只是有个函数，有些装饰作用&lt;br/&gt;语法糖：让代码更简单。更简洁，@timmer&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot; python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; time
    
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(f)&lt;/span&gt;:&lt;/span&gt; 
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
        start = time.time()
        ret=f() 
        end=time.end()
        print(end-start)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ret
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; inner
&lt;span class=&quot;hljs-meta&quot;&gt;@timmer #语法糖 @装饰器函数名,相当于调用func=timmer(func)&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt; 
    time.sheep(&lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;)
    print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;第一次用小书匠写博客，感觉还不错&quot;&lt;/span&gt;)
    

ret = func()
print(ret)
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 class=&quot;xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;装饰器的原则&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;原则：开放封闭原则&lt;br/&gt;开放：对扩展是开放的&lt;br/&gt;封闭：对修改是封闭的&lt;br/&gt;详细介绍：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_1&quot;&gt;1.对扩展是开放的&lt;br/&gt;　　　　为什么要对扩展开放呢？&lt;br/&gt;　　　　我们说，任何一个程序，不可能在设计之初就已经想好了所有的功能并且未来不做任何更新和修改。所以我们必须允许代码扩展、添加新功能。&lt;br/&gt;　　2.对修改是封闭的&lt;br/&gt;　　　　为什么要对修改封闭呢？&lt;br/&gt;　　　　就像我们刚刚提到的，因为我们写的一个函数，很有可能已经交付给其他人使用了，如果这个时候我们对其进行了修改，很有可能影响其他已经在使用该函数的用户。&lt;br/&gt;装饰器完美的遵循了这个开放封闭原则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot; python&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;outer&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;iner&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;inner&quot;&lt;/span&gt;
    inner()
outer()
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 class=&quot;xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;传参的被装饰函数，装饰带参数的装饰器&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot; python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; time
    
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(f)&lt;/span&gt;:&lt;/span&gt; 
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(a)&lt;/span&gt;:&lt;/span&gt;
        start = time.time()
        ret=f(a) 
        end=time.end()
        print(end-start)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ret
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; inner
    
&lt;span class=&quot;hljs-meta&quot;&gt;@timmer &lt;/span&gt;


&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(a)&lt;/span&gt;:&lt;/span&gt; 
    time.sheep(&lt;span class=&quot;hljs-number&quot;&gt;0.01&lt;/span&gt;)
    print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;第一次用小书匠写博客，感觉还不错&quot;&lt;/span&gt;,a)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;不错不错&quot;&lt;/span&gt;
    

ret = func(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)
print(ret)
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 class=&quot;xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;万能参数的装饰器&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;24&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot; python&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;wrapper&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(func)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(*argc,**kwargc)&lt;/span&gt; :&lt;/span&gt;
        ret = func(*argc,**kwargc)
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ret
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; inner

&lt;span class=&quot;hljs-meta&quot;&gt;@wrapper&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;multi_args&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; :&lt;/span&gt;
    print(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;)
&lt;span class=&quot;hljs-meta&quot;&gt;@wrapper&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;multi_args1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(a,b)&lt;/span&gt; :&lt;/span&gt;
    print(a,b)
&lt;span class=&quot;hljs-meta&quot;&gt;@wrapper&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;multi_args2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(list_num)&lt;/span&gt; :&lt;/span&gt;
    print(list_num)
multi_args()
multi_args1(&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)
multi_args2([&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;])
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;输出的结果如下：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_1&quot;&gt;1 3 4 6 7 9&lt;br/&gt;3 5&lt;br/&gt;[4, 5, 7, 8, 9, 10]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 class=&quot;xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;两个有用的宏&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;1 函数名.&lt;strong&gt;name&lt;/strong&gt; 查看字符串格式的函数名&lt;br/&gt;2 函数名.&lt;strong&gt;doc&lt;/strong&gt; #document 查看函数的注释&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot; python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; functools &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; wraps
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;wrapper&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(func)&lt;/span&gt;:&lt;/span&gt;  
&lt;span class=&quot;hljs-meta&quot;&gt;    @wraps(func)&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(*args,**kwargs)&lt;/span&gt;:&lt;/span&gt;
        print(&lt;span class=&quot;hljs-string&quot;&gt;'在被装饰的函数执行之前做的事'&lt;/span&gt;)
        ret = func(*args,**kwargs)
        print(&lt;span class=&quot;hljs-string&quot;&gt;'在被装饰的函数执行之后做的事'&lt;/span&gt;)
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ret
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; inner

&lt;span class=&quot;hljs-meta&quot;&gt;@wrapper   #holiday = wrapper(holiday)&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;holiday&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(day)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-string&quot;&gt;'''这是一个放假通知'''&lt;/span&gt;
    print(&lt;span class=&quot;hljs-string&quot;&gt;'全体放假%s天'&lt;/span&gt;%day)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'好开心'&lt;/span&gt;

print(holiday.__name__)
print(holiday.__doc__)
ret = holiday(&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)   
print(ret)
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;结果如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_1&quot;&gt;holiday&lt;br/&gt;这是一个放假通知&lt;br/&gt;在被装饰的函数执行之前做的事&lt;br/&gt;全体放假3天&lt;br/&gt;在被装饰的函数执行之后做的事&lt;br/&gt;好开心&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;代码执行顺序详解&quot; src=&quot;http://futuretechx.com/wp-content/uploads/2018/11/20181104212152.png&quot; alt=&quot;代码执行顺序详解&quot; name=&quot;&quot; data-src=&quot;http://futuretechx.com/wp-content/uploads/2018/11/20181104212152.png&quot;/&gt;&lt;p&gt;代码执行顺序详解&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;h3 class=&quot;xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;装饰器的进阶&lt;/span&gt;&lt;/h3&gt;

&lt;h5 class=&quot;xsj_heading_h5&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;1 带参数的装饰器&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;假如你有成千上万个函数使用了一个装饰器，现在你想把这些装饰器都取消掉，你要怎么做？一个一个的取消掉？ 没日没夜忙活3天。。。过两天你领导想通了，再让你加上。。。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot; python&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; time
FLAGE = &lt;span class=&quot;hljs-keyword&quot;&gt;False&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;timmer_out&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(flag)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;timmer&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(func)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(*args,**kwargs)&lt;/span&gt;:&lt;/span&gt;
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; flag:
                start = time.time()
                ret = func(*args,**kwargs)
                end = time.time()
                print(end-start)
                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ret
            &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:
                ret = func(*args, **kwargs)
                &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ret
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; inner
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; timmer

&lt;span class=&quot;hljs-meta&quot;&gt;@timmer_out(FLAGE)    #wahaha = timmer(wahaha)&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;wahaha&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;)
    print(&lt;span class=&quot;hljs-string&quot;&gt;'wahahahahahaha'&lt;/span&gt;)

&lt;span class=&quot;hljs-meta&quot;&gt;@timmer_out(True)&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;erguotou&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    time.sleep(&lt;span class=&quot;hljs-number&quot;&gt;0.1&lt;/span&gt;)
    print(&lt;span class=&quot;hljs-string&quot;&gt;'erguotoutoutou'&lt;/span&gt;)

wahaha()
erguotou()
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;结果如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_1&quot;&gt;wahahahahahaha&lt;br/&gt;erguotoutoutou&lt;br/&gt;0.10090804100036621&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 class=&quot;xsj_heading_h5&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;多个装饰器装饰同一个函数&lt;/span&gt;&lt;/h5&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;16&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot; python&quot;&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;wrapper1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(func)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;inner1&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
        print(&lt;span class=&quot;hljs-string&quot;&gt;'wrapper1 ,before func'&lt;/span&gt;)
        ret = func()
        print(&lt;span class=&quot;hljs-string&quot;&gt;'wrapper1 ,after func'&lt;/span&gt;)
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ret
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; inner1

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;wrapper2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(func)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;inner2&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
        print(&lt;span class=&quot;hljs-string&quot;&gt;'wrapper2 ,before func'&lt;/span&gt;)
        ret = func()
        print(&lt;span class=&quot;hljs-string&quot;&gt;'wrapper2 ,after func'&lt;/span&gt;)
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ret
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; inner2

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;wrapper3&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(func)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;inner3&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
        print(&lt;span class=&quot;hljs-string&quot;&gt;'wrapper3 ,before func'&lt;/span&gt;)
        ret = func()
        print(&lt;span class=&quot;hljs-string&quot;&gt;'wrapper3 ,after func'&lt;/span&gt;)
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; ret
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; inner3

&lt;span class=&quot;hljs-meta&quot;&gt;@wrapper3&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;@wrapper2&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;@wrapper1&lt;/span&gt;
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;
    print(&lt;span class=&quot;hljs-string&quot;&gt;'in f'&lt;/span&gt;)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'哈哈哈'&lt;/span&gt;

print(f())
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;执行的结果如下：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p class=&quot;xsj_paragraph_level_1&quot;&gt;wrapper3 ,before func&lt;br/&gt;wrapper2 ,before func&lt;br/&gt;wrapper1 ,before func&lt;br/&gt;in f&lt;br/&gt;wrapper1 ,after func&lt;br/&gt;wrapper2 ,after func&lt;br/&gt;wrapper3 ,after func&lt;br/&gt;哈哈哈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;enter description here&quot; src=&quot;http://futuretechx.com/wp-content/uploads/2018/11/20181104212226.png&quot; alt=&quot;enter description here&quot; name=&quot;&quot; data-src=&quot;http://futuretechx.com/wp-content/uploads/2018/11/20181104212226.png&quot;/&gt;&lt;p&gt;enter description here&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;h3 class=&quot;xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;总结：&lt;/span&gt;&lt;/h3&gt;

&lt;h6 class=&quot;xsj_heading_h6&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;装饰器的主要功能和装饰器的固定结构&lt;/span&gt;&lt;/h6&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;装饰器的主要功能：&lt;br/&gt;在不改变函数调用方式的基础上在函数的前、后添加功能。添加功能的这部分就在装饰器中&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt;装饰器的固定格式：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python hljs&quot; data-info=&quot; python&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;timer&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(func)&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;inner&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(*args,**kwargs)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-string&quot;&gt;'''执行函数之前要做的'''&lt;/span&gt;
        re = func(*args,**kwargs)
        &lt;span class=&quot;hljs-string&quot;&gt;'''执行函数之后要做的'''&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; re
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; inner

&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; functools &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; wraps

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;deco&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(func)&lt;/span&gt;:&lt;/span&gt;
&lt;span class=&quot;hljs-meta&quot;&gt;    @wraps(func) #加在最内层函数正上方&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;wrapper&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(*args,**kwargs)&lt;/span&gt;:&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; func(*args,**kwargs)
    &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; wrapper
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph_level_0&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img title=&quot;enter description here&quot; src=&quot;http://futuretechx.com/wp-content/uploads/2018/11/20181104212236.png&quot; alt=&quot;enter description here&quot; name=&quot;&quot; data-src=&quot;http://futuretechx.com/wp-content/uploads/2018/11/20181104212236.png&quot;/&gt;&lt;p&gt;enter description here&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Sun, 04 Nov 2018 14:19:00 +0000</pubDate>
<dc:creator>旦复旦兮</dc:creator>
<og:description>python装饰器 Python，装饰器 装饰器 装饰器的形成过程：最简单的装饰器，一个参数的装饰器，万能参数 装饰器函数的作用：不想改变函数的调用方式，但是还是想在原来的函数前后添加功能。（在不修改</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ChinacloudTech/p/9906240.html</dc:identifier>
</item>
<item>
<title>Nginx反代Mogilefs分布式储存示例 - readygood</title>
<link>http://www.cnblogs.com/readygood/p/9899230.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/readygood/p/9899230.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　随着信息技术不断的发展，给我们带来便利的同时，不断增加的数据量级、信息之间的连接关联越来越复杂、数据访问的并发量日益增加对I/O的要求越来越高、数据类型越来越复杂等难题也成为信息技术继续高速发展亟需解决的难题。分布式存储系统的出现在很大程度上解决了以上大部分难题。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　分布式存储系统，是将数据分散存储在多台独立的设备上。传统的网络存储系统采用集中的存储服务器存放所有数据，存储服务器成为系统性能的瓶颈，也是可靠性和安全性的焦点，不能满足大规模存储应用的需要。分布式存储系统采用可扩展的系统结构，利用多台存储服务器分担存储负荷，利用位置服务器定位存储信息，它不但提高了系统的可靠性、可用性和存取效率，还易于扩展。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　分布式存储系统在接口类型上可分为通用分布式储存和专用分布式储存。通用分布式储存是指没有文件系统接口，需要通过API接口进行访问；专用分布式储存也称为分布式文件系统，它们一般都会有文件系统接口，可以直接挂载。通用分布式储存有mogilefs、fastdfs等，专用分布式储存系统有moosefs等。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;1.Mogilefs架构图：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181103144452938-1826847701.png&quot; alt=&quot;&quot; width=&quot;478&quot; height=&quot;391&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.组成Mogliefs的组件：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.Trackers(mogilefsd)：Mogliefs的核心组件，主要功能是(Replication)节点文件复制、(Deletion)文件删除、(Query)元数据查询、(Monitor)健康监测、(Reaper)储存失败重置等等。它通常称为元数据服务器，但它不会去储存元数据，而是将元数据储存在如MySQL这一类的数据库中。为保证架构的可靠性，Trackers一般有多个。Trackers可看作是一个旁挂式代理，只负责处理元数据信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.数据库：数据库用来存放Mogliefs的元数据，而由Trackers来管理数据。因此通常建议做HA。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.mogstored(储存节点)：实际文件存放的地方。通常会将实际文件保存至少两份副本。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3.示例演示拓扑图&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在三个节点同时安装Trackers和mogstored，选择其中一个节点安装MySQL。在生产环境最好是能单独将MySQL部署并且做主从复制。Trackers和mogstored也可以分开部署在不同节点上，这些都需要根据实际的生产环境来决定。这里主要是演示mogilefs，不做MySQL主从复制演示。若想要Mogilefs能挂载，可以用FUSE来实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　需要注意的是mogilefs存储的文件URL很特殊(后面会解释mogilefs文件名生产的过程)，如存储一张图片时文件URL可能会是类似6060/0000/0000/0000/00000021.jpg这样的格式，对用户来讲就不太友好，用户可能需要直观的类似image.hello.com/21.jpg这样的URL。所以通常会使用Nginx来反代Mogilefs。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181103215217391-323933622.png&quot; alt=&quot;&quot; width=&quot;497&quot; height=&quot;524&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.系统环境与安装&lt;/h2&gt;
&lt;p&gt;　　M&lt;span&gt;ogilefs是一个相对较年代较久但成熟的分布式储存，考虑到可能在Centos7上会出现兼容问题，这里Centos6来演示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作系统：CentOS release 6.6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Mogilefs：2.46&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;nginx：1.10&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;mysql：5.1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IP分配：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　n1:192.168.29.111，n2:192.168.29.112，n3:192.168.29.113，n4:192.168.29.114&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结构如上图所示。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1.在n1节点上安装MySQL、mogilefsd、mogstored，并将n1配置为Trackers、Storage Node&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　MySQL直接用yum安装。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
~]# yum install -y mysql mysql-server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;安装Mogilefs的Trackers和Storage Node组件，安装时一定要安装Perl相关的依赖包，依赖包有：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;perl&lt;/span&gt;-Danga-Socket-&lt;span&gt;1.61&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.el6.rf.noarch.rpm
&lt;/span&gt;&lt;span&gt;perl&lt;/span&gt;-IO-stringy-&lt;span&gt;2.110&lt;/span&gt;-&lt;span&gt;1.2&lt;/span&gt;&lt;span&gt;.el6.rfx.noarch.rpm&lt;br/&gt;&lt;/span&gt;&lt;span&gt;perl&lt;/span&gt;-Net-Netmask-&lt;span&gt;1.9015&lt;/span&gt;-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;.el6.noarch.rpm
Perlbal&lt;/span&gt;-&lt;span&gt;1.78&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.el6.noarch.rpm&lt;br/&gt;&lt;span&gt;perl&lt;/span&gt;-Perlbal-&lt;span&gt;1.78&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.el6.noarch.rpm
Perlbal&lt;/span&gt;-doc-&lt;span&gt;1.78&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.el6.noarch.rpm&lt;br/&gt;perl-IO-AIO-3.71-2.el6.x86_64.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;上述依赖包一定要安装后才能安装Mogilefs。安装组件：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y MogileFS-Server-mogstored-&lt;span&gt;2.46&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;.el6.noarch.rpm MogileFS-Server-mogilefsd-&lt;span&gt;2.46&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;.el6.noarch.rpm MogileFS-Server-&lt;span&gt;2.46&lt;/span&gt;-&lt;span&gt;2&lt;/span&gt;.el6.noarch.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;配置 &lt;span class=&quot;cnblogs_code&quot;&gt;MogileFS-Server-mogilefsd&lt;/span&gt; ：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
~]# vim /etc/mogilefs/mogilefsd.conf #Mogilfs Trackers的主配置文件
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
# Enable daemon mode to work &lt;span&gt;in&lt;/span&gt;&lt;span&gt; background and use syslog
daemonize &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt; #是否以守护进程的方式运行。
# Where to store the pid of the daemon (must be the same &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; the init script)
pidfile &lt;/span&gt;= /var/run/mogilefsd/&lt;span&gt;mogilefsd.pid #pid文件路径
# Database connection information
db_dsn &lt;/span&gt;= DBI:mysql:mogilefs:host=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.111&lt;/span&gt;&lt;span&gt;&lt;span&gt; #数据库的地址&lt;/span&gt;
db_user &lt;/span&gt;=&lt;span&gt; moguser &lt;span&gt;#配置数据库的用户名及密码&lt;/span&gt;
db_pass &lt;/span&gt;= &lt;span&gt;123456&lt;/span&gt;&lt;span&gt;
# IP:PORT to listen on &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; mogilefs client requests
listen &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;&lt;span&gt;&lt;span&gt; #监听的地址与端口&lt;/span&gt;
# Optional, &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; you don&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t define the port above.&lt;/span&gt;
conf_port = &lt;span&gt;7001&lt;/span&gt;&lt;span&gt; #默认端口
# Number of query workers to start by default.
query_jobs &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;&lt;span&gt; #查询进程数量
# Number of delete workers to start by default.
delete_jobs &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt; 
# Number of replicate workers to start by default.
replicate_jobs &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
# Number of reaper workers to start by default.
# (you don&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t usually need to increase this)&lt;/span&gt;
reaper_jobs = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
# Number of fsck workers to start by default.
# (these can cause a lot of load when fsck&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ing)&lt;/span&gt;
#fsck_jobs = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
# Minimum amount of space to reserve &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; megabytes
# default: &lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;
# Consider setting this to be larger than the largest &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt; you
# would normally be uploading.
#min_free_space &lt;/span&gt;= &lt;span&gt;200&lt;/span&gt;&lt;span&gt;
# Number of seconds to &lt;/span&gt;&lt;span&gt;wait&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;&lt;span&gt; a storage node to respond.
# default: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
# Keep this low, so busy storage nodes are quickly ignored.
#node_timeout &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
# Number of seconds to &lt;/span&gt;&lt;span&gt;wait&lt;/span&gt;&lt;span&gt; to connect to a storage node.
# default: &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
# Keep this low so overloaded nodes get skipped.
#conn_timeout &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
# Allow replication to use the secondary node get port,
# &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; you have apache or similar configured &lt;span&gt;for&lt;/span&gt; GET&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;
#repl_use_get_port = &lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;修改完配置后，进入数据库创建一个可以远程连接的root用户，或者使用 &lt;span class=&quot;cnblogs_code&quot;&gt;mogdbsetup&lt;/span&gt; 初始化数据库：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; GRANT ALL ON mogilefs.* TO &lt;span&gt;'&lt;/span&gt;&lt;span&gt;moguser&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.29.%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED BY &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; #创建用户moguser，拥有管理mogilefs库的所有权限，并允许192.&lt;span&gt;168.29&lt;/span&gt;.*&lt;span&gt;的用户远程连接。
mysql&lt;/span&gt;&amp;gt; FLUSH PRIVILEGES;&lt;br/&gt;mysql&amp;gt; quit
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
~]# mogdbsetup --dbhost=&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; --dbuser=moguser --dbpass=&lt;span&gt;123456&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;初始化完成后可以在MySQL中看到创建好的 &lt;span class=&quot;cnblogs_code&quot;&gt;mogilefs&lt;/span&gt; 库以及里面的表：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181103231046054-819487422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;启动mogilefs并确认7001端口处于监听状态:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
~&lt;span&gt;]# service mogilefsd start
Starting mogilefsd                                         [  OK  ]&lt;br/&gt;~]# ss -lnt&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;注：可以在n2、n3节点都安装Trackers服务，从而消除单点故障风险也能平均I/O压力。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3.在n1上配置Storage Node&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;Storage Node配置文件路径为&lt;/span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;/etc/mogilefs/mogstored.conf&lt;/span&gt; ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
~]# vim /etc/mogilefs/&lt;span&gt;mogstored.conf
maxconns &lt;/span&gt;= &lt;span&gt;10000 #最大并发连接数&lt;/span&gt;&lt;span&gt;
httplisten &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;7500 #Mogilefs数据的传输是通过http协议实现的，这里是监听的地址和端口&lt;/span&gt;&lt;span&gt;
mgmtlisten &lt;/span&gt;= &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;7501 #健康监测的监听地址和端口&lt;/span&gt;&lt;span&gt;
docroot &lt;/span&gt;= /mogliefs/mogdata #数据的存储路径，目录的属组和属主必须是mogilefs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;创建数据存储目录并修改属组和属主为mogilefs：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
~]# &lt;span&gt;mkdir&lt;/span&gt; -pv /mogliefs/&lt;span&gt;mogdata
&lt;/span&gt;~]# &lt;span&gt;chown&lt;/span&gt; -R mogilefs.mogilefs /mogliefs/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;启动mogstored，查看进程是否正常启动端口是否监听：&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
~&lt;span&gt;]# service mogstored start
&lt;/span&gt;~]# ss -lnt #监听端口为7500、&lt;span&gt;7501&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;4.按照n1的步骤在节点n2、n3上安装Mogilefs，并将n1上的配置文件复制到n2、n3。&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
~]# &lt;span&gt;scp&lt;/span&gt; /etc/mogilefs&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.conf root@192.168.29.112:/etc/mogilefs/
~]# scp /etc/mogilefs/*.conf root@192.168.29.113:/etc/mogilefs/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;启动 &lt;span class=&quot;cnblogs_code&quot;&gt;mogstored&lt;/span&gt; 服务并确认监听：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
~&lt;span&gt;]# service mogstored start
&lt;/span&gt;~]# ss -lnt #监听端口为7500、&lt;span&gt;7501&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;5.用在n1上用mogadm命令将所有节点整合成集群。&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　添加存储节点，并检查：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ~]# mogadm host add &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.111&lt;/span&gt; --ip=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.111&lt;/span&gt; --port=&lt;span&gt;7500&lt;/span&gt; --status=&lt;span&gt;alive
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; ~]# mogadm host add &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.112&lt;/span&gt; --ip=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.112&lt;/span&gt; --port=&lt;span&gt;7500&lt;/span&gt; --status=&lt;span&gt;alive
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; ~]# mogadm host add &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.113&lt;/span&gt; --ip=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.113&lt;/span&gt; --port=&lt;span&gt;7500&lt;/span&gt; --status=alive
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
~]# mogadm check
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181104152938769-360824207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;若想让mogilefs集群中的存储被识别成不同设备，需要在创建的 &lt;span class=&quot;cnblogs_code&quot;&gt;/mogliefs/mogdata&lt;/span&gt; 目录下再创建名为 &lt;span class=&quot;cnblogs_code&quot;&gt;dev*&lt;/span&gt; 的目录，使每个节点被当做存储设备使用。mogilefs是将冗余存储在不同设备中的，每一个节点都应该被识别为不同的设备。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;在n1、n2、n3上的 &lt;span class=&quot;cnblogs_code&quot;&gt;/mogliefs/mogdata/&lt;/span&gt; 目录下分别创建dev1,dev2,dev3目录，并在Trackers上添加设备：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ~]# mogadm device add &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.111&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; ~]# mogadm device add &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.112&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; ~]# mogadm device add &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.113&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181104155311273-1543583900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6.创建Domain和Class&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;在Mogilefs中，在多个节点上为了方便文件副本管理，通常在设备中不会以文件为单位进行管理，而是以class(类)做管理，复制删除等操作都是以class为最小单位进行的。每个class中可以放很多文件，class的容积也不是固定的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在Mogilefs的存储空间中，所有数据文件都在同一平面，所以不能有同名的情况发生，这样会影响Mogilefs的灵活性，所以引入了Domain(名称空间)的概念。Domain包含Class，在不同的Domain中可以有相同的文件名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181104165317384-1585079755.png&quot; alt=&quot;&quot; width=&quot;412&quot; height=&quot;381&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
~&lt;span&gt;]# mogadm domain add imgs #创建名为imgs的Domain
&lt;/span&gt;~&lt;span&gt;]# mogadm domain add text #创建名为text的Domain
&lt;/span&gt;~]# mogadm domain list #查看Domain list
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181104170202801-589229912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;可以自定义Class的属性，格式为： &lt;span class=&quot;cnblogs_code&quot;&gt;mogadm class add &amp;lt;domain&amp;gt; &amp;lt;class&amp;gt; [opts]&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
~]# mogadm class add imgs png --mindevcount=&lt;span&gt;3&lt;/span&gt; --hashtype=&lt;span&gt;MD5 #在Domain imgs中定义名为png的class，在不同设备中复制3份，并用MD5做校验
&lt;/span&gt;~]# mogadm class add imgs jpg --mindevcount=&lt;span&gt;3&lt;/span&gt; --hashtype=&lt;span&gt;MD5 #在Domain imgs中定义名为jpg的class，在不同设备中复制3份，并用MD5做校验
&lt;/span&gt;~]# mogadm domain list
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181104191406687-1768512396.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;7.使用Mogilefs做上传下载测试&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;Mogilefs可以用自建的API接口进行交互，其中有很多用于管理存储数据的命令。例如上传数据命令为 &lt;span class=&quot;cnblogs_code&quot;&gt;mogupload&lt;/span&gt; ，查看数据命令为 &lt;span class=&quot;cnblogs_code&quot;&gt;mogfileinfo&lt;/span&gt; 等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;例：测试将文件 &lt;span class=&quot;cnblogs_code&quot;&gt;/test/&lt;span&gt;123&lt;/span&gt;.png&lt;/span&gt; 上传至Mogilefs集群(文件事先在本地准备好)：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
~]# mogupload --trackers=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.111&lt;/span&gt; --domain=imgs --class=png --key=&lt;span&gt;'/&lt;/span&gt;&lt;span&gt;111.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; --&lt;span&gt;file&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/test/123.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  #通过IP为192.&lt;span&gt;168.29&lt;/span&gt;&lt;span&gt;.111的Trackers将123.png文件上传，并保存至Domain为imgs，Class为png的空间中，并重命名为111.png
&lt;/span&gt;~]# mogfileinfo --trackers=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.111&lt;/span&gt; --domain=imgs --class=png --key=&lt;span&gt;'/&lt;/span&gt;&lt;span&gt;111.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; #查看Domain为imgs，Class为png中key为111.png的文件的存储情况。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181104202841817-71702088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181104203128976-1203107892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;至此，Mogilefs分布式储存集群就搭建完成了，但若想要使客户端能与之通信，就需要在接口上进行编程，这样就很麻烦了，好在我们能用Nginx做反代进行通信。下面来演示Nginx反代Mogilefs的步骤。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;5.Nginx反代Mogilefs&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1.打开n2，n3的&lt;/span&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;mogilefsd&lt;/span&gt; &lt;span&gt;服务，将3个节点全部设置为Trackers(保证配置文件与n1相同)：&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
~]# service mogilefsd start
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;2.在n4节点编译安装Nginx&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;安装依赖包：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
~]# &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; &lt;span&gt;gcc&lt;/span&gt; &lt;span&gt;gcc&lt;/span&gt;-c++ &lt;span&gt;perl &lt;/span&gt;pcre-devel &lt;span class=&quot;hljs-keyword&quot;&gt;openssl openssl-devel&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　下载Nginx编译安装包 &lt;span class=&quot;cnblogs_code&quot;&gt;nginx-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;.&lt;span&gt;tar&lt;/span&gt;.gz&lt;/span&gt; 与Nginx_Mogilefs模块 &lt;span class=&quot;cnblogs_code&quot;&gt;nginx_mogilefs_module-&lt;span&gt;1.0&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;.&lt;span&gt;tar&lt;/span&gt;.gz&lt;/span&gt; 并展开：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
~]# &lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
nginx&lt;/span&gt;-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;         nginx_mogilefs_module-&lt;span&gt;1.0&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
nginx&lt;/span&gt;-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;.&lt;span&gt;tar&lt;/span&gt;.gz  nginx_mogilefs_module-&lt;span&gt;1.0&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;.&lt;span&gt;tar&lt;/span&gt;.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
~]# cd nginx-&lt;span&gt;1.10&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
.&lt;/span&gt;/&lt;span&gt;configure \
&lt;/span&gt;&amp;gt;   --prefix=/&lt;span&gt;usr \
&lt;/span&gt;&amp;gt;   --sbin-path=/usr/sbin/&lt;span&gt;nginx \
&lt;/span&gt;&amp;gt;   --conf-path=/etc/nginx/&lt;span&gt;nginx.conf \
&lt;/span&gt;&amp;gt;   --error-log-path=/var/log/nginx/&lt;span&gt;error.log \
&lt;/span&gt;&amp;gt;   --http-log-path=/var/log/nginx/&lt;span&gt;access.log \
&lt;/span&gt;&amp;gt;   --pid-path=/var/run/nginx/&lt;span&gt;nginx.pid  \
&lt;/span&gt;&amp;gt;   --lock-path=/var/lock/&lt;span&gt;nginx.lock \
&lt;/span&gt;&amp;gt;   --user=&lt;span&gt;nginx \
&lt;/span&gt;&amp;gt;   --group=&lt;span&gt;nginx \
&lt;/span&gt;&amp;gt;   --with-&lt;span&gt;http_ssl_module \
&lt;/span&gt;&amp;gt;   --with-&lt;span&gt;http_flv_module \
&lt;/span&gt;&amp;gt;   --with-&lt;span&gt;http_stub_status_module \
&lt;/span&gt;&amp;gt;   --with-&lt;span&gt;http_gzip_static_module \
&lt;/span&gt;&amp;gt;   --http-client-body-temp-path=/var/tmp/nginx/client/&lt;span&gt; \
&lt;/span&gt;&amp;gt;   --http-proxy-temp-path=/var/tmp/nginx/proxy/&lt;span&gt; \
&lt;/span&gt;&amp;gt;   --http-fastcgi-temp-path=/var/tmp/nginx/fcgi/&lt;span&gt; \
&lt;/span&gt;&amp;gt;   --http-uwsgi-temp-path=/var/tmp/nginx/&lt;span&gt;uwsgi \
&lt;/span&gt;&amp;gt;   --http-scgi-temp-path=/var/tmp/nginx/&lt;span&gt;scgi \
&lt;/span&gt;&amp;gt;   --with-&lt;span&gt;pcre \
&lt;/span&gt;&amp;gt;   --with-&lt;span&gt;debug \
&lt;/span&gt;&amp;gt;   &lt;span&gt;--add-module=../nginx_mogilefs_module-&lt;span&gt;1.0&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;/ #一定记得添加Mogilefs模块所在的路径，不可少。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;~]# make&lt;/span&gt; &amp;amp; &lt;span&gt;make&lt;/span&gt; &lt;span&gt;install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;添加nginx用户并启动nginx：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
~]# useradd -s /sbin/nologin -M nginx&lt;br/&gt;~]# /usr/sbin/nginx
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;3.配置Nginx&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　单Trackers示例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; location /imgs/&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             mogilefs_tracker &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.111&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;&lt;span&gt;; #单Trackers示例
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            mogilefs_domain imgs; #指定Domain
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            mogilefs_class png jpg; #指定Class
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            mogilefs_pass { #传输相关配置
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                proxy_pass $mogilefs_path;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 proxy_hide_header Content-&lt;span&gt;Type;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                proxy_buffering off;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;多Trackers示例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在nginx配置中的http配置段添加调度模块：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;upstream mogsvr {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         server &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.111&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         server &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.112&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         server &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;29.113&lt;/span&gt;:&lt;span&gt;7001&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在nginx配置中的server配置段添：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; location /imgs/&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;                mogilefs_tracker mogsvr;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            mogilefs_domain imgs;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            mogilefs_class png jpg;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            mogilefs_pass {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                proxy_pass $mogilefs_path;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 proxy_hide_header Content-&lt;span&gt;Type;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                proxy_buffering off;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　重新启动nginx，并通过nginx访问之前上传的图片：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1479216/201811/1479216-20181104215337460-1181762434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 总结：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　在上传文件时遇到一个错误提示&lt;span data-spm-anchor-id=&quot;5176.100033.1.i0.5a052974Wuzv0W&quot;&gt;MogileFS::Backend: couldn't connect to mogilefsdbackend at /usr/local/share/perl/5.8.4/Client.pm line 282，这是由于mogilefsd服务于MySQL无法连接造成的，检查它们之间的连接情况就能发现错误所在。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 04 Nov 2018 13:59:00 +0000</pubDate>
<dc:creator>readygood</dc:creator>
<og:description>一、分布式存储系统简介 随着信息技术不断的发展，给我们带来便利的同时，不断增加的数据量级、信息之间的连接关联越来越复杂、数据访问的并发量日益增加对I/O的要求越来越高、数据类型越来越复杂等难题也成为信</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/readygood/p/9899230.html</dc:identifier>
</item>
<item>
<title>机器学习数学基础总结 - 郭耀华</title>
<link>http://www.cnblogs.com/guoyaohua/p/9905760.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guoyaohua/p/9905760.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;h2 id=&quot;一基本知识&quot;&gt;一、基本知识&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;本文中所有的向量都是列向量的形式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf{\vec x}=(x_1,x_2,\cdots,x_n)^T=\begin{bmatrix}x_1\\x_2\\ \vdots \\x_n\end{bmatrix}\]&lt;/span&gt; 本书中所有的矩 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf X\in \mathbb R^{m\times n}\)&lt;/span&gt; 都表示为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf X = \begin{bmatrix} x_{1,1}&amp;amp;x_{1,2}&amp;amp;\cdots&amp;amp;x_{1,n}\\ x_{2,1}&amp;amp;x_{2,2}&amp;amp;\cdots&amp;amp;x_{2,n}\\ \vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\ x_{m,1}&amp;amp;x_{m,2}&amp;amp;\cdots&amp;amp;x_{m,n}\\ \end{bmatrix}\]&lt;/span&gt; 简写为 &lt;span class=&quot;math inline&quot;&gt;\((x_{i,j})_{m\times n}\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\([x_{i,j}]_{m\times n}\)&lt;/span&gt; 。&lt;/li&gt;
&lt;li&gt;矩阵的&lt;code&gt;F&lt;/code&gt;范数：设矩 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf A=(a_{i,j})_{m\times n}\)&lt;/span&gt; ，则其&lt;code&gt;F&lt;/code&gt;范数为 &lt;span class=&quot;math inline&quot;&gt;\(||\mathbf A||_F=\sqrt{\sum_{i,j}a_{i,j}^{2}}\)&lt;/span&gt; 。&lt;br/&gt;它是向量 &lt;span class=&quot;math inline&quot;&gt;\(L_2\)&lt;/span&gt; 范数的推广。&lt;/li&gt;
&lt;li&gt;矩阵的迹：设矩 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf A=(a_{i,j})_{m\times n}\)&lt;/span&gt; ， $ \mathbf A$ 的迹为 &lt;span class=&quot;math inline&quot;&gt;\(tr(\mathbf A)=\sum_{i}a_{i,i}\)&lt;/span&gt; 。&lt;br/&gt;迹的性质有：
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf A\)&lt;/span&gt; 的&lt;code&gt;F&lt;/code&gt; 范数等 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf A\mathbf A^T\)&lt;/span&gt; 的迹的平方根 &lt;span class=&quot;math inline&quot;&gt;\(||\mathbf A||_F=\sqrt{tr(\mathbf A \mathbf A^{T})}\)&lt;/span&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf A\)&lt;/span&gt; 的迹等 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf A^T\)&lt;/span&gt; 的迹 &lt;span class=&quot;math inline&quot;&gt;\(tr(\mathbf A)=tr(\mathbf A^{T})\)&lt;/span&gt; 。&lt;/li&gt;
&lt;li&gt;交换律：假设 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf A\in \mathbb R^{m\times n},\mathbf B\in \mathbb R^{n\times m}\)&lt;/span&gt; ，则有 &lt;span class=&quot;math inline&quot;&gt;\(tr(\mathbf A\mathbf B)=tr(\mathbf B\mathbf A)\)&lt;/span&gt; 。&lt;/li&gt;
&lt;li&gt;结合律 &lt;span class=&quot;math inline&quot;&gt;\(tr(\mathbf A\mathbf B\mathbf C)=tr(\mathbf C\mathbf A\mathbf B)=tr(\mathbf B\mathbf C\mathbf A)\)&lt;/span&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二向量操作&quot;&gt;二、向量操作&lt;/h2&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li&gt;一组向 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec v}_1,\mathbf{\vec v}_2,\cdots,\mathbf{\vec v}_n\)&lt;/span&gt; 是线性相关的：指存在一组不全为零的实 &lt;span class=&quot;math inline&quot;&gt;\(a_1,a_2,\cdots,a_n\)&lt;/span&gt; ，使得 &lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=1}^{n}a_i\mathbf{\vec v}_i=\mathbf{\vec 0}\)&lt;/span&gt; 。&lt;br/&gt;一组向 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec v}_1,\mathbf{\vec v}_2,\cdots,\mathbf{\vec v}_n\)&lt;/span&gt; 是线性无关的，当且仅 &lt;span class=&quot;math inline&quot;&gt;\(a_i=0,i=1,2,\cdots,n\)&lt;/span&gt; 时，才有 &lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=1}^{n}a_i\mathbf{\vec v}_i=\mathbf{\vec 0}\)&lt;/span&gt; 。&lt;/li&gt;
&lt;li&gt;一个向量空间所包含的最大线性无关向量的数目，称作该向量空间的维数。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;三维向量的点积 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec u}\cdot\mathbf{\vec v} =u _xv_x+u_yv_y+u_zv_z = |\mathbf{\vec u}| | \mathbf{\vec v}| \cos(\mathbf{\vec u},\mathbf{\vec v})\)&lt;/span&gt; 。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/algebra/dot.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;li&gt;三维向量的叉积：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf{\vec w}=\mathbf{\vec u}\times \mathbf{\vec v}=\begin{bmatrix}\mathbf{\vec i}&amp;amp; \mathbf{\vec j}&amp;amp;\mathbf{\vec k}\\ u_x&amp;amp;u_y&amp;amp;u_z\\ v_x&amp;amp;v_y&amp;amp;v_z\\ \end{bmatrix}\]&lt;/span&gt; 其 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec i}, \mathbf{\vec j},\mathbf{\vec k}\)&lt;/span&gt; 分别 &lt;span class=&quot;math inline&quot;&gt;\(x,y,z\)&lt;/span&gt; 轴的单位向量。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf{\vec u}=u_x\mathbf{\vec i}+u_y\mathbf{\vec j}+u_z\mathbf{\vec k},\quad \mathbf{\vec v}=v_x\mathbf{\vec i}+v_y\mathbf{\vec j}+v_z\mathbf{\vec k}\]&lt;/span&gt; ​
&lt;ul&gt;&lt;li&gt;$\mathbf{\vec u} $ 和 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec v}\)&lt;/span&gt; 的叉积垂直于 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec u},\mathbf{\vec v}\)&lt;/span&gt; 构成的平面，其方向符合右手规则。&lt;/li&gt;
&lt;li&gt;叉积的模等于 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec u},\mathbf{\vec v}\)&lt;/span&gt; 构成的平行四边形的面积&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec u}\times \mathbf{\vec v}=-\mathbf{\vec v}\times \mathbf{\vec u}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;$\mathbf{\vec u}\times( \mathbf{\vec v} \times \mathbf{\vec w})=(\mathbf{\vec u}\cdot \mathbf{\vec w})\mathbf{\vec v}-(\mathbf{\vec u}\cdot \mathbf{\vec v})\mathbf{\vec w} $&lt;br/&gt;&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/algebra/cross.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;三维向量的混合积：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[[\mathbf{\vec u} \;\mathbf{\vec v} \;\mathbf{\vec w}]=(\mathbf{\vec u}\times \mathbf{\vec v})\cdot \mathbf{\vec w}= \mathbf{\vec u}\cdot (\mathbf{\vec v} \times \mathbf{\vec w})\\ =\begin{vmatrix} u_x&amp;amp;u_y&amp;amp;u_z\\ v_x&amp;amp;v_y&amp;amp;v_z\\ w_x&amp;amp;w_y&amp;amp;w_z \end{vmatrix} =\begin{vmatrix} u_x&amp;amp;v_x&amp;amp;w_x\\ u_y&amp;amp;v_y&amp;amp;w_y\\ u_z&amp;amp;v_z&amp;amp;w_z\end{vmatrix} \]&lt;/span&gt; 其物理意义为： &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec u} ,\mathbf{\vec v} ,\mathbf{\vec w}\)&lt;/span&gt; 为三个棱边所围成的平行六面体的体积。 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec u} ,\mathbf{\vec v} ,\mathbf{\vec w}\)&lt;/span&gt; 构成右手系时，该平行六面体的体积为正号。&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;两个向量的并矢：给定两个向 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}=(x_1,x_2,\cdots,x_n)^{T}, \mathbf {\vec y}= (y_1,y_2,\cdots,y_m)^{T}\)&lt;/span&gt; ，则向量的并矢记作：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf {\vec x}\mathbf {\vec y} =\begin{bmatrix}x_1y_1&amp;amp;x_1y_2&amp;amp;\cdots&amp;amp;x_1y_m\\ x_2y_1&amp;amp;x_2y_2&amp;amp;\cdots&amp;amp;x_2y_m\\ \vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\ x_ny_1&amp;amp;x_ny_2&amp;amp;\cdots&amp;amp;x_ny_m\\ \end{bmatrix}\]&lt;/span&gt; 也记 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}\otimes\mathbf {\vec y}\)&lt;/span&gt; 或 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x} \mathbf {\vec y}^{T}\)&lt;/span&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三矩阵运算&quot;&gt;三、矩阵运算&lt;/h2&gt;
&lt;ol readability=&quot;12&quot;&gt;&lt;li&gt;给定两个矩 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf A=(a_{i,j}) \in \mathbb R^{m\times n},\mathbf B=(b_{i,j}) \in \mathbb R^{m\times n}\)&lt;/span&gt; ，定义：
&lt;ul&gt;&lt;li&gt;阿达马积&lt;code&gt;Hadamard product&lt;/code&gt;（又称作逐元素积）：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf A \circ \mathbf B =\begin{bmatrix} a_{1,1}b_{1,1}&amp;amp;a_{1,2}b_{1,2}&amp;amp;\cdots&amp;amp;a_{1,n}b_{1,n}\\ a_{2,1}b_{2,1}&amp;amp;a_{2,2}b_{2,2}&amp;amp;\cdots&amp;amp;a_{2,n}b_{2,n}\\ \vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\ a_{m,1}b_{m,1}&amp;amp;a_{m,2}b_{m,2}&amp;amp;\cdots&amp;amp;a_{m,n}b_{m,n}\end{bmatrix}\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;克罗内积&lt;code&gt;Kronnecker product&lt;/code&gt;：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf A \otimes \mathbf B =\begin{bmatrix}a_{1,1}\mathbf B&amp;amp;a_{1,2}\mathbf B&amp;amp;\cdots&amp;amp;a_{1,n}\mathbf B\\ a_{2,1}\mathbf B&amp;amp;a_{2,2}\mathbf B&amp;amp;\cdots&amp;amp;a_{2,n}\mathbf B\\ \vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\ a_{m,1}\mathbf B&amp;amp;a_{m,2}\mathbf B&amp;amp;\cdots&amp;amp;a_{m,n}\mathbf B \end{bmatrix}\]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x},\mathbf {\vec a},\mathbf {\vec b},\mathbf {\vec c}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 阶向量 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf A,\mathbf B,\mathbf C,\mathbf X\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 阶方阵，则有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{\partial(\mathbf {\vec a}^{T}\mathbf {\vec x}) }{\partial \mathbf {\vec x} }=\frac{\partial(\mathbf {\vec x}^{T}\mathbf {\vec a}) }{\partial \mathbf {\vec x} } =\mathbf {\vec a}\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\frac{\partial(\mathbf {\vec a}^{T}\mathbf X\mathbf {\vec b}) }{\partial \mathbf X }=\mathbf {\vec a}\mathbf {\vec b}^{T}=\mathbf {\vec a}\otimes\mathbf {\vec b}\in \mathbb R^{n\times n}\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\frac{\partial(\mathbf {\vec a}^{T}\mathbf X^{T}\mathbf {\vec b}) }{\partial \mathbf X }=\mathbf {\vec b}\mathbf {\vec a}^{T}=\mathbf {\vec b}\otimes\mathbf {\vec a}\in \mathbb R^{n\times n}\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\frac{\partial(\mathbf {\vec a}^{T}\mathbf X\mathbf {\vec a}) }{\partial \mathbf X }=\frac{\partial(\mathbf {\vec a}^{T}\mathbf X^{T}\mathbf {\vec a}) }{\partial \mathbf X }=\mathbf {\vec a}\otimes\mathbf {\vec a}\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\frac{\partial(\mathbf {\vec a}^{T}\mathbf X^{T}\mathbf X\mathbf {\vec b}) }{\partial \mathbf X }=\mathbf X(\mathbf {\vec a}\otimes\mathbf {\vec b}+\mathbf {\vec b}\otimes\mathbf {\vec a})\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\frac{\partial[(\mathbf A\mathbf {\vec x}+\mathbf {\vec a})^{T}\mathbf C(\mathbf B\mathbf {\vec x}+\mathbf {\vec b})]}{\partial \mathbf {\vec x}}=\mathbf A^{T}\mathbf C(\mathbf B\mathbf {\vec x}+\mathbf {\vec b})+\mathbf B^{T}\mathbf C(\mathbf A\mathbf {\vec x}+\mathbf {\vec a})\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\frac{\partial (\mathbf {\vec x}^{T}\mathbf A \mathbf {\vec x})}{\partial \mathbf {\vec x}}=(\mathbf A+\mathbf A^{T})\mathbf {\vec x}\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\frac{\partial[(\mathbf X\mathbf {\vec b}+\mathbf {\vec c})^{T}\mathbf A(\mathbf X\mathbf {\vec b}+\mathbf {\vec c})]}{\partial \mathbf X}=(\mathbf A+\mathbf A^{T})(\mathbf X\mathbf {\vec b}+\mathbf {\vec c})\mathbf {\vec b}^{T} \]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\frac{\partial (\mathbf {\vec b}^{T}\mathbf X^{T}\mathbf A \mathbf X\mathbf {\vec c})}{\partial \mathbf X}=\mathbf A^{T}\mathbf X\mathbf {\vec b}\mathbf {\vec c}^{T}+\mathbf A\mathbf X\mathbf {\vec c}\mathbf {\vec b}^{T}\]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;如 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 是一元函数，则：
&lt;ul&gt;&lt;li&gt;其逐元向量函数为 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf{\vec x}) =(f(x_1),f(x_2),\cdots,f(x_n))^{T}\)&lt;/span&gt; 。&lt;/li&gt;
&lt;li&gt;其逐矩阵函数为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[f(\mathbf X)=\begin{bmatrix} f(x_{1,1})&amp;amp;f(x_{1,2})&amp;amp;\cdots&amp;amp;f(x_{1,n})\\ f(x_{2,1})&amp;amp;f(x_{2,2})&amp;amp;\cdots&amp;amp;f(x_{2,n})\\ \vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\ f(x_{m,1})&amp;amp;f(x_{m,2})&amp;amp;\cdots&amp;amp;f(x_{m,n})\\ \end{bmatrix}\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;其逐元导数分别为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[f^{\prime}(\mathbf{\vec x}) =(f^{\prime}(x1),f^{\prime}(x2),\cdots,f^{\prime}(x_n))^{T}\\ f^{\prime}(\mathbf X)=\begin{bmatrix} f^{\prime}(x_{1,1})&amp;amp;f^{\prime}(x_{1,2})&amp;amp;\cdots&amp;amp;f^{\prime}(x_{1,n})\\ f^{\prime}(x_{2,1})&amp;amp;f^{\prime}(x_{2,2})&amp;amp;\cdots&amp;amp;f^{\prime}(x_{2,n})\\ \vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\ f^{\prime}(x_{m,1})&amp;amp;f^{\prime}(x_{m,2})&amp;amp;\cdots&amp;amp;f^{\prime}(x_{m,n})\\ \end{bmatrix}\]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;各种类型的偏导数：
&lt;ul&gt;&lt;li&gt;标量对标量的偏导数 &lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial u}{\partial v}\)&lt;/span&gt; 。&lt;/li&gt;
&lt;li&gt;标量对向量 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 维向量）的偏导数 &lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial u}{\partial \mathbf {\vec v}}=(\frac{\partial u}{\partial v_1},\frac{\partial u}{\partial v_2},\cdots,\frac{\partial u}{\partial v_n})^{T}\)&lt;/span&gt; 。&lt;/li&gt;
&lt;li&gt;标量对矩阵 &lt;span class=&quot;math inline&quot;&gt;\(m\times n\)&lt;/span&gt; 阶矩阵)的偏导数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{\partial u}{\partial \mathbf V}=\begin{bmatrix} \frac{\partial u}{\partial V_{1,1}}&amp;amp;\frac{\partial u}{\partial V_{1,2}}&amp;amp;\cdots&amp;amp;\frac{\partial u}{\partial V_{1,n}}\\ \frac{\partial u}{\partial V_{2,1}}&amp;amp;\frac{\partial u}{\partial V_{2,2}}&amp;amp;\cdots&amp;amp;\frac{\partial u}{\partial V_{2,n}}\\ \vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\ \frac{\partial u}{\partial V_{m,1}}&amp;amp;\frac{\partial u}{\partial V_{m,2}}&amp;amp;\cdots&amp;amp;\frac{\partial u}{\partial V_{m,n}} \end{bmatrix}\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;向量 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 维向量）对标量的偏导数 &lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial \mathbf {\vec u}}{\partial v}=(\frac{\partial u_1}{\partial v},\frac{\partial u_2}{\partial v},\cdots,\frac{\partial u_m}{\partial v})^{T}\)&lt;/span&gt; 。&lt;/li&gt;
&lt;li&gt;向量 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 维向量）对向量 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 维向量)的偏导数（雅可比矩阵，行优先）&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{\partial \mathbf {\vec u}}{\partial \mathbf {\vec v}}=\begin{bmatrix} \frac{\partial u_1}{\partial v_1}&amp;amp;\frac{\partial u_1}{\partial v_2}&amp;amp;\cdots&amp;amp;\frac{\partial u_1}{\partial v_n}\\ \frac{\partial u_2}{\partial v_1}&amp;amp;\frac{\partial u_2}{\partial v_2}&amp;amp;\cdots&amp;amp;\frac{\partial u_2}{\partial v_n}\\ \vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\ \frac{\partial u_m}{\partial v_1}&amp;amp;\frac{\partial u_m}{\partial v_2}&amp;amp;\cdots&amp;amp;\frac{\partial u_m}{\partial v_n} \end{bmatrix}\]&lt;/span&gt; 如果为列优先，则为上面矩阵的转置。&lt;/li&gt;
&lt;li&gt;矩阵 &lt;span class=&quot;math inline&quot;&gt;\(m\times n\)&lt;/span&gt; 阶矩阵)对标量的偏导数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{\partial \mathbf U}{\partial v}=\begin{bmatrix} \frac{\partial U_{1,1}}{\partial v}&amp;amp;\frac{\partial U_{1,2}}{\partial v}&amp;amp;\cdots&amp;amp;\frac{\partial U_{1,n}}{\partial v}\\ \frac{\partial U_{2,1}}{\partial v}&amp;amp;\frac{\partial U_{2,2}}{\partial v}&amp;amp;\cdots&amp;amp;\frac{\partial U_{2,n}}{\partial v}\\ \vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\ \frac{\partial U_{m,1}}{\partial v}&amp;amp;\frac{\partial U_{m,2}}{\partial v}&amp;amp;\cdots&amp;amp;\frac{\partial U_{m,n}}{\partial v} \end{bmatrix}\]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对于矩阵的迹，有下列偏导数成立：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{\partial [tr(f(\mathbf X))]}{\partial \mathbf X }=(f^{\prime}(\mathbf X))^{T}\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\frac{\partial [tr(\mathbf A\mathbf X\mathbf B)]}{\partial \mathbf X }=\mathbf A^{T}\mathbf B^{T} \]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\frac{\partial [tr(\mathbf A\mathbf X^{T}\mathbf B)]}{\partial \mathbf X }=\mathbf B\mathbf A \]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\frac{\partial [tr(\mathbf A\otimes\mathbf X )]}{\partial \mathbf X }=tr(\mathbf A)\mathbf I\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\frac{\partial [tr(\mathbf A\mathbf X \mathbf B\mathbf X)]}{\partial \mathbf X }=\mathbf A^{T}\mathbf X^{T}\mathbf B^{T}+\mathbf B^{T}\mathbf X \mathbf A^{T} \]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\frac{\partial [tr(\mathbf X^{T} \mathbf B\mathbf X \mathbf C)]}{\partial \mathbf X }=(\mathbf B^{T}+\mathbf B)\mathbf X \mathbf C \mathbf C^{T} \]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\frac{\partial [tr(\mathbf C^{T}\mathbf X^{T} \mathbf B\mathbf X \mathbf C)]}{\partial \mathbf X }=\mathbf B\mathbf X \mathbf C +\mathbf B^{T}\mathbf X \mathbf C^{T} \]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\frac{\partial [tr(\mathbf A\mathbf X \mathbf B\mathbf X^{T} \mathbf C)]}{\partial \mathbf X }= \mathbf A^{T}\mathbf C^{T}\mathbf X\mathbf B^{T}+\mathbf C \mathbf A \mathbf X \mathbf B\]&lt;/span&gt; &lt;span class=&quot;math display&quot;&gt;\[\frac{\partial [tr((\mathbf A\mathbf X\mathbf B+\mathbf C)(\mathbf A\mathbf X\mathbf B+\mathbf C))]}{\partial \mathbf X }= 2\mathbf A ^{T}(\mathbf A\mathbf X\mathbf B+\mathbf C)\mathbf B^{T}\]&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;假 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf U= f(\mathbf X)\)&lt;/span&gt; 是关 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf X\)&lt;/span&gt; 的矩阵值函数 &lt;span class=&quot;math inline&quot;&gt;\(f:\mathbb R^{m\times n}\rightarrow \mathbb R^{m\times n}\)&lt;/span&gt; ）， &lt;span class=&quot;math inline&quot;&gt;\(g(\mathbf U)\)&lt;/span&gt; 是关 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf U\)&lt;/span&gt; 的实值函数 $g:\mathbb R^{m\times n}\rightarrow \mathbb R $ ），则下面链式法则成立：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{\partial g(\mathbf U)}{\partial \mathbf X}= \left(\frac{\partial g(\mathbf U)}{\partial x_{i,j}}\right)_{m\times n}=\begin{bmatrix} \frac{\partial g(\mathbf U)}{\partial x_{1,1}}&amp;amp;\frac{\partial g(\mathbf U)}{\partial x_{1,2}}&amp;amp;\cdots&amp;amp;\frac{\partial g(\mathbf U)}{\partial x_{1,n}}\\ \frac{\partial g(\mathbf U)}{\partial x_{2,1}}&amp;amp;\frac{\partial g(\mathbf U)}{\partial x_{2,2}}&amp;amp;\cdots&amp;amp;\frac{\partial g(\mathbf U)}{\partial x_{2,n}}\\ \vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\ \frac{\partial g(\mathbf U)}{\partial x_{m,1}}&amp;amp;\frac{\partial g(\mathbf U)}{\partial x_{m,2}}&amp;amp;\cdots&amp;amp;\frac{\partial g(\mathbf U)}{\partial x_{m,n}}\\ \end{bmatrix}\\ =\left(\sum_{k}\sum_{l}\frac{\partial g(\mathbf U)}{\partial u_{k,l}}\frac{\partial u_{k,l}}{\partial x_{i,j}}\right)_{m\times n}=\left(tr\left[\left(\frac{\partial g(\mathbf U)}{\partial \mathbf U}\right)^{T}\frac{\partial \mathbf U}{\partial x_{i,j}}\right]\right)_{m\times n}\]&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;一概率与分布&quot;&gt;一、概率与分布&lt;/h2&gt;
&lt;h3 id=&quot;条件概率与独立事件&quot;&gt;1.1 条件概率与独立事件&lt;/h3&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;条件概率：已 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 事件发生的条件 &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt; 发生的概率，记 &lt;span class=&quot;math inline&quot;&gt;\(P(B\mid A)\)&lt;/span&gt; ，它等于事 &lt;span class=&quot;math inline&quot;&gt;\(AB\)&lt;/span&gt; 的概率相对于事 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 的概率，即：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P(B\mid A)=\frac {P(AB)}{P(A)}\]&lt;/span&gt; 其中必须 &lt;span class=&quot;math inline&quot;&gt;\(P(A) \gt 0\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;条件概率分布的链式法则：对 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个随机变 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf x_1,\mathbf x_2,\cdots,\mathbf x_n\)&lt;/span&gt; ，有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P(\mathbf x_1,\mathbf x_2,\cdots,\mathbf x_n)=P(\mathbf x_1)\prod_{i=2}^{n}P(\mathbf x_i \mid \mathbf x_1,\cdots,\mathbf x_{i-1})\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;两个随机变 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf x,\mathbf y\)&lt;/span&gt; 相互独立的数学描述：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\forall x\in \mathcal X,\forall y\in \mathcal Y, P(\mathbf x=x,\mathbf y=y)=P(\mathbf x=x)P(\mathbf y=y)\]&lt;/span&gt; 记作 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf x \bot \mathbf y\)&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;两个随机变 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf x,\mathbf y\)&lt;/span&gt; 关于随机变 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf z\)&lt;/span&gt; 条件独立的数学描述：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\forall x\in \mathcal X,\forall y\in \mathcal Y,\forall z \in\mathcal Z\\ P(\mathbf x=x,\mathbf y=y\mid \mathbf z=z)=P(\mathbf x=x\mid \mathbf z=z)P(\mathbf y=y\mid \mathbf z=z)\]&lt;/span&gt; 记作 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf x \bot \mathbf y \mid \mathbf z\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;联合概率分布&quot;&gt;1.2 联合概率分布&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;定 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 的联合分布为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P(a,b)=P\{{\mathbf x} \le a, {\mathbf y} \le b\}, - \infty \lt a,b \lt + \infty \]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 的分布可以从联合分布中得到：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ P_{\mathbf x}(a)=P\{{\mathbf x} \le a\}=P\{{\mathbf x} \le a, {\mathbf y} \le \infty\}=P(a,\infty), - \infty \lt a \lt + \infty \]&lt;/span&gt; 类似的 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 的分布可以从联合分布中得到：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ P_{\mathbf y}(b)=P\{{\mathbf y} \le b\}=P\{{\mathbf x} \le \infty, {\mathbf y} \le b\}=P(\infty,b), - \infty \lt b \lt + \infty \]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 都是离散随机变量时，定 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 的联合概率质量函数为 &lt;span class=&quot;math inline&quot;&gt;\(p(x,y)=P\{{\mathbf x}=x,{\mathbf y}=y\}\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 的概率质量函数分布为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p_{\mathbf x}(x)=\sum_{y \;:\;p(x,y) \gt 0}p(x,y) \\ p_{\mathbf y}(y)=\sum_{x \;:\;p(x,y) \gt 0}p(x,y)\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 联合地连续时，即存在函 &lt;span class=&quot;math inline&quot;&gt;\(p(x,y)\)&lt;/span&gt; ，使得对于所有的实数集 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt; 满足：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P\{{\mathbf x} \in A, {\mathbf y} \in B\}=\int_B \int_A p(x,y) dx dy\]&lt;/span&gt; 则函 &lt;span class=&quot;math inline&quot;&gt;\(p(x,y)\)&lt;/span&gt; 称 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 的概率密度函数。
&lt;ul&gt;&lt;li&gt;联合分布为&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P(a,b)=P\{{\mathbf x} \le a, {\mathbf y} \le b\}= \int_{-\infty}^{a} \int_{-\infty}^{b} p(x,y) dx dy\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 的概率密度函数以及分布函数分别为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P_{\mathbf x}(a)=\int_{-\infty}^{a} \int_{-\infty}^{\infty} p(x,y) dx dy =\int_{-\infty}^{a} p_{\mathbf x}(x)dx\\ P_{\mathbf y}(b)=\int_{-\infty}^{\infty} \int_{-\infty}^{b} p(x,y) dx dy=\int_{-\infty}^{b} p_{\mathbf y}(y)dy\\ p_{\mathbf x}(x)=\int_{-\infty}^{\infty} p(x,y) dy\\ p_{\mathbf y}(y)=\int_{-\infty}^{\infty} p(x,y) dx\]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二期望&quot;&gt;二、期望&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;期望：（是概率分布的泛函，函数的函数）
&lt;ul&gt;&lt;li&gt;离散型随机变 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 的期望：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbb E[{\mathbf x}]=\sum_{i=1}^{\infty}x_ip_i\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;若级数不收敛，则期望不存在&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;连续性随机变 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 的期望：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbb E[{\mathbf x}]=\int_{-\infty}^{\infty}xp(x)dx\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;若极限不收敛，则期望不存在&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;期望描述了随机变量的平均情况，衡量了随机变 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 的均值&lt;/li&gt;
&lt;li&gt;定理： &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}=g({\mathbf x})\)&lt;/span&gt; 均为随机变量 &lt;span class=&quot;math inline&quot;&gt;\(g(\cdot)\)&lt;/span&gt; 是连续函数
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 为离散型随机变量， &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 的期望存在，则：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbb E[{\mathbf y}]=\mathbb E[g({\mathbf x})]=\sum_{i=1}^{\infty}g(x_i)p_i\]&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 为连续型随机变量， &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 的期望存在，则：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbb E[{\mathbf y}]=\mathbb E[g({\mathbf x})]=\int_{-\infty}^{\infty}g(x)p(x)dx\]&lt;/span&gt; 该定理的意义在于：当 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb E({\mathbf y})\)&lt;/span&gt; 时，不必计算 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 的分布，只需要利 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 的分布即可。该定理可以推广至两个或者两个以上随机变量的情况。此时：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathbb E[Z]=\mathbb E[g({\mathbf x},{\mathbf y})]=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}g(x,y)p(x,y)dxdy\]&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;上述公式也记做：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbb E_{\mathbf x\sim P}[g(x)]=\sum_{x}g(x)p(x)\\ \mathbb E_{\mathbf x\sim P}[g(x)]=\int g(x)p(x)dx\\ \mathbb E_{\mathbf x,\mathbf y\sim P}[g(x)]\int g(x,y)p(x,y)dxdy\]&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;期望性质：
&lt;ul&gt;&lt;li&gt;常数的期望就是常数本身&lt;/li&gt;
&lt;li&gt;对常 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; 有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbb E[C{\mathbf x}]=C\mathbb E[{\mathbf x}]\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对两个随机变 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x},{\mathbf y}\)&lt;/span&gt; ，有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbb E[{\mathbf x}+{\mathbf y}]=\mathbb E[{\mathbf x}]+\mathbb E[{\mathbf y}]\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;该结论可以推广到任意有限个随机变量之和的情况&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对两个相互独立的随机变量，有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbb E[{\mathbf x}{\mathbf y}]=\mathbb E[{\mathbf x}]\mathbb E[{\mathbf y}]\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;该结论可以推广到任意有限个相互独立的随机变量之积的情况&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三方差&quot;&gt;三、方差&lt;/h2&gt;
&lt;h3 id=&quot;方差&quot;&gt;3.1 方差&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;对随机变 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(\mathbb E[({\mathbf x}-\mathbb E[{\mathbf x}])^{2}]\)&lt;/span&gt; 存在，则称它 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 的方差，记 &lt;span class=&quot;math inline&quot;&gt;\(Var[{\mathbf x}]\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 的标准差为方差的开平方。即：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[Var[{\mathbf x}]=\mathbb E[({\mathbf x}-\mathbb E[{\mathbf x}])^{2}] \\ \sigma=\sqrt{Var[{\mathbf x}]}\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;方差度量了随机变量 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 与期望值偏离的程度，衡量了 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 取值分散程度的一个尺度。&lt;/li&gt;
&lt;li&gt;由于绝对值 &lt;span class=&quot;math inline&quot;&gt;\(|{\mathbf x}-\mathbb E[{\mathbf x}] |\)&lt;/span&gt; 带有绝对值，不方便运算，因此采用平方来计算。又因为 &lt;span class=&quot;math inline&quot;&gt;\(|{\mathbf x}-\mathbb E[{\mathbf x}]|^2\)&lt;/span&gt; 是一个随机变量，因此对它取期望，即得 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 与期望值偏离的均值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;根据定义可知：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[Var[{\mathbf x}]=\mathbb E[({\mathbf x}-\mathbb E[{\mathbf x}])^{2}]=\mathbb E[{\mathbf x}^{2}]-(\mathbb E[{\mathbf x}])^{2}\\ Var [f(\mathbf x)]=\mathbb E[(f(\mathbf x)-\mathbb E[f(\mathbf x)])^{2}]\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对于一个期望 &lt;span class=&quot;math inline&quot;&gt;\(\mu\)&lt;/span&gt; ，方差 &lt;span class=&quot;math inline&quot;&gt;\(\sigma^{2},\sigma \ne 0\)&lt;/span&gt; 的随机变 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; ，随机变 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}^{*}=\frac {{\mathbf x}-\mu}{\sigma}\)&lt;/span&gt; 的数学期望为0，方差为1。 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}^{\ast}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 的标准化变量&lt;/li&gt;
&lt;li&gt;方差的性质：
&lt;ul&gt;&lt;li&gt;常数的方差恒为0&lt;/li&gt;
&lt;li&gt;对常 &lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(Var[C{\mathbf x}]=C^{2}Var[{\mathbf x}]\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对两个随机变 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x},{\mathbf y}\)&lt;/span&gt; ，有 $Var[{\mathbf x}+{\mathbf y}]=Var[{\mathbf x}] +Var[{\mathbf y}] +2\mathbb E[({\mathbf x}-\mathbb E[{\mathbf x}])({\mathbf y}-\mathbb E[{\mathbf y}])] $
&lt;ul&gt;&lt;li&gt;当 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 相互独立时，有 $Var[{\mathbf x}+{\mathbf y}] = Var[{\mathbf x}] +Var[{\mathbf y}] $ 。可以推广至任意有限多个相互独立的随机变量之和的情况&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(Var [{\mathbf x}] =0\)&lt;/span&gt; 的充要条件 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 以概率1取常数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;协方差与相关系数&quot;&gt;3.2 协方差与相关系数&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;对于二维随机变 &lt;span class=&quot;math inline&quot;&gt;\(({\mathbf x},{\mathbf y})\)&lt;/span&gt; ，可以讨论描 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 之间相互关系的数字特征。
&lt;ul&gt;&lt;li&gt;定义 $\mathbb E[({\mathbf x}-\mathbb E[{\mathbf x}])({\mathbf y}-\mathbb E [{\mathbf y}])] $ 为随机变量 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 的协方差，记作 $ Cov[ {\mathbf x},{\mathbf y}]=\mathbb E[({\mathbf x}-\mathbb E[{\mathbf x}])({\mathbf y}-\mathbb E [{\mathbf y}])]$ 。&lt;/li&gt;
&lt;li&gt;定义 &lt;span class=&quot;math inline&quot;&gt;\(\rho_{{\mathbf x}{\mathbf y}}=\frac {Cov[{\mathbf x},{\mathbf y}]}{\sqrt{Var[{\mathbf x}] }\sqrt{Var[{\mathbf y}]}}\)&lt;/span&gt; 为随机变量 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 　的相关系数，它是协方差的归一化。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;由定义可知：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[Cov[ {\mathbf x},{\mathbf y}] =Cov[ {\mathbf y},{\mathbf x}] \\ Cov [{\mathbf x},{\mathbf x}] =Var [{\mathbf x}] \\ Var [{\mathbf x}+{\mathbf y}] =Var [{\mathbf x}] +Var [{\mathbf y}] +2Cov [{\mathbf x},{\mathbf y}] \]&lt;/span&gt; ​&lt;/li&gt;
&lt;li&gt;协方差的性质：
&lt;ul&gt;&lt;li&gt;$Cov [a{\mathbf x},b{\mathbf y}] =abCov [{\mathbf x},{\mathbf y}] $ , &lt;span class=&quot;math inline&quot;&gt;\(a,b\)&lt;/span&gt; 为常数&lt;/li&gt;
&lt;li&gt;$Cov[ {\mathbf x}_1+{\mathbf x}_2,{\mathbf y} ]=Cov [{\mathbf x}_1,{\mathbf y}] +Cov [{\mathbf x}_2,{\mathbf y}] $&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(Cov [f(\mathbf x),g(\mathbf y)]=\mathbb E[(f(\mathbf x)-\mathbb E[f(\mathbf x)])(g(\mathbf y)-\mathbb E[g(\mathbf y)])]\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\rho[f(\mathbf x),g(\mathbf y)]=\frac {Cov[f(\mathbf x),g(\mathbf y)]}{\sqrt{Var[f(\mathbf x)] }\sqrt{Var[g(\mathbf y)]}}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;协方差的物理意义：
&lt;ul&gt;&lt;li&gt;协方差的绝对值越大，说明两个随机变量都远离它们的均值。&lt;/li&gt;
&lt;li&gt;协方差如果为正，则说明两个随机变量同时趋向于取较大的值；如果为负，则说明一个随变量趋向于取较大的值，另一个随机变量趋向于取较小的值&lt;/li&gt;
&lt;li&gt;两个随机变量的独立性可以导出协方差为零。但是两个随机变量的协方差为零无法导出独立性
&lt;ul&gt;&lt;li&gt;因为独立性也包括：没有非线性关系。有可能两个随机变量是非独立的，但是协方差为零&lt;/li&gt;
&lt;li&gt;假设随机变 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf x\sim U[-1,1]\)&lt;/span&gt; 。定义随机变 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf s\)&lt;/span&gt; 的概率分布函数为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P(\mathbf s=1)= \frac 12P(\mathbf s=-1)= \frac 12 \]&lt;/span&gt; 定义随机变 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf y=\mathbf {sx}\)&lt;/span&gt; ，则随机变 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf x,\mathbf y\)&lt;/span&gt; 是非独立的，但是有 &lt;span class=&quot;math inline&quot;&gt;\(Cov[\mathbf x,\mathbf y]=0\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;相关系数的物理意义：考虑以随机变 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 的线性函 &lt;span class=&quot;math inline&quot;&gt;\(a+b{\mathbf x}\)&lt;/span&gt; 来近似表 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 。以均方误差&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[e=\mathbb E[({\mathbf y}-(a+b{\mathbf x}))^{2}]=\mathbb E[{\mathbf y}^{2}] +b^{2}\mathbb E[{\mathbf x}^{2}] +a^{2}-2b\mathbb E[{\mathbf x}{\mathbf y}] +2ab\mathbb E[{\mathbf x}] -2a\mathbb E [{\mathbf y}] \]&lt;/span&gt; 来衡量 &lt;span class=&quot;math inline&quot;&gt;\(a+b{\mathbf x}\)&lt;/span&gt; 近似表 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 的好坏程度 &lt;span class=&quot;math inline&quot;&gt;\(e\)&lt;/span&gt; 越小表示近似程度越高。为求得&lt;br/&gt;最好的近似，则 &lt;span class=&quot;math inline&quot;&gt;\(a,b\)&lt;/span&gt; 分别取偏导数，得到：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[a_0=\mathbb E[{\mathbf y}] -b_0\mathbb E[{\mathbf x}] =\mathbb E[{\mathbf y}] -\mathbb E[{\mathbf x}] \frac{Cov [{\mathbf x},{\mathbf y}]}{Var [{\mathbf x}] }\\ b_0=\frac{Cov[ {\mathbf x},{\mathbf y}] }{Var[ {\mathbf x}] }\\ \min(e)=\mathbb E[({\mathbf y}-(a_0+b_0{\mathbf x}))^{2}]=(1-\rho^{2}_{{\mathbf x}{\mathbf y}})Var [{\mathbf y}] \]&lt;/span&gt; 因此有以下定理：
&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\rho_{{\mathbf x}{\mathbf y}}=0\)&lt;/span&gt; 时， &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 不相关。
&lt;ul&gt;&lt;li&gt;不相关是就线性关系来讲的，而相互独立是一般关系而言的。&lt;/li&gt;
&lt;li&gt;相互独立一定不相关；不相关则未必独立。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;协方差矩阵&quot;&gt;3.3 协方差矩阵&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;矩： &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 是随机变量
&lt;ul&gt;&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb E[{\mathbf x}^{k}] ,k=1,2,\cdots\)&lt;/span&gt; 存在，则称它为 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 的 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 阶原点矩，简称 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 阶矩&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb E[({\mathbf x}-\mathbb E[{\mathbf x}])^{k}] ,k=2,3,\cdots\)&lt;/span&gt; 存在，则称它为 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 的 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 阶中心矩&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb E[{\mathbf x}^{k}{\mathbf y}^{l}] ,k,l=1,2,\cdots\)&lt;/span&gt; 存在，则称它为 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 的 $ k+l$ 阶混合矩&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb E[({\mathbf x}-\mathbb E[{\mathbf x}])^{k}({\mathbf y}-\mathbb E[{\mathbf y}])^{l}] ,k,l=1,2,\cdots\)&lt;/span&gt; 存在，则称它为 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}\)&lt;/span&gt; 的 &lt;span class=&quot;math inline&quot;&gt;\(k+l\)&lt;/span&gt; 阶混合中心矩&lt;br/&gt;因此期望是一阶原点矩，方差是二阶中心矩，协方差是二阶混合中心矩&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;协方差矩阵：二维随机变 &lt;span class=&quot;math inline&quot;&gt;\(({\mathbf x}_1,{\mathbf x}_2)\)&lt;/span&gt; 有四个二阶中心矩（设他们都存在），记作：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align} c_{11}&amp;amp;=\mathbb E[({\mathbf x}_1-\mathbb E[{\mathbf x}_1])^{2}] \\ c_{12}&amp;amp;=\mathbb E[({\mathbf x}_1-\mathbb E[{\mathbf x}_1])( {\mathbf x}_2-\mathbb E[{\mathbf x}_2]) ] \\ c_{21}&amp;amp;=\mathbb E[( {\mathbf x}_2-\mathbb E[{\mathbf x}_2])({\mathbf x}_1-\mathbb E[{\mathbf x}_1] ) ] \\ c_{22}&amp;amp;=\mathbb E[({\mathbf x}_2-\mathbb E[{\mathbf x}_2])^{2}] \\ \end{align}\]&lt;/span&gt; 这个矩阵称作随机变 &lt;span class=&quot;math inline&quot;&gt;\(({\mathbf x}_1,{\mathbf x}_2)\)&lt;/span&gt; 的协方差矩阵。&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 维随机变 &lt;span class=&quot;math inline&quot;&gt;\(({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n)\)&lt;/span&gt; 的二阶混合中心 &lt;span class=&quot;math inline&quot;&gt;\(c_{ij}=Cov [{\mathbf x}_i,{\mathbf x}_j] =\mathbb E[({\mathbf x}_i-\mathbb E[{\mathbf x}_i] )( {\mathbf x}_j-\mathbb E[{\mathbf x}_j] ) ] ,i,j=1,2,\cdots,n\)&lt;/span&gt; ,都存在，则称矩阵&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf C= \begin{bmatrix} c_{11} &amp;amp; c_{12} &amp;amp; \cdots &amp;amp; c_{1n} \\ c_{21} &amp;amp; c_{22} &amp;amp; \cdots &amp;amp; c_{2n} \\ \vdots &amp;amp;\vdots &amp;amp;\ddots &amp;amp;\vdots \\ c_{n1} &amp;amp; c_{n2} &amp;amp; \cdots &amp;amp; c_{nn} \\ \end{bmatrix}\]&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 维随机变 &lt;span class=&quot;math inline&quot;&gt;\(({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n)\)&lt;/span&gt; 的协方差矩阵。
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;6.5&quot;&gt;
&lt;p&gt;由于 &lt;span class=&quot;math inline&quot;&gt;\(c_{ij}=c_{ji}, i\ne j, i,j=1,2,\cdots,n\)&lt;/span&gt; 因此协方差矩阵是个对称阵&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 维随机变量的分布是不知道的，或者太复杂以致数学上不容易处理。因此实际中协方差矩阵非常重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;四大数定律及中心极限定理&quot;&gt;四、大数定律及中心极限定理&lt;/h2&gt;
&lt;h3 id=&quot;切比雪夫不等式&quot;&gt;4.1 切比雪夫不等式&lt;/h3&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;切比雪夫不等式：随机变 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 具有期 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb E[{\mathbf x}] =\mu\)&lt;/span&gt; ，方 &lt;span class=&quot;math inline&quot;&gt;\(Var({\mathbf x})=\sigma^{2}\)&lt;/span&gt; ,对于任意正 &lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt; ，不等式&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P\{|{\mathbf x}-\mu| \ge \varepsilon\} \le \frac {\sigma^{2}}{\varepsilon^{2}}\]&lt;/span&gt; 成立&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;其意义是：对于距 $\mathbb E[{\mathbf x}] $ 足够远的地方（距离大于等 &lt;span class=&quot;math inline&quot;&gt;\(\varepsilon\)&lt;/span&gt; ），事件出现的概率是小于等 $ \frac {\sigma^{2}}{\varepsilon^{2}}$ ；即事件出现在区 &lt;span class=&quot;math inline&quot;&gt;\([\mu-\varepsilon , \mu+\varepsilon]\)&lt;/span&gt; 的概率大 &lt;span class=&quot;math inline&quot;&gt;\(1- \frac {\sigma^{2}}{\varepsilon^{2}}\)&lt;/span&gt;&lt;br/&gt;该不等式给出了随机变 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 在分布未知的情况下，事 &lt;span class=&quot;math inline&quot;&gt;\(\{|{\mathbf x}-\mu| \le \varepsilon\}\)&lt;/span&gt; 的下限估计（ &lt;span class=&quot;math inline&quot;&gt;\(P\{|{\mathbf x}-\mu| \lt 3\sigma\} \ge 0.8889\)&lt;/span&gt;&lt;br/&gt;证明：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P\{|{\mathbf x}-\mu| \ge \varepsilon\}=\int_{|x-\mu| \ge \varepsilon}p(x)dx \le \int_{|x-\mu| \ge \varepsilon} \frac{|x-\mu|^{2}}{\varepsilon^{2}}p(x)dx \\ \le \frac {1}{\varepsilon^{2}}\int_{-\infty}^{\infty}(x-\mu)^{2}p(x)dx=\frac{\sigma^{2}}{\varepsilon^{2}}\]&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;切比雪夫不等式的特殊情况：设随机变 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n,\cdots\)&lt;/span&gt; 相互独立，且具有相同的数学期望和方差 $ \mathbb E[{\mathbf x}_k] =\mu, Var[{\mathbf x}_k] =\sigma^{2},k=1,2,\cdots$ 。作 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个随机变量的算术平均 $ \overline {\mathbf x} =\frac {1}{n} \sum _{k=1}^{n}{\mathbf x}_k$ ，则对于任意正 $ \varepsilon$ 有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\lim_{n\rightarrow \infty}P\{|\overline {\mathbf x}-\mu| \lt \varepsilon\}=\lim_{n\rightarrow \infty}P\{|\frac{1}{n}\sum_{k=1}^{n}{\mathbf x}_k-\mu| \lt \varepsilon\} =1\]&lt;/span&gt; 证明：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbb E[\frac{1}{n}\sum_{k=1}^{n}{\mathbf x}_k]=\mu\\ Var[\frac{1}{n}\sum_{k=1}^{n}{\mathbf x}_k]=\frac{\sigma^{2}}{n}\]&lt;/span&gt; 有切比雪夫不等式，以 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 趋于无穷时，可以证明。详细过程省略&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;大数定理&quot;&gt;4.2 大数定理&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;依概率收敛： &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}_1,{\mathbf y}_2,\cdots,{\mathbf y}_n,\cdots\)&lt;/span&gt; 是一个随机变量序列 &lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt; 是一个常数。若对于任意正 $ \varepsilon$ 有 &lt;span class=&quot;math inline&quot;&gt;\(\lim_{n\rightarrow \infty}P\{|{\mathbf y}_{n}-a| \le \varepsilon \}=1\)&lt;/span&gt; ,则称序 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}_1,{\mathbf y}_2,\cdots,{\mathbf y}_n,\cdots\)&lt;/span&gt; 依概率收敛 &lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt; 。记作 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}_{n} \stackrel{P}{\rightarrow} a\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;依概率收敛的两个含义：
&lt;ul&gt;&lt;li&gt;收敛：表明这是一个随机变量序列，而不是某个随机变量；且序列是无限长，而不是有限长&lt;/li&gt;
&lt;li&gt;依概率：表明序列无穷远处的随机变量 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}_{\infty}\)&lt;/span&gt; 的分布规律为：绝大部分分布于点 &lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt; ，极少数位于 &lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt; 之外。且分布于 &lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt; 之外的事件发生的概率之和为0&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;大数定理一：设随机变 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n,\cdots\)&lt;/span&gt; 相互独立，且具有相同的数学期望和方差 $ \mathbb E[{\mathbf x}_k] =\mu, Var[{\mathbf x}_k] =\sigma^{2},k=1,2,\cdots$ 。则序列 $ \overline {\mathbf x} =\frac {1}{n} \sum _{k=1}^{n}{\mathbf x}_k$ 依概率收敛 &lt;span class=&quot;math inline&quot;&gt;\(\mu\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(\overline {\mathbf x} \stackrel{P}{\rightarrow} \mu\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;这里并没有要求随机变量 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n,\cdots\)&lt;/span&gt; 同分布&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;伯努利大数定理： &lt;span class=&quot;math inline&quot;&gt;\(n_A\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 次独立重复实验中事 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 发生的次数 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 是事 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 在每次试验中发生的概率。则对于任意正 $ \varepsilon$ 有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\lim_{n \rightarrow \infty}P\{|\frac{n_{A}}{n}-p| \lt \varepsilon\}=1 \\ or: \quad \lim_{n \rightarrow \infty}P\{|\frac{n_{A}}{n}-p| \ge \varepsilon\}=0\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;即：当独立重复实验执行非常大的次数时，事件 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt; 发生的频率逼近于它的概率&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;辛钦定理：设随机变 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n,\cdots\)&lt;/span&gt; 相互独立，服从同一分布，且具有相同的数学期望 $ \mathbb E[{\mathbf x}_k] =\mu,k=1,2,\cdots$ 。则对于任意正 $ \varepsilon$ 有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\lim_{n\rightarrow \infty}P\{|\frac{1}{n}\sum_{k=1}^{n}{\mathbf x}_k-\mu| \lt \varepsilon\} =1\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;这里并没有要求随机变量 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n,\cdots\)&lt;/span&gt; 的方差存在&lt;/li&gt;
&lt;li&gt;伯努利大数定理是亲钦定理的特殊情况。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;中心极限定理&quot;&gt;4.3 中心极限定理&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;独立同分布的中心极限定理：设随机变 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n\)&lt;/span&gt; 独立同分布，且具有数学期望和方差 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb E[{\mathbf x}_k] =\mu, Var[{\mathbf x}_k] =\sigma^{2} \gt 0,k=1,2,\cdots\)&lt;/span&gt; ，则随机变量之 &lt;span class=&quot;math inline&quot;&gt;\(\overline {S{\mathbf x}_n}=\sum_{k=1}^{n} {\mathbf x}_k\)&lt;/span&gt; 的标准变化量:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[{\mathbf y}_n=\frac{\overline {S{\mathbf x}_n}-\mathbb E[\overline {S{\mathbf x}_n}] }{\sqrt{Var[\overline {S{\mathbf x}_n}] }}=\frac{\overline {S{\mathbf x}_n}-n\mu}{\sqrt n \sigma}\]&lt;/span&gt; 的概率分布函 &lt;span class=&quot;math inline&quot;&gt;\(F_n(x)\)&lt;/span&gt; 对于任 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 满足：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\lim_{n\rightarrow \infty}F_n(x)=\lim_{n\rightarrow \infty}P\{{\mathbf y}_n \le x\}\\ =\lim_{n\rightarrow \infty}P\{\frac{\sum_{k=1}^{n} {\mathbf x}_k-n\mu}{\sqrt n \sigma} \le x\}\\ = \int_{-\infty}^{x} \frac{1}{\sqrt{2\pi}}e^{-t^{2}/2}dt=\Phi(x)\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;其物理意义为：均值方差为 &lt;span class=&quot;math inline&quot;&gt;\(\mu,\sigma^{2}\)&lt;/span&gt; 的独立同分布的随机变量 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n\)&lt;/span&gt; 之和 &lt;span class=&quot;math inline&quot;&gt;\(\overline {S{\mathbf x}_n}=\sum_{k=1}^{n} {\mathbf x}_k\)&lt;/span&gt; 的标准变化量 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}_n\)&lt;/span&gt; ，当 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 充分大时，其分布近似与标准正态分布。即 &lt;span class=&quot;math inline&quot;&gt;\(\overline {S{\mathbf x}_n}=\sum_{k=1}^{n} {\mathbf x}_k\)&lt;/span&gt; 在 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 充分大时，其分布近似于 &lt;span class=&quot;math inline&quot;&gt;\(N(n\mu,n\sigma^{2})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;一般情况下，很难求出 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个随机变量之和的分布函数。因此当 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 充分大时，可以通过正态分布来做理论上的分析或者计算。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Liapunov定理：设随机变 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n,\cdots\)&lt;/span&gt; 相互独立，具有数学期望和方差 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb E[{\mathbf x}_k] =\mu_k,Var[{\mathbf x}_k] =\sigma_k^{2} \gt 0, k=1,2,\cdots\)&lt;/span&gt; ，记 &lt;span class=&quot;math inline&quot;&gt;\(B_n^{2}=\sum_{k=1}^{n}\sigma_k^{2}\)&lt;/span&gt; 。&lt;br/&gt;若存在正 &lt;span class=&quot;math inline&quot;&gt;\(\delta\)&lt;/span&gt; ，使得 &lt;span class=&quot;math inline&quot;&gt;\(n \rightarrow \infty\)&lt;/span&gt; 时，&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{1}{B_n^{2+\delta}}\sum_{k=1}^{n}\mathbb E [|{\mathbf x}_k-\mu_k|^{2+\delta}] \rightarrow 0\]&lt;/span&gt; 则随机变量之 &lt;span class=&quot;math inline&quot;&gt;\(\overline {S{\mathbf x}_n}=\sum_{k=1}^{n} {\mathbf x}_k\)&lt;/span&gt; 的标准变化量:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[Z_n=\frac{\overline {S{\mathbf x}_n}-\mathbb E[\overline {S{\mathbf x}_n}] }{\sqrt{Var [\overline {S{\mathbf x}_n}] }}=\frac{\overline {S{\mathbf x}_n}-\sum_{k=1}^{n}\mu_k}{B_n}\]&lt;/span&gt; 的概率分布函 &lt;span class=&quot;math inline&quot;&gt;\(F_n(x)\)&lt;/span&gt; 对于任 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 满足：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\lim_{n\rightarrow \infty}F_n(x)=\lim_{n\rightarrow \infty}P\{Z_n \le x\}\\ =\lim_{n\rightarrow \infty}P\{\frac{\sum_{k=1}^{n} {\mathbf x}_k-\sum_{k=1}^{n}\mu_k}{B_n} \le x\}\\ = \int_{-\infty}^{x} \frac{1}{\sqrt{2\pi}}e^{-t^{2}/ 2}dt=\Phi(x)\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;其物理意义为：相互独立的随机变量 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n,\cdots\)&lt;/span&gt; 之和 &lt;span class=&quot;math inline&quot;&gt;\(\overline {S{\mathbf x}_n}=\sum_{k=1}^{n} {\mathbf x}_k\)&lt;/span&gt; 的衍生随机变量序 &lt;span class=&quot;math inline&quot;&gt;\(Z_n=\frac{\overline {S{\mathbf x}_n}-\sum_{k=1}^{n}\mu_k}{B_n}\)&lt;/span&gt; ，当 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 充分大时，其分布近似与标准正态分布。&lt;/li&gt;
&lt;li&gt;这里并不要求 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n,\cdots\)&lt;/span&gt; 同分布&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Demoiver-Laplace定理：设随机变量序 &lt;span class=&quot;math inline&quot;&gt;\(\eta_n,n=1,2,...\)&lt;/span&gt; 服从参数 &lt;span class=&quot;math inline&quot;&gt;\(n, p(0 \lt p \lt 1)\)&lt;/span&gt; 的二项分布，则对于任 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; ,有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\lim_{n\rightarrow \infty}P\{\frac{\eta_n-np}{\sqrt{np(1-p)}} \le x\}=\int_{-\infty}^{x} \frac{1}{\sqrt{2\pi}}e^{-t^{2}\mid 2}dt=\Phi(x)\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;该定理表明，正态分布是二项分布的极限分布。当 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 充分大时，可以利用正态分布来计算二项分布的概率。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;五不确定性来源&quot;&gt;五、不确定性来源&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;机器学习中不确定性有三个来源:
&lt;ul&gt;&lt;li&gt;模型本身固有的随机性。如量子力学中的粒子动力学方程。&lt;/li&gt;
&lt;li&gt;不完全的观测。即使是确定性系统，当无法观测所有驱动变量时，结果也是随机的。&lt;/li&gt;
&lt;li&gt;不完全建模。有时必须放弃一些观测信息。
&lt;ul&gt;&lt;li&gt;如机器人建模中：虽然可以精确观察机器人周围每个对象的位置；但在预测这些对象将来的位置时，对空间进行了离散化。则位置预测将带有不确定性。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;六常见概率分布&quot;&gt;六、常见概率分布&lt;/h2&gt;
&lt;h3 id=&quot;均匀分布&quot;&gt;6.1 均匀分布&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;离散随机变量的均匀分布：假 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf x\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 个取值 &lt;span class=&quot;math inline&quot;&gt;\(x_1,x_2,\cdots,x_k\)&lt;/span&gt; ，则均匀分布的概率密度函数(&lt;code&gt;probability mass function:PMF&lt;/code&gt;)为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P(\mathbf x=x_i) =\frac 1k,\quad i=1,2,\cdots,k\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;连续随机变量的均匀分布：假 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf x\)&lt;/span&gt; 在&lt;code&gt;[a,b]&lt;/code&gt;上均匀分布，则其概率密度函数(&lt;code&gt;probability density function：PDF&lt;/code&gt;)为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p(\mathbf x=x)=\begin{cases} 0,&amp;amp;x\notin [a,b]\\ \frac{1}{b-a},&amp;amp;x \in [a,b]\\ \end{cases} \]&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;二项分布&quot;&gt;6.2 二项分布&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;伯努利分布（二项分布）：参数 &lt;span class=&quot;math inline&quot;&gt;\(\phi\in [0,1]\)&lt;/span&gt; 。随机变 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf x \in \{0,1\}\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;概率分布函数为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P(\mathbf x=x)=\phi^{x}(1-\phi)^{1-x}\;,x \in \{0,1\}\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;期望： &lt;span class=&quot;math inline&quot;&gt;\(\mathbb E_{\mathbf x}[x]=\phi\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;方差： &lt;span class=&quot;math inline&quot;&gt;\(Var_{\mathbf x}[x]=\phi(1-\phi)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;categorical&lt;/code&gt;分布：它是二项分布的推广，也称作&lt;code&gt;multinoulli&lt;/code&gt;分布。假设随机变 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf x \in \{1,2,\cdots,K\}\)&lt;/span&gt; ，其概率分布函数为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P(\mathbf x=1)=\theta_1\\ P(\mathbf x=2)=\theta_2\\ \vdots\\ P(\mathbf x=K-1)=\theta_{K-1}\\ P(\mathbf x=K)=1-\sum_{i=1}^{K-1}\theta_i \\\]&lt;/span&gt; 其 &lt;span class=&quot;math inline&quot;&gt;\(\theta_i\)&lt;/span&gt; 为参数，它满 &lt;span class=&quot;math inline&quot;&gt;\(\theta_i \in [0,1]\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=1}^{K-1}\theta_i \in [0,1]\)&lt;/span&gt; 。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;高斯分布&quot;&gt;6.3 高斯分布&lt;/h3&gt;
&lt;h4 id=&quot;一维正态分布&quot;&gt;6.3.1 一维正态分布&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;正态分布的概率密度函数为:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p(x)=\frac{1}{\sqrt{2\pi}\sigma}e^{-(x-\mu)^{2}/ (2\sigma^{2})}, -\infty \lt x \lt \infty\]&lt;/span&gt; 其 $\mu,\sigma(\sigma \gt 0) $ 为常数。
&lt;ul&gt;&lt;li&gt;若随机变量 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 的概率密度函数如上所述，则称 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}\)&lt;/span&gt; 服从参数为 &lt;span class=&quot;math inline&quot;&gt;\(\mu,\sigma\)&lt;/span&gt; 的正态分布或者高斯分布，记作 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x} \sim N(\mu,\sigma^{2})\)&lt;/span&gt; 。&lt;/li&gt;
&lt;li&gt;特别的，当 &lt;span class=&quot;math inline&quot;&gt;\(\mu=0,\sigma=1\)&lt;/span&gt; 时，称为标准正态分布，其概率密度函数记作 &lt;span class=&quot;math inline&quot;&gt;\(\varphi(x)\)&lt;/span&gt; , 分布函数记作 &lt;span class=&quot;math inline&quot;&gt;\(\Phi(x)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;为了计算方便，有时也记作：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathcal N(x;\mu,\beta^{-1}) =\sqrt{\frac{\beta}{2\pi}}\exp\left(-\frac{1}{2}\beta(x-\mu)^{2}\right)\]&lt;/span&gt; 其 &lt;span class=&quot;math inline&quot;&gt;\(\beta \in (0,\infty)\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;正态分布是很多应用中的合理选择。如果某个随机变量取值范围是实数，且对它的概率分布一无所知，通常会假设它服从正态分布。有两个原因支持这一选择：&lt;/li&gt;
&lt;li&gt;建模的任务的真实分布通常都确实接近正态分布。中心极限定理表明，多个独立随机变量的和近似正态分布。&lt;/li&gt;
&lt;li&gt;在具有相同方差的所有可能的概率分布中，正态分布的熵最大（即不确定性最大）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;正态分布的概率密度函数性质：
&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\({\mathbf x} \sim N(\mu,\sigma^{2})\)&lt;/span&gt; 则 &lt;span class=&quot;math inline&quot;&gt;\(\frac{{\mathbf x}-\mu}{\sigma} \sim N(0,1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;有限个相互独立的正态随机变量的线性组合仍然服从正态分布。&lt;/li&gt;
&lt;li&gt;正态分布的期望就 &lt;span class=&quot;math inline&quot;&gt;\(\mu\)&lt;/span&gt; ，方差就 &lt;span class=&quot;math inline&quot;&gt;\(\sigma^{2}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;若随机变 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}_i \sim N(\mu_i,\sigma_i^{2}),i=1,2,\cdots,n\)&lt;/span&gt; 且它们相互独立，则它们的线性组合：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(C_1{\mathbf x}_1+C_2{\mathbf x}_2+\cdots+C_n{\mathbf x}_n\)&lt;/span&gt; 其中 &lt;span class=&quot;math inline&quot;&gt;\(C_1,C_2,\cdots,C_n\)&lt;/span&gt; 不全是为0的常数）仍然服从正态分布，且：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[C_1{\mathbf x}_1+C_2{\mathbf x}_2+\cdots+C_n{\mathbf x}_n \sim N(\sum_{i=1}^{n}C_i\mu_i,\sum_{i=1}^{n}C_i^{2}\sigma_i^{2})\]&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;多维正态分布&quot;&gt;6.3.2 多维正态分布&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;二维正态随机变 &lt;span class=&quot;math inline&quot;&gt;\(({\mathbf x}_1,{\mathbf x}_2)\)&lt;/span&gt; 的概率密度为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p(x_1,x_2)=\\ \frac{1}{2\pi\sigma_1\sigma_2\sqrt{1-\rho^{2}}}\exp\{\frac{-1}{2(1-\rho^{2})}[\frac{(x_1-\mu_1)^{2}}{\sigma_1^{2}}-2\rho\frac{(x_1-\mu_1)(x_2-\mu_2)}{\sigma_1\sigma_2}+\frac{(x_2-\mu_2)^{2}}{\sigma_2^{2}}]\}\]&lt;/span&gt; 可以计算出:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p_{\mathbf x}(x)=\frac{1}{\sqrt{2\pi}\sigma_1}e^{-(x-\mu_1)^{2}/ (2\sigma_1^{2})}, -\infty \lt x \lt \infty \\ p_{\mathbf y}(y)=\frac{1}{\sqrt{2\pi}\sigma_2}e^{-(y-\mu_2)^{2}/ (2\sigma_2^{2})}, -\infty \lt y \lt \infty\\ \mathbb E[{\mathbf x}] =\mu_1 \\ \mathbb E[{\mathbf y}] =\mu_2 \\ Var[{\mathbf x}] =\sigma_1^{2} \\ Var[{\mathbf y}]=\sigma_2^{2}\\ Cov[{\mathbf x},{\mathbf y}]=\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}(x-\mu_1)(y-\mu_2)p(x,y)dxdy=\rho \sigma_1\sigma_2\\ \rho_{{\mathbf x}{\mathbf y}}=\rho\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;引入矩阵：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf{\vec {\mathbf x}}=\begin{bmatrix} x_1 \\ x_2 \end{bmatrix} \quad \mathbf{\vec \mu}=\begin{bmatrix} \mu_1 \\ \mu_2 \end{bmatrix}\\ \mathbf{\Sigma}=\begin{bmatrix} c_{11} &amp;amp;c_{12}\\ c_{21} &amp;amp;c_{22} \end{bmatrix} = \begin{bmatrix} \sigma_1^{2} &amp;amp; \rho \sigma_1 \sigma_2 \\ \rho \sigma_1 \sigma_2 &amp;amp; \sigma_2^{2} \end{bmatrix}\]&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\mathbf \Sigma\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(({\mathbf x}_1,{\mathbf x}_2)\)&lt;/span&gt; 的协方差矩阵。其行列式 &lt;span class=&quot;math inline&quot;&gt;\(\det \mathbf{\Sigma} =\sigma_1^{2}\sigma_2^{2}(1-\rho^{2})\)&lt;/span&gt; ，其逆矩阵为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf{\Sigma}^{-1}=\frac{1}{\det\mathbf \Sigma}\begin{bmatrix} \sigma_2^{2} &amp;amp; -\rho \sigma_1 \sigma_2 \\ -\rho \sigma_1 \sigma_2 &amp;amp; \sigma_1^{2} \end{bmatrix}\]&lt;/span&gt; 于 &lt;span class=&quot;math inline&quot;&gt;\(({\mathbf x}_1,{\mathbf x}_2)\)&lt;/span&gt; 的概率密度函数可以写 &lt;span class=&quot;math inline&quot;&gt;\(( \mathbf {\vec {\mathbf x}}- \mathbf {\vec \mu})^{T}\)&lt;/span&gt; 表示矩阵的转置：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p(x_1,x_2)=\frac{1}{(2\pi)(\det \mathbf \Sigma)^{1/ 2}}\exp\{- \frac 12 ( \mathbf {\vec {\mathbf x}}- \mathbf {\vec \mu})^{T} \mathbf \Sigma^{-1}( \mathbf {\vec {\mathbf x}}- \mathbf {\vec \mu})\}\]&lt;/span&gt; 其中均 &lt;span class=&quot;math inline&quot;&gt;\(\mu_1,\mu_2\)&lt;/span&gt; 决定了曲面的位置（本例中均值都为0）。标准 &lt;span class=&quot;math inline&quot;&gt;\(\sigma_1,\sigma_2\)&lt;/span&gt; 决定了曲面的陡峭程度（本例中方差都为1）。 &lt;span class=&quot;math inline&quot;&gt;\(\rho\)&lt;/span&gt; 决定了协方差矩阵的形状，从而决定了曲面的形状
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\rho=0\)&lt;/span&gt; 时，协方差矩阵对角线非零，其他位置均为零。此时表示随机变量之间不相关。此时的联合分布概率函数形状如下图所示，曲面在 &lt;span class=&quot;math inline&quot;&gt;\(z=0\)&lt;/span&gt; 平面的截面是个圆形：&lt;br/&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/probability/2dimension_Normal_distribution_rho_0.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\rho=0.5\)&lt;/span&gt; 时，协方差矩阵对角线非零，其他位置均为零。此时表示随机变量之间相关。此时的联合分布概率函数形状如下图所示，曲面在 &lt;span class=&quot;math inline&quot;&gt;\(z=0\)&lt;/span&gt; 平面的截面是个椭圆，相当于圆形沿着直线 &lt;span class=&quot;math inline&quot;&gt;\(y=x\)&lt;/span&gt; 方向压缩 ：&lt;br/&gt;&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/probability/2dimension_Normal_distribution_rho_0_5.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\rho=1\)&lt;/span&gt; 时，协方差矩阵对角线非零，其他位置均为零。此时表示随机变量之间完全相关。此时的联合分布概率函数形状为：曲面在 &lt;span class=&quot;math inline&quot;&gt;\(z=0\)&lt;/span&gt; 平面的截面是直线 &lt;span class=&quot;math inline&quot;&gt;\(y=x\)&lt;/span&gt; ，相当于圆形沿着直线 &lt;span class=&quot;math inline&quot;&gt;\(y=x\)&lt;/span&gt; 方向压缩成一条直线 。由于 &lt;span class=&quot;math inline&quot;&gt;\(\rho=1\)&lt;/span&gt; 会导致除数为 0，因此这里给出 &lt;span class=&quot;math inline&quot;&gt;\(\rho=0.9\)&lt;/span&gt; ：&lt;br/&gt;&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/probability/2dimension_Normal_distribution_rho_0_9.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;多维正态随机变 &lt;span class=&quot;math inline&quot;&gt;\(({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n)\)&lt;/span&gt; ，引入列矩阵：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf{\vec {\mathbf x}}=\begin{bmatrix} x_1 \\ x_2 \\ \vdots\\ x_n \end{bmatrix} \quad \mathbf{\vec \mu}=\begin{bmatrix} \mu_1 \\ \mu_2\\ \vdots\\ \mu_n \end{bmatrix}=\begin{bmatrix} \mathbb E[{\mathbf x}_1] \\ \mathbb E[{\mathbf x}_2] \\ \vdots\\ \mathbb E[{\mathbf x}_n] \end{bmatrix}\]&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\mathbf \Sigma\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n)\)&lt;/span&gt; 的协方差矩阵。则&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p(x_1,x_2,x_3,\cdots,x_n)=\frac {1}{(2\pi)^{n/2}(\det \mathbf \Sigma)^{1/2}} \exp \{- \frac 12( \mathbf {\vec {\mathbf x}}- \mathbf {\vec \mu})^{T}\mathbf \Sigma^{-1}( \mathbf {\vec {\mathbf x}}- \mathbf {\vec \mu})\}\]&lt;/span&gt; 记做&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathcal N(\mathbf{\vec x};\mathbf{\vec \mu},\mathbf\Sigma) =\sqrt{\frac{1}{(2\pi)^{n}det(\mathbf\Sigma)}}\exp\left(-\frac 12(\mathbf{\vec x-\vec \mu})^{T}\mathbf\Sigma^{-1}(\mathbf{\vec x-\vec \mu})\right)\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 维正态变量具有下列四条性质：
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 维正态变量的每一个分量都是正态变量；反之， &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n\)&lt;/span&gt; 都是正态变量，且相互独立， &lt;span class=&quot;math inline&quot;&gt;\(({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n)\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 维正态变量&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 维随机变 &lt;span class=&quot;math inline&quot;&gt;\(({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n)\)&lt;/span&gt; 服 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 维正态分布的充要条件 &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n\)&lt;/span&gt; 的任意线性组合 &lt;span class=&quot;math inline&quot;&gt;\(l_1{\mathbf x}_1+l_2{\mathbf x}_2+\cdots+l_n{\mathbf x}_n\)&lt;/span&gt; 服从一维正态分布，其 &lt;span class=&quot;math inline&quot;&gt;\(l_1,l_2,\cdots,l_n\)&lt;/span&gt; 不全为0&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n)\)&lt;/span&gt; 服 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 维正态分布， &lt;span class=&quot;math inline&quot;&gt;\({\mathbf y}_1,{\mathbf y}_2,\cdots,{\mathbf y}_k\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}_j,j=1,2,\cdots,n\)&lt;/span&gt; 的线性函数， &lt;span class=&quot;math inline&quot;&gt;\(({\mathbf y}_1,{\mathbf y}_2,\cdots,{\mathbf y}_k)\)&lt;/span&gt; 也服从多维正态分布&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这一性质称为正态变量的线性变换不变性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n)\)&lt;/span&gt; 服 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 维正态分布， &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n\)&lt;/span&gt; 相互独 &lt;span class=&quot;math inline&quot;&gt;\(\Longleftrightarrow\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\({\mathbf x}_1,{\mathbf x}_2,\cdots,{\mathbf x}_n\)&lt;/span&gt; 两两不相关&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;指数分布&quot;&gt;6.4 指数分布&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;指数分布：
&lt;ul&gt;&lt;li&gt;概率密度函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p(x;\lambda)=\begin{cases} 0,&amp;amp; x\lt0\\ \frac{\lambda}{\exp(\lambda x)},&amp;amp; x\ge0\\ \end{cases} \]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;期望： &lt;span class=&quot;math inline&quot;&gt;\(\mathbb E_{\mathbf x}[x]=\frac{1}{\lambda}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;方差： &lt;span class=&quot;math inline&quot;&gt;\(Var_{\mathbf x}[x]=\frac{1}{\lambda^{2}}\)&lt;/span&gt;&lt;br/&gt;&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/probability/expon.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;拉普拉斯分布&quot;&gt;6.5 拉普拉斯分布&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;拉普拉斯分布：
&lt;ul&gt;&lt;li&gt;概率密度函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p(x;\mu,\gamma)=\frac{1}{2\gamma}\exp\left(-\frac{|x-\mu|}{\gamma}\right) \]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;期望： &lt;span class=&quot;math inline&quot;&gt;\(\mathbb E_{\mathbf x}[x]=\mu\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;方差： &lt;span class=&quot;math inline&quot;&gt;\(Var_{\mathbf x}[x]=2\gamma^{2}\)&lt;/span&gt;&lt;br/&gt;&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/probability/laplace.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;狄拉克分布&quot;&gt;6.6 狄拉克分布&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;狄拉克分布：假设所有的概率都集中在一 &lt;span class=&quot;math inline&quot;&gt;\(\mu\)&lt;/span&gt; 上，则对应的概率密度函数为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p(x)=\delta(x-\mu) \]&lt;/span&gt; 其 &lt;span class=&quot;math inline&quot;&gt;\(\delta(\cdot)\)&lt;/span&gt; 为狄拉克函数，其性质为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\delta(x)=0,\forall x\neq 0 \int_{-\infty}^{\infty}\delta(x)dx=1 \]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;狄拉克分布的一个典型用途就是定义连续型随机变量的经验分布函数。假设数据集中有样 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec x}_1,\mathbf{\vec x}_2,\cdots,\mathbf{\vec x}_N\)&lt;/span&gt; ，则定义经验分布函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat p(\mathbf{\vec x})=\frac 1N\sum_{i=1}^{N}\delta(\mathbf{\vec x}-\mathbf{\vec x}_i)\]&lt;/span&gt; 它就是对每个样本赋予了一个概率质 &lt;span class=&quot;math inline&quot;&gt;\(\frac 1N\)&lt;/span&gt; 。
&lt;ul&gt;&lt;li&gt;对于离散型随机变量的经验分布，则经验分布函数就是&lt;code&gt;multinoulli&lt;/code&gt;分布，它简单地等于训练集中的经验频率。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;经验分布的两个作用：
&lt;ul&gt;&lt;li&gt;通过查看训练集样本的经验分布，从而指定该训练集的样本采样的分布（保证采样之后的分布不失真）&lt;/li&gt;
&lt;li&gt;经验分布就是使得训练数据的可能性最大化的概率密度函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;多项式分布与狄里克雷分布&quot;&gt;6.7 多项式分布与狄里克雷分布&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;多项式分布的质量密度函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[Mult(m_1,m_2,\cdots,m_K;\vec\mu,N)=\frac{N!}{m_1!m_2!\cdots m_K!}\prod_{k=1}^{K}\mu_k^{m_k}\]&lt;/span&gt; 它 &lt;span class=&quot;math inline&quot;&gt;\((\mu_1+\mu_2+\cdots+\mu_K)^{m_1+m_2+\cdots+m_K}\)&lt;/span&gt; 的多项式展开的形式&lt;/li&gt;
&lt;li&gt;狄利克雷分布的概率密度函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[Dir(\vec\mu;\vec\alpha)=\frac{\Gamma(\sum_{k=1}^{K}\alpha_k)}{\sum_{k=1}^{K}\Gamma(\alpha_k)}\prod_{k=1}^{K}\mu_k^{\alpha_k-1}\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;可以看到，多项式分布与狄里克雷分布的概率密度函数非常相似，区别仅仅在于前面的归一化项
&lt;ul&gt;&lt;li&gt;多项式分布是针对离散型随机变量，通过求和获取概率&lt;/li&gt;
&lt;li&gt;狄里克雷分布时针对连续型随机变量，通过求积分来获取概率&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;混合概率分布&quot;&gt;6.8 混合概率分布&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;混合概率分布：它组合了其他几个分量的分布来组成。
&lt;ul&gt;&lt;li&gt;在每次生成样本中，首先通过&lt;code&gt;multinoulli&lt;/code&gt;分布来决定选用哪个分量，然后由该分量的分布函数来生成样本。&lt;/li&gt;
&lt;li&gt;其概率分布函数为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P(\mathbf x)=\sum_{i}P(c=i)P(\mathbf x\mid c=i)\]&lt;/span&gt; 其 &lt;span class=&quot;math inline&quot;&gt;\(P(c=i)\)&lt;/span&gt; 为一个&lt;code&gt;multinoulli&lt;/code&gt;分布 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 的取值范围就是各分量的编号。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;前面介绍的连续型随机变量的经验分布函数就是一个混合概率分布的例子，此 &lt;span class=&quot;math inline&quot;&gt;\(P(c=i)=\frac 1N\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;混合概率分布可以通过简单的概率分布创建更复杂的概率分布
&lt;ul&gt;&lt;li&gt;一个常见的例子是混合高斯模型，其 &lt;span class=&quot;math inline&quot;&gt;\(P(\mathbf x\mid c=i)\)&lt;/span&gt; 为高斯模型。每个分量都有对应的参 &lt;span class=&quot;math inline&quot;&gt;\((\mathbf{\vec \mu}_i,\mathbf \Sigma_i)\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;有些混合高斯模型有更强的约束，如 &lt;span class=&quot;math inline&quot;&gt;\(\forall i,\mathbf \Sigma_i=\mathbf\Sigma\)&lt;/span&gt; ，更进一步还可以要求 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf\Sigma\)&lt;/span&gt; 为一个对角矩阵。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;混合高斯模型是一个通用的概率密度函数逼近工具。任何平滑的概率密度函数都可以通过足够多分量的混合高斯模型来逼近。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;七先验分布与后验分布&quot;&gt;七、先验分布与后验分布&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;在贝叶斯学派中，&lt;code&gt;先验分布+数据（似然）= 后验分布&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;例如：假设需要识别一大箱苹果中的好苹果、坏苹果的概率。
&lt;ul&gt;&lt;li&gt;根据你对苹果好、坏的认知，给出先验分布为：50个好苹果和50个坏苹果&lt;/li&gt;
&lt;li&gt;现在你拿出10个苹果，发现有：8个好苹果，2个坏苹果。&lt;br/&gt;根据数据，你得到后验分布为：58个好苹果，52个坏苹果&lt;/li&gt;
&lt;li&gt;再拿出10个苹果，发现有：9个好苹果，1个坏苹果。&lt;br/&gt;根据数据，你得到后验分布为：67个好苹果，53个坏苹果&lt;/li&gt;
&lt;li&gt;这样不断重复下去，不断更新后验分布。当一箱苹果清点完毕，则得到了最终的后验分布。&lt;br/&gt;在这里：&lt;/li&gt;
&lt;li&gt;如果不使用先验分布，仅仅清点这箱苹果中的好坏，则得到的分布只能代表这一箱苹果。&lt;/li&gt;
&lt;li&gt;采用了先验分布之后得到的分布，可以认为是所有箱子里的苹果的分布。&lt;/li&gt;
&lt;li&gt;先验分布时：给出的好、坏苹果的个数（也就是频数）越大，则先验分布越占主导地位。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;假设好苹果的概率 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; ，则抽 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 个苹果中，好苹果个数 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 个的概率为一个二项分布：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[Binom(k\mid p;N)=C_N^kp^k(1-p)^{N-k}\]&lt;/span&gt; 其 &lt;span class=&quot;math inline&quot;&gt;\(C_N^k\)&lt;/span&gt; 为组合数。&lt;/li&gt;
&lt;li&gt;现在的问题是：好苹果的概 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 不再固定，而是服从一个分布。&lt;br/&gt;假设好苹果的概 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 的先验分布为贝塔分布&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[Beta(p; \alpha,\beta)=\frac{\Gamma(\alpha+\beta)}{\Gamma(\alpha)\Gamma(\beta)}p^{\alpha-1}(1-p)^{\beta-1}\]&lt;/span&gt; ​&lt;br/&gt;则后验概率为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P(p\mid k; N,\alpha,\beta)=\frac{P(k\mid p; N)\times P(p; \alpha,\beta)}{P(k; N,\alpha,\beta)} \\ \propto P(k\mid p; N)\times P(p; \alpha,\beta)=C_N^kp^k(1-p)^{N-k}\times \frac{\Gamma(\alpha+\beta)}{\Gamma(\alpha)\Gamma(\beta)}p^{\alpha-1}(1-p)^{\beta-1}\\ \propto p^{k+\alpha-1}(1-p)^{N-k+\beta-1}\]&lt;/span&gt; 归一化之后，得到后验概率为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P(p\mid k;N,\alpha,\beta)=\frac{\Gamma(\alpha+\beta+N)}{\Gamma(\alpha+k)\Gamma(\beta+N-k)}p^{k+\alpha-1}(1-p)^{N-k+\beta-1}​\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;好苹果概 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 的先验分布的期望为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbb E[p]=\frac{\alpha}{\alpha+\beta}\]&lt;/span&gt; 好苹果概 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 的后验分布的期望为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbb E[p\mid k]=\frac{\alpha+k}{\alpha+\beta+N}\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;根据上述例子所述：
&lt;ul&gt;&lt;li&gt;好苹果的先验概率的期望为 &lt;span class=&quot;math inline&quot;&gt;\(\frac {50}{50+50}=\frac 12\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;进行第一轮数据校验之后，好苹果的后验概率的期望为 &lt;span class=&quot;math inline&quot;&gt;\(\frac {50+8}{50+50+10}=\frac {58}{110}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt; 视为先验的好苹果数量 &lt;span class=&quot;math inline&quot;&gt;\(\beta\)&lt;/span&gt; 视为先验的坏苹果数量 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 表示箱子中苹果的数量 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 表示箱子中的好苹果数量（相应的 &lt;span class=&quot;math inline&quot;&gt;\(N-k\)&lt;/span&gt; 就是箱子中坏苹果的数量）。则：好苹果的先验概率分布的期望、后验概率分布的期望符合人们的生活经验。&lt;/li&gt;
&lt;li&gt;这里使用先验分布和后验分布的期望，因 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 是一个随机变量。若想通过一个数值来刻画好苹果的可能性，则用期望较好。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;更一般的，如果苹果不仅仅分为好、坏两种，而是分作“尺寸1、尺寸2、...尺 &lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt; ”等。 &lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt; 个苹果中， &lt;span class=&quot;math inline&quot;&gt;\(m_1\)&lt;/span&gt; 个尺寸1的苹果 &lt;span class=&quot;math inline&quot;&gt;\(m_2\)&lt;/span&gt; 个尺寸2的苹果... &lt;span class=&quot;math inline&quot;&gt;\(m_K\)&lt;/span&gt; 个尺 &lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt; 的苹果的概率服从多项式分布：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[Mult(m_1,m_2,\cdots,m_K;\vec\mu,N)=\frac{N!}{m_1!m_2!\cdots m_K!}\prod_{k=1}^{K}\mu_k^{m_k}\]&lt;/span&gt; 其中苹果为尺寸1的概率 &lt;span class=&quot;math inline&quot;&gt;\(\mu_1\)&lt;/span&gt; ，尺寸2的概率 &lt;span class=&quot;math inline&quot;&gt;\(\mu_2\)&lt;/span&gt; ，...尺 &lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt; 的概率 &lt;span class=&quot;math inline&quot;&gt;\(\mu_K\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(N=\sum_{k=1}^Km_k\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;假设苹果尺寸的先验概率分布为狄利克雷分布：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[Dir(\vec\mu;\vec\alpha)=\frac{\Gamma(\sum_{k=1}^{K}\alpha_k)}{\sum_{k=1}^{K}\Gamma(\alpha_k)}\prod_{k=1}^{K}\mu_k^{\alpha_k-1}\]&lt;/span&gt; 苹果尺寸的先验概率分布的期望为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbb E[\vec\mu]=\left(\frac{\alpha_1}{\sum_{k=1}^K\alpha_k},\frac{\alpha_2}{\sum_{k=1}^K\alpha_k},\cdots,\frac{\alpha_K}{\sum_{k=1}^K\alpha_k}\right)\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;则苹果尺寸的后验概率分布也为狄里克雷分布：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[Dir(\vec\mu;\vec\alpha+\mathbf{\vec m})=\frac{\Gamma(N+\sum_{k=1}^{K}\alpha_k)}{\sum_{k=1}^{K}\Gamma(\alpha_k+m_k)}\prod_{k=1}^{K}\mu_k^{\alpha_k+m_k-1}\]&lt;/span&gt; 苹果尺寸的后验概率分布的期望为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbb E[\vec\mu]=\left(\frac{\alpha_1+m_1}{N+\sum_{k=1}^K\alpha_k},\frac{\alpha_2+m_2}{N+\sum_{k=1}^K\alpha_k},\cdots,\frac{\alpha_K+m_K}{N+\sum_{k=1}^K\alpha_k}\right)\]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;八测度论&quot;&gt;八、测度论&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;测度为零：非正式化的提法是，如果集合中的点的数量可以忽略不计，则该集合的测度为零。
&lt;ul&gt;&lt;li&gt;如：二维空间中的直线的测度为零，而正方形的测度非零。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;几乎处处相等：不满足条件的那些点组成的集合的测度为零。&lt;/li&gt;
&lt;li&gt;假设随机变 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf x,\mathbf y\)&lt;/span&gt; 满 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf y=g(\mathbf x)\)&lt;/span&gt; ，且函 &lt;span class=&quot;math inline&quot;&gt;\(g(\cdot)\)&lt;/span&gt; 满足：处处连续、可导、且存在反函数。&lt;br/&gt;则有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p_{\mathbf x}(x)=p_{\mathbf y}(g(x)) \left|\frac{\partial g(x)}{\partial x}\right|\]&lt;/span&gt; 或者等价地：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p_{\mathbf y}(y)=p_{\mathbf x}(g^{-1}(y)) \left|\frac{\partial x}{\partial y}\right| \]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;如果扩展到高维空间，则有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p_{\mathbf x}(\mathbf{\vec x})=p_{\mathbf y}(g(\mathbf{\vec x})) \left|\det\left(\frac{\partial g(\mathbf{\vec x})}{\partial \mathbf{\vec x}}\right)\right|\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;并不 &lt;span class=&quot;math inline&quot;&gt;\(p_{\mathbf y}(y)=p_{\mathbf x}(g^{-1}(y))\)&lt;/span&gt; ，这是因 &lt;span class=&quot;math inline&quot;&gt;\(g(\cdot)\)&lt;/span&gt; 引起了空间扭曲，从而导 &lt;span class=&quot;math inline&quot;&gt;\(\int p_{\mathbf x}(g(x))dx \neq 1\)&lt;/span&gt; 。其实我们有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[|p_{\mathbf y}(g(x))dy|=|p_{\mathbf x}(x)dx|\]&lt;/span&gt; 求解该方程，即得到上述解。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;九信息论&quot;&gt;九、信息论&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;信息论背后的原理是：从不太可能发生的事件中能学到更多的有用信息。
&lt;ul&gt;&lt;li&gt;发生可能性较大的事件包含较少的信息&lt;/li&gt;
&lt;li&gt;发生可能性较小的事件包含较多的信息&lt;/li&gt;
&lt;li&gt;独立事件包含额外的信息&lt;br/&gt;对于事 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf x=x\)&lt;/span&gt; ，定义自信息&lt;code&gt;self-information&lt;/code&gt;为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[I(x)=-\log P(x) \]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;自信息仅仅处理单个输出，但是如果计算自信息的期望，它就是熵：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[H(\mathbf x)=\mathbb E_{\mathbf x\sim P}[I(x)]=-\mathbb E_{\mathbf x\sim P}[\log P(x)]\]&lt;/span&gt; 记 &lt;span class=&quot;math inline&quot;&gt;\(H(P)\)&lt;/span&gt; 。&lt;br/&gt;熵刻画了按照真实分 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; 来识别一个样本所需要的编码长度的期望（即平均编码长度）。&lt;br/&gt;如：含有4个字母&lt;code&gt;(A,B,C,D)&lt;/code&gt;的样本集中，真实分 &lt;span class=&quot;math inline&quot;&gt;\(P=(\frac 12,\frac 12,0,0)\)&lt;/span&gt; ，则只需要1位编码即可识别样本。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KL&lt;/code&gt;散度：对于给定的随机变 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf x\)&lt;/span&gt; ,它的两个概率分布函 &lt;span class=&quot;math inline&quot;&gt;\(P(x)\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(Q(x)\)&lt;/span&gt; 的区别可以用&lt;code&gt;KL&lt;/code&gt;散度来度量：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[D_{KL}(P||Q)=\mathbb E_{\mathbf x\sim P}\left[\log \frac{P(x)}{Q(x)}\right]=\mathbb E_{\mathbf x\sim P}\left[\log P(x) -\log Q(x) \right]\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;KL&lt;/code&gt;散度非负。当它为0时，当且仅当 &lt;code&gt;P&lt;/code&gt;和&lt;code&gt;Q&lt;/code&gt;是同一个分布（对于离散型随机变量），或者两个分布几乎处处相等（对于连续型随机变量）&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(D_{KL}(P||Q) \neq D_{KL}(Q||P)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;交叉熵&lt;code&gt;cross-entropy&lt;/code&gt; &lt;span class=&quot;math inline&quot;&gt;\(H(P,Q)=H(P)+D_{KL}(P||Q)=-\mathbb E_{\mathbf x\sim P}\log Q(x)\)&lt;/span&gt; 。&lt;br/&gt;交叉熵刻画了使用错误分 &lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt; 来表示真实分 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; 中的样本的平均编码长度。&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(D_{KL(P||Q)}\)&lt;/span&gt; 刻画了错误分 &lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt; 编码真实分 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; 带来的平均编码长度的增量。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;一数值稳定性&quot;&gt;一、数值稳定性&lt;/h2&gt;
&lt;h3 id=&quot;近似误差&quot;&gt;1.1 近似误差&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在计算机中执行数学运算需要使用有限的比特位来表达实数，这会引入近似误差
&lt;ul&gt;&lt;li&gt;近似误差可以在多步数值运算中传递、积累，从而导致理论上成功的算法失败&lt;/li&gt;
&lt;li&gt;数值算法设计时要考虑将累计误差最小化&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;上溢出&lt;code&gt;overflow&lt;/code&gt;和下溢出&lt;code&gt;underflow&lt;/code&gt;：
&lt;ul&gt;&lt;li&gt;一种严重的误差是下溢出：当接近零的数字四舍五入为零时，发生下溢出
&lt;ul&gt;&lt;li&gt;许多函数在参数为零和参数为一个非常小的正数时，行为是不同的。如对数函数要求自变量大于零；除法中要求除数非零。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;另一种严重的误差是上溢出：当数值非常大，超过了计算机的表示范围时，发生上溢出。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;softmax-函数&quot;&gt;1.2 softmax 函数&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;一个数值稳定性的例子是&lt;code&gt;softmax&lt;/code&gt;函数。&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec x}=(x_1,x_2,\cdots,x_n)^{T}\)&lt;/span&gt; ，则&lt;code&gt;softmax&lt;/code&gt;函数定义为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\text{softmax}(\mathbf{\vec x})=\left(\frac{\exp(x_1)}{\sum_{j=1}^{n}\exp(x_j)},\frac{\exp(x_2)}{\sum_{j=1}^{n}\exp(x_j)},\cdots,\frac{\exp(x_n)}{\sum_{j=1}^{n}\exp(x_j)}\right)^{T} \]&lt;/span&gt; 当所有 &lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt; 都等于常 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 时，&lt;code&gt;softmax&lt;/code&gt;函数的每个分量的理论值都 &lt;span class=&quot;math inline&quot;&gt;\(\frac 1n\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;考虑 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 是一个非常大的负数（比如趋近负无穷），此时 &lt;span class=&quot;math inline&quot;&gt;\(\exp( c)\)&lt;/span&gt; 下溢出。此时 $ \frac{\exp(c )}{\sum_{j=1}^{n}\exp(c )}$ 分母为零，结果未定义。&lt;/li&gt;
&lt;li&gt;考虑 &lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt; 是一个非常大的正数（比如趋近正无穷），此时 &lt;span class=&quot;math inline&quot;&gt;\(\exp( c)\)&lt;/span&gt; 上溢出。 $ \frac{\exp(c )}{\sum_{j=1}^{n}\exp(c )}$ 的结果未定义。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;解决的办法是： &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec z}=\mathbf{\vec x}-\max_i x_i\)&lt;/span&gt; ，则 $\text{softmax}(\mathbf{\vec z}) $ 的 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个分量为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\text{softmax}(\mathbf{\vec z})_i=\frac{\exp(z_i)}{\sum_{j=1}^{n}\exp(z_j)}=\frac{\exp(\max_k x_k)\exp(z_i)}{\exp(\max_k x_k)\sum_{j=1}^{n}\exp(z_j)}\\ =\frac{\exp(z_i+\max_k x_k)}{\sum_{j=1}^{n}\exp(z_j+\max_k x_k)}\\ =\frac{\exp(x_i)}{\sum_{j=1}^{n}\exp(x_j)}\\ =\text{softmax}(\mathbf{\vec x})_i\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;当 $\mathbf{\vec x} $ 的分量较小时， $\mathbf{\vec z} $ 的分量至少有一个为零，从而导致 &lt;span class=&quot;math inline&quot;&gt;\(\text{softmax}(\mathbf{\vec z})_i\)&lt;/span&gt; 的分母至少有一项为 1，从而解决了下溢出的问题。&lt;/li&gt;
&lt;li&gt;当 $\mathbf{\vec x} $ 的分量较大时 &lt;span class=&quot;math inline&quot;&gt;\(\text{softmax}(\mathbf{\vec z})_i\)&lt;/span&gt; 相当于分子分母同时除以一个非常大的数 &lt;span class=&quot;math inline&quot;&gt;\(\exp(\max_i x_i)\)&lt;/span&gt; ，从而解决了上溢出。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;还有个问题： $\mathbf{\vec x} $ 的分量较小时 &lt;span class=&quot;math inline&quot;&gt;\(\text{softmax}(\mathbf{\vec x})_i\)&lt;/span&gt; 的计算结果可能为0。
&lt;/li&gt;
&lt;li&gt;当从头开始实现一个数值算法时，需要考虑数值稳定性。&lt;br/&gt;当使用现有的数值计算库时，不需要考虑数值稳定性。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;softmax&lt;/code&gt;名字的来源是&lt;code&gt;hardmax&lt;/code&gt;。&lt;br/&gt;&lt;code&gt;hardmax&lt;/code&gt;把一个向 $\mathbf{\vec x} $ 映射成向 &lt;span class=&quot;math inline&quot;&gt;\((0,\cdots,0,1,0,\cdots,0)^T\)&lt;/span&gt; 。即 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec x}\)&lt;/span&gt; 最大元素的位置填充&lt;code&gt;1&lt;/code&gt;，其它位置填充&lt;code&gt;0&lt;/code&gt;。&lt;br/&gt;&lt;code&gt;softmax&lt;/code&gt;会在这些位置填充&lt;code&gt;0.0~1.0&lt;/code&gt;之间的值（如：某个概率值）。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二conditioning&quot;&gt;二、Conditioning&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Conditioning&lt;/code&gt;刻画了一个函数的如下特性：当函数的输入发生了微小的变化时，函数的输出的变化有多大。
&lt;ul&gt;&lt;li&gt;对于&lt;code&gt;Conditioning&lt;/code&gt;较大的函数，在数值计算中可能有问题。因为函数输入的舍入误差可能导致函数输出的较大变化。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对于方 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf A\in \mathbb R^{n\times n}\)&lt;/span&gt; ，其条件数&lt;code&gt;condition number&lt;/code&gt;为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\text{condition number}=\max_{1\le i,j\le n,i\ne j}\left|\frac{\lambda_i}{\lambda_j} \right|\]&lt;/span&gt; 其 &lt;span class=&quot;math inline&quot;&gt;\(\lambda_i,i=1,2,\cdots,n\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\mathbf A\)&lt;/span&gt; 的特征值。
&lt;ul&gt;&lt;li&gt;方阵的条件数就是最大的特征值除以最小的特征值。&lt;/li&gt;
&lt;li&gt;当方阵的条件数很大时，矩阵的求逆将对误差特别敏感（即： &lt;span class=&quot;math inline&quot;&gt;\(\mathbf A\)&lt;/span&gt; 的一个很小的扰动，将导致其逆矩阵一个非常明显的变化）。&lt;/li&gt;
&lt;li&gt;条件数是矩阵本身的特性，它会放大那些包含矩阵求逆运算过程中的误差。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三梯度下降法&quot;&gt;三、梯度下降法&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;梯度下降法是求解无约束最优化问题的一种常见方法，优点是实现简单&lt;/li&gt;
&lt;li&gt;对于函数 &lt;span class=&quot;math inline&quot;&gt;\(f:\mathbb R^{n} \rightarrow \mathbb R\)&lt;/span&gt; ，输入为多维的。假设输 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec x}=(x_1,x_2,\cdots,x_n)^{T}\)&lt;/span&gt; ，则定义梯度：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x})=\left(\frac{\partial}{\partial x_1}f(\mathbf{\vec x}),\frac{\partial}{\partial x_2}f(\mathbf{\vec x}),\cdots,\frac{\partial}{\partial x_n}f(\mathbf{\vec x})\right)^{T}\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;驻点满足： &lt;span class=&quot;math inline&quot;&gt;\(\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x})=\mathbf{\vec 0}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;沿着方 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec u}\)&lt;/span&gt; 的方向导数&lt;code&gt;directional derivative&lt;/code&gt;定义为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\lim_{\alpha\rightarrow 0}\frac{f(\mathbf{\vec x}+\alpha\mathbf{\vec u})-f(\mathbf{\vec x})}{\alpha} \]&lt;/span&gt; 其 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec u}\)&lt;/span&gt; 为单位向量。
&lt;ul&gt;&lt;li&gt;方向导数就是 &lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial}{\partial \alpha}f(\mathbf{\vec x}+\alpha\mathbf{\vec u})\)&lt;/span&gt; 。根据链式法则，它也等于 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec u}^{T}\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x})\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;为了最小 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; ，则寻找一个方向：沿着该方向，函数值减少的速度最快（换句话说，就是增加最慢）。即：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\min_{\mathbf{\vec u}} \mathbf{\vec u}^{T}\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x})\\ s.t.\quad ||\mathbf{\vec u}||_2=1\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;假 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec u}\)&lt;/span&gt; 与梯度的夹角 &lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt; ，则目标函数等于：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[||\mathbf{\vec u}||_2||\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x})||_2 \cos\theta\]&lt;/span&gt; 考虑 &lt;span class=&quot;math inline&quot;&gt;\(||\mathbf{\vec u}||_2=1\)&lt;/span&gt; ，以及梯度的大小 &lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt; 无关，于是上述问题转化为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\min_\theta \cos\theta\]&lt;/span&gt; 于是 &lt;span class=&quot;math inline&quot;&gt;\(\theta^{*}=\pi\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec u}\)&lt;/span&gt; 沿着梯度的相反的方向。&lt;br/&gt;即：梯度的方向是函数值增加最快的方向，梯度的相反方向是函数值减小的最快的方向。&lt;/li&gt;
&lt;li&gt;可以沿着负梯度的方向来降 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 的值，这就是梯度下降法。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;根据梯度下降法，为了寻 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 的最小点，迭代过程为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf{\vec x}^{\prime}= \mathbf{\vec x}-\epsilon\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x})\]&lt;/span&gt; 迭代结束条件为：梯度向 &lt;span class=&quot;math inline&quot;&gt;\(\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x})\)&lt;/span&gt; 的每个成分为零或者非常接近零。
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; 为学习率，它是一个正数，决定了迭代的步长。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;选择学习率有多种方法：
&lt;ul&gt;&lt;li&gt;一种方法是：选 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; 为一个小的、正的常数&lt;/li&gt;
&lt;li&gt;另一种方法是：给定多 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; ，然后选择使 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf{\vec x}-\epsilon\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x}))\)&lt;/span&gt; 最小的那个值作为本次迭代的学习率（即：选择一个使得目标函数下降最大的学习率）。这种做法叫做线性搜索&lt;code&gt;line search&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;第三种方法是：求得 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf{\vec x}-\epsilon\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x}))\)&lt;/span&gt; 取极小值 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; ，即求解最优化问题：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\epsilon^{*}=\arg\min_{\epsilon,\epsilon \gt 0 }f(\mathbf{\vec x}-\epsilon\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x}))\]&lt;/span&gt; 这种方法也称作最速下降法。
&lt;ul&gt;&lt;li&gt;在最速下降法中，假设相邻的三个迭代点分别为 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec x}^{&amp;lt;k&amp;gt;},\mathbf{\vec x}^{&amp;lt;k+1&amp;gt;},\mathbf{\vec x}^{&amp;lt;k+2&amp;gt;}\)&lt;/span&gt; ，可以证明 &lt;span class=&quot;math inline&quot;&gt;\((\mathbf{\vec x}^{&amp;lt;k+1&amp;gt;}-\mathbf{\vec x}^{&amp;lt;k&amp;gt;})\cdot (\mathbf{\vec x}^{&amp;lt;k+2&amp;gt;}-\mathbf{\vec x}^{&amp;lt;k+1&amp;gt;})=0\)&lt;/span&gt; 。即相邻的两次搜索的方向是正交的！&lt;br/&gt;证明：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf{\vec x}^{&amp;lt;k+1&amp;gt;}=\mathbf{\vec x}^{&amp;lt;k&amp;gt;}-\epsilon^{&amp;lt;k&amp;gt;}\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x}^{&amp;lt;k&amp;gt;})\\ \mathbf{\vec x}^{&amp;lt;k+2&amp;gt;}=\mathbf{\vec x}^{&amp;lt;k+1&amp;gt;}-\epsilon^{&amp;lt;k+1&amp;gt;}\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x}^{&amp;lt;k+1&amp;gt;})\\\]&lt;/span&gt; 根据最优化问题，有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\epsilon^{&amp;lt;k+1&amp;gt;}=\arg\min_{\epsilon,\epsilon \gt 0 }f(\mathbf{\vec x}^{&amp;lt;k+1&amp;gt;}-\epsilon\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x}^{&amp;lt;k+1&amp;gt;}))\\ \rightarrow \frac{\partial f(\mathbf{\vec x}^{&amp;lt;k+1&amp;gt;}-\epsilon\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x}^{&amp;lt;k+1&amp;gt;})) }{\partial \epsilon}\mid_{\epsilon=\epsilon^{&amp;lt;k+1&amp;gt;}}=0\\ \rightarrow \nabla _{\mathbf{\vec x}} f(\mathbf{\vec x}^{&amp;lt;k+2&amp;gt;})\cdot \nabla _{\mathbf{\vec x}} f(\mathbf{\vec x}^{&amp;lt;k+1&amp;gt;})=0\\ \rightarrow (\mathbf{\vec x}^{&amp;lt;k+1&amp;gt;}-\mathbf{\vec x}^{&amp;lt;k&amp;gt;})\cdot (\mathbf{\vec x}^{&amp;lt;k+2&amp;gt;}-\mathbf{\vec x}^{&amp;lt;k+1&amp;gt;})=0\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;此时迭代的路线是锯齿形的，因此收敛速度较慢&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;某些情况下如果梯度向 &lt;span class=&quot;math inline&quot;&gt;\(\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x})\)&lt;/span&gt; 的形式比较简单，则可以直接求解方程：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x})=\mathbf{\vec 0}\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;此时不用任何迭代，直接获得解析解。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;梯度下降算法：
&lt;ul&gt;&lt;li&gt;输入：
&lt;ul&gt;&lt;li&gt;目标函数 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf {\vec x})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;梯度函数 $g(\mathbf {\vec x})=\nabla f(\mathbf {\vec x}) $&lt;/li&gt;
&lt;li&gt;计算精度 &lt;span class=&quot;math inline&quot;&gt;\(e\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;输出 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf {\vec x})\)&lt;/span&gt; 的极小 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^*\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;算法步骤：
&lt;ul&gt;&lt;li&gt;选取初始 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{&amp;lt;0&amp;gt;}\in \mathbb R^{n}\)&lt;/span&gt; , &lt;span class=&quot;math inline&quot;&gt;\(k=0\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;计 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf {\vec x}^{&amp;lt;k&amp;gt;})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;计算梯 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec g}_k=g(\mathbf {\vec x}^{&amp;lt;k&amp;gt;})\)&lt;/span&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;若梯 &lt;span class=&quot;math inline&quot;&gt;\(|\mathbf {\vec g}_k| \lt e\)&lt;/span&gt; ，则停止迭代 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^*=\mathbf {\vec x}\)&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;即此时导数为0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;若梯 &lt;span class=&quot;math inline&quot;&gt;\(|\mathbf {\vec g}_k| \ge e\)&lt;/span&gt; ，则 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec p}_k=-\mathbf {\vec g}_k\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_k\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_k =\min_{\epsilon \le 0}f(\mathbf {\vec x}^{&amp;lt;k&amp;gt;}+\epsilon \mathbf {\vec p}_k)\)&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;通常这也是个最小化问题。但是可以给定一系列 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_k\)&lt;/span&gt; 的值：如&lt;code&gt;[10,1,0.1,0.01,0.001,0.0001]&lt;/code&gt;然后从中挑选&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{&amp;lt;k+1&amp;gt;} = \mathbf {\vec x}^{&amp;lt;k&amp;gt;}+\epsilon_k \mathbf {\vec p}_k\)&lt;/span&gt; ，计 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf {\vec x}^{&amp;lt;k+1&amp;gt;})\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(|f(\mathbf {\vec x}^{&amp;lt;k+1&amp;gt;})-f(\mathbf {\vec x}^{&amp;lt;k&amp;gt;})| \lt e\)&lt;/span&gt; 或者 &lt;span class=&quot;math inline&quot;&gt;\(|\mathbf {\vec x}^{&amp;lt;k+1&amp;gt;}-\mathbf {\vec x}^{&amp;lt;k&amp;gt;}| \lt e\)&lt;/span&gt; 时，停止迭代 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^*=\mathbf {\vec x}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;否则，令 &lt;span class=&quot;math inline&quot;&gt;\(k=k+1\)&lt;/span&gt; ，计算梯度 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec g}_k=g(\mathbf {\vec x}^{&amp;lt;k&amp;gt;})\)&lt;/span&gt; 继续迭代&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/numerical/gradient_descent.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;当目标函数是凸函数时，梯度下降法的解是全局最优的。
&lt;ul&gt;&lt;li&gt;通常情况下，梯度下降法的解不保证是全局最优的&lt;/li&gt;
&lt;li&gt;梯度下降法的收敛速度未必是最快的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;四海森矩阵&quot;&gt;四、海森矩阵&lt;/h2&gt;
&lt;h3 id=&quot;二阶导数&quot;&gt;4.1 二阶导数&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;二阶导 &lt;span class=&quot;math inline&quot;&gt;\(f^{\prime\prime}(x)\)&lt;/span&gt; 刻画了曲率。假设有一个二次函数（实际任务中，很多函数不是二次的，但是在局部可以近似为二次函数）：
&lt;ul&gt;&lt;li&gt;如果函数的二阶导数为零，则它是一条直线。如果梯度为 1，则当沿着负梯度的步长为 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; 时，函数值减少 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果函数的二阶导数为负，则函数向下弯曲。如果梯度为1，则当沿着负梯度的步长为 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; 时，函数值减少的量大于 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果函数的二阶导数为正，则函数向上弯曲。如果梯度为1，则当沿着负梯度的步长为 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; 时，函数值减少的量少于 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;&lt;br/&gt;&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/numerical/curvature.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;海森矩阵&quot;&gt;4.2 海森矩阵&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;当函数输入为多维时，定义海森矩阵：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf H(f)(\mathbf{\vec x}) =\begin{bmatrix} \frac{\partial^{2}}{\partial x_1\partial x_1}f&amp;amp;\frac{\partial^{2}}{\partial x_1\partial x_2}f&amp;amp;\cdots&amp;amp;\frac{\partial^{2}}{\partial x_1\partial x_n}f\\ \frac{\partial^{2}}{\partial x_2\partial x_1}f&amp;amp;\frac{\partial^{2}}{\partial x_2\partial x_2}f&amp;amp;\cdots&amp;amp;\frac{\partial^{2}}{\partial x_2\partial x_n}f\\ \vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\ \frac{\partial^{2}}{\partial x_n\partial x_1}f&amp;amp;\frac{\partial^{2}}{\partial x_n\partial x_2}f&amp;amp;\cdots&amp;amp;\frac{\partial^{2}}{\partial x_n\partial x_n}f \end{bmatrix}\]&lt;/span&gt; 即海森矩阵的 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 列元素为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf H_{i,j}=\frac{\partial^{2}}{\partial x_i\partial x_j}f(\mathbf{\vec x}) \]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;当二阶偏导是连续时，海森矩阵是对称阵，即有 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf H=\mathbf H^{T}\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;在深度学习中大多数海森矩阵都是对称阵&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对于特定方 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec d}\)&lt;/span&gt; 上的二阶导数为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf{\vec d}^T\mathbf H \mathbf{\vec d}\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;如果 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec d}\)&lt;/span&gt; 是海森矩阵的特征向量，则该方向的二阶导数就是对应的特征值&lt;/li&gt;
&lt;li&gt;如果 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec d}\)&lt;/span&gt; 不是海森矩阵的特征向量，则该方向的二阶导数就是所有特征值的加权平均，权重在 &lt;code&gt;(0,1)&lt;/code&gt;之间。且与 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec d}\)&lt;/span&gt; 夹角越小的特征向量对应的特征值具有更大的权重。&lt;/li&gt;
&lt;li&gt;最大特征值确定了最大二阶导数，最小特征值确定最小二阶导数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;海森矩阵与学习率&quot;&gt;4.3 海森矩阵与学习率&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf{\vec x})\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec x}_0\)&lt;/span&gt; 处泰勒展开：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[f(\mathbf{\vec x}) \approx f(\mathbf{\vec x}_0)+(\mathbf{\vec x}-\mathbf{\vec x}_0 )^{T}\mathbf{\vec g}+\frac 12(\mathbf{\vec x}-\mathbf{\vec x}_0)^{T}\mathbf H (\mathbf{\vec x}-\mathbf{\vec x}_0)\]&lt;/span&gt; 其 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec g}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec x}_0\)&lt;/span&gt; 处的梯度 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf H\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec x}_0\)&lt;/span&gt; 处的海森矩阵。&lt;br/&gt;根据梯度下降法：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf{\vec x}^{\prime}= \mathbf{\vec x}-\epsilon\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x})\]&lt;/span&gt; 应用在 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec x}_0\)&lt;/span&gt; ，有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[f(\mathbf{\vec x}_0-\epsilon\mathbf{\vec g})\approx f(\mathbf{\vec x}_0)-\epsilon\mathbf{\vec g}^{T}\mathbf{\vec g}+\frac 12\epsilon^{2}\mathbf{\vec g}^{T}\mathbf H \mathbf{\vec g}\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;第一项代表函数在点 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec x}_0\)&lt;/span&gt; 处的值&lt;/li&gt;
&lt;li&gt;第二项代表由于斜率的存在，导致函数值的变化&lt;/li&gt;
&lt;li&gt;第三项代表由于曲率的存在，对于函数值变化的矫正&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;注意：如 &lt;span class=&quot;math inline&quot;&gt;\(\frac 12\epsilon^{2}\mathbf{\vec g}^{T}\mathbf H \mathbf{\vec g}\)&lt;/span&gt; 较大，则很有可能导致：沿着负梯度的方向，函数值反而增加！
&lt;ul&gt;&lt;li&gt;如 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec g}^{T}\mathbf H \mathbf{\vec g} \le 0\)&lt;/span&gt; ，则无 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; 取多大的值，可以保证函数值是减小的&lt;/li&gt;
&lt;li&gt;如 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec g}^{T}\mathbf H \mathbf{\vec g} \gt 0\)&lt;/span&gt; ，则学习 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; 不能太大。 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; 太大则函数值增加
&lt;ul&gt;&lt;li&gt;根 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf{\vec x}_0-\epsilon\mathbf{\vec g}) - f(\mathbf{\vec x}_0) \lt 0\)&lt;/span&gt; 有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\epsilon \lt \frac{\mathbf{2\vec g}^{T}\mathbf{\vec g}}{\mathbf{\vec g}^{T}\mathbf H\mathbf{\vec g}}\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;考虑最速下降法，选择使 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 下降最快 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; ，则有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\epsilon^{*}=\arg\min_{\epsilon,\epsilon \gt 0 }f(\mathbf{\vec x}_0-\epsilon\mathbf{\vec g})\]&lt;/span&gt; 求 &lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial }{\partial \epsilon} f(\mathbf{\vec x}_0-\epsilon\mathbf{\vec g})=0\)&lt;/span&gt; 有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\epsilon^{*}=\frac{\mathbf{\vec g}^{T}\mathbf{\vec g}}{\mathbf{\vec g}^{T}\mathbf H\mathbf{\vec g}}\]&lt;/span&gt; &amp;gt; 根 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec g}^{T}\mathbf H \mathbf{\vec g} \gt 0\)&lt;/span&gt; ，很明显有 $\epsilon^{*} \lt \frac{\mathbf{2\vec g}^{T}\mathbf{\vec g}}{\mathbf{\vec g}^{T}\mathbf H\mathbf{\vec g}} $&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;由于海森矩阵为实对称阵，因此它可以进行特征值分解。&lt;br/&gt;假设其特征值从大到小排列为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\lambda_1,\lambda_2,\cdots,\lambda_n\]&lt;/span&gt; 其瑞利商 &lt;span class=&quot;math inline&quot;&gt;\(R(\mathbf{\vec x})=\frac{\mathbf{\vec x}^{T}\mathbf H\mathbf{\vec x}}{\mathbf{\vec x}^{T}\mathbf{\vec x}},\mathbf{\vec x} \ne \mathbf{\vec 0}\)&lt;/span&gt; ，可以证明：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\lambda_n \le R(\mathbf{\vec x}) \le \lambda_1\\ \lambda_1=\max_{\mathbf{\vec x}\ne \mathbf{\vec 0}} R(\mathbf{\vec x})\\ \lambda_n=\min_{\mathbf{\vec x}\ne \mathbf{\vec 0}} R(\mathbf{\vec x}) \]&lt;/span&gt; 根据：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\epsilon^{*}=\frac{\mathbf{\vec g}^{T}\mathbf{\vec g}}{\mathbf{\vec g}^{T}\mathbf H\mathbf{\vec g}}=\frac{1}{R(\mathbf{\vec g})}\]&lt;/span&gt; 可知海森矩阵决定了学习率的取值范围。
&lt;ul&gt;&lt;li&gt;最坏的情况下，梯度 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec g}\)&lt;/span&gt; 与海森矩阵最大特征值 &lt;span class=&quot;math inline&quot;&gt;\(\lambda_1\)&lt;/span&gt; 对应的特征向量平行，则此时最优学习率为 &lt;span class=&quot;math inline&quot;&gt;\(\frac {1}{\lambda_1}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;驻点与全局极小点&quot;&gt;4.4 驻点与全局极小点&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;满足导数为零的点（ &lt;span class=&quot;math inline&quot;&gt;\(f^{\prime}(x)=0\)&lt;/span&gt; ）称作驻点。驻点可能为下面三种类型之一：
&lt;ul&gt;&lt;li&gt;局部极小点：在 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的一个邻域内，该点的值最小&lt;/li&gt;
&lt;li&gt;局部极大点：在 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的一个邻域内，该点的值最大&lt;/li&gt;
&lt;li&gt;鞍点：既不是局部极小，也不是局部极大&lt;br/&gt;&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/numerical/critical_point.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;全局极小点 &lt;span class=&quot;math inline&quot;&gt;\(x^{*}=\arg\min_x f(x)\)&lt;/span&gt; 。
&lt;ul&gt;&lt;li&gt;全局极小点可能有一个或者多个&lt;/li&gt;
&lt;li&gt;在深度学习中，目标函数很可能具有非常多的局部极小点，以及许多位于平坦区域的鞍点。这使得优化非常不利。因此通常选取一个非常低的目标函数值，而不一定要是全局最小值。&lt;br/&gt;&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/numerical/deeplearning_optimization.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;二阶导数可以配合一阶导数来决定驻点的类型：
&lt;ul&gt;&lt;li&gt;局部极小点 &lt;span class=&quot;math inline&quot;&gt;\(f^{\prime}(x)=0,f^{\prime\prime}(x)\gt 0\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;局部极大点 &lt;span class=&quot;math inline&quot;&gt;\(f^{\prime}(x)=0,f^{\prime\prime}(x)\lt 0\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(f^{\prime}(x)=0,f^{\prime\prime}(x)= 0\)&lt;/span&gt; ：驻点的类型可能为任意三者之一。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对于多维的情况类似：
&lt;ul&gt;&lt;li&gt;局部极小点 $\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x})=0 $ ，且海森矩阵为正定的（即所有的特征值都是正的）。
&lt;ul&gt;&lt;li&gt;当海森矩阵为正定时，任意方向的二阶偏导数都是正的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;局部极大点 $\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x})=0 $ ，且海森矩阵为负定的（即所有的特征值都是负的）。
&lt;ul&gt;&lt;li&gt;当海森矩阵为负定时，任意方向的二阶偏导数都是负的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;$\nabla _{\mathbf{\vec x}} f(\mathbf{\vec x})=0 $ ，且海森矩阵的特征值中至少一个正值、至少一个负值时，为鞍点。&lt;/li&gt;
&lt;li&gt;当海森矩阵非上述情况时，驻点类型无法判断。&lt;br/&gt;下图 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf{\vec x})=x_1^{2}-x_2^{2}\)&lt;/span&gt; 在原点附近的等值线。其海森矩阵为一正一负。&lt;/li&gt;
&lt;li&gt;沿着 &lt;span class=&quot;math inline&quot;&gt;\(x_1\)&lt;/span&gt; 方向，曲线向上；沿着 &lt;span class=&quot;math inline&quot;&gt;\(x_2\)&lt;/span&gt; 方向，曲线向下。&lt;/li&gt;
&lt;li&gt;鞍点就是在一个横截面内的局部极小值，另一个横截面内的局部极大值。&lt;br/&gt;&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/numerical/saddle.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;四牛顿法&quot;&gt;四、牛顿法&lt;/h2&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li&gt;梯度下降法有个缺陷：它未能利用海森矩阵的信息
&lt;ul&gt;&lt;li&gt;当海森矩阵的条件数较大时，不同方向的梯度的变化差异很大。
&lt;/li&gt;
&lt;li&gt;当海森矩阵的条件数较大时，也难以选择合适的步长。
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;下图是利用梯度下降法寻找函数最小值的路径。
&lt;ul&gt;&lt;li&gt;该函数是二次函数，海森矩阵条件数为 5，表明最大曲率是最小曲率的5倍。&lt;/li&gt;
&lt;li&gt;红线为梯度下降的搜索路径。（它没有用最速下降法，而是用到线性搜索。如果是最速下降法，则相邻两次搜索的方向正交）&lt;br/&gt;&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/numerical/g_descent.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;牛顿法结合了海森矩阵。&lt;br/&gt;考虑泰勒展开式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[f(\mathbf{\vec x}) \approx f(\mathbf{\vec x}_0)+(\mathbf{\vec x}-\mathbf{\vec x}_0 )^{T}\mathbf{\vec g}+\frac 12(\mathbf{\vec x}-\mathbf{\vec x}_0)^{T}\mathbf H (\mathbf{\vec x}-\mathbf{\vec x}_0)\]&lt;/span&gt; 其 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec g}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec x}_0\)&lt;/span&gt; 处的梯度 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf H\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec x}_0\)&lt;/span&gt; 处的海森矩阵。&lt;br/&gt;如 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf{\vec x}\)&lt;/span&gt; 为极值点，则有 &lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial}{\partial \mathbf{\vec x}}f(\mathbf{\vec x})=\mathbf{\vec 0}\)&lt;/span&gt; ，则有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf{\vec x}^{*}=\mathbf{\vec x}_0 -\mathbf H^{-1}\mathbf{\vec g}\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 是个正定的二次型，则牛顿法直接一次就能到达最小值点&lt;/li&gt;
&lt;li&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 不是正定的二次型，则可以在局部近似为正定的二次型，那么则采用多次牛顿法即可到达最小值点。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一维情况下，梯度下降法和牛顿法的原理展示：&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/numerical/newton.JPG&quot;/&gt;&lt;/center&gt;
&lt;ul&gt;&lt;li&gt;梯度下降法：下一次迭代的 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{&amp;lt;k+1&amp;gt;}=\mathbf {\vec x}^{&amp;lt;k&amp;gt;}-\epsilon_k \nabla f(\mathbf {\vec x})\)&lt;/span&gt; 。
&lt;ul&gt;&lt;li&gt;对于一维的情况，可以固定 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_k=\eta\)&lt;/span&gt; ，由于随着迭代的推进 &lt;span class=&quot;math inline&quot;&gt;\(f^{\prime}(x)\)&lt;/span&gt; 绝对值是减小的（直到0），因此越靠近极值点 &lt;span class=&quot;math inline&quot;&gt;\(\Delta(x)\)&lt;/span&gt; 越小&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;牛顿法：目标 &lt;span class=&quot;math inline&quot;&gt;\(\nabla f(\mathbf {\vec x})=0\)&lt;/span&gt; 。在一维情况下就是求 &lt;span class=&quot;math inline&quot;&gt;\(f^\prime (x)=0\)&lt;/span&gt; 。牛顿法的方法是： &lt;span class=&quot;math inline&quot;&gt;\(x=x^{&amp;lt;k&amp;gt;}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(y=f^{\prime}(x)\)&lt;/span&gt; 切线，该切线过 &lt;span class=&quot;math inline&quot;&gt;\((x^{&amp;lt;k&amp;gt;},f^{\prime}(x^{&amp;lt;k&amp;gt;}))\)&lt;/span&gt; 。该切线 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 轴上的交点就是&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[x^{&amp;lt;k+1&amp;gt;}=x^{&amp;lt;k&amp;gt;}-\frac {f^{\prime}(x^{&amp;lt;k&amp;gt;})}{f^{\prime\prime}(x^{&amp;lt;k&amp;gt;})}\]&lt;/span&gt; 推广到多维情况下就是：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf {\vec x}^{&amp;lt;k+1&amp;gt;}=\mathbf {\vec x}^{&amp;lt;k&amp;gt;}-\mathbf H_k^{-1}\mathbf {\vec g}_k\]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当位于一个极小值点附近时，牛顿法比梯度下降法能更快地到达极小值点。
&lt;ul&gt;&lt;li&gt;如果在一个鞍点附近，牛顿法效果很差；而梯度下降法此时效果较好（除非负梯度的方向刚好指向了鞍点）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;仅仅利用了梯度的优化算法（如梯度下降法）称作一阶优化算法；同时利用了海森矩阵的优化算法（如牛顿法）称作二阶优化算法&lt;/li&gt;
&lt;li&gt;牛顿法算法：
&lt;ul&gt;&lt;li&gt;输入：
&lt;ul&gt;&lt;li&gt;目标函数 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf {\vec x})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;梯度 &lt;span class=&quot;math inline&quot;&gt;\(g(\mathbf {\vec x})=\nabla f(\mathbf {\vec x})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;海森矩阵 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf H(\mathbf {\vec x})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;精度要求 &lt;span class=&quot;math inline&quot;&gt;\(e\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;输出 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf {\vec x})\)&lt;/span&gt; 的极小值 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^*\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;算法步骤：
&lt;ul&gt;&lt;li&gt;选取初始 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{&amp;lt;0&amp;gt;}\in \mathbb R^{n}\)&lt;/span&gt; , &lt;span class=&quot;math inline&quot;&gt;\(k=0\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;计 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec g}_k=g(\mathbf {\vec x}^{&amp;lt;k&amp;gt;})\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(|\mathbf {\vec g}_k| \lt e\)&lt;/span&gt; ，则停止计算，得到近似 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}=\mathbf {\vec x}^*\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(|\mathbf {\vec g}_k| \ge e\)&lt;/span&gt; ，则:
&lt;ul&gt;&lt;li&gt;计算 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf H_k=\mathbf H(\mathbf {\vec x}^{&amp;lt;k&amp;gt;})\)&lt;/span&gt; ，并求 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec p}_k,\mathbf H_k \mathbf {\vec p}_k=-\mathbf {\vec g}_k\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;置 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{&amp;lt;k+1&amp;gt;}=\mathbf {\vec x}^{&amp;lt;k&amp;gt;}+\mathbf {\vec p}_k\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;置 &lt;span class=&quot;math inline&quot;&gt;\(k=k+1\)&lt;/span&gt; ，计算 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec g}_k=g(\mathbf {\vec x}^{&amp;lt;k&amp;gt;})\)&lt;/span&gt; ，迭代&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;梯度下降法中，每一 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}\)&lt;/span&gt; 增加的方向一定是梯度相反的方 &lt;span class=&quot;math inline&quot;&gt;\(- \epsilon_k \nabla_k\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;增加的幅度由 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_k\)&lt;/span&gt; 决定，若跨度过大容易引发震荡；&lt;br/&gt;而牛顿法中，每一 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}\)&lt;/span&gt; 增加的方向是梯度增速最大的反方 &lt;span class=&quot;math inline&quot;&gt;\(- \mathbf H_k^{-1} \nabla_k\)&lt;/span&gt; （它通常情况下与梯度不共线）&lt;/li&gt;
&lt;li&gt;增加的幅度已经包含在 $ \mathbf H_k^{-1}$ 中（也可以乘以学习率作为幅度的系数）&lt;br/&gt;&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/numerical/gradient_descent_newton.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;深度学习中的目标函数非常复杂，无法保证可以通过上述优化算法进行优化。因此有时会限定目标函数具有&lt;code&gt;Lipschitz&lt;/code&gt;连续，或者其导数&lt;code&gt;Lipschitz&lt;/code&gt;连续。
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;凸优化在某些特殊的领域取得了巨大的成功。但是在深度学习中，大多数优化问题都难以用凸优化来描述。&lt;br/&gt;凸优化的重要性在深度学习中大大降低。凸优化仅仅作为一些深度学习算法的子程序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;五拟牛顿法&quot;&gt;五、拟牛顿法&lt;/h2&gt;
&lt;h3 id=&quot;原理&quot;&gt;5.1 原理&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在牛顿法的迭代中，需要计算海森矩阵的逆矩 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf H^{-1}\)&lt;/span&gt; ，这一计算比较复杂。
&lt;ul&gt;&lt;li&gt;可以考虑用一个 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 阶矩阵 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf G_k=G(\mathbf {\vec x}^{&amp;lt;k&amp;gt;})\)&lt;/span&gt; 来近似代替 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf H^{-1}_k=H^{-1}(\mathbf {\vec x}^{&amp;lt;k&amp;gt;})\)&lt;/span&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;先看海森矩阵满足的条件 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec g}_{k+1}-\mathbf {\vec g}_k=\mathbf H_k (\mathbf {\vec x}^{&amp;lt;k+1&amp;gt;}-\mathbf {\vec x}^{&amp;lt;k&amp;gt;})\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;令 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec y}_k=\mathbf {\vec g}_{k+1}-\mathbf {\vec g}_k, \vec \delta_k=\mathbf {\vec x}^{&amp;lt;k+1&amp;gt;}-\mathbf {\vec x}^{&amp;lt;k&amp;gt;}\)&lt;/span&gt; 则有 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec y}_k=\mathbf H_k \vec \delta_k\)&lt;/span&gt; ，或者 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf H_k^{-1}\mathbf {\vec y}_k=\vec \delta_k\)&lt;/span&gt; 。这称为拟牛顿条件&lt;/li&gt;
&lt;li&gt;根据牛顿法的迭代: &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{&amp;lt;k+1&amp;gt;}=\mathbf {\vec x}^{&amp;lt;k&amp;gt;}-\mathbf H_k^{-1}\mathbf {\vec g}_k\)&lt;/span&gt; ，将 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf {\vec x})\)&lt;/span&gt; 在 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{&amp;lt;k&amp;gt;}\)&lt;/span&gt; 的一阶泰勒展开：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f(\mathbf {\vec x}^{&amp;lt;k+1&amp;gt;})=f(\mathbf {\vec x}^{&amp;lt;k&amp;gt;})+f'(\mathbf {\vec x}^{&amp;lt;k&amp;gt;})(\mathbf {\vec x}^{&amp;lt;k+1&amp;gt;}-\mathbf {\vec x}^{&amp;lt;k&amp;gt;})\\ =f(\mathbf {\vec x}^{&amp;lt;k&amp;gt;})+\mathbf {\vec g}_k^{T}(-\mathbf H_k^{-1}\mathbf {\vec g}_k)=f(\mathbf {\vec x}^{&amp;lt;k&amp;gt;})-\mathbf {\vec g}_k^{T}\mathbf H^{-1}_k\mathbf {\vec g}_k\]&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\mathbf H_k\)&lt;/span&gt; 是正定矩阵时，总 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf {\vec x}^{&amp;lt;k+1&amp;gt;})&amp;lt;f(\mathbf {\vec x}^{&amp;lt;k&amp;gt;})\)&lt;/span&gt; ，因此每次都是沿着函数递减的方向迭代&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;拟牛顿法如果选 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf G_k\)&lt;/span&gt; 作 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf H_k^{-1}\)&lt;/span&gt; 的近似时 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf G_k\)&lt;/span&gt; 同样要满足两个条件：
&lt;/li&gt;
&lt;li&gt;正定矩阵定义： &lt;span class=&quot;math inline&quot;&gt;\(\mathbf M\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(n\times n\)&lt;/span&gt; 阶方阵，如果对任何非零向 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}\)&lt;/span&gt; ，都 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{T} \mathbf M \mathbf {\vec x} \gt 0\)&lt;/span&gt; ，就 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf M\)&lt;/span&gt; 正定矩阵
&lt;ul&gt;&lt;li&gt;正定矩阵判定：
&lt;ul&gt;&lt;li&gt;判定定理1：对称阵 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf M\)&lt;/span&gt; 为正定的充分必要条件是 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf M\)&lt;/span&gt; 的特征值全为正。&lt;/li&gt;
&lt;li&gt;判定定理2：对称阵 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf M\)&lt;/span&gt; 为正定的充分必要条件是 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf M\)&lt;/span&gt; 的各阶顺序主子式都为正。&lt;/li&gt;
&lt;li&gt;判定定理3：任意阵 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf M\)&lt;/span&gt; 为正定的充分必要条件是 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf M\)&lt;/span&gt; 合同于单位阵。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;正定矩阵的性质：
&lt;ul&gt;&lt;li&gt;正定矩阵一定是非奇异的。奇异矩阵的定义：若 &lt;span class=&quot;math inline&quot;&gt;\(n\times n\)&lt;/span&gt; 阶矩阵 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf M\)&lt;/span&gt; 为奇异阵，则其的行列式为零，即 &lt;span class=&quot;math inline&quot;&gt;\(|\mathbf M|=0\)&lt;/span&gt; 。&lt;/li&gt;
&lt;li&gt;正定矩阵的任一主子矩阵也是正定矩阵。&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf M\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(n\times n\)&lt;/span&gt; 阶对称正定矩阵，则存在唯一的主对角线元素都是正数的下三角阵 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf L\)&lt;/span&gt; ，使得 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf M=\mathbf L\mathbf L^{T}\)&lt;/span&gt; ，此分解式称为 正定矩阵的乔列斯基（&lt;code&gt;Cholesky&lt;/code&gt;）分解。&lt;/li&gt;
&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf M\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(n\times n\)&lt;/span&gt; 阶正定矩阵，则 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf M\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(n\times n\)&lt;/span&gt; 阶可逆矩阵。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;正定矩阵在某个合同变换下可化为标准型，即对角矩阵。&lt;/li&gt;
&lt;li&gt;所有特征值大于零的对称矩阵也是正定矩阵。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;合同矩阵：两个实对称矩 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf A\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\mathbf B\)&lt;/span&gt; 是合同的，当且仅当存在一个可逆矩 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf P\)&lt;/span&gt; ，使 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf A=\mathbf P^{T}\mathbf B\mathbf P\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf A\)&lt;/span&gt; 的合同变换：对某个可逆矩阵 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf P\)&lt;/span&gt; ，对 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf A\)&lt;/span&gt; 执行 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf P^{T}\mathbf A\mathbf P\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;dfp-算法&quot;&gt;5.2 DFP 算法&lt;/h3&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li&gt;DFP算法(&lt;code&gt;Davidon-Fletcher-Powell&lt;/code&gt;)选 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf G_{k+1}\)&lt;/span&gt; 的方法是：&lt;br/&gt;假设每一步迭代 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf G_{k+1}\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf G_k\)&lt;/span&gt; 加上两个附加项构成 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf G_{k+1}=\mathbf G_k+\mathbf P_k+\mathbf Q_k\)&lt;/span&gt; ，其 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf P_k,\mathbf Q_k\)&lt;/span&gt; 是待定矩阵。此时有 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf G_{k+1}\mathbf {\vec y}_k=\mathbf G_k\mathbf {\vec y}_k+\mathbf P_k\mathbf {\vec y}_k+\mathbf Q_k\mathbf {\vec y}_k\)&lt;/span&gt; 。&lt;br/&gt;为了满足拟牛顿条件，可以取 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf P_k\mathbf {\vec y}_k=\vec \delta_k,\quad \mathbf Q_k\mathbf {\vec y}_k =-\mathbf G_k\mathbf {\vec y}_k\)&lt;/span&gt; 。&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;这样 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf P_k,\mathbf Q_k\)&lt;/span&gt; 不止一个。例如取&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf P_k=\frac{\vec \delta_k\vec \delta_k^{T}}{\vec \delta_k^{T}\mathbf {\vec y}_k},\quad \mathbf Q_k=-\frac{\mathbf G_k\mathbf {\vec y}_k \mathbf {\vec y}_k^{T} \mathbf G_k}{\mathbf {\vec y}_k^{T}\mathbf G_k \mathbf {\vec y}_k}\]&lt;/span&gt; ​&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这 &lt;span class=&quot;math inline&quot;&gt;\(\vec \delta_k,\mathbf {\vec y}_k\)&lt;/span&gt; 都是列向量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;则迭代公式为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf G_{k+1}=\mathbf G_k+\frac{\vec \delta_k\vec \delta_k^{T}}{\vec \delta_k^{T}\mathbf {\vec y}_k}-\frac{\mathbf G_k\mathbf {\vec y}_k \mathbf {\vec y}_k^{T} \mathbf G_k}{\mathbf {\vec y}_k^{T} \mathbf G_k \mathbf {\vec y}_k}\]&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;其中的向 &lt;span class=&quot;math inline&quot;&gt;\(\vec \delta_k,\mathbf {\vec y}_k\)&lt;/span&gt; 都是列向量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;可以证明，如果初始矩 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf G_0\)&lt;/span&gt; 是正定的，则迭代过程中每个矩 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf G_k\)&lt;/span&gt; 都是正定的&lt;/li&gt;
&lt;li&gt;DFP算法：
&lt;ul&gt;&lt;li&gt;输入：
&lt;ul&gt;&lt;li&gt;目标函数 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf {\vec x})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;梯度 &lt;span class=&quot;math inline&quot;&gt;\(g(\mathbf {\vec x})=\nabla f(\mathbf {\vec x})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;精度要求 &lt;span class=&quot;math inline&quot;&gt;\(e\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;输出 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf {\vec x})\)&lt;/span&gt; 的极小值 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^*\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;算法步骤：
&lt;ul&gt;&lt;li&gt;选取初始 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{&amp;lt;0&amp;gt;}\in \mathbb R^{n}\)&lt;/span&gt; , &lt;span class=&quot;math inline&quot;&gt;\(\mathbf G_0\)&lt;/span&gt; 为正定对称矩阵， &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; =0&lt;/li&gt;
&lt;li&gt;计 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec g}_k=g(\mathbf {\vec x}^{&amp;lt;k&amp;gt;})\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(|\mathbf {\vec g}_k| \lt e\)&lt;/span&gt; ，则停止计算，得到近似 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}=\mathbf {\vec x}^*\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(|\mathbf {\vec g}_k| \ge e\)&lt;/span&gt; ，则:
&lt;ul&gt;&lt;li&gt;计算 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec p}_k=-\mathbf G_k\mathbf {\vec g}_k\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;一维搜索：求 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_k\)&lt;/span&gt; ： &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_k=\min_{\epsilon \ge 0}f(\mathbf {\vec x}^{&amp;lt;k&amp;gt;}+\epsilon\mathbf {\vec p}_k)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;设置 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{&amp;lt;k+1&amp;gt;}=\mathbf {\vec x}^{&amp;lt;k&amp;gt;}+\epsilon_k\mathbf {\vec p}_k\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;计算 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec g}_{k+1}=g(\mathbf {\vec x}^{&amp;lt;k+1&amp;gt;})\)&lt;/span&gt; 。若 &lt;span class=&quot;math inline&quot;&gt;\(|\mathbf {\vec g}_{k+1}| \lt \varepsilon\)&lt;/span&gt; ， 则停止计算，得到近似解 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}=\mathbf {\vec x}^*\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;否则计算 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf G_{k+1}\)&lt;/span&gt; ，置 &lt;span class=&quot;math inline&quot;&gt;\(k=k+1\)&lt;/span&gt; ，计算 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec p}_k=-\mathbf G_k\mathbf {\vec g}_k\)&lt;/span&gt; 迭代&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;DFP算法中，每一 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}\)&lt;/span&gt; 增加的方向 &lt;span class=&quot;math inline&quot;&gt;\(-\mathbf G_k \nabla_k\)&lt;/span&gt; 的方向。增加的幅度 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_k\)&lt;/span&gt; 决定，若跨度过大容易引发震荡&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/numerical/gradient_descent_newton_dfp.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;bfgs-算法&quot;&gt;5.2 BFGS 算法&lt;/h3&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;BFGS是最流行的拟牛顿算法。DFP算法中， &lt;span class=&quot;math inline&quot;&gt;\(\mathbf G_k\)&lt;/span&gt; 逼 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf H^{-1}\)&lt;/span&gt; 。换个角度可以用矩 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf B_k\)&lt;/span&gt; 逼近海森矩 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf H\)&lt;/span&gt; 。此时对应的拟牛顿条件为 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf B_{k+1}\vec \delta_k=\mathbf {\vec y}_k\)&lt;/span&gt; 。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;因 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf B_0\)&lt;/span&gt; 是给定的初始化条件，所以下标 &lt;span class=&quot;math inline&quot;&gt;\(k+1\)&lt;/span&gt; 开始&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;5.5&quot;&gt;
&lt;p&gt;令 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf B_{k+1}=\mathbf B_k+\mathbf P_k+\mathbf Q_k\)&lt;/span&gt; ，有 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf B_{k+1}\vec \delta_k=\mathbf B_k\vec \delta_k+\mathbf P_k\vec \delta_k+\mathbf Q_k\vec \delta_k\)&lt;/span&gt;&lt;br/&gt;可以 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf P_k\vec \delta_k=\mathbf {\vec y}_k,\mathbf Q_k\vec \delta_k=-\mathbf B_k\vec \delta_k\)&lt;/span&gt; 。寻找合适 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf P_k,\mathbf Q_k\)&lt;/span&gt; ，可以得到BFGS算法矩阵 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf B_{k+1}\)&lt;/span&gt; 的迭代公式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf B_{k+1}=\mathbf B_k+\frac{\mathbf {\vec y}_k\mathbf {\vec y}_k^{T}}{\mathbf {\vec y}_k^{T}\vec \delta_k}-\frac{\mathbf B_k\vec \delta_k\vec \delta_k^{T}\mathbf B_k}{\vec \delta_k^{T}\mathbf B_k\vec \delta_k}\]&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;其中的向 &lt;span class=&quot;math inline&quot;&gt;\(\vec \delta_k,\mathbf {\vec y}_k\)&lt;/span&gt; 都是列向量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;可以证明， &lt;span class=&quot;math inline&quot;&gt;\(\mathbf B_0\)&lt;/span&gt; 是正定的，则迭代过程中每个矩 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf B_k\)&lt;/span&gt; 都是正定的。&lt;/li&gt;
&lt;li&gt;BFGS算法：
&lt;ul&gt;&lt;li&gt;输入：
&lt;ul&gt;&lt;li&gt;目标函数 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf {\vec x})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;梯度 &lt;span class=&quot;math inline&quot;&gt;\(g(\mathbf {\vec x})=\nabla f(\mathbf {\vec x})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;精度要求 &lt;span class=&quot;math inline&quot;&gt;\(\ e\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;输出 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf {\vec x})\)&lt;/span&gt; 的极小值 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^*\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;算法步骤：
&lt;ul&gt;&lt;li&gt;选取初始 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{&amp;lt;0&amp;gt;}\in \mathbb R^{n}\)&lt;/span&gt; , &lt;span class=&quot;math inline&quot;&gt;\(\mathbf B_0\)&lt;/span&gt; 为正定对称矩阵， &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; =0&lt;/li&gt;
&lt;li&gt;计 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec g}_k=g(\mathbf {\vec x}^{&amp;lt;k&amp;gt;})\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(|\mathbf {\vec g}_k| \lt e\)&lt;/span&gt; ，则停止计算，得到近似 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}=\mathbf {\vec x}^*\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(|\mathbf {\vec g}_k| \ge e\)&lt;/span&gt; ，则:
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;BFPS算法中，每一 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}\)&lt;/span&gt; 增加的方向 &lt;span class=&quot;math inline&quot;&gt;\(-\mathbf B_k^{-1} \nabla_k\)&lt;/span&gt; 的方向。增加的幅度 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon_k\)&lt;/span&gt; 决定，若跨度过大容易引发震荡&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/numerical/gradient_descent_newton_dfp_bfgs.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;broyden-类算法&quot;&gt;5.3 Broyden 类算法&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf G_k=\mathbf B_k^{-1},\mathbf G_{k+1}=\mathbf B_{k+1}^{-1}\)&lt;/span&gt; ，则对式子&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf B_{k+1}=\mathbf B_k+\frac{\mathbf {\vec y}_k\mathbf {\vec y}_k^{T}}{\mathbf {\vec y}_k^{T}\vec \delta_k}-\frac{\mathbf B_k\vec \delta_k\vec \delta_k^{T}\mathbf B_k}{\vec \delta_k^{T}\mathbf B_k\vec \delta_k}\]&lt;/span&gt; 使用两次&lt;code&gt;Sherman-Morrison&lt;/code&gt;公式可得：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf G_{k+1}=(\mathbf I-\frac{\vec \delta_k\mathbf {\vec y}_k^{T}}{\vec \delta_k^{T}\mathbf {\vec y}_k})\mathbf G_k(\mathbf I-\frac{\vec \delta_k\mathbf {\vec y}_k^{T}}{\vec \delta_k^{T}\mathbf {\vec y}_k})^{T}+\frac{\vec \delta_k\vec \delta_k^{T}}{\vec \delta_k^{T}\mathbf {\vec y}_k}\]&lt;/span&gt; &amp;gt; 其中的向 &lt;span class=&quot;math inline&quot;&gt;\(\vec \delta_k,\mathbf {\vec y}_k\)&lt;/span&gt; 都是列向量&lt;/li&gt;
&lt;li&gt;令DFP算法获得 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf G_{k+1}\)&lt;/span&gt; 的迭代公式记作&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf G^{DFP}=\mathbf G_k+\frac{\vec \delta_k\vec \delta_k^{T}}{\vec \delta_k^{T}\mathbf {\vec y}_k}-\frac{\mathbf G_k\mathbf {\vec y}_k \mathbf {\vec y}_k^{T} \mathbf G_k}{\mathbf {\vec y}_k^{T} \mathbf G_k \mathbf {\vec y}_k}\]&lt;/span&gt; 由BFGS算法获得 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf G_{k+1}\)&lt;/span&gt; 的迭代公式记作&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbf G^{BFGS}=(\mathbf I-\frac{\vec \delta_k\mathbf {\vec y}_k^{T}}{\vec \delta_k^{T}\mathbf {\vec y}_k})\mathbf G_k(\mathbf I-\frac{\vec \delta_k\mathbf {\vec y}_k^{T}}{\vec \delta_k^{T}\mathbf {\vec y}_k})^{T}+\frac{\vec \delta_k\vec \delta_k^{T}}{\vec \delta_k^{T}\mathbf {\vec y}_k}\]&lt;/span&gt; 他们都满足拟牛顿条件，所以他们的线性组合 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf G_{k+1}= \alpha \mathbf G^{DFP}+(1- \alpha)\mathbf G^{BFGS}\)&lt;/span&gt; 也满足拟牛顿条件，而且是正定的。其 &lt;span class=&quot;math inline&quot;&gt;\(0 \le \alpha \le 1\)&lt;/span&gt; 。&lt;br/&gt;这样获得了一族拟牛顿法，称为Broyden类算法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sherman-Morrison&lt;/code&gt;公式：假 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf A\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 阶可逆矩阵 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec u},\mathbf {\vec v}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 维列向量， &lt;span class=&quot;math inline&quot;&gt;\(\mathbf A+\mathbf {\vec u}\mathbf {\vec v}^{T}\)&lt;/span&gt; 也是可逆矩阵，则：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[(\mathbf A+\mathbf {\vec u}\mathbf {\vec v}^{T})^{-1}=\mathbf A^{-1}-\frac{\mathbf A^{-1}\mathbf {\vec u}\mathbf {\vec v}^{T}\mathbf A^{-1}}{1+\mathbf {\vec v}^{T}\mathbf A^{-1}\mathbf {\vec u}}\]&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;六-约束优化&quot;&gt;六、 约束优化&lt;/h2&gt;
&lt;h3 id=&quot;原理-1&quot;&gt;6.1 原理&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在有的最优化问题中，希望输 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}\)&lt;/span&gt; 位于特定的集 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb S\)&lt;/span&gt; 中，这称作约束优化问题。
&lt;ul&gt;&lt;li&gt;集 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb S\)&lt;/span&gt; 内的点 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}\)&lt;/span&gt; 称作可行解&lt;/li&gt;
&lt;li&gt;集合 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb S\)&lt;/span&gt; 也称作可行域。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;约束优化的一个简单方法是：对梯度下降法进行修改。
&lt;ul&gt;&lt;li&gt;每次迭代后，将得到的新 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}\)&lt;/span&gt; 映射到集 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb S\)&lt;/span&gt; 中&lt;/li&gt;
&lt;li&gt;如果使用线性搜索：则每次只搜索那些使得新 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}\)&lt;/span&gt; 位于集 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb S\)&lt;/span&gt; 中的那 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;另一个做法：将线性搜索得到的新的 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}\)&lt;/span&gt; 映射到集合 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb S\)&lt;/span&gt; 中。&lt;/li&gt;
&lt;li&gt;或者：在线性搜索之前，将梯度投影到可行域的切空间内&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;kkt-方法&quot;&gt;6.2 KKT 方法&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在约束最优化问题中，常常利用拉格朗日对偶性将原始问题转换为对偶问题，通过求解对偶问题而得到原始问题的解。&lt;/li&gt;
&lt;li&gt;约束最优化问题的原始问题：&lt;br/&gt;假 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf {\vec x}),c_i(\mathbf {\vec x}),h_j(\mathbf {\vec x})\)&lt;/span&gt; 是定义 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb R^{n}\)&lt;/span&gt; 上的连续可微函数。考虑约束最优化问题：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\min_{\mathbf {\vec x} \in \mathbb R^{n}}f(\mathbf {\vec x})\\ s.t. \quad c_i(\mathbf {\vec x}) \le 0,i=1,2,\cdots,k \;;\quad h_j(\mathbf {\vec x})=0,j=1,2,\cdots,l\]&lt;/span&gt; 可行域由等式和不等式确定&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbb S=\{\mathbf {\vec x} \mid c_i(\mathbf {\vec x}) \le 0,i=1,2,\cdots,k \;;\quad h_j(\mathbf {\vec x})=0,j=1,2,\cdots,l\}\]&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;原始问题&quot;&gt;6.2.1 原始问题&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;引入拉格朗日函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[L(\mathbf {\vec x},\vec \alpha,\vec\beta)=f(\mathbf {\vec x})+\sum_{i=1}^{k}\alpha_ic_i(\mathbf {\vec x})+\sum_{j=1}^{l}\beta_jh_j(\mathbf {\vec x})\]&lt;/span&gt; 这 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}=(x^{(1)},x^{(2)},\cdots,x^{(n)})^{T} \in \mathbb R^{n}, \alpha_i,\beta_j\)&lt;/span&gt; 是拉格朗日乘子 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i \ge 0\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(L(\mathbf {\vec x}, \vec \alpha\vec\beta)\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}, \vec \alpha,\vec \beta\)&lt;/span&gt; 的多元非线性函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;定义函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\theta_P(\mathbf {\vec x})=\max_{\vec \alpha,\vec\beta\;:\;\alpha_i \ge 0}L(\mathbf {\vec x},\vec \alpha, \vec\beta)\]&lt;/span&gt; 其中下 &lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt; 表示原始问题。则有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \theta_P(\mathbf {\vec x})= \begin{cases} f(\mathbf {\vec x}), &amp;amp; \text{if $\mathbf {\vec x}$ statisfy original problem's constraint} \\ +\infty, &amp;amp; \text{or else.} \end{cases}\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}\)&lt;/span&gt; 满足原问题的约束，则很容易证 &lt;span class=&quot;math inline&quot;&gt;\(L(\mathbf {\vec x},\vec \alpha,\vec\beta)=f(\mathbf {\vec x})+\sum_{i=1}^{k}\alpha_ic_i(\mathbf {\vec x}) \le f(\mathbf {\vec x})\)&lt;/span&gt; ，等号 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_i=0\)&lt;/span&gt; 时取到&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}\)&lt;/span&gt; 不满足原问题的约束：
&lt;ul&gt;&lt;li&gt;若不满足 $ c_i(\mathbf {\vec x}) \le 0$ ：设违反的为 &lt;span class=&quot;math inline&quot;&gt;\(c_{i0}(\mathbf {\vec x}) \gt 0\)&lt;/span&gt; ，则令 &lt;span class=&quot;math inline&quot;&gt;\(\vec \alpha_{i0} \rightarrow \infty\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(L(\mathbf {\vec x},\vec \alpha,\vec\beta)=f(\mathbf {\vec x})+\sum_{i=1}^{k}\alpha_ic_i(\mathbf {\vec x}) \rightarrow \infty\)&lt;/span&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;若不满足 $ h_j(\mathbf {\vec x}) = 0$ ： 设违反的为 &lt;span class=&quot;math inline&quot;&gt;\(h_{j0}(\mathbf {\vec x}) \ne 0\)&lt;/span&gt; ，则令 &lt;span class=&quot;math inline&quot;&gt;\(\vec\beta_{j0}h_{j0}(\mathbf {\vec x}) \rightarrow \infty\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(L(\mathbf {\vec x},\vec \alpha,\vec\beta)=f(\mathbf {\vec x})+\sum_{i=1}^{k}\alpha_ic_i(\mathbf {\vec x})+\vec\beta_{j0}h_{j0}(\mathbf {\vec x}) \rightarrow \infty\)&lt;/span&gt;&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;考虑极小化问题：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\min_{\mathbf {\vec x}} \theta_P(\mathbf {\vec x})=\min_{\mathbf {\vec x}}\max_{\vec \alpha,\vec\beta\;:\;\alpha_i \ge 0}L(\mathbf {\vec x},\vec \alpha, \vec\beta)\]&lt;/span&gt; 则该问题是与原始最优化问题是等价的，即他们有相同的问题。
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\min_{\mathbf {\vec x}}\max_{\vec \alpha,\vec\beta\;:\;\alpha_i \ge 0}L(\mathbf {\vec x},\vec \alpha, \vec\beta)\)&lt;/span&gt; 称为广义拉格朗日函数的极大极小问题。&lt;/li&gt;
&lt;li&gt;为了方便，定义原始问题的最优值为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p^{*}=\min_{\mathbf {\vec x}}\theta_P(\mathbf {\vec x})\]&lt;/span&gt; ​&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;对偶问题&quot;&gt;6.2.2 对偶问题&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;对偶问题：定 &lt;span class=&quot;math inline&quot;&gt;\(\theta_D(\vec \alpha,\vec\beta)=\min_\mathbf {\vec x} L(\mathbf {\vec x},\vec \alpha,\vec\beta)\)&lt;/span&gt; 。考虑极大 &lt;span class=&quot;math inline&quot;&gt;\(\theta_D(\vec \alpha,\vec\beta)\)&lt;/span&gt; ，即：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\max_{\vec \alpha,\vec\beta\;:\;\alpha_i \ge 0}\theta_D(\vec \alpha,\vec\beta)=\max_{\vec \alpha,\vec\beta\;:\;\alpha_i \ge 0} \min_{\mathbf {\vec x}}L(\mathbf {\vec x},\vec \alpha, \vec\beta)\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;问题 &lt;span class=&quot;math inline&quot;&gt;\(\max_{\vec \alpha,\vec\beta\;:\;\alpha_i \ge 0} \min_{\mathbf {\vec x}}L(\mathbf {\vec x},\vec \alpha, \vec\beta)\)&lt;/span&gt; 称为广义拉格朗日函数的极大极小问题。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可以将广义拉格朗日函数的极大极小问题表示为约束最优化问题：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\max_{\vec \alpha,\vec\beta\;:\;\alpha_i \ge 0}\theta_D(\vec \alpha,\vec\beta)=\max_{\vec \alpha,\vec\beta\;:\;\alpha_i \ge 0} \min_{\mathbf {\vec x}}L(\mathbf {\vec x},\vec \alpha, \vec\beta)\\ s.t. \alpha_i \ge 0, i=1,2,\cdots,k\]&lt;/span&gt; 称为原始问题的对偶问题。&lt;/li&gt;
&lt;li&gt;定义对偶问题的最优值：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[d^*=\max_{\vec \alpha,\vec\beta\;:\;\alpha_i \ge 0}\theta_D(\vec \alpha,\vec\beta)\]&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;原始问题与对偶问题关系&quot;&gt;6.2.3 原始问题与对偶问题关系&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;定理一：若原问题和对偶问题具有最优值，则：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[d^{*}=\max_{\vec \alpha,\vec\beta\;:\;\vec \alpha_i \ge 0}\min_{\mathbf {\vec x}}L(\mathbf {\vec x},\vec \alpha, \vec\beta) \le \min_{\mathbf {\vec x}}\max_{\vec \alpha,\vec\beta\;:\;\vec \alpha_i \ge 0}L(\mathbf {\vec x},\vec \alpha, \vec\beta)=p^{*}\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;推论一： &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{*}\)&lt;/span&gt; 为原始问题的可行解， &lt;span class=&quot;math inline&quot;&gt;\(\theta_P(\mathbf {\vec x}^{*})\)&lt;/span&gt; 的值 &lt;span class=&quot;math inline&quot;&gt;\(p^{*}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\vec \alpha^{*},\vec\beta^{*}\)&lt;/span&gt; 为对偶问题的可行解 &lt;span class=&quot;math inline&quot;&gt;\(\theta_D(\vec \alpha^{*},\vec\beta^{*})\)&lt;/span&gt; 值 &lt;span class=&quot;math inline&quot;&gt;\(d^{*}\)&lt;/span&gt; 。&lt;br/&gt;如果 &lt;span class=&quot;math inline&quot;&gt;\(p^{*}=d^{*}\)&lt;/span&gt; ， &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{*},\vec \alpha^{*},\vec\beta^{*}\)&lt;/span&gt; 分别为原始问题和对偶问题的最优解。&lt;/li&gt;
&lt;li&gt;定理二：假设函 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf {\vec x})\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(c_i(\mathbf {\vec x})\)&lt;/span&gt; 为凸函数 &lt;span class=&quot;math inline&quot;&gt;\(h_j(\mathbf {\vec x})\)&lt;/span&gt; 是仿射函数；并且假设不等式约 &lt;span class=&quot;math inline&quot;&gt;\(c_i(\mathbf {\vec x})\)&lt;/span&gt; 是严格可行的，即存 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}\)&lt;/span&gt; ，对于所 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(c_i(x) \lt 0\)&lt;/span&gt; 。&lt;br/&gt;则存 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{*},\vec \alpha^{*},\vec\beta^{*}\)&lt;/span&gt; ，使得 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{*}\)&lt;/span&gt; 是原始问 &lt;span class=&quot;math inline&quot;&gt;\(\min_{\mathbf {\vec x}}\theta_P(\mathbf {\vec x})\)&lt;/span&gt; 的解 &lt;span class=&quot;math inline&quot;&gt;\(\vec \alpha^{*},\vec\beta^{*}\)&lt;/span&gt; 是对偶问 &lt;span class=&quot;math inline&quot;&gt;\(\max_{\vec \alpha,\vec\beta\;:\;\alpha_i \ge 0}\theta_D(\vec \alpha,\vec\beta)\)&lt;/span&gt; 的解，并 &lt;span class=&quot;math inline&quot;&gt;\(p^{*}=d^{*}=L(\mathbf {\vec x}^{*},\vec \alpha^{*},\vec\beta^{*})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;定理三：假设函 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf {\vec x})\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(c_i(\mathbf {\vec x})\)&lt;/span&gt; 为凸函数 &lt;span class=&quot;math inline&quot;&gt;\(h_j(\mathbf {\vec x})\)&lt;/span&gt; 是仿射函数；并且假设不等式约 &lt;span class=&quot;math inline&quot;&gt;\(c_i(\mathbf {\vec x})\)&lt;/span&gt; 是严格可行的，即存 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}\)&lt;/span&gt; ，对于所 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(c_i(x) \lt 0\)&lt;/span&gt; 。&lt;br/&gt;则存 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{*},\vec \alpha^{*},\vec\beta^{*}\)&lt;/span&gt; ，使 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{*}\)&lt;/span&gt; 是原始问 &lt;span class=&quot;math inline&quot;&gt;\(\min_{\mathbf {\vec x}}\theta_P(\mathbf {\vec x})\)&lt;/span&gt; 的解 &lt;span class=&quot;math inline&quot;&gt;\(\vec \alpha^{*},\vec\beta^{*}\)&lt;/span&gt; 是对偶问 &lt;span class=&quot;math inline&quot;&gt;\(\max_{\vec \alpha,\vec\beta\;:\;\alpha_i \ge 0}\theta_D(\vec \alpha,\vec\beta)\)&lt;/span&gt; 的解的充要条件是 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}^{*},\vec \alpha^{*},\vec\beta^{*}\)&lt;/span&gt; 满足下面的&lt;code&gt;Karush-kuhn-Tucker(KKT)&lt;/code&gt;条件：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\nabla_\mathbf {\vec x}L(\mathbf {\vec x}^{*},\vec \alpha^{*},\vec\beta^{*})=0\\ \nabla_\vec \alpha L(\mathbf {\vec x}^{*},\vec \alpha^{*},\vec\beta^{*})=0\\ \nabla_\vec\beta L(\mathbf {\vec x}^{*},\vec \alpha^{*},\vec\beta^{*})=0\\ \vec \alpha^{*}_ic_i(\mathbf {\vec x}^{*})=0,i=1,2,\cdots,k\\ c_i(\mathbf {\vec x}^{*})\le 0,i=1,2,\cdots,k\\ \vec \alpha^{*}_i \ge 0,i=1,2,\cdots,k\\ h_j(\mathbf {\vec x}^{*})= 0,j=1,2,\cdots,l\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;仿射函数：仿射函数即由1阶多项式构成的函数。&lt;br/&gt;一般形式 &lt;span class=&quot;math inline&quot;&gt;\(f(\mathbf {\vec x}) = \mathbf A \mathbf {\vec x} + b\)&lt;/span&gt; ，这里 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf A\)&lt;/span&gt; 是一 &lt;span class=&quot;math inline&quot;&gt;\(m\times k\)&lt;/span&gt; 矩阵 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}\)&lt;/span&gt; 是一 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 维列向量 &lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt; 是一 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 维列向量
&lt;ul&gt;&lt;li&gt;它实际上反映了一种从 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 维到 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 维的空间映射关系。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;凸函数： &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 为定义在区 &lt;span class=&quot;math inline&quot;&gt;\(I\)&lt;/span&gt; 上的函数，若 &lt;span class=&quot;math inline&quot;&gt;\(I\)&lt;/span&gt; 上的任意两 &lt;span class=&quot;math inline&quot;&gt;\(\mathbf {\vec x}_1,\mathbf {\vec x}_2\)&lt;/span&gt; 和任意的实 &lt;span class=&quot;math inline&quot;&gt;\(\lambda \in (0,1)\)&lt;/span&gt; ，总 &lt;span class=&quot;math inline&quot;&gt;\(f(\lambda \mathbf {\vec x}_1+(1-\lambda)\mathbf {\vec x}_2) \ge \lambda f(\mathbf {\vec x}_1)+(1-\lambda)f(\mathbf {\vec x}_2)\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 称 &lt;span class=&quot;math inline&quot;&gt;\(I\)&lt;/span&gt; 上的凸函数&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;一-sigmoid&quot;&gt;一、 sigmoid&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;sigmoid&lt;/code&gt;函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\sigma(x)=\frac{1}{1+\exp(-x)}\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;该函数可以用于生成二项分布 &lt;span class=&quot;math inline&quot;&gt;\(\phi\)&lt;/span&gt; 参数&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 很大或者很小时，该函数处于饱和状态。
&lt;ul&gt;&lt;li&gt;此时函数的曲线非常平坦，并且自变量的一个较大的变化只能带来函数值的一个微小的变化（即对自变量的变化不敏感）。&lt;br/&gt;&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/func/sigmoid.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二-softplus&quot;&gt;二、 softplus&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;softplus&lt;/code&gt;函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\zeta(x)=\log(1+\exp(x))\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;该函数可以生成正态分布 &lt;span class=&quot;math inline&quot;&gt;\(\sigma^{2}\)&lt;/span&gt; 参数&lt;/li&gt;
&lt;li&gt;它之所以称作&lt;code&gt;softplus&lt;/code&gt;，因为它是下面函数的一个光滑逼近：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[x^{+}=\max(0,x)\]&lt;/span&gt; ​&lt;br/&gt;&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/func/softplus.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sigmoid&lt;/code&gt;和&lt;code&gt;softplus&lt;/code&gt;函数的性质：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\sigma(x)=\frac{\exp(x)}{\exp(x)+\exp(0)} \\ \frac {d}{dx}\sigma(x)=\sigma(x)(1-\sigma(x)) \\ 1-\sigma(x)=\sigma(-x) \\ \log\sigma(x)=-\zeta(-x) \\ \frac{d}{dx}\zeta(x)=\sigma(x) \\ \forall x\in(0,1),\sigma^{-1}(x)=\log(\frac{x}{1-x}) \\ \forall x \gt 0,\zeta^{-1}(x)=\log(\exp(x)-1) \\ \zeta(x)=\int_{-\infty}^{x}\sigma(y)dy \\ \zeta(x)-\zeta(-x)=x \\\]&lt;/span&gt; 其 &lt;span class=&quot;math inline&quot;&gt;\(f^{-1}(\cdot)\)&lt;/span&gt; 为反函数。
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\sigma^{-1}(x)\)&lt;/span&gt; 也称作&lt;code&gt;logit&lt;/code&gt;函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果定义两个函数&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[x^{+}=\max(0,x)\\ x^{-}=\max(0,-x)\]&lt;/span&gt; 则它们分布获取 &lt;span class=&quot;math inline&quot;&gt;\(y=x\)&lt;/span&gt; 的正部分和负部分。&lt;br/&gt;根据定义有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[x=x^{+}-x^{-} \]&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\zeta(x)\)&lt;/span&gt; 逼近的 &lt;span class=&quot;math inline&quot;&gt;\(x^{+}\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(\zeta(-x)\)&lt;/span&gt; 逼近的 &lt;span class=&quot;math inline&quot;&gt;\(x^{-}\)&lt;/span&gt; ，于是有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\zeta(x)-\zeta(-x)=x \]&lt;/span&gt;
&lt;center&gt;&lt;img src=&quot;http://www.huaxiaozhuan.com/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/imgs/func/sigmoid_softplus.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三gamma-函数和贝塔函数&quot;&gt;三、Gamma 函数和贝塔函数&lt;/h2&gt;
&lt;h3 id=&quot;伽马函数&quot;&gt;3.1 伽马函数&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;伽马函数定义为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\Gamma(x)=\int_0^{+\infty} t^{x-1}e^{-t}dt\quad,x\in \mathbb R\\ or. \quad\Gamma(z)=\int_0^{+\infty} t^{z-1}e^{-t}dt\quad,z\in \mathbb Z\\\]&lt;/span&gt; 性质为：
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Gamma(x+1)=x\Gamma(x)\)&lt;/span&gt; ，因此伽马函数是阶乘在实数域上的扩展。
&lt;ul&gt;&lt;li&gt;对于正整数 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 有： &lt;span class=&quot;math inline&quot;&gt;\(\Gamma(n)=(n-1)!\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;与贝塔函数的关系：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[B(m,n)=\frac{\Gamma(m)\Gamma(n)}{\Gamma(m+n)}\]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对 &lt;span class=&quot;math inline&quot;&gt;\(x \in (0,1)\)&lt;/span&gt; 有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\Gamma(1-x)\Gamma(x)=\frac{\pi}{\sin\pi x}\]&lt;/span&gt; 则推导出重要公式 &lt;span class=&quot;math inline&quot;&gt;\(\Gamma(\frac 12)=\sqrt\pi\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对 &lt;span class=&quot;math inline&quot;&gt;\(x\gt 0\)&lt;/span&gt; ，伽马函数严格凹函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 足够大时，可以用Stirling公式来计算Gamma函数值：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\Gamma(x) \sim \sqrt{2\pi} e^{-x}x^{x+1/2}\]&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;伽马分布&quot;&gt;3.2 伽马分布&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;伽马分布的概率密度函数为：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[p(x;\alpha,\beta)=\frac{\beta^{\alpha}}{\Gamma(\alpha)}x^{\alpha-1}e^{-\beta x},\quad x\gt 0\]&lt;/span&gt; 记 &lt;span class=&quot;math inline&quot;&gt;\(\Gamma(\alpha,\beta)\)&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;期望 &lt;span class=&quot;math inline&quot;&gt;\(\mathbb E[X]=\frac \alpha\beta\)&lt;/span&gt; ，方 &lt;span class=&quot;math inline&quot;&gt;\(Var[X]=\frac{\alpha}{\beta^2}\)&lt;/span&gt;&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;性质：
&lt;ul&gt;&lt;li&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(\beta=n\)&lt;/span&gt; 时， 为 &lt;code&gt;Erlang&lt;/code&gt;分布&lt;/li&gt;
&lt;li&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(\alpha=1,\beta=\frac 1\lambda\)&lt;/span&gt; 时，就是参数为 $\lambda $ 的指数分布&lt;/li&gt;
&lt;li&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(\alpha=\frac n2,\beta=\frac 12\)&lt;/span&gt; 时，就是常用的卡方分布&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;伽马分布的可加性：设随机变 &lt;span class=&quot;math inline&quot;&gt;\(X_1,X_2,\cdots,X_n\)&lt;/span&gt; 相互独立并且都服从伽马分 &lt;span class=&quot;math inline&quot;&gt;\(X \sim \Gamma(x;)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;贝塔函数&quot;&gt;3.3 贝塔函数&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;贝塔函数：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[B(m,n)=2\int_0^{\frac \pi 2}\sin ^{2m-1}(x) \cos ^{2n-1}(x) dx\]&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(m,n\gt 0\)&lt;/span&gt; 时，有：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[B(m,n)=\int _0^1x^{m-1}(1-x)^{n-1}dx\]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(m,n\)&lt;/span&gt; 足够大时，可以用Stirling公式来计算贝塔函数值：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[B(m,n)=\frac{\sqrt{(2\pi)m^{m-1/2}n^{n-1/2}}}{(m+n)^{m+n-1/2}}\]&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;3.2926829268293&quot;&gt;
&lt;p&gt;本文转载自华校专老师博客，博客地址：&lt;a href=&quot;http://www.huaxiaozhuan.com/&quot; class=&quot;uri&quot;&gt;http://www.huaxiaozhuan.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 04 Nov 2018 13:40:00 +0000</pubDate>
<dc:creator>郭耀华</dc:creator>
<og:description>[TOC] 线性代数 一、基本知识 1. 本文中所有的向量都是列向量的形式： $$\mathbf{\vec x}=(x_1,x_2,\cdots,x_n)^T=\begin{bmatrix}x_1\\</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guoyaohua/p/9905760.html</dc:identifier>
</item>
<item>
<title>数学 线性筛约数个数和，约数和 - _王小呆</title>
<link>http://www.cnblogs.com/wangxiaodai/p/9905935.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangxiaodai/p/9905935.html</guid>
<description>&lt;h2 id=&quot;线性筛约数个数和约数和&quot;&gt;线性筛约数个数和，约数和&lt;/h2&gt;
&lt;h3 id=&quot;一线性筛约数个数和&quot;&gt;一，线性筛约数个数和&lt;/h3&gt;
&lt;p&gt;​ 根据唯一分解定理，可得：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ n=p_1^{r_1}*p_2^{r_2}*……*p_k^{r_k} \]&lt;/span&gt;&lt;br/&gt;​ 对于每个n的约束，肯定是由以上质因数&lt;span class=&quot;math inline&quot;&gt;\(p_k\)&lt;/span&gt;相乘得来的，那么根据乘法原理，每个质因数都可以选择&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;到&lt;span class=&quot;math inline&quot;&gt;\(r_k\)&lt;/span&gt;这&lt;span class=&quot;math inline&quot;&gt;\(r_k+1\)&lt;/span&gt;个选择。&lt;/p&gt;
&lt;p&gt;​ 那么n的约数个数即为&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ d(n)=\prod_{i=1}^k(r_i+1) \]&lt;/span&gt;&lt;br/&gt;筛的过程中需要保存n的最小质因子的出现个数即&lt;span class=&quot;math inline&quot;&gt;\(r_1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我们设d(i)表示&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;的约数个数和，num(i)表示i的最小质因数的个数。&lt;/p&gt;
&lt;p&gt;那么就可以愉快地分情况讨论了。&lt;/p&gt;
&lt;p&gt;(一)，如果当前数是素数，那么可得：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ d(i)=2\\num(i)=1 \]&lt;/span&gt;&lt;br/&gt;(二)，当前数取模枚举的第j个素数不为0，即&lt;span class=&quot;math inline&quot;&gt;\(i％prime[j]!=0\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;​ 我们要去更新&lt;span class=&quot;math inline&quot;&gt;\(i*prime[j]\)&lt;/span&gt;的有关信息。&lt;/p&gt;
&lt;p&gt;​ 首先我们知道&lt;span class=&quot;math inline&quot;&gt;\(i*prime[j]\)&lt;/span&gt;这个数中之前一定不包含&lt;span class=&quot;math inline&quot;&gt;\(prime[j]\)&lt;/span&gt;这个质因数。&lt;/p&gt;
&lt;p&gt;​ 那么约数个数和就要加上&lt;span class=&quot;math inline&quot;&gt;\(prime[j]\)&lt;/span&gt;的，也就是：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ d(i*prime[j])=(1+r_1)*……*(1+r_k)*(1+1)\\=d(i)*d(prime[j]) \]&lt;/span&gt;&lt;br/&gt;​ 然后对于最小质因子，因为ｊ是从小到大枚举的，所以&lt;span class=&quot;math inline&quot;&gt;\(i*prime[j]\)&lt;/span&gt;这个数的最小质因子也就是&lt;span class=&quot;math inline&quot;&gt;\(prime[j]\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ 所以就可以得到：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ num(i*prime[j])=1 \]&lt;/span&gt;&lt;br/&gt;(三)，当前数取模枚举的第j个素数为0，即&lt;span class=&quot;math inline&quot;&gt;\(j%prime[j]==0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ 依旧要去更新&lt;span class=&quot;math inline&quot;&gt;\(i*prime[j]\)&lt;/span&gt;的信息。&lt;/p&gt;
&lt;p&gt;​ 这个时候&lt;span class=&quot;math inline&quot;&gt;\(i*prime(j)\)&lt;/span&gt;中已经存在&lt;span class=&quot;math inline&quot;&gt;\(prime[j]\)&lt;/span&gt;这个质因子了，并且&lt;span class=&quot;math inline&quot;&gt;\(prime[j]\)&lt;/span&gt;也一定是&lt;span class=&quot;math inline&quot;&gt;\(i*prime[j]\)&lt;/span&gt;的最小质因子，所以就可以得到：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ d(i*prime[j])=(1+r_1+1)*……*(1+r_k) \]&lt;/span&gt;&lt;br/&gt;那么怎么从&lt;span class=&quot;math inline&quot;&gt;\(d(i)\)&lt;/span&gt;转移呢？&lt;/p&gt;
&lt;p&gt;这个时候就可以用到我们之前维护的num(i)了。&lt;/p&gt;
&lt;p&gt;转移也就非常简单了：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ d(i*prime[j])=d(i)/(num(i)+1)*(num(i)+2) \]&lt;/span&gt;&lt;br/&gt;num也要转移，加上最小质因子&lt;span class=&quot;math inline&quot;&gt;\(prime[j]\)&lt;/span&gt;的贡献也就是：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ num(i*prime[j])=num(i)+1 \]&lt;/span&gt;&lt;br/&gt;综上，就可以写出筛质因数个数的代码了。&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;

using namespace std;

const int wx=1017;

int isprime[wx],prime[wx],d[wx],num[wx];
int tot,n,m;

inline int read(){
    int sum=0,f=1; char ch=getchar();
    while(ch&amp;lt;'0'||ch&amp;gt;'9'){if(ch=='-')f=-1; ch=getchar();}
    while(ch&amp;gt;='0'&amp;amp;&amp;amp;ch&amp;lt;='9'){sum=(sum&amp;lt;&amp;lt;1)+(sum&amp;lt;&amp;lt;3)+ch-'0'; ch=getchar();}
    return sum*f;
}

void Euler(){
    memset(isprime,1,sizeof isprime); d[1]=1;
    for(int i=2;i&amp;lt;=n;i++){
        if(isprime[i]){
            prime[++tot]=i;
            d[i]=2;
            num[i]=1;
        }
        for(int j=1;j&amp;lt;=tot&amp;amp;&amp;amp;i*prime[j]&amp;lt;=n;j++){
            isprime[i*prime[j]]=0;
            if(i%prime[j]==0){
                d[i*prime[j]]=d[i]/(num[i]+1)*(num[i]+2);
                num[i*prime[j]]=num[i]+1; break;
            }
            else{
                d[i*prime[j]]=d[i]*d[prime[j]];
                num[i*prime[j]]=1;
            }
        }
    }
}



int main(){
    n=read(); Euler();
    for(int i=1;i&amp;lt;=n;i++)printf(&quot;%d %d\n&quot;,i,d[i]);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二线性筛约数和&quot;&gt;二，线性筛约数和&lt;/h3&gt;
&lt;p&gt;我们设&lt;span class=&quot;math inline&quot;&gt;\(sd(i)\)&lt;/span&gt;表示i的约数和。&lt;/p&gt;
&lt;p&gt;在算数基本定理中，可以得：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ sd(n)=(1+p_1+p_1^2+……+p_1^{r_1})*(1+p_2+p_2^2+……+p_2^{r_2})*……*(1+p_k+p_k^2+……+p_k^{r_k}) \]&lt;/span&gt;&lt;br/&gt;​ 那么根据这个式子就可以开始干了。。。&lt;/p&gt;
&lt;p&gt;​ 这个时候我们需要记录最小质因子的那一项也就是&lt;span class=&quot;math inline&quot;&gt;\((1+p_1+p_1^2+……+p_1^{r_1})\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;可以设&lt;span class=&quot;math inline&quot;&gt;\(sd(i)\)&lt;/span&gt;表示i的约数和。设&lt;span class=&quot;math inline&quot;&gt;\(num(i)\)&lt;/span&gt;表示我们需要记录的最小质因子的那一项(等比数列？)。&lt;/p&gt;
&lt;p&gt;好了，开始分情况讨论吧。&lt;/p&gt;
&lt;p&gt;(一)，当前数是一个素数：&lt;/p&gt;
&lt;p&gt;​ 易知：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ sd(i)=i+1\\num(i)=i+1 \]&lt;/span&gt;&lt;br/&gt;(二)，当前数取模枚举的质数不等于0&lt;/p&gt;
&lt;p&gt;​ 易知&lt;span class=&quot;math inline&quot;&gt;\(i*prime[j]\)&lt;/span&gt;里原先没有&lt;span class=&quot;math inline&quot;&gt;\(prime[j]\)&lt;/span&gt;这一项，加上这一项之后可得：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ sd(i*prime[j])=sd(i)*sd(prime[j]) \]&lt;/span&gt;&lt;br/&gt;​ (好吧我又犯懒了。。。但是思路是和上面一样的)&lt;/p&gt;
&lt;p&gt;​ 同时更新一下&lt;span class=&quot;math inline&quot;&gt;\(num(i*prime[j])\)&lt;/span&gt;。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ num(i*prime[j])=1+prime[j] \]&lt;/span&gt;&lt;br/&gt;这是因为质因子从小到大枚举，那么&lt;span class=&quot;math inline&quot;&gt;\(i*prime[j]\)&lt;/span&gt;的最小质因子就应该是&lt;span class=&quot;math inline&quot;&gt;\(prime[j]\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(num(i*prime[j])\)&lt;/span&gt;也就应该等于&lt;span class=&quot;math inline&quot;&gt;\(num(prime[j])\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(三)，当前数取模枚举的质数等于0&lt;/p&gt;
&lt;p&gt;​ 那么&lt;span class=&quot;math inline&quot;&gt;\(sd(i*prime[j])\)&lt;/span&gt;中的第一项也就是&lt;span class=&quot;math inline&quot;&gt;\(num(i*prime[j])\)&lt;/span&gt;一定是&lt;span class=&quot;math inline&quot;&gt;\(prime[j]\)&lt;/span&gt;的一项。&lt;/p&gt;
&lt;p&gt;​ 也就是&lt;span class=&quot;math inline&quot;&gt;\((1+p_i+p_i^2+……+p_i^{r_i})\)&lt;/span&gt;这个时候要变成&lt;span class=&quot;math inline&quot;&gt;\((1+p_i+p_i^2+……+p_i^{r_i}+p_i^{r_i+1})\)&lt;/span&gt;，那么只需要所有的都乘以一个&lt;span class=&quot;math inline&quot;&gt;\(p_i\)&lt;/span&gt;也就是&lt;span class=&quot;math inline&quot;&gt;\(prime[j]\)&lt;/span&gt;，然后再加一个一就好了。&lt;/p&gt;
&lt;p&gt;​ 即：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ d(i*prime[j])=(d(i)/num(i)*(num(i)*prime[j])+1 \]&lt;/span&gt;&lt;br/&gt;然后&lt;span class=&quot;math inline&quot;&gt;\(num(i*prime[j])\)&lt;/span&gt;依旧是&lt;span class=&quot;math inline&quot;&gt;\(prime[j]\)&lt;/span&gt;这一项，那么就是：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ num(i*prime[j])=num(i)*prime[j]+1 \]&lt;/span&gt;&lt;br/&gt;这样，我们又可以开始愉快的写代码啦。。。&lt;/p&gt;
&lt;p&gt;code:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstring&amp;gt;

using namespace std;

const int wx=1017; 

inline int read(){
    int sum=0,f=1; char ch=getchar();
    while(ch&amp;lt;'0'||ch&amp;gt;'9'){if(ch=='-')f=-1; ch=getchar();}
    while(ch&amp;gt;='0'&amp;amp;&amp;amp;ch&amp;lt;='9'){sum=(sum&amp;lt;&amp;lt;1)+(sum&amp;lt;&amp;lt;3)+ch-'0'; ch=getchar();}
    return sum*f;
}

int isprime[wx],sd[wx],num[wx],prime[wx];
int n,tot;

void Euler(){
    memset(isprime,1,sizeof isprime); sd[1]=1;
    for(int i=2;i&amp;lt;=n;i++){
        if(isprime[i]){
            prime[++tot]=i;
            sd[i]=1+i; num[i]=1+i;
        }
        for(int j=1;j&amp;lt;=tot&amp;amp;&amp;amp;prime[j]*i&amp;lt;=n;j++){
            isprime[i*prime[j]]=0;
            if(i%prime[j]!=0){
                sd[i*prime[j]]=sd[i]*sd[prime[j]];
                num[i*prime[j]]=prime[j]+1;
            }
            else{
                sd[i*prime[j]]=sd[i]/num[i]*(num[i]*prime[j]+1);
                num[i*prime[j]]=num[i]*prime[j]+1; break;
            }
        }
    }
}

int main(){
    n=read(); Euler();
    for(int i=1;i&amp;lt;=n;i++)printf(&quot;%d %d\n&quot;,i,sd[i]);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 04 Nov 2018 13:23:00 +0000</pubDate>
<dc:creator>_王小呆</dc:creator>
<og:description>线性筛约数个数和，约数和 一，线性筛约数个数和 ​ 根据唯一分解定理，可得： $$ n=p_1^{r_1} p_2^{r_2} …… p_k^{r_k} $$ ​ 对于每个n的约束，肯定是由以上质因数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangxiaodai/p/9905935.html</dc:identifier>
</item>
</channel>
</rss>