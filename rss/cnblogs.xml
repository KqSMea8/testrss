<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一种强化的基于局部直方图裁剪均衡化的对比度调节算法。 - Imageshop</title>
<link>http://www.cnblogs.com/Imageshop/p/7993319.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Imageshop/p/7993319.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　在很久前实现对比度受限的自适应直方图均衡化时，就曾经想过对该算法进行一定程度的扩展，之后使用自动对比度和自动色阶代替直方图均衡化也提出了新的算法，也达到了不错的效果。本文进一步对该算法进行一定程度的扩展和补充优化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、本文算法的概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　根据选取的优化的水平和垂直网格数，将图像切分成一个一个的子块，然后统计每个子块的直方图信息，并和原图整体的直方图信息进行某种混合，对于彩色图像，为了避免不同通道之间处理后变化过于不协调，还增加了各通道直方图与亮度通道直方图的信息合成，然后对合成后的直方图进行直方图裁剪和均衡化的，获取各子块新的映射直方图，为了避免新的映射表中的数据有较大的奇点或噪音，对映射表的数据进行多点取样，然后使用样条插值算法对取样点进行插值，或者对新的映射表进行一定程度的高斯模糊，得到一张较为平滑的映射表。最后使用类似CLAHE算法中的双线性插值对每个子块之间的映射表进行插值得到新的像素值。本方法计算量小，速度很快，对映射表进行平滑插值或高斯模糊能有效的抑制对比度调整时产生的噪声，防止了信息的过度放大造成图片失真，是一种高效并且效果突出的对比度增强算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、算法过程详解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　1、水平和垂直网格数的确定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　类似于CALHE算法，对网格的合理选取也会对本算法的结果产生重要的影响，过多的网格数会使得计算量显著加大，过少的网格数使得结果趋于接近整体的直方图均衡化，一般情况下，可选择8*8个网格，这里可以通过以下原则来简单的做个优化：&lt;/span&gt;&lt;span&gt;图像的亮度的均方差越小，即整幅图像的明暗比较一致，使用较多的网格数，比如8*8，否则使用较少的网格，比如4*4。这是因为当图像明暗较为一致时，各小块的直方图数据差异不会很大，而如果明暗不一致，选择较小的块，各块之间的直方图信息差异可能很大，会造成插值时出现明显的瑕疵。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2、按规定的网格数划分图像，并获取每块的直方图信息&lt;/span&gt;HistB，HistG，HistR。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 3、获取全图的直方图数据&lt;/span&gt;HistgramB，HistgramG，HistgramR以及亮度直方图HistgramL。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　其中亮度定义为：　　Lightness = (R*19595 + G*38469 + B*7472) &amp;gt;&amp;gt; 16&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    4、对子块直方图和全局直方图进行融合，如下代码所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
HistB[Index] = (HistB[Index] * Adaptation + (&lt;span&gt;100&lt;/span&gt; - Adaptation) * HistgramB[Index]) / &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
HistG[Index] &lt;/span&gt;= (HistG[Index] * Adaptation + (&lt;span&gt;100&lt;/span&gt; - Adaptation) * HistgramG[Index]) / &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
HistR[Index] &lt;/span&gt;= (HistR[Index] * Adaptation + (&lt;span&gt;100&lt;/span&gt; - Adaptation) * HistgramR[Index]) / &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
HistL[Index] &lt;/span&gt;= (HistL[Index] * Adaptation + (&lt;span&gt;100&lt;/span&gt; - Adaptation) * HistgramL[Index]) / &lt;span&gt;100&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　其中Adaptation为融合因子，其有效范围为[0,100]，当取值越小时，全局直方图其主导作用，效果越接近普通的直方图均衡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5、对上述融合后的结果再次和亮度直方图进行融合，融合过程如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
HistB[Index] = (HistB[Index] * Correction + (&lt;span&gt;100&lt;/span&gt; - Correction) * HistL[Index]) / &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
HistG[Index] &lt;/span&gt;= (HistG[Index] * Correction + (&lt;span&gt;100&lt;/span&gt; - Correction) * HistL[Index]) / &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;
HistR[Index] &lt;/span&gt;= (HistR[Index] * Correction + (&lt;span&gt;100&lt;/span&gt; - Correction) * HistL[Index]) / &lt;span&gt;100&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　&lt;span&gt;　其中Correction为颜色校正因子，其有效范围为[0,100]，当取值越大时，各通道之间越独立，效果越接近普通的直方图均衡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上述代码中Index表示直方图色阶的索引范围，有效值[0,Bins – 1]，Bins为直方图的数量，8位时为256。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　6、按照CALHE的方式对直方图进行裁剪，之后对裁剪的直方图进行均衡化得到每个小块的映射表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　7、局部均衡化后映射表的平滑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1)  将映射表的 Bins取K等份，得到每等份数据对应的映射表值，构成K个二维坐标点序列，亦可以根据直方图的累计数据，把累计数据平均分为K等分，得到K个二维序列点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2）根据K个二维坐标点，使用样条插值算法拟合出一条过各个取样点的平滑映射曲线。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　3）在平滑曲线表中取0至于Bins中各色阶对应的插值结果，作为新的映射表结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　　　对于Bins =256的图像，K值建议可取32左右。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　或者另外一种处理方式就是对映射表进行一维方向的均值或者高斯平滑，平滑窗口可选WindowSize = 7左右。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这种平滑可以带来一定的好处，特别是对于图像变换比较平缓的区域，能够在一定程度上减弱由于增强带来的色块感觉，而且这种方式推广到所有基于直方图增强技术的算法中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;span&gt;　8、按照CLAHE算法的过程对每个小块进行双线性插值得到最终的增强效果，当然&lt;/span&gt;&lt;span&gt;对第一行、第一列、最后一行、最后一列的子块靠近图像边缘的那一半都只使用映射表单个方向的线性插值，而这些子块的其他部分以及其他子块均使用映射表双线性插值获得最终结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       如果输入图像是灰度图，由于只有一个通道，则本算法中的Correction在此场景中是可舍弃的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　整个过程的流程框图如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                             &lt;img src=&quot;http://images2017.cnblogs.com/blog/349293/201712/349293-20171206171903675-685241867.png&quot; alt=&quot;&quot; width=&quot;469&quot; height=&quot;726&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  &lt;span&gt;&lt;strong&gt;     三、测试结果&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下图为未经过处理的原始图像，可见原始图中对比度很差，图像的细节信息很少，图像饱和度也很差。右侧是使用本算法后处理的效果图，处理后图像饱和度自然，色彩鲜艳，隐藏在原图右侧的一些不可易见的细节也能清楚的展示出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/349293/201712/349293-20171207123335316-1519318162.jpg&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;           &lt;img src=&quot;http://images2017.cnblogs.com/blog/349293/201712/349293-20171207123353909-371358268.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　原始图像　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　           Adaptation = 50，Correction = 50， ClipLimit = 20时的效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/349293/201712/349293-20171207124054550-353281049.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;          &lt;img src=&quot;http://images2017.cnblogs.com/blog/349293/201712/349293-20171207152037675-1581258898.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　           Adaptation = 0，Correction = 50， ClipLimit = 20时的效果                                                                                      Adaptation = 100，Correction = 50， ClipLimit = 20时的效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/349293/201712/349293-20171207152230472-1959710595.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;         &lt;img src=&quot;http://images2017.cnblogs.com/blog/349293/201712/349293-20171207152332019-574745034.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  　　　　　　 Adaptation = 50，Correction = 0， ClipLimit = 20时的效果　　　　　　　　　　　　　　　　　　　　　　   Adaptation = 50，Correction = 100， ClipLimit = 20时的效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     下面作图是另外一副未经处理的图像，这副图像信息较为完整，色彩也较为丰富，但是经过本算法处理后，得到的结果图（右图）则显得更为惊艳和夺目，因此对于正常的图像，本算法也具有较强的实用性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/349293/201712/349293-20171207152725144-725979175.jpg&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;        &lt;img src=&quot;http://images2017.cnblogs.com/blog/349293/201712/349293-20171207152813253-212194845.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　特别强调，该算法不适宜处理人脸图像。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       该算法难以使用SSE优化，我在考虑是否还有其他方式优化。速度上1080P的彩图大约30ms可以搞定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       测试工程的地址：&lt;a href=&quot;http://files.cnblogs.com/files/Imageshop/SSE_Optimization_Demo.rar&quot; target=&quot;_blank&quot;&gt;http://files.cnblogs.com/files/Imageshop/SSE_Optimization_Demo.rar&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/349293/201712/349293-20171207154114581-161094390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      写博不易，欢迎点赞或者打赏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/349293/201712/349293-20171207154249363-216379654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 Dec 2017 07:49:00 +0000</pubDate>
<dc:creator>Imageshop</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Imageshop/p/7993319.html</dc:identifier>
</item>
<item>
<title>Python函数篇（二）之递归函数、匿名函数及高阶函数 - 无敌小怪兽</title>
<link>http://www.cnblogs.com/Chen-Zhipeng/p/7991550.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Chen-Zhipeng/p/7991550.html</guid>
<description>&lt;h2&gt;1.全局变量和局部变量&lt;/h2&gt;
&lt;p&gt;　　一般定义在程序的最开始的变量称为函数变量，在子程序中定义的变量称为局部变量，可以简单的理解为，无缩进的为全局变量，有缩进的是局部变量，全局变量的作用域是整个程序，而局部变量的作用域是子程序内部，当程序运行时，首先会找程序内部有没有局部变量，如果有，则调用，如果没有，才会去调用全局变量。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;name=&quot;czp&quot;　　　　　　　　　　　　&lt;span&gt;#全局变量&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func():
    &lt;span&gt;name&lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&quot;czp1&quot;　　　　　　　　　&lt;span&gt;#局部变量&lt;/span&gt;&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)
func()
运行结果：
czp1　　　　　　　　　　　　 　&lt;span&gt;调用func()函数，程序会先在函数内部找有没有name这个变量，如果有，就会调用该name的值，而如果没有定义局部变量的话，函数会去找全局name。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以通过global关键字，通过局部变量修改全局变量，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;name=&quot;czp&quot;　　　　　　　　　　&lt;span&gt;#定义全局变量&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt;&lt;span&gt;&lt;span&gt; name　　　　　　　&lt;span&gt;在函数内部，通过global关键字，通过局部变量修改全局变量的值&lt;/span&gt;&lt;/span&gt;
    &lt;span&gt;name&lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&quot;czp1&quot;&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name)
&lt;span&gt;func()　　　　　　　　　　　　&lt;span&gt;打印局部变量中name的值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;&lt;span&gt;(name)　　　　　　　　　&lt;span&gt;打印全局变量中name的值&lt;/span&gt;&lt;/span&gt;
运行结果：
czp1
czp1　　　　　　　　　　　　　&lt;span&gt;在运行结果中可以明显看出，通过global，在定义局部变量的同时，也修改了全局变量的值&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　global与nonlocal的区别：&lt;/p&gt;
&lt;p&gt;　　python引用变量的顺序： 当前作用域局部变量-&amp;gt;外层作用域变量-&amp;gt;当前模块中的全局变量-&amp;gt;python内置变量&lt;/p&gt;
&lt;p&gt;　　global关键字用来在函数或局部作用域中使用全局变量，并通过glabal关键字在局部作用域中修改全局变量（一般不推荐这么做）&lt;/p&gt;
&lt;p&gt;　　nonlocal关键字用来在函数或局部作用域使用外层（非全局）变量。&lt;/p&gt;
&lt;h2&gt;2.递归函数&lt;/h2&gt;
&lt;p&gt;　　在一个函数的内部，可以调用其他的函数，如果某一个函数在内部调用的函数仍然是自身，这个函数就可以称为递归函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; calc(n):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(n)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; int(n/2)==&lt;span&gt;0:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n
    &lt;/span&gt;&lt;span&gt;return calc(int(n/2&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;)　　　　　　　　&lt;span&gt;在calc函数中，反复调用calc自身，这样的函数就是递归函数&lt;/span&gt;
calc(&lt;/span&gt;10&lt;span&gt;)
运行结果：
&lt;/span&gt;10
5
2
1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意：在递归函数中，并不是可以让自身永远的循环下去，递归函数中必须定义一个明确的结束条件，每进行更深一次的递归，解决问题的规模必须要较上一层有所减少，&lt;/p&gt;
&lt;p&gt;　　递归函数常用来进行二分查找。。&lt;/p&gt;
&lt;h2&gt;3.匿名函数&lt;/h2&gt;
&lt;p&gt;　　匿名函数其实就是不需要指定显示的函数。用lambda关键字定义，通常我们定义一个函数用这种形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; calc(x):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x+1
&lt;span&gt;print&lt;/span&gt;(calc(2&lt;span&gt;))
运行结果：
&lt;/span&gt;3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　而上段代码 用匿名函数使用的话，就可以使用如下的方式，通过lambda关键字，传入一个形参x，用冒号隔开，后面加入return的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
res=&lt;span&gt;lambda x:x+1&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(res(2&lt;span&gt;))
运行结果：
&lt;/span&gt;3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　匿名函数单独这么用意义不大，但是和其他函数一起用的时候，功能就显现的很明显了。如下面的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;res=map(lambda x:x**2,[2,4,6,])
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; res:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)
运行结果：
&lt;/span&gt;4
16
36
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　我会在接下来写内置方法的时候具体的展示出使用匿名函数的好处。&lt;/p&gt;
&lt;h2&gt;4.高阶函数&lt;/h2&gt;
&lt;p&gt;　　高阶函数的特点如下：1）函数接收的参数是一个函数 ；2）函数的返回值是一个函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;将函数作为参数传给另一个函数&lt;br/&gt;def&lt;/span&gt;&lt;span&gt; foo(n):　　
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(n)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; bar(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my name is %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;name)
&lt;/span&gt;&lt;span&gt;print(foo(bar(&quot;尼古拉斯赵四&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)))&lt;/span&gt;
运行结果：
my name &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;&lt;span&gt; 尼古拉斯赵四
None
None　　　　　　　　　　　　　　　　　　　　&lt;span&gt;返回两个None，因为在foo（）和bar（）函数中我没有定义retturn。默认返回None&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;将函数作为另一个函数的返回值&lt;br/&gt;def&lt;/span&gt;&lt;span&gt; bar():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;from bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; foo():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;from foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bar
&lt;span&gt;foo()()&lt;/span&gt;
运行结果：
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; foo
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; bar
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.内置函数&lt;/h2&gt;
&lt;p&gt;　　首先我先介绍3个比较重要，也是比较常用的内置函数，map；reduce，filter3个内置函数&lt;/p&gt;
&lt;h3&gt;　　1.map：&lt;/h3&gt;
&lt;p&gt;　  　将函数作用于seq中的每一个元素，并将所有的调用的结果作为一个list返回。&lt;/p&gt;
&lt;p&gt;　　  模拟一下这个需求：有一个列表[1,2,3,4],我要让列表中的每一个元素自增1，然后打印出来，这个程序可以这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
name=[1,2,3,4&lt;span&gt;]　　　　　　　　
res&lt;/span&gt;=&lt;span&gt;[]　　　　　　　　　　　　　　　　　　&lt;span&gt;定义一个空列表，用来接收自增一后的值
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; calc(array):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; array:　　　　　　　　　　 &lt;span&gt;使用for循环，遍历传入列表中的每一个元素&lt;/span&gt;
        &lt;span&gt;res.append(i&lt;/span&gt;&lt;/span&gt;&lt;span&gt;+1)　　　　　　　　
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(calc(name))
运行结果：
[&lt;/span&gt;2, 3, 4, 5]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那如果 我想要的需求是让列表自减1，自乘呢，难道要把这段代码重复写一段，只是改一句res.append（i-1），或者更高级一点，我们在定义一个函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def increase(x):
    return x-1　　　　　　　　　　　　　　　&lt;span&gt;定义一个自减1的函数&lt;/span&gt;&lt;/span&gt;&lt;span&gt;
name&lt;/span&gt;=[1,2,3,4&lt;span&gt;]
res&lt;/span&gt;=&lt;span&gt;[]
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; calc(func,array):　　　　　　　　　　 &lt;span&gt;在这里定义两个形参，一个用来传入函数increase，一个用来传入列表name
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; array:
       &lt;span&gt; res.append(increase(i))　　　　 
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;&lt;span&gt;(calc(increase,name))&lt;/span&gt;
运行结果：
[0, &lt;/span&gt;1, 2, 3]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　更高级一点呢？我们用map+上面提到的匿名函数，可以很好的完成这样的需求：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
name=[1,2,3,4]&lt;br/&gt;print(list(map(lambda x:x+1,name)))&lt;br/&gt;运行结果：&lt;br/&gt;[2,3,4,5]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ok,上面写了那么多，两行代码搞定。&lt;/p&gt;
&lt;h3&gt;　　2.reduce：&lt;/h3&gt;
&lt;p&gt;　　reduce()函数接收的参数和 map()类似，&lt;strong&gt;一个函数 f，一个list&lt;/strong&gt;，但行为和 map()不同，reduce()传入的函数 f 必须接收两个参数，reduce()对list的每个元素反复调用函数f，并返回最终结果值。可以简单的理解为，map接受一个列表，返回的仍然是一个列表，而reduce会进行计算，返回一个值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from functools import&lt;/span&gt;&lt;span&gt;&lt;span&gt; reduce &lt;/span&gt;                 &lt;span&gt;必须导入reduce方法&lt;/span&gt;
name&lt;/span&gt;=[1,2,3,4&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;((reduce(lambda x,y:x+&lt;/span&gt;&lt;span&gt;&lt;span&gt;y,name)))&lt;/span&gt;　　　　　&lt;span&gt;　函数必须传入两个参数，然后传入list。&lt;/span&gt;
运行结果：
&lt;/span&gt;10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　reduce还有一个默认参数 ，就是可以在list后再传入一个初始值。&lt;/p&gt;
&lt;pre&gt;
　def reduce(function, sequence, initial=None)    这个初始值默认为None
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from functools import&lt;/span&gt;&lt;span&gt;&lt;span&gt; reduce&lt;/span&gt;
name&lt;/span&gt;=[1,2,3,4&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;((reduce(lambda x,y:x+y,name,5&lt;/span&gt;&lt;span&gt;&lt;span&gt;)))　　　　&lt;span&gt; 还是上面的例子，我在最后加了初始值5（默认是none）&lt;/span&gt;&lt;/span&gt;
运行结果：
&lt;/span&gt;15
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3.filter&lt;/h3&gt;
&lt;p&gt;　　 filter读入iterable所有的项，判断这些项对function是否为真，返回一个包含所有为真的项的迭代器。如果function是None，返回非空的项。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
name=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;czp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zp1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print(list(filter(lambda n:n.endswith(&quot;c&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;),name)))　　　　&lt;span&gt;通过匿名函数判断条件，返回值为真，就会打印成列表的形式&lt;/span&gt;&lt;/span&gt;
运行结果：
[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　在下一篇文章中，我会介绍其他的常用内置函数&lt;/p&gt;
</description>
<pubDate>Thu, 07 Dec 2017 07:45:00 +0000</pubDate>
<dc:creator>无敌小怪兽</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Chen-Zhipeng/p/7991550.html</dc:identifier>
</item>
<item>
<title>Android OpenGL ES 开发（二）: OpenGL ES 环境搭建 - 灰色飘零</title>
<link>http://www.cnblogs.com/renhui/p/7997557.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renhui/p/7997557.html</guid>
<description>&lt;p&gt;为了在Android应用程序中使用OpenGL ES绘制图形，必须要为他们创建一个视图容器。其中最直接或者最常用的方式就是实现一个GLSurfaceView和一个GLSurfaceView.Renderer。GLSurfaceView是用OpenGL绘制图形的视图容器，GLSurfaceView.Renderer控制在该视图内绘制的内容。&lt;/p&gt;
&lt;p&gt;下面将讲解如何使用GLSurfaceView 和 GLSurfaceView.Renderer 在一个简单的应用程序的Activity上面做一个最小的实现。&lt;/p&gt;

&lt;p&gt;为了让你的应用程序能够使用OpenGL ES 2.0的API，你必须添加以下声明到manifest：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;uses-feature&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; android:glEsVersion=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0x00020000&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; android:required=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你的应用程序需要使用纹理压缩，你还需要声明你的应用程序需要支持哪种压缩格式，以便他们安装在兼容的设备上。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;supports-gl-texture&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; android:name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;GL_OES_compressed_ETC1_RGB8_texture&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;supports-gl-texture&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; android:name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;GL_OES_compressed_paletted_texture&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于更多的纹理压缩格式的知识，可以到 &lt;a href=&quot;https://developer.android.com/guide/topics/graphics/opengl.html#textures&quot; class=&quot;uri&quot;&gt;https://developer.android.com/guide/topics/graphics/opengl.html#textures&lt;/a&gt; 做进一步的了解。&lt;/p&gt;

&lt;p&gt;使用OpenGL ES的应用程序的Activity和其他应用程的Activity一样，不同的地方在于你设置的Activity的布局。在许多使用OpenGL ES的app中，你可以添加TextView，Button和ListView，还可以添加GLSurfaceView。&lt;/p&gt;
&lt;p&gt;下面的代码展示了使用GLSurfaceView做为主视图的基本实现：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; OpenGLES20Activity &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Activity {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; GLSurfaceView mGLView;

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;(Bundle savedInstanceState) {
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;onCreate&lt;/span&gt;(savedInstanceState);

        &lt;span class=&quot;co&quot;&gt;// Create a GLSurfaceView instance and set it&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// as the ContentView for this Activity.&lt;/span&gt;
        mGLView = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyGLSurfaceView&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;);
        &lt;span class=&quot;fu&quot;&gt;setContentView&lt;/span&gt;(mGLView);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：OpenGL ES 2.0 需要的Android版本是2.2及以上，请确保你的Android项目针对的版本是否符合。&lt;/p&gt;

&lt;p&gt;GLSurfaceView是一个特殊的View，通过这个View你可以绘制OpenGL图像。但是View本身没有做太多的事情，主要的绘制是通过设置在View里面的GLSurfaceView.Renderer 来控制的。实际上，创建这个对象的代码是很少的，你能会想尝试跳过extends的操作，只去创建一个没有被修改的GLSurfaceView实例，但是不建议这样去做。因为在某些情况下，你需要扩展这个类来捕获触摸的事件，捕获触摸的事件的方式会在后面的文章里面做介绍。&lt;br/&gt;GLSurfaceView的基本代码很少，为了快速的实现，通常会在使用它的Activity中创建一个内部类来做实现：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyGLSurfaceView &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; GLSurfaceView {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; MyGLRenderer mRenderer;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyGLSurfaceView&lt;/span&gt;(Context context){
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(context);

        &lt;span class=&quot;co&quot;&gt;// Create an OpenGL ES 2.0 context&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;setEGLContextClientVersion&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;);

        mRenderer = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;MyGLRenderer&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;// Set the Renderer for drawing on the GLSurfaceView&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;setRenderer&lt;/span&gt;(mRenderer);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你可以通过设置GLSurfaceView.RENDERMODE_WHEN_DIRTY来让你的GLSurfaceView监听到数据变化的时候再去刷新，即修改GLSurfaceView的渲染模式。这个设置可以防止重绘GLSurfaceView，直到你调用了requestRender()，这个设置在默写层面上来说，对你的APP是更有好处的。&lt;/p&gt;

&lt;p&gt;实现了GLSurfaceView.Renderer 类才是真正算是开始能够在应用中使用OpenGL ES。这个类控制着与它关联的GLSurfaceView 绘制的内容。在renderer 里面有三个方法能够被Android系统调用，以便知道在GLSurfaceView绘制什么以及如何绘制&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;onSurfaceCreated() - 在View的OpenGL环境被创建的时候调用。&lt;/li&gt;
&lt;li&gt;onDrawFrame() - 每一次View的重绘都会调用&lt;/li&gt;
&lt;li&gt;onSurfaceChanged() - 如果视图的几何形状发生变化（例如，当设备的屏幕方向改变时），则调用此方法。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;下面是使用OpenGL ES 渲染器的基本实现，仅仅做的事情就是在GLSurfaceView绘制一个黑色背景。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyGLRenderer &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; GLSurfaceView.&lt;span class=&quot;fu&quot;&gt;Renderer&lt;/span&gt; {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onSurfaceCreated&lt;/span&gt;(GL10 unused, EGLConfig config) {
        &lt;span class=&quot;co&quot;&gt;// Set the background frame color&lt;/span&gt;
        GLES20.&lt;span class=&quot;fu&quot;&gt;glClearColor&lt;/span&gt;(&lt;span class=&quot;fl&quot;&gt;0.&lt;/span&gt;0f, &lt;span class=&quot;fl&quot;&gt;0.&lt;/span&gt;0f, &lt;span class=&quot;fl&quot;&gt;0.&lt;/span&gt;0f, &lt;span class=&quot;fl&quot;&gt;1.&lt;/span&gt;0f);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onDrawFrame&lt;/span&gt;(GL10 unused) {
        &lt;span class=&quot;co&quot;&gt;// Redraw background color&lt;/span&gt;
        GLES20.&lt;span class=&quot;fu&quot;&gt;glClear&lt;/span&gt;(GLES20.&lt;span class=&quot;fu&quot;&gt;GL_COLOR_BUFFER_BIT&lt;/span&gt;);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;onSurfaceChanged&lt;/span&gt;(GL10 unused, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; width, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; height) {
        GLES20.&lt;span class=&quot;fu&quot;&gt;glViewport&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, width, height);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上述的内容就是基本的OpenGL ES基本的环境配置，本文的代码仅仅是创建一个简单的Android应用然后使用OpenGL展示一个黑板。虽然没有做其他更加有趣的事情，但是，通过创建这些类，你应该已经拥有了使用OpenGL绘制图形元素的基础了。&lt;/p&gt;
&lt;p&gt;注：你可能很好奇为什么在使用OpenGL ES 2.0的API的时候会看到GL10的参数，因为这些方法签名被简单地用于2.0 API这样可以保持Android框架代码的简单。&lt;/p&gt;
&lt;p&gt;如果你熟悉OpenGL的API，现在你应该可以在你的APP里面创建一个OpenGL ES的环境，并开始进行画图了。但是如果需要更多的帮助来使用OpenGL，就请期待下面的文章吧。&lt;/p&gt;
</description>
<pubDate>Thu, 07 Dec 2017 07:03:00 +0000</pubDate>
<dc:creator>灰色飘零</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renhui/p/7997557.html</dc:identifier>
</item>
<item>
<title>【微服务】之三：从零开始，轻松搞定SpringCloud微服务-配置中心 - 千万之路刚开始</title>
<link>http://www.cnblogs.com/hyhnet/p/7998767.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hyhnet/p/7998767.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在整个微服务体系中，除了注册中心具有非常重要的意义之外，还有一个注册中心。注册中心作为管理在整个项目群的配置文件及动态参数的重要载体服务。Spring Cloud体系的子项目中，Spring Cloud Config子项目就是该注册中心。在整个分布式框架系统中，充当重要角色。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;官方解释&quot;&gt;官方解释&lt;/h2&gt;
&lt;p&gt;Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems (e.g. configuration management, service discovery, circuit breakers, intelligent routing, micro-proxy, control bus, one-time tokens, global locks, leadership election, distributed sessions, cluster state). Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns. They will work well in any distributed environment, including the developer's own laptop, bare metal data centres, and managed platforms such as Cloud Foundry.&lt;/p&gt;
&lt;h2 id=&quot;本系列博文目录&quot;&gt;本系列博文目录&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/hyhnet/p/7998751.html&quot;&gt;【微服务】从零开始，轻松搞定SpringCloud微服务目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说明：本系列源码持续更新，开始本篇之前先了解前面几篇文章。&lt;/p&gt;
&lt;h2 id=&quot;开始起飞&quot;&gt;开始起飞&lt;/h2&gt;
&lt;p&gt;基本思路：本文采用Git仓库作为配置文件的存放地址，通过创建一个配置中心服务器启动服务，然后再通过创建一个配置中心的客户端进行测试是否正常运转。&lt;/p&gt;
&lt;h3 id=&quot;创建配置中心仓库&quot;&gt;创建配置中心仓库&lt;/h3&gt;
&lt;p&gt;在原有的父类项目下创建一个普通的子项目，可以删除无关的文件，只留下空白项目。然后再创建一个测试的配置文件。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3565867-25f32db74b9be57b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置文件中加入测试数据&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode yml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;co&quot;&gt;#随意设置的一个参数&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;myblog:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;name:&lt;/span&gt; 千万之路刚开始-author-hyh
  &lt;span class=&quot;fu&quot;&gt;url:&lt;/span&gt; http://www.hanyahong.com
  &lt;span class=&quot;fu&quot;&gt;location:&lt;/span&gt; BeiJing&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;创建配置中心服务端&quot;&gt;创建配置中心服务端&lt;/h3&gt;
&lt;h4 id=&quot;创建子项目&quot;&gt;创建子项目&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3565867-d0cef6178d0af2f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;pom文件配置&quot;&gt;POM文件配置&lt;/h4&gt;
&lt;p&gt;在pom.xml文件中做一下配置&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-config-server&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;

   &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;kw&quot;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;test&lt;span class=&quot;kw&quot;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;

   &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-starter-eureka&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;kw&quot;&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
           &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
           &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;kw&quot;&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;配置项目resource配置文件&quot;&gt;配置项目resource配置文件&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：整个博客是对各个子项目整合，因此加入了服务注册中心的相关配置&lt;/p&gt;
&lt;p&gt;在resources文件夹下创建application.yml文件。并加入以下配置：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;#服务端口
server:
  port: 8082

#服务注册中心配置
eureka:
  client:
    serviceUrl:
      defaultZone: http://localhost:8081/eureka/

#spring设置
spring:
  application:
    name: config-server
  cloud:
    config:
      server:
        git:
          uri: https://github.com/hanyahong/spring-cloud-microservice.git
          searchPaths: cloud-hyh-config-repo
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;创建主方法类&quot;&gt;创建主方法类&lt;/h4&gt;
&lt;p&gt;在创建完包以后，创建主方法。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&lt;span class=&quot;fu&quot;&gt;@EnableDiscoveryClient&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@EnableConfigServer&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ConfigApplication {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        SpringApplication.&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;(ConfigApplication.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此，服务端配置完毕，启动服务器即可，等待客户端验证。&lt;/p&gt;
&lt;h3 id=&quot;创建客户端&quot;&gt;创建客户端&lt;/h3&gt;
&lt;p&gt;创建一个配置客户端，对刚刚的服务进行测试。&lt;br/&gt;@EnableDiscoveryClient: 服务发现客户端注解，用于被发现。&lt;br/&gt;@EnableConfigServer: 开启配置中心服务器配置。&lt;/p&gt;
&lt;h4 id=&quot;创建客户端子项目&quot;&gt;创建客户端子项目&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3565867-f62fbe22fbdcdd4d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;配置pom文件&quot;&gt;配置pom文件&lt;/h4&gt;
&lt;p&gt;在子项目pom.xml中加入一下依赖及插件。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt; &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-actuator&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-cloud-starter-config&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;scope&amp;gt;&lt;/span&gt;test&lt;span class=&quot;kw&quot;&gt;&amp;lt;/scope&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;创建配置文件&quot;&gt;创建配置文件&lt;/h4&gt;
&lt;p&gt;在子项目中resources文件夹下，创建bootstrap.yml文件。加入一下配置。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode yml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;fu&quot;&gt;spring:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;application:&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;#本项目名称&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;name:&lt;/span&gt; config-client
  &lt;span class=&quot;fu&quot;&gt;cloud:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;config:&lt;/span&gt;
      &lt;span class=&quot;co&quot;&gt;#配置中心服务器地址配置&lt;/span&gt;
      &lt;span class=&quot;fu&quot;&gt;uri:&lt;/span&gt; http://localhost:8082/
      &lt;span class=&quot;fu&quot;&gt;profile:&lt;/span&gt; default
      &lt;span class=&quot;fu&quot;&gt;label:&lt;/span&gt; master
      &lt;span class=&quot;fu&quot;&gt;retry:&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;# 配置重试次数，默认为6&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;max-attempts:&lt;/span&gt; 6
        &lt;span class=&quot;co&quot;&gt;# 间隔乘数 默认1.1&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;multiplier:&lt;/span&gt; 1.1
        &lt;span class=&quot;co&quot;&gt;# 初始重试间隔时间，默认1000ms&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;initial-interval:&lt;/span&gt; 1000
        &lt;span class=&quot;co&quot;&gt;# 最大间隔时间，默认2000ms&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;max-interval:&lt;/span&gt; 2000

&lt;span class=&quot;fu&quot;&gt;server:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;port:&lt;/span&gt; 8091
&lt;span class=&quot;co&quot;&gt;#服务发现配置&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;eureka:&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;client:&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;service-url:&lt;/span&gt;
      &lt;span class=&quot;fu&quot;&gt;defaultZone:&lt;/span&gt; http://localhost:8081/eureka/&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;创建程序入口&quot;&gt;创建程序入口&lt;/h4&gt;
&lt;p&gt;创建默认包以后创建ConfgClientApplication.java 文件。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/** &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Description :配置中心启动类&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Author hanyahong&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Date 2017/12/6- 14:06&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;


&lt;span class=&quot;fu&quot;&gt;@SpringBootApplication&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ConfigClientApplication {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        SpringApplication.&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;(ConfigClientApplication.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;创建测试api&quot;&gt;创建测试API&lt;/h4&gt;
&lt;p&gt;创建一个测试API文件，TestApi.java。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Description :配置中心-客户端展示API&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Author hanyahong&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * @Date 2017/12/6- 16:39&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@RefreshScope&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;@RestController&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestApi {

    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${myblog.name}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String name;
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${myblog.url}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String url;
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${myblog.location}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String location;
    &lt;span class=&quot;fu&quot;&gt;@RequestMapping&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;/blog-info&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;getBlogInfo&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;从Github仓库中获取得到我博客信息：【&quot;&lt;/span&gt;+location+&lt;span class=&quot;st&quot;&gt;&quot;,&quot;&lt;/span&gt;+&lt;span class=&quot;st&quot;&gt;&quot;,&quot;&lt;/span&gt;+url+&lt;span class=&quot;st&quot;&gt;&quot;,&quot;&lt;/span&gt;+name+&lt;span class=&quot;st&quot;&gt;&quot;】&quot;&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;@RefreshScope:开启刷新&lt;/p&gt;
&lt;p&gt;至此，配置中心测试的客户端基本完毕。&lt;br/&gt;对于子项目来说有三个子项目：&lt;br/&gt;&lt;strong&gt;cloud-hyh-config&lt;/strong&gt; 端口号：8082&lt;br/&gt;&lt;strong&gt;cloud-hyh-config-client&lt;/strong&gt; 端口号：8091&lt;br/&gt;&lt;strong&gt;cloud-hyh-config-repo&lt;/strong&gt; 纯存储使用，该文档下面的配置文件一定要上传到仓库后，才可以远程获取。&lt;/p&gt;
&lt;h3 id=&quot;启动项目并测试&quot;&gt;启动项目并测试&lt;/h3&gt;
&lt;p&gt;对服务注册中心（上篇有写）、服务配置中心、服务客户端分别进行启动。&lt;br/&gt;可以通过注册中心查看是否都已经被纳入管理。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3565867-8fcbb0c27fd5e3bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试一：&lt;/strong&gt; 注册中心测试&lt;br/&gt;首先通过访问配置中心服务器的地址可以进行测试是否获取成功。&lt;br/&gt;访问 &lt;a href=&quot;http://localhost:8082/config-client.yml&quot; class=&quot;uri&quot;&gt;http://localhost:8082/config-client.yml&lt;/a&gt; 对仓库中资源文件 测试是否返回结果。&lt;br/&gt;另外也可以通过 &lt;a href=&quot;http://localhost:8082/config-client/master&quot; class=&quot;uri&quot;&gt;http://localhost:8082/config-client/master&lt;/a&gt; 进行访问。浏览器显示返回结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;name&quot;:&quot;config-client&quot;,&quot;profiles&quot;:[&quot;master&quot;],&quot;label&quot;:null,&quot;version&quot;:&quot;7169e90f628c85d582f3f9d5fceda36696ebd751&quot;,&quot;state&quot;:null,&quot;propertySources&quot;:[{&quot;name&quot;:&quot;https://github.com/hanyahong/spring-cloud-microservice.git/cloud-hyh-config-repo/config-client.yml&quot;,&quot;source&quot;:{&quot;myblog.name&quot;:&quot;千万之路刚开始-author-hyh&quot;,&quot;myblog.url&quot;:&quot;http://www.hanyahong.com&quot;,&quot;myblog.location&quot;:&quot;BeiJing&quot;,&quot;config-client.name&quot;:&quot;test&quot;}}]}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试二：&lt;/strong&gt; 客户端访问API测试&lt;br/&gt;通过客户端访问API &lt;a href=&quot;http://localhost:8091/blog-info&quot; class=&quot;uri&quot;&gt;http://localhost:8091/blog-info&lt;/a&gt; 显示结果：&lt;br/&gt;&lt;code&gt;从Github仓库中获取得到我博客信息：【BeiJing-Customs,,http://www.hanyahong.com,千万之路刚开始-author-hyh】&lt;/code&gt;&lt;br/&gt;测试成功！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试三：&lt;/strong&gt; 动态更新参数测试&lt;br/&gt;配置中心一个重要的功能就是你无须重启去生效一些参数配置，系统可以通过访问/refresh 进行动态刷新，将参数生效。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;修改配置文件信息，上传git仓库。&lt;/li&gt;
&lt;li&gt;使用PostMan 或其他工具进行一次POST请求 API:&lt;code&gt;http://localhost:8091/refresh&lt;/code&gt; （一定要看清楚，POST请求，浏览器直接访问无效，会报Request method 'GET' not supported 错误）。&lt;/li&gt;
&lt;li&gt;再一次访问 &lt;a href=&quot;http://localhost:8091/blog-info&quot; class=&quot;uri&quot;&gt;http://localhost:8091/blog-info&lt;/a&gt; ，可以看到已在未重启的情况下，配置动态更新。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;后续说明&quot;&gt;后续说明&lt;/h3&gt;
&lt;p&gt;因配置中心涉及很多数据的更新，不可能每次通过这种方式去动态更新，后续会有专门消息总线模块的讲解，将通过消息总线的机制去进行配置的传输。&lt;/p&gt;
&lt;h2 id=&quot;源码地址&quot;&gt;源码地址&lt;/h2&gt;
&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/hanyahong/spring-cloud-microservice&quot; class=&quot;uri&quot;&gt;https://github.com/hanyahong/spring-cloud-microservice&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 Dec 2017 05:58:00 +0000</pubDate>
<dc:creator>千万之路刚开始</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hyhnet/p/7998767.html</dc:identifier>
</item>
<item>
<title>（新）elasticsearch6.0版本安装head插件 - 炭烧小鸡</title>
<link>http://www.cnblogs.com/tanshaoxiaoji/p/elasticsearch_head_install.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanshaoxiaoji/p/elasticsearch_head_install.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1 前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　不知道是我电脑问题还是最近的开源软件都比较**，mysql和elasticsearch新版本变动都比较大。 elasticsearch6.0貌似已经不支持命令行安装head插件了，反正我是折腾了一下午才得出这个结论的。因此，如果你还想安装head，只能选择手动下载安装。（别再纠结于命令行安装了）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.2 下载head插件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;下载地址：&lt;a title=&quot;head插件下载&quot; href=&quot;https://github.com/mobz/elasticsearch-head&quot; target=&quot;_blank&quot;&gt;https://github.com/mobz/elasticsearch-head&lt;/a&gt;；点击clone or download按钮，点击download zip进行下载。下载完毕后解压到任意路径上，别放在elasticsearch安装路径上。&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1258453/201712/1258453-20171206214640769-1938167370.png&quot; alt=&quot;&quot; width=&quot;649&quot; height=&quot;349&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt; 1.3 安装node.js&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这个比较容易，下载后除路径自己填写外，其他直接next就OK了。下载地址：&lt;a title=&quot;nodejs下载&quot; href=&quot;https://nodejs.org/en/download/%20&quot; target=&quot;_blank&quot;&gt;https://nodejs.org/en/download/ &lt;/a&gt;。&lt;img src=&quot;http://images2017.cnblogs.com/blog/1258453/201712/1258453-20171206215728441-165289763.png&quot; alt=&quot;&quot; width=&quot;762&quot; height=&quot;312&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.4 安装grunt&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　运行head需要借助grunt命令，因此需要安装grunt，Windows+R，输入cmd，输入命令 &lt;span&gt;cd D:\nodejs&lt;span&gt;（你安装nodejs的路径）&lt;/span&gt;&lt;/span&gt; 进入nodejs的根目录下，（注意：如果这条命令不能成功执行，那就先执行 &lt;span&gt;D:&lt;/span&gt;，成功切换目录后再执行 &lt;span&gt;cd  D:\nodejs&lt;span&gt;（你安装nodejs的路径）。&lt;/span&gt;&lt;/span&gt;），然后执行指令 &lt;span&gt;npm install -g grunt  -cli&lt;/span&gt; 进行安装grunt。&lt;img src=&quot;http://images2017.cnblogs.com/blog/1258453/201712/1258453-20171207120719347-266872318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 1.5 安装pathomjs&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　输入命令&lt;span&gt; cd D:\head&lt;/span&gt;（你安装head的路径） 进入head的根目录下，然后执行命令：&lt;span&gt;npm install&lt;/span&gt; 进行安装&lt;strong&gt;pathomjs（安装时间较长，可以吃几把鸡先，你应该吃不到...）&lt;/strong&gt;。如果出现&lt;span&gt;Error&lt;/span&gt;关键字，则有可能是网络不顺畅，下载失败，那就继续下一段文字。如果成功（我用公司网络试了三次都不行，祝你好运！），则跳过下一段文字。&lt;img src=&quot;http://images2017.cnblogs.com/blog/1258453/201712/1258453-20171207125705222-2031939839.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;安装失败的过来围观一下&lt;/span&gt;，看上面的图片，安装失败时他会显示&lt;span&gt;下载路径&lt;/span&gt;和&lt;span&gt;存放路径&lt;/span&gt;。请你耐心点，你需要做的是，将相关信息复制下来，手动下载压缩包并放置在存放路径下，命令窗口再次执行安装命令  &lt;span&gt;npm install &lt;span&gt;，他们会去存放路径下检索文件并解压安装，只要提示文字没出现Error，则安装成功&lt;/span&gt;&lt;/span&gt;。（如果复制不到，可以这样试试，鼠标右键点击全选，然后在目标文本附近点击一下，然后拖动鼠标选上文本，按Ctrl+C,不要怀疑自己，试试在txt文本按Ctrl+V试试，是不是复制下来了？哈哈）&lt;img src=&quot;http://images2017.cnblogs.com/blog/1258453/201712/1258453-20171207132123363-1059549034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.6 运行head&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　最后，什么都别关，还没结束呢，在刚刚的命令窗口执行运行命令&lt;span&gt; grunt server&lt;/span&gt;，启动head服务，如下所示则为启动成功。（可以到head根目录下修改Gruntfile.js文件的启动端口，默认是9100）&lt;img src=&quot;http://images2017.cnblogs.com/blog/1258453/201712/1258453-20171207134010159-1899224888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　然后去修改elasticsearch的配置文件，&lt;span&gt;elasticsearch安装目录/config/elasticsearch.yml&lt;span&gt;，打开文件后在末端另起一行分别顶格添加如下两行红色字体文本，保存后重启elasticsearch.bat。图片是我的elasticsearch配置，提供给你参考下。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 http.cors.enabled: true
2 http.cors.allow-origin: &quot;*&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1258453/201712/1258453-20171207133303034-470358275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.7 用head访问elasticsearch&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　浏览器访问 &lt;span&gt;http://localhost:9100 &lt;span&gt;（head的服务端口），访问成功后，好好享受吧！！！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1258453/201712/1258453-20171207134620738-1494852938.png&quot; alt=&quot;&quot; width=&quot;908&quot; height=&quot;296&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.8 小互动，如果各位看得起我，有空给点建议。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;我总感觉写得太详细了，不知道会不会让读者看到这么多的文字扭头就走，大家能给点建议吗？比如说哪个地方不需要这么详细，哪里需要再继续详细描述。谢谢了！！&lt;/p&gt;

</description>
<pubDate>Thu, 07 Dec 2017 05:52:00 +0000</pubDate>
<dc:creator>炭烧小鸡</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanshaoxiaoji/p/elasticsearch_head_install.html</dc:identifier>
</item>
<item>
<title>js断点调试心得 - ranyonsue</title>
<link>http://www.cnblogs.com/ranyonsue/p/7998692.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ranyonsue/p/7998692.html</guid>
<description>&lt;div id=&quot;wmd-preview-section-199&quot; readability=&quot;35&quot;&gt;
&lt;h4 id=&quot;1断点调试是啥难不难&quot;&gt;1.断点调试是啥？难不难？&lt;/h4&gt;
&lt;p&gt;断点调试其实并不是多么复杂的一件事，简单的理解无外呼就是打开浏览器，打开sources找到js文件，在行号上点一下罢了。操作起来似乎很简单，其实很多人纠结的是，是在哪里打断点？（我们先看一个断点截图，以chrome浏览器的断点为例）&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;token md md-bang&quot;&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/730991/201604/730991-20160415232259520-1601780290.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;&lt;p&gt;
&lt;h5 id=&quot;用chrome浏览器打开页面-按f12打开开发者工具-打开sources-打开你要调试的js代码文件-在行号上单击一下ok恭喜你的处女断点打上了哈哈&quot;&gt;&lt;span&gt;用chrome浏览器打开页面 → 按f12打开开发者工具 → 打开Sources → 打开你要调试的js代码文件 → 在行号上单击一下，OK!恭喜你的处女断点打上了,哈哈~~&lt;/span&gt;&lt;/h5&gt;
&lt;/p&gt;&lt;div id=&quot;wmd-preview-section-928&quot; readability=&quot;33&quot;&gt;
&lt;h4 id=&quot;2断点怎么打才合适&quot;&gt;2.断点怎么打才合适？&lt;/h4&gt;
&lt;p&gt;打断点操作很简单，核心的问题在于，断点怎么打才能够排查出代码的问题所在呢？下面我继续举个例子方便大家理解，废话不多说，上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/730991/201604/730991-20160415232328066-1801247177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div id=&quot;wmd-preview-section-1881&quot; readability=&quot;38&quot;&gt;
&lt;p&gt;假设我们现在正在实现一个加载更多的功能，如上图，但是现在加载更多功能出现了问题，点击以后数据没有加载出来，这时候我们第一时间想到的应该是啥？（换一行写答案，大家可以看看自己的第一反应是啥）&lt;/p&gt;

&lt;p&gt;我最先想到的是，我点击到底有没有成功？点击事件里的方法有没有运行？好，要想知道这个问题的答案，我们立马去打个断点试试看，断点打在哪？自己先琢磨一下。&lt;/p&gt;
&lt;p&gt;接着上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/730991/201604/730991-20160415232405676-1315237491.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div id=&quot;wmd-preview-section-2260&quot; readability=&quot;35&quot;&gt;
&lt;p&gt;各位想到没？没错，既然想知道点击是否成功，我们当然是在代码中的点击事件处添加一个断点，切记不要添加在226行哦，因为被执行的是click方法内的函数，而不是226行的选择器。断点现在已经打上了，然后做什么呢？自己再琢磨琢磨~&lt;/p&gt;
&lt;p&gt;继续上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/730991/201604/730991-20160415232434895-1042536792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div id=&quot;wmd-preview-section-7398&quot; readability=&quot;73&quot;&gt;
&lt;p&gt;然后我们当然是回去点击加载更多按钮啦，为什么？额。。。如果你这么问，请允许我用这个表情&lt;img title=&quot;&quot; alt=&quot;Alt text&quot; longdesc=&quot;https://maxiang.io/1460730553140.png&quot;/&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/730991/201604/730991-20160415232619988-1011716611.png&quot; alt=&quot;&quot;/&gt;，不点击加载更多按钮，怎么去触发点击事件？不触发点击事件，怎么去执行点击事件里的函数？咆哮状。。不过我相信大家肯定不会问这么low的问题~不瞎扯了~&lt;/p&gt;
&lt;p&gt;继续正题，上面的图就是点击加载更多按钮后的情况，我们可以看到左侧的页面被一个半透明的层给盖住了，页面上方还有一串英文和两个按钮，右侧代码227行被添加上了背景色，出现这个情况，先不管那些按钮英文是啥意思有啥作用，你从这个图得到了什么信息？继续琢磨琢磨~&lt;/p&gt;
&lt;p&gt;如果出现了上图这个情况，说明一点，click事件中的函数被调用了，进一步说明了点击事件生效。那么我们对于这个问题产生的第一个“犯罪嫌疑人”就被排除了。&lt;/p&gt;
&lt;div id=&quot;wmd-preview-section-3312&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;44&quot;&gt;
&lt;h5 id=&quot;补充一下&quot;&gt;&lt;span&gt;补充一下：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;如果没有出现上面的情况咋办？那是不是说明点击事件没有生效呢？那是什么导致点击事件没有生效？大家自己思考思考~&lt;/p&gt;
&lt;p&gt;可能导致点击事件没生效的原因很多，比多选择器错误，语法错误，被选择的元素是后生成的等。怎么解决呢？&lt;/p&gt;
&lt;p&gt;选择器错误，大家可以继续往后看到console部分的内容，我想大家就知道怎么处理了&lt;/p&gt;
&lt;p&gt;语法错误，细心排查一下，不熟悉的语法可以百度对比一下&lt;/p&gt;
&lt;p&gt;被选择的元素是后生成的，最简单的处理就是使用.on()方法去处理，这个东东带有事件委托处理，详情可以自行百度。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h5 id=&quot;那么接下来犯罪嫌疑人的身份锁定在哪里呢&quot;&gt;&lt;span&gt;那么接下来”犯罪嫌疑人“的身份锁定在哪里呢？&lt;/span&gt;&lt;/h5&gt;
&lt;/p&gt;
&lt;p&gt;我们将目光投向事件内部，click事件触发了，那么接下来的问题就是它内部的函数问题了。如果你要问为什么？请给我一块豆腐。。。&lt;/p&gt;
&lt;p&gt;打个比方，给你一支笔，让你写字，然后你在纸上写了一个字，发现字没出来，为啥？你说我写了呀，纸上都还有划痕。那是不是可能笔没有墨水或者笔尖坏了了？这个例子和点击加载更多一个道理，写字这个动作就是点击操作，而内部函数就是墨水或者笔尖。明白了不~&lt;/p&gt;
&lt;p&gt;接着我们分析下点击事件里面的内容，里面包含三句话，第一句话是变量i自增长，第二句话是给按钮添加一个i标签，第三句话是调用请求数据的方法。&lt;/p&gt;
&lt;p&gt;就通过这三句话的本身作用，我们可以将较大一部分嫌疑放在第三句话，一小部分放在第一句和第二句话上，有人可能会疑惑，第二句话怎么会有嫌疑呢？他的作用只不过是添加一个标签，对于数据完全没有影响啊，确实，这句话对于数据没有影响，但是出于严谨考虑，它仍然有可能出错，例如它要是少了一个分号呢？或者句子内部某个符号错误呢？往往就是这种小问题浪费我们很多时间。&lt;/p&gt;
&lt;p&gt;好，为了进一步锁定”犯罪嫌疑人“，给大家介绍一个工具，也是上图出现两个图标之一，见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/730991/201604/730991-20160415232526941-1426556642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div id=&quot;wmd-preview-section-8807&quot; readability=&quot;34&quot;&gt;
&lt;p&gt;这个小图标的功能叫”逐语句执行“或者叫”逐步执行“，这是我个人理解的一个叫法，意思就是，每点击它一次，js语句就会往后执行一句，它还有一个快捷键，F10。下图示范一下它被点击以后的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/730991/201604/730991-20160415232547457-873887747.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;&lt;div id=&quot;wmd-preview-section-8988&quot; readability=&quot;73.5&quot;&gt;
&lt;p&gt;我单击了两次这个按钮（或者使用F10快捷键），js代码从227行执行到了229行，所以我管它叫”逐语句执行“或者”逐步执行“。这个功能非常的实用，大部分的调试都会使用到它。&lt;/p&gt;
&lt;div id=&quot;wmd-preview-section-2399&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;41&quot;&gt;

&lt;p&gt;上面介绍到我单击了两次“逐语句执行”按钮，代码从227行运行到229行，大家觉得这意味着啥？是不是说明从语法上来说，前两句是没有问题的，那么是不是也同时意味着前两句就排除嫌疑了呢？我看不然。&lt;/p&gt;
&lt;p&gt;大家都知道，加载更多就是一个下一页的功能，而其中最核心的一个就是传给后台的页码数值，每当我点击加载更多按钮一次，页码的数值就要加1，所以如果下一页的数据没出来，是不是有可能是因为页码数值也就是[i变量]（下面统一称呼i）有问题？那么如何排查页码是否存在问题呢？大家自己先思考思考。&lt;/p&gt;
&lt;p&gt;下面教大家两种查看页码数值i]实际输出值的方法，上图：&lt;/p&gt;
&lt;p&gt;第一种：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/730991/201604/730991-20160417223635270-433597399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-3855&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;35&quot;&gt;
&lt;p&gt;操作步骤如下：&lt;/p&gt;
&lt;p&gt;1.仍然是在227行打上断点 → 2. 点击加载更多按钮 → 3. 单击一次“逐语句执行“按钮，js代码执行到228行 → 4.用鼠标选中i++（什么叫选中大家里不理解？就是你要复制一个东西，是不是要选中它？对，就是这个选中） → 5. 选中以后，鼠标悬浮在目标上方，你就看到上图的结果。&lt;/p&gt;
&lt;p&gt;第二种：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/730991/201604/730991-20160417223652660-976991610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-5816&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;41&quot;&gt;
&lt;p&gt;这个方法其实和第一种差不多，只不过是在控制台输出i的值，大家只需要按照第一种方法执行到第三步 → 4. 打开和sources同一级栏目的console → 5. 在console下方的输入栏里输入i → 6. 按enter回车键即可。&lt;/p&gt;
&lt;p&gt;上面的第二种方法里，提到了console这个东西，我们可以称呼它为控制台或者其他什么都可以，这不重要~console的功能很强大，在调试的过程中，我们往往需要知道某些变量的值到底输出了什么，或者我们使用选择器[$”.div”)这种]是否选中了我们想要的元素等，都可以在控制台打印出来。当然直接用第一种方法也可以。&lt;/p&gt;
&lt;p&gt;给大家示范一下在console里打印我们想要选中的元素。上图~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/730991/201604/730991-20160417223712551-222773212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-11243&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;38&quot;&gt;
&lt;p&gt;&lt;img title=&quot;&quot; alt=&quot;Alt text&quot; longdesc=&quot;https://maxiang.io/1460898895933.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在控制台中输入$(this)，即可得到选择的元素，没错，正是我们所点击的对象——加载更多按钮元素。&lt;/p&gt;
&lt;p&gt;在这里给大家说说我对console这个控制台的理解：这个东东就是一个js解析器，是浏览器本身用来解析运行js的家伙，只不过浏览器通过console让我们开发者在调试过程中，可以控制js的运行以及输出。通过上面的两种方法，大家可能觉得使用起来很简单，但是我要给大家提醒一下，或者说是一些新手比较容易遇到的困惑。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-11260&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;35&quot;&gt;
&lt;h6 id=&quot;困惑一在没有打断点的情况下在console输入i结果console报错了&quot;&gt;&lt;span&gt;困惑一：在没有打断点的情况下，在console输入i，结果console报错了。&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;这应该是新手很常见的问题，为什么不打断点我就没有办法在控制台直接输出变量的值呢？个人理解这时候i只是一个局部变量，如果不打上断点，浏览器会把所有的js全部解析完成，console并不能访问到局部变量，只能访问到全局变量，所以这时候console会报错i未定义，但是当js打上断点时，console解析到了局部变量i所在的函数内，这时候i是能够被访问的。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-11618&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;36&quot;&gt;
&lt;h6 id=&quot;困惑二为什么我直接在console里输入xxx能打印出东西来呢&quot;&gt;&lt;span&gt;困惑二：为什么我直接在console里输入$(“.xxx”)能打印出东西来呢？&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;很简单，console本身就是一个js解析器，$(“.xxx”)就是一个js语句，所以自然console能够解析这个语句然后输出结果。&lt;/p&gt;
&lt;p&gt;介绍完“逐语句执行”按钮和console控制台的用法，最后再介绍一个按钮，上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/730991/201604/730991-20160417223735738-1888276495.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-13313&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;34&quot;&gt;
&lt;p&gt;这个按钮我称呼它为“逐过程执行”按钮，和“逐语句执行”按钮不同，“逐过程执行”按钮常用在一个方法调用多个js文件时，涉及到的js代码比较长，则会使用到这个按钮。&lt;/p&gt;
&lt;p&gt;上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/730991/201604/730991-20160417223748988-186612698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-13333&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;33&quot;&gt;
&lt;p&gt;假设上图我只在227行打了个断点，然后一直点击逐语句执行”按钮到229行，这时候如果再点击一次“逐语句执行”按钮呢？则会进入下图的js里：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/730991/201604/730991-20160417223809832-1297987077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-14189&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;34&quot;&gt;
&lt;p&gt;这些都是zepto库文件的内容，没啥好看的，里面运行很复杂，我们不可能一直使用“逐语句执行”按钮，这样你会发现你按了大半天还在库文件里面绕。。。这时候咋办？那就该“逐过程执行”按钮上场了。&lt;/p&gt;
&lt;p&gt;上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/730991/201604/730991-20160417223825207-1005801174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-15300&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;34&quot;&gt;
&lt;p&gt;我除了在227行打了一个断点，同时还在237行打了一个断点，当我们运行到229行时，直接单击“逐过程执行”按钮，你会发现，js直接跳过了库文件，运行到了237行，大家可以自己使用体验一下。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-22337&quot; class=&quot;wmd-preview-section preview-content&quot; readability=&quot;40&quot;&gt;
&lt;h4 id=&quot;最后总结&quot;&gt;最后总结：&lt;/h4&gt;
&lt;p&gt;本文主要介绍了“逐语句执行”按钮、“逐过程执行”按钮、console控制台这三个工具，以及调试bug时的一些思路。工具的用法我就不再赘述了，大家知道用法就行，具体怎么去更合理的使用，还需要大家通过大量的实践去总结提升~&lt;/p&gt;
&lt;p&gt;我其实在本文主要想讲的是调试bug的一个思路，但是由于选的例子涉及东西太多。。。怕全部写下来内容太长，大家也没兴趣看，所以我就简单的选了一部分给大家讲解，不知道大家有没有收获。别看我调试三句话写了一堆的东西，如果真的在实际项目中你也像我这样去做，估计你调试一个Bug的时间会比写一个脚本的时间还长很多。。。在实际情况下，我们应该养成拿到问题的第一时间，自行在脑海中排查问题，找到最有可能出现问题的点，如果没办法迅速的排查出最重要的点，那么你可以使用最麻烦但是很靠谱的方法，利用“逐语句执行”按钮将整个和问题相关的js依次去执行一遍，在执行的过程中，自己也跟着理清思路，同时注意下每个变量的值以及选择器选中的元素是否正确，一般来说，这样做一遍下来，bug都解决的差不多了。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h5 id=&quot;所以个人认为我们调试bug的思路应该是这样的首先js是否成功的执行进来其次js是否存在逻辑问题变量问题参数问题等等最后如果上述都没有问题请仔细查看各种符号&quot;&gt;&lt;span&gt;所以个人认为，我们调试bug的思路应该是这样的：首先，js是否成功的执行进来；其次，js是否存在逻辑问题，变量问题，参数问题等等；最后，如果上述都没有问题，请仔细查看各种符号。。。&lt;/span&gt;&lt;/h5&gt;
&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 07 Dec 2017 05:44:00 +0000</pubDate>
<dc:creator>ranyonsue</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ranyonsue/p/7998692.html</dc:identifier>
</item>
<item>
<title>Ztree改版 - 将图标字体化 - fontAwesome - 谎言让你心安</title>
<link>http://www.cnblogs.com/wbsndbf/p/7998657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wbsndbf/p/7998657.html</guid>
<description>&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;引言&lt;/h3&gt;
&lt;p&gt;ps:小白可以一看，大神勿打~&lt;/p&gt;
&lt;p&gt;用过 ztree 的盆友们都知道，ztree 功能强大，就功能上来说，追求着“无处不按钮”的体验，但好用不好看。可能有朋友说：“我这棵树只有我自己看，够用就行”&lt;/p&gt;
&lt;p&gt;（我听不见，你没追求~）。对于这种更多时候是在背面展示的内容，我们追求一个词：简约，什么叫简约？简约就是：简单中透露着大气，朴实中内敛着奢华。呃~&lt;/p&gt;
&lt;p&gt;对不起，扯远了，看最终效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/921970/201712/921970-20171207100347597-410346865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对比一下原型ztree，想要女神女友，还需改版ztree~&lt;/p&gt;
&lt;h3&gt;正文&lt;/h3&gt;
&lt;p&gt;对于ztree，我们审查下代码就能发现，它里面的图标是一整张图片，以背景图片配合background-position，来实现的。这样做的好处从性能方面来说储存消耗小，加载快，从更新方面来说&lt;/p&gt;
&lt;p&gt;，新版本图标上传图片覆盖就行了，当然前提是你得有个ui或者懂ps和ai的前端，光ps肯定是不够的，图标必须是矢量才能保证清晰度效果。&lt;/p&gt;
&lt;p&gt;知道了 ztree 图标是背景图片方式生成的，那么改版ztree我们就有了两个思路：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第一种：做一张尺寸一样的图片（注意图片里面图标大小也一致 ）去覆盖，这样的方便之处在于我们只需要知道背景图片在哪个文件夹&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　就能完成改版，不需要去看源码（想想挺方便哈），而条件在上面提过了；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第二种：注意它是背景图片，如果我们代码中在某图标位置添加文字（当然不能过多，不然会撑大）或尺寸合适的图片并不会改变布局，而是覆盖在背景图片上，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这样的话我们就可以在背景图片所在的标签里面加上 fontawesome 中对应的类名就可以实现效果了，至于那张背景图，删掉呗~&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;步骤&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;找个 demo 看一下 ztree 中各个图片对应的标签（折叠，文件夹，复选框，点线）有什么特别之处，比如说类名 id等，这里我们以 折叠图标为例，下面是源代码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/921970/201712/921970-20171207104550034-273856408.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我们可以看到现在折叠图片是折叠状态的：类名对应 &lt;span&gt;roots_close。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;展开源码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/921970/201712/921970-20171207104759519-1234513496.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;展开对应的类名是：&lt;span&gt;roots_open。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样看来我们可以想到：&lt;span&gt;对应于不同的状态  -  不同的类名  -  不同的类名对应不同的样式即背景图片位置不同  -  不同的图标。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说我们只需要在不同的状态的时候添加相应的 fontawesome 图标调用类名就可以轻松完全图标修改了，到底是不是这样呢？试试看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打开 ztree中 jquery.ztree.all.js，查找: &lt;span&gt;root_open :&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/921970/201712/921970-20171207121023300-1487819125.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;查找结果显示找不到，这伤害来得太突然，突然就有了一种“朕的大清要亡了的感觉”，冷静，这个不行，查另一个看看，还有个 &lt;span&gt;switch &lt;span&gt;，查找：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/921970/201712/921970-20171207121312081-1014748978.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;这下就有惊喜了，看图我们可以知道 switch 被定义为了 SWITCH，这样的话我们瞬间就可以想到会不会是 root_close 是由两个&lt;/p&gt;
&lt;p&gt;变量通过 _ 组合起来的呢，试一下就知道了， 查找 &lt;span&gt;root ：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/921970/201712/921970-20171207121556284-890795368.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;到了这里，暗松口气外加会心一笑：有了。查找 &lt;span&gt;ROOT&lt;/span&gt;，这里我选择了区分大小写查找，因为我们已经知道了它是被定义为了大写 ROOT 参数，后面只会以&lt;/p&gt;
&lt;p&gt;ROOT 形式出现在需要它的位置，看代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/921970/201712/921970-20171207122124941-1094766533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;顾名思义，这个方法是用来生成 节点线类名，折叠图标不就是两根线么？所以是它是它就是它。注意上图中的 &lt;span&gt;lineClass&lt;/span&gt; 数组，由它的名字我们猜测这是生成图标的数组，但现在它是空的，&lt;/p&gt;
&lt;p&gt;为了知道它到底是怎么用的，我们随便添加进去一个类名： &lt;span&gt;testThis &lt;span&gt;，刷新一下看看：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/921970/201712/921970-20171207122922003-478600389.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;可以清楚看到在代码中这个 testThis 被添加在了折叠图标的标签类名中,这样的话我们已经解决了折叠图标折叠起来的状态图标，但还没完，还有展开状态（可能有盆友心里已经在问了：还没完吧？还有最后一层的子节点呢？最后一层的子节点应该是没有折叠图标的啊，先保留问题），继续查找 ROOT，通过断点调试，最后我们锁定：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/921970/201712/921970-20171207131152159-1467861028.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于为什么锁定在这里，有兴趣的盆友可以自己试一下就知道了，这里不做解释了，这里我们再一次看到了 &lt;span&gt;DOCU &lt;span&gt;，而且如果细心观察了的话我们发现它总是出现最后（猜测：最后的子节点？）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/921970/201712/921970-20171207131600441-1386565207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写下如下代码调试查看结果：&lt;/p&gt;
&lt;p&gt;折叠：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/921970/201712/921970-20171207131653409-829583716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;展开：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/921970/201712/921970-20171207131719175-2018067033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，这样我们就完成了折叠图标的替换，通过大同小异的方法，我们一次替换 其余图标，这时我们发现最后一层的子节点上也有折叠图标，这很明显不科学，问题应该是出在&lt;/p&gt;
&lt;p&gt;生成折叠图标方法上面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/921970/201712/921970-20171207132115113-699649225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;做出如下处理，重置生成 类数组：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/921970/201712/921970-20171207132213738-914549267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题得到完美解决。&lt;/p&gt;
&lt;p&gt;接下来我们要做的就是完成这次改版，虽然这样也能用，但是如果每次修改都需要到代码里面到处查找修改，这就不符合我们追求的优化维护，怎么办呢？&lt;/p&gt;
&lt;p&gt;很简单，最开始的时候我们就注意到了，ztree 几乎将所有元素都定义为了参数来调用，如此我们也可以自己新建一个参数来定义这些类，并赋予默认值，这样&lt;/p&gt;
&lt;p&gt;以后要修改就只需要修改默认值就行了，看图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/921970/201712/921970-20171207132710113-2070982502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调用方式： consts.usericon.XXXX,如： consts.usericon.CLOSE .&lt;/p&gt;
&lt;p&gt;最终效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/921970/201712/921970-20171207132953534-1635754384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：ztree本身不提供增加节点按钮，需要自定义方法，这个有兴趣的盆友可以自己了解一下。&lt;/p&gt;
&lt;p&gt;最后附上整个demo给需要的朋友参考一下，有疑问可以留言互相交流，多谢各位看官，抱拳~&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;下载demo&quot; href=&quot;https://files.cnblogs.com/files/wbsndbf/ztreeTest.rar&quot; target=&quot;_blank&quot;&gt;下载demo&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 07 Dec 2017 05:36:00 +0000</pubDate>
<dc:creator>谎言让你心安</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wbsndbf/p/7998657.html</dc:identifier>
</item>
<item>
<title>虚拟机下 solr7.1 cloud 集群搭建 （手动解压和官方脚本两种方式） - 初心丶</title>
<link>http://www.cnblogs.com/zyp4614/p/7998516.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zyp4614/p/7998516.html</guid>
<description>[unable to retrieve full-text content]准备工作： vmware workstation 12，OS使用的是ubuntu16.04，三台虚拟机搭建一个solr集群，zookeeper共用这三台虚拟机组成zookeeper集群。 zookeeper的版本为3.4.10，solr版本为7.1，不使用tomcat，使用solr自带的jetty。</description>
<pubDate>Thu, 07 Dec 2017 05:34:00 +0000</pubDate>
<dc:creator>初心丶</dc:creator>
<dc:identifier>http://www.cnblogs.com/zyp4614/p/7998516.html</dc:identifier>
</item>
<item>
<title>机器学习算法 - 支持向量机SVM - 罗兵漂流记</title>
<link>http://www.cnblogs.com/robin201711/p/7998613.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/robin201711/p/7998613.html</guid>
<description>&lt;p&gt;在上两节中，我们讲解了机器学习的决策树和k-近邻算法，本节我们讲解另外一种分类算法：支持向量机SVM。&lt;/p&gt;
&lt;p&gt;SVM是迄今为止最好使用的分类器之一，它可以不加修改即可直接使用，从而得到低错误率的结果。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;【案例背景】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从前有两个地主，他们都是占山为王的一方霸主。本来各自吃饱自己的饭万事无忧，可是人心不知足蛇吞象啊，自己总是都想占对方的一亩三分地，冲突争吵从来都没有停歇过。当时的环境就是谁狠这土地就归谁，但是我们现在想从科学的角度来分析，如何让他们的地盘均分，画条边界线，从此互不干扰呢？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;【演示代码】&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np  
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pylab as plt
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; svm  

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;生成随机分布的点&lt;/span&gt;
np.random.seed(1&lt;span&gt;)  
X&lt;/span&gt;=np.r_[np.random.randn(20,2)-[2,2],np.random.randn(20,2)+[2,2&lt;span&gt;]]  
Y&lt;/span&gt;=[0]*20+[1]*20

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在图中画出随机分布的点&lt;/span&gt;
plt.scatter(X[:,0],X[:,1],c=Y,s=80,cmap=&lt;span&gt;plt.cm.Paired) 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里是SVM核心算法函数 &lt;/span&gt;
clf=svm.SVC(kernel=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;linear&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  
clf.fit(X,Y)
  
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;画出分割线  &lt;/span&gt;
w=&lt;span&gt;clf.coef_[0]  
a&lt;/span&gt;=-w[0]/w[1]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;得到斜率&lt;/span&gt;
xx=np.linspace(-5,5&lt;span&gt;)  
yy&lt;/span&gt;=a*xx-(clf.intercept_[0])/w[1&lt;span&gt;]  
plt.plot(xx,yy,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在图中画出支持向量的点的两条直线&lt;/span&gt;
b=&lt;span&gt;clf.support_vectors_[0]  
yy_down&lt;/span&gt;=a*xx+(b[1]-a*&lt;span&gt;b[0])  
b&lt;/span&gt;=clf.support_vectors_[-1&lt;span&gt;]  
yy_up&lt;/span&gt;=a*xx+(b[1]-a*&lt;span&gt;b[0])
plt.plot(xx,yy_down,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k--&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  
plt.plot(xx,yy_up,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k--&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将支持向量的点特殊显示  &lt;/span&gt;
plt.scatter(clf.support_vectors_[:,0],clf.support_vectors_[:,1],s=100&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在图中显示需要预测的点&lt;/span&gt;
test_x1, test_y1 = (-3, -3&lt;span&gt;)
test_x2, test_y2 &lt;/span&gt;= (0, 5&lt;span&gt;)
plt.scatter([test_x1],[test_y1],s&lt;/span&gt;=100&lt;span&gt;)
plt.scatter([test_x2],[test_y2],s&lt;/span&gt;=100&lt;span&gt;)
Z1 &lt;/span&gt;=&lt;span&gt; clf.predict([[test_x1, test_y1]])
Z2 &lt;/span&gt;=&lt;span&gt; clf.predict([[test_x2, test_y2]])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;预测结果：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,Z1)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示预测结果&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;预测结果：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,Z2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示预测结果&lt;/span&gt;
&lt;span&gt;
plt.show()  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;【执行结果】&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
预测结果： [0]
预测结果： [1]
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1291895/201712/1291895-20171207124637691-1771152937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;【结果分析】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在上图中，用了4种颜色的圆点和三条直线，他们分别表示如下：&lt;/p&gt;
&lt;p&gt;浅色点：地主1的建筑物&lt;/p&gt;
&lt;p&gt;紫色点：地主2的建筑物&lt;/p&gt;
&lt;p&gt;蓝色点：地主1和地主2相邻的关键建筑物&lt;/p&gt;
&lt;p&gt;黄色点：预测点1&lt;/p&gt;
&lt;p&gt;绿色点：预测点2&lt;/p&gt;
&lt;p&gt;实体直线：最终的分界线，即楚河汉界的分界线，直线下方是地主1的地盘，直线上方是地主2的地盘。&lt;/p&gt;
&lt;p&gt;虚线：关键点连成的直线，他们到分界线是等距的。&lt;/p&gt;

&lt;p&gt;我们看到预测结果，黄点预测结果显示0，表示它在地主1的地盘；绿点预测结果显示1，表示它在地主2的地盘。&lt;/p&gt;
&lt;p&gt;当然我们从肉眼也可以判断本次预测结果是对的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;【算法总结】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. SVM算法只能划分两类物体，当然多类的情况可以转化为多次两类进行划分。&lt;/p&gt;
&lt;p&gt;2. SVM算法不仅能划分线性可分的情况，还可以划分更加复杂线性不可分的情况，核心思想是：变成高阶计算，然后映射到低阶，以后有机会再单独演示这种情况。&lt;/p&gt;

&lt;p&gt; OK, 本讲到此结束，后续更多精彩内容，请持续关注我的博客。&lt;/p&gt;
&lt;p&gt;本文为原创文章，请珍惜作者的劳动成果，转载请注明出处。&lt;/p&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;http://www.cnblogs.com/robin201711/p/7998613.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/robin201711/p/7998613.html&lt;/a&gt;&lt;a href=&quot;http://www.cnblogs.com/robin201711/p/7992784.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 Dec 2017 05:25:00 +0000</pubDate>
<dc:creator>罗兵漂流记</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/robin201711/p/7998613.html</dc:identifier>
</item>
<item>
<title>Web Api 2.0中使用Swagger生成Api文档的2个小Tips - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/7998523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/7998523.html</guid>
<description>[unable to retrieve full-text content]当Web Api 2.0使用OAuth2授权时，如何在Swagger中添加Authorization请求头？ Swagger说明文档支持手动调用Api, 但是当Api使用OAuth2授权时，由于没有地方可以输入授权Token, 导致响应结果一直是401没有授权。 解决方案： 在Swagger配置文件</description>
<pubDate>Thu, 07 Dec 2017 05:14:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/7998523.html</dc:identifier>
</item>
</channel>
</rss>