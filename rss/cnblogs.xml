<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>设计模式（一）：模板模式 - JaJian</title>
<link>http://www.cnblogs.com/jajian/p/9653333.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jajian/p/9653333.html</guid>
<description>&lt;p&gt;实际开发中常常会遇到，代码骨架类似甚至相同，只是具体的实现不一样的场景。例如：流程都有开启、编辑、驳回、结束。每个流程都包含这几个步骤，不同的是不同的流程实例它们的内容不一样。共享单车都是先开锁、骑行、上锁、付款。这些大的步骤固定，不同的是每个实例的具体实现细节不一样。这些类似的业务我们都可以使用模板模式实现。为什么要使用模板模式以及如何使用呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。&lt;br/&gt;&lt;strong&gt;意图&lt;/strong&gt;：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤&lt;br/&gt;&lt;strong&gt;主要解决&lt;/strong&gt;：一些方法通用，却在每一个子类都重新写了这一方法。&lt;br/&gt;&lt;strong&gt;何时使用&lt;/strong&gt;：有一些通用的方法。&lt;br/&gt;&lt;strong&gt;如何解决&lt;/strong&gt;：将这些通用算法抽象出来。&lt;br/&gt;&lt;strong&gt;关键代码&lt;/strong&gt;：在抽象类实现，其他步骤在子类实现。&lt;/p&gt;

&lt;p&gt;我们以生活中买菜做饭的例子来写个Demo，烧饭一般都是买菜、洗菜、烹饪、装盘四大过程。中国自古有八大菜系，制作方式肯定都避不开这四个过程。那在模板模式中如何实现呢？&lt;br/&gt;创建一个抽象类，它的模板方法被设置为 final。&lt;strong&gt;为防止恶意操作，一般模板方法都加上 final 关键词。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractCookingService {
    //买菜
    protected abstract void shopping();
    //清洗
    protected abstract void wash();
    //烹饪
    protected abstract void cooking();
    //装盘
    protected abstract void dishedUp();

    public final void process() {
        shopping();
        wash();
        cooking();
        dishedUp();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建实现了上述抽象类的子类。&lt;br/&gt;// 徽菜烹饪&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 徽菜制作大厨
 */
public class HuiCaiChef extends AbstractCookingService {

    @Override
    protected void shopping() {
        System.out.println(&quot;买菜：新鲜鱼一条，红辣椒五两&quot;);
    }

    @Override
    protected void wash() {
        System.out.println(&quot;清洗：红椒洗净切片，鱼头半分&quot;);
    }

    @Override
    protected void cooking() {
        System.out.println(&quot;烹饪：鱼头水蒸，辣椒过油&quot;);
    }

    @Override
    protected void dishedUp() {
        System.out.println(&quot;装盘：用长形盘子装盛&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;// 川菜烹制&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 川菜制作大厨
 */
public class HuiCaiChef extends AbstractCookingService {

    @Override
    protected void shopping() {
        System.out.println(&quot;买菜：黑猪肉一斤，蒜头5个&quot;);
    }

    @Override
    protected void wash() {
        System.out.println(&quot;清洗：猪肉洗净，蒜头去皮&quot;);
    }

    @Override
    protected void cooking() {
        System.out.println(&quot;烹饪：大火翻炒，慢火闷油&quot;);
    }

    @Override
    protected void dishedUp() {
        System.out.println(&quot;装盘：深碗盛起，热油浇拌&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 TemplatePatternDemo 类执行模板方法 process() 来演示烹饪的定义方式。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TemplatePatternDemo {

    public static void main(String[] args) {
        System.out.println(&quot;----------川菜制作------------&quot;);
        AbstractCookingService chuanCaiService = new ChuanCaiChef();
        chuanCaiService.process();
        System.out.println(&quot;-----------徽菜制作-----------&quot;);
        AbstractCookingService huiCaiService = new HuiCaiChef();
        huiCaiService.process();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行程序，输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;----------川菜制作------------
买菜：新鲜鱼一条，红辣椒五两
清洗：红椒洗净切片，鱼头半分
烹饪：鱼头水蒸，辣椒过油
装盘：用长形盘子装盛
-----------徽菜制作-----------
买菜：黑猪肉一斤，蒜头5个
清洗：猪肉洗净，蒜头去皮
烹饪：大火翻炒，慢火闷油
装盘：深碗盛起，热油浇拌&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从以上实例可以看出，其实模板模式也没什么高深莫测的，简单来说就是三大步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个抽象类，定义几个抽象方法和一个final修饰的模板方法，而模板方法中设定了抽象方法的执行顺序或逻辑。&lt;/li&gt;
&lt;li&gt;无论子类有多少个，只需要继承该抽象类，实现父类的抽象方法重写自己的业务。&lt;/li&gt;
&lt;li&gt;根据不同的需求创建不同的子类实现，每次调用的地方只需调用模板方法，即可完成特定的模板流程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从以上的分析和Demo我们可以看到，模板方法提高了我们的代码的可维护性和可扩展性。有优点也有缺点。&lt;br/&gt;&lt;strong&gt;优点&lt;/strong&gt;： 1、封装不变部分，扩展可变部分。 2、提取公共代码，便于维护。 3、行为由父类控制，子类实现。&lt;br/&gt;&lt;strong&gt;缺点&lt;/strong&gt;：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。&lt;br/&gt;&lt;strong&gt;使用场景&lt;/strong&gt;： 1、有多个子类共有的方法，且逻辑相同。 2、重要的、复杂的方法，可以考虑作为模板方法。&lt;/p&gt;
</description>
<pubDate>Mon, 24 Sep 2018 15:43:00 +0000</pubDate>
<dc:creator>JaJian</dc:creator>
<og:description>实际开发中常常会遇到，代码骨架类似甚至相同，只是具体的实现不一样的场景。例如：流程都有开启、编辑、驳回、结束。每个流程都包含这几个步骤，不同的是不同的流程实例它们的内容不一样。共享单车都是先开锁、骑行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jajian/p/9653333.html</dc:identifier>
</item>
<item>
<title>React Native 入门基础知识总结 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/9697178.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/9697178.html</guid>
<description>&lt;p&gt;中秋在家闲得无事，想着做点啥，后来想想，为啥不学学 react native。在学习 React Native 时， 需要对前端（HTML，CSS，JavaScript）知识有所了解。对于JS，可以看看阮一峰老师的《&lt;a href=&quot;http://es6.ruanyifeng.com/&quot; target=&quot;_blank&quot;&gt;ECMAScript 6 入门&lt;/a&gt;》这篇文章。里面涉及很多 ES6 的新特性。我之前也是看了阮老师的文章做了一些学习笔记 &lt;a href=&quot;https://www.cnblogs.com/huansky/tag/ES6/&quot; target=&quot;_blank&quot;&gt;ES6 学习笔记&lt;/a&gt;。 &lt;/p&gt;
&lt;h2&gt;1、环境搭建&lt;/h2&gt;
&lt;p&gt;环境搭建中文教程，点击跳转RN中文社区 ：&lt;a href=&quot;http://reactnative.cn/docs/0.40/getting-started.html#content&quot; target=&quot;_blank&quot;&gt;http://reactnative.cn/docs/0.40/getting-started.html#content&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;社区内容讲得很详细，大家跟着操作一步一步来即可，遇到问题，直接百度。也可以看看这篇文章：&lt;a href=&quot;https://www.jianshu.com/p/276cb2c0283a&quot; target=&quot;_blank&quot;&gt;React Native 填坑指南&lt;/a&gt; 会教你如何把坑填平。&lt;/p&gt;
&lt;h2&gt;2、React Native 基础&lt;/h2&gt;
&lt;p&gt;先来看看一个实例，这个地址源码地址：&lt;a href=&quot;https://reactnative.cn/docs/sample-application-movies/&quot; target=&quot;_blank&quot;&gt;示例教程：电影列表&lt;/a&gt;。之所以选择这个例子，是因为它包含了几乎所有的 react native入门基础知识。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
import React, { Component } from &quot;react&quot;&lt;span&gt;;

import { Image, FlatList, StyleSheet, Text, View } from &lt;/span&gt;&quot;react-native&quot;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; REQUEST_URL =
&quot;https://raw.githubusercontent.com/facebook/react-native/0.51-stable/docs/MoviesExample.json&quot;&lt;span&gt;;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; class SampleAppMovies extends Component {
    constructor(props) {
        super(props);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {
            data: [],
            loaded: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
      };
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在ES6中，如果在自定义的函数里使用了this关键字，则需要对其进行“绑定”操作，否则this的指向会变为空&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 像下面这行代码一样，在constructor中使用bind是其中一种做法（还有一些其他做法，如使用箭头函数等）&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.fetchData = &lt;span&gt;this&lt;/span&gt;.fetchData.bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
}

componentDidMount() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fetchData();
}

fetchData() {
    fetch(REQUEST_URL)
    .then(response &lt;/span&gt;=&amp;gt;&lt;span&gt; response.json())
    .then(responseData &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意，这里使用了this关键字，为了保证this在调用时仍然指向当前组件，我们需要对其进行“绑定”操作&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
          data: &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.data.concat(responseData.movies),
          loaded: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      });
    });
}

render() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.loaded) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.renderLoadingView();
  }

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;&lt;span&gt;FlatList
      data&lt;/span&gt;={&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.data}
      renderItem&lt;/span&gt;={&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.renderMovie}
      style&lt;/span&gt;=&lt;span&gt;{styles.list}
      &lt;/span&gt;/&amp;gt;
&lt;span&gt;      );
}

renderLoadingView() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;View style={styles.container}&amp;gt;
      &amp;lt;Text&amp;gt;Loading movies...&amp;lt;/Text&amp;gt;
      &amp;lt;/View&amp;gt;
&lt;span&gt;      );
}

renderMovie({ item }) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; { item }是一种“解构”写法，请阅读ES2015语法的相关文档&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; item也是FlatList中固定的参数名，请阅读FlatList的相关文档&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;View style={styles.container}&amp;gt;
      &amp;lt;&lt;span&gt;Image
      source&lt;/span&gt;=&lt;span&gt;{{ uri: item.posters.thumbnail }}
      style&lt;/span&gt;=&lt;span&gt;{styles.thumbnail}
      &lt;/span&gt;/&amp;gt;
      &amp;lt;View style={styles.rightContainer}&amp;gt;
      &amp;lt;Text style={styles.title}&amp;gt;{item.title}&amp;lt;/Text&amp;gt;
      &amp;lt;Text style={styles.year}&amp;gt;{item.year}&amp;lt;/Text&amp;gt;
      &amp;lt;/View&amp;gt;
      &amp;lt;/View&amp;gt;
&lt;span&gt;      );
}
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; styles =&lt;span&gt; StyleSheet.create({
  container: {
    flex: &lt;/span&gt;1&lt;span&gt;,
    flexDirection: &lt;/span&gt;&quot;row&quot;&lt;span&gt;,
    justifyContent: &lt;/span&gt;&quot;center&quot;&lt;span&gt;,
    alignItems: &lt;/span&gt;&quot;center&quot;&lt;span&gt;,
    backgroundColor: &lt;/span&gt;&quot;#F5FCFF&quot;&lt;span&gt;
},
rightContainer: {
    flex: &lt;/span&gt;1&lt;span&gt;
},
title: {
    fontSize: &lt;/span&gt;20&lt;span&gt;,
    marginBottom: &lt;/span&gt;8&lt;span&gt;,
    textAlign: &lt;/span&gt;&quot;center&quot;&lt;span&gt;
},
year: {
    textAlign: &lt;/span&gt;&quot;center&quot;&lt;span&gt;
},
thumbnail: {
    width: &lt;/span&gt;53&lt;span&gt;,
    height: &lt;/span&gt;81&lt;span&gt;
},
list: {
    paddingTop: &lt;/span&gt;20&lt;span&gt;,
    backgroundColor: &lt;/span&gt;&quot;#F5FCFF&quot;&lt;span&gt;
}
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个例子从电影数据库中取得最近正在上映的 25 部电影，并在一个 &lt;code&gt;FlatList &lt;/code&gt;中展示出来。&lt;/p&gt;

&lt;h3&gt;2.1 import &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import React,{Component} from 'react'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 导入‘react’文件里export的一个默认的组件，将其命名为React以及Component这个非默认组件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有其他一些 import 的用法，具体含义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;import defaultcomponent form 'XXX'&lt;/span&gt;&lt;/strong&gt;　　　导入 XXX 文件中的默认组件，命名为 defaultcomponent&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;import {a} from 'XXX'&lt;/span&gt;&lt;/strong&gt; 　　导入 XXX 文件中的 a 组件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;import {a as b} from 'XXX'&lt;/span&gt;&lt;/strong&gt; 　　导入 XXX 文件中的a组件，并将其重命名为 b&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;import * as a from 'XXX'&lt;/span&gt;&lt;/strong&gt; 　　导入 XXX 文件中的所有组件，并将其命名为 a，调用具体组件的方式为 a.b、a.c。。。但不包含默认组件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2.2 var 定义变量&lt;/h3&gt;
&lt;p&gt;在组件前面，定一个变量 REQUEST_URL 用于保存请求网址，。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2.3 export 语句&lt;/h3&gt;
&lt;p&gt;模块的功能有两个关键字: export 和 import。export 用于用户自定义模块。import用于输入其他模块的功能，同时创建命名空间（namespace），防止函数名冲突。&lt;/p&gt;
&lt;p&gt;ES6允许将独立的JS文件作为模块，也就是说，允许一个 JavaScript 脚本文件调用另一个脚本文件。最简单的模块就是一个 JS 文件，里面使用 export 关键字输出变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;profile.js&lt;/span&gt;
    export &lt;span&gt;var&lt;/span&gt; firstName = &quot;Pandora&quot;&lt;span&gt;;
    export &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lastName = &quot;G.Dragon&quot;&lt;span&gt;;
    export &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; year = 1973&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;export还有下面这种写法，两者是等价的&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; firstName = &quot;Pandora&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lastName = &quot;G.Dragon&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; year = 1973&lt;span&gt;;
    export({firstName, lastName, year});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 export 定义模块之后，其他 JS 文件就可以通过 import 关键字加载这个模块（文件）了。加载方式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    import {firstName, lastName, year} from './profile'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; setHeader(element) {
        element.textContent &lt;/span&gt;= firstName + '' +&lt;span&gt; lastName;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码片段中，使用了 import 关键字接受一个对象——用“{ }”表示。里面指定了要从其他模块中导入的变量。大括号里面的变量名必须与被导入模块对外接口的名称相同。&lt;/p&gt;

&lt;h3&gt;2.4 Class 类&lt;/h3&gt;
&lt;p class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过&lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;class&lt;/code&gt;关键字，可以定义类。基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的&lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;class&lt;/code&gt;写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的“类”改写，就是下面这样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Point {
  constructor(x, y) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; y;
  }

  toString() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; '(' + &lt;span&gt;this&lt;/span&gt;.x + ', ' + &lt;span&gt;this&lt;/span&gt;.y + ')'&lt;span&gt;;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;上面代码定义了一个“类”，可以看到里面有一个 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;constructor &lt;/code&gt;方法，这就是构造方法，而 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;this &lt;/code&gt;关键字则代表实例对象。也就是说，ES5 的构造函数 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;Point&lt;/code&gt;，对应 ES6 的 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;Point &lt;/code&gt;类的构造方法。&lt;/p&gt;
&lt;p class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;Point 类除了构造方法，还定义了一个 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;toString &lt;/code&gt;方法。注意，定义“类”的方法的时候，前面不需要加上 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;function &lt;/code&gt;这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。&lt;/p&gt;
&lt;p class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;Class 之间可以通过 &lt;strong&gt;&lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;extends &lt;/code&gt;关键字&lt;/strong&gt;实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
class ColorPoint extends Point {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;上面代码定义了一个 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;ColorPoint &lt;/code&gt;类，该类通过 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;extends &lt;/code&gt;关键字，继承了 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;Point &lt;/code&gt;类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;Point &lt;/code&gt;类。下面，我们在 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;ColorPoint &lt;/code&gt;内部加上代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用父类的constructor(x, y)&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.color =&lt;span&gt; color;
  }

  toString() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.color + ' ' + super.toString(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用父类的toString()&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;上面代码中，&lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;constructor &lt;/code&gt;方法和 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;toString &lt;/code&gt;方法之中，都出现了&lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;super &lt;/code&gt;关键字，它在这里表示父类的构造函数，用来新建父类的 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;this &lt;/code&gt;对象。&lt;/p&gt;
&lt;p class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;&lt;strong&gt;子类必须在 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;constructor &lt;/code&gt;方法中调用 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;super &lt;/code&gt;方法，&lt;/strong&gt;否则新建实例时会报错。这是因为&lt;strong&gt;子类没有自己的 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;this &lt;/code&gt;对象，而是继承父类的 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;this &lt;/code&gt;对象，然后对其进行加工。&lt;/strong&gt;如果不调用&lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;super&lt;/code&gt;方法，子类就得不到 &lt;code class=&quot;pcalibre3 pcalibre4 calibre14&quot;&gt;this &lt;/code&gt;对象。&lt;/p&gt;
&lt;p class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;2.5 Props（属性）&lt;/h3&gt;
&lt;div readability=&quot;15.5&quot;&gt;
&lt;p&gt;大多数组件在创建时就可以使用各种参数来进行定制。用于定制的这些参数就称为&lt;code&gt;props&lt;/code&gt;（属性）。&lt;/p&gt;
&lt;p&gt;以常见的基础组件 &lt;code&gt;Image &lt;/code&gt;为例，在创建一个图片时，可以传入一个名为 &lt;code&gt;source &lt;/code&gt;的 prop 来指定要显示的图片的地址，以及使用名为 &lt;code&gt;style &lt;/code&gt;的 prop 来控制其尺寸。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; React, { Component } from 'react'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; { Image } from 'react-native'&lt;span&gt;;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Bananas &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Component {
  render() {
    let pic &lt;/span&gt;=&lt;span&gt; {
      uri: &lt;/span&gt;'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg'&lt;span&gt;
    };
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;Image source={pic} style={{width: 193, height: 110}} /&amp;gt;&lt;span&gt;
    );
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3 class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt; &lt;/h3&gt;
&lt;h3 class=&quot;calibre7&quot; data-original-font-size=&quot;22&quot; data-original-line-height=&quot;36&quot;&gt;2.6 state &lt;/h3&gt;
&lt;p&gt; props 是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。 对于需要改变的数据，我们需要使用 state。&lt;/p&gt;
&lt;p&gt;大多数组件在创建时就可以使用各种参数来进行定制。用于定制的这些参数就称为 &lt;code&gt;props&lt;/code&gt;（属性）。&lt;/p&gt;
&lt;p&gt;一般来说，你需要在 constructor 中初始化 &lt;code&gt;state&lt;/code&gt;（译注：这是 ES6 的写法，早期的很多 ES5 的例子使用的是 getInitialState 方法来初始化 state，这一做法会逐渐被淘汰），然后在需要修改时调用 &lt;code&gt;setState&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;提示一些初学者应该牢记的要点：&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2.7 react native 生命周期&lt;/h3&gt;
&lt;div readability=&quot;56.078829668282&quot;&gt;
&lt;p&gt;组件的生命周期方法对应着组件的不同生命阶段，通常我们分为三个阶段：组件初始化及挂载阶段、组件运行期阶段及组件卸载阶段。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;初始化及挂载阶段&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一、这是组件类的构造函数，通常在此初始化 state 数据模型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;constructor(props) {
  &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(props);
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;key : value&lt;/span&gt;
&lt;span&gt;  };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、表示组件将要加载到虚拟 DOM，在 render 方法之前执行，整个生命周期只执行一次。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;componentWillMount() {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、表示组件已经加载到虚拟 DOM，在 render 方法之后执行，整个生命周期只执行一次。&lt;span&gt;通常在该方法中完成异步网络请求或者集成其他 JavaScript库。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;componentDidMount() {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;运行期阶段&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一、在组件接收到其父组件传递的 &lt;code&gt;props &lt;/code&gt;的时候执行,参数为父组件传递的&lt;code&gt;props&lt;/code&gt;。在组件的整个生命周期可以多次执行。通常在此方法接收新的&lt;code&gt;props&lt;/code&gt;值，重新设置 &lt;code&gt;state&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;componentWillReceiveProps(nextProps) {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;key : value&lt;/span&gt;
&lt;span&gt;  });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、在 &lt;code&gt;componentWillReceiveProps(nextProps) &lt;/code&gt;执行之后立刻执行；或者在&lt;code&gt;state&lt;/code&gt;更改之后立刻执行。该方法包含两个参数，分别是 &lt;code&gt;props&lt;/code&gt;和 &lt;code&gt;state&lt;/code&gt;。该方法在组件的整个生命周期可以多次执行。如果该方法返回 &lt;code&gt;false&lt;/code&gt;，则 &lt;code&gt;componentWillUpdate(nextProps, nextState) &lt;/code&gt;及其之后执行的方法都不会执行，组件则不会进行重新渲染。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;shouldComponentUpdate(nextProps, nextState) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、在 &lt;code&gt;shouldComponentUpdate(nextProps, nextState) &lt;/code&gt;函数执行完毕之后立刻调用，该方法包含两个参数，分别是 &lt;code&gt;props &lt;/code&gt;和 &lt;code&gt;state&lt;/code&gt;。&lt;code&gt;render() &lt;/code&gt;函数执行之前调用。该方法在组件的整个生命周期可以多次执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;componentWillUpdate(nextProps, nextState) {

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、在 &lt;code&gt;render() &lt;/code&gt;方法执行之后立刻调用。该方法包含两个参数，分别是 &lt;code&gt;props &lt;/code&gt;和 &lt;code&gt;state&lt;/code&gt;。该方法在组件的整个生命周期可以多次执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;componentDidUpdate(preProps, preState) {

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四、&lt;code&gt;render &lt;/code&gt;方法用于渲染组件。在初始化阶段和运行期阶段都会执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;render() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(
    &lt;/span&gt;&amp;lt;View/&amp;gt;&lt;span&gt;
  );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;卸载阶段&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一、在组件由虚拟 DOM 卸载的时候调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;componentWillUnmount() {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2.8 fetch &lt;/h3&gt;
&lt;p&gt;fetch，说白了，就是 XMLHttpRequest 的一种替代方案。如果有人问你，除了 Ajax 获取后台数据之外，还有没有其他的替代方案？答案是还可以使用一种更优的解决方案 fetch。&lt;/p&gt;
&lt;p&gt;到现在为止，fetch 的支持性还不是很好，但是在谷歌浏览器中已经支持了fetch。fetch 挂在在 BOM 中，可以直接在谷歌浏览器中使用。&lt;/p&gt;
&lt;p&gt;查看 fetch 的支持情况：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;fetch的支持情况&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt; fetch 方法会返回一个 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise&lt;/a&gt;，这种模式可以简化异步风格的代码。如果你想了解 promise 的含义，可以参考文章 ：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/huansky/p/6064402.html&quot;&gt;手把手教你实现一个完整的 Promise&lt;/a&gt; 。带你了解 promise 的本质内核。&lt;/p&gt;
&lt;p&gt;下面我们来写第一个 fetch 获取后端数据的例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过fetch获取百度的错误提示页面&lt;/span&gt;
fetch('https://www.baidu.com/search/error.html') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回一个Promise对象&lt;/span&gt;
  .then((res)=&amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; res.text() &lt;span&gt;//&lt;/span&gt;&lt;span&gt; res.text()是一个Promise对象&lt;/span&gt;
&lt;span&gt;  })
  .then((res)&lt;/span&gt;=&amp;gt;&lt;span&gt;{
    console.log(res) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; res是最终的结果&lt;/span&gt;
  })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是不是很简单？再来看看 get 和 post 方法的使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过fetch获取百度的错误提示页面&lt;/span&gt;
fetch('https://www.baidu.com/search/error.html?a=1&amp;amp;b=2', { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在URL中写上传递的参数&lt;/span&gt;
    method: 'GET'&lt;span&gt;
  })

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; post 方法，把前面的 get 注释即可
fetch('&lt;/span&gt;&lt;span&gt;https://www.baidu.com/search/error.html&lt;/span&gt;&lt;span&gt;', {
    method: 'POST',
    body: new URLSearchParams([[&quot;foo&quot;, 1],[&quot;bar&quot;, 2]]).toString() // 这里是请求对象
  })
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  .then((res)&lt;/span&gt;=&amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res.text()
  })
  .then((res)&lt;/span&gt;=&amp;gt;&lt;span&gt;{
    console.log(res)
  })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;React Native 中已经内置了 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;XMLHttpRequest API&lt;/a&gt; (也就是俗称的 ajax)。一些基于 XMLHttpRequest 封装的第三方库也可以使用，例如 &lt;a href=&quot;https://github.com/niftylettuce/frisbee&quot;&gt;frisbee&lt;/a&gt; 或是 &lt;a href=&quot;https://github.com/mzabriskie/axios&quot;&gt;axios&lt;/a&gt; 等。但注意不能使用 jQuery，因为 jQuery 中还使用了很多浏览器中才有而 RN 中没有的东西（所以也不是所有 web 中的 ajax 库都可以直接使用）。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2.9 样式&lt;/h3&gt;
&lt;div readability=&quot;27.5&quot;&gt;
&lt;h4&gt;style 的定义方式：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1、直接在 render（）函数中定义&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;todo 设置样式一,直接在render中定义样式&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; mStyle = {color:'red',fontSize:34&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&amp;lt;Text style={mStyle}&amp;gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/93Laer &amp;lt;/Text&amp;gt;&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; or 类似于安卓中的匿名内部内&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return&amp;lt;Text style={{color:'red',fontSize:34}}&amp;gt; https://github.com/93Laer &amp;lt;/Text&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;2、方式二，通过 StyleSheet 创建 style，测试多个 style，以哪个为准&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建样式&lt;/span&gt;
const styles =&lt;span&gt; StyleSheet.create({
    bigblue:{
        color:&lt;/span&gt;'blue'&lt;span&gt;,
        fontSize:&lt;/span&gt;34&lt;span&gt;,
        fontWeight:&lt;/span&gt;'bold'&lt;span&gt;
    },
    red:{
        color:&lt;/span&gt;'red'&lt;span&gt;,
        fontSize:&lt;/span&gt;14&lt;span&gt;
    }
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用样式&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;todo 设置样式二，通过StyleSheet创建样式&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt;&amp;lt;Text style={styles.bigblue}&amp;gt; https :&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/93Laer &amp;lt;/Text&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接在组件中传入多个 style 对象,最后显示的效果就不展示了，在结尾直接给出结论&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里通过多种方式定义style，主要是告诉读者定义style的多种方式&lt;/span&gt;
 &lt;span&gt;var&lt;/span&gt; mStyle = {color:'red',fontSize:34&lt;span&gt;};
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&amp;lt;Text style={[mStyle,{color: 'blue',fontSize:20}]}&amp;gt; https :&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/93Laer &amp;lt;/Text&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过 StyleSheet 创建多个 style，并传入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 return&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Text &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;={[styles.bigblue,styles.red]}&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; https ://github.com/93Laer &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;hljs javascript&quot;&gt;
&lt;strong&gt;结论：&lt;/strong&gt;&lt;span&gt;当设置多个 style 时以最后一个为准，可理解为最后一个将之前的样式覆盖了。也可理解为，style 从 styles 数组中依次拿出 style，并赋值给自己，所以最后一次赋值就会显示效果&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此，关于 react native 入门的基础知识就讲解完毕了。&lt;/p&gt;

</description>
<pubDate>Mon, 24 Sep 2018 15:31:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>本文通过一个 react native 的例子来对 react native 入门的基础知识进行了总结，对于初学者只有掌握好这些入门的基础知识，才能更好地继续深入学习。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huansky/p/9697178.html</dc:identifier>
</item>
<item>
<title>依赖配置中心实现注有@ConfigurationProperties的bean相关属性刷新 - 小眼儿</title>
<link>http://www.cnblogs.com/hujunzheng/p/9697282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujunzheng/p/9697282.html</guid>
<description>&lt;h2&gt;配置中心是什么&lt;/h2&gt;
&lt;p&gt;　　配置中心，通过key=value的形式存储环境变量。配置中心的属性做了修改，项目中可以通过配置中心的依赖（sdk）立即感知到。需要做的就是如何在属性发生变化时，改变带有@ConfigurationProperties的bean的相关属性。&lt;/p&gt;
&lt;h2&gt;配置中心原理&lt;/h2&gt;
&lt;p&gt;　　在读配置中心源码的时候发现，里面维护了一个Environment，以及ZookeeperPropertySource。当配置中心属性发生变化的时候，清空ZookeeperPropertySource，并放入最新的属性值。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201809/640632-20180924231152294-615393343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ZookeeperPropertySource &lt;span&gt;extends&lt;/span&gt; EnumerablePropertySource&amp;lt;Properties&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201809/640632-20180924231233563-334472918.png&quot; alt=&quot;&quot; width=&quot;788&quot; height=&quot;472&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ZookeeperPropertySource重写了equals和hahscode方法，根据这两个方法可以判定配置中心是否修改了属性。&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201809/640632-20180924231301483-521600859.png&quot; alt=&quot;&quot; width=&quot;787&quot; height=&quot;399&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;动态刷新bean属性原理&lt;/h2&gt;
&lt;h3&gt;实现原理图&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/640632/201809/640632-20180924231351423-1983348432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;动态刷新bean父类&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseConfigCenterBean &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InitializingBean {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(BaseConfigCenterBean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置中心是否生效&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; cfgCenterEffect = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isCfgCenterEffect() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.checkCfgCenterEffect();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cfgCenterEffect;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; checkCfgCenterEffect() {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; tmpCfgCenterEffect = !&lt;span&gt;Objects.isNull(ConfigHelper.getEnvironment());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tmpCfgCenterEffect) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NOSONAR&lt;/span&gt;
            String value = (String) ConfigHelper.getZookeeperPropertySource().getProperty(&quot;cfg.center.effect&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isBlank(value)) {
                tmpCfgCenterEffect &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                tmpCfgCenterEffect &lt;/span&gt;=&lt;span&gt; Boolean.valueOf(value);
            }
        }

        cfgCenterEffect &lt;/span&gt;=&lt;span&gt; tmpCfgCenterEffect;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cfgCenterEffect) {
            String prefix &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getConfigPrefix();
            cfgCenterEffect &lt;/span&gt;=&lt;span&gt; Arrays.stream(ConfigHelper.getZookeeperPropertySource().getPropertyNames())
                    .filter(keyName &lt;/span&gt;-&amp;gt; keyName.indexOf(prefix) == 0&lt;span&gt;)
                    .count() &lt;/span&gt;&amp;gt; 0&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cfgCenterEffect) {
                LOGGER.info(String.format(&lt;/span&gt;&quot;配置中心没有发现模块=%s, prefix=%s的配置，将使用本地配置...&quot;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getModuleName(), prefix));
            }
        }
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 绑定自身目标
     *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doBind() {
        Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; BaseConfigCenterBean&amp;gt; clazz = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (AopUtils.isCglibProxy(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)) {
            clazz &lt;/span&gt;= (Class&amp;lt;? &lt;span&gt;extends&lt;/span&gt; BaseConfigCenterBean&amp;gt;) AopUtils.getTargetClass(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
        BaseConfigCenterBean target &lt;/span&gt;= binding(isCfgCenterEffect(), clazz, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getDefaultResourcePath());
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.copyProperties(target);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; copyProperties(BaseConfigCenterBean target) {
        ReflectionUtils.doWithFields(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.getClass(), field -&amp;gt;&lt;span&gt; {
            field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            field.set(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, field.get(target));
        }, field &lt;/span&gt;-&amp;gt; AnnotatedElementUtils.isAnnotated(field, ConfigField.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 绑定其他目标
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; clazz 目标类
     *&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;protected&lt;/span&gt; &amp;lt;T&amp;gt; T doBind(Class&amp;lt;T&amp;gt;&lt;span&gt; clazz) {
        T target &lt;/span&gt;= binding(isCfgCenterEffect(), clazz, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getDefaultResourcePath());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (target &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; InitializingBean) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                ((InitializingBean) target).afterPropertiesSet();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                LOGGER.error(String.format(&lt;/span&gt;&quot;属性初始化失败[afterPropertiesSet]， class=%s&quot;&lt;span&gt;, ClassUtils.getSimpleName(clazz), e));
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &amp;lt;T&amp;gt; T binding(&lt;span&gt;boolean&lt;/span&gt; cfgCenterEffect, Class&amp;lt;T&amp;gt;&lt;span&gt; clazz, String defaultResourcePath) {
        Optional&lt;/span&gt;&amp;lt;PropertySource&amp;gt; propertySource =&lt;span&gt; Optional.empty();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cfgCenterEffect) {
            propertySource &lt;/span&gt;=&lt;span&gt; Optional.ofNullable(ConfigHelper.getZookeeperPropertySource());
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            Optional&lt;/span&gt;&amp;lt;ResourcePropertySource&amp;gt; resourcePropertySource =&lt;span&gt; ResourceUtils.getResourcePropertySource(defaultResourcePath);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (resourcePropertySource.isPresent()) {
                propertySource &lt;/span&gt;=&lt;span&gt; Optional.ofNullable(resourcePropertySource.get());
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (propertySource.isPresent()) {
            T target;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                target &lt;/span&gt;=&lt;span&gt; RelaxedConfigurationBinder
                        .with(clazz)
                        .setPropertySources(propertySource.get())
                        .doBind();
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (GeneralException e) {
                LOGGER.error(String.format(&lt;/span&gt;&quot;属性绑定失败， class=%s&quot;&lt;span&gt;, ClassUtils.getSimpleName(clazz)), e);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterPropertiesSet() {
        Class&lt;/span&gt;&amp;lt;?&amp;gt; target = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (AopUtils.isAopProxy(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)) {
            target &lt;/span&gt;= AopUtils.getTargetClass(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
        LOGGER.info(String.format(&lt;/span&gt;&quot;%s-&amp;gt;%s模块引入配置中心%s...&quot;, &lt;span&gt;this&lt;/span&gt;.getModuleName(), ClassUtils.getSimpleName(target), (isCfgCenterEffect() ? &quot;生效&quot; : &quot;无效&quot;&lt;span&gt;)));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getModuleName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StringUtils.EMPTY;
    }

    @Subscribe
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; listenRefreshEvent(ConfigCenterUtils.ConfigRefreshEvent refreshEvent) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!refreshEvent.getModuleName().equals(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getModuleName())) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.refreshForEvent();
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过事件进行刷新&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; refreshForEvent();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取本地配置默认路径&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; String getDefaultResourcePath();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取配置属性的公共前缀&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; String getConfigPrefix();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　1、isCfgCenterEffect方法主要判断项目是否接入了配置中心并且配置中心配有bean中相关的属性。&lt;/p&gt;
&lt;p&gt;　　2、binding方法主要根据isCfgCenterEffect方法的返回值去加载配置中心的properties还是本地的properties。&lt;/p&gt;
&lt;p&gt;　　3、getDefaultResourcePath是主要是获取本地资源的默认路径（在没有接入配置中心的情况下）。&lt;/p&gt;
&lt;p&gt;　　4、getConfigPrefix方法返回bean中配置属性的公共前缀（等同于@ConfigurationProperties中的prefix属性）。&lt;/p&gt;
&lt;p&gt;　　5、refreshForEvent方法主要是在某个bean感知到配置中心更新属性时异步通知其他bean进行属性的更新。&lt;/p&gt;
&lt;h3&gt;bean属性绑定工具类&lt;/h3&gt;
&lt;p&gt;　　动态将propertysource绑定到带有@ConfigurationProperties注解的bean中。&lt;/p&gt;
&lt;p&gt;　　参考 org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; PropertiesConfigurationFactory&amp;lt;T&amp;gt;&lt;span&gt; factory;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RelaxedConfigurationBinder(T object) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; PropertiesConfigurationFactory&amp;lt;&amp;gt;&lt;span&gt;(object));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder(Class&amp;lt;?&amp;gt;&lt;span&gt; type) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; PropertiesConfigurationFactory&amp;lt;&amp;gt;&lt;span&gt;(type));
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt;&lt;span&gt; with(T object) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;&amp;gt;&lt;span&gt;(object);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt; with(Class&amp;lt;T&amp;gt;&lt;span&gt; type) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;&amp;gt;&lt;span&gt;(type);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder(PropertiesConfigurationFactory&amp;lt;T&amp;gt;&lt;span&gt; factory) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.factory =&lt;span&gt; factory;
        ConfigurationProperties properties &lt;/span&gt;= getMergedAnnotation(factory.getObjectType(), ConfigurationProperties.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        javax.validation.Validator validator &lt;/span&gt;=&lt;span&gt; Validation.buildDefaultValidatorFactory().getValidator();
        factory.setValidator(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SpringValidatorAdapter(validator));
        factory.setConversionService(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultConversionService());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!Objects.isNull(properties)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;NOSONAR&lt;/span&gt;
&lt;span&gt;            factory.setIgnoreNestedProperties(properties.ignoreNestedProperties());
            factory.setIgnoreInvalidFields(properties.ignoreInvalidFields());
            factory.setIgnoreUnknownFields(properties.ignoreUnknownFields());
            factory.setTargetName(properties.prefix());
            factory.setExceptionIfInvalid(properties.exceptionIfInvalid());
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt;&lt;span&gt; setTargetName(String targetName) {
        factory.setTargetName(targetName);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt; setPropertySources(PropertySource&amp;lt;?&amp;gt;&lt;span&gt;... propertySources) {
        MutablePropertySources sources &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MutablePropertySources();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (PropertySource&amp;lt;?&amp;gt;&lt;span&gt; propertySource : propertySources) {
            sources.addLast(propertySource);
        }
        factory.setPropertySources(sources);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt;&lt;span&gt; setPropertySources(Environment environment) {
        factory.setPropertySources(((ConfigurableEnvironment) environment).getPropertySources());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt;&lt;span&gt; setPropertySources(PropertySources propertySources) {
        factory.setPropertySources(propertySources);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt;&lt;span&gt; setConversionService(ConversionService conversionService) {
        factory.setConversionService(conversionService);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt;&lt;span&gt; setValidator(Validator validator) {
        factory.setValidator(validator);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; RelaxedConfigurationBinder&amp;lt;T&amp;gt; setResolvePlaceholders(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; resolvePlaceholders) {
        factory.setResolvePlaceholders(resolvePlaceholders);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; T doBind() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; GeneralException {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; factory.getObject();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; GeneralException(&quot;配置绑定失败！&quot;&lt;span&gt;, ex);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;配置中心工具类&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigCenterUtils {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(ConfigCenterUtils.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; AsyncEventBus eventBus = &lt;span&gt;new&lt;/span&gt; AsyncEventBus(Executors.newFixedThreadPool(8));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;NOSONAR&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Properties cfgProperties;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Environment environment;

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; {
        cfgProperties &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Properties();
        cfgProperties.putAll(ConfigHelper.getZookeeperPropertySource().getProperties());
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setEnvironment(Environment environment) {
        ConfigCenterUtils.environment &lt;/span&gt;=&lt;span&gt; environment;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; String getValue(String name) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; PropertiesUtil.getValue(name);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            LOGGER.info(&lt;/span&gt;&quot;配置中心无效， property name=&quot; +&lt;span&gt; name, e);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Objects.isNull(environment)) {
            LOGGER.info(&lt;/span&gt;&quot;environment无效，property name=&quot; +&lt;span&gt; name);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StringUtils.EMPTY;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;environment.containsProperty(name)) {
            LOGGER.info(&lt;/span&gt;&quot;environment无配置 property name=&quot; +&lt;span&gt; name);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; StringUtils.EMPTY;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; environment.getProperty(name);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; propertySourceShouldRefresh(String moduleName, ZookeeperPropertySource newPropertySource) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cfgProperties.equals(newPropertySource.getProperties())) {
            cfgProperties.clear();
            cfgProperties.putAll(newPropertySource.getProperties());
            eventBus.post(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigRefreshEvent(moduleName));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T createToRefreshPropertiesBean(Class&amp;lt;T&amp;gt;&lt;span&gt; clazz) {
        Enhancer enhancer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Enhancer();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置代理对象父类&lt;/span&gt;
&lt;span&gt;        enhancer.setSuperclass(clazz);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标识Spring-generated proxies&lt;/span&gt;
        enhancer.setInterfaces(&lt;span&gt;new&lt;/span&gt; Class[]{SpringProxy.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;});
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置增强&lt;/span&gt;
        enhancer.setCallback((MethodInterceptor) (target, method, args, methodProxy) -&amp;gt;&lt;span&gt; {
            ToRefresh toRefresh &lt;/span&gt;= AnnotationUtils.findAnnotation(method, ToRefresh.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Objects.isNull(toRefresh) ||&lt;span&gt; StringUtils.isBlank(toRefresh.method())) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; methodProxy.invokeSuper(target, args);
            }
            Method refreshMethod &lt;/span&gt;=&lt;span&gt; ReflectionUtils.findMethod(target.getClass(), toRefresh.method());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Objects.isNull(refreshMethod)) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; methodProxy.invokeSuper(target, args);
            }
            refreshMethod &lt;/span&gt;=&lt;span&gt; BridgeMethodResolver.findBridgedMethod(refreshMethod);
            refreshMethod.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            refreshMethod.invoke(target, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; methodProxy.invokeSuper(target, args);
        });

        T target &lt;/span&gt;= (T) enhancer.create();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建代理对象&lt;/span&gt;
&lt;span&gt;
        MethodIntrospector.selectMethods(clazz, (ReflectionUtils.MethodFilter) method &lt;/span&gt;-&amp;gt; AnnotatedElementUtils.isAnnotated(method, ToInitial.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;))
                .stream().findFirst().ifPresent(method &lt;/span&gt;-&amp;gt;&lt;span&gt; {
            method.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                method.invoke(target, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                LOGGER.error(String.format(&lt;/span&gt;&quot;初始化异常，class=%s ...&quot;&lt;span&gt;, ClassUtils.getSimpleName(clazz)), e);
            }
        });

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerListener(BaseConfigCenterBean refreshableBean) {
        eventBus.register(refreshableBean);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigRefreshEvent {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String moduleName;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConfigRefreshEvent(String moduleName) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.moduleName =&lt;span&gt; moduleName;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getModuleName() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; moduleName;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setModuleName(String moduleName) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.moduleName =&lt;span&gt; moduleName;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个工具主要作用：&lt;/p&gt;
&lt;p&gt;　　1、判断配置中心的属性是否发生了变化&lt;/p&gt;
&lt;p&gt;　　2、为BaseConfigCenterBean子类创建代理类，使属性在getter方法时检测属性是否应该刷新。&lt;/p&gt;
&lt;p&gt;　　3、提供将BaseConfigCenterBean类型的对象的注册为guava eventbus的监听对象，使之具有根据刷新事件自动刷新自身属性。&lt;/p&gt;
&lt;h3&gt;bean后置处理器&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ConfigCenterBeanPostProcessor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanPostProcessor {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object postProcessBeforeInitialization(Object bean, String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (AnnotatedElementUtils.isAnnotated(bean.getClass(), ConfigCenterBean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
            BaseConfigCenterBean refreshableBean &lt;/span&gt;=&lt;span&gt; (BaseConfigCenterBean) ConfigCenterUtils.createToRefreshPropertiesBean(bean.getClass());
            ConfigCenterUtils.registerListener(refreshableBean);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; refreshableBean;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object postProcessAfterInitialization(Object bean, String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该后置处理器的作用是对所有BaseConfigCenterBean类型的bean进行处理，生成代理bean，并注册为guava eventbus相应的listener。&lt;/p&gt;
&lt;h3&gt;pojo属性绑定配置中心优雅方案1&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@ConfigCenterBean
@ConfigurationProperties(prefix &lt;/span&gt;= &quot;wx.temporary.qrcode&quot;&lt;span&gt;)
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; QrcodeConstants &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BaseConfigCenterBean {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(QrcodeConstants.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;渠道&lt;/span&gt;
    @ConfigField &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标识该属性来自配置中心&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; List&amp;lt;Scene&amp;gt;&lt;span&gt; channels;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务&lt;/span&gt;
&lt;span&gt;    @ConfigField
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Scene&amp;gt;&lt;span&gt; bizs;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务和渠道映射关系&lt;/span&gt;
&lt;span&gt;    @ConfigField
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; biz2Channel;


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Scene&amp;gt;&lt;span&gt; channelMap;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Scene&amp;gt;&lt;span&gt; bizMap;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Scene&amp;gt;&lt;span&gt; getChannels() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; channels;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setChannels(List&amp;lt;Scene&amp;gt;&lt;span&gt; channels) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.channels =&lt;span&gt; channels;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Scene&amp;gt;&lt;span&gt; getBizs() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bizs;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setBizs(List&amp;lt;Scene&amp;gt;&lt;span&gt; bizs) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bizs =&lt;span&gt; bizs;
    }

    @ToRefresh(method &lt;/span&gt;= &quot;toRefresh&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Scene&amp;gt;&lt;span&gt; getChannelMap() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; channelMap;
    }

    @ToRefresh(method &lt;/span&gt;= &quot;toRefresh&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Scene&amp;gt;&lt;span&gt; getBizMap() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bizMap;
    }

    @ToRefresh(method &lt;/span&gt;= &quot;toRefresh&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; getBiz2Channel() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; biz2Channel;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setBiz2Channel(Map&amp;lt;String, String&amp;gt;&lt;span&gt; biz2Channel) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.biz2Channel =&lt;span&gt; biz2Channel;
    }

    @ToInitial
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; refreshQrcodeProperties() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.doBind();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性处理&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CollectionUtils.isEmpty(channels)) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.channelMap =&lt;span&gt; Maps.newHashMap();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.channelMap =&lt;span&gt; channels.stream()
                        .collect(Collectors.toMap(channel &lt;/span&gt;-&amp;gt;&lt;span&gt; channel.getType(), Function.identity()));
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CollectionUtils.isEmpty(bizs)) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bizMap =&lt;span&gt; Maps.newHashMap();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bizMap =&lt;span&gt; bizs.stream()
                        .collect(Collectors.toMap(biz &lt;/span&gt;-&amp;gt;&lt;span&gt; biz.getType(), Function.identity()));
            }

            LOGGER.info(String.format(&lt;/span&gt;&quot;%s 刷新成功..., 当前配置=%s...&quot;, &lt;span&gt;this&lt;/span&gt;.getModuleName(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            LOGGER.error(&lt;/span&gt;&quot;QrcodeConstants 对象属性绑定失败...&quot;&lt;span&gt;, e);
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; toRefresh() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isCfgCenterEffect()) {
                ZookeeperPropertySource propertySource &lt;/span&gt;=&lt;span&gt; ConfigHelper.getZookeeperPropertySource();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ConfigCenterUtils.propertySourceShouldRefresh(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getModuleName(), propertySource)) {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.refreshQrcodeProperties();
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            LOGGER.error(&lt;/span&gt;&quot;QrcodeConstants 对象属性刷新失败&quot;&lt;span&gt;, e);
        }
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;刷新事件调用&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; refreshForEvent() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.refreshQrcodeProperties();
    }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;本地资源文件&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultResourcePath() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;config/qrcode.properties&quot;&lt;span&gt;;
    }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性配置 公共前缀（和@ConfigurationProperties prefix 属性一致）&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getConfigPrefix() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;wx.temporary.qrcode&quot;&lt;span&gt;;
    }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模块名称&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getModuleName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;微信临时二维码配置&quot;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ReflectionToStringBuilder.toString(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;
                , ToStringStyle.JSON_STYLE
                , &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                , &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                , QrcodeConstants.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Scene {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String type;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String desc;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getType() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; type;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setType(String type) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.type =&lt;span&gt; type;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDesc() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; desc;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDesc(String desc) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.desc =&lt;span&gt; desc;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ReflectionToStringBuilder.toString(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;
                    , ToStringStyle.JSON_STYLE
                    , &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                    , &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                    , Scene.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;pojo属性绑定配置中心优雅方案2&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@ConfigCenterBean
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; QrcodeConstants &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; BaseConfigCenterBean {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(QrcodeConstants.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务和渠道映射关系&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; biz2Channel;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;渠道&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Scene&amp;gt;&lt;span&gt; channelMap;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Scene&amp;gt;&lt;span&gt; bizMap;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; QrcodeProperties qrcodeProperties;

    @ToRefresh(method &lt;/span&gt;= &quot;toRefresh&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Scene&amp;gt;&lt;span&gt; getChannelMap() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; channelMap;
    }

    @ToRefresh(method &lt;/span&gt;= &quot;toRefresh&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Scene&amp;gt;&lt;span&gt; getBizMap() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bizMap;
    }

    @ToRefresh(method &lt;/span&gt;= &quot;toRefresh&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; getBiz2Channel() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; biz2Channel;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setBiz2Channel(Map&amp;lt;String, String&amp;gt;&lt;span&gt; biz2Channel) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.biz2Channel =&lt;span&gt; biz2Channel;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; QrcodeProperties getRawQrcodeProperties() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; qrcodeProperties;
    }

    @ToInitial
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; refreshQrcodeProperties() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            QrcodeProperties qrcodeProperties &lt;/span&gt;= &lt;span&gt;super&lt;/span&gt;.doBind(QrcodeProperties.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Objects.isNull(qrcodeProperties)) {
                LOGGER.error(String.format(&lt;/span&gt;&quot;没有加载到%s配置，请检查配置...&quot;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getModuleName()));
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.qrcodeProperties =&lt;span&gt; qrcodeProperties;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性处理&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CollectionUtils.isEmpty(qrcodeProperties.channels)) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.channelMap =&lt;span&gt; Maps.newHashMap();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.channelMap =&lt;span&gt; qrcodeProperties.channels.stream()
                        .collect(Collectors.toMap(channel &lt;/span&gt;-&amp;gt;&lt;span&gt; channel.getType(), Function.identity()));
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CollectionUtils.isEmpty(qrcodeProperties.bizs)) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bizMap =&lt;span&gt; Maps.newHashMap();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bizMap =&lt;span&gt; qrcodeProperties.bizs.stream()
                        .collect(Collectors.toMap(biz &lt;/span&gt;-&amp;gt;&lt;span&gt; biz.getType(), Function.identity()));
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (CollectionUtils.isEmpty(qrcodeProperties.getBiz2Channel())) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.biz2Channel =&lt;span&gt; Maps.newHashMap();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.biz2Channel =&lt;span&gt; qrcodeProperties.getBiz2Channel();
            }

            LOGGER.info(String.format(&lt;/span&gt;&quot;%s 刷新成功..., 当前配置=%s...&quot;, &lt;span&gt;this&lt;/span&gt;.getModuleName(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            LOGGER.error(&lt;/span&gt;&quot;QrcodeConstants 对象属性绑定失败...&quot;&lt;span&gt;, e);
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; toRefresh() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isCfgCenterEffect()) {
                ZookeeperPropertySource propertySource &lt;/span&gt;=&lt;span&gt; ConfigHelper.getZookeeperPropertySource();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ConfigCenterUtils.propertySourceShouldRefresh(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getModuleName(), propertySource)) {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.refreshQrcodeProperties();
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            LOGGER.error(&lt;/span&gt;&quot;QrcodeConstants 对象属性刷新失败&quot;&lt;span&gt;, e);
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; refreshForEvent() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.refreshQrcodeProperties();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDefaultResourcePath() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;config/qrcode.properties&quot;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getConfigPrefix() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;wx.temporary.qrcode&quot;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getModuleName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;微信临时二维码配置&quot;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ToStringBuilder(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
                .append(&lt;/span&gt;&quot;biz2Channel&quot;&lt;span&gt;, biz2Channel)
                .append(&lt;/span&gt;&quot;channelMap&quot;&lt;span&gt;, channelMap)
                .append(&lt;/span&gt;&quot;bizMap&quot;&lt;span&gt;, bizMap)
                .toString();
    }

    @ConfigurationProperties(prefix &lt;/span&gt;= &quot;wx.temporary.qrcode&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; QrcodeProperties {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;渠道&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; List&amp;lt;Scene&amp;gt;&lt;span&gt; channels;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; List&amp;lt;Scene&amp;gt;&lt;span&gt; bizs;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务和渠道映射关系&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; biz2Channel;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Scene&amp;gt;&lt;span&gt; getChannels() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; channels;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setChannels(List&amp;lt;Scene&amp;gt;&lt;span&gt; channels) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.channels =&lt;span&gt; channels;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Scene&amp;gt;&lt;span&gt; getBizs() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bizs;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setBizs(List&amp;lt;Scene&amp;gt;&lt;span&gt; bizs) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bizs =&lt;span&gt; bizs;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, String&amp;gt;&lt;span&gt; getBiz2Channel() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; biz2Channel;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setBiz2Channel(Map&amp;lt;String, String&amp;gt;&lt;span&gt; biz2Channel) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.biz2Channel =&lt;span&gt; biz2Channel;
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Scene {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String type;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String desc;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getType() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; type;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setType(String type) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.type =&lt;span&gt; type;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getDesc() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; desc;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setDesc(String desc) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.desc =&lt;span&gt; desc;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ReflectionToStringBuilder.toString(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;
                    , ToStringStyle.JSON_STYLE
                    , &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                    , &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                    , Scene.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　方案1和方案2略有不同，针对一些属性，我们需要做一些逻辑处理。方案1中将源属性和逻辑之后的属性都放在了同一类中，方案二则是将源属性单独放到一个静态类中，最终处理过后的属性放在了目标类中。另外二者的doBind方法也是有区别的，仔细看一下BaseConfigCenterBean这个类就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; title=&quot;动物小伙伴拍手祝贺动图&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/wGnwDnq84NiaLA3ibqa1JW7dibHoSLXcIbBdDUsHDoLVIGDKZHkE28nlRu5mdTtQicw8xr8uN4RvOvk1CQe9GYIUSA/640?wx_fmt=gif&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-ratio=&quot;0.09363957597173145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/wGnwDnq84NiaLA3ibqa1JW7dibHoSLXcIbBdDUsHDoLVIGDKZHkE28nlRu5mdTtQicw8xr8uN4RvOvk1CQe9GYIUSA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;566&quot; data-order=&quot;0&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;     就先分享这么多了，更多分享请关注我们的技术公众吧！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　 参考文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/4Mpm8E8DdbgD2egTBrEznA&quot; target=&quot;_blank&quot;&gt;算法和技术SHARING&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Sep 2018 15:26:00 +0000</pubDate>
<dc:creator>小眼儿</dc:creator>
<og:description>配置中心是什么 配置中心，通过key=value的形式存储环境变量。配置中心的属性做了修改，项目中可以通过配置中心的依赖（sdk）立即感知到。需要做的就是如何在属性发生变化时，改变带有@Configu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hujunzheng/p/9697282.html</dc:identifier>
</item>
<item>
<title>ZooKeeper概念与应用 - -Finley-</title>
<link>http://www.cnblogs.com/Finley/p/9697237.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Finley/p/9697237.html</guid>
<description>&lt;p&gt;Zookeeper是开源的分布式协调服务，提供了分布式数据一致性的解决方案。&lt;/p&gt;
&lt;p&gt;Zookeeper 可用作配置中心和分布式锁服务，在 Dubbo、Kafka、Spark等分布式集群上得到广泛应用。&lt;/p&gt;

&lt;p&gt;Zookeeper的数据模型为树状结构，树的节点被称作ZNode。&lt;/p&gt;
&lt;p&gt;Zookeeper使用路径来唯一标识ZNode，类似于Unix文件系统中的绝对路径。路径必须以&lt;code&gt;/&lt;/code&gt;开头，由Unicode字符串组成，如&lt;code&gt;/myapp/master/0&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;每一个ZNode维护着三部分数据:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;stat: 节点状态信息，包括版本、更改时间、访问控制等&lt;/li&gt;
&lt;li&gt;data: 节点的内容数据，Zookeeper限制每个节点数据不超过1M。Zookeeper设计用来进行协调调度，请勿在其中存放大量数据。&lt;/li&gt;
&lt;li&gt;children: 该ZNode的子节点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每个节点都有独立的访问控制列表(Access Control List, ACL), 来控制用户对本节点的访问权限。&lt;/p&gt;
&lt;p&gt;每个ZNode都维护着三个版本号:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;dataVersion: 节点数据版本号&lt;/li&gt;
&lt;li&gt;cversion: 子节点版本号&lt;/li&gt;
&lt;li&gt;aclVersion: 节点访问控制列表版本号&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所有的写操作都会使相应的版本号增加。写操作必须指定要更新的ZNode的版本号，版本号不一致会导致写入失败。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Zxid&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有对Zookeeper状态的改变都会产生一个Zxid(ZooKeeper Transaction Id），Zxid全局有序。&lt;/p&gt;
&lt;p&gt;Zxid为标识事件发生的先后顺序: 即事件A发生早于事件B，那么事件A的Zxid定小于事件B的Zxid。&lt;/p&gt;
&lt;p&gt;每个ZNode维护两个Zxid:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cZxid: Znode创建&lt;/li&gt;
&lt;li&gt;mZxid: Znode最近修改&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Zxid是一个64位的数字, 高32位表示Zookeeper集群leader, 低32位表示逻辑顺序。每次leader改变后, 新产生的Zxid高32位都会改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节点类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Zookeeper中的节点分为两种:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;临时节点: 临时节点依赖于创建节点的会话(Session), 一旦Session结束临时节点会被自动删除。临时节点不允许拥有子节点&lt;/li&gt;
&lt;li&gt;永久节点: 永久节点生存期不依赖于客户端会话，只有客户端执行删除操作时才会删除。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Zookeeper 可以创建顺序子节点，即创建子节点时在路径结尾添加一个自增的32位 id, 该id在该节点的父节点下是唯一的。&lt;/p&gt;
&lt;h2 id=&quot;watch&quot;&gt;Watch&lt;/h2&gt;
&lt;p&gt;Zookeeper 所有的读操作getData(), getChildren()和 exists()都可以设置 Watch 触发器。&lt;/p&gt;
&lt;p&gt;Watch 触发器是一次性的，当触发器通知了一次状态变化后消失，不会通知状态的再次变化。&lt;/p&gt;
&lt;p&gt;Zookeeper 与客户端之间通过 Tcp Socket 进行通信， Zookeeper 会主动将时间通知客户端。&lt;/p&gt;
&lt;p&gt;Zookeeper 保证客户端只有首先收到了Watch通知后，才会感知到它所设置监视的znode发生了变化。&lt;/p&gt;
&lt;p&gt;Zookeeper 支持三种类型的watch:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;exists: 被监视的Znode 创建、删除、数据改变时被触发&lt;/li&gt;
&lt;li&gt;getData: 被监视的Znode 删除、数据改变时被触发&lt;/li&gt;
&lt;li&gt;getChildren: 被监视的Znode 删除、创建子节点、删除子节点时被触发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ZooKeeper 是具有较高一致性的分布式协调服务，它提供以下保证:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原子性: 所有操作具有原子性&lt;/li&gt;
&lt;li&gt;分布式一致性： 从任意节点中读取到的数据都是一致的&lt;/li&gt;
&lt;li&gt;顺序一致性: 从一个客户端来的更新请求会被顺序执行&lt;/li&gt;
&lt;li&gt;持久性: 写操作一旦成功，直到被覆盖为止持续有效&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Zookeeper 使用数据副本和崩溃恢复机制保证数据安全和集群高可用性。&lt;/p&gt;
&lt;p&gt;Zookeeper 使用基于 Paxos 算法的 ZAB协议(Zookeeper Atomic Broadcast)进行写操作，保证集群数据的一致性。&lt;/p&gt;
&lt;h2 id=&quot;配置中心&quot;&gt;配置中心&lt;/h2&gt;
&lt;p&gt;我们可以将系统中通用配置信息写入 ZNode 中，客户端启动时从 Zookeeper 获取配置数据并监视配置节点的变化，当配置发生改变 Zookeeper 会通知所有的客户端获取最新数据，从而实现在线更新配置。&lt;/p&gt;
&lt;p&gt;适合使用Zookeeper维护的配置通常:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据量较小&lt;/li&gt;
&lt;li&gt;在运行时动态发生变化&lt;/li&gt;
&lt;li&gt;各客户端读取到数据需要相同&lt;/li&gt;
&lt;li&gt;具有顺序一致性，客户端只要读取到新版本的数据，此后就不能读取到旧版本数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当服务启动时，服务提供者可以在Zookeeper的相应路径下创建临时节点，并在节点中写入服务配置信息。服务关闭(崩溃)时，临时节点自动删除。&lt;/p&gt;
&lt;p&gt;客户端启动时从 ZooKeeper 读取服务提供者信息从而实现自动的服务发布/移除功能。&lt;/p&gt;
&lt;h2 id=&quot;分布式锁&quot;&gt;分布式锁&lt;/h2&gt;
&lt;p&gt;Zookeeper 的临时节点可以维护客户端持有锁的状态，加锁失败的客户端可以使用 Watch 机制监视锁的释放情况，实现阻塞等待加锁。&lt;/p&gt;
&lt;p&gt;Zookeeper 的顺序节点可以实现一个简单的队列，可以利用此特性实现公平锁。客户端在锁节点下创建顺序子节点，持有最小子节点的客户端成功加锁，加锁失败的客户端 Watch 前一个顺序子节点，从而实现先到先得的公平锁机制。&lt;/p&gt;
&lt;h2 id=&quot;命名服务&quot;&gt;命名服务&lt;/h2&gt;
&lt;p&gt;ZooKeeper 的顺序节点可以生成全局唯一ID, 我们可以利用该ID为服务命名。相对于UUID, 该名称较短且可以保证绝不重复。&lt;/p&gt;
&lt;h2 id=&quot;master选举&quot;&gt;Master选举&lt;/h2&gt;
&lt;p&gt;与分布式公平锁应用类似，ZooKeeper 可以维护集群 Master。&lt;/p&gt;
&lt;p&gt;集群中所有可以成为 Master 的进程都在 Zookeeper 中的指定路径下创建顺序子节点，持有最小子节点的进程成为Master。&lt;/p&gt;
&lt;p&gt;集群中所有进程都 Watch 指定路径下节点的情况，一旦发生变化则重新读取最小子节点的持有者作为Master。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;脑裂问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传统集群实现方案是运行一个备用Master节点，备用Master节点定期向主Master节点发送ping请求，若能及时收到主Master的ack响应则认为正常。&lt;/p&gt;
&lt;p&gt;若Ack响应超时，备用Master则会取代原主Master成为新的集群主Master节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/793413/201809/793413-20180924230635896-490517406.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若响应超时因为主Master故障导致，备用Master成为新的主节点完全正常。&lt;/p&gt;
&lt;p&gt;若超时因为主备 Master 节点间 ping-ack 网络故障导致，那么主Master工作正常，而备用Master却误认为主Master崩溃而进行取代，那么集群中可能出现多个Master共存的故障(即脑裂故障)。&lt;/p&gt;
&lt;p&gt;若使用 Zookeeper 维护 Master 信息，无论是因为主Master故障还是通信问题导致最小子节点被删除，备用Master持有的节点都会成为最小子节点。&lt;/p&gt;
&lt;p&gt;此时，所有客户端都会受到通知并得知 Master 变更，保证集群中只有一个 Master。&lt;/p&gt;
&lt;p&gt;当崩溃的Master恢复后，它将成为新的备用Master加入集群。&lt;/p&gt;
&lt;p&gt;ZooKeeper 无法避免通信故障导致误判 Master 状态，但是可以保证在任何情况下集群中只有一个 Master 节点。&lt;/p&gt;
</description>
<pubDate>Mon, 24 Sep 2018 15:07:00 +0000</pubDate>
<dc:creator>-Finley-</dc:creator>
<og:description>ZooKeeper Node 与 Watch 概念介绍, 及特性和应用场景简介。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Finley/p/9697237.html</dc:identifier>
</item>
<item>
<title>Java分布式锁,搞懂分布式锁实现看这篇文章就对了 - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/java_lock.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/java_lock.html</guid>
<description>&lt;div class=&quot;bodyCustomClass&quot; readability=&quot;34.5&quot;&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;随着微处理机技术的发展，人们只需花几百美元就能买到一个CPU芯片，这个芯片每秒钟执行的指令比80年代最大的大型机的处理机每秒钟所执行的指令还多。如果你愿意付出两倍的价钱，将得到同样的CPU，但它却以更高的时钟速率运行。因此，最节约成本的办法通常是在一个系统中使用集中在一起的大量的廉价CPU。所以，倾向于分布式系统的主要原因是它可以潜在地得到比单个的大型集中式系统好得多的性价比。实际上，分布式系统是通过较低廉的价格来实现相似的性能的。&lt;/p&gt;
&lt;p&gt;随着互联网的兴起，越来越多的人使用者互联网产品。一般互联网系统都是分布式部署的，分布式部署确实能带来性能和效率上的提升，提升效率的同事，我们还需要注意，保证一个分布式环境下数据一致性的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;h2 id=&quot;_nav_0&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;分布式锁简述&lt;/h2&gt;
&lt;p&gt;在单机时代，虽然不存在分布式锁，但也会面临资源互斥的情况，只不过在单机的情况下，如果有多个线程要同时访问某个共享资源的时候，我们可以采用线程间加锁的机制，即当某个线程获取到这个资源后，就需要对这个资源进行加锁，当使用完资源之后，再解锁，其它线程就可以接着使用了。例如，在JAVA中，甚至专门提供了一些处理锁机制的一些API（synchronize/Lock等）。&lt;/p&gt;
&lt;p&gt;但是到了分布式系统的时代，这种线程之间的锁机制，就没作用了，系统可能会有多份并且部署在不同的机器上，这些资源已经不是在线程之间共享了，而是属于进程之间共享的资源。因此，为了解决这个问题，「分布式锁」就强势登场了。&lt;/p&gt;
&lt;p&gt;分布式锁是控制分布式系统之间同步访问共享资源的一种方式。在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。&lt;/p&gt;
&lt;p&gt;在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，这个时候，便需要使用到分布式锁。&lt;/p&gt;
&lt;p&gt;分布式锁要满足哪些要求呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;排他性：&lt;/span&gt;在同一时间只会有一个客户端能获取到锁，其它客户端无法同时获取&lt;/li&gt;
&lt;li&gt;&lt;span&gt;避免死锁：&lt;/span&gt;这把锁在一段有限的时间之后，一定会被释放（正常释放或异常释放）&lt;/li&gt;
&lt;li&gt;&lt;span&gt;高可用：&lt;/span&gt;获取或释放锁的机制必须高可用且性能佳&lt;/li&gt;
&lt;li&gt;&lt;span&gt;...&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;目前相对主流的有三种，从实现的复杂度上来看，从上往下难度依次增加：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;数据库(MySQL)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ZooKeeper&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;_nav_1&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;基于数据库实现&lt;/h2&gt;
&lt;p&gt;基于数据库来做分布式锁的话，通常有两种做法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;基于数据库的乐观锁&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;基于数据库的悲观锁&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;_nav_2&quot;&gt;乐观锁&lt;/h4&gt;
&lt;p&gt;乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。&lt;/p&gt;
&lt;p&gt;乐观锁机制其实就是在数据库表中引入一个版本号（version）字段来实现的。当我们要从数据库中读取数据的时候，同时把这个version字段也读出来，如果要对读出来的数据进行更新后写回数据库，则需要将version加1，同时将新的数据与新的version更新到数据表中，且必须在更新的时候同时检查目前数据库里version值是不是之前的那个version，如果是，则正常更新。如果不是，则更新失败，说明在这个过程中有其它的进程去更新过数据了。&lt;/p&gt;
&lt;p&gt;看图叙事。模拟实战场景。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/506684/201808/506684-20180829161041425-429935791.png&quot; alt=&quot;请叫我头头哥&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;如上图，故事男主人公(以下简称男主)打算去ATM机取3000元，故事女主人公(以下简称女主)则要在某宝买买买，买个包需要3000元，账户的余额是5000元。如果没有采用锁的话，在两人同时取款和买买买，可能会出现合计消费了6000，导致账户余额异常。所以需要用到锁的机制，当男主女主甚至更多小主同时消费时，除了读取到6000的账户余额外，还需要读取到当前的版本号version=1，等先行消费成功的主人公(无论谁先消费)去出发修改账户余额的同时，会触发version=version+1，即version=2。那么其他人使用未更新的version(1)去更新账户余额时就会发现版本号不对，就会导致本次更新失败，就得重新去读取最新账户余额以及版本号。&lt;/p&gt;
&lt;p&gt;乐观锁遵循的两点法则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;锁服务要有递增的版本号version&lt;/li&gt;
&lt;li&gt;每次更新数据的时候都必须先判断版本号对不对，然后再写入新的版本号&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;_nav_3&quot;&gt;悲观锁&lt;/h4&gt;
&lt;p&gt;悲观锁的特点是先获取锁，再进行业务操作，即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。&lt;/p&gt;
&lt;p&gt;通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的&lt;code&gt;select ... for update&lt;/code&gt;操作来实现悲观锁。当数据库执行&lt;code&gt;select for update&lt;/code&gt;时会获取被&lt;code&gt;select&lt;/code&gt;中的数据行的行锁，因此其他并发执行的&lt;code&gt;select for update&lt;/code&gt;如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。&lt;code&gt;select for update&lt;/code&gt;获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 消费以后更新银行余额
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; bankId 银行卡号
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; cost 消费金额
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; consume(Long bankId, Integer cost){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先锁定银行账户&lt;/span&gt;
        BankAccount product = query(&quot;SELECT * FROM bank_account WHERE bank_id=#{bankId} FOR UPDATE&quot;&lt;span&gt;, bankId);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (product.getNumber() &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; updateCnt = update(&quot;UPDATE tb_product_stock SET number=#{cost} WHERE product_id=#{productId}&quot;&lt;span&gt;, cost, bankId);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(updateCnt &amp;gt; 0){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新库存成功&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;乐观锁与悲观锁的区别&lt;/p&gt;
&lt;p&gt;乐观锁的思路一般是表中增加版本字段，更新时where语句中增加版本的判断，算是一种CAS（Compare And Swep）操作，银行消费场景中version起到了版本控制的作用（ AND &lt;code&gt;version=#{version}&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;悲观锁之所以是悲观，在于他认为本次操作会发生并发冲突，所以一开始就对银行账户加上锁（&lt;code&gt;SELECT ... FOR UPDATE&lt;/code&gt;），然后就可以安心的做判断和更新，因为这时候不会有别人更新账户余额。&lt;/p&gt;
&lt;h2 id=&quot;_nav_4&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;基于Redis实现&lt;/h2&gt;
&lt;p&gt;基于Redis实现的锁机制，主要是依赖redis自身的原子操作，例如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SET user_key user_value NX PX 100&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;redis从2.6.12版本开始，SET命令才支持这些参数：&lt;/p&gt;
&lt;p&gt;NX：只在在键不存在时，才对键进行设置操作，&lt;code&gt;SET key value NX&lt;/code&gt; 效果等同于 &lt;code&gt;SETNX key value&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;PX millisecond：设置键的过期时间为millisecond毫秒，当超过这个时间后，设置的键会自动失效&lt;/p&gt;
&lt;p&gt;上述代码示例是指，当redis中不存在user_key这个键的时候，才会去设置一个user_key键，并且给这个键的值设置为 user_value，且这个键的存活时间为100ms&lt;/p&gt;
&lt;p&gt;为什么这个命令可以帮我们实现锁机制呢？&lt;/p&gt;
&lt;p&gt;因为这个命令是只有在某个key不存在的时候，才会执行成功。那么当多个进程同时并发的去设置同一个key的时候，就永远只会有一个进程成功。当某个进程设置成功之后，就可以去执行业务逻辑了，等业务逻辑执行完毕之后，再去进行解锁。&lt;/p&gt;
&lt;p&gt;解锁很简单，只需要删除这个key就可以了，不过删除之前需要判断，这个key对应的value是当初自己设置的那个。&lt;/p&gt;
&lt;p&gt;另外，针对redis集群模式的分布式锁，可以采用redis的&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://redis.io/topics/redlock&quot; target=&quot;_blank&quot;&gt;Redlock&lt;/a&gt;(可能会被墙)机制。&lt;/p&gt;
&lt;h2 id=&quot;_nav_5&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;基于ZooKeeper实现&lt;/h2&gt;
&lt;p&gt;其实基于ZooKeeper，就是使用它的临时有序节点来实现的分布式锁。&lt;/p&gt;
&lt;p&gt;原理&lt;/p&gt;
&lt;p&gt;当某客户端要进行逻辑的加锁时，就在zookeeper上的某个指定节点的目录下，去生成一个唯一的临时有序节点， 然后判断自己是否是这些有序节点中序号最小的一个，如果是，则算是获取了锁。如果不是，则说明没有获取到锁，那么就需要在序列中找到比自己小的那个节点，并对其调用&lt;code&gt;exist()&lt;/code&gt;方法，对其注册事件监听，当监听到这个节点被删除了，那就再去判断一次自己当初创建的节点是否变成了序列中最小的。如果是，则获取锁，如果不是，则重复上述步骤。&lt;/p&gt;
&lt;p&gt;当释放锁的时候，只需将这个临时节点删除即可。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/506684/201808/506684-20180829161053632-1446386777.png&quot; alt=&quot;请叫我头头哥&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;如上图，locker是一个持久节点，&lt;code&gt;node_1/node_2/.../node_n&lt;/code&gt; 就是上面说的临时节点，由客户端client去创建的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;client_1/client_2/.../clien_n&lt;/code&gt; 都是想去获取锁的客户端。以client_1为例，它想去获取分布式锁，则需要跑到locker下面去创建临时节点（假如是node_1）创建完毕后，看一下自己的节点序号是否是locker下面最小的，如果是，则获取了锁。如果不是，则去找到比自己小的那个节点（假如是node_2），找到后，就监听node_2，直到node_2被删除，那么就开始再次判断自己的node_1是不是序列中最小的，如果是，则获取锁，如果还不是，则继续找一下一个节点。&lt;/p&gt;
&lt;h2 id=&quot;_nav_7&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;博客总结&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;分布式锁有很多种，开篇说的&quot;相对主流的有三种&quot;只是针对我所遇到的。分布式锁未来肯定是千变万化的，无论你身处一个什么样的公司，最开始的工作可能都得尽可能的从简单的做起。希望大家能根据所在公司业务场景，选择适合所在项目的方案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其他参考资料：&lt;/p&gt;

&lt;div id=&quot;MySignature&quot; readability=&quot;9.0030211480363&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a title=&quot;请叫我头头哥&quot; href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;请叫我头头哥&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a title=&quot;请叫我头头哥&quot; href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/toutou/&lt;/a&gt;&lt;br/&gt;关于作者：专注于基础平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a title=&quot;请叫我头头哥&quot; href=&quot;http://msg.cnblogs.com/msg/send/%E8%AF%B7%E5%8F%AB%E6%88%91%E5%A4%B4%E5%A4%B4%E5%93%A5&quot; target=&quot;_blank&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 24 Sep 2018 15:02:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>随着微处理机技术的发展，人们只需花几百美元就能买到一个CPU芯片，这个芯片每秒钟执行的指令比80年代最大的大型机的处理机每秒钟所执行的指令还多。如果你愿意付出两倍的价钱，将得到同样的CPU，但它却以更</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toutou/p/java_lock.html</dc:identifier>
</item>
<item>
<title>Cookie和Session在Node.JS中的实践（一） - 无聊就去读书</title>
<link>http://www.cnblogs.com/wljqds/p/cookie_session_node.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wljqds/p/cookie_session_node.html</guid>
<description>&lt;p&gt;Cookie和Session是一个非常有趣的概念，也是一个老生常谈的话题。然而，作者看了许多文章，也翻看了几本书籍，它们对Cookie和Session的概念、机制的描述都各不一致，大多文章都只谈到了Cookie和Session其中之一，但在现实开发中两者都需要使用。作者有时候写程序用到了两者但有时候连自己都没理解他们之间的区别、联系、机制等等概念。&lt;br/&gt;&lt;img src=&quot;http://p9h1w9ht8.bkt.clouddn.com/2018-09-23-19-08-16.png&quot; alt=&quot;2018-09-23-19-08-16&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;cookie&quot;&gt;Cookie&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;HTTP的无状态协议是产生Cookie技术的重要原因&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HTTP是一种不保存状态，即无状态（stateless）协议。HTTP协议自身不对请求和响应之间的通信转台进行保存。也就是说HTTP是不会做持久化（Persistence）处理的。当使用HTTP进行通信时，每当有新的请求发送，就会有对应的新响应产生。这并不是缺陷，而是HTTP为了更快的处理大量事务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p9h1w9ht8.bkt.clouddn.com/2018-09-23-19-52-17.png&quot; alt=&quot;2018-09-23-19-52-17&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然而，无状态协议让业务处理变得困难的情况越来越多了，如：我们登录了某宝，就算我们跳转到了某宝的其他页面，也需要保持登录这个“状态”，但HTTP协议做不到。针对这个例子，网站为了掌握是谁发送的请求，就需要把用户的状态保存起来。&lt;/p&gt;
&lt;p&gt;为了实现期望的保持状态功能，于是引入了Cookie技术，所以cookie的主要作用就是&lt;strong&gt;记录状态，包括会话状态管理，用户的个性化设置，浏览器的行为跟踪&lt;/strong&gt;。有了Cookie再用HTTP通信就可以管理状态，因此就有人说Cookie是HTTP的扩展。&lt;/p&gt;
&lt;h3 id=&quot;客户端中的cookie&quot;&gt;客户端中的Cookie&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是我们经常听到的关于Cookie的概念，但从来没见过Cookie长什么样子。在Chrome中通过开发者工具可以查看网站用到的所有Cookie，以博客园用到的Cookie为例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p9h1w9ht8.bkt.clouddn.com/2018-09-23-20-09-48.png&quot; alt=&quot;2018-09-23-20-09-48&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外我们可以使用&lt;code&gt;JavaScript&lt;/code&gt;原生的API获取cookie：&lt;code&gt;document.cookie&lt;/code&gt;，使用该方法获只能获取非&lt;code&gt;HttpOnly&lt;/code&gt;类型的cookie。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p9h1w9ht8.bkt.clouddn.com/2018-09-23-23-49-28.png&quot; alt=&quot;2018-09-23-23-49-28&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟直接在&lt;code&gt;chrome&lt;/code&gt;查看&lt;code&gt;cookie&lt;/code&gt;，使用控制台Console得到的结果除了&lt;code&gt;HttpOnly&lt;/code&gt;以外的Cookie都是一样的。可以发现，每一个&lt;code&gt;cookie&lt;/code&gt;都有几个不同的字段：&lt;code&gt;name,value,domain,path,expires/max-age,HttpOnly,secure&lt;/code&gt;来分析一下比较常用的字段：&lt;/p&gt;
&lt;h4 id=&quot;name和value&quot;&gt;name和value&lt;/h4&gt;
&lt;p&gt;设置&lt;code&gt;cookie&lt;/code&gt;的名字和值。必须设置字段。&lt;/p&gt;
&lt;h4 id=&quot;domain和path&quot;&gt;domain和path&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;domain&lt;/code&gt;是域名，&lt;code&gt;path&lt;/code&gt;是路径，两者加起来就是URL，&lt;code&gt;domain&lt;/code&gt;结合&lt;code&gt;path&lt;/code&gt;一起来限制cookie能被哪些URL访问。概念比较抽象，举个例子&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;以博客园为例，博客园cookie的&lt;code&gt;domain&lt;/code&gt;为&quot;cnblogs.com&quot;,&lt;code&gt;path&lt;/code&gt;为&quot;/&quot;，若我们请求的URL的域名是&quot;cnblogs.com&quot;或者它的子域&quot;home.cnblogs.com&quot;，并且URL的路径都是&quot;/&quot;或者它的子路径&quot;/example&quot;，&quot;/home/user&quot;，以上这些URL都能访问cookie，浏览器会将这些cookie添加到请求的cookie头部中去。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上两个字段是可选的，&lt;code&gt;domain&lt;/code&gt;默认cookie所在的域名，&lt;code&gt;path&lt;/code&gt;默认设置该cookie的网页所在的目录。&lt;/p&gt;
&lt;h4 id=&quot;secure&quot;&gt;secure&lt;/h4&gt;
&lt;p&gt;带有此字段的cookie表示只有在请求使用HTTPS协议的时候才能被传到服务器中。但通常建议不会把保密的数据放到cookie中存储。&lt;/p&gt;
&lt;h4 id=&quot;httponly&quot;&gt;HttpOnly&lt;/h4&gt;
&lt;p&gt;JavaScript原生API能访问浏览器的cookie，这可能会遭遇&lt;code&gt;XSS&lt;/code&gt;攻击，为了防范，设置了该字段的cookie，原生API是无法访问的。&lt;/p&gt;
&lt;h4 id=&quot;expire和max-age&quot;&gt;expire和Max-age&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;expires&lt;/code&gt;：表示cookie的最长有效时间，cookie失效时刻=expires形式是符合&lt;code&gt;HTTP-date&lt;/code&gt;规范的时间戳，这个&lt;code&gt;Date&lt;/code&gt;是一个通用的首部，语法：&lt;code&gt;Date: &amp;lt;day-name&amp;gt; &amp;lt;day&amp;gt; &amp;lt;month&amp;gt; &amp;lt;year&amp;gt; &amp;lt;hour&amp;gt;:&amp;lt;minute&amp;gt;:&amp;lt;second&amp;gt; GMT&lt;/code&gt;，可以通过&lt;code&gt;new Date().toGMTString获得&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Max-Age&lt;/code&gt;：表示cookie存储的最长时间。单位是秒，有效期：&lt;code&gt;创建时刻+max-age&lt;/code&gt;。跟expire的作用的一样的，若两者都存在则&lt;code&gt;Max-Age&lt;/code&gt;的优先级高。该属性在一些老浏览器中不支持。&lt;/p&gt;
&lt;p&gt;如果没有给cookie设置以上这两个字段，那么cookie默认就是所谓的&lt;code&gt;会话Cookie&lt;/code&gt;，有效期就是&lt;code&gt;session&lt;/code&gt;，这里的session指的就是会话，浏览器关闭后cookie就没有了整个过程就是一个会话。&lt;/p&gt;
&lt;h3 id=&quot;httpcookie工作原理&quot;&gt;HTTP+COOKIE工作原理&lt;/h3&gt;
&lt;p&gt;HTTP是无状态协议，所以需要COOKIE技术来保持状态。我们知道，Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，这里分析一下HTTP+COOKIE的工作原理：&lt;/p&gt;
&lt;p&gt;考虑两种可能：&lt;br/&gt;1.&lt;strong&gt;客户端第一请求该台服务器，也就是服务器没有发送cookie给该台客户端&lt;/strong&gt;，因此客户端的第一次请求是没有cookie首部字段数据的，而服务器作为响应也会将cookie首部数据发送到该台客户端中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p9h1w9ht8.bkt.clouddn.com/2018-09-24-01-20-48.png&quot; alt=&quot;2018-09-24-01-20-48&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;客户端不是第一次请求该台服务器，服务器已经有发送过cookie给该台客户端&lt;/strong&gt;，那么在客户端上的cookie都会随着请求一同发送到服务器中，而服务器会检查这个cookie给你返回相应的数据，而不再需要设定cookie。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p9h1w9ht8.bkt.clouddn.com/2018-09-24-20-07-56.png&quot; alt=&quot;2018-09-24-20-07-56&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;cookie实践&quot;&gt;COOKIE实践&lt;/h3&gt;
&lt;p&gt;为了能明白上面的cookie工作原理，以下进行实践，建议读者跟我一起做&lt;/p&gt;
&lt;p&gt;1.还是以博客园为例，在账户退出的状态下打开(&lt;a href=&quot;https://www.cnblogs.com&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com&lt;/a&gt;)[博客园首页],使用Chrome，如果对浏览器开发工具比较熟悉也可以使用火狐，把网站以往的cookie清除&lt;br/&gt;&lt;img src=&quot;http://p9h1w9ht8.bkt.clouddn.com/2018-09-24-19-42-41.png&quot; alt=&quot;2018-09-24-19-42-41&quot;/&gt;&lt;br/&gt;2.进行刷新页面，再打开chrome开发工具&lt;code&gt;network&lt;/code&gt;，选择其中的请求，点击查看&lt;code&gt;请求首部（Request Header）&lt;/code&gt;以及&lt;code&gt;响应首部（Response Header）&lt;/code&gt;，&lt;strong&gt;发现响应首部有&lt;code&gt;set-cookie字段&lt;/code&gt;，即服务器给浏览器设置的cookie。并且，请求首部是没有cookie字段的，因为我们自己清除了cookie！&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://p9h1w9ht8.bkt.clouddn.com/2018-09-24-20-01-56.png&quot; alt=&quot;2018-09-24-20-01-56&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://p9h1w9ht8.bkt.clouddn.com/2018-09-24-20-02-16.png&quot; alt=&quot;2018-09-24-20-02-16&quot;/&gt;&lt;br/&gt;此时，再去查看Cookie面板发现服务器已经给浏览器设置了Cookie。&lt;/p&gt;
&lt;p&gt;再次刷新页面。自行重复以上步骤，&lt;strong&gt;发现请求首部多了一个&lt;code&gt;cookie&lt;/code&gt;字段，即有了cookie后，对服务器的每一次请求都会带上cookie。&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://p9h1w9ht8.bkt.clouddn.com/2018-09-24-20-10-34.png&quot; alt=&quot;2018-09-24-20-10-34&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;HTTP的无状态协议是产生Cookie技术的重要原因，cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。cookie的主要作用就是记录状态，包括会话状态管理，用户的个性化设置，浏览器的行为跟踪。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;写到这，已经涉及不少知识，文章篇幅太长不好，第二篇再写session以及在node.JS的实践。剧透一下，通过Node.JS操作cookie的代码：）&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const express = require('express');
const cookieParser = require('cookie-parser')

var server = express();

server.use(cookieParser('alkdukajvldfq'));
server.use('/', function(req, res) {
    // 发送cookie,path是指定能访问cookie的路径，可从下往上读取，反则不行，比如/=&amp;gt;path:/aaa
    res.cookie('name', 'janro', {path: '/', maxAge: 3600*1000, signed: true});
    // 读取cookie
    console.log(req.cookies);
    console.log(req.signedCookies);
    // / 和favicon
    console.log(req.url);
    res.send('OK');

    //清除cookie
    res.clearCookie('name');
});


server.listen(8080);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下次，session见。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“推荐”按钮，您的“推荐”将是我最大的写作动力！&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000004556040&quot; class=&quot;uri&quot;&gt;https://segmentfault.com/a/1190000004556040&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies&quot; class=&quot;uri&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000007579928&quot; class=&quot;uri&quot;&gt;https://segmentfault.com/a/1190000007579928&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;图解HTTP&lt;/li&gt;
&lt;li&gt;JavaScript高级程序设计&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 24 Sep 2018 14:51:00 +0000</pubDate>
<dc:creator>无聊就去读书</dc:creator>
<og:description>Cookie和Session在Node.JS中的实践（一） Cookie和Session是一个非常有趣的概念，也是一个老生常谈的话题。然而，作者看了许多文章，也翻看了几本书籍，它们对Cookie和Se</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wljqds/p/cookie_session_node.html</dc:identifier>
</item>
<item>
<title>Log4j使用教程 - Miya。</title>
<link>http://www.cnblogs.com/SimpleWu/p/9696970.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SimpleWu/p/9696970.html</guid>
<description>&lt;p&gt;在我们的应用程序中日志是不可缺少的部分，在Apache中由一个功能无比强大的日志组件，它提供了方便的日志记录，这个开源的项目就是我们惯用的Log4j，jar包我么们一颗取Apache官网下载最新版本的。&lt;a href=&quot;https://logging.apache.org/log4j/2.x/&quot; target=&quot;_blank&quot;&gt;log4j下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一.入门篇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.打开我们的Eclipse新建一个Java项目并且导入Log4j的Jar包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201809/1462123-20180924213140199-188210937.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2.创建并且设置我们Log4j的资源文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; ### 设置###
log4j.rootLogger &lt;/span&gt;= debug,stdout,D,&lt;span&gt;E

### 输出信息到控制台 ###
log4j.appender.stdout &lt;/span&gt;=&lt;span&gt; org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target &lt;/span&gt;=&lt;span&gt; System.out
log4j.appender.stdout.layout &lt;/span&gt;=&lt;span&gt; org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern &lt;/span&gt;= &lt;span&gt;[&lt;/span&gt;&lt;span&gt;%-5p&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; %d{yyyy-MM-dd HH:mm:ss,&lt;span&gt;SSS} method:%l%n%m%n

### 输出DEBUG级别以上的日志到&lt;/span&gt;&lt;span&gt;E://logs/error.log ###
log4j.appender.D &lt;/span&gt;=&lt;span&gt; org.apache.log4j.DailyRollingFileAppender
log4j.appender.D.File &lt;/span&gt;=&lt;span&gt; E://logs/log.log
log4j.appender.D.Append &lt;/span&gt;=&lt;span&gt; true
log4j.appender.D.Threshold &lt;/span&gt;=&lt;span&gt; DEBUG 
log4j.appender.D.layout &lt;/span&gt;=&lt;span&gt; org.apache.log4j.PatternLayout
log4j.appender.D.layout.ConversionPattern &lt;/span&gt;= %-d{yyyy-MM-dd HH:mm:ss}  &lt;span&gt;[&lt;/span&gt;&lt;span&gt; %t:%r &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; - &lt;span&gt;[&lt;/span&gt;&lt;span&gt; %p &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;  %m%n

### 输入ERROR级别以上的日志到&lt;/span&gt;&lt;span&gt;E://logs/error.log ###
log4j.appender.E &lt;/span&gt;=&lt;span&gt; org.apache.log4j.DailyRollingFileAppender
log4j.appender.E.File &lt;/span&gt;=&lt;span&gt;E://logs/error.log 
log4j.appender.E.Append &lt;/span&gt;=&lt;span&gt; true
log4j.appender.E.Threshold &lt;/span&gt;=&lt;span&gt; ERROR 
log4j.appender.E.layout &lt;/span&gt;=&lt;span&gt; org.apache.log4j.PatternLayout
log4j.appender.E.layout.ConversionPattern &lt;/span&gt;= %-d{yyyy-MM-dd HH:mm:ss}  &lt;span&gt;[&lt;/span&gt;&lt;span&gt; %t:%r &lt;/span&gt;&lt;span&gt;]&lt;/span&gt; - &lt;span&gt;[&lt;/span&gt;&lt;span&gt; %p &lt;/span&gt;&lt;span&gt;]&lt;/span&gt;  %m%n
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.我们来到Log4jTest中的main方法设置日志内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
logger.debug(&quot;记录debug级别的信息  &quot;&lt;span&gt;);  
logger.info(&lt;/span&gt;&quot;记录info级别的信息  &quot;&lt;span&gt;);  
logger.error(&lt;/span&gt;&quot;记录error级别的信息  &quot;); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.查看我们的日志输出结果：&lt;/p&gt;
&lt;p&gt;这是控制台上打印的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201809/1462123-20180924214028314-1957044953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们在来看看我们日志文件&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201809/1462123-20180924214040592-1471181859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201809/1462123-20180924214059542-1257809864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候我们发现日志已经按照我们的配置要求输出到对应的文档去了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二.log4j最基本的使用方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;log4j最要由三个重要的组件构成：日志信息的优先级，日志信息的输出目的地，日志信息的输出格式。日志信息的优先级从高到低由ERROR,WARN,INFO,DEBUG,分别用来指定这条日志信息的重要程度；日志信息的输出目的地指定了日志是打印在控制台还是输出到文件中；而输出格式控制了日志信息的显示内容。&lt;/span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;1）定义配置文件&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;其实我们可以完全不用配置log4j文件，我们可以在代码中完成log4j的配置环境，但是使用配置文件将使应用程序变得更加的灵活。log4j支持两种配置文件格式，一种是XML格式的文件还有一种就是我们上面用的使用properteis资源文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;配置根Logger，语法为：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
log4j.rootLogger = [ level ] , appenderName, appenderName, …
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中，level 是日志记录的优先级，分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。Log4j建议只使用四个级别，优 先级从高到低分别是ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定 义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来。 appenderName就是指B日志信息输出到哪个地方。您可以同时指定多个输出目的地。&lt;/p&gt;
&lt;p&gt;配置日志信息输出目的地Appender，其语法为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
log4j.appender.appenderName =&lt;span&gt; fully.qualified.name.of.appender.class  
log4j.appender.appenderName.option1 &lt;/span&gt;=&lt;span&gt; value1  
…  
log4j.appender.appenderName.option &lt;/span&gt;= valueN
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，Log4j提供的appender有以下几种：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;org.apache.log4j.ConsoleAppender（控制台），  
org.apache.log4j.FileAppender（文件），  
org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），  
org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），  
org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.配置日志信息的格式（布局），其语法为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
log4j.appender.appenderName.layout =&lt;span&gt; fully.qualified.name.of.layout.class  
log4j.appender.appenderName.layout.option1 &lt;/span&gt;=&lt;span&gt; value1  
…  
log4j.appender.appenderName.layout.option &lt;/span&gt;= valueN
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，Log4j提供的layout有以下几种：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;org.apache.log4j.HTMLLayout（以HTML表格形式布局），  
org.apache.log4j.PatternLayout（可以灵活地指定布局模式），  
org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），  
org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下： %m 输出代码中指定的消息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;%p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL  
%r 输出自应用启动到输出该log信息耗费的毫秒数  
%c 输出所属的类目，通常就是所在类的全名  
%t 输出产生该日志事件的线程名  
%n 输出一个回车换行符，Windows平台为“rn”，Unix平台为“n”  
%d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 &lt;/span&gt;&lt;span&gt;22&lt;/span&gt;：&lt;span&gt;10&lt;/span&gt;：&lt;span&gt;28&lt;/span&gt;，&lt;span&gt;921&lt;/span&gt;&lt;span&gt;  
%l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Log4jTest.main(Log4jTest.java:&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2）在代码中使用Log4j&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; 首先我们要得到记录器&lt;/p&gt;
&lt;p&gt;使用Log4j，第一步就是获取日志记录器，这个记录器将负责控制日志信息。其语法为：&lt;/p&gt;
&lt;p&gt;　　public static Logger getLogger( String name)&lt;/p&gt;
&lt;p&gt;　　通过指定的名字获得记录器，如果必要的话，则为这个名字创建一个新的记录器。Name一般取本类的名字，比如：&lt;/p&gt;
&lt;p&gt;　　static Logger logger = Logger.getLogger ( ServerWithLog4j.class.getName () )&lt;/p&gt;
&lt;p&gt;然后我们需要读取配置文件&lt;/p&gt;
&lt;p&gt;当获得了日志记录器之后，第二步将配置Log4j环境，其语法为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;BasicConfigurator.configure ()： 自动快速地使用缺省Log4j环境。  
PropertyConfigurator.configure ( &lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt; configFilename) ：读取使用Java的特性文件编写的配置文件。  
DOMConfigurator.configure ( &lt;/span&gt;&lt;span&gt;String&lt;/span&gt; filename ) ：读取XML形式的配置文件。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;插入记录信息（格式化日志信息）&lt;/p&gt;
&lt;p&gt;当上两个必要步骤执行完毕，您就可以轻松地使用不同优先级别的日志记录语句插入到您想记录日志的任何地方，其语法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Logger.debug ( &lt;span&gt;Object&lt;/span&gt;&lt;span&gt; message ) ;  
Logger.info ( &lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt; message ) ;  
Logger.warn ( &lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt; message ) ;  
Logger.error ( &lt;/span&gt;&lt;span&gt;Object&lt;/span&gt; message ) ;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3）日志级别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　每个Logger都被了一个日志级别（log level），用来控制日志信息的输出。日志级别从高到低分为：&lt;/p&gt;
&lt;p&gt;　　A：off 最高等级，用于关闭所有日志记录。&lt;/p&gt;
&lt;p&gt;　　B：fatal 指出每个严重的错误事件将会导致应用程序的退出。&lt;/p&gt;
&lt;p&gt;　　C：error 指出虽然发生错误事件，但仍然不影响系统的继续运行。&lt;/p&gt;
&lt;p&gt;　　D：warm 表明会出现潜在的错误情形。&lt;/p&gt;
&lt;p&gt;　　E：info 一般和在粗粒度级别上，强调应用程序的运行全程。&lt;/p&gt;
&lt;p&gt;　　F：debug 一般用于细粒度级别上，对调试应用程序非常有帮助。&lt;/p&gt;
&lt;p&gt;　　G：all 最低等级，用于打开所有日志记录。&lt;/p&gt;
&lt;p&gt;　　上面这些级别是定义在org.apache.log4j.Level类中。Log4j只建议使用4个级别，优先级从高到低分别是error,warn,info和debug。通过使用日志级别，可以控制应用程序中相应级别日志信息的输出。例如，如果使用b了info级别，则应用程序中所有低于info级别的日志信息(如debug)将不会被打印出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三，Web项目中使用log4j&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面代码描述了Log4j的简单应用，其实使用Log4j也就是这样简单方便。当然除了上面的配置方法，还有其它，比如做一个J2EE应用，在J2EE应用使用Log4j，必须先在启动服务时加载Log4j的配置文件进行初始化，可以在web.xml中进行。&lt;/p&gt;

&lt;p&gt;　　1、web应用的log4j使用基本上都采用：新建一个servlet，这个servlet在init函数中为log4j执行配置。一般就是读入配置文件。所以需要在web.xml中为这个servlet配置，同时设定load-on-startup为1。&lt;/p&gt;

&lt;p&gt;　　2、这个servlet配置log4j就是读出配置文件，然后调用configure函数。这里有两个问题：一、需要知道文件在哪里；二、需要正确的文件类型&lt;/p&gt;

&lt;p&gt;　　3、配置文件位置在web.xml中配置一个param即可，路径一般是相对于web的root目录&lt;/p&gt;

&lt;p&gt;　　4、文件类型一般有两种，一个是Java的property文件，另一种是xml文件&lt;/p&gt;

&lt;p&gt;　　配置文件的大致内容：log4j可以指定输出的log级别的最低等级，以及log的输出配置格式，每个log可以指定多个输出方式&lt;/p&gt;
&lt;p&gt;接下来我们来创建一个WEB项目&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1462123/201809/1462123-20180924220216249-409653255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们配置WEB。xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &amp;lt;servlet&amp;gt;  
        &amp;lt;servlet-name&amp;gt;Log4JTestServlet&amp;lt;/servlet-name&amp;gt;  
        &amp;lt;servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;com.miya.log4j.Log4JTestServlet&amp;lt;/servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;  
    &amp;lt;/servlet&amp;gt;  

    &amp;lt;!--用来启动 log4jConfigLocation的servlet --&amp;gt;  
    &amp;lt;servlet&amp;gt;  
        &amp;lt;servlet-name&amp;gt;Log4JInitServlet&amp;lt;/servlet-name&amp;gt;  
        &amp;lt;servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;com.miya.log4j.Log4JInitServlet&amp;lt;/servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;  
        &amp;lt;init-param&amp;gt;  
            &amp;lt;param-name&amp;gt;log4j-properties-location&amp;lt;/param-name&amp;gt;  
            &amp;lt;param-value&amp;gt;/WEB-INF/classes/log4j.properties&amp;lt;/param-value&amp;gt;  
        &amp;lt;/init-param&amp;gt;  
        &amp;lt;load-on-startup&amp;gt;&lt;span&gt;1&lt;/span&gt;&amp;lt;/load-on-startup&amp;gt;  
    &amp;lt;/servlet&amp;gt;  

    &amp;lt;servlet-mapping&amp;gt;  
        &amp;lt;servlet-name&amp;gt;Log4JTestServlet&amp;lt;/servlet-name&amp;gt;  
        &amp;lt;url-pattern&amp;gt;/test&amp;lt;/url-pattern&amp;gt;  
    &amp;lt;/servlet-mapping&amp;gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置log4j.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; ### set log levels ###  
log4j.rootLogger &lt;/span&gt;=&lt;span&gt; debug,stdout,D,E  

log4j.appender.stdout &lt;/span&gt;=&lt;span&gt; org.apache.log4j.ConsoleAppender  
log4j.appender.stdout.Target &lt;/span&gt;=&lt;span&gt; System.out  
log4j.appender.stdout.layout &lt;/span&gt;=&lt;span&gt; org.apache.log4j.PatternLayout  
log4j.appender.stdout.layout.ConversionPattern &lt;/span&gt;= [%-5p] %d{yyyy-MM-&lt;span&gt;dd HH:mm:ss,SSS} method:%l%n%m%n  

log4j.appender.D &lt;/span&gt;=&lt;span&gt; org.apache.log4j.DailyRollingFileAppender  
log4j.appender.D.File &lt;/span&gt;= F://logs/&lt;span&gt;log.log  
log4j.appender.D.Append &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;  
log4j.appender.D.Threshold &lt;/span&gt;=&lt;span&gt; DEBUG   
log4j.appender.D.layout &lt;/span&gt;=&lt;span&gt; org.apache.log4j.PatternLayout  
log4j.appender.D.layout.ConversionPattern &lt;/span&gt;= %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] -&lt;span&gt; [ %p ]  %m%n  

log4j.appender.E &lt;/span&gt;=&lt;span&gt; org.apache.log4j.DailyRollingFileAppender  
log4j.appender.E.File &lt;/span&gt;=F://logs/&lt;span&gt;error.log   
log4j.appender.E.Append &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;  
log4j.appender.E.Threshold &lt;/span&gt;=&lt;span&gt; ERROR   
log4j.appender.E.layout &lt;/span&gt;=&lt;span&gt; org.apache.log4j.PatternLayout  
log4j.appender.E.layout.ConversionPattern &lt;/span&gt;= %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;WEB容器一打开就加载servlet这样也是就行了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当我们需要在Spring项目中加入Log4j&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;首先百年不变配置Web.xml&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;servlet&amp;gt;  
        &amp;lt;servlet-name&amp;gt;Log4JTestServlet&amp;lt;/servlet-name&amp;gt;  
        &amp;lt;servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;com.miya.log4j.Log4JTestServlet&amp;lt;/servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;  
    &amp;lt;/servlet&amp;gt;  

    &amp;lt;!--用来启动 log4jConfigLocation的servlet --&amp;gt;  
&amp;lt;!--     &amp;lt;servlet&amp;gt;  
        &amp;lt;servlet-name&amp;gt;Log4JInitServlet&amp;lt;/servlet-name&amp;gt;  
        &amp;lt;servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;com.miya.log4j.Log4JInitServlet&amp;lt;/servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;  
        &amp;lt;init-param&amp;gt;  
            &amp;lt;param-name&amp;gt;log4j-properties-location&amp;lt;/param-name&amp;gt;  
            &amp;lt;param-value&amp;gt;/WEB-INF/classes/log4j.properties&amp;lt;/param-value&amp;gt;  
        &amp;lt;/init-param&amp;gt;  
        &amp;lt;load-on-startup&amp;gt;&lt;span&gt;1&lt;/span&gt;&amp;lt;/load-on-startup&amp;gt;  
    &amp;lt;/servlet&amp;gt;--&amp;gt;  

    &amp;lt;servlet-mapping&amp;gt;  
        &amp;lt;servlet-name&amp;gt;Log4JTestServlet&amp;lt;/servlet-name&amp;gt;  
        &amp;lt;url-pattern&amp;gt;/test&amp;lt;/url-pattern&amp;gt;  
    &amp;lt;/servlet-mapping&amp;gt;   

        &amp;lt;!-- Spring 容器加载 --&amp;gt;  
    &amp;lt;listener&amp;gt;  
        &amp;lt;listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;  
    &amp;lt;/listener&amp;gt;  
    &amp;lt;context-param&amp;gt;  
        &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;  
        &amp;lt;param-value&amp;gt;classpath:applicationContext.xml&amp;lt;/param-value&amp;gt;  
    &amp;lt;/context-param&amp;gt;   

    &amp;lt;!-- 设置根目录 --&amp;gt;  
    &amp;lt;context-param&amp;gt;    
        &amp;lt;param-name&amp;gt;webAppRootKey&amp;lt;/param-name&amp;gt;    
        &amp;lt;param-value&amp;gt;webapp.root&amp;lt;/param-value&amp;gt;    
    &amp;lt;/context-param&amp;gt;    

    &amp;lt;context-param&amp;gt;  
        &amp;lt;param-name&amp;gt;log4jConfigLocation&amp;lt;/param-name&amp;gt;  
        &amp;lt;param-value&amp;gt;/WEB-INF/classes/log4j.properties&amp;lt;/param-value&amp;gt;  
    &amp;lt;/context-param&amp;gt;  
    &amp;lt;!-- 3000表示 开一条watchdog线程每60秒扫描一下配置文件的变化;这样便于日志存放位置的改变 --&amp;gt;  
    &amp;lt;context-param&amp;gt;    
         &amp;lt;param-name&amp;gt;log4jRefreshInterval&amp;lt;/param-name&amp;gt;    
         &amp;lt;param-value&amp;gt;&lt;span&gt;3000&lt;/span&gt;&amp;lt;/param-value&amp;gt;    
    &amp;lt;/context-param&amp;gt;   
    &amp;lt;listener&amp;gt;  
        &amp;lt;listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.util.Log4jConfigListener&amp;lt;/listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;  
    &amp;lt;/listener&amp;gt;   
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在spring的配置中applicationContext.xml中不需要加入任何bean。在我们程序一运行log4j的servlet也会跟着spring窗口启动了。&lt;/p&gt;

</description>
<pubDate>Mon, 24 Sep 2018 14:11:00 +0000</pubDate>
<dc:creator>Miya。</dc:creator>
<og:description>在我们的应用程序中日志是不可缺少的部分，在Apache中由一个功能无比强大的日志组件，它提供了方便的日志记录，这个开源的项目就是我们惯用的Log4j，jar包我么们一颗取Apache官网下载最新版本的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SimpleWu/p/9696970.html</dc:identifier>
</item>
<item>
<title>java异常查看利器之使用 jvmti 的Callback_JVMTI_EVENT_EXCEPTION 事件查看异常 - 来自非洲大草原的食人虎</title>
<link>http://www.cnblogs.com/yql1986/p/9695319.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yql1986/p/9695319.html</guid>
<description>&lt;p&gt;　　阅读本文前需要了解什么是&lt;strong&gt;jvmti&lt;/strong&gt;，&lt;strong&gt;jvmti&lt;/strong&gt;全称称之为 &lt;strong&gt;JVM Tool Interface，&lt;/strong&gt;有关jvmti更详细的知识，本文不再详细列出。大家可以借助百度来了解有关它更为详尽的内容。&lt;/p&gt;
&lt;p&gt;　　在开源文件大行其道的今天，基于java种种解决方案和框架纷绘踏至而来，浩瀚如海看不完也学不尽。在采用这些解决方案和框架进行项目开发时，往往会出现当程序卡壳时，既无异常提示信息亦没有与之对应的日志输出的局面。每每出现这样的困境时，往往只能通过打断点来一步步调试跟踪来解决。更有甚者，基于某一底层的框架进行相应的开发时，受限于框架开发者的精力和时间等因素的影响，如果框架针对某异常处理设计的不合理，处理异常时没有向外抛出异常，同时又没有输出日志信息。当出现问题时，雪上加霜的是框架又没有提供源码用于打断点调试，此时只能借助通过反编译工具，阅读框架源码来尝试解决问题。每每出现这些困境，真希望有一种工具能够洞悉那些被框架“吃掉”没有向往抛出的异常，以便加快问题的解决步伐。&lt;/p&gt;
&lt;p&gt;　　为了方便开发，一直都想做一个有关java异常查看的小工具。想了很长时间，想到了如下几种实现方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;借助字节码工具，在每一个方法开头和结尾处插入java异常捕获代码。这种方式实现起来效率太低了，况且如果在方法体内，捕获异常并没有向外抛出的话，就算采用这种方式也看不到异常。&lt;/li&gt;
&lt;li&gt;SpringMVC框架针对异常进行了统一的封装和处理，只要进行相应的扩展就能捕获到程序抛出的异常。这种实现方式较前一种比较看来，效率大大提高了，但是仍然没有解决前者提到的，如果应用程序内部自己“吃掉异常”，不向外抛出异常的话，依然无法捕捉到异常，而且这种实现实现方式仅仅局限于使用了SpringMVC框架的WEB应用程序，如果使用了其它的WEB架构或者非WEB的应用程序就会无能为力，局限性太强。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　思来索去，想到java应用程序的运行肯定是离不开jvm的，不妨看一下jvm中有没有提供这样的扩展。在网上搜索了一番，发现jvm还真提供了这样的扩展。&lt;/p&gt;
&lt;p&gt;JVM Tool Interface 链接地址：&lt;a title=&quot;https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html#Exception&quot; href=&quot;https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html#Exception&quot; target=&quot;_blank&quot;&gt;https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html#Exception&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;示例代码，在main方法中吃掉异常之后，不作任何处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.github.torlight.jvmtit;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * Hello world!
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; App {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main( String[] args ){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         
&lt;span&gt;11&lt;/span&gt;         System.out.println( &quot;Hello World!&quot;&lt;span&gt; );
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&quot;QQQ&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }    
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　程序加载相应的扩展，运行之后效果如下所示，可以看到在控制台上面，打印出空指针异常。如果不借助jvmti提供的异常事件进行相应的扩展话，控制台上就不会打印空指针异常信息。其实现原理也很简单，借助jvmti提供的异常事件进行相应的扩展，当jvm捕获到异常时，会回调针对该事件的扩展方法，在该方法体内部调用 printStackTrace 方法，打印异常提示信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;java.lang.ClassNotFoundException: com.github.torlight.jvmtit.App
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     at java.net.URLClassLoader.findClass(URLClassLoader.java:381&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     at java.lang.ClassLoader.loadClass(ClassLoader.java:424&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     at java.lang.ClassLoader.loadClass(ClassLoader.java:411&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:335&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     at java.lang.ClassLoader.loadClass(ClassLoader.java:357&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;java.lang.ClassNotFoundException: com.github.torlight.jvmtit.App
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     at java.net.URLClassLoader.findClass(URLClassLoader.java:381&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     at java.lang.ClassLoader.loadClass(ClassLoader.java:424&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     at java.lang.ClassLoader.loadClass(ClassLoader.java:411&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:335&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     at java.lang.ClassLoader.loadClass(ClassLoader.java:357&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     at sun.launcher.LauncherHelper.checkAndLoadMain(LauncherHelper.java:495&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15 java.lang.NullPointerException: QQQ
16     at com.github.torlight.jvmtit.App.main(App.java:14)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; Hello World!
&lt;span&gt;18&lt;/span&gt; loaded &lt;span&gt;class&lt;/span&gt; name=&lt;span&gt;run in Callback_JVMTI_EVENT_EXCEPTION method
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;  Exception: Ljava/lang/&lt;span&gt;ClassNotFoundException;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; loaded &lt;span&gt;class&lt;/span&gt; name=&lt;span&gt;run in Callback_JVMTI_EVENT_EXCEPTION method
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;  Exception: Ljava/lang/&lt;span&gt;ClassNotFoundException;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; loaded &lt;span&gt;class&lt;/span&gt; name=&lt;span&gt;run in Callback_JVMTI_EVENT_EXCEPTION method
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;  Exception: Ljava/lang/&lt;span&gt;NullPointerException;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; agent onload
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;下面贴出针对jvmti Callback_JVMTI_EVENT_EXCEPTION 事件进行扩展的agent代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这是主 DLL 文件。&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jvmti_evt_ex.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;  7&lt;/span&gt; #include &amp;lt;memory.h&amp;gt;
&lt;span&gt;  8&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt;  9&lt;/span&gt; #include &amp;lt;jvmti.h&amp;gt;
&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11 void printStackTrace(JNIEnv* env, jobject exception) {
 12     jclass throwable_class = (*env).FindClass(&quot;java/lang/Throwable&quot;);
 13     jmethodID print_method = (*env).GetMethodID(throwable_class, &quot;printStackTrace&quot;, &quot;()V&quot;);
 14     (*env).CallVoidMethod(exception, print_method);
 15 }
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; JNICALL Callback_JVMTI_EVENT_EXCEPTION (jvmtiEnv *&lt;span&gt;jvmti_env,
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     JNIEnv*&lt;span&gt; jni_env,
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;    jthread thread,
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;    jmethodID method,
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;    jlocation location,
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;    jobject exception,
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;    jmethodID catch_method,
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;    jlocation catch_location) {
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;loaded class name=%s\n &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;run in Callback_JVMTI_EVENT_EXCEPTION method&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; class_name;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;     jclass exception_class = jni_env-&amp;gt;&lt;span&gt;GetObjectClass(exception);
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     jvmti_env-&amp;gt;GetClassSignature(exception_class, &amp;amp;&lt;span&gt;class_name, NULL);
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exception: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, class_name);    
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;    printStackTrace(jni_env, exception);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; JNICALL Callback_JVMTI_EVENT_Exception_Catch (jvmtiEnv *&lt;span&gt;jvmti_env,
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     JNIEnv*&lt;span&gt; jni_env,
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;    jthread thread,
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;    jmethodID method,
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;    jlocation location,
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;    jobject exception)    {
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; class_name;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;     jclass exception_class = jni_env-&amp;gt;&lt;span&gt;GetObjectClass(exception);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;     jvmti_env-&amp;gt;GetClassSignature(exception_class, &amp;amp;&lt;span&gt;class_name, NULL);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Exception: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, class_name);    
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    printStackTrace(jni_env, exception);    
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt; JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *vm, &lt;span&gt;char&lt;/span&gt; *options, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;reserved){
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     jvmtiEnv *jvmti =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     
&lt;span&gt; 56&lt;/span&gt;     fprintf(stderr,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;agent onload&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; 
&lt;span&gt; 58&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取JVMTI environment&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;     jint erno = vm-&amp;gt;GetEnv((&lt;span&gt;void&lt;/span&gt; **)&amp;amp;&lt;span&gt;jvmti, JVMTI_VERSION_1_1);
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (erno !=&lt;span&gt; JNI_OK) {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         fprintf(stderr, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERROR: Couldn't get JVMTI environment&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; JNI_ERR;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     
&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册功能&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;    jvmtiCapabilities capabilities;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;     (&lt;span&gt;void&lt;/span&gt;)memset(&amp;amp;capabilities, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(jvmtiCapabilities));
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;    &lt;span&gt; capabilities.can_generate_exception_events=1;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt;     jvmtiError error = jvmti-&amp;gt;AddCapabilities(&amp;amp;&lt;span&gt;capabilities);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(error !=&lt;span&gt; JVMTI_ERROR_NONE) {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;         fprintf(stderr, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERROR: Unable to AddCapabilities JVMTI&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;  error;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; 
&lt;span&gt; 76&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置JVM事件 (JVMTI_EVENT_EXCEPTION) 回调&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;    jvmtiEventCallbacks ex_callbacks;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;     ex_callbacks.Exception = &amp;amp;&lt;span&gt;Callback_JVMTI_EVENT_EXCEPTION;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;     error = jvmti-&amp;gt;SetEventCallbacks(&amp;amp;ex_callbacks, (jint)&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(ex_callbacks));
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(error !=&lt;span&gt; JVMTI_ERROR_NONE) {
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;         fprintf(stderr, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ERROR: Unable to SetEventCallbacks JVMTI!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);        
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; error;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置事件通知&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;     error = jvmti-&amp;gt;&lt;span&gt;SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, (jthread)NULL);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(error !=&lt;span&gt; JVMTI_ERROR_NONE) {
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;         fprintf(stderr, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ERROR: Unable to SetEventNotificationMode JVMTI!,the error code=%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,error);
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;  error;
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; 
&lt;span&gt; 92&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; JNI_OK;
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;JNIEXPORT jint JNICALL
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     Agent_OnAttach(JavaVM* vm, &lt;span&gt;char&lt;/span&gt; *options, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;reserved){
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do nothing&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt;         
&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; JNI_OK;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt; JNIEXPORT &lt;span&gt;void&lt;/span&gt;&lt;span&gt; JNICALL
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     Agent_OnUnload(JavaVM *&lt;span&gt;vm){
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do nothing&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt;     
&lt;span&gt;106&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　示例代码和agent代码均已经上传至github上面（链接地址：&lt;a title=&quot;https://github.com/gittorlight/java-other/tree/master/jvmti_evt_ex&quot; href=&quot;https://github.com/gittorlight/java-other/tree/master/jvmti_evt_ex&quot; target=&quot;_blank&quot;&gt;https://github.com/gittorlight/java-other/tree/master/jvmti_evt_ex&lt;/a&gt;），我是用 visual studio 2010 来编译agent的，编译的时候需要根据所下载的jdk是32位还是64位来选择相对应的头文件。我使用的是64位的jdk 1.8，所以使用的是64位的头文件。截图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/112331/201809/112331-20180924130203159-1055216388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　编译agent截图（一）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/112331/201809/112331-20180924130504435-479079391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译agent截图（二）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/112331/201809/112331-20180924130613296-465417498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译agent截图（三）&lt;/p&gt;

&lt;p&gt; 编译完成agent之后，在应用程序的启动参数上面使用-agentpath 参数来加载该agent。以eclipse为例，截图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/112331/201809/112331-20180924131334766-1335582774.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加载agent截图（一）&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/112331/201809/112331-20180924131510978-1138930543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加载agent截图（二）&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/112331/201809/112331-20180924131639429-1501259367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加载agent截图（三）&lt;/p&gt;
</description>
<pubDate>Mon, 24 Sep 2018 14:03:00 +0000</pubDate>
<dc:creator>来自非洲大草原的食人虎</dc:creator>
<og:description>阅读本文前需要了解什么是jvmti，jvmti全称称之为 JVM Tool Interface，有关jvmti更详细的知识，本文不再详细列出。大家可以借助百度来了解有关它更为详尽的内容。 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yql1986/p/9695319.html</dc:identifier>
</item>
<item>
<title>微服务 SpringBoot 2.0（三）：启动剖析之@SpringBootApplication - Java面试必修</title>
<link>http://www.cnblogs.com/itmsbx/p/9696598.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itmsbx/p/9696598.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我原以为就一个注解，背后竟然还有3个 —— Java面试必修&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;引言&lt;/h3&gt;
&lt;p&gt;前面两章我们先后认识了SpringBoot和它的极简配置，为新手入门的学习降低了门槛，会基本的使用后，接下来我们将进一步认识SpringBoot，它为何能做到服务秒开，就来跟随我一起分析SpringBoot运行启动的原理吧。&lt;/p&gt;
&lt;p&gt;启动原理分2章讲解，本章讲解&lt;code&gt;@SpringBootApplication&lt;/code&gt;注解部分，若需了解&lt;a href=&quot;https://www.itmsbx.com/article/13&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;SpringApplication.run&lt;/a&gt;方法部分请点击此处&lt;/p&gt;
&lt;h3&gt;运行启动&lt;/h3&gt;
&lt;h4&gt;工具&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;SpringBoot版本：2.0.4&lt;/li&gt;
&lt;li&gt;开发工具：IDEA 2018&lt;/li&gt;
&lt;li&gt;Maven：3.3 9&lt;/li&gt;
&lt;li&gt;JDK：1.8&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先我们看一段启动代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoApplication {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(DemoApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这不就是个启动类嘛？从字面理解我都知道Spring启动的入口，有啥好看的。可别小瞧了这几行代码&lt;/p&gt;
&lt;h4&gt;开始推理&lt;/h4&gt;
&lt;p&gt;从上面代码来看，&lt;code&gt;@SpringBootApplication&lt;/code&gt; 和 &lt;code&gt;SpringApplication.run&lt;/code&gt;长得很相似，比较诡异，所以我们从这两个开始分析，首先先看注解&lt;/p&gt;
&lt;h5&gt;@SpringBootApplication&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(
    excludeFilters &lt;/span&gt;=&lt;span&gt; {@Filter(
    type &lt;/span&gt;=&lt;span&gt; FilterType.CUSTOM,
    classes &lt;/span&gt;= {TypeExcludeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;}
), @Filter(
    type &lt;/span&gt;=&lt;span&gt; FilterType.CUSTOM,
    classes &lt;/span&gt;= {AutoConfigurationExcludeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;}
)}
)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; SpringBootApplication {
...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;不要被那么多元注解声明所吓到，仔细查看可以看出其中有3个重要的注解&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@SpringBootConfiguration&lt;/li&gt;
&lt;li&gt;@EnableAutoConfiguration&lt;/li&gt;
&lt;li&gt;@ComponentScan&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以我觉得，这3个才是真正的幕后主使，&lt;code&gt;@SpringBootApplication&lt;/code&gt;只是他们找来挡枪口的，他们合体应该等价于&lt;code&gt;@SpringBootApplication&lt;/code&gt;，如下代码正常运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoApplication {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(DemoApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;哈哈，经过查询资料发现，Spring Boot 1.2版之前，真的是由这3个注解出面，之后呢，才隐居幕后，由小喽喽在前面挡枪&lt;/p&gt;
&lt;hr/&gt;&lt;h6&gt;@SpringBootConfiguration&lt;/h6&gt;
&lt;p&gt;首先我们来分析这个，点开看到源码之后我慌了，这特么什么都没有，唯一的疑点在@Configuration。&lt;br/&gt;好吧，还挺会伪装，我们就分析&lt;code&gt;@Configuration&lt;/code&gt;这个注解吧&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用之前spring的思维，我推断这个应该是解决当前Class的XML配置问题，凡是经过该注解修饰的，均被实例化到Spring应用程序上下文中，由spring统一管理生命周期，我说IoC大家应该熟悉了吧。&lt;/li&gt;
&lt;li&gt;举个例子&lt;br/&gt;传统的XML配置对象的写法&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&lt;/span&gt;&lt;span&gt;
       default-lazy-init&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;bean定义&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;userService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;..UserServiceImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    ...
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用&lt;code&gt;@Configuration&lt;/code&gt;之后的写法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringConfiguration{
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserService userService(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserServiceImpl();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;任何一个标注了&lt;code&gt;@Configuration&lt;/code&gt;的Java类定义都是一个JavaConfig配置类。&lt;br/&gt;任何一个标注了@Bean的方法，其返回值将作为一个bean定义注册到Spring的IoC容器，方法名将默认成该bean定义的id。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;表达依赖注入关系层面&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;userService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;..UserServiceImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;propery &lt;/span&gt;&lt;span&gt;name &lt;/span&gt;&lt;span&gt;=&quot;dependencyService&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dependencyService&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;dependencyService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;DependencyServiceImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringConfiguration{
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserService userService(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserServiceImpl(dependencyService());
    }
    
    @Bean
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DependencyService dependencyService(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DependencyServiceImpl();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果一个bean的定义依赖其他bean,则直接调用对应的JavaConfig类中依赖bean的创建方法即可，如上方的&lt;code&gt;dependencyService()&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;h6&gt;@ComponentScan&lt;/h6&gt;
&lt;p&gt;这个注解在Spring中很重要，它对应XML配置中的元素，&lt;code&gt;@ComponentScan&lt;/code&gt;的功能其实就是自动扫描并加载符合条件的组件（比如&lt;code&gt;@Component&lt;/code&gt;和&lt;code&gt;@Repository&lt;/code&gt;等）或者bean定义，最终将这些bean定义加载到IoC容器中。&lt;/p&gt;
&lt;p&gt;我们可以通过&lt;code&gt;basePackages&lt;/code&gt;等属性来细粒度的定制&lt;code&gt;@ComponentScan&lt;/code&gt;自动扫描的范围，如果不指定，则默认Spring框架实现会从声明&lt;code&gt;@ComponentScan&lt;/code&gt;所在类的package进行扫描。&lt;/p&gt;
&lt;p&gt;以前xml中是这么定义的，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;com.platform.fox.html.**.controller&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;com.platform.fox.html.**.repository&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;com.platform.fox.html.**.service&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;com.platform.fox.html.**.wshandler&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注：所以SpringBoot的启动类最好是放在root package下，因为默认不指定&lt;code&gt;basePackages&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;h6&gt;@EnableAutoConfiguration&lt;/h6&gt;
&lt;p&gt;Enable，通常来说我们认为它一定是在开启或者支持什么功能，比如：&lt;code&gt;@EnableScheduling&lt;/code&gt;、&lt;code&gt;@EnableCaching&lt;/code&gt;，所以他们要做的事情应该都是相似的，根据源码判断，简单概括一下就是，借助@Import的支持，收集和注册特定场景相关的bean定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import({AutoConfigurationImportSelector.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; EnableAutoConfiguration {
    String ENABLED_OVERRIDE_PROPERTY &lt;/span&gt;= &quot;spring.boot.enableautoconfiguration&quot;&lt;span&gt;;

    Class&lt;/span&gt;&amp;lt;?&amp;gt;[] exclude() &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    String[] excludeName() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我理解就是要开船了，&lt;code&gt;EnableAutoConfigurationImportSelector&lt;/code&gt;根据名单把水手，舵手、安检员都统一叫过来各就各位。帮助SpringBoot应用将所有符合条件的&lt;code&gt;@Configuration&lt;/code&gt;配置都加载到当前SpringBoot创建并使用的IoC容器。就像一管理员一样&lt;/p&gt;
&lt;p&gt;借助于Spring框架原有的一个工具类：&lt;code&gt;SpringFactoriesLoader&lt;/code&gt;的支持，&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;可以智能的自动配置功效才得以大功告成！&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EnableAutoConfigurationImportSelector&lt;/code&gt;中自动配置的关键方法如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取符合条件的带有Configuration的注解示例类&lt;/span&gt;
        List&amp;lt;String&amp;gt; configurations = SpringFactoriesLoader.loadFactoryNames(&lt;span&gt;this&lt;/span&gt;.getSpringFactoriesLoaderFactoryClass(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getBeanClassLoader());
        Assert.notEmpty(configurations, &lt;/span&gt;&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; configurations;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;SpringFactoriesLoader&lt;br/&gt;所以真正的工作者是&lt;code&gt;SpringFactoriesLoader&lt;/code&gt;，&lt;code&gt;SpringFactoriesLoader&lt;/code&gt;属于Spring框架私有的一种扩展方案，其主要功能就是从指定的配置文件&lt;code&gt;META-INF/spring.factories&lt;/code&gt;加载配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringFactoriesLoader {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; loadFactories(Class&amp;lt;T&amp;gt;&lt;span&gt; factoryClass, @Nullable ClassLoader classLoader) {
        ...
    }


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;String&amp;gt; loadFactoryNames(Class&amp;lt;?&amp;gt;&lt;span&gt; factoryClass, @Nullable ClassLoader classLoader) {
        ....
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;配合&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;使用的话，它更多是提供一种配置查找的功能支持，即根据&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;的完整类名&lt;code&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration&lt;/code&gt;作为查找的Key,获取对应的一组@Configuration类&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1708&quot; data-height=&quot;665&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5190738-55176cc2f041e374.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/5190738-55176cc2f041e374.png&quot; data-original-width=&quot;1708&quot; data-original-height=&quot;665&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;221164&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;spring.factories&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;上图就是从&lt;code&gt;SpringBoot的autoconfigure&lt;/code&gt;依赖包中的&lt;code&gt;META-INF/spring.factories&lt;/code&gt;配置文件中摘录的一段内容，可以很好地说明问题。我从中随机挑取一个类查看源代码&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1046&quot; data-height=&quot;609&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5190738-a6c13e7530313280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/5190738-a6c13e7530313280.png&quot; data-original-width=&quot;1046&quot; data-original-height=&quot;609&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;77398&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;WebMvcAutoConfiguration&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;所以，其底层真正实现是从classpath中搜寻所有的&lt;code&gt;META-INF/spring.factories&lt;/code&gt;配置文件，并将其中&lt;code&gt;org.springframework.boot.autoconfigure.EnableutoConfiguration&lt;/code&gt;对应的配置项通过反射实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@SpringBootApplication&lt;/code&gt;注解说完了，接下来我们来分析&lt;code&gt;SpringApplication.run&lt;/code&gt;方法&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;作者有话说：喜欢的话就请关注&lt;a href=&quot;https://www.itmsbx.com/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Java面试必修&lt;/a&gt; ，请自备水，更多干、干、干货等着你&lt;/p&gt;
</description>
<pubDate>Mon, 24 Sep 2018 12:38:00 +0000</pubDate>
<dc:creator>Java面试必修</dc:creator>
<og:description>前面两章我们先后认识了SpringBoot和它的极简配置，为新手入门的学习降低了门槛，会基本的使用后，接下来我们将进一步认识SpringBoot，它为何能做到服务秒开，就来跟随我一起分析SpringB</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itmsbx/p/9696598.html</dc:identifier>
</item>
<item>
<title>自己动手，写一个分布式系统（附c#代码示例） - 源之缘</title>
<link>http://www.cnblogs.com/yuanchenhui/p/remoteCall.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanchenhui/p/remoteCall.html</guid>
<description>&lt;p&gt;分布式系统有很多成熟的解决方案。如：微软的WCF。WCF太过于复杂，配置也麻烦。其实可以自己动手设计一个小的分布式系统。系统的原理完全在自己掌握之中，可以根据业务随机而变。这里展示远程调用最核心最基本的处理逻辑，其实远程调用并不复杂神秘。&lt;/p&gt;
&lt;p&gt;分布式系统其实是数据流的交换。数据必须快速的从一段传送到另一端，否则系统性能就大打折扣。对于.net，本人设计一个非常优化易于使用的网络库（EasyNetMessage）。使用该库，不需要关心底层细节，所有处理对象是string、byte；发送时，不需要处理分包（几十M的数据也可以一次发送）；收包时，不需要处理粘包。本文所示例代码，就是基于该网络库。本文章实例代码见底部。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实现目标&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;实现一个非常简单的应用   internal int AddCall(int value1, int value2)；就是两个整数相加。调用过程和本地完全一样，只是执行加法操作是在远程服务器实现的。操作非常简单，但是揭示了远程调用的核心处理流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/245753/201809/245753-20180924190821070-1438474728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;处理过程：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a) 数据发送&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;每次函数调用必须有一个唯一标识CallId，这个也是发包的唯一标识；服务端处理完后，返回的结果也带有此标识。通过此标识，将发送端数据和返回数据关联起来了。&lt;/p&gt;
&lt;p&gt;　　发送完数据后，客户端线程要挂起，等待服务器端的处理结果。线程挂起使用ManualResetEvent。并建立起CallId与ManualResetEvent的对应关系。当数据返回时，就能找到对应的ManualResetEvent。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;callid与事件关联&lt;/span&gt;
        Dictionary&amp;lt;&lt;span&gt;int&lt;/span&gt;, ManualResetEvent&amp;gt; _callEventGroup = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;int&lt;/span&gt;, ManualResetEvent&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;callId与返回结果关联&lt;/span&gt;
        Dictionary&amp;lt;&lt;span&gt;int&lt;/span&gt;, NetCallAddAck&amp;gt; _callResultGroup = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;int&lt;/span&gt;, NetCallAddAck&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; AddCall(&lt;span&gt;int&lt;/span&gt; value1, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; value2)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组织发送包&lt;/span&gt;
            NetCallAdd add = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NetCallAdd();
            add.Value1 &lt;/span&gt;=&lt;span&gt; value1.ToString();
            add.Value2 &lt;/span&gt;=&lt;span&gt; value2.ToString();

            MonitorClient client &lt;/span&gt;=&lt;span&gt; GetCurAppClient();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (client == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;socket未连接！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成线程事件，并与CallId关联&lt;/span&gt;
            ManualResetEvent callEvent = &lt;span&gt;new&lt;/span&gt; ManualResetEvent(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (_callEventGroup)
            {
                _callEventGroup.Add(add.CallId, callEvent);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送数据&lt;/span&gt;
            EN_SendDataResult result =&lt;span&gt; _netServer.SendData(client.ClientSocket, add.ToEasyMessage().ToNetPacket());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result !=&lt;span&gt; EN_SendDataResult.ok)
            {
                &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (_callEventGroup)
                {
                    _callEventGroup.Remove(add.CallId);
                }
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;网络发送异常！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待结果&lt;/span&gt;
            callEvent.WaitOne(&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
            _callEventGroup.Remove(add.CallId);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看结果集&lt;/span&gt;
            &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (_callResultGroup)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_callResultGroup.ContainsKey(add.CallId))
                {
                    NetCallAddAck ack &lt;/span&gt;=&lt;span&gt; _callResultGroup[add.CallId];
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;.Parse(ack.Result);
                }
            }

            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有返回结果！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;b）数据返回&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  数据返回后的处理是在另一个线程。数据返回后，先根据CallId查找对应的ManualResetEvent；如果找不到，有可能服务器处理太慢，超时了。&lt;/p&gt;
&lt;p&gt;  先将返回结果存储到哈希数组中，key为CallId。再调用ManualResetEvent的Set函数，唤醒调用端线程。调用端线程根据CallId到哈希表中获取结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnRcvAck(NetCallAddAck addAck)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据callid找到事件&lt;/span&gt;
            ManualResetEvent callEvent = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (_callEventGroup)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_callEventGroup.ContainsKey(addAck.CallId))
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                callEvent &lt;/span&gt;=&lt;span&gt;_callEventGroup[addAck.CallId];
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;结果存放到哈希表中&lt;/span&gt;
            &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (_callResultGroup)
            {
                _callResultGroup.Remove(addAck.CallId);
                _callResultGroup.Add(addAck.CallId, addAck);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置事件为有信号,调用方挂起的线程可以继续执行&lt;/span&gt;
&lt;span&gt;            callEvent.Set();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;进一步说明：&lt;/strong&gt;可以在此基础上，进一步扩展。开发出类似Redis的内存库。客户端的调用也不一定是同步 ，可以采用异步回调的方式处理。其实如果知道处理的原理，可以根据自己的业务做裁剪。只有知其所以然，才能开发出最符合自己业务的系统，才可能进一步优化。&lt;/p&gt;
&lt;p&gt;实例代码&lt;a title=&quot;远程过程实例程序代码&quot; href=&quot;https://download.csdn.net/download/qq_29939347/10684858&quot; target=&quot;_blank&quot;&gt; https://download.csdn.net/download/qq_29939347/10684858&lt;/a&gt; （代码已上传，但是需要审核，最近可能无法下载）&lt;/p&gt;
</description>
<pubDate>Mon, 24 Sep 2018 11:34:00 +0000</pubDate>
<dc:creator>源之缘</dc:creator>
<og:description>分布式系统有很多成熟的解决方案。如：微软的WCF。WCF太过于复杂，配置也麻烦。其实可以自己动手设计一个小的分布式系统。系统的原理完全在自己掌握之中，可以根据业务随机而变。这里展示远程调用最核心最基本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanchenhui/p/remoteCall.html</dc:identifier>
</item>
</channel>
</rss>