<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>django框架--路由系统 - zzzzou</title>
<link>http://www.cnblogs.com/zzzlw/p/9739789.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzzlw/p/9739789.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;一路由系统理解&quot;&gt;一、路由系统理解&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;系统功能：根据用户访问的不同&lt;code&gt;url&lt;/code&gt;，执行对应的视图函数。&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;web&lt;/code&gt;服务器可以根据用户访问的&lt;code&gt;url&lt;/code&gt;地址的不同，返回相应的&lt;code&gt;html&lt;/code&gt;页面，而&lt;code&gt;html&lt;/code&gt;的页面渲染由视图函数处理，这就需要有一个模块负责分析用户访问的&lt;code&gt;url&lt;/code&gt;地址，并根据预先定义的映射规则，将请求分发到不同的视图函数中进一步处理，负责这个工作的模块就是&lt;code&gt;web&lt;/code&gt;框架中的路由系统。路由系统的工作总结起来就是：&lt;strong&gt;制定路由规则，分析&lt;code&gt;url&lt;/code&gt;，分发请求到响应视图函数中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;路由系统的路由功能基于路由表，路由表是预先定义好的&lt;code&gt;url&lt;/code&gt;和视图函数的映射记录，换句话说，可以理解成将&lt;code&gt;url&lt;/code&gt;和视图函数做了绑定，映射关系有点类似一个&lt;code&gt;python&lt;/code&gt;字典:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;url_to_view_dic = {
    '路径1': view_func_1,
    '路径2': view_func_2,
    '路径n': view_func_n,
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;路由表的建立是控制层面，需要在实际业务启动前就准备完毕，即：先有路由，后有业务。&lt;br/&gt;一旦路由准备完毕，业务的转发将会完全遵从路由表的指导：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;去往路径1的request --&amp;gt; 被路由器分发到view_func_1函数处理
去往路径2的request --&amp;gt; 被路由器分发到view_func_2函数处理
去往路径n的request --&amp;gt; 被路由器分发到view_func_n函数处理
...&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;二路由系统功能划分&quot;&gt;二、路由系统功能划分&lt;/h2&gt;
&lt;p&gt;路由系统的本质功能是：&lt;strong&gt;指路&lt;/strong&gt;，针对一次路由请求，返回下一跳转发地址。&lt;br/&gt;任何路由系统都将涵盖至少如下两个核心功能：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路由器的核心功能：(非常重要!!!!)&lt;br/&gt;1、创建路由表（控制层面） ----&amp;gt; 用户定义&lt;br/&gt;2、路由分发（转发层面） ----&amp;gt; django框架自动处理&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;三路由表创建&quot;&gt;三、路由表创建&lt;/h2&gt;
&lt;h3 id=&quot;创建工具&quot;&gt;创建工具&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;django&lt;/code&gt;框架中的工具：&lt;strong&gt;&lt;code&gt;re_path&lt;/code&gt;和&lt;code&gt;path&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;所有的&lt;code&gt;web&lt;/code&gt;请求都将以&lt;code&gt;django&lt;/code&gt;项目目录下的&lt;code&gt;urls.py&lt;/code&gt;文件作为路由分发主入口,所以如果要完成最简单的路由功能，只需要在此文件中预先配置好路由表即可。&lt;code&gt;re_path&lt;/code&gt;是&lt;code&gt;django v1&lt;/code&gt;的工具，&lt;code&gt;path&lt;/code&gt;是&lt;code&gt;django v2&lt;/code&gt;的工具，后者兼容前者。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 项目urls.py文件, 目前两种工具可以任选使用
re_path(r'home/', views.index)
path('articles/&amp;lt;int:id&amp;gt;', views.show_article) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;路由的匹配顺序是&lt;strong&gt;自上而下&lt;/strong&gt;，一旦匹配即执行对应视图函数，便&lt;strong&gt;不再继续匹配&lt;/strong&gt;。&lt;br/&gt;所以路由表条目的顺序很重要，有严格要求的路径应该放前面，宽松要求甚至可以聚合的路径应该放后面。匹配成功后的视图函数以如下形式执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 执行接口: view_func(request, *args, **kw)
# 参数是固定的request对象以及由re_path或path捕获的无名分组/有名分组参数

views.index(request)
views.show_article(request, id)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下是一张简单的路由表配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# urls.py文件

urlpatterns = [
    # 自带后台管理页面路由
    path('admin/', admin.site.urls),
    
    # 新增
    re_path(r'^add/author/$', views.add_author),
    re_path(r'^add/book/$', views.add_book),
    
    # 删除
    re_path(r'delete/author/(\d+)', views.delete_author),
    re_path(r'delete/book/(\d+)', views.delete_book),
    
    # 修改
    re_path(r'edit/author/(\d+)', views.edit_author),
    re_path(r'edit/book/(\d+)', views.edit_book),
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;特别注意1，&lt;code&gt;django&lt;/code&gt;路由系统只会针对&lt;code&gt;url&lt;/code&gt;进行匹配，并不会再额外考虑&lt;code&gt;method&lt;/code&gt;或者其他&lt;code&gt;request&lt;/code&gt;中的属性，这也意味着仅仅只需考虑url即可。（当然，我觉得后续如有需要，可以增加匹配因子，以便做到更精准的匹配）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特别注意2，在浏览器中访问某一个&lt;code&gt;url&lt;/code&gt;，如果路径结尾没有添加&lt;code&gt;/&lt;/code&gt;，在&lt;code&gt;django&lt;/code&gt;框架中会被自动添加结尾的&lt;code&gt;/&lt;/code&gt;。在路由表中，匹配路径的时候要关注&lt;code&gt;/&lt;/code&gt;，即：&lt;code&gt;re_path(r'home/')&lt;/code&gt;，换句话说，可以认为在&lt;code&gt;django&lt;/code&gt;的环境下，路径&lt;code&gt;pathinfo&lt;/code&gt;是必须有后导&lt;code&gt;/&lt;/code&gt;的。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;二级路由&quot;&gt;二级路由&lt;/h3&gt;
&lt;p&gt;二级路由的意思就是把项目urls文件中的路由整理划分，分布到各自的应用目录&lt;code&gt;urls&lt;/code&gt;文件中，以此实现：&lt;br/&gt;1、降低项目&lt;code&gt;urls&lt;/code&gt;路由文件中路由数量，由各自应用&lt;code&gt;urls&lt;/code&gt;路由文件承担&lt;br/&gt;2、解耦整个项目的路由表，出现路由问题的时候可以单独在二级路由表中处理&lt;br/&gt;3、多级路由以树形结构执行查询，在路由数量很大的时候，可以比单路由表有更快的查询速度&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;include&lt;/code&gt;实现二级路由表,二级路由会将在一级路由匹配到的&lt;code&gt;url&lt;/code&gt;截断后再发送给子路由表继续匹配。以如下一级路由表为例，如果服务器收到一个&lt;code&gt;http://www.xxx.com:8080/game/user/add/?name=a&amp;amp;pswd=b&lt;/code&gt;的请求，首先会匹配一级路由表中的&lt;code&gt;game/&lt;/code&gt;并将截断后的&lt;code&gt;user/add/&lt;/code&gt;发送到二级路由表继续匹配。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;re_path(r'game/', include('game_app.urls')),
re_path(r'chat/', include('chat_app.urls')),
re_path(r'vidio/', include('vidio_app,urls'),&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;路由别名&quot;&gt;路由别名&lt;/h3&gt;
&lt;p&gt;因为路由&lt;code&gt;url&lt;/code&gt;会被频繁引用，所以会带来修改时工作量过大的问题，解决办法是启用一个别名来代替&lt;code&gt;url&lt;/code&gt;原始&lt;code&gt;url&lt;/code&gt;，在所有引用的地方使用别名，这样原始&lt;code&gt;url&lt;/code&gt;不论如何修改，都会被正确指向。当然，这个前提是，别名不能发生修改，否则同样要变动所有引用此别名的地方，所以别名的定义非常重要。此外，路由别名的作用域是全局，它是一个全局变量，这也意味着使用路由别名也有重名覆盖的风险。&lt;br/&gt;&lt;strong&gt;使用路由别名的目的是获取原始&lt;code&gt;url&lt;/code&gt;&lt;/strong&gt;，如果原&lt;code&gt;url&lt;/code&gt;有动态部分，需要在解析的时候传入对应参数来明确动态部分。&lt;/p&gt;
&lt;p&gt;路由别名重名覆盖风险的解决方法：&lt;br/&gt;1、在全局&lt;code&gt;urls&lt;/code&gt;中定义每一个二级路由的&lt;code&gt;namespace&lt;/code&gt;&lt;br/&gt;2、在每一个二级路由&lt;code&gt;urls&lt;/code&gt;中定义&lt;code&gt;app_name&lt;/code&gt;&lt;br/&gt;3、在别名定义的时候加上区分前缀如：&lt;code&gt;app01-home&lt;/code&gt;, &lt;code&gt;app02-home&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;别名的使用场景：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 在模板中使用：
{% url '别名' *args, **kw %}

# 在视图函数中使用：
reverse('别名', *args, **kw)&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;动态路由及重定向&quot;&gt;动态路由及重定向&lt;/h3&gt;
&lt;p&gt;动态路由&lt;br/&gt;所谓的动态路由，其实就是聚合大量同类的&lt;code&gt;url&lt;/code&gt;，并用&lt;code&gt;re&lt;/code&gt;规则执行匹配并获取动态数据部分。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# re_path:
re_path(r'articles/(?P&amp;lt;id&amp;gt;\d+)'), show_article)  ---&amp;gt; show_article(request, id=id)

# path:
path('articles/&amp;lt;int:id&amp;gt;', show_article) ---&amp;gt; show_article(request, id=id)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重定向&lt;br/&gt;&lt;code&gt;return redirect(某一个具体网址，可来自于反向解析的结果)&lt;/code&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;四自定义错误页面&quot;&gt;四、自定义错误页面&lt;/h2&gt;
&lt;p&gt;固定流程如下：&lt;br/&gt;&lt;code&gt;settings.py&lt;/code&gt;中&lt;code&gt;DEBUG&lt;/code&gt;改为&lt;code&gt;False&lt;/code&gt;，&lt;code&gt;ALLOWD_HOSTS&lt;/code&gt;改为&lt;code&gt;['*']&lt;/code&gt;&lt;br/&gt;&lt;code&gt;templates&lt;/code&gt;中新建对应的&lt;code&gt;404.html&lt;/code&gt;, &lt;code&gt;500.html&lt;/code&gt;等&lt;br/&gt;&lt;code&gt;urls&lt;/code&gt;中定义:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;handler404 = views.page_not_found
handler500 = views.server_error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;views&lt;/code&gt;中配置对应函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def page_not_found(request):
    return render(request, '404.html')
    
def server_error(request):
    return render(request, '500.html')&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;五图示路由系统在框架中的定位&quot;&gt;五、图示路由系统在框架中的定位&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;每次请求到服务器，执行路由的流程图&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181003145425744-477696618.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;伪代码实现以上图示&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 启动路由分发过程
def route(environ, route_table):
    url = environ.url
    view_func = None
    
    # 遍历路由表
    for map in route_table:
        if url == map[0]:
            view_func= map[1]
            break

    return view_func

# 执行视图函数处理过程
def start_handle(environ, view_func):
    if view_func:
        return view_func(environ)
    else:
        return page_not_found(environ)

# web服务器主循环
def run():
    # 循环处理每一次的请求
    while True:
        # 从tcp中获取当前客户端请求的http字节数据
        request_bytes = server.recv(1024)

        # 根据http协议解析，得到http数据
        request_http_data = http_parse(request_bytes.decode('utf-8'))

        # web框架进一步处理http数据，封装成方便使用的environ对象
        environ = build_environ(request_http_data)

        # 根据当前请求的url，在路由表中找到对应的视图函数 ---&amp;gt; 路由系统的工作界面
        view_func = route(environ, route_table)

        # 启动视图函数，处理当前请求的具体内容, 返回处理结果
        response = start_handle(environ, view_func)

        # 按照http协议拆解web框架封装好的response对象，得到http字符串
        response_http_data = http_encapsulation(response)

        # 发送http字节数据给客户端
        server.send(response_http_data.encode('utf-8'))

if __name__ == '__main__':
    run()
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;六路由系统的进阶想法&quot;&gt;六、路由系统的进阶想法&lt;/h2&gt;
&lt;p&gt;进阶考虑：&lt;br/&gt;路由器收到请求&lt;code&gt;request&lt;/code&gt;后，转发到后端另一台机器上执行，然后使用协程异步，处理其他的&lt;code&gt;reqeust&lt;/code&gt;请求。如果请求得到的响应，再切换回协程，然后执行响应。这样可以实现入口服务器作为所有请求的承接者，然后转发到对应的后面不同业务服务器处理各自的业务，可以把业务分离到不同的机器上，而且此时入口服务器也可以处理并发请求。&lt;br/&gt;&lt;strong&gt;即：多个服务器上均部署&lt;code&gt;django&lt;/code&gt;，多台服务器之间的&lt;code&gt;django&lt;/code&gt;可以相互通信，这样可以实现一个类似服务器集群的效果，可以完成负载均衡和备份的效果。&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1381809/201810/1381809-20181003153643168-2008535193.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 07:40:00 +0000</pubDate>
<dc:creator>zzzzou</dc:creator>
<og:description>[TOC] 一、路由系统理解 系统功能：根据用户访问的不同 ，执行对应的视图函数。 服务器可以根据用户访问的 地址的不同，返回相应的 页面，而 的页面渲染由视图函数处理，这就需要有一个模块负责分析用户</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zzzlw/p/9739789.html</dc:identifier>
</item>
<item>
<title>[C++一本通-图论算法] 例4-4 最小花费 - _tham</title>
<link>http://www.cnblogs.com/tham/p/9739899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tham/p/9739899.html</guid>
<description>&lt;h3 id=&quot;题目描述&quot;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;在n个人中，某些人的银行账号之间可以互相转账。这些人之间转账的手续费各不相同。给定这些人之间转账时需要从转账金额里扣除百分之几的手续费，请问A最少需要多少钱使得转账后B收到100元。&lt;/p&gt;
&lt;h3 id=&quot;输入输出格式&quot;&gt;输入输出格式&lt;/h3&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;输入格式：&lt;/h4&gt;
&lt;p&gt;第一行输入两个正整数n,m，分别表示总人数和可以互相转账的人的对数。&lt;br/&gt;以下m行每行输入三个正整数x,y,z，表示标号为x的人和标号为y的人之间互相转账需要扣除z%的手续费 (z&amp;lt;100)。&lt;br/&gt;最后一行输入两个正整数A,B。数据保证A与B之间可以直接或间接地转账。&lt;/p&gt;
&lt;h4 id=&quot;输出格式&quot;&gt;输出格式：&lt;/h4&gt;
&lt;p&gt;输出A使得B到账100元最少需要的总费用。精确到小数点后8位。&lt;/p&gt;
&lt;h3 id=&quot;输入输出样例&quot;&gt;输入输出样例&lt;/h3&gt;
&lt;h4 id=&quot;输入样例1&quot;&gt;输入样例#1：&lt;/h4&gt;
&lt;p&gt;3 3&lt;br/&gt;1 2 1&lt;br/&gt;2 3 2&lt;br/&gt;1 3 3&lt;br/&gt;1 3&lt;/p&gt;
&lt;h4 id=&quot;输出样例1&quot;&gt;输出样例#1：&lt;/h4&gt;
&lt;p&gt;103.07153164&lt;/p&gt;
&lt;h3 id=&quot;数据范围说明&quot;&gt;数据范围说明&lt;/h3&gt;
&lt;p&gt;1&amp;lt;=n&amp;lt;=2000&lt;/p&gt;
&lt;h3 id=&quot;解题思路&quot;&gt;解题思路&lt;/h3&gt;
&lt;p&gt;这一题数据较大，所以用Dijkstra，&lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt; 实现。由于从一个账户转钱到另外一个账户的手续费不同，所以我们视它们为边的权值。先求出去掉手续费后所遗留下的钱，并在寻找路径时尽量去找能留下更多钱的路径（注意在起始点时要给它赋值为1），并将权值相乘，最后拿100除以权值相乘得到的最大值，输出答案。&lt;/p&gt;
&lt;h4 id=&quot;实现代码&quot;&gt;实现代码&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
using namespace std;

const int M = 2002;
int n,m,a,b,k;
double map[M][M],minn;
double dis[M];
bool vis[M];

void dijkstra(int start)
{
    for(int i=1; i&amp;lt;=n; i++)
        dis[i]=map[start][i];
    vis[start]=true;
    dis[start]=1;//必须进行赋值1,因为若进行更改将使用乘法(0*every==0) 
    for(int i=1; i&amp;lt;n; i++)
    {
        minn=0;
        for(int j=1; j&amp;lt;=n; j++)
            if(!vis[j]&amp;amp;&amp;amp;dis[j]&amp;gt;minn)   //寻找剩余金额最大的 
                minn=dis[j],k=j;
        vis[k]=true;
        if(k==b) break;//结束标志
        for(int q=1; q&amp;lt;=n; q++)
            if(!vis[q]&amp;amp;&amp;amp;dis[q]&amp;lt;dis[k]*map[k][q])
                dis[q]=dis[k]*map[k][q];//进行松弛
    }
}

int main()
{
    double z;
    scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m);
    for(int i=1,x,y; i&amp;lt;=m; i++)
    {
        cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y&amp;gt;&amp;gt;z;
        map[x][y]=map[y][x]=(100-z)/100;//表示是原金额的百分之几
    }
    cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
    dijkstra(a);
    printf(&quot;%.8lf\n&quot;,100/dis[b]);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 03 Oct 2018 07:34:00 +0000</pubDate>
<dc:creator>_tham</dc:creator>
<og:description>题目描述 在n个人中，某些人的银行账号之间可以互相转账。这些人之间转账的手续费各不相同。给定这些人之间转账时需要从转账金额里扣除百分之几的手续费，请问A最少需要多少钱使得转账后B收到100元。 输入输</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tham/p/9739899.html</dc:identifier>
</item>
<item>
<title>透明代理、正向代理、反向代理的区别说明 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9739870.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9739870.html</guid>
<description>&lt;p&gt;代理方式有三种：正向代理、透明代理和反向代理。反向代理比较容易理解，毕竟是运维必掌握的知识，但是对正向代理、透明代理可能比较模糊，所以主要解惑正向代理和透明代理。&lt;/p&gt;
&lt;h2 id=&quot;透明代理&quot;&gt;透明代理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;透明代理&lt;/strong&gt;(transparent proxy)，看名字就知道这个代理服务器是透明的，透明代理其实也叫做内网代理(inline proxy)、拦截代理(intercepting proxy)以及强制代理(force proxy)。透明代理和正向代理的行为很相似，但细节上有所不同。透明代理将拦截客户端发送的请求，拦截后自己代为访问服务端，获取响应结果后再由透明代理交给客户端。一般公司内的上网行为管理软件就是透明代理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201810/733013-20181003151727019-1538915633.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如，客户端要访问www.baidu.com，如果是正向代理的方式，客户端会指明它要交给正向代理服务，就像路由中说要交给网关一样。如果是透明代理的方式，则是发送出去，然后被透明代理拦截，客户端以为请求的这个过程是自己完成的，并不知道是透明代理完成的。&lt;/p&gt;
&lt;h2 id=&quot;正向代理&quot;&gt;正向代理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;正向代理&lt;/strong&gt;(forward proxy)，看名字就知道是转发代理。客户端将请求转发给正代服务器，正向代理服务器再负责转发给服务端，响应时服务端先响应给正向代理服务器，正向代理服务器再转发给对应的客户端。也就是说，正向代理可以但不限于为局域网内客户端做代理，它扮演的角色类似于NAT。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201810/733013-20181003151816593-900961957.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实FQ上网时配置的代理目标就是正向代理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201810/733013-20181003152316798-589795454.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;正向代理和透明代理的区别&quot;&gt;正向代理和透明代理的区别&lt;/h2&gt;
&lt;p&gt;正向代理和透明代理的区别，细分起来还是有不少的，但主要几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;正向代理时，客户端明确指明请求要交给正向代理服务，也就是说要设置代理。而透明代理对客户端是透明的，客户端不知道更不用设置透明代理，但是客户端发出去的请求都会被透明代理拦截。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;正向代理为了实现某些额外的需求，有可能会修改请求报文，但按照RFC文档的要求，透明代理不会修改请求报文。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;正向代理可以内网也可以外网，但透明代理都是内网。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;反向代理&quot;&gt;反向代理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;反向代理&lt;/strong&gt;是为服务端转发请求，客户端将请求发送至反向代理服务器，反向代理服务器再将请求转发给真正的服务器以处理请求，响应时后端真正的服务器将处理结果发送给反向代理，再由反向代理构建响应并响应给客户端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201810/733013-20181003151855571-1575788792.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 07:25:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>代理方式有三种：正向代理、透明代理和反向代理。反向代理比较容易理解，毕竟是运维必掌握的知识，但是对正向代理、透明代理可能比较模糊，所以主要解惑正向代理和透明代理。 透明代理 透明代理 (transpa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9739870.html</dc:identifier>
</item>
<item>
<title>【朝花夕拾】Android性能优化篇之（一）序言及JVM篇 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/9739836.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/9739836.html</guid>
<description>&lt;p&gt;&lt;strong&gt;序言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;笔者从事Anroid开发有些年头了，深知掌握Anroid性能优化方面的知识的必要性，这是一个程序员必须修炼的内功。在面试中，它是面试官的挚爱，在工作中，它是代码质量的拦路虎，其重要性可见一斑。在团队中，性能优化的工作又往往由经验丰富的老师傅来完成，可见要做好性能优化，绝不是一件容易的事情。&lt;/p&gt;
&lt;p&gt;       性能优化方面涉及的知识点比较广，有理论基础知识，也有实际操作技能，笔者将通过一系列的文章来进行整理，将主要包括Java虚拟机、内存分配、垃圾回收，android虚拟机、进程管理、内存优化、内存泄漏，常用内存分析及优化工具介绍等。由于笔者水平和经验有限，也是在边研究边整理，有不当之处，请不吝赐教。&lt;/p&gt;
&lt;p&gt;        当前系列内容已完成如下篇章：&lt;/p&gt;
&lt;p&gt;      &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/andy-songwei/p/9739836.html&quot;&gt;【朝花夕拾】Android性能优化篇之（一）序言及JVM篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/andy-songwei/p/9291186.html&quot;&gt;【朝花夕拾】Android性能优化篇之（二）Java内存分配&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/andy-songwei/p/songzheweiwang.html&quot;&gt;【朝花夕拾】Android性能优化篇之（三）Java内存回收&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/andy-songwei/p/9721337.html&quot;&gt;【朝花夕拾】Android性能优化篇之（四）Apk打包&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        之所以在讲内存之前先介绍JVM，是因为JVM就像盘古一样开天辟地，在机器上开辟了一个虚拟的空间，然后才有了java生存的土壤。该系列文章的主角——内存就是JVM中的一部分。同时，这也是中高级程序员，架构师，系统调优师等职位所必须要了解甚至深入掌握的知识点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、什么是JVM？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       咱们这里借鉴百度百科的解释：&lt;/p&gt;
&lt;p&gt;       JVM是Java Virtual Machine 的缩写，即Java虚拟机，它是一种用于计算设备的规范，通过在实际的计算机上仿真模拟各种计算机功能来实现，可以简单理解为，它是一个在实际计算机中虚构出来的寄生计算机。Java源文件经过编译器编译成.class文件（字节码文件）后，由JVM来执行。JVM拥有一套支持java字节码文件(.class文件)执行的环境，可以将.class文件解释成具体平台上的机器指令并执行。Java程序只需要生成.class文件，即可以在任何装有JVM的设备上运行，而不需要理会具体操作系统平台相关的信息。此时的JVM就像一个翻译官一样连接连接着.class文件和系统平台。Java的这个特性叫做平台无关性，实现了“一次编译，到处运行”，JVM就是实现Java这个功能的大功臣。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、JDK,JRE,JVM是什么关系？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       如下截图为JDK安装包结构&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://images2018.cnblogs.com/blog/472002/201807/472002-20180710192849670-1670402420.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;  1、JDK&lt;/p&gt;
&lt;p&gt;      Java Development Kit 的缩写，即 Java开发工具包，提供了开发java程序所需要的基本条件。在上图JDK安装包截图的红色边框中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bin：最主要包含了编辑器javac.exe，功能是将java源文件编译为.class文件。&lt;/li&gt;
&lt;li&gt;include：包含了Java和JVM交互用的头文件。&lt;/li&gt;
&lt;li&gt;lib：包含了ava开发所需的类库。&lt;/li&gt;
&lt;li&gt;jre：为Java运行环境。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  2、JRE&lt;/p&gt;
&lt;p&gt;       Java Runtime Environment的缩写，即Java运行环境，下图为JRE文件夹的内容。注意，JRE是运行环境，而不是开发环境。&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2018.cnblogs.com/blog/472002/201807/472002-20180710194013596-1694376228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  3、JVM&lt;/p&gt;
&lt;p&gt;        执行.class文件。&lt;/p&gt;
&lt;p&gt;  4、结论&lt;/p&gt;
&lt;p&gt;        这三者的关系可以通过下图(摘自某网站)来理解：JDK包含了JRE,JRE又包含了JVM(对于比较懒得童鞋，可以先记住这个结论)。图中提到的Java开发工具，集成有类库和编译工具，只需关联jre即可。                &lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;http://img1.ph.126.net/A2iWlmXbFe6tSz2rRGkz-A==/727331339920439686.jpg&quot; alt=&quot;JDK、JRE、JVM三者的区别与联系 - 以德糊人 - ——挨踢民工 Playkid——&quot;/&gt; &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、JVM执行Java程序的流程 &lt;/strong&gt;       &lt;/p&gt;
&lt;p&gt;       下图显示了JVM在jiava程序工作流中的位置，可以结合前面的内容来看。&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/472002/201807/472002-20180726185841044-1267282086.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       实际上JVM的执行过程中，主要做了三个工作：（1）加载.class文件；（2）管理并分配内存（推荐阅读：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/andy-songwei/p/9291186.html&quot;&gt;【朝花夕拾】Android性能优化篇之（二）Java内存分配&lt;/a&gt;）；（3）执行垃圾回收（推荐阅读：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/andy-songwei/p/songzheweiwang.html&quot;&gt;【朝花夕拾】Android性能优化篇之（三）Java内存回收&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;       一个JVM实例对应一个独立运行的Java程序，是属于进程级别的，也有自己的生命周期：&lt;/p&gt;
&lt;p&gt;  1、启动&lt;/p&gt;
&lt;p&gt;        当启动一个Java程序的时候，就产生了一个JVM实例。我们还记得Java的入口函数 public static void main(String[] args)吗？每个拥有该函数的.class都可以作为JVM实例运行的起点。&lt;/p&gt;
&lt;p&gt;  2、运行&lt;/p&gt;
&lt;p&gt;        main()作为起点，启动主线程，其他任何线程都在该线程中启动。JVM有两种线程：User Thread（用户线程）和Daemon Thread（守护线程：为用户线程服务的线程），main()线程为用户线程，而守护线程通常由JVM自己使用。&lt;/p&gt;
&lt;p&gt;  3、消亡&lt;/p&gt;
&lt;p&gt;        当程序中的所有用户线程都终止时，JVM才会退出，守护线程无线程需要服务了，也就跟着退出了历史的舞台。若安全管理器允许，程序也可以使用Runtime或者System.exit()来退出。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、JVM架构及工作原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://images2018.cnblogs.com/blog/472002/201807/472002-20180726184123382-315796575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       上图更详细地展示了JVM的架构，由图可知，JVM主要是划分为三个子系统 ：（1）类加载器子系统 （2）运行时数据区 （3）执行引擎 和Java本地接口、本地方法库。&lt;/p&gt;
&lt;p&gt;  1、类加载器子系统(Class Loader SubSystem)&lt;/p&gt;
&lt;p&gt;       Java的动态类加载功能由该子系统处理，当它在运行时（不是编译时）首次引用一个类时，它加载、链接并初始化该类文件(.class文件)。&lt;/p&gt;
&lt;p&gt;    （1）加载(Loading)&lt;/p&gt;
&lt;p&gt;        类的加载在此组件中完成，加载过程主要由下面三个加载器实现：&lt;/p&gt;
&lt;p&gt;        1）启动类加载器(BootStrap class Loader)。负责从启动类路径中加载类，无非就是rt.jar。这个加载器会被赋予最高优先级。&lt;/p&gt;
&lt;p&gt;        2）扩展类加载器(Extension class Loader)。负责加载ext目录(jre\lib)内的类。&lt;/p&gt;
&lt;p&gt;        3）应用程序类加载器(Application class Loader)。负责加载应用程序级别类路径，涉及到路径的环境变量等。&lt;/p&gt;
&lt;p&gt;        这三个类加载器会遵循委托层次算法(Delegation Hierarchy Algorithm)加载类文件。&lt;/p&gt;
&lt;p&gt;    （2）链接(Linking)&lt;/p&gt;
&lt;p&gt;        该过程主要完成以下三个步骤：&lt;/p&gt;
&lt;p&gt;        1）校验(Verify)。字节码校验器会校验生成的字节码是否正确，如果校验失败，我们会得到校验错误。&lt;/p&gt;
&lt;p&gt;        2）准备(Prepare)。分配内存并初始化默认值给所有的静态变量。&lt;/p&gt;
&lt;p&gt;        3）解析(Resolve)。所有符号内存引用被方法区（Method Area）的原始引用所替代。&lt;/p&gt;
&lt;p&gt;    （3）初始化(Initialization)&lt;/p&gt;
&lt;p&gt;       这是类加载的最后阶段，这里所有的静态变量会赋初始值，并且静态块将被执行。&lt;/p&gt;
&lt;p&gt;  2、运行时数据区(Runtime Data Area)&lt;/p&gt;
&lt;p&gt;       该部分将在后续的文章（&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/andy-songwei/p/9291186.html&quot;&gt;【朝花夕拾】Android性能优化篇之（二）Java内存分配&lt;/a&gt;）中详细讲述，这里不做赘述。&lt;/p&gt;
&lt;p&gt;  3、执行引擎(Execution Engine)。&lt;/p&gt;
&lt;p&gt;        分配给运行时数据区的字节码将由执行引擎执行，执行引擎读取字节码并逐段执行。它包含了如下三个部分：解释器、编译器、垃圾回收器。&lt;/p&gt;
&lt;p&gt;    （1）解释器(interpreter)。&lt;/p&gt;
&lt;p&gt;        解释器能够快速地解释字节码，但执行却很慢。它的一个缺点就是，当一个方法被调用多次，每次都需要重新解释。&lt;/p&gt;
&lt;p&gt;    （2）JIT编译器。&lt;/p&gt;
&lt;p&gt;        JIT编译器消除了解释器的缺点，执行引擎利用解释器转换字节码，但如果是重复的代码，则使用JIT编译器将全部字节码编译成本机代码，本机代码将直接用于重复的方法调用，这样提高了系统的性能。它的工作由下面4个工具协同完成：&lt;/p&gt;
&lt;p&gt;        1）中间代码生成器。负责生成中间代码。&lt;/p&gt;
&lt;p&gt;        2）代码优化器。负责优化上面生成的中间代码。&lt;/p&gt;
&lt;p&gt;        3）目标代码生成器。负责生成机器代码或本机代码。&lt;/p&gt;
&lt;p&gt;        4）探测器(Profiler)。一个特殊的组件，负责寻找被多次调用的方法。&lt;/p&gt;
&lt;p&gt;    （3）垃圾回收器。&lt;/p&gt;
&lt;p&gt;       搜集并删除未引用的对象。可以通过调用“System.gc()”来触发垃圾回收，但并不保证会确实进行垃圾回收。JVM的垃圾回收只收集那些由new关键字创建的对象。所以，如果不是用new创建的对象，你可以使用finalize函数来执行清理。&lt;/p&gt;
&lt;p&gt;  4、Java本地接口(JNI,Native Method Interface Interface)&lt;/p&gt;
&lt;p&gt;       JNI会与本地方法库进行交互并提供执行引擎所需的本地库。&lt;/p&gt;
&lt;p&gt;  5、本地方法库(Native Method Library)&lt;/p&gt;
&lt;p&gt;      它是一个执行引擎的本地库集合。 &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、参考资料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       本文主要参考了如下内容（吃水不忘挖井人嘛，要尊重原作者）  &lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;https://www.cnblogs.com/sunada2005/p/3577799.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/sunada2005/p/3577799.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       &lt;a href=&quot;https://baike.baidu.com/item/JVM/2902369?fr=aladdin&quot; target=&quot;_blank&quot;&gt;https://baike.baidu.com/item/JVM/2902369?fr=aladdin&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;       最后推荐一本术，周志明著的《深入理解Java虚拟机——JVM高级特性与最佳实践》，业内评价很高，口碑非常好。&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 07:12:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>android性能优化问题一直是android开发者遇到的难点之一。性能优化包含的内容广而且比较深，内存的分配、管理、回收、溢出、优化，android进程机制，各种性能优化工具的使用，电量，界面流畅度</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andy-songwei/p/9739836.html</dc:identifier>
</item>
<item>
<title>为什么程序员需要知道互联网行业发展史 - kid551</title>
<link>http://www.cnblogs.com/kid551/p/9739776.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kid551/p/9739776.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/672506/201810/672506-20181003143600099-1715735321.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7.136690647482&quot;&gt;
&lt;p&gt;相关声明：写这篇文章绝不是为了抹黑《极客时间》，相反我相当看好这个产品，并愿意为它的成长贡献一份自己的苦药。在《极客时间》刚一推出时，我便写了文章《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247483998&amp;amp;idx=1&amp;amp;sn=acb416bb9f336d7cea1e66c7ba86d260&amp;amp;chksm=ec20e5e2db576cf4ddf72e51c295e562a1a0d62389c1ce157a60d093828fb32255a58a80cc0b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;「极客时间」带来的社区价值思考&lt;/a&gt;》来论述我看好它的原因。《极客时间》的很多专栏我都购买过，如果是纯黑，犯不着花费这么多钱去囤积专栏。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;《极客时间》上有一款很异样的专栏，叫做《技术与商业案例解读》。放在满是技术干货的专栏中间，这个专栏显得异常刺眼。查看其购买量，果不其然，也只有可怜的3000多订阅。相比于其他动则上万的专栏，实在是可怜。&lt;/p&gt;
&lt;p&gt;个人感觉，这样惨败的战绩不是因为作者飞总写出来的文章质量有问题，而是因为飞总的这个专栏被运营团队带偏了，没有让广大的技术人员认识到其真正的价值所在。整个感觉就是凉凉了……（心疼飞总一秒）&lt;/p&gt;
&lt;p&gt;飞总的专栏先是被取名为《大航海时代》，后来又改为《技术与商业案例解读》，说实话真的让人不知所云，也提不起兴致。试问，如果是一堆商业案例的讲述，那和说评书的说书先生有何不同？我一个写代码的技术人为什么要购买一个说书人的专栏？！&lt;/p&gt;
&lt;p&gt;所以，这样的标题、定位和宣传之下，这个专栏不凉凉也难啊。&lt;/p&gt;
&lt;p&gt;但飞总的专栏真的是做这个事情的吗？&lt;/p&gt;
&lt;p&gt;古语讲：读史使人明智，理由何在？无非是通过大量的历史事件的追溯和思考，总结出真实的不确定世界中，那些不变的、隐藏的规律。进而用这些规律来指导自己的决策、布局和人生规划。&lt;/p&gt;
&lt;p&gt;技术人员一般来讲都是理工科出生，基本没受过什么正经的人文训练。所以在“宏观视野”这块，是知道其重要却又无奈于能力之脆弱的短板。&lt;/p&gt;
&lt;p&gt;或许有人会说，要宏观视野干啥？我又不是CEO，也不是CTO，我管那么多干嘛？！管好自己的一亩三分地，把代码写好（talk is cheap, show me the code），才是本分、是干货、是脚踏实地。谈这些视野，都是虚的，没用。&lt;/p&gt;
&lt;p&gt;Okay，那我们可以回顾一下近几年头条、抖音的爆发，以及这几天腾讯的被重组。请问你能否看出它们的共性以及与你的关系所在？&lt;/p&gt;
&lt;p&gt;我在我的文章《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484537&amp;amp;idx=1&amp;amp;sn=d1d63e7ea9c7c637e37da2cfdb473a1b&amp;amp;chksm=ec20e3c5db576ad36ebaa14b8a6e31eb5de31bf668411b607eaa1ff579c4eb2c22cde5d35e00&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;是大家突然变low了吗？&lt;/a&gt;》里面分析过，头条、抖音的爆发，其本质是“互联网的同质竞争”导致大家不得不去开坑三四线城市，以至于让互联网的&lt;strong&gt;主流人群&lt;/strong&gt;，从原来一二线城市的精英阶层变成了三四线城市的草根人群。主流人群不一样了，试问，你所开发的产品的定位还固定不变，哪有不死的道理？都说头条low、抖音low，为什么它们的用户增量还那么好？因为增加的用户量都是三四线的草根人群啊！&lt;/p&gt;
&lt;p&gt;Okay，这时候你说，我一技术人员，这些跟我没关系。那等到你所在公司因为服务了错误的人群而导致不得不裁员降薪时，请问这时候和你有没有关系？！&lt;/p&gt;
&lt;p&gt;再看腾讯，去年的时候还如日中天赞誉满堂，为何在今年一下子就被万夫所指？！究其原因，不是说这些问题之前不存在，而是这些在腾讯的盛世之下，是不会被人关注的。甚至，盛世之下，你越是去关心一个公司的阴影部分，越是会被指责为鸡蛋里挑骨头。&lt;/p&gt;
&lt;p&gt;可是，当今年因为游戏版号问题导致腾讯神话破灭时，大家便有了更多的兴致去关心当年神话之下的阴影部分有哪些细节。于是，一个个地扒开来看，哇~千疮百孔啊！于是才有了知乎的热文《腾讯当下的技术建设是否落后于同体量的公司？》，以及腾讯在国庆前的被迫重组。&lt;/p&gt;
&lt;p&gt;Okay，你继续把持你的观点，“我一技术人员，关心什么宏观视野”。那请问，如果你就在腾讯，却完全不知道从哪些方面去考察公司，完全没有意识在公司的盛世之下，依然该细密地检查阴影部分的细密细节，请问，你的饭碗下的米饭都已经腐烂了，还和你没有关系吗？！&lt;/p&gt;
&lt;p&gt;又比如，你原本想要锻炼你的数据分析能力、锻造人工智能的技艺，直接冲着BAT的腾讯冲过去，请问你会不会发现自己其实被坑了呢？！因为，就像飞总文章《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5OTM3MjMyNA==&amp;amp;mid=2247485590&amp;amp;idx=1&amp;amp;sn=822c49b56629c403b398ae71784be579&amp;amp;chksm=ec96d2dddbe15bcb6254acf14dabe2489029d36f499ca5e5367510f047d8c71935907e1b5fb7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;深夜惊闻，腾讯机构为什么突然大重组？&lt;/a&gt;》里所讨论的，如果这家公司的核心盈利业务，并不需要牢牢地依靠技术支撑，只需要靠着已有的资源壁垒躺着捡钱，那这家公司怎么可能会往你向往的技术方向倾注资源呢？！&lt;/p&gt;
&lt;p&gt;请问，你有能力识别出这些潜在的关乎饭碗的问题吗？！请问你敢说这些技能，没有写代码重要吗？！&lt;/p&gt;
&lt;p&gt;那接下来的问题便是：如何锻炼？如何学会这些技能？&lt;/p&gt;
&lt;p&gt;那不就得靠一个个地去回顾技术历史、剖析商业上的陷阱和坑么？！而这些事情是谁做的？！不就是飞总的专栏所做的么？！&lt;/p&gt;
&lt;p&gt;如此重要的“关乎饭碗的方向性指导”，却被轻飘飘地冠以一个“商业案例分析”，实在令人唏嘘。说句狂妄的话，《极客时间》团队并没有真正明白、吃透飞总专栏的价值所在。因为他们从来没有从我上述的切入点去宣传、打造这个专栏。而上述这些切入点，个个都是技术人员所关注的痛点、恐惧点，哪有不买账的道理？！&lt;/p&gt;
&lt;p&gt;只是，这个轻飘飘的“商业案例解读”将大家带入了根本性的认知错误，实在令人伤心。&lt;/p&gt;




&lt;p&gt;&lt;strong&gt;近期回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484537&amp;amp;idx=1&amp;amp;sn=d1d63e7ea9c7c637e37da2cfdb473a1b&amp;amp;chksm=ec20e3c5db576ad36ebaa14b8a6e31eb5de31bf668411b607eaa1ff579c4eb2c22cde5d35e00&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;是大家突然变low了吗？&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484529&amp;amp;idx=1&amp;amp;sn=fe3fc746cd5e7487e2285dc99b3b5335&amp;amp;chksm=ec20e3cddb576adba9051c4f1b235ecea46ab4f42370667dc9e8befe46c4513e1bbc7b6a1ae2&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;至暗时刻&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484523&amp;amp;idx=1&amp;amp;sn=6a00789147f7f09276f6ae059790c94b&amp;amp;chksm=ec20e3d7db576ac19d0135cda2e613d3ca9a72a3f4d067062d0fe177e06992f2e38959550500&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;代号vangogh&lt;/a&gt;》&lt;/p&gt;

&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果你喜欢我的文章或分享，请长按下面的二维码关注我的微信公众号，谢谢！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/672506/201810/672506-20181003144054880-1795546052.jpg&quot; alt=&quot;&quot; width=&quot;588&quot; height=&quot;294&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;h3&gt;   &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;更多信息交流和观点分享，可加入知识星球：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/672506/201810/672506-20181003144152181-734118274.png&quot; alt=&quot;&quot; width=&quot;626&quot; height=&quot;386&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 06:43:00 +0000</pubDate>
<dc:creator>kid551</dc:creator>
<og:description>相关声明：写这篇文章绝不是为了抹黑《极客时间》，相反我相当看好这个产品，并愿意为它的成长贡献一份自己的苦药。在《极客时间》刚一推出时，我便写了文章《「极客时间」带来的社区价值思考》来论述我看好它的原因</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kid551/p/9739776.html</dc:identifier>
</item>
<item>
<title>树状数组详解 - Xenny</title>
<link>http://www.cnblogs.com/xenny/p/9739600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xenny/p/9739600.html</guid>
<description>&lt;p&gt;&lt;span&gt;先来看几个问题吧。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1.什么是树状数组？&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;顾名思义，就是用数组来模拟树形结构呗。那么衍生出一个问题，为什么不直接建树？答案是没必要，因为树状数组能处理的问题就没必要建树。和Trie树的构造方式有类似之处。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2.树状数组可以解决什么问题&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;可以解决大部分基于区间上的更新以及求和问题。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3.树状数组和线段树的区别在哪里&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;树状数组可以解决的问题都可以用线段树解决，这两者的区别在哪里呢？树状数组的系数要少很多，就比如字符串模拟大数可以解决大数问题，也可以解决1+1的问题，但没人会在1+1的问题上用大数模拟。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4.树状数组的优点和缺点&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;修改和查询的复杂度都是O(logN)，而且相比线段树系数要少很多，比传统数组要快，而且容易写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点是遇到复杂的区间问题还是不能解决，功能还是有限。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;二叉树大家一定都知道，如下图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181003121208845-81274925.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果每个父亲都存的是两个儿子的值，是不是就可以解决这类区间问题了呢。是的没错，但是这样的树形结构，叫做线段树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那真的的树形结构是怎样的，和上图类似，但省去了一些节点，以达到用数组建树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181003121604644-268531484.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;黑色数组代表原来的数组（下面用A[i]代替），红色结构代表我们的树状数组(下面用C[i]代替)，发现没有，每个位置只有一个方框，令每个位置存的就是子节点的值的和，则有&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;C[1] = A[1];&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;C[2] = A[1] + A[2];&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;C[3] = A[3];&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;C[4] = A[1] + A[2] + A[3] + A[4];&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;C[5] = A[5];&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;C[6] = A[5] + A[6];&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;C[7] = A[7];&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;C[8] = A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8];&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;可以发现，这颗树是有规律的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;C[i] = A[i - 2&lt;sup&gt;k&lt;/sup&gt;+1] + A&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;[i - 2&lt;sup&gt;k&lt;/sup&gt;+2] + ... + A[i];   //k为i的二进制中从最低位到高位连续零的长度&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;例如i = 8(1000)时候，k = 3，可自行验证。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个怎么实现求和呢，比如我们要找前7项和，那么应该是&lt;/span&gt;&lt;span&gt;SUM = C[7] + C[6] + C[4];&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而根据上面的式子，容易的出&lt;strong&gt;SUM&lt;sub&gt;i&lt;/sub&gt; = C[i] + C[i-2&lt;sup&gt;k1&lt;/sup&gt;] + C[(i - 2&lt;sup&gt;k1&lt;/sup&gt;) - 2&lt;sup&gt;k2&lt;/sup&gt;] + .....；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实树状数组就是一个二进制上面的应用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在新的问题来了2^k该怎么求呢，不难得出2^k = i&amp;amp;(i^(i-1));但这个还是不好求出呀，前辈的智慧就出来了，2^k = i&amp;amp;(-i);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里利用的负数的存储特性，负数是以补码存储的，对于整数运算 x&amp;amp;(-x)有&lt;br/&gt;       &lt;span&gt;●&lt;/span&gt; 当x为0时，即 0 &amp;amp; 0，结果为0；&lt;br/&gt;       ●当x为奇数时，最后一个比特位为1，取反加1没有进位，故x和-x除最后一位外前面的位正好相反，按位与结果为0。结果为1。&lt;br/&gt;       ●当x为偶数，且为2的m次方时，x的二进制表示中只有一位是1（从右往左的第m+1位），其右边有m位0，故x取反加1后，从右到左第有m个0，第m+1位及其左边全是1。这样，x&amp;amp; (-x) 得到的就是x。 &lt;br/&gt;       ●当x为偶数，却不为2的m次方的形式时，可以写作x= y * (2^k)。其中，y的最低位为1。实际上就是把x用一个奇数左移k位来表示。这时，x的二进制表示最右边有k个0，从右往左第k+1位为1。当对x取反时，最右边的k位0变成1，第k+1位变为0；再加1，最右边的k位就又变成了0，第k+1位因为进位的关系变成了1。左边的位因为没有进位，正好和x原来对应的位上的值相反。二者按位与，得到：第k+1位上为1，左边右边都为0。结果为2^k。&lt;br/&gt;        总结一下：x&amp;amp;(-x)，当x为0时结果为0；x为奇数时，结果为1；x为偶数时，结果为x中2的最大次方的因子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且这个有一个专门的称呼，叫做lowbit，即取2^k。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上面已经解释了如何用树状数组求区间和，那么如果我们要更新某一个点的值呢，还是一样的，上面说了&lt;span&gt;&lt;strong&gt;C[i] = A[i - 2&lt;sup&gt;k&lt;/sup&gt;+1] + A&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;[i - 2&lt;sup&gt;k&lt;/sup&gt;+2] + ... + A[i]&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;，那么如果我们更新某个A[i]的值，则会影响到所有包含有A[i]位置。如果求A[i]包含哪些位置里呢，同理有&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A[i] 包含于 C[i + 2&lt;sup&gt;k&lt;/sup&gt;]、C[(i + 2&lt;sup&gt;k&lt;/sup&gt;) + 2&lt;sup&gt;k&lt;/sup&gt;]...；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;好，现在已经搞清楚了更新和求和，就可以来建树状数组了。如果上面的求和、更新或者lowbit步骤还没搞懂的化，建议再思考弄懂再往下看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么构造一个树状数组则为&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;1005&lt;/span&gt;],c[&lt;span&gt;1005&lt;/span&gt;]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对应原数组和树状数组&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lowbit(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; x&amp;amp;(-&lt;span&gt;x);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updata(&lt;span&gt;int&lt;/span&gt; i,&lt;span&gt;int&lt;/span&gt; k){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在i位置加上k&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i &amp;lt;=&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         c[i] +=&lt;span&gt; k;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         i +=&lt;span&gt; lowbit(i);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getsum(&lt;span&gt;int&lt;/span&gt; i){        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;求A[1 - i]的和&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; res = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         res +=&lt;span&gt; c[i];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         i -=&lt;span&gt; lowbit(i);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样就构造了一个树状数组。下面看一道模板题目吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;题目链接：&lt;a href=&quot;https://vjudge.net/problem/HDU-1166&quot; target=&quot;_blank&quot;&gt;https://vjudge.net/problem/HDU-1166&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直接看代码吧&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;50005&lt;/span&gt;],c[&lt;span&gt;50005&lt;/span&gt;]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对应原数组和树状数组&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lowbit(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; x&amp;amp;(-&lt;span&gt;x);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updata(&lt;span&gt;int&lt;/span&gt; i,&lt;span&gt;int&lt;/span&gt; k){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在i位置加上k&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i &amp;lt;=&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         c[i] +=&lt;span&gt; k;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         i +=&lt;span&gt; lowbit(i);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getsum(&lt;span&gt;int&lt;/span&gt; i){        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;求A[1 - i]的和&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; res = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         res +=&lt;span&gt; c[i];
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         i -=&lt;span&gt; lowbit(i);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; t;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     cin&amp;gt;&amp;gt;&lt;span&gt;t;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; tot = &lt;span&gt;1&lt;/span&gt;; tot &amp;lt;= t; tot++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Case &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; tot &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         memset(a, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt; a);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         memset(c, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt; c);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         cin&amp;gt;&amp;gt;&lt;span&gt;n;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             cin&amp;gt;&amp;gt;&lt;span&gt;a[i];
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             updata(i,a[i]);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入初值的时候，也相当于更新了值&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;string&lt;/span&gt;&lt;span&gt; s;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; x,y;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(cin&amp;gt;&amp;gt;s &amp;amp;&amp;amp; s[&lt;span&gt;0&lt;/span&gt;] != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;&lt;span&gt;y;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(s[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Q&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;求和操作&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; sum = getsum(y) - getsum(x-&lt;span&gt;1&lt;/span&gt;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;x-y区间和也就等于1-y区间和减去1-(x-1)区间和&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;                 cout &amp;lt;&amp;lt; sum &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(s[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                updata(x,y);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(s[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 updata(x,-y);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;减去操作，即为加上相反数&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这就是最简单的点更新区间求和了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上面介绍的是最普通的单点更新，区间查询，但如果有些时候是区间更新，单点求和怎么半，又或是区间更新，区间求和怎么办。这里将介绍各种情况该怎么写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果上面的单点更新，区间查询还没看懂，建议再思考再往下看。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1.单点更新、单点查询&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;传统数组可做&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.单点更新、区间查询&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;已讲解，详细看上面&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3.区间更新、单点查询&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这就是第一个问题，如果题目是让你把x-y区间内的所有值全部加上k或者减去k，然后查询操作是问某个点的值，这种时候该怎么做呢。如果是像上面的树状数组来说，就必须把x-y区间内每个值都更新，这样的复杂度肯定是不行的，这个时候，就不能再用数据的值建树了，这里我们引入差分，利用差分建树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设我们规定A[0] = 0;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则有 &lt;strong&gt;A[i] = Σ&lt;sup&gt;i&lt;/sup&gt;&lt;sub&gt;j = 1&lt;/sub&gt;D[j];(D[j] = A[j] - A[j-1])，&lt;/strong&gt;即前面i项的差值和，这个有什么用呢？例如对于下面这个数组&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;A[] = 1 2 3 5 6 9&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;D[] = 1 1 1 2 1 3&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;如果我们把[2,5]区间内值加上2，则变成了&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;A[] = 1 4 5 7 8 9&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;D[] = 1 3 &lt;span&gt;1 2 1&lt;/span&gt; 1&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;发现了没有，当某个区间[x,y]值改变了，区间内的差值是不变的，只有D[x]和D[y+1]的值发生改变，至于为什么我想我就不用解释了吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我们就可以利用这个性质对D[]数组建立树状数组，代码为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;50005&lt;/span&gt;] = {0},c[&lt;span&gt;50005&lt;/span&gt;]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对应原数组和树状数组&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lowbit(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; x&amp;amp;(-&lt;span&gt;x);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updata(&lt;span&gt;int&lt;/span&gt; i,&lt;span&gt;int&lt;/span&gt; k){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在i位置加上k&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i &amp;lt;=&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         c[i] +=&lt;span&gt; k;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         i +=&lt;span&gt; lowbit(i);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getsum(&lt;span&gt;int&lt;/span&gt; i){        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;求D[1 - i]的和，即A[i]值&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; res = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         res +=&lt;span&gt; c[i];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         i -=&lt;span&gt; lowbit(i);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     cin&amp;gt;&amp;gt;&lt;span&gt;n;&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         cin&amp;gt;&amp;gt;&lt;span&gt;a[i];
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         updata(i,a[i] - a[i-1]);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入初值的时候，也相当于更新了值&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[x,y]区间内加上k&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     updata(x,k);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;A[x] - A[x-1]增加k&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     updata(y+&lt;span&gt;1&lt;/span&gt;,-k);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;A[y+1] - A[y]减少k
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询i位置的值&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; sum =&lt;span&gt; getsum(i);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样就把，原来要更新一个区间的值变成了只需要更新两个点。也很容易理解吧。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4.区间更新、区间查询&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;上面我们说的差值建树状数组，得到的是某个点的值，那如果我既要区间更新，又要区间查询怎么办。这里我们还是利用差分，由上面可知&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;∑&lt;sup&gt;n&lt;/sup&gt;&lt;sub&gt;i = 1&lt;/sub&gt;A[i] = &lt;span&gt;∑&lt;sup&gt;n&lt;/sup&gt;&lt;sub&gt;i = 1&lt;/sub&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;∑&lt;sup&gt;n&lt;/sup&gt;&lt;sub&gt;j = 1&lt;/sub&gt;D[j];&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;则&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;A[1]+A[2]+...+A[n]&lt;/p&gt;

&lt;p&gt;= (D[1]) + (D[1]+D[2]) + ... + (D[1]+D[2]+...+D[n]) &lt;/p&gt;

&lt;p&gt;= n*D[1] + (n-1)*D[2] +... +D[n]&lt;/p&gt;

&lt;p&gt;= n * (D[1]+D[2]+...+D[n]) - (0*D[1]+1*D[2]+...+(n-1)*D[n])&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以上式可以变为&lt;span&gt;∑&lt;sup&gt;n&lt;/sup&gt;&lt;sub&gt;i = 1&lt;/sub&gt;A[i] = n*&lt;span&gt;∑&lt;sup&gt;n&lt;/sup&gt;&lt;sub&gt;i = 1&lt;/sub&gt;D[i] -  &lt;span&gt;&lt;span&gt;∑&lt;sup&gt;n&lt;/sup&gt;&lt;sub&gt;i = 1&lt;/sub&gt;( D[i]*(i-1) );&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果你理解前面的都比较轻松的话，这里也就知道要干嘛了，维护两个数状数组，sum1[i] = D[i]，sum2[i] = D[i]*(i-1);&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a[&lt;span&gt;50005&lt;/span&gt;] = {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sum1[&lt;span&gt;50005&lt;/span&gt;];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(D[1] + D[2] + ... + D[n])&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sum2[&lt;span&gt;50005&lt;/span&gt;];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(1*D[1] + 2*D[2] + ... + n*D[n])&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lowbit(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; x&amp;amp;(-&lt;span&gt;x);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updata(&lt;span&gt;int&lt;/span&gt; i,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; x = i;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为x不变，所以得先保存i值&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i &amp;lt;=&lt;span&gt; n){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         sum1[i] +=&lt;span&gt; k;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         sum2[i] += k * (x-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         i +=&lt;span&gt; lowbit(i);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getsum(&lt;span&gt;int&lt;/span&gt; i){        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;求前缀和&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; res = &lt;span&gt;0&lt;/span&gt;, x =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(i &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         res += x * sum1[i] -&lt;span&gt; sum2[i];
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         i -=&lt;span&gt; lowbit(i);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     cin&amp;gt;&amp;gt;&lt;span&gt;n;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         cin&amp;gt;&amp;gt;&lt;span&gt;a[i];
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         updata(i,a[i] - a[i-&lt;span&gt;1&lt;/span&gt;]);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入初值的时候，也相当于更新了值&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;[x,y]区间内加上k&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     updata(x,k);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;A[x] - A[x-1]增加k&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     updata(y+&lt;span&gt;1&lt;/span&gt;,-k);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;A[y+1] - A[y]减少k
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;求[x,y]区间和&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; sum = getsum(y) - getsum(x-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;再附赠两道模板题目，可以自行写一下以便理解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;区间修改、单点查询模板题目：https://www.luogu.org/problem/show?pid=3368&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;区间修改、区间查询模板题目：https://vjudge.net/problem/POJ-3468&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;PS：这里大致归纳了一维树状数组的所有要使用到的东西，二维建树以及更多变式就不说了，具体问题再具体分析。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;后记：&lt;span&gt;自己看了一下写的不是很好，特别是公式和图，都是用简单的画图和直接写的，没有用编辑器，也不能说我懒吧，毕竟精力有限啦，以后有空还是会去学的，带给大家更好的博客。手敲也不易，希望大家理解，多多支持。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;不懂问我噢= =&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 03 Oct 2018 06:21:00 +0000</pubDate>
<dc:creator>Xenny</dc:creator>
<og:description>先来看几个问题吧。 1.什么是树状数组？ 顾名思义，就是用数组来模拟树形结构呗。那么衍生出一个问题，为什么不直接建树？答案是没必要，因为树状数组能处理的问题就没必要建树。和Trie树的构造方式有类似之</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xenny/p/9739600.html</dc:identifier>
</item>
<item>
<title>网页短链接实现原理探究 - 如是说</title>
<link>http://www.cnblogs.com/lishanlei/p/9739720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lishanlei/p/9739720.html</guid>
<description>&lt;p&gt;事情是这样的，今天一人问我一个问题，但是我懒得在说，就在网上找了一篇博客通过QQ发送给他，但是在发送链接时我发现之前很长的链接变成了短链接，且这个短链接能够正常访问之前的长链接，好奇之下就有了这篇文章．&lt;/p&gt;
&lt;h3&gt;什么是短链接？&lt;/h3&gt;
&lt;p&gt;我的理解就是通过一定的算法和技术实现将原本很长的网址转换为较短的网址，从而便于用户记忆和在互联网上的传播．常用于有字数约束的微博，二维码等场景．&lt;/p&gt;
&lt;p&gt;现在很多公司都提供了短链接服务，比如百度，新浪微博等等，以供用户自由方便的生成短链接．&lt;/p&gt;
&lt;p&gt;短链接的大致整体流程&lt;/p&gt;
&lt;p&gt;今天上午我找的原本链接是这个：&lt;/p&gt;


&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;5&quot;&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201942/201810/1201942-20181003140142757-1045117306.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以要想将生成短链接，我们需要注意两个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如何将任意长的字符串转化为较短长或者固定长的字符串．&lt;/li&gt;
&lt;li&gt; 如何将短链接还原成之前的长链接，使之能够访问．&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;算法实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Hash实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过一定方式将任意长的文本转化为一个固定长的字符串，只要目标文本长度适当，那么我们对于不同的输入通过哈希几乎(注意是几乎)不可能得到对应同一个字符串．通过对长链接进行Hash运算，将Hash值作为这个长链接的唯一标示．但是通过Hash实现可能会造成碰撞．不一样的长网址缩短成了同一个短网址，那也就做不到复原了．&lt;/p&gt;
&lt;p&gt;对于碰撞问题，有一种缓冲方法就是在呈现碰撞了以后后边在增加随机字符，随机字符的增加能够缓解碰撞的疑问，但是这终究是一种缓冲的办法，没有彻底解决碰撞． &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自增序列算法(永不重复算法)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以设置一个自增id，对于每一个新的长链接给他一个不重复的id．&lt;/p&gt;
&lt;p&gt;原理：当服务器接收到一个网址时首先检验这个网址在服务器中是否再存，如果不存在，存储这个新网址并分发一个id，这个id设置成自增，保证了每一个存储的网址的id都是唯一标示．比如上面的，当一个链接过来时，给这个链接发一个0，再有一个链接过来时，给后面这个链接一个1，以此类推．&lt;/p&gt;
&lt;p&gt;数据实现：我们发现短链接后面的参数好像都是定长的，但是如果通过id进行时，参数不定长，且随着id的自增，可能会出现这种情况：url.cn/10000000．我们可以将十进制的id转化为多进制，比如在以'0-9a-z'这36个字符表示的36进制中，一亿可以被表示为1njchs，基本实现不重复够用．如果数据量更大，我们可以采用62进制进行转化：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;4&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdn.net/20180930145801286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpc2hhbmxlaWxpeGlu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;&quot; width=&quot;200&quot; height=&quot;311&quot; data-cke-saved-src=&quot;https://img-blog.csdn.net/20180930145801286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpc2hhbmxlaWxpeGlu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdn.net/20180930145801286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpc2hhbmxlaWxpeGlu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;200&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;311&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;短址的长度一般设为 6 位，而每一位是由 &lt;code&gt;[a - z, A - Z, 0 - 9]&lt;/code&gt; 总共 62 个字母组成的，所以 6 位的话，总共会有 62^6 ~= 568亿种组合。&lt;/p&gt;
&lt;p&gt;存储实现：&lt;/p&gt;
&lt;p&gt;对于小型系统，简单的mysql系统的表自增索引即可实现(注意自增id数据类型，int只能到65535)&lt;/p&gt;
&lt;p&gt;大型系统可以搭建分布式key-value系统进行存储．&lt;/p&gt;
&lt;p&gt;我使用mysql简单建了一张表，用于保存长网址的数据，只有两个字段，一个是主键用于保存id，一个url字段用于存放原始的长网址．在进行长网址转换时，先检查数据表中是否存在该长网址，如果存在直接获取该记录的id，否在创建一条新的记录并返回该记录的id，对于这id进行进制转化处理后拼接到准备好的域名后面得到一个对应的短网址返回给用户．&lt;/p&gt;
&lt;p&gt;这里我简单模仿了一个转换短链接的功能：&lt;/p&gt;
&lt;p&gt;url.php：用于模拟数据库存储&lt;/p&gt;



&lt;p&gt;输出：&lt;a href=&quot;http://url.cn/J&quot; data-cke-saved-href=&quot;http://url.cn/J&quot;&gt;http://url.cn/J&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;至于解析短链接跳转至原有链接，只是对上面思路进行取反．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;摘要算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将长网址 &lt;code&gt;md5&lt;/code&gt; 生成 32 位签名串,分为 4 段, 每段 8 个字节&lt;/li&gt;
&lt;li&gt;对这四段循环处理, 取 8 个字节, 将他看成 16 进制串与 0x3fffffff(30位1) 与操作, 即超过 30 位的忽略处理&lt;/li&gt;
&lt;li&gt;这 30 位分成 6 段, 每 5 位的数字作为字母表的索引取得特定字符, 依次进行获得 6 位字符串&lt;/li&gt;
&lt;li&gt;总的 &lt;code&gt;md5&lt;/code&gt; 串可以获得 4 个 6 位串,取里面的任意一个就可作为这个长 url 的短 url 地址&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这种算法虽然会生成四个短链接，但是存在重复几率．&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法对比&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;采用自增序列的好处就是简单好理解易操作．但是由于id随着增大长度不固定，但是这个问题可以通过让id从指定的数字开始递增即可以解决．还有一个问题就是我们使用的短码是有序的，可能会存在安全方面的问题．当然相关的防护手法也有很多，比如签名验证之类的安全策略；我们也可以自己实现安全手法，比如从一个随机中心值进行开端计数，然后选用一些校检位算法计算出固定位的校检码，将其连接起来，得到固定长不递增的短码．&lt;/p&gt;
&lt;p&gt;第二种算法存在碰撞的问题，虽然产生重复(碰撞)的几率很小．但是也采用这种算法也有一个好处就是短码的位数是固定的，不会从一位到多位．&lt;/p&gt;
&lt;p&gt;所以这两种算法各有千秋，如果事务所需要的短链接有效期较短，那么通过批处理定期清洗，那么用摘要算法也不错．而自增算法能够确保任何恳求量都不会呈现冲突也不失一种非常好的解决算法．&lt;/p&gt;
&lt;h3&gt;重定向的问题(301还是302)&lt;/h3&gt;
&lt;p&gt;短链接重定向的执行过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户访问短链接：&lt;a href=&quot;https://dwz.cn/9WnR9Qcx&quot; data-cke-saved-href=&quot;https://dwz.cn/9WnR9Qcx&quot;&gt;https://dwz.cn/9WnR9Qcx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;短链接服务器dwz.cn收到请求，根据URL路径&lt;a href=&quot;https://dwz.cn/9WnR9Qcx&quot; data-cke-saved-href=&quot;https://dwz.cn/9WnR9Qcx&quot;&gt;9WnR9Qcx&lt;/a&gt;获取到原始的长链接：&lt;a href=&quot;http://www.lishanlei.cn/&quot; data-cke-saved-href=&quot;http://www.lishanlei.cn/&quot;&gt;http://www.lishanlei.cn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;服务器返回状态码，将响应头中的Location设置为：&lt;a href=&quot;http://www.lishanlei.cn/&quot; data-cke-saved-href=&quot;http://www.lishanlei.cn/&quot;&gt;http://www.lishanlei.cn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;浏览器重新向&lt;a href=&quot;http://www.lishanlei.cn/&quot; data-cke-saved-href=&quot;http://www.lishanlei.cn/&quot;&gt;http://www.lishanlei.cn/&lt;/a&gt;发送请求&lt;/li&gt;
&lt;li&gt;返回响应&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;301是永久重定向，而302是临时重定向．&lt;/p&gt;
&lt;p&gt;如果选取301，短链接生成以后就不会变化，所以用301符合http语义，这样对服务器的压力会有所减少．但是这样一来，我们就无法统计短地址被点击的次数了．&lt;/p&gt;
&lt;p&gt;而选择302会增加服务器的压力，但是我们可以统计短链接被点击的次数，这些数据可能对于公司的发展规划非常重要．&lt;/p&gt;
&lt;p&gt;综上所述，我认为更好的应该选择302&lt;/p&gt;

&lt;p&gt;End&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 06:04:00 +0000</pubDate>
<dc:creator>如是说</dc:creator>
<og:description>事情是这样的，今天一人问我一个问题，但是我懒得在说，就在网上找了一篇博客通过QQ发送给他，但是在发送链接时我发现之前很长的链接变成了短链接，且这个短链接能够正常访问之前的长链接，好奇之下就有了这篇文章</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lishanlei/p/9739720.html</dc:identifier>
</item>
<item>
<title>Java并发编程-CountDownLatch - lingjiango</title>
<link>http://www.cnblogs.com/iou123lg/p/9739697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iou123lg/p/9739697.html</guid>
<description>&lt;p&gt;　　基于&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9464385.html&quot; target=&quot;_blank&quot;&gt;AQS的前世今生&lt;/a&gt;，来学习并发工具类CountDownLatch。本文将从CountDownLatch的应用场景、源码原理解析来学习这个并发工具类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、&lt;/strong&gt; &lt;strong&gt;应用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　CountDownLatch是并发包中用来控制一个或者多个线程等待其他线程完成操作的并发工具类。现以工作中的一个场景来描述下CountDownLatch的应用，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
模拟工作中的一个需求场景：
用户会选择多个算法来计算费用，最后会将所有算法计算出的费用做一个加权求平均数，这个平均数是最终的费用。
每个算法的复杂度都不一样，打算每个线程负责一个算法的实现，所有的线程执行完成，最后再求平均数。
1、为每个算法创建一个线程，每个线程负责一个算法的实现
2、通过CountDownLatch来控制所有算法线程的同步
3、全部计算完成后再求平均数
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountDownLatchTask {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        CountDownLatchTask countDownLatchTask &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CountDownLatchTask();
        countDownLatchTask.startThreads(&lt;/span&gt;5&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据线程数和选择的算法 调度算法对应的实现&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; startThreads(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; threadNumber) {
        CountDownLatch countDownLatch &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CountDownLatch(threadNumber);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; threadNumber; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                    System.out.println(&lt;/span&gt;&quot;线程算法实现：&quot; +&lt;span&gt; Thread.currentThread().getName());
                    countDownLatch.countDown();
                }
            }).start();
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            countDownLatch.await();
            System.out.println(&lt;/span&gt;&quot;加权求平均数&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在分析原理实现前，总结下CountDownLatch的作用就是阻塞其他线程直到条件允许后才释放该阻塞，除了上述这个小案例，实际工作中还有很多可以使用CountDownLatch的场景，比如解析Excel文件时可以同时解析多个Sheet页，所有的Sheet解析完成才算完成了Excel文件的解析。从这个代码中也可以看到CountDownLatch的主要方法就是await和countDown，下面将以这两个方法来分析下CountDownLatch的原理实现。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;2、&lt;/strong&gt; &lt;strong&gt;源码原理解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 2.1 await方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　调用await方法会阻塞当前线程直到计数器的数值为0，方法如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; await() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        sync.acquireSharedInterruptibly(&lt;/span&gt;1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;共享式获取AQS的同步状态&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　调用的是AQS的acquireSharedInterruptibly方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquireSharedInterruptibly(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Thread.interrupted())&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程中断 说明闭锁对线程中断敏感&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tryAcquireShared(arg) &amp;lt; 0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;闭锁未使用完成 线程进入同步队列自旋等待 &lt;/span&gt;
&lt;span&gt;            doAcquireSharedInterruptibly(arg);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中tryAcquireShared依赖的是Sync的实现，和之前的&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9535710.html&quot; target=&quot;_blank&quot;&gt;ReentrantLock&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9637637.html&quot; target=&quot;_blank&quot;&gt;ReentrantReadWriteLock&lt;/a&gt;及&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9689491.html&quot; target=&quot;_blank&quot;&gt;Semaphore&lt;/a&gt;相比，CountDownLatch的Sync只提供了一种方式，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tryAcquireShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (getState() == 0) ? 1 : -1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;AQS的同步状态为0则闭锁结束 可以进行下一步操作&lt;/span&gt;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　doAcquireSharedInterruptibly方法就不再赘述，和之前&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9689491.html&quot; target=&quot;_blank&quot;&gt;Semaphore&lt;/a&gt;的实现是一致的，本质上仍然是AQS同步队列的入队自旋等待。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2 countDown方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　调用countDown方法会将计数器的数值减1直到计数器为0，方法如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; countDown() {
        sync.releaseShared(&lt;/span&gt;1&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　和&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9689491.html&quot; target=&quot;_blank&quot;&gt;Semaphore&lt;/a&gt;一样，调用的是AQS的releaseShared方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; releaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tryReleaseShared(arg)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;减少闭锁的计数器&lt;/span&gt;
            doReleaseShared();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;唤醒后续线程节点&lt;/span&gt;
           &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中tryReleaseShared依赖的是Sync的实现，和之前的&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9535710.html&quot; target=&quot;_blank&quot;&gt;ReentrantLock&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9637637.html&quot; target=&quot;_blank&quot;&gt;ReentrantReadWriteLock&lt;/a&gt;及&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9689491.html&quot; target=&quot;_blank&quot;&gt;Semaphore&lt;/a&gt;相比，CountDownLatch的Sync只提供了一种方式，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryReleaseShared(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; releases) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Decrement count; signal when transition to zero&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; getState();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c == 0&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计数器已经是0了&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; nextc = c-1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计数器减1&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (compareAndSetState(c, nextc)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CAS更新同步状态&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; nextc == 0&lt;span&gt;;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　唤醒后续线程节点的doReleaseShared也不再赘述，和之前&lt;a href=&quot;https://www.cnblogs.com/iou123lg/p/9689491.html&quot; target=&quot;_blank&quot;&gt;Semaphore&lt;/a&gt;的实现是一致的。&lt;/p&gt;
&lt;p&gt;　　总结：CountDownLatch类使用AQS同步状态来表示计数。在await时，所有的线程进入同步队列自旋等待，在countDown时，获取闭锁成功的线程会减少闭锁的计数器，同时唤醒后续线程取获取闭锁，直到await中的计数器为0，获取到闭锁的线程才可以通过，执行下一步操作。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;参考资料:&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;a href=&quot;https://github.com/lingjiango/ConcurrentProgramPractice&quot;&gt;https://github.com/lingjiango/ConcurrentProgramPractice&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 05:54:00 +0000</pubDate>
<dc:creator>lingjiango</dc:creator>
<og:description>基于AQS的前世今生，来学习并发工具类CountDownLatch。本文将从CountDownLatch的应用场景、源码原理解析来学习这个并发工具类。 1、 应用场景 CountDownLatch是并</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iou123lg/p/9739697.html</dc:identifier>
</item>
<item>
<title>mybatis抽取出的工具-（一）通用标记解析器（即拿即用） - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/9739632.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/9739632.html</guid>
<description>&lt;p&gt;在深入理解 &lt;strong&gt;mybatis&lt;/strong&gt; 原理过程中， 我不单单是想理解整个 &lt;strong&gt;mybatis&lt;/strong&gt; 是怎么运行的， 我还想从这个过程中提取出一些对自己有益的编程方法， 编程思想， 注释， 以及一些实用工具类。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;1. 简介&lt;/h2&gt;
&lt;h3 id=&quot;mybatis-config.xml-中使用&quot;&gt;1.1 mybatis-config.xml 中使用&lt;/h3&gt;
&lt;p&gt;在 &lt;strong&gt;mybatis-config.xml&lt;/strong&gt; 文件中， 我们常常看到类似的配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;properties&amp;gt;
    &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&amp;gt;
    &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot; /&amp;gt;
    &amp;lt;property name=&quot;username&quot; value=&quot;root&quot; /&amp;gt;
    &amp;lt;property name=&quot;password&quot; value=&quot;aaabbb&quot; /&amp;gt;
&amp;lt;/properties&amp;gt;
&amp;lt;environments default=&quot;development&quot;&amp;gt;
    &amp;lt;environment id=&quot;development&quot;&amp;gt;
        &amp;lt;transactionManager type=&quot;JDBC&quot;&amp;gt;
            &amp;lt;property name=&quot;&quot; value=&quot;&quot;/&amp;gt;
        &amp;lt;/transactionManager&amp;gt;
        &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
            &amp;lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&amp;gt;
            &amp;lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&amp;gt;
            &amp;lt;!--填写你的数据库用户名--&amp;gt;
            &amp;lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&amp;gt;
            &amp;lt;!--填写你的数据库密码--&amp;gt;
            &amp;lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&amp;gt;
        &amp;lt;/dataSource&amp;gt;
    &amp;lt;/environment&amp;gt;
&amp;lt;/environments&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将一些属性放置在 &lt;code&gt;properties&lt;/code&gt;标签下的子标签中， 后续在配置文件中就可以使用 &lt;strong&gt;${key}&lt;/strong&gt; 的形式将 &lt;strong&gt;value&lt;/strong&gt; 取出。&lt;/p&gt;
&lt;p&gt;也可以将属性配置在外部文件中，将外部文件的相对路径告知解析器即可:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;properties resource=&quot;jdbc.properties&quot;&amp;gt;&amp;lt;/properties&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;xxxmapper.xml-中使用&quot;&gt;1.2 xxxMapper.xml 中使用&lt;/h3&gt;
&lt;p&gt;当然， 在 &lt;strong&gt;xxxMapper.xml&lt;/strong&gt; 中， 我们写 &lt;strong&gt;SQL&lt;/strong&gt; 语句时也会用到， 如&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    select
    &amp;lt;include refid=&quot;Base_Column_List&quot; /&amp;gt;
    from student
    where student_id=#{student_id, jdbcType=INTEGER}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 &lt;code&gt;#{student_id, jdbcType=INTEGER}&lt;/code&gt; 替换为传入的参数。&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;2. 原理&lt;/h2&gt;
&lt;p&gt;在 mybatis 中， 处理这个过程的就是 &lt;code&gt;GenericTokenParser&lt;/code&gt; 类。&lt;/p&gt;
&lt;h3 id=&quot;generictokenparser-成员变量&quot;&gt;2.1 GenericTokenParser 成员变量&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;GenericTokenParser&lt;/code&gt; 类有三个成员变量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 开始标记
private final String openToken;
// 结束标记
private final String closeToken;
// 表处理器
private final TokenHandler handler;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;举个例子&lt;/p&gt;
&lt;p&gt;解析以上配置中的 &lt;strong&gt;${driver}&lt;/strong&gt;， 那么这几个成员变量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openToken=&quot;${&quot;;
closeToken=&quot;}&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;handler&lt;/code&gt;则是一个 &lt;code&gt;TokenHandler&lt;/code&gt; 接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface TokenHandler {
  String handleToken(String content);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在实际的过程中， 我们需要自己定义的处理器， 该处理器实现 &lt;code&gt;TokenHandler&lt;/code&gt; 即可， 后面的例子中会有示例。&lt;/p&gt;
&lt;h3 id=&quot;generictokenparser-构造函数&quot;&gt;2.2 GenericTokenParser 构造函数&lt;/h3&gt;
&lt;p&gt;构造函数很简单， 就是给几个成员变量赋值即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public GenericTokenParser(String openToken, String closeToken, TokenHandler handler) {
    this.openToken = openToken;
    this.closeToken = closeToken;
    this.handler = handler;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解析过程&quot;&gt;2.3 解析过程&lt;/h3&gt;
&lt;h4 id=&quot;整体流程&quot;&gt;2.3.1 整体流程&lt;/h4&gt;
&lt;p&gt;大的流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181003131932112?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;解析过程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整体上来讲， 就是找到这个需要处理的表达式， 将表达式的内容替换为处理器处理后的内容， 最后返回最终的字符串。&lt;/p&gt;
&lt;h4 id=&quot;流程详解&quot;&gt;2.3.2 流程详解&lt;/h4&gt;
&lt;p&gt;先看代码以及我给的注释&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public String parse(String text) {
    if (text == null || text.isEmpty()) {
        return &quot;&quot;;
    }
    // 从第0位开始， 查找开始标记的下标
    int start = text.indexOf(openToken, 0);
    if (start == -1) { // 找不到则返回原参数
        return text;
    }
    char[] src = text.toCharArray();
    // offset用来记录builder变量读取到了哪
    int offset = 0;
    // builder 是最终返回的字符串
    final StringBuilder builder = new StringBuilder();
    // expression 是每一次找到的表达式， 要传入处理器中进行处理
    StringBuilder expression = null;
    while (start &amp;gt; -1) {
        if (start &amp;gt; 0 &amp;amp;&amp;amp; src[start - 1] == '\\') {
            // 开始标记是转义的， 则去除转义字符'\'
            builder.append(src, offset, start - offset - 1).append(openToken);
            offset = start + openToken.length();
        } else {
            // 此分支是找到了结束标记， 要找到结束标记
            if (expression == null) {
                expression = new StringBuilder();
            } else {
                expression.setLength(0);
            }
            // 将开始标记前的字符串都添加到 builder 中 
            builder.append(src, offset, start - offset);
            // 计算新的 offset
            offset = start + openToken.length();
            
            // 从此处开始查找结束的标记
            int end = text.indexOf(closeToken, offset);
            while (end &amp;gt; -1) {
                if (end &amp;gt; offset &amp;amp;&amp;amp; src[end - 1] == '\\') {
                    // 此结束标记是转义的
                    expression.append(src, offset, end - offset - 1).append(closeToken);
                    offset = end + closeToken.length();
                    end = text.indexOf(closeToken, offset);
                } else {
                    expression.append(src, offset, end - offset);
                    offset = end + closeToken.length();
                    break;
                }
            }
            if (end == -1) {
                // 找不到结束标记了
                builder.append(src, start, src.length - start);
                offset = src.length;
            } else {
                // 找到了结束的标记， 则放入处理器进行处理
                builder.append(handler.handleToken(expression.toString()));
                offset = end + closeToken.length();
            }
        }
        // 因为字符串中可能有很多表达式需要解析， 因此开始下一个表达式的查找
        start = text.indexOf(openToken, offset);
    }
    // 最后一次未找到开始标记， 则将 offset 后的字符串添加到 builder 中
    if (offset &amp;lt; src.length) {
        builder.append(src, offset, src.length - offset);
    }
    return builder.toString();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你看代码看明白了， 就不用看下面的详细过程了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：就是参数的非空处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参数为空或 &quot;&quot; , 则返回 &quot;&quot;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (text == null || text.isEmpty()) {
    return &quot;&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二步：查找开始标记，声明变量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 从第0位开始， 查找开始标记的下标
    int start = text.indexOf(openToken, 0);
    if (start == -1) { // 找不到则返回原参数
        return text;
    }
    char[] src = text.toCharArray();
    // offset用来记录 builder 变量读取到的位置
    int offset = 0;
    // builder 是最终返回的字符串
    final StringBuilder builder = new StringBuilder();
    // expression 是每一次找到的表达式， 要传入处理器中进行处理
    StringBuilder expression = null;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果传入的字符串中没有要处理的开始标记， 那么直接就返回了， 不需要进行一堆变量的声明。&lt;/p&gt;
&lt;p&gt;如果找到了， 则进行变量的声明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步： 循环查找标记并进行处理&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在本例子中， 假设开始标记为 &lt;strong&gt;${&lt;/strong&gt;, 结束标记为 &lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;首先， 先查找开始标记符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只有找到了开始标记符才需要去找对应的结束标记符， 不然单独找到结束标记符没有意义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们找到了 &lt;code&gt;${&lt;/code&gt;， 有两种情况:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;${ 是开始标记符&lt;/li&gt;
&lt;li&gt;${ 就是我们本身想要的字符&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如何区分这两种情况呢， 正常的情况得到的是情况1， 如果想得到情况2， 在该解析器中， 是需要加入转义符号&lt;code&gt;\\&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;即我们在最终的字符中想要得到 &lt;code&gt;${&lt;/code&gt;字符， 则应该这样写 &lt;code&gt;\\${&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于情况2， 该解析器中是这样子处理的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; builder.append(src, offset, start - offset - 1).append(openToken);
 offset = start + openToken.length();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把转移符去掉， 将字符串添加到 builder 中。 记录解析到的位置 offset。 继续查找下一个开始标记。&lt;/p&gt;
&lt;p&gt;对于情况1，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接着， 查找结束标记符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们找到了 &lt;code&gt;}&lt;/code&gt;， 有两种情况:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;} 是开始标记符&lt;/li&gt;
&lt;li&gt;} 就是我们本身想要的字符&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么， 如同前面， 情况2也需要转移标记才能区分。情况2处理&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; // 此结束标记是转义的
expression.append(src, offset, end - offset - 1).append(closeToken);
offset = end + closeToken.length();
end = text.indexOf(closeToken, offset);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把转移符去掉， 将字符串添加到 builder 中。 记录解析到的位置 offset。 继续查找下一个结束标记，直到找到的是情况1， 则跳出循环。&lt;/p&gt;
&lt;p&gt;对于情况1， 得到&lt;code&gt;${&lt;/code&gt;和&lt;code&gt;}&lt;/code&gt;之间的表字符串作为 &lt;code&gt;expression&lt;/code&gt;， 继续往下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;处理器处理&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; // 找到了结束的标记， 则放入处理器进行处理
builder.append(handler.handleToken(expression.toString()));
offset = end + closeToken.length();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;最后， 只要还没找到最后， 则继续查找下一个开始的标记&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;start = text.indexOf(openToken, offset);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试&quot;&gt;3. 测试&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;  @Test
  public void simpleTest() {
    GenericTokenParser parser = new GenericTokenParser(&quot;${&quot;, &quot;}&quot;, new VariableTokenHandler(new HashMap&amp;lt;String, String&amp;gt;() {
      {
        put(&quot;driver&quot;, &quot;com.mysql.jdbc.Driver&quot;);
        put(&quot;url&quot;, &quot;jdbc:mysql://localhost:3306/mybatis&quot;);
        put(&quot;username&quot;, &quot;root&quot;);
        put(&quot;password&quot;, &quot;aaabbb&quot;);

      }
    }));

    // 测试单个解析
    assertEquals(&quot;com.mysql.jdbc.Driver&quot;, parser.parse(&quot;${driver}&quot;));
    // 多个一起测试
    assertEquals(&quot;驱动=com.mysql.jdbc.Driver，地址=jdbc:mysql://localhost:3306/mybatis，用户名=root&quot;,
            parser.parse(&quot;驱动=${driver}，地址=${url}，用户名=${username}&quot;));
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;代码&quot;&gt;4 代码&lt;/h2&gt;
&lt;p&gt;如需要代码， 请访问&lt;a href=&quot;https://github.com/homejim/mybatis-examples.git&quot;&gt;我的Github&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如有问题， 请跟我交流。&lt;/p&gt;
</description>
<pubDate>Wed, 03 Oct 2018 05:25:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>本文章主要介绍的是我从mybatis源码中提取出的工具， 有了该工具， 我们就可以愉快的处理类似 ${driver}， #{id, jdbcType=INTEGER}等表达式啦， 希望能帮助大家</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/9739632.html</dc:identifier>
</item>
<item>
<title>GNU/Linux 正则表达式与三剑侠（grep，sed，awk）（精） - 3L·BoNuo·Lotus</title>
<link>http://www.cnblogs.com/BoNuo/p/9736666.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BoNuo/p/9736666.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7426371.html&quot; target=&quot;_blank&quot;&gt;shell命令行的解析原理（单双无引号与字符及通配符的关系）：http://www.cnblogs.com/f-ck-need-u/p/7426371.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9621130.html&quot; target=&quot;_blank&quot;&gt;正则表达式里是如何表达字符集：https://www.cnblogs.com/f-ck-need-u/p/9621130.html &lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/7462706.html&quot; target=&quot;_blank&quot;&gt;grep的应用：https://www.cnblogs.com/f-ck-need-u/p/7462706.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/7499471.html&quot; target=&quot;_blank&quot;&gt;sed的应用：https://www.cnblogs.com/f-ck-need-u/p/7499471.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;


&lt;p&gt;&lt;span&gt;传闻中三剑侠的威名响彻云霄，传说中若没有正则表达式的神功，三剑侠也是芸芸众生，江湖中传言&quot;欲成剑侠，先练神功&quot;，不管传说或传闻我都信。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;度度果然不是盖的，一下就拔出了正则的历史，不看不知道，一看就大有来头，大约就是国外几位猛人科学家在搞一个伟大的工程时诞生了正则数学表达式，随后被目光深远的Ken，将这正则表达式引入于Unix的编辑器中。后面的事情大家都很清楚了，三剑侠大闹搜索界，传说由此开始，而故事远远没有落幕，......&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从正则的历史中，可以看出正则表达式对英文是100%的原生，也就是为英文的而生（会不会因英文而灭，不好说，或许明天你就嫁给我了，会有中文的笔画正则也说不定，拼音正则也行），&lt;span&gt;主要应用于按某规则搜索匹对英文中的内容&lt;/span&gt;，所以对英文的26个字母不熟悉的同志要努力下了（俺初中英语非常6，所以这26个英文字母，蒙着眼睛也知道谁是谁，谁跟谁，一点不模糊。），那么对英文的结构，就需要了解下，&lt;span&gt;英文&lt;span&gt;单词&lt;/span&gt;由英文&lt;span&gt;字母&lt;/span&gt;&lt;strong&gt;&lt;span&gt;排列&lt;/span&gt;&lt;/strong&gt;组合并以&lt;span&gt;空格&lt;/span&gt;来分隔每一个单词&lt;/span&gt;，这个就是我们下工夫及体会的本质（&lt;span&gt;英文字母，单词&lt;span&gt;[ 每个字母所在的位置决定了单词意义 ]&lt;/span&gt;，空格&lt;span&gt;构成英语文本的三剑豪&lt;/span&gt;&lt;/span&gt;）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;对所爱，要重复大声说：trust me , I love you&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1 字符（我思故我在，能想的，都是字符）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2 字母的不同&lt;span&gt;&lt;strong&gt;排序组合&lt;/strong&gt;&lt;/span&gt;构成不同的单词&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3 空格分隔单词（只要有某字符分隔单词，采用什么字符都可以）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;图解正则表达式的对英语文本的看法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508631/201810/508631-20181002130236064-948313039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;caption&gt;&lt;span&gt;示例：I love u 的字符与位置关系&lt;/span&gt;&lt;/caption&gt;
&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;字符&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;I&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;空格&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;l&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;o&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;v&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;e&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;空格&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;u&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;位置&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;3&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;4&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;5&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;6&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;7&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;8&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;对英文（其他字符集）搜索的两种模式（字符[ 组合 ]位置，字符[ 组合 ]的排序）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;字符 [ 组合 ] 位置搜索方式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;位置搜索方式比较单一，目的是确定字符（单词）在整行字符排列位置上，常用^来表示字符（单词）在一行文本的最开始位置（一行的顶格位置）， $ 来表示字符（单词）在一行文本的最末尾的位置（一行的最末尾位置），&lt;span&gt;任意单字符*&lt;/span&gt;表示所有的位置，\b作用就是单词与单词之间的位置，\B作用就是某单词内字母与字母之间的位置，这两个大小傻B不能用说，要直接上才明白。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这里有个知识点，就是shell的通配符及单引号、双引号、无引号与正则表达的元字符的应用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;shell 命令行输入命令且回车 --&amp;gt; shell会对输入命令及参数进行解析 &lt;span&gt;（为了让你的意图能正确到达正则，了解shell的解析是必要的）&lt;/span&gt;--&amp;gt; 正则表达式解析工作&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;19&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt; &lt;span&gt;^、$、任意字符*&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt; &lt;span&gt;* 表示重复前一个字符（单词）0~无限次，当等于0的情况，z*就表示位置了（其中z可以是任意的字符）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过sed的替换，将一句话的所有位置都替换6，替换后的位置比之前的位置又扩容了&lt;/span&gt;。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@server01 ~]# echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;It's my life.It's my life.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | grep --color &lt;span&gt;'&lt;/span&gt;&lt;span&gt;It&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;   
It&lt;/span&gt;&lt;span&gt;'s my life.&lt;span&gt;It&lt;/span&gt;'&lt;/span&gt;&lt;span&gt;s my life.&lt;br/&gt;[root@server01 &lt;/span&gt;~]# echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;It's my life.It's my life.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | grep --color &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&lt;span&gt;^&lt;/span&gt;It&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
It&lt;/span&gt;&lt;span&gt;'s my life.It'&lt;/span&gt;&lt;span&gt;s my life.
[root@server01 &lt;/span&gt;~]# &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@server01 ~]# echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;It's my life.It's my life.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | sed &lt;span&gt;'&lt;/span&gt;&lt;span&gt;s/&lt;span&gt;z*&lt;/span&gt;/6/g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
6I6t&lt;span&gt;6'6s6 6m6y6 6l6i6f6e6.6I6t6'6s6 6m6y6 6l6i6f6e6.6&lt;br/&gt;&lt;/span&gt;&lt;span&gt;
[root@server01 &lt;/span&gt;~]# echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;It's my life.It's my life.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | sed &lt;span&gt;'&lt;/span&gt;&lt;span&gt;s/&lt;span&gt;^&lt;/span&gt;a*/6/g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&lt;span&gt;
6&lt;/span&gt;I&lt;/span&gt;&lt;span&gt;t's my life.It's my&lt;/span&gt;&lt;span&gt; life.
[root@server01 &lt;/span&gt;~]# &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;4.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@server01 ~]# echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;It's my life.It's my life.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | grep --color &lt;span&gt;'&lt;/span&gt;&lt;span&gt;fe\.$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  
&lt;span&gt;It's my life.It's&lt;/span&gt; my li&lt;span&gt;fe.&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;
&lt;td readability=&quot;4.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@server01 ~]# echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;It's my life.It's my life.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | sed -r &lt;span&gt;'&lt;/span&gt;&lt;span&gt;s/&lt;span&gt;(yf)&lt;/span&gt;*$/6/g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
It&lt;/span&gt;&lt;span&gt;'s my life.It's my l&lt;/span&gt;ife.&lt;span&gt;6&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;  &lt;span&gt;\B、\b&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt; \B：一单词内的字母，不含首或尾字母（组合）&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; \b：单词与单词之间的分隔，以&lt;strong&gt;&lt;span&gt;单词&lt;/span&gt;&lt;/strong&gt;的首或尾字母（组合）及&lt;span&gt;非\w字符&lt;/span&gt;来&lt;span&gt;明确分隔。&lt;span&gt;&lt;strong&gt;注意要明确是你认为的单词&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td readability=&quot;4.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@server01 ~]# echo &lt;span&gt;'&lt;/span&gt;&lt;span&gt;live love life ifthen thenif&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; |grep --color &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\Bi\B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
l&lt;span&gt;i&lt;/span&gt;ve love l&lt;span&gt;i&lt;/span&gt;fe &lt;span&gt;i&lt;/span&gt;fthen then&lt;span&gt;i&lt;/span&gt;f
[root@server01 &lt;/span&gt;~]#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;
&lt;td readability=&quot;4.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@server01 ~]# echo &lt;span&gt;'&lt;/span&gt;&lt;span&gt;l&lt;span&gt;iv&lt;/span&gt;e l&lt;span&gt;ov&lt;/span&gt;e l&lt;span&gt;if&lt;/span&gt;e l&lt;span&gt;ef&lt;/span&gt;t l&lt;span&gt;is&lt;/span&gt;t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; |grep --color &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\bl&lt;span&gt;\w\+&lt;/span&gt;e\b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&lt;span&gt;           
live love life&lt;/span&gt; left list
[root@server01 &lt;/span&gt;~]#&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12.5&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt; 常用的组合：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;^$ 表示空行。第一个位置同时是开始也是结束。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;12&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@server01 ~]# echo &lt;span&gt;'&lt;/span&gt;&lt;span&gt;live love life left list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; |grep --color &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\bl&lt;span&gt;.*&lt;/span&gt;\+e\b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&lt;span&gt;
live love life&lt;/span&gt; left list
[root@server01 &lt;/span&gt;~]# &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;\bl&lt;span&gt;.*&lt;/span&gt;\+e\b   的写法是认为&quot;live love life&quot;是一个整体，可以理解为一个单词，因为&lt;span&gt;.*&lt;/span&gt;的意思是表示所有的字符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;\bl\w\+\e\b 的写法是认为live love life 是三个词。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@server01 ~]#  echo &lt;span&gt;'&lt;/span&gt;&lt;span&gt;live&lt;span&gt;,&lt;/span&gt;love&lt;span&gt;-&lt;/span&gt;life&lt;span&gt;;&lt;/span&gt;left&lt;span&gt;:&lt;/span&gt;list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; |grep --color &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\bl\w\+e\b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&lt;span&gt;    
live&lt;/span&gt;,&lt;span&gt;love&lt;/span&gt;&lt;/span&gt;-&lt;span&gt;&lt;span&gt;life&lt;/span&gt;;left:list
[root@server01 &lt;/span&gt;~]# 
&lt;/pre&gt;&lt;/div&gt;



&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;字符 [ 组合 ] 的排序搜索方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个相对比中文的笔画组合要好很多了，欲知详情（正则的元字符用法）请点击文章首部的&lt;span&gt;相关文件推荐，&lt;span&gt;我只做一下分类总结（没法子，功力不足，小弟我目前只站在他们的脚尖上。）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于英文单词由字母组成，所以字母对单词的特性就显现出现了，如在一个单词中，某字母或某组字母出现的次数、自定义范围内的字符、各种字符的分类。&lt;span&gt;无论如何捣鼓，都是人类书写的习惯&lt;/span&gt;。放大招如下表：&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;caption&gt;&lt;span&gt; 扩展正则（ERE）兼容基础正则（BRE）&lt;/span&gt;&lt;/caption&gt;
&lt;tbody readability=&quot;22&quot;&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;&lt;span&gt;shell通配符&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td colspan=&quot;4&quot;&gt;&lt;span&gt;正则表达式元字符&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;数量&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;符号&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;数量&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;特点&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;所属&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; 任意字符及数量&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 0 ~ 无限个&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; *&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0~ 无限 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;对前一个字符或一组字符定义&lt;span&gt;至少重复出现的次数范围&lt;/span&gt;0~无限次 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;数量类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;基础正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;.&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;一个任意的字符&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;数量类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;基础正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;+&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1 ~ 无限&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;对前一个字符或一组字符定义&lt;span&gt;至少重复出现的次数范围&lt;/span&gt;1~无限次&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;数量类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;扩展正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;一个任意的字符&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;？&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0 ~ 1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;对前一个字符或一组字符定义&lt;span&gt;至少出现&lt;/span&gt;0或1次&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;数量类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;扩展正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;{n,m}&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;n ~ m&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;对前一个字符或一组字符定义&lt;span&gt;至少重复出现的次数&lt;/span&gt;范围n~m次&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;数量类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;扩展正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;{n,}&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;n~ 无限&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;对前一个字符或一组字符定义&lt;span&gt;至少重复出现的次数&lt;/span&gt;范围n~无限次&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;数量类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;扩展正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;{,m}&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;0~m次&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;对前一个字符或一组字符定义&lt;span&gt;至少重复出现的次数&lt;/span&gt;范围0-m次&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;数量类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;扩展正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;{m}&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;m&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;对前一个字符或一组字符定义&lt;span&gt;重复出现&lt;/span&gt;m次&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;数据类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;扩展正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;touch {1..2}.txt&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;touch {a..c}.txt&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;序列1 ~ 序列2&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;{ 序列1..序列2 }&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13.5&quot;&gt;&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;[ 字符1 ... 字符n ]&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;span&gt;中括号内的任意一个字符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[a-z] 表示小写字母的任意一个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[A-Z] 表示大写字母的任意一个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[0-9] 表示数字的任意一个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[^0-9] 表示任意一个字符但不能是数字&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[i s,_-] 表示只能是字母i，s，空格，逗号，减号中的任意一个&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;范围类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（集合类）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 基础正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;[:alpha:]&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;等价于[a-zA-Z]，即是26个大小写英文字母&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用方式 [[:alpha:]]&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;字符分类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;基础正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;其余的字符分类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;其他[:系列:]的，到推荐的文章或度一下就有一吨粮食了。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;字符分类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;基础正则 &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;\W&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;非\w的所有可见或不可见的任意字符 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;字符分类&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;基础正则 &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;\w&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 大小写英文字母，数字，下划线&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;字符分类 &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;基础正则 &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;\S&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 任意一个可见的字符（理解用笔在纸上能写出的符号都是可见）&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;字符分类 &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;基础正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;\s&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt; 非可写的字符（理解无需用笔在纸上写出的字符，如空格）&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;字符分类 &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;基础正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span&gt;^&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span&gt;位置类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;基础正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;获取变量值&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span&gt;$&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span&gt;位置类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;基础正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span&gt;\b&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span&gt;\&amp;lt; 单词首 ；\&amp;gt; 单词尾，使用方式与 \b 基本一致&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;位置类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;基础正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span&gt;\B&lt;/span&gt;&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span&gt;位置类&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;基础正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span&gt;字符或组 &lt;span&gt;|&lt;/span&gt; 字符或组&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;左边或右边的字符或一组字符只能出现其一&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;2选1&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;扩展正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;（&lt;/span&gt;1或多个字符&lt;span&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;功能一：将括号里面的字符组成一组&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;功能二：可以给某些搜索命令（sed，grep）做反向引用&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;分组&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;扩展正则&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; \W，\S，\w，\s，及其他的字符分类都很好用。&lt;span&gt;&lt;strong&gt;下图是关于大S配小w，小S配大W的人脉关系图&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508631/201810/508631-20181002194554113-1842608206.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;正则表达式工作写真&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table border=&quot;0&quot;&gt;&lt;caption&gt;&lt;span&gt;正则表达式越模糊匹配，性能越低；反之性能越高（&lt;span&gt;多思考等效的正则表达式是深入理解正则及调优的关键&lt;/span&gt;）&lt;/span&gt;&lt;/caption&gt;
&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt; &lt;span&gt;正则的&lt;span&gt;工作原理概念&lt;/span&gt;模型&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;可以在度度找一下RegexBuddy 这个正则软件，能反映出正则表达式匹对内容大约需要多少次，&lt;span&gt;正则表达式的性能调优参考&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;29.5&quot;&gt;&lt;td&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/508631/201810/508631-20181003005411349-1994701698.png&quot; alt=&quot;&quot;/&gt;&lt;/td&gt;
&lt;td readability=&quot;52&quot;&gt;
&lt;p&gt;&lt;span&gt;举例：http://www.oldboyedu.com:80/html/html-tutorial.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提取：http，www.oldboyedu.com，80，/html/html-tutorial.html，四段内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分析：该url是一个复合词（字母数字标点符号混合），从要求中，发现有两个词是同类词，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个是http，一个是80，另两个是复合词，一个是字母与点号，一个是字母斜线减号点号组成。&lt;/span&gt;&lt;span&gt;其中，:或//要去掉&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基本思路，使用二选一的方式，将二选一变成多选&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基础解题关键：如何将内容分解对应的词或复合词&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1：同类词http、80，是同属一类字符  --&amp;gt;  \w+ 或 [a-z0-9]+ 就可以轻松啪它下来了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2：复合词www.oldboyedu.com.cn 域名类 --&amp;gt; 特点就是.xxx是重复的 --&amp;gt; \w+(\.\w+)+&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3：复合词/html/html-tutorial.html 路径类 --&amp;gt; 固定/html/后面可以无限任意字符  --&amp;gt;/\w+/.*&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;答案：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[root@s1 ~]# a=http://www.oldboyedu.com:80/html/html-tutorial.html&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[root@s1 ~]# echo $a | &lt;span&gt;&lt;span&gt;grep -oE&lt;/span&gt; '[a-z]+&lt;span&gt;|&lt;/span&gt;\w+(\.\w+){2}&lt;span&gt;|&lt;/span&gt;[0-9]{2}&lt;span&gt;|&lt;/span&gt;/\w+/.*'  &lt;span&gt;#四个表达式的顺序与url的四个内容一致，&lt;span&gt;解法一：一一对应&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[root@s1 ~]# echo $a | &lt;span&gt;&lt;span&gt;grep -Eo&lt;/span&gt; '\w+&lt;span&gt;|&lt;/span&gt;\w+(\.\w+)+&lt;span&gt;|&lt;/span&gt;/\w+/.*'  &lt;span&gt;#\w+ 匹配出 http 及 80，&lt;span&gt;解法二：提取同类的字符为一类&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[root@s1 ~]# echo $a | &lt;span&gt;&lt;span&gt;grep -oE&lt;/span&gt; '[a-z.0-9]+&lt;span&gt;|&lt;/span&gt;[^0-9]+$'  &lt;span&gt;#[^0-9]+$ 匹配出 /html/html-tutorial.html ，&lt;span&gt;解法三：与解法二类似，引用位置关系&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;机制解题的关键：在理解基础解题的基础上，搭配*可变0及正则匹配流程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[root@s1 ~]# echo $a | &lt;span&gt;grep -oE '(/\w+/.*)*([^:/])*'&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解题过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1 (/\w+/.*)*  由于有*，整个表达式可以变0，所以从url的第一个字符开始匹对都失败，直到/html/html-tutorial.html 才匹对成功，产生占有字符。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2 匹对过程： (/\w+/.*)* 已经匹对完整个内容了，但正则表达式 &lt;/span&gt;&lt;span&gt;([^:/])* 还没有匹对，所以&lt;span&gt; ([^:/])*&lt;/span&gt;&lt;span&gt;从头开始匹对&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3 贪婪与回溯：当 ([^:/])* 将/html/html-tutorial.html分解多个单词，而 (/\w+/.*)* 就一个单词，按贪婪原则 ，(/\w+/.*)*胜出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：一个正则表达式产生占有字符，不代表其他表达式就不会对该占有字符对应的内容重新匹对，&lt;span&gt;因为占有字符的最终确定是贪婪机制&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;占有字符&lt;/span&gt;与&lt;span&gt;零宽度&lt;/span&gt;是正则&lt;span&gt;匹对原理的基础&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;占有字符主要是&lt;span&gt;对字符 [ 组合 ] 的排序搜索方式&lt;/span&gt;的工作机制：核心就是正则表达式不会重复匹对已经匹配出结果的内容，及得出临时的结果（占有字符）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;caption&gt;&lt;span&gt;使用 RegexBuddy 帮助理解占位符，回溯，贪婪&lt;/span&gt;&lt;/caption&gt;
&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;19&quot;&gt;&lt;td readability=&quot;32&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@server01 ~]# echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | grep -E --color &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a.*1.*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  
abc123
[root@server01 &lt;/span&gt;~]# &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;匹对过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;a&lt;/span&gt;  #正则表达式第一个是字符a本身，这个直接匹对上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;bc123&lt;/span&gt;  # 表达式a.*中的&lt;span&gt;.*直接匹对后续的bc123&lt;span&gt;，因为.*代表任意无限的字符组合，体现的贪婪机制&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;a&lt;/span&gt;bc123  &lt;span&gt;#回溯开始。&lt;/span&gt;因为1.*表达式中的1是字符本身，&lt;span&gt;优先级比上一个表达式a.*中的.*要高&lt;/span&gt;，所以要产生回溯。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;a&lt;/span&gt;bc12    &lt;span&gt;#回溯要回溯到那个地点才行能？&lt;/span&gt;&lt;/span&gt;&lt;span&gt;理论上要证明表达式的字符1是在内容的字符排序中的第一&lt;/span&gt;个出现，并且在与a.*所对应的字符串中没有1，那么a.*所对应的字符串就是&lt;span&gt;占有字符&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;a&lt;/span&gt;bc12 &lt;span&gt;   #回溯开始。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;a&lt;/span&gt;bc1      #&lt;span&gt;还不能证明表达式字符1是在内容的字符排序中的第一个出现，但记录下第一次遇到字符1及位置&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;a&lt;/span&gt;bc1      #回溯开始。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;a&lt;/span&gt;bc        #a.*中.*匹对成功，并且没有字符1，故a.*的&lt;span&gt;占有字符产生（就是内容的abc）&lt;/span&gt;。也就是a.*可以退出这个正则匹对的舞台了。那么剩下的就到1.*上阵了&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;a&lt;/span&gt;bc&lt;span&gt;1&lt;/span&gt;      #1.*正则表达式中的字符1与内容的字符1匹对成功&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;a&lt;/span&gt;bc&lt;span&gt;1&lt;/span&gt;23  #1.*完成匹对内容的123&lt;span&gt;（数字123就是占有字符）&lt;/span&gt;，到此正则的比对完成。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt; &lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;零宽度主要是对&lt;span&gt;字符 [ 组合 ] 位置搜索方式&lt;/span&gt;的工作机制：核心就是让正则表达式在那个位置开始匹对，后续工作交由&lt;span&gt;对字符 [ 组合 ] 的排序搜索方式&lt;span&gt;接管&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;caption&gt;零宽度一般在一组表达式中有多选一时生效&lt;/caption&gt;
&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@server01 ~]# echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | grep -Eo --color &lt;span&gt;'&lt;/span&gt;&lt;span&gt;^(a..|1..)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
abc
[root@server01 &lt;/span&gt;~]# echo &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | grep -Eo --color &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a..|1..&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;   
abc
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;
[root@server01 &lt;/span&gt;~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 分析过程&lt;/p&gt;
&lt;p&gt;正则表达式 ^(a..|1..)中的 a.. 在内容的开始位置开始比较，1.. 依然在内容的开始位置开始比较，所以最终结果只能是 a.. 正则表达式能匹对abc123中的abc&lt;/p&gt;
&lt;p&gt;正则表达式 a..|1.. 的原理基本上，同上述的&lt;span&gt;对字符 [ 组合 ] 的排序搜索方式&lt;/span&gt;差不多了。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Wed, 03 Oct 2018 05:12:00 +0000</pubDate>
<dc:creator>3L&amp;#183;BoNuo&amp;#183;Lotus</dc:creator>
<og:description>相关好文章推荐： shell命令行的解析原理（单双无引号与字符及通配符的关系）：http://www.cnblogs.com/f-ck-need-u/p/7426371.html 正则表达式里是如何表</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BoNuo/p/9736666.html</dc:identifier>
</item>
</channel>
</rss>