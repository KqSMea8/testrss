<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>python中的赋值与深浅拷贝 - doublexi</title>
<link>http://www.cnblogs.com/doublexi/p/8745792.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/doublexi/p/8745792.html</guid>
<description>&lt;p&gt;Python当中对于拷贝，分为两种类型。一种是数字和字符串，另一种就是列表、元组、字典等其他类型了。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;1、赋值&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
a1 = 123123&lt;span&gt;
a2 &lt;/span&gt;= 123123
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; a2 = a1  # 赋值&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(id(a1))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过id()函数来打印变量在内存当中的地址&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(id(a2))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
1959780298352
1959780298352　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在以上代码块当中，a2与a1所赋的值是一样的，都是数字123123。因为python有一个重用机制，对于同一个数字，python并不会开辟一块新的内存空间，而是维护同一块内存地址，只是将该数字对应的内存地址的引用赋值给变量a1和a2。所以根据输出结果，a1和a2其实对应的是同一块内存地址，只是两个不同的引用罢了。同样的，对于a2 = a1，其实效果等同于“a1 = 123123; a2 = 123123”，它也就是将a1指向123123的引用赋值给a2。字符串跟数字的原理雷同，如果把123123改成“abcabc”也是一样的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：对于通过用 = 号赋值，数字和字符串在内存当中用的都是同一块地址。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;2、浅拷贝&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; copy  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用浅拷贝需要导入copy模块&lt;/span&gt;
&lt;span&gt; 
a1 &lt;/span&gt;= 123123&lt;span&gt;
a3 &lt;/span&gt;= copy.copy(a1)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用copy模块里的copy()函数就是浅拷贝了&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(id(a1))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(id(a3))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
35233168
35233168
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过使用copy模块里的copy()函数来进行浅拷贝，把a1拷贝一份赋值给a3，查看输出结果发现，a1和a3的内存地址还是一样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：对于浅拷贝，数字和字符串在内存当中用的也是同一块地址。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt; 3、深拷贝&lt;/h2&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; copy

a1 &lt;/span&gt;= 123123&lt;span&gt;
a4 &lt;/span&gt;= copy.deepcopy(a1)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 深拷贝是用copy模块里的deepcopy()函数&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(id(a1))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(id(a4))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
31432080
31432080
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看结果发现，对于深拷贝，数字和字符串在内存当中用的也是同一块地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以综上所述，对于数字和字符串的赋值、浅拷贝、深拷贝在内存当中用的都是同一块地址。&lt;/strong&gt;原理如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1307747/201804/1307747-20180409142513906-81843973.png&quot; alt=&quot;&quot; width=&quot;440&quot; height=&quot;332&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;1、赋值&lt;/h2&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
n1 = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 123, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 678&lt;span&gt;]}
n2 &lt;/span&gt;=&lt;span&gt; n1  # 赋值
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(id(n1))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(id(n2))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
2235551677536
2235551677536
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们的栗子当中用了一个字典n1，字典里面嵌套了一个列表，当我们把n1赋值给n2时，内存地址并没有发生变化，因为其实它也是只是把n1的引用拿过来赋值给n2而已。（我们用了一个字典来举例，其他类型也是一样的）&lt;/p&gt;
&lt;p&gt;原理如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1307747/201804/1307747-20180409143916437-1877441324.png&quot; alt=&quot;&quot; width=&quot;436&quot; height=&quot;299&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;br/&gt;&lt;strong&gt;结论：对于赋值，字典、列表、元组等其他类型用的内存地址不会变化。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt; 2、浅拷贝&lt;/h2&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; copy

n1 &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 123, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 678&lt;span&gt;]}
n3 &lt;/span&gt;=&lt;span&gt; copy.copy(n1)  # 浅拷贝
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第一层字典的内存地址：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(id(n1))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(id(n3))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第二层嵌套的列表的内存地址：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(id(n1[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(id(n3[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;第一层字典的内存地址：
&lt;/span&gt;6516024
6516096&lt;span&gt;
第二层嵌套的列表的内存地址：
&lt;/span&gt;36995720
36995720
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过以上结果可以看出，进行浅拷贝时，我们的字典第一层n1和n3指向的内存地址已经改变了，但是对于第二层里的列表并没有拷贝，它的内存地址还是一样的。原理如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1307747/201804/1307747-20180409145414483-599873973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 结论：所以对于浅拷贝，字典、列表、元组等类型，它们只拷贝第一层地址。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;3、深拷贝&lt;/h2&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; copy

n1 &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: 123, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 678&lt;span&gt;]}
n4 &lt;/span&gt;=&lt;span&gt; copy.deepcopy(n1)  # 深拷贝
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第一层字典的内存地址：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(id(n1))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(id(n4))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第二层嵌套的列表的内存地址：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(id(n1[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(id(n4[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;k3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;第一层字典的内存地址：
&lt;/span&gt;31157560
35463600&lt;span&gt;
第二层嵌套的列表的内存地址：
&lt;/span&gt;35947144
35947336
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过以上结果发现，进行深拷贝时，字典里面的第一层和里面嵌套的地址都已经变了。对于深拷贝，它会拷贝多层，将第二层的列表也拷贝一份，如果还有第三层嵌套，那么第三层的也会拷贝，但是对于里面的最小元素，比如数字和字符串，这里就是“wu”，123，“alex”，678之类的，按照python的机制，它们会共同指向同一个位置，它的内存地址是不会变的。原理如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1307747/201804/1307747-20180409150810831-60038028.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：对于深拷贝，字典、列表、元组等类型，它里面嵌套多少层，就会拷贝多少层出来，但是最底层的数字和字符串地址不变。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个实际应用场景的栗子。&lt;/p&gt;
&lt;p&gt;我们在维护服务器信息的时候，经常会要更新服务器信息，这时我们重新一个一个添加是比较麻烦的，我们可以把原数据类型拷贝一份，在它的基础上做修改。&lt;/p&gt;
&lt;p&gt;栗子一、使用浅拷贝&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; copy


dic &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [80&lt;span&gt;, ],
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [80&lt;span&gt;, ],
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;disk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [80&lt;span&gt;, ]
}
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义了一个字典，存储服务器信息。&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;before&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, dic)
new_dic &lt;/span&gt;=&lt;span&gt; copy.copy(dic)
new_dic[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][0] = 50  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更新cpu为50&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(dic)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(new_dic)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
before {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [80], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [80], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;disk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [80&lt;span&gt;]}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [50], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [80], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;disk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [80&lt;span&gt;]}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [50], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [80], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;disk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [80]}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时我们会发现，使用浅拷贝时，我们修改新的字典的值之后，原来的字典里面的cpu值也被修改了，这并不是我们希望看到的。&lt;/p&gt;
&lt;p&gt;栗子二、使用深拷贝&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; copy


dic &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [80&lt;span&gt;, ],
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [80&lt;span&gt;, ],
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;disk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [80&lt;span&gt;, ]
}
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;before&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, dic)
new_dic &lt;/span&gt;=&lt;span&gt; copy.deepcopy(dic)
new_dic[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;][0] = 50
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(dic)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(new_dic)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
before {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [80], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [80], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;disk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [80&lt;span&gt;]}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [80], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [80], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;disk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [80&lt;span&gt;]}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [50], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [80], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;disk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: [80]}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用深拷贝的时候，发现只有新的字典的cpu值被修改了，原来的字典里面的cpu值没有变。大功告成！&lt;/p&gt;
&lt;p&gt; 注：本文是根据老男孩课程内容整理而成的，图片也是出自武sir的，因为原文我找不到了，所以下面贴一下武sir的博客地址。本文仅供个人笔记使用，如果有侵犯，请联系我，我立即撤销。&lt;/p&gt;
&lt;p&gt;武sir博客地址：http://www.cnblogs.com/wupeiqi/&lt;/p&gt;
</description>
<pubDate>Mon, 09 Apr 2018 07:33:00 +0000</pubDate>
<dc:creator>doublexi</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/doublexi/p/8745792.html</dc:identifier>
</item>
<item>
<title>ASP.NET Web API编程——模型验证与绑定 - 甜橙很酸</title>
<link>http://www.cnblogs.com/hdwgxz/p/8759886.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hdwgxz/p/8759886.html</guid>
<description>&lt;p&gt; &lt;strong&gt;&lt;span&gt;1.模型验证&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用特性约束模型属性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以使用&lt;/span&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/system.componentmodel.dataannotations.aspx&quot;&gt;System.ComponentModel.DataAnnotations&lt;/a&gt;&lt;span&gt;提供的特性来限制模型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，&lt;/span&gt;Required特性表示字段值不能为空，Range特性限制数值类型的范围。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对实体类使用特性后，可以使用&lt;/span&gt;ModelState.IsValid来判断验证是否通过。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实体：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DataModel
{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Field1Name {&lt;span&gt;get&lt;/span&gt;;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}
        [Required]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Field2Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;控制器操作：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IHttpActionResult ModelValid(DataModel model)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ModelState.IsValid)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpResponseException(HttpStatusCode.BadRequest);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(model);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;客户端调用：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
            HttpClient client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost/WebApi_Test/api/account/modelvalid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (HttpRequestMessage request = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpRequestMessage(HttpMethod.Post, url))
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cont = &lt;span&gt;new&lt;/span&gt; { Id = &lt;span&gt;1&lt;/span&gt;, Field1Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
                HttpContent content &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringContent(JsonConvert.SerializeObject(cont));
                content.Headers.ContentType &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MediaTypeHeaderValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                request.Content &lt;/span&gt;=&lt;span&gt; content;
                HttpResponseMessage response &lt;/span&gt;=&lt;span&gt; client.SendAsync(request).Result;
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;状态码：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)response.StatusCode);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; task =&lt;span&gt; response.Content.ReadAsStringAsync();
                task.Wait();
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;结果：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, task.Result);
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201804/1024858-20180409143529361-2128015330.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;服务端运行截图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201804/1024858-20180409143608851-1566665724.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;若客户端传值为：&lt;/span&gt;var cont = new { Id = 1, Field1Name = &quot;1name&quot;, Field2Name=&quot;2name&quot; };&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201804/1024858-20180409143643003-1943338322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;默认赋值&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Web API会对客户端未指定的模型属性赋初值。对于int,double等数值类型默认的初值为0，对于字符串或引用类型默认的初值是null。如果未对属性使用特性加以约束，那么ModelState.IsValid的值就是true，若对这样的属性应用Required特性，那么当客户端为对其赋初值时，验证将无法通过，即ModelState.IsValid的值为false。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上例中不对&lt;/span&gt;Id属性赋值，运行客户端结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201804/1024858-20180409143729961-884094695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可见框架自动为&lt;/span&gt;int&lt;span&gt;型的&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;赋初值&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;过载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此外当客户端所用实体属性&lt;/span&gt;&lt;span&gt;多&lt;/span&gt;&lt;span&gt;于服务端时，服务端会忽略多出来的属性，但建议控制器操作（&lt;/span&gt;Action）所用参数列表的参数或类属性与客户端所传参数完全匹配。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若使用上述客户端，但传值为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;var cont = new { Field1Name = &quot;1name&quot;, Field2Name = &quot;2name&quot;,FieldOverLoad =&quot;overload&quot;};&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中&lt;/span&gt;DataModel&lt;span&gt;不包含&lt;/span&gt;FieldOverLoad &lt;span&gt;字段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201804/1024858-20180409143826621-631777165.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;过滤验证结果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以自定义操作过滤器来统一处理模型验证失败的情形。自定义操作过滤器派生自&lt;/span&gt;ActionFilterAttribute，我们需要重写OnActionExecuting方法，以便在操作（Action）调用之前处理。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web.Http.Controllers;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web.Http.Filters;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web.Http.ModelBinding;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; MyApi.Filters
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValidateModelAttribute : ActionFilterAttribute
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActionExecuting(HttpActionContext actionContext)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (actionContext.ModelState.IsValid == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
            {
                actionContext.Response &lt;/span&gt;=&lt;span&gt; actionContext.Request.CreateErrorResponse(
                    HttpStatusCode.BadRequest, actionContext.ModelState);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;在&lt;/span&gt;WebApiConfig的Register方法中将上述自定义过滤器添加进来，这样过滤器对每一个操作（Action）都起作用，如果不想使其对每一个操作都起作用，而是想应用于个别操作（Action），可以将此特性应用到目标操作（Action）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebApiConfig
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Register(HttpConfiguration config)
    {
        config.Filters.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ValidateModelAttribute());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProductsController : ApiController
{
    [ValidateModel]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpResponseMessage Post(Product product)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2模型绑定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;默认的绑定规则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;如果操作（&lt;/span&gt;Action）参数是简单类型，Web API框架会从URI中获取值。简单类型是指：.NET 框架定义的原始类型（int, bool, double等）、TimeSpan、DateTime、Guid、decimal、string；另外还有包含类型转换器的类型，改转换器可将字符串转换为此类型。这里从URI获取值具体指：从路由词典中获取值或者从URI的查询字符串中获取值。具体过程见介绍路由那篇博文。&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;对于复杂类型，&lt;/span&gt;Web API会使用多媒体格式化器从消息体中获得值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;类型转换&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认的模型绑定规则中提及了包含类型转换器的类型也是简单类型。类型转换器可以使类也被看做简单类型。这样按照默认的规则就可以从&lt;/span&gt;URI中获取值来构建参数列表了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：使用&lt;/span&gt;TypeConverter特性指明所使用的类型转换器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
[TypeConverter(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(GeoPointConverter))]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GeoPoint
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Latitude { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Longitude { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; TryParse(&lt;span&gt;string&lt;/span&gt; s, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; GeoPoint result)
    {
        result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; parts = s.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parts.Length != &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; latitude, longitude;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;double&lt;/span&gt;.TryParse(parts[&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;out&lt;/span&gt; latitude) &amp;amp;&amp;amp;
            &lt;span&gt;double&lt;/span&gt;.TryParse(parts[&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;out&lt;/span&gt;&lt;span&gt; longitude))
        {
            result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; GeoPoint() { Longitude = longitude, Latitude =&lt;span&gt; latitude };
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; GeoPointConverter : TypeConverter
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sourceType == &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.CanConvertFrom(context, sourceType);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; ConvertFrom(ITypeDescriptorContext context, 
        CultureInfo culture, &lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt; value)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value &lt;span&gt;is&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;)
        {
            GeoPoint point;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (GeoPoint.TryParse((&lt;span&gt;string&lt;/span&gt;)value, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; point))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; point;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.ConvertFrom(context, culture, value);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用&lt;/span&gt;[FromUri]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了强制&lt;/span&gt;Web API从URI中取值，可以使用FromUri特性。这样即使操作（Action）参数是复杂类型，框架也会中URI中取值来为参数赋值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;使用&lt;/span&gt;[&lt;/strong&gt;&lt;strong&gt;FromBody&lt;/strong&gt;&lt;strong&gt;]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了强制&lt;/span&gt;Web API从消息体中取值，可以使用FromBody&lt;span&gt;特性。这样即使操作（&lt;/span&gt;Action）参数是简单类型，框架也会从消息体中取值来为参数赋值。当使用FromBody&lt;span&gt;特性时，&lt;/span&gt;Web API使用请求的Content-Type标头来选择格式化器。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：对多个参数使用&lt;/span&gt;FromBody&lt;span&gt;不起作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务端操作为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IHttpActionResult ModelValid([FromBody]DataModel model)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ModelState.IsValid)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpResponseException(HttpStatusCode.BadRequest);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(model);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;客户端调用为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
            HttpClient client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost/WebApi_Test/api/account/modelvalid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (HttpRequestMessage request = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpRequestMessage(HttpMethod.Post, url))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;var cont = new { Id = 1, Field1Name = &quot;111&quot; };&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; cont = &lt;span&gt;new&lt;/span&gt; { Field1Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Field2Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;};
                HttpContent content &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringContent(JsonConvert.SerializeObject(cont));
                content.Headers.ContentType &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MediaTypeHeaderValue(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                request.Content &lt;/span&gt;=&lt;span&gt; content;
                HttpResponseMessage response &lt;/span&gt;=&lt;span&gt; client.SendAsync(request).Result;
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;状态码：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)response.StatusCode);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; task =&lt;span&gt; response.Content.ReadAsStringAsync();
                task.Wait();
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;结果：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, task.Result);
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行客户端可以正常获得结果，若使用&lt;/span&gt;FromUri，无法通过模型绑定验证，也无法获得结果。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;改变客户端传值的方式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
            HttpClient client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost/WebApi_Test/api/account/modelvalid?Field1Name=1name&amp;amp;Field2Name=2name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (HttpRequestMessage request = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpRequestMessage(HttpMethod.Post, url))
            {
                HttpResponseMessage response &lt;/span&gt;=&lt;span&gt; client.SendAsync(request).Result;
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;状态码：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)response.StatusCode);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; task =&lt;span&gt; response.Content.ReadAsStringAsync();
                task.Wait();
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;结果：{0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, task.Result);
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;运行结果为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201804/1024858-20180409144329189-531704267.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;自定义模型绑定器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模型绑定器从值提供器（&lt;/span&gt;value provider）中获得原始输入，这种设计拆分出两个不同的功能：&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;值提供器使用&lt;/span&gt;HTTP请求并且填充一个词典。&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;模型绑定器使用这个词典填充模型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;默认的值提供器从请求&lt;/span&gt;URI的查询字符串和路由词典中获取值。要绑定的参数的名称保存在ModelBindingContext.ModelName属性中，模型绑定器在词典中找相应的键值对。如果键值对存在，并且能够转换为待处理模型，模型绑定器分配绑定值给ModelBindingContext.Model属性。模型绑定器不会限制简单类型的转换。自定义模型绑定器需要实现IModelBinder接口。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GeoPointModelBinder : IModelBinder
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; List of known locations.&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ConcurrentDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, GeoPoint&amp;gt;&lt;span&gt; _locations
        &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConcurrentDictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, GeoPoint&amp;gt;&lt;span&gt;(StringComparer.OrdinalIgnoreCase);

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; GeoPointModelBinder()
    {
        _locations[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redmond&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;new&lt;/span&gt; GeoPoint() { Latitude = &lt;span&gt;47.67856&lt;/span&gt;, Longitude = -&lt;span&gt;122.131&lt;/span&gt;&lt;span&gt; };
        _locations[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;paris&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;new&lt;/span&gt; GeoPoint() { Latitude = &lt;span&gt;48.856930&lt;/span&gt;, Longitude = &lt;span&gt;2.3412&lt;/span&gt;&lt;span&gt; };
        _locations[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tokyo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;new&lt;/span&gt; GeoPoint() { Latitude = &lt;span&gt;35.683208&lt;/span&gt;, Longitude = &lt;span&gt;139.80894&lt;/span&gt;&lt;span&gt; };
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; BindModel(HttpActionContext actionContext, ModelBindingContext bindingContext)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bindingContext.ModelType != &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(GeoPoint))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        ValueProviderResult val &lt;/span&gt;=&lt;span&gt; bindingContext.ValueProvider.GetValue(
            bindingContext.ModelName);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (val == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; key = val.RawValue &lt;span&gt;as&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            bindingContext.ModelState.AddModelError(
                bindingContext.ModelName, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wrong value type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

        GeoPoint result;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_locations.TryGetValue(key, &lt;span&gt;out&lt;/span&gt; result) || GeoPoint.TryParse(key, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; result))
        {
            bindingContext.Model &lt;/span&gt;=&lt;span&gt; result;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        bindingContext.ModelState.AddModelError(
            bindingContext.ModelName, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cannot convert value to Location&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;使用上述自定义的模型绑定器的方式有多种。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;方式一、对于一个操作（&lt;/span&gt;Action）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; HttpResponseMessage Get([ModelBinder(&lt;span&gt;typeof&lt;/span&gt;(GeoPointModelBinder))] GeoPoint location)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;方式二、对于一个控制器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[ModelBinder(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(GeoPointModelBinder))]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GeoPoint
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ....&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;方式三、注册模型绑定器后，依然要使用在操作上使用特性，不过不用指定类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebApiConfig
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Register(HttpConfiguration config)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; provider = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleModelBinderProvider(
            &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(GeoPoint), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GeoPointModelBinder());
        config.Services.Insert(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(ModelBinderProvider), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, provider);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;    }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HttpResponseMessage Get([ModelBinder] GeoPoint location) { ... }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;自定义值提供器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;模型绑定器从值提供器中获取值，自定义值提供器需要实现&lt;/span&gt;IValueProvider接口。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CookieValueProvider : IValueProvider
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; _values;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CookieValueProvider(HttpActionContext actionContext)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (actionContext == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;actionContext&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        _values &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(StringComparer.OrdinalIgnoreCase);
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; cookie &lt;span&gt;in&lt;/span&gt;&lt;span&gt; actionContext.Request.Headers.GetCookies())
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (CookieState state &lt;span&gt;in&lt;/span&gt;&lt;span&gt; cookie.Cookies)
            {
                _values[state.Name] &lt;/span&gt;=&lt;span&gt; state.Value;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ContainsPrefix(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; prefix)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _values.Keys.Contains(prefix);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ValueProviderResult GetValue(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
    {
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; value;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_values.TryGetValue(key, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; value))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ValueProviderResult(value, value, CultureInfo.InvariantCulture);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;创建值提供器工厂，其派生自&lt;/span&gt;ValueProviderFactory&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CookieValueProviderFactory : ValueProviderFactory
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; IValueProvider GetValueProvider(HttpActionContext actionContext)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CookieValueProvider(actionContext);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;注册值提供器工厂。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Register(HttpConfiguration config)
{
    config.Services.Add(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(ValueProviderFactory), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CookieValueProviderFactory());

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;使用值提供器工厂，指定使用&lt;/span&gt;CookieValueProvider。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpResponseMessage Get(
[ValueProvider(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(CookieValueProviderFactory))] GeoPoint location)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;自定义&lt;/span&gt;HttpParameterBinding&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ModelBinderAttribute&lt;span&gt;继承自&lt;/span&gt;ParameterBindingAttribute&lt;span&gt;，&lt;/span&gt;ParameterBindingAttribute&lt;span&gt;继承自&lt;/span&gt;Attribute&lt;span&gt;，&lt;/span&gt;ParameterBindingAttribute&lt;span&gt;只有一个方法&lt;/span&gt;GetBinding&lt;span&gt;，改&lt;/span&gt;=该方法返回HttpParameterBinding&lt;span&gt;。&lt;/span&gt;HttpParameterBinding&lt;span&gt;代表了参数与值之间的绑定关系。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ModelBinderAttribute : ParameterBindingAttribute
{......}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ParameterBindingAttribute : Attribute
{
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; ParameterBindingAttribute();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获得参数绑定
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; parameter:参数描述&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; HttpParameterBinding GetBinding(HttpParameterDescriptor parameter);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;例：利用请求头中的&lt;/span&gt;if-match&lt;span&gt;或&lt;/span&gt;if-none-match&lt;span&gt;获得&lt;/span&gt;ETags&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ETag
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Tag { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; ETagMatch
{
    IfMatch,
    IfNoneMatch
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ETagParameterBinding : HttpParameterBinding
{
    ETagMatch _match;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ETagParameterBinding(HttpParameterDescriptor parameter, ETagMatch match) 
        : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(parameter)
    {
        _match &lt;/span&gt;=&lt;span&gt; match;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Task ExecuteBindingAsync(ModelMetadataProvider metadataProvider, 
        HttpActionContext actionContext, CancellationToken cancellationToken)
    {
        EntityTagHeaderValue etagHeader &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (_match)
        {
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ETagMatch.IfNoneMatch:
                etagHeader &lt;/span&gt;=&lt;span&gt; actionContext.Request.Headers.IfNoneMatch.FirstOrDefault();
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ETagMatch.IfMatch:
                etagHeader &lt;/span&gt;=&lt;span&gt; actionContext.Request.Headers.IfMatch.FirstOrDefault();
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }

        ETag etag &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (etagHeader != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            etag &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ETag { Tag =&lt;span&gt; etagHeader.Tag };
        }
        actionContext.ActionArguments[Descriptor.ParameterName] &lt;/span&gt;=&lt;span&gt; etag;

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tsc = &lt;span&gt;new&lt;/span&gt; TaskCompletionSource&amp;lt;&lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();
        tsc.SetResult(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tsc.Task;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;为使用自定义的&lt;/span&gt;HttpParameterBinding，定义一个派生自ParameterBindingAttribute的类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ETagMatchAttribute : ParameterBindingAttribute
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ETagMatch _match;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ETagMatchAttribute(ETagMatch match)
    {
        _match &lt;/span&gt;=&lt;span&gt; match;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; HttpParameterBinding GetBinding(HttpParameterDescriptor parameter)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parameter.ParameterType == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ETag))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ETagParameterBinding(parameter, _match);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; parameter.BindAsError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wrong parameter type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IfMatchAttribute : ETagMatchAttribute
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IfMatchAttribute()
        : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(ETagMatch.IfMatch)
    {
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IfNoneMatchAttribute : ETagMatchAttribute
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IfNoneMatchAttribute()
        : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(ETagMatch.IfNoneMatch)
    {
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;在控制器操作（&lt;/span&gt;Action）中使用它。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; HttpResponseMessage Get([IfNoneMatch] ETag etag) { ... }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;另外一种使用自定义的&lt;/span&gt;HttpParameterBinding的方式是利用HttpConfiguration.ParameterBindingRules这个属性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
config.ParameterBindingRules.Add(p =&amp;gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p.ParameterType == &lt;span&gt;typeof&lt;/span&gt;(ETag) &amp;amp;&amp;amp;&lt;span&gt; 
        p.ActionDescriptor.SupportedHttpMethods.Contains(HttpMethod.Get))
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ETagParameterBinding(p, ETagMatch.IfNoneMatch);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;可插拔服务&lt;/span&gt;IActionValueBinder&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;整个模型绑定过程是由&lt;/span&gt;IActionValueBinder服务控制器的。其默认实现完成以下工作：&lt;/p&gt;
&lt;p&gt;1）&lt;span&gt;在参数中查找&lt;/span&gt;ParameterBindingAttribute，包括[FromBody], [FromUri], and [ModelBinder], 或者自定义特性。&lt;/p&gt;
&lt;p&gt;2）&lt;span&gt;如果步奏&lt;/span&gt;1）中没有找到，那么在HttpConfiguration.ParameterBindingRules中寻找一个返回值为HttpParameterBinding的方法。&lt;/p&gt;
&lt;p&gt;3）&lt;span&gt;如果没有找到就使用默认规则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果操作（&lt;/span&gt;Action）参数是简单类型，Web API框架会从URI中获取值。简单类型是指：.NET 框架定义的原始类型（int, bool, double等）、TimeSpan、DateTime、Guid、decimal、string；另外还有包含类型转换器的类型，改转换器可将字符串转换为此类型。这里从URI获取值具体指：从路由词典中获取值或者从URI的查询字符串中获取值。具体过程见介绍路由那篇博文。对于复杂类型，Web API会使用多媒体格式化器从消息体中获得值。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;https://docs.microsoft.com/en-us/aspnet/web-api/&lt;/p&gt;
&lt;p&gt;部分示例自于该网站&lt;/p&gt;

&lt;p&gt;---------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;转载与引用请注明出处。&lt;/p&gt;
&lt;p&gt;时间仓促，水平有限，如有不当之处，欢迎指正。&lt;/p&gt;

</description>
<pubDate>Mon, 09 Apr 2018 07:02:00 +0000</pubDate>
<dc:creator>甜橙很酸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hdwgxz/p/8759886.html</dc:identifier>
</item>
<item>
<title>python之celery的使用(一) - 天宇之游</title>
<link>http://www.cnblogs.com/cwp-bg/p/8759638.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cwp-bg/p/8759638.html</guid>
<description>&lt;p&gt;前段时间需要使用rabbitmq做写缓存，一直使用pika+rabbitmq的组合，pika这个模块虽然可以很直观地操作rabbitmq，但是官方给的例子太简单，对其底层原理了解又不是很深，遇到很多坑，尤其是需要自己写连接池管理和channel池管理。虽然也有用过celery，一直也是celery+redis的组合，涉及很浅；目前打算深研一下celery+redis+rabbitmq的使用。&lt;/p&gt;
&lt;h2 id=&quot;celery-rabbitmq初步&quot;&gt;celery + rabbitmq初步&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;我们先不在集成框架如flask或Django中使用，而仅仅单独使用。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;简单介绍&quot;&gt;简单介绍&lt;/h3&gt;
&lt;p&gt;Celery 是一个异步任务队列。一个Celery安装有三个核心组件：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Celery 客户端: 用于发布后台作业。当与 Flask 一起工作的时候，客户端与 Flask 应用一起运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Celery workers: 运行后台作业的进程。Celery 支持本地和远程的 workers，可以在 Flask 服务器上启动一个单独的 worker，也可以在远程服务器上启动worker，需要拷贝代码；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;消息代理: 客户端通过消息队列和 workers 进行通信，Celery 支持多种方式来实现这些队列。最常用的代理就是 RabbitMQ 和 Redis。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;安装rabbitmq和redis&quot;&gt;安装rabbitmq和redis&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;sudo pip install redis&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;sudo pip install celery[librabbitmq]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;初步使用&quot;&gt;初步使用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用redis做结果存储，使用rabbitmq做任务队列；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# tasks.py
from celery import Celery

app = Celery('tasks', broker='amqp://username:passwd@ip:port/varhost',backend='redis://username:passwd@ip:6390/db')

@app.task
def add(x, y):
    return x + y

if __name__ == '__main__':
    result = add.delay(30, 42)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;发生了什么事&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;app.task装饰后将add函数变成一个异步的任务，add.delay函数将任务序列化发送到rabbitmq；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;该过程创建一个名字为celery的exchange，类型为direct（直连交换机）;创建一个名为celery的queue，队列和交换机使用路由键celery绑定；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;打开rabbitmq管理后台，可以看到有一条消息已经在celery队列中；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;记住：&lt;/strong&gt;当有多个装饰器的时候，celery.task一定要在最外层；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩展&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果使用redis作为任务队列中间人，在redis中存在两个键 celery 和 _kombu.binding.celery ， _kombu.binding.celery 表示有一名为 celery 的任务队列（Celery 默认），而 celery为默认队列中的任务列表，使用list类型，可以看看添加进去的任务数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;开启worker&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在task.py同一个目录下执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;celery -A tasks worker --loglevel=info&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;task指的就是该celery任务的名字，注意文件名tasks.py和创建celery对象的名字必须一致，否则wroker启动失败；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;执行完毕后结果存储在redis中，查看redis中的数据，发现存在一个string类型的键值对：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;celery-task-meta-064e4262-e1ba-4e87-b4a1-52dd1418188f:data&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该键值对的失效时间为24小时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析消息&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这是添加到任务队列中的消息数据。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;{&quot;body&quot;: &quot;gAJ9cQAoWAQAAAB0YXNrcQFYGAAAAHRlc3RfY2VsZXJ5LmFkZF90b2dldGhlcnECWAIAAABpZHEDWCQAAAA2NmQ1YTg2Yi0xZDM5LTRjODgtYmM5OC0yYzE4YjJjOThhMjFxBFgEAAAAYXJnc3EFSwlLKoZxBlgGAAAAa3dhcmdzcQd9cQhYBwAAAHJldHJpZXNxCUsAWAMAAABldGFxCk5YBwAAAGV4cGlyZXNxC05YAwAAAHV0Y3EMiFgJAAAAY2FsbGJhY2tzcQ1OWAgAAABlcnJiYWNrc3EOTlgJAAAAdGltZWxpbWl0cQ9OToZxEFgHAAAAdGFza3NldHERTlgFAAAAY2hvcmRxEk51Lg==&quot;,   # body是序列化后使用base64编码的信息，包括具体的任务参数，其中包括了需要执行的方法、参数和一些任务基本信息
&quot;content-encoding&quot;: &quot;binary&quot;, # 序列化数据的编码方式
&quot;content-type&quot;: &quot;application/x-python-serialize&quot;,  # 任务数据的序列化方式，默认使用python内置的序列化模块pickle
&quot;headers&quot;: {}, 
&quot;properties&quot;: 
        {&quot;reply_to&quot;: &quot;b7580727-07e5-307b-b1d0-4b731a796652&quot;,       # 结果的唯一id
        &quot;correlation_id&quot;: &quot;66d5a86b-1d39-4c88-bc98-2c18b2c98a21&quot;,  # 任务的唯一id
        &quot;delivery_mode&quot;: 2, 
        &quot;delivery_info&quot;: {&quot;priority&quot;: 0, &quot;exchange&quot;: &quot;celery&quot;, &quot;routing_key&quot;: &quot;celery&quot;},  # 指定交换机名称，路由键，属性
        &quot;body_encoding&quot;: &quot;base64&quot;, # body的编码方式
        &quot;delivery_tag&quot;: &quot;bfcfe35d-b65b-4088-bcb5-7a1bb8c9afd9&quot;}}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;将序列化消息反序列化&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;24&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; pickle
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; base64

result &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; 

base64.b64decode(&lt;span class=&quot;st&quot;&gt;'gAJ9cQAoWAQAAAB0YXNrcQFYGAAAAHRlc3RfY2VsZXJ5LmFkZF90b2dldGhlcnECWAIAAABpZHEDWCQAAAA2NmQ1YTg2Yi0xZDM5LTRjODgtYmM5OC0yYzE4YjJjOThhMjFxBFgEAAAAYXJnc3EFSwlLKoZxBlgGAAAAa3dhcmdzcQd9cQhYBwAAAHJldHJpZXNxCUsAWAMAAABldGFxCk5YBwAAAGV4cGlyZXNxC05YAwAAAHV0Y3EMiFgJAAAAY2FsbGJhY2tzcQ1OWAgAAABlcnJiYWNrc3EOTlgJAAAAdGltZWxpbWl0cQ9OToZxEFgHAAAAdGFza3NldHERTlgFAAAAY2hvcmRxEk51Lg=='&lt;/span&gt;)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(pickle.loads(result))

&lt;span class=&quot;co&quot;&gt;# 结果&lt;/span&gt;
{
    &lt;span class=&quot;st&quot;&gt;'task'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'test_celery.add_together'&lt;/span&gt;,  &lt;span class=&quot;co&quot;&gt;# 需要执行的任务&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;'id'&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;'66d5a86b-1d39-4c88-bc98-2c18b2c98a21'&lt;/span&gt;,  &lt;span class=&quot;co&quot;&gt;# 任务的唯一id&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;'args'&lt;/span&gt;: (&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;42&lt;/span&gt;),   &lt;span class=&quot;co&quot;&gt;# 任务的参数&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;'kwargs'&lt;/span&gt;: {},      
    &lt;span class=&quot;co&quot;&gt;'retries'&lt;/span&gt;: &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, 
    &lt;span class=&quot;co&quot;&gt;'eta'&lt;/span&gt;: &lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, 
    &lt;span class=&quot;co&quot;&gt;'expires'&lt;/span&gt;: &lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, &lt;span class=&quot;co&quot;&gt;# 任务失效时间&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;'utc'&lt;/span&gt;: &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;, 
    &lt;span class=&quot;co&quot;&gt;'callbacks'&lt;/span&gt;: &lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, &lt;span class=&quot;co&quot;&gt;# 完成后的回调&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;'errbacks'&lt;/span&gt;: &lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;,  &lt;span class=&quot;co&quot;&gt;# 任务失败后的回调&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;'timelimit'&lt;/span&gt;: (&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, &lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;), &lt;span class=&quot;co&quot;&gt;# 超时时间&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;'taskset'&lt;/span&gt;: &lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;, 
    &lt;span class=&quot;co&quot;&gt;'chord'&lt;/span&gt;: &lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;常见的数据序列化方式&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;binary: 二进制序列化方式；python的pickle默认的序列化方法；
json:json 支持多种语言, 可用于跨语言方案，但好像不支持自定义的类对象；
XML:类似标签语言；
msgpack:二进制的类 json 序列化方案, 但比 json 的数据结构更小, 更快；
yaml:yaml 表达能力更强, 支持的数据类型较 json 多, 但是 python 客户端的性能不如 json&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;经过比较，为了保持跨语言的兼容性和速度，采用msgpack或json方式；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;celery配置&quot;&gt;celery配置&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;celery的性能和许多因素有关，比如序列化的方式，连接rabbitmq的方式，多进程、单线程等等；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;基本配置项&quot;&gt;基本配置项&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;CELERY_DEFAULT_QUEUE：默认队列
BROKER_URL  : 代理人的网址
CELERY_RESULT_BACKEND：结果存储地址
CELERY_TASK_SERIALIZER：任务序列化方式
CELERY_RESULT_SERIALIZER：任务执行结果序列化方式
CELERY_TASK_RESULT_EXPIRES：任务过期时间
CELERY_ACCEPT_CONTENT：指定任务接受的内容序列化类型(序列化)，一个列表；&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;采用配置文件的方式执行celery&quot;&gt;采用配置文件的方式执行celery&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# main.py
from celery import Celery
import celeryconfig
app = Celery(__name__, include=[&quot;task&quot;])
# 引入配置文件
app.config_from_object(celeryconfig)

if __name__ == '__main__':
    result = add.delay(30, 42)

# task.py
from main import app
@app.task
def add(x, y):
    return x + y  

# celeryconfig.py
BROKER_URL =  'amqp://username:password@localhost:5672/yourvhost'
CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'
CELERY_TASK_SERIALIZER = 'msgpack'
CELERY_RESULT_SERIALIZER = 'msgpack'
CELERY_TASK_RESULT_EXPIRES = 60 * 60 * 24   # 任务过期时间
CELERY_ACCEPT_CONTENT = [&quot;msgpack&quot;]            # 指定任务接受的内容类型.&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;一些方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;r.ready()     # 查看任务状态，返回布尔值,  任务执行完成, 返回 True, 否则返回 False.
r.wait()      # 等待任务完成, 返回任务执行结果，很少使用；
r.get(timeout=1)       # 获取任务执行结果，可以设置等待时间
r.result      # 任务执行结果.
r.state       # PENDING, START, SUCCESS，任务当前的状态
r.status      # PENDING, START, SUCCESS，任务当前的状态
r.successful  # 任务成功返回true
r.traceback  # 如果任务抛出了一个异常，你也可以获取原始的回溯信息&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;celery的装饰方法celery.task&quot;&gt;celery的装饰方法celery.task&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;@celery.task()
def name():
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;task()方法将任务装饰成异步，参数：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;name:可以显示指定任务的名字；&lt;/p&gt;
&lt;p&gt;serializer：指定序列化的方法；&lt;/p&gt;
&lt;p&gt;bind:一个bool值，设置是否绑定一个task的实例，如果把绑定，task实例会作为参数传递到任务方法中，可以访问task实例的所有的属性，即前面反序列化中那些属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@task(bind=True)  # 第一个参数是self，使用self.request访问相关的属性
def add(self, x, y):
    logger.info(self.request.id)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;base:定义任务的基类，可以以此来定义回调函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import celery

class MyTask(celery.Task):
    # 任务失败时执行
    def on_failure(self, exc, task_id, args, kwargs, einfo):
        print('{0!r} failed: {1!r}'.format(task_id, exc))
    # 任务成功时执行
    def on_success(self, retval, task_id, args, kwargs):
        pass
    # 任务重试时执行
    def on_retry(self, exc, task_id, args, kwargs, einfo):
        pass

@task(base=MyTask)
def add(x, y):
    raise KeyError()

exc:失败时的错误的类型；
task_id:任务的id；
args:任务函数的参数；
kwargs:参数；
einfo:失败时的异常详细信息；
retval:任务成功执行的返回值；
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;另外还可以指定exchange信息等，不过一般不使用；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;调用异步任务的方法&quot;&gt;调用异步任务的方法&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;task.delay():这是apply_async方法的别名,但接受的参数较为简单；
task.apply_async(args=[arg1, arg2], kwargs={key:value, key:value})
send_task():可以发送未被注册的异步任务，即没有被celery.task装饰的任务；&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# tasks.py&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; celery &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Celery
app &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Celery()
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; add(x,y):
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; x&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;y

app.send_task(&lt;span class=&quot;st&quot;&gt;'tasks.add'&lt;/span&gt;,args&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;])  &lt;span class=&quot;co&quot;&gt;# 参数基本和apply_async函数一样&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# 但是send_task在发送的时候是不会检查tasks.add函数是否存在的，即使为空也会发送成功&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;apply_async的参数：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;countdown : 设置该任务等待一段时间再执行，单位为s；&lt;/p&gt;
&lt;p&gt;eta : 定义任务的开始时间；eta=time.time()+10;&lt;/p&gt;
&lt;p&gt;expires : 设置任务时间，任务在过期时间后还没有执行则被丢弃；&lt;/p&gt;
&lt;p&gt;retry : 如果任务失败后, 是否重试;使用true或false，默认为true&lt;/p&gt;
&lt;p&gt;shadow：重新指定任务的名字str，覆盖其在日志中使用的任务名称；&lt;/p&gt;
&lt;p&gt;retry_policy : 重试策略.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;max_retries : 最大重试次数, 默认为 3 次.
interval_start : 重试等待的时间间隔秒数, 默认为 0 , 表示直接重试不等待.
interval_step : 每次重试让重试间隔增加的秒数, 可以是数字或浮点数, 默认为 0.2
interval_max : 重试间隔最大的秒数, 即 通过 interval_step 增大到多少秒之后, 就不在增加了, 可以是数字或者浮点数, 默认为 0.2 .&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;add.apply_async((2, 2), retry=True, retry_policy={
    'max_retries': 3,
    'interval_start': 0,
    'interval_step': 0.2,
    'interval_max': 0.2,
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;routing_key:自定义路由键；&lt;/p&gt;
&lt;p&gt;queue：指定发送到哪个队列；&lt;/p&gt;
&lt;p&gt;exchange：指定发送到哪个交换机；&lt;/p&gt;
&lt;p&gt;priority：任务队列的优先级，0-9之间；&lt;/p&gt;
&lt;p&gt;serializer：任务序列化方法；通常不设置；&lt;/p&gt;
&lt;p&gt;compression：压缩方案，通常有zlib, bzip2&lt;/p&gt;
&lt;p&gt;headers：为任务添加额外的消息；&lt;/p&gt;
&lt;p&gt;link：任务成功执行后的回调方法；是一个signature对象；可以用作关联任务；&lt;/p&gt;
&lt;p&gt;link_error: 任务失败后的回调方法，是一个signature对象；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自定义发布者,交换机,路由键, 队列, 优先级,序列方案和压缩方法:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;task.apply_async((2,2), 
    compression='zlib',
    serialize='json',
    queue='priority.high',
    routing_key='web.add',
    priority=0,
    exchange='web_exchange')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一份比较常用的配置文件&quot;&gt;一份比较常用的配置文件&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# 注意，celery4版本后，CELERY_BROKER_URL改为BROKER_URL
BROKER_URL = 'amqp://username:passwd@host:port/虚拟主机名'
# 指定结果的接受地址
CELERY_RESULT_BACKEND = 'redis://username:passwd@host:port/db'
# 指定任务序列化方式
CELERY_TASK_SERIALIZER = 'msgpack' 
# 指定结果序列化方式
CELERY_RESULT_SERIALIZER = 'msgpack'
# 任务过期时间,celery任务执行结果的超时时间
CELERY_TASK_RESULT_EXPIRES = 60 * 20   
# 指定任务接受的序列化类型.
CELERY_ACCEPT_CONTENT = [&quot;msgpack&quot;]   
# 任务发送完成是否需要确认，这一项对性能有一点影响     
CELERY_ACKS_LATE = True  
# 压缩方案选择，可以是zlib, bzip2，默认是发送没有压缩的数据
CELERY_MESSAGE_COMPRESSION = 'zlib' 
# 规定完成任务的时间
CELERYD_TASK_TIME_LIMIT = 5  # 在5s内完成任务，否则执行该任务的worker将被杀死，任务移交给父进程
# celery worker的并发数，默认是服务器的内核数目,也是命令行-c参数指定的数目
CELERYD_CONCURRENCY = 4 
# celery worker 每次去rabbitmq预取任务的数量
CELERYD_PREFETCH_MULTIPLIER = 4 
# 每个worker执行了多少任务就会死掉，默认是无限的
CELERYD_MAX_TASKS_PER_CHILD = 40 
# 设置默认的队列名称，如果一个消息不符合其他的队列就会放在默认队列里面，如果什么都不设置的话，数据都会发送到默认的队列中
CELERY_DEFAULT_QUEUE = &quot;default&quot; 
# 设置详细的队列
CELERY_QUEUES = {
    &quot;default&quot;: { # 这是上面指定的默认队列
        &quot;exchange&quot;: &quot;default&quot;,
        &quot;exchange_type&quot;: &quot;direct&quot;,
        &quot;routing_key&quot;: &quot;default&quot;
    },
    &quot;topicqueue&quot;: { # 这是一个topic队列 凡是topictest开头的routing key都会被放到这个队列
        &quot;routing_key&quot;: &quot;topic.#&quot;,
        &quot;exchange&quot;: &quot;topic_exchange&quot;,
        &quot;exchange_type&quot;: &quot;topic&quot;,
    },
    &quot;task_eeg&quot;: { # 设置扇形交换机
        &quot;exchange&quot;: &quot;tasks&quot;,
        &quot;exchange_type&quot;: &quot;fanout&quot;,
        &quot;binding_key&quot;: &quot;tasks&quot;,
    },
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;-参考：&lt;/p&gt;
</description>
<pubDate>Mon, 09 Apr 2018 06:40:00 +0000</pubDate>
<dc:creator>天宇之游</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cwp-bg/p/8759638.html</dc:identifier>
</item>
<item>
<title>“认证发布”和“获取展示”，如何在 SharePoint 中正确使用 RSS Feed。 - Caspar.Cui</title>
<link>http://www.cnblogs.com/CasparCui/p/8759603.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CasparCui/p/8759603.html</guid>
<description>&lt;p&gt;在我们进行的日常工作中，是由一部分信息需要 Share 给其他人或者组织的。SharePoint 虽然支持在某个 Site Collection 中互通信息，但是跨 Site Collection 的数据分享就很难通过传统方法实现。一般来说，我们可以使用 Search Content Web Part 来实现其他 Site Collection 的数据表示，但是一旦需要表示的内容发生了变化，与已经写好的 Query text 不相符，表示的内容就有可能出现不全面或者们不能及时更新的问题。&lt;/p&gt;
&lt;p&gt;那么如何准确，及时的更新 SharePoint 中其他 Site Collection 中发布的信息呢？我们可以使用一项 SharePoint 2010 中就已经存在了的“老爷爷”功能，RSS Feed。&lt;/p&gt;
&lt;p&gt;RSS(Really Simple Syndication) - 简易信息聚合，是一种在互联网上广泛被采用的内容包装和投递协议。在互联网发展的前期就已经出现，1999 由网景公司发布 v0.91 版本，此后一直保持更新到 v2.0 版本。其具有以下三个特点：&lt;br/&gt;· 来源多样的个性化“聚合”特性。&lt;br/&gt;· 信息发布的时效、低成本特性。&lt;br/&gt;· 无“垃圾”信息、便利的本地内容管理特性。&lt;/p&gt;
&lt;p&gt;那么 SharePoint 对 RSS 的支持也就是一种对主流互联网功能的支持。当前，SharePoint 的 List 和 Library 均支持 RSS Feed 功能。&lt;/p&gt;
&lt;p&gt;说了这么多前提条件，那么 SharePoint 的 RSS Feed 功能究竟如何使用呢？在进行 RSS 的使用之前，我们先要了解一下 RSS Feed 的工作原理。&lt;/p&gt;
&lt;p&gt;在 SharePoint Server 2016 中，RSS Feed 的应用是需要访问特定的 permission provider，如果是在 Share Point 内部访问，RSS Feed，我们需要匿名访问权限或者 Windows - Kerberos 认证；如果是域外分享或者 SharePoint 外的环境进行访问，那么就只可以使用匿名认证。&lt;/p&gt;
&lt;p&gt;其原因可以参考下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/607239/201804/607239-20180409141729341-1589255502.png&quot; alt=&quot;&quot; width=&quot;1006&quot; height=&quot;601&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从此图可以看出 RSS Feed 的权限认证使用了网页登陆时的认证，并将匿名访问的认证通过 RSS Viewer 传递给了目标 RSS 源。RSS 源确认权限信息（匿名认证也是一种认证） 后将数据源内的信息传递给 RSS Viewer。这时 RSS Viewer 内就可以显示出 RSS Source 中的内容了。这要求RSS 源所在的被参照方 Site 支持匿名访问，这并不是说携带其他认证信息的访问就能访问 RSS 源了，而是无论何种 SharePoint 支持的认证，都可以转换为匿名认证对相关的数据进行访问。所以 RSS 源还是仅接受匿名访问的请求，其他携带权限信息的请求是会被拒绝的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/607239/201804/607239-20180409141809606-2032570912.png&quot; alt=&quot;&quot; width=&quot;1004&quot; height=&quot;564&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从此图可以看出，在 SharePoint 内部，并使用 Kerberos 认证的 RSS Feed 需要参照方和被参照方均支持 Kerberos 认证，且 RSS 可以依据所在 List / Library 的权限配置信息和访问的 Kerberos Token 来决定返回给请求端 RSS Viewer 的信息。也就是说， 利用 Kerberos 认证的 SharePoint Site Collection 间发布的 RSS Feed 是可以根据权限来控制表示在参照端 RSS Viewer 上的内容。&lt;/p&gt;
&lt;p&gt;了解了 RSS Feed 的工作过程，我们就来进行一下 RSS Feed 的相关操作。如果采用 Kerberos 认证的的 RSS Feed ，那么认证的部分只需要在 User 端配置 SPN 信息，以及在 Web Application 的 Authentication Provider 中选择 Windows - Kerberos 类型就可以完成配置了。而使用匿名访问的情况下，我们需要在 Web Application 配置中的 Authentication Provider 处打开匿名认证的同时，在目标 Site 上（或者 List / Library 上）也打开匿名认证，来保证目标 RSS Source 的可访问性。&lt;/p&gt;
&lt;p&gt;下面以实例表示如何开启一个匿名的 RSS Feed 功能：&lt;br/&gt;1，首先打开 Web Application Management，选择 RSS Source 所在的 Web Application 后，点击 Ribbon 上的 [Authentication Provider] 后，勾选匿名访问 [Enable anonymous access] 后，点击确定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/607239/201804/607239-20180409141850986-1916023785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2，打开 RSS Feed 所在的 Site ，并进入 Site Permission Setting 设置页面，点击 Ribbon 上的 [Anonymous Access] ，并在设置界面上将 Anonymous user can access: 的设定改为 [Entire Web site]，之后点击 [OK]，保存设定。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/607239/201804/607239-20180409141858817-749820183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3，打开要使用 RSS Feed 的 Library，在 Ribbon 的 Library Tag 中点击 RSS Feed 按钮，进入 RSS Feed 的发布页面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/607239/201804/607239-20180409141905270-1748574162.png&quot; alt=&quot;&quot; width=&quot;883&quot; height=&quot;296&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/607239/201804/607239-20180409141935797-1004731575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由于我的 Site Collection 原生语言是日语，所以这张图也就变成日语了，请不要在意，因为重点根本不在页面上。&lt;br/&gt;重点在页面的 URL 上，复制这个 URL。这样，发布的动作就已经完成了。下面我们要做的，就是将发布了的 RSS Feed 表示在一个 Web Page 上。&lt;/p&gt;
&lt;p&gt;在任意一个页面上，添加 SharePoint 中用于展示 RSS Source 内容的 Web Part ，RSS Viewer Web Part：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/607239/201804/607239-20180409141944706-81838405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加上去之后大概是这个效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/607239/201804/607239-20180409141952919-374057040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候我们需要对 RSS Viewer 进行编辑，添加 RSS Source 的 URL。点击 [Open the tool pane]，弹出 RSS Viewer 的设置侧边栏：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/607239/201804/607239-20180409142000881-970869933.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 [RSS Feed URL] 上，输入刚才发布的 RSS Source 的数据源的 URL后，点击 [OK] 保存设定。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/607239/201804/607239-20180409142009492-1001979407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样你就可以在 RSS Viewer 上看到 RSS Source 的数据啦：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/607239/201804/607239-20180409142017876-434230523.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果使用了不被支持的认证方式， RSS Viewer 会直接报错，并无法显示出内容，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/607239/201804/607239-20180409142033221-73044768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种情况就是参照了认证不符合要求的 RSS Source 的错误示例。&lt;/p&gt;
&lt;p&gt;需要注意的是，根据我的经验，使用何种认证方式进行请求的信息，是在发布的时间点就写在 Published URL 上的，也就是说，已经出现这个错误提示的 URL，即使将目标 Site / List / Library 修改成被支持的认证方式，也是无法直接使用当前的 URL 进行信息发布的，如要解决这个问题，只能在 RSS 源上重新发布 RSS Feed URL，并将新的 URL 更新到 RSS Viewer 中去。&lt;/p&gt;
&lt;p&gt;在 SharePoint 中使用 RSS Feed 的理论和方法就是这些，还有一部分是 Site 上对 RSS Feed 的签名信息的设定，这部分比较简单，我会在对此 blog 的更新中追加到这一篇中，就不开新篇记录了。&lt;/p&gt;

&lt;p&gt;&lt;img id=&quot;uploading_image_95652&quot; src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Apr 2018 06:28:00 +0000</pubDate>
<dc:creator>Caspar.Cui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CasparCui/p/8759603.html</dc:identifier>
</item>
<item>
<title>Mock API是如何在开发中发光发热的？ - wardennn</title>
<link>http://www.cnblogs.com/wardennn/p/8758750.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wardennn/p/8758750.html</guid>
<description>&lt;p&gt;在长期的服务过程中，我们经常会遇到前来咨询的用户与我们反馈以下这种情况：咨询者是一个前端人员，在项目开发的过程中需要与后端进行对接，遇到后端还没完成数据输出的情况下，他只好写静态模拟数据，在遇到大型项目的情况下，数据冗长、代码复杂、多样的数据类型包括IP、图片，地址，函数等，在极短的项目周期及验收时间下，手动修改模拟数据显得一点都不现实。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://dn-cnode.qbox.me/FoshWlll153mhO864NKe3kGkQrAf&quot; alt=&quot;TIM截图20180330150337.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对于这样的问题，其实eoLinker提供了目前最佳的解决方案：&lt;strong&gt;Mock API&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://dn-cnode.qbox.me/Fgzp5xMR8iwkFF5ppfJ4trZQj-Gv&quot; alt=&quot;27asda5674jy3abanner.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用Mock API，前后端人员只需要定义好接口文档就可以开始并行工作；后端之间的接口耦合和测试中未准备好的依赖接口也能被Mock解决，不会出现团队互等的情况。这样的话，越早开展开发自测，提前了发现、修复缺陷的时间，也有效地保证整个产品质量以及进度。&lt;/p&gt;
&lt;p&gt;eoLinker提供了两种模拟API的方式，&lt;strong&gt;基础Mock以及高级Mock&lt;/strong&gt;，那应该怎么使用eoLinker的Mock呢？基础Mock和高级Mock的区别是什么呢？&lt;/p&gt;
&lt;p&gt;在eoLinker中，&lt;strong&gt;基础Mock也称简易Mock&lt;/strong&gt;，提供了以下功能：&lt;/p&gt;
&lt;p&gt;1、支持HTTP、HTTPS&lt;/p&gt;
&lt;p&gt;2、支持RESTful风格API&lt;/p&gt;
&lt;p&gt;3、支持对请求方式进行校验（免费版为默认开启，专业版可针对项目设置关闭）&lt;/p&gt;
&lt;p&gt;4、支持模拟HTTP状态码&lt;/p&gt;
&lt;p&gt;5、支持真实的前置URL全局替换掉Mock请求的前置URL&lt;/p&gt;
&lt;p&gt;6、支持对请求参数进行校验（专业版）&lt;/p&gt;
&lt;p&gt;而高级Mock除了拥有基础Mock的功能之外，还具备以下功能：&lt;/p&gt;
&lt;p&gt;7、支持根据mockjs规则生成mock数据，支持自定义js函数&lt;/p&gt;
&lt;p&gt;8、支持根据在高级MOCK中设定的生成规则&amp;amp;属性值重新构造MOCK&lt;/p&gt;
&lt;p&gt;（专业版）&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;其中的3、6、8功能点，需前往专业版AMS中使用。下面我们选择三个重要功能点进行简单叙述。&lt;/p&gt;
&lt;h4&gt;1、支持设置返回结果的生成规则，支持MockJS：&lt;/h4&gt;
&lt;p&gt;Mock.js由于能拦截并模拟 ajax 请求，因此用Mock.js模拟后端数据变得异常简单：&lt;/p&gt;
&lt;p&gt;结合上述场景来看，eoLinker通过支持MockJS将能解决以下所有问题。&lt;/p&gt;
&lt;p&gt;1、文档没有事先定义，开发过程，后端人员可能存在口头讲述，但是和实际返回数据不一样的情况，而eoLinker 高级mock本身就规范了这种行为，高效协作不是问题。&lt;/p&gt;
&lt;p&gt;3、想要尽可能还原真实的数据，不用编写更多代码，也不用手动修改模拟数据。&lt;/p&gt;
&lt;p&gt;直接模拟后台数据返回，事半功倍。&lt;/p&gt;
&lt;p&gt;4、不担心例如IP，随机数，图片，地址等特殊的格式多重收集，丰富的格式支持省下大量时间。&lt;/p&gt;
&lt;p&gt;5、eoLinker的MOCK还支持自定义函数和正则等复杂的数据类型，方便拓展各类更多数据类型。&lt;/p&gt;
&lt;p&gt;正因如此，eoLinker MockAPI支持MockJS，解决了前后端开发中的数据模拟问题，大幅提升了开发的工作效率。&lt;/p&gt;
&lt;h4&gt;2、对请求参数进行校验：&lt;/h4&gt;
&lt;p&gt;这是高级版中的功能，eoLinker考虑到，开发过程中，有很多后端接口都会对参数进行校验的，确认哪些接口参数是必传，哪些接口参数是非必传。而前端开发调用的是Mock接口，从协助的角度上看，Mock API是模拟后端接口返回参数协作前端开发，那么对参数校验的功能也就十分必要，这样子才能模拟最真实的后端接口，更好地协助前端开发。eoLinker支持对请求参数进行校验，确定好这些接口参数是否必传，这样子就不会漏传某个参数了，行之有效的避免了冗余的工作量。&lt;/p&gt;
&lt;h4&gt;3、支持每次请求随机生成返回结果：&lt;/h4&gt;
&lt;p&gt;这同样是高级版中的功能，eoLinker认识到，随机生成返回结果的功能是必要的功能，因为接口每次返回的参数的值是不同的，所以随机生成可以使模拟的返回结果更真实。&lt;/p&gt;
&lt;p&gt;接下来就是高级Mock实际教程部分。&lt;/p&gt;
&lt;p&gt;1、编辑Mock数据 进入 接口编辑页面，点击上方 高级Mock 选项卡，进入到Mock设置页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://dn-cnode.qbox.me/FrQ312rihpvnvCDeHyoAxQhvLCog&quot; alt=&quot;1.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; Mock的填写依赖于接口文档中的返回参数，如果进入Mock设置页面发现没有可以设置的字段，请返回 基础信息 选项卡完善接口的返回信息； MockAPI支持 Mockjs 语法，了解相关语法教程请前往：&lt;a href=&quot;http://mockjs.com/%EF%BC%9B&quot; target=&quot;_blank&quot;&gt;http://Mockjs.com/；&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用步骤：&lt;/p&gt;
&lt;p&gt;1.返回参数填写相关键值对，若拥有层级结果，请用 两个英文右箭头 &amp;gt;&amp;gt;或者:: 表示层级：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://dn-cnode.qbox.me/FsbZOI88tIe9PHa7zQAbKGi6LcSk&quot; alt=&quot;2.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;根据Mockjs示例进行拆分填写。以下图 红框 部分进行讲解：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://dn-cnode.qbox.me/Fvk7fq0AjoAWsWv33wsJXrkcCCav&quot; alt=&quot;拆分讲解.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;name对应列表字段名；&lt;/p&gt;
&lt;p&gt;min-max对应列表生成规则；&lt;/p&gt;
&lt;p&gt;string对应列表属性值，使用需搭配&lt;a href=&quot;https://cnodejs.org/user/Mock&quot; target=&quot;_blank&quot;&gt;@Mock&lt;/a&gt;=使用，如 &lt;a href=&quot;https://cnodejs.org/user/Mock&quot; target=&quot;_blank&quot;&gt;@Mock&lt;/a&gt;=’★’&lt;/p&gt;
&lt;p&gt;将上图的Mock语法写入： &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://dn-cnode.qbox.me/FgN-Gf7UO-JvuphoMEwM4GK5DSgy&quot; alt=&quot;3.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;红色框部分为设置整体返回结果类型，支持两种（object/array），生成规则及属性值同样对应Mockjs语法 2、调用MockAPI 进入接口详情页，点击上方的Mock标签，在下方的Mock部分可以看到有Mock API的请求地址，复制该地址即可访问Mock API得到虚拟数据：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://dn-cnode.qbox.me/Fqnyt_VBxBT5xGth_kw0r4kHWat2&quot; alt=&quot;4.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://dn-cnode.qbox.me/Fq92Q31ECiyyfSleVvcODM9AJfyg&quot; alt=&quot;mock.jpg&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 09 Apr 2018 03:41:00 +0000</pubDate>
<dc:creator>wardennn</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wardennn/p/8758750.html</dc:identifier>
</item>
<item>
<title>爆款小程序是如何诞生的? - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/8758408.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/8758408.html</guid>
<description>&lt;p&gt;欢迎大家前往&lt;a href=&quot;https://cloud.tencent.com/developer?fromSource=waitui&quot; target=&quot;_blank&quot;&gt;腾讯云&lt;/a&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/developer?fromSource=waitui&quot; target=&quot;_blank&quot;&gt;+社区&lt;/a&gt;，获取更多腾讯海量技术实践干货哦&lt;span lang=&quot;EN-US&quot;&gt;~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本文首发在云+社区，未经许可，不得转载。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者：黄荣奎|腾讯云微信小程序解决方案负责人&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今年可以说是小程序的元年，各类游戏、店商、旅游类的小程序如雨后春笋般涌现，我想在座的朋友大家或多或少都使用过小程序，那么一款火爆的小程序是如何开发出来的呢？今天我们邀请了来自腾讯云Layabox和加推科技的五位技术专家为大家一站式分享解析如何从0到1低成本甚至是0成本开发一款爆款的小游戏，让微信小程序开发真正实现触手可及。&lt;/p&gt;
&lt;p&gt;今天我给大家带来的题目是腾讯云微信小程序解决方案。我叫黄荣奎，是腾讯微信小程序方案的负责人，目前我正在负责小程序在腾讯云上的解决方案，如何快速帮助开发者快速完成开发和上线。&lt;/p&gt;
&lt;p&gt;在去年的12月份我做一次分享的时候，大概有1/3的人有使用过小程序，现在应该会有更多。我们简单回顾一下微信小程序的发展历程，微信小程序在9月份开始内测到2017年1月9日的时候微信小程序正式开放，到了大家真正所接受的是2017年12月28日，就是微信小游戏开始开放的那一次，也就是大家所熟悉的跳一跳，那个时候微信小程序才被大家广泛的认识起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112679/201804/1112679-20180409105044318-1215688959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;简单分享一下微信小程序的一个分布，去年的时候微信小程序它的主要的来源来在于工具这一部分。类似于我们在生活中常用的摩拜单车，滴滴打车，但是现在比较火的游戏、社交已经赶超它的市场份额。&lt;/p&gt;

&lt;p&gt;先介绍一下小程序，这是官方给出的概念，&lt;strong&gt;小程序是一种新的开放能力，开发者可以快速的开发一个小程序，小程序可以在微信内被快捷的获取和传播，同时具有出色的使用体验。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;那么小程序实现的原理是什么？&lt;/h2&gt;
&lt;p&gt;第一是它的渲染层，就是他的Webviews，第二个是它的逻辑层，就是我们写业务逻辑实现登录功能和支付功能，第三个可以理解为微信原生的能力。&lt;/p&gt;
&lt;h3&gt;那么它是如何实现这一部分能力呢？&lt;/h3&gt;
&lt;p&gt;Webviews的话主要负责渲染，底层微信提供更多的底层的能力。我们可以看到微信把很多的丰富的原生客户端以及它自己的这些能力提供到了给了开发者。比如说网络，发起网络请求，存储和下载，存储包括文件的读写、音视频的读写，登录是微信版，形成关系连。组件就是我们常用的组件，包括这里面还有硬件给到开发者，包括音视频的录制、摄像头，还有拍照、扫码等。&lt;/p&gt;
&lt;h3&gt;那么它中间是通过什么进行消息的传递及调用的呢？&lt;/h3&gt;
&lt;p&gt;可以看到这里是通过事件以及返回数据来进行传递的。当用户它在界面上有一些操作行为的时候，就会触发一些事件，给到原生Webviews，再到业务逻辑。&lt;/p&gt;
&lt;h3&gt;那么小程序如何渲染出来的？&lt;/h3&gt;
&lt;p&gt;有过小程序开发者经验的都知道，我们写了一个叫WXM2的东西，定义成Javascript，和业务一起打包形成小程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112679/201804/1112679-20180409105201474-2033713802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这是小程序的一个事件处理的方法，可以看到里面有Publish。Publish是Servive发送数据给View，Service监听View事件，Service和View触发Native层，调用WX.api。&lt;/p&gt;
&lt;h2&gt;那么小程序它为什么会这么快？&lt;/h2&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;第一个是它有一个&lt;strong&gt;安装包缓存&lt;/strong&gt;，刚才有提到每一个小程序开发完成之后都会进行一个编译，形成小程序包。对比一下我们之前的一些开发方式，比如说H5的体验，会有很大的不一样的感觉，H5是TM2，通过请求下载到用户的设备上面，然后再进行渲染。如果出现网络比较差的情况，比如说3G、4G信号不太好的时候，都会出现白屏的情况。但是小程序不一样，它会生成程序包，可以缓存在用户的设备上面，这样用户在下一次使用的时候就不会重复下载。也就不会出现白屏等情况。当然对于小程序的安装包的大小也是有限制的，不能特别大，通常官方之前要求是不能大于2Mb，不知道现在有没有提升。&lt;/li&gt;
&lt;li&gt;第二个是&lt;strong&gt;Webview的界面&lt;/strong&gt;，当进入了小程序的时候，并不是点击一下才生成一个Webview，生成Webview是有时间消耗的。当我进入到小程序的主页的时候会生成多个Webview，显示时只需展示Webview，而不用再进行生成，这样加载速度会到很大的提升。&lt;/li&gt;
&lt;li&gt;第三，&lt;strong&gt;Native组件&lt;/strong&gt;，在这个页面里是原生的组件，以及里面的一些图片都是原生的，从而加快启动速度。当然它还使用了其他的，比如说分包加载之类的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们来比较一下各种开发方式，我们对小程序的体验以及它的开发难度及对用户使用上的消耗做一个对比。之前H5是我们想到的可以跨平台的解决方案，从开发来讲H5和小程序只需要了解前端开发就可以开发了。但是原生开发APP就比较大，而且是分平台的，IOS和安卓是不同的开发语言。如果一个团队开发一个小程序必须有IOS团队和安卓团队，开发成本较高。&lt;/p&gt;
&lt;p&gt;从用户体验上来讲，小程序的体验只能说较好，如果针对原生APP来对比还是会差一些。&lt;strong&gt;但是对比外围其他APP的话，小程序的速度、性能会快很多&lt;/strong&gt;。而且从能力上来讲的话，由微信提供的一些功能，小程序可以操作一些硬件，但是外围APP就有点吃力。原生APP支持最好，可以操作很底层的硬件。小程序可以通过查找或以附近的这种形式推荐，所以&lt;strong&gt;它的传播能力更好，同时支持朋友圈进行分享传播&lt;/strong&gt;。相对原生APP传播能力就很弱。针对某些使用场景的话，原生APP体验是非常差的，小程序非常快。比如说我在路上看到摩拜单车的话，我会直接用我的小程序扫一下。但是APP你还需要下载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112679/201804/1112679-20180409105233950-68487564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;如果要自己进行小程序的开发的话，通常需要有自己的服务器、运营也需要给它配置一些证书才进行开发，所以每一个开发者要了解服务器运维的知识。同时部署服务器代码不方便，服务器端代码调试不直观，更多的时候花费在周围环境的部署，而不是把更多的心思放在业务开发上面。&lt;/p&gt;
&lt;p&gt;针对这种情况我们做了这么一个&lt;strong&gt;解决方案Wafer1.0&lt;/strong&gt;，它的目的是解决服务器部署的问题，把服务器的均衡、服务器的扩容提前处理好，把业务的基础服务代码在服务器里面写好，同时拥有基础的会话服务，这是我们早期的解决方案。但是这种解决方案也存在一定的问题，需要用户了解原理是什么样的，服务器程序部署也要自己弄，架构太过专业化，不适合个人开发者，代码调试也不方便。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们跟微信做了深度的合作，开发出了我们的Wafer2&lt;/strong&gt;，Wafer1和Wafer2区别很大，尤其是开发者用户可以上传服务器端的代码，可以直接上传代码到开发环境和生产环境。开发设置环境和生产环境、域名、证书还有数据库都是系统提前准备好的。用户把代码写好，就可以直接上传代码。我们Wafer2也是集成了腾讯云现成的能力，比如说&lt;strong&gt;信道服务、对象存储，万象优图、智能语音&lt;/strong&gt;等等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112679/201804/1112679-20180409105302653-362294321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到Wafer2其实有很多新特性，包括代码一键上传，您不需要了解服务器端知识，只需要了解开发环境和生产环境即可。我们的开发和线上环境是分离的，我们能做到&lt;strong&gt;一键签发、部署SSL证书&lt;/strong&gt;。同时Node.js开发环境&lt;strong&gt;支持远程调试&lt;/strong&gt;，这一套都是免费的，欢迎大家体验。&lt;/p&gt;
&lt;p&gt;这个是我们现在在微信开发者工具里面的能力，右上角有一个腾讯云的小图标。有了这个能力您可以直接上传代码到开发环境，然后启动弹幕调试，可以在后台可以看到当前的环境变量，重启服务、停止服务，还可以上传代码到生产环境去。&lt;/p&gt;
&lt;p&gt;腾讯云小程序解决方案已经完美的解决了前面的两个问题（需要您一定服务器运维知识，部署服务器代码不方便的问题）那么还剩下两个问题，一个是服务器端代码调试不直观，针对这个问题我们和微信做了远程调试的能力，当然这是针对与Nods.js版本的。有Nods.js开发经验的同学肯定都不会陌生。另一个是远程调试，这里的代码都是服务器的代码，可以看到断点以及查看环境变量。&lt;/p&gt;
&lt;p&gt;Wafer2除了这些特点之外，还将用户的框架做好了，用户只需使用Wafer2绑定腾讯云账号和小程序的账号，然后创建小程序的项目。&lt;/p&gt;
&lt;p&gt;创建完成后，我们需要点击这里上传测试代码，这时您本地的代码就被上传到服务端，这里我们也给用户分配好了域名，用户只要在小程序里面把这个给配置好就可以来进行访问了。我们提供了蛮多的能力，包括快速节点接口、登录、语音识别等等这些能力我们都提供了，可以保证用户在开发的时候方便的使用到。&lt;/p&gt;
&lt;h2&gt;那么在这个基础上我们有做哪些东西呢？&lt;/h2&gt;
&lt;ul class=&quot;ul-level-0&quot;&gt;&lt;li&gt;第一个是聊天室小程序，这是基于我们自己Sdk做的聊天室的功能，主要使用到Websocket的服务。聊天主要用到的是信息的互动，双方通信，Websocket提供的一个能力，小程序登录会向服务器获取地址，其他由Paas提供当前的用户需不需要跟业务服务器进行连接，还是需要跟当时的服务器进行连接。这样做的好处是可以让我们开发的时候不需要更多的关注Websocket的实现。而且websocket有一定的性能消耗的，如果使用Paas可以免去这个性能消耗。我们也可以对异常的情况进行监测，比如说断线或者异常的情况进行兼容，这些能力都在我们的SDK里面，大家使用的时候了解一下。&lt;/li&gt;
&lt;li&gt;第二是图像识别，可以看到这是由腾讯云提供的万象优图能力，如身份证识别：用户上传身份证之后可以识别上面的姓名、出生年月、性别以及地址等，当然这只是腾讯云提供的一部分的能力。优图还可以提供了活体校验，大家后续可去了解。本文暂不涉及。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;除了这些之外，我们接下来还要做哪些东西呢？&lt;/h2&gt;
&lt;p&gt;目前的版本控制的现状是这样的，用户在开发小程序的时候，代码是在客户端进行编辑的，存储是用户自己存储的，当然这就会带来很多弊端，比如说代码的版本管理，版本对比，很多情况都不能在客户端完成。用户在开发完成之后需要部署服务器的话，需要自己去完成代码的部署。&lt;/p&gt;
&lt;p&gt;另一个弊端就是初始化项目比较复杂，版本控制和服务端没有关联，无法回退代码，开发者工具也不支持GIT操作。针对这种情况我们和微信也做了进一步的合作。结合腾讯云的TGIT，也就是腾讯内部使用的代码管理。然后在部署方面我们使用了程序集成，就是可以直接用开发者工具发布到服务器上，这个服务器可以是用户自己的服务器，也可以其他的服务器。&lt;/p&gt;
&lt;p&gt;有了这些能力的，我们就可以快速的一键初始化代码，开发者可以快速查看、对比和回滚代码，精确发布和回滚代码，然后TGIT提供免费私有的仓库。&lt;/p&gt;
&lt;p&gt;目前我们小程序开发者工具支持了有GS和PSP，后面我们可以支持到C++、Java和编译的发布。&lt;/p&gt;
&lt;p&gt;融合了这种持续继承之后它的优势，可以发布前可以预编译代码，支持编译语言，支持自定义持续集成，可以部署发布前运行，就是这些，谢谢大家。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Q：刚才说的发布的时候有生产和开发，我自己配置需要两台服务器吗？一个是开发一个是生产。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：这个不需要你自己手动去做，你只需要绑定腾讯云和小程序的账号就可以了，这个服务器是免费生成的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：这个服务器我们不需要要费用吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：目前开发是免费的，生产环境可能最近是收费的，之前是免费的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：我可以选用其他的服务商去提供的服务器嘛？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：可以需要自行部署，我们会在后面的运营、发布的话，允许用户自己去部署服务器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：我如果要用小程序得多个接服务的时候，我可以有一台服务器吗？那个服务器可以支持多各小程序吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：可以，需要自己在代码上做一些兼容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：咱们现在有方便的示例或者SDK之类的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：暂时还没有。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：现在就需要自己去调整代码逻辑？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：OK，没错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：你好，IOS版本的小程序跟安卓小程序，它的开发语言的话是一样吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：目前小程序它其实是跨平台的，也就是说写个代码的话只是一份，它可以同时兼容IOS和安卓平台，它的语言是nodejs这些是更加偏向于前端的开发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：问一个万象优图的问题，刚才你讲可以识别身份证，能不能识别我们自定义的一些，就是打印出来的病例是否可以识别？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：目前它有印刷体识别，身份证识别只是其中一个，我可以帮你联系一下优图的同事，有没有这个能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：咱们OCR进行身份证识别的时候，是直接把图片上传的吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：是，直接上传上来，给一个链接地址，接口就可以识别到了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q：之前我有尝试到AI，需要把图片转成，就是了解了一下内部小程序是可以这样转的，社区里有人说没有实现这个功能，你们以后会有对这个功能进行对外开放吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A：转成64的话应该有蛮多方法的，如果不开放的话，你可以通过开放接口。&lt;/p&gt;

&lt;blockquote readability=&quot;1.2463054187192&quot;&gt;
&lt;p&gt;&lt;strong&gt;问答&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/ask/61013?fromSource=waitui&quot; target=&quot;_blank&quot;&gt;短视频可以通过什么技术接入小程序？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关阅读&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;col-article-title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1082380?fromSource=waitui&quot; target=&quot;_blank&quot;&gt;微信小程序，开发大起底&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;col-article-title&quot;&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1084910?fromSource=waitui&quot; target=&quot;_blank&quot;&gt;刘翌：如何利用小程序技术解决企业销售难题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1084822?fromSource=waitui&quot; target=&quot;_blank&quot;&gt;李明：微信小游戏技术分享&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p class=&quot;col-article-title&quot;&gt;&lt;strong&gt;此文已由作者授权腾讯云+社区发布，原文链接：https://cloud.tencent.com/developer/article/1084417?fromSource=waitui&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;col-article-title&quot;&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112679/201803/1112679-20180330104936874-1573429539.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 09 Apr 2018 03:11:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/8758408.html</dc:identifier>
</item>
<item>
<title>云成本管理方法论（三）——云优化管理之判定规则 - FryFish</title>
<link>http://www.cnblogs.com/jancco/p/8758087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jancco/p/8758087.html</guid>
<description>&lt;p&gt;云优化管理四个管理维度中管理时点在通用管理模型基础上不需要额外补充，所以主要说明其他三个维度（管理对象、判定规则和管理措施）。另外，为了贴近我们熟悉的优化概念，我们将优化管理中的违规称为问题，并将处理违规称为实施优化。&lt;/p&gt;
&lt;p&gt;因为优化管理相对较复杂，我们将分两篇文章来讨论。此篇文章主要讨论管理对象和判定规则。&lt;/p&gt;
&lt;h2 id=&quot;管理对象&quot;&gt;管理对象&lt;/h2&gt;
&lt;p&gt;优化管理中的管理对象是资源指标和资源之间的关系（后面会看到，严格来说是“资源关系状态”）。其中，资源指标种类很丰富，并且一般会随资源种类的不同而不同，但是对于具体资源其指标种类是确定的，所以并不需要做一般性的分析。所以，我们重点需要分析影响资源成本优化的不同资源关系。为此，下面先对一些基础概念进行说明。&lt;/p&gt;
&lt;p&gt;资源基本关系：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关联 —— 如果一种资源的某一属性为另一种资源的标识信息，则称这一属性为关联属性，并称这两种资源具有关联关系。其中，具有此关联属性的资源称为关联资源，通过此属性标识的资源称为被关联资源。比如虚机一般会有一个安全组 ID 属性，在这一关联关系中就称虚机为关联资源，安全组为被关联资源。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/10250942-170608231f17f8f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500&quot; alt=&quot;关联关系&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;聚合 —— 聚合关系是一种强的关联关系。具有聚合关系的资源之间有整体和部分的关系。比如负载均衡器与虚机之间具有聚合关系，其中负载均衡器为代表整体的资源，虚机是部分资源。在聚合关系中可能会有双向关联，比如虚机会有“存储卷”集合属性，存储卷同时有“虚机 ID”属性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/10250942-92cf0e43cd2c85fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/380&quot; alt=&quot;聚合关系&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;组合 —— 组合关系是一种强的聚合关系。组合关系中代表部分的资源只从属于此组合关系中代表整体的资源，而不能同时作为其他资源的部分资源。比如，虚机与存储卷具有组合关系，一个存储卷不能同时与多个虚机形成关联关系。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/10250942-163e00c100b8094a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/480&quot; alt=&quot;组合关系&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外需要注意的是，无论在聚合还是组合关系中，代表部分的资源都有可能不与任何代表整体的资源发生关联。而由于聚合关系中的部分资源对整体资源没有强的依赖性，所以部分资源一般在这种情况下仍能够独立实现其业务功能（比如未关联负载均衡器的虚机仍可对外提供服务）；但对于组合关系，部分资源在这种情况下一般不能独立实现其业务功能（如未挂载到任何虚机的存储卷无法对外提供数据存储服务）。&lt;/p&gt;
&lt;p&gt;基于资源基本关系的定义，我们再定义如下几个概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;强制关联 —— 关联资源中的关联属性值不能为空。比如虚机与私有 IP，以及卷快照与存储卷之间是强制关联。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/10250942-ee4b9c4b586cdb89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300&quot; alt=&quot;强制关联&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;外键关联 —— 关联资源中关联属性如果不为空，则其对应的被关联资源必须存在（未被销毁）。如存储卷与虚机之间是外键关联，即如果存储卷的虚机 ID 不为空，则此虚机必须存在。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/10250942-05ed27eca212e1d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300&quot; alt=&quot;外键关联&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;快照关联 —— 快照关联是一种特殊的强制关联，但不是外键关联。快照关联中关联资源是快照，被关联资源是快照的来源资源。我们也可以将快照关联中的关联资源称为快照资源，将被关联资源称为源资源。如虚机和由此虚机生成的镜像之间有快照关联，其中镜像是快照资源，虚机是源资源。需要注意的是，虚机与生成此虚机的镜像之间并没有快照关联，而只是一般的关联关系。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/10250942-b2dfdcbc46a5195f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/380&quot; alt=&quot;快照关联&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;托管 —— 若一种资源的生命周期（创建，修改，停止，销毁等）完全受另外一种资源管理（且一般情况下不受人工干预），则这种关系称为托管关系，它是一种强的组合关系。同时，我们称进行管理（即进行托管）的资源为管控资源，被管理（即被托管）的资源为托管资源。伸缩组与虚机是一种典型的托管关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;父资源 —— 父资源是具有聚合关系的一组资源中代表整体的资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;子资源 —— 父资源是具有聚合关系的一组资源中代表部分的资源。子资源可能是单个资源（如虚机的公有&lt;br/&gt;IP）也可能是一组资源（如伸缩组中的虚机）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从上面的例子也可以看到。同一资源可能会有多种聚合关系（如虚机与负载均衡器以及虚机与伸缩组），而且不同的聚合关系可能既有一般聚合关系也有组合关系。&lt;/p&gt;
&lt;p&gt;需要明确的是，真实的资源之间具体应属于哪种关系是由其功能特征决定的，是固有的，所以对这些关系本身我们并没有办法去改进或优化。但是，我们可以对其关系状态进行优化。因此，下面列出各种关联关系的不同状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[关联]已关联/未关联&lt;/li&gt;
&lt;li&gt;[强制关联]已关联/未关联&lt;/li&gt;
&lt;li&gt;[外键关联]已关联/未关联&lt;/li&gt;
&lt;li&gt;[快照关联]已关联/未关联&lt;/li&gt;
&lt;li&gt;[聚合]已关联/未关联&lt;/li&gt;
&lt;li&gt;[组合]已关联/未关联&lt;/li&gt;
&lt;li&gt;[托管]已关联/未关联&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，由于关联关系中的“已关联”和“未关联”只具有最基本的信息，无从判断问题，因此将不作为管理对象。同时，还有如下几种非关联关系的关系状态也将作为管理对象：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;预留资源与实例资源用量匹配关系&lt;/li&gt;
&lt;li&gt;同一资源对象快照或备份的份数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，优化管理中的管理对象除资源关系状态外还有资源指标，所以汇总后&lt;strong&gt;云成本优化管理全部的管理对象&lt;/strong&gt;如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;强制关联-已关联&lt;/li&gt;
&lt;li&gt;强制关联-未关联&lt;/li&gt;
&lt;li&gt;外键关联-已关联&lt;/li&gt;
&lt;li&gt;外键关联-未关联&lt;/li&gt;
&lt;li&gt;快照关联-已关联&lt;/li&gt;
&lt;li&gt;快照关联-未关联&lt;/li&gt;
&lt;li&gt;聚合-已关联&lt;/li&gt;
&lt;li&gt;聚合-未关联&lt;/li&gt;
&lt;li&gt;组合-已关联&lt;/li&gt;
&lt;li&gt;组合-未关联&lt;/li&gt;
&lt;li&gt;托管-已关联&lt;/li&gt;
&lt;li&gt;托管-未关联&lt;/li&gt;
&lt;li&gt;预留与实例资源匹配关系&lt;/li&gt;
&lt;li&gt;快照或备份的份数&lt;/li&gt;
&lt;li&gt;资源指标&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/10250942-afaf515714cfedab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620&quot; alt=&quot;优化管理管理对象&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;判定规则&quot;&gt;判定规则&lt;/h2&gt;
&lt;p&gt;优化管理中的规则判定结果为是否存在问题（即违规），以及问题的类型。问题类型可结合管理对象和资源状态两方面的信息进行判断。&lt;/p&gt;
&lt;p&gt;在定义资源状态之前，我们先定义两种物理资源类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;运行所需资源 —— 云资源在其提供业务功能时需要占用的物理资源。&lt;/li&gt;
&lt;li&gt;定义所需资源 —— 云资源的定义、关系及元数据信息占用的物理资源。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以发现，有些资源如VPC，子网，用户账号、权限及秘钥等信息在其整个生命周期中都不会占用运行所需资源。这种资源在一般情况下价格为零。&lt;/p&gt;
&lt;p&gt;任意资源可能的状态有如下三种（忽略如“销毁中”等转换状态）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;活动中&lt;/li&gt;
&lt;li&gt;已停止&lt;/li&gt;
&lt;li&gt;已销毁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先，一种资源如果在其全部生命周期中都不会占用运行所需资源，则其只有活动中状态，没有已停止状态。对于会占用运行所需（物理）资源的云资源，活动中状态是指正在或有能力占用运行所需资源的状态；已停止是指不会占用运行所需资源的状态。已销毁是指已删除其定义所需资源的状态。&lt;/p&gt;
&lt;p&gt;下面针对不同的管理对象来分析其判定规则。&lt;/p&gt;
&lt;h3 id=&quot;关联关系相关&quot;&gt;关联关系相关&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;注：&lt;/code&gt;&lt;br/&gt;&lt;code&gt;1. 与使用管理的描述方式有所不同，关联关系相关的判定条件由表格的表头（被关联资源状态）及每行的第一列（关联资源状态）构成，其他单元格中内容即为判定结果。同时，从判定条件到判定结果之间的映射关系即构成了违规判断方法。&lt;/code&gt;&lt;br/&gt;&lt;code&gt;2. 判定结果有三类：“/”表示不存在此情形，“无”表示此情形属正常情况，其他情况为问题描述。&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;强制关联-已关联&quot;&gt;- 强制关联-已关联&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;活动中&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已停止&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已销毁或未创建&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;活动中&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;已停止&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;已销毁&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;强制关联-未关联&quot;&gt;- 强制关联-未关联&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;活动中&lt;/td&gt;
&lt;td&gt;数据错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;已停止&lt;/td&gt;
&lt;td&gt;数据错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;已销毁&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;外键关联已关联&quot;&gt;- [外键关联]已关联&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;活动中&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已停止&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已销毁或未创建&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;活动中&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数据错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;已停止&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数据错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;已销毁&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;外键关联未关联&quot;&gt;- [外键关联]未关联&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;活动中&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;已停止&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;已销毁&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;快照关联已关联&quot;&gt;- [快照关联]已关联&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;活动中&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已停止&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已销毁或未创建&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;活动中&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;源资源不存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;已停止&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;已销毁&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;快照关联未关联&quot;&gt;- [快照关联]未关联&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;活动中&lt;/td&gt;
&lt;td&gt;数据错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;已停止&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;已销毁&lt;/td&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;聚合已关联&quot;&gt;- [聚合]已关联&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;活动中&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已停止&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已销毁或未创建&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;活动中&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数据错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;已停止&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;父资源已停止&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数据错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;已销毁或未创建&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数据错误&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数据错误&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;聚合未关联&quot;&gt;- [聚合]未关联&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;活动中&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已停止&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已销毁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;父资源&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无子资源&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;子资源&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;组合已关联&quot;&gt;- [组合]已关联&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;活动中&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已停止&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已销毁或未创建&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;活动中&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数据错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;已停止&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;父资源已停止&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数据错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;已销毁或未创建&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数据错误&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数据错误&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;组合未关联&quot;&gt;- [组合]未关联&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;活动中&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已停止&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已销毁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;父资源&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;子资源&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无父资源&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无父资源&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;托管已关联&quot;&gt;- [托管]已关联&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;活动中&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已停止&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已销毁或未创建&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;活动中&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;已停止&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数据错误&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数据错误&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数据错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;已销毁或未创建&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数据错误&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数据错误&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;托管未关联&quot;&gt;- [托管]未关联&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;/&gt;
&lt;td align=&quot;center&quot;&gt;活动中&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已停止&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;已销毁&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;left&quot;&gt;管控资源&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;left&quot;&gt;托管资源&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数据错误&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;数据错误&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;/&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;匹配关系相关&quot;&gt;匹配关系相关&lt;/h3&gt;
&lt;h4 id=&quot;预留与实例资源匹配关系&quot;&gt;- 预留与实例资源匹配关系&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;预留资源不足&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;预留资源低利用率&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;用量关系相关&quot;&gt;用量关系相关&lt;/h3&gt;
&lt;h4 id=&quot;快照或备份的份数&quot;&gt;- 快照或备份的份数&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;快照或备份不足&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;快照或备份过多&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;资源指标相关&quot;&gt;资源指标相关&lt;/h3&gt;
&lt;h4 id=&quot;资源指标&quot;&gt;- 资源指标&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;资源低利用率&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;资源不足&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;补充说明&quot;&gt;补充说明&lt;/h3&gt;
&lt;p&gt;结合用户实际使用资源时的操作，我们会发现，如上判定规则判定得出的很多问题在用户合理的使用过程中实际也会发生。比如，在人工创建一个存储卷与完成挂载此存储卷之间会存在一定的时间差（在此期间会处于“无父资源”的状态），在业务不繁忙的时段预留资源可能会低利用率，一台虚机的 CPU 利用率在访问低谷时可能很低等等，这些状态都与用户的不合理操作无关，也并无可优化的问题。&lt;/p&gt;
&lt;p&gt;进一步考虑这个问题，会发现很多的“问题状态”必须持续一定的时间，或是达到总时长的一定比率后才会成为问题。所以，在实际制定判定规则时，一般都需要增加“持续时长”和/或“平均时长”等辅助判定条件。&lt;/p&gt;
&lt;h2 id=&quot;下期预告&quot;&gt;下期预告&lt;/h2&gt;
&lt;p&gt;下期文章：《云成本管理方法论（四）——云优化管理之管理措施》，将针对本篇文章中判定规则所发现的各类可优化问题，来一般性地说明对这些问题的优化措施。&lt;/p&gt;

</description>
<pubDate>Mon, 09 Apr 2018 02:43:00 +0000</pubDate>
<dc:creator>FryFish</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jancco/p/8758087.html</dc:identifier>
</item>
<item>
<title>es6学习笔记--Interator和Generator(以及for-of的用法) - 热爱前端的17号诶</title>
<link>http://www.cnblogs.com/sqh17/p/8659142.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sqh17/p/8659142.html</guid>
<description>&lt;p&gt;这几天学习了遍历器和生成器，看着资料学，有点雾里缭绕的感觉，让人忍不住放弃，还好多看了好几遍，怼着资料里的例子让自己学会了Interator和Generator。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Interator，中文简称：遍历器，是一种接口，为具有遍历结构的或者说有length长度的集合提供一个接口，从而进行遍历操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Generator，中文简称：生成器，从语法上讲是一种状态机，通过遍历操作，展示不同的状态情况。&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Interator(遍历器)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;20.5&quot;&gt;
&lt;p&gt;Iterator 接口的目的，就是为所有数据结构(集合)，提供了一种统一的访问机制，为for-of这个遍历方法提供接口，任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ps: 数据结构=集合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在 JavaScript 中 迭代器是一个对象，它提供了一个next() 方法，(除了next()方法还有return和throw方法),用来返回序列中的下一项。这个方法返回包含两个属性：done和 value。done属性是个布尔值，代表遍历是否结束,即是否还有必要再一次调用next方法。value属性代表当前成员的值。&lt;/p&gt;
&lt;p&gt;迭代器对象一旦被创建，就可以反复调用next()。&lt;/p&gt;
&lt;div readability=&quot;16.5&quot;&gt;以下代码是模拟迭代器：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; makeIterator(array){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; nextIndex = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
    next: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; nextIndex &amp;lt; array.length ?&lt;span&gt;
            {value: array[nextIndex&lt;/span&gt;++], done: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;} :
            {done: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;};
    }
    };
}
let a &lt;/span&gt;= makeIterator(['apple','pear','orange'&lt;span&gt;])
console.log(a.next())   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: &quot;apple&quot;, done: false}&lt;/span&gt;
console.log(a.next())   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: &quot;pear&quot;, done: false}&lt;/span&gt;
console.log(a.next())   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: &quot;orange&quot;, done: false}&lt;/span&gt;
console.log(a.next())   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {done: true}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由上述例子可知：next方法返回的是一个对象，有value和done属性，如果还有下一个next()可遍历，那么done为false，如果done为true，说明不可再次遍历。&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;ps：遍历器创建之后不会自动触发，而是由next()触发。&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable），&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性, Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;strong&gt;常见的具有Iterator接口的遍历器:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Array&lt;/p&gt;
&lt;p&gt;　　Map&lt;/p&gt;
&lt;p&gt;　　Set&lt;/p&gt;
&lt;p&gt;　　String&lt;/p&gt;
&lt;p&gt;　　TypedArray&lt;/p&gt;
&lt;p&gt;　　函数的 arguments 对象&lt;/p&gt;
&lt;p&gt;　　NodeList 对象&lt;/p&gt;
&lt;p&gt;　　生成器&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;span&gt;ps:普通的对象不具有Iterator接口，原因是对象的遍历是没有顺序的，没有相应的索引值可言，所以想要使普通的对象要有Iterator接口，需要给它加上Object方法变成有顺序的对象即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Iterator遍历器简单来说，就是在具有Iterator的对象(Array，Map，Set，String，TypedArray，函数的 arguments 对象，NodeList 对象，生成器)上进行for-of的循环，并且用next()方法获取遍历的值.&lt;/strong&gt;&lt;/p&gt;

&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;学习一下新型的&lt;span&gt;&lt;strong&gt;&lt;span&gt;for-of循环&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;。可在具有Iterator 接口的元素进行遍历。&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;for-of循环和以前的以前的for循环和es5的forEach循环一样，遍历操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;for...of语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let arr = [1,2,3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let v of arr){
    v &lt;/span&gt;+=1&lt;span&gt;;
    console.log(v)
} &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2  3  4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;for-of替代了以前的所有的循环遍历，融合了其优点，摒弃了其缺点。&lt;/p&gt;

&lt;div readability=&quot;8.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;for-of与for，forEach，for-in相比的优缺点:&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;1 forEach循环不能用 break 中断循环，否则会报错.也不能使用 return 语句返回到外层函数&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[1,2,3,4,5].forEach((i,v) =&amp;gt;&lt;span&gt; {
    console.log(v)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i &amp;gt; 3&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
})  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Uncaught SyntaxError: Illegal break statement&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;13&quot;&gt;2 for-in 遍历,只获取键名，获取不到键值。以任意顺序遍历键名，只能遍历带有字符串的key。通常不推荐循环数组。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(let v &lt;span&gt;in&lt;/span&gt; ['a','b','c'&lt;span&gt;]){
    console.log(v)
}  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0   1   2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3 for循环书写太复杂，emmmm，只能这么说。&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;

&lt;p&gt;&lt;strong&gt;for-of的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;&lt;span&gt;1 最简洁、最直接的遍历数组元素的语法&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
let arr = [1,2,3,4&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let v of arr){
    console.log(v)
}  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1    2    3    4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上个方法避开了for-in循环的所有缺陷。&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
let a = ['a','b','c','d'&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let v of a){
    console.log(v)
}   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a   b   c    d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码for-of可以直接获取键值，如果想要获取其索引值可以采用Object扩展方法keys()和entires()&lt;/p&gt;
&lt;div readability=&quot;18&quot;&gt;&lt;span&gt;2 与forEach()不同的是，它可以正确响应break、continue和return语句&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(let v of [1,2,3,4,5&lt;span&gt;]){
    console.log(v)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(v &amp;gt; 3&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;
    }
} &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  1   2   3    4     5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3 可以遍历其他的所有集合(Nodelist,Set,Map),还有生成器&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;div&amp;gt;1&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;2&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;3&amp;lt;/div&amp;gt;
&amp;lt;div&amp;gt;4&amp;lt;/div&amp;gt;
&lt;span&gt;

let doms &lt;/span&gt;= document.querySelectorAll('div'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let v of doms){
    console.log(v.innerHTML)
}    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1   2   3   4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;for-of可以遍历dom元素，并且进行相应的操作&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
let set = &lt;span&gt;new&lt;/span&gt; Set([1,2,3,4,5&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let v of set){
    console.log(v)
}   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  1   2  3  4  5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
let map = &lt;span&gt;new&lt;/span&gt; Map().set('a',1).set('b',2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let v of map){
    console.log(v)
}   
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;a&quot;, 1]&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; [&quot;b&quot;, 2] &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Set和Map本身具有 Iterator 接口，所以用for-of循环，set返回的是一个值，而map返回的是一个数组。&lt;/p&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;p&gt;&lt;span&gt;ps:for-of不能遍历普通的对象，会报xxx is not iterable,需要把普通对象转化成具有Interator接口的即可。Object.keys(),Object.values()和Obejct.entries()也可以获取&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let obj = {name:'peter',age:25&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let v of obj){
    console.log(v)
} &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Uncaught TypeError: obj is not iterable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let obj = {name:'peter',age:25&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let v of Object.keys(obj)){
    console.log(v)
} &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; name  age&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4 另外，for-of可以适用于字符串&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let str = 'hello'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let v of str) {
    console.log(v)
}   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; h  e  l  l  o&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interator不是很难懂，只要明白了哪些是数据集合，就说明具有Interator接口，自然就可以当作遍历器，从而使用for-of循环和使用next方法获取想要的数据。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Generator(生成器)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;14.5&quot;&gt;
&lt;p&gt;通过对Interator的理解，生成器也是具有Interator接口的对象，它本身带有遍历特性，返回一个遍历器对象。&lt;/p&gt;
&lt;div readability=&quot;25&quot;&gt;
&lt;p&gt;从写法上看，它和普通函数差别不大，就多了两个特性：&lt;/p&gt;
&lt;p&gt;　　1 在函数声明前加上星号(*),&lt;/p&gt;
&lt;p&gt;　　2 函数内部多了一个关键字yield。&lt;/p&gt;
&lt;p&gt;既然生成器是遍历器，那么可以使用遍历器的方法(本身函数不会实行，必须通过next()方法才能调用或者使用for-of返回)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;fn(){
    yield &lt;/span&gt;'peter'&lt;span&gt;;
    yield &lt;/span&gt;1&lt;span&gt;;
    yield {name:&lt;/span&gt;'peter'&lt;span&gt;};
    yield [&lt;/span&gt;1,2,3,4&lt;span&gt;];
    yield &lt;/span&gt;&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;foo(){
        yield &lt;/span&gt;123&lt;span&gt;;
    }
}
let a &lt;/span&gt;=&lt;span&gt; fn()
console.log(a.next())
console.log(a.next())
console.log(a.next())
console.log(a.next())
console.log(a.next())
console.log(a.next())
{value: &lt;/span&gt;&quot;peter&quot;, done: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;}
{value: &lt;/span&gt;1, done: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;}
{value: {…}, done: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;}
{value: Array(&lt;/span&gt;4), done: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;}
{value: ƒ, done: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;}
{value: undefined, done: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上述例子可知:每一个next()方法，就返回一个数据，这说明yield表达式代表一个进程，返回其后面的表达式。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;学习一下&lt;span&gt;&lt;strong&gt;yield&lt;/strong&gt;&lt;/span&gt;:&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;1 由于 Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。所以yield表达式就是暂停标志。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 yield 是关键字，其后面可以跟变量，常量，表达式，但是必须有next方法才能调用或者for-of返回,本身不是返回值&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;fn(){
    yield &lt;/span&gt;'a'&lt;span&gt;;
    let b &lt;/span&gt;= yield 'b' + 'c'&lt;span&gt;;
    yield &lt;/span&gt;'d'&lt;span&gt;
}
let foo &lt;/span&gt;=&lt;span&gt; fn()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let v of foo){
    console.log(v)
}  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  a   bc    d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由上述例子可知：yield返回的是后面的表达式，不影响前面的声明&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;&lt;strong&gt;3 遇到yield表达式时，进程暂停，next()方法才会调用yield后面的表达式。&lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;fn(){
    yield &lt;/span&gt;'1'&lt;span&gt;
    console.log(&lt;/span&gt;'start'&lt;span&gt;)
    yield &lt;/span&gt;'2'&lt;span&gt;
}
let a &lt;/span&gt;=&lt;span&gt; fn()
console.log(a.next())   
{value: &lt;/span&gt;&quot;1&quot;, done: &lt;span&gt;false&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4 作用和return差不多，但也有区别，return只能执行一回，yield能执行多次，每次遇到yield时就先暂停，然后下一次运行从暂停的位置开始。&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;&lt;strong&gt;5 yield只能在Genterator函数里才能运用，在其他地方运用会报错。&lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
    yield &lt;/span&gt;'a'&lt;span&gt;
}
fn()   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Uncaught SyntaxError: Unexpected string&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;16.5&quot;&gt;&lt;strong&gt;6 yield和return同时在一个函数里时，按照代码同步顺序执行的结果，到了return就直接返回，不继续执行下一步。&lt;/strong&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;fn(){
    yield &lt;/span&gt;'1'&lt;span&gt;;
    yield &lt;/span&gt;'2'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; '3'&lt;span&gt;;
    yield &lt;/span&gt;'4'&lt;span&gt;
}
let a &lt;/span&gt;=&lt;span&gt; fn()
console.log(a.next());  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: &quot;1&quot;, done: false}&lt;/span&gt;
console.log(a.next());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: &quot;2&quot;, done: false}&lt;/span&gt;
console.log(a.next());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: &quot;3&quot;, done: true}&lt;/span&gt;
console.log(a.next());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: undefined, done: true}&lt;/span&gt;
console.log(a.next());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: undefined, done: true}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;7 yield 也可以跟星号，代表在一个 Generator 函数里面执行另一个 Generator 函数。&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;15.5&quot;&gt;在生成器函数里是无法进行另一个Generator函数的，没有效果,若单单使用yield，返回的是另一个生成器的对象
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;foo(){
    yield &lt;/span&gt;'f'&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;fn(){
    yield &lt;/span&gt;'a'&lt;span&gt;;
    yield foo()
    yield &lt;/span&gt;'b'&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;( let v of fn()){
    console.log(v)   
}   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a   foo {&amp;lt;suspended&amp;gt;}     b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以在yield* 可以用来进行另一个Generator函数(只要在一个Generator函数运行另一个Generator函数就可以直接yield*)&lt;/p&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;foo(){
    yield &lt;/span&gt;1&lt;span&gt;;
    yield &lt;/span&gt;2&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;fn(){
    yield &lt;/span&gt;'a'&lt;span&gt;;
    yield &lt;/span&gt;*&lt;span&gt;foo()
    yield &lt;/span&gt;'b'&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;( let v of fn()){
    console.log(v)    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a   1  2    b&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面已经说到生成器也是具有Interator接口的对象，不可置否的，生成器本身带有Symbol.iterator，可以说生成器是遍历器的一种，所以可遍历，可以使用for-of来循环数据。&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;p&gt;for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;简单来说，for-of里返回的数据和next()中value一样.区别在于for-of循环完后不循环return后面的表达式。而next()则会。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;fn(){
    yield &lt;/span&gt;'a'&lt;span&gt;;
    yield &lt;/span&gt;'b'&lt;span&gt;;
    yield &lt;/span&gt;'c'&lt;span&gt;;
    yield &lt;/span&gt;'d'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'end'&lt;span&gt;
}
let a &lt;/span&gt;=&lt;span&gt; fn()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(let v of a){
    console.log(v)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; a   b   c    d   &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;fn(){
    yield &lt;/span&gt;'a'&lt;span&gt;;
    yield &lt;/span&gt;'b'&lt;span&gt;;
    yield &lt;/span&gt;'c'&lt;span&gt;;
    yield &lt;/span&gt;'d'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'end'&lt;span&gt;
}
let a &lt;/span&gt;=&lt;span&gt; fn()
console.log(a.next());   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: &quot;a&quot;, done: false}&lt;/span&gt;
console.log(a.next());   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: &quot;b&quot;, done: false}&lt;/span&gt;
console.log(a.next());   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: &quot;c&quot;, done: false}&lt;/span&gt;
console.log(a.next());   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: &quot;d&quot;, done: false}&lt;/span&gt;
console.log(a.next());   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: &quot;end&quot;, done: true}&lt;/span&gt;
console.log(a.next());   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: undefined, done: true}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;13&quot;&gt;扩展运算符也支持生成器的遍历
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;fn(){
    yield &lt;/span&gt;'a'&lt;span&gt;;
    yield &lt;/span&gt;'b'&lt;span&gt;;
    yield &lt;/span&gt;'c'&lt;span&gt;;
    yield &lt;/span&gt;'d'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'end'&lt;span&gt;
}
let a &lt;/span&gt;=&lt;span&gt; fn()
console.log([...a])   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由此可见，遍历出来的依然不包含return的表达式&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;概要总结；只要具有Symbol.iterator属性的，就可以遍历yield表达式&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;Generator 函数也不能跟new命令一起用，会报错&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;*&lt;span&gt; f() {
    yield &lt;/span&gt;2&lt;span&gt;;
    yield &lt;/span&gt;3&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; f()  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TypeError: F is not a constructor&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Generator 函数的方法:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;next() 返回 Generator 函数对象中yield后面的表达式&lt;/span&gt;&lt;/strong&gt;，上面已经用到了next方法。yield表达式本身没有返回值，总是返回undefined&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;当next()有参数时,该参数就会被当作上一个yield表达式的返回值。&lt;/p&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;fn(x){
    let a &lt;/span&gt;=&lt;span&gt; yield x;
    let b &lt;/span&gt;= yield 2 +&lt;span&gt; a;
}
let a &lt;/span&gt;= fn(2&lt;span&gt;);
console.log(a.next(&lt;/span&gt;5));   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 2, done: false}&lt;/span&gt;
console.log(a.next(10));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 12, done: false}&lt;/span&gt;
console.log(a.next(20));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: undefined, done: true}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。&lt;/p&gt;
&lt;p&gt;所以第一个next方法用来启动遍历器对象，所以不用带有参数。&lt;/p&gt;
&lt;p&gt;      第二个next()方法把第二个yield后面的2替换成了10，所以10+2=12&lt;/p&gt;
&lt;p&gt;      第三个next()方法因为没有yield，返回undefined，参数无效&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;&lt;span&gt;ps:如果一开始传了参数，第二个next没有传参数，则是undefined&lt;/span&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;fn(x){
    let a &lt;/span&gt;=&lt;span&gt; yield x;
    let b &lt;/span&gt;= yield 2 +&lt;span&gt; a;
}
let a &lt;/span&gt;= fn(2&lt;span&gt;);
console.log(a.next());   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 2, done: false}&lt;/span&gt;
console.log(a.next());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: NaN, done: false}&lt;/span&gt;
console.log(a.next());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: undefined, done: true}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;19&quot;&gt;
&lt;p&gt;第二个传参为空导致undefined+2等于NaN&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;next()方法的意义：Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;throw() 在函数体外抛出错误，然后在 Generator 函数体内捕获。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
let a = &lt;span&gt;function&lt;/span&gt;*&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        yield ;
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; ( e ){
        console.log(e);
    }
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; i =&lt;span&gt; a();
console.log(i.&lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;())  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Uncaught undefined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成器的声明方式和普通的一样。    yield后面没有表达式，为undefined。&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
let g = &lt;span&gt;function&lt;/span&gt;*&lt;span&gt; () {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        yield &lt;/span&gt;1&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
        console.log(e);
    }
    yield &lt;/span&gt;'a'&lt;span&gt;;
    yield &lt;/span&gt;'b'&lt;span&gt;
};

let i &lt;/span&gt;=&lt;span&gt; g();
console.log(i.next())  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
i.&lt;span&gt;throw&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; Error('出错了！'));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Error: 出错了！(…)   附带执行了一次yield ‘a’&lt;/span&gt;
console.log(i.next())  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;p&gt;throw()方法的作用就是捕获异常，并且继续执行下去,不因为异常而中断。throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ps:不要混淆遍历器对象的throw方法和全局的throw命令。上面的异常是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;throw()的意义：大大方便了对错误的处理。多个yield表达式，可以只用一个try...catch代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在 Generator 函数内部写一次catch语句就可以了。&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;return() 返回给定的值，并且终结遍历 Generator 函数。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;18.5&quot;&gt;当return()不传参数时，默认是undefined，就相当于最后一步，done即为true时的操作，value值为undefined
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;fn(){
    yield &lt;/span&gt;1&lt;span&gt;;
    yield &lt;/span&gt;2&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 3&lt;span&gt;;
}
let a &lt;/span&gt;=&lt;span&gt; fn();
console.log(a.next())   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 1, done: false}&lt;/span&gt;
console.log(a.&lt;span&gt;return&lt;/span&gt;());   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: undefined, done: true}&lt;/span&gt;
console.log(a.next())   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: undefined, done: true}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;22.5&quot;&gt;当return()传参数时，value值为传的参数
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; *&lt;span&gt;fn(){
    yield &lt;/span&gt;1&lt;span&gt;;
    yield &lt;/span&gt;2&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 3&lt;span&gt;;
}
let a &lt;/span&gt;=&lt;span&gt; fn();
console.log(a.next())   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 1, done: false}&lt;/span&gt;
console.log(a.&lt;span&gt;return&lt;/span&gt;(100));   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: 100, done: true}&lt;/span&gt;
console.log(a.next())   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {value: undefined, done: true}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;return()的意义：通常在生成器异步操作时需要在某个时段跳出来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Generator生成器是异步编程提供了方便。&lt;/p&gt;

&lt;p&gt;对于Interator和Generator，在平时使用时很少用到，只有那个for-of可以替代for循环使用，主要用于异步编程async当中。学习这个感觉没学全，过后我会再仔细学一遍。知识点我放到github里了，有需要可以去下载一起学习。&lt;/p&gt;
&lt;p&gt;还是那句话。有什么问题或错误请私信或者下方评论，一起讨论进步。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;阮一峰es6入门 http://es6.ruanyifeng.com/&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 09 Apr 2018 01:57:00 +0000</pubDate>
<dc:creator>热爱前端的17号诶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sqh17/p/8659142.html</dc:identifier>
</item>
<item>
<title>Postgres中postmaster代码解析(上) - 非我在</title>
<link>http://www.cnblogs.com/flying-tiger/p/8245527.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-tiger/p/8245527.html</guid>
<description>&lt;p&gt;之前我的一些文章都是在说Postgres的一些查询相关的代码。但是对于Postgres服务端是如何启动，后台进程是如何加载，服务端在哪里以及如何监听客户端的连接都没有一个清晰的逻辑。那么今天我来说说Postgres中的&lt;strong&gt;postmaster&lt;/strong&gt;模块的代码，试着解答这些问题。&lt;/p&gt;
&lt;p&gt;在正式讨论之前，我先说一下，代码主要涉及的是postgres源码的src/backend目录下的main，postmaster以及tcop模块。&lt;/p&gt;
&lt;p&gt;关于postmaster这个命令，熟悉postgres的一定不会陌生。在Linux上它是postgres命令的一个软连接，而在Windows上，它直接就是postgres命令的别名。因此，话题就转换为：postgres命令的处理细节。而postgres命令，从官方手册上我们可以知道，它是启动后端服务器的命令(当然前提是你要用initdb命令先生成一个database cluster)。无论是是直接使用postgres命令启动还是用pg_ctl命令，其本质都是调用postgres命令来启动数据库的。&lt;/p&gt;
&lt;p&gt;下面进入代码。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;命令的入口处理&quot;&gt;1.命令的入口处理&lt;/h2&gt;
&lt;p&gt;命令的入口在src/backend/main/main.c。这个main()函数所做的工作不多：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;做一下基本的初始化(主要是调用MemoryContextInit函数启动error和memory management子系统，还有其他的locale设置等)；
根据命令行的第一个参数分派不同的函数去处理。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们用postgres命令来启动一个数据库的时候，虽然参数很多。最简单的是对于&quot;–help, --version&quot;这两个参数的处理。对于这两个参数我们只需要简单的返回一下帮助信息即可返回。对于剩下的参数，我们不急着处理，因为我们首先要根据第一个参数确定的是我们希望database工作在何种模式？&lt;/p&gt;
&lt;p&gt;要回答这个问题的话，我们看一下src/backend/main/main.c，在main函数里，有以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    if (argc &amp;gt; 1 &amp;amp;&amp;amp; strcmp(argv[1], &quot;--boot&quot;) == 0)
        AuxiliaryProcessMain(argc, argv);       /* does not return */    ---&amp;gt;后端子进程，bootstrap
    else if (argc &amp;gt; 1 &amp;amp;&amp;amp; strcmp(argv[1], &quot;--describe-config&quot;) == 0)
        GucInfoMain();          /* does not return */
    else if (argc &amp;gt; 1 &amp;amp;&amp;amp; strcmp(argv[1], &quot;--single&quot;) == 0)
        PostgresMain(argc, argv,
                     NULL,      /* no dbname */
                     strdup(get_user_name_or_exit(progname)));  /* does not return */   ---&amp;gt;backend进程
    else
        PostmasterMain(argc, argv);     /* does not return */       ---&amp;gt;后台主进程&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来一一分析。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;首先是bootstrap(&quot;--boot&quot;参数指定)模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个模式大家可能比较陌生，在postgres的官方手册上也没有说明这个参数，这个参数目前只在postgres程序内部调用。这个模式下，数据库工作在启动模式下，此时数据库还不能接受外部的数据库连接，大概就是说此时数据库只是内核启动了，还没有对外部提供访问接口。那么这个模式的用处何在呢？&lt;/p&gt;
&lt;p&gt;那就让我们把目光放远一点，看看initdb这个命令吧(代码在src/bin/initdb下)。initdb命令我们很熟悉，这个命令用来初始化一个数据库集群。而在这个过程中，我们知道会建立template1，template0和postgres这个三个初始的数据库。那么问题是，我们这三个数据库是怎么建立的，数据库的表，视图索引之类的是怎么创建的？&lt;/p&gt;
&lt;p&gt;答案就是在调用工作在&quot;bootstrap&quot;模式下的postgres命令，启动一个&quot;standalone bootstrap process&quot;。也就是说，以&quot;内核&quot;模式启动postgres服务器，从而进行这一系列的数据库操作。证据何在？我们看看initdb.c:&lt;br/&gt;代码调用栈如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;main()
    -&amp;gt;initialize_data_directory()
        -&amp;gt;bootstrap_template1()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在bootstrap_template1中，有以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    snprintf(cmd, sizeof(cmd),
             &quot;\&quot;%s\&quot; --boot -x1 %s %s %s&quot;,
             backend_exec,
             data_checksums ? &quot;-k&quot; : &quot;&quot;,
             boot_options, talkargs);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以说是非常清晰了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;接下来是&quot;--describe-config&quot;参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个参数在官方手册是有定义说明的，我直接抄下来吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;这个选项会用制表符分隔的COPY格式导出服务器的内部配置变量、描述以及默认值。设计它的目的是用于管理工具。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以还是打印信息，只不过是打印数据库的内部的配置参数信息的，其实还是蛮实用的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;single(&quot;--single&quot;参数指定)模式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个很简单，选择数据库进入单用户模式。这个模式和正常的启动的差别是你是以单独的用户方式进入数据库的，不会做任何后台处理，例如自动检查点。一般是用来debug用。这里也不细说了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不指定以上参数的话，我们进入Postmater进程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;到这里，我们终于进入正题，进入PostmasterMain()函数，进入正常启动后端的过程。这个也是我们今天讨论的重点了。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;postmater的处理&quot;&gt;2.postmater的处理&lt;/h2&gt;
&lt;p&gt;postmaster部分的处理主函数是PostmasterMain()。这个函数的处理内容较多，我们按照步骤来解释：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1.memorycontext的建立与切换(切换到PostmasterContext)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们知道在main模块里我们建立了顶层上下文TopMemoryContext和其子上下文ErrorContext。此处调用AllocSetContextCreate()函数建立内存上下文PostmasterContext，并调用函数MemoryContextSwitchTo()将当前上下文切换到PostmasterContext。这样如果在Postmaster模块如果出现内存相关的问题，不会影响到其他模块(这也是内存上下文模块引入的原因吧)。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;2.信号处理函数(singal handler)的设置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;作为一个后端主进程，其拥有很多相关的子进程。我们也知道信号(singal)是进程间通信的一种比较方便的方式。这里Postmaster也利用了这一点，注册了很多信号处理函数来处理信号。有关这部分的信号以及相关的handler我列在下面了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/579102/201804/579102-20180408214809188-248117352.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;3.处理GUC和一些命令行参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这部分就比较常规了。注意这里调用InitializeGUCOptions()函数&lt;strong&gt;初始化&lt;/strong&gt;一些GUC，我们还并不能从config文件中读取，因为我们还没有处理命令行参数(命令行参数可以指定一些GUC参数以及config文件)。然后我们用getopt读取命令行参数，这样以后，我们就可以读取config文件进行GUC的设置和验证参数的合法性了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;4.数据库集群(database cluster)的锁定(lock)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;调用CreateDataDirLockFile()函数在数据库集群所在目录创建数据库集群的lock文件postmaster.pid。这样就能保证我们不会对同一个数据库集群&quot;启动两次&quot;。虽然我们也会创建socket lock文件，但是我们还是觉得数据库集群所在的目录更加可信和保险一点。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;5.共享库的预加载(process_shared_preload_libraries())&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们喜欢用Postgres的一大原因就是Postgres的丰富的插件，其中很多就是通过共享库来实现的。这里就是调用process_shared_preload_libraries()函数来导入你在shared_preload_libraries参数中指定的共享库的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;6.socket的初始化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里初始化TCP/IP socket和UNIX socket。初始化UNIX socket会在/tmp下创建socket文件。默认情况下，TCP/IP socket是禁用的，我们可以通过修改配置文件来开启。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;7.共享内存和信号量的初始化(reset_shared(PostPortNumber))&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里调用函数reset_shared(PostPortNumber)来处理共享内存和信号量。详细的说，它调用各模块的共享内存的使用量估计函数，计算总共所需的共享内存的量，并申请。详细的我们可以看CreateSharedMemoryAndSemaphores()函数。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;8.初始化(并未启动)数据库相关后台进程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;调用SysLogger_Start()函数启动syslogger后台子进程；&lt;/p&gt;
&lt;p&gt;分别调用pgstat_init()和autovac_init()函数初始化状态收集子进程(stats collection process)和自动清理子进程(autovacuum process)。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;9.读取客户端认证的配置文件()&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;调用load_hba()函数和load_ident()函数读取客户端认证文件pg_hba.conf和ident.conf。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;10.启动数据库(StartupDataBase()函数)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;做好了上面这些配置和设置，这里终于可以进行数据库的启动操作了。这里我们调用StartupDataBase()函数(其实就是一个宏)来启动数据库集群，这里主要发挥作用的是StartupProcessMain(void)函数，这个函数相当于启动数据库的Main函数。详细的调用栈如下，有兴趣的读者可以看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PostmasterMain()
    -&amp;gt;StartupDataBase()
        -&amp;gt;StartChildProcess()
            -&amp;gt;AuxiliaryProcessMain()
                -&amp;gt;StartupProcessMain(void)
                    -&amp;gt;StartupXLOG()&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;11.服务端主循环(ServerLoop())&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然数据库终于启动起来了，我们终于可以接受客户端发起的连接请求了，这里的ServerLoop()函数就是一个死循环。循环读取客户端的请求并进行相关处理。&lt;/p&gt;
&lt;p&gt;这里有一点说明，我提个问题，是不是进入ServerLoop()之后，我们就真的可以马上接受客户端的连接了呢？或者换句话说，我们到底到什么时候才能接受客户端连接呢？标志是什么呢？&lt;/p&gt;
&lt;p&gt;我们看PostmasterMain()函数里面关于上面的10和11的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    StartupPID = StartupDataBase();
    Assert(StartupPID != 0);
    StartupStatus = STARTUP_RUNNING;
    pmState = PM_STARTUP;

    /* Some workers may be scheduled to start now */
    maybe_start_bgworker();

    status = ServerLoop();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于上面的代码，我们发现，正是由StartupDataBase()函数启动了数据库，然后在ServerLoop()函数里面接受连接。&lt;/p&gt;
&lt;p&gt;但是，我们看到在进入ServerLoop()函数之前，pmState的值还是PM_STARTUP，而只有在PM_RUN状态，数据库才是真正的启动起来了。&lt;/p&gt;
&lt;p&gt;我们在看下函数reaper()，这个函数是postmaster函数的一个信号处理函数，当它捕获到Startup进程正常死亡(也就是说，数据库正常启动完毕了)后，会设置pmState为PM_RUN。&lt;/p&gt;
&lt;p&gt;因此，我们得到结论：&lt;strong&gt;在进入ServerLoop()函数后，只有在reaper函数捕获到Startup的正常死亡并设置pmState为PM_RUN之后，数据库才能真正的意义上接受连接。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们再看ServerLoop()里面到底做了什么。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;　PostmasterMain()
　  |-&amp;gt;ServerLoop()
　      |-&amp;gt;initMasks()
　      |-&amp;gt;for(;;)
　          |-&amp;gt;select()         &amp;lt;--监听端口
　          |-&amp;gt;ConnCreate()     &amp;lt;--创建connection相关的数据结构
　          |-&amp;gt;BackendStartup() &amp;lt;--建立后端进程backend process
　              |-&amp;gt;PostmasterRandom()
　              |-&amp;gt;fork_process()
　              |-&amp;gt;InitPostmasterChild()
　              |-&amp;gt;ClosePostmasterPorts()
　              |-&amp;gt;BackendInitialize()
　                  |-&amp;gt;ProcessStartupPacket()
　              |-&amp;gt;BackendRun()
　                  |-&amp;gt;PostgresMain()
            |-&amp;gt;ConnFree()       &amp;lt;--释放connection相关的数据结构&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再看看关于ServerLoop()中的关于socket和信号处理：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/579102/201804/579102-20180408221956346-1712021714.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;好的，今天就到这里，剩下的会继续讨论Postmaster的其他细节。&lt;/p&gt;
</description>
<pubDate>Mon, 09 Apr 2018 01:08:00 +0000</pubDate>
<dc:creator>非我在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-tiger/p/8245527.html</dc:identifier>
</item>
<item>
<title>R语言-离职率分析 - 月上贺兰</title>
<link>http://www.cnblogs.com/luhuajun/p/8745409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luhuajun/p/8745409.html</guid>
<description>&lt;p&gt;案例:员工流失是困扰企业的关键因素之一,在这次的分析中我将分析以下内容:&lt;/p&gt;
&lt;p&gt;　　 对一些重要变量进行可视化及探索分析,收入,晋升,满意度,绩效,是否加班等方面进行单变量分析&lt;/p&gt;
&lt;p&gt;　　 分析员工流失的因素,探索各个变量的影响度&lt;/p&gt;
&lt;p&gt;　　 构建有效的模型来预测员工是否会离职&lt;/p&gt;
&lt;p&gt;数据集主要分析的字段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;# Attrition 是否离职    需要预测的结果变量&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# Gender 性别&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# Age 年龄&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# Education 学历&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# NumCompaniesWorked 任职过的企业数量&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# TotalWorkingYears 工作年限&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# MaritalStatus 婚姻状况&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# YearsAtCompany 在公司的工作时间&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# JobRole 职位&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# JobLevel 职位等级&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# MonthlyIncome 月薪&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# JobInvolvement 工作投入程度&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# PerformanceRating 绩效评分&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# StockOptionLevel 员工的股权等级&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# PercentSalaryHike 涨薪百分比&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# TrainingTimesLastYear 上一年培训次数&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# YearsSinceLastPromotion 距离上次升值的时间&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# EnvironmentSatisfaction 环境满意度&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# JobSatisfaction 工作满意度&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# RelationshipSatisfaction 关系满意度&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# WorkLifeBalance 生活和工作的平衡度&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# DistanceFromHome 公司和家庭的距离&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# OverTime 是否要加班&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# BusinessTravel 是否要出差 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.导入包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;library(ggplot2)
library(grid)
library(gridExtra)
library(plyr)
library(rpart)
library(rpart.plot)
library(randomForest)
library(caret)
library(gbm)
library(survival)
library(pROC)
library(DMwR)
library(scales)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.导入数据集并查看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Attr.df &amp;lt;- read.csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\Udacity\\Data Analysis High\\R\\R_Study\\employee.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,header=T,encoding = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
head(Attr.df)
summary(Attr.df)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180408143409836-1513585352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:离职率大概在1:5左右&lt;/p&gt;
&lt;p&gt;　　　　 企业的员工的平均年龄在36,37岁左右&lt;/p&gt;
&lt;p&gt;　　　　 月薪的大概是在4900美元,这里采用中位数,平均数会引起偏差&lt;/p&gt;
&lt;p&gt;3.单变量分析&lt;/p&gt;
&lt;p&gt;　　3.1探索性别,年龄,工龄,企业数量,在公司的时限的分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工年龄的分布&lt;/span&gt;
g1 &amp;lt;- ggplot(Attr.df,aes(x=Age,fill=Attrition))+&lt;span&gt;
  geom_density(alpha&lt;/span&gt;=0.7&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工工作过的企业数量的关系&lt;/span&gt;
g2 &amp;lt;- ggplot(Attr.df,aes(x=NumCompaniesWorked,fill=Attrition))+&lt;span&gt;
  geom_density(alpha&lt;/span&gt;=0.7&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工工龄的分布&lt;/span&gt;
g3 &amp;lt;- ggplot(Attr.df,aes(x=YearsAtCompany,fill=Attrition))+&lt;span&gt;
  geom_density(alpha&lt;/span&gt;=0.7&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工总体工作年限的分布&lt;/span&gt;
g4 &amp;lt;- ggplot(Attr.df,aes(x=TotalWorkingYears,fill=Attrition))+&lt;span&gt;
  geom_density(alpha&lt;/span&gt;=0.7&lt;span&gt;)
grid.arrange(g1,g2,g3,g4,ncol&lt;/span&gt;=2,nrow=2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180408144255213-1236414778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:&lt;/p&gt;
&lt;p&gt;　　　　1.年龄较低的员工的离职率较高,主要集中在30岁以下的员工&lt;/p&gt;
&lt;p&gt;　　　　2.工作过的企业数量越多越容易离职&lt;/p&gt;
&lt;p&gt;　　　　3.在公司工作的时间越久,越不容易离职&lt;/p&gt;
&lt;p&gt;　　　　4.工龄低的员工离职的几率比较大&lt;/p&gt;
&lt;p&gt;　　3.2性别,职位等级,教育背景,部门的分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工的性别分布&lt;/span&gt;
g5 &amp;lt;- ggplot(Attr.df, aes(x= Gender,fill = Attrition)) +&lt;span&gt; 
  geom_bar(position &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fill&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt;
  labs(y&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + scale_y_continuous(labels=&lt;span&gt;percent) 

&lt;/span&gt;&lt;span&gt;# 离职员工的职位等级分布&lt;br/&gt;&lt;/span&gt;g6 &amp;lt;-ggplot(Attr.df, aes(x= JobLevel,fill = Attrition)) +&lt;span&gt; &lt;br/&gt;　　geom_bar(position &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fill&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt; labs(y&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;br/&gt;　　scale_y_continuous(labels=&lt;span&gt;percent) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工的教育背景分布&lt;/span&gt; &lt;br/&gt;g7 &amp;lt;- ggplot(Attr.df, aes(x= Education,fill = Attrition)) +&lt;span&gt; &lt;br/&gt;　　geom_bar(position &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fill&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt; labs(y&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;br/&gt;　　scale_y_continuous(labels=&lt;span&gt;percent) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工的部门分布&lt;/span&gt; &lt;br/&gt;g8 &amp;lt;- ggplot(Attr.df, aes(x= Department,fill = Attrition)) +&lt;span&gt; &lt;br/&gt;　　geom_bar(position &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fill&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt; labs(y&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + &lt;br/&gt;　　scale_y_continuous(labels=&lt;span&gt;percent) grid.arrange(g5, g6, g7, g8, ncol &lt;/span&gt;= 2, nrow = 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180408145338122-1550112010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:&lt;/p&gt;
&lt;p&gt;　　　　1.男性的离职率比女性稍高&lt;/p&gt;
&lt;p&gt;　　　　2.等级越高离职的可能性越小,但是主要集中1级别的职场新人&lt;/p&gt;
&lt;p&gt;　　　　3.学历和离职率没有太大的关联&lt;/p&gt;
&lt;p&gt;　　　　4.销售部门相对于其他两个部门离职率较高&lt;/p&gt;
&lt;p&gt;　　3.3 探索涨薪比例,培训次数,每年晋升,员工股权的分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工与涨薪比例的关系&lt;/span&gt;
g11 &amp;lt;- ggplot(Attr.df, aes(x = PercentSalaryHike, fill = Attrition)) +&lt;span&gt; 
  geom_density(alpha &lt;/span&gt;= 0.7&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工与培训次数的关系&lt;/span&gt;
g12 &amp;lt;- ggplot(Attr.df, aes(x= TrainingTimesLastYear,  group=Attrition)) +&lt;span&gt; 
  geom_bar(aes(y &lt;/span&gt;= ..prop.., fill =&lt;span&gt; Attrition), 
           stat&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, alpha = 0.7,position = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt;
  labs(y&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + scale_y_continuous(labels=&lt;span&gt;percent) 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工的与每年晋升的关系&lt;/span&gt;
g13 &amp;lt;- ggplot(Attr.df, aes(x = YearsSinceLastPromotion, fill = Attrition)) +&lt;span&gt; 
  geom_density(alpha &lt;/span&gt;= 0.7&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工与股票期权的关系&lt;/span&gt;
g14 &amp;lt;- ggplot(Attr.df, aes(x= StockOptionLevel,  group=Attrition)) +&lt;span&gt; 
  geom_bar(aes(y &lt;/span&gt;= ..prop.., fill =&lt;span&gt; Attrition), 
           stat&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, alpha = 0.7,position = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt;
  labs(y&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + scale_y_continuous(labels=&lt;span&gt;percent) 

grid.arrange(g11, g12, g13, g14, ncol &lt;/span&gt;= 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180408150153686-579634386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　结论:&lt;/p&gt;
&lt;p&gt;　　　　　　1.没有涨薪计划的员工流失率较高&lt;/p&gt;
&lt;p&gt;　　　　　　2.培训次数和离职率没有太大的影响&lt;/p&gt;
&lt;p&gt;　　　　　　3.没有晋升的员工离职率较高&lt;/p&gt;
&lt;p&gt;　　　　　　4.没有股权的员工流失率较大&lt;/p&gt;
&lt;p&gt;　　3.4探索工作满意度,同事满意度,环境满意度的分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工与工作满意度的关系&lt;/span&gt;
g15 &amp;lt;- ggplot(Attr.df, aes(x= JobSatisfaction,  group=Attrition)) +&lt;span&gt; 
  geom_bar(aes(y &lt;/span&gt;= ..prop.., fill =&lt;span&gt; Attrition), 
           stat&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, alpha = 0.7,position = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt;
  labs(y&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + scale_y_continuous(labels=&lt;span&gt;percent) 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工与同事满意度的关系&lt;/span&gt;
g16 &amp;lt;- ggplot(Attr.df, aes(x= RelationshipSatisfaction,  group=Attrition)) +&lt;span&gt; 
  geom_bar(aes(y &lt;/span&gt;= ..prop.., fill =&lt;span&gt; Attrition), 
           stat&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, alpha = 0.7,position = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt;
  labs(y&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + scale_y_continuous(labels=&lt;span&gt;percent) 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工与工作环境满意度的关系&lt;/span&gt;
g17 &amp;lt;- ggplot(Attr.df, aes(x= EnvironmentSatisfaction,  group=Attrition)) +&lt;span&gt; 
  geom_bar(aes(y &lt;/span&gt;= ..prop.., fill =&lt;span&gt; Attrition), 
           stat&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, alpha = 0.7,position = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt;
  labs(y&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + scale_y_continuous(labels=&lt;span&gt;percent) 
grid.arrange(g15, g16,g17, ncol &lt;/span&gt;= 3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180408150820495-1268179465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:满意度越高越不容易离职&lt;/p&gt;
&lt;p&gt;　　3.5探索加班,工作生活的平衡性,是否需要出差,家庭距离之间的关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工和加班之间的关系&lt;/span&gt;
g18 &amp;lt;- ggplot(Attr.df, aes(x= OverTime,  group=Attrition)) +&lt;span&gt; 
  geom_bar(aes(y &lt;/span&gt;= ..prop.., fill =&lt;span&gt; Attrition), 
           stat&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, alpha = 0.7,position = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt;
  labs(y&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + scale_y_continuous(labels=&lt;span&gt;percent) 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工和工作生活之间的关系&lt;/span&gt;
g19 &amp;lt;- ggplot(Attr.df, aes(x= WorkLifeBalance,  group=Attrition)) +&lt;span&gt; 
  geom_bar(aes(y &lt;/span&gt;= ..prop.., fill =&lt;span&gt; Attrition), 
           stat&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, alpha = 0.7,position = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt;
  labs(y&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + scale_y_continuous(labels=&lt;span&gt;percent) 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工和出差之间的关系&lt;/span&gt;
g20 &amp;lt;- ggplot(Attr.df, aes(x= BusinessTravel,  group=Attrition)) +&lt;span&gt; 
  geom_bar(aes(y &lt;/span&gt;= ..prop.., fill =&lt;span&gt; Attrition), 
           stat&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, alpha = 0.7,position = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt;
  labs(y&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + scale_y_continuous(labels=&lt;span&gt;percent) 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 离职员工和上班距离之间的关系&lt;/span&gt;
g21 &amp;lt;- ggplot(Attr.df,aes(x=DistanceFromHome,fill=Attrition))+&lt;span&gt;
  geom_density(alpha&lt;/span&gt;=0.7&lt;span&gt;)

grid.arrange(g18, g19,g20,g21, ncol &lt;/span&gt;= 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180408154638519-337257744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:&lt;/p&gt;
&lt;p&gt;　　　　1.加班越多离职率越高&lt;/p&gt;
&lt;p&gt;　　　　2.认为工作和生活协调为1的员工工离职率较高&lt;/p&gt;
&lt;p&gt;　　　　3.经常出差的员工离职率较高&lt;/p&gt;
&lt;p&gt;　　　　4.距离上班地点越远的员工离职率较高&lt;/p&gt;
&lt;p&gt;　　3.6月薪,职位等级和离职率的关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;# 离职员工和月薪的关系&lt;/span&gt;
g9 &lt;/span&gt;&amp;lt;- ggplot(Attr.df,aes(x=MonthlyIncome,fill=Attrition))+&lt;span&gt;
  geom_density(alpha&lt;/span&gt;=&lt;span&gt;0.7&lt;/span&gt;&lt;span&gt;)
&lt;span&gt;
# 离职员工与职位等级的关系&lt;/span&gt;
g10 &lt;/span&gt;&amp;lt;- ggplot(Attr.df, aes(x= JobInvolvement,  group=Attrition)) +&lt;span&gt; 
  geom_bar(aes(y &lt;/span&gt;= ..prop.., fill =&lt;span&gt; Attrition), 
           stat&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, alpha = &lt;span&gt;0.7&lt;/span&gt;,position = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,color=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt;
  labs(y&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Percentage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) + scale_y_continuous(labels=&lt;span&gt;percent) 

grid.arrange(g9, g10, ncol &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180409081747040-1020129540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:&lt;/p&gt;
&lt;p&gt;　　　　1.月薪低的员工容易离职&lt;/p&gt;
&lt;p&gt;　　　　2.职位级别低的离职率较高,但不是很明显&lt;/p&gt;
&lt;p&gt;　　3.6进一步分析月薪和职位级别的关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
ggplot(Attr.df,aes(x=JobInvolvement,y=MonthlyIncome,group=JobInvolvement))+&lt;span&gt;
  geom_boxplot(aes(fill&lt;/span&gt;=factor(..x..)),alpha=0.7)+&lt;span&gt;
  theme(legend.position &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,plot.title = element_text(hjust = 0.5))+&lt;span&gt;
  facet_grid(&lt;/span&gt;~Attrition)+ggtitle(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Attrition&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180409082119715-1477038429.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　结论:可以明显的得出收入的高低并不是影响员工离职的最主要的因素,如果付出和回报不成正比,会有极大的员工流动&lt;/p&gt;
&lt;p&gt;4.建模&lt;/p&gt;
&lt;p&gt;　　4.1决策树&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 去除数据集中没有必要的因子&lt;/span&gt;
levels(Attr.df$JobRole) &amp;lt;- c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lab&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Man&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MDir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RsD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RsSci&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SlEx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SlRep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
levels(Attr.df$EducationField) &lt;/span&gt;&amp;lt;- c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MRK&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MED&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NA&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TD&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
Attr.df &lt;/span&gt;&amp;lt;- Attr.df[c(-9,-10,-22,-27&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把数据集划分成训练集和测试集&lt;/span&gt;
n &amp;lt;-&lt;span&gt; nrow(Attr.df)
rnd &lt;/span&gt;&amp;lt;- sample(n,n*0.7&lt;span&gt;)
train &lt;/span&gt;&amp;lt;-&lt;span&gt; Attr.df[rnd,]
test &lt;/span&gt;&amp;lt;- Attr.df[-&lt;span&gt;rnd,]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 建模&lt;/span&gt;
dtree &amp;lt;- rpart(Attrition~.,data=&lt;span&gt;train)
preds &lt;/span&gt;&amp;lt;- predict(dtree,test,type=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
rocv &lt;/span&gt;&amp;lt;-&lt;span&gt; roc(as.numeric(test$Attrition),as.numeric(preds))
rocv$auc
prop.table(table(test$Attrition,preds,dnn &lt;/span&gt;= c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Actual&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Predicted&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)),1&lt;span&gt;)
dtreepr &lt;/span&gt;&amp;lt;- prune(dtree,cp=0.01666667&lt;span&gt;)
predspr &lt;/span&gt;&amp;lt;- predict(dtreepr,test,type=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
rocvpr &lt;/span&gt;&amp;lt;-&lt;span&gt; roc(as.numeric(test$Attrition),as.numeric(predspr))
rocvpr$auc
rpart.plot(dtreepr,type&lt;/span&gt;=4,extra=104,tweak = 0.9,fallen.leaves = F,cex = 0.7)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180409082810240-1586069849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:AUC的值0.624比较低,而且灵敏度0.3说明该模型并不能很好的预测离职&lt;/p&gt;
&lt;p&gt;　　4.2随机森林&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
set.seed(2343&lt;span&gt;)
fit.forest &lt;/span&gt;&amp;lt;- randomForest(Attrition~.,data=&lt;span&gt;train)
rfpreds &lt;/span&gt;&amp;lt;- predict(fit.forest,test,type=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
rocrf &lt;/span&gt;&amp;lt;-&lt;span&gt; roc(as.numeric(test$Attrition),as.numeric(rfpreds))
rocrf$auc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180409083307859-912159783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:需要进行优化&lt;/p&gt;
&lt;p&gt;　　4.3GBM&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
set.seed(3443&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义10折交叉验证用于控制所有的GBM模型训练&lt;/span&gt;
ctrl &amp;lt;- trainControl(method = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;cv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,number=10,summaryFunction = twoClassSummary,classProbs =&lt;span&gt; T)
gbmfit &lt;/span&gt;&amp;lt;- train(Attrition~.,data=train,method=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gbm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,verbose=F,metric=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ROC&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,trControl=&lt;span&gt;ctrl)
gbmpreds &lt;/span&gt;&amp;lt;-&lt;span&gt; predict(gbmfit,test)
rocgbm &lt;/span&gt;&amp;lt;-&lt;span&gt; roc(as.numeric(test$Attrition),as.numeric(gbmpreds))
rocgbm$auc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180409083457166-1160240062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:需要进行优化&lt;/p&gt;
&lt;p&gt;　4.4优化GBM模型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置和之前一样的种子数&lt;/span&gt;
ctrl$seeds &amp;lt;-&lt;span&gt; gbmfit$control$seeds

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 加权GBM,设置权重参数,平衡样本&lt;/span&gt;
model_weights &amp;lt;- ifelse(train$Attrition == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;No&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        (&lt;/span&gt;1/table(train$Attrition)[1&lt;span&gt;]),
                        (&lt;/span&gt;1/table(train$Attrition)[2&lt;span&gt;]))
                        
    
weightedleft &lt;/span&gt;&amp;lt;- train(Attrition ~&lt;span&gt; .,
                      data&lt;/span&gt;=&lt;span&gt;train,
                      method&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gbm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                      verbose&lt;/span&gt;=&lt;span&gt;F,
                      weights&lt;/span&gt;=&lt;span&gt;model_weights,
                      metric&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ROC&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                      trControl&lt;/span&gt;=&lt;span&gt;ctrl)

weightedpreds &lt;/span&gt;&amp;lt;-&lt;span&gt; predict(weightedleft,test)
rocweight &lt;/span&gt;&amp;lt;-&lt;span&gt; roc(as.numeric(test$Attrition),as.numeric(weightedpreds))
rocweight$auc

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 向上采样&lt;/span&gt;
ctrl$sampling &amp;lt;- &lt;span&gt;'&lt;/span&gt;&lt;span&gt;up&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
set.seed(&lt;/span&gt;3433&lt;span&gt;)
upfit &lt;/span&gt;&amp;lt;- train(Attrition ~&lt;span&gt;., 
               data &lt;/span&gt;=&lt;span&gt; train, 
               method &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gbm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
               verbose &lt;/span&gt;=&lt;span&gt; FALSE, 
               metric &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ROC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
               trControl &lt;/span&gt;=&lt;span&gt; ctrl)

uppreds &lt;/span&gt;&amp;lt;-&lt;span&gt; predict(upfit, test)
rocup &lt;/span&gt;&amp;lt;-&lt;span&gt; roc(as.numeric(test$Attrition), as.numeric(uppreds))
rocup$auc

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 向下采样&lt;/span&gt;
ctrl$sampling &amp;lt;- &lt;span&gt;'&lt;/span&gt;&lt;span&gt;down&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
set.seed(&lt;/span&gt;3433&lt;span&gt;)
downfit &lt;/span&gt;&amp;lt;- train(Attrition ~&lt;span&gt;., 
               data &lt;/span&gt;=&lt;span&gt; train, 
               method &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gbm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
               verbose &lt;/span&gt;=&lt;span&gt; FALSE, 
               metric &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ROC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 
               trControl &lt;/span&gt;=&lt;span&gt; ctrl)

downpreds &lt;/span&gt;&amp;lt;-&lt;span&gt; predict(downfit, test)
rocdown &lt;/span&gt;&amp;lt;-&lt;span&gt; roc(as.numeric(test$Attrition), as.numeric(downpreds))
rocdown$auc

prop.table(table(test$Attrition, weightedpreds, dnn &lt;/span&gt;= c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Actual&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Predicted&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)),1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180409084426715-289595285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:选取第二车向上采样的模型,精确度提升到72%,灵敏度提升到62%&lt;/p&gt;
&lt;p&gt;5 使用模型来预测离职&lt;/p&gt;
&lt;p&gt;　　5.1查看哪些因素影响员工离职&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
varImp(upfit)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180409084756273-359353771.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:影响员工离职的首要因素:加班,月薪,在公司工作的年限,是否有股权,年龄等因素&lt;/p&gt;
&lt;p&gt;　　5.2预测工作投入高,月薪少的员工的离职率&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
upfitprobs &amp;lt;- predict(upfit,test,type = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;prob&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
test$Prediction &lt;/span&gt;&amp;lt;-&lt;span&gt; upfitprobs$Yes
ggplot(test,
       aes(x&lt;/span&gt;=MonthlyIncome,y=Prediction,color=factor(JobInvolvement)))+&lt;span&gt;
  geom_point(alpha&lt;/span&gt;=0.7)+&lt;span&gt;
  geom_smooth(method &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  facet_wrap(&lt;/span&gt;~JobInvolvement)+&lt;span&gt;
  theme(legend.position &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  ggtitle(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;JobInvolvement&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  theme(plot.title &lt;/span&gt;= element_text(hjust = 0.5))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180409085219854-936851599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:图4表示工作投入高,但是月薪低的员工反而是不容易离职的,可能是因为对企业有归属感或者是企业的其他福利待遇较好&lt;/p&gt;
&lt;p&gt;　　5.3预测那些职位的离职率最高&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
ggplot(test,aes(x=JobRole,y=Prediction,fill=JobRole))+&lt;span&gt;
  geom_boxplot(alpha&lt;/span&gt;=0.5)+&lt;span&gt;
  theme(legend.position &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  scale_y_continuous(labels &lt;/span&gt;= percent)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201804/1173792-20180409085424755-780652567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:销售的离职率相对与其他的离职率较大&lt;/p&gt;
&lt;p&gt;总结:&lt;/p&gt;
&lt;p&gt;　　1.员工离职的很大原因是因为加班,或者是付出和回报不成正比导致的&lt;/p&gt;
&lt;p&gt;　　2.在某些生活方面,比如频繁出差,上班路程较远也是员工离职的一个次要原因&lt;/p&gt;
&lt;p&gt;　　3.相比于高薪的吸引力,员工更加认可股权的享有,享有股权分红的员工更不容易离职&lt;/p&gt;
&lt;p&gt;　　4.年龄,在公司的年限和工龄也是影响员工离职的一些重要的指标&lt;/p&gt;
&lt;p&gt;　　5.如果有更多的真实数据集,模型可能会更加准确&lt;/p&gt;
&lt;p&gt;github:https://github.com/Mounment/R-Project&lt;/p&gt;
</description>
<pubDate>Mon, 09 Apr 2018 01:00:00 +0000</pubDate>
<dc:creator>月上贺兰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luhuajun/p/8745409.html</dc:identifier>
</item>
</channel>
</rss>