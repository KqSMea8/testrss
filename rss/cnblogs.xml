<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>电力 Web SCADA 工控组态编辑器 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/8861348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/8861348.html</guid>
<description>&lt;p&gt;SVG 并非仅仅是一种图像格式， 由于它是一种基于 XML 的语言，也就意味着它继承了 XML 的跨平台性和可扩展性，从而在图形可重用性上迈出了一大步。如 SVG 可以内嵌于其他的 XML 文档中，而 SVG 文档中也可以嵌入其他的 XML 内容，各个不同的 SVG 图形可以方便地组合， 构成新的 SVG 图形。这个 Demo 运用的技术基于 HTML5 的技术适应了只能电网调度、配电网运行监控与配电网运维管控，通过移动终端实现 Web SCADA 账上运维的时代需求。由于传统电力行业 CS 桌面监控系统一直到新一代 Web 和移动终端进化中，HT 是实施成本最低，开发和运行效率最高的前端图形技术解决方案。SVG 矢量图形大家都不会陌生了，尤其是在工控电信等领域，但是这篇文章并不是要制作一个新的绘制 SVG 图的编辑器，而是一个可绘制矢量图形并且对这个图形进行数据绑定的更高阶。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201804/591709-20180417070126248-541087473.gif&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;整体框架&lt;/h2&gt;
&lt;p&gt;根据上图看得出来，整个界面被分为五个部分，分别为 palette 组件面板，toolbar 工具条，graphView 拓扑组件，propertyPane 属性面板以及 treeView 树组件，这五个部分中的组件需要先创建出来，然后才放到对应的位置上去：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
palette = &lt;span&gt;new&lt;/span&gt; ht.widget.Palette();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 组件面板&lt;/span&gt;
toolbar = &lt;span&gt;new&lt;/span&gt; ht.widget.Toolbar(toolbar_config);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 工具条&lt;/span&gt;
g2d = &lt;span&gt;new&lt;/span&gt; ht.graph.GraphView(dataModel);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拓扑组件  &lt;/span&gt;
treeView = &lt;span&gt;new&lt;/span&gt; ht.widget.TreeView(dataModel);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 树组件&lt;/span&gt;
propertyPane = &lt;span&gt;new&lt;/span&gt; ht.widget.PropertyPane(dataModel);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 属性面板&lt;/span&gt;
propertyView = propertyPane.getPropertyView();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 属性组件&lt;/span&gt;
rulerFrame = &lt;span&gt;new&lt;/span&gt; ht.widget.RulerFrame(g2d);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刻度尺&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201804/591709-20180408191242375-1043688896.png&quot; alt=&quot;&quot; width=&quot;362&quot; height=&quot;219&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些布局，只需要结合 splitView 和 borderPane 进行布局即可轻松完成~其中 splitView 为 HT 中的 分割组件，参数1为放置在前面的 view 组件（可为左边的，或者上面的）；参数2为放置在后面的 view 组件（可为右边的，或者下面的）；参数3为可选值，默认为 h，表示左右分割，若设置为 v 则为上下分割；参数4即为分割的比例。borderPane 跟 splitView 的作用有些相似，但是在这个 Demo 中布局，结合这两种组件，代码看起来会更加清爽。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
borderPane = &lt;span&gt;new&lt;/span&gt; ht.widget.BorderPane();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 边框面板&lt;/span&gt;
leftSplit = &lt;span&gt;new&lt;/span&gt; ht.widget.SplitView(palette, borderPane, 'h', 260);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分割组件，h表示左右分割，v表示上下分割&lt;/span&gt;
rightSplit = &lt;span&gt;new&lt;/span&gt; ht.widget.SplitView(propertyPane, treeView, 'v', 0.4&lt;span&gt;);
mainSplit &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ht.widget.SplitView(leftSplit, rightSplit, 'h', -260&lt;span&gt;);                                              

borderPane.setTopView(toolbar);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置边框面板的顶部组件为 toolbar&lt;/span&gt;
borderPane.setTopHeight(30&lt;span&gt;);
borderPane.setCenterView(rulerFrame);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置边框面板的中间组件为 rulerframe&lt;/span&gt;
mainSplit.addToDOM();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 mainSplit 的底层 div 添加进 body 体中&lt;/span&gt;
&lt;span&gt;
dataModel.deserialize(datamodel_config);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反序列化 datamodel_config 的内容，将json内容转为拓扑图场景内容&lt;/span&gt;
g2d.fitContent(&lt;span&gt;true&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;布局结束后，就要考虑每一个容器中应该放置哪些内容，我将这些内容分别封装到不同的函数中，通过调用这些函数来进行数据的显示。&lt;/p&gt;
&lt;h2&gt;Palette 组件面板&lt;/h2&gt;
&lt;p&gt;左侧的 Palette 组件面板需要向其内部添加 group 作为分组，然后再向组内添加节点。但是我们使用这个组件的最重要的一个原因是它能够拖拽节点，但是因为我们拖拽后需要在 graphView 拓扑组件中生成一个新的节点显示在拓扑图上，所以我将拖拽部分的逻辑写在了 graphView 拓扑组件的初始化函数中，这一小节就不做解释。&lt;/p&gt;
&lt;p&gt;虽然说最重要的因素是拖拽，但是不可否认，这个组件在分类上也是非常直观：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201804/591709-20180409105005776-840759334.png&quot; alt=&quot;&quot; width=&quot;168&quot; height=&quot;236&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，我在 Palette 中做了三个分组：电力、食品加工厂以及污水处理。并在这些分组下面填充了很多属于该组类型的节点。我将这些分组的信息存储在 palette_config.js 文件中，由于三组中的信息量太大，这里只将一小部分的信息展示出来，看看是如何通过 json 对象来对分组进行数据显示的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
palette_config =&lt;span&gt; {
    scene: {
        name: &lt;/span&gt;'电力'&lt;span&gt;,
        items: [
            { name: &lt;/span&gt;'文字', image: '__text__'&lt;span&gt;, type: ht.Text },
            { name: &lt;/span&gt;'箭头', image: 'symbols/arrow.json'&lt;span&gt; },
            { name: &lt;/span&gt;'地线', image: 'symbols/earthwire.json'&lt;span&gt; }
        ]
    },
    food: {
        name: &lt;/span&gt;'食品加工厂'&lt;span&gt;,
        items: [
            { name: &lt;/span&gt;'间歇式流化床处理器', image: 'symbols/food/Batch fluid bed processor.json'&lt;span&gt;},
            { name: &lt;/span&gt;'啤酒瓶', image: 'symbols/food/Beer bottle.json'&lt;span&gt;},
            { name: &lt;/span&gt;'台式均质机', image: 'symbols/food/Batch fluid bed processor.json'&lt;span&gt;}
        ]
    },
    pumps: {
        name: &lt;/span&gt;'污水处理'&lt;span&gt;,
        items: [
            { name: &lt;/span&gt;'3维泵', image: 'symbols/pumps/3-D Pump.json'&lt;span&gt;},
            { name: &lt;/span&gt;'18-惠勒卡车', image: 'symbols/pumps/18-wheeler truck 1.json'&lt;span&gt;}
        ]
    }     
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过遍历这个对象获取内部数据，显示不同的数据信息。当然，在获取对象的信息的时候，我们需要创建 ht.Group 类的对象，以及分组内部的 ht.Node 类的元素（这些元素都为组的孩子），然后将这些获取来的数据赋值到这两种类型的节点上，并且将这些节点添加到 Palette 的数据容器中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; initPalette(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化组件面板中的内容&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; name &lt;span&gt;in&lt;/span&gt; palette_config){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从 palette_config.js 文件中获取数据&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; info =&lt;span&gt; palette_config[name];
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; group = &lt;span&gt;new&lt;/span&gt; ht.Group();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 组件面板用ht.Group展示分组，ht.Node展示按钮元素&lt;/span&gt;
&lt;span&gt;        group.setName(info.name);
        group.setExpanded(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置group默认关闭&lt;/span&gt;
        palette.dm().add(group);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将节点添加到 palette 的数据容器中&lt;/span&gt;
&lt;span&gt;        
        info.items.forEach(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(item){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; node = &lt;span&gt;new&lt;/span&gt; ht.Node();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新建 ht.Node 类型节点&lt;/span&gt;
            node.setName(item.name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置名称 用于显示在 palette 面板中节点下方说明文字&lt;/span&gt;
            node.setImage(item.image);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置节点在 palette 面板中的显示图片&lt;/span&gt;

            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文本类型&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (item.type === ht.Text) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过 json 对象中设置的 type 信息来获取当前信息为何种类型的节点，不同类型的节点有些属性设置不同&lt;/span&gt;
&lt;span&gt;                node.s({
                    &lt;/span&gt;'text': 'Text',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文本类型的节点需要设置这个属性显示文本的内容&lt;/span&gt;
                    'text.align': 'center',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文本对齐方式&lt;/span&gt;
                    'text.vAlign': 'middle',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文本垂直对齐方式&lt;/span&gt;
                    'text.font': '32px Arial'&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文本字体&lt;/span&gt;
&lt;span&gt;                });
            }

            node.item &lt;/span&gt;=&lt;span&gt; item;
            node.s({
                &lt;/span&gt;'image.stretch': item.stretch || 'centerUniform',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置节点显示图片为填充的方式，这样不同比例的图片也不会因为拉伸而导致变形&lt;/span&gt;
                'draggable': item.draggable === undefined ? &lt;span&gt;true&lt;/span&gt; : item.draggable,&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置节点是否可被拖拽&lt;/span&gt;
&lt;span&gt;
            });                          
            group.addChild(node);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将节点设置为 group 组的孩子&lt;/span&gt;
            palette.dm().add(node);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点同样也得添加到 palette 的数据容器中进行存储&lt;/span&gt;
&lt;span&gt;        });
    }             
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;graphView 拓扑组件&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201804/591709-20180409124531515-2020865665.gif&quot; alt=&quot;&quot; width=&quot;482&quot; height=&quot;296&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.hightopo.com/demo/2deditor/HT-2D-Editor.html&quot; target=&quot;_blank&quot;&gt;http://www.hightopo.com/demo/2deditor/HT-2D-Editor.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面说到了 Palette 组件中节点拖拽到 graphView 拓扑图形中，来看看这个部分是如何实现的。如果 Palette 中的 Node 的 draggable 属性设置为  true ，那么 Palette 可以自动处理 dragstart ，但是 dragover 和 dragdrop 事件需要我们处理，我们知道 IOS 和 Android 设备上并不支持 dragover 和 dragdrop 这类事件，所以 Palette 插件还提供了模拟的拖拽事件 handleDragAndDrop，可以完美兼容 PC 和手持终端。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; initGraphView(){       
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ht.Default.isTouchable){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否为触屏可Touch方式交互&lt;/span&gt;
        palette.handleDragAndDrop = &lt;span&gt;function&lt;/span&gt;(e, state) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重写此方法可以禁用HTML5原生的Drag和Drop事件并启用模拟的拖拽事件&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(ht.Default.containedInView(e, g2d)){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断交互事件所处位置是否在View组件之上&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(state === 'between'&lt;span&gt;){
                    e.preventDefault();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取消事件的默认动作。&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(state === 'end'){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当state为end时，判断e是否在graphView的范围内，如果是，则创建Node&lt;/span&gt;
&lt;span&gt;                    handleDrop(e);
                }
            }
        };
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        g2d.getView().addEventListener(&lt;/span&gt;&quot;dragover&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
            e.dataTransfer.dropEffect &lt;/span&gt;= &quot;copy&quot;&lt;span&gt;;
            e.preventDefault();
        });
        g2d.getView().addEventListener(&lt;/span&gt;&quot;drop&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e) {
            handleDrop(e);
        });
    }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; handleDrop(e){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 被拖拽的元素在目标元素上同时鼠标放开触发的事件&lt;/span&gt;
&lt;span&gt;    e.preventDefault();
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; paletteNode = palette.dm().sm().ld();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 palette 面板上最后选中的节点                 &lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (paletteNode) {   
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; item =&lt;span&gt; paletteNode.item,
            image &lt;/span&gt;=&lt;span&gt; item.image;
            data &lt;/span&gt;= g2d.getDataAt(e, &lt;span&gt;null&lt;/span&gt;, 5);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取事件下的节点&lt;/span&gt;

        &lt;span&gt;var&lt;/span&gt; node = &lt;span&gt;new&lt;/span&gt; (item.type ||&lt;span&gt; ht.Node)();
        node.setImage(image);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置节点图片&lt;/span&gt;
        node.setName(item.name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置节点名称&lt;/span&gt;
        node.p(g2d.lp(e));&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置节点的坐标为拓扑中的逻辑坐标 lp函数为将事件坐标转换为拓扑中的逻辑坐标&lt;/span&gt;
        node.s('label', '');&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置节点在 graphView 中底部不显示 setName 中的说明。因为 label 的优先级大于 name &lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt;(data &lt;span&gt;instanceof&lt;/span&gt; ht.Group){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果拖拽到“组类型”的节点上，那么直接设置父亲孩子关系&lt;/span&gt;
            node.setParent(data);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置节点的父亲&lt;/span&gt;
            data.setExpanded(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 展开分组&lt;/span&gt;
        }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            node.setParent(g2d.getCurrentSubGraph());
        }       
        g2d.dm().add(node);
        g2d.sm().ss(node);                                                     
    }                    
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我在 graphView 拓扑图的场景中央添加了一个 json 场景，通过 dm.deserialize(datamodel_config) 反序列化 json 场景内容导出的一个电信行业的图纸。HT 独特的矢量引擎功能满足电力行业设备种类繁多、设备图元和线路网络需无极缩放、绑定量测数据实时刷新等需求；三维呈现技术使得电力厂站和变压器等设备 3D 可视化监控成为可能。&lt;/p&gt;
&lt;h2&gt;treeView 树组件 &lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201804/591709-20180410150808298-1753912310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于树组件，树组件和 graphView  拓扑组件共用同一个 dataModl 数据容器，本来只需要创建出一个树组件对象，然后将其添加进布局容器中即可显示当前拓扑图形中的所有的数据节点，一般 HT 会将树组件上的节点分为几种类型进行显示，ht.Edge、ht.Group、ht.Node、ht.SubGraph、ht.Shape 等类型进行显示，但是这样做有一个问题，如果创建的节点非常多的话，那么无法分辨出那个节点是哪一个，也就无法快速地定位和修改该节点，会给绘图人员带来很大的困扰，所以我在 treeView 的 label 和 icon 的显示上做了一些处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化树组件&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; initTreeView() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重载树组件上的文本显示&lt;/span&gt;
    treeView.getLabel = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ht.Text) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; data.s('text'&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ht.Shape) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; data.getName() || '不规则图形'&lt;span&gt;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; data.getName() || '节点'&lt;span&gt;
    };

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重载树组件上的图标显示&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; oldGetIconFunc =&lt;span&gt; treeView.getIcon;
    treeView.getIcon &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (data &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ht.Text) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'symbols/text.json'&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; img =&lt;span&gt; data.getImage();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; img ? img : oldGetIconFunc.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; propertyPane 属性面板&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201804/591709-20180410164620695-1217052817.png&quot; alt=&quot;&quot; width=&quot;623&quot; height=&quot;327&quot;/&gt;&lt;/p&gt;
&lt;p&gt;属性面板，即为显示属性的一个容器，不同的类型的节点可能在属性的显示上有所不同，所以我在 properties_config.js 文件中将几个比较常见的类型的属性存储到数组中，主要有几种属性： text_properties 用于显示文本类型的节点的属性、data_properties 所有的 data 节点均显示的属性、node_properties 用于显示 ht.Node 类型的节点的属性、group_properties 用于显示 ht.Group 类型的节点的属性以及 edge_properties 用于显示 ht.Edge 类型的节点的属性。通过将这些属性分类，我们可以对在 graphView 中选中的不同的节点类型来对属性进行过滤：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.811066126856&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; initPropertyView(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化属性组件               &lt;/span&gt;
    dataModel.sm().ms(&lt;span&gt;function&lt;/span&gt;(e){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听选中变化事件&lt;/span&gt;
        propertyView.setProperties(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; dataModel.sm().ld();
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 针对不同类型的节点设置不同的属性内容&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (data &lt;span&gt;instanceof&lt;/span&gt; ht.Text) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文本类型&lt;/span&gt;
&lt;span&gt;            propertyView.addProperties(text_properties);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data &lt;span&gt;instanceof&lt;/span&gt; ht.Data){&lt;span&gt;// &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;http://hightopo.com/&quot; target=&quot;_blank&quot;&gt;data&lt;/a&gt; 类型，所有的节点都基于这个类型&lt;/span&gt;
&lt;span&gt;            propertyView.addProperties(data_properties);
        }                                        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data &lt;span&gt;instanceof&lt;/span&gt; ht.Node){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; node 类型&lt;/span&gt;
&lt;span&gt;            propertyView.addProperties(node_properties);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data &lt;span&gt;instanceof&lt;/span&gt; ht.Group){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 组类型&lt;/span&gt;
&lt;span&gt;            propertyView.addProperties(group_properties);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data &lt;span&gt;instanceof&lt;/span&gt; ht.Edge){&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 连线类型&lt;/span&gt;
&lt;span&gt;            propertyView.addProperties(edge_properties);
        }     
    });                
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据绑定在属性栏中也有体现，拿 data_properties 中的“标签”和“可编辑”作为演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    name: &lt;/span&gt;'name',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置了 name 属性，如果没有设置 accessType 则默认通过 get/setName 来获取和设置 name 值&lt;/span&gt;
    displayName: '名称',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于存取属性名的显示文本值，若为空则显示name属性值&lt;/span&gt;
    editable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置该属性是否可编辑                       &lt;/span&gt;
&lt;span&gt;}, 
{
    name: &lt;/span&gt;'2d.editable',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 结合 accessType，则通过 node.s('2d.editable') 获取和设置该属性&lt;/span&gt;
    accessType: 'style',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 操作存取属性类型&lt;/span&gt;
    displayName: '可编辑',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用于存取属性名的显示文本值，若为空则显示name属性值&lt;/span&gt;
    valueType: 'boolean',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 布尔类型，显示为勾选框&lt;/span&gt;
    editable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置该属性是否可编辑  &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两个属性比较有代表性，一个是直接通过 get/set 来设置 name 属性值，一个是通过结合属性的类型来控制 name 的属性值。只要在属性栏中操作“名称”和“可编辑”两个属性，就可以直接在拓扑图中看到对应的节点的显示情况，这就是数据绑定。当然，还可以对矢量图形进行局部的数据绑定，但不是本文的重点，有兴趣的可以参考我的这篇文章 &lt;a id=&quot;cb_post_title_url&quot; href=&quot;http://www.cnblogs.com/xhload3d/p/8620358.html&quot;&gt;WebGL 3D 电信机架实战之数据绑定&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;toolbar 工具栏&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201804/591709-20180410154352600-946308204.png&quot; alt=&quot;&quot; width=&quot;596&quot; height=&quot;29&quot;/&gt;&lt;/p&gt;
&lt;p&gt;差点忘记说这个部分了，toolbar 上总共有 8 种功能，分别是选中编辑、连线、直角连线、不规则图形、刻度尺显示、场景放大、场景缩小以及场景内容导出 json。这 8 种功能都是存储在 toolbar_config.js 文件中的，通过绘制 toolbar 中的元素给每一个元素都添加上了对应的点击触发的内容，主要讲讲 CreateEdgeInteractor.js 创建连线的内容。&lt;/p&gt;
&lt;p&gt;我们通过 ht.Default.def 自定义了 CreateEdgeInteractor 类，然后通过 graphView.setInteractors([ new CreateEdgeInteractor(graphView, 'points')]) 这种方式来添加 graphView 拓扑图中的交互器，可以实现创建连线的交互功能。&lt;/p&gt;
&lt;p&gt;在 CreateEdgeInteractor 类中通过监听 touchend 放手后事件向 graphView 拓扑图中添加一个 edge 连线，可以通过在 CreateEdgeInteractor 函数中传参来绘制不同的连线类型，比如 “ortho” 则为折线类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40.865793780687&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; CreateEdgeInteractor = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (graphView, type) {
    CreateEdgeInteractor.superClass.constructor.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, graphView);   
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._type =&lt;span&gt; type;
};
ht.Default.def(CreateEdgeInteractor, DNDInteractor, {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自定义类，继承 DNDInteractor，此交互器有一些基本的交互功能&lt;/span&gt;
    handleWindowTouchEnd: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.redraw();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isPoints = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._target){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; edge = &lt;span&gt;new&lt;/span&gt; ht.Edge(&lt;span&gt;this&lt;/span&gt;._source, &lt;span&gt;this&lt;/span&gt;._target);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一条连线，传入起始点和终点&lt;/span&gt;
&lt;span&gt;            edge.s({
                &lt;/span&gt;'edge.type': &lt;span&gt;this&lt;/span&gt;._type&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置连线类型 为传入的参数 &lt;a href=&quot;http://hightopo.com/guide/guide/plugin/edgetype/ht-edgetype-guide.html#ref_edgetype&quot; target=&quot;_blank&quot;&gt;type&lt;/a&gt; 类型&lt;/span&gt;
&lt;span&gt;            });
            isPoints &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;._type === 'points';&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有设置则默认为 points 连线方式&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isPoints){
                edge.s({
                    &lt;/span&gt;'edge.points': [{&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置连线的点&lt;/span&gt;
                         x: (&lt;span&gt;this&lt;/span&gt;._source.p().x + &lt;span&gt;this&lt;/span&gt;._target.p().x)/2,
                         y: (&lt;span&gt;this&lt;/span&gt;._source.p().y + &lt;span&gt;this&lt;/span&gt;._target.p().y)/2
&lt;span&gt;                    }]
                });                
            }
            edge.setParent(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._graphView.getCurrentSubGraph());&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置连线的父亲节点为当前子网&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;._graphView.getDataModel().add(edge);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将连线添加到拓扑图的数据容器中&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;._graphView.getSelectionModel().setSelection(edge);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置选中该节点                        &lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._graphView.removeTopPainter(&lt;span&gt;this&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除顶层Painter&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isPoints){
            resetDefault();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重置toolbar导航栏的状态&lt;/span&gt;
&lt;span&gt;        }        
    }            
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 一开始想说要做这个编辑器还有点怕怕的，感觉任务重，但是不上不行，所以总是在拖，但是后来整体分析下来，发现其实一步一步来就好，不要把步骤想得太复杂，什么事情都是从小堆到大的，以前我们用 svg 绘制的图形都可以在这上面绘制，当然，如果有需要拓展也完全 ok，毕竟别人写的编辑器不一定能够完全满足你的要求。这个编辑器虽说在画图上面跟别家无异，但是最重要的是它能够绘制出矢量图形，结合 HT 的数据绑定和动画，我们就可以对这些矢量图形中的每一个部分进行操作，比如灯的闪烁啊，比如人眨眼睛等等操作，至于这些都是后话了。有了这个编辑器我也能够更加快速地进行开发了~&lt;/p&gt;
</description>
<pubDate>Mon, 16 Apr 2018 23:03:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xhload3d/p/8861348.html</dc:identifier>
</item>
<item>
<title>90后小伙利用支付宝漏洞被抓， 我为什么拍手叫好？ - 陈树义</title>
<link>http://www.cnblogs.com/chanshuyi/p/how_to_report_bug.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chanshuyi/p/how_to_report_bug.html</guid>
<description>&lt;p&gt;大家可能对前阵子支付宝的「赚钱红包」活动略有印象，活动大概就是这样的：支付为每个用户生成一个专用二维码，别人扫你的二维码就可以获得一个红包。而当对方消费时，你也将获得一个等额红包。但扫到后来也就一两毛钱，许多人就觉得没啥意思。&lt;/p&gt;
&lt;p&gt;但前几天爆出一个新闻，说是浙江余姚一个 90 后小伙却发现了这个活动的一个漏洞，在短短两天之内，通过这个活动&lt;strong&gt;非法获得赏金 90 余万元&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;这个 90 后小伙陈某发现：在某个支付宝页面中输入任意一个手机号码，支付宝后台服务器便会误以为该用户扫描了陈某的二维码，只要该用户在使用支付宝时抵用了这个红包，陈某的支付宝账号便可以获得同等额度的赏金。&lt;/p&gt;
&lt;p&gt;于是陈某便写了一个脚本，通过穷举手机号码的方式，让自己的支付宝绑定了无数个手机号码，从而在两天之内获取了 90 余万元的赏金。&lt;/p&gt;
&lt;p&gt;当然支付宝也不是吃素的，支付宝通过人工核查发现某些数据出现了异常，而相关用户的IP地址在余姚，立刻向余姚市公安局报案。目前陈某该案件已经由公安机关已侦查完毕，并以破坏计算机信息系统罪，向余姚市人民检察院移送审查起诉。&lt;/p&gt;
&lt;p&gt;这个新闻出来之后，很多技术人员质疑支付宝，&lt;strong&gt;明明是支付宝活动出的问题，为什么陈某要承担法律责任呢？&lt;/strong&gt;甚至有人将这件事情与之前柜员机故障吐钱被抓联系在一起。&lt;/p&gt;
&lt;p&gt;但作为一个知法懂法的四有青年，我不仅不质疑，我还要拍手叫好！&lt;/p&gt;
&lt;p&gt;《中华人民共和国刑法》第二百八十六条对于「破坏计算机信息系统罪」的描述是这样的：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;破坏计算机信息系统罪是指违反国家规定，对计算机信息系统功能或计算机信息系统中存储、处理或者传输的数据和应用程序进行破坏，或者故意制作、传播计算机病毒等破坏性程序，影响计算机系统正常运行，后果严重的行为。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;联合这次事件，我们可以明显知道陈某对支付宝的计算机系统中存储的数据进行了「破坏」，干扰了计算机系统的正常运行，并且该行为是具有主观的恶意，为了&lt;strong&gt;非法牟利&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这次事件不禁让我想起了前几年的「世纪佳缘白帽子」事件。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;乌云漏洞平台的白帽子袁炜，在去年12月份向乌云提交了其发现的婚恋交友网站世纪佳缘的系统漏洞。在世纪佳缘确认、修复了漏洞并按乌云平台惯例向漏洞提交者致谢后，事情突然发生转折。世纪佳缘在一个多月后以「网站数据被非法窃取」为由报警。4月份，袁炜被司法机关逮捕。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为我们并不是当事人，所以对于具体的细节也不得而知。但从外传的部分资料我们应该可以大概得知，可能袁炜为了确认漏洞的真实性，获取了部分的数据。&lt;/p&gt;
&lt;p&gt;从上面提到的「破坏计算机信息系统罪」可以知道，在没有免责声明的情况下，如果你通过非法手段获取了数据或者修改了数据，那么就存在对应的法律风险。&lt;/p&gt;
&lt;p&gt;其实现在很多互联网厂商已经很重视系统安全，还专门开设了相应的漏洞提交平台。例如阿里巴巴的漏洞提交平台：&lt;a href=&quot;https://security.alibaba.com/&quot;&gt;阿里安全响应中心&lt;/a&gt;。通过该平台你能提交发现的漏洞，并能获取响应的金币奖励。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3npq6ecr.bkt.clouddn.com/blog/how_to_report_bug_03.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而腾讯也有响应的漏洞提交平台：&lt;a href=&quot;https://security.tencent.com/index.php&quot;&gt;腾讯安全应急响应中心&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p3npq6ecr.bkt.clouddn.com/blog/how_to_report_bug_04.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作为一个技术工作者，接二连三的事件告诉我们：&lt;strong&gt;不懂法并不能成为技术无罪的挡箭牌。&lt;/strong&gt;我们在做相应的操作之前，一定要了解相关的法律法规，这样才不会让自己处于不利位置。&lt;/p&gt;
&lt;p&gt;而作为一个技术工作者，我们应当掌握专业的漏洞处理姿势，而不是用来牟利。所以下次如果你发现漏洞了，&lt;strong&gt;请控制自己的贪欲，果断向官方提交漏洞！&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 16 Apr 2018 17:45:00 +0000</pubDate>
<dc:creator>陈树义</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chanshuyi/p/how_to_report_bug.html</dc:identifier>
</item>
<item>
<title>我们真的会使用单例模式吗？ - baidixing</title>
<link>http://www.cnblogs.com/jiagoushi/p/8859746.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiagoushi/p/8859746.html</guid>
<description>&lt;p&gt;这篇博客的标题用了一个疑问句，源于我们公司的代码评审，深刻的讨论了单例模式的使用场景及其与静态方法来说有何不同，这次讨论确实让我真正的理解了单例模式的使用，虽然说理解还一定全面，但必须作为一个认知的提升。告诉了我自己，对于编程，不懂的太多，原理性的东西还需要持续的学习。&lt;/p&gt;
&lt;p&gt;进入正文，我们来讨论一下，什么是单例模式，何时使用单例模式？&lt;/p&gt;
&lt;p&gt;单例模式是经典设计模式的一种，熟悉设计模式或者说读过设计模式相关书籍的同事都知道，这应该算是设计模式中最简单、最容易理解、使用最广泛的一种。单例模式主要是用来实现一个类的实例全局唯一，使用double check的形式来定义。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SingleInstance
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; _lock = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SingleInstance _instance = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 私有构造函数
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; SingleInstance() { }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 单一实例
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; SingleInstance GetInstance()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (_instance == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;lock&lt;/span&gt;&lt;span&gt; (_lock)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (_instance == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                         _instance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SingleInstance();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _instance;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show()
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输出。。。郭志奇&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Speak()
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;说话。。。郭志奇&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
单例模式使用了私有构造函数来保证外部无法实例化、使用double check来保证实例被唯一创建。这是一个基本的单例模式写法，我一般会在其中写一些方法来进行调用，主要是为了避免每次调用都需要new的麻烦。但其中存在一些问题，如果采用静态方法来写：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输出。。。郭志奇&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Speak()
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;说话。。。郭志奇&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;比较这两种调用，其实使用方式是一致的，但单例模式会在程序运行中一直存在，不会被销毁，因为单例模式中使用到了静态变量，静态变量的使用会导致实例不会被销毁。但这也不应该是单例模式的缺点。&lt;/p&gt;
&lt;p&gt;但我为什么会说我们真的懂单例模式？&lt;/p&gt;
&lt;p&gt;回到开头，我们说单例模式，为什么我们需要单例模式，绝对不是因为方便调用，因为静态方法更方便。那到底为什么使用单例模式呢？其实经过我们的讨论，单例模式的使用场景是一些全局不可变参数，可以放到单例中，比如从配置获取值，然后缓存到单例中，这才是我们应当使用单例的场景，千万别像我，为了使用方便而无节制的使用单例。&lt;/p&gt;
&lt;p&gt;使用单例，方便调用，但会造成什么问题呢？&lt;/p&gt;
&lt;p&gt;要回答这个问题，我们首先回忆一下GC的垃圾回收机制，垃圾回收分为三代，如果类中包含静态成员，垃圾回收机制是不会回收的，也就意味着如果我们无节制的使用单例，会造成程序运行过程中出现大量的实例不会被销毁，会无意识的造成内存使用增高。    如果采用懒加载的方式，在单例未被调用的时候，不会实例化，如果采用饿汉加载的话，那么在程序初始化的时候，就会被初始化，无疑会加重程序的初始化成本，增加启动时间。&lt;/p&gt;
&lt;p&gt;如果我们仅仅是为了方便调用，可以使用静态方法。&lt;/p&gt;
&lt;p&gt;上面我们说了懒加载方式，我们来代码说明一下饿汉模式的加载方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SingleInstance
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; _lock = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; SingleInstance _instance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SingleInstance();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 私有构造函数
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; SingleInstance() { }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 单一实例
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; SingleInstance GetInstance()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        {            
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _instance;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show()
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输出。。。郭志奇&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Speak()
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;说话。。。郭志奇&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;饿汉模式的加载就是静态成员在定义的时候即初始化。&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;1、我们应该选择合适的时机使用单例模式，不要无节制的使用，应该明白何时才应该使用单例模式。&lt;/p&gt;
&lt;p&gt;2、尽量避免静态成员的使用，因为静态成员所在的实例，不会被GC回收。&lt;/p&gt;
&lt;p&gt;3、优先选择静态方法调用而不是单例模式调用。&lt;/p&gt;
&lt;p&gt;4、如果必须使用单例模式，尽量采用懒加载，而不是饿汉加载的方式，减少程序启动成本。&lt;/p&gt;
&lt;p&gt;引申：&lt;/p&gt;
&lt;p&gt;1、我们使用了lock(object)来锁定一个变量，达到加锁的目的，避免多个线程同时对实例执行初始化。那么如果我们lock(string 字符串类型)是否可以呢？答案是否定。&lt;/p&gt;
&lt;p&gt;2、System.String和string有什么不同呢？&lt;/p&gt;
&lt;p&gt;欢迎有不同见解的同事可以回复讨论，知识总是在讨论中得到升华。&lt;/p&gt;

</description>
<pubDate>Mon, 16 Apr 2018 16:13:00 +0000</pubDate>
<dc:creator>baidixing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiagoushi/p/8859746.html</dc:identifier>
</item>
<item>
<title>Python中的上下文管理器和with语句 - Yabea</title>
<link>http://www.cnblogs.com/ybjourney/p/8859519.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ybjourney/p/8859519.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Python2.5之后引入了上下文管理器（context manager），算是Python的黑魔法之一，它用于规定某个对象的使用范围。本文是针对于该功能的思考总结。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;为什么需要上下文管理器&quot;&gt;为什么需要上下文管理器？&lt;/h2&gt;
&lt;p&gt;首先，需要思索下为什么需要引入上下文管理器。&lt;br/&gt;在正常情况下，管理各种系统资源（如文件）、数据库连接时，通常是先打开这些资源，执行完相应的业务逻辑，最后关闭资源。&lt;br/&gt;举两个例子:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用Python打开一个文件写入内容，之后需要关闭这个文件。如果不正常关闭的话可能会在文件操作时出现异常，因为系统允许你打开的文件的最大数是有限的。&lt;/li&gt;
&lt;li&gt;在数据库连接时也是存在类似问题，数据库的连接算是一种比较昂贵的资源，若连接过多而没有及时关闭的话，就可能出现不能继续连接的异常错误。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是，很多程序员经常会忘记关闭文件，或者关闭数据库的连接。这时候就引入了&lt;strong&gt;上下文管理器&lt;/strong&gt;，它可以在你不需要该对象的时候，自动关闭它。&lt;/p&gt;
&lt;h2 id=&quot;上下文管理器怎么使用&quot;&gt;上下文管理器怎么使用？&lt;/h2&gt;
&lt;p&gt;上下文管理器的语法是：with...as...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例：文件操作&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print &quot;不使用上下文管理器&quot;
print &quot;*&quot; * 30
f = open('file.py', 'w')
print f.closed
f.write(&quot;# Hello World&quot;)
f.close()
print f.closed

print &quot;\n使用上下文管理器&quot;
print &quot;*&quot; * 30
with open(&quot;file.py&quot;, 'w') as f:
    print f.closed
    f.write('# Hello Python')
print f.closed&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里通过.closed比较，我们可以看到上下文管理器可以自动关闭文件，对于上下文管理器而言，有隶属于它的程序块，当隶属于它的程序块执行结束的时候（判断缩进），上下文管理器将自动关闭文件。&lt;br/&gt;上述实例，也可以使用try...except...来实现，同样可以很直观的看到使用with...as...语句之后，代码确实相对更加简洁。&lt;/p&gt;
&lt;h2 id=&quot;上下文管理实现机制&quot;&gt;上下文管理实现机制&lt;/h2&gt;
&lt;p&gt;因为文件对象是Python的内置对象，内置了上下文管理的特殊方法，所以它可以使用with语句。在Python中，任何对象，只要实现了上下文管理，就可以使用with语句，实现上下文管理需要通过__enter__和__exit__这两个方法来实现。&lt;br/&gt;&lt;strong&gt;关于这两个方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;enter&lt;/strong&gt;(self)：进入该对象时调用此方法，返回值将放入with...as...语句中的as说明的变量中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;exit&lt;/strong&gt;(self, type, value, tb):离开上下文管理器时调用该方法，如果有异常出现，返回False，type、value和tb将分别表示异常的类型、值和追踪信息，传递出上下文显示；如果没有异常，则三个变量的值均为None。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;with 上下文管理器：
    语法体&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当with语句遇到上下文管理器时，就会在执行语法体之前，先执行__enter__方法，然后再执行语法体，执行完语法体之后，执行__exit__方法。&lt;/p&gt;
&lt;h2 id=&quot;上下文管理器实现&quot;&gt;上下文管理器实现&lt;/h2&gt;
&lt;p&gt;使用Python2.7X实现一个上下文管理器:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Context(object):

    def __init__(self):
        print &quot;实例化一个对象&quot;

    def __enter__(self):
        print &quot;获取该对象&quot;

    def __exit__(self, exc_type, exc_val, exc_tb):
        print &quot;退出该对象&quot;

temp = Context()

with temp:
    print &quot;执行体&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，__enter__方法和__exit__方法的调用过程就很明晰。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;contextLib&lt;/strong&gt;&lt;br/&gt;在contextlib中，提供了contextmanager装饰器，通过yield返回函数将函数分隔为两部分，yield之前的语句在__enter__中执行，yield之后的语句在__exit__中执行，简化了上下文管理器的实现方式：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;通过上下文管理器，我们可以更好的控制对象在不同区间的特性，并且可以使用with语句替代try...except方法，使得代码更加的简洁，主要的使用场景是访问资源，可以保证不管过程中是否发生错误或者异常都会执行相应的清理操作，释放出访问的资源。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 16 Apr 2018 16:06:00 +0000</pubDate>
<dc:creator>Yabea</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ybjourney/p/8859519.html</dc:identifier>
</item>
<item>
<title>WebGL文字渲染的那些问题 - 木的树</title>
<link>http://www.cnblogs.com/dojo-lzz/p/8848165.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dojo-lzz/p/8848165.html</guid>
<description>&lt;p&gt;　　THREE.js&lt;span&gt;开发的应用运行在&lt;/span&gt;&lt;span&gt;iphone5&lt;/span&gt;&lt;span&gt;下发现有些时候会崩溃，跟了几天发现是因为&lt;/span&gt;&lt;span&gt;Sprite&lt;/span&gt;&lt;span&gt;太多频繁更新纹理占用显存导致的。通常解决纹理频繁更新问题就要用到&lt;/span&gt;&lt;span&gt;one draw all&lt;/span&gt;&lt;span&gt;方法，放到纹理上就是把所有纹理图片生成一张大图片的方式&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;一、阻止纹理重复上传&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　我们需要一张大纹理，先将所有的内容绘制在大纹理上，需要显示局部纹理的时候通过纹理坐标控制去大纹理上取图像。那么这个时候问题来了，&lt;/span&gt;THREE.js&lt;span&gt;内部实现方式是将&lt;/span&gt;&lt;span&gt;Texture&lt;/span&gt;&lt;span&gt;与图片、纹理坐标绑定，即使为所有的&lt;/span&gt;&lt;span&gt;Texture&lt;/span&gt;&lt;span&gt;对象设置同一张图片，&lt;/span&gt;&lt;span&gt;THREE.js&lt;/span&gt;&lt;span&gt;仍然会将每个&lt;/span&gt;&lt;span&gt;Texture&lt;/span&gt;&lt;span&gt;中的图片上传给&lt;/span&gt;&lt;span&gt;GPU&lt;/span&gt;&lt;span&gt;。每次上传一张大纹理严重阻塞&lt;/span&gt;&lt;span&gt;UI&lt;/span&gt;&lt;span&gt;渲染进程。&lt;/span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415164428692-1897817285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415164511645-695284025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先要解决的是让这张大纹理值上传一次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个问题需要我们对&lt;/span&gt;THREE.js&lt;span&gt;源码进行深入了解，可以看到&lt;/span&gt;&lt;span&gt;setTexture2D&lt;/span&gt;&lt;span&gt;函数中有一个&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;变量，这个变量是一个&lt;/span&gt;&lt;span&gt;WebGLProperties&lt;/span&gt;&lt;span&gt;类型的变量，而该类型存储各种东西：&lt;/span&gt;&lt;span&gt;Texture&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Material&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;RenderTarget&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;buffers&lt;/span&gt;&lt;span&gt;等。我们继续深入该类的源码，发现&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;方法会根据对象的&lt;/span&gt;&lt;span&gt;uuid&lt;/span&gt;&lt;span&gt;来获取相关&lt;/span&gt;&lt;span&gt;WebGL&lt;/span&gt;&lt;span&gt;属性，比如&lt;/span&gt;&lt;span&gt;gl.createTexture&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;gl.createBuffer&lt;/span&gt;&lt;span&gt;创建的各种缓冲区。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415164645915-1456517294.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　对应Texture得到的webgl属性如下，其中__webglTexture就是对应的纹理图片创建的缓冲区对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415165012119-878936550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么我们可以来一个取巧的方法，将所有纹理的的uuid都设置唯一，那么THREE.js只会对第一个Texture的纹理进行上传，后面的texture对象取到的都是第一个的properties，这样就能避免纹理重复上传。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415165040425-876625604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 二、建立纹理索引&lt;/h2&gt;
&lt;p&gt;　　我们需要自己维护一套索引关系，通过这套索引关系得到每个贴图在大纹理中纹理坐标。这里要为每一个poi记录它的起始位置和区域范围，其中要用到canvasContext.measureText来测量文本的宽度，文本高度可以直接根据fontSize取得。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415165150645-599210757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　同时索引建立完毕后，需要计算每个poi区域在全局纹理中的纹理坐标范围：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415165224312-512916516.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　要注意的是，这里纹理坐标的原点在左下方，有时候原点在左上方。建立索引代码如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415165251867-131801634.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、局部更新&lt;/h2&gt;
&lt;p&gt;　　上述方案虽然能够避免频繁上传纹理，但是需要每次将需要绘制的内容准备好，当有内容需要更新时，还是需要重新上传整个全局纹理，反而使得性能下降巨大。经过查阅资料后发现webgl中有一种局部纹理更新技术，简单来说先在内存中开辟一块的纹理区域，将所有内容绘制在这张全局纹理中，每次有更新时，只需要更新它的一个局部区域即可。&lt;br/&gt;　　但是这里要解决的问题是THREE.js并没有提供局部纹理更新的方式，也没有相应的自定义接口，那么这时候就需要我们自己来处理了。&lt;br/&gt;　　这里自定义一个Texture的子类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415165444062-323778640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　开辟一块内存区域&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415165523607-64728806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在需要的时候动态更新局部纹理，其中src这里是ImageData对象&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415165549245-1206188507.png&quot; alt=&quot;&quot;/&gt;　&lt;/p&gt;
&lt;p&gt;　　具体代码可以参考这里，我这里也是基于它来定制的。&lt;br/&gt;　　&lt;a href=&quot;https://github.com/spite/THREE.UpdatableTexture&quot; target=&quot;_blank&quot;&gt;https://github.com/spite/THREE.UpdatableTexture&lt;/a&gt;&lt;br/&gt;　　原文作者通过更改THREE.js源码的方式实现，而我是直接把下面这个函数拷贝到这个子类中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415165642415-1254475695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、高清屏的大坑&lt;/h2&gt;
&lt;p&gt;　　现在我们的方案是，先在gpu中开辟一块全局纹理区域，然后绘制时将poi绘制到一张与全局纹理同样大小的canvas上，然后从canvas中调用createImageData来获取像素，将像素局部更新到gpu中。那么在pc上我们得到的结果很完美。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415165739005-2143793067.png&quot; alt=&quot;&quot;/&gt;   然而放到移动端上后，我们得到的结果是：&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415165821459-884032443.png&quot; alt=&quot;&quot;/&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415165839468-126013631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　TMMD中间那块哪去了！找了大半天发现问题出现在高清屏上，挡在高清屏上绘制canvas上时，我们通常会做一些高清处理，比如四像素绘制一像素。&lt;br/&gt;　　我们做高清处理的方式是利用radio*radio设备像素绘制一css像素，看起来是css像素的大小，但实际在浏览器内部，看起来css上一像素实际在canvas里的像素是radio * radio（radio代表window.devicePixelRatio）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415165935487-2109980437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　但实际上在浏览器内部绘制canvas图像的单位是设备像素。那么如果我们还以上面的rectW、rectH来获取像素的话，我们得到的这部分像素并不是这个poi真正占有的像素数目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415170010092-778215253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　所以，问题就来了我们需要在gpu开辟的全局纹理的单位跟canvas中获取像素的单位要保持一致，我们统一使用设备像素。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415170144600-988680712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　我们对canvas也不用使用style来设置样式宽高了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415170217853-699733073.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　那么获取poi图像的真正像素范围时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415170253560-1407820344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　所以利用getImageData取像素时候，就要小心取到真正的像素区域，（startX * radio，startY * radio）- （poiRectW * radio, poiRectH * radio）;否则某些像素就会被丢弃掉，这部分像素才是浏览器真正使用的设备像素。&lt;/p&gt;
&lt;p&gt; 　　现在在移动设备上能够获取正确的高清label啦！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415170334602-893293216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五、局部更新引起的新问题&lt;/h2&gt;
&lt;p&gt; 　　当全局纹理被占满时候，在继续绘制poi，这时候新的poi区域需要更新到gpu中，那么也就带来了新的问题，在gpu中的纹理还保持着之前的像素，而新的poi会覆盖这部分区域，但有时候往往会与之前的文字叠加起来，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415170517257-2074971873.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到新更新的poi，在计算纹理坐标时候，有一部分像素包含了其他poi的像素。这个问题是因为新poi的区域刚好叠在了先前poi的边界上，那么我们只要给新的poi加一点buffer，这个buffer是白素透明区域，buffer会把之前的poi像素覆盖掉，而我们计算纹理坐标时，只取poi的边界，那么就可以解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415170550970-185027957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么首先绘制的时候就要保留buffer&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415170656220-1866838080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上传的时候使用buffer&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415170731396-301262068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　计算纹理坐标时，排除buffer&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415170802897-683579414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;六、局部更新带来的性能问题&lt;/h2&gt;
&lt;p&gt;　　根据目前的结果，局部更新能后解决crash的问题，但是带来了严重的性能开销，与同事应用局部更新提升性能的结果相反。这个问题还要继续跟踪。&lt;br/&gt;　　目前发现问题是因为使用了getImageData来获取数据，然后传递到gpu中，非ios设备用这种方式有时候getImageData的开销特别大，而ios设备相对好一些。&lt;br/&gt;　　测试发现非ios设备直接上传一张大纹理的效果反而比getImageData这种方式更好。但是依然不如之前上传多个canvas的性能。而在iphone5的测试机和iphone6的机器上性能比之前直接上传多个canvas的方式好一些，且没有崩溃问题。但是在岳阳的iphone6 plus 16g内存的手机上发现用具局部纹理更新性能很差，而且经常崩溃。&lt;br/&gt;　　后来发现原因是因为，虽然getImageData在IOS上性能好过非IOS设备，但性能开销仍然比较大，所以当场景中POI很多时，仍然会引起主线程卡顿，甚至计算太密集引起浏览器崩溃。其中层尝试使用cesium方式，每个poi创建新的canvas，将canvas进行局部上传，本以为这种方式不需要getImageData会更快一些，然而实践发现每次创建canvas设置参数的过程更耗时。&lt;/p&gt;
&lt;p&gt;　　最终的方案是仍然使用getImageData，但是将getImageData的过程分块处理，每50ms处理一次，分块放到场景中，这样就解决密集计算引起的崩溃问题，虽然增加了控制成本，但是能够有效解决IOS崩溃问题。有趣的是在安卓上getImageData方式开销很大，即使分块也不适合，而且安卓用一张大纹理的方式来处理，会发现很多POI绘制效果不好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415171031941-1071366663.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最终方案是，IOS使用getImageData局部纹理+分块加载方式绘制POI。安卓使用POI独立创建canvas+全量加载方式。（安卓不适用分块加载，是为了尽快把所有POI呈现给用户）&lt;/p&gt;
&lt;h2&gt;七、文字黑色描边问题&lt;/h2&gt;
&lt;p&gt; 　　这个问题自始至终困扰我好久一直没找到黑边的原因；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415171209423-287766026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将原始的canvas导出后发现这是因为原始的canvas就有一层边界&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415171312640-1221527306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　曾经怀疑是minFilter的设置不对在pc端纹理使用NEARESTFilter方式取值发现的确能够消除黑边，然而移动端仍然会出现黑边，最后使用颜色混合公式解决问题。&lt;/p&gt;
&lt;p&gt;　　gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);&lt;br/&gt;　　在Three.js中需要设置SpriteMaterial的blending为CustomBlending&lt;/p&gt;
&lt;h2&gt;八、颜色混合新问题&lt;/h2&gt;
&lt;p&gt; 　　但是使用上述方式同样引来新问题，设计反映poi的icon四周被裁切掉，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415171427276-342286090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　看着没问题是吧，设计同学截了图之后放大了20倍。。。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415171455625-1836055737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　刚开始我确实以为这是webgl渲染问题，后来仔细考虑了下这外圈白色的由来（遇到问题还是得静下心分析）。&lt;/p&gt;
&lt;p&gt;　　原因是设置了blendFunc（SrcAlphaFactor，OneMinusSrcAlphaFactor）导致有些icon周围的像素alpha比较低&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415171527829-543612756.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　颜色混合后增加了target的颜色分量，导致最终这些区域的颜色范围接近255，所以泛白。从而把原来图片四周有切边的问题充分暴露出&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　解决方法是设置alphaTest，如果原始纹理的alpha小于这个值则直接discard。最终得到的效果是：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415171606175-543893576.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415171629227-2102359647.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415171643774-701926621.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt; 九、TextureAlta问题&lt;/h2&gt;
&lt;p&gt; 　　前面因为sprite的旋转中心只能放在sprite纹理区域的中心所以，上面做了很多冗余纹理，有很多空白区域，目前改造了Sprite加了pivot可以动态改变选中中心点，改变后IOS下纹理的使用率提升了60%，安卓下因为是单个纹理上传所以，需要保证纹理的大小是2的n次方，纹理的浪费率降低了50%&lt;/p&gt;
&lt;p&gt;　　上述问题虽然解决了崩溃问题，但是实际使用中每个poi都要getImageData和texSubImage2D这个方法，造成单个poi耗时基本在25ms（iphone5 8.4.4）;虽然上面使用setTimeout 50ms分块方式上传，但是如果poi过多比如1000多的停车场，这样会导致停车场数据需要50s才能完全显示出来。这次优化的方案是等待所有poi图片拿到后，绘制所有的poi把画布调用一次getImageData和一次texSubImage2D上传到gpu，同时下次更新时，只会增量一次性上传更新。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415171850638-1591079736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;十、Frstrum增量更新&lt;/h2&gt;
&lt;p&gt;　　原来是在每一级别缩放时把所有的poi都生成好，现在的做法是只生成视锥体中能看得到的poi，然后在每次OrbitControl出发change事件时根据视锥体判断poi，做去重后增量更新&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415171947563-1635120255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　目前还是有些问题，有时候会碰到视锥体中的poi很少，可能是判断问题，后续会加入空间索引，根据索引和视锥体结合起来做增量更新&lt;/p&gt;
&lt;p&gt;　　后续使用发现在停车场这种大数据的poi全部加载到地图下，使用这种方式每次都要做去重处理，性能开销很大，处理方式是使用{}做hash代替数组includes方法，结果发现性能提示很大，原来3600个节点每次去重处理在iphone 16g 10.3.3上性能基本在28帧每秒，经过优化后数据帧率达到50+（主流iPhone7fps60）；iphone5 16g 8.4.1 性能在24左右优化后帧率在44+，安卓华为荣耀9优化前25帧，优化后 40+&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415172052790-55401326.png&quot; alt=&quot;&quot;/&gt;安卓之所以不适用IOS的绘制方式，是因为这种在安卓上的绘制效果不理想，被设计挑战&lt;/p&gt;
&lt;p&gt;　　安卓后面也做了一些优化，之前安卓是每次都会重新创建canvas并上传至gpu纹理中，导致使用视景体增量更新poi时，性能有所下降，后来每一层中的poi都根据icon、文字组成key缓存起来，并且缓存纹理，不但阻止canvas的重复创建，还阻止canvas重复上传至gpu纹理（three中使用同一uuid），使用该方案荣耀9的fps达到50+&lt;/p&gt;
&lt;h2&gt;十一、text glyphs&lt;/h2&gt;
&lt;p&gt;该方式还有待尝试&lt;br/&gt;&lt;a href=&quot;https://webglfundamentals.org/webgl/lessons/webgl-text-glyphs.html&quot; target=&quot;_blank&quot;&gt;https://webglfundamentals.org/webgl/lessons/webgl-text-glyphs.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;十二、真正解决POI文字黑边问题&lt;/h2&gt;
&lt;p&gt;　　由于要做poi渐变出现效果，但是因为之前处理黑边问题用的是颜色混合的方式，所以当动态改变透明度时，受颜色混合影响往往是文字颜色先消失，剩下透明度部分还存在显示先过很差。所以要实现渐变效果，不能使用颜色混合方法，但不适用颜色混合就会有黑边问题，所以要从源头上解决黑边问题。（看到最后会发现有残影）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415173156697-1292511315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么思考黑边到底是怎么产生的，这与webgl中纹理插值的颜色有关，有的设备像素取纹理时有不同的方案，但一般情况下纹理像素和设备像素都不是一一对应，所以有插值取值问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415172323246-952991436.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这是正常情况下利用canvas绘图时背景颜色不设置，那么可以看到我们绘制出来的canvas的确有一层奇怪的黑边。当设备取到纹理中这些边界时就会产生黑边。那么就要思考怎么不让它取到这层黑边，这个问题想了好久曾经试过用opacity过滤，发现不能解决问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415172403118-1412762536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　有一天突然想到如果canvas背景为有颜色，每个设备像素都能取到颜色，那么就不会有这个问题。所以我们能否通过改一下canvas的背景颜色同时有通过透明度过滤掉不合格的像素？最终发现这个问题还真可以。&lt;br/&gt;　　首先在绘制时将canvas背景设置为白色，但是有很低的透明度&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415172436334-149880939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候canvas绘制出来的效果是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/412020/201804/412020-20180415172505768-1777528421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到已经没有黑边了，那么这时候设备像素永远不会取到黑色边界，也就彻底解决了黑边问题。&lt;br/&gt;　　那么就可以利用tween来做动画了&lt;/p&gt;

</description>
<pubDate>Mon, 16 Apr 2018 16:04:00 +0000</pubDate>
<dc:creator>木的树</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dojo-lzz/p/8848165.html</dc:identifier>
</item>
<item>
<title>linux下nginx负载均衡搭建 - 苏永民</title>
<link>http://www.cnblogs.com/be-top/p/8859338.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/be-top/p/8859338.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;【一、Nginx能做什么】&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　1、http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。&lt;/p&gt;
&lt;p&gt;       2、虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网路使用的虚拟主机。&lt;/p&gt;
&lt;p&gt;　　3、反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器&lt;/p&gt;
&lt;p&gt;4、解决跨域问题。&lt;/p&gt;
&lt;h2&gt;【二、安装】&lt;/h2&gt;
&lt;p&gt;1、yum install nginx，提示No package nginx available。因为nginx位于第三方的yum源里面，而不在centos官方yum源里面，所以先yum &lt;span&gt;install&lt;/span&gt; &lt;code class=&quot;bash plain&quot;&gt;epel-release，待epel安装完后，再yum install nginx&lt;code class=&quot;bash plain&quot;&gt;&lt;br/&gt;&lt;/code&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、service nginx start 启动nginx，在浏览器输入ip地址即可访问nginx的界面，如果访问不了，查看防火墙的访问状态，增加80端口访问&lt;/p&gt;
&lt;h2&gt;【三、负载均衡配置】&lt;/h2&gt;
&lt;p&gt;nginx启动之后，我们需要根据需要修改配置文件，可以先使用 ps-ef|grep nginx查看当前使用的配置文件。&lt;/p&gt;
&lt;p&gt;在http模块中添加如下配置&lt;/p&gt;
&lt;pre&gt;
  upstream servers {
      server 192.168.80.1:8010 weight=10;
      server 192.168.80.10:8010 weight=10; &lt;br/&gt;}
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;把server改为&lt;/span&gt;&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;      server {&lt;/em&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;em id=&quot;__mceDel&quot;&gt;        listen       80;
        server_name  test.nginx.com;
        
        location / {
            proxy_pass   http://servers;
        }

        location /buy {
            proxy_pass   http://172.18.144.23:5789/;
        }            

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }&lt;/em&gt;最后重启service nginx reload&lt;p&gt;另外要切记开放防火墙访问端口才可以正常访问的
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 16 Apr 2018 15:55:00 +0000</pubDate>
<dc:creator>苏永民</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/be-top/p/8859338.html</dc:identifier>
</item>
<item>
<title>Vue-cropper 图片裁剪的基本原理 - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/8859291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/8859291.html</guid>
<description>&lt;p&gt;Vue-cropper 图片裁剪的基本原理&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一：裁剪的思路：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1-1，裁剪区域：&lt;/strong&gt;&lt;br/&gt;需要进行裁剪首先需要形成裁剪区域，裁剪区域的大小和我们的鼠标移动的距离相关联，鼠标移动有多远，裁剪区域就有多大。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416225940879-2013828147.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1-2 裁剪区域的宽和高的计算：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如上图，鼠标的横向移动距离和纵向移动距离就形成了裁剪区域的宽和高。那么裁剪区域的宽和高的计算是：当我们点下鼠标时，就能够通过event事件&lt;br/&gt;对象获取鼠标点击位置，e.clientX 和 e.clientY; 当鼠标进行移动的时候，也能通过event获取鼠标的位置，通过两次鼠标位置的改变，就能够获得&lt;br/&gt;鼠标移动的距离。即：初始的x轴位置为 initX = e.clientX, initY = e.clientY;&lt;br/&gt;移动到某个点的位置为：endX = e.clientX, endY = e.clientY;&lt;br/&gt;因此裁剪区域的宽 Tx = endX - initX;&lt;br/&gt;裁剪区域的高是 Ty = endY - initY;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1-3 阴影区域的形成&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;被我们裁剪图片中除了裁剪区域以外的部分，都属于阴影部分。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416230100194-182494825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么阴影区域要如何计算呢？比如左阴影宽，左阴影宽 = 裁剪区域的左偏移值 - 图片本身的左偏移值；那么上阴影高 = 裁剪区域的上偏移值 - 图片上偏移值, 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416230136296-738639731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么下阴影的高度 = 图片本身的高度 - 上阴影的高度 - 裁剪区域的高度；那么右阴影的宽度 = 图片的宽度 - 左阴影宽 - 裁剪区域的宽。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1-4 理解裁剪区域被越界&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;裁剪图片过程中会出现越界的情况，那么越界又需要分为2种情况，&lt;strong&gt;第一种是：裁剪过程中的越界，第二种是 移动裁剪区域的越界。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1-4-1 裁剪越界&lt;/strong&gt;&lt;br/&gt;什么是裁剪时越界？ 就是当我们使用鼠标拖动区域裁剪超出了图片的宽度和高度，形成了的越界；如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416230235688-355640298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于这种越界需要判断被裁剪区域的右侧相对于浏览器左侧的位置，不能超过图片右侧的位置相对于浏览器左侧的位置；&lt;br/&gt;且 被裁剪区域的底部相对于浏览器顶部的位置 不能超过 图片的底部相对于浏览器顶部的位置，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416230257263-1489874525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1-4-2 移动越界&lt;/strong&gt;&lt;br/&gt;移动越界指已经形成了裁剪区域了，但是我们可以通过鼠标裁剪区域时产生了越界。其实判断原理和裁剪越界的原理一样的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 图片如何进行压缩？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当图片的宽度大于容器的宽度，就需要进行压缩；因此 var scale = 容器的宽度 / 图片的宽度；&lt;br/&gt;如果图片的高度 * 缩放比例 &amp;gt; 容器的高度，那么缩放比例 scale = 容器的高度 / 图片的高度；否则的话，不进行压缩。&lt;br/&gt;&lt;strong&gt;2-1：对于压缩后 translate3d中的X轴和Y轴移动位置计算方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;x = 容器的宽度 / 压缩比&lt;br/&gt;y = 容器的高度 / 压缩比&lt;br/&gt;即：transform: translate3d(x, y, z) -&amp;gt; translate3d(容器的宽度 / 压缩比 + 'px', 容器的高度 / 压缩比 + 'px', 0)&lt;/p&gt;
&lt;p&gt;因此页面布局变成如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;图片裁剪&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;./index.css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;height:500px;margin: 0 auto;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;vue-cropper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;cropper-box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;cropper-box-canvas&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;width:644px;height:642px;transform: scale(0.778816, 0.778816) translate3d(453.252px, -87.312px, 0px) rotateZ(0deg)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416230443389-1451524334.jp&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;cropper-drag-box cropper-crop&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 裁剪的过程中，如何计算裁剪的宽度和高度？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当我们点下鼠标时，就能够通过event事件对象获取鼠标点击位置，e.clientX 和 e.clientY; 当鼠标进行移动的时候，也能通过event获取鼠标的位置，&lt;br/&gt;通过两次鼠标位置的改变，就能够获得鼠标移动的距离。即：&lt;br/&gt;初始的x轴和Y轴位置分别为 cropX = e.clientX, cropY = e.clientY;&lt;br/&gt;移动后现在的X轴和Y轴的位置分别为：nowX = e.clientX, nowY = e.clientY;&lt;br/&gt;因此裁剪区域的临时值 var fw = ~~(nowX - cropX);&lt;br/&gt;裁剪区域的临时值是 fh = ~~(nowY - cropY);&lt;/p&gt;
&lt;p&gt;裁剪图片的时候，有可能往右拖动(值会越来越大)，也有可能往相反的方向(向左)拖动(值会越来越小)，同理，向上或向下拖动也是同一个道理。因此需要判断 fw 和 fh是否大于0的判断；在鼠标按键下去的时候，先获取鼠标相对于事件源元素的X和Y轴坐标，e.offsetX 和 e.offsetY;&lt;br/&gt;因此 cropChangeX = e.offsetX; cropChangeY = e.offsetY;&lt;br/&gt;对于offsetX 和 offsetY 的理解如下；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416230711864-782000121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;if (fw &amp;gt; 0) {&lt;br/&gt;   var cropW(裁剪区域的实际宽度) = cropChangeX + fw &amp;gt; w(图片的实际宽度) ? w - cropChangeX : fw;&lt;br/&gt;   cropOffsertX = cropChangeX;&lt;br/&gt;}&lt;br/&gt;cropOffsertX 就是保存事件源相对于元素的距离。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416230748352-2040647259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果fw 小于0，说明是往左裁剪，那么裁剪的距离 fw = (事件结束的clientX - 事件的开始clientX);&lt;br/&gt;如果 (图片的实际宽度 - e.offsetX) + Math.abs(fw) &amp;gt; 图片的实际宽度 ? this.cropChangeX : Math.abs(fw);&lt;br/&gt;即：&lt;/p&gt;
&lt;p&gt;if (fw &amp;lt; 0) {&lt;br/&gt;   var cropW(裁剪区域的实际宽度) = (w - cropChangeX) + Math.abs(fw) &amp;gt; w ? cropChangeX : Math.abs(fw);&lt;br/&gt;   cropOffsertX = cropChangeX + fw &amp;gt; 0 ? cropChangeX + fw : 0;&lt;br/&gt;}&lt;br/&gt;说明往左裁剪的最大宽度只能是 e.offsetX; 不能超过该值，否则的话，就会越界。&lt;br/&gt;此时cropOffsertX偏移值改变了； cropOffsertX = cropChangeX + fw &amp;gt; 0 ? cropChangeX + fw : 0; 如图下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416230845377-452075553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面分析的是 宽和高不固定比例的裁剪，下面我们来看下 宽和高固定比例的裁剪。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. 宽和高固定比例裁剪计算；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比如宽和高比是 3:4 这样的截图；fixedNumber = [3, 4]&lt;/p&gt;
&lt;p&gt;因此 固定比例高度的计算&lt;br/&gt;fixedHeight              裁剪区域的实际宽度&lt;br/&gt;-------------  =  ---------------&lt;br/&gt;fixedNumber[1]         fixedNumber[0]&lt;/p&gt;
&lt;p&gt;因此：&lt;br/&gt;var fixedHeight = ~~(裁剪区域的实际宽度 / fixedNumber[0] * fixedNumber[1]);&lt;/p&gt;
&lt;p&gt;如果固定比例的移动的高度 + Y轴上相对于图片的偏移值 &amp;gt; 大于图片的高度的话，那么裁剪区域的高度(cropH) = 图片的高度(h) - Y轴上相对于图片的偏移值(cropOffsertY); 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416231018468-26870707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;获取到了 裁剪区域的高度的话，就可以获取到裁剪区域的宽度了；计算方式是：&lt;br/&gt;cropW(裁剪区域的宽度) = ~~(cropH / fixedNumber[1] * fixedNumber[0]);&lt;br/&gt;同时也要判断fw 是否大于0，来计算 cropOffsertX 的值；&lt;/p&gt;
&lt;p&gt;if (fw &amp;gt; 0) {&lt;br/&gt;   var cropOffsertX = cropChangeX&lt;br/&gt;} else {&lt;br/&gt;   var cropOffsertX = cropChangeX - cropW&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;fw &amp;gt; 0 说明是往右移动，因此 cropOffsertX = cropChangeX;&lt;br/&gt;fw &amp;lt; 0 说明是往左移动，cropOffsertX = 初始的 e.offsetX - 裁剪区域的宽度&lt;br/&gt;即：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (fixedHeight + cropOffsertY &amp;gt;&lt;span&gt; h) { 
  cropH(裁剪区域的高度) &lt;/span&gt;= h -&lt;span&gt; cropOffsertY;
  cropW(裁剪区域的宽度) &lt;/span&gt;= ~~(cropH / fixedNumber[1] * fixedNumber[0&lt;span&gt;]);
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fw &amp;gt; 0&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cropOffsertX =&lt;span&gt; cropChangeX
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cropOffsertX = cropChangeX -&lt;span&gt; cropW
  }
} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则 &lt;/span&gt;
  cropH =&lt;span&gt; fixedHeight;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6. 理解裁剪区域拉伸原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制裁剪区域拉伸的点，共有12种可以拉伸的点，分别有裁剪区域的四根线可以拉伸，有四根线上的八个点可以拉伸；如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416231158981-1753134943.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;当鼠标点击拉伸的时候，会触发mousedown事件；因此需要区分下到底是那根线或那个点向什么方向拉伸。因此定义 canChangeX 和 canChangeY 两个变量，&lt;br/&gt;判断是否能改变X轴和Y轴；默认是false；同时定义两个变量为 changeCropTypeX 和 changeCropTypeY，含义是能否改变x轴或Y轴的基准点。默认为1；可以改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 裁剪区域的最上面的线； 可以上下拉伸, 不能左右拉伸；&lt;/strong&gt;&lt;br/&gt;因此可以约定： canChangeX = false, canChangeY = true; changeCropTypeX = 0; changeCropTypeY = 1;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 裁剪区域左边的线；可以左右拉伸，不能上下拉伸；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此可以约定：canChangeX = true, canChangeY = false; changeCropTypeX = 1; changeCropTypeY = 0;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 裁剪区域底部线; 可以上下拉伸，不能左右拉伸；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此可以约定：canChangeX = false; canChangeY = true; changeCropTypeX = 0; changeCropTypeY = 2;(为了区分上面的线，因此等于2)；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 裁剪区域右边线；可以左右拉伸，不能上下拉伸；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此可以约定：canChangeX = true; canChangeY = false; changeCropTypeX = 2;（为了区分左边的线） changeCropTypeY = 0;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 左上角的点；可以向上或向左移动；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此 canChangeX = true, canChangeY = true; changeCropTypeX = 1; changeCropTypeY = 1;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 上面中间的点，只能上下拉伸，不能左右拉伸；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此 canChangeX = false, canChangeY = true; changeCropTypeX = 0; changeCropTypeY = 1;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. 右上角的点，可以左右拉伸和上下拉伸；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此 canChangeX = true, canChangeY = true; changeCropTypeX = 2; changeCropTypeY = 1;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8. 左中角的点，只能左右拉伸，不能上下拉伸；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此 canChangeX = true, canChangeY = false; changeCropTypeX = 1; changeCropTypeY = 0;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9. 右中角的点，只能左右拉伸，不能上下拉伸；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此 canChangeX = true, canChangeY = false; changeCropTypeX = 2; changeCropTypeY = 0;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10. 左下角的点，可以向上或向左移动；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此 canChangeX = true, canChangeY = true; changeCropTypeX = 1; changeCropTypeY = 2;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;11. 下线中间的店，可以上下拉伸，不能左右拉伸；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此 canChangeX = false, canChangeY = true; changeCropTypeX = 0; changeCropTypeY = 2;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12. 下右角点，可以上下拉伸，左右拉伸；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此 canChangeX = true, canChangeY = true; changeCropTypeX = 2; changeCropTypeY = 2;&lt;/p&gt;
&lt;p&gt;下面来看看移动操作；&lt;br/&gt;var fw = ~~(移动结束的clientX - 初始的clientX);&lt;br/&gt;var fh = ~~(移动结束的clientY - 初始的clientY);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6-1 向左或向右拉伸的基本原理：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (canChangeX) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果x轴能改变的话，说明是 裁剪区域中左右两根线或是左右两个线上的点了。&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (changeCropTypeX === 1&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果x轴的基点能改变的话，并且等于1，说明是裁剪区域左边的线或左边线上的点了。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那就有四种可能值，1. 左边的线，2. 左上角的点，3. 左中角的点。 4. 左下角的点。&lt;/span&gt;
&lt;span&gt;
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (changeCropTypeX === 2&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同理，说明是裁剪区域右边的线或右边线上的点了。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那也有四种可能值，1. 右边的线，2. 右上角的点，3. 右中角的点。4. 右下角的点。&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;changeCropTypeX === 1 的情况&lt;/strong&gt;；继续如下判断：&lt;/p&gt;
&lt;p&gt;假设裁剪区域的原始宽度为 cropOldW，裁剪区域的原始高度为 cropOldY， cropChangeX 保存原始的裁剪区域相对于图片的e.offsetX；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (cropOldW - fw &amp;gt; 0&lt;span&gt;) {&lt;/span&gt;&lt;span&gt;
  如果裁剪区域的原始宽度 大于 移动的距离的话，那么说明两点，第一是向左拉伸的话，fw为负数，第二是向右拉伸，但是拉伸的距离小于裁剪区域的原始宽度
  裁剪区域后的宽度 = 图片的宽度 - 拉伸前的offsetX - 拉伸的距离 &amp;lt;= 图片的宽度的话 ? 拉伸前的offsetX(cropChangeX) - 拉伸的距离 &lt;br/&gt;: 裁剪区原始宽度 + 拉伸前的offsetX.
  裁剪后的 cropOffsertX = 图片的宽度 - 拉伸前的offsetX(cropChangeX) - 拉伸的距离 &amp;lt;= 图片的宽度的话 ? &lt;br/&gt;裁剪区域前的offsertX（cropChangeX） + 拉伸的距离 : 0;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不管向左拉还是向右拉，裁剪区后的宽度 都等于 = 拉伸前的offsetX(cropChangeX) - 拉伸的距离;&lt;br/&gt;裁剪后的 cropOffsertX = 裁剪区域前的offsertX(cropChangeX) + 拉伸的距离;  如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416231654959-1694289412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (cropOldW - fw &amp;lt;= 0&lt;span&gt;) {&lt;/span&gt;&lt;span&gt;
  裁剪拉伸后的宽度 = 拉伸后的距离fw + cropChangeX &amp;lt;= 图片的宽度 ? 拉伸后的距离fw - 拉伸前的裁剪区域的宽度 : &lt;br/&gt;图片的宽度 - 拉伸前的裁剪区域的宽度 - cropChangeX;
  裁剪拉伸后的 cropOffsertX = 拉伸前的裁剪区域的offsetX(cropChangeX) + 裁剪区域之前的宽度;&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416231841720-290237894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;changeCropTypeX === 2 的情况；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明是裁剪区域右边的线或右边线上的点拉伸了。那也有四种可能值，1. 右边的线，2. 右上角的点，3. 右中角的点。4. 右下角的点。&lt;/p&gt;
&lt;p&gt;同理；右边的线拉伸也有向左拉伸和向右拉伸，如果向左拉伸的话，那么fw肯定为负数，如果向右拉伸的话，那么fw就为正数。&lt;/p&gt;
&lt;p&gt;if (cropOldW + fw &amp;gt; 0) {&lt;br/&gt;   // 如果原始的裁剪区域的宽度 + 拉伸的距离大于0，说明是向右拉伸或者向左拉伸，但是向左拉伸的距离小于原始裁剪区域&lt;br/&gt;  if (裁剪区域的原始宽度 + 移动距离fw + cropOffsertX &amp;lt;= 图片的宽度的话) {&lt;/p&gt;
&lt;p&gt;  }&lt;br/&gt;  这里的 &lt;strong&gt;裁剪区域的原始宽度 + 移动距离fw + cropOffsertX &amp;lt;= 图片的宽度的话&lt;/strong&gt; 也有两种情况，第一种是向左拉伸，第二种是向右拉伸，但是没有拉伸到底，&lt;br/&gt;  也就是说拉伸的距离没有到图片的最右边;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;现在的图片裁剪区域宽度(cropW) = 图片的原始区域的宽度 + fw(拉伸的距离，向左拉伸或向右拉伸);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  否则的话，也就是说拉伸到最右边了，那么 &lt;strong&gt;图片裁剪区域宽度(cropW) = 图片的宽度 - 裁剪区域拉伸前的cropOffsertX;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  因此此时 &lt;strong&gt;cropOffsertX = 拉伸前的裁剪区域的offsetX(cropChangeX);&lt;/strong&gt;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416232043739-1250160939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (cropOldW + fw &amp;lt;=0&lt;span&gt;) {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果原始裁剪区域的宽度 + 拉伸的距离小于或等于0的话，说明是向左拉伸，并且拉伸的距离正好大于或等于裁剪区域原始的宽度；&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这边向左拉伸的距离又可以分为2种情况，第一种是 向左拉伸的距离 小于 (原始裁剪区域 + 拉伸前的offsetX); 第二种就是向左拉伸的时候越界了，&lt;/p&gt;
&lt;p&gt;那么让拉伸后的宽度还控制在 offsetX的宽度即可，即不越界；因此如下逻辑判断: &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现在图片裁剪区域的宽度(cropW) = (图片的宽度w - 拉伸前的offsetX + Math.abs(拉伸的总距离 + 裁剪前的原始距离)) &amp;lt;= 图片的宽度w ？ Math.abs(拉伸的总距离 + 裁剪前的原始距离) : 拉伸前的offsetX;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时的 &lt;strong&gt;cropOffsertX = (图片的宽度w - 拉伸前的offsetX + Math.abs(拉伸的总距离 + 裁剪前的原始距离)) &amp;lt;= 图片的宽度w ？拉伸前的offsetX - Math.abs(拉伸的总距离 + 裁剪前的原始距离) : 0;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如下图所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416232208596-1224108754.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;6-2 向上或向下拉伸的基本原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (canChangeY) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果Y轴能改变的话，说明是 裁剪区域中上下两根线或是上下两个线上的点了。&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.changeCropTypeY === 1&lt;span&gt;) {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果Y轴的基点能改变的话，并且等于1，说明是裁剪区域上边的线或上边线上的点了。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那就有四种可能值，1. 上边的线，2. 上左角的点，3. 上中角的点。 4. 上右角的点。&lt;/span&gt;
&lt;span&gt;
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.changeCropTypeY === 2&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等于2，说明是裁剪区域下边的线或下边线上的点了。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同理也就有四种可能值，1. 下边的线，2. 下左角的点，3. 下中角的点。 4. 下右角的点。&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;changeCropTypeY === 1 的情况；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设裁剪区域的原始宽度为 cropOldH，裁剪区域的原始高度为 cropOldY， cropChangeY 保存原始的裁剪区域相对于图片的e.offsetY，&lt;br/&gt;向上或向下拉伸的距离为fh.&lt;/p&gt;
&lt;p&gt;如果是向下拉伸的话，又分为2种情况，第一种是向下拉伸它的距离不超过原始裁剪区域的高度 cropOldH, 第二种是已经超过它的原始裁剪区域的高度了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if (原始裁剪区域的高度cropOldH - 拉伸的距离fh &amp;gt; 0) {&lt;/strong&gt;&lt;br/&gt;   // 说明是向上拉伸(fw肯定为负数)或向下拉伸(fw肯定为正数)，但是向下拉伸的距离不超过原裁剪区域的高度&lt;br/&gt;   裁剪区域后的高度cropH 计算又分为2种情况，第一种是向上拉伸的距离fh小于或等于拉伸前的 e.offsetY, 第二种拉伸距离是大于e.offsetY，也就是向上&lt;br/&gt;   拉伸的时候越界了, 如果越界了，那么拉伸后的高度 = 裁剪之前的原始高度 + e.offsetY(裁剪区域之前的offsetY)；因此：&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;裁剪区域后的高度cropH = 图片的高度 - e.offsetY(裁剪区域之前的offsetY) - fh &amp;lt;= 图片的高度 ? 图片的原始高度cropOldH - 拉伸的距离fh :&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;   裁剪之前的原始高度 + e.offsetY(裁剪区域之前的offsetY);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;拉伸区域之后的cropOffsertY = 图片的高度 - e.offsetY(裁剪区域之前的offsetY) - fh &amp;lt;= 图片的高度 ? e.offsetY(裁剪区域之前的offsetY) + fh : 0&lt;/strong&gt;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416232415161-143050988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if (原始裁剪区域的高度cropOldH - 拉伸的距离fh &amp;lt;= 0) {&lt;/strong&gt;&lt;br/&gt;   // 说明是向下拉伸，且拉伸的距离fh大于或等于原始裁剪区域的高度cropOldH&lt;br/&gt;   同时一样也要判断两种情况，第一种是向下拉伸后，没有超过图片的最低端，第二种是超过了图片的最低端，也就是越界的情况。&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;拉伸后裁剪区域的高度 = 拉伸后的总距离fh + 拉伸前的offsetY &amp;lt;= 图片的高度h ? 拉伸后的总距离fh - 裁剪区域原始的高度cropOldH : 图片的高度H -&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;   拉伸前的offsetY - 裁剪区域原始的高度 cropOldH;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   拉伸区域之后的cropOffsetY = 拉伸前的offsetY + 裁剪区域原始的高度cropOldH;&lt;/strong&gt;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416232504476-661983494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;changeCropTypeY === 2 的情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;等于2，说明是裁剪区域下边的线或下边线上的点了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if (原裁剪区域的高度 + 被拉伸的距离fh &amp;gt; 0) {&lt;/strong&gt;&lt;br/&gt;   // 说明了有可能是向下拉伸，或向上拉伸，但是向上拉伸的距离小于原裁剪区域的高度&lt;br/&gt;   &lt;strong&gt;裁剪区域后的高度 = 原裁剪区域的高度 + 被拉伸的距离fh + 原始裁剪区域的offsetY &amp;lt;= 图片的高度 ? 原裁剪区域的高度 + 被拉伸的距离fh : 图片的高度 -&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;   原始裁剪的offsetY&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   裁剪后的cropOffsertY = 原始裁剪的offsetY;&lt;/strong&gt;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416232558511-1544019518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if (原裁剪区域的高度 + 被拉伸的距离fh &amp;lt;= 0) {&lt;/strong&gt;&lt;br/&gt;   // 说明是向上拉伸，且向上拉伸的距离大于或等于原始裁剪区域的高度&lt;br/&gt;   &lt;strong&gt;裁剪区域后的高度 = 图片的高度 - 原裁剪区域的offsetY + Math.abs(fh + 原裁剪区域的高度) &amp;lt;= 图片的高度 ? 原裁剪区域的高度 + 被拉伸的总距离fh :&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;   原裁剪区域的offsetY;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   裁剪后的offsetY = 图片的高度 - 原裁剪区域的offsetY + Math.abs(fh + 原裁剪区域的高度) &amp;lt;= 图片的高度 ? 原裁剪区域的offsetY - Math.abs(被拉伸的总距  离fh + 原裁剪区域的高度) : 0;&lt;/strong&gt;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416232644848-196664579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6-3: 向左或向右拉伸且是固定比例拉伸&lt;/strong&gt;，假设固定比例 3:4, 即 fixedNumber = [3, 4];&lt;br/&gt;向左或向右拉伸，高度会随着变化。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416232720974-438394427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;if (canChangeX &amp;amp;&amp;amp; fixed) {&lt;/p&gt;
&lt;p&gt;  比如宽和高比是 3:4 这样的比例；fixedNumber = [3, 4]&lt;br/&gt;  因此 固定比例高度的计算&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;裁剪区域的高度        fixedNumber[1]&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;  ------------- = ---------------&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;  裁剪区域的宽度        fixedNumber[0]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此：&lt;br/&gt;var 裁剪区域的高度(fixedHeight) = ~~(裁剪区域的宽度 / fixedNumber[0] * fixedNumber[1]);&lt;br/&gt;&lt;strong&gt;if (裁剪区域的高度 + 原裁剪区域的offsetY &amp;gt; 图片的高度) {&lt;/strong&gt;&lt;br/&gt;   // 说明向左拉伸或向右拉伸，导致纵向区域越界了，&lt;br/&gt;   &lt;strong&gt;拉伸后的高度 = 图片的高度 - 原裁剪区域的offsetY;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;拉伸后的宽度     3&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;     ----------  = ----&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;      拉伸后的高度      4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;拉伸后的宽度 = 拉伸后的高度 / fixedNumber[1] * fixedNumber[0];&lt;/strong&gt;&lt;br/&gt;} else {&lt;br/&gt;   &lt;strong&gt;拉伸后的高度 = fixedHeight;&lt;/strong&gt;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;同样的道理，如果Y轴上的上下线拉伸的话，宽度会跟着变化，也是一样的计算方式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if (this.canChangeY &amp;amp;&amp;amp; this.fixed) {&lt;/strong&gt;&lt;br/&gt;    比如宽和高比是 3:4 这样的比例；fixedNumber = [3, 4];&lt;br/&gt;    因此 固定比例宽度的计算&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;裁剪区域的高度       fixedNumber[1]&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;   ------------- = ---------------&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;    裁剪区域的宽度       fixedNumber[0]&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;裁剪区域的宽度(fixedWidth) = ~~(裁剪区域的高度 / fixedNumber[1] * fixedNumber[0]);&lt;/strong&gt;&lt;br/&gt;    if (裁剪区域的宽度 + 原裁剪区域的offsetX &amp;gt; 图片的宽度) {&lt;br/&gt;       // 说明向上或向下拉伸，横向区域越界了&lt;br/&gt;       拉伸后的宽度 = 图片的宽度 - 原裁剪区的offsetX;&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;拉伸后的宽度      3&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;        ---------- = ----&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;          拉伸后的高度    4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;拉伸后的高度 = 拉伸后的宽度 / fixedNumber[0] * fixedNumber[1];&lt;/strong&gt;&lt;br/&gt;   } else {&lt;br/&gt;     &lt;strong&gt;拉伸后的宽度 = fixedWidth;&lt;/strong&gt;&lt;br/&gt;   }&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7. 截图移动操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先可以先获取原裁剪区域的offsetx，和 offsetY, 该offsetX和offsetY是相对于浏览器的，因此原坐标的x轴和Y轴的 e.clientx 和 e.clientY;&lt;br/&gt;当鼠标移动裁剪区到一个新坐标的时候，会有一个新的 e.clientX 和 e.clientY; 把终点的x轴和Y轴离客户端的距离 - 起点的x轴和Y轴的距离，&lt;br/&gt;就等于移动了多少的距离了，再加上原裁剪区相对于浏览器的 offsetX 或 offsetY后，就是最终相对于浏览器的坐标了；因此；&lt;br/&gt;&lt;strong&gt;fw = 终点的x轴坐标(e.clientX) - 起点的x轴坐标(e.clientX) + 原裁剪区相对于浏览器的x轴坐标(offsetX);&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;fh = 终点的y轴坐标(e.clientY) - 起点的y轴坐标(e.clientY) + 原裁剪区相对于浏览器的y轴坐标(offsetY);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如下图所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416233231991-848944728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if (移动后的距离fw小于或等于1的话) {&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;    移动后的cropOffsertX = 1;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;} else if ((移动后的距离 + 裁剪区域的宽度) &amp;gt; 图片的宽度的话) {&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;   // 说明移动的裁剪区域越界了，那么就让裁剪区处于中间的位置&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;   移动后的cropOffsertX = 图片的宽度 - 裁剪区的宽度 - 1;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如下图所示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/561794/201804/561794-20180416233325133-853590665.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;else {&lt;br/&gt;  &lt;strong&gt;移动后的cropOffsertX = fw;&lt;/strong&gt;&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同理 if (移动后的距离fh小于或等于1的话) {&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;   移动后的cropOffsertY = 1;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;} else if ((移动后的距离 + 裁剪区域的高度) &amp;gt; 图片的高度的话) {&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;   // 说明移动的裁剪区域越界了，那么就让裁剪区处于中间的位置&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;   移动后的cropOffsertY = 图片的高度 - 裁剪区的高度 - 1;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;} else {&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;   移动后的cropOffsertY = fh;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8. 自动截图操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码的基本原理是：看组件是否传递了 autoCropWidth 和 autoCropHeight, 如果传递了该参数的宽度和高度的话，那么使用该参数的值，&lt;br/&gt;如果没有传递的话，或者说该宽度和高度的值都为0的话，那么截取的宽度和高度就是图片的宽度和高度的80%；如果传递的宽度w和高度h大于图片的&lt;br/&gt;本身的宽度或高度的话，那么宽度或高度的值就是图片的本身的宽度和高度的值。&lt;br/&gt;如果传递了固定比例的话，那么高度的计算是根据宽度的比例来计算出来的。计算方式还是之前一样的：如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
       w              fixedNumber[0&lt;span&gt;]
  &lt;/span&gt;-------------   =  ---------------&lt;span&gt;
       h              fixedNumber[&lt;/span&gt;1]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此 h = w / this.fixedNumber[0] * this.fixedNumber[1]&lt;/p&gt;
&lt;p&gt;如果高度大于图片的高度的话，那么高度就是等于图片的高度，然后根据现在的高度重新计算宽度；&lt;br/&gt;代码如下：&lt;br/&gt;// 如果比例之后 高度大于h&lt;br/&gt;if (h &amp;gt; this.h) {&lt;br/&gt;   h = this.h&lt;br/&gt;   w = h / this.fixedNumber[1] * this.fixedNumber[0]&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;自动截图的主要代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; w = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.autoCropWidth
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; h = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.autoCropHeight
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (w === 0 || h === 0&lt;span&gt;) {
  w &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.w * 0.8&lt;span&gt;
  h &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.h * 0.8&lt;span&gt;
}
w &lt;/span&gt;= w &amp;gt; &lt;span&gt;this&lt;/span&gt;.w ? &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.w : w
h &lt;/span&gt;= h &amp;gt; &lt;span&gt;this&lt;/span&gt;.h ? &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.h : h
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fixed) {
  h &lt;/span&gt;= w / &lt;span&gt;this&lt;/span&gt;.fixedNumber[0] * &lt;span&gt;this&lt;/span&gt;.fixedNumber[1&lt;span&gt;]
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果比例之后 高度大于h&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (h &amp;gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.h) {
  h &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.h
  w &lt;/span&gt;= h / &lt;span&gt;this&lt;/span&gt;.fixedNumber[1] * &lt;span&gt;this&lt;/span&gt;.fixedNumber[0&lt;span&gt;]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tugenhua0707/vue-cropper-demo&quot; target=&quot;_blank&quot;&gt;github的源码--PC端&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Apr 2018 15:42:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tugenhua0707/p/8859291.html</dc:identifier>
</item>
<item>
<title>开源纯C#工控网关+组态软件(九)定制Visual Studio - 老坏猫</title>
<link>http://www.cnblogs.com/evilcat/p/8859223.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/evilcat/p/8859223.html</guid>
<description>&lt;div&gt;
&lt;p class=&quot;PublishStatus&quot;&gt;&lt;span&gt; &lt;strong&gt;一、  &lt;/strong&gt; &lt;strong&gt;引子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;因为最近很忙（lan），很久没发博了。不少朋友对那个右键弹出菜单和连线的功能很感兴趣，因为VS本身是不包含这种功能的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/43917/201804/43917-20180416231356034-47530619.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/43917/201804/43917-20180416231344438-1025451272.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;大家想这是什么鬼，怎么我的设计器没有，其实这是一个微软黑科技，如果用好，VS可以打造为你专用的神兵利器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么我要扩展Visual Studio的界面设计器？当时我在设计组态软件的时候面临最大的困难大概就是设计器了。一套成熟的组态设计器包括：&lt;strong&gt;界面设计器&lt;/strong&gt;（包括工具栏、设计器、属性管理器）、&lt;strong&gt;脚本编辑器&lt;/strong&gt;（各种语法高亮、语法检查、自动完成等等等等）、&lt;strong&gt;编译&lt;/strong&gt;（解释）&lt;strong&gt;器&lt;/strong&gt;、&lt;strong&gt;调试器&lt;/strong&gt;、&lt;strong&gt;解决方案管理器&lt;/strong&gt;（如何组织项目、导入/导出文件、添加资源、添加引用等等等等），说出来吓死人，这些功能绝对不是我这类单兵作战人员能搞定的。那是微软、西门子这种级别的巨型公司以按人年计算的成本完成的。也曾经想过套用网上开源设计器，搜了半天，得出一个结论：网上的都是一些简单的DEMO或者原型设计，和我想实现的目标还差的太远，完善的好东西一般是不会开源的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是仔细想一下我上面列举的功能，不就是Visual Studio现成的功能吗?放着这个宇宙第一IDE不用，想自己重新造轮子，估计写到老都没有什么结果。于是我想能不能通过扩展VS，去实现一些组态软件的特殊要求功能，比如常用的变量组态编辑器、连线这类的功能？万能的谷歌让我找到了我想要的技术： WPF（含Blend） 设计器扩展。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、  &lt;/strong&gt; &lt;strong&gt;什么是WPF设计器扩展&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WPF设计器，常规的界面就是 工具栏+XAML编辑器+界面设计器。界面设计器包括右键编辑菜单、设计器装饰（如锚点进行缩放、旋转），属性编辑器等。这些功能已经很强大，完善了；但考虑到用户的特殊需求，VS提供    了强大的扩展功能，参考&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/windows/desktop/bb675306(v=vs.90).aspx&quot;&gt;https://msdn.microsoft.com/zh-cn/library/windows/desktop/bb675306(v=vs.90).aspx&lt;/a&gt; 的介绍：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WPF 设计器基于一个具有可扩展的体系结构的框架，用户可以扩展这种框架以创建自己的自定义设计体验。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;通过扩展 WPF 设计器对象模型，可以在很大程度上自定义 WPF 内容的设计时外观和行为。&lt;/strong&gt;例如，可以通过下列方式扩展 WPF 设计器：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;利用增强的图形自定义移动并调整标志符号的大小。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;向设计图面添加一个标志符号，在鼠标移动时该标志符号可以使所选控件倾斜。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在不同工具之间修改控件的设计时外观和行为。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;WPF 设计器 体系结构支持 WPF 的所有表现力。这样便可以创建很多以前不可能拥有的可视化设计体验。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;也就是说，WPF设计器扩展提供了一套API，可以自定义装饰器（如点选控件出现的旋转、拖放、拉伸、定位锚点）、右键菜单（如编辑、排序、对齐、剪切）、属性编辑器，并控制它们的行为；甚至可以改变设计器的外观。是不是很强大？然而这一黑科技很少人知道，而且为了实现设计器扩展，你必须严格遵守一些特殊的规则，而且设计器扩展的调试方式也很特殊。同时，在WPF设计器的扩展基本可以不修改就移植到Blend。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、  &lt;/strong&gt; &lt;strong&gt;如何实现设计器扩展&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;API总体架构&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/43917/201804/43917-20180416231432531-973831461.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;VS的状态分为&lt;strong&gt;设计时&lt;/strong&gt;和&lt;strong&gt;运行时&lt;/strong&gt;。设计时就是你打开VS，拖拽控件，界面布局，属性设置，代码编写，打交道的对象是Visual Studio；运行时就是你编译运行自己的exe文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WPF的界面设计器，其核心目标就是对控件（&lt;span&gt;Contorl&lt;/span&gt;）的控制，包括对控件的拖放、旋转、移动、属性编辑等。而在设计时如果要操作控件，首先要在设计、编辑过程中通过一些API“发现”要操作的控件，并使其能与VS设计器互动。API这里使用了一个 “提供者模式”来实现：对装饰器、菜单、属性编辑器等的操作功能，提供了相应的&lt;span&gt;Provider&lt;/span&gt;来实现，如装饰器的&lt;span&gt;AdornerProvider&lt;/span&gt;,右键菜单的&lt;span&gt;ContextMenuProvider&lt;/span&gt; 等。所有的&lt;span&gt;Provider&lt;/span&gt;都遵循这样的场景：当你做了一个“选择”的动作（比如拖动一个控件旋转-对应&lt;span&gt;AdornerProvider&lt;/span&gt;的Active事件；或点了某个右键菜单-对应&lt;span&gt;ContextMenuProvider&lt;/span&gt;的&lt;span&gt;Execute&lt;/span&gt;事件），进而通过动作事件的&lt;span&gt;PrimarySelection&lt;/span&gt;参数获取相对应的&lt;span&gt;ModelItem&lt;/span&gt;-控件在设计时的“马甲”，进而通过&lt;span&gt;ModelItem&lt;/span&gt;的&lt;span&gt;GetCurrentValue&lt;/span&gt;方法找到你选择的对象。大家也许会问，设计器扩展为何要多此一举的对控件加一层外壳&lt;span&gt;ModelItem&lt;/span&gt;，直接操作控件不就行了吗？回答是，你对控件的设计时操作，例如对控件的激活，使之成为设计器选中的控件，这一行为在控件本身并没有定义；而设计器也要通过自己“理解”的上下文才能与控件交互。&lt;span&gt;ModelItem&lt;/span&gt;将用户对控件的操作反馈给设计器，或者将设计的动作告知用户，起了关键的中介作用。而设计器本身的“马甲”是&lt;span&gt;DesignerView&lt;/span&gt;，可以通过这个类获取设计器当前设置，如当前界面大小、缩放比例等。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;如何实现&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;要实现一个完整的设计器扩展，要经历以下过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义元数据，设计器需要知道哪些控件具有哪些扩展。这是通过&lt;span&gt;Metadata&lt;/span&gt; 类来实现的：&lt;span&gt;Metadata&lt;/span&gt; 类有一个&lt;span&gt;AttributeTable&lt;/span&gt;方法，在其中构建了控件和功能（即相应的Provider）的映射关系。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;4.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Windows.Design.Features;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Windows.Design.Metadata;
 
 
[assembly: ProvideMetadata(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(HMIControl.VisualStudio.Design.Metadata))]
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; HMIControl.VisualStudio.Design
{
    &lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Metadata : IProvideAttributeTable
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Accessed by the designer to register any design-time metadata.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AttributeTable AttributeTable
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                AttributeTableBuilder builder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AttributeTableBuilder();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;InitializeAttributes(builder);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add the adorner provider to the design-time metadata.&lt;/span&gt;
&lt;span&gt;                builder.AddCustomAttributes(
                    &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(LinkableControl),
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FeatureAttribute(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ControlAdornerProvider))
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;new FeatureAttribute(typeof(TagComplexContextMenuProvider))&lt;/span&gt;
&lt;span&gt;                    );
                builder.AddCustomAttributes(
                  &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(HMIControlBase),
                  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;new FeatureAttribute(typeof(LinkLineAdornerProvider)),&lt;/span&gt;
                  &lt;span&gt;new&lt;/span&gt; FeatureAttribute(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TagComplexContextMenuProvider)));
                builder.AddCustomAttributes(
                    &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(LinkLine),
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FeatureAttribute(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(LinkLineAdornerProvider)),
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FeatureAttribute(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TagComplexContextMenuProvider)));
                builder.AddCustomAttributes(
                    &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(ButtonBase),
                    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FeatureAttribute(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TagWriterContextMenuProvider)));
                builder.AddCustomAttributes(
                  &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(HMIButton),
                  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FeatureAttribute(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TagWindowContextMenuProvider)),
                  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FeatureAttribute(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TagComplexContextMenuProvider)),
                  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FeatureAttribute(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TagWriterContextMenuProvider)));
                builder.AddCustomAttributes(
                  &lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(FromTo),
                  &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FeatureAttribute(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TagWindowContextMenuProvider)));
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; builder.CreateTable();
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;定义具体的&lt;span&gt;Provider&lt;/span&gt;，所有的&lt;span&gt;Provider&lt;/span&gt;都执行如下次序：根据用户选择，找到相关控件，并进行操作，将操作结果反馈给设计器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据设计器扩展的默认规则，在正确的位置使用正确的命名方式，否则你的扩展不会出现在设计器。这些默认规则包括：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;命名空间规则&lt;/strong&gt;：将设计器扩展项目的命名空间设置为&lt;span&gt;HMIControl.VisualStudio.Design&lt;/span&gt;(&lt;span&gt;HMIControl&lt;/span&gt;即控件库的命名空间)，以便设计器能够发现元数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;项目路径规则&lt;/strong&gt;：将项目的输出路径设置为“&lt;span&gt;..\HMIControl\bin\&lt;/span&gt;”(HMIControl即控件库的项目路径)。 使控件的程序集与元数据程序集位于同一文件夹中，从而可为设计器启用元数据发现。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;如何调试&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;一段不能加断点调试的代码会给编写者带来很大困扰。但设计器扩展有一个特殊性：没法在运行时加断点。好在微软早就为我们安排好了一切。具体可参考&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/sqlserver/bb514636&quot;&gt;https://msdn.microsoft.com/zh-cn/sqlserver/bb514636&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即调试时需要更改项目的属性，设置启动程序为VS的可执行文件： devenv.exe.相当于再打开一个新的VS作为运行时。调试时打开你的设计器操作，会发现第一个打开的VS中已经命中断点了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/43917/201804/43917-20180416231453838-276757414.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、  &lt;/strong&gt; &lt;strong&gt;组态定制需求的实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据组态软件的特殊需求，有两个重要功能是通过WPF设计器扩展实现的：控件连线和右键弹出表达式编辑器，具体代码在&lt;span&gt;LinkableControlDesign&lt;/span&gt;项目中。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;界面连线的实现&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;设计目标&lt;/strong&gt;：实现两个HMI控件的连线。每个控件最多有上下左右四个位置（即锚点，也可以少于四个甚至没有），连线从A控件任一位置引出，自动寻找路径，连到B控件的任一位置；路径不能穿越其他控件，而应自动绕开。连线均为直线，不能为圆弧线或斜线；在控件位置改变时，连线重新计算并绘制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;设计过程&lt;/strong&gt;：具有锚点的控件均继承&lt;span&gt;LinkableControl&lt;/span&gt;类。锚点装饰器类为&lt;span&gt;ControlAdorner&lt;/span&gt;，是一个控件容器，包含上下左右四个锚点，每个锚点由PinAdorner 定义，包含锚点的外形、自动生成路径等功能。路径发现由&lt;span&gt;PathFinder&lt;/span&gt;类实现。与设计器交互通过继承&lt;span&gt;AdornerProvider&lt;/span&gt; 类实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;运行过程&lt;/strong&gt;：通过&lt;span&gt;AdornerProvider&lt;/span&gt; 类的&lt;span&gt;Activate&lt;/span&gt;事件，获取当前点击（激活）的控件并转换为&lt;span&gt;LinkableControl&lt;/span&gt;，并找到控件的父容器&lt;span&gt;Panel&lt;/span&gt;、控件的装饰器&lt;span&gt;ControlAdorner&lt;/span&gt;及其包含的每个&lt;span&gt;PinAdorner&lt;/span&gt;、设计器包装&lt;span&gt;DesignerView&lt;/span&gt;。在每个&lt;span&gt;PinAdorner&lt;/span&gt;的鼠标点击和拖放事件内，可探索到其他控件的锚点、规划路径、生成连线&lt;span&gt;LinkLine&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时要考虑设计器进行缩放时路径的变化，在&lt;span&gt;DesignerView&lt;/span&gt;的&lt;span&gt;ZoomLevelChanged&lt;/span&gt;事件中处理。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;右键菜单的实现&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;设计目标&lt;/strong&gt;：组态软件一般都有自己的变量表达式编辑器，用来实现对界面控件的动画效果。如果要求设计者手工输入表达式，容易出错，也没有语法检查，很麻烦。但VS并没有提供这个功能，因此我想到了点选控件，弹出的右键菜单加上一个编辑项。这就要用到&lt;span&gt;ContextMenuProvider&lt;/span&gt;的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;设计过程&lt;/strong&gt;：&lt;span&gt;TagComplexContextMenuProvider&lt;/span&gt; 继承了&lt;span&gt;ContextMenuProvider&lt;/span&gt;，如果菜单“&lt;span&gt;ComplexEditor&lt;/span&gt;”被激活，触发&lt;span&gt;Exeute&lt;/span&gt;事件，则弹出窗体&lt;span&gt;TagComplexEditor&lt;/span&gt;，以设置控件的动画关联的变量表达式；操作结果将写回控件的&lt;span&gt;TagReadText&lt;/span&gt; 属性。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;未来改进&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;编辑器改进：&lt;/strong&gt;支持命令自动完成、语法高亮、更完善的语法检查。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;快捷键编辑&lt;/strong&gt;：目前的右键弹出编辑器菜单方式操作还可以进一步改进为快捷键方式。但似乎WPF扩展没有提供快捷键弹出的API，期待进一步完善。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、  &lt;/strong&gt; &lt;strong&gt;下面的计划&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写一系列帖子，把架构、原理讲清楚。大致如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;github地址：&lt;a href=&quot;https://github.com/GavinYellow/SharpSCADA&quot; target=&quot;_blank&quot;&gt;https://github.com/GavinYellow/SharpSCADA&lt;/a&gt;。QQ群：102486275&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 16 Apr 2018 15:24:00 +0000</pubDate>
<dc:creator>老坏猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/evilcat/p/8859223.html</dc:identifier>
</item>
<item>
<title>WPF 自定义TreeView控件样式，仿QQ联系人列表 - 小明GG</title>
<link>http://www.cnblogs.com/xiaomingg/p/8765802.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaomingg/p/8765802.html</guid>
<description>&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;TreeView控件在项目中使用比较频繁，普通的TreeView并不能满足我们的需求。因此我们需要滴对TreeView进行改造。下面的内容将介绍仿QQ联系人TreeView样式及TreeView数据绑定方法。&lt;/p&gt;
&lt;h2&gt;二、TreeView仿QQ联系人列表&lt;/h2&gt;
&lt;p&gt;准确的说不是仿QQ联系人列表，这个TreeView样式作为组织架构来使用更好。废话不多说，&lt;span&gt;先看效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366553/201804/1366553-20180409232420570-21281577.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 2.1、基本思路&lt;/h3&gt;
&lt;p&gt;像这种联系人列表一般涉及到多层级数据，而且有很多数据是需要动态更新的，如果通过手动一条条增加数据反而更复杂，而且不方便。因此为了绑定数据方便我们使用分层模板HierarchicalDataTemplate。&lt;/p&gt;
&lt;p&gt;分层模板中存在两种样式，一种是分组样式，一种是人员样式。不管是分组还是人员绑定的都是对象，这样我们在对象中添加一个属性来辨别是否为分组-IsGrouping。&lt;/p&gt;
&lt;p&gt;默认的TreeView控件四周会有边距，因此需要设置下TreeView的样式。另外鼠标经过和鼠标选中的背景色需要变化，因此还需要设置TreeViewItem的样式。&lt;/p&gt;
&lt;p&gt;根据思路，我们需要设置三个样式，TreeView样式，TreeViewItem样式，HierarchicalDataTemplate分层模板样式。另外为了自动计算下一级的边距，我们需要添加一个转换器IndentConverter。还需要一个转换器需要将布尔类型的IsGrouping转换为Visibility，还需要一个转换器来对Visibility取反。&lt;/p&gt;
&lt;p&gt;这样三个样式，三个转换器。就可以实现我们上面的效果，另外还可以进行动态数据绑定。&lt;/p&gt;
&lt;h3&gt;2.2、样式代码&lt;/h3&gt;
&lt;p&gt;HierarchicalDataTemplate分层模板样式代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;HierarchicalDataTemplate &lt;/span&gt;&lt;span&gt;x:Key&lt;/span&gt;&lt;span&gt;=&quot;ItemNode&quot;&lt;/span&gt;&lt;span&gt; ItemsSource&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Children,Mode=TwoWay}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid  &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;Transparent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid.Resources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;convert:BoolToVisible &lt;/span&gt;&lt;span&gt;x:Key&lt;/span&gt;&lt;span&gt;=&quot;boolToVisible&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;convert:VisibleToReverse &lt;/span&gt;&lt;span&gt;x:Key&lt;/span&gt;&lt;span&gt;=&quot;visibleToReverse&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid.Resources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;MinHeight&lt;/span&gt;&lt;span&gt;=&quot;30&quot;&lt;/span&gt;&lt;span&gt; x:Name&lt;/span&gt;&lt;span&gt;=&quot;userinfo&quot;&lt;/span&gt;&lt;span&gt; Background&lt;/span&gt;&lt;span&gt;=&quot;Transparent&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;-5 0 0 0&quot;&lt;/span&gt;&lt;span&gt; Visibility&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Visibility,ElementName=groupinginfo,Converter={StaticResource visibleToReverse}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;Height&lt;/span&gt;&lt;span&gt;=&quot;50&quot;&lt;/span&gt;&lt;span&gt; x:Name&lt;/span&gt;&lt;span&gt;=&quot;grid&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;#62acf9&quot;&lt;/span&gt;&lt;span&gt; Width&lt;/span&gt;&lt;span&gt;=&quot;40&quot;&lt;/span&gt;&lt;span&gt; Height&lt;/span&gt;&lt;span&gt;=&quot;40&quot;&lt;/span&gt;&lt;span&gt; CornerRadius&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt; HorizontalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Left&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;0 0 0 0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding SurName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; FontSize&lt;/span&gt;&lt;span&gt;=&quot;23&quot;&lt;/span&gt;&lt;span&gt; Foreground&lt;/span&gt;&lt;span&gt;=&quot;White&quot;&lt;/span&gt;&lt;span&gt; VerticalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt; HorizontalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;50 7 0 0&quot;&lt;/span&gt;&lt;span&gt; FontSize&lt;/span&gt;&lt;span&gt;=&quot;13&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Info}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Foreground&lt;/span&gt;&lt;span&gt;=&quot;#808080&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;50 30 0 0&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Count,StringFormat={}{0}人}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Foreground&lt;/span&gt;&lt;span&gt;=&quot;#808080&quot;&lt;/span&gt;&lt;span&gt; HorizontalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Right&quot;&lt;/span&gt;&lt;span&gt; VerticalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;0 0 5 0&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel &lt;/span&gt;&lt;span&gt;MinHeight&lt;/span&gt;&lt;span&gt;=&quot;25&quot;&lt;/span&gt;&lt;span&gt; x:Name&lt;/span&gt;&lt;span&gt;=&quot;groupinginfo&quot;&lt;/span&gt;&lt;span&gt; Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt; Background&lt;/span&gt;&lt;span&gt;=&quot;Transparent&quot;&lt;/span&gt;&lt;span&gt; HorizontalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Left&quot;&lt;/span&gt;&lt;span&gt; Visibility&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding IsGrouping,Converter={StaticResource boolToVisible}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding DisplayName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;3 0&quot;&lt;/span&gt;&lt;span&gt; VerticalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Center&quot;&lt;/span&gt;&lt;span&gt; HorizontalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Left&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;StackPanel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;HierarchicalDataTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TreeViewItem样式代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Style  &lt;/span&gt;&lt;span&gt;x:Key&lt;/span&gt;&lt;span&gt;=&quot;DefaultTreeViewItem&quot;&lt;/span&gt;&lt;span&gt; TargetType&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:Type TreeViewItem}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;MinHeight&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;25&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Background&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;Transparent&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;SnapsToDevicePixels&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Margin&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Template&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ControlTemplate &lt;/span&gt;&lt;span&gt;TargetType&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:Type TreeViewItem}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ControlTemplate.Resources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;convert:IndentConverter  &lt;/span&gt;&lt;span&gt;x:Key&lt;/span&gt;&lt;span&gt;=&quot;indentConverter&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ControlTemplate.Resources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;Transparent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid.RowDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RowDefinition&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid.RowDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;itemBackground&quot;&lt;/span&gt;&lt;span&gt; Background&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding Background}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  
                                BorderBrush&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding BorderBrush}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  
                                BorderThickness&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding BorderThickness}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  
                                Padding&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding Padding}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;Transparent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;ItemRoot&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Converter={StaticResource indentConverter},RelativeSource={RelativeSource TemplatedParent}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Background&lt;/span&gt;&lt;span&gt;=&quot;Transparent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid.ColumnDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColumnDefinition &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;16&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColumnDefinition &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid.ColumnDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ToggleButton &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;Expander&quot;&lt;/span&gt;&lt;span&gt; HorizontalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Left&quot;&lt;/span&gt;&lt;span&gt; ClickMode&lt;/span&gt;&lt;span&gt;=&quot;Press&quot;&lt;/span&gt;&lt;span&gt; IsChecked&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding IsExpanded, RelativeSource={RelativeSource TemplatedParent}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ToggleButton.Style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Style &lt;/span&gt;&lt;span&gt;TargetType&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:Type ToggleButton}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Focusable&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Width&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;16&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Height&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;16&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Template&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ControlTemplate &lt;/span&gt;&lt;span&gt;TargetType&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:Type ToggleButton}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Background&lt;/span&gt;&lt;span&gt;=&quot;Transparent&quot;&lt;/span&gt;&lt;span&gt; Height&lt;/span&gt;&lt;span&gt;=&quot;16&quot;&lt;/span&gt;&lt;span&gt; Padding&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Width&lt;/span&gt;&lt;span&gt;=&quot;16&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Path &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;ExpandPath&quot;&lt;/span&gt;&lt;span&gt; Data&lt;/span&gt;&lt;span&gt;=&quot;M0,0 L0,6 L6,0 z&quot;&lt;/span&gt;&lt;span&gt; Fill&lt;/span&gt;&lt;span&gt;=&quot;#66645e&quot;&lt;/span&gt;&lt;span&gt; Stroke&lt;/span&gt;&lt;span&gt;=&quot;#66645e&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Path.RenderTransform&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RotateTransform &lt;/span&gt;&lt;span&gt;Angle&lt;/span&gt;&lt;span&gt;=&quot;135&quot;&lt;/span&gt;&lt;span&gt; CenterY&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; CenterX&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                                                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Path.RenderTransform&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Path&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ControlTemplate.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Trigger &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;IsChecked&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;RenderTransform&quot;&lt;/span&gt;&lt;span&gt; TargetName&lt;/span&gt;&lt;span&gt;=&quot;ExpandPath&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RotateTransform &lt;/span&gt;&lt;span&gt;Angle&lt;/span&gt;&lt;span&gt;=&quot;180&quot;&lt;/span&gt;&lt;span&gt; CenterY&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt; CenterX&lt;/span&gt;&lt;span&gt;=&quot;3&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                                                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Fill&quot;&lt;/span&gt;&lt;span&gt; TargetName&lt;/span&gt;&lt;span&gt;=&quot;ExpandPath&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;#66645e&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Stroke&quot;&lt;/span&gt;&lt;span&gt; TargetName&lt;/span&gt;&lt;span&gt;=&quot;ExpandPath&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;#66645e&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                                                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Trigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Trigger &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;IsMouseOver&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Stroke&quot;&lt;/span&gt;&lt;span&gt; TargetName&lt;/span&gt;&lt;span&gt;=&quot;ExpandPath&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;#66645e&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Fill&quot;&lt;/span&gt;&lt;span&gt; TargetName&lt;/span&gt;&lt;span&gt;=&quot;ExpandPath&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;#66645e&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                                                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Trigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MultiTrigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MultiTrigger.Conditions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Condition &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;IsMouseOver&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                                                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Condition &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;IsChecked&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                                                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;MultiTrigger.Conditions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Stroke&quot;&lt;/span&gt;&lt;span&gt; TargetName&lt;/span&gt;&lt;span&gt;=&quot;ExpandPath&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;#66645e&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Fill&quot;&lt;/span&gt;&lt;span&gt; TargetName&lt;/span&gt;&lt;span&gt;=&quot;ExpandPath&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;#66645e&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                                                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;MultiTrigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ControlTemplate.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ControlTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ToggleButton.Style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ToggleButton&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ContentPresenter &lt;/span&gt;&lt;span&gt;Grid.Column&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; x:Name&lt;/span&gt;&lt;span&gt;=&quot;PART_Header&quot;&lt;/span&gt;&lt;span&gt; ContentSource&lt;/span&gt;&lt;span&gt;=&quot;Header&quot;&lt;/span&gt;&lt;span&gt;  
                                                 HorizontalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Stretch&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;

                                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ContentPresenter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ItemsPresenter &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;ItemsHost&quot;&lt;/span&gt;&lt;span&gt; Grid.Row&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ControlTemplate.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DataTrigger &lt;/span&gt;&lt;span&gt;Binding&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding IsGrouping}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Visibility&quot;&lt;/span&gt;&lt;span&gt; TargetName&lt;/span&gt;&lt;span&gt;=&quot;Expander&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;Hidden&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DataTrigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Trigger &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;HasItems&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Visibility&quot;&lt;/span&gt;&lt;span&gt; TargetName&lt;/span&gt;&lt;span&gt;=&quot;Expander&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;Collapsed&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Trigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Trigger &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;IsExpanded&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Visibility&quot;&lt;/span&gt;&lt;span&gt; TargetName&lt;/span&gt;&lt;span&gt;=&quot;ItemsHost&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;Collapsed&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Trigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Trigger &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;IsSelected&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Background&quot;&lt;/span&gt;&lt;span&gt; TargetName&lt;/span&gt;&lt;span&gt;=&quot;itemBackground&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;#FAE388&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Trigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MultiTrigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MultiTrigger.Conditions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Condition &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;IsFocused&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Condition &lt;/span&gt;&lt;span&gt;SourceName&lt;/span&gt;&lt;span&gt;=&quot;itemBackground&quot;&lt;/span&gt;&lt;span&gt; Property&lt;/span&gt;&lt;span&gt;=&quot;IsMouseOver&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;MultiTrigger.Conditions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Background&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot; #fceeb9&quot;&lt;/span&gt;&lt;span&gt; TargetName&lt;/span&gt;&lt;span&gt;=&quot;itemBackground&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;MultiTrigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Trigger &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;IsEnabled&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Foreground&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{DynamicResource {x:Static SystemColors.GrayTextBrushKey}}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Trigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ControlTemplate.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ControlTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TreeView样式代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Style &lt;/span&gt;&lt;span&gt;x:Key&lt;/span&gt;&lt;span&gt;=&quot;DefaultTreeView&quot;&lt;/span&gt;&lt;span&gt; TargetType&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:Type TreeView}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;ScrollViewer.CanContentScroll&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;VirtualizingStackPanel.IsVirtualizing&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;VirtualizingStackPanel.VirtualizationMode&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;Recycling&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;ScrollViewer.IsDeferredScrollingEnabled&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;ItemContainerStyle&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{StaticResource DefaultTreeViewItem}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Padding&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;ItemsPanel&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ItemsPanelTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VirtualizingStackPanel &lt;/span&gt;&lt;span&gt;IsItemsHost&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ItemsPanelTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.3、转换器代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IndentConverter : IValueConverter
    {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Convert(&lt;span&gt;object&lt;/span&gt; value, Type targetType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; parameter, CultureInfo culture)
        {
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; colunwidth = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; left = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;


            UIElement element &lt;/span&gt;= value &lt;span&gt;as&lt;/span&gt;&lt;span&gt; TreeViewItem;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (element.GetType() != &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TreeView))
            {
                element &lt;/span&gt;=&lt;span&gt; (UIElement)VisualTreeHelper.GetParent(element);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (element.GetType() == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(TreeViewItem))
                    left &lt;/span&gt;+=&lt;span&gt; colunwidth;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Thickness(left, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; ConvertBack(&lt;span&gt;object&lt;/span&gt; value, Type targetType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; parameter, CultureInfo culture)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BoolToVisible : IValueConverter
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Convert(&lt;span&gt;object&lt;/span&gt; value, Type targetType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; parameter, CultureInfo culture)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((&lt;span&gt;bool&lt;/span&gt;&lt;span&gt;)value)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Visibility.Visible;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Visibility.Collapsed;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; ConvertBack(&lt;span&gt;object&lt;/span&gt; value, Type targetType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; parameter, CultureInfo culture)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; VisibleToReverse : IValueConverter
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Convert(&lt;span&gt;object&lt;/span&gt; value, Type targetType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; parameter, CultureInfo culture)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((Visibility)value ==&lt;span&gt; Visibility.Visible)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Visibility.Collapsed;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Visibility.Visible;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; ConvertBack(&lt;span&gt;object&lt;/span&gt; value, Type targetType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; parameter, CultureInfo culture)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.4、引用示例&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TreeView &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;TreeViewOrg&quot;&lt;/span&gt;&lt;span&gt; BorderThickness&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; BorderBrush&lt;/span&gt;&lt;span&gt;=&quot;#BBB&quot;&lt;/span&gt;&lt;span&gt; Background&lt;/span&gt;&lt;span&gt;=&quot;Transparent&quot;&lt;/span&gt;&lt;span&gt; Width&lt;/span&gt;&lt;span&gt;=&quot;280&quot;&lt;/span&gt;&lt;span&gt; Height&lt;/span&gt;&lt;span&gt;=&quot;500&quot;&lt;/span&gt;&lt;span&gt; Margin&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt; ItemTemplate&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{StaticResource ItemNode}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Style&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{StaticResource DefaultTreeView}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TreeView&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.5、初始化数据源及绑定对象&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MainWindow()
        {
            InitializeComponent();
            OrgList &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ObservableCollection&amp;lt;OrgModel&amp;gt;&lt;span&gt;()
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrgModel()
                {
                    IsGrouping&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    DisplayName&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;单位名称(3/7)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Children&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ObservableCollection&amp;lt;OrgModel&amp;gt;&lt;span&gt;()
                    {
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrgModel(){
                            IsGrouping&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                            DisplayName&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;未分组联系人(2/4)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                            Children&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; ObservableCollection&amp;lt;OrgModel&amp;gt;&lt;span&gt;()
                            {
                                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrgModel(){
                                    IsGrouping&lt;/span&gt;=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                                    SurName&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;刘&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                    Name&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;刘棒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                    Info&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我要走向天空！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                    Count&lt;/span&gt;=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
                                }
                            }
                        }
                    },
                }

            };
            TreeViewOrg.ItemsSource &lt;/span&gt;=&lt;span&gt; OrgList;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ObservableCollection&amp;lt;OrgModel&amp;gt; OrgList { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrgModel
        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsGrouping { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ObservableCollection&amp;lt;OrgModel&amp;gt; Children { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DisplayName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SurName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Info { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Count { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 16 Apr 2018 15:19:00 +0000</pubDate>
<dc:creator>小明GG</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaomingg/p/8765802.html</dc:identifier>
</item>
<item>
<title>老刘 Yii2 源码学习笔记之 Component 类 - 掸尘</title>
<link>http://www.cnblogs.com/liuzhang/p/8857544.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuzhang/p/8857544.html</guid>
<description>&lt;h2&gt; 类图关系&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/353089/201804/353089-20180416181800962-1354274428.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 属性与方法&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
class Component extends BaseObject
{
    
    private $_events = [];
    private $_eventWildcards = [];
    private $_behaviors;

    
    public function __get($name)
    public function __set($name, $value)
    public function __isset($name)
    public function __unset($name)
    public function __call($name, $params)
    public function __clone()

    
    public function hasProperty($name, $checkVars = true, $checkBehaviors = true)
    public function canGetProperty($name, $checkVars = true, $checkBehaviors = true)
    public function canSetProperty($name, $checkVars = true, $checkBehaviors = true)
    public function hasMethod($name, $checkBehaviors = true)
    public function behaviors()
    public function hasEventHandlers($name)
        
    public function on($name, $handler, $data = null, $append = true)
    public function off($name, $handler = null)
    public function trigger($name, Event $event = null)
    public function getBehavior($name)
    public function getBehaviors()
    public function attachBehavior($name, $behavior)
    public function attachBehaviors($behaviors)
    public function detachBehavior($name)
    public function detachBehaviors()
    public function ensureBehaviors()
    private function attachBehaviorInternal($name, $behavior)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了className() 方法，BaseObject 父类的方法已经全部重写，因为 BaseObject 只是一个单独的基类，Component 类与 Event 和 Behavior 有更复杂的关联。&lt;/p&gt;
&lt;h2&gt; 事件&lt;/h2&gt;
&lt;p&gt; 事件的代码可以先看 on 方法。[$handler, $data] 数组 0 是 handler  2 是 data 参数 &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
    /**
     * @param $name 事件名称
     * @param $handler 处理回调
     * @param null $data 参数
     * @param bool $append 是否追加
     */
    public function on($name, $handler, $data = null, $append = true)
    {
        //初始化行为
        $this-&amp;gt;ensureBehaviors();

        if (strpos($name, '*') !== false) {
            if ($append || empty($this-&amp;gt;_eventWildcards[$name])) {
                $this-&amp;gt;_eventWildcards[$name][] = [$handler, $data];
            } else {
                array_unshift($this-&amp;gt;_eventWildcards[$name], [$handler, $data]);
            }
            return;
        }
        // 如果已经存在事件名称追加
        if ($append || empty($this-&amp;gt;_events[$name])) {
            $this-&amp;gt;_events[$name][] = [$handler, $data];
        } else {
            array_unshift($this-&amp;gt;_events[$name], [$handler, $data]);
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 事件的执行，下面的代码可以看到 如果 $event 为 NULL， 会 new Event， 并设置 sender 属性为当前 类， $event-&amp;gt;data 为 on 的data 参数，  方法的最后一行， Event::trigger($this, $name, $event)  会执行类级别的事件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
 public function trigger($name, Event $event = null)
    {
        $this-&amp;gt;ensureBehaviors();

        $eventHandlers = [];
        foreach ($this-&amp;gt;_eventWildcards as $wildcard =&amp;gt; $handlers) {
            if (StringHelper::matchWildcard($wildcard, $name)) {
                $eventHandlers = array_merge($eventHandlers, $handlers);
            }
        }

        if (!empty($this-&amp;gt;_events[$name])) {
            $eventHandlers = array_merge($eventHandlers, $this-&amp;gt;_events[$name]);
        }

        if (!empty($eventHandlers)) {
            if ($event === null) {
                $event = new Event();
            }
            if ($event-&amp;gt;sender === null) {
                $event-&amp;gt;sender = $this;
            }
            $event-&amp;gt;handled = false;
            $event-&amp;gt;name = $name;
            foreach ($eventHandlers as $handler) {
                $event-&amp;gt;data = $handler[1];
                call_user_func($handler[0], $event);
                // stop further handling if the event is handled
                if ($event-&amp;gt;handled) {
                    return;
                }
            }
        }

        // invoke class-level attached handlers
        Event::trigger($this, $name, $event);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以举个例子, 可以看一下，全部都执行了，可以把 $event 打印一下看一下data&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
namespace app\events;
use yii\base\Event;

class MyEvent extends Event {
    public $message;

    function __construct($message)
    {
        parent::__construct();
        $this-&amp;gt;message = $message;
    }
}


class SiteController extends Controller
{
    const EVENT_TEST = 'test';

    /**
     * {@inheritdoc}
     */
    function init()
    {
        parent::init(); // TODO: Change the autogenerated stub
        $this-&amp;gt;on(self::EVENT_TEST, [new \app\models\EventTest(), 'add'],  ['a', 'b']);
        Event::on(SiteController::className(), self::EVENT_TEST,  function () { echo 'class level event';});
    }&lt;br/&gt;public function actionTest()
    {
        $event = new MyEvent('implements');
        $this-&amp;gt;trigger(self::EVENT_TEST, $event);
        echo 'done';
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;  行为&lt;/h2&gt;
&lt;p&gt; 使用行为（behavior）可以在不修改现有类的情况下，对类的功能进行扩充。 通过将行为绑定到一个类，可以使类具有行为本身所定义的属性和方法，就好像类本来就有这些属性和方法一样。 而且不需要写一个新的类去继承或包含现有类。把行为注入到类中。举个例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
class MyClass extends yii\base\Component
{
    // 空的
}

// Step 2: 定义一个行为类，他将绑定到MyClass上
class MyBehavior extends yii\base\Behavior
{
    // 行为的一个属性
    public $property1 = 'This is property in MyBehavior.';

    // 行为的一个方法
    public function method1()
    {
        return 'Method in MyBehavior is called.';
    }
}

$myClass = new MyClass();
$myBehavior = new MyBehavior();

// Step 3: 将行为绑定到类上
$myClass-&amp;gt;attachBehavior('myBehavior', $myBehavior);

// Step 4: 访问行为中的属性和方法，就和访问类自身的属性和方法一样
echo $myClass-&amp;gt;property1;
echo $myClass-&amp;gt;method1();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上是怎么做到呢， 可以看 Component  里的魔术方法 set、get、call ，对行为对象的属性和方法进行了注入。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
public function __get($name)
{
    //其他省略
    // behavior property
    $this-&amp;gt;ensureBehaviors();
    foreach ($this-&amp;gt;_behaviors as $behavior) {
        if ($behavior-&amp;gt;canGetProperty($name)) {
            return $behavior-&amp;gt;$name;
        }
    }
    //其他省略
}

public function __set($name, $value)
{
    //其他省略
    // behavior property 
    $this-&amp;gt;ensureBehaviors();
    foreach ($this-&amp;gt;_behaviors as $behavior) {
        if ($behavior-&amp;gt;canSetProperty($name)) {
            $behavior-&amp;gt;$name = $value;
            return;
        }
    }
    //其他省略
}

public function __call($name, $params)
{
    $this-&amp;gt;ensureBehaviors();
    foreach ($this-&amp;gt;_behaviors as $object) {
        if ($object-&amp;gt;hasMethod($name)) {
            return call_user_func_array([$object, $name], $params);
        }
    }
    throw new UnknownMethodException('Calling unknown method: ' . get_class($this) . &quot;::$name()&quot;);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; Behavior 类中可以绑定事件, 如下面的代码,继承 Behavior并设置 events 属性. &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
public function attach($owner)
    {
        $this-&amp;gt;owner = $owner;
        foreach ($this-&amp;gt;events() as $event =&amp;gt; $handler) {
            $owner-&amp;gt;on($event, is_string($handler) ? [$this, $handler] : $handler);
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举个具体的例子,下面的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
namespace app\component;

use Yii;
use yii\base\Controller;
use yii\base\Behavior;

class MyBehavior extends Behavior
{
    public $param;

    public function events()
    {
        return [
            Controller::EVENT_BEFORE_ACTION =&amp;gt; 'handlerBeforeAction'
        ];
    }

    public function handlerBeforeAction()
    {
        echo '由行为注册的组件事件, 执行 beforeAction &amp;lt;br&amp;gt;';
    }

    public function behaviorMethod()
    {
        echo '行为中的定义的方法';
    }
}


namespace app\controllers;

use Yii;
use yii\web\Controller;
use app\component\MyBehavior;



/**
 * Class  CurdController
 * @package app\controllers
 */
class BehaviorController extends Controller
{
    public function behaviors()
    {
        return [
            'access' =&amp;gt; [
                'class' =&amp;gt; MyBehavior::className(),
                'param' =&amp;gt; 'behavior param'
            ]
        ];
    }


    public function actionIndex()
    {
        echo '行为中的属性: '.$this-&amp;gt;param.'&amp;lt;br&amp;gt;';
        $this-&amp;gt;behaviorMethod();
        echo '&amp;lt;br&amp;gt;';
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果为:&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
由行为注册的组件事件, 执行 beforeAction 
行为中的属性: behavior param
行为中的定义的方法
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;行为设计灵活,  遵循设计原则对修改关闭,对扩展开放. 行为与 &lt;a href=&quot;http://www.php.net/traits&quot;&gt;traits&lt;/a&gt; 区别可以参考文档核心概念. 行为的添加删除具体可以阅读类里面的详细内容.&lt;/p&gt;
&lt;h2&gt; 属性&lt;/h2&gt;
&lt;p&gt;属性的设置可以参考魔术方法 set 和 get, 非常方便的像调用属性一样调用方法.&lt;/p&gt;
</description>
<pubDate>Mon, 16 Apr 2018 15:04:00 +0000</pubDate>
<dc:creator>掸尘</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuzhang/p/8857544.html</dc:identifier>
</item>
</channel>
</rss>