<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>街头智慧 | 经验性科学的梳理 - kid551</title>
<link>http://www.cnblogs.com/kid551/p/8455133.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kid551/p/8455133.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/672506/201802/672506-20180220133401370-556440311.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;终于知晓自己在不确定性的商业中看到的是什么了，也逐渐清楚自己在数学建模上的劣质表现是为何。本质来说，这是实验学科同理论学科在研究方法上的本质差别。&lt;/p&gt;


&lt;p&gt;对于实验学科来说，最重要的能力是探索中的“猜”，是能够在复杂无规律的现象中总结出、洞察出一些线索，并以此为基础开展工作，建立联系和理论。&lt;/p&gt;
&lt;p&gt;而对理论研究如数学来讲，其侧重点是梳理逻辑，或者说对逻辑形态的精准、严格的构建，其目标是将已知的内容，按照数学严密的逻辑要求做展现。从数学历史来看，非欧几何的建立、广义函数论的成熟，无一不是从已经运用娴熟的物理化学计算中，做重新的梳理和严密数学根基的建立。更极端的，整个现代概率论的基础，其核心并不是去发现新的概率现象，而是从集合论出发，去重新构建整个概率大厦。本质来看，这正是对“逻辑形式”的注重。是为了完成数学意义下的逻辑严密形态而做出的工作。&lt;/p&gt;


&lt;p&gt;可对实验科学来讲，或者说对于整个商业来讲，其目标不是追求逻辑的严密与精美，而是追求能够在混乱的现象和支离破碎的论断中，看出规律，对纷繁的现象和结论做出取舍，弄清楚应该自己应该关注的重点是什么。&lt;/p&gt;
&lt;p&gt;而这样的能力，可以在数学建模中得到体现，或者在真正的数据分析中得以体现。曾经很吃惊，为何自己的数学理论做得很好，却对数学建模一筹莫展？原因是：这是两项不同本质和且需要不同训练能力的活动。那种街头智慧，能在破碎现象面前，做局部地偏见性猜测。&lt;/p&gt;
&lt;p&gt;这种局部性的偏见猜测，是在未知领域里做探索的重要工具。不同于普通场景下追求完美的惯性思维，面对未知，找到一个带有偏见的甚至是错误的落脚点做开始，远远比等待严密性出现的坐以待毙要有用得多。&lt;/p&gt;


&lt;p&gt;在支离破碎中展现其充分的想象力和联想力，是探索和挖掘的另一个关键。面对残破的还未建立起来的体系，你如何去“知晓”两种现象是可以被拖拽到一起，形成一个关联？依靠逻辑吗？可这时候整个逻辑框架都还未成形，又如何去做逻辑推演呢？&lt;/p&gt;
&lt;p&gt;也即是，此刻的你根本无法运用逻辑这一工具，但却不得不“犹如得到上天指示”一般，将貌似毫不相关的东西放到一起。这其实依靠的是你的想象力与创造力。它才是“发现”的精髓。&lt;/p&gt;
&lt;p&gt;通过丰富的经验积累和长期的观察，运用出色的想象力把不同的现象之间搭上桥，从而在新奇的组合中开创出新的东西。你在平日生活中越是注重训练自己的关联性想象，越是能够在发现和探索中处于优势。&lt;/p&gt;


&lt;p&gt;经验科学的“普遍复杂，少有普遍适用结论，主要实验方式是归纳而非逻辑演绎”的特点，几乎可以照搬用于描述商业。为什么说在商业中更加需要直觉，需要那种敏锐的嗅觉和街头智慧？正是因为这一特点：商业面对的现象极端复杂多变，刚完成一个结论的验证，所考察的对象就发生了改变。刚赚到一笔钱，下一个投资环境和经营形势便出现了分歧。&lt;/p&gt;
&lt;p&gt;这样的探索环境和数学面对的严密持久固定的理论体系是不同的。甚至你会不断地感到沮丧：如同在对抗海边的浮沙，刚做好一个城堡，便被海浪冲掉了。&lt;/p&gt;
&lt;p&gt;这种环境下的生存法不同于一般的常识，需要更多的细究。你需要更加灵活地做局部应对，需要通过猜测和联想来构建可以暂时落脚的跳板，然后以“风险对赌”为工具，去期待“概率上的盈利”，以此去逐步壮大自己的实力。&lt;/p&gt;
&lt;p&gt;而在做数学建模和数据分析时，其大概思维框架也是如此。你要在一篇茫茫数据中，看出点不同，看出点猫腻，那就需要你有一套特殊的探索方式。仅仅毫无方向地去胡乱猜测，就如同做概率上的网格搜索，效率极低。&lt;/p&gt;


&lt;p&gt;那到底应该如何去猜测，从哪些角度去猜测数据中蕴含的信息呢？这就需要&lt;strong&gt;有大牛的指导&lt;/strong&gt;，通关观摩大神的工作，以此来做逆向工程，弄清楚大神是以一种什么步调、原则和思维框架，在未知领域里做探索。这是你不断观摩大神论文、代码的关键所在。其核心不是去看他做出的优美结论，而是把自己安放在他的位置，去揣摩他的心思，进而发现他独有的探索数据、探索未知的视角和方式。只有掌握了这套经验式的、没有记录在书本上的技能，才能够以此作为跳板，去提升自己的分析能力和探索能力。&lt;/p&gt;
&lt;p&gt;同样的，在商业上、在投资领域，你面对的依旧是复杂和不确定性所构成的世界，并且这个世界的代价更加难以承受。你的一个决策失误，足以让你倾家荡产，让你从富甲一方变成落魄草寇。在这样的环境下，获得在丛林中的生存技能变得极端迫切！而获取方式同样是“在实践和摸爬滚打中逐步前行”。&lt;/p&gt;
&lt;p&gt;但是在这样的摸索中，如果你缺乏大牛的指导，或者说你缺乏寻找大牛指的意识（例如上文说的研究和寻找大牛的工作，来实现被指导），你的摸索风险将变得极端巨大甚至随时可能丧失性命。你不能将风险的规避仅仅依赖于自身的顿悟，你还需要有历史的辅助。你要谨慎行事。&lt;/p&gt;
&lt;p&gt;通过“跟随一位大牛，做近距离的观摩、总结、揣测他的行事作风和思考方式，以此来逆向工程出他的生存技能”来控制风险。通过学习他人的错误来控制风险，而不是贸然行事，让自己去经历不可接受的错误。&lt;/p&gt;
&lt;p&gt;从这个角度来讲，涉足商业领域的屏障，便是那份得天独厚的“成长环境”。但是在利益作为核心的商业领域，又有谁愿意去指导和培养一位商业干才来同自己竞争，来瓜分自己的一杯羹呢？&lt;/p&gt;
&lt;p&gt;此时，如果你是商业家族的后代，便具备了一种先天优势，可以得到商业环境中生存的精髓。如果你恰好没有这样的出生，那就需要考虑通过辛勤的奋斗和良好的行事作风，在从事的行业里建立起良好信誉，通过与周围志同道合的人，做面对面的切磋与交流来实现互相指导。&lt;/p&gt;
&lt;p&gt;在实践性的经验领域，经验传播最重要的方式“是一同工作、一同切磋、一同交流”。而在理论领域中奉为圭臬的文本记录，却显得贫瘠而乏力。商人们会花费大量的时间去喝茶闲聊，就是希望可以在互相的交流中多吸收彼此用血换来的经验，来指导自己。&lt;/p&gt;
&lt;p&gt;这同世界各地的优秀实验室做定期的同行交流一样：构建一个良好经验交流环境，以达到互相促进在各自经验领域的成长而已。&lt;/p&gt;


&lt;p&gt;所以，在不同于理论研究的经验性科学里，你的重心便是：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;多在同行业中做交流，来促进彼此经验的累积和应用；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;多去研究行业大牛的工作、文章，以此逆向工程出大牛们的“探索、发现、筛选”准则，工作原则，以及行事方式；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;多在生活中培养自己猜测和联想的习惯，形成敏锐的洞察力和直觉，以此作为创造的基础。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;以上面的方式作为基础，不停地动手实验，甚至是，一直去做实验，一天的80%的时间去做实验。这份辛勤、不怕脏不怕累的动手能力，是一切成果的必要条件。要不停地、疯狂地在枯燥乏味、繁琐多变的多方案实验设计和实施中，去做工作。有了这样巨量的工作积累做保障，才有可能产生出为数不多的一些零星成果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;做！做！做！&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;近期回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484175&amp;amp;idx=1&amp;amp;sn=4d751dc8042f2800d3489aca0f299510&amp;amp;chksm=ec20e4b3db576da51a6325bb7dc322738d9dd716bfb71b6c591089f573e730adc27fdd8161ff&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;设计模式之“Decorator”注疏#02&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484167&amp;amp;idx=1&amp;amp;sn=1037b9b2b788d45909f9168bde2a5a4c&amp;amp;chksm=ec20e4bbdb576dad61bc8449ea58ca4d7bde734babe1e192b49d8ff181ad1dd7ad9f871aaab4&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;由阅读源码想到 | 下篇&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484162&amp;amp;idx=1&amp;amp;sn=09e32f3bb4deea92acc02a713b16ab63&amp;amp;chksm=ec20e4bedb576da823fa42563405b770828bb8680840ddf98b51fc9285d7b3a216d226be3494&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;由阅读源码想到&lt;/a&gt;》&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;如果你喜欢我的文章或分享，请长按下面的二维码关注我的微信公众号，谢谢！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxO9bdR9L0kttlgPe8JlGY87dGprLDyYXqdZWbhAxcETGrnWXCm3UgREhBG7DE3y9FknUCbYCUuuBg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; width=&quot;auto&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxO9bdR9L0kttlgPe8JlGY87dGprLDyYXqdZWbhAxcETGrnWXCm3UgREhBG7DE3y9FknUCbYCUuuBg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt; &lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;   &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;VIP赞赏专区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxM4uGL2UpKV92GZ6XjwDoShRKLD8ib7bibuGZVibkyhQ0At2IS64V9GX4ib91xibovBtibt7qicowFpvibP1Q/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; width=&quot;57%&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VJsh0SqOtxM4uGL2UpKV92GZ6XjwDoShRKLD8ib7bibuGZVibkyhQ0At2IS64V9GX4ib91xibovBtibt7qicowFpvibP1Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1152&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 05:36:00 +0000</pubDate>
<dc:creator>kid551</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kid551/p/8455133.html</dc:identifier>
</item>
<item>
<title>技术人生, 回顾2017 - 追梦子</title>
<link>http://www.cnblogs.com/pssp/p/8455116.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pssp/p/8455116.html</guid>
<description>&lt;h2 id=&quot;扯淡&quot;&gt;扯淡&lt;/h2&gt;
&lt;p&gt;一年又一年，过的真快，又到了做总结的日子了，回想过去的一年中，有迷茫，有收获，值得高兴的是收获更多一点。&lt;/p&gt;
&lt;p&gt;看了下&lt;a href=&quot;http://www.cnblogs.com/pssp/p/6136375.html&quot;&gt;2017年的总结&lt;/a&gt;，写的较多的是比较迷茫和抓不住重点，今年再看这两点，稍有了不错的提升，之前比较迷茫就在于要学的比较多，互联网技术更新较快，因此较为急躁，也花了很多时间在这上面，但成果很少，因为更多的是学习语法之类的，思考层面较少，写的东西没有用在解决实际问题上。&lt;/p&gt;
&lt;h2 id=&quot;走过的路&quot;&gt;2017走过的路&lt;/h2&gt;
&lt;p&gt;今年做的比较正确的一件事是换了家公司，如果不是换了公司，就没有这之后的总结，换的这家公司是BTA中的一个，以前总想去大公司看看，因为那里有最好的技术，更多的资源，现在算是实现了这个愿望，刚去的那一个多月压力很大，对很多东西都不太懂，甚至都不知道FE,RD,PM,QA这些名词是什么意思，不过这些名词倒不是大问题，重要的是要学会思维上的转变。&lt;/p&gt;
&lt;p&gt;在技术方面在这家公司学到的很少，不过值得一提的是我们前端leader，某次做了一个关于记录知识的分享，在那次我才真正知道记录的重要性，也使我在往后的日子里一直坚持记录&lt;/p&gt;
&lt;p&gt;这一年博客写的很少，一方面是写一篇博客需要的时间较多，一般在3个小时左右，另一方面是不想写较浅的文章，没有什么意义，不论是对自己还是其他人，最重要的一点是，我厌倦了现在的博客系统，我打算用新的方式来分享文章，做一个所有知识聚合平台，而公开的文章会被抽取出来，作为博客来分享(之后会分享此系统的架构，如果对知识管理感兴趣的可以关注下，很有意思，不过估计的到5，6月份了)&lt;/p&gt;
&lt;p&gt;这一年也做了很多有意思的东西，从最开始的mock后端数据，到webpack脚手架开发，再到知识管理系统，时间管理工具，这些真正让我体会到编程的乐趣，因为它们解决了我的实际问题，以及现实中的问题，而不是以前写的那些玩具，所谓的DEMO，这其中包括，从前端到后端的开发，再到桌面应用，在开发的过程中还学到了关于产品设计的一些东西，如果不去开发这些，我现在不会真正明白什么叫简洁，什么叫实用，什么叫少即是多，也真正体会到，只有真正喜欢一个产品，才能把它做好，因为一个好的产品就是不断的去改，不断的去完善，如果只是把它做出来，再也不去管它，那产品将是个废品，现在想来有多少人做了废品，却全然不知。&lt;/p&gt;
&lt;p&gt;因为在开发这些，所以才让我不再一味的去追求最新技术，因为真的没有时间和精力，更合适的说法是不漫无目的去学一个东西，更多的是遇到才去学，这样也就不再那么畏惧新知识了，反而知道每个知识的使用场景&lt;/p&gt;
&lt;p&gt;另一个值得高兴的是坚持了一年多写日记，虽然没能每天都记，但至少坚持了下来，不容易啊，话说至从学会记录开始，很多事都坚持去完成了，如果放在没有记录以前，往往出现的情况是，由于某段时间比较繁忙，之前捣鼓的事就不了了之了，这种事真是多如牛毛&lt;/p&gt;
&lt;p&gt;还有一件我认为对今后的发展有重大意义，在前段时间，我明白过来一件事，那就是不要因为自己的角色，或者领导没叫你去做，而始终弄着自己那一分三亩地，之所以有这个想法，是因为我们团队最近招了一个刚大学毕业的，他虽然来公司不久，但他做的贡献绝对不比那些来公司1,2年的小，于是我在想，产生的这种差距在哪，我倒不认为是因为技术，因为团队内技术能力强的不是没有，后来想到的是，他做的东西都是为了解决实际问题，再者很多东西没有人让他去做，但他却做了，我想这是让他变得优秀的关键原因&lt;/p&gt;
&lt;p&gt;如果发现可以去做的，永远不要等别人来说，因为没有人会喊着让你做，再者你不去做，总有人会去做，但如果你去做了，只会变得更优秀&lt;/p&gt;
&lt;p&gt;下半年的时候本想去翻译html5.2，但没坚持下来，因为后来觉得翻译这东西没啥意思，技术更新太快，往往是翻译的跟不上官方的速度，所以觉得还是官方的比较好，看不懂也可以用翻译，虽不是很准但也可以看懂个大概，勉强接受&lt;/p&gt;
&lt;h2 id=&quot;目标&quot;&gt;2018目标&lt;/h2&gt;
&lt;p&gt;2018的主要目标是把知识管理系统完善，以及时间管理工具v2的开发，还有团队内的基础服务开发&lt;/p&gt;
&lt;p&gt;2019再见&lt;/p&gt;
&lt;p&gt;写于2018.02.15&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 05:29:00 +0000</pubDate>
<dc:creator>追梦子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pssp/p/8455116.html</dc:identifier>
</item>
<item>
<title>应用负载均衡之LVS(二)：VS_TUN和VS_DR的arp问题 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8455004.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8455004.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8455004.html#blog1&quot;&gt;&lt;span&gt;1. ARP协议简介&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8455004.html#blog2&quot;&gt;&lt;span&gt;2. arp_ignore和arp_announce变量的作用分析&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8455004.html#blog2.1&quot;&gt;&lt;span&gt;2.1 arp_ignore&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8455004.html#blog2.2&quot;&gt;&lt;span&gt;2.2 arp_announce&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8455004.html#blog3&quot;&gt;&lt;span&gt;3. 设置arp_ignore和arp-announce&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-arp-&quot;&gt;1. ARP协议简介&lt;/h2&gt;
&lt;p&gt;ARP(Address Resolution Protocol)协议称为&lt;span&gt;&lt;strong&gt;地址解析协议&lt;/strong&gt;&lt;/span&gt;，用于将主机IP地址解析为主机的MAC地址，即&lt;code&gt;IP&amp;lt;--&amp;gt;MAC&lt;/code&gt;之间一一映射。RARP协议相反，是将MAC地址解析为IP地址。&lt;/p&gt;
&lt;p&gt;ARP解析时分两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;解析目标和自己在同一网段。&lt;br/&gt;A解析同网段的B，A根据自己的IP和子网掩码判断B和自己同网段，这时A就直接在这个网段上发一个ARP广播包寻求B的MAC地址，所有人都收到广播信息，但是B会将MAC地址回应给A，A缓存B的MAC地址。&lt;/li&gt;
&lt;li&gt;解析目标和自己不在同一网段。&lt;br/&gt;A根据自己的IP和子网掩码判断出B和自己不在同一个网段，这时A就向自己的网段发送一个ARP广播包用来解析网关的MAC地址，也就是路由器的接口MAC地址，然后路由器回应，A缓存回应的MAC结果。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当发送ARP请求广播后，目标设备会进行应答，其中请求数据包和应答数据包的格式非常接近。以下是请求包和应答包数据格式的&lt;strong&gt;一&lt;span&gt;部分&lt;/span&gt;&lt;/strong&gt;，完整格式请百度或者翻阅TCP/IP协议卷(一)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733013/201802/733013-20180214201459999-683308506.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;op字段是一个1-4的值，1表示该数据帧是ARP请求包，2表示该数据帧是ARP应答包，3和4则表示RARP的请求和应答包。&lt;/li&gt;
&lt;li&gt;src_MAC和src_IP是数据帧中的源MAC和源IP地址。这两个字段的值不一定是对应的，意思是src_IP不一定配置在src_MAC地址的接口上。&lt;/li&gt;
&lt;li&gt;dest_MAC和dest_IP则是目标MAC地址和目标IP地址。对于ARP请求包，dest_MAC值为&quot;ff:ff:ff:ff:ff:ff&quot;，表示这是广播包。同样，这两个字段的值也并非是对应的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当发送ARP请求广播包时，op的值设置为1，目标MAC设置为广播地址&quot;ff:ff:ff:ff:ff:ff&quot;，然后在局域网内广播，这是在询问&quot;who has DEST_IP&quot;。每台主机都能收到该广播包，但只有设置了目标IP的主机才会应答：&quot;Reply DEST_IP is-at DEST_MAC&quot;。应答时使用单播包进行回应，会将op值改为2，表示这是应答包，同时将应答的MAC地址替换原来的&quot;ff:ff:ff:ff:ff:ff&quot;，并将src和dest的字段位置进行调换。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733013/201802/733013-20180214203925937-409086845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;当响应者接收到请求者的ARP请求时，它会将请求包中的源MAC和源IP缓存到ARP缓存表中。当请求者接收到响应者的应答包时，它会将应答包中的源MAC地址和源IP地址缓存到ARP缓存表中。也就是说，一次arp请求，会让两端主机都缓存对方的IP和MAC地址。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用ping命令或其他TCP连接时，两端都会缓存对方的ARP条目。但为了测试，可以手动使用arping命令发送一个自定义源MAC和源IP的arp请求让对方缓存自己的IP和MAC。&lt;/p&gt;
&lt;p&gt;假如主机A上有eth0(192.168.100.54)和eth1两网卡，主机B有eth0(192.168.100.70)。下面的命令表示，在主机A上向主机B发送一个arp广播包(如果&quot;-c N&quot;的N大于1，则只有第一个请求包是广播，其他是单播)，其中源MAC为eth1网卡的MAC，但源IP为eth0上的IP地址192.168.100.54。这会使得主机B缓存的arp条目为&lt;code&gt;192.168.100.54&amp;lt;--&amp;gt;eth1_MAC&lt;/code&gt;，但实际上这并非正确的映射关系。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;arping&lt;/span&gt; -c &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; -I eth1 src &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.54&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.70&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有些程序可以检测到IP地址冲突的现象。典型的如DHCP服务器准备提供IP地址给客户端之前，会发送一个arp广播，以便确认该IP地址是否已被其他主机使用(例如其他主机使用静态IP时手动输入了该IP)。如果没有收到回应，则表示该IP地址没有被使用，可以提供给客户端使用，如果收到了回应，则表示该IP地址已经被使用了，DHCP会从IP池中换一个IP提供给客户端。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;arp -a&lt;/code&gt;命令可以显示arp缓存表的内容，&lt;code&gt;arp -d ADDR&lt;/code&gt;可以删除ARP缓存表中某条ARP记录，这两命令对于Windows和Linux系统都可用。此外，对于Windows，&lt;code&gt;arp -d *&lt;/code&gt;表示删除arp缓存表中的所有记录，对于Linux，则使用&lt;code&gt;ip neigh flush all&lt;/code&gt;命令来删除arp缓存中所有记录。&lt;/p&gt;
&lt;p&gt;注意，无论是arp请求还是arp应答，都带有完整的源MAC、源IP、目标MAC和目标IP。这看似一句废话，但不熟知arp请求的人很容易因此而陷入困惑。&lt;/p&gt;

&lt;h2 id=&quot;2-arp_ignore-arp_announce-&quot;&gt;2. arp_ignore和arp_announce变量的作用分析&lt;/h2&gt;
&lt;p&gt;在设置VS/TUN和VS/DR时，需要设置到这两个arp相关的内核变量，所以这里先解释解释。&lt;/p&gt;
&lt;p&gt;前文已经说明了arp请求包或应答包中，MAC地址可以和IP地址不对应。这样一来就出现问题了，ARP请求包中，使用哪个源IP地址以及哪个源MAC地址？ARP应答包中，使用哪个源MAC和源IP地址(注意，应答包中源IP地址并不一定是请求包中的目标IP，可能会更换为本机的其他IP地址)？&lt;/p&gt;
&lt;p&gt;arp_ignore和arp_announce这两个变量的作用正是设置使用哪个源IP和哪个源MAC。其中&lt;span&gt;&lt;strong&gt;arp_ignore设置的是收到请求包后，在应答包中将本机的哪个IP地址和MAC地址回应给请求者以供缓存；arp_announce设置的是发出请求包时，选择哪个IP和MAC地址供响应者缓存&lt;/strong&gt;&lt;/span&gt;，这也符合announce的字面意思：向外通告本机的哪个IP地址和MAC地址供其他主机缓存。&lt;/p&gt;
&lt;p&gt;它们的作用如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/733013/201802/733013-20180214214923593-1336016880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来细看arp_ignore和arp_announce的介绍。&lt;/p&gt;

&lt;h3 id=&quot;2-1-arp_ignore&quot;&gt;2.1 arp_ignore&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;arp_ignore - INTEGER
    Define different modes for sending replies in response to
    received ARP requests that resolve local target IP addresses:
    0 - (default): reply for any local target IP address, configured
    on any interface
    1 - reply only if the target IP address is local address
    configured on the incoming interface
    2 - reply only if the target IP address is local address
    configured on the incoming interface and both with the
    sender's IP address are part from same subnet on this interface
    3 - &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; reply &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; addresses configured &lt;span class=&quot;hljs-keyword&quot;&gt;with&lt;/span&gt; scope host,
    &lt;span class=&quot;hljs-keyword&quot;&gt;only&lt;/span&gt; resolutions &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; link addresses &lt;span class=&quot;hljs-keyword&quot;&gt;are&lt;/span&gt; replied
    &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt; - reserved
    &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt; - &lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; reply &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; addresses

    The &lt;span class=&quot;hljs-keyword&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; conf/{&lt;span class=&quot;hljs-keyword&quot;&gt;all&lt;/span&gt;,interface}/arp_ignore &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; used
    &lt;span class=&quot;hljs-keyword&quot;&gt;when&lt;/span&gt; ARP request &lt;span class=&quot;hljs-keyword&quot;&gt;is&lt;/span&gt; received &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; the {interface}&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大致翻译一下：&lt;/p&gt;
&lt;p&gt;该变量接受一个整数值。定义的是&lt;span&gt;&lt;strong&gt;当本机接收到别的主机发送的ARP请求时的不同应答模式：回应哪个IP和MAC地址给请求者。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0 - (default):将本机所有非lo接口的IP地址都回应出去。&lt;/li&gt;
&lt;li&gt;1 - 只有当ARP请求中的目标IP地址配置在流入接口上时才响应。&lt;/li&gt;
&lt;li&gt;2 - 只有当ARP请求中的目标IP地址配置在流入接口上时，且该IP地址是接口地址上的子网地址时才响应(例如192.168.100.10/24和192.168.100.10/16的关系)。&lt;/li&gt;
&lt;li&gt;3 - do not reply for local addresses configured with scope host, only resolutions for global and link addresses are replied。&lt;/li&gt;
&lt;li&gt;4-7 - 保留&lt;/li&gt;
&lt;li&gt;8 - 不回应任意地址。&lt;/li&gt;
&lt;li&gt;当某接口接收到ARP请求时，&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子来解释值为0和1的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1)arp_ignore=0时，当主机收到arp请求时，会将本机任意可能的IP地址都应答给arp请求者。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，主机A有3个网卡，eth0(192.168.100.17/24)，eth1(192.168.100.36/24)和eth2(172.16.10.10/16)，主机B有网卡eth0(192.168.100.39)。当主机B发起对192.168.100.36或17的ping时，由于主机A回应icmp响应给主机B时，默认情况下有以下路由：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@xuexi&lt;/span&gt; ~]
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;         &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.2&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;         UG    &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; eth&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;         &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.2&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;         UG    &lt;span class=&quot;hljs-number&quot;&gt;101&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; eth1
&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;         &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.2&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;         UG    &lt;span class=&quot;hljs-number&quot;&gt;102&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; eth2
&lt;span class=&quot;hljs-number&quot;&gt;172.16&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;         &lt;span class=&quot;hljs-number&quot;&gt;255.255&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;     U     &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; eth2
&lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;         &lt;span class=&quot;hljs-number&quot;&gt;255.255&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;255.0&lt;/span&gt;   U     &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;      &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; eth&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.0&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;         &lt;span class=&quot;hljs-number&quot;&gt;255.255&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;255.0&lt;/span&gt;   U     &lt;span class=&quot;hljs-number&quot;&gt;101&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; eth1
&lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.2&lt;/span&gt;   &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;         &lt;span class=&quot;hljs-number&quot;&gt;255.255&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;255.255&lt;/span&gt; UH    &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;    &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;        &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; eth2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时主机A会将eth0和eth1上的IP地址都应答给主机B，且这两个IP地址对应的MAC地址都是eth0(因为该接口是该网段的第一条路由出口)的MAC地址。以下是主机B上ping 192.168.100.36后的arp缓存表，如果结果不同，请&lt;code&gt;ip neigh flush all&lt;/code&gt;清空缓存表或者多等待一段时间再测试。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-attr_selector&quot;&gt;[root@xuexi ~]&lt;/span&gt;# &lt;span class=&quot;hljs-tag&quot;&gt;ip&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;s&lt;/span&gt; 
192&lt;span class=&quot;hljs-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.36&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;dev&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;eth0&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;lladdr&lt;/span&gt; 00&lt;span class=&quot;hljs-pseudo&quot;&gt;:0c&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:29&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:fb&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:dd&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:04&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;REACHABLE&lt;/span&gt;
192&lt;span class=&quot;hljs-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.1&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;dev&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;eth0&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;lladdr&lt;/span&gt; 00&lt;span class=&quot;hljs-pseudo&quot;&gt;:50&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:56&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:c0&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:00&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:08&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;REACHABLE&lt;/span&gt;
192&lt;span class=&quot;hljs-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.100&lt;/span&gt;&lt;span class=&quot;hljs-class&quot;&gt;.17&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;dev&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;eth0&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;lladdr&lt;/span&gt; 00&lt;span class=&quot;hljs-pseudo&quot;&gt;:0c&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:29&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:fb&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:dd&lt;/span&gt;&lt;span class=&quot;hljs-pseudo&quot;&gt;:04&lt;/span&gt; &lt;span class=&quot;hljs-tag&quot;&gt;STALE&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果将主机A上192.168.100.0 eth0的路由条目删除，则主机B ping 192.168.100.36时，主机A将不再把eth0(192.168.100.17)响应给主机B，尽管它可以使用eth1对应的路由出去。但如果主机B ping 192.168.100.17，那么也会将该地址响应出去，使用的源MAC地址也是eth1(因为路由出口为eth1)。因此，主机B只会缓存主机A的192.168.100.36 eth1_MAC。&lt;/p&gt;
&lt;p&gt;由此可知，所谓&lt;span&gt;&lt;strong&gt;响应任意可能的IP地址并不是响应所有地址&lt;/strong&gt;&lt;/span&gt;，lo接口、非同一网段地址以及无第一路由的接口地址就不会主动响应出去。同样，那些定义在接口上的别名地址也默认不会响应出去，因为它们的数据的流入流出都是通过它所依附的接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2)arp_ignore=1时，当主机收到arp请求时，只有arp请求包中目标IP和流入接口上的IP相同时，才会响应该IP以及该接口的MAC。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，设置eth0网卡的该变量值为1。不过，为了完善测试，先将上面示例中删除的路由条目添加回来。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;route&lt;/span&gt; add -net &lt;span class=&quot;hljs-number&quot;&gt;192.168.100.0&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;24&lt;/span&gt; dev eth0

echo &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;gt;/proc/sys/net/ipv4/conf/eth0/arp_ignore
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时主机B上ping 192.168.100.17时，主机A将只会响应eth0_MAC给主机B，&lt;span&gt;&lt;strong&gt;且ping 192.168.100.36时将ping不通(这一点需要注意，在后面配置LVS的arp参数时，外界主机往往只能ping通同网段的其中一个地址)&lt;/strong&gt;&lt;/span&gt;。以下是在主机B上ping 192.168.100.36时在主机A上抓取的数据包。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@xuexi&lt;/span&gt; ~]
tcpdump: verbose output suppressed, &lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; -v &lt;span class=&quot;hljs-keyword&quot;&gt;or&lt;/span&gt; -vv &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; full protocol decode
listening on eth&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;link&lt;/span&gt;-type EN10MB (Ethernet), capture size &lt;span class=&quot;hljs-number&quot;&gt;65535&lt;/span&gt; bytes
&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;21&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;51.739967&lt;/span&gt; ARP, Request who-has &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.36&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;tell&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.39&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;46&lt;/span&gt;
&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;21&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;52.739741&lt;/span&gt; ARP, Request who-has &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.36&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;tell&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.39&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;46&lt;/span&gt;
&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;21&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;53.739868&lt;/span&gt; ARP, Request who-has &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.36&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;tell&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.39&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;46&lt;/span&gt;
&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;21&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;55.742680&lt;/span&gt; ARP, Request who-has &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.36&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;tell&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.39&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;46&lt;/span&gt;
&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;21&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;56.743560&lt;/span&gt; ARP, Request who-has &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.36&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;tell&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.39&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;46&lt;/span&gt;
&lt;span class=&quot;hljs-number&quot;&gt;12&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;21&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;57.743086&lt;/span&gt; ARP, Request who-has &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.36&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;tell&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;100.39&lt;/span&gt;, &lt;span class=&quot;hljs-keyword&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;46&lt;/span&gt;
^C
&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt; packets captured
&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt; packets received by filter
&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; packets dropped by kernel
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果中可以看出，主机A收到目标IP为192.168.100.36的ARP请求后，完全没有对其给出响应动作。因为主机B发出的ARP请求包到达主机A时的流入接口为eth0，而192.168.100.36并不是配置在eth0上，由于eth0的arp_ignore=1，所以不会应答对192.168.100.36的arp请求，主机B也就不知道192.168.100.36的MAC地址，从而无法与A主机通信。&lt;/p&gt;
&lt;p&gt;这里的关键是主机A上ARP请求的流入接口是eth0而不是eth1，尽管ping的目标是eth1:192.168.100.36。也就是说，只要eth0的arp_ignore=1，那么该主机上该网段的所有地址(除了配置在eth0上的IP)都无法与外界通信。&lt;/p&gt;
&lt;p&gt;之所以主机A上请求的流入接口是eth0而非eth1(此处eth0和eth1同网段)，这是主机A的路由表决定的。因此在arp请求过程中，路由表中路由的先后顺序非常重要，它不仅决定了数据从哪流入流出，还决定了流入、流出时使用哪个MAC地址，而这直接决定是否能成功ARP请求、ARP响应以及arp缓存的&lt;code&gt;IP&amp;lt;--&amp;gt;MAC&lt;/code&gt;映射结果。如果你在学习arp_ignore和arp_announce时做了很多测试，必然能体会到这一点。&lt;/p&gt;

&lt;h3 id=&quot;2-2-arp_announce&quot;&gt;2.2 arp_announce&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;arp_announce - INTEGER
    Define different restriction levels for announcing the local
    source IP address from IP packets in ARP requests sent on
    interface:
    0 - (default) &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;Use&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;any&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; address, configured &lt;span class=&quot;hljs-keyword&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;any&lt;/span&gt; interface
    &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; - Try &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; avoid &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; addresses that &lt;span class=&quot;hljs-keyword&quot;&gt;are&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; the target&lt;span class=&quot;hljs-string&quot;&gt;'s
    subnet for this interface. This mode is useful when target
    hosts reachable via this interface require the source IP
    address in ARP requests to be part of their logical network
    configured on the receiving interface. When we generate the
    request we will check all our subnets that include the
    target IP and will preserve the source address if it is from
    such subnet. If there is no such subnet we select source
    address according to the rules for level 2.
    2 - Always use the best local address for this target.
    In this mode we ignore the source address in the IP packet
    and try to select local address that we prefer for talks with
    the target host. Such local address is selected by looking
    for primary IP addresses on all our subnets on the outgoing
    interface that include the target IP address. If no suitable
    local address is found we select the first local address
    we have on the outgoing interface or on all other interfaces,
    with the hope we will receive reply for our request and
    even sometimes no matter the source IP address we announce.

    The max value from conf/{all,interface}/arp_announce is used.

    Increasing the restriction level gives more chance for
    receiving answer from the resolved target while decreasing
    the level announces more valid sender'&lt;/span&gt;s information.&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大致翻译一下：该变量接受一个整数值。它定义的是&lt;span&gt;&lt;strong&gt;当发送ARP请求时，在请求数据包中填入的源IP地址和源MAC地址，它们是被响应者缓存的内容&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li&gt;0 - (default)可以使用本机上任意接口的任意地址。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;1 - 尽量不使用不在目标IP所在子网的地址。当目标主机可以通过该接口达到，但要求ARP数据包中的源IP地址是逻辑网络接口网段中的地址时，设置为该级别很有用。当生成ARP请求数据包时，将检测所有包含目标IP的子网(自身网段或子网都可以)，如果源IP地址处于该子网内，则使用该地址。如果没有包含该源IP地址的子网，则使用级别2(arp_announce=2)来处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;2 - 总是为目标地址寻找最佳本地地址作为ARP请求的源IP地址。这种模式下，将忽略源IP地址，而是尝试选择出能和目标IP最佳通信质量的IP地址。这个IP是通过寻找各流出接口上的主IP地址(primary IP，不能是secondary IP)得到的，它需要和目标IP地址在同网段或属于其子网内。如果没有选出合适的地址，将选择第一个流出接口上的IP地址，这样不仅可以接收到应答包，还能无视已经手动通告的源地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;稍微解释下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;arp_announce=0&lt;/code&gt;时，向外发送ARP请求时，很可能会使用流出接口的IP地址和MAC地址，这没有硬性限制。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arp_announce=1&lt;/code&gt;时，尽量使用与目标IP地址在同一子网的地址，例如目标IP地址为192.168.100.40/16，而本机有IP地址192.168.100.22/24，这个IP地址是目标IP地址子网内的一个地址，因此会尽量使用该地址作为ARP请求中的源IP地址，但是源MAC地址还是数据流出接口上的MAC。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arp_announce=1&lt;/code&gt;时，不管ARP请求包中指定的源IP地址是什么(因为ARP请求包中的源IP和源MAC可以手动指定)，总会在本地搜索出和目标IP最匹配的IP地址来作为源地址。它会优先选和目标IP同子网的本地IP，如果没有则选路由表中的第一个流出接口上的IP。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，如果Linux主机有3个网卡：eth0(IP0)、eth1(IP1)和eth2(IP2)。如果想通过eth2接口流出源地址为IP0的ARP请求广播包，默认情况下是行不通的。因为默认情况下，使用eth2流出ARP请求的源IP地址必须使用IP2。因此必须设置arp_announce=1或2，其实设置为1时也只是有机会流出，因为它要判断IP0和目标IP地址是否存在子网所属关系。只有设置arp_announce=2才必然能流出，但这时该Linux主机向外通告的IP地址将不是IP0，而是IP2。&lt;/p&gt;

&lt;h2 id=&quot;3-arp_ignore-arp_announce&quot;&gt;3.设置arp_ignore和arp_announce&lt;/h2&gt;
&lt;p&gt;Linux内核2.0.xx版本中，&lt;span&gt;&lt;strong&gt;回环接口、回环别名接口(如lo:0，lo:1)以及回环隧道接口&lt;/strong&gt;&lt;/span&gt;都不会做arp回应，对于LVS集群来说，这很方便。但从Linux 2.2.xx开始，除了&lt;span&gt;&lt;strong&gt;回环地址(127.0.0.0/8)和广播地址外&lt;/strong&gt;&lt;/span&gt;，其他所有地址(包括回环接口上的别名接口)都会做arp回应。因此，在这样的内核版本下配置LVS可能会出现一些问题。从Linux内核2.2.14开始，&lt;span&gt;&lt;strong&gt;提供了一个接口标记&quot;hidden&quot;用于从ARP广播中隐藏指定接口&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这意味着对于现在的CentOS6、CentOS7来说，虽然每个接口(包括lo接口)都可以设置这两个变量，但这两个变量只对能arp回应的接口才生效(如eth0,eth1等对外通信的普通接口)。也就是说，&lt;span&gt;&lt;strong&gt;在lo接口上设置arp_ignore、arp_announce等arp参数是没有意义的&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;尽管对lo接口设置arp参数没有意义，但为了保证lo和普通网卡、隧道设置方法的统一性，以及未来的内核可能对此做出改变，本文以及网上的文章还是对它进行了同样的设置。&lt;/p&gt;
&lt;p&gt;例如，设置lo接口的arp_ignore=1、arp_announce=2。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;echo &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/proc/sys&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/net/ipv&lt;/span&gt;4/conf/lo/arp_ignore
echo &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &amp;gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/proc/sys&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/net/ipv&lt;/span&gt;4/conf/lo/arp_announce
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在接口上设置了别名IP，例如eth0:0，由于它们仍然使用所依附的接口流入流出数据，因此在接口上设置arp_ignore和arp_announce对别名IP同样生效。&lt;/p&gt;
&lt;p&gt;其实，在/proc/sys/net/ipv4/conf下，除了各网卡接口的配置目录，还有default和all两个目录，这两个目录内关于arp参数的值只影响普通网卡，不影响lo接口，也没有意义去影响lo接口。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;[root&lt;span class=&quot;hljs-property&quot;&gt;@xuexi&lt;/span&gt; ~]
total &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
dr-xr-xr-x &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; root root &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; Feb &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;2018&lt;/span&gt; all
dr-xr-xr-x &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; root root &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; Feb &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;2018&lt;/span&gt; &lt;span class=&quot;hljs-reserved&quot;&gt;default&lt;/span&gt;
dr-xr-xr-x &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; root root &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; Feb &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;56&lt;/span&gt; eth0
dr-xr-xr-x &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; root root &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; Feb &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;56&lt;/span&gt; eth1
dr-xr-xr-x &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; root root &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; Feb &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;56&lt;/span&gt; lo
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;default目录中的变量值为普通网络接口提供初始化值(不影响lo接口)。这个目录其实没什么用，因为每次重启操作系统，/proc/sys下的设置都会失效，而直接设置该目录下的值又起不到提供初始化值的作用。之所以放在conf目录内是为了提示我们可以设置default属性的值。例如，向sysctl.conf中追加永久设置&lt;code&gt;net.ipv4.conf.default.arp_ignore=1&lt;/code&gt;，这样每次重启系统后各网卡接口的arp_ignore级别都是1(注意：普通网卡才生效，lo接口不受影响)。&lt;/li&gt;
&lt;li&gt;all目录中的变量作用范围是所有网卡(不包括lo接口)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于每个网卡来说，将比较all目录中的变量值和网卡自身的变量值，取较大值。例如：&lt;/p&gt;
&lt;p&gt;conf/eth0/arp_ignore值为1，conf/all/arp_ignore值为0，则对于eth0接口来说，arp_ignore=1。&lt;br/&gt;conf/lo/arp_announce值为0，conf/all/arp_announce值为2，则对于lo接口来说，arp_announce=0，因为all目录不影响lo接口。但最终，lo接口上设置的arp参数值是没有意义的。&lt;/p&gt;
&lt;p&gt;通常，VS/TUN和VS/DR模式下，Real Server上的VIP设置在lo的别名接口上(如lo:0上)，因此应该如下设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;echo &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/proc/sys&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/net/ipv&lt;/span&gt;4/conf/lo/arp_ignore
echo &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/proc/sys&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/net/ipv&lt;/span&gt;4/conf/all/arp_ignore
echo &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &amp;gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/proc/sys&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/net/ipv&lt;/span&gt;4/conf/lo/arp_announce
echo &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &amp;gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/proc/sys&lt;/span&gt;&lt;span class=&quot;hljs-regexp&quot;&gt;/net/ipv&lt;/span&gt;4/conf/all/arp_announce
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中生效的为第二条和第四条规则，第一条和第三条对lo接口的设置语句可有可无。&lt;/p&gt;
&lt;p&gt;将conf/all/arp_ignore设置为1，可以保证无论哪个对外通信的网卡接口都只会向外响应自己接口上的IP地址(甚至可能有些同网段的接口因为路由顺序排在后面而响应不出去)，这样就隐藏了设置在lo别名接口上的VIP地址。&lt;br/&gt;将conf/all/arp_announce设置为2，可以保证本机只向外通告普通网卡上的IP地址，lo别名接口上的VIP不可能被通告出去。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8455004.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8455004.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 04:05:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8455004.html</dc:identifier>
</item>
<item>
<title>WPF: WPF 中的 Triggers 和 VisualStateManager - WPInfo</title>
<link>http://www.cnblogs.com/wpinfo/p/wpf_triggers_vsm.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wpinfo/p/wpf_triggers_vsm.html</guid>
<description>&lt;p&gt;在之前写的这篇文章 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/wpinfo/p/readonly_dp.html&quot;&gt;WPF: 只读依赖属性的介绍与实践&lt;/a&gt; 中，我们介绍了在 WPF 自定义控件中如何添加只读依赖属性，并且使其结合属性触发器 (Trigger) 来实现对控件样式的改变。事实上，关于触发器，在 WPF 中除了属性触发器，还有事件触发器 (EventTrigger) 和数据触发器 (DataTrigger)。此外，为了控制控件外观的切换，除了可以使用触发器外，我们还可以使用 VisualStates 和 VisualStateManager 来完成。&lt;/p&gt;
&lt;p&gt;本文接下来会分别简单地介绍 Triggers 和 VisualStateManager，并且介绍一下它们的区别；了解这些，将会有助于我们在开发自定义控件时，能够明白何时选择属发器，何时选择 VisualStateManager。&lt;/p&gt;
&lt;h2&gt;一、触发器 (Triggers)&lt;/h2&gt;
&lt;p&gt;前面说过，触发器有三类，它们分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;属性触发器 (Trigger/MultiTrigger)&lt;/li&gt;
&lt;li&gt;事件触发器 (EventTrigger)&lt;/li&gt;
&lt;li&gt;数据触发器 (DataTrigger/MultiDataTrigger)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些触发器的主要作用是：当指定属性的值发生改变或者事件触发时来更改控件的外观或行为；而且被触发器监测的属性必须是依赖属性，事件必须是路由事件；它们能够用在这些地方：DataTemplate, ControlTemplate, Style, 以及控件的 Inline 属性中。&lt;/p&gt;
&lt;h3&gt;1、属性触发器&lt;/h3&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;UIElement 属性改变时，执行 Trigger；&lt;/li&gt;
&lt;li&gt;必须设置 Property 和 Value；必须包括 Setter 对象（不支持 EventSetter）；&lt;/li&gt;
&lt;li&gt;可以设置 EnterActions 和 ExitActions；&lt;/li&gt;
&lt;li&gt;当条件不符合时，会将属性值还原到原来的值 ；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Style &lt;/span&gt;&lt;span&gt;x:Key&lt;/span&gt;&lt;span&gt;=&quot;ButtonStyle&quot;&lt;/span&gt;&lt;span&gt; TargetType&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:Type Button}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Style.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Trigger &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;IsPressed&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Opacity&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;0.5&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Trigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Trigger &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;IsEnabled&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Foreground&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;Red&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Trigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Style.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;MultiTrigger&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;特点：元素 (UIElement) 或控件的多个属性改变时，执行 Trigger，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Style &lt;/span&gt;&lt;span&gt;x:Key&lt;/span&gt;&lt;span&gt;=&quot;MulitTriggerButtonStyle&quot;&lt;/span&gt;&lt;span&gt; TargetType&lt;/span&gt;&lt;span&gt;=&quot;Button&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Style.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MultiTrigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MultiTrigger.Conditions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Condition &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;IsPressed&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Condition &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Background&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;BlanchedAlmond&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;MultiTrigger.Conditions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MultiTrigger.Setters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Foreground&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;Blue&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;BorderThickness&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;BorderBrush&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;Blue&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;MultiTrigger.Setters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;MultiTrigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Style.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. 事件触发器&lt;/h3&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当 FrameworkElement 的路由事件(RouteEvent)触发时，执行 EventTrigger；&lt;/li&gt;
&lt;li&gt;通常用来执行一些动画；&lt;/li&gt;
&lt;li&gt;不会还原成原来的值（不像 Property Trigger 一样）；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border  &lt;/span&gt;&lt;span&gt;…&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;EventTrigger &lt;/span&gt;&lt;span&gt;RoutedEvent&lt;/span&gt;&lt;span&gt;=&quot;Mouse.MouseEnter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BeginStoryboard&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Storyboard&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColorAnimation &lt;/span&gt;&lt;span&gt;Duration&lt;/span&gt;&lt;span&gt;=&quot;0:0:1&quot;&lt;/span&gt;&lt;span&gt; Storyboard.TargetName&lt;/span&gt;&lt;span&gt;=&quot;MyBorder&quot;&lt;/span&gt;&lt;span&gt; 
                                Storyboard.TargetProperty&lt;/span&gt;&lt;span&gt;=&quot;Color&quot;&lt;/span&gt;&lt;span&gt; To&lt;/span&gt;&lt;span&gt;=&quot;Gray&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
               &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Storyboard&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;BeginStoryboard&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;EventTrigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. 数据触发器&lt;/h3&gt;
&lt;p&gt;特点：数据绑定源的值符合 Trigger 指定的条件时，执行 Trigger；例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DataTemplate.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DataTrigger &lt;/span&gt;&lt;span&gt;Binding&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Path=Picture}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:Null}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;TargetName&lt;/span&gt;&lt;span&gt;=&quot;viewImage&quot;&lt;/span&gt;&lt;span&gt; Property&lt;/span&gt;&lt;span&gt;=&quot;Source&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;/Images/noImage.png&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        ……
       &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DataTrigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DataTemplate.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;MultiDataTrigger&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;特点：当多个绑定值符合 Trigger 的 Conditions 指定的条件时，执行 Trigger；例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DataTemplate.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MultiDataTrigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MultiDataTrigger.Conditions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Condition &lt;/span&gt;&lt;span&gt;Binding&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Path=Picture}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:Null}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Condition &lt;/span&gt;&lt;span&gt;Binding&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Path=Title}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;Waterfall&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;MultiDataTrigger.Conditions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MultiDataTrigger.Setters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;TargetName&lt;/span&gt;&lt;span&gt;=&quot;viewImage&quot;&lt;/span&gt;&lt;span&gt; Property&lt;/span&gt;&lt;span&gt;=&quot;Source&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;/Images/noImage.png&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;TargetName&lt;/span&gt;&lt;span&gt;=&quot;viewImage&quot;&lt;/span&gt;&lt;span&gt; Property&lt;/span&gt;&lt;span&gt;=&quot;Opacity&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;0.5&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;TargetName&lt;/span&gt;&lt;span&gt;=&quot;viewText&quot;&lt;/span&gt;&lt;span&gt; Property&lt;/span&gt;&lt;span&gt;=&quot;Background&quot;&lt;/span&gt;&lt;span&gt; Value&lt;/span&gt;&lt;span&gt;=&quot;Brown&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;MultiDataTrigger.Setters&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;MultiDataTrigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DataTemplate.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，要说明的是，对于控件的内联 (Inline) 属性，仅能设置 EventTrigger，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;EventTrigger &lt;/span&gt;&lt;span&gt;…&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;EventTrigger&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button.Triggers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以，总结来看，以上三类触发器的使用场景就是当控件的属性值被更改或者事件被触发时，更修改控件的外观或行为；并且属性触发器有独特的特点，就是在属性值还原时，样式也会随即恢复。&lt;/p&gt;
&lt;p&gt;理解了这些，在开发自定义控件时，我们就可以通过为自定义控件合理地定义依赖属性、只读依赖属性以及路由事件，来控制控件的显示。接下来，我们来看 VisualStateManager，它也可以解决同样的问题。&lt;/p&gt;
&lt;h2&gt;二、VisualStateManager&lt;/h2&gt;
&lt;p&gt;要使用 VisualStateManager，需要定义 VisualState；在 VisualState 中定义控件的不同的状态以及每种状态下的样式，然后，在代码中合适的地方，我们可以使用 VisusalStateManager 类的 GoToState 来切换到对应的状态，从而实现样式的切换。&lt;/p&gt;
&lt;p&gt;所以，总括地说，这里涉及了以下四个方面：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;VisualState: 视图状态(Visual States)表示控件在一个特殊的逻辑状态下的样式、外观；&lt;/li&gt;
&lt;li&gt;VisualStateGroup: 状态组由相互排斥的状态组成，状态组与状态组并不互斥；&lt;/li&gt;
&lt;li&gt;VisualTransition: 视图转变 (Visual Transitions) 代表控件从一个视图状态向另一个状态转换时的过渡；&lt;/li&gt;
&lt;li&gt;VisualStateManager: 由它负责在代码中来切换到不同的状态；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;每个 VisualState 都属于一个状态组 (VisualStateGroup)，也即一个 VisualStateGroup 中可以定义多个 VisualState；并且，我们也可以定义多个 VisualStateGroup；需要再次强调的是：同一个 VisualStateGroup 中 VisualState 是互斥的，而不同的 VisualStateGroup 中的 VisualState 是在同一时刻是可以共存的。以 Button 为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/676860/201802/676860-20180214150414187-463687289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到，在它里面，定义了三个 VisualStateGroup，分别是 CommonStates（正常状态）、FocusStates（焦点状态）、ValidationStates（验证状态），而每个 VisualStateGroup 下又有若干个 VisualState。在 CommonStates 中，按钮可以是 Normal 、MouseOver 或 Pressed（只能是三者之一），但它却可以结合其它 VisualStateGroup 中的 VisualState 来显示，如按钮具有焦点时且鼠标移动到其上，这就结合了 MouseOver 与 Focused 两种状态。以下它的部分代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ControlTemplate &lt;/span&gt;&lt;span&gt;TargetType&lt;/span&gt;&lt;span&gt;=&quot;Button&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualStateManager.VisualStateGroups&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualStateGroup &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;CommonStates&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualStateGroup.Transitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualTransition &lt;/span&gt;&lt;span&gt;GeneratedDuration&lt;/span&gt;&lt;span&gt;=&quot;0:0:1&quot;&lt;/span&gt;&lt;span&gt; To&lt;/span&gt;&lt;span&gt;=&quot;MouseOver&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualTransition &lt;/span&gt;&lt;span&gt;GeneratedDuration&lt;/span&gt;&lt;span&gt;=&quot;0:0:1&quot;&lt;/span&gt;&lt;span&gt; To&lt;/span&gt;&lt;span&gt;=&quot;Pressed&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualTransition &lt;/span&gt;&lt;span&gt;GeneratedDuration&lt;/span&gt;&lt;span&gt;=&quot;0:0:1&quot;&lt;/span&gt;&lt;span&gt; To&lt;/span&gt;&lt;span&gt;=&quot;Normal&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;VisualStateGroup.Transitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualState &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;Normal&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualState &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;MouseOver&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Storyboard&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColorAnimation
                            &lt;/span&gt;&lt;span&gt;Storyboard.TargetName&lt;/span&gt;&lt;span&gt;=&quot;BackgroundBorder&quot;&lt;/span&gt;&lt;span&gt;
                            Storyboard.TargetProperty&lt;/span&gt;&lt;span&gt;=&quot;Background.(SolidColorBrush.Color)&quot;&lt;/span&gt;&lt;span&gt;
                            To&lt;/span&gt;&lt;span&gt;=&quot;#A1D6FC&quot;&lt;/span&gt;&lt;span&gt;
                            Duration&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Storyboard&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;VisualState&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualState &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;Pressed&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Storyboard&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ColorAnimation
                            &lt;/span&gt;&lt;span&gt;Storyboard.TargetName&lt;/span&gt;&lt;span&gt;=&quot;BackgroundBorder&quot;&lt;/span&gt;&lt;span&gt;
                            Storyboard.TargetProperty&lt;/span&gt;&lt;span&gt;=&quot;Background.(SolidColorBrush.Color)&quot;&lt;/span&gt;&lt;span&gt;
                            To&lt;/span&gt;&lt;span&gt;=&quot;#FCA1A1&quot;&lt;/span&gt;&lt;span&gt;
                            Duration&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Storyboard&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;VisualState&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;VisualStateGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;VisualStateManager.VisualStateGroups&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Border
            &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;BackgroundBorder&quot;&lt;/span&gt;&lt;span&gt;
            Background&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding Background}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            BorderBrush&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding BorderBrush}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            BorderThickness&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding BorderThickness}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            SnapsToDevicePixels&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ContentPresenter
            &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding Padding}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            HorizontalAlignment&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding HorizontalContentAlignment}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            VerticalAlignment&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding VerticalContentAlignment}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            Focusable&lt;/span&gt;&lt;span&gt;=&quot;False&quot;&lt;/span&gt;&lt;span&gt;
            RecognizesAccessKey&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt;
            SnapsToDevicePixels&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding SnapsToDevicePixels}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ControlTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在自定义控件的开发过程中，我们也可以采用同样的原则，即在 XAML 中定义 VisualStateGroup、VisualState 以及 VisualTransition（可选），由借助于 VisualStateManager 来实现切换。以下是一个带水印功能的 TextBox 中 VisualStates 的定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualStateManager.VisualStateGroups&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualStateGroup &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;WatermarkGroup&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualStateGroup.Transitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualTransition &lt;/span&gt;&lt;span&gt;From&lt;/span&gt;&lt;span&gt;=&quot;ShowWatermarkState&quot;&lt;/span&gt;&lt;span&gt; To&lt;/span&gt;&lt;span&gt;=&quot;HideWatermarkState&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
              &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Storyboard&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DoubleAnimation &lt;/span&gt;&lt;span&gt;Storyboard.TargetName&lt;/span&gt;&lt;span&gt;=&quot;PART_Watermark&quot;&lt;/span&gt;&lt;span&gt;
                                  Storyboard.TargetProperty&lt;/span&gt;&lt;span&gt;=&quot;Opacity&quot;&lt;/span&gt;&lt;span&gt; From&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;
                                  To&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt; Duration&lt;/span&gt;&lt;span&gt;=&quot;0:0:2&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
               &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Storyboard&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;                                        
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;VisualTransition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualTransition &lt;/span&gt;&lt;span&gt;From&lt;/span&gt;&lt;span&gt;=&quot;HideWatermarkState&quot;&lt;/span&gt;&lt;span&gt; To&lt;/span&gt;&lt;span&gt;=&quot;ShowWatermarkState&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Storyboard&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DoubleAnimation &lt;/span&gt;&lt;span&gt;Storyboard.TargetName&lt;/span&gt;&lt;span&gt;=&quot;PART_Watermark&quot;&lt;/span&gt;&lt;span&gt;
                                   Storyboard.TargetProperty&lt;/span&gt;&lt;span&gt;=&quot;Opacity&quot;&lt;/span&gt;&lt;span&gt; From&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;
                                   To&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt; Duration&lt;/span&gt;&lt;span&gt;=&quot;0:0:2&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
               &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Storyboard&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;VisualTransition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;VisualStateGroup.Transitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualState &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;ShowWatermarkState&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Storyboard&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ObjectAnimationUsingKeyFrames &lt;/span&gt;&lt;span&gt;Duration&lt;/span&gt;&lt;span&gt;=&quot;0:0:0&quot;&lt;/span&gt;&lt;span&gt;
                             Storyboard.TargetName&lt;/span&gt;&lt;span&gt;=&quot;PART_Watermark&quot;&lt;/span&gt;&lt;span&gt;
                             Storyboard.TargetProperty&lt;/span&gt;&lt;span&gt;=&quot;(UIElement.Visibility)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DiscreteObjectKeyFrame &lt;/span&gt;&lt;span&gt;KeyTime&lt;/span&gt;&lt;span&gt;=&quot;0:0:0&quot;&lt;/span&gt;&lt;span&gt;
                             Value&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:Static Visibility.Visible}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
               &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ObjectAnimationUsingKeyFrames&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Storyboard&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;VisualState&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualState &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;HideWatermarkState&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Storyboard&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ObjectAnimationUsingKeyFrames &lt;/span&gt;&lt;span&gt;Duration&lt;/span&gt;&lt;span&gt;=&quot;0:0:0&quot;&lt;/span&gt;&lt;span&gt;
                             Storyboard.TargetName&lt;/span&gt;&lt;span&gt;=&quot;PART_Watermark&quot;&lt;/span&gt;&lt;span&gt;
                             Storyboard.TargetProperty&lt;/span&gt;&lt;span&gt;=&quot;(UIElement.Visibility)&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DiscreteObjectKeyFrame &lt;/span&gt;&lt;span&gt;KeyTime&lt;/span&gt;&lt;span&gt;=&quot;0:0:0&quot;&lt;/span&gt;&lt;span&gt;
                             Value&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:Static Visibility.Collapsed}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
               &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ObjectAnimationUsingKeyFrames&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Storyboard&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;VisualState&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;                                
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;VisualStateGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;VisualStateManager.VisualStateGroups&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出，它定义了 WatermarkGroup 组，并在其中定义了 ShowWatermarkState 和 HideWatermarkState 两个 VisualState，并且，通过定义的 VisualTransition 能够实现在这两种状态下切换时，水印文本会有淡入、淡出的效果。&lt;/p&gt;
&lt;p&gt;最后，在代码中，调用  VisualStateManager.GoToState 方法来切换到合适的状态即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; UpdateState()
{
   &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; textExists = Text.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; watermark = GetTemplateChild(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PART_Watermark&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; FrameworkElement;
   &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; state = textExists || IsFocused ? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HideWatermarkState&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ShowWatermarkState&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 
   VisualStateManager.GoToState(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, state, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
}
 
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnGotFocus(RoutedEventArgs e)
{
   &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnGotFocus(e);
   UpdateState();
}
 
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnLostFocus(RoutedEventArgs e)
{
   &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnLostFocus(e);
   UpdateState();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，何时切换状态呢？一般情况下，包括但不限于以下几个场合或地方：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 OnApplyTemplate 方法（即应用模板时）；&lt;/li&gt;
&lt;li&gt;当某个属性改变时（可以在 PropertyChangedCallback 中调用）；&lt;/li&gt;
&lt;li&gt;当某个事件发生后； &lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;三、Triggers 与 VisualStateManager 的区别&lt;/h2&gt;
&lt;p&gt;以上我们看到 Trigger 和 VisualStateManager 都可以完成相同的事，不过它们也是有区别的，主要有以下几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Triggers 仅仅在 XAML 中使用（尽管它可能要用到我们的自定义属性或事件，但对于更改状态这件事来说，我们只要在 XAML 中操作即可），而 VisualStateManager 则 XAML 和 C# 代码都需要；&lt;/li&gt;
&lt;li&gt;对于 Trigger，定义模板的人可以自由地指定当条件符合时时该有何种的变化；而对于 VisualStateManager，则需要控件开发人员定义不同的 VisualState，然后定义模板的人根据约定（根据 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.windows.templatevisualstateattribute(v=vs.110).aspx&quot; target=&quot;_blank&quot;&gt;TemplateVisualStateAttribute&lt;/a&gt; 特性）来定义在控件不同状态下的样式；&lt;/li&gt;
&lt;li&gt;对于 Trigger，它是对事件、属性或者所绑定的数据发生变化时，作出对应的改变；而 VSM 则可以自由控制状态的切换，并定在切换时，还可以指定 VisualTransition；&lt;/li&gt;
&lt;li&gt;最后， VisualStateManager 不仅支持 WPF，而且也支持 UWP，我们可以说它是“跨平台”的，而 Trigger 在 UWP 上不被支持。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本文主要讨论了 WPF 中的触发器 Triggers 和 VisualStateManager，在设计自定义控件时，它们都能够辅以完成控件样式切换的功能；我们分别介绍了它们二者的使用方法以及使用要点；最后我们也总结了它们的区别。当我们了解了它们各自的特点以及它们的区别后，我们就可以有选择地、更方便地来设计我们的自定义控件，并在 WPF 开发过程中自由地运用它们。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;http://putridparrot.com/blog/visualstatemanager-and-alternative-to-triggers/&quot; target=&quot;_blank&quot;&gt;VisualStateManager and alternative to Triggers&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Feb 2018 02:51:00 +0000</pubDate>
<dc:creator>WPInfo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wpinfo/p/wpf_triggers_vsm.html</dc:identifier>
</item>
<item>
<title>一个Windows下线程池的实现（C++） - TanGuoying</title>
<link>http://www.cnblogs.com/tanguoying/p/8454637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanguoying/p/8454637.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本文配套代码：&lt;a href=&quot;https://github.com/TTGuoying/ThreadPool&quot; target=&quot;_blank&quot;&gt;https://github.com/TTGuoying/ThreadPool&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　先看看几个概念：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt; 线程：进程中负责执行的执行单元。一个进程中至少有一个线程。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; 多线程：一个进程中有多个线程同时运行，根据cpu切换轮流工作，在多核cpu上可以几个线程同时在不同的核心上同时运行。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; 线程池：基本思想还是一种对象池思想，开辟一块内存空间，里面存放一些休眠（挂起Suspend）的线程。当有任务要执行时，从池中取一个空闲的线程执行任务，执行完成后线程休眠放回池中。这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　我们为什么要使用线程池呢？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　简单来说就是线程本身存在开销，我们利用多线程来进行任务处理，单线程也不能滥用，无止禁的开新线程会给系统产生大量消耗，而线程本来就是可重用的资源，不需要每次使用时都进行初始化，因此可以采用有限的线程个数处理无限的任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　本文的线程池是在Windows上实现的。主要思路是维护一个&lt;span&gt;空闲线程队列&lt;/span&gt;、一个&lt;span&gt;忙碌线程队列&lt;/span&gt;和一个&lt;span&gt;任务队列&lt;/span&gt;，一开始建立一定数量的空闲线程放进&lt;span&gt;空闲线程队列&lt;/span&gt;，当有任务进入&lt;span&gt;任务队列&lt;/span&gt;时，从&lt;span&gt;空闲线程队列&lt;/span&gt;中去一个线程执行任务，线程变为忙碌线程移入&lt;span&gt;忙碌线程队列&lt;/span&gt;，任务执行完成后，线程到&lt;span&gt;任务队列&lt;/span&gt;中取任务继续执行，如果&lt;span&gt;任务队列&lt;/span&gt;中没有任务线程休眠后从&lt;span&gt;忙碌线程队列&lt;/span&gt;回到&lt;span&gt;空闲线程队列&lt;/span&gt;。下面是线程池的工作原理图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/832024/201802/832024-20180219231421765-1436093126.png&quot; alt=&quot;&quot; width=&quot;676&quot; height=&quot;639&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本线程池类实现了自动调节池中线程数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　废话少说，直接上代码：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;==========================================================================
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;* 类ThreadPool是本代码的核心类，类中自动维护线程池的创建和任务队列的派送
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;* 其中的TaskFun是任务函数
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;* 其中的TaskCallbackFun是回调函数
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;*用法：定义一个ThreadPool变量，TaskFun函数和TaskCallbackFun回调函数，然后调用ThreadPool的QueueTaskItem()函数即可
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;Author: TTGuoying
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; 
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;Date: 2018/02/19 23:15
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;==========================================================================
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; once
&lt;span&gt; 17&lt;/span&gt; #include &amp;lt;Windows.h&amp;gt;
&lt;span&gt; 18&lt;/span&gt; #include &amp;lt;list&amp;gt;
&lt;span&gt; 19&lt;/span&gt; #include &amp;lt;queue&amp;gt;
&lt;span&gt; 20&lt;/span&gt; #include &amp;lt;memory&amp;gt;
&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; std::list;
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; std::queue;
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; std::shared_ptr;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; THRESHOLE_OF_WAIT_TASK  20
&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt; typedef &lt;span&gt;int&lt;/span&gt;(*TaskFun)(PVOID param);                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务函数&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt; typedef &lt;span&gt;void&lt;/span&gt;(*TaskCallbackFun)(&lt;span&gt;int&lt;/span&gt; result);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 回调函数&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadPool
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程类(内部类)&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Thread
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         Thread(ThreadPool *&lt;span&gt;threadPool);
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         ~&lt;span&gt;Thread();
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;         BOOL isBusy();                                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否有任务在执行&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; ExecuteTask(TaskFun task, PVOID param, TaskCallbackFun taskCallback);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行任务&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         ThreadPool *threadPool;                                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所属线程池&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;         BOOL    busy;                                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否有任务在执行&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;         BOOL    exit;                                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否退出&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;         HANDLE  thread;                                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程句柄&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;         TaskFun    task;                                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要执行的任务&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;         PVOID    param;                                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务参数&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt;         TaskCallbackFun taskCb;                                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 回调的任务&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt; __stdcall ThreadProc(PVOID pM);                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程函数&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; IOCP的通知种类&lt;/span&gt;
&lt;span&gt; 56&lt;/span&gt;     &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; WAIT_OPERATION_TYPE
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;        GET_TASK,
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;        EXIT
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 待执行的任务类&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WaitTask
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        WaitTask(TaskFun task, PVOID param, TaskCallbackFun taskCb, BOOL bLong)
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;-&amp;gt;task =&lt;span&gt; task;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;-&amp;gt;param =&lt;span&gt; param;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;-&amp;gt;taskCb =&lt;span&gt; taskCb;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;-&amp;gt;bLong =&lt;span&gt; bLong;
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;         ~WaitTask() { task = NULL; taskCb = NULL; bLong = FALSE; param =&lt;span&gt; NULL; }
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;         TaskFun    task;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 要执行的任务&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;         PVOID param;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务参数&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt;         TaskCallbackFun taskCb;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 回调的任务&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;         BOOL bLong;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否时长任务&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从任务列表取任务的线程函数&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; __stdcall GetTaskThreadProc(PVOID pM)
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;         ThreadPool *threadPool = (ThreadPool *&lt;span&gt;)pM;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;         BOOL bRet =&lt;span&gt; FALSE;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         DWORD dwBytes = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;        WAIT_OPERATION_TYPE opType;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;         OVERLAPPED *&lt;span&gt;ol;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (WAIT_OBJECT_0 != WaitForSingleObject(threadPool-&amp;gt;stopEvent, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;             BOOL bRet = GetQueuedCompletionStatus(threadPool-&amp;gt;completionPort, &amp;amp;dwBytes, (PULONG_PTR)&amp;amp;opType, &amp;amp;&lt;span&gt;ol, INFINITE);
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 收到退出标志&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (EXIT ==&lt;span&gt; (DWORD)opType)
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (GET_TASK ==&lt;span&gt; (DWORD)opType)
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                 threadPool-&amp;gt;&lt;span&gt;GetTaskExcute();
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程临界区锁&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CriticalSectionLock
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;         CRITICAL_SECTION cs;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;临界区&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;         CriticalSectionLock() { InitializeCriticalSection(&amp;amp;&lt;span&gt;cs); }
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         ~CriticalSectionLock() { DeleteCriticalSection(&amp;amp;&lt;span&gt;cs); }
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; Lock() { EnterCriticalSection(&amp;amp;&lt;span&gt;cs); }
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; UnLock() { LeaveCriticalSection(&amp;amp;&lt;span&gt;cs); }
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;     ThreadPool(size_t minNumOfThread = &lt;span&gt;2&lt;/span&gt;, size_t maxNumOfThread = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;     ~&lt;span&gt;ThreadPool();
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; 
&lt;span&gt;122&lt;/span&gt;     BOOL QueueTaskItem(TaskFun task, PVOID param, TaskCallbackFun taskCb = NULL, BOOL longFun = FALSE);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务入队&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt; 
&lt;span&gt;124&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;     size_t getCurNumOfThread() { &lt;span&gt;return&lt;/span&gt; getIdleThreadNum() + getBusyThreadNum(); }    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取线程池中的当前线程数&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt;     size_t GetMaxNumOfThread() { &lt;span&gt;return&lt;/span&gt; maxNumOfThread - numOfLongFun; }            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取线程池中的最大线程数&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; SetMaxNumOfThread(size_t size)            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置线程池中的最大线程数&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt; &lt;span&gt;    { 
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (size &amp;lt;&lt;span&gt; numOfLongFun)
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;             maxNumOfThread = size +&lt;span&gt; numOfLongFun;
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;             maxNumOfThread =&lt;span&gt; size; 
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;    }                    
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;     size_t GetMinNumOfThread() { &lt;span&gt;return&lt;/span&gt; minNumOfThread; }                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取线程池中的最小线程数&lt;/span&gt;
&lt;span&gt;137&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; SetMinNumOfThread(size_t size) { minNumOfThread = size; }                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置线程池中的最小线程数&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt;     size_t getIdleThreadNum() { &lt;span&gt;return&lt;/span&gt; idleThreadList.size(); }    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取线程池中的线程数&lt;/span&gt;
&lt;span&gt;140&lt;/span&gt;     size_t getBusyThreadNum() { &lt;span&gt;return&lt;/span&gt; busyThreadList.size(); }    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取线程池中的线程数&lt;/span&gt;
&lt;span&gt;141&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; CreateIdleThread(size_t size);                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建空闲线程&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; DeleteIdleThread(size_t size);                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除空闲线程&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt;     Thread *GetIdleThread();                                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取空闲线程&lt;/span&gt;
&lt;span&gt;144&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; MoveBusyThreadToIdleList(Thread *busyThread);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 忙碌线程加入空闲列表&lt;/span&gt;
&lt;span&gt;145&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; MoveThreadToBusyList(Thread *thread);                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程加入忙碌列表&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; GetTaskExcute();                                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从任务队列中取任务执行&lt;/span&gt;
&lt;span&gt;147&lt;/span&gt;     WaitTask *GetTask();                                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从任务队列中取任务&lt;/span&gt;
&lt;span&gt;148&lt;/span&gt; 
&lt;span&gt;149&lt;/span&gt;     CriticalSectionLock idleThreadLock;                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 空闲线程列表锁&lt;/span&gt;
&lt;span&gt;150&lt;/span&gt;     list&amp;lt;Thread *&amp;gt; idleThreadList;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 空闲线程列表&lt;/span&gt;
&lt;span&gt;151&lt;/span&gt;     CriticalSectionLock busyThreadLock;                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 忙碌线程列表锁&lt;/span&gt;
&lt;span&gt;152&lt;/span&gt;     list&amp;lt;Thread *&amp;gt; busyThreadList;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 忙碌线程列表&lt;/span&gt;
&lt;span&gt;153&lt;/span&gt; 
&lt;span&gt;154&lt;/span&gt; &lt;span&gt;    CriticalSectionLock waitTaskLock;
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;     list&amp;lt;WaitTask *&amp;gt; waitTaskList;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务列表&lt;/span&gt;
&lt;span&gt;156&lt;/span&gt; 
&lt;span&gt;157&lt;/span&gt;     HANDLE                    dispatchThrad;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分发任务线程&lt;/span&gt;
&lt;span&gt;158&lt;/span&gt;     HANDLE                    stopEvent;                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通知线程退出的时间&lt;/span&gt;
&lt;span&gt;159&lt;/span&gt;     HANDLE                    completionPort;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 完成端口&lt;/span&gt;
&lt;span&gt;160&lt;/span&gt;     size_t                    maxNumOfThread;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程池中最大的线程数&lt;/span&gt;
&lt;span&gt;161&lt;/span&gt;     size_t                    minNumOfThread;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程池中最小的线程数&lt;/span&gt;
&lt;span&gt;162&lt;/span&gt;     size_t                    numOfLongFun;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程池中最小的线程数&lt;/span&gt;
&lt;span&gt;163&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ThreadPool.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; #include &amp;lt;process.h&amp;gt;
&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;ThreadPool::ThreadPool(size_t minNumOfThread, size_t maxNumOfThread)
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (minNumOfThread &amp;lt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;-&amp;gt;minNumOfThread = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;-&amp;gt;minNumOfThread =&lt;span&gt; minNumOfThread;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (maxNumOfThread &amp;lt; &lt;span&gt;this&lt;/span&gt;-&amp;gt;minNumOfThread * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;-&amp;gt;maxNumOfThread = &lt;span&gt;this&lt;/span&gt;-&amp;gt;minNumOfThread * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;-&amp;gt;maxNumOfThread =&lt;span&gt; maxNumOfThread;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     stopEvent =&lt;span&gt; CreateEvent(NULL, TRUE, FALSE, NULL);
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     completionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;    idleThreadList.clear();
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;     CreateIdleThread(&lt;span&gt;this&lt;/span&gt;-&amp;gt;&lt;span&gt;minNumOfThread);
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;    busyThreadList.clear();
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt;     dispatchThrad = (HANDLE)_beginthreadex(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, GetTaskThreadProc, &lt;span&gt;this&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     numOfLongFun = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt; ThreadPool::~&lt;span&gt;ThreadPool()
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;    SetEvent(stopEvent);
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     PostQueuedCompletionStatus(completionPort, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, (DWORD)EXIT, NULL);
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;    CloseHandle(stopEvent);
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;BOOL ThreadPool::QueueTaskItem(TaskFun task, PVOID param, TaskCallbackFun taskCb, BOOL longFun)
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;    waitTaskLock.Lock();
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     WaitTask *waitTask = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WaitTask(task, param, taskCb, longFun);
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;    waitTaskList.push_back(waitTask);
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;    waitTaskLock.UnLock();
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;     PostQueuedCompletionStatus(completionPort, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, (DWORD)GET_TASK, NULL);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; TRUE;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ThreadPool::CreateIdleThread(size_t size)
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;    idleThreadLock.Lock();
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;         idleThreadList.push_back(&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;    idleThreadLock.UnLock();
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ThreadPool::DeleteIdleThread(size_t size)
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;    idleThreadLock.Lock();
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;     size_t t =&lt;span&gt; idleThreadList.size();
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (t &amp;gt;=&lt;span&gt; size)
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; size; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             auto thread =&lt;span&gt; idleThreadList.back();
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;             &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; thread;
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;            idleThreadList.pop_back();
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; t; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;             auto thread =&lt;span&gt; idleThreadList.back();
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; thread;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;            idleThreadList.pop_back();
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;    idleThreadLock.UnLock();
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; 
&lt;span&gt; 80&lt;/span&gt; ThreadPool::Thread *&lt;span&gt;ThreadPool::GetIdleThread()
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     Thread *thread =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;    idleThreadLock.Lock();
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (idleThreadList.size() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         thread =&lt;span&gt; idleThreadList.front();
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;        idleThreadList.pop_front();
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;    idleThreadLock.UnLock();
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (thread == NULL &amp;amp;&amp;amp; getCurNumOfThread() &amp;lt;&lt;span&gt; maxNumOfThread)
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;         thread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (thread == NULL &amp;amp;&amp;amp; waitTaskList.size() &amp;gt;&lt;span&gt; THRESHOLE_OF_WAIT_TASK)
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;         thread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;         InterlockedIncrement(&amp;amp;&lt;span&gt;maxNumOfThread);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; thread;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ThreadPool::MoveBusyThreadToIdleList(Thread *&lt;span&gt; busyThread)
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;    idleThreadLock.Lock();
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;    idleThreadList.push_back(busyThread);
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;    idleThreadLock.UnLock();
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; 
&lt;span&gt;110&lt;/span&gt; &lt;span&gt;    busyThreadLock.Lock();
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (auto it = busyThreadList.begin(); it != busyThreadList.end(); it++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (*it ==&lt;span&gt; busyThread)
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;            busyThreadList.erase(it);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;    busyThreadLock.UnLock();
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; 
&lt;span&gt;121&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (maxNumOfThread != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; idleThreadList.size() &amp;gt; maxNumOfThread * &lt;span&gt;0.8&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;         DeleteIdleThread(idleThreadList.size() / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; 
&lt;span&gt;126&lt;/span&gt;     PostQueuedCompletionStatus(completionPort, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, (DWORD)GET_TASK, NULL);
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; 
&lt;span&gt;129&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ThreadPool::MoveThreadToBusyList(Thread *&lt;span&gt; thread)
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;    busyThreadLock.Lock();
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;    busyThreadList.push_back(thread);
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;    busyThreadLock.UnLock();
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ThreadPool::GetTaskExcute()
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;     Thread *thread =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;     WaitTask *waitTask =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;     waitTask =&lt;span&gt; GetTask();
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (waitTask ==&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; 
&lt;span&gt;147&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (waitTask-&amp;gt;&lt;span&gt;bLong)
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (idleThreadList.size() &amp;gt;&lt;span&gt; minNumOfThread)
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;             thread =&lt;span&gt; GetIdleThread();
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;154&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;             thread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;             InterlockedIncrement(&amp;amp;&lt;span&gt;numOfLongFun);
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;             InterlockedIncrement(&amp;amp;&lt;span&gt;maxNumOfThread);
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;161&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;         thread =&lt;span&gt; GetIdleThread();
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; 
&lt;span&gt;165&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (thread !=&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;         thread-&amp;gt;ExecuteTask(waitTask-&amp;gt;task, waitTask-&amp;gt;param, waitTask-&amp;gt;&lt;span&gt;taskCb);
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;         &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; waitTask;
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;        MoveThreadToBusyList(thread);
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;172&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; &lt;span&gt;        waitTaskLock.Lock();
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;        waitTaskList.push_front(waitTask);
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;        waitTaskLock.UnLock();
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;     
&lt;span&gt;178&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt; 
&lt;span&gt;180&lt;/span&gt; ThreadPool::WaitTask *&lt;span&gt;ThreadPool::GetTask()
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;     WaitTask *waitTask =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; &lt;span&gt;    waitTaskLock.Lock();
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (waitTaskList.size() &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;         waitTask =&lt;span&gt; waitTaskList.front();
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; &lt;span&gt;        waitTaskList.pop_front();
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt; &lt;span&gt;    waitTaskLock.UnLock();
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; waitTask;
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt; 
&lt;span&gt;193&lt;/span&gt; 
&lt;span&gt;194&lt;/span&gt; ThreadPool::Thread::Thread(ThreadPool *&lt;span&gt;threadPool) :
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt; &lt;span&gt;    busy(FALSE),
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;    thread(INVALID_HANDLE_VALUE),
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; &lt;span&gt;    task(NULL),
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; &lt;span&gt;    taskCb(NULL),
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt; &lt;span&gt;    exit(FALSE),
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; &lt;span&gt;    threadPool(threadPool)
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;     thread = (HANDLE)_beginthreadex(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, ThreadProc, &lt;span&gt;this&lt;/span&gt;, CREATE_SUSPENDED, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt; 
&lt;span&gt;205&lt;/span&gt; ThreadPool::Thread::~&lt;span&gt;Thread()
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;     exit =&lt;span&gt; TRUE;
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;     task =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;209&lt;/span&gt;     taskCb =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt; &lt;span&gt;    ResumeThread(thread);
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt;    WaitForSingleObject(thread, INFINITE);
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; &lt;span&gt;    CloseHandle(thread);
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt; 
&lt;span&gt;215&lt;/span&gt; &lt;span&gt;BOOL ThreadPool::Thread::isBusy()
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; busy;
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; 
&lt;span&gt;220&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ThreadPool::Thread::ExecuteTask(TaskFun task, PVOID param, TaskCallbackFun taskCallback)
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;     busy =&lt;span&gt; TRUE;
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;task =&lt;span&gt; task;
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;param =&lt;span&gt; param;
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;-&amp;gt;taskCb =&lt;span&gt; taskCallback;
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt; &lt;span&gt;    ResumeThread(thread);
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt; 
&lt;span&gt;229&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ThreadPool::Thread::ThreadProc(PVOID pM)
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt;     Thread *pThread = (Thread*&lt;span&gt;)pM;
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt; 
&lt;span&gt;233&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (pThread-&amp;gt;&lt;span&gt;exit)
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程退出&lt;/span&gt;
&lt;span&gt;237&lt;/span&gt; 
&lt;span&gt;238&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (pThread-&amp;gt;task == NULL &amp;amp;&amp;amp; pThread-&amp;gt;taskCb ==&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;             pThread-&amp;gt;busy =&lt;span&gt; FALSE;
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;             pThread-&amp;gt;threadPool-&amp;gt;&lt;span&gt;MoveBusyThreadToIdleList(pThread);
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;             SuspendThread(pThread-&amp;gt;&lt;span&gt;thread);
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt; 
&lt;span&gt;246&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; resulst = pThread-&amp;gt;task(pThread-&amp;gt;&lt;span&gt;param);
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(pThread-&amp;gt;&lt;span&gt;taskCb)
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt;             pThread-&amp;gt;&lt;span&gt;taskCb(resulst);
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;         WaitTask *waitTask = pThread-&amp;gt;threadPool-&amp;gt;&lt;span&gt;GetTask();
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (waitTask !=&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt;             pThread-&amp;gt;task = waitTask-&amp;gt;&lt;span&gt;task;
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;             pThread-&amp;gt;taskCb = waitTask-&amp;gt;&lt;span&gt;taskCb;
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt;             &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; waitTask;
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;258&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt;             pThread-&amp;gt;task =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt;             pThread-&amp;gt;param =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt;             pThread-&amp;gt;taskCb =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt;             pThread-&amp;gt;busy =&lt;span&gt; FALSE;
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt;             pThread-&amp;gt;threadPool-&amp;gt;&lt;span&gt;MoveBusyThreadToIdleList(pThread);
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;             SuspendThread(pThread-&amp;gt;&lt;span&gt;thread);
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt; 
&lt;span&gt;268&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;269&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ThreadPool.cpp: 定义控制台应用程序的入口点。
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdafx.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ThreadPool.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Task
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Task1(PVOID p) 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (i &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             Sleep(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             i--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TaskCallback
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; TaskCallback1(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; result)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;   %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, result);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     ThreadPool threadPool(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;30&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        threadPool.QueueTaskItem(Task::Task1, NULL, TaskCallback::TaskCallback1);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    threadPool.QueueTaskItem(Task::Task1, NULL, TaskCallback::TaskCallback1, TRUE);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    getchar();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 19 Feb 2018 15:23:00 +0000</pubDate>
<dc:creator>TanGuoying</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanguoying/p/8454637.html</dc:identifier>
</item>
<item>
<title>------ 解析因内核栈溢出导致的 “double fault” 蓝屏 ------ - f1yin9_0x5hark</title>
<link>http://www.cnblogs.com/flying-shark/p/8454533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-shark/p/8454533.html</guid>
<description>&lt;p&gt;——————————————————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前一篇指出 tail_recursivef_factorial() 会递归调用自身来计算某个正整数的阶乘。当要计算的目标数值过大，经历多次调用后，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就会耗尽可用的内核栈，引发一次页错误异常，而转移控制到错误处理程序前再次向无效的内存地址压入“陷阱帧”则会让原本可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以&lt;/span&gt;&lt;span&gt;处理的异常升级为“double fault”，致使系统崩溃。&lt;/span&gt;&lt;span&gt;本篇通过试图计算 &lt;span&gt;685!&lt;/span&gt; 来触发“double fault”并进行分析。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;将编译好的驱动拷贝到被调试机器上，利用 sc.exe 把它加载至内核空间，源码中（参见上一篇）设置的初始断点被激活从而断入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调试机上的 WinDbg.exe，观察驱动入口点“DriverEntry()”内的局部变量，其中“Number”的值 0x2ad 正是要计算阶乘的数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;685：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219214914318-279441032.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;按下“g”键恢复执行，没多久就让系统崩溃了，这在我们的意料之中，如果没有连接宿主机上的调试器，目标系统就会直接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;蓝屏，并且显示“bug check”代码——0000007F：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219215025292-871208570.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在 MSDN 网站上搜索该错误码，它对应于“&lt;span&gt;UNEXPECTED_KERNEL_MODE_TRAP&lt;/span&gt;”，官方给出的解释如下：&lt;/span&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;The UNEXPECTED_KERNEL_MODE_TRAP bug check has a value of 0x0000007F.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;This bug check indicates that the Intel CPU generated a trap and the kernel failed to catch this trap.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;This trap could be a bound trap (a trap the kernel is not permitted to catch) or a double fault&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(a fault that occurred while processing an earlier fault, which always results in a system failure).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种错误是由于 Intel CPU 生成了一个陷阱（trap），而内核未能捕获这个陷阱。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;此陷阱可能是一个受困陷阱（内核不允许捕获的陷阱），或一个“double fault”（当处理一个早先的错误时又出现一个错误，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这样就总是会导致系统故障）。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;原文描述中的后一种情况（处理错误时又发生另一个错误）就是我们此刻的处境。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;UNEXPECTED_KERNEL_MODE_TRAP 有四个参数，你可以从上一张图看到，首个参数值为“0x00000008（陷阱编号）”，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;官方对该值的解释为：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;34&quot;&gt;
&lt;p&gt;&lt;span&gt;0x00000008, or Double Fault, indicates that an exception occurs during a call to the handler for a prior exception.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Typically, the two exceptions are handled serially.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;However, there are several exceptions that cannot be handled serially,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;and in this situation the processor signals a double fault. There are two common causes of a double fault:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A kernel stack overflow. This overflow occurs when a guard page is hit, and the kernel tries to push a trap frame.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Because there is no stack left, a stack overflow results, causing the double fault.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;If you think this overview has occurred, use !thread to determine the stack limits, and then use kb&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(Display Stack Backtrace) with a large parameter (for example, kb 100) to display the full stack.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A hardware problem.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“Double Fault”，指明在调用前一个异常处理程序期间，又出现了一个异常。一般而言，两个异常是顺序处理的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;然而，有一些异常无法顺序处理，在这种情况下处理器就会发出一个“double fault”信号。有两种常见情况会导致&lt;/span&gt;&lt;br/&gt;&lt;span&gt;“double fault”：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1。一次内核栈溢出。当接触到一个保护页时就会发生此类溢出，然后内核试图向其中压入一个陷阱帧。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;因为已经没有剩余栈可用了，导致又一次栈溢出，造成“double fault”。如果你认为发生了这种溢出，利用“!thread”调试器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;命令确定栈界限，然后使用“kb”（显示栈回溯）命令，并带着较大的参数（比如 kb 100）来显示完整的栈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2。硬件问题&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;遵循原文的指示，我们先检查当前线程的栈界限，然后执行栈回溯看是否真的越界了，如下图所示，内核栈边界在 8bf47000 处，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而发生异常前的最后一次递归调用的帧指针（&lt;span&gt;ChildEBP&lt;/span&gt;）为 8bf47008 ，已经快要出界了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219215346599-1941129028.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;“&lt;span&gt;nt!KiTrap08&lt;/span&gt;”是实际的陷阱处理程序，有趣的是前面的陷阱编号（0x00000008）就在这个例程的名字中，这绝不是巧合，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实际上“nt!KiTrap08”就是“double fault”专用的异常处理程序！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;传递给它的第三个参数“801d8940”同时也就是 UNEXPECTED_KERNEL_MODE_TRAP 的第二个参数，它是一&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;个“&lt;span&gt;nt!_NT_TIB&lt;/span&gt;”结构的&lt;/span&gt;&lt;span&gt;“&lt;span&gt;SubSystemTib&lt;/span&gt;”字段值：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219215505470-1343190109.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实这个字段中包含的信息对于我们此刻的故障排查而言并不那么重要，只是怕有人好奇它的来龙去脉，才略作说明罢了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图中的 nt!KiTrap08 栈帧名称后面给出了一个 &lt;strong&gt;&lt;span&gt;TSS（任务状态段）&lt;/span&gt;&lt;/strong&gt;的段选择符为 28。这才是关键的信息，通过它可会回到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事故现场，分析异常发生时的上下文。这个段选择符存储在“&lt;span&gt;nt!_KTSS&lt;/span&gt;”结构的首个字段（&lt;span&gt;Backlink&lt;/span&gt;）内：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219215651128-1629080340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;看到这里应该能够稍稍体会出内核中相关数据结构设计的多么用心良苦！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;放下我们的多愁善感，利用调试器的“.tss”命令，后接段选择符，即可回到事故现场，如下所示，异常发生时，EIP 指向即将执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的指令地址为 977bd06f，换言之是该地址处的“前一条”指令（push ecx）导致的异常，为啥这条压栈指令会导致异常呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你看“那时”的 esp 已经指向了内核栈的边界点（8bf47000），而压栈指令需要先把 esp 值减去 4 字节，然后再把 ecx 的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写入 8BF46FFC 地址处，该地址已经位于边界之外。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还记得前一篇我们计算出每次递归调用都会消耗掉 16 字节的内核栈空间吗？这出错前的最后一次调用中，试图消耗的最后 4 字节&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就在边界之外！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219215757020-176204568.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;低于 8bf47000 的虚拟内存没有分配实际的物理页，而且我们模拟对 8BF46FFC 执行物理地址转译也失败，证实是由于访问到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无效&lt;/span&gt;&lt;span&gt;地址引发异常的（CR2 寄存器存储导致页错误的访问地址）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219215848136-1145881044.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219215917981-2048059349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如前所述，页错误发生后，在控制权转移到 nt!KiTrap08 之前，再次向这个无效的地址压入一张“陷阱帧”，导致再度出现错误，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而 nt!KiTrap08 通过传递给它的首个参数（0x0000007f）明白了这是一个“double fault”，所以调用 nt!KiBugCheck，后者&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;探测调试器是否存在，决定是要绘制蓝屏还是断入调试器。这就是前面那张栈回溯输出的由来！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;执行“kv 1000”回溯大范围的栈帧，你可以看到 683 次（栈帧编号 0x2b0 - 5）对 tail_recursivef_factorial() 的调用，在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的预测点（685 号栈帧）之前就发生了溢出：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219220029413-340818351.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;最后介绍一个强大的命令“&lt;span&gt;!analyze -v&lt;/span&gt;”，它会自动分析内核崩溃的原因，并给出所有对故障排除有帮助的信息，对于本例而言，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有价值的信息截图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219220108171-938955032.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1318637/201802/1318637-20180219220137505-247403330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;—————————————————————————————————————————————————————&lt;/span&gt;&lt;br/&gt;&lt;span&gt;小结：本篇以源码+调试+在线文档等综合手段排除了“double fault”蓝屏故障；编写驱动并上机调试是理解内核设计思想&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的最佳途经！&lt;/span&gt;&lt;br/&gt;&lt;span&gt;—————————————————————————————————————————————————————&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 19 Feb 2018 14:03:00 +0000</pubDate>
<dc:creator>f1yin9_0x5hark</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-shark/p/8454533.html</dc:identifier>
</item>
<item>
<title>Language Modeling with Gated Convolutional Networks - 笨兔勿应</title>
<link>http://www.cnblogs.com/bentuwuying/p/8454498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bentuwuying/p/8454498.html</guid>
<description>

&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所谓的语言模型，即是指在得知前面的若干个单词的时候，下一个位置上出现的某个单词的概率。&lt;/p&gt;
&lt;p&gt;最朴素的方法是N-gram语言模型，即当前位置只和前面N个位置的单词相关。如此，问题便是，N小了，语言模型的表达能力不够。N大了，遇到稀疏性问题，无法有效的表征上下文。&lt;/p&gt;
&lt;p&gt;LSTM模型一般会将单词embedding到连续空间，然后输入进LSTM，从而有效的表征上下文。但LSTM的问题在于，作为递归模型，当前状态依赖于上一状态，并行化受到限制。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/2.png&quot; alt=&quot;&quot;/&gt; &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所谓的门限卷积，其核心在于为卷积的激活值添加一个门限开关，来决定其有多大的概率传到下一层去。下面一步步对上图进行解析。&lt;/p&gt;
&lt;p&gt;首先，将单词embedding到连续空间；即上图中的第二部分Lookup Table。这样，单词序列就能表现为矩阵了。&lt;/p&gt;
&lt;p&gt;然后就是卷积单元了（上图中的第三部分），与普通卷积不同，门限卷积在这里分为两部分，一部分是卷积激活值，即B，该处于普通卷积的不同在于没有用Tanh，而是直接线性。另一部分是门限值，即A，A也是直接线性得到，但会经过一个sigmoid运算符。&lt;/p&gt;
&lt;p&gt;之后就是门限单元，A和B进行element-wise的相乘，得到卷积后的结果。卷积单元和门限单元加起来形成一个卷积层。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/4.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过多个这样的卷积层之后，再将其输入到SoftMax中，得到最后的预测。&lt;/p&gt;
&lt;h2 id=&quot;细节&quot;&gt;细节&lt;/h2&gt;
&lt;p&gt;在做卷积层的时候，需要不让第i个输出值看到i以后的输入值。这是由语言模型的特性决定的，需要用i之前的信息来预测i。为了达到这样的效果，需要将输入层进行偏移，偏移k/2个单位，其中k是卷积的宽度，偏移后开头空缺的部分就用0进行padding。&lt;/p&gt;
&lt;p&gt;由于residual network的强大能力，在真正的实现里，会把卷积单元和门限单元包在一个residual block里。&lt;/p&gt;
&lt;p&gt;在最后的softmax层，普通的softmax会因为词表巨大而非常低效。因而选用adaptive softmax。adaptive softmax可以为高频词分配更多的空间而给低频次分配比较少的空间。&lt;/p&gt;

&lt;p&gt;LSTM中有input门和forget门两种，这两种缺一则会导致有些信息的缺失。而卷积中，经过实验，不需要forget gate。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而LSTM中使用的input门，如上。这种在卷积上却容易导致vanishing问题。因为tanh‘和σ’都是小于1的值。&lt;/p&gt;
&lt;p&gt;因而，在卷积上，使用：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该方法存在一路使得X的导数可以不被downscale的传下去。&lt;/p&gt;

&lt;h2 id=&quot;setup&quot;&gt;Setup&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用Google Billion Word和WikiText-103两种数据集。&lt;/li&gt;
&lt;li&gt;使用perplexity来进行衡量结果。&lt;/li&gt;
&lt;li&gt;使用Nesterov’s momentum算法来训练，momentum设为0.99。&lt;/li&gt;
&lt;li&gt;weight normalization.&lt;/li&gt;
&lt;li&gt;gradient clipping to 0.1&lt;/li&gt;
&lt;li&gt;使用Kaiming initialization&lt;/li&gt;
&lt;li&gt;learning rate 从[1., 2.]中uniformly选取&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;效果测试&quot;&gt;效果测试&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/8.png&quot; alt=&quot;&quot;/&gt; &lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/9.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单GPU上效果最好。&lt;/p&gt;
&lt;h2 id=&quot;性能测试&quot;&gt;性能测试&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/10.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Throughput是指在并行化条件下最大输出。 &lt;br/&gt;Responsiveness是指序列化的处理输入。 &lt;br/&gt;由表可知，CNN本身的处理速度非常快。而LSTM在并行化后也能拥有很高的速度。究其原因，是在cuDNN中对LSTM有特别的优化，而对1-D convolution却没有。但即便如此，CNN仍然完胜。&lt;/p&gt;
&lt;h2 id=&quot;不同门限测试&quot;&gt;不同门限测试&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/11.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GTU: tanh(X*W+b)⊗σ(X*V+c)&lt;/li&gt;
&lt;li&gt;GLU: (X*W+b)⊗σ(X*V+c)&lt;/li&gt;
&lt;li&gt;ReLU: X⊗(X&amp;gt;0)&lt;/li&gt;
&lt;li&gt;Tanh: tanh(X*W+b)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;非线性模型测试&quot;&gt;非线性模型测试&lt;/h2&gt;
&lt;p&gt;上一个实验证明了Gated linear unit深受Linear unit的好处。这里评测一下GLU和纯线性模型的比较。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/12.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Bilinear: (X*W+b)⊗(X*V+c)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;纯Linear模型同5-gram模型效果类似。&lt;/p&gt;
&lt;h2 id=&quot;模型深度测试&quot;&gt;模型深度测试&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/13.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;context-size测试&quot;&gt;Context Size测试&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/14.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;训练测试&quot;&gt;训练测试&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://raw.githubusercontent.com/stdcoutzyx/Blogs/master/blog2016-september-later/GCN/15.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;卷积不似LSTM那样灵活，输入只能是定长。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 19 Feb 2018 13:39:00 +0000</pubDate>
<dc:creator>笨兔勿应</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bentuwuying/p/8454498.html</dc:identifier>
</item>
<item>
<title>JDBC【数据库连接池、DbUtils框架、分页】 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8454470.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8454470.html</guid>
<description>&lt;h2 id=&quot;什么是数据库连接池&quot;&gt;什么是数据库连接池&lt;/h2&gt;
&lt;p&gt;简单来说：&lt;strong&gt;数据库连接池就是提供连接的。。。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么我们要使用数据库连接池&quot;&gt;为什么我们要使用数据库连接池&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;数据库的连接的建立和关闭是非常消耗资源的&lt;/li&gt;
&lt;li&gt;频繁地打开、关闭连接造成系统性能低下&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;编写连接池&quot;&gt;编写连接池&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;编写连接池需&lt;strong&gt;实现java.sql.DataSource接口&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;创建批量的Connection用LinkedList保存&lt;/strong&gt;【既然是个池，当然用集合保存、、LinkedList底层是链表，对增删性能较好】&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现getConnetion()&lt;/strong&gt;，让getConnection()每次调用，都是&lt;strong&gt;在LinkedList中取一个Connection返回给用户&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用Connection.close()方法，Connction返回给LinkedList&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;


    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; LinkedList&amp;lt;Connection&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();
    
    &lt;span class=&quot;co&quot;&gt;//获取连接只需要一次就够了，所以用static代码块&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; {
        &lt;span class=&quot;co&quot;&gt;//读取文件配置&lt;/span&gt;
        InputStream inputStream = Demo1.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getClassLoader&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getResourceAsStream&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;db.properties&quot;&lt;/span&gt;);

        Properties properties = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Properties();
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            properties.&lt;span class=&quot;fu&quot;&gt;load&lt;/span&gt;(inputStream);
            String url = properties.&lt;span class=&quot;fu&quot;&gt;getProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;url&quot;&lt;/span&gt;);
            String username = properties.&lt;span class=&quot;fu&quot;&gt;getProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt;);
            String driver = properties.&lt;span class=&quot;fu&quot;&gt;getProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;driver&quot;&lt;/span&gt;);
            String password = properties.&lt;span class=&quot;fu&quot;&gt;getProperty&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt;);

            &lt;span class=&quot;co&quot;&gt;//加载驱动&lt;/span&gt;
            Class.&lt;span class=&quot;fu&quot;&gt;forName&lt;/span&gt;(driver);

            &lt;span class=&quot;co&quot;&gt;//获取多个连接，保存在LinkedList集合中&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;; i++) {
                Connection connection = DriverManager.&lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;(url, username, password);
                list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(connection);
            }
            
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (ClassNotFoundException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (SQLException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }

    }

    &lt;span class=&quot;co&quot;&gt;//重写Connection方法，用户获取连接应该从LinkedList中给他&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Connection &lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(list.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;());
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(list);

       &lt;span class=&quot;co&quot;&gt;//先判断LinkedList是否存在连接&lt;/span&gt;
       &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; list.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;() &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; ? list.&lt;span class=&quot;fu&quot;&gt;removeFirst&lt;/span&gt;() : &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;; 
    }

&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们已经完成前三步了，现在问题来了&lt;strong&gt;。我们调用Conncetion.close()方法，是把数据库的物理连接关掉，而不是返回给LinkedList的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;写一个Connection子类，覆盖close()方法&lt;/li&gt;
&lt;li&gt;写一个Connection包装类，增强close()方法&lt;/li&gt;
&lt;li&gt;用动态代理，返回一个代理对象出去，拦截close()方法的调用，对close()增强&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;分析第一个思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Connection是通过数据库驱动加载的，保存了数据的信息&lt;/strong&gt;。写一个子类Connection，new出对象，&lt;strong&gt;子类的Connction无法直接继承父类的数据信息，也就是说子类的Connection是无法连接数据库的&lt;/strong&gt;，更别谈覆盖close()方法了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分析第二个思路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;写一个Connection包装类。
&lt;ol&gt;&lt;li&gt;写一个类，实现与被增强对象的相同接口【Connection接口】&lt;/li&gt;
&lt;li&gt;定义一个变量，指向被增强的对象&lt;/li&gt;
&lt;li&gt;定义构造方法，接收被增强对象&lt;/li&gt;
&lt;li&gt;覆盖想增强的方法&lt;/li&gt;
&lt;li&gt;对于不想增强的方法，直接调用被增强对象的方法&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;这个思路本身是没什么毛病的，就是&lt;strong&gt;实现接口时，方法太多了！&lt;/strong&gt;，所以我们也不使用此方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分析第三个思路代码实现：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Connection &lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (list.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;() &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
            &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Connection connection = list.&lt;span class=&quot;fu&quot;&gt;removeFirst&lt;/span&gt;();

            &lt;span class=&quot;co&quot;&gt;//看看池的大小&lt;/span&gt;
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(list.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;());

            &lt;span class=&quot;co&quot;&gt;//返回一个动态代理对象&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; (Connection) Proxy.&lt;span class=&quot;fu&quot;&gt;newProxyInstance&lt;/span&gt;(Demo1.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getClassLoader&lt;/span&gt;(), connection.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getInterfaces&lt;/span&gt;(), &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; InvocationHandler() {

                &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(Object proxy, Method method, Object[] args) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Throwable {

                    &lt;span class=&quot;co&quot;&gt;//如果不是调用close方法，就按照正常的来调用&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!method.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;close&quot;&lt;/span&gt;)) {
                        method.&lt;span class=&quot;fu&quot;&gt;invoke&lt;/span&gt;(connection, args);
                    } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {

                        &lt;span class=&quot;co&quot;&gt;//进到这里来，说明调用的是close方法&lt;/span&gt;
                        list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(connection);

                        &lt;span class=&quot;co&quot;&gt;//再看看池的大小&lt;/span&gt;
                        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(list.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;());

                    }
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                }

            });
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;我们上面已经能够简单编写一个线程池了。下面我们来使用一下开源数据库连接池&lt;/p&gt;
&lt;h2 id=&quot;dbcp&quot;&gt;DBCP&lt;/h2&gt;
&lt;p&gt;使用DBCP数据源的步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;导入两个jar包【Commons-dbcp.jar和Commons-pool.jar】&lt;/li&gt;
&lt;li&gt;读取配置文件&lt;/li&gt;
&lt;li&gt;获取BasicDataSourceFactory对象&lt;/li&gt;
&lt;li&gt;创建DataSource对象&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; DataSource dataSource = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;//读取配置文件&lt;/span&gt;
            InputStream inputStream = Demo3.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getClassLoader&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getResourceAsStream&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;dbcpconfig.properties&quot;&lt;/span&gt;);
            Properties properties = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Properties();
            properties.&lt;span class=&quot;fu&quot;&gt;load&lt;/span&gt;(inputStream);

            &lt;span class=&quot;co&quot;&gt;//获取工厂对象&lt;/span&gt;
            BasicDataSourceFactory basicDataSourceFactory = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BasicDataSourceFactory&lt;/span&gt;();
            dataSource = basicDataSourceFactory.&lt;span class=&quot;fu&quot;&gt;createDataSource&lt;/span&gt;(properties);

        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Connection &lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; dataSource.&lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;();

    }

    &lt;span class=&quot;co&quot;&gt;//这里释放资源不是把数据库的物理连接释放了，是把连接归还给连接池【连接池的Connection内部自己做好了】&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;release&lt;/span&gt;(Connection conn, Statement st, ResultSet rs) {

        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (rs != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                rs.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }
            rs = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (st != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                st.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }

        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (conn != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                conn.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }

        }
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;c3p0&quot;&gt;C3P0&lt;/h2&gt;
&lt;p&gt;C3P0数据源的性能更胜一筹，并且它可以&lt;strong&gt;使用XML配置文件配置信息！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;导入开发包【c3p0-0.9.2-pre1.jar】和【mchange-commons-0.2.jar】&lt;/li&gt;
&lt;li&gt;导入XML配置文件【可以在程序中自己一个一个配，C3P0的doc中的Configuration有XML文件的事例】&lt;/li&gt;
&lt;li&gt;new出ComboPooledDataSource对象&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ComboPooledDataSource comboPooledDataSource = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; {
        &lt;span class=&quot;co&quot;&gt;//如果我什么都不指定，就是使用XML默认的配置，这里我指定的是oracle的&lt;/span&gt;
        comboPooledDataSource = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ComboPooledDataSource&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;oracle&quot;&lt;/span&gt;);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Connection &lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; comboPooledDataSource.&lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;();
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h2 id=&quot;tomcat数据源&quot;&gt;Tomcat数据源&lt;/h2&gt;
&lt;p&gt;Tomcat服务器也给我们提供了连接池，内部其实就是DBCP&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在META-INF目录下配置context.xml文件【文件内容可以在tomcat默认页面的 JNDI Resources下Configure Tomcat's Resource Factory找到】&lt;/li&gt;
&lt;li&gt;导入Mysql或oracle开发包到tomcat的lib目录下&lt;/li&gt;
&lt;li&gt;初始化JNDI-&amp;gt;获取JNDI容器-&amp;gt;检索以XXX为名字在JNDI容器存放的连接池&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;context.xml文件的配置：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
&amp;lt;Context&amp;gt;

  &amp;lt;Resource name=&lt;span class=&quot;st&quot;&gt;&quot;jdbc/EmployeeDB&quot;&lt;/span&gt;
            auth=&lt;span class=&quot;st&quot;&gt;&quot;Container&quot;&lt;/span&gt;
            type=&lt;span class=&quot;st&quot;&gt;&quot;javax.sql.DataSource&quot;&lt;/span&gt;
            
            username=&lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;
            password=&lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;
            driverClassName=&lt;span class=&quot;st&quot;&gt;&quot;com.mysql.jdbc.Driver&quot;&lt;/span&gt;
            url=&lt;span class=&quot;st&quot;&gt;&quot;jdbc:mysql://localhost:3306/zhongfucheng&quot;&lt;/span&gt;
            maxActive=&lt;span class=&quot;st&quot;&gt;&quot;8&quot;&lt;/span&gt;
            maxIdle=&lt;span class=&quot;st&quot;&gt;&quot;4&quot;&lt;/span&gt;/&amp;gt;
&amp;lt;/Context&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {

            &lt;span class=&quot;co&quot;&gt;//初始化JNDI容器&lt;/span&gt;
            Context initCtx = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; InitialContext();

            &lt;span class=&quot;co&quot;&gt;//获取到JNDI容器&lt;/span&gt;
            Context envCtx = (Context) initCtx.&lt;span class=&quot;fu&quot;&gt;lookup&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;java:comp/env&quot;&lt;/span&gt;);

            &lt;span class=&quot;co&quot;&gt;//扫描以jdbc/EmployeeDB名字绑定在JNDI容器下的连接池&lt;/span&gt;
            DataSource ds = (DataSource)
                    envCtx.&lt;span class=&quot;fu&quot;&gt;lookup&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;jdbc/EmployeeDB&quot;&lt;/span&gt;);

            Connection conn = ds.&lt;span class=&quot;fu&quot;&gt;getConnection&lt;/span&gt;();
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(conn);

        } 
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;dbutils它是对JDBC的简单封装，极大简化jdbc编码的工作量&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;dbutils类&quot;&gt;DbUtils类&lt;/h2&gt;
&lt;p&gt;提供了&lt;strong&gt;关闭连接，装载JDBC驱动，回滚提交事务等方法&lt;/strong&gt;的工具类【比较少使用，因为我们学了连接池，就应该使用连接池连接数据库】&lt;/p&gt;
&lt;h2 id=&quot;queryrunner类&quot;&gt;QueryRunner类&lt;/h2&gt;
&lt;p&gt;该类&lt;strong&gt;简化了SQL查询，配合ResultSetHandler使用，可以完成大部分的数据库操作&lt;/strong&gt;，重载了许多的查询，更新，批处理方法。大大减少了代码量&lt;/p&gt;
&lt;h2 id=&quot;resultsethandler接口&quot;&gt;ResultSetHandler接口&lt;/h2&gt;
&lt;p&gt;该接口&lt;strong&gt;规范了对ResultSet的操作&lt;/strong&gt;，要对结果集进行什么操作，传入ResultSetHandler接口的实现类即可。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ArrayHandler：把结果集中的第一行数据转成对象数组。&lt;/li&gt;
&lt;li&gt;ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。&lt;/li&gt;
&lt;li&gt;BeanHandler：将结果集中的第一行数据封装到一个对应的JavaBean实例中。&lt;/li&gt;
&lt;li&gt;BeanListHandler：将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。&lt;/li&gt;
&lt;li&gt;ColumnListHandler：将结果集中某一列的数据存放到List中。&lt;/li&gt;
&lt;li&gt;KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。&lt;/li&gt;
&lt;li&gt;MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。&lt;/li&gt;
&lt;li&gt;MapListHandler：将结果集中的每一行数据都封装到一个Map里，然后再存放到List&lt;/li&gt;
&lt;li&gt;ScalarHandler 将ResultSet的一个列到一个对象中。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;使用DbUtils框架对数据库的CRUD&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;

&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;* 使用DbUtils框架对数据库的CRUD&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;* 批处理&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;* */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Test {

    &lt;span class=&quot;fu&quot;&gt;@org&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;junit&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {

        &lt;span class=&quot;co&quot;&gt;//创建出QueryRunner对象&lt;/span&gt;
        QueryRunner queryRunner = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;QueryRunner&lt;/span&gt;(JdbcUtils.&lt;span class=&quot;fu&quot;&gt;getDataSource&lt;/span&gt;());
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;INSERT INTO student (id,name) VALUES(?,?)&quot;&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;//我们发现query()方法有的需要传入Connection对象，有的不需要传入&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//区别：你传入Connection对象是需要你来销毁该Connection，你不传入，由程序帮你把Connection放回到连接池中&lt;/span&gt;
        queryRunner.&lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;(sql, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[]{&lt;span class=&quot;st&quot;&gt;&quot;100&quot;&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;&quot;zhongfucheng&quot;&lt;/span&gt;});

    }

    &lt;span class=&quot;fu&quot;&gt;@org&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;junit&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;query&lt;/span&gt;()&lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {

        &lt;span class=&quot;co&quot;&gt;//创建出QueryRunner对象&lt;/span&gt;
        QueryRunner queryRunner = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;QueryRunner&lt;/span&gt;(JdbcUtils.&lt;span class=&quot;fu&quot;&gt;getDataSource&lt;/span&gt;());
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;SELECT * FROM student&quot;&lt;/span&gt;;

        List list = (List) queryRunner.&lt;span class=&quot;fu&quot;&gt;query&lt;/span&gt;(sql, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BeanListHandler&lt;/span&gt;(Student.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;));
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(list.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;());

    }

    &lt;span class=&quot;fu&quot;&gt;@org&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;junit&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;delete&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {
        &lt;span class=&quot;co&quot;&gt;//创建出QueryRunner对象&lt;/span&gt;
        QueryRunner queryRunner = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;QueryRunner&lt;/span&gt;(JdbcUtils.&lt;span class=&quot;fu&quot;&gt;getDataSource&lt;/span&gt;());
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;DELETE FROM student WHERE id='100'&quot;&lt;/span&gt;;

        queryRunner.&lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;(sql);
    }

    &lt;span class=&quot;fu&quot;&gt;@org&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;junit&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {
        &lt;span class=&quot;co&quot;&gt;//创建出QueryRunner对象&lt;/span&gt;
        QueryRunner queryRunner = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;QueryRunner&lt;/span&gt;(JdbcUtils.&lt;span class=&quot;fu&quot;&gt;getDataSource&lt;/span&gt;());
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;UPDATE student SET name=? WHERE id=?&quot;&lt;/span&gt;;

        queryRunner.&lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;(sql, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[]{&lt;span class=&quot;st&quot;&gt;&quot;zhongfuchengaaa&quot;&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;});
    }

    &lt;span class=&quot;fu&quot;&gt;@org&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;junit&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;batch&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {
        &lt;span class=&quot;co&quot;&gt;//创建出QueryRunner对象&lt;/span&gt;
        QueryRunner queryRunner = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;QueryRunner&lt;/span&gt;(JdbcUtils.&lt;span class=&quot;fu&quot;&gt;getDataSource&lt;/span&gt;());
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;INSERT INTO student (name,id) VALUES(?,?)&quot;&lt;/span&gt;;

        Object[][] objects = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;][];
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;; i++) {
            objects[i] = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[]{&lt;span class=&quot;st&quot;&gt;&quot;aaa&quot;&lt;/span&gt;, i + &lt;span class=&quot;dv&quot;&gt;300&lt;/span&gt;};
        }
        queryRunner.&lt;span class=&quot;fu&quot;&gt;batch&lt;/span&gt;(sql, objects);
    }

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;分页技术是非常常见的，&lt;strong&gt;在搜索引擎下搜索页面，不可能把全部数据都显示在一个页面里边&lt;/strong&gt;。所以我们用到了分页技术。&lt;/p&gt;
&lt;h2 id=&quot;oracle实现分页&quot;&gt;Oracle实现分页&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      Oracle分页语法：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        @lineSize---每页显示数据行数&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        @currentPage----当前所在页&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt; *FROM (
        &lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt; 列名,列名,&lt;span class=&quot;kw&quot;&gt;ROWNUM&lt;/span&gt; rn
        &lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; 表名
        &lt;span class=&quot;kw&quot;&gt;WHERE&lt;/span&gt; ROWNUM&amp;lt;=(currentPage*lineSize)) temp
    
    &lt;span class=&quot;kw&quot;&gt;WHERE&lt;/span&gt; temp.rn&amp;gt;(currentPage&lt;span class=&quot;dv&quot;&gt;-1&lt;/span&gt;)*lineSize;
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Oracle分页原理简单解释&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      Oracle分页：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        Oracle的分页依赖于ROWNUM这个伪列，ROWNUM主要作用就是产生行号。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      分页原理：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        1：子查询查出前n行数据，ROWNUM产生前N行的行号&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        2：使用子查询产生ROWNUM的行号，通过外部的筛选出想要的数据&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      例子：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        我现在规定每页显示5行数据【lineSize=5】，我要查询第2页的数据【currentPage=2】&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        注：【对照着语法来看】&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      实现：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        1：子查询查出前10条数据【ROWNUM&amp;lt;=10】&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        2：外部筛选出后面5条数据【ROWNUM&amp;gt;5】&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        3：这样我们就取到了后面5条的数据&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    */&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h2 id=&quot;mysql实现分页&quot;&gt;Mysql实现分页&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode sql&quot;&gt;
&lt;code class=&quot;sourceCode sql&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      Mysql分页语法：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      @start---偏移量，不设置就是从0开始【也就是(currentPage-1)*lineSize】&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      @length---长度，取多少行数据&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    */&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;SELECT&lt;/span&gt; *
    &lt;span class=&quot;kw&quot;&gt;FROM&lt;/span&gt; 表名
    &lt;span class=&quot;kw&quot;&gt;LIMIT&lt;/span&gt; [&lt;span class=&quot;kw&quot;&gt;START&lt;/span&gt;], &lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
    
    &lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      例子：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        我现在规定每页显示5行数据，我要查询第2页的数据&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      分析：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        1：第2页的数据其实就是从第6条数据开始，取5条&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;      实现：&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        1：start为5【偏移量从0开始】&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;        2：length为5&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;*/&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Mysql从(currentPage-1)*lineSize开始取数据，取lineSize条数据&lt;/li&gt;
&lt;li&gt;Oracle先获取currentPage&lt;em&gt;lineSize条数据，从(currentPage-1)&lt;/em&gt;lineSize开始取数据&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;使用jdbc连接数据库实现分页&quot;&gt;使用JDBC连接数据库实现分页&lt;/h2&gt;
&lt;p&gt;下面是常见的分页图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/XiVdAWv.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;配合图片，看下我们的需求是什么：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;算出有多少页的数据，显示在页面上&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据页码，从数据库显示相对应的数据。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;分析：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;算出有多少页数据这是非常简单的【在数据库中查询有多少条记录，你每页显示多少条记录，就可以算出有多少页数据了】&lt;/li&gt;
&lt;li&gt;使用Mysql或Oracle的分页语法即可&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过上面分析，我们会发现需要用到4个变量&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;currentPage--当前页【由用户决定的】&lt;/li&gt;
&lt;li&gt;totalRecord--总数据数【查询表可知】&lt;/li&gt;
&lt;li&gt;lineSize--每页显示数据的数量【由我们开发人员决定】&lt;/li&gt;
&lt;li&gt;pageCount--页数【totalRecord和lineSize决定】&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;27&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
        &lt;span class=&quot;co&quot;&gt;//每页显示3条数据&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; lineSize = &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;//总记录数&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; totalRecord = &lt;span class=&quot;fu&quot;&gt;getTotalRecord&lt;/span&gt;();

        &lt;span class=&quot;co&quot;&gt;//假设用户指定的是第2页&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; currentPage = &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;//一共有多少页&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; pageCount = &lt;span class=&quot;fu&quot;&gt;getPageCount&lt;/span&gt;(totalRecord, lineSize);

        &lt;span class=&quot;co&quot;&gt;//使用什么数据库进行分页，记得要在JdbcUtils中改配置&lt;/span&gt;
        List&amp;lt;Person&amp;gt; list = &lt;span class=&quot;fu&quot;&gt;getPageData2&lt;/span&gt;(currentPage, lineSize);
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Person person : list) {
            System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(person);
        }

    }

    &lt;span class=&quot;co&quot;&gt;//使用JDBC连接Mysql数据库实现分页&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; List&amp;lt;Person&amp;gt; &lt;span class=&quot;fu&quot;&gt;getPageData&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; currentPage, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; lineSize) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {

        &lt;span class=&quot;co&quot;&gt;//从哪个位置开始取数据&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; start = (currentPage - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) * lineSize;

        QueryRunner queryRunner = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;QueryRunner&lt;/span&gt;(JdbcUtils.&lt;span class=&quot;fu&quot;&gt;getDataSource&lt;/span&gt;());
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;SELECT name,address  FROM person LIMIT ?,?&quot;&lt;/span&gt;;

        List&amp;lt;Person&amp;gt; persons = (List&amp;lt;Person&amp;gt;) queryRunner.&lt;span class=&quot;fu&quot;&gt;query&lt;/span&gt;(sql, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BeanListHandler&lt;/span&gt;(Person.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[]{start, lineSize});
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; persons;

    }

    &lt;span class=&quot;co&quot;&gt;//使用JDBC连接Oracle数据库实现分页&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; List&amp;lt;Person&amp;gt; &lt;span class=&quot;fu&quot;&gt;getPageData2&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; currentPage, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; lineSize) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {

        &lt;span class=&quot;co&quot;&gt;//从哪个位置开始取数据&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; start = (currentPage - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;) * lineSize;

        &lt;span class=&quot;co&quot;&gt;//读取前N条数据&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; end = currentPage * lineSize;

        QueryRunner queryRunner = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;QueryRunner&lt;/span&gt;(JdbcUtils.&lt;span class=&quot;fu&quot;&gt;getDataSource&lt;/span&gt;());
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;SELECT &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;  name, &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;  address &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;FROM ( &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;  SELECT &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;    name, &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;    address , &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;    ROWNUM rn &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;  FROM person &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;  WHERE ROWNUM &amp;lt;= ? &quot;&lt;/span&gt; +
                &lt;span class=&quot;st&quot;&gt;&quot;)temp WHERE temp.rn&amp;gt;?&quot;&lt;/span&gt;;

        List&amp;lt;Person&amp;gt; persons = (List&amp;lt;Person&amp;gt;) queryRunner.&lt;span class=&quot;fu&quot;&gt;query&lt;/span&gt;(sql, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;BeanListHandler&lt;/span&gt;(Person.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;), &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[]{end, start});
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; persons;

    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getPageCount&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; totalRecord, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; lineSize) {

        &lt;span class=&quot;co&quot;&gt;//简单算法&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//return (totalRecord - 1) / lineSize + 1;&lt;/span&gt;

        &lt;span class=&quot;co&quot;&gt;//此算法比较好理解，把数据代代进去就知道了。&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; totalRecord % lineSize == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; ? (totalRecord / lineSize) : (totalRecord / lineSize) + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;

    }


    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;  &lt;span class=&quot;fu&quot;&gt;getTotalRecord&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; SQLException {

        &lt;span class=&quot;co&quot;&gt;//使用DbUtils框架查询数据库表中有多少条数据&lt;/span&gt;
        QueryRunner queryRunner = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;QueryRunner&lt;/span&gt;(JdbcUtils.&lt;span class=&quot;fu&quot;&gt;getDataSource&lt;/span&gt;());
        String sql = &lt;span class=&quot;st&quot;&gt;&quot;SELECT COUNT(*) FROM person&quot;&lt;/span&gt;;

        Object o = queryRunner.&lt;span class=&quot;fu&quot;&gt;query&lt;/span&gt;(sql, &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ScalarHandler&lt;/span&gt;());

        String ss = o.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;();
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;  s = Integer.&lt;span class=&quot;fu&quot;&gt;parseInt&lt;/span&gt;(ss);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; s;
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。习惯在微信看技术文章的同学，&lt;strong&gt;可以关注微信公众号:Java3y。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 19 Feb 2018 13:27:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8454470.html</dc:identifier>
</item>
<item>
<title>ORM规约变更经典案例---mysql军规 - 静儿1986</title>
<link>http://www.cnblogs.com/xiexj/p/8454209.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/8454209.html</guid>
<description>&lt;p&gt;　　先介绍一下《&lt;span id=&quot;doc-tittle-0&quot;&gt;MySQL数据库开发的三十六条军规》，这里只介绍核心的，具体内容大家可以自行百度，这是从底层开发人员到管理者必须知道规范。出自58赶集。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
写在前面的话：
　　总是在灾难发生后，才想起容灾的主要性；
　　总是在吃过亏后，才记得有人提醒过。&lt;br/&gt;核心军规：
      不在数据库做计算，CPU计算务必移至业务层；
      控制单表数据量，单表记录控制在千万级；
      控制列数量，字段数控制在20以内；
      平衡范式与冗余，为提高效率可以牺牲范式设计，冗余数据；
      拒绝3B(big)，大SQL、大数据、大批量
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　介绍两个例子。这个适合用STAR法则。STAR法则是情境(situation)、任务(task)、行动(action)、结论(result)四项的缩写。STAR法则是一种常常被面试官使用的工具。一般常说的开放性的问题，就是设立一个场景怎样解决问题基本用的是这种工具。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;案例1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以下是我们组发生的一个真实例子，具体操作和调研是由我两个同事实施的。&lt;/p&gt;
&lt;p&gt;情境：&lt;/p&gt;
&lt;p&gt;　　核心交易目前在进行代码重构，数据模型的重构是其中重要的一个环节。一天我们同事在进行DDL(Data Defination Lauguage)的变更，由于两个字段比较相近，但是其中一个是原有字段不可为空，另外一个是新增字段，允许为空，结果空字段被赋值给了非空字段，DDL执行导致大量异常。DDL变更回滚后日志恢复正常。&lt;/p&gt;
&lt;p&gt;任务：&lt;/p&gt;
&lt;p&gt;　　从java程序到连接mysql数据库用到了atlas、mybatis、数据库驱动到达mysql数据。而字段的映射是mybatis这样的ORM(Object Ralational Mapping)框架来处理的，我们的任务就是分析mybatis的源码和配置，找到问题的根源和以后要注意的事项。　&lt;/p&gt;
&lt;p&gt;行动：&lt;/p&gt;
&lt;p&gt;　　下载mybatis源码进行调试、分析。当前生产环境中，Mybatis版本是3.2.8.&lt;/p&gt;
&lt;p&gt;　　在使用mybatis时，有时可以不定义resultMap，直接在&amp;lt;select&amp;gt;语句上指定resultType。此时涉及到Mybatis的结果集自动映射。Mybatis的自动映射。Mybatis的自动映射默认开启。分析源码理解mybatis结果自动映射原理：&lt;/p&gt;
&lt;p&gt;　　1. mybatis自动映射预处理流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112728/201802/1112728-20180219194440616-1159301287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.自动映射流程(applyAutomaticMappings方法)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1112728/201802/1112728-20180219195108894-783525886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　  就是说applyAutomaticMappings要用到两个配置参数：mapUnderscoreToCamelCase和callSettersOnNulls。&lt;/p&gt;
&lt;p&gt;　　mapUnderscoreToCamelCase:是否开启驼峰命名。开启后会对大小写、下划线均不敏感。&lt;/p&gt;
&lt;p&gt;      callSettersOnNulls:是否在该字段值为null时将结果同时反射set赋值方法进行赋值。&lt;/p&gt;
&lt;p&gt;　　3. 自动驼峰命名规则测试实验&lt;/p&gt;
&lt;table class=&quot;wrapped fixed-table confluenceTable&quot;&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th class=&quot;confluenceTh&quot;&gt;实体属性&lt;/th&gt;
&lt;th class=&quot;confluenceTh&quot;&gt;字段名&lt;/th&gt;
&lt;th class=&quot;confluenceTh&quot;&gt;是否自动驼峰命名&lt;/th&gt;
&lt;th class=&quot;confluenceTh&quot;&gt;是否可以赋值&lt;/th&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;deviceId&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;device_id&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;true&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;赋值给deviceId&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;deviceId&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;device_id&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;false&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;没有赋值给deviceId&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;confluenceTd&quot;&gt;
&lt;p&gt;&lt;span&gt;traceno&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;traceNo&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;traceno&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;true&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;赋值给traceNo&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;confluenceTd&quot;&gt;
&lt;p&gt;&lt;span&gt;traceno&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;traceNo&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;trace_no&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;false&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;都没有进行赋值&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td class=&quot;confluenceTd&quot;&gt;
&lt;p&gt;&lt;span&gt;traceno&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;traceNo&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;trace_no&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;true&lt;/span&gt;&lt;/td&gt;
&lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;赋值给traceNo&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;结论：&lt;/p&gt;
&lt;p&gt;　　在映射时会先把没有在resultMap中定义字段映射的字段按照名称相同的方式自动映射到返回类型的对应属性上。自动映射会忽略下划线和大小写。&lt;/p&gt;
&lt;p&gt;　　Mybatis settings配置项说明应该仔细研读。&lt;/p&gt;
&lt;p&gt;　　字段定义各个字段之间的区分要尽可能的大，严禁使用只有大小写和下划线不同的两个字段。&lt;/p&gt;

&lt;p&gt;　　我们现在在做分享会和读书会，我的想法是这些学习活动要尽量贴近项目，做有深度的学习。代码是随便找个人培训一下就可以写的，但是写出代码的效率和可维护性等代码质量的要求决定了大公司对初级程序员要求的门槛。而对所有技术研究的深度决定了突发问题的解决能力，对后续的建设提出的指导和建议。&lt;/p&gt;

&lt;p&gt;案例2：&lt;/p&gt;
&lt;p&gt;　　《逆流而上》里介绍的一个案例。&lt;/p&gt;
&lt;p&gt;情境：&lt;/p&gt;
&lt;p&gt;　　在某次项目发布阶段（数据库使用了分库分表），因为业务需要新增表字段，从SQL的代码逻辑来看，使用了select *，新增字段应该是兼容的，但在做线上数据库DDL操作后，立即出现了日志错误数飙升报警。当回滚还未执行，日志错误就已经自动恢复。&lt;/p&gt;
&lt;p&gt;任务：&lt;/p&gt;
&lt;p&gt;　　从问题的现象来看，这个问题只有在变更过程中才出现，不太像是结果集映射问题，如果是映射问题，不执行回滚时无法自动恢复的。DBA反馈，可能是TDDL(Taobao Dustributed Data Layer分布式数据访问引擎)层对Select * 的解析逻辑引起DDL变更的不兼容。我们的任务就是确认问题发生的真正原因和对以后的指导意义。&lt;/p&gt;
&lt;p&gt;行动（分析过程）：&lt;/p&gt;
&lt;p&gt;　　1. TDDL在执行的时候，碰到select *,会从数据库表中解决出对应的全部字段：取第一个库的第一个表进行解析，解析之后，会缓存结果。替换*，然后在吧解析后的SQL语句交到目标数据库执行。&lt;/p&gt;
&lt;p&gt;　　2. 在第一个库变更后，TDDL拿到最新的字段列表，后续一段时间内的查询，都直接用带有新增字段的SQL语句提交到数据库执行；由于有部分数据库还没执行变更，没有新的字段，导致数据库执行出错，无法查询数据。&lt;/p&gt;
&lt;p&gt;结论：&lt;/p&gt;
&lt;p&gt; 　　对于此问题是分库分表中，持久层框架无对select *的兼容逻辑导致。&lt;/p&gt;
&lt;p&gt;　　但是使用select *的弊端不限于此，比如select * 查询非必需字段，会造成资源浪费甚至影响服务器性能；增加SQL的解析成本；表结构变更可能会引起字段映射问题；不会使用覆盖索引，不利于查询的性能优化等。&lt;/p&gt;
&lt;p&gt;　　《阿里巴巴编程规约》中对于ORM规范，有明确一条强制规约：在表查询中，一律不要使用*作为查询的字段列表，需要哪些字段必须明确写明。&lt;/p&gt;

&lt;p&gt;　　很多人问过我学习方法的问题，我觉得把这些基本规约和军规仔细研读，在平时的工作中多总结实践，也可以算作一个初级或者中级程序员的亮点了。技术追求体现在解决不了的问题追究到底，了解不了的问题研究到底。项目中问题不是天天有，但是这些理论怎样和实际结合确是天天要面对的问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;跑题时间：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　周末，男神在看电视，我照例在旁边垫子上一边做瑜伽一边陪看电视。看的是一部很老的电影《叶问前传》。看完之后我就跟男神分享心得：“你看叶问看起来正直厚道的一个人，做起事情来很讲究方法。想搞定女友，人家先搞定女友他爹。最后女友舍身救叶问，也得到了他爹实际上的支持。”&lt;/p&gt;
&lt;p&gt;　　女孩子和男孩子真的是来自两个星球。我看一个片子通常会想很多。但是我说出来的必定和实际发生的事情有一定的联系。但是男孩子通常是看不出来的。比如我跟男神说的上面的心得。是因为前一天晚上我俩聊天，他说看到一个姑娘比我还要超凡脱俗。&lt;/p&gt;
&lt;p&gt;　　我说你真要和她在一起，知道了她每月要买多少化妆品你就不这么想了。女孩子多半人前人后不一样。&lt;/p&gt;
&lt;p&gt;      男神说如果在外面见到我，可能没有那么喜欢我。我在外面看起来滑头滑脑的。&lt;/p&gt;
&lt;p&gt;　　我心想自己在外人看来基本上算是老年痴呆，但是职业习惯，见什么人说什么话。不然男神不爱吱声，我又不说话，我俩在别人看来简直一对怪胎。我也不点破，只对男神说：“你用词不当，这个词应该是‘古灵精怪’”。&lt;/p&gt;
&lt;p&gt;　　后来他说想找个小尼姑当小老婆。看样子他还是不太认同，觉得还是应该自己是一根木头，外面看起来就应该是一根木头，也不顾及别人跟你这根木头打交道到底会不会尴尬。&lt;/p&gt;
&lt;p&gt;　　所以我会有机会就旁敲侧击一下：做人要遵从本心，做事要灵活。&lt;/p&gt;
</description>
<pubDate>Mon, 19 Feb 2018 12:47:00 +0000</pubDate>
<dc:creator>静儿1986</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiexj/p/8454209.html</dc:identifier>
</item>
<item>
<title>画与软件项目 - draculav</title>
<link>http://www.cnblogs.com/saaav/p/6486532.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/saaav/p/6486532.html</guid>
<description>&lt;p&gt; 　　这篇博客开始写很久了，都已经在我随笔列表的第三页了，然而因为各种原因一直拖着没有写完，所以下面可能出现的最近未必是真的最近。还有最喜欢的两幅画没放进来，有些遗憾，分别是现藏于中国美术馆的万山红遍层林尽染和常熟田。因为一个意外的契机开始，很长时间以来不断的去各种画展，有美术馆、画院，也会去私人的画廊。虽然看不懂，但是毕竟好看的不好看还是能看出来的、赏心悦目，懂不懂什么的......。艺术可以触动人的感性思维，我就属于感性思维有缺陷的，期望能被艺术品感染一下，弥补点这方面的缺陷，或许也能借他山之石在技术方面有所感悟也未可知......吧，总之既然能感受其中的美目前也就足够了，就像某个段子说的，喜欢吃冰淇淋并不需要先学会制冷。看的时间长了就会有一些与自己工作相关的感触。另外，在听一些数学、力学课的时候，偶尔会意外得听到一些关于艺术的认识，我觉得很适合先给大家看一下。&lt;/p&gt;
&lt;p&gt;　　莱布尼茨：音乐，是人类精神通过无意识计算而获得的愉悦享受。&lt;/p&gt;
&lt;p&gt;　　下面这张图是我听清华力学课的时候，截下来的一张截图：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/445166/201802/445166-20180218153626608-2120122215.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　别的不多说，只说经常在美术馆听到的一类评价，这画画的真像。我个人是觉得画得像应该是相机出现以前的事，之后更多的应该是画家在画中表现出的感悟，或者某些画面对画家的触动，这类甚至在有些摄影艺术中也难以展现出来的令人&quot;愉悦&quot;的&quot;无意识计算&quot;。&lt;/p&gt;
&lt;p&gt;　　画家以画展示所思所感，观者因画中感性被画家心境引导出自己的心境。其实我们做需求的时候多数也是这样的，让客户提需求，很难能提出什么来，但是你做出点东西以后，他就会有这样那样的想法，这样那样的改法，相对这句话我们就是画作者，客户就是观者，我们需要引导出客户的真实需求，是想提高办公效率还是辅助标准化办公流程，我真实遇到过一个项目，客户提出的需求和最终的目的有一定冲突，事实上多数项目都有这种问题，只是有时候不难么明显，不过频繁修改的需求很多都是这种原因。&lt;/p&gt;
&lt;p&gt;　　关于开头的第一句话：“画家以画展示所思所感，观者因画中感性被画家心境引导出自己的心境”。太宗以史为鉴，我现在有机会以画为鉴，品味被画家引导出的自己的心境。以观者的角度体味能被画引导出的对自己的认识，凡事需先认清自己，方能择一适自己所行之路。有了需求就需要开始选型，能从画中发现自己有什么能与之共鸣，我们要使用什么样的技术和框架帮助自己完成项目，选择之前就要首先认清自己，擅长什么、能多大程度上使用从未接触的技术、团队的技术组成、人员性格、配合的默契程度等等。&lt;/p&gt;
&lt;p&gt;　　明确了自身的情况，也更容易设计出自己团队可以完成的业务模型，并在期限内完成它。由于接连不断的去看画，总是有新的想法，所以改了很多次，原本打算在博客最后引出的我对贴在&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/saaav/p/4548019.html&quot;&gt;DDD初学指南&lt;/a&gt;&lt;span class=&quot;postTitle2&quot;&gt;的对评论的回答，但是由于某天看了王衍成先生的画，于是我决定在这部分写了。关于“&lt;code class=&quot;csharp plain&quot;&gt;业务模型更接近现实&lt;/code&gt;”这回事，其实早几年我也是这么想的，但是逐渐改变了看法，业务模型应该是为了更好完成我们的系统而设计的。粗略的看上去似乎并不冲突，但目的不同，结果也会有很大不同。首先，业务模型是抽象的，是为了表达系统最终目的而做出的只为完成系统的目的抽象。相对的”更接近现实“这种说法更贴近于实现。并且现实方方面面就像米特奥拉说的“这个世界的信息是多层次的，无论多无聊的信息都不会用单一的表达形式，存在这样的复杂性”，而好的业务模型一定是以最精简的抽象来表达系统所要完成的目标，比如王先生的这幅画：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　　　　　　　　　　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201704/445166-20170426165359709-439519654.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实开始没什么感觉，只觉得是水边倒影，直到走到这个角度：&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201705/445166-20170501145337679-2064396635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　说句实在话，走到这个角度，其实我也完全不知道他在画什么，但是这时这幅画突然给我一种林间小路的感觉，虽然本来觉得更像是水面，不过感觉到了上午紧张工作的大脑突然放松了，不管作者究竟想表达什么，看画人有所触动也就够了，就像某些阅读理解的答案中常说的：留给读者无限的想象空间。画通过画家对所画之物的抽象来表达画的核心，软件通过业务逻辑的抽象来体现软件的核心价值。&lt;/p&gt;
&lt;p&gt;　　王先生的画几乎画名都是无题，他应该只是想传达他的一种感性，一种体会到的感觉，并不想说明白那是什么，其实感性很多时候是没法说明白的，所以才说是无意识的计算，只要目的达到了，究竟画的是什么不太重要。软件模型也是，最重要的不是设计出了什么，而是是否完成了目标，模型是手段，手段通常是不应该喧宾夺主的。当然，这并不是说手段不重要，画的名字本身就是落在画之外的一种手段：&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201705/445166-20170501150802007-948220095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　画名很多时候是核心概念的表达，相对于软件是系统的核心价值，业务方的表达倾向于描述现实他们需要的功能，而这可能并不是软件真正的需求，有时候在需求说明书的不起眼套路段落中，有时候甚至不会出现。他们的目的或许是加快工作效率，或许是限制职能权限，或许是调整业务方向，如果不确认好真正的目的，只按他们对现实的描述去做，绝大多数时候会导致后期大幅调整，这一点不只是业务，在技术理论中也是一样的，某一处差之毫厘，整个系统谬以千里。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201707/445166-20170713165448259-1531570608.png&quot; alt=&quot;由于总是在看画，所以这博客写的不免有些臃肿，然而忍不住啊，这画说实在初看没什么感觉，然而一看名字，乾坤一草堂，再看画面，以草堂为中心顿感草堂之简与画面自然映照，一种我描述不好的美感与心中产生。&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这画说实在初看时没什么感觉，然而一看名字，乾坤一草堂，再看画面，以草堂为中心顿感草堂之简与画面自然映照，其草堂当为诗人画家观湖光山色之处，满幅乾坤图尽收与草堂之中，顿感豪气，令人精神振奋。名字之重要程度可见一斑。而做需求的时候也不能仅仅关注系统之内的功能，系统之外的主题更是核心。&lt;/p&gt;
&lt;p&gt;　　王先生的画对我们来说可能有些太抽象了，我们来看一个不那么抽象的，并且有名字的：&lt;/p&gt;
&lt;p&gt; 　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201705/445166-20170501145421351-1851263875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这幅画也是在中国美术馆看到的，时间由点长了，没记错的话画名叫蓝天，作者是张立国先生。这幅画最重要的部分很显然左上角的一小块蓝天，能说明它是蓝天模型的也只有一小块云，或者还有它的位置，然而已经足够表现出它作为核心子领域的业务概念了；这幅画的架构清晰，表达出来的业务对象也非常明确，但并没有去逐渐贴近现实去建模；三面围墙（姑且认为是墙吧）和墙下之人以及一点蓝天就是整幅画，画中之人或许在望天或许是渴望轻松自然；墙的颜色不同，也或许是现代化的生活筑起的高墙隔开了人与人之间的关系，然而他们或许都是向往着同一片蓝天，当然三人也可能在同一件屋子中。至于究竟如何，或许不重要，每个人的触动或许也是如人饮水冷暖自知，看懂画家在画什么并不重要，只要对画有所触动，便也算没有白看，画的价值也在与此。清晰的架构和业务模型，更利于表达相对清晰的感情，至少我的感想被限定在了一个小范围内，而王先生那副画，有时看着像林间小路，有时候又觉得草树池塘，偶尔还会春绿秋黄，但一切都是为了最终目的，无题亦是主题，不能因为技术洁癖或对模型本身的最求而使目标有所偏差。一幅画要想感染人，我想画家并不是单纯的只想画得像，不然照照片就可以了；软件同样如此，我们开发软件目的并不是要让它做出现实人做的事，而是让用户借助它更好的完成工作。&lt;/p&gt;
&lt;p&gt;　　刚刚提到了，好的模型一定是最简化的模型，大家都明白这个道理，但是做的时候，经常会不自觉的为了让模型看起来逻辑上更完整，更“合理”而增加些东西，例如群里曾经讨论过论坛帖子的回复是否要作为帖子聚合的对象，因为帖子删了，回复的存在可能就没有意义了，但是这个看起来逻辑上更完整的约束是否有价值就未必了。1+1=2，是因为抽象出了现实中的数量这一属性，但是如果一个1是男人，另外一个是女性，这1+1极有可能结果会是3，然而数学可不能这么算，所以业务模型的抽象与真实的现实，并不一定要统一。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201703/445166-20170321211356221-1901870290.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是在一家私人画廊看的，虽然不是画，不过也差不多，关于这件作品的讲解：http://www.vart.cc/guides/1141?fragment=9799，我也不多介绍了。此作品的作者农西奥的一句名言，大家有没有觉得比较熟悉。。。&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201703/445166-20170321211100580-922909301.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;338&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　到这可以先小结一下开篇的那个问题了，模型未必应该贴近现实，而是抽象出现实的某一部分，其实这也并不是很贴切，模型的目的是为了更好的实现整个系统，只是一般情况下这样更容易开发而已，关于部分抽象这事可以看一下下面的作品与现实的对比，我就不多说了，更何况一个完全不按现实去抽象的模型就一定不利于系统开发么，面向对象出现以前就没有好的软件系统么？&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201707/445166-20170709173050493-1218178171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图为潘天寿先生的画与原型对比。其实前些天公司组织去长城拓展，我拍的照片总觉得不好看，一度非常怀疑我莱卡的镜头，后来想明白了：之所以看着很好看，但拍出来效果不好是因为人会选择性忽略一些不重要的东西，相机不会，所以有电线等东西照进来，所以会感觉没看到的好看，经常在美术馆拍的画也是，现场看很漂亮，但是很多画是在玻璃保护中，玻璃的反光导致照下来的根本看不出效果。所以画也好我们的模型也好，如果想要满意，该忽略的东西无论在现实中多重要都是要忽略的。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201705/445166-20170531184936383-1370704254.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个问题我的看法大概就是这样了，似乎这个结并不怎么小，不过就不要在意这些细节了。&lt;/p&gt;
&lt;p&gt;　　开篇就是一张抽象画可能不是很容易找到方向欣赏画。其实小学就学过，万物都是有联系的。画和程序都是人创作出来的，既然不懂美术，可以试着从软件的角度来欣赏一副画，即使和原作者想表达的不同，只要能有所得就不算白看了，就像nginx，本来是个静态服务器，但是有几个人真是从静态服务器的角度用的。&lt;/p&gt;
&lt;p&gt;　　最容易看明白的画当属素描了（其他如静物画和油画也多包涵浓重的感情色彩），我之所以觉得素描的传达的感情色彩少，主要是因为它多是一种记录写实，是真正作品创作前的一个标记，用来引导艺术家回忆起当时的感觉（不算学生练笔的），毕竟直接在荒山野岭画出成品来即使有素描版，多半也不会展出，我反正是没见过。也不是说素描一点感情色彩都没有，当然是有一定倾向的，但是我看不出来（极个别除外），手里画的图片太多了，常见的铅笔素描没翻到，但是找到了几张水墨写生：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/445166/201802/445166-20180219105932517-401248640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　素描很多时候看不出，我个人觉得可能也不需要看出画家想表达什么，多是对应成品来欣赏的，虽然这两幅也不是完全没有韵味。在软件中，这类还比较多，比如一些通用的开源框架，如Spring Boot，它没有业务含义，但作为一个可以拿过来就用组件也是非常不错的，本身也是相当不错的架构。&lt;/p&gt;
&lt;p&gt;　　基础设施在有一定的业务倾向，甚至于需求讨论之前就可以进行，但可能是伴随着业务的开发才逐步完成的。关于业务模型的建立和落实到开发上，多数现在还是一个并列的过程，一次性设计一个完整的模型，之后再按着模型按部就班的开发。但是这种方式其实是几十年前的经典，在一定规模下，还是成功的。而现在已经不再是那个时代了，市场瞬息万变，政策也总在调整，需求无法一成不变。若是一个工期一年以上的项目，按第一版出的模型去做，股市可能都差了几千点了。其实，画画也是需要一遍一遍迭代的。&lt;/p&gt;
&lt;p&gt;                                              &lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201704/445166-20170425162813928-149375049.jpg&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　先有一个大体方向，然后从主要部分开始，一点一点的丰满，再细化迭代。我试验过一些建模和落地的理论，其中在项目中最成功的应该属于测试驱动+T型功能导向集成（在&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/saaav/p/3936902.html&quot;&gt;功能构建&lt;/a&gt;中描述过）。比如人像，脸当然是最重要的部分，于是先构造出头部轮廓，再以头部轮廓为基础，逐渐延展开来。对于开发，我们就先开发最核心、稳定的模型和功能，以此为基础，逐渐开展相关的模型和功能，并根据实际情况逐渐调整，比如今天碳...不够...黑，就多图两笔...什么的。测试驱动开发也是一个非常好的实践，很适合辅助功能导向的集成。以单元测试组成业务的结构，也就是画的轮廓组成，最初的被测试方法内部可能只是返回了个伪造的结果，过程中也不一定时时刻刻都是完善的，脸第一次上色的第四幅看上去并不怎么好看，集成测试开始后，结合整个画面也可以看出到了第五幅脸似乎颜色有些过重了，就根据当时的具体情况对功能做一定的调整，为了项目的顺利完成，对需求和功能甚至于模型进行适当的删减调整也是必要的。当集成测试完成，色彩填充画的各部分的精神被联结起来，被单元测试过的代码内部实现丰满连通，画就完成了。&lt;/p&gt;

&lt;p&gt;                           &lt;img src=&quot;https://images2017.cnblogs.com/blog/445166/201802/445166-20180219111104767-1364046702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　                           　&lt;img src=&quot;https://images2017.cnblogs.com/blog/445166/201802/445166-20180219111218314-246837475.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其实，我本来是想用齐白石老先生的草稿来着，那一系列草稿更明显更丰富，然而我没找到，那些草稿在画院，偶尔会展出，碰到的时候再说吧。对于上面这画，人像应该就属于核心子域，但是只有一个核心是不成的，其实经常也能看到一些不错的话，但是画面不够丰满，给人的感觉总想缺了什么的。 对这幅画来说，画面上的题字恰到好处。软件架构通常也是围绕着业务核心，延展出各个通用子领域，各部分相互独立，但并不能缺少。一旦某部分的业务膨胀，也可以将其独立为一个上下文，它对于原有系统是一个支持子域，对于自身也是一个核心子域。也有遇到过这种情况，一幅画上的题字特别漂亮，大家都不去关心主要部分的画，而是看字了，而既然被展出了，就说明了其艺术价值。这种情况也并不是坏事，比如互联网企业本身就是随着市场发展而变化，比如只去京东和亚马逊自营买东西，大家也少不了用支付宝。&lt;/p&gt;
&lt;p&gt;　　核心子域和非核心子域在开发中投入的比重也未必一定是核心最重，比如上面的乾坤一草堂。我们在做项目的时候，每一层面都是在找一个平衡，因为平衡并不是有固定规律的，所以很多书才会说，软件是门艺术。我在网上听清华大学数学建模课程的时候，姜启源教授曾讲过，技术大致有章可循，而艺术无法归纳成普遍使用的准则。虽然姜教授是在讲数学建模，但我认为贯穿整个项目的每一个部分都是这样的，无论是需求与开发团队资源之间的平衡、模型距离现实远近之间的平衡，还是开发时实现的优雅与性能之间的平衡（当然，个别时候未必不可兼得）。这些平衡并无一定之规。比如下面这幅环保题材的画，小姑娘、彩色的气球、小狗、后面的烟囱、以及看不清后面是工厂还是废墟的影影绰绰，无处不是模糊与清晰之间平衡的体现，清晰一点或再模糊一些都未必能有如此效果。&lt;/p&gt;
&lt;p&gt;　　                            　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201706/445166-20170616144053165-976921226.jpg&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　也不必为框框架架约束，不一定实现的要华丽。极有可能很简单的实现也能恰到好处，当然，恰到好处说起来容易，既然无法规定普适的规则怎么办呢，我的经验是，当模型或实现等可以让自己觉得不别扭、或者念头通畅就可以了。开头莱布尼茨的名言暗示了一点，我们的无意识计算或者直觉可以帮助我们找到自己根据现有资源所能达到的最好平衡。&lt;/p&gt;
&lt;p&gt;　　最后再看一幅画，这幅画非常简单，但传达的感性非常丰满。我们做软件也是一样，只要有合适的数据结构，体会画的动与静，抽象程度未必需要非常精细，特地强调这点因为说起来容易，其实很多人，尤其是有代码洁癖的人非常容易把数据结构设计的非常精致，下手之前还在想要把握分寸，但是一旦开始就一发不可收拾，我以前就经常这样。下面这幅画中核心部分是一个出门迎接阳光的人，这人看起来只是随便画了些轮廓阴影，但是恰到好处，线条并不觉得乱，而大面积的房间简约而不简单，墙上一幅树叶既使画面丰满，也能突出主人向往春天，我初看时还有一种在家临渊慕鱼不如出门享受阳关，退而结网脚踏实地一步一步走出去的感觉。&lt;/p&gt;
&lt;p&gt; 　　　　　                　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/445166/201703/445166-20170305085648485-857751910.jpg&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;

&lt;p&gt;------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;公众号：&lt;/p&gt;

&lt;p&gt;                                                                                &lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dLzFictDamzbKZpj5nOwxClXmOMElzyXXc2BVQcBzoLjicwzZYyq4ZSEe4fH1sPVp5ibeO5GJwOVsO8KW4tojQ9fw/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dLzFictDamzbKZpj5nOwxClXmOMElzyXXc2BVQcBzoLjicwzZYyq4ZSEe4fH1sPVp5ibeO5GJwOVsO8KW4tojQ9fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;





</description>
<pubDate>Mon, 19 Feb 2018 08:57:00 +0000</pubDate>
<dc:creator>draculav</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/saaav/p/6486532.html</dc:identifier>
</item>
</channel>
</rss>