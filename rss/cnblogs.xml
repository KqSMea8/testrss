<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>scala成长之路（7）函数进阶——可能是史上最浅显易懂的闭包教程 - 王亚楼</title>
<link>http://www.cnblogs.com/wangyalou/p/9601939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangyalou/p/9601939.html</guid>
<description>&lt;p&gt;由于scala中函数内部能定义函数，且函数能作为函数的返回值，那么问题来了，当返回的函数使用了外层函数的局部变量时，会发生什么呢？没错，就产生是闭包。&lt;/p&gt;
&lt;p&gt;关于闭包的解释网上一大堆，但基本上都是照葫芦画瓢，一个模子刻出来的，说来说去都只讲了“内部函数引用外层函数的局部变量”这个刻板的定义，根本没降到精髓。精髓是什么？且看我一句话给你讲清楚：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;闭包就是外层函数函数的对象，外层函数就是闭包的构造函数！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;怎么样，是不是摸不着头脑？其实是这样，我们使用闭包的目的并不是为了引用外层函数的局部变量，这只是手段，不是目的；我们的最终目的其实是函数的定制化，即按照一定的模板根据输出生成具有不同功能的函数，其实就是“&lt;strong&gt;函数的函数&lt;/strong&gt;”。这里我们马上可以想到，就相当于“类”的思想，能根据不同的构造函数产生不同的“类的对象”。其实这里就是利用了这种思路，把外层函数当做构造函数，利用传入的参数进行定制，生成具有不同功能的函数并返回。&lt;/p&gt;
&lt;p&gt;道理我都懂，但这跟“引用局部变量”有什么关系？很简单呀，比方说外层函数就是一个毛坯房，返回的函数时精装修房，那么外层函数的参数是装修图纸，最终得到的房子肯定是要用到这个图纸或者图纸的衍生物的，因此为了实现定制化，很定要依靠于外层函数的局部变量。&lt;/p&gt;
&lt;p&gt;但是这里有个问题：我们都知道，正常来说函数的局部变量是存储在栈内存的，而对象是存储在堆内存的，因此同一个类可能存在多个对象，而函数在执行完成之后栈内存就会释放，因此不会存在多份函数的局部变量。但是根据我们上边的分析，定制化的函数肯定是要用到局部变量的，而且不同的定制化肯定是要保存多份局部变量，且相互之间空间独立的，就如同不同的对象一样。那么scala是怎么解决这个问题的呢？根据这篇文章 https://www.jianshu.com/p/8f24150fad2a 的介绍，scala在生成闭包时使用了一个临时对象来保存外层函数中的局部变量，因此可以算是将当前堆内存中的变量拷贝了一份到栈内存中，因此实现了多份局部空间的并存，以及函数闭包。&lt;/p&gt;

</description>
<pubDate>Thu, 06 Sep 2018 15:26:00 +0000</pubDate>
<dc:creator>王亚楼</dc:creator>
<og:description>scala的闭包讲解，可能是史上最浅显易懂的闭包教程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangyalou/p/9601939.html</dc:identifier>
</item>
<item>
<title>我的第一个python web开发框架（37）——职位管理功能 - AllEmpty</title>
<link>http://www.cnblogs.com/EmptyFS/p/9601845.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EmptyFS/p/9601845.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　对于职位管理，我们可以理解它为角色权限的管理，就像前面所说的一样，有了职位管理，后台管理系统绑定好对应的权限以后，新进员工、离职或岗位调整，管理员操作起来就非常的便捷了，只需要重新绑定对应职位就可以做好权限的切换工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为了方便职位管理，我们可以将页面设计成下面这个样子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/129385/201809/129385-20180906215151345-302946307.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　左边显示部分列表，点击其中一个项后，右边显示对应部门的职位，然后再对职位进行增、改、删等操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　左边我们可以直接使用上一章的部门列表接口，然后将jqGrid前端组件修改一下，只显示名称一列就可以了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　然后在前端代码中的jqGrid组件中，增加onSelectRow方法，点击列表项时执行右边列表查询和刷新操作就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　右边需要增加职位列表查询接口，查询时需要提交部门id作为查询条件，具体接口代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/system/positions/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback():
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    获取列表数据
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 部门id&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     department_id = convert_helper.to_int0(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;department_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;部门id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页面索引&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     page_number = convert_helper.to_int1(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False))
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 页面页码与显示记录数量&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     page_size = convert_helper.to_int0(web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False))
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     sidx = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sidx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     sord = web_helper.get_query(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sord&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, is_check_null=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化排序字段&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     order_by = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id asc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; sidx:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         order_by = sidx + &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt; +&lt;span&gt; sord
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     _positions_logic =&lt;span&gt; positions_logic.PositionsLogic()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取记录&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     wheres = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; department_id:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         wheres = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;department_id=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; str(department_id)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     result = _positions_logic.get_list(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, wheres, page_number, page_size, order_by)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直接输出json&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; json.dumps(result)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;查询失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　代码看起来是否感觉很熟悉，和前端列表查询的代码差不多，只是接收参数、查询条件和调用的类不一样而已。所以我们只需要熟悉工具函数、底层ORM方法和调用方法，写起代码来就非常便捷，代码的可读性也大大增强了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接着我们来处理新增职位操作，新增职位时，需要管理填写的内容只有职位名称，因为所属部门与部门编码在页面中可以直接带过来，另一个操作就是设置访问权限了，这也是我们整个权限管理中最重要的一个环节&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/129385/201809/129385-20180906222717287-1554256049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　由上图可以看到，设置访问权限它是一个树列表，它使用的是ztree控件，按它要求的格式，将列表值传给ztree控件就可以自动生成这样的树列表了，然后前端代码通过ztree控件的onCheck方法，获取所有勾选项对应的菜单项id，组合成权限字串提交到接口，更新到数据表中，该职位就拥有了我们所勾选的所有权限了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于访问权限树列表的展示，首先，它需要读取菜单列表，输出ztree控件要求的格式；其次，我们在编辑职位权限时，需要对已拥有权限的项自动打上勾，这个我们也可以直接在接口中输出对应的参数来进行设置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以我们可以在上一章的menu_info.py文件中，增加下面接口来处理，通过提交过来的职位id，来获取该职位拥有的权限，然后通过逐项判断菜单项与权限的关系，来判断是否打勾。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/api/system/menu_info/positions/&amp;lt;id:int&amp;gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback(id):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    根据用户职位权限获取列表数据（树列表），为已有权限的数据赋值
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     _menu_info_logic =&lt;span&gt; menu_info_logic.MenuInfoLogic()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取记录（ztree控件需要输出记录id、父id、树节点名称、节点是否扩开这几项参数）&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     result = _menu_info_logic.get_list(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id, parent_id, name, not is_leaf as open, false as checked&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; result &lt;span&gt;and&lt;/span&gt; result.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取指定的职位记录&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         _positions_logic =&lt;span&gt; positions_logic.PositionsLogic()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         positions_logic_model =&lt;span&gt; _positions_logic.get_model_for_cache(id)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; positions_logic_model:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取该职位权限字串&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             page_power = positions_logic_model.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page_power&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断当前菜单项id是否存在于该职位的权限字串中&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; model &lt;span&gt;in&lt;/span&gt;&lt;span&gt; result.get('rows'):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果存在，则表示当前职位拥有该菜单项的权限，即在菜单权限列表中需要打勾&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(model.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 0)) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; page_power:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     model[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;checked&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(0, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tree_list&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: result.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)})
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;查询失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　我们再来看看点击保存后，执行新增职位记录接口代码是怎么实现的&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @post(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/system/positions/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback():
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    新增记录
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     name = web_helper.get_form(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;角色名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     department_id = convert_helper.to_int0(web_helper.get_form(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;department_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;部门id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     page_power = web_helper.get_form(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page_power&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;权限列表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, is_check_null=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     _department_logic =&lt;span&gt; department_logic.DepartmentLogic()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取对应的部门记录&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     department_result =&lt;span&gt; _department_logic.get_model_for_cache(department_id)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; department_result:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;部门不存在&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     _positions_logic =&lt;span&gt; positions_logic.PositionsLogic()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 组合更新字段&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     fields =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: string(name),
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;department_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: department_id,
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;department_code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: string(department_result.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;code&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;)),
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;department_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: string(department_result.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;)),
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;page_power&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: string(page_power),
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取记录&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     result =&lt;span&gt; _positions_logic.add_model(fields)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直接输出json&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;提交成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这段代码跟之前的新增也差不多，先是接收提交的参数，然后组合更新字典，再调用提交到数据表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　修改职位权限功能跟上面的类似，不过接口中需要增加一个获取职位记录实体的接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/system/positions/&amp;lt;id:int&amp;gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback(id):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    获取指定记录
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     _positions_logic =&lt;span&gt; positions_logic.PositionsLogic()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取记录&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     result =&lt;span&gt; _positions_logic.get_model_for_cache(id)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直接输出json&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, result)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;查询失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; @put(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/system/positions/&amp;lt;id:int&amp;gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback(id):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    修改记录
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     name = web_helper.get_form(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;角色名称&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     department_id = convert_helper.to_int0(web_helper.get_form(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;department_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;部门id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     page_power = web_helper.get_form(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;page_power&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;权限列表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, is_check_null=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; page_power == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         page_power = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     _positions_logic =&lt;span&gt; positions_logic.PositionsLogic()
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     positions_result =&lt;span&gt; _positions_logic.get_model_for_cache(id)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; department_id != positions_result.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;department_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;该角色所属部门错误，请与管理员联系&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 组合更新字段&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     fields =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: string(name),
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;'&lt;/span&gt;&lt;span&gt;page_power&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: string(page_power),
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 读取记录&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     result =&lt;span&gt; _positions_logic.edit_model(id, fields)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直接输出json&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;提交成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, result)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;提交失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　最后是删除接口，我们在执行删除操作时，一定要判断它是否已绑定了管理员账号，不然直接删除后，管理员登录后台系统以后将没有任何权限，无法做任何操作。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @delete(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/system/positions/&amp;lt;id:int&amp;gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; callback(id):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    删除指定记录
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断要删除的记录是否被引用，是的话不能删除&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     _manager_logic =&lt;span&gt; manager_logic.ManagerLogic()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; _manager_logic.exists(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;positions_id=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; str(id)):
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前职位已绑定相关管理员，不能直接删除&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除记录&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     _positions_logic =&lt;span&gt; positions_logic.PositionsLogic()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     result =&lt;span&gt; _positions_logic.delete_model(id)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 直接输出json&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(0, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;删除成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; web_helper.return_msg(-1, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;删除失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;a href=&quot;https://pan.baidu.com/s/10cwvW2MHxEVdsdGNFngKVA&quot; target=&quot;_blank&quot;&gt;本文对应的源码下载&lt;/a&gt; &lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;版权声明：本文原创发表于 &lt;a href=&quot;http://www.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;博客园&lt;/span&gt;&lt;/a&gt;，作者为 &lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/EmptyFS/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;AllEmpty&lt;/span&gt;&lt;/a&gt; &lt;/strong&gt;本文欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则视为侵权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;python开发QQ群：669058475    作者博客：http://www.cnblogs.com/EmptyFS/&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Sep 2018 15:16:00 +0000</pubDate>
<dc:creator>AllEmpty</dc:creator>
<og:description>对于职位管理，我们可以理解它为角色权限的管理，就像前面所说的一样，有了职位管理，后台管理系统绑定好对应的权限以后，新进员工、离职或岗位调整，管理员操作起来就非常的便捷了，只需要重新绑定对应职位就可以做</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EmptyFS/p/9601845.html</dc:identifier>
</item>
<item>
<title>Win32之隐藏DLL隐藏模块技术 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/9601860.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/9601860.html</guid>
<description>&lt;p&gt;这一讲涉及到windows底层技术.跟汇编内容. 我们才可以实现模块隐藏(也称为DLL隐藏)&lt;/p&gt;

&lt;h2&gt;一丶API反汇编勾引兴趣&lt;/h2&gt;
&lt;p&gt;　　我们都用过Windows的进程跟线程API  也就是 GetCurrentThreadId() 跟 GetCurrentProcessId():&lt;/p&gt;
&lt;p&gt;一个是获取进程ID,一个是线程ID&lt;/p&gt;
&lt;p&gt;那么我们利用反汇编技术.看看其实现代码是什么.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180906185156649-1044752317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到使用了FS寄存器.并且获取18内容. 然后+20内容获取出我们的进程Pid&lt;/p&gt;
&lt;p&gt;那么FS寄存器是什么.&lt;/p&gt;
&lt;h2&gt;二丶FS寄存器简介&lt;/h2&gt;
&lt;p&gt;　　FS寄存器如果学习过内核的同学们应该知道.段选择子. 在这里就不说了.&lt;/p&gt;
&lt;p&gt;FS是执向一个TEB结构的一个寄存器. TEB结构是什么. TEB结构是线程环境快. 保存了当前的线程的信息.&lt;/p&gt;
&lt;p&gt;MSDN中.TEB是一个假的TEB.只告诉你有这个东西. 具体我们需要时Windbg查看结构体成员.&lt;/p&gt;
&lt;p&gt;MSDN链接: &lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/desktop/api/winternl/ns-winternl-_teb&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/windows/desktop/api/winternl/ns-winternl-_teb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用WinDbg的dt命令即可查看.&lt;/p&gt;
&lt;p&gt;如下图:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180906185530039-1969744077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们通过反汇编.知道了TEB结构的地址 .也就是 mov eax,dword ptr fs:[0x18]&lt;/p&gt;
&lt;p&gt;那么其实Windows底层也提供了一个获取TEB结构的API . NtCurrentTeb()  返回TEB的地址.因为TEB结构我们并没有.所以直接用DWORD接受即可.&lt;/p&gt;
&lt;p&gt;当然可以通过dt TEB知道结构体的成员. 那么我们可以伪造. 不过这个不是我们的重点.&lt;/p&gt;
&lt;p&gt;首先Win32下TEB 的结构跟64位下的TEB结构不一样.&lt;/p&gt;
&lt;p&gt;32位下 TEB获取是 mov eax,fs:[0x18]  64位下是 mov rax,qword ptr gs:[0x30] 具体的可以自己逆向一个访问TEB的API查看即可.&lt;/p&gt;
&lt;h2&gt;三丶以32位讲解. 熟悉TEB结构体.&lt;/h2&gt;
&lt;p&gt;　　这里直接列出dt出来的32位下的TEB结构体&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
+&lt;span&gt;0x000&lt;/span&gt; NtTib            : _NT_TIB                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;TIB结构.存储栈信息&lt;/span&gt;
   +&lt;span&gt;0x01c&lt;/span&gt;&lt;span&gt; EnvironmentPointer : Ptr32 Void              
   &lt;/span&gt;+&lt;span&gt;0x020&lt;/span&gt; ClientId         : _CLIENT_ID                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存进程ID跟线程ID&lt;/span&gt;
   +&lt;span&gt;0x028&lt;/span&gt;&lt;span&gt; ActiveRpcHandle  : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0x02c&lt;/span&gt;&lt;span&gt; ThreadLocalStoragePointer : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0x030&lt;/span&gt; ProcessEnvironmentBlock : Ptr32 _PEB   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;PEB进程环境快结构.&lt;/span&gt;
   +&lt;span&gt;0x034&lt;/span&gt;&lt;span&gt; LastErrorValue   : Uint4B
   &lt;/span&gt;+&lt;span&gt;0x038&lt;/span&gt;&lt;span&gt; CountOfOwnedCriticalSections : Uint4B
   &lt;/span&gt;+&lt;span&gt;0x03c&lt;/span&gt;&lt;span&gt; CsrClientThread  : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0x040&lt;/span&gt;&lt;span&gt; Win32ThreadInfo  : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0x044&lt;/span&gt; User32Reserved   : [&lt;span&gt;26&lt;/span&gt;&lt;span&gt;] Uint4B
   &lt;/span&gt;+&lt;span&gt;0x0ac&lt;/span&gt; UserReserved     : [&lt;span&gt;5&lt;/span&gt;&lt;span&gt;] Uint4B
   &lt;/span&gt;+&lt;span&gt;0x0c0&lt;/span&gt;&lt;span&gt; WOW32Reserved    : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0x0c4&lt;/span&gt;&lt;span&gt; CurrentLocale    : Uint4B
   &lt;/span&gt;+&lt;span&gt;0x0c8&lt;/span&gt;&lt;span&gt; FpSoftwareStatusRegister : Uint4B
   &lt;/span&gt;+&lt;span&gt;0x0cc&lt;/span&gt; SystemReserved1  : [&lt;span&gt;54&lt;/span&gt;&lt;span&gt;] Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0x1a4&lt;/span&gt;&lt;span&gt; ExceptionCode    : Int4B
   &lt;/span&gt;+&lt;span&gt;0x1a8&lt;/span&gt;&lt;span&gt; ActivationContextStackPointer : Ptr32 _ACTIVATION_CONTEXT_STACK
   &lt;/span&gt;+&lt;span&gt;0x1ac&lt;/span&gt; SpareBytes       : [&lt;span&gt;36&lt;/span&gt;&lt;span&gt;] UChar
   &lt;/span&gt;+&lt;span&gt;0x1d0&lt;/span&gt;&lt;span&gt; TxFsContext      : Uint4B
   &lt;/span&gt;+&lt;span&gt;0x1d4&lt;/span&gt;&lt;span&gt; GdiTebBatch      : _GDI_TEB_BATCH
   &lt;/span&gt;+&lt;span&gt;0x6b4&lt;/span&gt;&lt;span&gt; RealClientId     : _CLIENT_ID
   &lt;/span&gt;+&lt;span&gt;0x6bc&lt;/span&gt;&lt;span&gt; GdiCachedProcessHandle : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0x6c0&lt;/span&gt;&lt;span&gt; GdiClientPID     : Uint4B
   &lt;/span&gt;+&lt;span&gt;0x6c4&lt;/span&gt;&lt;span&gt; GdiClientTID     : Uint4B
   &lt;/span&gt;+&lt;span&gt;0x6c8&lt;/span&gt;&lt;span&gt; GdiThreadLocalInfo : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0x6cc&lt;/span&gt; Win32ClientInfo  : [&lt;span&gt;62&lt;/span&gt;&lt;span&gt;] Uint4B
   &lt;/span&gt;+&lt;span&gt;0x7c4&lt;/span&gt; glDispatchTable  : [&lt;span&gt;233&lt;/span&gt;&lt;span&gt;] Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xb68&lt;/span&gt; glReserved1      : [&lt;span&gt;29&lt;/span&gt;&lt;span&gt;] Uint4B
   &lt;/span&gt;+&lt;span&gt;0xbdc&lt;/span&gt;&lt;span&gt; glReserved2      : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xbe0&lt;/span&gt;&lt;span&gt; glSectionInfo    : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xbe4&lt;/span&gt;&lt;span&gt; glSection        : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xbe8&lt;/span&gt;&lt;span&gt; glTable          : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xbec&lt;/span&gt;&lt;span&gt; glCurrentRC      : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xbf0&lt;/span&gt;&lt;span&gt; glContext        : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xbf4&lt;/span&gt;&lt;span&gt; LastStatusValue  : Uint4B
   &lt;/span&gt;+&lt;span&gt;0xbf8&lt;/span&gt;&lt;span&gt; StaticUnicodeString : _UNICODE_STRING
   &lt;/span&gt;+&lt;span&gt;0xc00&lt;/span&gt; StaticUnicodeBuffer : [&lt;span&gt;261&lt;/span&gt;&lt;span&gt;] Wchar
   &lt;/span&gt;+&lt;span&gt;0xe0c&lt;/span&gt;&lt;span&gt; DeallocationStack : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xe10&lt;/span&gt; TlsSlots         : [&lt;span&gt;64&lt;/span&gt;&lt;span&gt;] Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xf10&lt;/span&gt;&lt;span&gt; TlsLinks         : _LIST_ENTRY
   &lt;/span&gt;+&lt;span&gt;0xf18&lt;/span&gt;&lt;span&gt; Vdm              : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xf1c&lt;/span&gt;&lt;span&gt; ReservedForNtRpc : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xf20&lt;/span&gt; DbgSsReserved    : [&lt;span&gt;2&lt;/span&gt;&lt;span&gt;] Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xf28&lt;/span&gt;&lt;span&gt; HardErrorMode    : Uint4B
   &lt;/span&gt;+&lt;span&gt;0xf2c&lt;/span&gt; Instrumentation  : [&lt;span&gt;9&lt;/span&gt;&lt;span&gt;] Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xf50&lt;/span&gt;&lt;span&gt; ActivityId       : _GUID
   &lt;/span&gt;+&lt;span&gt;0xf60&lt;/span&gt;&lt;span&gt; SubProcessTag    : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xf64&lt;/span&gt;&lt;span&gt; EtwLocalData     : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xf68&lt;/span&gt;&lt;span&gt; EtwTraceData     : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xf6c&lt;/span&gt;&lt;span&gt; WinSockData      : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xf70&lt;/span&gt;&lt;span&gt; GdiBatchCount    : Uint4B
   &lt;/span&gt;+&lt;span&gt;0xf74&lt;/span&gt;&lt;span&gt; CurrentIdealProcessor : _PROCESSOR_NUMBER
   &lt;/span&gt;+&lt;span&gt;0xf74&lt;/span&gt;&lt;span&gt; IdealProcessorValue : Uint4B
   &lt;/span&gt;+&lt;span&gt;0xf74&lt;/span&gt;&lt;span&gt; ReservedPad0     : UChar
   &lt;/span&gt;+&lt;span&gt;0xf75&lt;/span&gt;&lt;span&gt; ReservedPad1     : UChar
   &lt;/span&gt;+&lt;span&gt;0xf76&lt;/span&gt;&lt;span&gt; ReservedPad2     : UChar
   &lt;/span&gt;+&lt;span&gt;0xf77&lt;/span&gt;&lt;span&gt; IdealProcessor   : UChar
   &lt;/span&gt;+&lt;span&gt;0xf78&lt;/span&gt;&lt;span&gt; GuaranteedStackBytes : Uint4B
   &lt;/span&gt;+&lt;span&gt;0xf7c&lt;/span&gt;&lt;span&gt; ReservedForPerf  : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xf80&lt;/span&gt;&lt;span&gt; ReservedForOle   : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xf84&lt;/span&gt;&lt;span&gt; WaitingOnLoaderLock : Uint4B
   &lt;/span&gt;+&lt;span&gt;0xf88&lt;/span&gt;&lt;span&gt; SavedPriorityState : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xf8c&lt;/span&gt;&lt;span&gt; SoftPatchPtr1    : Uint4B
   &lt;/span&gt;+&lt;span&gt;0xf90&lt;/span&gt;&lt;span&gt; ThreadPoolData   : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xf94&lt;/span&gt;&lt;span&gt; TlsExpansionSlots : Ptr32 Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xf98&lt;/span&gt;&lt;span&gt; MuiGeneration    : Uint4B
   &lt;/span&gt;+&lt;span&gt;0xf9c&lt;/span&gt;&lt;span&gt; IsImpersonating  : Uint4B
   &lt;/span&gt;+&lt;span&gt;0xfa0&lt;/span&gt;&lt;span&gt; NlsCache         : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xfa4&lt;/span&gt;&lt;span&gt; pShimData        : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xfa8&lt;/span&gt;&lt;span&gt; HeapVirtualAffinity : Uint4B
   &lt;/span&gt;+&lt;span&gt;0xfac&lt;/span&gt;&lt;span&gt; CurrentTransactionHandle : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xfb0&lt;/span&gt;&lt;span&gt; ActiveFrame      : Ptr32 _TEB_ACTIVE_FRAME
   &lt;/span&gt;+&lt;span&gt;0xfb4&lt;/span&gt;&lt;span&gt; FlsData          : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xfb8&lt;/span&gt;&lt;span&gt; PreferredLanguages : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xfbc&lt;/span&gt;&lt;span&gt; UserPrefLanguages : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xfc0&lt;/span&gt;&lt;span&gt; MergedPrefLanguages : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xfc4&lt;/span&gt;&lt;span&gt; MuiImpersonation : Uint4B
   &lt;/span&gt;+&lt;span&gt;0xfc8&lt;/span&gt;&lt;span&gt; CrossTebFlags    : Uint2B
   &lt;/span&gt;+&lt;span&gt;0xfc8&lt;/span&gt; SpareCrossTebBits : Pos &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;&lt;span&gt; Bits
   &lt;/span&gt;+&lt;span&gt;0xfca&lt;/span&gt;&lt;span&gt; SameTebFlags     : Uint2B
   &lt;/span&gt;+&lt;span&gt;0xfca&lt;/span&gt; SafeThunkCall    : Pos &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; Bit
   &lt;/span&gt;+&lt;span&gt;0xfca&lt;/span&gt; InDebugPrint     : Pos &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; Bit
   &lt;/span&gt;+&lt;span&gt;0xfca&lt;/span&gt; HasFiberData     : Pos &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; Bit
   &lt;/span&gt;+&lt;span&gt;0xfca&lt;/span&gt; SkipThreadAttach : Pos &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; Bit
   &lt;/span&gt;+&lt;span&gt;0xfca&lt;/span&gt; WerInShipAssertCode : Pos &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; Bit
   &lt;/span&gt;+&lt;span&gt;0xfca&lt;/span&gt; RanProcessInit   : Pos &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; Bit
   &lt;/span&gt;+&lt;span&gt;0xfca&lt;/span&gt; ClonedThread     : Pos &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; Bit
   &lt;/span&gt;+&lt;span&gt;0xfca&lt;/span&gt; SuppressDebugMsg : Pos &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; Bit
   &lt;/span&gt;+&lt;span&gt;0xfca&lt;/span&gt; DisableUserStackWalk : Pos &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; Bit
   &lt;/span&gt;+&lt;span&gt;0xfca&lt;/span&gt; RtlExceptionAttached : Pos &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; Bit
   &lt;/span&gt;+&lt;span&gt;0xfca&lt;/span&gt; InitialThread    : Pos &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; Bit
   &lt;/span&gt;+&lt;span&gt;0xfca&lt;/span&gt; SpareSameTebBits : Pos &lt;span&gt;11&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt; Bits
   &lt;/span&gt;+&lt;span&gt;0xfcc&lt;/span&gt;&lt;span&gt; TxnScopeEnterCallback : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xfd0&lt;/span&gt;&lt;span&gt; TxnScopeExitCallback : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xfd4&lt;/span&gt;&lt;span&gt; TxnScopeContext  : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0xfd8&lt;/span&gt;&lt;span&gt; LockCount        : Uint4B
   &lt;/span&gt;+&lt;span&gt;0xfdc&lt;/span&gt;&lt;span&gt; SpareUlong0      : Uint4B
   &lt;/span&gt;+&lt;span&gt;0xfe0&lt;/span&gt; ResourceRetValue : Ptr32 Void
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据上图我们首先看注释的成员.因为成员很多.只讲解重要的.其余成员可以通过Google获取.&lt;/p&gt;
&lt;p&gt;_NT_TIB结构.这个结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180906190207930-376459810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存了栈从哪里开始到哪里结束.版本信息.等等.&lt;/p&gt;
&lt;p&gt;下面的是 保存进程ID跟线程ID的结构体. 我们看一下.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180906190312162-269020599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进程ID是 1db8 线程ID是 0x394&lt;/p&gt;
&lt;p&gt;上面的命令windbg可以通过点击. 我是点击的所以命令很乏在. dx....... xxxx&lt;/p&gt;
&lt;p&gt;我们直接可以使用 dt _CLIENT_ID 地址 来看.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180906190456285-1491575070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TEB首地址我们知道是 fs:[0x18] 所以我们db一下看看地址是什么.下面会使用这个地址.&lt;/p&gt;
&lt;p&gt;上面我们知道了  _CLIENT_ID结构体了.那么我们就可以自己不适用API 然后获取进程PID了跟线程PID了.&lt;/p&gt;
&lt;h2&gt;四丶使用代码实现自己的获取进程PID跟线程PID函数.&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DWORD GetMyCurrentProcessPid32()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取自己进程的PID&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    1.使用API 获取TEB首地址  NtCurrentTeb(); 
    2.使用汇编获取
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;API 获取TEB的地址
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DWORD dwTebAddress = (DWORD)NtCurrentTeb();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 64是 GS:[30]  模块首地址

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dwTebAddress = dwTebAddress + 0x20; 

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DWORD dwPid = *(DWORD *)dwTebAddress;&lt;/span&gt;
&lt;span&gt;
    DWORD dwPid &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;    __asm
    {
        mov eax, fs:[&lt;/span&gt;&lt;span&gt;0x18&lt;/span&gt;&lt;span&gt;]
        add eax, &lt;/span&gt;&lt;span&gt;0x20          //加0x20是获取进程pid + 0x24则是获取线程PID&lt;/span&gt;&lt;span&gt;
        mov eax,[eax]
        mov dwPid,eax
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dwPid;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果懂了上面的结构.那么上面的代码就很好理解了. 上面有两种方法实现.一个是指针实现.也就是通过NtCurrentTeb()获取TEB结构.自己加偏移取内容得出进程PID&lt;/p&gt;
&lt;p&gt;另一种就是汇编了.&lt;/p&gt;
&lt;p&gt;汇编很简单.&lt;/p&gt;
&lt;p&gt;　　1.首先获取TEB结构首地址&lt;/p&gt;
&lt;p&gt;　　2.TEB结构首地址 + 0x20偏移 获取到的是 _CLIENT_ID结构.&lt;/p&gt;
&lt;p&gt;　　3.因为是结构本身.所以对 [eax] 也就是对eax取内容.得出进程PID&lt;/p&gt;
&lt;p&gt;　　4.将进程PID赋值给变量.然后下方返回.&lt;/p&gt;
&lt;p&gt;实验代码截图:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180906191259168-419546893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完全可以获取出来.&lt;/p&gt;
&lt;p&gt;上面实现自己的API只是对TEB结构有一个认识.知道可以做什么.&lt;/p&gt;
&lt;p&gt;下面贴一份64位程序获取自己的进程PID&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;LONGLONG GetMyCurrentProcessPid64()
{
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    1.使用API 获取TEB首地址  NtCurrentTeb();
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;API 获取TEB的地址&lt;/span&gt;
    __int64 dwTebAddress = (__int64)NtCurrentTeb();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; GS:[30]  模块首地址&lt;/span&gt;
&lt;span&gt;
    dwTebAddress &lt;/span&gt;= dwTebAddress + &lt;span&gt;0x40&lt;/span&gt;&lt;span&gt;;              //64位改成40偏移了.具体偏移自己使用Windbg查看64的环境下的TEB结构.不多解释.

    __int64 dwPid &lt;/span&gt;= *(__int64 *&lt;span&gt;)dwTebAddress;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dwPid;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;五丶PEB结构&lt;/h2&gt;
&lt;p&gt;　　其实最主要的是我们要将的PEB结构.&lt;/p&gt;
&lt;p&gt;　　PEB就是进程环境块.保存了进程的一些列细心.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180906191419283-1471817392.png&quot; alt=&quot;&quot;/&gt;  如果是32位情况下则是+0x30&lt;/p&gt;
&lt;p&gt;我们看下PEB结构中的信息&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[+&lt;span&gt;0x000&lt;/span&gt;] InheritedAddressSpace : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x001&lt;/span&gt;] ReadImageFileExecOptions : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x002&lt;/span&gt;] BeingDebugged    : &lt;span&gt;0x1&lt;/span&gt; [Type: unsigned &lt;span&gt;char&lt;/span&gt;]           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个char类型.为1表示调试状态.为0表示没有调试.可以用于反调试. API也是从这里获取的标志&lt;/span&gt;
    [+&lt;span&gt;0x003&lt;/span&gt;] BitField         : &lt;span&gt;0x8&lt;/span&gt; [Type: unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x003&lt;/span&gt; ( &lt;span&gt;0&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;)] ImageUsesLargePages : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x003&lt;/span&gt; ( &lt;span&gt;1&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;)] IsProtectedProcess : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x003&lt;/span&gt; ( &lt;span&gt;2&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;)] IsLegacyProcess  : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x003&lt;/span&gt; ( &lt;span&gt;3&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;)] IsImageDynamicallyRelocated : &lt;span&gt;0x1&lt;/span&gt; [Type: unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x003&lt;/span&gt; ( &lt;span&gt;4&lt;/span&gt;: &lt;span&gt;4&lt;/span&gt;)] SkipPatchingUser32Forwarders : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x003&lt;/span&gt; ( &lt;span&gt;7&lt;/span&gt;: &lt;span&gt;5&lt;/span&gt;)] SpareBits        : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x004&lt;/span&gt;] Mutant           : &lt;span&gt;0xffffffff&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x008&lt;/span&gt;] ImageBaseAddress : &lt;span&gt;0x11d0000&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x00c&lt;/span&gt;] Ldr              : &lt;span&gt;0x77190200&lt;/span&gt; [Type: _PEB_LDR_DATA *]   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于模块隐藏的结构体&lt;/span&gt;
    [+&lt;span&gt;0x010&lt;/span&gt;] ProcessParameters : &lt;span&gt;0x7216d0&lt;/span&gt; [Type: _RTL_USER_PROCESS_PARAMETERS *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x014&lt;/span&gt;] SubSystemData    : &lt;span&gt;0x0&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x018&lt;/span&gt;] ProcessHeap      : &lt;span&gt;0x720000&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x01c&lt;/span&gt;] FastPebLock      : &lt;span&gt;0x77192100&lt;/span&gt; [Type: _RTL_CRITICAL_SECTION *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x020&lt;/span&gt;] AtlThunkSListPtr : &lt;span&gt;0x0&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x024&lt;/span&gt;] IFEOKey          : &lt;span&gt;0x0&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x028&lt;/span&gt;] CrossProcessFlags : &lt;span&gt;0x2&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x028&lt;/span&gt; ( &lt;span&gt;0&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;)] ProcessInJob     : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x028&lt;/span&gt; ( &lt;span&gt;1&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;)] ProcessInitializing : &lt;span&gt;0x1&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x028&lt;/span&gt; ( &lt;span&gt;2&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;)] ProcessUsingVEH  : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x028&lt;/span&gt; ( &lt;span&gt;3&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;)] ProcessUsingVCH  : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x028&lt;/span&gt; ( &lt;span&gt;4&lt;/span&gt;: &lt;span&gt;4&lt;/span&gt;)] ProcessUsingFTH  : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x028&lt;/span&gt; (&lt;span&gt;31&lt;/span&gt;: &lt;span&gt;5&lt;/span&gt;)] ReservedBits0    : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x02c&lt;/span&gt;] KernelCallbackTable : &lt;span&gt;0x0&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x02c&lt;/span&gt;] UserSharedInfoPtr : &lt;span&gt;0x0&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x030&lt;/span&gt;] SystemReserved   [Type: unsigned &lt;span&gt;long&lt;/span&gt; [&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]]
    [&lt;/span&gt;+&lt;span&gt;0x034&lt;/span&gt;] AtlThunkSListPtr32 : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x038&lt;/span&gt;] ApiSetMap        : &lt;span&gt;0x40000&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x03c&lt;/span&gt;] TlsExpansionCounter : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x040&lt;/span&gt;] TlsBitmap        : &lt;span&gt;0x77194250&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x044&lt;/span&gt;] TlsBitmapBits    [Type: unsigned &lt;span&gt;long&lt;/span&gt; [&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]]
    [&lt;/span&gt;+&lt;span&gt;0x04c&lt;/span&gt;] ReadOnlySharedMemoryBase : &lt;span&gt;0x7efe0000&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x050&lt;/span&gt;] HotpatchInformation : &lt;span&gt;0x0&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x054&lt;/span&gt;] ReadOnlyStaticServerData : &lt;span&gt;0x7efe0a90&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; * *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x058&lt;/span&gt;] AnsiCodePageData : &lt;span&gt;0x7efa0000&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x05c&lt;/span&gt;] OemCodePageData  : &lt;span&gt;0x7efa0000&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x060&lt;/span&gt;] UnicodeCaseTableData : &lt;span&gt;0x7efd0028&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x064&lt;/span&gt;] NumberOfProcessors : &lt;span&gt;0x8&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x068&lt;/span&gt;] NtGlobalFlag     : &lt;span&gt;0x70&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x070&lt;/span&gt;] CriticalSectionTimeout : {-&lt;span&gt;25920000000000&lt;/span&gt;&lt;span&gt;} [Type: _LARGE_INTEGER]
    [&lt;/span&gt;+&lt;span&gt;0x078&lt;/span&gt;] HeapSegmentReserve : &lt;span&gt;0x100000&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x07c&lt;/span&gt;] HeapSegmentCommit : &lt;span&gt;0x2000&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x080&lt;/span&gt;] HeapDeCommitTotalFreeThreshold : &lt;span&gt;0x10000&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x084&lt;/span&gt;] HeapDeCommitFreeBlockThreshold : &lt;span&gt;0x1000&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x088&lt;/span&gt;] NumberOfHeaps    : &lt;span&gt;0x1&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x08c&lt;/span&gt;] MaximumNumberOfHeaps : &lt;span&gt;0x10&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x090&lt;/span&gt;] ProcessHeaps     : &lt;span&gt;0x77194760&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; * *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x094&lt;/span&gt;] GdiSharedHandleTable : &lt;span&gt;0x0&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x098&lt;/span&gt;] ProcessStarterHelper : &lt;span&gt;0x0&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x09c&lt;/span&gt;] GdiDCAttributeList : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x0a0&lt;/span&gt;] LoaderLock       : &lt;span&gt;0x771920c0&lt;/span&gt; [Type: _RTL_CRITICAL_SECTION *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x0a4&lt;/span&gt;] OSMajorVersion   : &lt;span&gt;0x6&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x0a8&lt;/span&gt;] OSMinorVersion   : &lt;span&gt;0x1&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x0ac&lt;/span&gt;] OSBuildNumber    : &lt;span&gt;0x1db1&lt;/span&gt; [Type: unsigned &lt;span&gt;short&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x0ae&lt;/span&gt;] OSCSDVersion     : &lt;span&gt;0x100&lt;/span&gt; [Type: unsigned &lt;span&gt;short&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x0b0&lt;/span&gt;] OSPlatformId     : &lt;span&gt;0x2&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x0b4&lt;/span&gt;] ImageSubsystem   : &lt;span&gt;0x3&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x0b8&lt;/span&gt;] ImageSubsystemMajorVersion : &lt;span&gt;0x6&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x0bc&lt;/span&gt;] ImageSubsystemMinorVersion : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x0c0&lt;/span&gt;] ActiveProcessAffinityMask : &lt;span&gt;0xff&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x0c4&lt;/span&gt;] GdiHandleBuffer  [Type: unsigned &lt;span&gt;long&lt;/span&gt; [&lt;span&gt;34&lt;/span&gt;&lt;span&gt;]]
    [&lt;/span&gt;+&lt;span&gt;0x14c&lt;/span&gt;] PostProcessInitRoutine : &lt;span&gt;0x0&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; (*&lt;span&gt;)()]
    [&lt;/span&gt;+&lt;span&gt;0x150&lt;/span&gt;] TlsExpansionBitmap : &lt;span&gt;0x77194248&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x154&lt;/span&gt;] TlsExpansionBitmapBits [Type: unsigned &lt;span&gt;long&lt;/span&gt; [&lt;span&gt;32&lt;/span&gt;&lt;span&gt;]]
    [&lt;/span&gt;+&lt;span&gt;0x1d4&lt;/span&gt;] SessionId        : &lt;span&gt;0x1&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x1d8&lt;/span&gt;] AppCompatFlags   : {&lt;span&gt;0x0&lt;/span&gt;&lt;span&gt;} [Type: _ULARGE_INTEGER]
    [&lt;/span&gt;+&lt;span&gt;0x1e0&lt;/span&gt;] AppCompatFlagsUser : {&lt;span&gt;0x0&lt;/span&gt;&lt;span&gt;} [Type: _ULARGE_INTEGER]
    [&lt;/span&gt;+&lt;span&gt;0x1e8&lt;/span&gt;] pShimData        : &lt;span&gt;0x0&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x1ec&lt;/span&gt;] AppCompatInfo    : &lt;span&gt;0x0&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x1f0&lt;/span&gt;] CSDVersion       : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Service Pack 1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; [Type: _UNICODE_STRING]
    [&lt;/span&gt;+&lt;span&gt;0x1f8&lt;/span&gt;] ActivationContextData : &lt;span&gt;0x60000&lt;/span&gt; [Type: _ACTIVATION_CONTEXT_DATA *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x1fc&lt;/span&gt;] ProcessAssemblyStorageMap : &lt;span&gt;0x0&lt;/span&gt; [Type: _ASSEMBLY_STORAGE_MAP *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x200&lt;/span&gt;] SystemDefaultActivationContextData : &lt;span&gt;0x50000&lt;/span&gt; [Type: _ACTIVATION_CONTEXT_DATA *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x204&lt;/span&gt;] SystemAssemblyStorageMap : &lt;span&gt;0x0&lt;/span&gt; [Type: _ASSEMBLY_STORAGE_MAP *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x208&lt;/span&gt;] MinimumStackCommit : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x20c&lt;/span&gt;] FlsCallback      : &lt;span&gt;0x0&lt;/span&gt; [Type: _FLS_CALLBACK_INFO *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x210&lt;/span&gt;&lt;span&gt;] FlsListHead      [Type: _LIST_ENTRY]
    [&lt;/span&gt;+&lt;span&gt;0x218&lt;/span&gt;] FlsBitmap        : &lt;span&gt;0x77194240&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x21c&lt;/span&gt;] FlsBitmapBits    [Type: unsigned &lt;span&gt;long&lt;/span&gt; [&lt;span&gt;4&lt;/span&gt;&lt;span&gt;]]
    [&lt;/span&gt;+&lt;span&gt;0x22c&lt;/span&gt;] FlsHighIndex     : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x230&lt;/span&gt;] WerRegistrationData : &lt;span&gt;0x0&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x234&lt;/span&gt;] WerShipAssertPtr : &lt;span&gt;0x0&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x238&lt;/span&gt;] pContextData     : &lt;span&gt;0x70000&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x23c&lt;/span&gt;] pImageHeaderHash : &lt;span&gt;0x0&lt;/span&gt; [Type: &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x240&lt;/span&gt;] TracingFlags     : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x240&lt;/span&gt; ( &lt;span&gt;0&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;)] HeapTracingEnabled : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x240&lt;/span&gt; ( &lt;span&gt;1&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;)] CritSecTracingEnabled : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt;]
    [&lt;/span&gt;+&lt;span&gt;0x240&lt;/span&gt; (&lt;span&gt;31&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;)] SpareTracingBits : &lt;span&gt;0x0&lt;/span&gt; [Type: unsigned &lt;span&gt;long&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个结构中我们简单了解一下. &lt;/p&gt;
&lt;p&gt;第一个注释的地方.那个地方可以用于反调试. 如果我们程序是调试状态.那么这个位置则为1.否则正常状态启动则为0&lt;/p&gt;
&lt;p&gt;第二个是我们用于模块隐藏的一个结构.  执向一个 _PEB_LDR_DATA的结构&lt;/p&gt;
&lt;p&gt;我们看下这个结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180906192105270-1078101303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个结构. +0c偏移 看名字.是一个保存模块列表信息的一个结构. 其中执向的是一个_LIST_ENTRY这是一个双向链表. 其实真正执向的结构不是这个.&lt;/p&gt;
&lt;p&gt;而是: _LDR_DATA_TABLE_ENTRY 结构.而这个结构MSDN也说了.但是结构成员是不缺定的.所以我们继续使用Windbg查看就可以得出这个结构真实的面目.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180906192453284-1706613727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们看到这个结构就会发现一个新天地.这个结构中保存了模块信息. 其中 + 0偏移 + 8 偏移就是上面的双向链表.只不过windows把下面的成员给我们隐藏了.&lt;/p&gt;

&lt;h2&gt;六丶_LDR_DATA_TABLE_ENTRY 结构成员解析&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;DR_DATA_TABLE_ENTRY
ntdll&lt;/span&gt;!&lt;span&gt;_LDR_DATA_TABLE_ENTRY
   &lt;/span&gt;+&lt;span&gt;0x000&lt;/span&gt;&lt;span&gt; InLoadOrderLinks : _LIST_ENTRY                         双向链表头
   &lt;/span&gt;+&lt;span&gt;0x008&lt;/span&gt;&lt;span&gt; InMemoryOrderLinks : _LIST_ENTRY                       双向链表尾
   &lt;/span&gt;+&lt;span&gt;0x010&lt;/span&gt;&lt;span&gt; InInitializationOrderLinks : _LIST_ENTRY
   &lt;/span&gt;+&lt;span&gt;0x018&lt;/span&gt;&lt;span&gt; DllBase          : Ptr32 Void                          dll模块基址.
   &lt;/span&gt;+&lt;span&gt;0x01c&lt;/span&gt;&lt;span&gt; EntryPoint       : Ptr32 Void                          dll模块入口点
   &lt;/span&gt;+&lt;span&gt;0x020&lt;/span&gt;&lt;span&gt; SizeOfImage      : Uint4B                              镜像大小
   &lt;/span&gt;+&lt;span&gt;0x024&lt;/span&gt;&lt;span&gt; FullDllName      : _UNICODE_STRING    UNICODE_STRING结构的模块路径
   &lt;/span&gt;+&lt;span&gt;0x02c&lt;/span&gt;&lt;span&gt; BaseDllName      : _UNICODE_STRING
   &lt;/span&gt;+&lt;span&gt;0x034&lt;/span&gt;&lt;span&gt; Flags            : Uint4B
   &lt;/span&gt;+&lt;span&gt;0x038&lt;/span&gt;&lt;span&gt; LoadCount        : Uint2B
   &lt;/span&gt;+&lt;span&gt;0x03a&lt;/span&gt;&lt;span&gt; TlsIndex         : Uint2B
   &lt;/span&gt;+&lt;span&gt;0x03c&lt;/span&gt;&lt;span&gt; HashLinks        : _LIST_ENTRY
   &lt;/span&gt;+&lt;span&gt;0x03c&lt;/span&gt;&lt;span&gt; SectionPointer   : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0x040&lt;/span&gt;&lt;span&gt; CheckSum         : Uint4B
   &lt;/span&gt;+&lt;span&gt;0x044&lt;/span&gt;&lt;span&gt; TimeDateStamp    : Uint4B
   &lt;/span&gt;+&lt;span&gt;0x044&lt;/span&gt;&lt;span&gt; LoadedImports    : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0x048&lt;/span&gt;&lt;span&gt; EntryPointActivationContext : Ptr32 _ACTIVATION_CONTEXT
   &lt;/span&gt;+&lt;span&gt;0x04c&lt;/span&gt;&lt;span&gt; PatchInformation : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0x050&lt;/span&gt;&lt;span&gt; ForwarderLinks   : _LIST_ENTRY
   &lt;/span&gt;+&lt;span&gt;0x058&lt;/span&gt;&lt;span&gt; ServiceTagLinks  : _LIST_ENTRY
   &lt;/span&gt;+&lt;span&gt;0x060&lt;/span&gt;&lt;span&gt; StaticLinks      : _LIST_ENTRY
   &lt;/span&gt;+&lt;span&gt;0x068&lt;/span&gt;&lt;span&gt; ContextInformation : Ptr32 Void
   &lt;/span&gt;+&lt;span&gt;0x06c&lt;/span&gt;&lt;span&gt; OriginalBase     : Uint4B
   &lt;/span&gt;+&lt;span&gt;0x070&lt;/span&gt; LoadTime         : _LARGE_INTEGER
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;知道上面的结构.那么我们要实现模块隐藏就很简单了.&lt;/p&gt;
&lt;p&gt;思路:&lt;/p&gt;
&lt;p&gt;　　我们获取到了这个结构.因为是链表.可以遍历链表. 根据DllBase判断 你的模块基址跟这个模块基址是否一样.如果一样那么我们就断开链表&lt;/p&gt;
&lt;p&gt;也就是把当前模块的链表头跟尾巴.执向下一个. 保证没有链表执向即可.&lt;/p&gt;
&lt;p&gt;实现一个模块隐藏很简单.难的就是上面的结构.我们必须要熟悉.偏移要知道.我们才可以做到模块隐藏.&lt;/p&gt;
&lt;p&gt;具体代码我会放到下面. 然后讲解代码.&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;Windows.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;

DWORD g_isHide &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _UNICODE_STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING, &lt;/span&gt;*&lt;span&gt;PUNICODE_STRING;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _PEB_LDR_DATA {
    ULONG                   Length;
    BOOLEAN                 Initialized;
    PVOID                   SsHandle;
    LIST_ENTRY              InLoadOrderModuleList;
    LIST_ENTRY              InMemoryOrderModuleList;
    LIST_ENTRY              InInitializationOrderModuleList;
} PEB_LDR_DATA, &lt;/span&gt;*&lt;span&gt;PPEB_LDR_DATA;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; _LDR_MODULE
{
    LIST_ENTRY          InLoadOrderModuleList;   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;+0x00&lt;/span&gt;
    LIST_ENTRY          InMemoryOrderModuleList; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;+0x08  &lt;/span&gt;
    LIST_ENTRY          InInitializationOrderModuleList; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;+0x10&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;*               BaseAddress;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;+0x18&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;*               EntryPoint;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;+0x1c&lt;/span&gt;
&lt;span&gt;    ULONG               SizeOfImage;
    UNICODE_STRING      FullDllName;
    UNICODE_STRING      BaseDllName;
    ULONG               Flags;
    SHORT               LoadCount;
    SHORT               TlsIndex;
    HANDLE              SectionHandle;
    ULONG               CheckSum;
    ULONG               TimeDateStamp;
} LDR_MODULE, &lt;/span&gt;*&lt;span&gt;PLDR_MODULE;
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; HideDll()　　　　　　　　　　　　　　　　　　　　　　　　　　//这个函数是主要的
{
    HMODULE hMod &lt;/span&gt;= ::GetModuleHandle(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ntdll.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    PLIST_ENTRY Head, Cur;
    PPEB_LDR_DATA ldr;
    PLDR_MODULE ldm;
    __asm
    {
        mov eax, fs:[&lt;/span&gt;&lt;span&gt;0x30&lt;/span&gt;&lt;span&gt;]　　　　　　　　　　　　　　　　　　//获取PEB结构
        mov ecx, [eax &lt;/span&gt;+ &lt;span&gt;0x0c&lt;/span&gt;] &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Ldr                     //获取_PEB_LDR_DATA结构&lt;/span&gt;
&lt;span&gt;        mov ldr, ecx
    }
    Head &lt;/span&gt;= &amp;amp;(ldr-&amp;gt;&lt;span&gt;InLoadOrderModuleList);               //获取模块链表地址
    Cur &lt;/span&gt;= Head-&amp;gt;&lt;span&gt;Flink;                                  //获取指向的结点.
    &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
    {
        ldm &lt;/span&gt;=&lt;span&gt; CONTAINING_RECORD(Cur, LDR_MODULE, InLoadOrderModuleList); //获取 _LDR_DATA_TABLE_ENTRY结构体地址
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;printf(&quot;EntryPoint [0x%X]\n&quot;,ldm-&amp;gt;BaseAddress);&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (hMod == ldm-&amp;gt;&lt;span&gt;BaseAddress)                                    //判断要隐藏的DLL基址跟结构中的基址是否一样
        {
            g_isHide &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;                                                //如果进入.则标志置为1,表示已经开始进行隐藏了.
            ldm&lt;/span&gt;-&amp;gt;InLoadOrderModuleList.Blink-&amp;gt;Flink =                    //双向链表. 断开链表&lt;span&gt;
                ldm&lt;/span&gt;-&amp;gt;&lt;span&gt;InLoadOrderModuleList.Flink;
            ldm&lt;/span&gt;-&amp;gt;InLoadOrderModuleList.Flink-&amp;gt;Blink =&lt;span&gt;
                ldm&lt;/span&gt;-&amp;gt;&lt;span&gt;InLoadOrderModuleList.Blink;
            ldm&lt;/span&gt;-&amp;gt;InInitializationOrderModuleList.Blink-&amp;gt;Flink =&lt;span&gt;
                ldm&lt;/span&gt;-&amp;gt;&lt;span&gt;InInitializationOrderModuleList.Flink;
            ldm&lt;/span&gt;-&amp;gt;InInitializationOrderModuleList.Flink-&amp;gt;Blink =&lt;span&gt;
                ldm&lt;/span&gt;-&amp;gt;&lt;span&gt;InInitializationOrderModuleList.Blink;
            ldm&lt;/span&gt;-&amp;gt;InMemoryOrderModuleList.Blink-&amp;gt;Flink =&lt;span&gt;
                ldm&lt;/span&gt;-&amp;gt;&lt;span&gt;InMemoryOrderModuleList.Flink;
            ldm&lt;/span&gt;-&amp;gt;InMemoryOrderModuleList.Flink-&amp;gt;Blink =&lt;span&gt;
                ldm&lt;/span&gt;-&amp;gt;&lt;span&gt;InMemoryOrderModuleList.Blink;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        Cur &lt;/span&gt;= Cur-&amp;gt;&lt;span&gt;Flink;
    } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (Head !=&lt;span&gt; Cur);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;按键开始隐藏\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    getchar();
    HideDll();

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (g_isHide == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;没有成功隐藏\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        system(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;成功隐藏\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    system(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面是我们隐藏ntdll.看一下没有隐藏的时候&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180906230905997-632309741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;隐藏一下ntdll看下.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180906230830301-1762992277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 06 Sep 2018 15:09:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<og:description>Win32之隐藏DLL隐藏模块技术 这一讲涉及到windows底层技术.跟汇编内容. 我们才可以实现模块隐藏(也称为DLL隐藏) 一丶API反汇编勾引兴趣 我们都用过Windows的进程跟线程API</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/9601860.html</dc:identifier>
</item>
<item>
<title>机器学习之支持向量机—SVM原理代码实现 - w_x_w1985</title>
<link>http://www.cnblogs.com/further-further-further/p/9596898.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/further-further-further/p/9596898.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;Created on Tue Sep  4 16:58:16 2018
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;支持向量机代码实现
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;SMO(Sequential Minimal Optimization)最小序列优化
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;@author: weixw
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;核转换函数（一个特征空间映射到另一个特征空间，低维空间映射到高维空间）&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;高维空间解决线性问题，低维空间解决非线性问题&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;线性内核 = 原始数据矩阵（100*2）与原始数据第一行矩阵转秩乘积（2*1） =&amp;gt;（100*1）&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;非线性内核公式：k(x,y) = exp(-||x - y||**2/2*(e**2))&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1.原始数据每一行与原始数据第一行作差， &lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;2.平方   &lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; kernelTrans(dataMat, rowDataMat, kTup):
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     m,n=&lt;span&gt;np.shape(dataMat)
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化核矩阵 m*1&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;     K = np.mat(np.zeros((m,1&lt;span&gt;)))
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; kTup[0] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;lin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;#&lt;/span&gt;&lt;span&gt;线性核&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;         K = dataMat*&lt;span&gt;rowDataMat.T
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;elif&lt;/span&gt; kTup[0] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;非线性核&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(m):
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;xi - xj&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt;             deltaRow = dataMat[j,:] -&lt;span&gt; rowDataMat
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;             K[j] = deltaRow*&lt;span&gt;deltaRow.T
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1*m m*1 =&amp;gt; 1*1&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;         K = np.exp(K/(-2*kTup[1]**2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;: &lt;span&gt;raise&lt;/span&gt; NameError(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Houston We Have a Problem -- That Kernel is not recognized&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; K
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         
&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义数据结构体，用于缓存，提高运行速度&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; optStruct:
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, dataSet, labelSet, C, toler, kTup):
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         self.dataMat = np.mat(dataSet) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;原始数据，转换成m*n矩阵&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;         self.labelMat = np.mat(labelSet).T &lt;span&gt;#&lt;/span&gt;&lt;span&gt;标签数据 m*1矩阵&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;         self.C = C &lt;span&gt;#&lt;/span&gt;&lt;span&gt;惩罚参数，C越大，容忍噪声度小，需要优化；反之，容忍噪声度高，不需要优化；&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;                    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;所有的拉格朗日乘子都被限制在了以C为边长的矩形里&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt;         self.toler = toler &lt;span&gt;#&lt;/span&gt;&lt;span&gt;容忍度&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;         self.m = np.shape(self.dataMat)[0] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;原始数据行长度&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;         self.alphas = np.mat(np.zeros((self.m,1))) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; alpha系数，m*1矩阵&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;         self.b = 0 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;偏置&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;         self.eCache = np.mat(np.zeros((self.m,2))) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 保存原始数据每行的预测值&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;         self.K = np.mat(np.zeros((self.m,self.m))) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 核转换矩阵 m*m&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(self.m):
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;             self.K[:,i] =&lt;span&gt; kernelTrans(self.dataMat, self.dataMat[i,:], kTup)
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算原始数据第k项对应的预测误差  1*m m*1 =&amp;gt;1*1  &lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;oS：结构数据&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;k： 原始数据行索引           &lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; calEk(oS, k):
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;f(x) = w*x + b &lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;     fXk = float(np.multiply(oS.alphas,oS.labelMat).T*oS.K[:,k] +&lt;span&gt; oS.b)
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     Ek = fXk -&lt;span&gt; float(oS.labelMat[k])
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ek
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; 
&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在alpha有改变都要更新缓存&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; updateEk(oS, k):
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;     Ek =&lt;span&gt; calEk(oS, k)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     oS.eCache[k] = [1&lt;span&gt;, Ek]
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;     
&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;第一次通过selectJrand()随机选取j,之后选取与i对应预测误差最大的j（步长最大）&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; selectJ(i, oS, Ei):
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt;     maxK = -1  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;误差最大时对应索引&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt;     maxDeltaE = 0 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;最大误差&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt;     Ej = 0 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; j索引对应预测误差&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存每一行的预测误差值 1相对于初始化为0的更改&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt;     oS.eCache[i] = [1&lt;span&gt;,Ei]
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取数据缓存结构中非0的索引列表(先将矩阵第0列转化为数组)&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;     validEcacheList =&lt;span&gt; np.nonzero(oS.eCache[:,0].A)[0]
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历索引列表，寻找最大误差对应索引&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; len(validEcacheList) &amp;gt; 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; k &lt;span&gt;in&lt;/span&gt;&lt;span&gt; validEcacheList:
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; k ==&lt;span&gt; i:
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt;             Ek =&lt;span&gt; calEk(oS, k)
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;             deltaE = abs(Ei -&lt;span&gt; Ek)
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(deltaE &amp;gt;&lt;span&gt; maxDeltaE):
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                 maxK =&lt;span&gt; k
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                 maxDeltaE =&lt;span&gt; deltaE
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                 Ej =&lt;span&gt; Ek
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; maxK, Ej
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;随机选取一个不等于i的j&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;         j =&lt;span&gt; selectJrand(i, oS.m)
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;         Ej =&lt;span&gt; calEk(oS, j)
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; j,Ej
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;随机选取一个不等于i的索引          &lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; selectJrand(i, m):
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     j =&lt;span&gt; i
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (j ==&lt;span&gt; i):
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;        j =&lt;span&gt; int(np.random.uniform(0, m))
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; j
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;alpha范围剪辑&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; clipAlpha(aj, L, H):
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; aj &amp;gt;&lt;span&gt; H:
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;         aj =&lt;span&gt; H
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; aj &amp;lt;&lt;span&gt; L:
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;         aj =&lt;span&gt; L
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; aj
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从文件获取特征数据，标签数据&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; loadDataSet(fileName):
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;     dataSet = []; labelSet =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;     fr =&lt;span&gt; open(fileName)
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; fr.readlines():
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;分割&lt;/span&gt;
&lt;span&gt;111&lt;/span&gt;         lineArr = line.strip().split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         dataSet.append([float(lineArr[0]), float(lineArr[1&lt;span&gt;])])
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;         labelSet.append(float(lineArr[2&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataSet, labelSet
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; 
&lt;span&gt;116&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算 w 权重系数&lt;/span&gt;
&lt;span&gt;117&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; calWs(alphas, dataSet, labelSet):
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;     dataMat =&lt;span&gt; np.mat(dataSet)
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1*100 =&amp;gt; 100*1&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt;     labelMat =&lt;span&gt; np.mat(labelSet).T
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;     m, n =&lt;span&gt; np.shape(dataMat)    
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;     w = np.zeros((n, 1&lt;span&gt;))    
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(m):
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;         w += np.multiply(alphas[i]*&lt;span&gt;labelMat[i], dataMat[i,:].T)        
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; w
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算原始数据每一行alpha,b，保存到数据结构中，有变化及时更新       &lt;/span&gt;
&lt;span&gt;127&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; innerL(i, oS):
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算预测误差&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt;     Ei =&lt;span&gt; calEk(oS, i)
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;选择第一个alpha，违背KKT条件2&lt;/span&gt;
&lt;span&gt;131&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;正间隔，负间隔&lt;/span&gt;
&lt;span&gt;132&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((oS.labelMat[i] * Ei &amp;lt; -oS.toler) &lt;span&gt;and&lt;/span&gt; (oS.alphas[i] &amp;lt; oS.C)) &lt;span&gt;or&lt;/span&gt; ((oS.labelMat[i] * Ei &amp;gt; oS.toler) &lt;span&gt;and&lt;/span&gt; (oS.alphas[i] &amp;gt;&lt;span&gt; 0)):
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;第一次随机选取不等于i的数据项，其后根据误差最大选取数据项&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;         j, Ej =&lt;span&gt; selectJ(i, oS, Ei)
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化，开辟新的内存&lt;/span&gt;
&lt;span&gt;136&lt;/span&gt;         alphaIold =&lt;span&gt; oS.alphas[i].copy()
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;         alphaJold =&lt;span&gt; oS.alphas[j].copy()
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过 a1y1 + a2y2 = 常量&lt;/span&gt;
&lt;span&gt;139&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;    0 &amp;lt;= a1,a2 &amp;lt;= C 求出L,H&lt;/span&gt;
&lt;span&gt;140&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; oS.labelMat[i] !=&lt;span&gt; oS.labelMat[j]:
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;             L = max(0, oS.alphas[j] -&lt;span&gt; oS.alphas[i])
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;             H = min(oS.C, oS.C + oS.alphas[j] -&lt;span&gt; oS.alphas[i])
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;             L = max(0, oS.alphas[j] + oS.alphas[i] -&lt;span&gt; oS.C)
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;             H = min(oS.C, oS.alphas[j] +&lt;span&gt; oS.alphas[i])
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; L ==&lt;span&gt; H : 
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;L == H&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;内核分母 K11 + K22 - 2K12&lt;/span&gt;
&lt;span&gt;150&lt;/span&gt;         eta = oS.K[i, i] + oS.K[j, j] - 2.0*&lt;span&gt;oS.K[i, j]
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; eta &amp;lt;=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eta &amp;lt;= 0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算第一个alpha j&lt;/span&gt;
&lt;span&gt;155&lt;/span&gt;         oS.alphas[j] += oS.labelMat[j]*(Ei - Ej)/&lt;span&gt;eta
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;修正alpha j的范围&lt;/span&gt;
&lt;span&gt;157&lt;/span&gt;         oS.alphas[j] =&lt;span&gt; clipAlpha(oS.alphas[j], L, H)
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;alpha有改变，就需要更新缓存数据&lt;/span&gt;
&lt;span&gt;159&lt;/span&gt; &lt;span&gt;        updateEk(oS, j)
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果优化后的alpha 与之前的alpha变化很小，则舍弃，并重新选择数据项的alpha&lt;/span&gt;
&lt;span&gt;161&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (abs(oS.alphas[j] - alphaJold) &amp;lt; 0.00001&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;j not moving enough, abandon it.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算alpha对的另一个alpha i&lt;/span&gt;
&lt;span&gt;165&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ai_new*yi + aj_new*yj = 常量&lt;/span&gt;
&lt;span&gt;166&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ai_old*yi + ai_old*yj = 常量 &lt;/span&gt;
&lt;span&gt;167&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 作差=&amp;gt; ai = ai_old + yi*yj*(aj_old - aj_new)&lt;/span&gt;
&lt;span&gt;168&lt;/span&gt;         oS.alphas[i] += oS.labelMat[j]*oS.labelMat[i]*(alphaJold -&lt;span&gt; oS.alphas[j])
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;alpha有改变，就需要更新缓存数据&lt;/span&gt;
&lt;span&gt;170&lt;/span&gt; &lt;span&gt;        updateEk(oS, i)
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算b1,b2&lt;/span&gt;
&lt;span&gt;172&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; y(x) = w*x + b =&amp;gt; b = y(x) - w*x&lt;/span&gt;
&lt;span&gt;173&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; w = aiyixi(i= 1-&amp;gt;N求和)&lt;/span&gt;
&lt;span&gt;174&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;b1_new = y1_new - (a1_new*y1*k11 + a2_new*y2*k21 + ai*yi*ki1(i = 3 -&amp;gt;N求和 常量))&lt;/span&gt;
&lt;span&gt;175&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;b1_old = y1_old - (a1_old*y1*k11 + a2_old*y2*k21 + ai*yi*ki1(i = 3 -&amp;gt;N求和 常量))&lt;/span&gt;
&lt;span&gt;176&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;作差=&amp;gt; b1_new = b1_old + (y1_new - y1_old) - y1*k11*(a1_new - a1_old) - y2*k21*(a2_new - a2_old)&lt;/span&gt;
&lt;span&gt;177&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; =&amp;gt; b1_new = b1_old + Ei - yi*(ai_new - ai_old)*kii - yj*(aj_new - aj_old)*kij      &lt;/span&gt;
&lt;span&gt;178&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;同样可推得 b2_new = b2_old + Ej - yi*(ai_new - ai_old)*kij - yj*(aj_new - aj_old)*kjj&lt;/span&gt;
&lt;span&gt;179&lt;/span&gt;         bi = oS.b - Ei - oS.labelMat[i]*(oS.alphas[i] - alphaIold)*oS.K[i,i] - oS.labelMat[j]*(oS.alphas[j] - alphaJold)*&lt;span&gt;oS.K[i,j]
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;         bj = oS.b - Ej - oS.labelMat[i]*(oS.alphas[i] - alphaIold)*oS.K[i,j] - oS.labelMat[j]*(oS.alphas[j] - alphaJold)*&lt;span&gt;oS.K[j,j]
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;首选alpha i，相对alpha j 更准确&lt;/span&gt;
&lt;span&gt;182&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (0 &amp;lt; oS.alphas[i]) &lt;span&gt;and&lt;/span&gt; (oS.alphas[i] &amp;lt;&lt;span&gt; oS.C):
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;             oS.b =&lt;span&gt; bi
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt; (0 &amp;lt; oS.alphas[j]) &lt;span&gt;and&lt;/span&gt; (oS.alphas[j] &amp;lt;&lt;span&gt; oS.C):
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;             oS.b =&lt;span&gt; bj
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;             oS.b = (bi + bj)/2.0
&lt;span&gt;188&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 1
&lt;span&gt;189&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;     
&lt;span&gt;192&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;完整SMO核心算法，包含线性核核非线性核，返回alpha,b&lt;/span&gt;
&lt;span&gt;193&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;dataSet 原始特征数据&lt;/span&gt;
&lt;span&gt;194&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;labelSet 标签数据&lt;/span&gt;
&lt;span&gt;195&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;C 凸二次规划参数&lt;/span&gt;
&lt;span&gt;196&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;toler 容忍度&lt;/span&gt;
&lt;span&gt;197&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;maxInter 循环次数&lt;/span&gt;
&lt;span&gt;198&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;kTup 指定核方式&lt;/span&gt;
&lt;span&gt;199&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;程序逻辑：&lt;/span&gt;
&lt;span&gt;200&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;第一次全部遍历，遍历后根据alpha对是否有修改判断，&lt;/span&gt;
&lt;span&gt;201&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果alpha对没有修改，外循环终止；如果alpha对有修改，则继续遍历属于支持向量的数据。&lt;/span&gt;
&lt;span&gt;202&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;直至外循环次数达到maxIter&lt;/span&gt;
&lt;span&gt;203&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;相比简单SMO算法，运行速度更快，原因是：&lt;/span&gt;
&lt;span&gt;204&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1.不是每一次都全量遍历原始数据，第一次遍历原始数据，&lt;/span&gt;
&lt;span&gt;205&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果alpha有优化，就遍历支持向量数据，直至alpha没有优化，然后再转全量遍历，这是如果alpha没有优化，循环结束；&lt;/span&gt;
&lt;span&gt;206&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;2.外循环不需要达到maxInter次数就终止；&lt;/span&gt;
&lt;span&gt;207&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; smoP(dataSet, labelSet, C, toler, maxInter, kTup = (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, 0)):
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;初始化结构体类，获取实例&lt;/span&gt;
&lt;span&gt;209&lt;/span&gt;     oS =&lt;span&gt; optStruct(dataSet, labelSet, C, toler, kTup)
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;     iter =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;全量遍历标志&lt;/span&gt;
&lt;span&gt;212&lt;/span&gt;     entireSet =&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;alpha对是否优化标志&lt;/span&gt;
&lt;span&gt;214&lt;/span&gt;     alphaPairsChanged =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;外循环 终止条件：1.达到最大次数 或者 2.alpha对没有优化&lt;/span&gt;
&lt;span&gt;216&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (iter &amp;lt; maxInter) &lt;span&gt;and&lt;/span&gt; ((alphaPairsChanged &amp;gt; 0) &lt;span&gt;or&lt;/span&gt;&lt;span&gt; (entireSet)):
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;         alphaPairsChanged =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;全量遍历 ，遍历每一行数据 alpha对有修改，alphaPairsChanged累加&lt;/span&gt;
&lt;span&gt;219&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; entireSet:
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(oS.m):
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;                 alphaPairsChanged +=&lt;span&gt; innerL(i, oS)
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fullSet, iter: %d i:%d, pairs changed %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(iter, i, alphaPairsChanged))
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;             iter += 1
&lt;span&gt;224&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取(0，C)范围内数据索引列表，也就是只遍历属于支持向量的数据&lt;/span&gt;
&lt;span&gt;226&lt;/span&gt;             nonBounds = np.nonzero((oS.alphas.A &amp;gt; 0) * (oS.alphas.A &amp;lt;&lt;span&gt; C))[0]
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; nonBounds:
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;                 alphaPairsChanged +=&lt;span&gt; innerL(i, oS)
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;non-bound, iter: %d i:%d, pairs changed %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt;(iter, i, alphaPairsChanged))
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt;             iter += 1
&lt;span&gt;231&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;全量遍历-&amp;gt;支持向量遍历&lt;/span&gt;
&lt;span&gt;232&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; entireSet:
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;             entireSet =&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;支持向量遍历-&amp;gt;全量遍历&lt;/span&gt;
&lt;span&gt;235&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt; alphaPairsChanged ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt;             entireSet =&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iteation number: %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt; iter)
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;entireSet :%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt; entireSet)
&lt;/span&gt;&lt;span&gt;239&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;alphaPairsChanged :%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt; alphaPairsChanged)
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oS.b,oS.alphas
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt; 
&lt;span&gt;242&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;绘制支持向量&lt;/span&gt;
&lt;span&gt;243&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; drawDataMap(dataArr,labelArr,b,alphas):
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt;     &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;245&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;alphas.A&amp;gt;0 获取大于0的索引列表，只有&amp;gt;0的alpha才对分类起作用&lt;/span&gt;
&lt;span&gt;246&lt;/span&gt;     svInd=np.nonzero(alphas.A&amp;gt;&lt;span&gt;0)[0]           
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt;      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;分类数据点&lt;/span&gt;
&lt;span&gt;248&lt;/span&gt;     classified_pts = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:[],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:[]}
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; point,label &lt;span&gt;in&lt;/span&gt;&lt;span&gt; zip(dataArr,labelArr):
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; label == 1.0&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;             classified_pts[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;+1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(point)
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;             classified_pts[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].append(point)
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt;     fig =&lt;span&gt; plt.figure()
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt;     ax = fig.add_subplot(111&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;绘制数据点&lt;/span&gt;
&lt;span&gt;257&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; label,pts &lt;span&gt;in&lt;/span&gt;&lt;span&gt; classified_pts.items():
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt;         pts =&lt;span&gt; np.array(pts)
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt;         ax.scatter(pts[:, 0], pts[:, 1], label =&lt;span&gt; label)
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;绘制分割线&lt;/span&gt;
&lt;span&gt;261&lt;/span&gt;     w =&lt;span&gt; calWs(alphas, dataArr, labelArr)
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;函数形式：max( x ,key=lambda a : b )        #    x可以是任何数值，可以有多个x值&lt;/span&gt;
&lt;span&gt;263&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;先把x值带入lambda函数转换成b值，然后再将b值进行比较&lt;/span&gt;
&lt;span&gt;264&lt;/span&gt;     x1, _=max(dataArr, key=&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x:x[0])
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt;     x2, _=min(dataArr, key=&lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; x:x[0])    
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;     a1, a2 =&lt;span&gt; w
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt;     y1, y2 = (-b - a1*x1)/a2, (-b - a1*x2)/&lt;span&gt;a2
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;矩阵转化为数组.A&lt;/span&gt;
&lt;span&gt;269&lt;/span&gt; &lt;span&gt;    ax.plot([x1, x2],[y1.A[0][0], y2.A[0][0]])
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt;     
&lt;span&gt;271&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;绘制支持向量&lt;/span&gt;
&lt;span&gt;272&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; svInd:
&lt;/span&gt;&lt;span&gt;273&lt;/span&gt;         x, y=&lt;span&gt; dataArr[i]        
&lt;/span&gt;&lt;span&gt;274&lt;/span&gt;         ax.scatter([x], [y], s=150, c =&lt;span&gt;'&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, alpha=0.7, linewidth=1.5, edgecolor = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#AB3319&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt; &lt;span&gt;    plt.show()
&lt;/span&gt;&lt;span&gt;276&lt;/span&gt;     
&lt;span&gt;277&lt;/span&gt;      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;alpha&amp;gt;0对应的数据才是支持向量，过滤不是支持向量的数据&lt;/span&gt;
&lt;span&gt;278&lt;/span&gt;     sVs= np.mat(dataArr)[svInd] &lt;span&gt;#&lt;/span&gt;&lt;span&gt;get matrix of only support vectors&lt;/span&gt;
&lt;span&gt;279&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;there are %d Support Vectors.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; np.shape(sVs)[0])
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt;     
&lt;span&gt;281&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练结果    &lt;/span&gt;
&lt;span&gt;282&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; getTrainingDataResult(dataSet, labelSet, b, alphas, k1=1.3&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;283&lt;/span&gt;     datMat =&lt;span&gt; np.mat(dataSet)
&lt;/span&gt;&lt;span&gt;284&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;100*1&lt;/span&gt;
&lt;span&gt;285&lt;/span&gt;     labelMat =&lt;span&gt; np.mat(labelSet).T
&lt;/span&gt;&lt;span&gt;286&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;alphas.A&amp;gt;0 获取大于0的索引列表，只有&amp;gt;0的alpha才对分类起作用&lt;/span&gt;
&lt;span&gt;287&lt;/span&gt;     svInd=np.nonzero(alphas.A&amp;gt;&lt;span&gt;0)[0]
&lt;/span&gt;&lt;span&gt;288&lt;/span&gt;     sVs=&lt;span&gt;datMat[svInd]
&lt;/span&gt;&lt;span&gt;289&lt;/span&gt;     labelSV =&lt;span&gt; labelMat[svInd];
&lt;/span&gt;&lt;span&gt;290&lt;/span&gt;     m,n =&lt;span&gt; np.shape(datMat)
&lt;/span&gt;&lt;span&gt;291&lt;/span&gt;     errorCount =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;292&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(m):
&lt;/span&gt;&lt;span&gt;293&lt;/span&gt;         kernelEval = kernelTrans(sVs,datMat[i,:],(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, k1))
&lt;/span&gt;&lt;span&gt;294&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; y(x) = w*x + b =&amp;gt; b = y(x) - w*x&lt;/span&gt;
&lt;span&gt;295&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; w = aiyixi(i= 1-&amp;gt;N求和)&lt;/span&gt;
&lt;span&gt;296&lt;/span&gt;         predict = kernelEval.T * np.multiply(labelSV, alphas[svInd]) +&lt;span&gt; b
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; np.sign(predict)!=np.sign(labelSet[i]): errorCount += 1
&lt;span&gt;298&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the training error rate is: %f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (float(errorCount)/&lt;span&gt;m))
&lt;/span&gt;&lt;span&gt;299&lt;/span&gt;     
&lt;span&gt;300&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; getTestDataResult(dataSet, labelSet, b, alphas, k1=1.3&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;301&lt;/span&gt;     datMat =&lt;span&gt; np.mat(dataSet)
&lt;/span&gt;&lt;span&gt;302&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;100*1&lt;/span&gt;
&lt;span&gt;303&lt;/span&gt;     labelMat =&lt;span&gt; np.mat(labelSet).T
&lt;/span&gt;&lt;span&gt;304&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;alphas.A&amp;gt;0 获取大于0的索引列表，只有&amp;gt;0的alpha才对分类起作用&lt;/span&gt;
&lt;span&gt;305&lt;/span&gt;     svInd=np.nonzero(alphas.A&amp;gt;&lt;span&gt;0)[0]
&lt;/span&gt;&lt;span&gt;306&lt;/span&gt;     sVs=&lt;span&gt;datMat[svInd]
&lt;/span&gt;&lt;span&gt;307&lt;/span&gt;     labelSV =&lt;span&gt; labelMat[svInd];
&lt;/span&gt;&lt;span&gt;308&lt;/span&gt;     m,n =&lt;span&gt; np.shape(datMat)
&lt;/span&gt;&lt;span&gt;309&lt;/span&gt;     errorCount =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;310&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(m):
&lt;/span&gt;&lt;span&gt;311&lt;/span&gt;         kernelEval = kernelTrans(sVs,datMat[i,:],(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rbf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, k1))
&lt;/span&gt;&lt;span&gt;312&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; y(x) = w*x + b =&amp;gt; b = y(x) - w*x&lt;/span&gt;
&lt;span&gt;313&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; w = aiyixi(i= 1-&amp;gt;N求和)&lt;/span&gt;
&lt;span&gt;314&lt;/span&gt;         predict=kernelEval.T * np.multiply(labelSV,alphas[svInd]) +&lt;span&gt; b
&lt;/span&gt;&lt;span&gt;315&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; np.sign(predict)!=np.sign(labelSet[i]): errorCount += 1    
&lt;span&gt;316&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the test error rate is: %f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (float(errorCount)/&lt;span&gt;m))  
&lt;/span&gt;&lt;span&gt;317&lt;/span&gt;     
&lt;span&gt;318&lt;/span&gt;     
&lt;/pre&gt;</description>
<pubDate>Thu, 06 Sep 2018 15:03:00 +0000</pubDate>
<dc:creator>w_x_w1985</dc:creator>
<og:description>支持向量机—SVM原理代码实现 本文系作者原创，转载请注明出处:https://www.cnblogs.com/further-further-further/p/9596898.html 1. 解决</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/further-further-further/p/9596898.html</dc:identifier>
</item>
<item>
<title>【学习笔记】多线程编程-线程池/任务/线程 - Mandy鹿</title>
<link>http://www.cnblogs.com/mandylu2018/p/9594442.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mandylu2018/p/9594442.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;写在前面的话&lt;/strong&gt;：之前一直没了解过多线程编程相关的东西，对于线程之类相关的概念也是一知半解。这次借着准备面试的时机，计划将一些关键性的盲区（除多线程以外，还有垃圾回收、图片缓存、性能优化等等）都彻底扫一遍。接下来我会陆续整理成学习笔记，主要作为自己学习后的温习巩固之用。如果能帮助到同样迷茫的小白的话，深感荣幸；如果因为缺少实战导致理解有误或解释不清的地方，还请路过的大牛不吝赐教，共同进步^_^&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;知识点相关&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;作为这次学习的切入点，&lt;span&gt;&lt;strong&gt;线程池&lt;/strong&gt;&lt;/span&gt;关联到的概念有很多，比如线程到底是什么，常搭配使用的Runnable又是啥，为什么又要搭配起来使用，等等。&lt;/p&gt;
&lt;p&gt;关于这些，我找到了一篇博文：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/jmsjh/p/7762034.html&quot;&gt;多线程（Thread、线程创建、线程池）&lt;/a&gt;，里面的解释说明非常全面了，感兴趣的可以整篇通读，一定受益匪浅。我在这里仅把几个重要且基础的点列出来，按自己的理解简要说明一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;线程Thread类&lt;/strong&gt;：用于创建线程（start方法）和定义线程所执行的任务（run方法），这里的run方法与主线程中的main方法等效。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;任务Runnable接口&lt;/strong&gt;：一般有两种方法定义任务，一种是继承Thread类重写run方法，另一种则是实现Runnable接口重写run方法。后者用的比较多，是常用搭配，目的就在于将线程创建和线程任务这两块&lt;strong&gt;解耦&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;任务Callable接口&lt;/strong&gt;：作用与Runnable类似，call方法也与run方法地位相同，区别在于Callable返回结果而Runnable不返回&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;任务结果Future接口&lt;/strong&gt;：对应的通过Future接口的get方法来获取Callable返回的结果，&lt;em&gt;&lt;span&gt;注意：使用get方法时如还未得到结果则会阻塞当前线程直至拿到结果&lt;/span&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;任务FutureTask类&lt;/strong&gt;：可以理解为是Runnable/Callable和Future的结合体，通过在Callable（Runnable也会先转为Callable）外面加包一层，使用get方法直接获取任务结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;除了以上这些涉及到的类，还有一些多线程相关的概念列举如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;：简单来说，一个应用对应一个进程，占用一定内存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程&lt;/strong&gt;：一个进程包含多个线程，线程相当于是任务执行单元，互不干扰&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抢占式调度&lt;/strong&gt;：按优先级高低分配向线程分配内存资源；多线程并不提高程序运行速度，而是在于提高运行效率，提高CPU的使用率&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主线程&lt;/strong&gt;：运行main方法所在的线程即为主线程；通常将耗时操作放到主线程以外的线程，以防阻塞主线程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;准备工作完毕，下面重点讲线程池↓&lt;/p&gt;
&lt;h2&gt;为什么要使用线程池&lt;/h2&gt;
&lt;p&gt;简单来说，线程池就像一个管家，通过调度和合理分配工作，让每个佣人（即线程）在繁忙时都能各司其职高效完成任务，同时又能在空闲时得到充分休息。更具体来说，主要有两点：&lt;span&gt;一是合理利用现存的线程，减少线程创建和销毁所消耗的资源开销，加快响应；二是便于监督和管理每个线程的生命周期。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;线程池ThreadPoolExecutor类&lt;/h2&gt;
&lt;p&gt;要搞清楚这个类，先上一张图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1334793/201809/1334793-20180906003809740-581694390.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一张继承关系图。最初的&lt;strong&gt;Executor&lt;/strong&gt;接口定义的是execute方法，比较简单。它的子类&lt;strong&gt;ExecutorService&lt;/strong&gt;接口，你可以理解为是&lt;strong&gt;通用线程池类&lt;/strong&gt;，里面增加了线程池常用的一些用于控制线程的方法，如submit和shutdown等，用于管理生命周期。继承的&lt;strong&gt;AbstractExecutorService&lt;/strong&gt;抽象类，是在ExecutorService基础上的默认实现。最后，&lt;strong&gt;ThreadPoolExecutor&lt;/strong&gt;继承自该抽象类，通过构造方法来配置线程池。&lt;/p&gt;
&lt;p&gt;这里还要提一下&lt;strong&gt;Executors&lt;/strong&gt;类，不在图中，是线程池工厂类，可以通过一系列静态方法创建线程池。查看源码可以发现，方法内部都是使用ThreadPoolExecutor的构造方法加上不同的配置参数来实现。&lt;/p&gt;
&lt;p&gt;下面是ThreadPoolExecutor类的几个构造方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1334793/201809/1334793-20180906123006202-707671568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重点讲第三个，其他的构造方法基本类似。其中的参数有（按顺序依次）：核心线程数&lt;strong&gt;&lt;span&gt;N&lt;/span&gt;&lt;/strong&gt;，最大线程数&lt;strong&gt;&lt;span&gt;M&lt;/span&gt;&lt;/strong&gt;，超时时间&lt;strong&gt;&lt;span&gt;T&lt;/span&gt;&lt;/strong&gt;，时间单位&lt;strong&gt;&lt;span&gt;U&lt;/span&gt;&lt;/strong&gt;，缓冲队列&lt;strong&gt;&lt;span&gt;B&lt;/span&gt;&lt;/strong&gt;和拒绝处理&lt;strong&gt;&lt;span&gt;Handler&lt;/span&gt;&lt;/strong&gt;。这些参数各自代表的含义，将结合不同的缓冲队列类型分情况讲解：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;SynchronousQueue&lt;/strong&gt;类型：所有任务不进入缓冲队列（可以理解为缓冲队列的容量为0），直接进入可用线程执行，当无可用线程时则直接创建新线程执行任务。当线程数超过&lt;strong&gt;&lt;span&gt;M&lt;/span&gt;&lt;/strong&gt;时，调用&lt;strong&gt;&lt;span&gt;Handler&lt;/span&gt;&lt;/strong&gt;处理被拒绝的新任务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LinkedBlockingQueue&lt;/strong&gt;类型：有新任务时，若当前线程数少于&lt;span&gt;&lt;strong&gt;N&lt;/strong&gt;&lt;/span&gt;，则创建新线程；若大于等于&lt;strong&gt;&lt;span&gt;N&lt;/span&gt;&lt;/strong&gt;，则进入缓冲队列；当缓冲队列充满时，且线程数少于&lt;strong&gt;&lt;span&gt;M&lt;/span&gt;&lt;/strong&gt;，则继续创建新线程，直至达到&lt;strong&gt;&lt;span&gt;M&lt;/span&gt;&lt;/strong&gt;时调用&lt;strong&gt;&lt;span&gt;Handler&lt;/span&gt;&lt;/strong&gt;处理拒绝任务。一般情况下，LinkedBlockingQueue作为无界队列不指定缓冲容量，可以无限扩展，此时相当于&lt;strong&gt;&lt;span&gt;M&lt;/span&gt;&lt;/strong&gt;失效；但也可以通过构造函数来指定容量。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ArrayBlockingQueue&lt;/strong&gt;类型：规则与LinkedBlockingQueue类似，但一般情况下指定队列长度。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体这三种队列类型的区别可以参考这篇文章：&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/feiyun126/p/7686302.html&quot; target=&quot;_blank&quot;&gt;ThreadPoolExecutor的三种队列&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有超时时间&lt;strong&gt;&lt;span&gt;T&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;和时间单位&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;U&lt;/span&gt;&lt;/strong&gt;，主要作用在于令非核心线程闲置超过一定时长后自动销毁，从而释放资源。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;拒绝任务Handler&lt;/h2&gt;
&lt;p&gt;当线程数和缓冲队列都达到饱和时，会调用相应的Handler处理拒绝的任务。以下是四种预定义的处理策略： &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在默认的AbortPolicy 中，拒绝后直接抛出异常RejectedExecutionException。&lt;/li&gt;
&lt;li&gt;在CallerRunsPolicy 中，直接在 execute 方法的调用线程中运行被拒绝的任务。该策略提供简单的反馈控制机制，能够减缓新任务的提交速度。&lt;/li&gt;
&lt;li&gt;在DiscardPolicy 中，拒绝后直接放弃任务。&lt;/li&gt;
&lt;li&gt;在DiscardOldestPolicy 中，位于工作队列头部（即最旧）的任务将被放弃，然后重试执行程序（如果再次失败，则重复此过程）。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;线程池的简单示例&lt;/h2&gt;
&lt;p&gt;以斐波那契数列为例，主要展示了不同任务类型的用法区别，注意此处使用submit而不是execute来提交任务，两者区别类似Callable和Runnable。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.effective.java.concurrent.task;  
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Callable;  
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutionException;  
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.ExecutorService;  
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executors;  
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Future;  
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.FutureTask;  
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RunnableFutureTask {  
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;   
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; ExecutorService mExecutor =  &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(2, 3, 5, TimeUnit.SECONDS, &lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;());  
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   
&lt;span&gt;14&lt;/span&gt;   
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {  
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        futureDemo();  
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }  
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;   
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; futureDemo() {  
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {  
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;/**&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;             * 提交runnable则没有返回值, future没有数据 
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;              &lt;span&gt;*/&lt;/span&gt;  
&lt;span&gt;25&lt;/span&gt;             Future&amp;lt;?&amp;gt; result = mExecutor.submit(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {  
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;   
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                @Override  
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {  
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     fibc(20&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                }  
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            });  
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;   
&lt;span&gt;33&lt;/span&gt;             System.out.println(&quot;future result from runnable : &quot; +&lt;span&gt; result.get());  
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;   
&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;/**&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;             * 提交Callable, 有返回值, future中能够获取返回值 
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;              &lt;span&gt;*/&lt;/span&gt;  
&lt;span&gt;38&lt;/span&gt;             Future&amp;lt;Integer&amp;gt; result2 = mExecutor.submit(&lt;span&gt;new&lt;/span&gt; Callable&amp;lt;Integer&amp;gt;&lt;span&gt;() {  
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                @Override  
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; Integer call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {  
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; fibc(20&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                }  
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            });  
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;   
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            System.out  
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                     .println(&quot;future result from callable : &quot; +&lt;span&gt; result2.get());  
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;   
&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;/**&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;             * FutureTask可以通过Thread包装来直接执行，也可以提交给ExecuteService来执行 
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;             * ，并且还可以通过v get()返回执行结果，在线程体没有执行完成的时候，主线程一直阻塞等待，执行完则直接返回结果。 
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;              &lt;span&gt;*/&lt;/span&gt;  
&lt;span&gt;52&lt;/span&gt;             FutureTask&amp;lt;Integer&amp;gt; futureTask = &lt;span&gt;new&lt;/span&gt; FutureTask&amp;lt;Integer&amp;gt;&lt;span&gt;(  
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt; Callable&amp;lt;Integer&amp;gt;&lt;span&gt;() {  
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                        @Override  
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                         &lt;span&gt;public&lt;/span&gt; Integer call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {  
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                             &lt;span&gt;return&lt;/span&gt; fibc(20&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                        }  
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;                    });  
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提交futureTask  &lt;/span&gt;
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;            mExecutor.submit(futureTask) ;  
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             System.out.println(&quot;future result from futureTask : &quot;  
&lt;span&gt;63&lt;/span&gt;                     +&lt;span&gt; futureTask.get());  
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;   
&lt;span&gt;65&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {  
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;            e.printStackTrace();  
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ExecutionException e) {  
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;            e.printStackTrace();  
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;        }  
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;    }  
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;   
&lt;span&gt;72&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt; &lt;span&gt;     * 效率底下的斐波那契数列, 耗时的操作 
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;     *  
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; num 
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt; 
&lt;span&gt;77&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;  
&lt;span&gt;78&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; fibc(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num) {  
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (num == 0&lt;span&gt;) {  
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;        }  
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (num == 1&lt;span&gt;) {  
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;  
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; &lt;span&gt;        }  
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; fibc(num - 1) + fibc(num - 2&lt;span&gt;);  
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; &lt;span&gt;    }   
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; }  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;除文中提到的博文外，其余参考博文列举如下，感谢各位博主的无私分享^_^：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; href=&quot;https://www.cnblogs.com/MOBIN/p/5436482.html&quot;&gt;java并发编程--Executor框架&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/hayre/article/details/53291712&quot; target=&quot;_blank&quot;&gt;一心多用多线程-线程池ThreadPoolExecutor-看这篇就够了&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/hayre/article/details/53314599&quot; target=&quot;_blank&quot;&gt;一心多用多线程-细谈java线程池submit与execute的区别&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/qq_25806863/article/details/71126867&quot; target=&quot;_blank&quot;&gt;Java多线程-线程池ThreadPoolExecutor构造方法和规则&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/qq_19431333/article/details/77483763&quot; target=&quot;_blank&quot;&gt;深入理解Callable&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/bboyfeiyu/article/details/24851847&quot; target=&quot;_blank&quot;&gt;Java中的Runnable、Callable、Future、FutureTask的区别与示例&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Sep 2018 14:28:00 +0000</pubDate>
<dc:creator>Mandy鹿</dc:creator>
<og:description>简单来说，线程池就像一个管家，通过调度和合理分配工作，让每个佣人（即线程）在繁忙时都能各司其职高效完成任务，同时又能在空闲时得到充分休息。更具体来说，主要有两点：一是合理利用现存的线程，减少线程创建和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mandylu2018/p/9594442.html</dc:identifier>
</item>
<item>
<title>Java基础-并发工具类(一) - aidodoo</title>
<link>http://www.cnblogs.com/aidodoo/p/9601499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aidodoo/p/9601499.html</guid>
<description>&lt;p&gt;本系列文章主要讲解&lt;code&gt;Java&lt;/code&gt;并发相关的内容，包括同步、锁、信号量、阻塞队列、线程池等，整体思维导图如下：&lt;br/&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/concurrent2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;系列文章列表：&lt;/p&gt;
&lt;p&gt;本文主要以实例讲解&lt;code&gt;CountDownLatch&lt;/code&gt;、&lt;code&gt;Semaphore&lt;/code&gt;、阻塞队列和线程池等内容。&lt;/p&gt;
&lt;h2 id=&quot;countdownlatch&quot;&gt;CountDownLatch&lt;/h2&gt;
&lt;h3 id=&quot;基本概念和用途&quot;&gt;基本概念和用途&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;主要是在其他线程执行操作前，允许一个或者多个线程一直等待。&lt;br/&gt;其源码实现主要采用&lt;code&gt;AQS&lt;/code&gt;,具体可参考&lt;a href=&quot;http://www.cnblogs.com/aidodoo/p/9601499.html&quot;&gt;&lt;code&gt;Java&lt;/code&gt;并发基础-同步和锁&lt;/a&gt;。&lt;br/&gt;构造方法&lt;code&gt;CountDownLatch&lt;/code&gt;(&lt;code&gt;int&lt;/code&gt; &lt;code&gt;count&lt;/code&gt;)用来初始化计数器，实际就是设置&lt;code&gt;count&lt;/code&gt;(最终是设置&lt;code&gt;state&lt;/code&gt;值)的初始值。该值设置后，不能重置，所有当线程必须用这种方法反复倒计数时，可改为使用 &lt;code&gt;CyclicBarrier&lt;/code&gt;。&lt;br/&gt;&lt;code&gt;countDown()&lt;/code&gt;方法用来减少计数器的值，每次减&lt;code&gt;1&lt;/code&gt;。&lt;br/&gt;&lt;code&gt;getCount()&lt;/code&gt;方法用来返回当前计数器的值。&lt;br/&gt;流程图简化如下&lt;br/&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/CountDownLatch.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;运行示例&quot;&gt;运行示例&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;SynchronizedDemo&lt;/code&gt;代码中，我们使用&lt;code&gt;Thread&lt;/code&gt;的&lt;code&gt;join&lt;/code&gt;方法等待一个&lt;code&gt;Spender&lt;/code&gt;和&lt;code&gt;Earner&lt;/code&gt;线程运行完成后，再去获取账户余额&lt;code&gt;balance&lt;/code&gt;的值，这里我们利用&lt;code&gt;CountDownLatch&lt;/code&gt;计数器，先阻塞主线程，待一组&lt;code&gt;Spender&lt;/code&gt;和一组&lt;code&gt;Earner&lt;/code&gt;线程完成后，再让主线程获取账户余额的值，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.molyeo.java.concurrent;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Created by zhangkh on 2018/7/17.
 */
public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        System.out.println(&quot;main thread start&quot;);
        Account account = new Account();
        account.setBalance(100000);
        CountDownLatch latch = new CountDownLatch(20);
        System.out.println(&quot;main latch init=&quot;+latch.getCount());
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        for (int i = 0; i &amp;lt; 10; i++) {
            SpenderWithCountDownLatch spender = new SpenderWithCountDownLatch(account, latch);
            executorService.submit(spender);
        }
        for (int i = 0; i &amp;lt; 10; i++) {
            EarnerWithCountDownLatch earner = new EarnerWithCountDownLatch(account, latch);
            executorService.submit(earner);
        }
        System.out.println(&quot;main thread block&quot;);
        latch.await();
        System.out.println(&quot;main latch=&quot;+latch.getCount());

        System.out.println(&quot;main thread continue to do&quot;);
        System.out.println(&quot;balance=&quot;+account.getBalance());
        executorService.shutdown();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先初始化&lt;code&gt;CountDownLatch&lt;/code&gt;的值为&lt;code&gt;20&lt;/code&gt;，然后分布创建一组&lt;code&gt;Spender&lt;/code&gt;线程(每组&lt;code&gt;10&lt;/code&gt;个)和一组&lt;code&gt;Earner&lt;/code&gt;线程(每组&lt;code&gt;10&lt;/code&gt;个),并将&lt;code&gt;account&lt;/code&gt;和&lt;code&gt;latch&lt;/code&gt;传递给这些线程。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SpenderWithCountDownLatch&lt;/code&gt;代码如下，运行时主要是&lt;code&gt;30&lt;/code&gt;次减少账户余额，每次减少&lt;code&gt;1000&lt;/code&gt;。运行完成后调用&lt;code&gt;latch&lt;/code&gt;.&lt;code&gt;countDown()&lt;/code&gt;，减少计数器的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SpenderWithCountDownLatch implements Runnable {
    private final Account account;
    private final CountDownLatch latch;

    public SpenderWithCountDownLatch(Account account, CountDownLatch latch) {

        this.account = account;
        this.latch = latch;
    }

    @Override
    public void run() {
        for (int i = 0; i &amp;lt; 30; i++) {
            account.subtractAmount(1000);
        }
        latch.countDown();
        System.out.println(&quot;Spender run ......&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;EarnerWithCountDownLatch&lt;/code&gt;代码如下，运行时主要是&lt;code&gt;30&lt;/code&gt;次增加账户余额，每次增加&lt;code&gt;1000&lt;/code&gt;。运行完成后调用&lt;code&gt;latch&lt;/code&gt;.&lt;code&gt;countDown()&lt;/code&gt;，减少计数器的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class EarnerWithCountDownLatch implements Runnable {
    private final Account account;
    private final CountDownLatch latch;

    public EarnerWithCountDownLatch(Account account, CountDownLatch latch) {
        this.account = account;
        this.latch = latch;
    }

    @Override
    public void run() {
        for (int i = 0; i &amp;lt; 30; i++) {
            account.addAmount(1000);
        }
        latch.countDown();
        System.out.println(&quot;Earner run ....&quot; );

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Account&lt;/code&gt;代码如下，需要利用同步块或者&lt;code&gt;Lock&lt;/code&gt;保证&lt;code&gt;addAmount&lt;/code&gt;和&lt;code&gt;subtractAmount&lt;/code&gt;方法线程安全&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Account {
    private double balance;

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public void addAmount(double amount) {
        synchronized (Account.class) {
            balance = balance + amount;
        }
    }

    public void subtractAmount(double amount) {
        synchronized (Account.class) {
            balance = balance - amount;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个程序输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;main thread start
main latch init=20
main thread block
Spender run ......
Spender run ......
Spender run ......
Earner run ....
Earner run ....
Earner run ....
Earner run ....
Earner run ....
Earner run ....
Spender run ......
Earner run ....
Earner run ....
Spender run ......
Earner run ....
Earner run ....
Spender run ......
Spender run ......
Spender run ......
Spender run ......
Spender run ......
main latch=0
main thread continue to do
balance=100000.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;满足预期结果为&lt;code&gt;100000&lt;/code&gt;，同时主线程一直阻塞直到&lt;code&gt;latch&lt;/code&gt;的值为&lt;code&gt;0&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;cyclicbarrier&quot;&gt;CyclicBarrier&lt;/h2&gt;
&lt;h3 id=&quot;基本概念和主要方法&quot;&gt;基本概念和主要方法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CyclicBarrier&lt;/code&gt;允许一组线程互相等待，直到所有的线程到到达公共屏障点(&lt;code&gt;common&lt;/code&gt; &lt;code&gt;barrier&lt;/code&gt; &lt;code&gt;point&lt;/code&gt;)。和&lt;code&gt;CountDownLatch&lt;/code&gt;不同的是，&lt;code&gt;CyclicBarrier&lt;/code&gt;可以在释放等待线程后重置然后重用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public CyclicBarrier(int parties, Runnable barrierAction)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;parties&lt;/code&gt;，表示线程数量，即参与者数量&lt;br/&gt;&lt;code&gt;barrierAction&lt;/code&gt;表示启动&lt;code&gt;barrier&lt;/code&gt;时执行指定的操作，该操作由最后一个进入&lt;code&gt;barrier&lt;/code&gt;的线程执行&lt;br/&gt;&lt;strong&gt;await()&lt;/strong&gt;&lt;br/&gt;参与者阻塞等待，直到所有的参与者都到达&lt;code&gt;barrier&lt;/code&gt;&lt;br/&gt;流程图简化如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/CyclicBarrier.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用示例&quot;&gt;使用示例&lt;/h3&gt;
&lt;p&gt;我们看下面一个示例，其功能是主线程、&lt;code&gt;Spender&lt;/code&gt;线程和&lt;code&gt;Earner&lt;/code&gt;线程共用一个&lt;code&gt;barrier&lt;/code&gt;，其中&lt;code&gt;barrier&lt;/code&gt;初始值为&lt;code&gt;3&lt;/code&gt;，三个线程都到达&lt;code&gt;barrier&lt;/code&gt;后执行&lt;code&gt;BarrierAction&lt;/code&gt;定义的动作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.molyeo.java.concurrent;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Created by zhangkh on 2018/9/5.
 */
public class CyclicBarrierDemo {
    public static void main(String[] args) {
        Account account=new Account();
        account.setBalance(100000);

        CyclicBarrier barrier = new CyclicBarrier(3, new BarrierAction());
        ExecutorService executorService = Executors.newFixedThreadPool(10);
        SpenderWithCyclicBarrier spender = new SpenderWithCyclicBarrier(account, barrier);
        executorService.submit(spender);
        EarnerWithCyclicBarrier earner = new EarnerWithCyclicBarrier(account, barrier);
        executorService.submit(earner);
        try{
            System.out.println(String.format(&quot;%20s waiting at barrier&quot;,Thread.currentThread().getName()));
            barrier.await();
        }catch (InterruptedException e){
            e.printStackTrace();
        }catch (BrokenBarrierException e){
            e.printStackTrace();
        }
        System.out.println(&quot;balance=&quot;+account.getBalance());
        System.out.println(String.format(&quot;%20s done&quot;,Thread.currentThread().getName()));

    }

}
class BarrierAction implements Runnable{
    public void run() {
        System.out.println(String.format(&quot;%20s executed&quot;,Thread.currentThread().getName()));
    }
}

class SpenderWithCyclicBarrier implements Runnable {
    private final Account account;
    private final CyclicBarrier barrier;

    public SpenderWithCyclicBarrier(Account account, CyclicBarrier barrier) {
        this.account = account;
        this.barrier = barrier;
    }

    @Override
    public void run() {
        for (int i = 0; i &amp;lt; 30; i++) {
            account.subtractAmount(1000);
        }
        try{
            System.out.println(String.format(&quot;%20s waiting at barrier&quot;,Thread.currentThread().getName()));
            barrier.await();
        }catch (InterruptedException e){
            e.printStackTrace();
        }catch (BrokenBarrierException e){
            e.printStackTrace();
        }
        System.out.println(String.format(&quot;%20s done&quot;,Thread.currentThread().getName()));
    }
}

class EarnerWithCyclicBarrier implements Runnable {
    private final Account account;
    private final CyclicBarrier barrier;

    public EarnerWithCyclicBarrier(Account account, CyclicBarrier barrier) {
        this.account = account;
        this.barrier = barrier;
    }

    @Override
    public void run(){
        for (int i = 0; i &amp;lt; 30; i++) {
            account.addAmount(1000);
        }
        try{
            System.out.println(String.format(&quot;%20s waiting at barrier&quot;,Thread.currentThread().getName()));
            barrier.await();
        }catch (InterruptedException e){
            e.printStackTrace();
        }catch (BrokenBarrierException e){
         e.printStackTrace();
        }
        System.out.println(String.format(&quot;%20s done&quot;,Thread.currentThread().getName()));

    }
}
class Account {
    private double balance;

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public void addAmount(double amount) {
        synchronized (Account.class) {
            balance = balance + amount;
        }
    }

    public void subtractAmount(double amount) {
        synchronized (Account.class) {
            balance = balance - amount;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; pool-1-thread-2 waiting at barrier
            main waiting at barrier
 pool-1-thread-1 waiting at barrier
 pool-1-thread-1 executed
 pool-1-thread-1 done
 pool-1-thread-2 done
 balance=100000.0
            main done&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到&lt;code&gt;pool&lt;/code&gt;-&lt;code&gt;1&lt;/code&gt;-&lt;code&gt;thread&lt;/code&gt;-&lt;code&gt;2&lt;/code&gt;和&lt;code&gt;main&lt;/code&gt;线程执行完对账户余额的操作后，先到达&lt;code&gt;barrier&lt;/code&gt;阻塞等待，&lt;code&gt;pool&lt;/code&gt;-&lt;code&gt;1&lt;/code&gt;-&lt;code&gt;thread&lt;/code&gt;-&lt;code&gt;1&lt;/code&gt;线程最后到达，然后由&lt;code&gt;pool&lt;/code&gt;-&lt;code&gt;1&lt;/code&gt;-&lt;code&gt;thread&lt;/code&gt;-&lt;code&gt;1&lt;/code&gt;线程执行预定义的动作，即输出&lt;code&gt;executed&lt;/code&gt;后，这三个线程再继续执行其他信息的输出。&lt;br/&gt;这里要注意到时，各位输出的内容可能是上面的不太一致，不过第三行和第四行的线程名要么是&lt;code&gt;main&lt;/code&gt;、要么是&lt;code&gt;pool&lt;/code&gt;-&lt;code&gt;1&lt;/code&gt;-&lt;code&gt;thread&lt;/code&gt;-&lt;code&gt;1&lt;/code&gt;，或者是&lt;code&gt;pool&lt;/code&gt;-&lt;code&gt;1&lt;/code&gt;-&lt;code&gt;thread&lt;/code&gt;-&lt;code&gt;2&lt;/code&gt;。不会存在两个线程名不一样的情况。这里说明了到达&lt;code&gt;barrier&lt;/code&gt;后预定义的动作是由最后到达的线程去执行的。&lt;/p&gt;
&lt;p&gt;本文参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://it-ebooks.info/book/3916/&quot;&gt;Java 7 Concurrency Cookbook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ifeve.com/concurrency-modle-seven-week-1/&quot;&gt;concurrency-modle-seven-week&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tutorials.jenkov.com/java-concurrency/concurrency-models.html&quot;&gt;java-concurrency&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://tutorials.jenkov.com/java-util-concurrent/lock.html&quot;&gt;java-util-concurrent&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/&quot;&gt;java se 8 apidoc&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;关于作者&lt;br/&gt;爱编程、爱钻研、爱分享、爱生活&lt;br/&gt;关注分布式、高并发、数据挖掘&lt;br/&gt;如需捐赠，请扫码&lt;br/&gt;&lt;img src=&quot;http://pcxupmf8g.bkt.clouddn.com/sqm.jpg&quot; width=&quot;256&quot; height=&quot;256&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Sep 2018 14:23:00 +0000</pubDate>
<dc:creator>aidodoo</dc:creator>
<og:description>文章主要讲解`Java`并发相关的内容，包括同步、锁、信号量、阻塞队列、线程池等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aidodoo/p/9601499.html</dc:identifier>
</item>
<item>
<title>MongoDB 执行mongoexport时异常及分析（关于数字类型的查询） - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9601266.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9601266.html</guid>
<description>&lt;p&gt;今天在用mongoexport导出满足一定条件下的数据时，遇到了一个报错，现纪录下来，并且针对此错误对MongoDB 的 &lt;strong&gt;数字类型 &lt;/strong&gt;做了进一步的学习。&lt;/p&gt;
&lt;h2&gt;背景 及 报错信息 &lt;/h2&gt;
&lt;p&gt;今天接到一个业务需求，需要从MongoDB 数据库 order集合中导出符合以下条件的数据：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;db.qqwj_order.find({&quot;Source&quot;:NumberInt(&quot;21&quot;),&quot;Batch&quot;:&quot;支付中的订单提醒：2018/9/5&quot;,&quot;MsgContent&quot;:/还未完成在线付款/})&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;通过MongoDB 客户端工具 【NoSQLBooster for MongoDB】查询检查，语句执行正常，显示相应记录数为 15265。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180906211555691-1985737399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;导出数据使用mongoexport命令，执行命令如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;/data/mongodb/mongobin344/bin/mongoexport  -h 172.X.X.XXX --port 端口 --db 数据库 -u 账号 -p '密码' --authenticationDatabase 认证数据库 --type=csv -c qqwj_order -f MsgContent,REC_CreateTime  &lt;strong&gt;-q '{ &quot;Source&quot;:NumberInt(&quot;21&quot;),&quot;Batch&quot;:&quot;支付中的订单提醒：2018/9/5&quot;,&quot;MsgContent&quot;:/还未完成在线付款/}'&lt;/strong&gt; -o  /data/mongodb_back/sms.csv &lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但是执行报错：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;XXX is not valid JSON: json: cannot unmarshal string into Go value of type json.NumberInt&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;错误截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180906211737107-735838796.png&quot; alt=&quot;&quot; width=&quot;587&quot; height=&quot;32&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;错误推断及测试&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;因为报错信息中NumberInt 关键字，此时去看我们的查询条件正好也有此关键字，所以推测 是不是这个问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;结果将导出命令中的 NumberInt(&quot;21&quot;) 直接替换为 21 ，再次执行。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;执行命令为 ：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;em&gt;/data/mongodb/mongobin344/bin/mongoexport  -h 172.X.X.XXX --port 端口 --db 数据库 -u 账号 -p '密码' --authenticationDatabase 认证数据库 --type=csv -c qqwj_order -f MsgContent,REC_CreateTime  -q '{&quot;Source&quot;:21,&quot;Batch&quot;:&quot;支付中的订单提醒：2018/9/5&quot;,&quot;MsgContent&quot;:/还未完成在线付款/}' -o  /data/mongodb_back/sms.csv&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;执行结果为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180906211928533-1463522559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果表明修改后，&lt;strong&gt;数据成功导出&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;错误解析与原理探究&lt;/h2&gt;

&lt;p align=&quot;left&quot;&gt;为什么通过查询器查看，数据就是     &quot;Source&quot; : NumberInt(&quot;21&quot;)，但是在shell 中的执行导出命令写成&quot;Source&quot; : NumberInt(&quot;21&quot;) 就会报错。而一定要转换为&quot;Source&quot;:21&lt;/p&gt;
&lt;p&gt;查询器查询出的Source字段显示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180906212053890-465219666.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;明明就是 &quot;Source&quot; : NumberInt(&quot;21&quot;)，为什么复制到shell，执行报错？？？&lt;/p&gt;

&lt;p&gt;回头看，找原理。我们知道目前MongoDB 支持4中数据类型。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;double&lt;/li&gt;
&lt;li&gt;32-bit integer&lt;/li&gt;
&lt;li&gt;64-bit integer&lt;/li&gt;
&lt;li&gt;Decimal （New in version 3.4.）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在MongoDB客户端可以执行查询，但是在shell中无法执行导出，那么会不会和这两种工具有关？会不会和插入的NumberInt(数字) 还是NumberInt('数字‘)有关？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面对假设进行验证测试。&lt;/p&gt;
&lt;p&gt;通过 NoSQLBooster for MongoDB 方式 插入测试数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180906212719353-453821288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过 shell方式插入测试数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180906212742358-350085731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过$type 去查看插入的数据类型&lt;/p&gt;

&lt;p&gt;1》执行db.numbers.find({n:{$type:1}})  // Type 为 Double；查询Type 为 Double的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180906212840445-2039662679.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上查询结果显示，不管是通过客户端还是shell，当数字不指明数据类型时，插入的数字数据默认都是Double。&lt;/p&gt;

&lt;p&gt; 2》执行命令 db.numbers.find({n:{$type:16}})  // Type 为 32-bit integer ；查询Type 为 32-bit integer的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180906213020015-1067991549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上查询表名，不管通过客户端还是shell，指定的NumberInt(5) 还是NumberInt('5‘) 后台都转成统一32-bit integer 类型存储了。&lt;/p&gt;

&lt;p&gt; 3》执行命令 db.numbers.find({n:{$type:18}})  // Type 为 64-bit integer 查询Type 为 64-bit integer的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180906213106793-721466912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上查询表名，不管通过客户端还是shell，指定的NumberLong(5) 还是NumberLong('5') 后台都转成统一64-bit integer 类型存储了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以上的测试说明，当我们在存储数字数据时会自动转储（不管什么客户端工具,是shell还是 【NoSQLBooster for MongoDB】，不管 NumberLong(5) 还是NumberLong('5')；NumberInt(5) 还是NumberInt('5‘)）。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有点糊涂了吧？ 如此这样，那为什么 在查询是报错呢？&lt;/p&gt;
&lt;p&gt;回头再看错误提示：XXX is not valid JSON: json: cannot unmarshal &lt;span&gt;&lt;strong&gt;&lt;span&gt;string&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; into Go value of type json.&lt;strong&gt;&lt;span&gt;NumberInt&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其意思是shell 认为我们把一个字符类型的数据传给了 json.NumberInt。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那我如果将导出命令中的 NumberInt(&quot;21&quot;) 将 换成 NumberInt(21)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;执行命令为 ：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;em&gt;/data/mongodb/mongobin344/bin/mongoexport  -h 172.X.X.XXX --port 端口 --db 数据库 -u 账号 -p '密码' --authenticationDatabase 认证数据库 --type=csv -c qqwj_order -f MsgContent,REC_CreateTime  -q '{&quot;Source&quot;: NumberInt(21),&quot;Batch&quot;:&quot;支付中的订单提醒：2018/9/5&quot;,&quot;MsgContent&quot;:/还未完成在线付款/}' -o  /data/mongodb_back/sms.csv &lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180906213849186-239598208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行也成功。&lt;/p&gt;
&lt;h2&gt;结论&lt;/h2&gt;
&lt;p&gt;说了很多总结下：&lt;/p&gt;
&lt;p&gt;执行&lt;strong&gt;&lt;span&gt;失败&lt;/span&gt;&lt;/strong&gt;的导出命令是：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;/data/mongodb/mongobin344/bin/mongoexport  -h 172.X.X.XXX --port 端口 --db 数据库 -u 账号 -p '密码' --authenticationDatabase 认证数据库 --type=csv -c qqwj_order -f MsgContent,REC_CreateTime  -q '{ &quot;Source&quot;:&lt;strong&gt;&lt;span&gt;NumberInt(&quot;21&quot;)&lt;/span&gt;&lt;/strong&gt;,&quot;Batch&quot;:&quot;支付中的订单提醒：2018/9/5&quot;,&quot;MsgContent&quot;:/还未完成在线付款/}' -o  /data/mongodb_back/sms.csv &lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;执行&lt;span&gt;&lt;strong&gt;成功&lt;/strong&gt;&lt;/span&gt;的导出命令是：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;/data/mongodb/mongobin344/bin/mongoexport  -h 172.X.X.XXX --port 端口 --db 数据库 -u 账号 -p '密码' --authenticationDatabase 认证数据库 --type=csv -c qqwj_order -f MsgContent,REC_CreateTime  -q '{&quot;Source&quot;:&lt;strong&gt;&lt;span&gt;21&lt;/span&gt;&lt;/strong&gt;,&quot;Batch&quot;:&quot;支付中的订单提醒：2018/9/5&quot;,&quot;MsgContent&quot;:/还未完成在线付款/}' -o  /data/mongodb_back/sms.csv&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;和 &lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;em&gt;/data/mongodb/mongobin344/bin/mongoexport  -h 172.X.X.XXX --port 端口 --db 数据库 -u 账号 -p '密码' --authenticationDatabase 认证数据库 --type=csv -c qqwj_order -f MsgContent,REC_CreateTime  -q '{&quot;Source&quot;: &lt;strong&gt;&lt;span&gt;NumberInt(21)&lt;/span&gt;&lt;/strong&gt;,&quot;Batch&quot;:&quot;支付中的订单提醒：2018/9/5&quot;,&quot;MsgContent&quot;:/还未完成在线付款/}' -o  /data/mongodb_back/sms.csv &lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;三个导出命令不同的地方已用红色字体标注。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;P．S  1  ：后来作者深究了一下，为什么同样的查询，通样的查询结果，有的显示  &quot;n&quot; : 5  ； 有的显示 &quot;n&quot; : NumberInt(&quot;5&quot;)。嘻嘻 》》》》版本不同而已。&lt;/p&gt;
&lt;p&gt;旧版本（部分）的显示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180906214428111-2076420856.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新版本（例如nosqlbooster4mongo-4.7.1）的显示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/780228/201809/780228-20180906214451644-1033570516.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;P．S  2  ：在存储数字数据时，到底会存储为何种数据类型，其实和语言的的驱动有关。例如在Ruby 和 Python 语言里在序列化整数时，驱动会自动确定是否编码为32-bit integer 还是 64-bit integer；shell 需要显示指定才可以。&lt;/p&gt;
</description>
<pubDate>Thu, 06 Sep 2018 14:01:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>今天在用mongoexport导出满足一定条件下的数据时，遇到了一个报错，现纪录下来，并且针对此错误对MongoDB 的 数字类型 做了进一步的学习。 背景 及 报错信息 今天接到一个业务需</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9601266.html</dc:identifier>
</item>
<item>
<title>SpringCloud(8)---zuul权限校验、接口限流 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/9601170.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/9601170.html</guid>
<description>
&lt;h2&gt;&lt;span&gt;一、权限校验搭建&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;正常项目开发时,权限校验可以考虑JWT和springSecurity结合进行权限校验，这个后期会总结，这里做个基于ZuulFilter过滤器进行一个简单的权限校验过滤。&lt;/p&gt;
&lt;p&gt;对于组件zuul中，其实带有权限认证的功能，那就是ZuulFilter过滤器。ZuulFilter是Zuul中核心组件，通过继承该抽象类，覆写几个关键方法达到自定义调度请求的作用&lt;/p&gt;
&lt;p&gt;使用到的组件包括：Eureka、Feign、Zuul，包括以下四个项目：&lt;/p&gt;
&lt;p&gt; （1）Eureka-server： 7001 注册中心&lt;/p&gt;
&lt;p&gt; （2）product-server ： 8001 商品微服务&lt;/p&gt;
&lt;p&gt; （3）order-server ： 9001 订单微服务&lt;/p&gt;
&lt;p&gt; （4）zuul-gateway ： 6001 Zuul网关&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201809/1090617-20180906212616101-215602007.png&quot; alt=&quot;&quot; width=&quot;1001&quot; height=&quot;151&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有关四个服务的基本配置我这里就不写了，具体可以看之前几篇博客，这里只写LoginFilter权限校验类&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;    1、LoginFilter类&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 登录过滤器&lt;br/&gt;*记得类上加Component注解
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LoginFilter &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ZuulFilter {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 过滤器类型，前置过滤器&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    @Override
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String &lt;span&gt;filterType()&lt;/span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; PRE_TYPE;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 过滤器顺序，越小越先执行
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    @Override
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;&lt;span&gt; filterOrder()&lt;/span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 4&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 过滤器是否生效
     * 返回true代表需要权限校验，false代表不需要用户校验即可访问
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    @Override
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;&lt;span&gt; shouldFilter()&lt;/span&gt; {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;共享RequestContext，上下文对象&lt;/span&gt;
        RequestContext requestContext =&lt;span&gt; RequestContext.getCurrentContext();
        HttpServletRequest request &lt;/span&gt;=&lt;span&gt; requestContext.getRequest();

        System.out.println(request.getRequestURI());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要权限校验URL&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&quot;/apigateway/order/api/v1/order/save&quot;&lt;span&gt;.equalsIgnoreCase(request.getRequestURI())) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;/apigateway/order/api/v1/order/list&quot;&lt;span&gt;.equalsIgnoreCase(request.getRequestURI())) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;/apigateway/order/api/v1/order/find&quot;&lt;span&gt;.equalsIgnoreCase(request.getRequestURI())) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 业务逻辑
     * 只有上面返回true的时候，才会进入到该方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    @Override
    &lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;run()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ZuulException {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;JWT&lt;/span&gt;
        RequestContext requestContext =&lt;span&gt; RequestContext.getCurrentContext();
        HttpServletRequest request &lt;/span&gt;=&lt;span&gt; requestContext.getRequest();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;token对象,有可能在请求头传递过来，也有可能是通过参数传过来，实际开发一般都是请求头方式&lt;/span&gt;
        String token = request.getHeader(&quot;token&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isBlank((token))) {
            token &lt;/span&gt;= request.getParameter(&quot;token&quot;&lt;span&gt;);
        }
        System.out.println(&lt;/span&gt;&quot;页面传来的token值为：&quot; +&lt;span&gt; token);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;登录校验逻辑  如果token为null，则直接返回客户端，而不进行下一步接口调用&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (StringUtils.isBlank(token)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤该请求，不对其进行路由&lt;/span&gt;
            requestContext.setSendZuulResponse(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回错误代码&lt;/span&gt;
&lt;span&gt;            requestContext.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;      2、关键说明&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;（1）方法说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;filterType&lt;/span&gt; : filter类型,分为pre、error、post、 route&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;filterOrder&lt;/span&gt;: filter执行顺序，通过数字指定，数字越小，执行顺序越先&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;shouldFilter&lt;/span&gt;: filter是否需要执行 true执行 false 不执行&lt;/p&gt;
&lt;p&gt;            &lt;span&gt;run&lt;/span&gt; : filter具体逻辑（上面为true那么这里就是具体执行逻辑）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）filter类型说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;            &lt;span&gt;pre&lt;/span&gt;: 请求执行之前filter&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;route&lt;/span&gt;: 处理请求，进行路由&lt;/p&gt;
&lt;p&gt;          &lt;span&gt;post&lt;/span&gt;: 请求处理完成后执行的filter&lt;/p&gt;
&lt;p&gt;        &lt;span&gt; error&lt;/span&gt;: 出现错误时执行的filter&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;       3、测试&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;先在请求头和传参都&lt;span&gt;不传token&lt;/span&gt;，校验失败：返回401状态码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201809/1090617-20180906213252399-855508337.png&quot; alt=&quot;&quot; width=&quot;573&quot; height=&quot;212&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在参数的时候&lt;span&gt;传入token&lt;/span&gt;值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201809/1090617-20180906213329013-1927956637.png&quot; alt=&quot;&quot; width=&quot;566&quot; height=&quot;166&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看后台输出&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201809/1090617-20180906213453880-1292234025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明模拟校验通过，返回用户信息。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、接口限流搭建&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;接口限流可以在nginx层面做限流，也可以在网关层面做限流，这里在网关层面做限流，&lt;span&gt;基于guava框架&lt;/span&gt;来做网关限流。&lt;/p&gt;
&lt;p&gt;先对guava框架限流的概念进行讲解下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201809/1090617-20180906213610239-526459252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它的大致意思就是每一个请求进来先到桶里去拿令牌，拿到令牌的请求放行，假设你设置了1000个令牌，如果拿完了，那么后面来调接口的请求就需要排队等有新的令牌才能调用该接口。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;OrderRateLimiterFilter限流过滤类&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 订单限流
 *其它和上面都一样，只是run()中逻辑不一样
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OrderRateLimiterFilter &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ZuulFilter {


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每秒产生1000个令牌&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; RateLimiter RATE_LIMITER = RateLimiter.create(1000&lt;span&gt;);

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String filterType() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; PRE_TYPE;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; filterOrder() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -4&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; shouldFilter() {
        RequestContext requestContext &lt;/span&gt;=&lt;span&gt; RequestContext.getCurrentContext();
        HttpServletRequest request &lt;/span&gt;=&lt;span&gt; requestContext.getRequest();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只对订单接口限流&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&quot;/apigateway/order/api/v1/order/save&quot;&lt;span&gt;.equalsIgnoreCase(request.getRequestURI())) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object run() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ZuulException {
        RequestContext requestContext &lt;/span&gt;=&lt;span&gt; RequestContext.getCurrentContext();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;就相当于每调用一次tryAcquire()方法，令牌数量减1，当1000个用完后，那么后面进来的用户无法访问上面接口
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当然这里只写类上面一个接口，可以这么写，实际可以在这里要加一层接口判断。&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;RATE_LIMITER.tryAcquire()) {
            requestContext.setSendZuulResponse(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HttpStatus.TOO_MANY_REQUESTS.value()里面有静态代码常量&lt;/span&gt;
&lt;span&gt;            requestContext.setResponseStatusCode(HttpStatus.TOO_MANY_REQUESTS.value());
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br/&gt;&lt;span&gt;我只是偶尔安静下来，对过去的种种思忖一番。那些曾经的旧时光里即便有过天真愚钝，也不值得谴责。毕竟，往后的日子，还很长。不断鼓励自己，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;天一亮，又是崭新的起点，又是未知的征程（上校10）&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 06 Sep 2018 13:40:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>zuul权限校验、接口限流 一、权限校验搭建 正常项目开发时,权限校验可以考虑JWT和springSecurity结合进行权限校验，这个后期会总结，这里做个基于ZuulFilter过滤器进行一个简单的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9601170.html</dc:identifier>
</item>
<item>
<title>多工序、多机台(产线)环境下的排程要点 - kentzhang</title>
<link>http://www.cnblogs.com/kentzhang/p/9600973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kentzhang/p/9600973.html</guid>
<description>&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;195.82070598364&quot;&gt;

&lt;p&gt;释义：文中提到的资源，是指需要完成一个生产作业（或称任务，生产任务）所需的生产条件，例如机台、原料等，称为广义资源。 &lt;/p&gt;
&lt;p&gt;对于生产计划，常见有以下四种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单一工序，单一资源种类.&lt;/li&gt;
&lt;li&gt;单一工序，多资源种类.&lt;/li&gt;
&lt;li&gt;多工序，单一资源种类(较少见).&lt;/li&gt;
&lt;li&gt;多工序，多资源种类.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　下面对上述四种生产计划进行逐一分析，本文的分析，着重于计划的优化实现，而不是硬性规则的确保。例如通过工序的就绪情况来确定资源的就绪要求，例如MRP等，这些硬性的约束可以通过规则引擎（例如&lt;a href=&quot;http://www.drools.org/&quot; target=&quot;_blank&quot;&gt;Drools&lt;/a&gt;）来确保在生成计划过程中，计划的安排满足各种业务规则；而无需通过规划引擎（例如&lt;a href=&quot;http://www.optaplanner.org/&quot; target=&quot;_blank&quot;&gt;Optaplanner&lt;/a&gt;)，在满足了硬性业务规则的基础上进一步优化。&lt;/p&gt;
&lt;h2&gt; 单一工序，单一资源种类&lt;/h2&gt;
&lt;p&gt;　　对于单一工序，单一种类资源的情况，是最简单的一种排程场景。即一个产品的生产过程只需使用同一种资源，进行一次加工即完成了产品的整个生产过程。这种情况下，既然是单一工序，那也就没有了工序的先后资源的限制；单一种类资源，即表示没有了资源的选择优化。在生产实践中，此类生产计划通常是对产品工序路线中，众多工序中的一个较重要的工序进行制定计划时使用。需要进行优化的主要是对资源的使用分配，例如各机之间实现负荷平衡等需求。我们在实现这类计划时，需要通过设定机台平衡的约束，让引擎在为工序分配任务时，尽可能地实现同一类机的负荷平衡。例如在印刷生产中，对排在最后的手工工序制定生产计划时，需要根据各个产线的人力安排情况，按比例安排定额任务。这些情况可使用“单一工序、单一种类”资源计划。&lt;/p&gt;
&lt;h2&gt; 单一工序，多资源种类&lt;/h2&gt;
&lt;p&gt;　　单一工序 ，多种类资源情况，仅对产品的一个工序进行排产，仅可用于这个工序的资源是多种多样的，并且各种资源之间可以互换的。此类计划主要是为了实现资源的优化分配。即按照一定的原则来对各个工序进行资源安排。例如：各种资源使用成本各不相同，在制定计划时，为了降低生产成本，应该在确保其它更高优先级的约束或硬性约束的前提下，尽量使用低成本的资源进行生产。举个实际的例子，在印刷行业中，对于对印张进行印刷的工序，有些印张可以通过CMYK四色印制，也可以通过调配特殊色，通过专色印制；但前者的成本相比后者更低，前后两种印刷方式就表示两种资源。在对印刷工序定制生产计划时，就会优先使用CMYK印刷，但这个也不是绝对的，例如如果CMYK资源已经超出负荷时，不动用专色印刷就无法实现按时交货时，还是会放弃成本这个约束，来迁就交期这个更高优先级的约束的。&lt;/p&gt;
&lt;h2&gt;多工序，单一资源种类&lt;/h2&gt;
&lt;p&gt;　　多个工序，单一种类资源的情况，则相对较少见。即计划中需要制定整个产品工序路线中的所有工序的资源和时间，其中资源只需要只有一种可选。可以理解到，这种情况对资源分配的要求就较低了，计划着重于对工序的前后关系制约了或工序自身的其它因素的优化。即是在资源分配上，如第一种情况：“单一资源、单一任务”一样，基于资源利用的一些原则进行资源分配。而在安排工序的加工时间问题上，则需要根据产品的工序路线，实现对前后工序在时间上的次序关系；而这种次序又受到资源分配的限制。例如：如果印刷的第二工序中（有些企业称为印后加工），有过油、过胶、过UV三个工序，如果有一种机台同时可以实现这三种工序的，那么就满足了“多个工序、单一资源种类”的场景。这时候关于工序的资源分配，会有相应的资源使用约束。但更重要的约束是：一个产品的多个工序的处理次序上，这个次序必然是根据产品的工序路线设定的资源来执行的，否则就违反了硬性约束。所以，综合上述的资源分配和工序资源两种要求，我们需要面对的是两上互相矛盾的问题：1. 对于同一个产品需要确保其执行的工序与工序路线上设定的一致， 2. 对于一个资源（例如机台）上的生产效率而言，如何可以实现更多的同工序连接生产，因为即使是使用同一资源，通常在该资源上，不同工序的生产任务之间的切换，会产生成本的，有可能是时间成本，也有可能是具体的货币成本。所以，难点就在于如何平衡上面两个问题，从而实现资源利用率最大化和工序资源不被违反。&lt;/p&gt;
&lt;h2&gt;多工序，多资源种类&lt;/h2&gt;
&lt;p&gt;　　多个工序，多资源种类的和产计划，也是目前最为常见，也是最为复杂的生产计划，是本文讨论的重点。多工序与前一个问题一样，是针对整个产品的工序路线进行排产。而且生产各个工序所用的资源是不同种类的。因此，这种情况我们面对了两个相对零散也有交互的矛盾：1. 对于一个产品而言，其多个工序是依据工序路线形成生产资源的； 2. 多种资源就表示各个生产工序所使用的资源有可能不一样，也有可能一样的。因为工序的前后次序的限制原因，当引擎在对一个工序完成了资源分配后，进一步进行生产时间的分配，但因为同一产品的工序执行次序，是需要按照工序路线的先后次序来执行的，也就是说计划中，除了需要分配好的资源外，还要确保这个资源在指定的时间段内，没有被其它产品的生产任务占用。那么当同时对多个产品进行排产时，各个产品的工序路线形成的工序生产序列和资源分配方案，很容易就形成了胶着状态，甚至在多个资源之间会出现死锁状态。&lt;/p&gt;
&lt;p&gt; 　　下面，我们以多个不同种类的机台，处理工序路线上多个工序的案例，来计划“多工序、多资源种类”的情况，并分析需要实现这种计划，所需的技巧、技术难点和可能出现的情况，及其应对方法.&lt;/p&gt;

&lt;h2&gt;规划过程中用到的概念&lt;/h2&gt;
&lt;p&gt;　　为了便于描述规划过程中的各种情况，现先定义以下概念：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;任务或生产任务&lt;/strong&gt;：一个产品的一个工序的生产作业称作一个任务，例如印刷后加工有：过胶 -&amp;gt; 烫金 -&amp;gt; 丝印，则表示这个产品的后加工中有三个任务，分别是过胶任务， 烫金任务和丝印任务。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;工序路线任务链&lt;/strong&gt;：一个产品中的不同工序对应的生产作业，其次序是由其工序路线确定的，一个产品的所有生产作业序列，即任务序列，称为工序路线任务链.&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;机台任务链&lt;/strong&gt;：多个任务被分配在一个机台上时，同一时间只能处理一个产品，即同一时间只能进行一个任务，这些同在一机台上形成的任务序列，称为机台任务链接.&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;前置任务，后置任务&lt;/strong&gt;：同一产品上多个任务，根据工序路线的规定形成与工序次序一次的生产任务次序(即工序路线任务链)。在链中两个相邻的任务，前者称作后者的前置任务；后者称作前者的后置任务。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;前一任务，后一任务&lt;/strong&gt;：分布于同一机台上的多个工序任务（即机台任务链），在机台任务链中相个相邻的任务；前者称为后者的前一任务，后者称作前者的前一任务。&lt;/p&gt;
&lt;h2&gt;多工序、多机台排程里的限制&lt;/h2&gt;
&lt;p&gt;　　下面我们来针对实用性最强，制造业面对最多的场景 ：多工序、多台机台场景展开讨论。处理这类生产计划，有以下两个因素处理起来最为麻烦。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1. 多任务与多机台的匹配&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　因为在待排的计划要素中，任务与机台的种类都存在多样性，且可能存一种任务可分配到多种机台，一种机台可以做多种任务的情况，因此，任务与机台的匹配问题会相对其它三种生产计划复杂一些。但往往这也是体现出Optaplanner价值的其中一个要点。&lt;/p&gt;
&lt;h4&gt;　　2. 工序路线任务链与机台任务链之间存在互相制约关系&lt;/h4&gt;
&lt;p&gt;　　　　一个产品的工序中线确定的任务序列，与分配于同一机台上的任务序列，在加工次序上存在互相制约。加工次序体现在加工的时间先后。即一个产品的任务序列，必然按其工序路线，存在一定的先后次序。而当个产品被分配到各个机台上进行生产作业时，因为生产路线上存在时间先后次序，会令到一个机台上多个任务需要按次序生产的时候，每个任务的作业时间段可能并不是紧密连接。因为当准备在机台上启动一个任务时，这个任务的前置工序可能尚未完成，从而令到该任务所在的机台已就绪（其前一任务已完成，机台已为该任务准备就绪），但因为它的前置工序还没完成，导致它无法开始，因为一旦开始就违反了工序路线约束，从而令该机台上排在它后面的其它后任务都要推迟，而这些任务被推迟，又有可能导致它们自身的后置任务需要推迟，从而会出现机台任务链和工序路线任务链互相影响。我们称这种情况为“&lt;strong&gt;连锁反应&lt;/strong&gt;”，解决好这种连锁反应，是解决排程的关键。&lt;/p&gt;
&lt;p&gt;　　因为上述描述的连锁反应的情况出现，有可能令出现&lt;strong&gt;环状影响&lt;/strong&gt;的情况。因为一个正常的产计划会存在&lt;strong&gt;时间&lt;/strong&gt;与&lt;strong&gt;空间&lt;/strong&gt;两个主要维度，其中的空间维度本文的场景中就是机台，表示为一个任务被分配到了指定机台。而时间维度则体现为任务的开始时间和结束时间（事实上结束时间可以通过开始时间推导出来），即确定一个任务的计划开始时刻。那么就需要有一个逻辑，对各个已分配空间（即机台）的任务进行时间推导。任务的时间推导我们需要通过Optaplanner的afterEntityChanged事件来进行(这个事件仅出现于Chained Through Time模式, 以后将会有专门的文章讲述Optaplanner的时间分配模式，其中Chained Through Time模式是重点)，而推导的起源(就是从哪个任务开始推)我们通常是以当前Move（Move是Optaplanner的最小作业单位）所处理的任务开始，这个任务我们称为&lt;strong&gt;震动源。&lt;/strong&gt;经过它的工序路线任务链传递到机台任务链，再由机台任务链的影响回工序路线任务链，当这种环状的影响线路，经过一系列的连锁反应，正好返回来对震动源进行推导的时候, 那么相当于又开始了轮与上一轮一样的推导路线，就会无限地推导下去，死循环就产生了。我们需要准确识别这种连锁反应会否产生死循环，并当确实产生死循环时，就要将当前的move标识的&lt;strong&gt;不合法&lt;/strong&gt;，在开启时间推导之前，通过Optaplanner的Move Selection Filter将当前的move取消，从而避免产生程序溢出，令系统崩溃。下面会举实际的死循环例子说明这种情况。&lt;/p&gt;
&lt;p&gt; 　　下面我们先明确多任务多机台生产计划的基础约束，再讨论死循环的具体产生经过。&lt;/p&gt;
&lt;h2&gt;计划约束&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;每个工序只能分配到指定的机台；&lt;/li&gt;
&lt;li&gt;除产品的首个工序外，所有任务都有一个前置任务，它的开始条件是它的前置任务已结束，即同一产品的工序根据工序路线存在FS关系。&lt;/li&gt;
&lt;li&gt;同一机台同一时间只能处理同一任务。即分配到机台上的工序生产任务，而生产时间不能重叠。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;排程过程中产生的死循环&lt;/h2&gt;
&lt;p&gt;　　例如下图：红框的任务Task1, Task2, Task3表示了一个产品的工序路线上的3个工序对应的任务，即表示这三个任务形成了工序路线任务链，它们分别分布于machine1, machine2, machine3三个机台。根据工序路线任务链的次序约束，其生产次序是Task1 -&amp;gt; Task2 -&amp;gt; Task3. 而蓝色背景的两个任务则是另外一个产品的工序路线任务链，根据该产品的工序路线，它的生产门外汉是TaskA -&amp;gt; TaskB, 可以看到这两个工序的次序跟红框工序中的Task2, Task3的次序是倒过来的。而从机台machine2的机台任务链上，我们可以看到,存在一个这样的生产次序关系：Task B -&amp;gt; Task 2。那么在Optaplanner通过一个Move来产生一个可能的方案，并对这个方案中各个任务的开始时间进行推导时，就有可能组合出如图中的状态，从而出现死循环，因为一个产品的工序需要按工序路线任务链的次序执行，而一个机台上生产机台任务链中的任务也是存在先后关系的，也即具有时序性的，一个机台在同一时间只能生产一个任务，也就有了一个机台自身的生产任务也是一个次序链的。从图中可以看出，存在了这么一个环状的生产任务次序： &lt;strong&gt;Task2&lt;/strong&gt; -&amp;gt; Task3 -&amp;gt; TaskA -&amp;gt; TaskB -&amp;gt; &lt;strong&gt;Task2,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;即当Task1, Task2, Task3, TaskA, TaskB中任意一个任务的开始时间被推导时，它都将成为上述死循环描述中的震动源，从而产生死循环。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/148283/201809/148283-20180902023728781-1239817215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;实际多工序多机台生产计划中的约束&lt;/h2&gt;
&lt;p&gt; 　　在实际制造中，除了上述讨论的三个主要约束外，还会存在非常多企业自身业务场景相关的限制因素，会更大程度上限制生产活动的执行。而这此限制需要正确地反映到生产计划中，否则最终产生的计划就无法执行。本文只列出对生成计划的正确性有影响的、各计划均会存在的共性因素；而那些与各个行业、企业的业务相关的个性化因素，则不在本文考虑范围内，各位在自己设计系统时考虑即可。例如：印刷行业中的印刷后加工工序，做完洒金粉工序，是需要等待一定时间，令金粉固化后，才能进入下一工序的，那么也就是说这个工序与下一个工序之间存在一个最短时间间隔的限制，否则是会产生质量事故的，因此是一个硬约束。&lt;/p&gt;
&lt;h2&gt;任务死循环的检测经验&lt;/h2&gt;
&lt;p&gt;　　因为生产计划的复杂性，造成工序任务链与机台任务链之间存在异常复杂的制约，需要对Optaplanner产生的可能方案进行合法性判断，识别任务的开始时间推导过程中，是否存在死循环的可能，则需要非常严谨的逻辑分析与正确的模型与算法设计。现分享一下本农在此类项目中，在这方面遇到的问题。&lt;/p&gt;
&lt;p&gt;　　当时我把机台任务链、工序路线任务链设计出来，并明确了模型中各实体的职责和关系后。发现了时间推导存在死循环的可能。因为我认为对Optaplanner将要规划出来的可能方案中的各种任务的关系已经有足够认识，就根据推导过程中可以出现的情况进行死循环检测，检测过程也相当简单。因为当一个可能方案中任务的时空关系一旦确定之后，所有的任务即构成了一个有向图(directed graph),那么我检查这个有向图是否存在环即可。我尝试过使用队列结构对这个图进行广度优先遍历，并识别环是否存在。也尝试过通过递归方式进行深度优先遍历（其实递归使用的数据结构就是栈，知晓VC++的同学应该从WinAPI32编程中学习过函数调用的机制，其实调用调用路径就是一个栈)。无论怎么尝试，检测结果就是无法完美、全面。因为我们项目中需要考虑的因素更多，出现意想不到的可能性更大。因此，有段时间我自己都觉得，不太可能解决这个问题，盟生了放弃的念头。幸好我遇到一个好领导，我的老板（我们这里都叫上级做老板）Jeffrey给了我非常多机会和支持，并不时跟我一起分析，他也了解到问题的复杂性，并给予理解与鼓励。最终我的解决办法是：对Optaplanner在规划过程中产生的每个可能方案，都进行模型上的抽象与简化，去除一些不影响死循环判断的因素，把它归约成一个正正式式的有向图，并通过一些成熟的有向图环检测的算法对其进行判断。其实思路主就是：把之前根据复杂的业务规则实现不同的逻辑进行分支检测的方法，倒过来，将含有一些业务因素的有向图，归约成数学算法可以处理的规范有向图，再对其进行检测。目前这个功能已经相当稳定，再她不会时不时出现意想不到的情况了。关于有向图的环检测算法，网上有很多，大家自己找或者自己研究都能弄出来，就不在本文深究了。&lt;/p&gt;
&lt;h2&gt;通过Selection Filter对不合法方案进行过滤&lt;/h2&gt;
&lt;p&gt;　　其实若我们只研究本文中提出的多任务多机台生产任务的最基本三个约束的话，上文提到的不合法方案就只剩下任务死循环方案了。若在现实项目开发中，一个方案不合法的定义会更多，更丰富，且更复杂。一旦我们通过各种手段检测出一个方案是不合法的。我们就可以通过Selection Filter，在Optaplanner对的VariableListener对象的afterEntityChanged事件处理方法之前，把事个move放弃掉。关于Selection FIlter的用法，大家可以先从Optaplanner的开发手册中查看，我将会专门撰写Selection Filter相关的文章 对其进行说明。&lt;/p&gt;

&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　自此，本文描述了基于Optaplanner设计APS排产引擎时，遇到比较棘手的问题。包括：计划类型的识别，由任务组成的工序链与机台链，任务与机台之间的匹配，工序链与机链之间的胶着可能性与循环识别与处理。希望能帮到大家。&lt;/p&gt;
&lt;p&gt;　　本人也是初初研究APS排程引擎，都还是在不断探索中，有不正确的地方，还请多多提点。为谢。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果对此大家有何建议，欢迎大家加我企鹅一起探讨,Q：12977379或&lt;/strong&gt;&lt;strong&gt;V信：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/148283/201809/148283-20180906203541004-2125861207.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实 Optaplanner规划引擎不需要对Java过份精通即可使用,因为它使用到的都是Java最基本的知道，但还是需要有基本的Java知识才行，希望大家找我研究讨论时，如果Java, Maven等方面仍接触较少，请大家先行自补该方面的知识，本猿暂时只能跟大家探讨Optaplanner, Drools的应用，而Java相关的知识，恕无法提供有效的帮助，毕竟本猿也只是个Java新手。先谢了。&lt;/strong&gt;&lt;/p&gt;


&lt;/div&gt;&lt;p&gt;一个IT老农，先尽力担好当儿子、丈夫和父亲的责任，然后做点有趣的事。&lt;/p&gt;</description>
<pubDate>Thu, 06 Sep 2018 13:04:00 +0000</pubDate>
<dc:creator>kentzhang</dc:creator>
<og:description>关于生产计划排程的种类及其特性 释义：文中提到的资源，是指需要完成一个生产作业（或称任务，生产任务）所需的生产条件，例如机台、原料等，称为广义资源。 对于生产计划，常见有以下四种类型： 单一工序，单一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kentzhang/p/9600973.html</dc:identifier>
</item>
<item>
<title>[原创作品]颠覆传统开发模式的web服务器 - 像风一样i</title>
<link>http://www.cnblogs.com/yueshutong/p/9600961.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yueshutong/p/9600961.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1136672/201809/1136672-20180906213618075-1434394507.png&quot; alt=&quot;//images2018.cnblogs.com/blog/1136672/201809/1136672-20180906213618075-1434394507.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;jerry-为何而生&quot;&gt;1、Jerry 为何而生&lt;/h2&gt;
&lt;p&gt;以Java web举例，现在的网站系统开发模式，对于web端和服务端的数据交互以及页面渲染，无外乎两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一种是交给后端处理，Jsp，Freemark模板引擎之流，这种开发模式需要前端人员做好静态页面交给后端去处理一些其它工作。这种开发模式到如今也依旧流行，这也是招聘Java web程序员要求也要会HTML、JS、CSS的原因。到现在基本上都是采用这种开发模式，注意这种模式并非真正的前后端分离！&lt;/li&gt;
&lt;li&gt;另一种是交给前端处理，前端全部完成web端的页面渲染工作。要知道的是，前端处理只能使用JS，一些前端JS模板引擎也有不少，无论再花哨，本质依旧是JS。不可忽视的是，完全依赖JS处理前端页面存在弊端，如果没弊端的话那第一种模式也早就淘汰了。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;jerry-是什么&quot;&gt;2、Jerry 是什么&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Jerry是帮助前后端完全分离的工具，它可以帮助后端工程师只做后端，前端工程师只做前端。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;jerry-的模式&quot;&gt;3、Jerry 的模式&lt;/h2&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;一种完全真正的前后端分离，Jerry采用如今最流行的JSON作为前后端数据交互的接口。&lt;/p&gt;
&lt;p&gt;对后端工程师来说，只需要关心接口的实现，不需要再接触前端页面，甚至不要求懂HTML，JS等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;只做接口有什么优势？一套接口适用web、Android、ios各个平台，这对软件项目的可扩展性大大提升。不可否认的是，现在依旧有些网站采用后端直接返回html片段的开发模式，这对软件的扩展性非常不利。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;对前端工程师来说，任务脉络更为清晰而简洁。一是对页面进行类似JSP形式的渲染，这在之前是由后端工程师来做的。可以说是完全颠覆以往。而且，非JS渲染，自然不存在JS渲染页面的弊端。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;jerry-的优势&quot;&gt;4、Jerry 的优势&lt;/h2&gt;
&lt;ol readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;快！启动快，毫秒级的启动！&lt;/p&gt;
&lt;p&gt;响应快，配置后台监控，响应时间一览无遗。&lt;/p&gt;
&lt;p&gt;优先读取各种文件的缓存，使用EhCache实现。&lt;/p&gt;
&lt;p&gt;对于后端接口，在缓存的基础上使用负载均衡。负载均衡算法为加权轮询。&lt;/p&gt;
&lt;p&gt;对于日志监控等耗时而且响应无关的操作，全部运行在其它线程。&lt;/p&gt;
&lt;p&gt;如果你还有其它加快速度的方法，欢迎留言私信。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;轻！轻量级，没有过多依赖，大部分功能能自己实现就自己写。全部依赖如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Netty&lt;/li&gt;
&lt;li&gt;slf4j + logback&lt;/li&gt;
&lt;li&gt;fastjson&lt;/li&gt;
&lt;li&gt;ehcache&lt;/li&gt;
&lt;li&gt;jsoup&lt;/li&gt;
&lt;li&gt;junit4&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;自带监控系统。对页面的响应速度以及HTTP信息一览无遗。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;jerry-语法&quot;&gt;5、Jerry 语法&lt;/h2&gt;
&lt;p&gt;Jerry 渲染HTML页面的语法类似EL表达式。形如：&lt;code&gt;${字段名}&lt;/code&gt;，我们称之为取名为JE表达式。&lt;/p&gt;
&lt;p&gt;例如，服务端的JSON数据为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;message&quot;: &quot;响应成功&quot;,
    &quot;state&quot;: {
        &quot;message&quot;: &quot;ok&quot;,
    },
    &quot;data&quot;: [{
        &quot;time&quot;: &quot;2018-04-25 13:25:07&quot;,
    }, {
        &quot;time&quot;: &quot;2018-04-25 13:25:07&quot;,
    }]

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们想获取 message的值渲染到html页面，只需要在html页面写入：&lt;code&gt;${message}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于state对象里的message，可以写入：&lt;code&gt;${state.message}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于data数组对象里的time值，可以写入：&lt;code&gt;${data[0].time}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;值得一提的是，JE暂时不支持if else，while等语法，这将是下一个版本的首要解决问题。&lt;/p&gt;
&lt;h2 id=&quot;监控系统&quot;&gt;6、监控系统&lt;/h2&gt;
&lt;p&gt;监控系统对各个页面与文件的响应耗时与请求信息进行监控，监控频率可以在全局配置文件中进行自定义配置，默认为10s。&lt;/p&gt;
&lt;p&gt;对于监控日志可以自定义输出目录，目录只支持相对路径（也就是只能在webapps目录下），监控日志格式为JSON。&lt;/p&gt;
&lt;p&gt;默认提供的监控页面位于webapps/manage项目下。默认访问：&lt;a href=&quot;http://ip%E5%9C%B0%E5%9D%80:8888/manage&quot; class=&quot;uri&quot;&gt;http://ip地址:8888/manage&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;后台监控页面预览：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1136672/201809/1136672-20180906200050889-260934544.png&quot; alt=&quot;//images2018.cnblogs.com/blog/1136672/201809/1136672-20180906200050889-260934544.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;监控系统运行流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1136672/201809/1136672-20180906200057694-271202095.png&quot; alt=&quot;//images2018.cnblogs.com/blog/1136672/201809/1136672-20180906200057694-271202095.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;负载均衡&quot;&gt;7、负载均衡&lt;/h2&gt;
&lt;p&gt;需要说明的是，对于Jerry的负载均衡与Nginx的负载均衡是不一样的。换一个角度来说，拥有cache的Jerry负载均衡功能更强大。因为Jerry已经缓存了整个文件，包括经过渲染后的含有JE与法的文件。所以在缓存时间内，它只会访问后端接口一次，只有缓存失效后，才会再次访问。如果你想体验加权负载均衡，可以把缓存时间设置为1。然后不断刷新页面。关于如何设置负载均衡，参考接口配置。&lt;/p&gt;
&lt;h2 id=&quot;全局配置&quot;&gt;8、全局配置&lt;/h2&gt;
&lt;p&gt;全局配置文件位于config目录下，使用默认UTF-8编码进行读取。详细配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#开启端口
port=8888
#默认首页
index=index.html
#默认项目
project=ROOT
#全局404模板（webapps/）
404=/template/404.html
#接口配置文件名，要求内容为Json
config=page.json
#接口配置文件的编码
charset=UTF-8
#监控刷新频率(毫秒/ms)
monitor=10000
#监控文件目录（webapps/）
monitorLog=/manage/log.json
#缓存：最大存储元素个数
maxElementsInMemory=10000
#缓存：最大发呆时间(秒/s)
timeToIdleSeconds=120
#缓存：最大存活时间(秒/s)
timeToLiveSeconds=600
#控制台日志级别INFO/DEBUG
level=INFO&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Jerry把所有的web项目与页面都放在了webapps下，服务器也只会响应webapps目录下的文件。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;关于全局404模板，默认即可。不过也支持自定义。&lt;/li&gt;
&lt;li&gt;关于接口配置文件，默认page.json。你可以自定义，但一定必须是json内容，而且位于项目根目录下（如ROOT/page.json）。&lt;/li&gt;
&lt;li&gt;接口配置文件的编码就是page.json文件的读取时的编码格式。默认utf-8&lt;/li&gt;
&lt;li&gt;监控刷新频率。最低为1s，默认10s。&lt;/li&gt;
&lt;li&gt;上面缓存的意思是在有效的600秒(10分钟)内，如果连续120秒(2分钟)未访问缓存，则缓存失效。就算有访问，也只会存活600秒。&lt;/li&gt;
&lt;li&gt;当你想查看运行日志时，切换为debug即可。默认info。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;接口配置&quot;&gt;9、接口配置&lt;/h2&gt;
&lt;p&gt;先看一下示范文件，下面进行讲解。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[
  {
    &quot;page&quot;: &quot;index.html&quot;,
    &quot;id&quot;: &quot;je&quot;,
    &quot;method&quot;: &quot;GET&quot;,
    &quot;timeout&quot;: 20000,
    &quot;header&quot;: {
      &quot;Connection&quot;: &quot;keep-alive&quot;
    },
    &quot;inter&quot;: [
      {
        &quot;link&quot;: &quot;https://www.kuaidi100.com/query?type=shentong&amp;amp;postid=3374107234608&amp;amp;id=1&quot;,
        &quot;weight&quot;: 1
      },
      {
        &quot;link&quot;: &quot;https://www.kuaidi100.com/query?type=yuantong&amp;amp;postid=801371015800473775&quot;,
        &quot;weight&quot;: 2
      }
    ]
  },
  {
    &quot;page&quot;: &quot;admin/index.html&quot;,
    &quot;id&quot;: &quot;je&quot;,
    &quot;method&quot;: &quot;GET&quot;,
    &quot;timeout&quot;: 20000,
    &quot;header&quot;: {
      &quot;Connection&quot;: &quot;keep-alive&quot;
    },
    &quot;inter&quot;: [
      {
        &quot;link&quot;: &quot;https://www.kuaidi100.com/query?type=shentong&amp;amp;postid=3374107234608&amp;amp;id=1&quot;,
        &quot;weight&quot;: 1
      }
    ]
  }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;page&lt;/td&gt;
&lt;td&gt;HTML文件路径。如配置xxx相当于：项目名/xxx&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;ID名称。要求同一个page一定要有不同的id。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;method&lt;/td&gt;
&lt;td&gt;对后端接口发起请求时的方法。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;timeout&lt;/td&gt;
&lt;td&gt;对后端接口发起请求的超时时间。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;header&lt;/td&gt;
&lt;td&gt;对后端接口发起请求时的header。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;inter&lt;/td&gt;
&lt;td&gt;后端接口对象，可以定义多个实现负载均衡。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;link&lt;/td&gt;
&lt;td&gt;后端接口实际地址。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;weight&lt;/td&gt;
&lt;td&gt;权重，用于负载均衡。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;一些其它问题&quot;&gt;10、一些其它问题&lt;/h2&gt;
&lt;h3 id=&quot;linux与windows&quot;&gt;1、Linux与Windows&lt;/h3&gt;
&lt;p&gt;在Linux部署Jerry服务器，访问文件严格区分大小写。而在Windows对大小写不敏感。&lt;/p&gt;
&lt;p&gt;举个例子，访问/ROOT和/ROOt时，在Windows是可以的，在Linux是失败的。&lt;/p&gt;
&lt;p&gt;如果在使用中您还遇到了其它Bug，欢迎在我的码云项目或者博客给我留言评论。&lt;/p&gt;
&lt;h3 id=&quot;关于编码&quot;&gt;2、关于编码&lt;/h3&gt;
&lt;p&gt;对于不需要JE处理的HTML文件来说，不涉及编码问题。&lt;/p&gt;
&lt;p&gt;对于需要JE处理的HTML文件，你在HTML文件中声明的&lt;code&gt;&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;&lt;/code&gt;关乎如何解析你的文件。若出现乱码，请检查你的HTML文件。&lt;/p&gt;
&lt;h3 id=&quot;如何启动&quot;&gt;3、如何启动&lt;/h3&gt;
&lt;p&gt;下载zip压缩包，解压后执行&lt;code&gt;java -jar 文件名&lt;/code&gt;即可运行。&lt;/p&gt;
&lt;p&gt;如使其在后台运行，在末尾加个&lt;code&gt;&amp;amp;&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;然后使用的问题，一般来说，看看ROOT项目如何做的，在查看上面的文档，就差不多懂了。&lt;/p&gt;
&lt;h2 id=&quot;作者有话&quot;&gt;11、作者有话&lt;/h2&gt;
&lt;h3 id=&quot;禁止申请专利还有非常感谢大家支持&quot;&gt;禁止申请专利！还有，非常感谢大家支持！&lt;/h3&gt;
&lt;p&gt;Jerry源于我四个月前的一个想法，经过了四个月的学习，然后最近把项目重构了一遍。发到了各个平台。不谈项目好坏，至少它让我对这段时间的学习做了一次实践。最后，很想说一句话，既然都在谈前后端分离，这次，不如分的彻底点！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/zyzpp/JerryServer/stargazers&quot;&gt;&lt;img src=&quot;https://gitee.com/zyzpp/JerryServer/badge/star.svg?theme=dark&quot; alt=&quot;star&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/zyzpp/JerryServer/members&quot;&gt;&lt;img src=&quot;https://gitee.com/zyzpp/JerryServer/badge/fork.svg?theme=dark&quot; alt=&quot;fork&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的博客：&lt;a href=&quot;https://yueshutong.cnblogs.com/&quot; class=&quot;uri&quot;&gt;https://yueshutong.cnblogs.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gitee：&lt;a href=&quot;https://gitee.com/zyzpp/JerryServer&quot; class=&quot;uri&quot;&gt;https://gitee.com/zyzpp/JerryServer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github：&lt;a href=&quot;https://github.com/yueshutong/JerryServer/&quot; class=&quot;uri&quot;&gt;https://github.com/yueshutong/JerryServer/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;开源中国：&lt;a href=&quot;https://www.oschina.net/p/jerryserver&quot; class=&quot;uri&quot;&gt;https://www.oschina.net/p/jerryserver&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Sep 2018 13:01:00 +0000</pubDate>
<dc:creator>像风一样i</dc:creator>
<og:description>Jerry Server 开发文档 1、Jerry 为何而生 以Java web举例，现在的网站系统开发模式，对于web端和服务端的数据交互以及页面渲染，无外乎两种： 1. 第一种是交给后端处理，Js</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yueshutong/p/9600961.html</dc:identifier>
</item>
</channel>
</rss>