<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>关于IM的一些思考与实践 - stoneniqiu</title>
<link>http://www.cnblogs.com/stoneniqiu/p/8626931.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stoneniqiu/p/8626931.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/stoneniqiu/p/8488150.html&quot; target=&quot;_blank&quot;&gt;上一篇&lt;/a&gt;简单的实现了一个聊天网页，但这个太简单，消息全广播，没有用户认证和已读未读处理，主要的意义是走通了&lt;a href=&quot;https://github.com/sta/websocket-sharp&quot; target=&quot;_blank&quot;&gt;websocket-sharp&lt;/a&gt;做服务端的可能性。那么一个完整的IM还需要实现哪些部分？&lt;/p&gt;
&lt;h2&gt;一、发消息&lt;/h2&gt;
&lt;p&gt;用户A想要发给用户B，首先是将消息推送到服务器，服务器将拿到的toid和内容包装成一个完整的message对象，分别推送给客户B和客户A。为什么也要推送给A呢，因为A也需要知道是否推送成功，以及拿到了messageId可以用来做后面的已读未读功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/417688/201803/417688-20180322212454320-1564181380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里有两个问题还要解决，第一个是Server如何推送到客户B，另外一个问题是群消息如何处理？&lt;/p&gt;
&lt;h3&gt;实现推送&lt;/h3&gt;
&lt;p&gt;先解决第一个问题，在Server端，每次连接都会创建一个WebSocketBehavior对象，每个WebSocketBehavior都有一个唯一的Id，如果用户在线我们就可以推送过去：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 Sessions.SendTo(userKey, Json.JsonParser.Serialize(msg));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要解决的是需要将用户的Id和WebSocketBehavior的Id关联起来，所以这就要求每个用户连接之后需要马上验证。所以用户的流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/417688/201803/417688-20180322213903438-1619076231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于JavaScript和Server交互的主要途径就是onmessage方法，暂时不能像socketio那样可以自定义事件让后台执行完成后就触发，我们先只能约定消息类型来实现验证和聊天的区分。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; send(obj) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须是对象，还有约定的类型&lt;/span&gt;
&lt;span&gt;        ws.send(JSON.stringify(obj))
    }
 socketSDK.sendTo &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (toId,msg) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
            toId:toId,
            content: msg,
            type: &lt;/span&gt;&quot;002&quot;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;聊天&lt;/span&gt;
&lt;span&gt;        }
        send(obj);
      }
    socketSDK.validToken &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (token) {
          &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
              content: token &lt;/span&gt;||&lt;span&gt; localStorage.token,
              type: &lt;/span&gt;&quot;001&quot;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证&lt;/span&gt;
&lt;span&gt;          }
          send(obj);
      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在后端拿到token就可以将用户的guid存下来，所有用户的guid与WebSocketBehavior的Id关系都保存在缓存里面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; infos =&lt;span&gt; _userService.DecryptToken(token);
 UserGuid &lt;/span&gt;= infos[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!cacheManager.IsSet(infos[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]))
  {
   &lt;span&gt; cacheManager.Set(infos[&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt;], Id, &lt;span&gt;60&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
  }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;告之client验证结果，并把guid发过去&lt;/span&gt;
SendToSelf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token验证成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用WebSocketBehavior的Send方法可以将对象直接发送给与其连接的客户端。接下来我们只需要判断toid这个用户在缓存里面，我们就能把消息推送给他。如果不在线，就直接保存消息。&lt;/p&gt;
&lt;h3&gt;群消息&lt;/h3&gt;
&lt;p&gt;群是一个用户的集合，发一条消息到群里面，数据库也只需要存储一条，而不是每个人都存一条，但每个人都会收到一次推送。这是我的Message对象和Group对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2304e183-22d5-4b14-8fd6-527936b1595e')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_2304e183-22d5-4b14-8fd6-527936b1595e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2304e183-22d5-4b14-8fd6-527936b1595e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2304e183-22d5-4b14-8fd6-527936b1595e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2304e183-22d5-4b14-8fd6-527936b1595e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Message
    {
       &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _receiverId;

       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Message()
       {
           SendTime &lt;/span&gt;=&lt;span&gt; DateTime.Now;
           MsgId &lt;/span&gt;= Guid.NewGuid().ToString().Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
       }

       [Key]
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MsgId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; SenderId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Content { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime SendTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsRead { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ReceiverId
       {
           &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
           {
               &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _receiverId;
           }
           &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
           {
               _receiverId &lt;/span&gt;=&lt;span&gt; value;
               IsGroup&lt;/span&gt;=&lt;span&gt;isGroup(_receiverId);
           }
       }

       [NotMapped]
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Int32 MsgIndex { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
       
       [NotMapped]
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsGroup { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; isGroup(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key)
       {
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; !&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(key) &amp;amp;&amp;amp; key.Length == &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;
       }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a8ed5929-1079-455a-8249-99fe9d6daddd')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_a8ed5929-1079-455a-8249-99fe9d6daddd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a8ed5929-1079-455a-8249-99fe9d6daddd&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a8ed5929-1079-455a-8249-99fe9d6daddd',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a8ed5929-1079-455a-8249-99fe9d6daddd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Group
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ICollection&amp;lt;User.User&amp;gt;&lt;span&gt; _users;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Group()
        {
            Id &lt;/span&gt;=&lt;span&gt; Encrypt.GenerateOrderNumber();
            CreateTime&lt;/span&gt;=&lt;span&gt;DateTime.Now;
            ModifyTime&lt;/span&gt;=&lt;span&gt;DateTime.Now;
        }

        [Key]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime CreateTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime ModifyTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
 
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GroupName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Image { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

       [Required]
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;群主&lt;/span&gt;
       &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CreateUserId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
   
        [NotMapped]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; User.User Owner { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ICollection&amp;lt;User.User&amp;gt;&lt;span&gt; Users
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; _users??(_users=&lt;span&gt;new&lt;/span&gt; List&amp;lt;User.User&amp;gt;&lt;span&gt;()); }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; { _users =&lt;span&gt; value; }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Description { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsDeleteD { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;对于Message而言，主要就是SenderId，Content和ReceiverId，我通过ReceiverId来区分这条消息是发给个人的消息还是群消息。对于群Id是一个长度固定的字符串区别于用户的GUID。这样就可以实现群消息和个人消息的推送了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　　　　　　　case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;正常聊天
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先检查是否合法&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;IsValid)
                        {
                            SendToSelf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请先验证!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在这里创建消息 避免群消息的时候多次创建&lt;/span&gt;
                        &lt;span&gt;var&lt;/span&gt; msg = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Message()
                        {
                            SenderId &lt;/span&gt;=&lt;span&gt; UserGuid,
                            Content &lt;/span&gt;=&lt;span&gt; obj.content,
                            IsRead &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                            ReceiverId &lt;/span&gt;=&lt;span&gt; toid,
                        };
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先发送给自己 两个作用 1告知对方服务端已经收到消息 2 用于对方通过msgid查询已读未读&lt;/span&gt;
&lt;span&gt;                        SendToSelf(msg);

                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断toid是user还是 group&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (msg.IsGroup)
                        {
                            log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;群消息:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+obj.content+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,发送者：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;UserGuid);
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;那么要找出这个group的所有用户&lt;/span&gt;
                            &lt;span&gt;var&lt;/span&gt; group =&lt;span&gt; _userService.GetGroup(toid);
                            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; user &lt;span&gt;in&lt;/span&gt;&lt;span&gt; group.Users)
                            {
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;除了发消息的本人
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;群里的其他人都要收到消息&lt;/span&gt;
                                &lt;span&gt;if&lt;/span&gt; (user.UserGuid.ToString() !=&lt;span&gt; UserGuid)
                                {
                                    SendToUser(user.UserGuid.ToString(), msg);
                                }
                            }
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        {
                            log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;单消息:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + obj.content + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,发送者：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; UserGuid);
                            SendToUser(toid, msg);
                        }
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;save message
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;_msgService.Insert(msg);&lt;/span&gt;
                        &lt;span&gt;break&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而SendToUser就可以将之前的缓存Id拿出来了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SendToUser(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; toId, Message msg)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; userKey = cacheManager.Get&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(toId);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个判断可以拿掉 不存在的用户肯定不在线
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;var touser = _userService.GetUserByGuid(obj.toId);&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (userKey != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送给对方&lt;/span&gt;
&lt;span&gt;                Sessions.SendTo(userKey, Json.JsonParser.Serialize(msg));
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不需要通知对方
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SendToSelf(toId + &quot;还未上线!&quot;);&lt;/span&gt;
&lt;span&gt;            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;二、收消息&lt;/h2&gt;
&lt;p&gt;收消息包含两个部分，一个是发送回执，一个是页面消息显示。回执用来做已读未读。显示的问题在于，有历史消息，有当前的消息有未读的消息，不同人发的不同消息，怎么呈现呢？先说回执&lt;/p&gt;
&lt;h3&gt;回执&lt;/h3&gt;
&lt;p&gt;我定义的回执如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Receipt
    {
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Receipt()
       {
           CreateTime &lt;/span&gt;=&lt;span&gt; DateTime.Now;
           ReceiptId &lt;/span&gt;= Guid.NewGuid().ToString().Replace(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
       }
       [Key]
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ReceiptId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MsgId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
       &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
       &lt;span&gt;///&lt;/span&gt;&lt;span&gt; user的guid
       &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
       &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UserId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
       &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime CreateTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回执不同于消息对象，不需要考虑是否是群的，回执都是发送到个人的，单聊的时候这个很好理解，A发给B，B读了之后发个回执给A，A就知道B已读了。那么A发到群里一条消息，读了这条消息的人都把回执推送给A。A就可以知道哪些人读了哪些人未读。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/417688/201803/417688-20180322224406900-447261878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;js的方法里面我传了一个toid，本质上是可以通过message对象查到用户的id的。但我不想让后端去查询这个id，前端拿又很轻松。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   //&lt;/span&gt;&lt;span&gt;这个toid是应该可以省略的，因为可以通过msgId去获取&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;目前这么做的理由就是避免服务端进行一次查询。&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;toId必须是userId 也就是对应的sender&lt;/span&gt;
      socketSDK.sendReceipt = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (toId, msgId) {&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt; {
              toId: toId,
              content: msgId,
              type:&lt;/span&gt;&quot;003&quot;&lt;span&gt;
          }
          send(obj)
      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　　　　　　　case&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;003&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
                        key &lt;/span&gt;= cacheManager.Get&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(toid);
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; recepit = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Receipt()
                        {
                            MsgId &lt;/span&gt;=&lt;span&gt; obj.content,
                            UserId &lt;/span&gt;=&lt;span&gt; UserGuid,
                        };
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送给 发回执的人，告知服务端已经收到他的回执&lt;/span&gt;
&lt;span&gt;                        SendToSelf(recepit);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送给对方&lt;/span&gt;
                           &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Sessions.SendTo(key, Json.JsonParser.Serialize(recepit));
                        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; save recepit&lt;/span&gt;
                        &lt;span&gt;break&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样前端拿到回执就能处理已读未读的效果了。&lt;/p&gt;
&lt;h3&gt;消息呈现：&lt;/h3&gt;
&lt;p&gt;我采用的是每个对话对应一个div，这样切换自然，不用每次都要渲染。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/417688/201803/417688-20180322224921893-2024432582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当用户点击左边栏的时候，就会在右侧插入一个.messages的div。包括当收到了消息还没有页面的时候，也需要创建页面。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; leftsay(boxid, content, msgid) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个view不一定打开了。&lt;/span&gt;
        $box = $(&quot;#&quot; +&lt;span&gt; boxid);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以先放到隐藏的页面上去，&lt;/span&gt;
        word = $(&quot;&amp;lt;div class='msgcontent'&amp;gt;&quot;&lt;span&gt;).html(content);
        warp &lt;/span&gt;= $(&quot;&amp;lt;div class='leftsay'&amp;gt;&quot;).attr(&quot;id&quot;&lt;span&gt;, msgid).append(word);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ($box.length != 0&lt;span&gt;) {
            $box.append(warp);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            $box &lt;/span&gt;= $(&quot;&amp;lt;div class='messages' id=&quot; + boxid + &quot;&amp;gt;&quot;&lt;span&gt;);
            $box.append(word);
            $(&lt;/span&gt;&quot;#messagesbox&quot;&lt;span&gt;).append($box);    
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;未读消息&lt;/h3&gt;
&lt;p&gt;当前页面不在active状态，就不能发已读回执。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
   
 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; unreadmark(friendId, count) {
        $(&lt;/span&gt;&quot;#&quot; + friendId).find(&quot;span&quot;&lt;span&gt;).remove();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; span = $(&quot;&amp;lt;span class='unreadnum' &amp;gt;&quot;&lt;span&gt;).html(count);
        $(&lt;/span&gt;&quot;#&quot;+&lt;span&gt;friendId).append(span);
    }

sdk.on(&lt;/span&gt;&quot;messages&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sdk.isSelf(data.senderid)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自己说的&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;肯定是当前对话&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;照理说还要判断是不是当前的对话框&lt;/span&gt;
            data.list =&lt;span&gt; [];//为msg对象增加一个数组 用来存储回执
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (data.isgroup)
            selfgroupmsg[data.msgid] &lt;/span&gt;=&lt;span&gt; data;&lt;span&gt;//缓存群消息 用于处理回执&lt;/span&gt;
            rightsay(data.content, data.msgid);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;别人说的&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不一定是当前对话，就要从ReceiverId判断。&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; _toid =&lt;span&gt; data.senderid;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;sdk.isSelf(data.receiverid)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接受者不是自己 说明是群消息&lt;/span&gt;
                _toid =&lt;span&gt; data.receiverid;
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; boxid = _toid +&lt;span&gt; viewkey;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是当前会话就发送已读回执&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (_toid ==&lt;span&gt; currentToId) {
                sdk.sendReceipt(data.senderid, data.msgid);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;msgscache[_toid]) {
                    msgscache[_toid] &lt;/span&gt;=&lt;span&gt; [];
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存入未读列表&lt;/span&gt;
&lt;span&gt;                msgscache[_toid].push(data);
                unreadmark(_toid, msgscache[_toid].length);
            }

            leftsay(boxid, data.content, data.msgid);

        }

    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;单聊的时候已读未读比较简单，就判断这条消息是否收到了回执。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 $(&quot;#&quot; + msgid).find(&quot;.unread&quot;).html(&quot;已读&quot;).addClass(&quot;ed&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是群聊的时候，显示的是“几人未读”，而且要能够看到哪些人读了哪些人未读，为了最大的减少查询，在最初获取联系人列表的时候就需要将群的成员也一起带出来，然后前端记录下每一条群消息的所收到的回执。这样每收到一条就一个人。而前端只需要缓存发送的群消息即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;function&lt;/span&gt;&lt;span&gt; readmsg(data) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;区分是单聊还是群聊&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;单聊就直接是已读&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; msgid =&lt;span&gt; data.msgid;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rawmsg =&lt;span&gt; selfgroupmsg[msgid];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;rawmsg) {
            $(&lt;/span&gt;&quot;#&quot; + msgid).find(&quot;.unread&quot;).html(&quot;已读&quot;).addClass(&quot;ed&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            rawmsg.list.push(data);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到了这个群的信息&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; ginfo =&lt;span&gt; groupinfo[rawmsg.receiverid];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;总的人数&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; total =&lt;span&gt; ginfo.Users.length;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到原始的消息&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;已读的人数&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; readcount =&lt;span&gt; rawmsg.list.length;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;未读人数&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; unread = total - readcount-1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;除去自己&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; txt = &quot;已读&quot;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (unread != 0&lt;span&gt;) {
                txt &lt;/span&gt;= unread + &quot;人未读&quot;&lt;span&gt;;
                $(&lt;/span&gt;&quot;#&quot; + msgid).find(&quot;.unread&quot;&lt;span&gt;).html(txt);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                $(&lt;/span&gt;&quot;#&quot; + msgid).find(&quot;.unread&quot;).html(txt).addClass(&quot;ed&quot;&lt;span&gt;);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就可以显示几人未读了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/417688/201803/417688-20180322230205695-1377483783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小结：大致的流程已经走通，但还有些问题，比如历史消息和消息存储还没有处理，文件发送，另外还有对于一个用户他可能不止一个端，要实现多屏同步，这就需要缓存下每个用户所有的WebSocketBehavior对象Id。 后续继续完善。&lt;/p&gt;

</description>
<pubDate>Thu, 22 Mar 2018 15:32:00 +0000</pubDate>
<dc:creator>stoneniqiu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stoneniqiu/p/8626931.html</dc:identifier>
</item>
<item>
<title>selenium 基础（一） - crazymanpj</title>
<link>http://www.cnblogs.com/crazymanpj/p/8627679.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/crazymanpj/p/8627679.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;selenium安装&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
pip install selenium
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;selenium操作浏览器原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;早期selenium 1.0 用的selenium RC, 后来selenum2集合了selenium1.0 + webdriver，selenium RC被webdriver替换。通过webdriver，测试脚本（例如python）可以方便的通过API操作浏览器页面元素，包括打开，关闭，最大化，最小化，元素定位，元素单击等等等。但是selenium操作浏览器还需要一个驱动程序，不同的浏览器如filefox，chrome所需要的驱动程序不一样，就算是同款浏览器，因为浏览器内部提供的原生自动化接口API不同，也需要适配不同版本的驱动程序，不然就有可能出现调用接口失败的情况。&lt;/p&gt;
&lt;p&gt;webdriver按照server-client经典设计模式设计，client可以理解为测试脚本，selenium支持多种语言（java，python，ruby，php等），server端可以理解为浏览器，client和server的通信根据the WebDriver Wire协议告诉服务端我们希望浏览器接下来做什么事情。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;驱动下载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
Chrome:  https://sites.google.com/a/chromium.org/chromedriver/downloads
Edge:  https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/
Firefox:  https://github.com/mozilla/geckodriver/releases
Safari:  https://webkit.org/blog/6900/webdriver-support-in-safari-10/
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;一个selenium简单的例子：（相应驱动要放在path环境变量中）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from selenium import webdriver
browser = webdriver.Chrome()
url = 'http://www.baidu.com'
browser.get(url)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;浏览器基础操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法比较多，先整理一些，有需要后面再补充进来（有些参考了webdriver.py和webelement.py）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;新建一个driver，初始化要操作的浏览器&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
driver = webdriver.Chrome()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;访问url&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
driver.get(url)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;最大化窗口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
driver.maximize_window()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;设置窗口宽，高&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
driver.set_window_size(width,height)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;页面操作&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
browser.back()
browser.forward()
browser.refresh()
browser.close() 关闭当前窗口
browser.quit()  退出驱动并关闭每个关联窗口
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;页面信息&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
browser.title    
browser.current_url
browser.current_window_handle 返回当前窗口句柄
driver.window_handles 所有窗口handle
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;frame切换&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
switch_to_frame()
switch_to_window()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;对话框&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
switch_to_alert()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;控件填写信息,也可以是文件上传&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
send_keys()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;回车&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
send_keys(Keys.RETURN)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;判断元素是否可见&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
is_displayed()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;操作cookie&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
get_cookies()
get_cookie(name)
delete_cookie(name)
delete_all_cookies()
add_cookie(cookie_dict)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;显式等待和隐式等待&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;显式等待会让WebDriver等待满足一定的条件以后再进一步的执行。 而隐式等待让Webdriver等待一定的时间后再才是查找某元素。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;显式等待&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
WebDriverWait(driver, 10).untile(EC.visibility_of_element_located((By.CLASS_NAME, &quot;logo_sogou&quot;)))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;隐式等待&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
implicitly_wait(10)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;屏幕截屏&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
save_screeshot(filepath)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;元素查找&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;id查找&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
find_element_by_id(&quot;xxx&quot;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;name查找&lt;/strong&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
find_element_by_name(&quot;xxx&quot;)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;class查找&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
find_element_by_class_name(&quot;xxx&quot;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;css查找&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
find_element_by_css_selector('.s_ipt')
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;XPath查找&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类似于xml定位一样，html的标签也可以用这类方式来查找，而且更健壮&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
find_element_by_xpath(&quot;/html/body/form[1]&quot;)
find_element_by_xpath(&quot;//form[1]&quot;)   html页面中第一个form元素
find_element_by_xpath(&quot;//div[@id='search_ext']&quot;)
find_element_by_xpath(&quot;//div[@class='ipt_wrap']/span[1]&quot;)
find_element_by_xpath(&quot;//input[@name='continue'][@type='button']&quot;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;超链接查找&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
find_element_by_link_text('Continue')  完全匹配
find_element_by_partial_link_text('Conti')   部分匹配
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;一次查找返回多个元素（list）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
find_elements_by_name
find_elements_by_xpath
find_elements_by_link_text
&lt;/pre&gt;&lt;/div&gt;


&lt;hr/&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;http://selenium-python-zh.readthedocs.io/en/latest/index.html&lt;/p&gt;

</description>
<pubDate>Thu, 22 Mar 2018 15:30:00 +0000</pubDate>
<dc:creator>crazymanpj</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/crazymanpj/p/8627679.html</dc:identifier>
</item>
<item>
<title>NEO从入门到开窗(3) - NEO编译器 - Dexter Di</title>
<link>http://www.cnblogs.com/DexterDi/p/8627621.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DexterDi/p/8627621.html</guid>
<description>&lt;p&gt;一、啰嗦两句&lt;/p&gt;
&lt;p&gt;第一节的时候咱说了C#编译完了之后，就该NEO的编译器搞事情了。我们完全可以按这个节奏搞，手动用NEO的编译器neon编译dll文件生成指令码文件.avm。但是NEO团队给我们写智能合约提供了个插件，咱们就先看看这玩意怎么玩，然后简单的介绍一下NEO的编译器源码。&lt;/p&gt;

&lt;p&gt;二、NeoContractPlugin&lt;/p&gt;
&lt;p&gt;咱在VS里【工具】-》【扩展和更新】里搜下NeoContractPlugin，安装这个模板。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/217273/201803/217273-20180322222749976-1260385913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完事新建项目时候就能新建一个NeoContract的项目了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/217273/201803/217273-20180322222926371-26011942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建完之后，就是这样滴。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/217273/201803/217273-20180322223303845-2085422797.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好，按NEO的模板创建出来的东东，多了build.tasks和Neo.ConvertTask.dll这俩文件，除此之外，在项目文件里还导入了一个project和AfterBuild之后的任务。这里做的事情，其实就是告诉项目编译完了之后跑一个ConvertTask的任务，看到项目里的Neo.ConvertTask.dll了么，后面我们介绍它。 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/217273/201803/217273-20180322223527305-852210332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/217273/201803/217273-20180322223505084-1022211442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ConvertTask这个任务是干嘛的，我们来看一眼源码，源码在项目neo-devpack-dotnet中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;&lt;img id=&quot;code_img_closed_687c3b60-8efb-445e-98a1-ed2fc31338c9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_687c3b60-8efb-445e-98a1-ed2fc31338c9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_687c3b60-8efb-445e-98a1-ed2fc31338c9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;85&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Build.Framework;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Build.Utilities;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Diagnostics;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Neo
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; this class generate config / xml file by template
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConvertTask : Task
    {
        [Required]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ITaskItem DataSource { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; execute replace logic
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;ture successful, false failure&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Execute()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; srcdll = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.DataSource.ToString();
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; dllname =&lt;span&gt; System.IO.Path.GetFileName(srcdll);
            ProcessStartInfo pinfo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProcessStartInfo();
            pinfo.FileName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cmd.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            pinfo.WorkingDirectory &lt;/span&gt;=&lt;span&gt; System.IO.Path.GetDirectoryName(srcdll);
            pinfo.UseShellExecute &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            pinfo.RedirectStandardInput &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            pinfo.RedirectStandardOutput &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            pinfo.CreateNoWindow &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            pinfo.StandardOutputEncoding &lt;/span&gt;=&lt;span&gt; System.Text.Encoding.UTF8;

            Process p &lt;/span&gt;=&lt;span&gt; Process.Start(pinfo);
            p.StandardInput.AutoFlush &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            p.StandardInput.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;neon &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; dllname);
            p.StandardInput.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前四行后一行不要&lt;/span&gt;
            &lt;span&gt;string&lt;/span&gt; lastline = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; bSucc = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p.StandardOutput.EndOfStream == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; line =&lt;span&gt; p.StandardOutput.ReadLine();
                count&lt;/span&gt;++&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (count &amp;lt;= &lt;span&gt;4&lt;/span&gt;) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastline != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; lastline.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastline[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastline.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;WARN&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        {
                            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Log.LogWarning(lastline.Substring(&lt;span&gt;6&lt;/span&gt;&lt;span&gt;));
                            lastline &lt;/span&gt;=&lt;span&gt; line;
                            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (lastline.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;ERR&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        {
                            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Log.LogError(lastline.Substring(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;));
                            lastline &lt;/span&gt;=&lt;span&gt; line;
                            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (lastline.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;WARN|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        {
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; l = lastline.Substring(&lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ine = lastline.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; text = lastline.Substring(ine + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; file = lastline.Substring(&lt;span&gt;6&lt;/span&gt;, ine - &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lines = file.Split(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[] { &lt;span&gt;'&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; });
                            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; _line = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lines.Length &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                            {
                                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;.TryParse(lines[&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;out&lt;/span&gt;&lt;span&gt; _line);
                            }
                            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Log.LogWarning(&lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, lines[&lt;span&gt;0&lt;/span&gt;], _line, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, text);
                            lastline &lt;/span&gt;=&lt;span&gt; line;
                            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (lastline.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;ERR|&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        {
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; l = lastline.Substring(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ine = lastline.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; text = lastline.Substring(ine + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; file = lastline.Substring(&lt;span&gt;5&lt;/span&gt;, ine - &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
                            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lines = file.Split(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[] { &lt;span&gt;'&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; });
                            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; _line = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lines.Length &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                            {
                                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;.TryParse(lines[&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;out&lt;/span&gt;&lt;span&gt; _line);
                            }
                            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Log.LogWarning(&lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, lines[&lt;span&gt;0&lt;/span&gt;], _line, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, text);
                            lastline &lt;/span&gt;=&lt;span&gt; line;
                            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastline.IndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SUCC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    {
                        bSucc &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Log.LogMessageFromText(lastline, MessageImportance.High);

                }

                lastline &lt;/span&gt;=&lt;span&gt; line;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;lines.Add(line);&lt;/span&gt;
&lt;span&gt;            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this.Log.LogMessageFromText(lastline, MessageImportance.High);&lt;/span&gt;
&lt;span&gt;
            p.WaitForExit();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bSucc;
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;ConvertTask&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;好，先不管细节，就是起了一个cmd进程跑neon，其实就是帮我们调了一下NEO的编译器，妥了，那咱们就看看编译器搞了些撒事情吧。&lt;/p&gt;

&lt;p&gt;三、NEO编译器&lt;/p&gt;
&lt;p&gt;这一部分最好还是看看源码，我就简单介绍一下。这里有三个类比较关键：&lt;/p&gt;
&lt;p&gt;1. ModuleDefination: 这个类是用的库Mono.cecil，这个库可以查看或者修改IL文件，这里是官方地址：&lt;a href=&quot;http://www.mono-project.com/docs/tools+libraries/libraries/Mono.Cecil/&quot; target=&quot;_blank&quot;&gt;http://www.mono-project.com/docs/tools+libraries/libraries/Mono.Cecil/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. ILModule: 这个是编译器里定义的一个类，类的主要方法就是LoadModule，一看就明白了，其实现正是使用ModuleDefination加载并读取IL文件，将其转化为ILModule。这里其实还是用一种数据类型记录的智能合约代码的元数据信息，方法、字段、属性等的描述信息，可以理解成我们用反射操作类型。&lt;/p&gt;
&lt;p&gt;3. NeoModule: 这个是另外一个数据结构，通过一个ModuleConverter的类从ILModule逐条指令转化进NeoModule，这个结构里保持了一个有序字典，value就是转化后的指令码，也就是我们说的OpCode。之后就是把这个NeoModule Build成字段数组写入.avm文件。&lt;/p&gt;
&lt;p&gt;理解这三个类的含义就明白编译器的流程了。这里的难点是指令码，非常多，所以需要详细了解的自己看下源码吧。&lt;/p&gt;

&lt;p&gt;四、小结&lt;/p&gt;
&lt;p&gt;好了，今天就简单讲了一下NEO的智能合约模板背后都搞了啥，以及NEO编译器大概怎么编译的。通过前面几讲，大伙儿应该从工程的角度对NEO的智能合约这部分有些了解了。&lt;/p&gt;
&lt;p&gt;后续，准备从NEO的命令行全节点Neo-cli入手讲讲NEO的内部机制。&lt;/p&gt;

</description>
<pubDate>Thu, 22 Mar 2018 15:09:00 +0000</pubDate>
<dc:creator>Dexter Di</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DexterDi/p/8627621.html</dc:identifier>
</item>
<item>
<title>.Net小白的大学四年，内含面经 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/8627584.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/8627584.html</guid>
<description>&lt;p&gt;我是码农阿宇，和博客园的广大兄弟一样，我们都喜欢.Net,但是你们是985/211，而我江西一所普通得不能再普通的二本大学---九江学院，大四毕业在即，英语四级未过（为什么强调这一点？见文末……）,目前在百世物流（中国）科技有限公司担任.Net软件工程师，说得好听是叫软件工程师，其实就是一个刚来打杂的实习生（文末有少量面经）。&lt;/p&gt;
&lt;p&gt;个人觉得，一名我这样的渣渣大学生，是有怎样的能力才能进入一所这样的上市大公司？又是什么样的心态让我有勇气去面京东，去面网易？我想，大概是99%的厚脸皮加上我大学前三年修来的1%的能力。&lt;/p&gt;

&lt;p&gt;被入取到数字媒体技术专业，其实是搞游戏开发的，我还以为是搞传媒的，当时想着以为数字媒体搞传媒，妹子一定多，质量还一定很高，所以就报了，进来后，好像我想多了，妹子也还是有的，就是和想想的差距有点大。&lt;/p&gt;
&lt;p&gt;刚上大学，和大家一样，懵懂，满腔热血，高考发挥失常，所以刚上大学我励志大学一定好好努力，大四考研，来个咸鱼翻身，后面沉迷代码，放弃了。&lt;/p&gt;

&lt;p&gt;大二的时候，班主任问我们有没有想跟他一起做项目的，当时感觉“做项目”好高大上的样子，就报名参加了，老师的项目团队里面缺做C#开发的，我就这样阴差阳错地与.Net结下了不解之缘，到那天为止我对.Net还是一无所知，就到学校图书馆借了一本书，《C#从入门到精通》，那本书序言第一句：C#是一种优雅的语言。优雅~~  一个让男生肾上腺素上升的名词，所以就再同学们面前下了决心，优雅~~  优雅~~有意思，看我怎么把C#“搞定”吧！&lt;/p&gt;

&lt;p&gt;一学，就是两年。期间有学姐、有培训机构的老师、有步入职场好久的学长，告诉我，.Net不行了，换个方向学吧！！&lt;/p&gt;
&lt;p&gt;都上车了，想下去，没勇气了！花了两年的功夫，两年里，从一无所知到入门，大大小小参加了老师十多个项目，去过上海、赣州等地做过项目负责人，负责项目的开展，当年报名跟老师参加“做项目”的，也由十来个人，最后只有我一个，也变成了班上的“大神”。这两年，花得时间功夫，说转行，放弃，不舍得，也不甘心了。&lt;/p&gt;
&lt;p&gt;大致了解了C#后，虽然知道自己被《C#从入门到精通》一书的“优雅”一词骗了，有种“老子XXXX,你给我看这个？”的感觉，但是“大神”面子还是要的，不然就被通学嘲笑了！所以假装一副“沉迷.Net,无法自拔”的样子的程序猿的样子。哈哈~~&lt;/p&gt;

&lt;p&gt;其实在这几年里，除了敲代码，也干了其他的一些事情：&lt;/p&gt;
&lt;p&gt;（1）         在中国移动做兼职业务员，最终做到了主管。&lt;/p&gt;
&lt;p&gt;（2）         在“觅范中国”做江西省的省主管&lt;/p&gt;
&lt;p&gt;（3）         在UC（阿里巴巴）做校园大使&lt;/p&gt;
&lt;p&gt;（4）         在京东做过校园主管&lt;/p&gt;
&lt;p&gt;（5）         拿了三年的国家励志奖学金&lt;/p&gt;
&lt;p&gt;（6）         去了全国十一个省的不同地区旅游&lt;/p&gt;
&lt;p&gt;（7）         以及其他一些大学生在大学该做的事情（阴险笑…）&lt;/p&gt;
&lt;p&gt;这些，对我帮助很大，开阔了我的视野，也让我变成了一名不宅的程序员，我让我觉得大学很充实，最重要的，赚了几万块钱Money，每个人对每个人的大学正确过法都有自己的定义，但是我认为，我这样的大学，我很满意。&lt;/p&gt;

&lt;p&gt;转眼到了大四，在大四开学的时，各大互联网巨头公司便开始如火如荼的校招，很多同学，感觉还醉在了大学的美酒里，没有反应过来，要开始找工作了，我买了人生的第一套正装，头发梳成大人摸样，开始四处投简历，我所在的九江，一个四线小市，注定与大公司的校招宣讲无缘，所以我就踩着皮鞋夹着简历，那两个月的周末，武汉、南昌、合肥到处跑，碰了不少壁，但了积累了很多面试经验，以至于后面应付各种面试胸有成竹大概脸皮厚了，其中包括一场中国移动校招面试，八个老总，围坐一圈面我，我还是表现还可以。&lt;/p&gt;
&lt;p&gt;中间插播一些大家想看的面试心得：&lt;/p&gt;
&lt;p&gt;（1）         HR面过了那么多人，对各种自我表扬真的听出老茧，我觉得他们更喜欢听你说故事，对，说出你的故事，展现出你的不一样，这样相比那些干巴巴的自我表扬更有说服力。&lt;/p&gt;
&lt;p&gt;（2）         面试过程中，时刻自信、礼貌，同时保持谦卑。&lt;/p&gt;
&lt;p&gt;（3）         作为一名程序员面试，多借机会展现出你在某一方面的深入研究，比如研究了某个开源项目的源码，知道某个过程的工作原理，而不仅仅是，我知道怎么用。&lt;/p&gt;
&lt;p&gt;（4）         面试碰壁后，多总结，不要过去了就过去了，同样的坑，不能踩第二次，笔试题或者面试官问的不懂的问题结束后借助谷歌百度等搞懂。&lt;/p&gt;
&lt;p&gt;（5）         大学生，大家都没有什么深入的工作经验，但是，要展现出你的学习能力，不懂就是不懂，给面试官一种如果给我一定的时间，我一定能学会的信心，比如，当年老师给了一个什么没接触过的技术难点，我熬夜不到两天研究透彻。&lt;/p&gt;
&lt;p&gt;没什么太多的面经了，可能一时也没有想起来，后面想起了我会再作补充。&lt;/p&gt;
&lt;p&gt;最后说一下，作为学生走出校园，来到大公司实习后的感受。&lt;/p&gt;
&lt;p&gt;（1）         英语太差了，后悔没有好好学习英语，搞程序这一行，不得不承认，很多好的技术出来后，文档还有交流社区什么的都是英文的，我基本上要借助翻译软件翻译进行学习，而同事直接看全因为无压力，很羡慕，各位在大学的同学，一定不要放弃，好好学英语。&lt;/p&gt;
&lt;p&gt;（2）         其次，我发现但凡公司技术牛逼的都很热情，乐于奉献与分享，有不懂的问他们都很有耐心，所以我觉得要想成为和他们一样的大牛，也要善于把自己的学习心得体会分享出来。&lt;/p&gt;
&lt;p&gt;（3）         多看源码！看源码！&lt;/p&gt;
&lt;p&gt;（4）         刚出校园，一切不比在学校，没有那么清闲自在，会觉得我一直期待的走出校园，可走出来了但是怎么跟自己想象的完全不一样，既然改变不了它就去适应它，坚持下去，时间长了，就好了。&lt;/p&gt;
&lt;p&gt;（5）         毕业了，不等于不学习了，要像一块海绵，不停地吸水，社会嘈杂，没有校园安静有图书馆，但也要静下心学习。&lt;/p&gt;

&lt;p&gt;最后，感谢我的大学班主任-程老师，把我引进门并给我项目锻炼，让我走出校园有了一定项目经验。也感谢百世没有因为我学历不佳而拒绝我，给了我机会走进大企业。&lt;/p&gt;
&lt;p&gt;写下这篇文章，鼓励自己，勿忘初心，坚持下去。以上纯属个人观点，大家有不同的理解，欢迎来喷。&lt;/p&gt;
&lt;p&gt;爆大学毕业风骚照一张，纪念我逝去的大学，大学同学，很想你们。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1293736/201803/1293736-20180322230246192-2037880115.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;2018年3月22日西溪畔&lt;/p&gt;
</description>
<pubDate>Thu, 22 Mar 2018 15:04:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/8627584.html</dc:identifier>
</item>
<item>
<title>Java日志框架：slf4j作用及其实现原理 - 五月的仓颉</title>
<link>http://www.cnblogs.com/xrq730/p/8619156.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xrq730/p/8619156.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;简单回顾门面模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;slf4j是门面模式的典型应用，因此在讲slf4j前，我们先简单回顾一下门面模式，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;门面模式，其核心为&lt;span&gt;&lt;strong&gt;外部与一个子系统的通信必须通过一个统一的外观对象进行，使得子系统更易于使用&lt;/strong&gt;&lt;span&gt;。用一张图来表示门面模式的结构为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201803/801753-20180321204740208-1670144043.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;门面模式的核心为Facade即门面对象，门面对象核心为几个点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;知道所有子角色的功能和责任&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;将客户端发来的请求委派到子系统中，没有实际业务逻辑&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;不参与子系统内业务逻辑的实现&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;大致上来看，对门面模式的回顾到这里就可以了，开始接下来对SLF4J的学习。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;我们为什么要使用slf4j&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们为什么要使用slf4j，举个例子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;我们自己的系统中使用了logback这个日志系统
我们的系统使用了A.jar，A.jar中使用的日志系统为log4j
我们的系统又使用了B.jar，B.jar中使用的日志系统为slf4j&lt;/span&gt;-&lt;span&gt;simple

这样，我们的系统就不得不同时支持并维护logback、log4j、slf4j&lt;/span&gt;-simple三种日志框架，非常不便。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;解决这个问题的方式就是引入一个适配层，由适配层决定使用哪一种日志系统，而调用端只需要做的事情就是打印日志而不需要关心如何打印日志，slf4j或者commons-logging就是这种适配层，slf4j是本文研究的对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上面的描述，我们必须清楚地知道一点：&lt;span&gt;&lt;strong&gt;slf4j只是一个日志标准，并不是日志系统的具体实现&lt;/strong&gt;&lt;/span&gt;。理解这句话非常重要，slf4j只提做两件事情：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;提供日志接口&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;提供获取具体日志对象的方法&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;slf4j-simple、logback都是slf4j的具体实现，log4j并不直接实现slf4j，但是有专门的一层桥接slf4j-log4j12来实现slf4j。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了更理解slf4j，我们先看例子，再读源码，相信读者朋友会对slf4j有更深刻的认识。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;slf4j应用举例&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面讲了，slf4j的直接/间接实现有slf4j-simple、logback、slf4j-log4j12，我们先定义一个pom.xml，引入相关jar包：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 原文：五月的仓颉http://www.cnblogs.com/xrq730/p/8619156.html &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.xrq.log&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;log-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;log-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;http://maven.apache.org&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.11&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.slf4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;slf4j-api&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.7.25&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ch.qos.logback&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;logback-classic&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.2.3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.slf4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;slf4j-simple&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.7.25&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;log4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;log4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.2.17&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.slf4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;slf4j-log4j12&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.7.21&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;写一段简单的Java代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSlf4j() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Logger logger = LoggerFactory.getLogger(Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     logger.error(&quot;123&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;接着我们首先把上面pom.xml的第30行~第49行注释掉，即不引入任何slf4j的实现类，运行Test方法，我们看一下控制台的输出为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201803/801753-20180322210329212-109853098.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看到没有任何日志的输出，这验证了我们的观点：&lt;span&gt;&lt;strong&gt;slf4j不提供日志的具体实现，只有slf4j是无法打印日志的&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着打开logback-classic的注释，运行Test方法，我们看一下控制台的输出为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201803/801753-20180322210559779-329522420.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看到我们只要引入了一个slf4j的具体实现类，即可使用该日志框架输出日志。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后做一个测验，我们把所有日志打开，引入logback-classic、slf4j-simple、log4j，运行Test方法，控制台输出为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201803/801753-20180322210821802-131238582.png&quot; alt=&quot;&quot; width=&quot;1097&quot; height=&quot;150&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;和上面的差别是，可以输出日志，但是会输出一些告警日志，提示我们同时引入了多个slf4j的实现，然后选择其中的一个作为我们使用的日志系统。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从例子我们可以得出一个重要的结论，&lt;strong&gt;&lt;span&gt;即slf4j的作用：只要所有代码都使用门面对象slf4j，我们就不需要关心其具体实现，最终所有地方使用一种具体实现即可，更换、维护都非常方便&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;slf4j实现原理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面看了slf4j的示例，下面研究一下slf4j的实现，我们只关注重点代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;slf4j的用法就是常年不变的一句&quot;&lt;span&gt;&lt;strong&gt;Logger logger = LoggerFactory.getLogger(Object.class);&lt;/strong&gt;&lt;/span&gt;&quot;，可见这里就是通过LoggerFactory去拿slf4j提供的一个Logger接口的具体实现而已，LoggerFactory的getLogger的方法实现为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger getLogger(Class&amp;lt;?&amp;gt;&lt;span&gt; clazz) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Logger logger =&lt;span&gt; getLogger(clazz.getName());
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (DETECT_LOGGER_NAME_MISMATCH) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Class&amp;lt;?&amp;gt; autoComputedCallingClass =&lt;span&gt; Util.getCallingClass();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (autoComputedCallingClass != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; nonMatchingClasses(clazz, autoComputedCallingClass)) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             Util.report(String.format(&quot;Detected logger name mismatch. Given name: \&quot;%s\&quot;; computed name: \&quot;%s\&quot;.&quot;&lt;span&gt;, logger.getName(),
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                            autoComputedCallingClass.getName()));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             Util.report(&quot;See &quot; + LOGGER_NAME_MISMATCH_URL + &quot; for an explanation&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; logger;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从第2行开始跟代码，一直跟到LoggerFactory的bind()方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bind() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Set&amp;lt;URL&amp;gt; staticLoggerBinderPathSet = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; skip check under android, see also
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt; &lt;span&gt;http://jira.qos.ch/browse/SLF4J-328&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isAndroid()) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             staticLoggerBinderPathSet =&lt;span&gt; findPossibleStaticLoggerBinderPathSet();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the next line does the binding&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        StaticLoggerBinder.getSingleton();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         INITIALIZATION_STATE =&lt;span&gt; SUCCESSFUL_INITIALIZATION;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        reportActualBinding(staticLoggerBinderPathSet);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        fixSubstituteLoggers();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        replayEvents();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; release all resources in SUBST_FACTORY&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        SUBST_FACTORY.clear();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoClassDefFoundError ncde) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         String msg =&lt;span&gt; ncde.getMessage();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (messageContainsOrgSlf4jImplStaticLoggerBinder(msg)) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             INITIALIZATION_STATE =&lt;span&gt; NOP_FALLBACK_INITIALIZATION;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             Util.report(&quot;Failed to load class \&quot;org.slf4j.impl.StaticLoggerBinder\&quot;.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             Util.report(&quot;Defaulting to no-operation (NOP) logger implementation&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             Util.report(&quot;See &quot; + NO_STATICLOGGERBINDER_URL + &quot; for further details.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            failedBinding(ncde);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ncde;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (java.lang.NoSuchMethodError nsme) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         String msg =&lt;span&gt; nsme.getMessage();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (msg != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; msg.contains(&quot;org.slf4j.impl.StaticLoggerBinder.getSingleton()&quot;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             INITIALIZATION_STATE =&lt;span&gt; FAILED_INITIALIZATION;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             Util.report(&quot;slf4j-api 1.6.x (or later) is incompatible with this binding.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             Util.report(&quot;Your binding is version 1.5.5 or earlier.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             Util.report(&quot;Upgrade your binding to version 1.6.x.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; nsme;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        failedBinding(e);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Unexpected initialization failure&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个地方第7行是一个关键，看一下代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Set&amp;lt;URL&amp;gt;&lt;span&gt; findPossibleStaticLoggerBinderPathSet() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; use Set instead of list in order to deal with bug #138
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; LinkedHashSet appropriate here because it preserves insertion order
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; during iteration&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     Set&amp;lt;URL&amp;gt; staticLoggerBinderPathSet = &lt;span&gt;new&lt;/span&gt; LinkedHashSet&amp;lt;URL&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         ClassLoader loggerFactoryClassLoader = LoggerFactory.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getClassLoader();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         Enumeration&amp;lt;URL&amp;gt;&lt;span&gt; paths;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (loggerFactoryClassLoader == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             paths =&lt;span&gt; ClassLoader.getSystemResources(STATIC_LOGGER_BINDER_PATH);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             paths =&lt;span&gt; loggerFactoryClassLoader.getResources(STATIC_LOGGER_BINDER_PATH);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (paths.hasMoreElements()) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             URL path =&lt;span&gt; paths.nextElement();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            staticLoggerBinderPathSet.add(path);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ioe) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         Util.report(&quot;Error getting resources from path&quot;&lt;span&gt;, ioe);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; staticLoggerBinderPathSet;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个地方重点其实就是第12行的代码，getLogger的时候会去classpath下找STATIC_LOGGER_BINDER_PATH，STATIC_LOGGER_BINDER_PATH值为&quot;org/slf4j/impl/StaticLoggerBinder.class&quot;，即&lt;span&gt;&lt;strong&gt;所有slf4j的实现，在提供的jar包路径下，一定是有&quot;org/slf4j/impl/StaticLoggerBinder.class&quot;存在的&lt;/strong&gt;&lt;/span&gt;，我们可以看一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201803/801753-20180322225204212-2118755582.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201803/801753-20180322225216313-1753469757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201803/801753-20180322225225451-413964397.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们不能避免在系统中同时引入多个slf4j的实现，所以接收的地方是一个Set。大家应该注意到，上部分在演示同时引入logback、slf4j-simple、log4j的时候会有警告：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201803/801753-20180322225633011-1104573372.png&quot; alt=&quot;&quot; width=&quot;1031&quot; height=&quot;131&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是因为有三个&quot;org/slf4j/impl/StaticLoggerBinder.class&quot;存在的原因，此时reportMultipleBindingAmbiguity方法控制台输出语句：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; reportMultipleBindingAmbiguity(Set&amp;lt;URL&amp;gt;&lt;span&gt; binderPathSet) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isAmbiguousStaticLoggerBinderPathSet(binderPathSet)) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         Util.report(&quot;Class path contains multiple SLF4J bindings.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (URL path : binderPathSet) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;             Util.report(&quot;Found binding in [&quot; + path + &quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         Util.report(&quot;See &quot; + MULTIPLE_BINDINGS_URL + &quot; for an explanation.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;那网友朋友可能会问，同时存在三个&quot;org/slf4j/impl/StaticLoggerBinder.class&quot;怎么办？首先确定的是这不会导致启动报错，其次在这种情况下编译期间，编译器会选择其中一个StaticLoggerBinder.class进行绑定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后StaticLoggerBinder就比较简单了，不同的StaticLoggerBinder其getLoggerFactory实现不同，拿到ILoggerFactory之后调用一下getLogger即拿到了具体的Logger，可以使用Logger进行日志输出。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Mar 2018 15:03:00 +0000</pubDate>
<dc:creator>五月的仓颉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xrq730/p/8619156.html</dc:identifier>
</item>
<item>
<title>快速搭建CentOS+ASP.NET Core环境支持WebSocket - fyter</title>
<link>http://www.cnblogs.com/fyter/p/linux_centos_aspnet_core_websocket.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fyter/p/linux_centos_aspnet_core_websocket.html</guid>
<description>&lt;p&gt;以前用python，go尝试在linux下做web服务，python没有强类型支持与高性能，go又没有很好的集成开发环境（还有强迫症的语法），回头看了几次.net，都没有时间尝试，现终于实现了这些想法，与大家分享。做web大项目，做工程，必须要有称手的工具帮我调试、测试、开发。工程化很重要，VS是一个称职好选手。&lt;/p&gt;
&lt;p&gt;环境：CentOS 7.x，.net core 2&lt;/p&gt;
&lt;p&gt;以下.net core 2安装操作为官方方法。如果你使用Docker，那么更简单了，只需要docker pull microsoft/dotnet就可以了。如果你使用Bash On Windows，那么与实际对应的Linux子系统安装完全相同。&lt;/p&gt;
&lt;p&gt;https://www.microsoft.com/net/learn/get-started/linux/centos&lt;/p&gt;
&lt;p&gt;CentOS安装.net core（其他系统在这个页面都可以选择，包括：RHEL、Ubuntu、Debian、Fedora、openSUSE）：&lt;/p&gt;
&lt;p&gt;依次执行（root下没有sudo也可以）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; rpm --import https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;packages.microsoft.com/keys/microsoft.asc&lt;/span&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;sh&lt;/span&gt; -c &lt;span&gt;'&lt;/span&gt;&lt;span&gt;echo -e &quot;[packages-microsoft-com-prod]\nname=packages-microsoft-com-prod \nbaseurl= https://packages.microsoft.com/yumrepos/microsoft-rhel7.3-prod\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc&quot; &amp;gt; /etc/yum.repos.d/dotnetdev.repo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;yum&lt;/span&gt;&lt;span&gt; update
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt;&lt;span&gt; libunwind libicu
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; dotnet-sdk-&lt;span&gt;2.1&lt;/span&gt;.&lt;span&gt;101&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span class=&quot;prompt-unix&quot;&gt;&lt;span class=&quot;prompt-unix&quot;&gt;&lt;span class=&quot;prompt-unix&quot;&gt;只需要这几部，.net core 2就安装好了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用dotnet命令创建空web项目，编译测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet new web -&lt;span&gt;o wstest
dotnet build wstest
dotnet run &lt;/span&gt;--project wstest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：dotnet new 命令会帮你创建项目，包括文件夹，必要的项目文件。build与run命令之前可以cd wstest，这样就可以免去后面的参数，把当前目录当作操作对象。&lt;/p&gt;
&lt;p&gt;注：可以再简洁点：dotnet run -p wstest。编译运行一起完成。&lt;/p&gt;
&lt;p&gt;无意外的话，项目已经启动，并且在localhost（端口默认是5000）开始监听http请求。做这些事情的方便快捷是python、go、node.js、PHP、JAVA等等不能比的。当然，如果你在Windows下，就更快了，包括后续的编码、调试、测试。&lt;/p&gt;
&lt;p&gt;接下来，我们进入WebSocket阶段。&lt;/p&gt;
&lt;p&gt;1、我们先创建一个html文件，放到项目的wwwroot目录下，用于测试WebSocket。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;out&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt;&lt;span&gt; ws &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebSocket(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ws://127.0.0.1:5000/ws&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        ws.onopen &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;open&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        }
        ws.onmessage &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (ev) {
            log(ev.data)
        }
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; log(text) {
            out.innerHTML&lt;/span&gt;&lt;span&gt;+=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;div&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、开启asp.net的静态文件访问与WebSocket支持。Linux下的asp.net宿主服务Kestrel已经支持WebSocket，可以直接运行。&lt;/p&gt;
&lt;p&gt;在Startup.cs的public Configure成员函数中添加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;app.UseWebSockets();
app.UseStaticFiles();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、为Startup.cs的Startup类添加WebSocket处理方法（成员函数）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Echo(HttpContext ctx, WebSocket ws)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bytes = System.Text.UTF8Encoding.UTF8.GetBytes(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; buff = &lt;span&gt;new&lt;/span&gt; ArraySegment&amp;lt;&lt;span&gt;byte&lt;/span&gt;&amp;gt;&lt;span&gt;(bytes);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; ws.SendAsync(buff, WebSocketMessageType.Text, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, System.Threading.CancellationToken.None);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、再为Startup.cs的public Configure成员函数添加处理函数，可选择去掉app.Run的调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            app.Use(&lt;span&gt;async&lt;/span&gt; (context, next) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (context.WebSockets.IsWebSocketRequest)
                {
                    WebSocket ws &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.WebSockets.AcceptWebSocketAsync();
                    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; Echo(context, ws);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                    &lt;span&gt;await&lt;/span&gt;&lt;span&gt; next();
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、Startup.cs文件的头部添加引用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt; System.Net.WebSockets;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码就这么多了。接下来验证结果。&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1、如果你放到华为云、腾讯云，这样有安全组的服务器上，你需要开启之前提到的端口TCP转入权限。&lt;/p&gt;
&lt;p&gt;2、test.html中的websocket地址请更换为实际的服务器地址与端口。&lt;/p&gt;
&lt;p&gt;3、动态IP支持的云主机自己是不知道自己的外网IP地址的，所以只能监听0.0.0.0端口或者内外绑定的端口。&lt;/p&gt;
&lt;p&gt;4、注意自己的防火墙是否放行对应的端口，可用iptables或firewall-cmd查询，CentOS7默认采用firewall-cmd作为防火墙的操作端。iptables也可以，但是不能保存。可安装iptables-services解决。&lt;/p&gt;

&lt;p&gt;dotnet run以后，你可以找个浏览器访问你的http服务了。&lt;/p&gt;
&lt;p&gt;如果顺利，你可以看到页面输出ok字样。说明，asp.net core的静态页面已经输出，并且页面用WebSocket协议访问我们的http服务。&lt;/p&gt;

&lt;p&gt;不顺利的可能基本是监听的IP地址无法访问或端口未开放。&lt;/p&gt;
&lt;p&gt;另一个原因是dotnet创建的项目里没有项目配置文件，你可能不知道怎么配置监听ip与端口。下面是launchSettings.json文件。你应该把它放到项目的Properties文件夹中。它是我从VisualStudio向导生成的文件中提取的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;profiles&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;anyname&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;commandName&quot;: &quot;Project&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;launchBrowser&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&quot;environmentVariables&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;&lt;span&gt;
      },
      &lt;/span&gt;&quot;applicationUrl&quot;: &quot;http://0.0.0.0:5000/&quot;&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;好了，祝你顺利！&lt;/p&gt;
</description>
<pubDate>Thu, 22 Mar 2018 15:01:00 +0000</pubDate>
<dc:creator>fyter</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fyter/p/linux_centos_aspnet_core_websocket.html</dc:identifier>
</item>
<item>
<title>安装 Accumulo——突破自己，就是成长 - shoufengwei</title>
<link>http://www.cnblogs.com/shoufengwei/p/8627436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shoufengwei/p/8627436.html</guid>
<description>&lt;p&gt;在我刚开始接触分布式集群的时候，是自己在几台虚拟机中手动安装的 Hadoop 和 Spark ，所以当时对 Hadoop 的配置有个简单的印象 ，但是后面发现了 Cloudera 和 Ambari 之后（两个分布式集群自动管理工具），就再没有手动安装过。这就导致我用了很久的 Accumulo 却从未手动安装过，使用 Cloudera 安装导致我根本没有关心 Accumulo 是怎么从无到有冒出来的，只是简单了解了安装的大概过程，并学会了如何使用它。&lt;/p&gt;
&lt;p&gt;今天不同，当我再次安装 Cloudera 集群的时候，首先选择了 Ubuntu 16.04 操作系统进行安装（是的，我是个非常愿意尝试新鲜事物的人），无耐装好之后才发现使用 16.04 导致 Accumulo 的安装包（Parcel）根本无法进行集群内的分发，这就意味着我无法安装它，折腾了半天之后未果，当然自己也有想着手动安装一下算了，但是懒惰的本性让我打消了这个念头，我不愿意冒着折腾半天未必能成功的风险去手动安装，因为我有更好的解决方案——只需要将操作系统退回到 14.04 即可，因为我有多次在 14.04 上安装成功的经验，所以胸有成竹。但气愤的是不知什么问题，整个集群安装成功之后在安装 Accumulo 的时候一直报错，报错的原因是环境变量的问题，用惯了集群，我根本不知道这个问题应当如何解决，多次折腾未果。把人逼到绝路的时候，也就是应当改变的时候了，于是只能走上手动安装，这就有了今天这篇文章。&lt;/p&gt;

&lt;p&gt;打开 Accumulo 官网，很自然的先去找 quickstart，网址为：&lt;a href=&quot;http://accumulo.apache.org/quickstart-1.x/&quot; class=&quot;uri&quot;&gt;http://accumulo.apache.org/quickstart-1.x/&lt;/a&gt;。文档里写的很清楚，但是刚接触的人（比如我这个貌似老手的新手），也会有点不知所云，学习的最好方式就是去尝试，于是我毫不犹豫的就按照提示步骤执行下去。&lt;/p&gt;
&lt;p&gt;首先是下载，无需多言，在 &lt;a href=&quot;http://accumulo.apache.org/downloads/&quot; class=&quot;uri&quot;&gt;http://accumulo.apache.org/downloads/&lt;/a&gt; 中选择自己想要安装的版本即可。&lt;/p&gt;
&lt;p&gt;下载完后，解压缩并进入目录，前几步都没有问题，按照要求执行即可，当走到 Initialization 的时候一直在报错，折腾了许久才慢慢明白怎么回事，解决问题的过程也就对 Accumulo 和 Accumulo 的安装有了更加清晰的认识，知道了 Accumulo 到底是怎么回事。&lt;/p&gt;
&lt;p&gt;安装过程中的难点主要在于配置 &lt;code&gt;conf/accumulo-site.xml&lt;/code&gt; 和 &lt;code&gt;conf/accumulo-env.sh&lt;/code&gt; 这两个文件，要配置好这两个文件就要对 Cloudera 和基础的 Hadoop 有了解。我先来介绍一下这两个文档如何修改，再来对修改的原因和整体做一介绍。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;conf/accumulo-site.xml&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将 &lt;code&gt;instance.volumes&lt;/code&gt; 改为 &lt;code&gt;hdfs://master:8020/accumulo&lt;/code&gt;，master 为 hadoop namenode 节点的&lt;br/&gt;IP 或者 hostname，8020 为 cdh 环境下的 HDFS 端口；将 &lt;code&gt;instance.zookeeper.host&lt;/code&gt; 修改为 &lt;code&gt;zk1:2181,zk2:2181,zk3:2181&lt;/code&gt;，其中 zk1-3 为 zookeeper 的节点 IP 或 hostname，当然不一定是 3 个，根据自己的情况而定；将 &lt;code&gt;trace.token.property.password&lt;/code&gt; 修改为你想要设置的密码；将 &lt;code&gt;general.classpaths&lt;/code&gt; 修改如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ACCUMULO_HOME/lib/accumulo-server.jar,
$ACCUMULO_HOME/lib/accumulo-core.jar,
$ACCUMULO_HOME/lib/accumulo-start.jar,
$ACCUMULO_HOME/lib/accumulo-fate.jar,
$ACCUMULO_HOME/lib/accumulo-proxy.jar,
$ACCUMULO_HOME/lib/[^.].*.jar,
$ZOOKEEPER_HOME/zookeeper[^.].*.jar,
$HADOOP_CONF_DIR,
$HADOOP_PREFIX/share/hadoop/common/[^.].*.jar,
$HADOOP_PREFIX/jars/[^.].*.jar,
$HADOOP_PREFIX/share/hadoop/common/lib/(?!slf4j)[^.].*.jar,
$HADOOP_PREFIX/share/hadoop/hdfs/[^.].*.jar,
$HADOOP_PREFIX/share/hadoop/mapreduce/[^.].*.jar,
$HADOOP_PREFIX/share/hadoop/yarn/[^.].*.jar,
$HADOOP_PREFIX/share/hadoop/yarn/lib/jersey.*.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要是添加 &lt;code&gt;$HADOOP_PREFIX/jars/[^.].*.jar&lt;/code&gt; 项，这个文件中存放了与 hadoop 有关的所有 jar 包，注意匹配处必须写为 &lt;code&gt;[^.].*.jar&lt;/code&gt;，直接写通配符 &lt;code&gt;*.jar&lt;/code&gt; 不能正常工作，这涉及到正则表达式，具体可以查阅相关资料。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;conf/accumulo-env.sh&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设置 &lt;code&gt;HADOOP_PREFIX&lt;/code&gt; 为 &lt;code&gt;/opt/cloudera/parcels/CDH-5.11.2-1.cdh5.11.2.p0.4&lt;/code&gt;，最后一级目录根据安装版本不同会发生变化；设置 &lt;code&gt;JAVA_HOME&lt;/code&gt; 为 &lt;code&gt;/usr/jdk1.8.0_*&lt;/code&gt;，此处是自己安装的 jdk 目录，安装 jdk 查阅相关资料，JDK1.8应该是个不错的选择；设置 &lt;code&gt;ZOOKEEPER_HOME&lt;/code&gt; 为 &lt;code&gt;/opt/cloudera/parcels/CDH/lib/zookeeper&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;完成上述两个文件的修改，在接着官方文档执行即可，所以整个步骤其实非常简单。下面我来分析一下整个安装过程并通过安装过程简单分析一下 Accumulo 的大概工作原理。&lt;/p&gt;

&lt;p&gt;在下载并解压完压缩包之后会执行 &lt;code&gt;./bin/bootstrap_config.sh&lt;/code&gt;，其实这一步的目的就是为了生成和简单配置上面要修改的两个文件，整个安装过程的核心也在上面的两个文件，先来看一下 &lt;code&gt;conf/accumulo-env.sh&lt;/code&gt; 文件要修改的内容，其实就是 Hadoop 安装路径、JDK 路径和 Zookeeper 安装路径，这三个路径刚好说明了 Accumulo 的工作原理：基于 JDK 通过 Zookeeper 进行集群调度，并将自己的数据保存到 HDFS 中，就像普通的数据库数据保存在文件系统中，Accumulo 将数据保存到 HDFS 中，这样就实现了分布式数据库。由于我是采用 CDH 安装的 Hadoop 集群，所以 &lt;code&gt;HADOOP_PREFIX&lt;/code&gt; 和 &lt;code&gt;ZOOKEEPER_HOME&lt;/code&gt; 是固定的，Cloudera 通过 pacel 管理集群，所以其安装路径都是在 &lt;code&gt;/opt/cloudera/parcels&lt;/code&gt; 文件夹下。&lt;/p&gt;
&lt;p&gt;知道了上面这些也就明白了 &lt;code&gt;conf/accumulo-site.xml&lt;/code&gt; 的修改原因，&lt;code&gt;instance.volumes&lt;/code&gt; 指定了 HDFS 节点，使得 Accumulo 能够正常访问 HDFS；&lt;code&gt;instance.zookeeper.host&lt;/code&gt; 指定了 zookeeper 集群的路径，使得 zookeeper 能够管理 accumulo；&lt;code&gt;general.classpaths&lt;/code&gt; 指定了 Accumulo 工作的 jar 包。&lt;/p&gt;

&lt;p&gt;在我尝试手动安装 Accumulo 并成功之后，我才发现 Accumulo 并不复杂。一切事情都是这样，你想象中很复杂或者惧怕的事情其实只要你动手去实践、一点点去突破就会慢慢的解决，当然一切看似简单的事情也都会有各种各样的问题，只有亲自去尝试才是解决问题和发现问题的最好方式。&lt;/p&gt;
&lt;p&gt;纸上得来终觉浅，绝知此事要躬行！共勉&lt;/p&gt;
</description>
<pubDate>Thu, 22 Mar 2018 14:43:00 +0000</pubDate>
<dc:creator>shoufengwei</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shoufengwei/p/8627436.html</dc:identifier>
</item>
<item>
<title>评分卡系列（四）：泛化误差估计和模型调参 - JSong</title>
<link>http://www.cnblogs.com/gasongjian/p/8627404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gasongjian/p/8627404.html</guid>
<description>&lt;p&gt;作者：JSong，时间：2017.10.21&lt;/p&gt;
&lt;blockquote readability=&quot;4.3670886075949&quot;&gt;
&lt;p&gt;本文大量引用了 &lt;a href=&quot;http://www.cnblogs.com/jasonfreak&quot;&gt;jasonfreak&lt;/a&gt; 的系列文章，在此进行注明和感谢.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;广义的偏差（bias）描述的是预测值和真实值之间的差异，方差（variance）描述的是不同样本下模型效果的离散程度。在《Understanding the Bias-Variance Tradeoff》当中有一副图形象地向我们展示了偏差和方差的关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/802399/201803/802399-20180322222515322-1377858994.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一bias-variance-分解&quot;&gt;一、Bias-variance 分解&lt;/h2&gt;
&lt;p&gt;算法在不同训练集上学到的结果很可能不同，即便这些训练集来自于同一分布。对测试样本 x ,令 y_D 为 x 在数据集中的标记，y 为 x 的真实标记， f(x;D) 为训练集 D 上学的模型 f 在 x 上的预测输出。&lt;/p&gt;
&lt;p&gt;在回归任务中，学习算法的期望输出为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\bar{f}(x)=\mathbb{E}_{D}[f(x;D)]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用样本数相同的不同训练集产生的方差为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[var(x)=\mathbb{E}_{D}[(f(x;D)-\bar{f}(x))^2]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;噪声为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\varepsilon^2=\mathbb{E}_{D}[(y_{D}-y)^2]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们将期望输出与真实标记之间的差别称为偏差（bias）：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[bias^2(x)=(\bar{f}(x)-y)^2\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为便于讨论，假定噪声期望为零，即&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\mathbb{E}_D[y_D-y]=0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过简单的多项式展开合并，对算法的期望泛化误差进行分解：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align*} E(f;D)=&amp;amp;\mathbb{E}_{D}\left[(f(x;D)-y_D)^2\right]\\ =&amp;amp;\mathbb{E}_{D}\left[(f(x;D)-\bar{f}(x)+\bar{f}(x)-y_D)^2\right]\\ =&amp;amp;\mathbb{E}_{D}\left[(f(x;D)-\bar{f}(x))^2\right]+(\bar{f}(x)-y)^2+\mathbb{E}_{D}[(y_D-y)^2] \end{align*}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;于是有&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[E(f;D)=bias^2(x)+var(x)+\varepsilon^2\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也就是说，泛化误差可分解为偏差、方差与噪声之和。&lt;/p&gt;
&lt;p&gt;偏差和方差是有冲突的，下面是一个示意图。在训练不足（模型复杂度低）时，偏差主导了泛化误差率；随着训练程度的加深，方差逐渐主导了泛化误差率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/802399/201803/802399-20180322222539347-1101074623.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二集成学习框架下的泛化误差分解&quot;&gt;二、集成学习框架下的泛化误差分解&lt;/h2&gt;
&lt;p&gt;在 bagging 和 boosting 框架中，通过计算基模型的期望和方差，我们可以得到模型整体的期望和方差。为了简化模型，我们假设基模型的权重、方差及两两间的相关系数相等。由于bagging和boosting的基模型都是线性组成的，那么有：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[E(f)=E(\sum_{i=1}^{m}\gamma_{i}\cdot_{}f_{i})=\sum_{i=1}^{m}\gamma_{i}\cdot_{}E(f_i)=\gamma\cdot\sum_{i}^{m}E(f_i)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align} Var(f)=&amp;amp;Var(\sum_{i}^{m}\gamma_{i}\cdot_{}f_{i})=Cov(\sum_{i}^{m}\gamma_{i}\cdot_{}f_{i},\sum_{i}^{m}\gamma_{i}\cdot_{}f_{i})\\ =&amp;amp;\sum_{i}^{m}\gamma_{i}^2\cdot_{}Var(f_i)+\sum_{i}^{m}\sum_{j\neq_{}i}^{m}2\rho\gamma_{i}\gamma_{j}\sqrt{Var(f_i)}\sqrt{Var(f_j)}\\ =&amp;amp;m^2\gamma^2\sigma^2\rho+m\gamma^2\sigma^2(1-\rho) \end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;bagging-的偏差和方差&quot;&gt;2.1 bagging 的偏差和方差&lt;/h3&gt;
&lt;p&gt;对于bagging来说，每个基模型的权重等于 1/m 且期望近似相等（子训练集都是从原训练集中进行子抽样），故我们可以进一步化简得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[E(f)=\gamma\cdot\sum_{i}^{m}E(f_i)=\frac{1}{m}m\mu=\mu\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{align} Var(F)=&amp;amp;m^2\gamma^2\sigma^2\rho+m\gamma^2\sigma^2(1-\rho)\\ =&amp;amp;m^2\frac{1}{m^2}\sigma^2\rho+m\frac{1}{m^2}\sigma^2(1-\rho)\\ =&amp;amp;\sigma^2\rho+\frac{\sigma^2(1-\rho)}{m} \end{align}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;根据上式我们可以看到，整体模型的期望近似于基模型的期望，这也就意味着整体模型的偏差和基模型的偏差近似。同时，整体模型的方差小于等于基模型的方差（当相关性为1时取等号），随着基模型数（m）的增多，整体模型的方差减少，从而防止过拟合的能力增强，模型的准确度得到提高。但是，模型的准确度一定会无限逼近于1吗？并不一定，当基模型数增加到一定程度时，方差公式第二项的改变对整体方差的作用很小，防止过拟合的能力达到极限，这便是准确度的极限了。另外，在此我们还知道了为什么bagging中的基模型一定要为强模型，否则就会导致整体模型的偏差度低，即准确度低。&lt;/p&gt;
&lt;p&gt;　　Random Forest是典型的基于bagging框架的模型，其在bagging的基础上，进一步降低了模型的方差。Random Fores中基模型是树模型，在树的内部节点分裂过程中，不再是将所有特征，而是随机抽样一部分特征纳入分裂的候选项。这样一来，基模型之间的相关性降低，从而在方差公式中，第一项显著减少，第二项稍微增加，整体方差仍是减少。&lt;/p&gt;
&lt;h3 id=&quot;boosting-的偏差和方差&quot;&gt;2.2 boosting 的偏差和方差&lt;/h3&gt;
&lt;p&gt;对于boosting来说，基模型的训练集抽样是强相关的，那么模型的相关系数近似等于1，故我们也可以针对boosting化简公式为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[E(f)=\gamma\sum_{i}^{m}E(f_i)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[Var(F)=m^2\gamma^2\sigma^2\rho+m\gamma^2\sigma^2(1-\rho)=m^2\gamma^2\sigma^2\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过观察整体方差的表达式，我们容易发现，若基模型不是弱模型，其方差相对较大，这将导致整体模型的方差很大，即无法达到防止过拟合的效果。因此，boosting框架中的基模型必须为弱模型。&lt;/p&gt;
&lt;p&gt;因为基模型为弱模型，导致了每个基模型的准确度都不是很高（因为其在训练集上的准确度不高）。随着基模型数的增多，整体模型的期望值增加，更接近真实值，因此，整体模型的准确度提高。但是准确度一定会无限逼近于1吗？仍然并不一定，因为训练过程中准确度的提高的主要功臣是整体模型在训练集上的准确度提高，而随着训练的进行，整体模型的方差变大，导致防止过拟合的能力变弱，最终导致了准确度反而有所下降。&lt;/p&gt;
&lt;p&gt;基于boosting框架的 Gradient Tree Boosting 模型中基模型也为树模型，同 Random Forrest，我们也可以对特征进行随机抽样来使基模型间的相关性降低，从而达到减少方差的效果。&lt;/p&gt;
&lt;h3 id=&quot;总结一下bagging-boosting&quot;&gt;2.3 总结一下：bagging &amp;amp; boosting&lt;/h3&gt;
&lt;p&gt;调参的最终目的在于：模型在训练集上的准确度和防止过拟合能力的大和谐！&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用模型的偏差和方差来描述其在训练集上的准确度和防止过拟合的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于bagging来说，整体模型的偏差和基模型近似，随着训练的进行，整体模型的方差降低&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;对于boosting来说，整体模型的初始偏差较高，方差较低，随着训练的进行，整体模型的偏差降低（虽然也不幸地伴随着方差增高），当训练过度时，因方差增高，整体模型的准确度反而降低.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;整体模型的偏差和方差与基模型的偏差和方差息息相关&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三常见分类模型及其参数介绍&quot;&gt;三、常见分类模型及其参数介绍&lt;/h2&gt;
&lt;p&gt;本文介绍的都是 scikit-learn 中的模型。&lt;/p&gt;
&lt;h3 id=&quot;逻辑回归模型&quot;&gt;3.1 逻辑回归模型&lt;/h3&gt;
&lt;p&gt;在scikit-learn中，与逻辑回归有关的主要是这3个类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;logisticRegression&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LogisticRegressionCV&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;logistic_regression_path&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中LogisticRegression和LogisticRegressionCV的主要区别是LogisticRegressionCV使用了交叉验证来选择正则化系数C。而LogisticRegression需要自己每次指定一个正则化系数。另外logistic_regression_path类则比较特殊，它拟合数据后，不能直接来做预测，只能为拟合数据选择合适逻辑回归的系数和正则化系数，主要是用在模型选择的时候，一般情况用不到这个类，所以后面不再讲述logistic_regression_path类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LogisticRegression&lt;/code&gt; 的参数使用如下：&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;class sklearn.linear_model.LogisticRegression(penalty='l2', dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver='liblinear', max_iter=100, multi_class='ovr', verbose=0, warm_start=False, n_jobs=1)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体含义为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/802399/201803/802399-20180322222609395-990577823.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;集成学习模型&quot;&gt;3.2 集成学习模型&lt;/h3&gt;
&lt;p&gt;在scikit-learn中，与随机森林有关的有两个。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RandomForestClassifier(): A random forest classifier.&lt;/li&gt;
&lt;li&gt;RandomForestRegressor(): A random forest regressor.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里主要讲第一个，它的参数如下：&lt;/p&gt;
&lt;blockquote readability=&quot;24&quot;&gt;
&lt;p&gt;class sklearn.ensemble.RandomForestClassifier(n_estimators=10, criterion=’gini’, max_depth=None, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_features=’auto’, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, bootstrap=True, oob_score=False, n_jobs=1, random_state=None, verbose=0, warm_start=False, class_weight=None)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;与GBDT有关的也是两个。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GradientBoostingClassifier([loss, …])： Gradient Boosting for classification.&lt;/li&gt;
&lt;li&gt;GradientBoostingRegressor([loss, …])： Gradient Boosting for regression.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中分类模型的参数如下：&lt;/p&gt;
&lt;blockquote readability=&quot;25&quot;&gt;
&lt;p&gt;class sklearn.ensemble.GradientBoostingClassifier(loss=’deviance’, learning_rate=0.1, n_estimators=100, subsample=1.0, criterion=’friedman_mse’, min_samples_split=2, min_samples_leaf=1, min_weight_fraction_leaf=0.0, max_depth=3, min_impurity_decrease=0.0, min_impurity_split=None, init=None, random_state=None, max_features=None, verbose=0, max_leaf_nodes=None, warm_start=False, presort=’auto’)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这两个模型参数的详细介绍如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/802399/201803/802399-20180322222621656-1243278832.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上一节我们对bagging和boosting两种集成学习技术的泛化误差估计有了初步的了解。Random Forest的子模型都拥有较低的偏差，整体模型的训练过程旨在降低方差，故其需要较少的子模型（n_estimators默认值为10）且子模型不为弱模型（max_depth的默认值为None），同时，降低子模型间的相关度可以起到减少整体模型的方差的效果（max_features的默认值为auto）。&lt;/p&gt;
&lt;p&gt;另一方面，Gradient Tree Boosting的子模型都拥有较低的方差，整体模型的训练过程旨在降低偏差，故其需要较多的子模型（n_estimators默认值为100）且子模型为弱模型（max_depth的默认值为3），但是降低子模型间的相关度不能显著减少整体模型的方差（max_features的默认值为None）。&lt;/p&gt;
&lt;h2 id=&quot;四分类模型的调参方法&quot;&gt;四、分类模型的调参方法&lt;/h2&gt;
&lt;p&gt;调参是一个最优化问题。如果样本量不是非常大，计算资源也足够，那我们可以直接用网格搜索进行穷举。例如在随机森林算法中，可以用sklearn提供的GridSearchCV函数来调参。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;23&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;param_test1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;{&lt;span class=&quot;st&quot;&gt;'n_estimators'&lt;/span&gt;:&lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;71&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)，&lt;span class=&quot;st&quot;&gt;'max_features'&lt;/span&gt;:&lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;50&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)}  
gsearch1&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; GridSearchCV(estimator &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;RandomForestClassifier(min_samples_split&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;,  
                                 min_samples_leaf&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt;,max_depth&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;,random_state&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;),   
                       param_grid &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;param_test1,scoring&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'roc_auc'&lt;/span&gt;,cv&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;)  
gsearch1.fit(X,y)  
gsearch1.grid_scores_, gsearch1.best_params_, gsearch1.best_score_&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于小数据集，我们还能这么任性，但是参数组合爆炸，在大数据集上，如果用网格搜索，那真的要下一个猴年马月才能看到结果了。而且实际上网格搜索也不一定能得到全局最优解，而另一些研究者从解优化问题的角度尝试解决调参问题。&lt;/p&gt;
&lt;p&gt;坐标下降法是一类非梯度优化算法。算法在每次迭代中，在当前点处沿一个坐标方向进行一维搜索以求得一个函数的局部极小值。在整个过程中循环使用不同的坐标方向。对于不可拆分的函数而言，算法可能无法在较小的迭代步数中求得最优解。为了加速收敛，可以采用一个适当的坐标系，例如通过主成分分析获得一个坐标间尽可能不相互关联的新坐标系（如自适应坐标下降法）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/802399/201803/802399-20180322222723487-115069343.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们最容易想到一种特别朴实的类似于坐标下降法的方法，与坐标下降法不同的是，其不是循环使用各个参数进行调整，而是贪心地选取了对整体模型性能影响最大的参数。参数对整体模型性能的影响力是动态变化的，故每一轮坐标选取的过程中，这种方法在对每个坐标的下降方向进行一次直线搜索（line search）。首先，找到那些能够提升整体模型性能的参数，其次确保提升是单调或近似单调的。这意味着，我们筛选出来的参数是对整体模型性能有正影响的，且这种影响不是偶然性的，要知道，训练过程的随机性也会导致整体模型性能的细微区别，而这种区别是不具有单调性的。最后，在这些筛选出来的参数中，选取影响最大的参数进行调整即可。&lt;/p&gt;
&lt;p&gt;另外无法对整体模型性能进行量化，也就谈不上去比较参数影响整体模型性能的程度。我们还没有一个准确的方法来量化整体模型性能，只能通过交叉验证来近似计算整体模型性能。然而交叉验证也存在随机性，假设我们以验证集上的平均准确度作为整体模型的准确度，我们还得关心在各个验证集上准确度的变异系数，如果变异系数过大，则平均值作为整体模型的准确度也是不合适的。&lt;/p&gt;
&lt;h2 id=&quot;五评分卡实践&quot;&gt;五、评分卡实践&lt;/h2&gt;
&lt;p&gt;这次我们与时俱进，用 Kaggle上的 Lending Club 数据来建模。大家可以到 &lt;a href=&quot;http://www.cnblogs.com/gasongjian/p/www.kaggle.com/wendykan/lending-club-loan-data&quot;&gt;Kaggle/Lending Club/&lt;/a&gt; 上下载，在主页上还可以看到世界各地的人用各种姿势在玩这份数据。另外也可以关注我的公众号：JSong老师，后台回复 “数据集” 下载&lt;/p&gt;
&lt;p&gt;同样第一步先导入数据，其包含了 Lending Club 从2007-2015年共887379个用户的借款数据。这份数据一共有75个字段，这些字段又分为五种类型：ID类、开卡前的数据、描述信用卡的数据、注销后的数据、欠款状态等。由于我们要在开卡前预测用户时候会欠款，所以这里只能使用 var_submission 中的数据。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;80&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;data&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;pd.read_csv(&lt;span class=&quot;st&quot;&gt;'.&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;lending-club-loan-data&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;loan.csv'&lt;/span&gt;)
&lt;span class=&quot;co&quot;&gt;#data=data.sample(frac=0.1)&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# Identifiers, etc. (we won't use them as predictors)&lt;/span&gt;
var_identifiers &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'id'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'member_id'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'url'&lt;/span&gt;]
&lt;span class=&quot;co&quot;&gt;# Features available at a moment of credit application submission&lt;/span&gt;
var_submission &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'loan_amnt'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'term'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'int_rate'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'installment'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'grade'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'sub_grade'&lt;/span&gt;,
         &lt;span class=&quot;co&quot;&gt;'emp_title'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'emp_length'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'home_ownership'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'annual_inc'&lt;/span&gt;,
         &lt;span class=&quot;co&quot;&gt;'verification_status'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'desc'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'purpose'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'title'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'zip_code'&lt;/span&gt;,
         &lt;span class=&quot;co&quot;&gt;'addr_state'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'dti'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'delinq_2yrs'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'earliest_cr_line'&lt;/span&gt;,
         &lt;span class=&quot;co&quot;&gt;'inq_last_6mths'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'mths_since_last_delinq'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'mths_since_last_record'&lt;/span&gt;,
         &lt;span class=&quot;co&quot;&gt;'open_acc'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'pub_rec'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'total_acc'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'initial_list_status'&lt;/span&gt;,
         &lt;span class=&quot;co&quot;&gt;'collections_12_mths_ex_med'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'mths_since_last_major_derog'&lt;/span&gt;,
         &lt;span class=&quot;co&quot;&gt;'policy_code'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'application_type'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'annual_inc_joint'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'dti_joint'&lt;/span&gt;,
         &lt;span class=&quot;co&quot;&gt;'verification_status_joint'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'acc_now_delinq'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'tot_coll_amt'&lt;/span&gt;,
         &lt;span class=&quot;co&quot;&gt;'tot_cur_bal'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'open_acc_6m'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'open_il_6m'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'open_il_12m'&lt;/span&gt;,
         &lt;span class=&quot;co&quot;&gt;'open_il_24m'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'mths_since_rcnt_il'&lt;/span&gt;,  &lt;span class=&quot;st&quot;&gt;'total_bal_il'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'il_util'&lt;/span&gt;,
         &lt;span class=&quot;co&quot;&gt;'open_rv_12m'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'open_rv_24m'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'max_bal_bc'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'all_util'&lt;/span&gt;,
         &lt;span class=&quot;co&quot;&gt;'total_rev_hi_lim'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'inq_fi'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'total_cu_tl'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'inq_last_12m'&lt;/span&gt;]

&lt;span class=&quot;co&quot;&gt;# Features describing an open credit&lt;/span&gt;
var_open &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'funded_amnt'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'funded_amnt_inv'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'issue_d'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'pymnt_plan'&lt;/span&gt;,
         &lt;span class=&quot;co&quot;&gt;'revol_bal'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'revol_util'&lt;/span&gt;, &lt;span class=&quot;co&quot;&gt;# revol_bal maybe available during the application&lt;/span&gt;
         &lt;span class=&quot;co&quot;&gt;'out_prncp'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'out_prncp_inv'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'total_pymnt'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'total_pymnt_inv'&lt;/span&gt;,
         &lt;span class=&quot;co&quot;&gt;'total_rec_prncp'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'total_rec_int'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'total_rec_late_fee'&lt;/span&gt;,
         &lt;span class=&quot;co&quot;&gt;'last_pymnt_d'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'last_pymnt_amnt'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'next_pymnt_d'&lt;/span&gt;,
         &lt;span class=&quot;co&quot;&gt;'last_credit_pull_d'&lt;/span&gt;]

&lt;span class=&quot;co&quot;&gt;# Features available after closing a credit&lt;/span&gt;
var_close &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'recoveries'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'collection_recovery_fee'&lt;/span&gt;]

&lt;span class=&quot;co&quot;&gt;# Response variable&lt;/span&gt;
var_y &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'loan_status'&lt;/span&gt;]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本系列最后一篇文章的目的在于讲解调参的方法，所以这次不再详细介绍数据清洗和特征变换的过程。这次我们主要采用集成学习相关算法来建模，所以特征工程中就直接用哑变量，有兴趣的童鞋可以自己用woe编码试试。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;26&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# 借款状态处理&lt;/span&gt;
statuses &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data.loan_status.unique()
bad &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'Charged Off'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'Default'&lt;/span&gt;,
                   &lt;span class=&quot;co&quot;&gt;'Does not meet the credit policy. Status:Charged Off'&lt;/span&gt;,
                   &lt;span class=&quot;co&quot;&gt;'Late (31-120 days)'&lt;/span&gt;]
good &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'Fully Paid'&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;'Does not meet the credit policy. Status:Fully Paid'&lt;/span&gt;]
&lt;span class=&quot;co&quot;&gt;# current 的样本都不能用&lt;/span&gt;
current &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'Current'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'In Grace Period'&lt;/span&gt;, &lt;span class=&quot;st&quot;&gt;'Late (16-30 days)'&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;'Issued'&lt;/span&gt;]
&lt;span class=&quot;co&quot;&gt;# Selecting relevant features and observations&lt;/span&gt;
data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data[var_submission&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;var_y]
data &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data[data.loan_status.isin(bad&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;good)]
&lt;span class=&quot;co&quot;&gt;# Features per type of preprocessing required&lt;/span&gt;
data[&lt;span class=&quot;st&quot;&gt;'loan_status'&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;data[&lt;span class=&quot;st&quot;&gt;'loan_status'&lt;/span&gt;].&lt;span class=&quot;bu&quot;&gt;map&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; x: &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; x &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; bad &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)

&lt;span class=&quot;co&quot;&gt;# 去除缺失率大于60%的字段&lt;/span&gt;
data&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;data.dropna(thresh&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(data) &lt;span class=&quot;op&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;fl&quot;&gt;0.6&lt;/span&gt;,axis&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
nunique&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;data.&lt;span class=&quot;bu&quot;&gt;apply&lt;/span&gt;(pd.Series.nunique)
data&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;data.loc[:,nunique&lt;span class=&quot;op&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]

&lt;span class=&quot;co&quot;&gt;###### 特征变换&lt;/span&gt;
data[&lt;span class=&quot;st&quot;&gt;'term'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data[&lt;span class=&quot;st&quot;&gt;'term'&lt;/span&gt;].&lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;.split(&lt;span class=&quot;st&quot;&gt;' '&lt;/span&gt;).&lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;].astype(&lt;span class=&quot;bu&quot;&gt;float&lt;/span&gt;)
&lt;span class=&quot;co&quot;&gt;# extract numbers from emp_length and fill missing values with the median&lt;/span&gt;
data[&lt;span class=&quot;st&quot;&gt;'emp_length'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data[&lt;span class=&quot;st&quot;&gt;'emp_length'&lt;/span&gt;].&lt;span class=&quot;bu&quot;&gt;str&lt;/span&gt;.extract(&lt;span class=&quot;st&quot;&gt;'(\d+)'&lt;/span&gt;).astype(&lt;span class=&quot;bu&quot;&gt;float&lt;/span&gt;)
data[&lt;span class=&quot;st&quot;&gt;'emp_length'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data[&lt;span class=&quot;st&quot;&gt;'emp_length'&lt;/span&gt;].fillna(data.emp_length.median())

&lt;span class=&quot;co&quot;&gt;# 将日期转换成月份数，以最早的日期数为基准&lt;/span&gt;
tmp&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;pd.to_datetime(&lt;span class=&quot;st&quot;&gt;'01-'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;data[&lt;span class=&quot;st&quot;&gt;'earliest_cr_line'&lt;/span&gt;])
data[&lt;span class=&quot;st&quot;&gt;'earliest_cr_line'&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;(tmp&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;tmp.&lt;span class=&quot;bu&quot;&gt;min&lt;/span&gt;()).&lt;span class=&quot;bu&quot;&gt;map&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; x:&lt;span class=&quot;bu&quot;&gt;round&lt;/span&gt;(x.days&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;) &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; pd.notnull(x) &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; np.nan)
data[&lt;span class=&quot;st&quot;&gt;'earliest_cr_line'&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;data[&lt;span class=&quot;st&quot;&gt;'earliest_cr_line'&lt;/span&gt;].fillna(data[&lt;span class=&quot;st&quot;&gt;'earliest_cr_line'&lt;/span&gt;].median())

&lt;span class=&quot;co&quot;&gt;# drop 无意义ID和难以分析的文本变量&lt;/span&gt;
var_drop &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;st&quot;&gt;'emp_title'&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;'title'&lt;/span&gt;,&lt;span class=&quot;st&quot;&gt;'zip_code'&lt;/span&gt;]
data&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;data.drop(var_drop,axis&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
X&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;data.drop(&lt;span class=&quot;st&quot;&gt;'loan_status'&lt;/span&gt;,axis&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
y&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;data[&lt;span class=&quot;st&quot;&gt;'loan_status'&lt;/span&gt;]

categorical_var&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;list&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;set&lt;/span&gt;(X.columns[X.&lt;span class=&quot;bu&quot;&gt;apply&lt;/span&gt;(pd.Series.nunique)&lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;])&lt;span class=&quot;op&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;set&lt;/span&gt;(X.select_dtypes(include&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;[&lt;span class=&quot;st&quot;&gt;'O'&lt;/span&gt;]).columns))

continuous_var&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;list&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;set&lt;/span&gt;(X.columns)&lt;span class=&quot;op&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;bu&quot;&gt;set&lt;/span&gt;(categorical_var))

&lt;span class=&quot;co&quot;&gt;# 特征工程&lt;/span&gt;
tmp&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;pd.get_dummies(X[categorical_var].applymap(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; x:&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;%s&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;%&lt;/span&gt;x),drop_first&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;)
&lt;span class=&quot;co&quot;&gt;# 补缺&lt;/span&gt;
imputer&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;preprocessing.Imputer(strategy&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'median'&lt;/span&gt;)
X[continuous_var]&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;imputer.fit_transform(X[continuous_var])
X[continuous_var]&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;preprocessing.MinMaxScaler().fit_transform(X[continuous_var])
X&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;pd.concat([tmp,X[continuous_var]],axis&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;处理后一共还有 268530 个样本，212个变量。接下来我们开始建模和调参。首先看一下 bad 和 good 的占比：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;209711 (78.0959%)&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;58819 (21.9041%)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这是一个典型的样本不平衡问题，如果不做任何处理，建模得到的结果虽然auc和精确率都挺高，但召回率（坏瓜有多少被挑出）和F1分数都会相对偏低（f1只有0.11左右）。这里我们可以采用下采样和Smote算法，为了简单和充分利用到每个样本，我将直接用第二种方法。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;# Balanced&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; imblearn.over_sampling &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; SMOTE
index_split &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt;(&lt;span class=&quot;bu&quot;&gt;len&lt;/span&gt;(X)&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.6&lt;/span&gt;)
X_train, y_train &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; SMOTE().fit_sample(X[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:index_split], y[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:index_split])
X_test, y_test &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; X[index_split:], y[index_split:]&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时训练集有26万，测试集有10万。接下来我们用逻辑回归、随机森林和GBDT三种算法来建模，而且都用默认的参数。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;clfs&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;{&lt;span class=&quot;st&quot;&gt;'LogisticRegression'&lt;/span&gt;:LogisticRegressionCV(),
&lt;span class=&quot;co&quot;&gt;'RandomForest'&lt;/span&gt;:RandomForestClassifier(),
&lt;span class=&quot;co&quot;&gt;'GradientBoosting'&lt;/span&gt;:GradientBoostingClassifier()}
y_preds,y_probas&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;{},{}
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; clf &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; clfs:
    clfs[clf].fit(X_train, y_train)
    y_preds[clf] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;clfs[clf].predict(X_test)
    y_probas[clf] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; clfs[clf].predict_proba(X_test)[:,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]
models_report,conf_matrix&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;Classifier_Report(y_test,y_preds,y_probas)
&lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(models_report)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;模型结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/802399/201803/802399-20180322222757773-50933791.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/802399/201803/802399-20180322222808752-1173040174.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/802399/201803/802399-20180322222823268-1471937373.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/802399/201803/802399-20180322222836000-1872439804.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/802399/201803/802399-20180322222852264-837207813.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到三个模型中随机森林的效果最差。另外逻辑回归的f1分数最大，但它的精确率有点低，密度曲线也不是很分散。&lt;/p&gt;
&lt;p&gt;目前的样本量对于个人计算机而言，已经很大了，梦想用暴力网格搜索的话，还是算了。。。现在这两种算法中，GBDT的调参相对更复杂一些，所以我们以它为例。 GBDT算法的核心思路是每次迭代学习上一步迭代之后的模型残差，并且通过梯度下降的方法来求解参数。其过程影响类参数有“子模型数”（n_estimators）和“学习率”（learning_rate），这两个参数不能单独来讨论，需要一起优化。我们可以使用GridSearchCV找到关于这两个参数的最优解。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;param_test &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;{&lt;span class=&quot;st&quot;&gt;'n_estimators'&lt;/span&gt;:&lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;80&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;),&lt;span class=&quot;st&quot;&gt;'learning_rate'&lt;/span&gt;:[i&lt;span class=&quot;op&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;25&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)]}
gb&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;GradientBoostingClassifier(random_state&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
gsearch1&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; GridSearchCV(estimator &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; gb,param_grid &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;param_test,scoring&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'f1'&lt;/span&gt;,n_jobs&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,cv&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)  
gsearch1.fit(X_train, y_train)
gsearch1.grid_scores_, gsearch1.best_params_, gsearch1.best_score_&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将调参的结果用图像展示如下，颜色越深，代表预测准确率越高：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/802399/201803/802399-20180322222909430-1767246012.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;这里有一个很大的陷阱：“子模型数”和“学习率”带来的性能提升是不均衡的，在前期会比较高，在后期会比较低，如果一开始我们将这两个参数调成最优，这样很容易陷入一个“局部最优解”。在目标函数都不确定的情况下（如是否凸？），谈局部最优解就是耍流氓，本文中“局部最优解”指的是调整各参数都无明显性能提升的一种状态，所以打了引号。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这应该算是最优化理论中的 &lt;strong&gt;过犹不及经验&lt;/strong&gt; ，在学校时候老师曾告诉我，每个维度优化一点点，这样反而更容易达到最优。所以我在这里选择 &lt;code&gt;n_estimators = 140, learning_rate = 0.17&lt;/code&gt;,不大不小。&lt;/p&gt;
&lt;p&gt;另外细心的话会发现我在 &lt;code&gt;GridSearchCV&lt;/code&gt; 中用的是 f1 分数，这是因为在样本不平衡问题中，p-r 曲线比 roc 曲线更好用。roc曲线利用的是正类和负类的概率分布函数，对样本不平衡不敏感。&lt;/p&gt;
&lt;p&gt;接下来我们依次优化剩下的参数，代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;26&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;param&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;{
&lt;span class=&quot;st&quot;&gt;'min_samples_leaf'&lt;/span&gt;:&lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;),
&lt;span class=&quot;co&quot;&gt;'max_depth'&lt;/span&gt;:&lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;),
&lt;span class=&quot;co&quot;&gt;'subsample'&lt;/span&gt;:[&lt;span class=&quot;fl&quot;&gt;0.6&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.04&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;range&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;)],
&lt;span class=&quot;co&quot;&gt;'max_features'&lt;/span&gt;:np.floor(np.sqrt(np.linspace(&lt;span class=&quot;fl&quot;&gt;0.04&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;*&lt;/span&gt;X_train.shape[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]).astype(np.&lt;span class=&quot;bu&quot;&gt;int&lt;/span&gt;)
}

gb&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;GradientBoostingClassifier(n_estimators&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;140&lt;/span&gt;,learning_rate&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.17&lt;/span&gt;,random_state&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;)
trained_param&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;{}
param_test&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;{}
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; param:
    param_test.update({k:param[k]})
    param_test.update(trained_param)
    gsearch1&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; GridSearchCV(estimator &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; gb,param_grid &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;param_test,scoring&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'f1'&lt;/span&gt;,n_jobs&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;,cv&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)
    gsearch1.fit(X_train, y_train)
    best_params&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;gsearch1.best_params_
    trained_param&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;{k:[best_params[k]] &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; k &lt;span class=&quot;op&quot;&gt;in&lt;/span&gt; best_params}
    &lt;span class=&quot;bu&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'优化后的参数：'&lt;/span&gt;, gsearch1.best_params_)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得到的参数为：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;4&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;180&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;5&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;0.76&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;事实上调参并没有结束，我们还需要杀几个回马枪，但这里我就不继续了（训练太慢了。。）。将优化后的模型用于测试集额预测，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/802399/201803/802399-20180322223013124-2019533199.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/802399/201803/802399-20180322223025442-1115403014.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/802399/201803/802399-20180322223038858-1228314902.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/802399/201803/802399-20180322223057446-347169416.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到模型精确率从0.703972 提高到了0.741109，但f1分数下降了（暂时没想明白为什么） 。理论上肯定还有提升空间，这个样本量对于我的 surface 而言压力还是挺大的，每一个参数的调休都花了我一两个个多小时去训练模型，甚至在子模型数和学习率的调优过程中不得不对训练集进行采样。&lt;/p&gt;
&lt;p&gt;整个调参过程其实能看得出并不严谨，但不管怎样，我还是放出来供大家一起参考和探讨（一些细节的讨论可以看 &lt;code&gt;jasonfreak&lt;/code&gt; 的博客）。一个好的结果取决于对业务、模型理论等的理解程度，取决于好的数据、好的特征工程以及好的调参技巧。相关的代码都可以关注我的公众号，后台回复：“评分卡” 下载。&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;[1]. &lt;a href=&quot;http://www.cnblogs.com/gasongjian/p/scott.fortmann-roe.com/docs/BiasVariance.html&quot;&gt;Understanding the Bias-Variance Tradeoff&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2]. &lt;a href=&quot;http://www.cnblogs.com/jasonfreak/p/5657196.html&quot;&gt;使用sklearn进行集成学习——理论&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] [sklearn:model_evaluation](&lt;a href=&quot;http://scikit-learn.org/stable/modules/model_evaluation.html&quot; class=&quot;uri&quot;&gt;http://scikit-learn.org/stable/modules/model_evaluation.html&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;[4]. &lt;a href=&quot;http://blog.csdn.net/u012969412/article/details/72973055&quot;&gt;GridSearch使用方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5] [使用sklearn进行集成学习——理论](www.cnblogs.com/jasonfreak/p/5657196.html)&lt;/p&gt;
&lt;p&gt;[6]. &lt;a href=&quot;http://www.cnblogs.com/gasongjian/p/www.cnblogs.com/jasonfreak/p/5720137.html&quot;&gt;使用sklearn进行集成学习——实践&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;评分卡系列文章&quot;&gt;&lt;code&gt;评分卡系列文章&lt;/code&gt;：&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://www.cnblogs.com/gasongjian/p/8284010.html&quot;&gt;评分卡系列（一）：讲讲评分系统的构建&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;http://www.cnblogs.com/gasongjian/p/8159501.html&quot;&gt;评分卡系列（二）：特征工程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;http://www.cnblogs.com/gasongjian/p/8284229.html&quot;&gt;评分卡系列（三）：分类学习器的评估&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;http://www.cnblogs.com/gasongjian/p/8627404.html&quot;&gt;评分卡系列（四）：分类学习器的评估&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号，评分卡系列相关代码和数据都可在公众号中下载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/802399/201803/802399-20180322223539539-56428075.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Mar 2018 14:37:00 +0000</pubDate>
<dc:creator>JSong</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gasongjian/p/8627404.html</dc:identifier>
</item>
<item>
<title>Unity3d底层数据传递分析 - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/8627351.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/8627351.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;WeTest 导读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这篇文章主要分析了在Mono框架下，非托管堆、运行时、托管堆如何关联，以及通过哪些方式调用。内存方面，介绍了什么是封送，以及类和结构体的关系和区别。&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、托管交互（Interop）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Mono的&lt;span&gt;官方文档（&lt;a href=&quot;http://www.mono-project.com/docs/advanced/embedding/&quot;&gt;&lt;span&gt;http://www.mono-project.com/docs/advanced/embedding/&lt;/span&gt;&lt;/a&gt;）中有关于嵌入原理的描述。我们知道Unity3d底层是C++完成的，而C#代码会被编译成CIL(Common Intermediate Language)，连接两部分的技术就是MonoRuntime。通常C++部分被称为非托管代码（Unmanaged code)，即下图左侧，CIL/.NET部分被称为托管代码（manage code），即下图右侧。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322221157956-793724708.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、封送&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在C#中的string，通过内部调用传给C++时，会使用MonoString* ，它是指向托管堆对象的字符串类型指针，这个转换就是封送（Marshalling）。&lt;/p&gt;



&lt;p&gt;具体说来，封送是将对象的内存表示，变换为适合存储或发送的数据格式的过程。&lt;/p&gt;



&lt;p&gt;对于简单的数据类型，例如整数和浮点数等基础类型，封送是隐式的按位拷贝(blitting)。另一种不必封送的情况是指针传递，例如通过引用传递结构体到非托管代码，只会拷贝结构的指针。当然，也可以通过MarshalAs来自定义封送策略。&lt;/p&gt;



&lt;p&gt;需要谨记的是，这两部分内存则完全独立。托管内存分配在GC堆上，非托管内存则完全由C++层的业务代码自己控制。因此堆上的内容被C++访问时，很有可能因为堆的机制被GC掉了。为了防止出现这种情况，可以使用C#的fixed关键字来单边锁定变量。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;在P/Invoke模式中没有使用fixed，而采用另一种常见的托管到非托管的封送方式：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1. Runtime分配一块非托管内存。&lt;/p&gt;

&lt;p&gt;2. 托管类数据拷贝到刚申请的非托管内存中。&lt;/p&gt;

&lt;p&gt;3. 调用非托管方法时，使用上面的非托管内存数据，而不是原始托管内存数据。这样做是为了，当GC发生时，非托管内存是可用的。&lt;/p&gt;

&lt;p&gt;4. 将非托管内存拷回托管内存。&lt;/p&gt;



&lt;p&gt;因为不能确定托管堆中的内存会何时失效，在非托管代码中，我们不应该缓存任何托管代码传进来的数据。&lt;/p&gt;



&lt;p&gt;另一种情况是返回值，类在非托管代码中，不可以作为值返回，只可以返回指针。因为堆内容无法互通，当返回到托管代码时，&lt;strong&gt;会经历以下步骤：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1. 托管代码调用非托管代码，返回了指向在非托管内存中的结构体的指针。&lt;/p&gt;

&lt;p&gt;2. 在托管代码中找到对应的托管类并实例化，将非托管内容封送到托管类中。&lt;/p&gt;

&lt;p&gt;3. 非托管代码中的内存被Marshal.FreeCoTaskMem()函数释放。&lt;/p&gt;



&lt;p&gt;想要避免这种内存分配，可以返回一个IntPtr，并且用Marshal类方法操作指针。关于类与结构体，在后面有更详细的论述。&lt;/p&gt;





&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、跨域调用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;托管代码能通过以下两种方式调用C++，即P/Invoke与内部调用（Embedding）。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;P/Invoke&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用P/Invoke调用方式，需要将C++函数声明为public。例如：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322221331995-1332860364.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;然后在C#层添加下面的声明即可：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322221346959-407529190.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;通过__Internal关键字可以令Mono在当前执行的非托管代码中查找函数，通过自扩展的Marshalling，可以适配大量的数据类型，是最简单的Interop方式。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;内部调用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;内部调用是在C++中注册调用，并直接访问托管对象，控制Marshall。例如，我们要返回字符串，就先要在C++中显示注册接口。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322221421046-2142877082.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;然后在C#中声明下面的函数：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322221435024-1996505973.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;最后实现在C++中实现这个函数：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322221450136-1519981959.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;通过MonoString和mono_string_new，即完成了字符串的Marshalling过程。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、内存分配&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;类与结构体&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于托管代码与非托管代码，类与结构体有不一样的传递方法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、类的传递&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;类是在托管堆上分配的，因此不能以值类型传给非托管代码，而只能传引用。以代码举例来说：&lt;/p&gt;

&lt;p&gt;对于下面的非托管代码：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322221523893-1272120804.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;一个可用的类包装(class wrapper)，可以是：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322221546621-1102110466.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在托管代码中，我们需要指定类的数据格式，默认是LayoutKind.Auto。这种分配方式下，运行时会自动选择合适的内存布局来创建非托管内存，因此内存结构不能被外部所知。我们可以使用LayoutKind.Sequential或LayoutKind.Explicit来指定内存分配策略。例如托管代码的定义还可以这样写：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322221606822-509261338.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;另外，类方法有自己的封送方式。正如前面提到的，很多数据是借助Marshaling进行访问。如果需要制定拷贝规则，要指定关键字[In],[Out],[In,Out]，传递方向如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322221643990-1744228022.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;当不指定这些属性时，就会根据数据类型（Value或Reference）来决定拷贝方式。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322221705814-832110739.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;例如，引用类型(类，数组，字符串，接口)作为值传递时，出于性能考虑会被标注为[In]。这也是默认标记，即不做从非托管拷贝回托管的操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、&lt;span&gt;结构体的传递&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结构体与类有两点不同：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 结构体分配在运行时的栈上（Runtime Stack)。&lt;/p&gt;
&lt;p&gt;2. 默认使用Sequential，非托管代码使用时不需要额外设置属性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在把结构体传递给非托管代码时，有些情况下不会产生内存拷贝：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 作为值传递时，结构分配在栈上，并且是可比特化类型（blittable types）&lt;/p&gt;
&lt;p&gt;2. 作为引用传递&lt;/p&gt;

&lt;p&gt;在上述情况下，不需要指定[Out]作为关键字。反过来说，如果结构体中包含不可比特化的类型，例如:System.Boolean，System.String，或者array，就需要自己完成Marshalling了。&lt;/p&gt;

&lt;p&gt;依照上面的非托管代码定义，结构体包装可以是：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322221722034-634361761.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;结构体在非托管代码中，可以作为值返回，但不可以返回ref或out。所以要想返回指向结构的指针，就必须使用IntPtr，或在外部定义unsafe。如果使用IntPtr做返回值，可以用Marshal.PtrToStructure系列函数，将指针转换为托管结构体。&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;成员变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;对于类与结构体的成员变量，乖巧的做法是：不要将包含引用类型（比如说类）的类或结构体传给非托管代码。因为非托管代码不能安全的操作非托管引用，托管代码也不一定会深封送数据。因此，打包类中最好不包含数组对象，尤其是string。当然，如果无法绕开，就需要自定义封送。&lt;/p&gt;



&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322221815058-1887786809.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;或者：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322221841479-1916163832.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;需要注意的是，如此使用必须保证托管代码中有内存分配，例如：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322221917404-1545395801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;





&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、GC安全&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;由于Marshalling是通过数据拷贝实现的，仔细看来其实不太靠谱。如上面所说，通常会用IntPtr和unsafe特性来处理封送拷贝问题。但指针来说，需要注意避免在函数运行时被垃圾回收掉。例如下面的代码：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322222029095-1170540357.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;执行完c.m()后，GC就会回收C的实例。很有可能非托管代码中的C.OperatOnHandle依然在使用_handle，因为已经跨界了，托管代码是不可能知道这件事的。解决办法是在这种情况下使用HandleRef来替代IntPtr。它可以保证直到非托管代码调用结束之后才GC托管对象。在.NET2.0中，我们也可以&lt;span&gt;&lt;span&gt;查阅文档（&lt;a href=&quot;http://www.mono-project.com/docs/advanced/safehandles/&quot;&gt;http://www.mono-project.com/docs/advanced/safehandles/&lt;/a&gt;）使用SafeFileHandle或者SafeWaitHandle。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;既然我们要持有，那就要肩负起从托管代码释放非托管代码的责任。简单的做法是，确保所有资源的包装类中都有释放函数，并在使用完成后调用。如果不希望等待统一的GC，可以使用&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322222045861-82707228.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;来防止对象进入析构队列，直接回收资源。&lt;/p&gt;

&lt;p&gt;如果觉得手动调用析构不放心，可以用using块来包围，以确保在块结束时自动释放，代码大致如下：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180322222111939-190543964.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;最后提醒一下，由于继承会提升GC权重(promote GC generation)，包装类要尽量避免使用虚函数或作为非封存类（non-sealed calss)。如果释放的成员变量是包含其他对象的ArrayList，那么这个List、容器中的子对象、子对象中递归引用的对象，都会被提升GC权重。我们都知道，GC权重越大，被回收的速率越慢。所以优化的策略是：每个析构类都是叶子结点，主干是则是由这些互不引用的叶子组成的树。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;篇文章主要分析了在Mono框架下，非托管堆、运行时、托管堆如何关联，以及通过哪些方式调用。内存方面，介绍了什么是封送，以及类和结构体的关系和区别。本来准备结合Unity3D做些分析，但文章内容多成这样，恐怕已然没什么人看，拆分一下吧，但愿不要太监了。&lt;/p&gt;


&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;UPA—— &lt;/span&gt;&lt;/strong&gt;一款针对Unity游戏/产品的深度性能分析工具，由腾讯WeTest和unity官方共同研发打造，可以帮助游戏开发者快速定位性能问题。旨在为游戏开发者提供更完善的手游性能解决方案，同时与开发环节形成闭环，保障游戏品质。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;点击&lt;/span&gt;&lt;/strong&gt;&lt;a href=&quot;http://wetest.qq.com/cube?from=content_cnblogs&quot;&gt;&lt;span&gt;http://wetest.qq.com/cube/&lt;/span&gt;&lt;/a&gt;&lt;strong&gt; 即可使用。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对UPA感兴趣的开发者，欢迎加入QQ群：633065352&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果对使用当中有任何疑问，欢迎联系腾讯WeTest企业QQ：800024531&lt;/span&gt;&lt;/p&gt;





</description>
<pubDate>Thu, 22 Mar 2018 14:25:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/8627351.html</dc:identifier>
</item>
<item>
<title>Linux源码-等待队列注释 - stonehat</title>
<link>http://www.cnblogs.com/stonehat/p/8627302.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stonehat/p/8627302.html</guid>
<description>&lt;p&gt;Linux中了等待队列的毒，代码中充斥着等待队列。不信你翻翻代码。&lt;/p&gt;
&lt;p&gt;等待队列的唤醒我们这里叫激活。免得和线程唤醒混淆。&lt;/p&gt;
&lt;p&gt;转载注明出处哦：&lt;a href=&quot;http://www.cnblogs.com/stonehat/p/8627302.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/stonehat/p/8627302.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;数据结构&quot;&gt;数据结构&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;头结点wait_queue_head_t的结构&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __wait_queue_head {
    
    &lt;span class=&quot;co&quot;&gt;// 自旋锁，用来做同步&lt;/span&gt;
    spinlock_t lock;
    
    &lt;span class=&quot;co&quot;&gt;// 链表，&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; list_head task_list;
};

&lt;span class=&quot;co&quot;&gt;// 熟悉的wait_queue_head_t实际上是struct __wait_queue_head&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __wait_queue_head wait_queue_head_t;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;普通节点wait_queue_t的结构&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;
   &lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __wait_queue wait_queue_t;

   &lt;span class=&quot;co&quot;&gt;//wait_queue_func_t的定义&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; (*wait_queue_func_t)(wait_queue_t *wait, &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; mode, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sync, &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *key);

   &lt;span class=&quot;co&quot;&gt;//__wait_queue的定义&lt;/span&gt;
   &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __wait_queue {
       &lt;span class=&quot;co&quot;&gt;// 激活后是否继续激活下一个entry。候选值为WQ_FLAG_EXCLUSIVE。一般设置为0。&lt;/span&gt;
       &lt;span class=&quot;co&quot;&gt;// 当等待队列所有entry的flags==0时，等待队列所有entry都会被激活。所以就会有惊群现象。&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; flags;
       &lt;span class=&quot;co&quot;&gt;// 排他性标志，调用wake_up时，可以传入参数，控制激活多少个排他性的entry就停止。&lt;/span&gt;
   &lt;span class=&quot;ot&quot;&gt;#define WQ_FLAG_EXCLUSIVE    0x01&lt;/span&gt;
       
       &lt;span class=&quot;co&quot;&gt;//线程结构&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; task_struct * task;
       
       &lt;span class=&quot;co&quot;&gt;// 函数指针。被激活时调用。&lt;/span&gt;
    wait_queue_func_t func;
       
       &lt;span class=&quot;co&quot;&gt;// listItem。内核链表如何做通用化的。就是靠特殊的宏操作。&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; list_head task_list;
   };&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;h2 id=&quot;函数&quot;&gt;函数&lt;/h2&gt;
&lt;h2 id=&quot;一初始化&quot;&gt;一、初始化&lt;/h2&gt;
&lt;h3 id=&quot;头节点初始化&quot;&gt;1. 头节点初始化&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#define INIT_LIST_HEAD(ptr) do { \&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    (ptr)-&amp;gt;next = (ptr); (ptr)-&amp;gt;prev = (ptr); \&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;} while (0)&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; init_waitqueue_head(wait_queue_head_t *q)
{
    &lt;span class=&quot;co&quot;&gt;// 初始化自旋锁&lt;/span&gt;
    q-&amp;gt;lock = SPIN_LOCK_UNLOCKED;
    &lt;span class=&quot;co&quot;&gt;// 初始化链表&lt;/span&gt;
    INIT_LIST_HEAD(&amp;amp;q-&amp;gt;task_list);
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;entry节点初始化&quot;&gt;2. entry节点初始化&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 初始化一个等待队列entry&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 这个entry在激活的时候直接会唤醒task_struct线程&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; init_waitqueue_entry(wait_queue_t *q, &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; task_struct *p)
   {
    &lt;span class=&quot;co&quot;&gt;//表示这个不是排他性的entry&lt;/span&gt;
    q-&amp;gt;flags = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    
    q-&amp;gt;task = p;
    
    &lt;span class=&quot;co&quot;&gt;// 默认给一个唤醒q-&amp;gt;task的函数指针。&lt;/span&gt;
    q-&amp;gt;func = default_wake_function;
   }

&lt;span class=&quot;co&quot;&gt;// 初始化一个等待队列entry&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;// 这个entry在激活的时候仅仅调用func.&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; init_waitqueue_func_entry(wait_queue_t *q,
                    wait_queue_func_t func)
   {
    q-&amp;gt;flags = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    q-&amp;gt;task = NULL;
    q-&amp;gt;func = func;
   }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;二添加&quot;&gt;二、添加&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; FASTCALL(add_wait_queue(wait_queue_head_t *q, wait_queue_t * wait));
&lt;span class=&quot;kw&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; FASTCALL(add_wait_queue_exclusive(wait_queue_head_t *q, wait_queue_t * wait));&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码实现&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; fastcall add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)
{
    &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; flags;

    wait-&amp;gt;flags &amp;amp;= ~WQ_FLAG_EXCLUSIVE;
    spin_lock_irqsave(&amp;amp;q-&amp;gt;lock, flags);
    __add_wait_queue(q, wait);
    spin_unlock_irqrestore(&amp;amp;q-&amp;gt;lock, flags);
}
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; __add_wait_queue(wait_queue_head_t *head, wait_queue_t *new)
{
    list_add(&amp;amp;new-&amp;gt;task_list, &amp;amp;head-&amp;gt;task_list);
}
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; list_add(&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; list_head *new, &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; list_head *head)
{
    __list_add(new, head, head-&amp;gt;next);
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简化代码看&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; fastcall add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)
{
    &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; flags;

    wait-&amp;gt;flags &amp;amp;= ~WQ_FLAG_EXCLUSIVE;
    &lt;span class=&quot;co&quot;&gt;//加锁保护，保存中断&lt;/span&gt;
    spin_lock_irqsave(&amp;amp;q-&amp;gt;lock, flags);
    
    q-&amp;gt;task_list-&amp;gt;pre=wait-&amp;gt;task_list;
    wait-&amp;gt;task_list-&amp;gt;next=q-&amp;gt;task_list;
    wait-&amp;gt;task_list-&amp;gt;pre=q-&amp;gt;task_list-&amp;gt;next;
    q-&amp;gt;task_list-&amp;gt;next = wait-&amp;gt;task_list;
    
    __add_wait_queue(q, wait);
    &lt;span class=&quot;co&quot;&gt;//解锁。&lt;/span&gt;
    spin_unlock_irqrestore(&amp;amp;q-&amp;gt;lock, flags);
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;三删除&quot;&gt;三、删除&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; FASTCALL(remove_wait_queue(wait_queue_head_t *q, wait_queue_t * wait));&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;//忽略&lt;/p&gt;
&lt;h2 id=&quot;四队列激活&quot;&gt;四、队列激活&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#define wake_up(x)          __wake_up(x, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, 1, NULL)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define wake_up_nr(x, nr)       __wake_up(x, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, nr, NULL)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define wake_up_all(x)          __wake_up(x, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE, 0, NULL)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define wake_up_interruptible(x)    __wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define wake_up_interruptible_nr(x, nr) __wake_up(x, TASK_INTERRUPTIBLE, nr, NULL)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define wake_up_interruptible_all(x)    __wake_up(x, TASK_INTERRUPTIBLE, 0, NULL)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define wake_up_locked(x)       __wake_up_locked((x), TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE)&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define wake_up_interruptible_sync(x)   __wake_up_sync((x),TASK_INTERRUPTIBLE, 1)&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 激活等待队列.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;@q:&lt;span class=&quot;co&quot;&gt; the waitqueue&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;@mode:&lt;span class=&quot;co&quot;&gt; which threads&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * &lt;/span&gt;@nr_exclusive:&lt;span class=&quot;co&quot;&gt; 最多激活多少个WQ_FLAG_EXCLUSIVE属性的entry。0表示都不限制。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; fastcall __wake_up(wait_queue_head_t *q, &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; mode,
                &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; nr_exclusive, &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *key)
{
    &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; flags;

    spin_lock_irqsave(&amp;amp;q-&amp;gt;lock, flags);
    __wake_up_common(q, mode, nr_exclusive, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, key);
    spin_unlock_irqrestore(&amp;amp;q-&amp;gt;lock, flags);
}


&lt;span class=&quot;co&quot;&gt;/*&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * 激活核心代码。遍历所有task_list，取出wait_queue_t结构（宏操作取出），执行里面的func。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * nr_exclusive表示要执行多少个WQ_FLAG_EXCLUSIVE属性的entry。&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; __wake_up_common(wait_queue_head_t *q, &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; mode,
                 &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; nr_exclusive, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sync, &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; *key)
{
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; list_head *tmp, *next;

    list_for_each_safe(tmp, next, &amp;amp;q-&amp;gt;task_list) {
        wait_queue_t *curr;
        &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; flags;
        curr = list_entry(tmp, wait_queue_t, task_list);
        flags = curr-&amp;gt;flags;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (curr-&amp;gt;func(curr, mode, sync, key) &amp;amp;&amp;amp;
            (flags &amp;amp; WQ_FLAG_EXCLUSIVE) &amp;amp;&amp;amp;
            !--nr_exclusive)
            &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;巧妙的宏&quot;&gt;巧妙的宏&lt;/h2&gt;
&lt;p&gt;在等待队列中，队列其实是由list_head构成的，而在遍历激活entry的时候，可以取出对应的wait_queue_t结构体。如何做到的？&lt;/p&gt;
&lt;p&gt;看下wait_queue_t结构。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; __wait_queue {
   
    &lt;span class=&quot;dt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; flags;
&lt;span class=&quot;ot&quot;&gt;#define WQ_FLAG_EXCLUSIVE   0x01&lt;/span&gt;
    
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; task_struct * task;
    
    wait_queue_func_t func;
    
    &lt;span class=&quot;co&quot;&gt;// list_head在结构体内部。&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; list_head task_list;
};&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们一般是从外部去取内部成员，而内核链表是通过内部成员去取外部结构体指针。有什么好处？这样可以做通用的链表结构，而不用担心内部单元类型。&lt;/p&gt;
&lt;p&gt;那如何从内部成员获得外部结构体指针呢？以wait_queue_t 的变量a为例，内部task_list地址记为b。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;b- &amp;amp;( ( (wait_queue_t *) 0 )-&amp;gt;task_list)&lt;/code&gt;可以获得wait_queue_t a的地址。&lt;/p&gt;
</description>
<pubDate>Thu, 22 Mar 2018 14:18:00 +0000</pubDate>
<dc:creator>stonehat</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stonehat/p/8627302.html</dc:identifier>
</item>
</channel>
</rss>