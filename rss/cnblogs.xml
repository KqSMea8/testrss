<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用Nagios打造专业的业务状态监控 - 运维咖啡吧</title>
<link>http://www.cnblogs.com/37Y37/p/9672418.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/37Y37/p/9672418.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;想必各个公司都有部署zabbix之类的监控系统来监控服务器的资源使用情况、各服务的运行状态，是否这种监控就足够了呢？有没有遇到监控系统一切正常确发现项目无法正常对外提供服务的情况呢？本篇文章聊聊我们如何简单的使用Nagios监控业务的状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;文中的业务指用户访问的网站页面，对外提供的API接口，移动端的APP等产品&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通常我们会在项目所在的机房部署一套监控系统来监控我们服务器和MySQL之类的公共服务，制定报警策略，在出现异常情况的时候邮件或短信提醒我们及时处理。&lt;/p&gt;
&lt;p&gt;此类监控主要的关注点有两个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;资源的占用情况，例如负载高低、内存大小、磁盘空间等&lt;/li&gt;
&lt;li&gt;服务的状态监控，例如Nginx状态、Mysql主从状态等&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;同时也会存在以下两个主要问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;缺少业务状态的监控，不能很直观的知道业务当前的状态，可能服务器、服务都正常但业务确挂了&lt;/li&gt;
&lt;li&gt;监控服务器和业务服务器处于同一机房环境内，监控网络故障、入口网络拥堵等情况都可能会导致收不到监控系统的报警，且只能监控机房内的情况，用户到机房入口的情况无法监控&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么如何解决这两个问题呢？&lt;/p&gt;
&lt;p&gt;业务状态监控，就是要最直观的的反映业务当前是正常还是故障，该怎么监控呢？以web项目为例，首先就是要确定具体URL的返回状态，是200正常还是404未找到等，其次要考虑页面里边的内容是不是正常，我们知道最终反馈给用户内容的是由一些静态资源和后端接口数据共同组成的HTML页面，想知道内容究竟对不对这个比较困难，退而求其次我们默认所有静态资源和后端接口都返回正常状态则表示正常，这个监控就比较容易实现了。&lt;/p&gt;
&lt;p&gt;静态资源可以直接由nginx服务器处理，nginx的并发能力很强，一般不会成为性能的瓶颈，针对静态资源的监控我们可以结合ELK一起来看。后端接口的处理性能就要差很多了，对业务状态的监控也主要是对后端接口状态的监控，那我们是否需要监控所有的接口呢？这个实施起来比较麻烦，我觉得没太大必要，只需要监控几个有代表性的接口就可以了，例如&lt;strong&gt;我们所有的项目中都让开发单独加了一个health check的接口，这个接口的作用是连接项目所有用到的服务进行操作，如接口连接mysql进行数据查询以确定mysql能给正常提供服务，连接redis进行get、set操作以确定redis服务正常，对于这个接口的监控就能覆盖到整个链路的服务情况&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于监控服务器和业务服务器在同一个机房内所导致的问题（上边讲到的第二点问题），我们可以通过在不同的网络环境内部署独立的状态监控来解决，例如办公区部署Nagios，不同网络监控也更接近用户的网络情况，这套状态监控就区别于机房部署的资源占用监控了，主要用来监控业务的状态，也就是我们上边提到的URL和接口状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/19/165eef6d4127a08a?w=1444&amp;amp;h=439&amp;amp;f=png&amp;amp;s=36209&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们能不能直接将监控部署在机房外的环境来节省一套监控呢？例如公司或者其他的机房部署监控。这样不是个好方案，跨网络的监控性能太差了，首先网络之间的延迟都比同机房内要大的多，其次大量监控项频繁的数据传输对带宽也是不小的压力&lt;/p&gt;

&lt;p&gt;我们业务状态监控采用了Nagios，Nagios部署简单配置灵活，这种场景下非常适合。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;系统环境：Debian8&lt;/li&gt;
&lt;li&gt;nginx + nagios架构&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;部署nagios&quot;&gt;部署Nagios&lt;/h2&gt;
&lt;p&gt;1.安装基础环境&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# apt-get update
# apt-get install -y build-essential libgd2-xpm-dev autoconf gcc libc6 make wget
# apt-get install -y nginx php5-fpm spawn-fcgi fcgiwrap&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.下载并解压nagios&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# wget https://assets.nagios.com/downloads/nagioscore/releases/nagios-4.0.8.tar.gz
# tar -zxvf nagios-4.0.8.tar.gz 
# cd nagios-4.0.8

# ./configure &amp;amp;&amp;amp; make all

# make install-groups-users
# usermod -a -G nagios www-data

# make install
# make install-init
# make install-config
# make install-commandmode
# cd ..&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;nagios安装完成后就可以启动了，但是web页面是无法访问的，查看日志会报错&lt;code&gt;(No output on stdout) stderr: execvp(/usr/local/nagios/libexec/check_ping, ...) failed. errno is 2: No such file or directory&lt;/code&gt;，这是因为我们只安装了nagios的core，没有安装nagios的插件，需要安装插件来支持core工作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3.安装nagios-plugins&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# wget https://nagios-plugins.org/download/nagios-plugins-2.2.1.tar.gz
# tar -zxvf nagios-plugins-2.2.1.tar.gz
# cd nagios-plugins-2.2.1
# ./configure
# make
# make install
# cd ..&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;nagios的插件主要是添加了check_ping、checkhttp之类的辅助检查的脚本，默认位于&lt;code&gt;/usr/local/nagios/libexec/&lt;/code&gt;下，可以借助这些插件来监控我们的HTTP接口或主机、服务状态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4.创建nagios web访问的账号密码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# vi /usr/local/bin/htpasswd.pl
#!/usr/bin/perl
 
use strict;
 
if ( @ARGV != 2 ){
    print &quot;usage: /usr/local/bin/htpasswd.pl &amp;lt;username&amp;gt; &amp;lt;password&amp;gt;\n&quot;;
}
else {
    print $ARGV[0].&quot;:&quot;.crypt($ARGV[1],$ARGV[1]).&quot;\n&quot;;
}
# chmod +x /usr/local/bin/htpasswd.pl

#利用perl脚本生成账号密码到htpasswd.users文件中
# /usr/local/bin/htpasswd.pl nagiosadmin nagios@ops-coffee &amp;gt; /usr/local/nagios/htpasswd.users&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;nagios默认开启了账号认证，认证相关的配置在这个文件里&lt;code&gt;/usr/local/nagios/etc/cgi.cfg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果安装了httpd服务，可以直接接触htpasswd命令生成密码，这里我们没有httpd服务，所以写个perl脚本来生成密码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;5.nginx添加server配置，让浏览器可以访问&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server {
    listen       80;
    server_name  ngs.domain.com;

    access_log /var/log/nginx/nagios.access.log;
    error_log /var/log/nginx/nagios.error.log;

    auth_basic &quot;Private&quot;;
    auth_basic_user_file /usr/local/nagios/htpasswd.users;

    root /usr/local/nagios/share;
    index index.php index.html;

    location / {
        try_files $uri $uri/ index.php /nagios;
    }

    location /nagios {
        alias /usr/local/nagios/share;
    }

    location ~ \.php$ {
        include /etc/nginx/fastcgi_params;
        fastcgi_pass unix:/var/run/php5-fpm.sock;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }

    location ~ ^/nagios/(.*\.php)$ {
        alias /usr/local/nagios/share/$1;
        include /etc/nginx/fastcgi_params;
        fastcgi_pass unix:/var/run/php5-fpm.sock;
    }

    location ~ \.cgi$ {
        root /usr/local/nagios/sbin/;
        rewrite ^/nagios/cgi-bin/(.*)\.cgi /$1.cgi break;
        fastcgi_param AUTH_USER $remote_user;
        fastcgi_param REMOTE_USER $remote_user;
        include /etc/nginx/fastcgi_params;
        fastcgi_pass unix:/var/run/fcgiwrap.socket;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6.检查配置文件并启动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#检查配置文件是否有语法错误
# /usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg 

#启动nagios服务
# /usr/local/nagios/bin/nagios -d /usr/local/nagios/etc/nagios.cfg

#启动fcgiwrap和php5-fpm服务
# service fcgiwrap restart
# service php5-fpm restart&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7.浏览器访问服务器IP或域名就可以看到nagios的页面了，默认有本机的监控数据，不需要的话可以在配置文件&lt;code&gt;localhost.cfg&lt;/code&gt;中删除&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/19/165eef6d402b2267?w=1265&amp;amp;h=428&amp;amp;f=png&amp;amp;s=41842&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;nagios配置&quot;&gt;Nagios配置&lt;/h2&gt;
&lt;p&gt;Nagios的主配置文件路径为&lt;code&gt;/usr/local/nagios/etc/nagios.cfg&lt;/code&gt;，里边默认已经配置了一些配置文件的路径，cfg_file=后边配置的都是配置文件，nagios程序会来这里读取配置，我们可以新添加一个专门用来监控HTTP API的配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cfg_file=/usr/local/nagios/etc/objects/check_api.cfg&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;check_api.cfg里边的内容如下&quot;&gt;check_api.cfg里边的内容如下：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;define service{
    use                     generic-service
    host_name               localhost
    service_description     web_project_01
    check_command           check_http!ops-coffee.cn -S
}

define service{
    use                     generic-service
    host_name               localhost
    service_description     web_project_02
    check_command           check_http!ops-coffee.cn -S -u / -e 200
}

define service{
    use                     generic-service
    host_name               localhost
    service_description     web_project_03
    check_command           check_http!ops-coffee.cn -S -u /action/health -k &quot;sign:e5dhn&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;define service&lt;/strong&gt;：定义一个服务，每一个页面或api属于一个服务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;use&lt;/strong&gt;：定义服务使用的模板，模板配置文件在&lt;code&gt;/usr/local/nagios/etc/objects/templates.cfg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;host_name&lt;/strong&gt;：定义服务所属的主机，我们这里区别主机意义不大，统一都属于localhost好了&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;service_description&lt;/strong&gt;：定义服务描述，这个值会最终展示在web页面上的service字段，定义应简单有意义&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;check_command&lt;/strong&gt;：定义服务检查使用的命令，命令的配置文件在&lt;code&gt;/usr/local/nagios/etc/objects/commands.cfg&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;check_http检测https接口时可以使用-S参数，如果报错&lt;code&gt;SSL is not available&lt;/code&gt;，那么你需要先安装libssl-dev包，然后重新编译（&lt;code&gt;./configure --with-openssl=/usr/bin/openssl&lt;/code&gt;）部署nagios-plugin插件添加对ssl的支持&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;check_command我们配置了check_http需要修改commands.cfg文件中默认的check_http配置如下&quot;&gt;&lt;strong&gt;check_command&lt;/strong&gt;我们配置了check_http，需要修改commands.cfg文件中默认的check_http配置如下：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;define command {
    command_name    check_http
    command_line    $USER1$/check_http -H $ARG1$
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;define command&lt;/strong&gt;：定义一个command&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;command_name&lt;/strong&gt;：定义command的名字，在主机或服务的配置文件中可以引用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;command_line&lt;/strong&gt;：定义命令的路径和执行方式，这个&lt;code&gt;check_http&lt;/code&gt;就是我们通过安装nagios-plugin生成的，位于&lt;code&gt;/usr/local/nagios/libexec/&lt;/code&gt;下，&lt;code&gt;check_http&lt;/code&gt;的详细用法可以通过&lt;code&gt;check_http -h查看&lt;/code&gt;，支持比较广泛&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;use我们配置了generic-service可以通过配置服务模板定义很多默认的配置如下&quot;&gt;&lt;strong&gt;use&lt;/strong&gt;我们配置了generic-service，可以通过配置服务模板定义很多默认的配置如下：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;define service {
    name                            generic-service         ; The 'name' of this service template
    active_checks_enabled           1                       ; Active service checks are enabled
    passive_checks_enabled          1                       ; Passive service checks are enabled/accepted
    parallelize_check               1                       ; Active service checks should be parallelized (disabling this can lead to major performance problems)
    obsess_over_service             1                       ; We should obsess over this service (if necessary)
    check_freshness                 0                       ; Default is to NOT check service 'freshness'
    notifications_enabled           1                       ; Service notifications are enabled
    event_handler_enabled           1                       ; Service event handler is enabled
    flap_detection_enabled          1                       ; Flap detection is enabled
    process_perf_data               1                       ; Process performance data
    retain_status_information       1                       ; Retain status information across program restarts
    retain_nonstatus_information    1                       ; Retain non-status information across program restarts
    is_volatile                     0                       ; The service is not volatile
    check_period                    24x7                    ; The service can be checked at any time of the day
    max_check_attempts              2                       ; Re-check the service up to 3 times in order to determine its final (hard) state
    check_interval                  1                      ; Check the service every 10 minutes under normal conditions
    retry_interval                  1                       ; Re-check the service every two minutes until a hard state can be determined
    contact_groups                  admins                  ; Notifications get sent out to everyone in the 'admins' group
    notification_options            w,u,c,r                 ; Send notifications about warning, unknown, critical, and recovery events
    notification_interval           60                      ; Re-notify about service problems every hour
    notification_period             24x7                    ; Notifications can be sent out at any time
    register                        0                       ; DON'T REGISTER THIS DEFINITION - ITS NOT A REAL SERVICE, JUST A TEMPLATE!
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置太多就不一一解释了，配合后边的英文注释应该看得懂，说几个重要的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;max_check_attempts&lt;/strong&gt;：重试几次来最终确定服务的状态，例如我们一个服务挂了，需要重试3次才会确定这个服务确实是挂了，然后发邮件或短信通知我们&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;check_interval&lt;/strong&gt;：检查频率配置，在服务正常的情况下多长时间轮训检查一次，这里为了更及时的反馈结果我们配置一分钟一次&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;retry_interval&lt;/strong&gt;：当服务状态发生变更的时候多长时间轮序检查一次，我们也给配置一分钟一次&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;contact_groups&lt;/strong&gt;：定义联系人组，当发生故障需要报警时，发送报警给哪个组，这个组的配置文件在&lt;code&gt;/usr/local/nagios/etc/objects/contacts.cfg&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;contact_groups我们配置了admins接下来看下contacts.cfg的配置&quot;&gt;&lt;strong&gt;contact_groups&lt;/strong&gt;我们配置了admins，接下来看下contacts.cfg的配置&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;define contact{
    contact_name                    sa       ; Short name of user
    use                             generic-contact     ; Inherit default values from generic-contact template (defined above)
    alias                           Nagios Admin        ; Full name of user

    service_notification_period     24x7
    host_notification_period        24x7
    service_notification_options    w,u,c,r
    host_notification_options       d,u,r
    host_notification_commands      notify-host-by-email,notify-host-by-sms
    service_notification_commands   notify-service-by-email,notify-service-by-sms

    email                           ops-coffee@domain.com
    pager                           15821212121,15822222222
}

define contactgroup{
    contactgroup_name       admins
    alias                   Nagios Administrators
    members                 sa
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;contactgroup就是我们定义的联系人组admins&lt;/li&gt;
&lt;li&gt;admins组管理了成员sa联系人&lt;/li&gt;
&lt;li&gt;sa联系人定义了主机和服务的命令，例如这里我们定义的notify-host-by-email,notify-host-by-sms发邮件和发短信的命令，这个命令的定义位置跟我们check_http的定义都在文件&lt;code&gt;/usr/local/nagios/etc/objects/commands.cfg&lt;/code&gt;文件内&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;全部配置完成后重启nagios服务，会看到监控已经正常&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/19/165eef6d4096fc40?w=1264&amp;amp;h=492&amp;amp;f=png&amp;amp;s=76042&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;nagstamon插件&quot;&gt;Nagstamon插件&lt;/h2&gt;
&lt;p&gt;介绍一款配合nagios用起来非常棒的插件Nagstamon，Nagstamon是一款nagios的桌面小工具（实际上现在不仅仅能配合nagios使用，还能配合zabbix等使用），启动后常驻系统托盘，当nagios监控状态发生变化时会及时的跳出来并发出声音警告，能够更加及时的获取业务状态。&lt;/p&gt;
&lt;p&gt;配置如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/19/165eef6d41d8094a?w=547&amp;amp;h=317&amp;amp;f=png&amp;amp;s=13488&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Update interval能够配置多长时间取一次nagios的状态，我们这里调整为1s&lt;/li&gt;
&lt;li&gt;当出现报警时桌面直接飙红，给你心跳加速的感觉&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/19/165eef6d49b050f7?w=1680&amp;amp;h=145&amp;amp;f=png&amp;amp;s=20780&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;业务状态监控作为Zabbix之类过程监控的补充，并不能替代过程监控系统，在我们过程监控不是很完善的情况下很有用，目前我们有相当一部分的报警都首先发现于这套业务状态监控&lt;/li&gt;
&lt;li&gt;选择Nagios主要是她比较纯粹，专注状态监控（有插件实现过程记录），且对Nagios比较熟悉了。Nagios看似配置复杂，几个配置文件环环相扣，实际上理清楚配置文件之间的关系就会发现配置合理且简单&lt;/li&gt;
&lt;li&gt;部署的状态监控节点越多覆盖地区越多用户状态获取就越准确，但由于网络环境复杂，我们也不可能在每个省市、节点部署监控系统来监控项目的状态，如有必要可以考虑一些商业监控方案，能够做到全球节点监控，但相应的成本可能就会增加，要综合权衡&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/9/19/165eef6d41a2bcf2?w=430&amp;amp;h=476&amp;amp;f=jpeg&amp;amp;s=38786&quot; alt=&quot;长按关注公众号查看更多原创文章&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你觉得文章对你有帮助，请转发分享给更多的人。如果你觉得读的不尽兴，推荐阅读以下文章：&lt;/p&gt;
</description>
<pubDate>Tue, 18 Sep 2018 23:16:00 +0000</pubDate>
<dc:creator>运维咖啡吧</dc:creator>
<og:description>想必各个公司都有部署zabbix之类的监控系统来监控服务器的资源使用情况、各服务的运行状态，是否这种监控就足够了呢？有没有遇到监控系统一切正常确发现项目无法正常对外提供服务的情况呢？本篇文章聊聊我们如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/37Y37/p/9672418.html</dc:identifier>
</item>
<item>
<title>Linux 桌面玩家指南：04. Linux 桌面系统字体配置要略 - 京山游侠</title>
<link>http://www.cnblogs.com/youxia/p/LinuxDesktop004.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youxia/p/LinuxDesktop004.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;特别说明：&lt;/strong&gt;要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用&lt;code&gt;$&lt;/code&gt;标记数学公式的开始和结束。如果某条评论中出现了两个&lt;code&gt;$&lt;/code&gt;，MathJax 会将两个&lt;code&gt;$&lt;/code&gt;之间的内容按照数学公式进行排版，从而导致评论区格式混乱。如果大家的评论中用到了&lt;code&gt;$&lt;/code&gt;，但是又不是为了使用数学公式，就请使用&lt;code&gt;\$&lt;/code&gt;转义一下，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想从头阅读该系列吗？下面是传送门：&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.x.org/releases/X11R7.7/doc/xorg-docs/fonts/fonts.html&quot;&gt;Fonts in X11R7.7&lt;/a&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://keithp.com/~keithp/talks/xtc2001/paper/&quot;&gt;The Xft Font Library: Architecture and Users Guide&lt;/a&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://freetype.sourceforge.net/freetype2/&quot;&gt;FreeType 2 官网&lt;/a&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://avi.alkalay.net/articlefiles/linux/docs/font-howto/Font.html&quot;&gt;Optimal Use of Fonts on Linux&lt;/a&gt; ；&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.freedesktop.org/wiki/Software/fontconfig/&quot;&gt;Fontconfig 官网&lt;/a&gt; 。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;字体效果预览&quot;&gt;字体效果预览&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;宋体12pt：这里是中文，以及标点符号“，。！？：；”This is English.&lt;/span&gt; &lt;span&gt;这一行是6pt。&lt;/span&gt;&lt;span&gt;这一行是7pt。&lt;/span&gt;&lt;span&gt;这一行是8pt。&lt;/span&gt;&lt;span&gt;这一行是9pt。&lt;/span&gt;&lt;span&gt;这一行是10pt。&lt;/span&gt;&lt;span&gt;这一行是11pt。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　黑体12pt：这里是中文，以及标点符号“，。！？：；”This is English.&lt;/span&gt; &lt;span&gt;这一行是6pt。&lt;/span&gt;&lt;span&gt;这一行是7pt。&lt;/span&gt;&lt;span&gt;这一行是8pt。&lt;/span&gt;&lt;span&gt;这一行是9pt。&lt;/span&gt;&lt;span&gt;这一行是10pt。&lt;/span&gt;&lt;span&gt;这一行是11pt。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;微软雅黑12pt：这里是中文，以及标点符号“，。！？：；”This is English.&lt;/span&gt; &lt;span&gt;这一行是6pt。&lt;/span&gt;&lt;span&gt;这一行是7pt。&lt;/span&gt;&lt;span&gt;这一行是8pt。&lt;/span&gt;&lt;span&gt;这一行是9pt。&lt;/span&gt;&lt;span&gt;这一行是10pt。&lt;/span&gt;&lt;span&gt;这一行是11pt。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　serif: This is English, 这是英文中夹杂的中文。&lt;/span&gt;&lt;span&gt;This line is 6pt.&lt;/span&gt; &lt;span&gt;This line is 7pt.&lt;/span&gt; &lt;span&gt;This line is 8pt.&lt;/span&gt; &lt;span&gt;This line is 9pt.&lt;/span&gt; &lt;span&gt;This line is 10pt.&lt;/span&gt; &lt;span&gt;This line is 11pt.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Times New Roman: This is English, 这是英文中夹杂的中文。&lt;/span&gt;&lt;span&gt;This line is 6pt.&lt;/span&gt; &lt;span&gt;This line is 7pt.&lt;/span&gt; &lt;span&gt;This line is 8pt.&lt;/span&gt; &lt;span&gt;This line is 9pt.&lt;/span&gt; &lt;span&gt;This line is 10pt.&lt;/span&gt; &lt;span&gt;This line is 11pt.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　Georgia: This is English, 这是英文中夹杂的中文。&lt;/span&gt;&lt;span&gt;This line is 6pt.&lt;/span&gt; &lt;span&gt;This line is 7pt.&lt;/span&gt; &lt;span&gt;This line is 8pt.&lt;/span&gt; &lt;span&gt;This line is 9pt.&lt;/span&gt; &lt;span&gt;This line is 10pt.&lt;/span&gt; &lt;span&gt;This line is 11pt.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;sans-serif: This is English, 这是英文中夹杂的中文。&lt;/span&gt;&lt;span&gt;This line is 6pt.&lt;/span&gt; &lt;span&gt;This line is 7pt.&lt;/span&gt; &lt;span&gt;This line is 8pt.&lt;/span&gt; &lt;span&gt;This line is 9pt.&lt;/span&gt; &lt;span&gt;This line is 10pt.&lt;/span&gt; &lt;span&gt;This line is 11pt.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;verdana: This is English, 这是英文中夹杂的中文。&lt;/span&gt;&lt;span&gt;This line is 6pt.&lt;/span&gt; &lt;span&gt;This line is 7pt.&lt;/span&gt; &lt;span&gt;This line is 8pt.&lt;/span&gt; &lt;span&gt;This line is 9pt.&lt;/span&gt; &lt;span&gt;This line is 10pt.&lt;/span&gt; &lt;span&gt;This line is 11pt.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　Arial: This is English, 这是英文中夹杂的中文。&lt;/span&gt;&lt;span&gt;This line is 6pt.&lt;/span&gt; &lt;span&gt;This line is 7pt.&lt;/span&gt; &lt;span&gt;This line is 8pt.&lt;/span&gt; &lt;span&gt;This line is 9pt.&lt;/span&gt; &lt;span&gt;This line is 10pt.&lt;/span&gt; &lt;span&gt;This line is 11pt.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;程序代码：&lt;br/&gt;　　#include &amp;lt;stdio.h&amp;gt;&lt;br/&gt;　　int main(){&lt;br/&gt;　　　　return 0;//很显然这是为了测试等宽字体&lt;br/&gt;　　}&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;字体的分类及电脑中的字体显示技术&quot;&gt;字体的分类及电脑中的字体显示技术&lt;/h2&gt;
&lt;p&gt;先了解字体的分类及其用途。&lt;/p&gt;
&lt;p&gt;1、英文字体分为三类，分别是有衬线字体（serif）、无衬线字体（sans-serif）和等宽字体（monospace）。Serif 是有衬线字体，意思是在字的笔画开始、结束的地方有额外的装饰，而且笔画的粗细会有所不同。Sans-serif 就没有这些额外的装饰，而且笔画的粗细差不多。在传统的正文印刷中，普遍认为有衬线字体能带来更佳的可读性（相比无衬线字体），尤其是在大段落的文章中，衬线增加了阅读时对字母的视觉参照。而无衬线字体往往被用在标题、较短的文字段落或者一些通俗读物中。相比严肃正经的有衬线字体，无衬线字体给人一种休闲轻松的感觉。同时，由于无衬线字体笔画比较饱满，所以比较适合电脑屏幕显示，在印刷和打印中，可以用无衬线字体做标题、加粗字体等表示强调。等宽字体就不用多说啦，主要用于终端字体或编程。&lt;/p&gt;
&lt;p&gt;2、中文字体可以参照英文字体进行分类，由于中文都是等宽的，所以就只需要区分有衬线（serif）和无衬线（sans-serif）。中文的宋体、仿宋就相当于英文的 serif，所以用于传统印刷和打印效果比较好。而中文的黑体、楷体、圆体等字体相当于英文的 sans-serif，用于电脑屏幕的显示效果比较好，也可以用在印刷和打印中做标题和粗体字。&lt;/p&gt;
&lt;p&gt;3、Serif 字体的经典代表有 Georgia 和 Times New Roman，sans-serif 字体的经典代表有 Arial 和Verdana，monospace 字体的经典代表有 Courier New 和 DejaVu Sans Mono。&lt;/p&gt;
&lt;p&gt;电脑中的字体既是一门艺术，也是一门技术。要将屏幕上的字体显示得好看难度可不小。字体可以表示为点阵（bitmap），也可以表示为轮廓（outline）。点阵字体不能缩放，轮廓字体可以随意缩放。&lt;/p&gt;
&lt;p&gt;1、要获得锐利清晰的效果，小字必须显示为点阵（bitmap），大字可以显示为轮廓；&lt;/p&gt;
&lt;p&gt;2、显示轮廓字体时，为了让字体边缘显得比较光滑，需要对字体边缘进行抗锯齿（anti-alias）；&lt;/p&gt;
&lt;p&gt;3、为了获得更好的效果，字体设计厂家在设计字体的时候，会对字体进行微调（hinting）。字体微调是一项耗时耗力的工作，所以就产生了自动微调技术（autohint）；&lt;/p&gt;
&lt;p&gt;4、为了让字体在液晶显示器上获得更好的效果（主要也是为了字体边缘光滑），产生了次像素平滑技术（subpixle），微软的 ClearType 技术也属于次像素平滑技术的一种。所谓次像素，是指每个像素中的单独的 R、G、B 分量，所以次像素平滑用好了，字体边缘看起来会更平滑，如果用不好，字体边缘就会显得花花绿绿。也正是因为 CRT 显示器和液晶显示器每个像素的组成方式不一样，所以在 CRT 显示器中不能开次像素平滑。&lt;/p&gt;
&lt;p&gt;5、增加屏幕的 dpi，可以增加画字的像素，从而获得更平滑的显示效果。比如在传统的 96dpi 的电脑显示器上，一个 9pt 的字符用 12 个像素绘制，一个 12pt 的字符用 16 个像素绘制，使用轮廓字体确实很难做到平滑。但是在目前的安卓手机、苹果 iPad 等设备上，高分辨率的润眼屏都在 300dpi 以上，画一个 12pt 的字符可以用 50 多个像素，字体平滑自然不是问题，根本不需要使用点阵、微调、抗锯齿、次像素等技术。我认为，随着显示器硬件技术的发展，以上技术都将成为浮云。&lt;/p&gt;
&lt;h2 id=&quot;linux桌面系统字体的历史及现状&quot;&gt;Linux桌面系统字体的历史及现状&lt;/h2&gt;
&lt;p&gt;这一节很有历史意义。为了向大家充分展示 Linux 桌面系统字体的历史，我安装了 CentOS 5、CentOS 6、CentOS 7、Ubuntu 15.04 和 Ubuntu 18.04，并使用上一节编写的字体测试内容对以上系统的桌面环境的字体显示情况进行了测试。让大家了解 Linux 桌面系统中文字体的五代变迁经历。这五代分别是 CentOS 5 时代的文鼎PL细上海宋和文鼎PL中楷、CentOS 6 时代的 AR PL UMing、CentOS 7 时代的文泉驿黑体、Ubuntu 15.04 时代的 Droid Sans Fallback、Ubuntu 18.04 时代的思源黑体和思源宋体。CentOS 5 发布于 2007 年，比这更早的 Linux 桌面字体的配置是什么样子，以及使用的配置方法是什么，我就不去考究了，前面专门放上几个参考文献的链接，至于更早的字体配置方法，以参考文献中说的为准。&lt;/p&gt;
&lt;p&gt;先看上一节的字体测试在 Windows 10 中的显示效果，下图是原始大小：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180911204247588-1388004311.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图是使用 Ctrl+鼠标滚轮 将字体放大后的效果：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180911204346558-645488335.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Windows 10 中的显示效果可以当成一个参考标准，虽然网络上仍然还有人对 Windows 的字体渲染技术不太满意，认为跟 MacOS 相比还有差距，但是我已经非常满意了。毕竟 Windows 是一个商业的系统，MicroSoft 是一个有钱的大公司，在字体方面做得还是非常好的。其它在字体方面做得好的公司还有 Apple、Adobe、Google，无一不是有钱的大公司。 这些公司不仅设计了（或者花钱买或者花钱请人设计了）一系列好看的字体，还掌握了很多字体渲染方面的专利。这就使得 Linux 这样的开源系统比较被动了。&lt;/p&gt;
&lt;p&gt;从上面两图可以看出，Windows 10 中的字体不管是大号还是小号，都显示得很饱满，而且能够准确区分 serif 和 sans-serif 字体，在 serif 的分类中，又有显示得更好看的 Georgia 和 Times New Roman 字体，在 sans-serif 的分类中，又有显示得更加好看的 Arial 和 Verdana 字体。仔细观看字体并对比，发现在 Windows 10 中， serif 字体不管中英文默认都会以宋体显示，sans-serif 字体不管中英文默认都会以微软雅黑显示。宋体和黑体都是微软买的，中易设计的字体，我们平时用得最多，所以最熟悉。字体比较小时，微软雅黑明显比黑体显示得好看，字体大的时候，微软雅黑和黑体就没有太大的差别了。而且我认为，微软雅黑的引号不好看。宋体字在小字号时，有点阵显示，微软雅黑和 Verdana 在小字号时，也有非常好的 hinting。&lt;/p&gt;
&lt;p&gt;Hinting 需要两方面的支持，一是设计字体时，针对字体进行微调，这是一项耗时耗力的工作，所以大公司才搞得起；二是字体渲染时，渲染技术要支持字体中的 hinting 信息。而对 TrueType 字体中的 hinting 进行渲染的技术是有专利壁垒的，所以在早期的 Linux 系统中，使用的 freetype 字体渲染库默认是不支持 hinting 的，如果要开启 hinting 支持，需要自己编译 libfreetype。不过参考文献中说了，如果系统中的 libfreetype 库是 libfreetype6 或以上版本，就说明已经开启 hinting 支持了。现在新一点的 Linux 发行版都满足要求。&lt;/p&gt;
&lt;p&gt;没有对比就没有伤害，下面看看 CentOS 5 桌面系统对字体的支持是什么样的，下两图是原始大小：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180911211948757-974001478.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180911212945806-380459799.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;怎一个模糊了得啊。网页中的字体非常的虚，一点都不饱满，而系统菜单中的字体显示得还比较清晰，因为系统菜单中的字体用的是点阵。基本上可以认为，小字显示为点阵会比较饱满锐利，而显示为轮廓字体则会发虚。下面是使用 Ctrl+鼠标滚轮 放大以后的效果：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180911212117834-1516291261.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将网页放大后，发虚的情况就会好很多，但是和 Windows 下的显示还是没法比。另外，在 CentOS 5 中它不能准确显示 sans-serif 和黑体，所有的字都显示为 serif 和 宋体，更离谱的是，它认为 serif 中夹杂的中文应该显示为楷体。总而言之，CentOS 5 中的字体配置是非常失败的。&lt;/p&gt;
&lt;p&gt;当然，这是有历史原因的。CentOS 5 系统中对中文的支持主要依赖于 2001 年文鼎向开源界贡献的两套字体：文鼎PL中楷和文鼎PL细上海宋，如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201809/16576-20180911213258356-811501065.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时期 Windows 中用的宋体和黑体虽然好，但那是要钱的，在 Linux 中盗用是违法的。而同时期开源界又没有什么好的开源字体，所以只能那么将就了。这时我不得不提一下中科红旗的 Linux，大概也是在这个时期吧，因为字体的原因，我放弃过 Redhat，而选用了中科红旗 Linux。中科红旗 Linux 选用的是和 Windows 一样的中易的宋体，字体清晰锐利，而且中科红旗 Linux 也使用 rpm 管理软件包，所以用着还算顺手。不好的是，我那时对 Linux 字体配置理解不深，写了一些错误的随笔，不过后来都删了，而且这次删随笔致使我的博客排名严重下降，再也没升上来（当然，和我懒没有再继续发高质量博客也有很大关系）。&lt;/p&gt;
&lt;p&gt;随着时间的流逝，2011 年，CentOS 6 发布了。在 CentOS 6 中，以上测试字体的内容显示为这样：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180914193825734-1279709855.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;放大后，是这样：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180914193841925-344682706.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上两张图片可以看到，除了 Arial 显示为 sans-serif 之外，其它的字体都是显示为宋体，而且在小字时有了点阵。和 CentOS 5 相比算是有很大的进步了，因为小字采用点阵后，清晰锐利了不少，发虚的情况没了。不好的是，这个宋体并没有我们习惯的 SimSun 好看，而且逗号句号还不是在一行的偏下的部位，而是跑到了一行的正中。这个宋体是由哪个字体支持的呢？下图可以看到 CentOS 6 中安装的中文字体：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180914194500020-306941359.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，CentOS 6 的主打字体是 AR PL UMing。从 AR PL 这几个字符可以看出，AR PL UMing 和文鼎贡献的那两套字体是一脉相承的。确实如此，只不过是经过合并、修改、增加了日语韩语及香港常用字型后，更名为 CJKUniFonts，据说含有点阵。从名字可以看出，有了这套字体，中日韩都可以搞定。而且，CentOS 6 中已经有了文泉驿字体，之所以没有显示黑体不是因为没有黑体，而是因为没有正确配置。&lt;/p&gt;
&lt;p&gt;也就是说，至少在 CentOS 6 之前，Linux 桌面发行版都没有认识到黑体字的重要价值。&lt;/p&gt;
&lt;p&gt;转眼到了 2014 年，CentOS 7 发布了，这个阶段对应的 Fedora 大约是 20 和 21 这两个版本。在 CentOS 7 中，字体测试显示效果是这样的：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180914195405164-1439358875.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;放大后，是这样的：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180914195423670-2102186566.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面两张图片可以看出，除了明确指定为 Times New Roman 的字体之外，其它的字体都显示为黑体，而且小字有点阵。它的主打字体是什么呢？请看下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180914200045986-1678885799.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;黑体选用的是文泉驿，依然安装有 AR PL UMing 作为宋体的支持，但是不作为主打。认识到点阵的重要性和认识到黑体的重要性，可以算是这个时期 Linux 桌面发行版的进步吧。但是，不能正确区分 serif 和 sans-serif，这也是一个巨大的不足吧。&lt;/p&gt;
&lt;p&gt;这个时期的 Ubuntu 又是什么样子的呢？我们来看看 Ubuntu 15.04，这是 2015 年的发行版。下面直接连上三图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180914200631083-374021047.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180914200640260-871147551.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180914200647516-305785778.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我认为，这个时期的 Linux 桌面发行版应该是受到了 Android 手机和苹果 ipad mini 这样的小尺寸高分辨率屏幕的巨大影响，主要表现为认识到了黑体字的重要性，并逐渐放弃了点阵，因为屏幕的 ppi 比较高，点阵就不是必须的了。Ubuntu 15.04 是一种字体打天下，使用的是 Droid Sans Fallback，而这种字体正是 Google 公司为其 Android 系统设计的中日韩字体。这个时期的 Ubuntu，是有进军手机系统的野心的。但是作为 Linux 桌面发行版，不能准确区分 serif 和 sans-serif，也是有硬伤的。&lt;/p&gt;
&lt;p&gt;到了 2018 年，Ubuntu 终于放弃了 Unity 桌面，而回归了 Gnome 3，这也标志着其在手机操作系统市场的失败。Ubuntu 18.04 桌面系统显示效果是这样的：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180914210602283-191658704.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180914210609990-1204691998.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180914210617215-1795354388.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180914210624906-2114534590.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个阶段，开源领域能够使用的字体也是越来越丰富了。Ubuntu 18.04 中使用的是思源黑体和思源宋体，同时，系统中也安装有 AR PL UMing 和 AR PL UKai。另外，如果有需要，我们随时也可以安装前面提到的文泉驿以及 Droid Sans Fallback。思源黑体和思源宋体的字形以及标点符号还是很漂亮的，可以作为主打字体。Ubuntu 18.04 中小字虽然没有使用点阵，但是其饱满程度和 CentOS 5 相比要强不少，没有明显发虚的感觉，说明不仅字体在进步，字体渲染技术也在进步。Ubuntu 18.04 可以正确区分 serif 和 sans-serif 字体，对它们分别选用宋体和黑体，这已经很令人满意了。&lt;/p&gt;
&lt;p&gt;可以这么说，Ubuntu 18.04 可能是目前在字体方面最让人省心的 Linux 桌面发行版，在字体配置方面，我们只需要微调即可。例如，serif 字体显示的是 AR PL UMing，如果更改为思源宋体会更漂亮，Times New Roman 英文字体识别是正确的，但是里面夹杂的中文应该显示为宋体，而不应该是黑体，Georgia 字体应该是 serif 分类的，而不应该是 sans-serif 分类的，其中夹杂的中文也应该为宋体。另外，没有点阵也算是一个小小的缺陷。为什么说是小小的缺陷而不是说硬伤呢？那是因为我认为随着屏幕的发展和渲染技术的进步，点阵已经不是太重要了。&lt;/p&gt;
&lt;h2 id=&quot;使用-fontconfig-配置-linux-桌面字体的语法和流程&quot;&gt;使用 Fontconfig 配置 Linux 桌面字体的语法和流程&lt;/h2&gt;
&lt;p&gt;目前，在 Linux 系统上配置字体的工具是 Fontconfig。我们要感谢这个时代，曾经混乱不堪的字体配置方法终于被 Fontconfig 一统江湖，我们要配置系统中的字体，只需要学习 Fontconfig 就行了。我在文章的开始给出了参考资料，&lt;a href=&quot;https://www.x.org/releases/X11R7.7/doc/xorg-docs/fonts/fonts.html&quot;&gt;Fonts in X11R7.7&lt;/a&gt; 中说，X11 包含两套字体系统，一套是 The core X11 fonts system，另一套是 Xft fonts system。前者是伴随 X11R1 在 1987 年诞生的，最初只能使用单色的点阵字体，多年来虽小有改进，但是依然很难用。后者是专门为可缩放字体而设计的字体系统，还支持抗锯齿和次像素平滑。该参考文献中还特意指出，虽然 X.org 会继续维护 The core X11 fonts system，但是仍然建议 toolkits author 尽早切换到 Xft 字体系统。什么 toolkits 呢？在 Linux 下无非就是 Qt 和 GTK 而已。[Optimal Use of Fonts on Linux] 中说，从 QT3 和 GTK 2 开始，使用这两种库编写的程序就都是使用 Xft 字体系统了。Xft 只是一个接口，在目前的 Linux 中，普遍使用的 Fontconfig 进行字体的配置，使用 FreeType 进行字体渲染。前面我也给出了参考资料 &lt;a href=&quot;http://freetype.sourceforge.net/freetype2/&quot;&gt;FreeType 2 官网&lt;/a&gt; 和 &lt;a href=&quot;https://www.freedesktop.org/wiki/Software/fontconfig/&quot;&gt;Fontconfig 官网&lt;/a&gt; ，有兴趣的朋友们可以自己去看。&lt;/p&gt;
&lt;p&gt;在这里，我再次强调，玩 Linux 要与时俱进，网络上有很多信息是过时的，要注意鉴别。例如，如果在网络上搜索 Linux 字体安装、配置的文章，如果出来的结果还提及要使用&lt;code&gt;mkfontdir&lt;/code&gt;和&lt;code&gt;mkfontscale&lt;/code&gt;这样的命令，还使用像&lt;code&gt;-misc-fixed-medium-r-normal--10-100-75-75-c-60-iso8859-1&lt;/code&gt;这么复杂的字体名称，甚至还提及要使用 xfs 字体服务器，那么这一定是很陈旧的内容了。有多陈旧呢？大概比 CentOS 5 还早 15 年吧。当然，如果你确实需要使用 The core X11 font system，可以阅读我给出的参考文献 &lt;a href=&quot;https://www.x.org/releases/X11R7.7/doc/xorg-docs/fonts/fonts.html&quot;&gt;Fonts in X11R7.7&lt;/a&gt; ，系统地学习它。在我的 Linux 桌面中，我只需要使用 Fontconfig 就够了。&lt;/p&gt;
&lt;p&gt;学习 Fontconfig 的最佳方式是阅读&lt;code&gt;man fonts.conf&lt;/code&gt;手册页，其次，就是阅读&lt;code&gt;/etc/fonts/conf.d&lt;/code&gt;目录下的配置文件，从实例中学习。&lt;/p&gt;
&lt;p&gt;Fontconfig 是一个字体配置工具，在系统中，其它软件是如何和 Fontconfig 交互的呢？可以这么理解，当一个程序需要字体时，它先告诉 Fontconfig 需要什么字体，然后，Fontconfig 根据系统中是否安装有这个字体，以及系统对字体的配置，向这个程序返回一个信息，这个信息中包含有你可以用哪个字体，这个字体的文件是什么，包含哪些属性。程序收到 Fontconfig 的回应后，再调用 FreeType 库来渲染这个字体。这么说有点抽象，下面来一个具体点的例子。就以 Firefox 显示我的这篇随笔为例吧，我的博客设置的字体是 verdana 和微软雅黑，所以 Firefox 就会和 Fontconfig 说：“我要 verdana 和 微软雅黑。” Fontconfig 检查系统中的字体以及配置文件后，发现系统中没有 verdana 和微软雅黑，但是可以使用 DejaVu Sans 和 Noto Sans CJK 代替，就会回答：“请使用 DejaVu Sans 和 Noto Sans CJK，它们的文件分别是什么什么，它们的其它属性分别是什么什么。” 然后 Firefox 就会以 DejaVu Sans 和思源黑体显示我这篇随笔。&lt;/p&gt;
&lt;p&gt;把上面的过程进行总结，就是一个程序需要字体时，它先构建一个 pattern，这个 pattern 其实是一个字体列表，而且这个字体列表的每一项并不总是像前面例子中那样只有字体名称，有时还包含一些更详细的要求，例如字体大小、语言、发行者、字符集、是否微调、dpi、像素大小等信息。而对于每一个字体，可以这样表示：&lt;/p&gt;
&lt;pre class=&quot;nohighlight&quot;&gt;
&lt;code&gt;&amp;lt;families&amp;gt;-&amp;lt;point sizes&amp;gt;:&amp;lt;name1&amp;gt;=&amp;lt;values1&amp;gt;:&amp;lt;name2&amp;gt;=&amp;lt;values2&amp;gt;...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而常见的字体属性有哪些呢？请看下表：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;37&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;family&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;字族名称{例如&quot;Microsoft YaHei&quot; &quot;微软雅黑&quot;}&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;style&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;字体风格名称(会覆盖slant与weight){例如&quot;Bold&quot; &quot;Oblique&quot;}&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;slant&lt;/td&gt;
&lt;td&gt;Int&lt;/td&gt;
&lt;td&gt;倾斜度{0}。分为：Italic(100,斜体), oblique(110,合成斜体), roman(0,正体)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;11&quot;&gt;&lt;td&gt;weight&lt;/td&gt;
&lt;td&gt;Int&lt;/td&gt;
&lt;td&gt;粗细程度{80}，从0-210,由最细到最粗。例如：light(50,细), regular(80,一般), medium(100,中等), bold(200,粗)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;size&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;td&gt;磅大小(point size)，单位是绝对大小的&quot;磅&quot;(=1/72英寸)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;pixelsize&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;td&gt;像素大小(pixel size)，单位是显示屏上的&quot;像素&quot;。[pixelsize = (size&lt;em&gt;scale&lt;/em&gt;dpi)/72]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;10&quot;&gt;&lt;td&gt;spacing&lt;/td&gt;
&lt;td&gt;Int&lt;/td&gt;
&lt;td&gt;字符间距。分为：proportional(0,变宽), dual(90,双宽), mono(100,等宽), charcell(110,字符单元)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;foundry&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;字体制造商名称的缩写&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;antialias&lt;/td&gt;
&lt;td&gt;Bool&lt;/td&gt;
&lt;td&gt;渲染字形(glyph)时是否开启抗锯齿功能[建议对矢量字体设为&quot;true&quot;]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;hinting&lt;/td&gt;
&lt;td&gt;Bool&lt;/td&gt;
&lt;td&gt;渲染字形(glyph)时是否开启微调功能(包括内嵌微调与自动微调)[建议对矢量字体设为&quot;true&quot;]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;autohint&lt;/td&gt;
&lt;td&gt;Bool&lt;/td&gt;
&lt;td&gt;&quot;true&quot;表示只使用自动微调；&quot;false&quot;表示优先使用内嵌微调，但对于没有内嵌微调的字体仍会使用自动微调。[建议设为&quot;false&quot;]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;10&quot;&gt;&lt;td&gt;hintstyle&lt;/td&gt;
&lt;td&gt;Int&lt;/td&gt;
&lt;td&gt;微调的程度(同时作用于内嵌微调与自动微调)。分为：none(0,关闭), slight(1,轻度), medium(2,中度), full(3,完全)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;file&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;字体文件的名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;scalable&lt;/td&gt;
&lt;td&gt;Bool&lt;/td&gt;
&lt;td&gt;字形(glyph)是否可以缩放{True}&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;dpi&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;td&gt;目标dpi(像素/英寸)值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;rgba&lt;/td&gt;
&lt;td&gt;Int&lt;/td&gt;
&lt;td&gt;LCD子像素的排列顺序。分为：unknown(0), rgb(1), bgr(2), vrgb(3), vbgr(4), none(5)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;lcdfilter&lt;/td&gt;
&lt;td&gt;Int&lt;/td&gt;
&lt;td&gt;LCD filter 的风格。lcdnone(0),lcddefault(1),lcdlight(2),lcdlegacy(3)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;lang&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;字体所支持的RFC-3066语言的列表{例如&quot;zh-cn&quot;}&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我只选择了一些最常用的属性，完整的属性列表请查看 Fontconfig 的文档。Fontconfig 对程序传过来的 pattern 进行扫描和替换，然后把能够满足程序要求的字体列表传回给程序。Fontconfig 还提供很多辅助工具，如&lt;code&gt;fc-list&lt;/code&gt;、&lt;code&gt;fc-pattern&lt;/code&gt;、&lt;code&gt;fc-match&lt;/code&gt;、&lt;code&gt;fc-cache&lt;/code&gt;等命令。下面，使用&lt;code&gt;fc-match&lt;/code&gt;命令对常用的 serif-12 、 georgia-12 、 sans-serif-12 、 verdana-12 字体进行查询，看看 Fontconfig 返回什么字体，以及这些字体的属性是什么样的。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180917161254360-1717967293.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果显示，我们向 Fontconfig 要 serif，Fontconfig 会回应 AR PL UMing，我们向 Fontconfig 要 sans-serif，Fontconfig 会回应 Noto Sans CJK SC。在字体的属性中，antialias、autohint、hinting、hintstyle 等属性都是没有问题的，唯独 dpi 不对，只有 75，所以画一个 12pt 的字只有 12.5 个像素。这不科学，后面我要把 dpi 改成 96。&lt;/p&gt;
&lt;p&gt;Fontconfig 对字体列表的替换规则是在 Fontconfig 的配置文件中定义的。Fontconfig 会根据配置文件中的定义，对字体列表进行两次扫描，第一次是针对 pattern 进行替换和修改，第二次是对已经选中的字体的属性进行扫描和修改。Fontconfig 的配置文件是 XML 文件，其语法是自描述的，都是意义非常明确的单词，一看就懂。下面我们根据例子来学习Fontconfig 配置的语法。&lt;/p&gt;
&lt;p&gt;首先，Fontconfig 配置文件的最外层 XML 元素一定是：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&amp;gt;
&amp;lt;fontconfig&amp;gt;
    ...
&amp;lt;/fontconfig&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看系统中的&lt;code&gt;/etc/fonts/fonts.conf&lt;/code&gt;文件，其内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&amp;gt;
&amp;lt;!-- /etc/fonts/fonts.conf file to configure system font access --&amp;gt;
&amp;lt;fontconfig&amp;gt;

&amp;lt;!-- Font directory list --&amp;gt;

    &amp;lt;dir&amp;gt;/usr/share/fonts&amp;lt;/dir&amp;gt;
    &amp;lt;dir&amp;gt;/usr/local/share/fonts&amp;lt;/dir&amp;gt;
    &amp;lt;dir prefix=&quot;xdg&quot;&amp;gt;fonts&amp;lt;/dir&amp;gt;
    &amp;lt;!-- the following element will be removed in the future --&amp;gt;
    &amp;lt;dir&amp;gt;~/.fonts&amp;lt;/dir&amp;gt;

&amp;lt;!--
  Accept deprecated 'mono' alias, replacing it with 'monospace'
--&amp;gt;
    &amp;lt;match target=&quot;pattern&quot;&amp;gt;
        &amp;lt;test qual=&quot;any&quot; name=&quot;family&quot;&amp;gt;
            &amp;lt;string&amp;gt;mono&amp;lt;/string&amp;gt;
        &amp;lt;/test&amp;gt;
        &amp;lt;edit name=&quot;family&quot; mode=&quot;assign&quot; binding=&quot;same&quot;&amp;gt;
            &amp;lt;string&amp;gt;monospace&amp;lt;/string&amp;gt;
        &amp;lt;/edit&amp;gt;
    &amp;lt;/match&amp;gt;

&amp;lt;!--
  Accept alternate 'sans serif' spelling, replacing it with 'sans-serif'
--&amp;gt;
    &amp;lt;match target=&quot;pattern&quot;&amp;gt;
        &amp;lt;test qual=&quot;any&quot; name=&quot;family&quot;&amp;gt;
            &amp;lt;string&amp;gt;sans serif&amp;lt;/string&amp;gt;
        &amp;lt;/test&amp;gt;
        &amp;lt;edit name=&quot;family&quot; mode=&quot;assign&quot; binding=&quot;same&quot;&amp;gt;
            &amp;lt;string&amp;gt;sans-serif&amp;lt;/string&amp;gt;
        &amp;lt;/edit&amp;gt;
    &amp;lt;/match&amp;gt;

&amp;lt;!--
  Accept deprecated 'sans' alias, replacing it with 'sans-serif'
--&amp;gt;
    &amp;lt;match target=&quot;pattern&quot;&amp;gt;
        &amp;lt;test qual=&quot;any&quot; name=&quot;family&quot;&amp;gt;
            &amp;lt;string&amp;gt;sans&amp;lt;/string&amp;gt;
        &amp;lt;/test&amp;gt;
        &amp;lt;edit name=&quot;family&quot; mode=&quot;assign&quot; binding=&quot;same&quot;&amp;gt;
            &amp;lt;string&amp;gt;sans-serif&amp;lt;/string&amp;gt;
        &amp;lt;/edit&amp;gt;
    &amp;lt;/match&amp;gt;

&amp;lt;!--
  Ignore dpkg temporary files created in fonts directories
--&amp;gt;
    &amp;lt;selectfont&amp;gt;
        &amp;lt;rejectfont&amp;gt;
            &amp;lt;glob&amp;gt;*.dpkg-tmp&amp;lt;/glob&amp;gt;
        &amp;lt;/rejectfont&amp;gt;
    &amp;lt;/selectfont&amp;gt;
    &amp;lt;selectfont&amp;gt;
        &amp;lt;rejectfont&amp;gt;
            &amp;lt;glob&amp;gt;*.dpkg-new&amp;lt;/glob&amp;gt;
        &amp;lt;/rejectfont&amp;gt;
    &amp;lt;/selectfont&amp;gt;

&amp;lt;!--
  Load local system customization file
--&amp;gt;
    &amp;lt;include ignore_missing=&quot;yes&quot;&amp;gt;conf.d&amp;lt;/include&amp;gt;

&amp;lt;!-- Font cache directory list --&amp;gt;

    &amp;lt;cachedir&amp;gt;/var/cache/fontconfig&amp;lt;/cachedir&amp;gt;
    &amp;lt;cachedir prefix=&quot;xdg&quot;&amp;gt;fontconfig&amp;lt;/cachedir&amp;gt;
    &amp;lt;!-- the following element will be removed in the future --&amp;gt;
    &amp;lt;cachedir&amp;gt;~/.fontconfig&amp;lt;/cachedir&amp;gt;

    &amp;lt;config&amp;gt;
&amp;lt;!--
  Rescan configuration every 30 seconds when FcFontSetList is called
 --&amp;gt;
        &amp;lt;rescan&amp;gt;
            &amp;lt;int&amp;gt;30&amp;lt;/int&amp;gt;
        &amp;lt;/rescan&amp;gt;
    &amp;lt;/config&amp;gt;

&amp;lt;/fontconfig&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;&amp;lt;dir&amp;gt;&amp;lt;/dir&amp;gt;&lt;/code&gt;元素中的内容，就是指定字体的存放目录，从文件中可以看出，如果是我们自己下载的字体，可以直接放到&lt;code&gt;~/.fonts&lt;/code&gt;目录中，它是可以识别的；&lt;code&gt;&amp;lt;include&amp;gt;&amp;lt;/include&amp;gt;&lt;/code&gt;元素指定从&lt;code&gt;conf.d&lt;/code&gt;目录加载别的配置文件；&lt;code&gt;&amp;lt;cachedir&amp;gt;&amp;lt;/cachedir&amp;gt;&lt;/code&gt;元素指定缓存目录；&lt;code&gt;&amp;lt;selectfont&amp;gt;&amp;lt;rejectfont&amp;gt;&amp;lt;/rejectfont&amp;gt;&amp;lt;/selectfont&amp;gt;&lt;/code&gt;指定哪些字体需要排除，相当于设置黑名单，而&lt;code&gt;&amp;lt;selectfont&amp;gt;&amp;lt;acceptfont&amp;gt;&amp;lt;/acceptfont&amp;gt;&amp;lt;/selectfont&amp;gt;&lt;/code&gt;则明确指定哪些字体必须接受，相当于设置白名单；至于&lt;code&gt;&amp;lt;config&amp;gt;&amp;lt;rescan&amp;gt;&amp;lt;/rescan&amp;gt;&amp;lt;/config&amp;gt;&lt;/code&gt;，就是设置每隔多长时间重新扫描一次配置文件。由此可见，其语法真的是自解释的，一看就懂。关于其中的&lt;code&gt;&amp;lt;match&amp;gt;&amp;lt;/match&amp;gt;&lt;/code&gt;元素，后面再具体讲解。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;/etc/fonts/conf.d/&lt;/code&gt;目录中，有一个&lt;code&gt;50-user.conf&lt;/code&gt;配置文件，其内容如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&amp;gt;
&amp;lt;fontconfig&amp;gt;
    &amp;lt;!--
        Load per-user customization files where stored on XDG Base Directory
        specification compliant places. it should be usually:
          $HOME/.config/fontconfig/conf.d
          $HOME/.config/fontconfig/fonts.conf
    --&amp;gt;
    &amp;lt;include ignore_missing=&quot;yes&quot; prefix=&quot;xdg&quot;&amp;gt;fontconfig/conf.d&amp;lt;/include&amp;gt;
    &amp;lt;include ignore_missing=&quot;yes&quot; prefix=&quot;xdg&quot;&amp;gt;fontconfig/fonts.conf&amp;lt;/include&amp;gt;
    &amp;lt;!-- the following elements will be removed in the future --&amp;gt;
    &amp;lt;include ignore_missing=&quot;yes&quot; deprecated=&quot;yes&quot;&amp;gt;~/.fonts.conf.d&amp;lt;/include&amp;gt;
    &amp;lt;include ignore_missing=&quot;yes&quot; deprecated=&quot;yes&quot;&amp;gt;~/.fonts.conf&amp;lt;/include&amp;gt;
&amp;lt;/fontconfig&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个文件中，它还是使用了&lt;code&gt;&amp;lt;include&amp;gt;&amp;lt;/include&amp;gt;&lt;/code&gt;元素，只不过它这次指定的加载配置文件的地方是&lt;code&gt;~/.fonts.conf.d&lt;/code&gt;和&lt;code&gt;~/.fonts.conf&lt;/code&gt;，也就是说，我们可以把自己的配置文件放到自己的主目录下，Fontconfig 能够识别。&lt;/p&gt;
&lt;p&gt;在 Fontconfig 的配置文件中，重点是&lt;code&gt;&amp;lt;match&amp;gt;&amp;lt;/match&amp;gt;&lt;/code&gt;元素，它是对 pattern 进行修改的主要场所。它的基本格式是这样的：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;match target=&quot;目标&quot;&amp;gt;
    &amp;lt;test qual=&quot;any|all&quot; name=&quot;属性&quot; target=&quot;目标&quot; compare=&quot;比较&quot;&amp;gt;
    &amp;lt;/test&amp;gt;
    &amp;lt;edit name=&quot;属性&quot; mode=&quot;修改方式&quot; binding=&quot;绑定&quot;&amp;gt;
    &amp;lt;/edit&amp;gt;
&amp;lt;/match&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;match&amp;gt;&amp;lt;/match&amp;gt;&lt;/code&gt;必须首先包含一系列&lt;code&gt;&amp;lt;test&amp;gt;&amp;lt;/test&amp;gt;&lt;/code&gt;组成的列表，可以为空，然后再包含一系列&lt;code&gt;&amp;lt;edit&amp;gt;&amp;lt;/edit&amp;gt;&lt;/code&gt;组成的列表，可以为空，但是两种列表不能同时为空，而且&lt;code&gt;&amp;lt;test&amp;gt;&amp;lt;/test&amp;gt;&lt;/code&gt;列表必须位于&lt;code&gt;&amp;lt;edit&amp;gt;&amp;lt;/edit&amp;gt;&lt;/code&gt;列表之前。如果&quot;目标&quot;满足&lt;code&gt;&amp;lt;test&amp;gt;&amp;lt;/test&amp;gt;&lt;/code&gt;列表的所有测试条件（当 qual=&quot;all&quot; 时）或者列表中的任一测试条件（当 qual=&quot;any&quot; 时），那么将被按照&lt;code&gt;&amp;lt;edit&amp;gt;&amp;lt;/edit&amp;gt;&lt;/code&gt;列表中的指令序列进行修改。&quot;目标&quot;的默认值是&quot;pattern&quot;，表示此&lt;code&gt;&amp;lt;match&amp;gt;&lt;/code&gt;单元针对的是用于匹配的 pattern （第一次扫描）。如果&quot;目标&quot;的值是&quot;font&quot;，那么就表示此&lt;code&gt;&amp;lt;match&amp;gt;&lt;/code&gt;单元针对的是已被选定的字体（第二次扫描）。如果&quot;目标&quot;的值是&quot;scan&quot;，那么就表示此&lt;code&gt;&amp;lt;match&amp;gt;&lt;/code&gt;单元针对的是扫描字体以创建内部配置数据的初始化阶段。 &lt;code&gt;&amp;lt;test&amp;gt;&amp;lt;/test&amp;gt;&lt;/code&gt;用于和&quot;目标&quot;的&quot;属性&quot;进行&quot;比较&quot;。&quot;比较&quot;的默认值是&quot;eq&quot;[等于]，其他还有：&quot;not_eq&quot;[不等于]、 &quot;less&quot;[小于]、&quot;less_eq&quot;[小于等于]、&quot;more&quot;[大于]、 &quot;more_eq&quot;[大于等于]、&quot;contains&quot;[包含(用于字符串比较)]、&quot;not_contains&quot;[不包含(用于字符串比较)]。&lt;code&gt;&amp;lt;edit&amp;gt;&amp;lt;/edit&amp;gt;&lt;/code&gt;用于修改&quot;目标&quot;的&quot;属性&quot;值列表。&quot;绑定&quot;仅在 name=&quot;family&quot; 的情况下才有意义，其默认值是&quot;weak&quot;，表示弱绑定；若设为&quot;strong&quot;，则表示强绑定；而设为&quot;same&quot;，则表示不改变当前的绑定。至于如何修改，则与两个因素有关：(1)&quot;修改方式&quot;，(2)此&lt;code&gt;&amp;lt;edit&amp;gt;&lt;/code&gt;的&quot;属性&quot;是否与同&lt;code&gt;&amp;lt;match&amp;gt;&lt;/code&gt;内某个&lt;code&gt;&amp;lt;test&amp;gt;&lt;/code&gt;的&quot;属性&quot;相同。具体如下表所示：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&quot;assign&quot;(默认值)&lt;/td&gt;
&lt;td&gt;替换第一个匹配的值&lt;/td&gt;
&lt;td&gt;替换全部值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&quot;assign_replace&quot;&lt;/td&gt;
&lt;td&gt;替换全部值&lt;/td&gt;
&lt;td&gt;替换全部值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&quot;prepend&quot;&lt;/td&gt;
&lt;td&gt;在第一个匹配的值之前插入&lt;/td&gt;
&lt;td&gt;在值列表的首部插入&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&quot;prepend_first&quot;&lt;/td&gt;
&lt;td&gt;在值列表的首部插入&lt;/td&gt;
&lt;td&gt;在值列表的首部插入&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&quot;append&quot;&lt;/td&gt;
&lt;td&gt;在第一个匹配的值之后添加&lt;/td&gt;
&lt;td&gt;在值列表的尾部添加&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&quot;append_last&quot;&lt;/td&gt;
&lt;td&gt;在值列表的尾部添加&lt;/td&gt;
&lt;td&gt;在值列表的尾部添加&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&quot;delete&quot;&lt;/td&gt;
&lt;td&gt;删除第一个匹配的值&lt;/td&gt;
&lt;td&gt;删除全部值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&quot;delete_all&quot;&lt;/td&gt;
&lt;td&gt;删除全部值&lt;/td&gt;
&lt;td&gt;删除全部值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;除了&lt;code&gt;&amp;lt;match&amp;gt;&amp;lt;/match&amp;gt;&lt;/code&gt;元素之外，还有一个&lt;code&gt;&amp;lt;alias&amp;gt;&amp;lt;/alias&amp;gt;&lt;/code&gt;元素，其基本格式是这样的：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;alias binding=&quot;绑定&quot;&amp;gt;
    &amp;lt;family&amp;gt;&quot;需要替换的字体&quot;&amp;lt;/family&amp;gt;
    &amp;lt;prefer&amp;gt;
        &amp;lt;family&amp;gt;&quot;替换后的字体&quot;&amp;lt;/family&amp;gt;
        &amp;lt;family&amp;gt;&quot;替换后的字体&quot;&amp;lt;/family&amp;gt;
    &amp;lt;/prefer&amp;gt;
&amp;lt;/alias&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;alias&amp;gt;&amp;lt;/alias&amp;gt;&lt;/code&gt;元素相当于为修改字族名称提供了一种专门的速记法。在&lt;code&gt;&amp;lt;alias&amp;gt;&amp;lt;/alias&amp;gt;&lt;/code&gt;元素中，&lt;code&gt;&amp;lt;prefer&amp;gt;, &amp;lt;accept&amp;gt;, &amp;lt;default&amp;gt;&lt;/code&gt;就等于前面&quot;修改方式&quot;中的&quot;prepend&quot;、&quot;append&quot;、&quot;append_last&quot;。&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;fc-pattern&lt;/code&gt;命令查看 Fontconfig 对应用程序传递进来的 pattern 进行替换后的结果，也可以使用&lt;code&gt;fc-match&lt;/code&gt;命令查看 Fontconfig 最终返回给应用程序的字体列表。如下两图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180918170710949-1730151959.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180918170718668-102040516.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般情况下，排列在 pattern 最前面的字体会被选用，如果最前面的字体中没有满足条件的字符，则使用 pattern 中的下一个字体。我们使用这种思路对字体进行制定。例如，如果把 pattern 修改为 &lt;code&gt;&quot; WenQuanYi Bitmap Song&quot; &quot;Noto Serif CJK SC&quot;&lt;/code&gt;，那么应用程序会优先使用文泉驿点阵宋体，但是当字体的大小超出了文泉驿点阵宋体能够提供的范围时，就会使用后面的思源宋体。再例如，如果把 pattern 修改为 &lt;code&gt;&quot;verdana&quot; &quot;Noto Sans CJK SC&quot;&lt;/code&gt;，那么应用程序就会优先使用 verdana 显示英文字体，但是当要显示的字符超出了英文字符的范围时，就会使用后面的思源黑体。&lt;/p&gt;
&lt;p&gt;但是，binding 的设置会改变上面字体选择的过程。binding=&quot;strong&quot;、binding=&quot;weak&quot; 和 binding=&quot;same&quot; 分别有不同的效果。如果该属性设置不合理，则可能会出现这样的问题：明明使用 fc-pattern 查看的时候是 WenQuanYi Bitmap Song 排在 Noto Serif CJK SC 前面，是 Verdana 排在 Noto Sans CJK SC 前面，但是使用 fc-match 匹配的时候，偏偏首选的是 Noto Serif CJK SC 和 Noto Sans CJK SC。为什么会这样呢？这是因为 Fontconfig 选择字体的时候不仅仅只看字族名称的排列顺序，还要综合考虑一种字体能覆盖的字符集和字体大小范围，所以，在前面的例子中，虽然 WenQuanYi Bitmap Song 排在 Noto Serif CJK SC 前面，但是它覆盖的字体大小范围只有 12px 到 16px，Verdana 虽然排在 Noto Sans CJK SC 前面，但是其覆盖的字符集不包含中日韩文，所以 Fontconfig 就会首选排在后面的字体。为了解决这个问题，就必须把 binding 属性设置为 strong，这样，不管什么情况都首选排在前面的字体，只有遇到该字体不能胜任的字符时才选择后面的字体。在我的配置文件中，我都是一路 strong 到底。&lt;/p&gt;
&lt;p&gt;现在的 Linux 桌面发行版在使用 Fontconfig 配置字体的时候，都有固定的流程。我们进入&lt;code&gt;/etc/fonts/conf.d&lt;/code&gt;目录看一下，发现里面有 90 多个配置文件，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180917160706378-257878212.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一个文件名前面都有一个数字，数字可以决定配置文件的加载顺序，而 Fontconfig 在对 pattern 进行替换时，就是按照&lt;code&gt;&amp;lt;match&amp;gt;&amp;lt;/match&amp;gt;&lt;/code&gt;元素出现的先后顺序进行的。在该目录下，还有一个&lt;code&gt;README&lt;/code&gt;文件，看一下其中的内容，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180917160723775-1477725954.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中明确说明了系统字体配置的整个流程。00 到 09 开头的配置文件，用于设置字体文件的存放目录，在 Ubuntu 18.04 中，没有 00 到 09 开头的配置文件。10 到 19 开头的文件用于设置系统中字体的全局配置选项，例如 antialias、hintstyle 等属性，对系统中所有的字体有效。20 到 29 是针对特定字体设置属性，只对配置文件中指定的字体有效。30 到 39 是字体族的替换，用于把某一个字体替换成另外一个字体。40 到 49 是对字体进行分类，这样，当系统中找不到某一个字体时，可以用同一类别的字体进行代替。50 到 59 载入用户自定义的配置文件。60 到 69 是把字体分类进行填实。40 到 49 和 60 到 69 是互相配合的。例如，当应用程序要求的字体是微软雅黑，就会向 Fontconfig 提交一个 pattern &lt;code&gt;&quot;微软雅黑&quot;&lt;/code&gt;，而 Fontconfig 发现系统中没有微软雅黑字体，他就会对这个字进行分类，微软雅黑肯定是属于 sans-serif 分类的，所以 40 到 49 开头的配置文件就会把 pattern 修改为&lt;code&gt;&quot;微软雅黑&quot; &quot;sans-serif&quot;&lt;/code&gt;。然后，到了 60 到 69 开头的配置文件，它发现 pattern 中有&quot;sans-serif&quot;，但这只是个分类名，不是一个具体的字体名，它需要对这个分类进行填实，怎么填呢？可以把&quot;Noto Sans CJK SC&quot;放到&quot;sans-serif&quot;的前面。这时，pattern 被修改为&lt;code&gt;&quot;微软雅黑&quot; &quot;Noto Sans CJK SC&quot; &quot;sans-serif&quot;&lt;/code&gt;。这就是系统中字体先分类再填实分类的过程，当然 Ubuntu 18.04 中需要分类的字体和用来填实分类的字体更多，这个替换后的 pattern 会更复杂，这是因为 Ubuntu 18.04 是一个面向全球的发行版，它必须考虑到所有可能的语言。而我们自己的系统只需要满足自己的需求就可以了，其实系统中的很多配置文件是可以裁减掉的。如果要看完全不用系统自带的配置文件，全部自己定义字体的过程，可以看我 2014 年写的&lt;a href=&quot;https://www.cnblogs.com/youxia/p/linux004.html&quot;&gt;Linux 桌面系统字体配置要略&lt;/a&gt;，里面是用 Fedora 20 做的示范。后来我就变懒了，再改系统的字体我只做加法，只在&lt;code&gt;~/.fonts.conf.d&lt;/code&gt;目录中放少数几个配置文件了事。70 到 79 开头的配置文件对可用的字体做进一步的调整，明确指定选择哪些字体或排除哪些字体。80 到 89 定义 scan 阶段对字体属性的修改。90 到 99 定义字体合成。其实在 Ubuntu 18.04 中，70 到 99 开头的配置文件并没有严格遵守这些约定。&lt;/p&gt;
&lt;p&gt;系统中的配置文件很多，下面挑少数几个学习以下。先看&lt;code&gt;10-antialias.conf&lt;/code&gt;，内容如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&amp;gt;
&amp;lt;fontconfig&amp;gt;
&amp;lt;!--  Use the Antialiasing --&amp;gt;
  &amp;lt;match target=&quot;pattern&quot;&amp;gt;
    &amp;lt;edit name=&quot;antialias&quot; mode=&quot;append&quot;&amp;gt;&amp;lt;bool&amp;gt;true&amp;lt;/bool&amp;gt;&amp;lt;/edit&amp;gt;
  &amp;lt;/match&amp;gt;
&amp;lt;/fontconfig&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个文件最简单，只有一个&lt;code&gt;&amp;lt;match&amp;gt;&amp;lt;/match&amp;gt;&lt;/code&gt;元素，而且里面的&lt;code&gt;&amp;lt;test&amp;gt;&amp;lt;/test&amp;gt;&lt;/code&gt;元素为空，就是说，这个配置文件将所有字体的 antialias 属性设置为 true。而 20 开头的配置文件都是针对单个字体的属性进行设置的，例如&lt;code&gt;20-unhint-small-dejavu-serif.conf&lt;/code&gt;，其内容如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE fontconfig SYSTEM &quot;../fonts.dtd&quot;&amp;gt;
&amp;lt;fontconfig&amp;gt;
  &amp;lt;match target=&quot;font&quot;&amp;gt;
    &amp;lt;test name=&quot;family&quot;&amp;gt;
      &amp;lt;string&amp;gt;DejaVu Serif&amp;lt;/string&amp;gt;
    &amp;lt;/test&amp;gt;
    &amp;lt;test compare=&quot;less&quot; name=&quot;pixelsize&quot;&amp;gt;
      &amp;lt;double&amp;gt;7.5&amp;lt;/double&amp;gt;
    &amp;lt;/test&amp;gt;
    &amp;lt;edit name=&quot;hinting&quot;&amp;gt;
      &amp;lt;bool&amp;gt;false&amp;lt;/bool&amp;gt;
    &amp;lt;/edit&amp;gt;
  &amp;lt;/match&amp;gt;
&amp;lt;/fontconfig&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该配置设置当字体为 DejaVu Serif，pixelsize 小于 7.5 的时候，将 hinting 属性设置为 false。30 到 39 开头的配置文件用于字体替换，其中最复杂的是&lt;code&gt;30-metric-alias.conf&lt;/code&gt;，就是对常用的一些英文字体进行交叉替换，这样，当某种字体缺乏的时候，可以马上用另外一个字体替代。这个配置文件太长了，我就不贴了。贴个短一点的，&lt;code&gt;35-arphic-uming-alias.conf&lt;/code&gt;，内容如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&amp;gt;
&amp;lt;fontconfig&amp;gt;
    &amp;lt;alias binding=&quot;same&quot;&amp;gt;
      &amp;lt;family&amp;gt;AR PL ShanHeiSun Uni&amp;lt;/family&amp;gt;
      &amp;lt;prefer&amp;gt;&amp;lt;family&amp;gt;AR PL UMing HK&amp;lt;/family&amp;gt;&amp;lt;/prefer&amp;gt;
    &amp;lt;/alias&amp;gt;

    &amp;lt;alias binding=&quot;same&quot;&amp;gt;
      &amp;lt;family&amp;gt;AR PL ShanHeiSun Uni MBE&amp;lt;/family&amp;gt;
      &amp;lt;prefer&amp;gt;&amp;lt;family&amp;gt;AR PL UMing TW MBE&amp;lt;/family&amp;gt;&amp;lt;/prefer&amp;gt;
    &amp;lt;/alias&amp;gt;
&amp;lt;/fontconfig&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是设置为当 pattern 中有 AR PL ShanHeiSun Uni 时，将 AR PL Uming HK 放到它的前面。这里使用了&lt;code&gt;&amp;lt;alias&amp;gt;&lt;/code&gt;简写语法。&lt;/p&gt;
&lt;p&gt;40 到 49 开头的配置文件对字体进行分类，这里也大量使用&lt;code&gt;&amp;lt;alias&amp;gt;&lt;/code&gt;简写语法。例如&lt;code&gt;45-latin.conf&lt;/code&gt;对所有的英文字体进行分类，因为要分类的字体特别多，多以该文件特别长。分类的方法，就是把 serif、sans-serif、monospace 这样的分类名添加到 pattern 的最后。内容如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&amp;gt;
&amp;lt;fontconfig&amp;gt;
&amp;lt;!--
  Mark common families with their generics so we'll get
  something reasonable
--&amp;gt;

&amp;lt;!--
  Serif faces
 --&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Bitstream Vera Serif&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Cambria&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Constantia&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;DejaVu Serif&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Elephant&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Garamond&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Georgia&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Liberation Serif&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Luxi Serif&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;MS Serif&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Nimbus Roman No9 L&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Nimbus Roman&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Palatino Linotype&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Thorndale AMT&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Thorndale&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Times New Roman&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Times&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
&amp;lt;!--
  Sans-serif faces
 --&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Albany AMT&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Albany&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Arial Unicode MS&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Arial&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Bitstream Vera Sans&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Britannic&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Calibri&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Candara&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Century Gothic&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Corbel&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;DejaVu Sans&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Helvetica&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Haettenschweiler&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Liberation Sans&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;MS Sans Serif&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Nimbus Sans L&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Nimbus Sans&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Luxi Sans&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Tahoma&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Trebuchet MS&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Twentieth Century&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Verdana&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
&amp;lt;!--
  Monospace faces
 --&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Andale Mono&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;monospace&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Bitstream Vera Sans Mono&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;monospace&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Consolas&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;monospace&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Courier New&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;monospace&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Courier&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;monospace&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Cumberland AMT&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;monospace&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Cumberland&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;monospace&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;DejaVu Sans Mono&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;monospace&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Fixedsys&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;monospace&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Inconsolata&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;monospace&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Liberation Mono&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;monospace&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Luxi Mono&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;monospace&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Nimbus Mono L&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;monospace&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Nimbus Mono&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;monospace&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Nimbus Mono PS&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;monospace&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Terminal&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;monospace&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
&amp;lt;!--
  Fantasy faces
 --&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Bauhaus Std&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;fantasy&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Cooper Std&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;fantasy&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Copperplate Gothic Std&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;fantasy&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Impact&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;fantasy&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
&amp;lt;!--
  Cursive faces
  --&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Comic Sans MS&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;cursive&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;ITC Zapf Chancery Std&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;cursive&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;Zapfino&amp;lt;/family&amp;gt;
        &amp;lt;default&amp;gt;&amp;lt;family&amp;gt;cursive&amp;lt;/family&amp;gt;&amp;lt;/default&amp;gt;
    &amp;lt;/alias&amp;gt;

&amp;lt;/fontconfig&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;肯定是不可能列出世界上所有的字体的，所以总会有不认识的字体。&lt;code&gt;49-sansserif.conf&lt;/code&gt;配置文件就设置将所有不认识的字体，都分类为 sans-serif。内容如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&amp;gt;
&amp;lt;fontconfig&amp;gt;
&amp;lt;!--
  If the font still has no generic name, add sans-serif
 --&amp;gt;
    &amp;lt;match target=&quot;pattern&quot;&amp;gt;
        &amp;lt;test qual=&quot;all&quot; name=&quot;family&quot; compare=&quot;not_eq&quot;&amp;gt;
            &amp;lt;string&amp;gt;sans-serif&amp;lt;/string&amp;gt;
        &amp;lt;/test&amp;gt;
        &amp;lt;test qual=&quot;all&quot; name=&quot;family&quot; compare=&quot;not_eq&quot;&amp;gt;
            &amp;lt;string&amp;gt;serif&amp;lt;/string&amp;gt;
        &amp;lt;/test&amp;gt;
        &amp;lt;test qual=&quot;all&quot; name=&quot;family&quot; compare=&quot;not_eq&quot;&amp;gt;
            &amp;lt;string&amp;gt;monospace&amp;lt;/string&amp;gt;
        &amp;lt;/test&amp;gt;
        &amp;lt;edit name=&quot;family&quot; mode=&quot;append_last&quot;&amp;gt;
            &amp;lt;string&amp;gt;sans-serif&amp;lt;/string&amp;gt;
        &amp;lt;/edit&amp;gt;
    &amp;lt;/match&amp;gt;
&amp;lt;/fontconfig&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释一下就是说，一个 pattern 中既没有 sans-serif，又没有 serif，也没有 monospace，就说明这个 pattern 还没有被分类，没有被分类的原因肯定是出现了前面配置文件中没有见过的字体名称。那么，将 sans-serif 添加到这个 pattern 的最后。相当于把不认识的字体都分类为 sans-seirf。&lt;/p&gt;
&lt;p&gt;而对分类进行填实，可以看一下&lt;code&gt;60-latin.conf&lt;/code&gt;，内容如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&amp;gt;
&amp;lt;fontconfig&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;serif&amp;lt;/family&amp;gt;
        &amp;lt;prefer&amp;gt;
            &amp;lt;family&amp;gt;DejaVu Serif&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Bitstream Vera Serif&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Times New Roman&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Thorndale AMT&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Luxi Serif&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Nimbus Roman No9 L&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Nimbus Roman&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Times&amp;lt;/family&amp;gt;
        &amp;lt;/prefer&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;sans-serif&amp;lt;/family&amp;gt;
        &amp;lt;prefer&amp;gt;
            &amp;lt;family&amp;gt;DejaVu Sans&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Bitstream Vera Sans&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Verdana&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Arial&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Albany AMT&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Luxi Sans&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Nimbus Sans L&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Nimbus Sans&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Helvetica&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Lucida Sans Unicode&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;BPG Glaho International&amp;lt;/family&amp;gt; &amp;lt;!-- lat,cyr,arab,geor --&amp;gt;
            &amp;lt;family&amp;gt;Tahoma&amp;lt;/family&amp;gt; &amp;lt;!-- lat,cyr,greek,heb,arab,thai --&amp;gt;
        &amp;lt;/prefer&amp;gt;
    &amp;lt;/alias&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;monospace&amp;lt;/family&amp;gt;
        &amp;lt;prefer&amp;gt;
            &amp;lt;family&amp;gt;DejaVu Sans Mono&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Bitstream Vera Sans Mono&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Inconsolata&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Andale Mono&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Courier New&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Cumberland AMT&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Luxi Mono&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Nimbus Mono L&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Nimbus Mono&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Nimbus Mono PS&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Courier&amp;lt;/family&amp;gt;
        &amp;lt;/prefer&amp;gt;
    &amp;lt;/alias&amp;gt;
&amp;lt;!--
  Fantasy faces
 --&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;fantasy&amp;lt;/family&amp;gt;
        &amp;lt;prefer&amp;gt;
            &amp;lt;family&amp;gt;Impact&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Copperplate Gothic Std&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Cooper Std&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Bauhaus Std&amp;lt;/family&amp;gt;
        &amp;lt;/prefer&amp;gt;
    &amp;lt;/alias&amp;gt;
&amp;lt;!--
  Cursive faces
  --&amp;gt;
    &amp;lt;alias&amp;gt;
        &amp;lt;family&amp;gt;cursive&amp;lt;/family&amp;gt;
        &amp;lt;prefer&amp;gt;
            &amp;lt;family&amp;gt;ITC Zapf Chancery Std&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Zapfino&amp;lt;/family&amp;gt;
            &amp;lt;family&amp;gt;Comic Sans MS&amp;lt;/family&amp;gt;
        &amp;lt;/prefer&amp;gt;
    &amp;lt;/alias&amp;gt;

&amp;lt;/fontconfig&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里也大量使用&lt;code&gt;&amp;lt;alias&amp;gt;&lt;/code&gt;简写语法。很显然，这只是对英文字体进行填实，不能满足我中文用户的需要。对中文字体进行填实，请看&lt;code&gt;69-language-selector-zh-cn.conf&lt;/code&gt;的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&amp;gt;
&amp;lt;fontconfig&amp;gt;

    &amp;lt;match target=&quot;pattern&quot;&amp;gt;
        &amp;lt;test name=&quot;lang&quot;&amp;gt;
            &amp;lt;string&amp;gt;zh-cn&amp;lt;/string&amp;gt;
        &amp;lt;/test&amp;gt;
        &amp;lt;test qual=&quot;any&quot; name=&quot;family&quot;&amp;gt;
            &amp;lt;string&amp;gt;serif&amp;lt;/string&amp;gt;
        &amp;lt;/test&amp;gt;
        &amp;lt;edit name=&quot;family&quot; mode=&quot;prepend&quot; binding=&quot;strong&quot;&amp;gt;
            &amp;lt;string&amp;gt;Noto Serif CJK SC&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;HYSong&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;AR PL UMing CN&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;AR PL UMing HK&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;AR PL New Sung&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;WenQuanYi Bitmap Song&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;AR PL UKai CN&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;AR PL ZenKai Uni&amp;lt;/string&amp;gt;
        &amp;lt;/edit&amp;gt;
    &amp;lt;/match&amp;gt; 
    &amp;lt;match target=&quot;pattern&quot;&amp;gt;
        &amp;lt;test qual=&quot;any&quot; name=&quot;family&quot;&amp;gt;
            &amp;lt;string&amp;gt;sans-serif&amp;lt;/string&amp;gt;
        &amp;lt;/test&amp;gt;
        &amp;lt;test name=&quot;lang&quot;&amp;gt;
            &amp;lt;string&amp;gt;zh-cn&amp;lt;/string&amp;gt;
        &amp;lt;/test&amp;gt;
        &amp;lt;edit name=&quot;family&quot; mode=&quot;prepend&quot; binding=&quot;strong&quot;&amp;gt;
            &amp;lt;string&amp;gt;Noto Sans CJK SC&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;WenQuanYi Zen Hei&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;HYSong&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;AR PL UMing CN&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;AR PL UMing HK&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;AR PL New Sung&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;AR PL UKai CN&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;AR PL ZenKai Uni&amp;lt;/string&amp;gt;
        &amp;lt;/edit&amp;gt;
    &amp;lt;/match&amp;gt; 
    &amp;lt;match target=&quot;pattern&quot;&amp;gt;
        &amp;lt;test qual=&quot;any&quot; name=&quot;family&quot;&amp;gt;
            &amp;lt;string&amp;gt;monospace&amp;lt;/string&amp;gt;
        &amp;lt;/test&amp;gt;
        &amp;lt;test name=&quot;lang&quot;&amp;gt;
            &amp;lt;string&amp;gt;zh-cn&amp;lt;/string&amp;gt;
        &amp;lt;/test&amp;gt;
        &amp;lt;edit name=&quot;family&quot; mode=&quot;prepend&quot; binding=&quot;strong&quot;&amp;gt;
            &amp;lt;string&amp;gt;DejaVu Sans Mono&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;Noto Sans Mono CJK SC&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;WenQuanYi Zen Hei Mono&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;HYSong&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;AR PL UMing CN&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;AR PL UMing HK&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;AR PL New Sung&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;AR PL UKai CN&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;AR PL ZenKai Uni&amp;lt;/string&amp;gt;
        &amp;lt;/edit&amp;gt;
    &amp;lt;/match&amp;gt; 

&amp;lt;/fontconfig&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们常见的中文字体基本上都在这里了。&lt;/p&gt;
&lt;p&gt;最后再学习两个配置文件，一个是&lt;code&gt;70-no-bitmaps.conf&lt;/code&gt;，内容如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&amp;gt;
&amp;lt;fontconfig&amp;gt;
&amp;lt;!-- Reject bitmap fonts --&amp;gt;
 &amp;lt;selectfont&amp;gt;
  &amp;lt;rejectfont&amp;gt;
   &amp;lt;pattern&amp;gt;
     &amp;lt;patelt name=&quot;scalable&quot;&amp;gt;&amp;lt;bool&amp;gt;false&amp;lt;/bool&amp;gt;&amp;lt;/patelt&amp;gt;
   &amp;lt;/pattern&amp;gt;
  &amp;lt;/rejectfont&amp;gt;
 &amp;lt;/selectfont&amp;gt;
&amp;lt;/fontconfig&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里出现了一个新元素&lt;code&gt;&amp;lt;patelt name=...&amp;gt;&lt;/code&gt;，这个元素配置单个属性，但是其子元素可以是一个列表。上面这个配置文件就是说，凡是 scalable 属性为 false 的字体，都被 reject 掉，也就是不使用任何不可缩放的字体。而我们的 WenQuanYi Bitmap Song 恰恰就是这样一个不可缩放的点阵字体，怎么办？&lt;code&gt;85-xfonts-wqy-1.conf&lt;/code&gt;这个配置文件就使用&lt;code&gt;&amp;lt;acceptfont&amp;gt;&lt;/code&gt;元素为这个字体开了绿灯，内容如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&amp;gt;
&amp;lt;!-- WenQuanYi Bitmap Font for CJK users --&amp;gt;
&amp;lt;fontconfig&amp;gt;

&amp;lt;!--
    Enable WenQuanYi Bitmap Song only
--&amp;gt;
    &amp;lt;selectfont&amp;gt;
        &amp;lt;acceptfont&amp;gt;
            &amp;lt;pattern&amp;gt;
                 &amp;lt;patelt name=&quot;family&quot;&amp;gt;&amp;lt;string&amp;gt;WenQuanYi Bitmap Song&amp;lt;/string&amp;gt;&amp;lt;/patelt&amp;gt;
            &amp;lt;/pattern&amp;gt;
        &amp;lt;/acceptfont&amp;gt;
    &amp;lt;/selectfont&amp;gt;

&amp;lt;/fontconfig&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，对 Fontconfig 的学习就到这里吧。下面开始实战。&lt;/p&gt;
&lt;h2 id=&quot;配置-ubuntu-18.04-的字体&quot;&gt;配置 Ubuntu 18.04 的字体&lt;/h2&gt;
&lt;p&gt;前面提到的所有 Linux 发行版都安装有 Times New Roman 字体，但是没有 Georgia、Verdana、Arial。后面这几个字体是微软公司设计的 webcore 字体，可以免费使用。而中文的 SimSun 和微软雅黑是不能免费使用的，我们只能用思源宋体和思源黑体。思源宋体没有点阵，不过没关系，我们可以使用文泉驿点阵宋体替代。使用如下命令安装文泉驿字体和 webcore 字体：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo aptitude install fonts-wqy-microhei fonts-wqy-zenhei xfonts-wqy
sudo aptitude install ttf-mscorefonts-installer&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下两图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180917162024151-389544589.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180917162032219-575722950.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完毕之后，我们系统中就多了以下几种字体，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180917162221351-535993310.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后进行配置。思路是这样的：&lt;/p&gt;
&lt;p&gt;1、先修改全局配置，将 dpi 改为 96。而 hinting 和抗锯齿是在 gnome-tweak-tool中设置的，还比较令人满意，就不改了。&lt;/p&gt;
&lt;p&gt;2、 宋体和 serif 字体都使用思源宋体 Noto Serif CJK SC，但是宋体在小字时需要点阵，serif 在小字时不需要点阵。为什么呢？因为当页面设计者把字体设置为宋体时，他肯定是针对中文设计的，但是如果他设置为 serif，则一定是针对英语设计的，而英文字体往往没有点阵，搭配点阵的宋体并不好看。Times New Roman 和 Georgia 在英文的时候当然显示为 Times New Roman 和 Georgia，但是这两个字体没有中文，所以要把 Noto Serif CJK SC 添加到这两个字体的后面，当这两个字体中夹杂中文时，就显示为思源宋体。同理，如果页面设计者将字体设置为 Times New Roman 或者 Georgia，他肯定是针对英文设计的，所以其中夹杂的中文也不需要点阵。&lt;/p&gt;
&lt;p&gt;3、黑体、微软雅黑、Verdana、Arial 和 sans-serif，完全不需要做任何修改，保持 Ubuntu 18.04 默认的配置就行了，不需要做任何修改，也不要试图给 sans-serif 的中文添加点阵，理由还是和上一条中说的一样，中文使用点阵是很漂亮的，但是和没有点阵的英文搭配时，就不是那么和谐了。&lt;/p&gt;
&lt;p&gt;所以，我们只需要两个配置文件就行了。根据上一节的学习我们知道了，只需要把配置文件放到&lt;code&gt;~/.fonts.conf.d/&lt;/code&gt;目录下就行了，为了配合系统字体配置文件的命名规律，我把它命名为&lt;code&gt;10-dpi.conf&lt;/code&gt;和&lt;code&gt;68-serif.conf&lt;/code&gt;，在第一个文件中，把 dpi 改成 96，在第二个文件中，针对 serif、Times New Roman、Georgia、宋体和 SimSun 进行配置，如下。&lt;/p&gt;
&lt;p&gt;使用 gnome-tweak-tool 设置 hinting 和抗锯齿，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180917164301688-2013120876.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更改 dpi 的配置文件&lt;code&gt;~/.fonts.conf.d/10-dpi.conf&lt;/code&gt;的内容如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&amp;gt;
&amp;lt;fontconfig&amp;gt;
&amp;lt;!--  Use the Antialiasing --&amp;gt;
  &amp;lt;match target=&quot;pattern&quot;&amp;gt;
    &amp;lt;edit name=&quot;dpi&quot; mode=&quot;assign&quot;&amp;gt;&amp;lt;double&amp;gt;96&amp;lt;/double&amp;gt;&amp;lt;/edit&amp;gt;
  &amp;lt;/match&amp;gt;
&amp;lt;/fontconfig&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更改好 dpi 之后，使用&lt;code&gt;fc-match&lt;/code&gt;查看字体，可以看到 12pt 的字的 pixelsize 是 16，能用更多的像素去渲染一个字，效果当然要好一些。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180917164519227-185933031.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置宋体及 serif 的文件&lt;code&gt;~/fonts.conf.d/68-serif.conf&lt;/code&gt;的内容如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE fontconfig SYSTEM &quot;../fonts.dtd&quot;&amp;gt;
&amp;lt;fontconfig&amp;gt;
    &amp;lt;match target=&quot;pattern&quot;&amp;gt;
        &amp;lt;test name=&quot;family&quot;&amp;gt;
            &amp;lt;string&amp;gt;serif&amp;lt;/string&amp;gt;
        &amp;lt;/test&amp;gt;
        &amp;lt;edit name=&quot;family&quot; mode=&quot;assign&quot; binding=&quot;strong&quot;&amp;gt;
            &amp;lt;string&amp;gt;Noto Serif CJK SC&amp;lt;/string&amp;gt;
        &amp;lt;/edit&amp;gt;
    &amp;lt;/match&amp;gt;
    &amp;lt;match target=&quot;pattern&quot;&amp;gt;
        &amp;lt;test name=&quot;family&quot;&amp;gt;
            &amp;lt;string&amp;gt;宋体&amp;lt;/string&amp;gt;
        &amp;lt;/test&amp;gt;
        &amp;lt;edit name=&quot;family&quot; mode=&quot;assign&quot; binding=&quot;strong&quot;&amp;gt;
            &amp;lt;string&amp;gt;WenQuanYi Bitmap Song&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;Noto Serif CJK SC&amp;lt;/string&amp;gt;
        &amp;lt;/edit&amp;gt;
    &amp;lt;/match&amp;gt;
    &amp;lt;match target=&quot;pattern&quot;&amp;gt;
        &amp;lt;test name=&quot;family&quot;&amp;gt;
            &amp;lt;string&amp;gt;SimSun&amp;lt;/string&amp;gt;
        &amp;lt;/test&amp;gt;
        &amp;lt;edit name=&quot;family&quot; mode=&quot;assign&quot; binding=&quot;strong&quot;&amp;gt;
            &amp;lt;string&amp;gt;WenQuanYi Bitmap Song&amp;lt;/string&amp;gt;
            &amp;lt;string&amp;gt;Noto Serif CJK SC&amp;lt;/string&amp;gt;
        &amp;lt;/edit&amp;gt;
    &amp;lt;/match&amp;gt;
    &amp;lt;match target=&quot;pattern&quot;&amp;gt;
        &amp;lt;test name=&quot;family&quot;&amp;gt;
            &amp;lt;string&amp;gt;Times New Roman&amp;lt;/string&amp;gt;
        &amp;lt;/test&amp;gt;
        &amp;lt;edit name=&quot;family&quot; mode=&quot;append&quot; binding=&quot;strong&quot;&amp;gt;
            &amp;lt;string&amp;gt;Noto Serif CJK SC&amp;lt;/string&amp;gt;
        &amp;lt;/edit&amp;gt;
    &amp;lt;/match&amp;gt;
    &amp;lt;match target=&quot;pattern&quot;&amp;gt;
        &amp;lt;test name=&quot;family&quot;&amp;gt;
            &amp;lt;string&amp;gt;Georgia&amp;lt;/string&amp;gt;
        &amp;lt;/test&amp;gt;
        &amp;lt;edit name=&quot;family&quot; mode=&quot;append&quot; binding=&quot;strong&quot;&amp;gt;
            &amp;lt;string&amp;gt;Noto Serif CJK SC&amp;lt;/string&amp;gt;
        &amp;lt;/edit&amp;gt;
    &amp;lt;/match&amp;gt;
&amp;lt;/fontconfig&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置完成后的效果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180917164812017-1932416826.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是我认为的最完美的效果。宋体、Serif 都显示为思源宋体，Georgia 和 Times New Roman 只有中文显示为思源宋体，而且，只有明确将字体指定为宋体或 SimSun 的字，才有点阵，而指定为 Serif、Georgia 和 Times New Roman 的字，没有点阵。黑体、微软雅黑、sans-serif 都显示为思源黑体，Verdana 和 Arial 的中文部分显示为思源黑体，都没有点阵。&lt;/p&gt;
&lt;p&gt;为什么说如果页面设计者指定字体为宋体时最好用点阵呢？以新浪网首页为例就可以说明问题。如果我们的系统中宋体没有点阵，页面效果是这样的：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180917165842988-1515226144.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仔细看这个页面的效果，上半部分是分类导航，页面设计者指定的字体是微软雅黑，所以没有点阵显示得也很饱满，但是下半部分是新闻标题，页面设计者指定的字体是宋体，显示就很虚。如果我们的系统中宋体有点阵，看起来就会漂亮不少，效果是这样的：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180917170005984-2096884916.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么说黑体、微软雅黑以及英文字体不需要点阵呢？以我自己的博客为例就可以说明问题。我的博客字体用的是 verdana 搭配微软雅黑。如果设置了黑体显示点阵（这里使用文泉驿点阵正黑），效果是这样的：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180917170233206-1341539666.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当使用点阵时，中文字还是显示得很漂亮。但是，一和英文字体搭配，就不是那么协调了。如果都不用点阵，效果如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201809/16576-20180917170409270-906148248.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;中文和英文都很饱满，而且饱满程度基本一致，看起来非常协调。这就是我在 Ubuntu 18.04 中的最终配置，看博客和写博客都很舒服哦。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这篇随笔篇幅很长。先是用了很大的篇幅来展示各 Linux 桌面发行版的字体配置情况，充分展示了 Linux 桌面字体的历史变迁，还是很值得一看的。其次又用了很大的篇幅来介绍 Fontconfig 的配置语法，以及 Linux 桌面发行版中字体配置的思路和流程。最后，才在 Ubuntu 18.04 中进行字体配置实战，实战只占了很少的篇幅。但是，我认为前面的铺垫都是非常有意义的，我们只要充分掌握了 Fontconfig 的配置语法、Linux 桌面字体配置的思路和流程，那么，在字体配置方面，真的就可以为所欲为了。&lt;/p&gt;
&lt;h2 id=&quot;求打赏&quot;&gt;求打赏&lt;/h2&gt;
&lt;p&gt;我对这次写的这个系列要求是非常高的：首先内容要有意义、够充实，信息量要足够丰富；其次是每一个知识点要讲透彻，不能模棱两可含糊不清；最后是包含丰富的截图，让那些不想装 Linux 系统的朋友们也可以领略到 Linux 桌面的风采。如果我的努力得到大家的认可，可以扫下面的二维码打赏一下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/16576/201808/16576-20180831154735325-1276475036.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;版权申明&quot;&gt;版权申明&lt;/h2&gt;
&lt;p&gt;该随笔由京山游侠在2018年09月19日发布于博客园，引用请注明出处，转载或出版请联系博主。QQ邮箱：1841079@qq.com&lt;/p&gt;
</description>
<pubDate>Tue, 18 Sep 2018 22:36:00 +0000</pubDate>
<dc:creator>京山游侠</dc:creator>
<og:description>特别说明： 要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用 标记数学公式的开始和结束。如果某条评论中出现了两个 ，MathJax 会将两个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youxia/p/LinuxDesktop004.html</dc:identifier>
</item>
<item>
<title>[编译] 5、在Linux下搭建安卓APP的开发烧写环境（makefile版）—— 在Linux上用命令行+VIM开发安卓APP - beautifulzzzz</title>
<link>http://www.cnblogs.com/zjutlitao/p/9672376.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjutlitao/p/9672376.html</guid>
<description>&lt;p&gt;星期三, 19. 九月 2018 02:19上午 - BEAUTIFULZZZZ&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;br/&gt;&lt;strong&gt;0）前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文不讨论用IDE和文本编辑器开发的优劣，是基于以下两点考虑去尝试用命令行编译安卓APP的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;了解安卓APP的编译过程，了解IDE干了什么事；&lt;/li&gt;
&lt;li&gt;放在打包服务器上需要自动化生成APP的脚本；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1）安装配置环境&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;12.461419753086&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;安装java&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  sudo apt-get install openjdk-8-jdk-headless&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt; 安装之前先要卸载之前版本的java，否则会报错!!! [error-1].&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;安装SDK tools&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  wget https://dl.google.com/android/repository/sdk-tools-linux-3859397.zip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建议将其解压到&lt;code&gt;/opt&lt;/code&gt;目录下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  mkdir -p /opt/android-sdk
  unzip sdk-tools-linux-3859397.zip -d /opt/android-sdk&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;21.409568874869&quot;&gt;
&lt;p&gt;用sdkmanager安装SDK&lt;sup&gt;&lt;a href=&quot;https://developer.android.com/studio/command-line/sdkmanager&quot;&gt;(#1)&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;sdkmanager是用来查看、安装、更新、卸载Android SDK的命令行工具，官方说明如下：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;The sdkmanager is a command line tool that allows you to view, install, update, and uninstall packages for the Android SDK.&lt;br/&gt;The sdkmanager tool is provided in the Android SDK Tools package (25.2.3 and higher) and is located in android_sdk/tools/bin/.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;列出Installed packages和Available Packages，查看包安装情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  cd /opt/android-sdk/tools/bin
  ./sdkmanager --list&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装platform tools 19（写文章时最新的是26），该工具包含adb和fastboot，该工具对应的API级别也是19：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  ./sdkmanager &quot;platform-tools&quot; &quot;platforms;android-19&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装build tools 26.0.1（最新的），该工具包含aapt、apksigner、zipalign等编译、认证、打包工具：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  ./sdkmanager &quot;platform-tools&quot; &quot;build-tools;26.0.1&quot; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后你会在/opt/android-sdk/中看到build-tools、paltforms、tools三个文件夹～&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2）编写简单Hello World程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建工程文件夹&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd ~/Downloads/
mkdir HelloAndroid
cd HelloAndroid&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建工程文件tree&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p src/com/example/helloandroid
mkdir obj
mkdir bin
mkdir -p res/layout
mkdir res/values
mkdir res/drawable&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Make the file src/com/example/helloandroid/MainActivity.java and put that inside:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.example.helloandroid;

import android.app.Activity;
import android.os.Bundle;

public class MainActivity extends Activity {
   @Override
   protected void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      setContentView(R.layout.activity_main);
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Make the strings.xml file in the res/values folder. It contains all the text that your application uses:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;resources&amp;gt;
   &amp;lt;string name=&quot;app_name&quot;&amp;gt;A Hello Android&amp;lt;/string&amp;gt;
   &amp;lt;string name=&quot;hello_msg&quot;&amp;gt;Hello Android!&amp;lt;/string&amp;gt;
   &amp;lt;string name=&quot;menu_settings&quot;&amp;gt;Settings&amp;lt;/string&amp;gt;
   &amp;lt;string name=&quot;title_activity_main&quot;&amp;gt;MainActivity&amp;lt;/string&amp;gt;
&amp;lt;/resources&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The activity_main.xml is a layout file which have to be in res/layout:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot;
   android:layout_width=&quot;match_parent&quot;
   android:layout_height=&quot;match_parent&quot; &amp;gt;
   
   &amp;lt;TextView
      android:layout_width=&quot;wrap_content&quot;
      android:layout_height=&quot;wrap_content&quot;
      android:layout_centerHorizontal=&quot;true&quot;
      android:layout_centerVertical=&quot;true&quot;
      android:text=&quot;@string/hello_msg&quot;
      tools:context=&quot;.MainActivity&quot; /&amp;gt;
&amp;lt;/RelativeLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;You also have to add the file AndroidManifest.xml at the root:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version='1.0'?&amp;gt;
&amp;lt;manifest xmlns:a='http://schemas.android.com/apk/res/android' package='com.example.helloandroid' a:versionCode='0' a:versionName='0'&amp;gt;
    &amp;lt;application a:label='A Hello Android'&amp;gt;
    &amp;lt;activity a:name='com.example.helloandroid.MainActivity'&amp;gt;
         &amp;lt;intent-filter&amp;gt;
            &amp;lt;category a:name='android.intent.category.LAUNCHER'/&amp;gt;
            &amp;lt;action a:name='android.intent.action.MAIN'/&amp;gt;
         &amp;lt;/intent-filter&amp;gt;
    &amp;lt;/activity&amp;gt;
    &amp;lt;/application&amp;gt;
&amp;lt;/manifest&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终文件构成为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  HelloAndroid  tree
.
├── AndroidManifest.xml
├── bin
├── libs
├── obj
├── res
│   ├── drawable
│   ├── layout
│   │   └── activity_main.xml
│   └── values
│       └── strings.xml
└── src
    └── com
    └── example
        └── helloandroid
            └── MainActivity.java&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3）编译工程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将工程路径设置为变量(方便一会使用)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;export PROJ=~/Downloads/HelloAndroid&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;First, we need generate the &lt;strong&gt;R.java&lt;/strong&gt; file which is necessary for our code:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd /opt/android-sdk/build-tools/26.0.1/
./aapt package -f -m -J $PROJ/src -M $PROJ/AndroidManifest.xml -S $PROJ/res -I /opt/android-sdk/platforms/android-19/android.jar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;compile the &lt;strong&gt;.java&lt;/strong&gt; files:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd ~/Downloads/HelloAndroid
javac -d obj -classpath src -bootclasspath /opt/android-sdk/platforms/android-19/android.jar src/com/example/helloandroid/*.java&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The compiled .class files are in obj folder, but Android can’t read them. We have to translate them in a file called “classes.dex” which will be read by the dalvik Android runtime:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd /opt/android-sdk/build-tools/26.0.1/
./dx --dex --output=$PROJ/bin/classes.dex $PROJ/obj&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;We can now put everything in an APK:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./aapt package -f -m -F $PROJ/bin/hello.unaligned.apk -M $PROJ/AndroidManifest.xml -S $PROJ/res -I /opt/android-sdk/platforms/android-19/android.jar
cp $PROJ/bin/classes.dex .
./aapt add $PROJ/bin/hello.unaligned.apk classes.dex&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;If you want, you can check the content of the package like this:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./aapt list $PROJ/bin/hello.unaligned.apk&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们生成了一个hello.unaligned.apk文件，但是，它是不能安装到安卓手机里面的！因为它&lt;strong&gt;unaligned&lt;/strong&gt; &amp;amp;&amp;amp; &lt;strong&gt;unsigned&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）Align and Sign the package&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;keytool -genkeypair -validity 365 -keystore mykey.keystore -keyalg RSA -keysize 2048

cd /opt/android-sdk/build-tools/26.0.1/
./zipalign -f 4 $PROJ/bin/hello.unaligned.apk $PROJ/bin/hello.apk
./apksigner sign --ks mykey.keystore $PROJ/bin/hello.apk&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用keytool创建一个keystore，只要依次回答其问题即可，输入密码自己别忘了，今后会用到！运行成功之后会生成一个mykey.keystore文件，用于今后给apk签名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt; 记住务必要先Align，然后再Sign，否则会出错 [error-2].&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5）真机安装测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装并运行比较简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;adb install $PROJ/bin/hello.apk
adb shell am start -n com.example.helloandroid/.MainActivity&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;note:&lt;/strong&gt; 一般运行安装前，建议先运行adb logcat看看安卓有没有连接并开启开发者模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6）自动化脚本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了不用每次都要手输上面的每一步，我们将上面的操作整理成一个脚本&lt;strong&gt;run.sh&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  HelloAndroid  cat run.sh 
#!/bin/bash

set -e

AAPT=&quot;/opt/android-sdk/build-tools/26.0.1/aapt&quot;
DX=&quot;/opt/android-sdk/build-tools/26.0.1/dx&quot;
ZIPALIGN=&quot;/opt/android-sdk/build-tools/26.0.1/zipalign&quot;
APKSIGNER=&quot;/opt/android-sdk/build-tools/26.0.1/apksigner&quot; # /!\ version 26
PLATFORM=&quot;/opt/android-sdk/platforms/android-19/android.jar&quot;



function build(){
    echo &quot;Generating R.java file...&quot;
    $AAPT package -f -m -J src -M AndroidManifest.xml -S res -I $PLATFORM

    echo &quot;Compiling...&quot;
    javac -d obj -classpath src -bootclasspath $PLATFORM  src/com/example/helloandroid/*.java

    echo &quot;Translating in Dalvik bytecode...&quot;
    $DX --dex --output=classes.dex obj

    echo &quot;Making APK...&quot;
    $AAPT package -f -m -F bin/hello.unaligned.apk -M AndroidManifest.xml -S res -I $PLATFORM
    $AAPT add bin/hello.unaligned.apk classes.dex

    echo &quot;Aligning and signing APK...&quot;
    $ZIPALIGN -f 4 bin/hello.unaligned.apk bin/hello.apk
    $APKSIGNER sign --ks mykey.keystore bin/hello.apk
}

function clean(){
    echo &quot;Cleaning...&quot;
    rm -rf classes.dex
    rm -rf bin/*
    rm -rf obj/*
    rm -rf src/com/example/helloandroid/R.java
}

function program(){
    echo &quot;Launching...&quot;
    adb install -r bin/hello.apk
    adb shell am start -n com.example.helloandroid/.MainActivity
}


if [ &quot;$1&quot; == &quot;all&quot; ]; then
    clean
    build
    program
elif [ &quot;$1&quot; == &quot;clean&quot; ]; then
    clean
elif [ &quot;$1&quot; == &quot;build&quot; ]; then
    build
elif [ &quot;$1&quot; == &quot;program&quot; ]; then
    program
else
    echo &quot;error&quot;
fi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并编写一个&lt;strong&gt;makefile&lt;/strong&gt;脚本，通过调用run.sh实现编译、清除、安装各种操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  HelloAndroid  cat makefile 

clean:
    ./run.sh clean

build:
    ./run.sh build

program:
    ./run.sh program

all:
    ./run.sh all&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们完成了一个简单的命令行版的Hello World工程！当然，大多数非常复杂的安卓工程需要用IDE去开发，或者开发用IDE打包用命令 ～ 下次我会把一个稍微复杂点的蓝牙安卓工程改造成命令行版。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;常见错误&quot;&gt;常见错误&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;error-1：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  HelloAndroid  javac -d obj -classpath src -bootclasspath /opt/android-sdk/platforms/android-19/android.jar src/com/example/helloandroid/*.java

javac: option --boot-class-path not allowed with target 1.10&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;error-2：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;➜  HelloAndroid  ./build.sh test
Cleaning...
Generating R.java file...
Compiling...
Translating in Dalvik bytecode...
Making APK...
 'classes.dex'...
Aligning and signing APK...
WARNING: An illegal reflective access operation has occurred
WARNING: Illegal reflective access by com.android.apksigner.PasswordRetriever (file:/opt/android-sdk/build-tools/26.0.1/lib/apksigner.jar) to method java.io.Console.encoding()
WARNING: Please consider reporting this to the maintainers of com.android.apksigner.PasswordRetriever
WARNING: Use --illegal-access=warn to enable warnings of further illegal reflective access operations
WARNING: All illegal access operations will be denied in a future release
Keystore password for signer #1: 
Launching...
Failed to install bin/hello.apk: Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: Failed to collect certificates from /data/app/vmdl1775334521.tmp/base.apk: META-INF/MYKEY.SF indicates /data/app/vmdl1775334521.tmp/base.apk is signed using APK Signature Scheme v2, but no such signature was found. Signature stripped?]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要If you need to run zipalign, do it before the APK is signed，因此将APKSIGNER放在ZIPALIG之后&lt;sup&gt;&lt;a href=&quot;https://stackoverflow.com/questions/41391531/android-signing-apk-signature-v2&quot;&gt;(#4)&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;links&quot;&gt;LINKS&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.android.com/studio/command-line/sdkmanager&quot;&gt;[1].sdkmanager 用法&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://developer.android.com/studio/build/building-cmdline&quot;&gt;[2].Build your app from the command line&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://medium.com/@authmane512/how-to-build-an-apk-from-command-line-without-ide-7260e1e22676&quot;&gt;[3].How to make Android apps without IDE from command line&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://stackoverflow.com/questions/41391531/android-signing-apk-signature-v2&quot;&gt;[4].Android signing apk signature V2&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://stackoverflow.com/questions/19911762/what-are-the-android-sdk-build-tools-platform-tools-and-tools-and-which-versio&quot;&gt;[5].What are the Android SDK build-tools, platform-tools and tools? And which version should be used?&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://bugzilla.xamarin.com/show_bug.cgi?id=52178&quot;&gt;[6].Not able to build code after installing latest java version 1.9&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/NativeScript/nativescript-cli/issues/3139&quot;&gt;[7].Android SDK is not installed or is not configured properly, environment looks ok&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://developer.android.com/studio/#downloads&quot;&gt;[8].Command line tools only Download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://btfzmd.oss-cn-shanghai.aliyuncs.com/base/bar.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@beautifulzzzz
智能硬件、物联网，热爱技术，关注产品
博客：http://blog.beautifulzzzz.com
园友交流群：414948975&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 18 Sep 2018 18:29:00 +0000</pubDate>
<dc:creator>beautifulzzzz</dc:creator>
<og:description>星期三, 19. 九月 2018 02:19上午 BEAUTIFULZZZZ ![][ bar] 0）前言 本文不讨论用IDE和文本编辑器开发的优劣，是基于以下两点考虑去尝试用命令行编译安卓APP的：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjutlitao/p/9672376.html</dc:identifier>
</item>
<item>
<title>【Spark】Spark SQL, DataFrames and Datasets Guide(翻译文，持续更新) - 早起的虫儿去吃鸟</title>
<link>http://www.cnblogs.com/yeyeck/p/9665090.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yeyeck/p/9665090.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文主要是翻译Spark官网Spark &lt;a href=&quot;http://spark.apache.org/docs/latest/sql-programming-guide.html&quot;&gt;&lt;span&gt;SQL programming guide&lt;/span&gt;&lt;/a&gt; 。只能保证大概意思，尽量保证细节。英文水平有限，如果有错误的地方请指正，轻喷。&lt;/strong&gt;&lt;strong&gt;目录导航在右上角&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;　　Spark SQL 是一个结构化数据处理的 Spark 模块 。 与基础的 Spark RDD API 不同的是， Spark SQL 所提供的接口为 Spark 提供了 更多关于数据结构和正在执行的计算结构的信息。 Spark 在其内部利用这些额外的信息去做更多的优化。有几种用于和 Sparrk SQL&lt;/p&gt;
&lt;p&gt;交互的方法，包括 SQL 和 Dataset API。 当你计算一个结果， 会使用同一个执行引擎， 这独立于你所用来描述这个算法的API和语言。这种一致性意味着开发者可以轻易地在不同的 API 中来回切换， 因为它为表达给定的转换提供了最自然的方式。&lt;/p&gt;
&lt;p&gt;　　本页所有示例使用了 Spark 提供的样例数据并且可以在 spark-shell 、pyspark shell 或者 sparkR shell 中运行。&lt;/p&gt;
&lt;h3&gt;SQL&lt;/h3&gt;
&lt;p&gt;　　Spark SQL 的一个用处是执行 SQL 查询。 Spark SQL 同样可以用来从 现有的 HIVE 中读取数据。 更多有关配置这个特性的信息，请查阅 HIVE Tables 部分。当你使用其他语言执行SQL时，将会返回一个 Dataset 或者 DataFrame 作为结果。你同样可以使用命令行或者 JDBC/ODBC 与 SQL 接口进行交互。&lt;/p&gt;
&lt;h3&gt;Dataset 和 Dataframe&lt;/h3&gt;
&lt;p&gt;　　Dataset 是一种分布式数据集，是 Spark1.6 新增的接口。它提供了RDD（强类型，可以使用强大的 lambda 表达式）的优点，并受益于Spark SQL 的优化执行引擎。Dataset 可以通过 JVM 构建，然后使用转换方法（map, flatMap, filter等等）进行操作。 Dataset API &lt;/p&gt;
&lt;p&gt;在 Java 和 Scala 中可用。 Python 并不支持Dataset API。但是由于Python的动态特性， Dataset API 的很多优势都是可用的（比如你可以自然地使用名称 row.columnName 来访问 row 的域 ）。 R 语言的情况类似。&lt;/p&gt;
&lt;p&gt;　　DataFrame 是一种按列命名组织的 Dataset， 它在概念上等价于关系型数据库的一个表或者 R/Python 的一个数据帧， 但是它（DataFrame）的底层做了更多的优化。DataFrame 可以通过大量的数据源构建，例如：结构化的数据文件， HIVE 的表， 数据库，或现有的RDD。Java、Python、Scala、R语言都支持 DataFrame API。 在 Scala 和 Java， DataFrame 由Dataset的 rowS 表示。 在 Scala API 中，DataFrame 可以简单地认为是 Dataset[Row] 的别名。 然而，在 Java API 中， 用户需要使用 Dataset&amp;lt;Row&amp;gt; 来表示 DataFrame。&lt;/p&gt;
&lt;p&gt;　　在整个文档中， 我们通常把 Scala/Java Dataset 的 RowS 称为 DataFrames。&lt;/p&gt;
&lt;h2&gt; 准备开始&lt;/h2&gt;
&lt;h3&gt;起点： SparkSession&lt;/h3&gt;
&lt;p&gt;Spark 所有功能的入口是 SparkSession 类。创建最基本的 SaprkSession， 只需要调用 SparkSession.builder():&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;scala版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
import org.apache.spark.sql.SparkSession

val spark = SparkSession
  .builder()
  .appName(&quot;Spark SQL basic example&quot;)
  .config(&quot;spark.some.config.option&quot;, &quot;some-value&quot;)
  .getOrCreate()

// For implicit conversions like converting RDDs to DataFrames
import spark.implicits.　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在  Spark 仓库 “examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala” 中可以找到完整的示例代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;java版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.spark.sql.SparkSession;

SparkSession spark &lt;/span&gt;=&lt;span&gt; SparkSession
  .builder()
  .appName(&lt;/span&gt;&quot;Java Spark SQL basic example&quot;&lt;span&gt;)
  .config(&lt;/span&gt;&quot;spark.some.config.option&quot;, &quot;some-value&quot;&lt;span&gt;)
  .getOrCreate();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在  Spark 仓库 “examples/src/main/java/org/apache/spark/examples/sql/JavaSparkSQLExample.java” 中可以找到完整的示例代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Python版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; pyspark.sql &lt;span&gt;import&lt;/span&gt;&lt;span&gt; SparkSession

spark &lt;/span&gt;=&lt;span&gt; SparkSession \
    .builder \
    .appName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Python Spark SQL basic example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) \
    .config(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spark.some.config.option&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;some-value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) \
    .getOrCreate()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在  Spark 仓库 “examples/src/main/python/sql/basic.py” 中可以找到完整的示例代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R语言&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
sparkR.session(appName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;R Spark SQL basic example&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, sparkConfig = list(spark.some.config.option = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;some-value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在  Spark 仓库 “examples/src/main/r/RSparkSQLExample.R” 中可以找到完整的示例代码&lt;/p&gt;
&lt;p&gt;请注意，sparkR.session() 第一次被调用时，它会初始化一个全局的 SparkSession 单例对象，并且之后继续调用这个方法都将返回这个实例。 通过这种方式，用户只需要对 SparkSession 做一次初始化，然后 SparkR 的其他方法比如 read.df 将会隐式地访问这个全局地单例对象， 并且用户不需要传递 SparkSession 的实例。&lt;/p&gt;

&lt;p&gt;Spark2.0 的 SparkSession 提供了对 HIVE 特性的内置支持， 包括使用 HiveQL 编写查询语句的能力，访问 Hive UDFs 和 从 Hive Table 中读取数据的能力。为了使用这些特性，您需要安装一个 HIVE。&lt;/p&gt;

&lt;h3&gt;创建 DataFrame&lt;/h3&gt;
&lt;p&gt;有了SparkSession， 应用程序可以通过本地的 R data.frame、Hive Table、 或者 Spark 数据源 来创建DataFrame。&lt;/p&gt;
&lt;p&gt;作为示例，以下代码使用一个 JSON 文件的内容 创建一个 DataFrame&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scala版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
val df = spark.read.json(&quot;examples/src/main/resources/people.json&quot;)

// Displays the content of the DataFrame to stdout
df.show()
// +----+-------+
// | age|   name|
// +----+-------+
// |null|Michael|
// |  30|   Andy|
// |  19| Justin|
// +----+-------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在  Spark 仓库 “examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala” 中可以找到完整的示例代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Java版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.spark.sql.Dataset;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.spark.sql.Row;

Dataset&lt;/span&gt;&amp;lt;Row&amp;gt; df = spark.read().json(&quot;examples/src/main/resources/people.json&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Displays the content of the DataFrame to stdout&lt;/span&gt;
&lt;span&gt;df.show();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; +----+-------+
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; | age|   name|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; +----+-------+
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |null|Michael|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |  30|   Andy|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |  19| Justin|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; +----+-------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在  Spark 仓库 “examples/src/main/java/org/apache/spark/examples/sql/JavaSparkSQLExample.java” 中可以找到完整的示例代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Python版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; spark is an existing SparkSession&lt;/span&gt;
df = spark.read.json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;examples/src/main/resources/people.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Displays the content of the DataFrame to stdout&lt;/span&gt;
&lt;span&gt;df.show()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; +----+-------+&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; | age|   name|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; +----+-------+&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; |null|Michael|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; |  30|   Andy|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; |  19| Justin|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; +----+-------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在  Spark 仓库 “examples/src/main/python/sql/basic.py” 中可以找到完整的示例代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R语言&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
df &amp;lt;- read.json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;examples/src/main/resources/people.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Displays the content of the DataFrame&lt;/span&gt;
&lt;span&gt;head(df)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#   age    name&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 1  NA Michael&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 2  30    Andy&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 3  19  Justin&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Another method to print the first few rows and optionally truncate the printing of long values&lt;/span&gt;
&lt;span&gt;showDF(df)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;# +----+-------+&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# | age|   name|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# +----+-------+&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# |null|Michael|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# |  30|   Andy|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# |  19| Justin|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# +----+-------+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在  Spark 仓库 “examples/src/main/r/RSparkSQLExample.R” 中可以找到完整的示例代码&lt;/p&gt;

&lt;h3&gt;弱类型的 Dataset 操作（aka DataFrame 操作）&lt;/h3&gt;
&lt;p&gt;DataFrame 为 Scala、Java、Python、R语言提供了一种特定的结构化数据操作。&lt;/p&gt;
&lt;p&gt;上面提到过，在 Spark2.0 中，DataFrame 对于 Scala 和 Java API 仅仅是 Dataset 的 RowS。这些操作也被称为 “弱类型转换”，这与 强类型的Scala/Java 中的 “强类型转换” 形成了鲜明的对比。&lt;/p&gt;
&lt;p&gt;这里我们囊括了使用 Datasets 做结构化数据处理的基本示例：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scala版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
// This import is needed to use the $-notation
import spark.implicits._
// Print the schema in a tree format
df.printSchema()
// root
// |-- age: long (nullable = true)
// |-- name: string (nullable = true)

// Select only the &quot;name&quot; column
df.select(&quot;name&quot;).show()
// +-------+
// |   name|
// +-------+
// |Michael|
// |   Andy|
// | Justin|
// +-------+

// Select everybody, but increment the age by 1
df.select($&quot;name&quot;, $&quot;age&quot; + 1).show()
// +-------+---------+
// |   name|(age + 1)|
// +-------+---------+
// |Michael|     null|
// |   Andy|       31|
// | Justin|       20|
// +-------+---------+

// Select people older than 21
df.filter($&quot;age&quot; &amp;gt; 21).show()
// +---+----+
// |age|name|
// +---+----+
// | 30|Andy|
// +---+----+

// Count people by age
df.groupBy(&quot;age&quot;).count().show()
// +----+-----+
// | age|count|
// +----+-----+
// |  19|    1|
// |null|    1|
// |  30|    1|
// +----+-----+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在  Spark 仓库 “examples/src/main/scala/org/apache/spark/examples/sql/SparkSQLExample.scala” 中可以找到完整的示例代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;java版&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; col(&quot;...&quot;) is preferable to df.col(&quot;...&quot;)&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; org.apache.spark.sql.functions.col;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Print the schema in a tree format&lt;/span&gt;
&lt;span&gt;df.printSchema();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; root
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |-- age: long (nullable = true)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |-- name: string (nullable = true)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Select only the &quot;name&quot; column&lt;/span&gt;
df.select(&quot;name&quot;&lt;span&gt;).show();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; +-------+
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |   name|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; +-------+
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |Michael|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |   Andy|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; | Justin|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; +-------+

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Select everybody, but increment the age by 1&lt;/span&gt;
df.select(col(&quot;name&quot;), col(&quot;age&quot;).plus(1&lt;span&gt;)).show();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; +-------+---------+
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |   name|(age + 1)|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; +-------+---------+
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |Michael|     null|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |   Andy|       31|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; | Justin|       20|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; +-------+---------+

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Select people older than 21&lt;/span&gt;
df.filter(col(&quot;age&quot;).gt(21&lt;span&gt;)).show();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; +---+----+
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |age|name|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; +---+----+
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; | 30|Andy|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; +---+----+

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Count people by age&lt;/span&gt;
df.groupBy(&quot;age&quot;&lt;span&gt;).count().show();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; +----+-----+
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; | age|count|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; +----+-----+
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |  19|    1|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |null|    1|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; |  30|    1|
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; +----+-----+&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在  Spark 仓库 “examples/src/main/java/org/apache/spark/examples/sql/JavaSparkSQLExample.java” 中可以找到完整的示例代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Python版&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 对于Python来说，我们可以通过属性（df.age）或者通过索引(df['age']) 来访问 DataFrame 的列。 虽然前者用于交互式数据探索非常方便， 但使用者强烈建议使用后者，因为它具有前瞻性，并且不会因为 DataFrame 的列命和属性名重复产生冲突。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; spark, df are from the previous example&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Print the schema in a tree format&lt;/span&gt;
&lt;span&gt;df.printSchema()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; root&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; |-- age: long (nullable = true)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; |-- name: string (nullable = true)&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Select only the &quot;name&quot; column&lt;/span&gt;
df.select(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).show()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; +-------+&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; |   name|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; +-------+&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; |Michael|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; |   Andy|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; | Justin|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; +-------+&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Select everybody, but increment the age by 1&lt;/span&gt;
df.select(df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] + 1&lt;span&gt;).show()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; +-------+---------+&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; |   name|(age + 1)|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; +-------+---------+&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; |Michael|     null|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; |   Andy|       31|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; | Justin|       20|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; +-------+---------+&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Select people older than 21&lt;/span&gt;
df.filter(df[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &amp;gt; 21&lt;span&gt;).show()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; +---+----+&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; |age|name|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; +---+----+&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; | 30|Andy|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; +---+----+&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Count people by age&lt;/span&gt;
df.groupBy(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).count().show()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; +----+-----+&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; | age|count|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; +----+-----+&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; |  19|    1|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; |null|    1|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; |  30|    1|&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; +----+-----+&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在  Spark 仓库 “examples/src/main/python/sql/basic.py” 中可以找到完整的示例代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R语言&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create the DataFrame&lt;/span&gt;
df &amp;lt;- read.json(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;examples/src/main/resources/people.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Show the content of the DataFrame&lt;/span&gt;
&lt;span&gt;head(df)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#   age    name&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 1  NA Michael&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 2  30    Andy&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 3  19  Justin&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Print the schema in a tree format&lt;/span&gt;
&lt;span&gt;printSchema(df)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;# root&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# |-- age: long (nullable = true)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# |-- name: string (nullable = true)&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Select only the &quot;name&quot; column&lt;/span&gt;
head(select(df, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#      name&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 1 Michael&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 2    Andy&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 3  Justin&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Select everybody, but increment the age by 1&lt;/span&gt;
head(select(df, df$name, df$age + 1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#      name (age + 1.0)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 1 Michael          NA&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 2    Andy          31&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 3  Justin          20&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Select people older than 21&lt;/span&gt;
head(where(df, df$age &amp;gt; 21&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#   age name&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 1  30 Andy&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Count people by age&lt;/span&gt;
head(count(groupBy(df, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#   age count&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 1  19     1&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 2  NA     1&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;# 3  30     1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在  Spark 仓库 “examples/src/main/r/RSparkSQLExample.R” 中可以找到完整的示例代码&lt;/p&gt;

&lt;p&gt;关于 DataFrame 可执行的操作的完整列表，请移步 &lt;a href=&quot;http://spark.apache.org/docs/latest/api/R/index.html&quot;&gt;API Documentation&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;除了简单的列引用和表示之外，DataFrame 同样有一个丰富的函数库，包括字符串操作、日期算法、常用数学操作 等等。 完整的列表可以在 &lt;a href=&quot;http://spark.apache.org/docs/latest/api/R/SparkDataFrame.html&quot;&gt;DataFrame Function Reference&lt;/a&gt;.中找到。&lt;/p&gt;

</description>
<pubDate>Tue, 18 Sep 2018 17:26:00 +0000</pubDate>
<dc:creator>早起的虫儿去吃鸟</dc:creator>
<og:description>本文主要是翻译Spark官网Spark SQL programming guide 。只能保证大概意思，尽量保证细节。英文水平有限，如果有错误的地方请指正，轻喷。目录导航在右上角 Spark</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yeyeck/p/9665090.html</dc:identifier>
</item>
<item>
<title>算法系列教程03 - 人人都能懂的图灵机原理 - Liam Wang</title>
<link>http://www.cnblogs.com/willick/p/algorithms-03.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/algorithms-03.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?postid=9672003&quot; readability=&quot;98.313809016684&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/willick/p/algorithms-02.html#4069226&quot; target=&quot;_blank&quot;&gt;上一讲&lt;/a&gt;我们知道了图灵机在历史上出现的原因，它是一个计算模型，用来判定一个问题到底可不可解，那么它是如何判定的呢？&lt;/p&gt;
&lt;p&gt;在本篇文章开始之前，我们先来看一段视频：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;视频来源：&lt;a href=&quot;https://www.youtube.com/watch?v=E3keLeMwfHY&quot;&gt;&lt;span&gt;YouTube&lt;/span&gt;&lt;/a&gt; (经下载后上传到腾讯视频)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;图灵机的构成&lt;/h2&gt;
&lt;p&gt;为了方便讲述图灵机的构成，我从视频中截取了一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3wQgM1c.jpg&quot; alt=&quot;图灵机的组成&quot;/&gt;&lt;/p&gt;
&lt;p&gt;视频中的图灵机是用现代工艺做的，可以看到图灵机并不复杂，它做的事情很简单。当机器处于“Read”状态的时候，会从纸带上读内容，完了经过某种计算再向左或向右移动，然后在当前位置写上符号 0 或 1（如果已经有符号会先擦除），下面有个状态(State)会变化，另外还显示了当前的位置(Position)和步数(Step)。&lt;/p&gt;
&lt;p&gt;从上面图中我们可以看到，图灵机就是一个机器（称为控制器）和一根纸带组成的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制器&lt;/span&gt;，包含用来写内容的“笔”、“擦子”。它可以向纸带读、写、改数据，所读内容我们可以理解为程序语句；它可以使纸带左右移动；它还有一个可以变换的状态。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;纸带&lt;/span&gt;，左右两边无限延长，纸带上可以写内容（也就是存储），内容可以是数字和字母。我们可以把纸带理解为存储器。&lt;/p&gt;
&lt;p&gt;我们再来看看图灵机是怎么工作的。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;图灵机运行原理&lt;/h2&gt;
&lt;p&gt;首先图灵机工作前，需要先在纸带上写好一些符号，例如“1 1 0”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/INAi2Pc.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加粗的方格表示当前控制器笔头指向的位置。现在我们编写一段简单的程序，这段程序用表格表示是这样的：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;读取&lt;/th&gt;
&lt;th&gt;写入&lt;/th&gt;
&lt;th&gt;移动&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;空白&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;向右移&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;向右移&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这个程序很容易理解，比如表格的第三行（即最后一行），意思就是当程序读取到 1 时，在当前位置写入 0，再向右移动一格。假设我们已经把这段程序输入到机器中了，然后机器开始运作。&lt;/p&gt;
&lt;p&gt;首先机器读取纸带当前的符号，如上面的纸带图，读取到的是“0”，匹配程序表的第二行，按照程序的指示，应该在当前位置写入“1”再向右移一格，过程如下两个纸带图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/2oAcXIm.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;机器继续读取当前位置的符号，读取到的是“1”，匹配程序表的第三行，然后按照程序的指示在当前位置写入“0”，再向右移一格，这一步图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/YhreBks.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依此继续执行，最后一步图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/L4107m8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后读取到空白时，按照程序的指示，既不写也不移动。事实上这个程序并不完整，还存在问题，例如怎样才能让机器停止，又如何让机器不停地重复读取、写入和移动的过程呢？&lt;/p&gt;
&lt;p&gt;我们还要在程序中加入状态，控制器必须要有记录状态的功能。为什么一定要加入状态呢？因为如果没有状态的话，在纸带有限的符号下，程序表只能是有限的行数。比如示例中的纸带有三种符号：0、1 和空白，那么程序表最多也就只能是三行，机器最多只能执行三种可能的动作。加入状态后，假如状态有 0 或 1 两种，那么程序表的行数就可以增加到 2x3=6 行，这称为 3 符号 2 状态图灵机。&lt;/p&gt;
&lt;p&gt;例如下面是一个含有两种状态的程序表：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;当前状态&lt;/th&gt;
&lt;th&gt;读取&lt;/th&gt;
&lt;th&gt;写入&lt;/th&gt;
&lt;th&gt;移动&lt;/th&gt;
&lt;th&gt;修改状态&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;空白&lt;/td&gt;
&lt;td&gt;空白&lt;/td&gt;
&lt;td&gt;向左移&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;向右移&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;向右移&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;空白&lt;/td&gt;
&lt;td&gt;空白&lt;/td&gt;
&lt;td&gt;向右移&lt;/td&gt;
&lt;td&gt;停止&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;向左移&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;向左移&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;机器每一步需要结合当前的状态再来执行相应的操作，所以在机器运行前，需要有个初始状态。机器执行完一步后，按照指示修改状态，以备下一步使用。&lt;/p&gt;
&lt;p&gt;假如机器的初始状态为 0，继续使用上面最后一步的纸带，当前指向的是空白，那么匹配的是表格的第一行，按照程序指示，在当前位置写入空白，并向左移一格，图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/BgIAGyn.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依次类推，后续步骤的图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/IJAE6ik.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一步步这样匹配演示下来，上图对应的最后一步是向左移一格后指向了空白，状态变为了 1（匹配的是第五行）。此时，继续执行，当前位置是空白，当前状态是 1，那么匹配的是表格的第四行，向右移一格，状态变为停止，如下图示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/JqEHCQW.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样图灵机就完成了一次计算。纸带由“001”通过给定的程序计算变成了“110”，如果把它们看成二进制的话，其实是做了一次 1+5=6 的运算。&lt;/p&gt;
&lt;p&gt;随着控制器状态增多，那么我们就可以编写越复杂的程序，也就能和现代计算机一样执行复杂的算法。&lt;/p&gt;
&lt;p&gt;好了，知道了图灵机的运行原理，我们再回到开篇提到的问题，既然说图灵机是一种计算模型，那么它怎么来判定一个问题有没有解呢？&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;图灵机停机&lt;/h2&gt;
&lt;p&gt;如果图灵机成功完成了一次计算，我们就说图灵机&lt;span&gt;成功停机&lt;/span&gt;了。&lt;span&gt;停机&lt;/span&gt;就意味着计算结束并得出结果，停机后纸带上的符号就是计算结果。&lt;/p&gt;
&lt;p&gt;当我们遇到一个问题，比如说输入 A，问：能否由 A 计算出 B？图灵机能帮我们做一个判定，如果我们能在 A 与 B 之间找到或设计出一个图灵机程序，使输入 A 停机得到的结果是 B，就说明这个问题可解，否则就说明这个问题不可解。&lt;/p&gt;
&lt;p&gt;图灵机就是这样解决“可计算性的判定”问题的，这是图灵机的一个重大意义。另外，我们可以看到图灵机给出了一个可实现的通用计算模型，还引入了存储器、程序、控制器等概念的原型，为现代计算机奠定了基础，这也是图灵机为什么受到人们重视的原因。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/turing-machine/one.html&quot;&gt;&lt;span&gt;https://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/turing-machine/one.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 18 Sep 2018 17:09:00 +0000</pubDate>
<dc:creator>Liam Wang</dc:creator>
<og:description>上一讲我们知道了图灵机在历史上出现的原因，它是一个计算模型，用来判定一个问题到底可不可解，那么它是如何判定的呢？ 在本篇文章开始之前，我们先来看一段视频： 视频来源：YouTube (经下载</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/willick/p/algorithms-03.html</dc:identifier>
</item>
<item>
<title>javascript精雕细琢（一）：var let const function声明的区别 - 低头苦读、抬头高歌</title>
<link>http://www.cnblogs.com/keepStudying/p/9672334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/keepStudying/p/9672334.html</guid>
<description>&lt;p&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;var&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;let&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;const&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;function&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;在学习javascript的过程中，变量是无时无刻不在使用的。那么相对应的，变量声明方法也如是。变量是由自己决定，但变量声明方法是早已经定义好的。那么在使用变量之前，了解变量声明方法，就变得尤为重要。在ES6推出之前，最常用的声明变量方法就是var。但是由于var自身的缺陷，ES6推出了let和const替代var。虽然修正了var的缺陷，但不能改变的，是之前已经用var写了多少年的项目，这些项目是无法随着var的被取代而轻易更改的。所以仍存在着使用var的公司和项目，这也使得了解var、let、const的区别变得有必要。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　在接下来的说明中，为了理解起来一目了然，使用了图片说明的方式，搭配适当的文字解释，并没有粘贴代码（因为代码都及其简单）。我希望读完这篇文章后，能达到理解记忆的效果。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、var&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;&lt;span&gt;在说明var并看图之前，我们先统一思路，将变量的声明及使用过程分为：*****&lt;span&gt;&lt;strong&gt;创建→初始化→赋值→修改&lt;/strong&gt;&lt;/span&gt;*****四步。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　  &lt;strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;首先，来看var的声明及使用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1080150/201809/1080150-20180918214733567-1789755172.jpg&quot; alt=&quot;&quot;/&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;span&gt;由上图可以看出，var在它的执行环境中的声明及操作过程为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　（ &lt;strong&gt;创建→初始化 ）→赋值→修改&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;1、隐藏步骤：在环境最顶端，创建变量，并初始化为undefined&lt;strong&gt;—— 变量提升；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;2、为变量赋值；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　&lt;/strong&gt;　3、对变量进行操作，可以在后续操作中对变量值进行修改；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过console.log的打印结果，我们可以清晰的认识到一点——var的初始化与赋值是分离的，而且初始化的过程优先于执行环境中的所有操作。这就是为什么在var声明赋值前console.log变量，会打印出undefined，而不是报错的原因。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　var声明的初始化先于赋值的现象，就叫做*****&lt;strong&gt;变量提升*****&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;下面再来看第二张图，说明var的另一个缺陷：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1080150/201809/1080150-20180918221131815-1032436538.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;由上图可以看出，var声明一个变量时，可以无限次的以同一个变量名不断的 &lt;strong&gt;创建→初始化→赋值，这跟直接修改变量值的结果是一样的。&lt;/strong&gt;但是实际操作中不会有人通过这种方式对变量执行操作，而且这种设计缺陷着实让人无法忍受……。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、let&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;上图：&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1080150/201809/1080150-20180918221654489-945375828.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;同样，先分析过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　（ &lt;strong&gt;创建→初始化→赋值 ）→修改&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;1、不存在隐藏步骤；&lt;span&gt;隐藏步骤在环境最顶端，创建变量，并初始化为undefined&lt;strong&gt;—— 变量提升；&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;2、创建变量、初始化并赋值；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　&lt;/strong&gt;　3、对变量进行操作，可以在后续操作中对变量值进行修改；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过上图，我们可以看出let声明变量时，（ &lt;strong&gt;创建→初始化→赋值 ）是在一步完成的。不存在变量提升的现象。&lt;/strong&gt;所以在let声明前console.log(a)，报错***&lt;strong&gt;a is not defined&lt;/strong&gt;***，因为此时a还没有被创建。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　&lt;span&gt;　&lt;strong&gt;接下来再看第二张图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/blog/1080150/201809/1080150-20180918222655604-936624043.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　上图说明了let区别于var的另一个特性——&lt;strong&gt;变量的唯一性。&lt;/strong&gt;同一个变量名，不能在let中重复使用，所以执行上图操作的结果，就是报错***&lt;strong&gt;Identifier 'a' has already been declared&lt;/strong&gt;***；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、const&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;span&gt;再上图：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1080150/201809/1080150-20180919000114688-1363084778.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;分析过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　（ &lt;strong&gt;创建→初始化→赋值 ）&lt;span&gt;→修改&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;1、不存在隐藏步骤；&lt;span&gt;隐藏步骤在环境最顶端，创建变量，并初始化为undefined&lt;strong&gt;—— 变量提升；&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;2、创建变量、初始化并赋值。&lt;strong&gt;必须赋值，不赋值会报错；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　&lt;/strong&gt;　3、对变量进行操作，&lt;span&gt;可以在后续操作中对变量值进行修改&lt;/span&gt;，&lt;strong&gt;不可以对变量进行修改，但是可以对变量的属性进行修改；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;为了说明const的特性，特意声明了一个对象。在理解了var和let的过程之后，再来看const的整个过程，会发现在（ &lt;strong&gt;创建→初始化→赋值 ）&lt;/strong&gt;的过程中，const和let是&lt;strong&gt;没有区别的&lt;/strong&gt;。唯一的区别在于&lt;strong&gt;→&lt;/strong&gt;&lt;strong&gt;修改。&lt;/strong&gt;如果执行了图片中的代码，在&lt;strong&gt;***a = 1***那步&lt;/strong&gt;会报错&lt;strong&gt;*** Assignment to constant variable***。&lt;/strong&gt;其中的constant就是const的英文全拼，它的意思的***&lt;strong&gt;不变的、恒定的、恒量&lt;/strong&gt;***。从字面上就能理解，通过const声明的变量，是一个恒定值，&lt;strong&gt;即无法更改的值&lt;/strong&gt;。所以当通过&lt;strong&gt;***a = 1***&lt;/strong&gt;试图修改a的值时&lt;strong&gt;，报错。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;虽然a本身的值无法修改，&lt;strong&gt;但是a内的属性是可以修改的。&lt;/strong&gt;从图上最后一步可以看出。a.name的值成功修改为&quot;Jack&quot;。这就是const 的第二个特性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　同let一样的，const的第三个特性也是&lt;strong&gt;变量的唯一性&lt;/strong&gt;，不再过多阐述。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、function&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;　　&lt;span&gt;继续上图：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/blog/1080150/201809/1080150-20180919002323263-945309503.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;　&lt;span&gt;　分析过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　（ &lt;strong&gt;创建→初始化→赋值 ）→执行/修改&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;1、隐藏步骤；隐藏步骤在环境最顶端，创建函数，初始化并赋值为函数定义；&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　&lt;/strong&gt;2、执行函数，无论函数在何位置，只要可用，就可以调用；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　function是专门用于函数声明的方法，由于函数的复杂性，以及利用性。function声明的函数，&lt;strong&gt;会在整个环境变量最顶端完成创建、初始化、赋值三位一体的操作&lt;/strong&gt;。这样一来，&lt;strong&gt;不管在何处声明了函数，可以在任何地方调用函数方法&lt;/strong&gt;。这是比较合乎常理的性质。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　function另外一个性质，同var一样，它也可以对同一变量重复声明，而且后边的函数定义会覆盖前边的函数定义，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1080150/201809/1080150-20180919004735963-69390876.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;结果打印1，说明前边声明的函数方法被后边所覆盖。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　&lt;/span&gt;&lt;span&gt;　综上所述，可以总结为如下几点：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　1、var与let、const的区别在于&lt;strong&gt;变量提升&lt;/strong&gt;，以及&lt;strong&gt;变量的唯一性&lt;/strong&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　2、const与let的区别，除了&lt;strong&gt;变量值不能修改&lt;/strong&gt;，其他性质一样；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　3、function由于其自身的需要，&lt;strong&gt;创建→初始化→赋值 三位一体，在环境最顶端完成；&lt;/strong&gt;也正因为这种性质，&lt;strong&gt;函数可以在任何位置被调用；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　4、&lt;/strong&gt;如果可以，尽量使用let、const代替var；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　&lt;span&gt;　本文仅仅简单罗列了在&lt;strong&gt;函数声明及操作&lt;/strong&gt;方面，var、let、const、function的区别，意在为初学者理清概念偏差，少走弯路，并通过理解学习，早日跨入JS门槛。至于在&lt;strong&gt;for循环以及其他一些地方上存在的区别，涉及实际使用。以后会单独再开一篇进行讲解。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　以上，如有错误或是纰漏，欢迎批评指正~&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 18 Sep 2018 17:01:00 +0000</pubDate>
<dc:creator>低头苦读、抬头高歌</dc:creator>
<og:description>目录 引言 var let const function 总结 引言 在学习javascript的过程中，变量是无时无刻不在使用的。那么相对应的，变量声明方法也如是。变量是由自己决定，但变量声明方法是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/keepStudying/p/9672334.html</dc:identifier>
</item>
<item>
<title>mybatis源码-解析配置文件（三）之配置文件Configuration解析(超详细， 值得收藏) - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/9672224.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/9672224.html</guid>
<description>&lt;h2 id=&quot;系列内容&quot;&gt;1.1 系列内容&lt;/h2&gt;
&lt;p&gt;本系列文章讲解的是&lt;strong&gt;mybatis解析配置文件&lt;/strong&gt;内部的逻辑， 即&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; Reader reader = Resources.getResourceAsReader(&quot;mybatis-config.xml&quot;);
 SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其背后的逻辑。&lt;/p&gt;
&lt;h2 id=&quot;适合对象&quot;&gt;1.2 适合对象&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;了解如何使用 &lt;strong&gt;mybatis&lt;/strong&gt; 来访问数据库。可参看《&lt;a href=&quot;https://www.cnblogs.com/homejim/p/9613205.html&quot;&gt;mybatis 初步使用（IDEA的Maven项目, 超详细）&lt;/a&gt;》;&lt;/li&gt;
&lt;li&gt;具备 DOM 解析 XML 的基本知识。 可参考《&lt;a href=&quot;https://www.cnblogs.com/homejim/p/9652273.html&quot;&gt;mybatis源码-解析配置文件（一）之XML的DOM解析方式&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;了解整个配置文件解析是什么样的一个流程。可参考《&lt;a href=&quot;https://www.cnblogs.com/homejim/p/9654992.html&quot;&gt;mybatis源码-解析配置文件（二）之解析的流程&lt;/a&gt;》。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;本文内容&quot;&gt;1.3 本文内容&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Configuration&lt;/code&gt;类的讲解；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parser.parse()&lt;/code&gt;将配置解析到&lt;code&gt;Configuration&lt;/code&gt;中的过程；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;mybatis使用到了配置文件， 本文中， 不讲解 &lt;strong&gt;mapper.xml&lt;/strong&gt;， 后续会另开章节重点讲解。&lt;/p&gt;
&lt;h2 id=&quot;mysql.properties&quot;&gt;2.1 mysql.properties&lt;/h2&gt;
&lt;p&gt;这是存储数据库信息的对应文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql.driver=com.mysql.jdbc.Driver
mysql.url=jdbc:mysql://localhost:3306/mybatis
mysql.username=root
mysql.password=jim666&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;mybatis-config.xml&quot;&gt;2.2 mybatis-config.xml&lt;/h2&gt;
&lt;p&gt;核心配置文件， 管理 &lt;strong&gt;mybatis&lt;/strong&gt; 的运行行为。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;!-- 配置全局属性 --&amp;gt;

    &amp;lt;properties resource=&quot;mysql.properties&quot;&amp;gt; &amp;lt;/properties&amp;gt;

    &amp;lt;settings&amp;gt;
        &amp;lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&amp;gt;
    &amp;lt;/settings&amp;gt;

    &amp;lt;typeAliases&amp;gt;
        &amp;lt;package name=&quot;com.homejim.mybatis.entity&quot;/&amp;gt;
    &amp;lt;/typeAliases&amp;gt;

    &amp;lt;environments default=&quot;development&quot;&amp;gt;
        &amp;lt;environment id=&quot;development&quot;&amp;gt;
            &amp;lt;transactionManager type=&quot;JDBC&quot;&amp;gt;
                &amp;lt;property name=&quot;&quot; value=&quot;&quot;/&amp;gt;
            &amp;lt;/transactionManager&amp;gt;
            &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
                &amp;lt;property name=&quot;driver&quot; value=&quot;${mysql.driver}&quot;/&amp;gt;
                &amp;lt;property name=&quot;url&quot; value=&quot;${mysql.url}&quot;/&amp;gt;
                &amp;lt;property name=&quot;username&quot; value=&quot;${mysql.username}&quot;/&amp;gt;
                &amp;lt;property name=&quot;password&quot; value=&quot;${mysql.password}&quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;

    &amp;lt;mappers&amp;gt;
        &amp;lt;package name=&quot;com.homejim.mybatis.mapper&quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Configuration&lt;/code&gt;类对应的就是我们的 &lt;strong&gt;mybatis-config.xml&lt;/strong&gt; 配置文件， 我们配置的信息经过解析后就会存储到&lt;code&gt;Configuration&lt;/code&gt;的成员变量中。&lt;/p&gt;
&lt;h2 id=&quot;解析入口&quot;&gt;3.1 解析入口&lt;/h2&gt;
&lt;p&gt;解析的入口是以下的函数:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public Configuration parse() {
    if (parsed) {
      throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);
    }
    parsed = true;
    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));
    return configuration;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先通过&lt;code&gt;parser.evalNode(&quot;/configuration&quot;)&lt;/code&gt;函数解析解析出 &lt;strong&gt;configuration&lt;/strong&gt;节点， 在使用&lt;code&gt;parseConfiguration&lt;/code&gt;函数解析获得旗下各个节点的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void parseConfiguration(XNode root) {
    try {
      //issue #117 read properties first
      &amp;lt;!--解析 properties 节点--&amp;gt;
      propertiesElement(root.evalNode(&quot;properties&quot;));
      &amp;lt;!--解析 settings 节点--&amp;gt;
      Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));
      loadCustomVfs(settings);
      &amp;lt;!--解析 typeAliases 节点--&amp;gt;
      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
      &amp;lt;!--解析 plugins 节点--&amp;gt;
      pluginElement(root.evalNode(&quot;plugins&quot;));
      &amp;lt;!--解析 objectFactory 节点--&amp;gt;
      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
      &amp;lt;!--解析 objectWrapperFactory 节点--&amp;gt;
      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
      &amp;lt;!--解析 reflectorFactory 节点--&amp;gt;
      reflectorFactoryElement(root.evalNode(&quot;reflectorFactory&quot;));
      settingsElement(settings);
      // read it after objectFactory and objectWrapperFactory issue #631
      &amp;lt;!--解析 environments 节点， 需要在 objectFactory 和 objectWrapperFactory才能读取--&amp;gt;
      environmentsElement(root.evalNode(&quot;environments&quot;));
       &amp;lt;!--解析 databaseIdProvider 节点--&amp;gt;
      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
       &amp;lt;!--解析 typeHandlers 节点--&amp;gt;
      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
      &amp;lt;!--解析 mappers 节点--&amp;gt;
      mapperElement(root.evalNode(&quot;mappers&quot;));
    } catch (Exception e) {
      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;常用函数&quot;&gt;3.2 常用函数&lt;/h2&gt;
&lt;h3 id=&quot;获取节点&quot;&gt;3.2.1 获取节点&lt;/h3&gt;
&lt;p&gt;其实就是使用 &lt;strong&gt;DOM&lt;/strong&gt; 结合 &lt;strong&gt;Xpath&lt;/strong&gt; 的方法获得各个节点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public XNode evalNode(String expression) {
    return evalNode(document, expression);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而后返回相应的 &lt;strong&gt;XNode&lt;/strong&gt; 类对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public XNode evalNode(Object root, String expression) {
    Node node = (Node) evaluate(expression, root, XPathConstants.NODE);
    if (node == null) {
      return null;
    }
    return new XNode(this, node, variables);
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终调用的是&lt;code&gt;xpath.evaluate(expression, root, returnType)&lt;/code&gt;, 不理解这个过程的可参考之前的&lt;a href=&quot;https://www.cnblogs.com/homejim/p/9652273.html&quot;&gt;文章&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private Object evaluate(String expression, Object root, QName returnType) {
    try {
      return xpath.evaluate(expression, root, returnType);
    } catch (Exception e) {
      throw new BuilderException(&quot;Error evaluating XPath.  Cause: &quot; + e, e);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取子节点&quot;&gt;3.2.2 获取子节点&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public List&amp;lt;XNode&amp;gt; getChildren() {
    List&amp;lt;XNode&amp;gt; children = new ArrayList&amp;lt;XNode&amp;gt;();
    NodeList nodeList = node.getChildNodes();
    if (nodeList != null) {
      for (int i = 0, n = nodeList.getLength(); i &amp;lt; n; i++) {
        Node node = nodeList.item(i);
        if (node.getNodeType() == Node.ELEMENT_NODE) {
          children.add(new XNode(xpathParser, node, variables));
        }
      }
    }
    return children;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上是调用了 &lt;strong&gt;DOM&lt;/strong&gt; 中的 &lt;code&gt;Node&lt;/code&gt; 类的 getChildNodes 函数， 并将返回的节点转换为 &lt;code&gt;XNode&lt;/code&gt; , 添加到对应的 &lt;code&gt;List&lt;/code&gt; 中返回。&lt;/p&gt;
&lt;h3 id=&quot;获取子节点并存到-properties-对象中&quot;&gt;3.2.3 获取子节点并存到 Properties 对象中&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public Properties getChildrenAsProperties() {
    Properties properties = new Properties();
    for (XNode child : getChildren()) {
      String name = child.getStringAttribute(&quot;name&quot;);
      String value = child.getStringAttribute(&quot;value&quot;);
      if (name != null &amp;amp;&amp;amp; value != null) {
        properties.setProperty(name, value);
      }
    }
    return properties;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些子节点都含有 &lt;strong&gt;name&lt;/strong&gt; 和 &lt;strong&gt;value&lt;/strong&gt; 属性， 存 &lt;strong&gt;name-&amp;gt;value&lt;/strong&gt; 的形式。&lt;/p&gt;
&lt;h2 id=&quot;节点相关成员变量及其解析&quot;&gt;3.3 节点相关成员变量及其解析&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Configuration&lt;/code&gt;中有很多成员变量：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180918235328572?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;成员变量&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以分为以下几种, 按配置的顺序：&lt;/p&gt;
&lt;h3 id=&quot;properties-属性相关&quot;&gt;3.3.1 properties 属性相关&lt;/h3&gt;
&lt;h4 id=&quot;成员变量&quot;&gt;3.3.1.1 成员变量&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;protected Properties variables = new Properties();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应 &lt;code&gt;Properties&amp;gt;&lt;/code&gt;类， 可以将相应的配置 &lt;strong&gt;.properties&lt;/strong&gt; 的文件信息存放到里面。&lt;/p&gt;
&lt;h4 id=&quot;对应-xml-节点properties&quot;&gt;3.3.1.2 对应 XML 节点:&amp;lt;properties&amp;gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;properties resource=&quot;mysql.properties&quot;&amp;gt; &amp;lt;/properties&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;作用&quot;&gt;3.3.1.3 作用&lt;/h4&gt;
&lt;p&gt;如 mysql.properties 文件， 其内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql.driver=com.mysql.jdbc.Driver
mysql.url=jdbc:mysql://localhost:3306/mybatis
mysql.username=root
mysql.password=jim666&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在解析后， 存放在 variables 成员变量中， 是这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180919000001774?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;属性&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样做的目的是我们可以将这些属性在后面的内容中复用:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
    &amp;lt;property name=&quot;driver&quot; value=&quot;${mysql.driver}&quot;/&amp;gt;
    &amp;lt;property name=&quot;url&quot; value=&quot;${mysql.url}&quot;/&amp;gt;
    &amp;lt;property name=&quot;username&quot; value=&quot;${mysql.username}&quot;/&amp;gt;
    &amp;lt;property name=&quot;password&quot; value=&quot;${mysql.password}&quot;/&amp;gt;
&amp;lt;/dataSource&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;解析过程&quot;&gt;3.3.1.4 解析过程&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;private void propertiesElement(XNode context) throws Exception {
    if (context != null) {
      // 先解析&amp;lt;properties&amp;gt;下的各个子节点， 以name-&amp;gt;value的形式记录到 Properties 对象中
      Properties defaults = context.getChildrenAsProperties();
      // 解析 resource 和 url 属性
      String resource = context.getStringAttribute(&quot;resource&quot;);
      String url = context.getStringAttribute(&quot;url&quot;);
      // resource 和 url 属性不能同时不为空， 也就是说只能存在一个
      if (resource != null &amp;amp;&amp;amp; url != null) {
        throw new BuilderException(&quot;The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.&quot;);
      }
      // 根据 resource 或 url， 将对应的 .properties 文件加载进来， 并将内容全部存到 Properties 对象中
      if (resource != null) {
        defaults.putAll(Resources.getResourceAsProperties(resource));
      } else if (url != null) {
        defaults.putAll(Resources.getUrlAsProperties(url));
      } 
      // 将Configuration 对象中原先的属性合并进来。
      Properties vars = configuration.getVariables();
      if (vars != null) {
        defaults.putAll(vars);
      }
      // 两个含有该成员变量的类对象更新
      parser.setVariables(defaults);
      configuration.setVariables(defaults);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;几个要点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先读取的是 &lt;strong&gt;&amp;lt;properties&amp;gt;&lt;/strong&gt; 下的 &lt;strong&gt;&amp;lt;propertie&amp;gt;&lt;/strong&gt; 属性；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&amp;lt;properties&amp;gt;&lt;/strong&gt; 中， 不能同时存在 resource 和 url 属性；&lt;/li&gt;
&lt;li&gt;更新时， 不单单只是更新 &lt;strong&gt;configuration&lt;/strong&gt;， XPathParser 对象也需要更新， 后面用得到。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;settings-属性相关&quot;&gt;3.3.2 settings 属性相关&lt;/h3&gt;
&lt;h4 id=&quot;成员变量-1&quot;&gt;3.3.2.1 成员变量&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;  protected boolean safeRowBoundsEnabled;
  protected boolean safeResultHandlerEnabled = true;
  protected boolean mapUnderscoreToCamelCase;
  protected boolean aggressiveLazyLoading;
  protected boolean multipleResultSetsEnabled = true;
  protected boolean useGeneratedKeys;
  protected boolean useColumnLabel = true;
  protected boolean cacheEnabled = true;
  protected boolean callSettersOnNulls;
  protected boolean useActualParamName = true;
  protected boolean returnInstanceForEmptyRow;

  protected String logPrefix;
  protected Class &amp;lt;? extends Log&amp;gt; logImpl;
  protected Class &amp;lt;? extends VFS&amp;gt; vfsImpl;
  protected LocalCacheScope localCacheScope = LocalCacheScope.SESSION;
  protected JdbcType jdbcTypeForNull = JdbcType.OTHER;
  protected Set&amp;lt;String&amp;gt; lazyLoadTriggerMethods = new HashSet&amp;lt;String&amp;gt;(Arrays.asList(new String[] { &quot;equals&quot;, &quot;clone&quot;, &quot;hashCode&quot;, &quot;toString&quot; }));
  protected Integer defaultStatementTimeout;
  protected Integer defaultFetchSize;
  protected ExecutorType defaultExecutorType = ExecutorType.SIMPLE;
  protected AutoMappingBehavior autoMappingBehavior = AutoMappingBehavior.PARTIAL;
  protected AutoMappingUnknownColumnBehavior autoMappingUnknownColumnBehavior = AutoMappingUnknownColumnBehavior.NONE;
  
  protected boolean lazyLoadingEnabled = false;
  protected ProxyFactory proxyFactory = new JavassistProxyFactory();
  
  protected Class&amp;lt;?&amp;gt; configurationFactory;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成员变量名称和以上配置文件的 &lt;strong&gt;name&lt;/strong&gt; 属性一一对应。&lt;/p&gt;
&lt;h4 id=&quot;对应-xml-节点settings&quot;&gt;3.3.2.2 对应 XML 节点:&amp;lt;settings&amp;gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;settings&amp;gt;
    &amp;lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&amp;gt;
    ...
&amp;lt;/settings&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 &lt;strong&gt;XML&lt;/strong&gt; 文件中， &amp;lt;settings&amp;gt;节点内其实有很多 &amp;lt;setting&amp;gt; 节点， 但是他们都有默认值， 因此一般情况下， 我们只需要配置一些我们需要改变的配置即可。&lt;/p&gt;
&lt;p&gt;一个配置完整的 settings 元素的示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;settings&amp;gt;
  &amp;lt;!--允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为false。--&amp;gt;
  &amp;lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&amp;gt;
  &amp;lt;!--允许在嵌套语句中使用分页（ResultHandler）。如果允许使用则设置为false。--&amp;gt;
  &amp;lt;setting name=&quot;safeResultHandlerEnabled&quot; value=&quot;true&quot;/&amp;gt;
  &amp;lt;!--是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 --&amp;gt;
  &amp;lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&amp;gt;
  &amp;lt;!--当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载（参考lazyLoadTriggerMethods).  (true in ≤3.4.1) --&amp;gt;
  &amp;lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&amp;gt;
  &amp;lt;!--是否允许单一语句返回多结果集（需要兼容驱动）。--&amp;gt;
  &amp;lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&amp;gt;
  &amp;lt;!--允许 JDBC 支持自动生成主键，需要驱动兼容。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）。--&amp;gt;
  &amp;lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&amp;gt;
  &amp;lt;!--使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。--&amp;gt;
  &amp;lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&amp;gt;
  &amp;lt;!--全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存。 --&amp;gt;
  &amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt;
  &amp;lt;!--指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。--&amp;gt;
  &amp;lt;setting name=&quot;callSettersOnNulls&quot; value=&quot;false&quot;/&amp;gt;
  &amp;lt;!--允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的工程必须采用Java 8编译，并且加上-parameters选项。（从3.4.1开始）--&amp;gt;
  &amp;lt;setting name=&quot;useActualParamName&quot; value=&quot;true&quot;/&amp;gt;
  &amp;lt;!--当返回行的所有列都是空时，MyBatis默认返回null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集 (i.e. collectioin and association)。（从3.4.2开始） --&amp;gt;
  &amp;lt;setting name=&quot;returnInstanceForEmptyRow&quot; value=&quot;false&quot;/&amp;gt;
  &amp;lt;!--增加到日志名称的前缀， 默认没有--&amp;gt;
  &amp;lt;setting name=&quot;logPrefix&quot; value=&quot;&quot;/&amp;gt;
  &amp;lt;!--日志的实现类型， 默认未指定， 未指定时将自动查找--&amp;gt;
  &amp;lt;setting name=&quot;logImpl&quot; value=&quot;&quot;/&amp;gt;
  &amp;lt;!--指定VFS的实现， 默认未指定--&amp;gt;
  &amp;lt;setting name=&quot;vfsImpl&quot; value=&quot;&quot;/&amp;gt;
  &amp;lt;!--默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。 --&amp;gt;
  &amp;lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&amp;gt;
  &amp;lt;!--当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型--&amp;gt;
  &amp;lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&amp;gt;
  &amp;lt;!--  指定哪个对象的方法触发一次延迟加载。--&amp;gt;
  &amp;lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&amp;gt;
  &amp;lt;!--设置超时时间，它决定驱动等待数据库响应的秒数。--&amp;gt;
  &amp;lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&amp;gt;
  &amp;lt;!--为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。 --&amp;gt;
  &amp;lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&amp;gt;
  &amp;lt;!--配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。--&amp;gt;
  &amp;lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&amp;gt;
  &amp;lt;!--指定 MyBatis 应如何自动映射列到字段或属性--&amp;gt;
  &amp;lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&amp;gt;
  &amp;lt;!--指定发现自动映射目标未知列（或者未知属性类型）的行为--&amp;gt;
  &amp;lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&amp;gt;
  &amp;lt;!--延迟加载的全局开关--&amp;gt;
  &amp;lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;false&quot;/&amp;gt;
  &amp;lt;!--指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具--&amp;gt;
  &amp;lt;setting name=&quot;proxyFactory&quot; value=&quot;JAVASSIST&quot;/&amp;gt;
  &amp;lt;!--指定一个提供Configuration实例的类--&amp;gt;
  &amp;lt;setting name=&quot;configurationFactory&quot; value=&quot;&quot;/&amp;gt;
&amp;lt;/settings&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更具体的内容， 参见 &lt;a href=&quot;http://www.mybatis.org/mybatis-3/zh/configuration.html#settings&quot;&gt;mybatis简介&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;作用-1&quot;&gt;3.3.2.3 作用&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;settings&lt;/strong&gt; 是 &lt;strong&gt;MyBatis&lt;/strong&gt; 中极为重要的设置，它们会改变 &lt;strong&gt;MyBatis&lt;/strong&gt; 的运行时行为。&lt;/p&gt;
&lt;h4 id=&quot;解析过程-1&quot;&gt;3.3.1.4 解析过程&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;private Properties settingsAsProperties(XNode context) {
    if (context == null) {
      return new Properties();
    }
    // 解析所有的子节点， 并存到 Properties 对象中。
    Properties props = context.getChildrenAsProperties();
    // Check that all settings are known to the configuration class
    // 创建对应的 MetaClass 对象
    MetaClass metaConfig = MetaClass.forClass(Configuration.class, localReflectorFactory);
    // 检测 Configuraion 对象中是否定义了相应的 setter 方法, 不定义代表不存在该属性， 直接抛异常
    for (Object key : props.keySet()) {
      if (!metaConfig.hasSetter(String.valueOf(key))) {
        throw new BuilderException(&quot;The setting &quot; + key + &quot; is not known.  Make sure you spelled it correctly (case sensitive).&quot;);
      }
    }
    return props;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;typealiases-相关属性&quot;&gt;3.3.3 typeAliases 相关属性&lt;/h3&gt;
&lt;h4 id=&quot;成员变量-2&quot;&gt;3.3.3.1 成员变量&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;protected final TypeAliasRegistry typeAliasRegistry = new TypeAliasRegistry();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;对应-xml-节点typealiases&quot;&gt;3.3.3.2 对应 XML 节点:&amp;lt;typeAliases&amp;gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;typeAliases&lt;/code&gt;， 即类型别名。类型别名是为 Java 类型设置一个短的名字。它只和 XML 配置有关，存在的意义仅在于用来减少类完全限定名的冗余。&lt;/p&gt;
&lt;h4 id=&quot;作用-2&quot;&gt;3.3.3.3 作用&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;typeAliases&amp;gt;
  &amp;lt;typeAlias alias=&quot;Author&quot; type=&quot;domain.blog.Author&quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似以上配置， 当需要使用&lt;code&gt;domain.blog.Author&lt;/code&gt;时， 我们可以用&lt;code&gt;Author&lt;/code&gt;来进行代替。&lt;/p&gt;
&lt;p&gt;当开启包扫描之后， 在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。&lt;/p&gt;
&lt;h4 id=&quot;解析过程-2&quot;&gt;3.3.3.4 解析过程&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;private void typeAliasesElement(XNode parent) {
    if (parent != null) {
      // 处理全部的子类
      for (XNode child : parent.getChildren()) {
        // 处理 &amp;lt;package&amp;gt; 子节点
        if (&quot;package&quot;.equals(child.getName())) {
          // 获取配置处的属性 name , 其对应着包名
          String typeAliasPackage = child.getStringAttribute(&quot;name&quot;);
          configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);
        } else {
          // 处理 &amp;lt;typeAlias&amp;gt;节点
          String alias = child.getStringAttribute(&quot;alias&quot;);
          String type = child.getStringAttribute(&quot;type&quot;);
          try {
            Class&amp;lt;?&amp;gt; clazz = Resources.classForName(type);
            if (alias == null) {
              // 如果alias没有配置，则按照约定的方式注册类
              typeAliasRegistry.registerAlias(clazz);
            } else {
              // alias 配置了， 则将类注册到alias
              typeAliasRegistry.registerAlias(alias, clazz);
            }
          } catch (ClassNotFoundException e) {
            throw new BuilderException(&quot;Error registering typeAlias for '&quot; + alias + &quot;'. Cause: &quot; + e, e);
          }
        }
      }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;plugins-相关属性&quot;&gt;3.3.4 plugins 相关属性&lt;/h3&gt;
&lt;h4 id=&quot;成员变量-3&quot;&gt;3.3.4.1 成员变量&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;protected final InterceptorChain interceptorChain = new InterceptorChain();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;对应-xml-节点plugins&quot;&gt;3.3.4.2 对应 XML 节点:&amp;lt;plugins&amp;gt;&lt;/h4&gt;
&lt;p&gt;在之前的项目中， 没有配置相应的plugins, 但可以参考使用 &lt;strong&gt;Mybatis-PageHelper&lt;/strong&gt; 的配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;plugins&amp;gt;
    &amp;lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&amp;gt;
        &amp;lt;!-- config params as the following --&amp;gt;
        &amp;lt;property name=&quot;param1&quot; value=&quot;value1&quot;/&amp;gt;
    &amp;lt;/plugin&amp;gt;
&amp;lt;/plugins&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;作用-3&quot;&gt;3.3.4.3 作用&lt;/h4&gt;
&lt;p&gt;插件是 MyBatis 提供的扩展机制之一，用户可以通过添加自定义插件在 SQL 语句执行过程中的某一点进行拦截。&lt;/p&gt;
&lt;p&gt;更具体的后面会专门开一章进行讲解。&lt;/p&gt;
&lt;h4 id=&quot;解析过程-3&quot;&gt;3.3.4.4 解析过程&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;private void pluginElement(XNode parent) throws Exception {
    if (parent != null) {
      // 遍历 &amp;lt;pluagins&amp;gt; 下的所有 &amp;lt;plugin&amp;gt; 节点
      for (XNode child : parent.getChildren()) {
        // 获取对应的 &amp;lt;plugin&amp;gt; 中的 interceptor 属性
        String interceptor = child.getStringAttribute(&quot;interceptor&quot;);
        // 获取 &amp;lt;plugin&amp;gt; 下的所有 &amp;lt;property&amp;gt; 节点， 并以 name-&amp;gt;value 的形式存入 Properties 对象中
        Properties properties = child.getChildrenAsProperties();
        // 通过反射生成对象
        Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();
        // 设置拦截器的属性
        interceptorInstance.setProperties(properties);
        // 将拦截器添加到 Configuration 对象中
        configuration.addInterceptor(interceptorInstance);
      }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;objectfactory-相关属性&quot;&gt;3.3.5 objectFactory 相关属性&lt;/h3&gt;
&lt;h4 id=&quot;成员变量-4&quot;&gt;3.3.5.1 成员变量&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;protected ObjectFactory objectFactory = new DefaultObjectFactory();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;对应-xml-节点objectfactory&quot;&gt;3.3.5.2 对应 XML 节点:&amp;lt;objectFactory&amp;gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;objectFactory type=&quot;org.mybatis.example.ExampleObjectFactory&quot;&amp;gt;
  &amp;lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&amp;gt;
&amp;lt;/objectFactory&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;作用-4&quot;&gt;3.3.5.3 作用&lt;/h4&gt;
&lt;p&gt;MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认构造方法，要么在参数映射存在的时候通过参数构造方法来实例化。 如果想覆盖对象工厂的默认行为，则可以通过创建自己的对象工厂来实现。&lt;/p&gt;
&lt;h4 id=&quot;解析过程-4&quot;&gt;3.3.5.4 解析过程&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;private void objectFactoryElement(XNode context) throws Exception {
    if (context != null) {
      // 获取 &amp;lt;objectFactory&amp;gt; 的type属性
      String type = context.getStringAttribute(&quot;type&quot;);
      // 获取 &amp;lt;plugin&amp;gt; 下的所有 &amp;lt;property&amp;gt; 节点， 并以 name-&amp;gt;value 的形式存入 Properties 对象中
      Properties properties = context.getChildrenAsProperties();
      // 通过反射生成对象
      ObjectFactory factory = (ObjectFactory) resolveClass(type).newInstance();
      // 设置属性
      factory.setProperties(properties);
      // 将 ObjectFactory 对象设置到 Configuration 对象中
      configuration.setObjectFactory(factory);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;objectwrapperfactory-相关属性&quot;&gt;3.3.6 objectWrapperFactory 相关属性&lt;/h3&gt;
&lt;h4 id=&quot;成员变量-5&quot;&gt;3.3.6.1 成员变量&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;protected ObjectWrapperFactory objectWrapperFactory = new DefaultObjectWrapperFactory();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;对应-xml-节点objectwrapperfactory&quot;&gt;3.3.6.2 对应 XML 节点:&amp;lt;objectWrapperFactory&amp;gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;objectWrapperFactory type=&quot;&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;作用-5&quot;&gt;3.3.6.3 作用&lt;/h4&gt;
&lt;p&gt;启用之后， 可以自己实现驼峰效果。&lt;/p&gt;
&lt;h4 id=&quot;解析过程-5&quot;&gt;3.3.6.4 解析过程&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;private void objectWrapperFactoryElement(XNode context) throws Exception {
    if (context != null) {
      // 获取 &amp;lt;objectWrapperFactory&amp;gt; 的type属性
      String type = context.getStringAttribute(&quot;type&quot;);
      // 通过反射生成 ObjectWrapperFactory 对象
      ObjectWrapperFactory factory = (ObjectWrapperFactory) resolveClass(type).newInstance();
      // 将 ObjectWrapperFactory 对象设置到 Configuration 对象中
      configuration.setObjectWrapperFactory(factory);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;reflectorfactory-相关属性&quot;&gt;3.3.7 reflectorFactory 相关属性&lt;/h3&gt;
&lt;h4 id=&quot;成员变量-6&quot;&gt;3.3.7.1 成员变量&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;protected ObjectWrapperFactory objectWrapperFactory = new DefaultObjectWrapperFactory();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;对应-xml-节点reflectorfactory&quot;&gt;3.3.7.2 对应 XML 节点:&amp;lt;reflectorFactory&amp;gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;reflectorFactory type=&quot;&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;作用-6&quot;&gt;3.3.7.3 作用&lt;/h4&gt;
&lt;p&gt;可以自己定义反射类&lt;/p&gt;
&lt;h4 id=&quot;解析过程-6&quot;&gt;3.3.7.4 解析过程&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;private void reflectorFactoryElement(XNode context) throws Exception {
    if (context != null) {
       // 获取 &amp;lt;objectWrapperFactory&amp;gt; 的type属性
       String type = context.getStringAttribute(&quot;type&quot;);
       // 通过反射生成 ReflectorFactory 对象
       ReflectorFactory factory = (ReflectorFactory) resolveClass(type).newInstance();
        // 将 ReflectorFactory 对象设置到 Configuration 对象中
       configuration.setReflectorFactory(factory);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;environments-相关属性&quot;&gt;3.3.8 environments 相关属性&lt;/h3&gt;
&lt;h4 id=&quot;成员变量-7&quot;&gt;3.3.8.1 成员变量&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;protected Environment environment;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Enviroment 中， 含有id， 事务， 数据源：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final class Environment {
  private final String id;
  private final TransactionFactory transactionFactory;
  private final DataSource dataSource;
  ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;对应-xml-节点environments&quot;&gt;3.3.8.2 对应 XML 节点:&amp;lt;environments&amp;gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;environments default=&quot;development&quot;&amp;gt;
    &amp;lt;environment id=&quot;development&quot;&amp;gt;
        &amp;lt;transactionManager type=&quot;JDBC&quot;&amp;gt;
            &amp;lt;property name=&quot;&quot; value=&quot;&quot;/&amp;gt;
        &amp;lt;/transactionManager&amp;gt;
        &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
            &amp;lt;property name=&quot;driver&quot; value=&quot;${mysql.driver}&quot;/&amp;gt;
            &amp;lt;property name=&quot;url&quot; value=&quot;${mysql.url}&quot;/&amp;gt;
            &amp;lt;property name=&quot;username&quot; value=&quot;${mysql.username}&quot;/&amp;gt;
            &amp;lt;property name=&quot;password&quot; value=&quot;${mysql.password}&quot;/&amp;gt;
        &amp;lt;/dataSource&amp;gt;
    &amp;lt;/environment&amp;gt;
&amp;lt;/environments&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Environment主要用于配置数据源和事务信息。Mybatis支持多环境设置，可以为开发，测试，生产使用不同的配置。&lt;/p&gt;
&lt;h4 id=&quot;作用-7&quot;&gt;3.3.8.3 作用&lt;/h4&gt;
&lt;p&gt;就是设置数据库连接的环境， 需要配置事务管理器和数据源来构造相应的对象。&lt;/p&gt;
&lt;p&gt;既然&lt;code&gt;environments&lt;/code&gt;可以配置多个&lt;code&gt;environment&lt;/code&gt;, 那么为什么成员变量的类型不是&lt;code&gt;List&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;答： &lt;strong&gt;多个环境，每个 SqlSessionFactory 实例只能选择其一&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;解析过程-7&quot;&gt;3.3.8.4 解析过程&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;  private void environmentsElement(XNode context) throws Exception {
    if (context != null) {
      // 未指定， 则使用 default 属性指定的 &amp;lt;environment&amp;gt;
      if (environment == null) {
        environment = context.getStringAttribute(&quot;default&quot;);
      }
      // 遍历所有的 &amp;lt;environment&amp;gt; 子节点
      for (XNode child : context.getChildren()) {
        String id = child.getStringAttribute(&quot;id&quot;);
        // 只有 id 与 XMLConfigBuilder 的 environment 匹配上才会进行解析里面的内容
        if (isSpecifiedEnvironment(id)) {
          // 创建 TransactionFactory 对象
          TransactionFactory txFactory = transactionManagerElement(child.evalNode(&quot;transactionManager&quot;));
          // 创建 DataSourceFactory 对象， 并以之创建 DataSource 对象
          DataSourceFactory dsFactory = dataSourceElement(child.evalNode(&quot;dataSource&quot;));
          DataSource dataSource = dsFactory.getDataSource();
          // 创建 Environment.Builder 对象， 将以上产生的对象对应设置到该对象中
          Environment.Builder environmentBuilder = new Environment.Builder(id)
              .transactionFactory(txFactory)
              .dataSource(dataSource);
          // environmentBuilder.build()创建 Environment 对象， 并设置到 Configuration 对象对应的成员变量中
          configuration.setEnvironment(environmentBuilder.build());
        }
      }
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;databaseidprovider-相关属性&quot;&gt;3.3.9 databaseIdProvider 相关属性&lt;/h3&gt;
&lt;h4 id=&quot;成员变量-8&quot;&gt;3.3.9.1 成员变量&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;protected String databaseId;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;对应-xml-节点databaseidprovider&quot;&gt;3.3.9.2 对应 XML 节点:&amp;lt;databaseIdProvider&amp;gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;databaseIdProvider type=&quot;DB_VENDOR&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;作用-8&quot;&gt;3.3.9.3 作用&lt;/h4&gt;
&lt;p&gt;MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。在后续的 &lt;strong&gt;XXXXmapper.xml&lt;/strong&gt; 文件中， 可以指定 &lt;strong&gt;databaseId&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;解析过程-8&quot;&gt;3.3.9.4 解析过程&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;  private void databaseIdProviderElement(XNode context) throws Exception {
    DatabaseIdProvider databaseIdProvider = null;
    if (context != null) {
      String type = context.getStringAttribute(&quot;type&quot;);
      // awful patch to keep backward compatibility
      // 为了兼容， 更改 type 为 VENDOR 至 DB_VENDOR
      if (&quot;VENDOR&quot;.equals(type)) {
          type = &quot;DB_VENDOR&quot;;
      }
      // 解析对应的配置信息
      Properties properties = context.getChildrenAsProperties();
      // 通过反射生成对象
      databaseIdProvider = (DatabaseIdProvider) resolveClass(type).newInstance();
      // 设置属性
      databaseIdProvider.setProperties(properties);
    }
    Environment environment = configuration.getEnvironment();
    
    if (environment != null &amp;amp;&amp;amp; databaseIdProvider != null) {
      String databaseId = databaseIdProvider.getDatabaseId(environment.getDataSource());
      configuration.setDatabaseId(databaseId);
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;typehandlers-相关属性&quot;&gt;3.3.10 typeHandlers 相关属性&lt;/h3&gt;
&lt;h4 id=&quot;成员变量-9&quot;&gt;3.3.10.1 成员变量&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;protected final TypeHandlerRegistry typeHandlerRegistry;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;对应-xml-节点typehandlers&quot;&gt;3.3.10.2 对应 XML 节点:&amp;lt;typeHandlers&amp;gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;typeHandlers&amp;gt;
  &amp;lt;typeHandler handler=&quot;org.mybatis.example.ExampleTypeHandler&quot;/&amp;gt;
&amp;lt;/typeHandlers&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;作用-9&quot;&gt;3.3.10.3 作用&lt;/h4&gt;
&lt;p&gt;无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。&lt;/p&gt;
&lt;h4 id=&quot;解析过程-9&quot;&gt;3.3.10.4 解析过程&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;private void typeHandlerElement(XNode parent) throws Exception {
    if (parent != null) {
      // 遍历所有的子节点
      for (XNode child : parent.getChildren()) {
        // 包（package）子节点
        if (&quot;package&quot;.equals(child.getName())) {
          String typeHandlerPackage = child.getStringAttribute(&quot;name&quot;);
          typeHandlerRegistry.register(typeHandlerPackage);
        } else { // 非 package 子节点
          // 获取相应的属性
          String javaTypeName = child.getStringAttribute(&quot;javaType&quot;);
          String jdbcTypeName = child.getStringAttribute(&quot;jdbcType&quot;);
          String handlerTypeName = child.getStringAttribute(&quot;handler&quot;);
          // 根据属性， 通过反射创建对象
          Class&amp;lt;?&amp;gt; javaTypeClass = resolveClass(javaTypeName);
          JdbcType jdbcType = resolveJdbcType(jdbcTypeName);
          Class&amp;lt;?&amp;gt; typeHandlerClass = resolveClass(handlerTypeName);
          // 将对象注册到 typeHandlerRegistry 对象中
          if (javaTypeClass != null) {
            if (jdbcType == null) {
              typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);
            } else {
              typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);
            }
          } else {
            typeHandlerRegistry.register(typeHandlerClass);
          }
        }
      }
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mappers-相关属性&quot;&gt;3.3.11 mappers 相关属性&lt;/h3&gt;
&lt;h4 id=&quot;成员变量-10&quot;&gt;3.3.11.1 成员变量&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt; //映射的语句
protected final Map&amp;lt;String, MappedStatement&amp;gt; mappedStatements = new StrictMap&amp;lt;MappedStatement&amp;gt;(&quot;Mapped Statements collection&quot;);
// 缓存集合
protected final Map&amp;lt;String, Cache&amp;gt; caches = new StrictMap&amp;lt;Cache&amp;gt;(&quot;Caches collection&quot;);
// 结果集合
protected final Map&amp;lt;String, ResultMap&amp;gt; resultMaps = new StrictMap&amp;lt;ResultMap&amp;gt;(&quot;Result Maps collection&quot;);
// 存储过程参数集合
protected final Map&amp;lt;String, ParameterMap&amp;gt; parameterMaps = new StrictMap&amp;lt;ParameterMap&amp;gt;(&quot;Parameter Maps collection&quot;);
// 主键生成器合集
protected final Map&amp;lt;String, KeyGenerator&amp;gt; keyGenerators = new StrictMap&amp;lt;KeyGenerator&amp;gt;(&quot;Key Generators collection&quot;);

protected final Set&amp;lt;String&amp;gt; loadedResources = new HashSet&amp;lt;String&amp;gt;();
protected final Map&amp;lt;String, XNode&amp;gt; sqlFragments = new StrictMap&amp;lt;XNode&amp;gt;(&quot;XML fragments parsed from previous mappers&quot;);

// 存储不完整的语句
protected final Collection&amp;lt;XMLStatementBuilder&amp;gt; incompleteStatements = new LinkedList&amp;lt;XMLStatementBuilder&amp;gt;();
protected final Collection&amp;lt;CacheRefResolver&amp;gt; incompleteCacheRefs = new LinkedList&amp;lt;CacheRefResolver&amp;gt;();
protected final Collection&amp;lt;ResultMapResolver&amp;gt; incompleteResultMaps = new LinkedList&amp;lt;ResultMapResolver&amp;gt;();
protected final Collection&amp;lt;MethodResolver&amp;gt; incompleteMethods = new LinkedList&amp;lt;MethodResolver&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;对应-xml-节点mappers&quot;&gt;3.3.11.2 对应 XML 节点:&amp;lt;mappers&amp;gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;mappers&amp;gt;
    &amp;lt;package name=&quot;com.homejim.mybatis.mapper&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;作用-10&quot;&gt;3.3.11.3 作用&lt;/h4&gt;
&lt;p&gt;mybatis-config.xml 配置文件中的＜mappers＞节点会告诉 MyBatis 去哪些位置查找映射配置文件以及使用了配置注解标识的接口。&lt;/p&gt;
&lt;p&gt;这也是配置文件解析的重点， 后续会开一篇文章进行讲解。&lt;/p&gt;
&lt;h4 id=&quot;解析过程-10&quot;&gt;3.3.11.4 解析过程&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;  private void mapperElement(XNode parent) throws Exception {
    if (parent != null) {
      for (XNode child : parent.getChildren()) {
        // &amp;lt;package&amp;gt; 子节点， 就是包下面的类
        if (&quot;package&quot;.equals(child.getName())) {
          String mapperPackage = child.getStringAttribute(&quot;name&quot;);
          configuration.addMappers(mapperPackage);
        } else { // 对应 &amp;lt;mapper&amp;gt; 子节点
          // resource / url / class 中 3选1
          String resource = child.getStringAttribute(&quot;resource&quot;);
          String url = child.getStringAttribute(&quot;url&quot;);
          String mapperClass = child.getStringAttribute(&quot;class&quot;);
          // 如果节点指定了 resource 或 url， 则创建 XMLMapperBuilder 对象， 
          // 通过该对象的 parse() 函数将 mapper 添加到 configuration 中
          if (resource != null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass == null) {
            ErrorContext.instance().resource(resource);
            InputStream inputStream = Resources.getResourceAsStream(resource);
            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());
            mapperParser.parse();
          } else if (resource == null &amp;amp;&amp;amp; url != null &amp;amp;&amp;amp; mapperClass == null) {
            ErrorContext.instance().resource(url);
            InputStream inputStream = Resources.getUrlAsStream(url);
            XMLMapperBuilder mapperParser = new XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());
            mapperParser.parse();
          } else if (resource == null &amp;amp;&amp;amp; url == null &amp;amp;&amp;amp; mapperClass != null) {
            Class&amp;lt;?&amp;gt; mapperInterface = Resources.classForName(mapperClass);
            configuration.addMapper(mapperInterface);
          } else {
            throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);
          }
        }
      }
    }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个是后面需要更详细的开章节进行讲解的。&lt;/p&gt;

&lt;p&gt;至此， 本文章就结束了。 本来是想写更详细一点的， 后面发现篇幅越来越大， 因此有一些部分没有展开。后续会挑某些部分的解析过程进行更深入的讲解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果您觉得还可以， 给个赞吧。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 18 Sep 2018 16:14:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>看完之后， 你就明白mybatis是如何解析配置文件了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/9672224.html</dc:identifier>
</item>
<item>
<title>.NET西安社区 [拥抱开源，又见 .NET] 活动简报 - .NET西安社区</title>
<link>http://www.cnblogs.com/xiandnc/p/9671905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiandnc/p/9671905.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413706/201809/1413706-20180918224226456-1729969901.png&quot; alt=&quot;&quot; width=&quot;724&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;拥抱开源, 又见 .NET」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;随着 .NET Core的发布和开源，.NET又重新回到了人们的视野。除了开源、跨平台、高性能以及优秀的语言特性，越来越多的第三方开源库也出现在了Github上——包括ML.NET机器学习、Xamarin移动开发平台、基于Actor模型的分布式框架Orleans以及分布式开发及部署平台Service Fabric等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9月15日 .NET西安社区第一次线下分享交流会如期举行并取得圆满成功；以下是活动本次活动的精彩内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1413706/201809/1413706-20180918224440112-506379175.png&quot; alt=&quot;&quot; width=&quot;724&quot; height=&quot;550&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img class=&quot;m_-3618777044857827066m_4197985313132386423m_346241576649129318inbox-inbox-mcnImage CToWUd a6T&quot; src=&quot;https://ci4.googleusercontent.com/proxy/mMbkBGh_OJlPO_RXybl3UN52oknWw2bXv8jBPw8e0X5hs5KvAN9GD1WEZVglVMVDluj_Ym9AtfEWoWXIaT4hMDZQ6U8bYFt5nJFF4rRURkbW9R8G2D5kwRlDLLY6ce9zQ4zaNvT1AMkn79RxRmgX78vUAHqrJk8Vqi44Oom9F_jlQDk=s0-d-e1-ft#https://gallery.mailchimp.com/c51fe856261b7e9ceefd0e79a/_compresseds/782b2f7e-7384-46a3-8cca-4369cbc43351.jpg&quot; alt=&quot;&quot; width=&quot;309&quot; height=&quot;232&quot;/&gt;      &lt;img class=&quot;m_-3618777044857827066m_4197985313132386423m_346241576649129318inbox-inbox-mcnImage CToWUd a6T&quot; src=&quot;https://ci5.googleusercontent.com/proxy/Q20XUSHq7mfSfRfc8SvrVw47kRG8kyT-goRexh84jPWwWNBwDILUSMudyiISXkQIjNZetAJ0zyR6xKQ_McNJ0TKGD-j6-gauN421sgg-joMM_SJWV7J6QnmWoD_63toRsomq-EDVqaF44N3N0NsNXY3-zsta5a1OXHeI7kfXtnwQ0Uw=s0-d-e1-ft#https://gallery.mailchimp.com/c51fe856261b7e9ceefd0e79a/_compresseds/2ee8eb4f-4dc5-4418-823f-f0ceb0ece0b8.jpg&quot; alt=&quot;&quot; width=&quot;309&quot; height=&quot;232&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;m_-3618777044857827066m_4197985313132386423m_346241576649129318inbox-inbox-mcnImage CToWUd a6T&quot; src=&quot;https://ci6.googleusercontent.com/proxy/_N30oL1HnMZ8xaCF3QlEZSM7KrNvc8wTaTeMf9FEN-8JWmpz7-Svo79MWbv8KYfhAhwWGk8QbU0LiNly7wuJeygyZ8qv6CANsnXye0YK58DFjY80FPn2-yHc56V9_NUO_GhA1FDrGai4RKzttUVABT8ke_gQbiVNyDQloD9MjDDMgn8=s0-d-e1-ft#https://gallery.mailchimp.com/c51fe856261b7e9ceefd0e79a/_compresseds/1dcc1873-baa1-4e6a-a9fc-31d65f4e0ae7.jpg&quot; alt=&quot;&quot; width=&quot;309&quot; height=&quot;232&quot;/&gt;      &lt;img class=&quot;m_-3618777044857827066m_4197985313132386423m_346241576649129318inbox-inbox-mcnImage CToWUd a6T&quot; src=&quot;https://ci3.googleusercontent.com/proxy/04aYdeoZM2to7HyT3hh5GI2JpmiPxmC3iCW8jlHWvjG3BFcAxNhxLFKjqhjfDtckB7Xqz1XVhk-c-zj4z1Sr0tZ42tzz-QXu98fr0ZZy7XR_KTdTdWNIgk0U0UOIw1_UDvXHm_G2L-M3gAVWfnLQHSO9E3C5_Ua9fQtojSgX0bqrlUc=s0-d-e1-ft#https://gallery.mailchimp.com/c51fe856261b7e9ceefd0e79a/_compresseds/5e264564-2ba0-4322-975f-860b21ee994a.jpg&quot; alt=&quot;&quot; width=&quot;309&quot; height=&quot;232&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;活动反馈：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1413706/201809/1413706-20180918225240768-1870851214.png&quot; alt=&quot;&quot; width=&quot;724&quot; height=&quot;550&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;感谢张阳对F#普及，改变了自己很多对代码的认识。希望能分享一些&lt;span&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-2.1&quot; target=&quot;_blank&quot; data-saferedirecturl=&quot;https://www.google.com/url?hl=en&amp;amp;q=https://docs.microsoft.com/en-us/aspnet/core/?view%3Daspnetcore-2.1&amp;amp;source=gmail&amp;amp;ust=1537367771308000&amp;amp;usg=AFQjCNEJxp0Zi7hA7UAoiOm6kgqxElfOdQ&quot;&gt;ASP.NET Core&lt;/a&gt;&lt;/span&gt;大型工程化的经验和干货。也愿意作为讲师分享使用Blazor的心得；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;认识了新朋友，对DotNet了解更深入，觉得应该有一些 .NET Core新特性，以及相对于 .NET Fx的优势的介绍，期望下次活动分享交流Azure，.NET Core应用架构相关经验心得；也愿意作为讲师进行&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-2.1&quot; target=&quot;_blank&quot; data-saferedirecturl=&quot;https://www.google.com/url?hl=en&amp;amp;q=https://docs.microsoft.com/en-us/aspnet/core/?view%3Daspnetcore-2.1&amp;amp;source=gmail&amp;amp;ust=1537367771308000&amp;amp;usg=AFQjCNEJxp0Zi7hA7UAoiOm6kgqxElfOdQ&quot;&gt;ASP.NET Core&lt;/a&gt;+Azure App Service+ Azure SQL实践分享；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;增长了见识，见识到很多新的技术，多增加互动的环节效果会更好；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;特别鸣谢：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;感谢魏琼东，张文清，张阳三位讲师为我们带来的精彩话题；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;感谢西安thoughtworks对「拥抱开源, 又见 .NET」第一次线下分享交流活动的大力支持；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;还有陈计节，远在北京，特意主动联系我们，赞助 .NET西安社区《C#本质论》&amp;amp;《.NET性能优化》共10本图书；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;感谢彭子健，马建勋，阿布，何易凡，王婧，卢冲（排名以报名顺序为准）牺牲周末，冒雨前来，协助社区布置活动现场，维护活动内外场秩序。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;非常感谢大家的鼎力支持，是你们的支持和付出，促成了 .NET西安社区的成立，也促成了西安地区第一次 .NET线下分享交流会的圆满成功！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后的最后，期待大家对 .NET西安社区持续关注，更期待大家线上、线下分享。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面是三位讲师的ppt下载链接。&lt;/span&gt;&lt;/p&gt;




</description>
<pubDate>Tue, 18 Sep 2018 15:11:00 +0000</pubDate>
<dc:creator>.NET西安社区</dc:creator>
<og:description>拥抱开源, 又见 .NET」 随着 .NET Core的发布和开源，.NET又重新回到了人们的视野。除了开源、跨平台、高性能以及优秀的语言特性，越来越多的第三方开源库也出现在了Github上——包括M</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiandnc/p/9671905.html</dc:identifier>
</item>
<item>
<title>机器学习之KNN原理与代码实现 - w_x_w1985</title>
<link>http://www.cnblogs.com/further-further-further/p/9670187.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/further-further-further/p/9670187.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;Created on Mon Sep 17 15:58:58 2018
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;KNN(K-Nearest Neighbor) K-近邻算法
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;@author: weixw
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; operator
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输入：行测试数据集，训练数据集，标签数据集，用于选择最近邻居的数目&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;功能：根据欧氏距离公式，找到与未知类别的测试数据距离最小的 k 个点，&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     以这 k 个点出现频率最高的类别座位测试数据的预测分类。&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     欧氏距离公式：测试数据与训练数据对应位置作差，平方和，然后开方&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出：测试数据预测分类结果&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; classify(testDataSet, trainingDataSet, labelList, k):
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;训练数据集行数&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;     trainingDataSetSize =&lt;span&gt; trainingDataSet.shape[0]
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;np.tile(testDataSet, (trainingDataSetSize,1)沿X轴复制1倍（相当于没有复制），再沿Y轴复制trainingDataSetSize倍，维数：1000*3&lt;/span&gt;
&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;欧氏距离公式实现 &lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;1 测试数据 - 训练数据&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;     diffMat = np.mat(np.tile(testDataSet, (trainingDataSetSize, 1)) -&lt;span&gt; trainingDataSet)
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;2 差平方（需要将matrix转化为数组，否则报错）&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt;     sqDiffMat = diffMat.A**2
&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;3 按行求和 axis = 0(默认按列) axis = 1(按行)&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;     sqDistances = sqDiffMat.sum(axis = 1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;4 开方&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;     distances = sqDistances**0.5
&lt;span&gt; 28&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;agrsort():从小到大排序，返回欧氏距离最小值对应的索引列表&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt;     sortedDistIndicies =&lt;span&gt; distances.argsort()
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;预测分类计数&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;     predictClassCount =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;多数表决方式，选择 k 个欧氏距离最小值 &lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(k):
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;找到索引对应的标签值&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;         voteLabel =&lt;span&gt; labelList[sortedDistIndicies[i]]
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;预测标签值字典，存储索引标签值预测次数&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;         predictClassCount[voteLabel] = predictClassCount.get(voteLabel, 0) + 1
&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;对象按值逆向（由大到小）排序 &lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; sorted(iterable[, cmp[, key[, reverse]]])&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; itemgetter(1) 取第一项结果&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;     sortedPredictClassCount = sorted(predictClassCount.items(), key = operator.itemgetter(1), reverse =&lt;span&gt; True)
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sortedPredictClassCount[0][0]
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输入：数据文件&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;功能：加载文件，文件最后一列是标签数据，分离特征数据集与标签数据集&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     自动检测多少列特征数据并分离&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出：特征数据集矩阵，标签数据集矩阵&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; loadDataSet(fileName):
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;特征数据列长度&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;     numberFeat = len(open(fileName).readline().split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)) - 1
&lt;span&gt; 53&lt;/span&gt;     dataSet = []; labelSet =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     fr =&lt;span&gt; open(fileName)
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; fr.readlines():
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         lineArr =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;去除收尾空格，然后分割每一列&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt;         curLine = line.strip().split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存每一列特征数据&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(numberFeat):
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;            lineArr.append(float(curLine[i]))
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;        dataSet.append(lineArr)
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;         labelSet.append(float(curLine[-1&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; np.mat(dataSet), labelSet
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输入：原始特征数据集&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;功能：数据归一化，使每类数据都在同一范围内 (0, 1) 变化&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     归一化公式：newValue = (oldValue - min)/(max - min)&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出：归一化后特征数据集，范围数组大小（分母）,列最小值数组   &lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; autoNorm(dataMat):
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;min(axis) 无参数：所有值中最小值；axis = 0：每列最小值；axis = 1：每行最小值&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;求出每列最小值&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;     minValsMat =&lt;span&gt; dataMat.min(0)
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;求出每列最大值&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;     maxValsMat =&lt;span&gt; dataMat.max(0)
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算差值（对应位置相减）&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt;     rangesMat = maxValsMat -&lt;span&gt; minValsMat
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;归一化特征数据集初始化，维数：1000*3&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;     normDataMat =&lt;span&gt; np.zeros(np.shape(dataMat))
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;原始数据集行数目&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;     m =&lt;span&gt; dataMat.shape[0]
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;归一化公式分子实现&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;np.tile(minVals, (m,1)沿X轴复制1倍（相当于没有复制），再沿Y轴复制m倍，维数：1000*3&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;     normDataMat = dataMat - np.tile(minValsMat, (m, 1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;归一化公式实现，求得归一化结果&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt;     normDataMat = normDataMat/np.tile(rangesMat, (m, 1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; normDataMat, rangesMat, minValsMat
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输入：特征数据集矩阵，标签数据集列表，测试数据与训练数据比例，用于选择最近邻居的数目&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;功能：求出测试特征数据集预测分类结果&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.解析文件&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.通过ratio确定测试数据集&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.归一化&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.对每一行测试数据运用欧氏距离公式以及多数表决方式预测分类结果&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5.求出整个测试数据集的预测分类结果&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出：测试数据预测分类结果&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; dataClassify(dataMat, labelList, ratio, k):
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;         
&lt;span&gt; 99&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;特征数据集归一化&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt;     normDataMat, rangesMat, minValsMat =&lt;span&gt; autoNorm(dataMat)
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;归一化特征数据集行数目&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt;     m =&lt;span&gt; normDataMat.shape[0]
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;测试数据集行数目（也就知道训练数据集行数）&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt;     testDataNum = int(m*&lt;span&gt;ratio)
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;预测分类错误计数&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt;     errorCount = 0.0
&lt;span&gt;107&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(testDataNum):
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;求出测试数据集每行预测分类&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;         classifierResult =&lt;span&gt; classify(normDataMat[i, :], normDataMat[testDataNum:m, :], labelList[testDataNum:m], k)
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the classifier result is: %d, the real answer is: %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt; (classifierResult, labelList[i]))
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;统计错误预测分类&lt;/span&gt;
&lt;span&gt;112&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(classifierResult !=&lt;span&gt; labelList[i]):
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             errorCount += 1.0
&lt;span&gt;114&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the total error count is %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt; errorCount)
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the total error rate is: %f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(errorCount/&lt;span&gt;float(testDataNum)))
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;     
&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;绘制散点图&lt;/span&gt;
&lt;span&gt;119&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; drawScatter(filename):
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;     &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;加载文件，分离特征数据集和标签数据集&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt;     dataMat, labelList =&lt;span&gt; loadDataSet(filename)
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;矩阵转化为数组&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt;     dataArr =&lt;span&gt; dataMat.A
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一副图画&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt; &lt;span&gt;    plt.figure()
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存标签类型相同的索引值（观察标签数据集，有3种不同类型）&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt;     label_idx1 = []; label_idx2 = []; label_idx3 =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;遍历标签数组，索引，值&lt;/span&gt;
&lt;span&gt;130&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; index, value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(labelList):
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(value == 1&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;            label_idx1.append(index)
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;         &lt;span&gt;elif&lt;/span&gt;(value == 2&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;            label_idx2.append(index)
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;            label_idx3.append(index)
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;scatter(x,y,s,maker,color,label)&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;x,y必须是数组类型，s表示形状大小，maker:形状&lt;/span&gt;
&lt;span&gt;139&lt;/span&gt;     plt.scatter(dataArr[label_idx1, 1], dataArr[label_idx1, 2], marker = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, color = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;m&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, label = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;no like&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, s = 30&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;     plt.scatter(dataArr[label_idx2, 1], dataArr[label_idx2, 2], marker = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, color = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, label = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;like&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, s = 50&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;     plt.scatter(dataArr[label_idx3, 1], dataArr[label_idx3, 2], marker = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, color = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, label = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;very like&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, s = 15&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;     plt.legend(loc = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;upper right&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;         
&lt;span&gt;144&lt;/span&gt;         
&lt;/pre&gt;</description>
<pubDate>Tue, 18 Sep 2018 15:09:00 +0000</pubDate>
<dc:creator>w_x_w1985</dc:creator>
<og:description>KNN原理与代码实现 本文系作者原创，转载请注明出处:https://www.cnblogs.com/further-further-further/p/9670187.html 1. KNN原理 K</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/further-further-further/p/9670187.html</dc:identifier>
</item>
<item>
<title>使用Dapper处理多个结果集和多重映射的教程 - 省厓</title>
<link>http://www.cnblogs.com/shengya/p/9671932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shengya/p/9671932.html</guid>
<description>&lt;p&gt;在本文中，我们将介绍如何使用DAPPER从单个数据库调用中读取数据库中的多个结果集。我们将看看我们可能希望这样做的场景，以及如何使用它的Query和QueryMultiple方法更简洁地实现这一点。 当我们谈论以数据为中心的应用程序时，可能会出现一些场景，在这些场景中我们可能希望从数据库中检索多重结果。多个结果集既可以是相关的，也可以是无关的。要做到这一点，我们不需要对数据库进行多次往返，而是可以在一次数据库调用本身中实际使用dapper检索结果，然后将结果映射到代码中的所需对象。 在我们继续并开始研究如何做到这一点之前，让我们首先试着理解在我们的应用程序中可能希望做到这一点的场景： &lt;strong&gt;1、查询无关实体：&lt;/strong&gt;所请求的实体根本不相关。 2、&lt;strong&gt;查询具有1至多个关系的相关实体：&lt;/strong&gt;被请求的实体具有1对多的关系，我们需要在代码中处理多个结果集 &lt;strong&gt;3、查询具有1至1关系的相关实体：&lt;/strong&gt;被请求的实体具有1-1关系，我们需要在代码中执行处理多个映射 在第一个场景中，我们有完全不相关的实体，因此基本上，我们只想执行两个独立的查询来检索数据，然后将其映射到这些实体。在第二个场景中，返回的实体与1-多相关，因此我们希望检索数据，然后将结果映射到具有1至多个关系的POCO中。最后，在第三个场景中，返回的实体是1-1，因此我们希望检索数据，然后将结果映射到具有1-1关系的POCO中。 现在让我们看看一些代码，了解如何使用Dapper来实现这一切。 所有这些都可以通过DAPPER的查询、QueryMultiple和Read方法进行归档。现在让我们把重点放在如何在代码中执行这些操作。&lt;/p&gt;

&lt;p&gt;假设我们想从API中检索书籍和视频列表。我们可以通过两个简单的选择所有查询来实现这一点，数据库结果看起来如下： &lt;img src=&quot;https://www.codeproject.com/KB/library/1260540/DBResults1.PNG&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://www.codeproject.com/KB/library/1260540/DBResults1.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，为了能够从代码中执行同样的操作，我们首先需要定义我们的实体：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Book
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; BookName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ISBN { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Video
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; VideoName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用这些模型，让我们看看如何只使用一个数据库调用来使用DAPPER检索这些结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; define our SQL query - it contains mulitple queries seprated by ;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; query = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SELECT * from Books; Select * from Videos&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Execute the query&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; results =&lt;span&gt; dbConnection.QueryMultiple(query);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; retrieve the results into the respective models&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; books = results.Read&amp;lt;Book&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; videos = results.Read&amp;lt;Video&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;new&lt;/span&gt; { Books = books, Videos =&lt;span&gt; videos});
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在让我们在POSTMAN中运行，以查看行动中的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368278/201809/1368278-20180918223359956-1109966857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：我已经创建了一个简单的API控制器来测试这个代码，所有的DB访问代码都在里面运行。这只是为了演示目的和现实世界的应用，这样的代码根本不应该被使用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询具有1到多关系的查询相关实体&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 检索相关实体的另一个典型场景是实体之间存在一对多关系。让我们尝试使用组织和联系人的例子来可视化这一点。组织通常具有与其关联的多个联系人。如果我们想要检索一个组织，并且想要检索所有关联的联系人，我们可以利用QueryMultiple来做到这一点。这就是关系在数据库中的样子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368278/201809/1368278-20180918223714021-1402598326.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先让我们检查一下如何使用SQL查询做同样的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368278/201809/1368278-20180918223803839-900493122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，如果我们必须在代码中做同样的事情，我们首先需要定义我们的实体。请注意，我们的实体也将建模一对多关系的方式，每个组织有一个联系人列表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Organization
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; OrganizationName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;contact&amp;gt; Contacts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Contact
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; OrganizationId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ContactName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}
&lt;/span&gt;&amp;lt;/contact&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在让我们看一下用于检索这些相关实体的代码，并了解如何用dapper的QueryMultiple方法填充与1到多个关系相关的实体。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult GetOrganization(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; define our SQL query - it contains mulitple queries seprated by ;&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; query = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;SELECT* from Organizations where id = @id;
                Select * from Contacts where OrganizationId = @id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Execute the query&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; results = dbConnection.QueryMultiple(query, &lt;span&gt;new&lt;/span&gt; { @id =&lt;span&gt; id });

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; retrieve the results into the respective models&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; org = results.ReadSingle&amp;lt;Organization&amp;gt;&lt;span&gt;();
    org.Contacts &lt;/span&gt;= results.Read&amp;lt;Contact&amp;gt;&lt;span&gt;().ToList();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(org);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的代码中，我们可以看到我们是如何同时执行2个查询的。我们接受了第一个查询结果并填充了我们的组织对象。第二个查询结果作为同一个组织对象的联系人集合被推送。&lt;/p&gt;
&lt;p&gt; 现在让我们在POSTMAN中运行，以查看行动中的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368278/201809/1368278-20180918224046940-2121142997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;具有1到1关系的查询相关实体&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;前两个场景非常简单，因为它们要求我们编写两个独立的查询，然后独立收集每个查询的结果，以便根据需要创建模型对象。&lt;/p&gt;
&lt;p&gt; 但是有1到1个关系的场景是很棘手的。从数据库的角度来看，我们可以在单个SQL查询本身中检索相关实体，但是随后我们希望将单个结果集映射到代码中的多个对象中。这可以使用在DAPPER中可用的多重映射特征来完成。让我们在一个例子的帮助下理解这一点。&lt;/p&gt;
&lt;p&gt; 注意：我们仍然可以使用与1到许多关系相同的方法来检索与1到1相关的数据，但是本节将展示如何使用单个SQL并映射结果。&lt;/p&gt;
&lt;p&gt; 让我们举一个联系和护照的例子。每个联系人只能有一个护照。让我们先想象一下这个数据库关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368278/201809/1368278-20180918224313493-1076495498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在，让我们看看是否需要从数据库中检索联系人列表及其护照信息，我们如何用SQL实现这一点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368278/201809/1368278-20180918231639042-860546003.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在让我们看看我们的实体如何寻找联系和护照。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Contact
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; OrganizationId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ContactName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Passport Passport { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Passport
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Contactid { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; PassportNumber { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在让我们看看如何从数据库中检索这些相关实体，并使用更简洁的多重映射完整地填充具有相同关系的POCOs。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
[HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult GetContact(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; query = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Select
                c.ID, c.Organizationid, c.ContactName,
                p.ID as PassPortId, p.ContactId, p.PassportNumber
                from Contacts c,
                Passports p
                where c.ID = p.ContactID
                and c.id = @id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Execute the query&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; contact = dbConnection.Query&amp;lt;Contact, Passport, Contact&amp;gt;(query, MapResults, &lt;span&gt;new&lt;/span&gt; { @id = id }, splitOn: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PassportId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(contact);
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Contact MapResults(Contact contact, Passport passport)
{
    contact.Passport &lt;/span&gt;=&lt;span&gt; passport;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; contact;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的代码中，我们使用的是查询方法的重载版本，它采用多个类型。传递的类型是我们要映射的每个对象的类型参数，最后一个类型参数是表示该查询将返回的对象类型的附加参数。&lt;/p&gt;

&lt;p&gt;因此，在我们的查询中，我们希望将结果映射到类型Contact和Passsport，然后期望结果返回到类型Contact的对象中。&lt;/p&gt;

&lt;p&gt;现在，让我们看看在查询方法中传递的实际参数。&lt;/p&gt;

&lt;p&gt;第一个参数是SQL查询本身。&lt;/p&gt;
&lt;p&gt;第二个参数是映射函数，它将获取结果，将它绑定到相应的类型，然后创建所需的返回类型并返回该返回类型。在我们的代码中，它采用Contact和Passport类型，并将Contact的Passport属性指定为正在传递的Passport值。一旦这样做，结果接触类型返回。&lt;/p&gt;
&lt;p&gt;第三个参数是命令参数@ id。&lt;/p&gt;
&lt;p&gt;最后一个参数拆分是将告诉DAPPER哪些列必须映射到下一个对象的列名。在我们的示例中，我们将此值作为PassportId传递，这意味着在找到PassportId列之前，所有列都将映射到第一种类型，即Contact，然后随后的列将被映射到下一个参数类型，即Passport。&lt;/p&gt;
&lt;p&gt;注意：如果我们有2个以上的对象需要映射，splitOn将是一个逗号分隔的列表，其中每个列名将充当分隔符，并开始下一个对象类型的映射列。&lt;/p&gt;

&lt;p&gt;现在让我们在POSTMAN中运行，以查看行动中的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368278/201809/1368278-20180918231944055-765209209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欧了，我们使用DAPPER从数据库中检索多个结果集，以避免数据库往返。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在本文中，我们讨论了如何使用dapper提供的特性在一次运行中检索多个相关或无关的实体，从而避免多次数据库往返。这是从初学者的角度写的。我希望这有一定的信息性。&lt;/p&gt;

</description>
<pubDate>Tue, 18 Sep 2018 14:48:00 +0000</pubDate>
<dc:creator>省厓</dc:creator>
<og:description>在本文中，我们将介绍如何使用DAPPER从单个数据库调用中读取数据库中的多个结果集。我们将看看我们可能希望这样做的场景，以及如何使用它的Query和QueryMultiple方法更简洁地实现这一点。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shengya/p/9671932.html</dc:identifier>
</item>
</channel>
</rss>