<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Asp.net Core 使用Jenkins + Dockor 实现持续集成、自动化部署（一）：Jenkins安装 - 乔达摩</title>
<link>http://www.cnblogs.com/xiaxiaolu/p/10041788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaxiaolu/p/10041788.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201811/641760-20181129234042290-2122189149.png&quot; alt=&quot;Related image&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其实园子里很多大佬都写过，我也是一个搬运工很多东西不是原创的，不过还是想把自己安装的过程，记录下来如果能帮到大家的忙，也是一件功德无量的事；&lt;/p&gt;

&lt;p&gt;centos：7.2&lt;br/&gt;cpu:1核 2G内存 1M带宽&lt;br/&gt;其实用的腾讯云&lt;/p&gt;

&lt;p&gt;这里的jenkins就不从docker hub里面直接pull镜像安装了，为什么呢，我这里引用大佬的原话：&lt;/p&gt;
&lt;blockquote readability=&quot;8.5714285714286&quot;&gt;
&lt;p&gt;首先不直接从Docker Store上直接Pull Jenkins 的 Image 文件，因为待会需要进行dotnet core 的 Docker自动部署，需要对宿主机上的Docker进行直接操作，那么需要挂载 Docker 给 Jenkins Image，所以现在需要自己动手编写 Dockerfile 构建自定义的Jenkins。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/LongJiangXie/p/7517909.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/LongJiangXie/p/7517909.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;构建自定义的dockerfile&quot;&gt;1、构建自定义的Dockerfile&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# touch Dockerfile
# vim Dockerfile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入以下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FROM jenkins

USER root
#清除了基础镜像设置的源，切换成腾讯云的jessie源
#使用非腾讯云环境的需要将 tencentyun 改为 aliyun
RUN echo '' &amp;gt; /etc/apt/sources.list.d/jessie-backports.list \
  &amp;amp;&amp;amp; echo &quot;deb http://mirrors.tencentyun.com/debian jessie main contrib non-free&quot; &amp;gt; /etc/apt/sources.list \
  &amp;amp;&amp;amp; echo &quot;deb http://mirrors.tencentyun.com/debian jessie-updates main contrib non-free&quot; &amp;gt;&amp;gt; /etc/apt/sources.list \
  &amp;amp;&amp;amp; echo &quot;deb http://mirrors.tencentyun.com/debian-security jessie/updates main contrib non-free&quot; &amp;gt;&amp;gt; /etc/apt/sources.list
#更新源并安装缺少的包
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y libltdl7 &amp;amp;&amp;amp; apt-get update

ARG dockerGid=999

RUN echo &quot;docker:x:${dockerGid}:jenkins&quot; &amp;gt;&amp;gt; /etc/group 

# 安装 docker-compose 因为等下构建环境的需要
RUN curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose

RUN chmod +x /usr/local/bin/docker-compose&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;build镜像&quot;&gt;2、build镜像&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;docker build . -t auto-jenkins&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201811/641760-20181129234041599-1056173322.png&quot; alt=&quot;1539831424590&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到Successfully 莫名的心情愉悦。这就代表构建成功了；&lt;/p&gt;
&lt;h2 id=&quot;创建jenkins项目文件的挂载目录&quot;&gt;3、创建jenkins项目文件的挂载目录&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;mkdir -p /var/jenkins_home&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;修改目录权限&quot;&gt;4、修改目录权限&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这一步必不可少！会导致权限不足报错&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;chown -R 1000 /var/jenkins_home&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;run我们自定义jenkins镜像-auto-jenkins&quot;&gt;5、run我们自定义jenkins镜像 auto-jenkins&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里我用7080作为对外的jenkins ip（因为我的8080被占用了）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;docker run --name jenkins -p 7080:8080 -p 50000:50000 \
-v /var/run/docker.sock:/var/run/docker.sock \
-v $(which docker):/bin/docker \
-v /var/jenkins_home:/var/jenkins_home \
-d auto-jenkins&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;run之后使用&lt;code&gt;docker ps&lt;/code&gt; 查看运行中的容器，如看到如下图，表示jenkins已正常启动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201811/641760-20181129234041089-274228027.png&quot; alt=&quot;1539832220978&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、完成jenkins安装&lt;/p&gt;
&lt;p&gt;访问 &lt;a href=&quot;http://%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8ip:7080&quot; class=&quot;uri&quot;&gt;http://你的服务器ip:7080&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201811/641760-20181129234040697-609274436.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要安装密码，证明这是你的服务器，进入容器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker exec -it jenkins /bin/bash
cat /var/jenkins_home/secrets/initialAdminPassword&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复制密码填好，点击继续；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201811/641760-20181129234040138-1404589877.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，点击Install suggested plugins，安装jenkins常用插件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201811/641760-20181129234039470-1250485053.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完毕后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/641760/201811/641760-20181129234038881-503695539.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来到这里，其实安装结束了，填写完管理员信息后，开始你的自动化部署之旅吧！&lt;/p&gt;
&lt;p&gt;接下来，请继续看我的另一篇文章 &lt;a href=&quot;https://www.cnblogs.com/xiaxiaolu/p/10041800.html&quot;&gt;Asp.net Core 使用Jenkins + Dockor 实现持续集成、自动化部署（二）：部署&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/LongJiangXie/p/7517909.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/LongJiangXie/p/7517909.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 29 Nov 2018 15:46:00 +0000</pubDate>
<dc:creator>乔达摩</dc:creator>
<og:description>﻿ 写在前面 其实园子里很多大佬都写过，我也是一个搬运工很多东西不是原创的，不过还是想把自己安装的过程，记录下来如果能帮到大家的忙，也是一件功德无量的事； 运行环境 centos：7.2 cpu:1核</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaxiaolu/p/10041788.html</dc:identifier>
</item>
<item>
<title>设计模式之单例模式 - Eurekaa</title>
<link>http://www.cnblogs.com/zuanzuan/p/10041705.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuanzuan/p/10041705.html</guid>
<description>&lt;p&gt;本篇博客归类于设计模式，单例模式算是我了解的不多的设计模式之一，在某些应用场景下为了节省资源，常常使用单例模式来编写代码。&lt;/p&gt;
&lt;p&gt;单例模式（Singleton Pattert）是一种常用的软件设计模式，该模式的主要目的是确保在某一个类中能且只能产生一个实例。当在某些场景下希望某个类只能产生一个实例时，就可以使用单例模式了。&lt;/p&gt;

&lt;p&gt;单例模式也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。&lt;/p&gt;
&lt;p&gt;实现单例模式的思路是：一个类能返回对象一个引用（永远是同一个）和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。&lt;/p&gt;
&lt;p&gt;单例模式在多线程的应用场合下必须小心使用。如果当唯一实例尚未创建时，有两个线程同时调用创建实例方法，那么它们同时没有检测到唯一实例的存在，从而同时各自创建了一个实例，这样就有两个实例被构造出来，从而违反了单例模式中实例惟一的原则。解决这个问题的办法是为指示是否已经实例化的变量提供一个互斥锁（虽然这样会降低效率）。&lt;/p&gt;
&lt;p&gt;在面向对象编程中，学习了使用某一个类来创建多个不同的对象，那么如何使得该类只能产生一个对象呢？&lt;/p&gt;
&lt;p&gt;在Python 中，可以使用多种方法来实现单例模式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用模块&lt;/li&gt;
&lt;li&gt;使用魔术方法__new__&lt;/li&gt;
&lt;li&gt;使用装饰器&lt;/li&gt;
&lt;li&gt;使用元类&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;使用模块&quot;&gt;使用模块&lt;/h2&gt;
&lt;p&gt;python 中的模块就是天然的单例模式，因为模块只会在第一次导入的时候加载，会生成一个 &lt;strong&gt;.pyc&lt;/strong&gt;文件，第二次导入时，就会直接加载 &lt;strong&gt;.pyc&lt;/strong&gt;文件，而不会再次执行模块代码。因此，可以把相关的代码和数据定义在一个模块中，就可以获得一个单例对象了。然后要用的话导入就可以，我可以保证这样做的话肯定只有一个单例对象。代码就不演示了。&lt;/p&gt;
&lt;h2 id=&quot;使用特殊方法__new__&quot;&gt;使用特殊方法__new__&lt;/h2&gt;
&lt;p&gt;在使用类实例化一个对象时，其实python 解释器做了两步操作:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用 object 的__new__方法创建一个空对象；&lt;/li&gt;
&lt;li&gt;调用类本身的__init__方法进行初始化（这都是通过元类的__call__来间接调用的）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么是不是可以在调用__new__的时候做一些判断来使得只能创建一个单例对象呢？&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Singleinstance:
    _instance = None
    def __new__(cls, *arg, **kwargs):
        if not cls._instance:
            cls._instance = super(Singleinstance, cls).__new__(cls, *args, **kwargs)
        return cls._instance
class MyClass(Singleinstance):
    a = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码中，将类的__new__方法和一个类的属性关联起来，如果 cls._instance 为 None 则创建一个对象，否则的话直接返回cls._instance。&lt;/p&gt;
&lt;h2 id=&quot;使用装饰器&quot;&gt;使用装饰器&lt;/h2&gt;
&lt;p&gt;装饰器可以动态的修改一个类或者函数的功能。所以可以使用装饰器来装饰某各类，使其只能生成一个实例：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from functools import wraps

def singleinstance(cls):
    instances = {}
    @wraps(cls)
    def getinstance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    return getinstance

@singleinstance
class MyClass:
    a = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面，定义了一个装饰器 singleinstance，它返回了一个内部函数getinstance，该函数会判断某个类是否在字典 instance 中，如果不存在，则会将 cls 作为 key，cls(*args, **kwargs)作为 value存到 instances 中，否则，直接返回 instances[cls]。该装饰器可以装饰所有只需要产生一个实例的类上。&lt;/p&gt;

&lt;p&gt;元类 metaclass 可以通过自定义__new__方法和__init__方法来控制类的创建过程，它主要做三件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拦截类的创建&lt;/li&gt;
&lt;li&gt;修改类的定义&lt;/li&gt;
&lt;li&gt;返回修改后的类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用元类实现单例的代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class MyMetaClass(type):

    # def __init__(self):
    #     pass

    instance = None
    def __call__(cls, *args, **kwargs):
        # 判断对象有没有创建过
        if not MyMetaClass.instance:
            # 创建空对象
            MyMetaClass.instance = object.__new__(cls)
            print(cls.__name__)
            print(cls.__dict__)
            print(&quot;创建新的播放器对象!&quot;)
            # 初始化对象
            MyMetaClass.instance.__init__(*args,**kwargs)
            print(type(MyMetaClass.instance))
            # 返回对象
        return MyMetaClass.instance

class CDPlayer(metaclass=MyMetaClass):
    pass     &lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 29 Nov 2018 15:25:00 +0000</pubDate>
<dc:creator>Eurekaa</dc:creator>
<og:description>前言 本篇博客归类于设计模式，单例模式算是我了解的不多的设计模式之一，在某些应用场景下为了节省资源，常常使用单例模式来编写代码。 单例模式（Singleton Pattert）是一种常用的软件设计模式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuanzuan/p/10041705.html</dc:identifier>
</item>
<item>
<title>Charles--/安装/破解/支持https抓包 - jack.cx</title>
<link>http://www.cnblogs.com/Jack-cx/p/10041579.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jack-cx/p/10041579.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 一、安装破解Charles&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.下载charles4.0.2版本，下面的jar包需要和charles版本对应&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.&lt;span&gt;下载地址：&lt;/span&gt;&lt;a href=&quot;https://www.cr173.com/soft/494576.html&quot;&gt;&lt;span&gt;https://www.cr173.com/soft/494576.html&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.1&lt;span&gt;这里下的是破解版里面有破解的&lt;/span&gt;&lt;span&gt;Charles.jar&lt;/span&gt;&lt;span&gt;和注册名以及&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.2&lt;span&gt;如果本地有了&lt;/span&gt;&lt;span&gt;4.0.2&lt;/span&gt;&lt;span&gt;版本的&lt;/span&gt;&lt;span&gt;charles&lt;/span&gt;&lt;span&gt;也可以在这个网盘下载破解的&lt;/span&gt;&lt;span&gt;jar&lt;/span&gt;&lt;span&gt;包 &lt;/span&gt;&lt;span&gt;https://pan.baidu.com/s/1Pe3nNLqmYDKM2f15HoNMdw&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3.3.&lt;span&gt;点击&lt;/span&gt;charles&lt;span&gt;完成安装&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3.1&lt;span&gt;在访达中选择此应用显示包内容，找到&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;目录把破解的&lt;/span&gt;&lt;span&gt;Charles.jar&lt;/span&gt;&lt;span&gt;替换进去&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129230157593-1441525345.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;3.2 &lt;span&gt;打开&lt;/span&gt;&lt;span&gt;charles,&lt;/span&gt;&lt;span&gt;导航&lt;/span&gt;&lt;span&gt;--help--register charles&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129230236269-116973962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;3.3 &lt;span&gt;输入&lt;/span&gt;&lt;span&gt;name:&lt;/span&gt;xclient   key&lt;span&gt;：&lt;/span&gt;18e69f6d5bc820d4d3  &lt;span&gt;点击&lt;/span&gt;register&lt;span&gt;重启即破解成功&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129230317770-262560565.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、配置代理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;  1.1&lt;span&gt;导航栏&lt;/span&gt;&lt;span&gt;--Proxy---Proxy Settings  &lt;/span&gt;&lt;span&gt;默认端口&lt;/span&gt;&lt;span&gt;8888&lt;/span&gt; &lt;span&gt;可以自定义，点击&lt;/span&gt;&lt;span&gt;ok&lt;/span&gt;&lt;span&gt;后重启&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129230504734-1854364034.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;1.2&lt;span&gt;手机配置代理，保存后&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;打开&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;访问接口即可&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129230544629-462167898.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;查看请求&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129230627720-1135978482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 这样就配置好了，但是不能抓取https接口，所以现在配置下ssl&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、配置安装ssl抓取https&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.&lt;span&gt;打卡&lt;/span&gt;charles--&amp;gt;help--&amp;gt;ssl proxying---&amp;gt;install charles root certificate....&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129230824087-929926540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;1.&lt;span&gt;下载证书，手机浏览器打开&lt;/span&gt;chls.pro/ssl &lt;span&gt;下载证书&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129230903263-1410568028.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;2.&lt;span&gt;安装到手机&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ios&lt;span&gt;：设置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;通用&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;描述文件&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;选择下载的文件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;span&gt;设置&lt;/span&gt;--&amp;gt;&lt;span&gt;通用&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;关于本机&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;证书信任设置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;选择安装的证书信任&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;安卓：设置&lt;/span&gt;--&amp;gt;&lt;span&gt;设置和隐私&lt;/span&gt;&lt;span&gt;-&amp;gt;-&lt;/span&gt;&lt;span&gt;更多安全设置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;从&lt;/span&gt;&lt;span&gt;SD&lt;/span&gt;&lt;span&gt;卡安装&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;选择下载的文件会弹出命名下即可（以华为为例）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.&lt;span&gt;可以选择性设置抓取指定的&lt;/span&gt;https&lt;span&gt;域名&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129231022187-1165106367.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 重启抓取https接口验证&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327198/201811/1327198-20181129231118647-1922455087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Charles安装和配置代理抓包就完成了！！！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 29 Nov 2018 15:18:00 +0000</pubDate>
<dc:creator>jack.cx</dc:creator>
<og:description>一、安装破解Charles 1.下载charles4.0.2版本，下面的jar包需要和charles版本对应 2.下载地址：https://www.cr173.com/soft/494576.html</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jack-cx/p/10041579.html</dc:identifier>
</item>
<item>
<title>一文让你完全弄懂Stegosaurus - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/10041534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/10041534.html</guid>
<description>&lt;p&gt;国内关于 &lt;code&gt;Stegosaurus&lt;/code&gt; 的介绍少之又少，一般只是单纯的工具使用的讲解之类的，并且本人在学习过程中也是遇到了很多的问题，基于此种情况下写下此文，也是为我逝去的青春时光留个念想吧~&lt;/p&gt;
&lt;h3 id=&quot;stegosaurus是什么&quot;&gt;Stegosaurus是什么？&lt;/h3&gt;
&lt;p&gt;在了解 &lt;code&gt;Stegosaurus&lt;/code&gt; 是什么之前，我们首先需要弄清楚的一个问题是：什么是隐写术？&lt;/p&gt;
&lt;p&gt;隐写术，从字面上来理解，隐是隐藏，所以我们从字面上可以知道，隐写术是一类可以隐藏自己写的一些东西的方法，可能我们所写的这些东西是一些比较重要的信息，不想让别人看到，我们会考虑采取一些办法去隐藏它，比如对所写的文件加解密，用一些特殊的纸张(比如纸张遇到水后，上面的字才会显示出来)之类的。隐写术这种手段在日常生活中用的十分广泛，我相信部分小伙伴们小时候曾经有过写日记的习惯，写完的日记可能不想让爸爸妈妈知道(青春期萌动的内心，咱们都是过来人，都懂这个2333)，所以以前常常会买那种上了把锁的那种日记本，这样就不怕自己的小秘密被爸爸妈妈知道啦。&lt;/p&gt;
&lt;p&gt;事实上，隐写术是一门关于信息隐藏的技巧与科学，专业一点的讲，就是指的是采取一些不让除预期的接收者之外的任何人知晓信息的传递事件或者信息的内容的方法。隐写术的英文叫做 &lt;code&gt;Steganography&lt;/code&gt; ，根据维基百科的解释，这个英文来源于特里特米乌斯的一本讲述密码学与隐写术的著作 &lt;code&gt;Steganographia&lt;/code&gt; ，该书书名源于希腊语，意为“隐秘书写”。(这个不是重点)&lt;/p&gt;
&lt;p&gt;所以今天呢，我们要给大家介绍的是隐写术的其中一个分支(也就是其中一种隐写的方法)，也就是 &lt;code&gt;Stegosaurus&lt;/code&gt; ， &lt;code&gt;Stegosaurus&lt;/code&gt; 是一款隐写工具，它允许我们在 &lt;code&gt;Python&lt;/code&gt; 字节码文件( &lt;code&gt;pyc&lt;/code&gt; 或 &lt;code&gt;pyo&lt;/code&gt; )中嵌入任意 &lt;code&gt;Payload&lt;/code&gt; 。由于编码密度较低，因此我们嵌入 &lt;code&gt;Payload&lt;/code&gt; 的过程既不会改变源代码的运行行为，也不会改变源文件的文件大小。 &lt;code&gt;Payload&lt;/code&gt; 代码会被分散嵌入到字节码之中，所以类似 &lt;code&gt;strings&lt;/code&gt; 这样的代码工具无法查找到实际的 &lt;code&gt;Payload&lt;/code&gt; 。 &lt;code&gt;Python&lt;/code&gt; 的 &lt;code&gt;dis&lt;/code&gt; 模块会返回源文件的字节码，然后我们就可以使用 &lt;code&gt;Stegosaurus&lt;/code&gt; 来嵌入 &lt;code&gt;Payload&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;为了方便维护，我将此项目移至 &lt;code&gt;Github&lt;/code&gt; 上：https://github.com/AngelKitty/stegosaurus&lt;/p&gt;
&lt;p&gt;首先讲到一个工具，不可避免的，我们需要讲解它的用法，我并不会像文档一样工整的把用法罗列在一起，如果需要了解更加细节的部分请参考 &lt;a href=&quot;https://github.com/AngelKitty/stegosaurus&quot;&gt;&lt;code&gt;Github&lt;/code&gt;&lt;/a&gt;上的详细文档，我会拿一些实际的案例去给大家讲解一些常见命令的用法，在后续的文章中，我会大家深入理解 &lt;code&gt;python&lt;/code&gt; 反编译的一些东西。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Stegosaurus&lt;/code&gt; 仅支持 &lt;code&gt;Python3.6&lt;/code&gt; 及其以下版本&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拿到一个工具，我们一般会看看它的基本用法：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;python3 stegosaurus.py -h&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ python3 -m stegosaurus -h
usage: stegosaurus.py [-h] [-p PAYLOAD] [-r] [-s] [-v] [-x] carrier

positional arguments:
  carrier               Carrier py, pyc or pyo file

optional arguments:
  -h, --help            show this help message and exit
  -p PAYLOAD, --payload PAYLOAD
                        Embed payload in carrier file
  -r, --report          Report max available payload size carrier supports
  -s, --side-by-side    Do not overwrite carrier file, install side by side
                        instead.
  -v, --verbose         Increase verbosity once per use
  -x, --extract         Extract payload from carrier file&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224148815-224587391.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到有很多参数选项，我们就以一道赛题来讲解部分参数命令吧~&lt;/p&gt;
&lt;p&gt;我们此次要讲解的这道题是来自 &lt;code&gt;Bugku&lt;/code&gt; 的 &lt;code&gt;QAQ&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;赛题链接如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;http://ctf.bugku.com/files/447e4b626f2d2481809b8690613c1613/QAQ
http://ctf.bugku.com/files/5c02892cd05a9dcd1c5a34ef22dd9c5e/cipher.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先拿到这道题，用 &lt;code&gt;010Editor&lt;/code&gt; 乍一眼看过去，我们可以看到一些特征信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224147720-2014371843.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以判断这是个跟 &lt;code&gt;python&lt;/code&gt; 有关的东西，通过查阅相关资料可以判断这是个 &lt;code&gt;python&lt;/code&gt; 经编译过后的 &lt;code&gt;pyc&lt;/code&gt; 文件。这里可能很多小伙伴们可能不理解了，什么是 &lt;code&gt;pyc&lt;/code&gt; 文件呢？为什么会生成 &lt;code&gt;pyc&lt;/code&gt; 文件？ &lt;code&gt;pyc&lt;/code&gt; 文件又是何时生成的呢？下面我将一一解答这些问题。&lt;/p&gt;
&lt;p&gt;简单来说， &lt;code&gt;pyc&lt;/code&gt; 文件就是 &lt;code&gt;Python&lt;/code&gt; 的字节码文件，是个二进制文件。我们都知道 &lt;code&gt;Python&lt;/code&gt; 是一种全平台的解释性语言，全平台其实就是 &lt;code&gt;Python&lt;/code&gt; 文件在经过解释器解释之后(或者称为编译)生成的 &lt;code&gt;pyc&lt;/code&gt; 文件可以在多个平台下运行，这样同样也可以隐藏源代码。其实， &lt;code&gt;Python&lt;/code&gt; 是完全面向对象的语言， &lt;code&gt;Python&lt;/code&gt; 文件在经过解释器解释后生成字节码对象 &lt;code&gt;PyCodeObject&lt;/code&gt; ， &lt;code&gt;pyc&lt;/code&gt; 文件可以理解为是 &lt;code&gt;PyCodeObject&lt;/code&gt; 对象的持久化保存方式。而 &lt;code&gt;pyc&lt;/code&gt; 文件只有在文件被当成模块导入时才会生成。也就是说， &lt;code&gt;Python&lt;/code&gt; 解释器认为，只有 &lt;code&gt;import&lt;/code&gt; 进行的模块才需要被重用。 生成 &lt;code&gt;pyc&lt;/code&gt; 文件的好处显而易见，当我们多次运行程序时，不需要重新对该模块进行重新的解释。主文件一般只需要加载一次，不会被其他模块导入，所以一般主文件不会生成 &lt;code&gt;pyc&lt;/code&gt; 文件。&lt;/p&gt;
&lt;p&gt;我们举个例子来说明这个问题：&lt;/p&gt;
&lt;p&gt;为了方便起见，我们事先创建一个test文件夹作为此次实验的测试：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mkdir test &amp;amp;&amp;amp; cd test/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设我们现在有个 &lt;code&gt;test.py&lt;/code&gt; 文件，文件内容如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def print_test():
    print('Hello,Kitty!')

print_test()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们执行以下命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;python3 test.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不用说，想必大家都知道打印出的结果是下面这个：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Hello,Kitty!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们通过下面命令查看下当前文件夹下有哪些文件：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ls -alh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224146423-502302143.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以发现，并没有 &lt;code&gt;pyc&lt;/code&gt; 文件生成。&lt;/p&gt;
&lt;p&gt;‘我们再去创建一个文件为 &lt;code&gt;import_test.py&lt;/code&gt; 文件，文件内容如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注： &lt;code&gt;test.py&lt;/code&gt; 和 &lt;code&gt;import_test.py&lt;/code&gt; 应当放在同一文件夹下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import test

test.print_test()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们执行以下命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;python3 import_test.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Hello,Kitty!
Hello,Kitty!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;诶，为啥会打印出两句相同的话呢？我们再往下看，我们通过下面命令查看下当前文件夹下有哪些文件：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ls -alh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;总用量 20K
drwxr-xr-x 3 python python 4.0K 11月  5 20:38 .
drwxrwxr-x 4 python python 4.0K 11月  5 20:25 ..
-rw-r--r-- 1 python python   31 11月  5 20:38 import_test.py
drwxr-xr-x 2 python python 4.0K 11月  5 20:38 __pycache__
-rw-r--r-- 1 python python   58 11月  5 20:28 test.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;诶，多了个 &lt;code&gt;__pycache__&lt;/code&gt; 文件夹，我们进入文件夹下看看有什么？&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cd __pycache__ &amp;amp;&amp;amp; ls&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224145422-875160291.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到生成了一个 &lt;code&gt;test.cpython-36.pyc&lt;/code&gt; 。为什么是这样子呢？&lt;/p&gt;
&lt;p&gt;我们可以看到，我们在执行 &lt;code&gt;python3 import_test.py&lt;/code&gt; 命令的时候，首先开始执行的是 &lt;code&gt;import test&lt;/code&gt; ，即导入 &lt;code&gt;test&lt;/code&gt; 模块，而一个模块被导入时， &lt;code&gt;PVM(Python Virtual Machine)&lt;/code&gt; 会在后台从一系列路径中搜索该模块，其搜索过程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在当前目录下搜索该模块&lt;/li&gt;
&lt;li&gt;在环境变量 &lt;code&gt;PYTHONPATH&lt;/code&gt; 中指定的路径列表中依次搜索&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;python&lt;/code&gt; 安装路径中搜索&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;事实上， &lt;code&gt;PVM&lt;/code&gt; 通过变量 &lt;code&gt;sys.path&lt;/code&gt; 中包含的路径来搜索，这个变量里面包含的路径列表就是上面提到的这些路径信息。&lt;/p&gt;
&lt;p&gt;模块的搜索路径都放在了 &lt;code&gt;sys.path&lt;/code&gt; 列表中，如果缺省的 &lt;code&gt;sys.path&lt;/code&gt; 中没有含有自己的模块或包的路径，可以动态的加入 &lt;code&gt;(sys.path.apend)&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;事实上， &lt;code&gt;Python&lt;/code&gt; 中所有加载到内存的模块都放在 &lt;code&gt;sys.modules&lt;/code&gt; 。当 &lt;code&gt;import&lt;/code&gt; 一个模块时首先会在这个列表中查找是否已经加载了此模块，如果加载了则只是将模块的名字加入到正在调用 &lt;code&gt;import&lt;/code&gt; 的模块的 &lt;code&gt;Local&lt;/code&gt; 名字空间中。如果没有加载则从 &lt;code&gt;sys.path&lt;/code&gt; 目录中按照模块名称查找模块文件，模块文件可以是 &lt;code&gt;py&lt;/code&gt; 、 &lt;code&gt;pyc&lt;/code&gt; 、 &lt;code&gt;pyd&lt;/code&gt; ，找到后将模块载入内存，并加入到 &lt;code&gt;sys.modules&lt;/code&gt; 中，并将名称导入到当前的 &lt;code&gt;Local&lt;/code&gt; 名字空间。&lt;/p&gt;
&lt;p&gt;可以看出来，&lt;strong&gt;一个模块不会重复载入&lt;/strong&gt;。多个不同的模块都可以用 &lt;code&gt;import&lt;/code&gt; 引入同一个模块到自己的 &lt;code&gt;Local&lt;/code&gt; 名字空间，其实背后的 &lt;code&gt;PyModuleObject&lt;/code&gt; 对象只有一个。&lt;/p&gt;
&lt;p&gt;在这里，我还要说明一个问题，&lt;strong&gt;&lt;code&gt;import&lt;/code&gt; 只能导入模块，不能导入模块中的对象(类、函数、变量等)。&lt;/strong&gt;例如像上面这个例子，我在 &lt;code&gt;test.py&lt;/code&gt; 里面定义了一个函数 &lt;code&gt;print_test()&lt;/code&gt; ，我在另外一个模块文件 &lt;code&gt;import_test.py&lt;/code&gt;不能直接通过 &lt;code&gt;import test.print_test&lt;/code&gt; 将 &lt;code&gt;print_test&lt;/code&gt; 导入到本模块文件中，只能用 &lt;code&gt;import test&lt;/code&gt; 进行导入。如果我想只导入特定的类、函数、变量，用 &lt;code&gt;from test import print_test&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224144386-1313733869.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然说到了 &lt;code&gt;import&lt;/code&gt; 导入机制，再提一提嵌套导入和 &lt;code&gt;Package&lt;/code&gt; 导入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;import&lt;/code&gt; 嵌套导入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;嵌套，不难理解，就是一个套着一个。小时候我们都玩过俄罗斯套娃吧，俄罗斯套娃就是一个大娃娃里面套着一个小娃娃，小娃娃里面还有更小的娃娃，而这个嵌套导入也是同一个意思。假如我们现在有一个模块，我们想要导入模块 &lt;code&gt;A&lt;/code&gt; ，而模块 &lt;code&gt;A&lt;/code&gt; 中有含有其他模块需要导入，比如模块 &lt;code&gt;B&lt;/code&gt; ，模块 &lt;code&gt;B&lt;/code&gt; 中又含有模块 &lt;code&gt;C&lt;/code&gt; ，一直这样延续下去，这种方式我们称之为 &lt;code&gt;import&lt;/code&gt; 嵌套导入。&lt;/p&gt;
&lt;p&gt;对这种嵌套比较容易理解，我们需要注意的一点就是各个模块的 &lt;code&gt;Local&lt;/code&gt; 名字空间是独立的，所以上面的例子，本模块 &lt;code&gt;import A&lt;/code&gt; 完了后，本模块只能访问模块 &lt;code&gt;A&lt;/code&gt; ，不能访问 &lt;code&gt;B&lt;/code&gt; 及其它模块。虽然模块 &lt;code&gt;B&lt;/code&gt; 已经加载到内存了，如果要访问，还必须明确在本模块中导入 &lt;code&gt;import B&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;那如果我们有以下嵌套这种情况，我们该怎么处理呢？&lt;/p&gt;
&lt;p&gt;比如我们现在有个模块 &lt;code&gt;A&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# A.py
from B import D
class C:
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有个模块 &lt;code&gt;B&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# B.py
from A import C
class D:
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们简单分析一下程序，如果程序运行，应该会去从模块B中调用对象D。&lt;/p&gt;
&lt;p&gt;我们尝试执行一下 &lt;code&gt;python A.py&lt;/code&gt; ：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224143517-1778488256.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;报 &lt;code&gt;ImportError&lt;/code&gt; 的错误，似乎是没有加载到对象 &lt;code&gt;D&lt;/code&gt; ，而我们将 &lt;code&gt;from B import D&lt;/code&gt; 改成 &lt;code&gt;import B&lt;/code&gt; ，我们似乎就能执行成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224142796-1461623914.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是怎么回事呢？这其实是跟 &lt;code&gt;Python&lt;/code&gt; 内部 &lt;code&gt;import&lt;/code&gt; 的机制是有关的，具体到 &lt;code&gt;from B import D&lt;/code&gt; ， &lt;code&gt;Python&lt;/code&gt; 内部会分成以下几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;sys.modules&lt;/code&gt; 中查找符号 &lt;code&gt;B&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果符号 &lt;code&gt;B&lt;/code&gt; 存在，则获得符号 &lt;code&gt;B&lt;/code&gt; 对应的 &lt;code&gt;module&lt;/code&gt; 对象 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; 。从 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; 的 &lt;code&gt;__dict__&lt;/code&gt; 中获得符号 &lt;code&gt;D&lt;/code&gt; 对应的对象，如果 &lt;code&gt;D&lt;/code&gt; 不存在，则抛出异常&lt;/li&gt;
&lt;li&gt;如果符号 &lt;code&gt;B&lt;/code&gt; 不存在，则创建一个新的 &lt;code&gt;module&lt;/code&gt; 对象 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; ，注意，此时 &lt;code&gt;module&lt;/code&gt; 对象的 &lt;code&gt;__dict__&lt;/code&gt; 为空。执行 &lt;code&gt;B.py&lt;/code&gt; 中的表达式，填充 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; 的 &lt;code&gt;__dict__&lt;/code&gt; 。从 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; 的 &lt;code&gt;__dict__&lt;/code&gt; 中获得 &lt;code&gt;D&lt;/code&gt; 对应的对象。如果 &lt;code&gt;D&lt;/code&gt; 不存在，则抛出异常。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，这个例子的执行顺序如下：&lt;/p&gt;
&lt;p&gt;1、执行 &lt;code&gt;A.py&lt;/code&gt; 中的 &lt;code&gt;from B import D&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注：由于是执行的 &lt;code&gt;python A.py&lt;/code&gt; ，所以在 &lt;code&gt;sys.modules&lt;/code&gt; 中并没有 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; 存在，首先为 &lt;code&gt;B.py&lt;/code&gt; 创建一个 &lt;code&gt;module&lt;/code&gt; 对象( &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; )，注意，这时创建的这个 &lt;code&gt;module&lt;/code&gt; 对象是空的，里边啥也没有，在 &lt;code&gt;Python&lt;/code&gt; 内部创建了这个 &lt;code&gt;module&lt;/code&gt; 对象之后，就会解析执行 &lt;code&gt;B.py&lt;/code&gt; ，其目的是填充 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; 这个 &lt;code&gt;dict&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、执行 &lt;code&gt;B.py&lt;/code&gt; 中的 &lt;code&gt;from A import C&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注：在执行 &lt;code&gt;B.py&lt;/code&gt; 的过程中，会碰到这一句，首先检查 &lt;code&gt;sys.modules&lt;/code&gt; 这个 &lt;code&gt;module&lt;/code&gt; 缓存中是否已经存在 &lt;code&gt;&amp;lt;module A&amp;gt;&lt;/code&gt; 了，由于这时缓存还没有缓存 &lt;code&gt;&amp;lt;module A&amp;gt;&lt;/code&gt; ，所以类似的， &lt;code&gt;Python&lt;/code&gt; 内部会为 &lt;code&gt;A.py&lt;/code&gt; 创建一个 &lt;code&gt;module&lt;/code&gt; 对象( &lt;code&gt;&amp;lt;module A&amp;gt;&lt;/code&gt; )，然后，同样地，执行 &lt;code&gt;A.py&lt;/code&gt; 中的语句。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、再次执行 &lt;code&gt;A.py&lt;/code&gt; 中的 &lt;code&gt;from B import D&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注：这时，由于在第 &lt;code&gt;1&lt;/code&gt; 步时，创建的 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; 对象已经缓存在了 &lt;code&gt;sys.modules&lt;/code&gt; 中，所以直接就得到了 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; ，但是，注意，从整个过程来看，我们知道，这时 &lt;code&gt;&amp;lt;module B&amp;gt;&lt;/code&gt; 还是一个空的对象，里面啥也没有，所以从这个 &lt;code&gt;module&lt;/code&gt; 中获得符号 &lt;code&gt;D&lt;/code&gt; 的操作就会抛出异常。如果这里只是 &lt;code&gt;import B&lt;/code&gt; ，由于 &lt;code&gt;B&lt;/code&gt; 这个符号在 &lt;code&gt;sys.modules&lt;/code&gt; 中已经存在，所以是不会抛出异常的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以从下图很清楚的看到 &lt;code&gt;import&lt;/code&gt; 嵌套导入的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224141887-1531061124.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Package&lt;/code&gt; 导入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;包 &lt;code&gt;(Package)&lt;/code&gt; 可以看成模块的集合，只要一个文件夹下面有个 &lt;code&gt;__init__.py&lt;/code&gt; 文件，那么这个文件夹就可以看做是一个包。包下面的文件夹还可以成为包(子包)。更进一步的讲，多个较小的包可以聚合成一个较大的包。通过包这种结构，我们可以很方便的进行类的管理和维护，也方便了用户的使用。比如 &lt;code&gt;SQLAlchemy&lt;/code&gt; 等都是以包的形式发布给用户的。&lt;/p&gt;
&lt;p&gt;包和模块其实是很类似的东西，如果查看包的类型： &lt;code&gt;import SQLAlchemy type(SQLAlchemy)&lt;/code&gt; ，可以看到其实也是 &lt;code&gt;&amp;lt;type 'module'&amp;gt;&lt;/code&gt; 。 &lt;code&gt;import&lt;/code&gt; 包的时候查找的路径也是 &lt;code&gt;sys.path&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;包导入的过程和模块的基本一致，只是导入包的时候会执行此包目录下的 &lt;strong&gt;&lt;code&gt;__init__.py&lt;/code&gt;&lt;/strong&gt; ，而不是模块里面的语句了。另外，如果只是单纯的导入包，而包的 &lt;code&gt;__init__.py&lt;/code&gt; 中又没有明确的其他初始化操作，那么此包下面的模块是不会自动导入的。&lt;/p&gt;
&lt;p&gt;假设我们有如下文件结构：&lt;/p&gt;
&lt;pre class=&quot;markdown&quot;&gt;
&lt;code&gt;.
└── PA
    ├── __init__.py
    ├── PB1
    │   ├── __init__.py
    │   └── pb1_m.py
    ├── PB2
    │   ├── __init__.py
    │   └── pb2_m.py
    └── wave.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224140878-350095984.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wave.py&lt;/code&gt; ， &lt;code&gt;pb1_m.py&lt;/code&gt; ， &lt;code&gt;pb2_m.py&lt;/code&gt; 文件中我们均定义了如下函数：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def getName():
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;__init__.py&lt;/code&gt; 文件内容均为空。&lt;/p&gt;
&lt;p&gt;我们新建一个 &lt;code&gt;test.py&lt;/code&gt; ，内容如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys
import PA.wave #1
import PA.PB1 #2
import PA.PB1.pb1_m as m1 #3
import PA.PB2.pb2_m #4
PA.wave.getName() #5
m1.getName() #6
PA.PB2.pb2_m.getName() #7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们运行以后，可以看出是成功执行成功了，我们再看看目录结构：&lt;/p&gt;
&lt;pre class=&quot;markdown&quot;&gt;
&lt;code&gt;.
├── PA
│   ├── __init__.py
│   ├── __init__.pyc
│   ├── PB1
│   │   ├── __init__.py
│   │   ├── __init__.pyc
│   │   ├── pb1_m.py
│   │   └── pb1_m.pyc
│   ├── PB2
│   │   ├── __init__.py
│   │   ├── __init__.pyc
│   │   ├── pb2_m.py
│   │   └── pb2_m.pyc
│   ├── wave.py
│   └── wave.pyc
└── test.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224140068-2085643088.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来分析一下这个过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当执行&lt;code&gt;#1&lt;/code&gt; 后， &lt;code&gt;sys.modules&lt;/code&gt; 会同时存在 &lt;code&gt;PA&lt;/code&gt; 、 &lt;code&gt;PA.wave&lt;/code&gt; 两个模块，此时可以调用 &lt;code&gt;PA.wave&lt;/code&gt; 的任何类或函数了。但不能调用 &lt;code&gt;PA.PB1(2)&lt;/code&gt; 下的任何模块。当前 &lt;code&gt;Local&lt;/code&gt; 中有了 &lt;code&gt;PA&lt;/code&gt; 名字。&lt;/li&gt;
&lt;li&gt;当执行 &lt;code&gt;#2&lt;/code&gt; 后，只是将 &lt;code&gt;PA.PB1&lt;/code&gt; 载入内存， &lt;code&gt;sys.modules&lt;/code&gt; 中会有 &lt;code&gt;PA&lt;/code&gt; 、 &lt;code&gt;PA.wave&lt;/code&gt; 、 &lt;code&gt;PA.PB1&lt;/code&gt; 三个模块，但是 &lt;code&gt;PA.PB1&lt;/code&gt; 下的任何模块都没有自动载入内存，此时如果直接执行 &lt;code&gt;PA.PB1.pb1_m.getName()&lt;/code&gt; 则会出错，因为 &lt;code&gt;PA.PB1&lt;/code&gt; 中并没有 &lt;code&gt;pb1_m&lt;/code&gt; 。当前 &lt;code&gt;Local&lt;/code&gt; 中还是只有 &lt;code&gt;PA&lt;/code&gt; 名字，并没有 &lt;code&gt;PA.PB1&lt;/code&gt; 名字。&lt;/li&gt;
&lt;li&gt;当执行 &lt;code&gt;#3&lt;/code&gt; 后，会将 &lt;code&gt;PA.PB1&lt;/code&gt; 下的 &lt;code&gt;pb1_m&lt;/code&gt; 载入内存， &lt;code&gt;sys.modules&lt;/code&gt; 中会有 &lt;code&gt;PA&lt;/code&gt; 、 &lt;code&gt;PA.wave&lt;/code&gt; 、 &lt;code&gt;PA.PB1&lt;/code&gt; 、 &lt;code&gt;PA.PB1.pb1_m&lt;/code&gt; 四个模块，此时可以执行 &lt;code&gt;PA.PB1.pb1_m.getName()&lt;/code&gt; 了。由于使用了 &lt;code&gt;as&lt;/code&gt; ，当前 &lt;code&gt;Local&lt;/code&gt; 中除了 &lt;code&gt;PA&lt;/code&gt; 名字，另外添加了 &lt;code&gt;m1&lt;/code&gt; 作为 &lt;code&gt;PA.PB1.pb1_m&lt;/code&gt; 的别名。&lt;/li&gt;
&lt;li&gt;当执行 &lt;code&gt;#4&lt;/code&gt; 后，会将 &lt;code&gt;PA.PB2&lt;/code&gt; 、 &lt;code&gt;PA.PB2.pb2_m&lt;/code&gt; 载入内存， &lt;code&gt;sys.modules&lt;/code&gt; 中会有 &lt;code&gt;PA&lt;/code&gt; 、 &lt;code&gt;PA.wave&lt;/code&gt; 、 &lt;code&gt;PA.PB1&lt;/code&gt; 、 &lt;code&gt;PA.PB1.pb1_m&lt;/code&gt; 、 &lt;code&gt;PA.PB2&lt;/code&gt; 、 &lt;code&gt;PA.PB2.pb2_m&lt;/code&gt; 六个模块。当前 &lt;code&gt;Local&lt;/code&gt; 中还是只有 &lt;code&gt;PA&lt;/code&gt; 、 &lt;code&gt;m1&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;下面的 &lt;code&gt;#5&lt;/code&gt; ，&lt;code&gt;#6&lt;/code&gt; ， &lt;code&gt;#7&lt;/code&gt; 都是可以正确运行的。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注：需要注意的问题是如果 &lt;code&gt;PA.PB2.pb2_m&lt;/code&gt; 想导入 &lt;code&gt;PA.PB1.pb1_m&lt;/code&gt; 、 &lt;code&gt;PA.wave&lt;/code&gt; 是可以直接成功的。最好是采用明确的导入路径，对于 &lt;code&gt;../..&lt;/code&gt; 相对导入路径还是不推荐使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然我们已经知道 &lt;code&gt;pyc&lt;/code&gt; 文件的产生，再回到那道赛题，我们尝试将 &lt;code&gt;pyc&lt;/code&gt; 文件反编译回 &lt;code&gt;python&lt;/code&gt; 源码。我们使用在线的开源工具进行尝试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224139190-493105890.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;部分代码没有反编译成功？？？我们可以尝试分析一下，大概意思就是读取 &lt;code&gt;cipher.txt&lt;/code&gt; 那个文件，将那个文件内容是通过 &lt;code&gt;base64&lt;/code&gt; 编码的，我们的目的是将文件内容解码，然后又已知 &lt;code&gt;key&lt;/code&gt; ，通过 &lt;code&gt;encryt&lt;/code&gt; 函数进行加密的，我们可以尝试将代码补全：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def encryt(key, plain):
    cipher = ''
    for i in range(len(plain)):
        cipher += chr(ord(key[i % len(key)]) ^ ord(plain[i]))

    return cipher


def getPlainText():
    plain = ''
    with open('cipher.txt') as (f):
        while True:
            line = f.readline()
            if line:
                plain += line
            else:
                break

    return plain.decode('base_64')


def main():
    key = 'LordCasser'
    plain = getPlainText()
    cipher = encryt(key, plain)
    with open('xxx.txt', 'w') as (f):
        f.write(cipher)


if __name__ == '__main__':
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre class=&quot;markdown&quot;&gt;
&lt;code&gt;YOU ARE FOOLED
THIS IS NOT THAT YOU WANT
GO ON DUDE
CATCH THAT STEGOSAURUS&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提示告诉我们用 &lt;code&gt;STEGOSAURUS&lt;/code&gt; 工具进行隐写的，我们直接将隐藏的payload分离出来即可。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;python3 stegosaurus.py -x QAQ.pyc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224138449-497760819.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们得到了最终的 &lt;code&gt;flag&lt;/code&gt; 为：&lt;strong&gt;&lt;code&gt;flag{fin4lly_z3r0_d34d}&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然都说到这个份子上了，我们就来分析一下我们是如何通过 &lt;code&gt;Stegosaurus&lt;/code&gt; 来嵌入 &lt;code&gt;Payload&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;我们仍然以上面这个代码为例子，我们设置脚本名称为 &lt;code&gt;encode.py&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;第一步，我们使用 &lt;code&gt;Stegosaurus&lt;/code&gt; 来查看在不改变源文件 &lt;code&gt;(Carrier)&lt;/code&gt; 大小的情况下，我们的 &lt;code&gt;Payload&lt;/code&gt; 能携带多少字节的数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python3 -m stegosaurus encode.py -r&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224137902-1756455640.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，我们可以安全地嵌入最多24个字节的 &lt;code&gt;Payload&lt;/code&gt; 了。如果不想覆盖源文件的话，我们可以使用 &lt;code&gt;-s&lt;/code&gt; 参数来单独生成一个嵌入了 &lt;code&gt;Payload&lt;/code&gt; 的 &lt;code&gt;py&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;python3 -m stegosaurus encode.py -s --payload &quot;flag{fin4lly_z3r0_d34d}&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224137398-503319738.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们可以用 &lt;code&gt;ls&lt;/code&gt; 命令查看磁盘目录，嵌入了 &lt;code&gt;Payload&lt;/code&gt; 的文件( &lt;code&gt;carrier&lt;/code&gt; 文件)和原始的字节码文件两者大小是完全相同的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224136786-114718507.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：如果没有使用 &lt;code&gt;-s&lt;/code&gt; 参数，那么原始的字节码文件将会被覆盖。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以通过向 &lt;code&gt;Stegosaurus&lt;/code&gt; 传递 &lt;code&gt;-x&lt;/code&gt; 参数来提取出 &lt;code&gt;Payload&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;python3 -m stegosaurus __pycache__/encode.cpython-36-stegosaurus.pyc -x&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224135808-1025476130.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们构造的 &lt;code&gt;Payload&lt;/code&gt; 不一定要是一个 &lt;code&gt;ASCII&lt;/code&gt; 字符串， &lt;code&gt;shellcode&lt;/code&gt; 也是可以的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224134986-1367540570.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们重新编写一个 &lt;code&gt;example.py&lt;/code&gt; 模块，代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys
import os
import math
def add(a,b):
    return int(a)+int(b)
def sum1(result):
    return int(result)*3

def sum2(result):
    return int(result)/3

def sum3(result):
    return int(result)-3

def main():
    a = 1
    b = 2
    result = add(a,b)
    print(sum1(result))
    print(sum2(result))
    print(sum3(result))

if __name__ == &quot;__main__&quot;:
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们让它携带 &lt;code&gt;Payload&lt;/code&gt; 为 &lt;code&gt;flag_is_here&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224133950-311455782.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以查看嵌入 &lt;code&gt;Payload&lt;/code&gt; 之前和之后的 &lt;code&gt;Python&lt;/code&gt; 代码运行情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224133240-1779084107.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;strings&lt;/code&gt; 查看 &lt;code&gt;Stegosaurus&lt;/code&gt; 嵌入了 &lt;code&gt;Payload&lt;/code&gt; 之后的文件输出情况( &lt;code&gt;payload&lt;/code&gt; 并没有显示出来)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100338/201811/1100338-20181129224131418-1962374587.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来使用 &lt;code&gt;Python&lt;/code&gt; 的 &lt;code&gt;dis&lt;/code&gt; 模块来查看 &lt;code&gt;Stegosaurus&lt;/code&gt; 嵌入 &lt;code&gt;Payload&lt;/code&gt; 之前和之后的文件字节码变化情况：&lt;/p&gt;
&lt;p&gt;嵌入payload之前：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#( 11/29/18@ 5:14下午 )( python@Sakura ):~/桌面
   python3 -m dis example.py 
  1           0 LOAD_CONST               0 (0)
              2 LOAD_CONST               1 (None)
              4 IMPORT_NAME              0 (sys)
              6 STORE_NAME               0 (sys)

  2           8 LOAD_CONST               0 (0)
             10 LOAD_CONST               1 (None)
             12 IMPORT_NAME              1 (os)
             14 STORE_NAME               1 (os)

  3          16 LOAD_CONST               0 (0)
             18 LOAD_CONST               1 (None)
             20 IMPORT_NAME              2 (math)
             22 STORE_NAME               2 (math)

  4          24 LOAD_CONST               2 (&amp;lt;code object add at 0x7f90479778a0, file &quot;example.py&quot;, line 4&amp;gt;)
             26 LOAD_CONST               3 ('add')
             28 MAKE_FUNCTION            0
             30 STORE_NAME               3 (add)

  6          32 LOAD_CONST               4 (&amp;lt;code object sum1 at 0x7f9047977810, file &quot;example.py&quot;, line 6&amp;gt;)
             34 LOAD_CONST               5 ('sum1')
             36 MAKE_FUNCTION            0
             38 STORE_NAME               4 (sum1)

  9          40 LOAD_CONST               6 (&amp;lt;code object sum2 at 0x7f9047977ae0, file &quot;example.py&quot;, line 9&amp;gt;)
             42 LOAD_CONST               7 ('sum2')
             44 MAKE_FUNCTION            0
             46 STORE_NAME               5 (sum2)

 12          48 LOAD_CONST               8 (&amp;lt;code object sum3 at 0x7f9047977f60, file &quot;example.py&quot;, line 12&amp;gt;)
             50 LOAD_CONST               9 ('sum3')
             52 MAKE_FUNCTION            0
             54 STORE_NAME               6 (sum3)

 15          56 LOAD_CONST              10 (&amp;lt;code object main at 0x7f904798c300, file &quot;example.py&quot;, line 15&amp;gt;)
             58 LOAD_CONST              11 ('main')
             60 MAKE_FUNCTION            0
             62 STORE_NAME               7 (main)

 23          64 LOAD_NAME                8 (__name__)
             66 LOAD_CONST              12 ('__main__')
             68 COMPARE_OP               2 (==)
             70 POP_JUMP_IF_FALSE       78

 24          72 LOAD_NAME                7 (main)
             74 CALL_FUNCTION            0
             76 POP_TOP
        &amp;gt;&amp;gt;   78 LOAD_CONST               1 (None)
             80 RETURN_VALUE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;嵌入 &lt;code&gt;payload&lt;/code&gt; 之后：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#( 11/29/18@ 5:31下午 )( python@Sakura ):~/桌面
   python3 -m dis example.py                                 
  1           0 LOAD_CONST               0 (0)
              2 LOAD_CONST               1 (None)
              4 IMPORT_NAME              0 (sys)
              6 STORE_NAME               0 (sys)

  2           8 LOAD_CONST               0 (0)
             10 LOAD_CONST               1 (None)
             12 IMPORT_NAME              1 (os)
             14 STORE_NAME               1 (os)

  3          16 LOAD_CONST               0 (0)
             18 LOAD_CONST               1 (None)
             20 IMPORT_NAME              2 (math)
             22 STORE_NAME               2 (math)

  4          24 LOAD_CONST               2 (&amp;lt;code object add at 0x7f146e7038a0, file &quot;example.py&quot;, line 4&amp;gt;)
             26 LOAD_CONST               3 ('add')
             28 MAKE_FUNCTION            0
             30 STORE_NAME               3 (add)

  6          32 LOAD_CONST               4 (&amp;lt;code object sum1 at 0x7f146e703810, file &quot;example.py&quot;, line 6&amp;gt;)
             34 LOAD_CONST               5 ('sum1')
             36 MAKE_FUNCTION            0
             38 STORE_NAME               4 (sum1)

  9          40 LOAD_CONST               6 (&amp;lt;code object sum2 at 0x7f146e703ae0, file &quot;example.py&quot;, line 9&amp;gt;)
             42 LOAD_CONST               7 ('sum2')
             44 MAKE_FUNCTION            0
             46 STORE_NAME               5 (sum2)

 12          48 LOAD_CONST               8 (&amp;lt;code object sum3 at 0x7f146e703f60, file &quot;example.py&quot;, line 12&amp;gt;)
             50 LOAD_CONST               9 ('sum3')
             52 MAKE_FUNCTION            0
             54 STORE_NAME               6 (sum3)

 15          56 LOAD_CONST              10 (&amp;lt;code object main at 0x7f146e718300, file &quot;example.py&quot;, line 15&amp;gt;)
             58 LOAD_CONST              11 ('main')
             60 MAKE_FUNCTION            0
             62 STORE_NAME               7 (main)

 23          64 LOAD_NAME                8 (__name__)
             66 LOAD_CONST              12 ('__main__')
             68 COMPARE_OP               2 (==)
             70 POP_JUMP_IF_FALSE       78

 24          72 LOAD_NAME                7 (main)
             74 CALL_FUNCTION            0
             76 POP_TOP
        &amp;gt;&amp;gt;   78 LOAD_CONST               1 (None)
             80 RETURN_VALUE&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注： &lt;code&gt;Payload&lt;/code&gt; 的发送和接受方法完全取决于用户个人喜好， &lt;code&gt;Stegosaurus&lt;/code&gt; 只提供了一种向 &lt;code&gt;Python&lt;/code&gt; 字节码文件嵌入或提取 &lt;code&gt;Payload&lt;/code&gt; 的方法。但是为了保证嵌入之后的代码文件大小不会发生变化，因此 &lt;code&gt;Stegosaurus&lt;/code&gt; 所支持嵌入的 &lt;code&gt;Payload&lt;/code&gt; 字节长度十分有限。因此 ，如果你需要嵌入一个很大的 &lt;code&gt;Payload&lt;/code&gt; ，那么你可能要将其分散存储于多个字节码文件中了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了在不改变源文件大小的情况下向其嵌入 &lt;code&gt;Payload&lt;/code&gt; ，我们需要识别出字节码中的无效空间( &lt;code&gt;Dead Zone&lt;/code&gt; )。这里所谓的无效空间指的是那些即使被修改也不会改变原 &lt;code&gt;Python&lt;/code&gt; 脚本正常行为的那些字节数据。&lt;/p&gt;
&lt;p&gt;需要注意的是，我们可以轻而易举地找出 &lt;code&gt;Python3.6&lt;/code&gt; 代码中的无效空间。 &lt;code&gt;Python&lt;/code&gt; 的引用解释器 &lt;code&gt;CPython&lt;/code&gt; 有两种类型的操作码：即无参数的和有参数的。在版本号低于 &lt;code&gt;3.5&lt;/code&gt; 的 &lt;code&gt;Python&lt;/code&gt; 版本中，根据操作码是否带参，字节码中的操作指令将需要占用 &lt;code&gt;1&lt;/code&gt; 个字节或 &lt;code&gt;3&lt;/code&gt; 个字节。在 &lt;code&gt;Python3.6&lt;/code&gt; 中就不一样了， &lt;code&gt;Python3.6&lt;/code&gt; 中所有的指令都占用 &lt;code&gt;2&lt;/code&gt; 个字节，并会将无参数指令的第二个字节设置为 &lt;code&gt;0&lt;/code&gt; ，这个字节在其运行过程中将会被解释器忽略。这也就意味着，对于字节码中每一个不带参数的操作指令， &lt;code&gt;Stegosaurus&lt;/code&gt; 都可以安全地嵌入长度为 &lt;code&gt;1&lt;/code&gt; 个字节的 &lt;code&gt;Payload&lt;/code&gt; 代码。&lt;/p&gt;
&lt;p&gt;我们可以通过 &lt;code&gt;Stegosaurus&lt;/code&gt; 的 &lt;code&gt;-vv&lt;/code&gt; 选项来查看 &lt;code&gt;Payload&lt;/code&gt; 是如何嵌入到这些无效空间之中的：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#( 11/29/18@10:35下午 )( python@Sakura ):~/桌面
   python3 -m stegosaurus example.py -s -p &quot;ABCDE&quot; -vv          
2018-11-29 22:36:26,795 - stegosaurus - DEBUG - Validated args
2018-11-29 22:36:26,797 - stegosaurus - INFO - Compiled example.py as __pycache__/example.cpython-36.pyc for use as carrier
2018-11-29 22:36:26,797 - stegosaurus - DEBUG - Read header and bytecode from carrier
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - POP_TOP (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - POP_TOP (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - POP_TOP (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - BINARY_SUBTRACT (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - BINARY_TRUE_DIVIDE (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - BINARY_MULTIPLY (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - BINARY_ADD (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - POP_TOP (0)
2018-11-29 22:36:26,798 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,798 - stegosaurus - INFO - Found 14 bytes available for payload
Payload embedded in carrier
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - POP_TOP (65) ----A
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - POP_TOP (66) ----B
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - POP_TOP (67) ----C
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - RETURN_VALUE (68) ----D
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - BINARY_SUBTRACT (69) ----E
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - BINARY_TRUE_DIVIDE (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - BINARY_MULTIPLY (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - BINARY_ADD (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - POP_TOP (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - RETURN_VALUE (0)
2018-11-29 22:36:26,799 - stegosaurus - DEBUG - Creating new carrier file name for side-by-side install
2018-11-29 22:36:26,799 - stegosaurus - INFO - Wrote carrier file as __pycache__/example.cpython-36-stegosaurus.pyc&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;参考文献&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;https://bitbucket.org/jherron/stegosaurus/src&lt;/li&gt;
&lt;li&gt;https://github.com/AngelKitty/stegosaurus&lt;/li&gt;
&lt;li&gt;https://www.freebuf.com/sectool/129357.html&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 29 Nov 2018 14:52:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<og:description>国内关于 的介绍少之又少，一般只是单纯的工具使用的讲解之类的，并且本人在学习过程中也是遇到了很多的问题，基于此种情况下写下此文，也是为我逝去的青春时光留个念想吧~ Stegosaurus是什么？ 在了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/10041534.html</dc:identifier>
</item>
<item>
<title>javascript基础修炼(10)——VirtualDOM和基本DFS - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/10030036.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/10030036.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201811/24/d29248a27ce274c3e79a3719b06e9217.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;virtual-dom是什么&quot;&gt;1. Virtual-DOM是什么&lt;/h2&gt;
&lt;p&gt;Virtual-DOM，即虚拟DOM树。浏览器在解析文件时，会将&lt;code&gt;html&lt;/code&gt;文档转换为&lt;code&gt;document&lt;/code&gt;对象，在浏览器环境中运行的脚本文件都可以获取到它，通过操作&lt;code&gt;document&lt;/code&gt;对象暴露的接口可以直接操作页面上的DOM节点。但是DOM读写是非常耗性能的，很容易触发不必要的重绘和重排，为了更好地处理DOM操作，&lt;code&gt;Virtual-DOM&lt;/code&gt;技术就诞生了。&lt;code&gt;Virtual-DOM&lt;/code&gt;就是在javascript中模拟真实DOM的结构，通过数据追踪和状态对比来减少对于真实DOM的操作，以此来提高程序的效率的一种技术。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Virtual-DOM&lt;/code&gt;技术是前端高性能的基石，它是真实&lt;code&gt;document&lt;/code&gt;对象的抽象，通过对比新旧&lt;code&gt;Virtual-DOM&lt;/code&gt;的区别，找出发生变化的DOM节点，再利用算法得到相对更合理的DOM节点修改方案，最终再将方案应用在&lt;code&gt;document&lt;/code&gt;对象上来改变页面的展示内容。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;主流前端SPA框架都离不开【&lt;code&gt;Virtual-DOM&lt;/code&gt;模型 + &lt;code&gt;DOM-Diff&lt;/code&gt;算法 + 生命周期钩子】这样的核心模型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;virtual-dom的基本结构&quot;&gt;2. Virtual-DOM的基本结构&lt;/h2&gt;
&lt;p&gt;在上一篇博文&lt;a href=&quot;https://%C3%97%C3%97%C3%97w.cnblogs.com/dashnowords/p/9955460.html&quot;&gt;《javascript基础修炼(9)——MVVM中双向数据绑定的基本原理》&lt;/a&gt;中，我们通过&lt;code&gt;document.getElementById()&lt;/code&gt;从真实DOM中获得了带有自定义属性的待解析结构，这里是有一些问题的，实际的过程是先解析模板字符串得到虚拟DOM树，最后生成真实的DOM树。&lt;/p&gt;
&lt;p&gt;实际上我们在使用SPA框架时所编写的&lt;code&gt;html&lt;/code&gt;模板，并没有被直接当做DOM片段加载到页面上使用，而是将文件当做字符串读入到程序中，然后通过解析来生成&lt;code&gt;Virtual-DOM&lt;/code&gt;树，接着通过SPA框架的渲染函数来生成必要的片段后才生成真实的DOM节点。例如我们要生成下文示例的&lt;code&gt;HTML&lt;/code&gt;片段（为了方便演示，示例中只涉及了类名和文本节点）:&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;body class=&quot;main&quot;&amp;gt;
   &amp;lt;div class=&quot;sideBar&quot;&amp;gt;
       &amp;lt;ul class=&quot;sideBarContainer&quot;&amp;gt;
           &amp;lt;li class=&quot;sideBarItem&quot;&amp;gt;sidebar-1&amp;lt;/li&amp;gt;
           &amp;lt;li class=&quot;sideBarItem&quot;&amp;gt;sidebar-2&amp;lt;/li&amp;gt;
           &amp;lt;li class=&quot;sideBarItem&quot;&amp;gt;sidebar-3&amp;lt;/li&amp;gt;
       &amp;lt;/ul&amp;gt;
   &amp;lt;/div&amp;gt;
   &amp;lt;div class=&quot;mainContent&quot;&amp;gt;
        &amp;lt;div class=&quot;header&quot;&amp;gt;header-zone&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;coreContent&quot;&amp;gt;core-content&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;footer&quot;&amp;gt;footer-zone&amp;lt;/div&amp;gt;
   &amp;lt;/div&amp;gt;
   &amp;lt;div class=&quot;rightSide&quot;&amp;gt;暂未开发&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们需要构建出一个简易模型来表达上面的结构：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;virtualDom = {
    name:&quot;body&quot;,
    props:{
        className:&quot;main&quot;
    },
    children:[{
        name:&quot;div&quot;,
        props:{...},
        children:[...]
      },{
        name:&quot;div&quot;,
        props:{...},
        children:[...]
      },{
        name:&quot;div&quot;,
        props:{...},
        children:[...]
      }]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建立一个生成虚拟节点的辅助函数:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//构建DOM节点的辅助函数
function h(name, props, children) {
    return {
        name:name,
        props:props,
        children:children
    }
}
//手动生成virtual-DOM
var tree = h('body',{className:'main'},[
       h('div',{className:'sideBar'},[
          h('ul',{className:'sideBarContainer'},[
               h('li',{className:'sideBarItem'},['sidebar-1']),
               h('li',{className:'sideBarItem'},['sidebar-2']),
               h('li',{className:'sideBarItem'},['sidebar-3']),
            ])
        ]),
       h('div',{className:'mainContent'},[
           h('div',{className:'header'},['header-zone']),
           h('div',{className:'coreContent'},['core-content']),
           h('div',{className:'footer'},['footer-zone']),
        ]),
       h('div',{className:'rightSide'},['暂未开发'])
    ]);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的方法得到的&lt;code&gt;tree&lt;/code&gt;对象就涵盖了模板片段中的结构和关键信息。实际开发中并不需要像上面一样手动来填写DOM结构，可以将模板字符串挂载到离线DOM节点上，然后在递归解析的同时来构建&lt;code&gt;Virtual-DOM&lt;/code&gt;就可以了。&lt;/p&gt;
&lt;h2 id=&quot;使用dfs从virtual-dom生成dom&quot;&gt;3. 使用DFS从Virtual-DOM生成DOM&lt;/h2&gt;
&lt;p&gt;至此我们完成了模板的编译，也得到了&lt;code&gt;Virtual-DOM&lt;/code&gt;对象，但它似乎并没有什么用处，毕竟我们已经完成了对模板的解析，渲染出页面没什么问题，其实&lt;code&gt;Virtual-DOM&lt;/code&gt;对于首屏来说并没有什么特别重要的意义，它的价值在模型和视图发生变化时才会体现。上一篇博文的末尾我们已经提到了更新视图时的效率问题，当数据模型发生变化后，我们需要一个方法来收集所有需要修改的DOM，并为之提供高效的修改方式（你总不能一有变化就把整个网页重新渲染，或者让数据模型各自去修改各自绑定的DOM吧）。那么为了能够收集所有DOM节点的变化，我们就需要遍历所有节点。&lt;/p&gt;
&lt;p&gt;对数据结构和算法有一定了解的读者很容易想到，遍历解析一个&lt;code&gt;Virtual-DOM&lt;/code&gt;实际上就是对其进行先序深度优先遍历(Pre-Order Depth-First-Search)，本节中，我们先预热一下，使用这种方式来复现一下DOM结构。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function dfswalking(tree) {
    var _childrenLength;
    //执行动作
    if (typeof tree.children[0] === 'string') {
        console.log(`&amp;lt;${tree.name} class=&quot;${tree.props.className}&quot;&amp;gt;${tree.children[0]}&amp;lt;/${tree.name}&amp;gt;`);
    } else {
        console.log(`&amp;lt;${tree.name} class=&quot;${tree.props.className}&quot;&amp;gt;  --&amp;gt;`);
        for(var i = 0, _childrenLength = tree.children.length; i &amp;lt; _childrenLength; i++){
            dfswalking(tree.children[i]);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本例中仅打印出字符串的方式来展示，可以在控制台看到输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i2.51cto.com/images/blog/201811/24/17c96d1c30de7e2aef6d9f02ae69a827.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下一篇博文中将分析如何通过&lt;code&gt;domDiff(oldTree, newTree)&lt;/code&gt;的方法通过同样的遍历方法来收集变化并批量更新视图。&lt;/p&gt;
&lt;h2 id=&quot;声明&quot;&gt;4. 声明&lt;/h2&gt;
&lt;p&gt;本篇只是部分原理的学习笔记，并不代表框架真实源码的实现逻辑。&lt;/p&gt;
</description>
<pubDate>Thu, 29 Nov 2018 14:26:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>1. Virtual DOM是什么 Virtual DOM，即虚拟DOM树。浏览器在解析文件时，会将 文档转换为 对象，在浏览器环境中运行的脚本文件都可以获取到它，通过操作 对象暴露的接口可以直接操作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/10030036.html</dc:identifier>
</item>
<item>
<title>Shell编程-12-Shell脚本规范及调试 - Surpassme</title>
<link>http://www.cnblogs.com/surpassme/p/10041382.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/surpassme/p/10041382.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h3 id=&quot;shell脚本规范&quot;&gt;Shell脚本规范&lt;/h3&gt;
&lt;p&gt;    良好的代码规范不仅方便阅读，也利于维护和提升开发效率。因此建议大家在编写Shell脚本时养成良好的代码习惯。今天就和大家探讨一下在Shell脚本中的一些规范，详细如下所示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、在Shell脚本中，第一行指定脚本解释器，如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#!/bin/bash
或
#!/bin/sh&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;2、在Shell脚本中填写代码作者、日期、版权等信息，便于协同开发&lt;/li&gt;
&lt;li&gt;3、Shell脚本中的注释，尽量采用英文注释，避免中文注释，可避免本机或切换系统环境后出现乱码，如果必须采用中文，建议按在脚本中添加以下环境变量&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;export LANG=&quot;zh_CN.UTF-8&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;4、脚本命名需要简洁明了且以&lt;strong&gt;.sh&lt;/strong&gt;作为扩展名&lt;/li&gt;
&lt;li&gt;5、脚本尽量存放在固定的路径中，便于查找、调用和维护&lt;/li&gt;
&lt;li&gt;6、代码编写技巧如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt; a):成对的符号尽量一次书写完整，而后再向里面添加内容，这样可以避免遗漏符号。
     如 {} [] '' &quot; &quot; ``
&amp;gt; b):[ ]和[[ ]] 两端至少要留有一个空格
&amp;gt; c):对于if/for/while/select/case 等应一次将格式写完，而后再添加对应的处理语句
&amp;gt; d):代码中应注意缩进，便于阅读，可使用TAB或空格，一般建议采用空格键进行缩进
&amp;gt; e):字符串赋值给变量应加双引号（&quot;&quot;）并且等号前后不能有空格
    如 str=&quot;Test&quot;
&amp;gt; f):脚本中的书写必须为英文状态下的符号、字母等。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;7、全局变量（环境变量）的定义需要全部大写，其名称需要一看便知其意，定义需要使用&lt;strong&gt;export&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;8、局部变量（普通变量）命名需要遵循一定的命名规则，如驼峰语法;风格要统一&lt;/li&gt;
&lt;li&gt;9、Shell函数中的变量可以使用&lt;strong&gt;local&lt;/strong&gt;方式进行定义，使之仅在该函数体内有效，从而避免与外部程序的变量相同，造成程序异常&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat local.sh
#!/bin/bash
function Test () {
 local i # 定义本地变量，仅在函数体内有效
for((i=0;i&amp;lt;5;i++))
 do
   echo &quot;in function i is:&quot; ${i}
 done
}
Test
i=100
echo &quot;not in function i is:&quot;${i}
[root@localhost Test]# bash local.sh
in function i is: 0
in function i is: 1
in function i is: 2
in function i is: 3
in function i is: 4
not in function i is:100&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;10、在引用变量时，若变量前后都有字符，则需要使用&lt;strong&gt;${variable}&lt;/strong&gt;进行引用，避免产生歧义；当变量为字符串时，需要使用&lt;strong&gt;&quot;${variable}&quot;&lt;/strong&gt;进行引用；当变量为整数时，则可以直接使用&lt;strong&gt;$variable&lt;/strong&gt;进行引用。&lt;/li&gt;
&lt;li&gt;11、对于一些经常变化的信息，建议采用变量或位置参数等进行定义和使用。&lt;/li&gt;
&lt;li&gt;12、脚本中要检查配置项是否为空，是否可执行等，增加脚本的健壮性。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;shell脚本调试&quot;&gt;Shell脚本调试&lt;/h3&gt;
&lt;p&gt;    相比于其他编程语言，Shell脚本没有专门的IDE去进行各类细致的调试。但我们可以通过运行Shell脚本的错误提示和打印信息来进行排错和纠错。&lt;/p&gt;
&lt;h4 id=&quot;常见错误示例&quot;&gt;常见错误示例&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1、if语句缺少结尾关键字&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat -n testif.sh
     1  #!/bin/bash
     2  if [ -f /root/Test/a.sh ]
     3    then
     4     echo &quot;/root/Test/a.sh exist&quot;
     5  else
     6    echo &quot;/root/Test/a.sh no exist&quot; # 缺少fi
[root@localhost Test]# bash testif.sh
testif.sh:行7: 语法错误: 未预期的文件结尾&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在上面提示中，显示第7行存在错误，依据该提示，我们可以仔细观察错误提示的前后，应该不难找出错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;在运行Shell脚本出现错误后，不能单看提示的错误行，需要结合提示行前后进行排错。Shell不会对脚本错误进行精确定位，这个也是区别于其他语言的地方。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;2、循环语句中缺少关键字或关键字拼写不正确&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat -n testif.sh
     1  #!/bin/bash
     2  while
     3   do
     4  if [ -f /root/Test/a.sh ]
     5    then
     6     echo &quot;/root/Test/a.sh exist&quot;
     7  else
     8    echo &quot;/root/Test/a.sh no exist&quot; # 结尾少了done
[root@localhost Test]# bash testif.sh
testif.sh:行3: 未预期的符号 `do' 附近有语法错误
testif.sh:行3: ` do'&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;3、成对的符号落了单&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat -n testif.sh
     1  #!/bin/bash
     2  #while
     3   #do
     4  if [ -f /root/Test/a.sh # 缺少 ]
     5    then
     6     echo &quot;/root/Test/a.sh exist&quot;
     7  else
     8    echo &quot;/root/Test/a.sh no exist&quot;
     9  fi
[root@localhost Test]# bash testif.sh
testif.sh: 第 4 行:[: 缺少 `]'
/root/Test/a.sh no exist&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;4、[]和[[]]两端缺少空格&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat testif.sh
#!/bin/bash
#while
 #do
if [-f /root/Test/a.sh] # [] 两端没有空格
  then
   echo &quot;/root/Test/a.sh exist&quot;
else
  echo &quot;/root/Test/a.sh no exist&quot;
fi
[root@localhost Test]# bash testif.sh
testif.sh:行4: [-f: 未找到命令&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;shell调试技巧&quot;&gt;Shell调试技巧&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1、Windows中编写脚本明明语法什么均正确，在Linux中跟却提示各种语法错误，这种情况建议优先在Linux写脚本。因为Windows中和格式与Linux格式还是有很多差异的。&lt;/li&gt;
&lt;li&gt;2、在代码关键地方打印日志，如使用&lt;strong&gt;echo&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;3、使用bash命令参数调试，常用调试参数如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt; -n : 不执行脚本仅检查脚本语法是否存在错误
&amp;gt; -v : 先将脚本内容显示到屏幕再执行执行脚本
&amp;gt; -x : 将执行脚本的内容及输出全部显示到屏幕上&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上参数示例如下，所示：&lt;br/&gt;-n参数示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat -n testif.sh 
     1  #!/bin/bash
     2  #while
     3   #do
     4  if [ -f /root/Test/a.sh ]
     5    then
     6     echo &quot;/root/Test/a.sh exist&quot;
     7  else
     8    echo &quot;/root/Test/a.sh no exist&quot;
     9                                    # 缺少结束标志 fi
[root@localhost Test]# bash -n testif.sh
testif.sh:行10: 语法错误: 未预期的文件结尾&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;-v参数示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# bash -v testif.sh # 显示脚本内容并执行脚本
#!/bin/bash
#while
 #do
if [ -f /root/Test/a.sh ]
  then
   echo &quot;/root/Test/a.sh exist&quot;
else
  echo &quot;/root/Test/a.sh no exist&quot;
fi
/root/Test/a.sh no exist  # 脚本执行结果&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;-x参数示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost Test]# cat -n sum.sh
     1  #!/bin/bash
     2  function Sum () {
     3   for((i=1;i&amp;lt;=$1;i++))
     4   do
     5    ((sum=sum+i))
     6    echo &quot;{1..$1} sum is :&quot; ${sum}
     7   done
     8  }
     9  
    10  Sum $1
    11  if [ $? == &quot;0&quot; ]
    12   then
    13    echo &quot;Completed&quot;
    14  else
    15    echo &quot;Error&quot;
    16  fi
[root@localhost Test]# bash -x sum.sh 5
+ Sum 5
+ (( i=1 ))
+ (( i&amp;lt;=5 ))
+ (( sum=sum+i ))
+ echo '{1..5} sum is :' 1
{1..5} sum is : 1
+ (( i++ ))
+ (( i&amp;lt;=5 ))
+ (( sum=sum+i ))
+ echo '{1..5} sum is :' 3
{1..5} sum is : 3
+ (( i++ ))
+ (( i&amp;lt;=5 ))
+ (( sum=sum+i ))
+ echo '{1..5} sum is :' 6
{1..5} sum is : 6
+ (( i++ ))
+ (( i&amp;lt;=5 ))
+ (( sum=sum+i ))
+ echo '{1..5} sum is :' 10
{1..5} sum is : 10
+ (( i++ ))
+ (( i&amp;lt;=5 ))
+ (( sum=sum+i ))
+ echo '{1..5} sum is :' 15
{1..5} sum is : 15
+ (( i++ ))
+ (( i&amp;lt;=5 ))
+ '[' 0 == 0 ']'
+ echo Completed
Completed&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;前面带有&quot;+&quot;表示执行的过程语句，没有带&quot;+&quot;则表示输出的结果，通过-x参数可以查看整个执行的过程中每一步&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;shell调试总结&quot;&gt;Shell调试总结&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1、如果在Windows中编写的脚本在Linux中无法运行时，可使用工具&lt;strong&gt;dos2unix&lt;/strong&gt;或Notepad++转换为Linux格式&lt;/li&gt;
&lt;li&gt;2、Shell脚本运行中的报错并不像其他高级语言一样详细，在排错时需要结合前后代码段进行排查纠错&lt;/li&gt;
&lt;li&gt;3、在调试中可使用bash自带的参数进行调试定位问题点&lt;/li&gt;
&lt;li&gt;4、平时养成良好的代码习惯和规范，可以规避部分常识性的错误&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    Shell编程基础篇到此已经介绍完毕。本系列也仅仅入门系统，如果还要继续深入学习，还需要多看看别人优秀的代码，做到多看多练，方能更进一步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文同步在微信订阅号上发布，如各位小伙伴们喜欢我的文章，也可以关注我的微信订阅号：woaitest，或扫描下面的二维码添加关注：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/3349421-2a0edd703123621d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;MyQRCode.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 29 Nov 2018 14:26:00 +0000</pubDate>
<dc:creator>Surpassme</dc:creator>
<og:description>[TOC] Shell脚本规范     良好的代码规范不仅方便阅读，也利于维护和提升开发效率。因此建议大家在编写Shell脚本时养成良好的代码习惯。今天就和大家探讨一下在Shell</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/surpassme/p/10041382.html</dc:identifier>
</item>
<item>
<title>Nuxt.js开启SSR渲染 - 吴封斌技术博客</title>
<link>http://www.cnblogs.com/bfwbfw/p/10040929.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bfwbfw/p/10040929.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一节：nuxt.js相关概述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nuxt.js简单的说是Vue.js的通用框架，最常用的就是用来作SSR（服务器端渲染）.Vue.js是开发SPA（单页应用）的,Nuxt.js这个框架，用Vue开发多页应用，并在服务端完成渲染，可以直接用命令把我们制作的vue项目生成为静态html。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.那服务器端渲染到底有什么好处呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要的原因时SPA（单页应用）不利于搜索引擎的SEO操作，Nuxt.js适合作新闻、博客、电影、咨询这样的需要搜索引擎提供流量的项目。如果你要作移动端的项目，就没必要使用这个框架了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.什么是SSR？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SSR，即服务器渲染，就是在服务器端将对Vue页面进行渲染生成html文件，将html页面传递给浏览器。&lt;/p&gt;
&lt;p&gt;SSR两个优点：&lt;/p&gt;
&lt;p&gt;(1)SEO 不同于SPA的HTML只有一个无实际内容的HTML和一个app.js，SSR生成的HTML是有内容的，这让搜索引擎能够索引到页面内容。&lt;/p&gt;
&lt;p&gt;(2)更快内容到达时间 传统的SPA应用是将bundle.js从服务器获取，然后在客户端解析并挂载到dom。而SSR直接将HTML字符串传递给浏览器。大大加快了首屏加载时间。&lt;/p&gt;
&lt;p&gt;Nuxt.js的官方网站是这样介绍的：&lt;/p&gt;
&lt;p&gt;Nuxt.js 是一个基于 Vue.js 的通用应用框架。 通过对客户端/服务端基础架构的抽象组织，Nuxt.js 主要关注的是应用的 UI渲染。&lt;/p&gt;
&lt;p&gt;Nuxt.js是特点（优点）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于 Vue.js&lt;/li&gt;
&lt;li&gt;自动代码分层&lt;/li&gt;
&lt;li&gt;服务端渲染&lt;/li&gt;
&lt;li&gt;强大的路由功能，支持异步数据&lt;/li&gt;
&lt;li&gt;静态文件服务&lt;/li&gt;
&lt;li&gt;ES6/ES7 语法支持&lt;/li&gt;
&lt;li&gt;打包和压缩 JS 和 CSS&lt;/li&gt;
&lt;li&gt;HTML头部标签管理&lt;/li&gt;
&lt;li&gt;本地开发支持热加载&lt;/li&gt;
&lt;li&gt;集成ESLint&lt;/li&gt;
&lt;li&gt;支持各种样式预处理器： SASS、LESS、 Stylus等等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二节：Nuxt环境搭建&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.nuxt.js安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在使用npm前你需要安装Node到系统中。&lt;/p&gt;
&lt;p&gt;（1）用npm来安装vue-cli这个框架。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install vue-cli -g
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装完成后可以使用vue -V 来测试是否安装成功。（注意：这里要使用大写的V，小写无效）。&lt;/p&gt;
&lt;p&gt; （2）使用vue安装 nuxt&lt;/p&gt;
&lt;p&gt;安装好vue-cli后，就可以使用init命令来初始化Nuxt.js项目。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
vue init nuxt/starter
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候他会在github上下载模版，然后会询问你项目的名称叫什么，作者什么的，这些完全可以根据自己的爱好填写。&lt;/p&gt;
&lt;p&gt;（3）使用npm install安装依赖包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个过程是要等一会的，如果你这个过程安装失败，可以直接诶删除项目中的node_modules文件夹后，重新npm install进行安装。&lt;/p&gt;
&lt;p&gt;（4）使用npm run dev 启动服务&lt;/p&gt;
&lt;p&gt;（5）在浏览器输入 localhost:3000,可以看到结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三节 ：Nuxt目录结构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201811/860581-20181129212821627-1730540414.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第四节：Nuxt常用配置项&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.配置IP和端口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开发中经常会遇到端口被占用或者指定IP的情况。我们需要在根目录下的package.json里对config项进行配置。比如现在我们想把IP配置成127.0.0.1，端口设置1000。&lt;/p&gt;
&lt;p&gt;/package.json&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&quot;config&quot;&lt;span&gt;:{
    &lt;/span&gt;&quot;nuxt&quot;&lt;span&gt;:{
      &lt;/span&gt;&quot;host&quot;:&quot;127.0.0.1&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;port&quot;:&quot;1000&quot;&lt;span&gt;
    }
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置好后，我们在终端中输入npm run dev，然后你会看到服务地址改为了127.0.0.1:1000.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.配置全局CSS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在开发多页项目时，都会定义一个全局的CSS来初始化我们的页面渲染，比如把padding和margin设置成0，网上也有非常出名的开源css文件normailze.css。要定义这些配置，需要在nuxt.config.js里进行操作。&lt;/p&gt;
&lt;p&gt;比如现在我们要把页面字体设置为红色，就可以在assets/css/normailze.css文件，然后把字体设置为红色。&lt;/p&gt;
&lt;p&gt;/assets/css/normailze.css&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;html{
    color:red;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;/nuxt.config.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  css:['~assets/css/normailze.css'],
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;设置好后，在终端输入npm run dev 。然后你会发现字体已经变成了红色。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.配置webpack的loader&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在nuxt.config.js里是可以对webpack的基本配置进行覆盖的，比如现在我们要配置一个url-loader来进行小图片的64位打包。就可以在nuxt.config.js的build选项里进行配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;build: {
    loaders:[
      {
        test:&lt;/span&gt;/\.(png|jpe?g|gif|svg)$/&lt;span&gt;,
        loader:&lt;/span&gt;&quot;url-loader&quot;&lt;span&gt;,
        query:{
          limit:&lt;/span&gt;10000&lt;span&gt;,
          name:&lt;/span&gt;'img/[name].[hash].[ext]'&lt;span&gt;
        }
      }
    ],
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    ** Run ESLint on save
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    extend (config, { isDev, isClient }) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isDev &amp;amp;&amp;amp;&lt;span&gt; isClient) {
        config.module.rules.push({
          enforce: &lt;/span&gt;'pre'&lt;span&gt;,
          test: &lt;/span&gt;/\.(js|vue)$/&lt;span&gt;,
          loader: &lt;/span&gt;'eslint-loader'&lt;span&gt;,
          exclude: &lt;/span&gt;/(node_modules)/&lt;span&gt;
        })
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第五节：Nuxt的路由配置和参数传递&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Nuxt.js的路由并不复杂，它给我们进行了封装，让我们节省了很多配置环节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.简单路由Demo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们现在根目录的pages文件下新建两个文件夹，about和news（模仿关于我们和新闻的功能模块）。&lt;/p&gt;
&lt;p&gt;（1）在about文件夹下新建index.vue文件，并写入下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;About Index page&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Home&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（2）在news文件夹下新建index.vue文件，并写入下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;News Index page&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Home&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）修改原来的pages文件夹下的index.vue，删除没用的代码，写入下面链接代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;HOME&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/about&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ABOUT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/news&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;NEWS&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  components: {
  }
}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于Nuxt.js都为我们作好了，不用写任何配置代码。所以我们可以在页面上实现相关跳转。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;code&gt;&amp;lt;nuxt-link&amp;gt;&lt;/code&gt;标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然上面的例子跳转已经成功，但是Nuxt.js并不推荐这种&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;标签的作法，它为我们准备了&lt;code&gt;&amp;lt;nuxt-link&amp;gt;&lt;/code&gt;标签（vue中叫组件）。我们先把首页的&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;标签替换成&lt;code&gt;&amp;lt;nuxt-link&amp;gt;，改造如下：&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;nuxt-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{name:'index'}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;HOME&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;nuxt-link&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;nuxt-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{name:'about'}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ABOUT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;nuxt-link&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;nuxt-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{name:'news'}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;NEWS&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;nuxt-link&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  components: {
  }
}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们再次预览页面，也是可以进行正常跳转的，在实际开发中尽量使用标签的方法跳转路由。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.params传递参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;路由经常需要传递参数，我们可以简单的使用params来进行传递参数，我们现在向新闻页面（news）传递个参数，然后在新闻页面进行简单的接收。&lt;/p&gt;
&lt;p&gt;（1）我们先修改pages下的Index.vue文件，给新闻的跳转加上params参数，传递3306。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;nuxt-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{name:'index'}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;HOME&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;nuxt-link&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;nuxt-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{name:'about'}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ABOUT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;nuxt-link&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;nuxt-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{name:'news',params:{newsId:3306}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;NEWS&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;nuxt-link&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  components: {
  }
}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）在news文件夹下的index.vue里用$route.params.newsId进行接收，代码如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;News Index page&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;NewsID:{{$route.params.newsId}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Home&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;成功实现参数的传递。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;第六节：Nuxt的动态路由和参数校验&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.动态路由&lt;/strong&gt;，其实动态路由就是带参数的路由。比如我们现在新闻模块下面有很多新闻详细页，这时候就需要动态路由的帮助了。&lt;/p&gt;
&lt;p&gt;（1）新闻详细页面： 我在news文件夹下面新建了&lt;strong&gt;_id.v&lt;/strong&gt;ue的文件，以下画线为前缀的Vue文件就是动态路由，然后在文件里边有 $route.params.id来接收参数。&lt;/p&gt;
&lt;p&gt;/pages/news/_id.vue&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;News-Content [{{$route.params.id}}]&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Home&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）修改新闻首页路由&lt;/p&gt;
&lt;p&gt;我们在/pages/news/index.vue进行修改，增加两个详细页的路由News-1和News-2。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;News Index page&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;NewsID:{{$route.params.newsId}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Home&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/news/123&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;News-1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/news/456&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;News-2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;代码写好后，打开npm run dev 进行查看，我们已经进入了新闻详细页，并在详细页中取得了传递过来的新闻id。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.参数校验&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进入一个页面，对参数传递的正确性校验是必须的，Nuxt.js也贴心的为我们准备了校验方法validate( )。&lt;/p&gt;
&lt;p&gt;（1）在接受参数的页面添加&lt;/p&gt;
&lt;p&gt;/pages/news/_id.vue&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  validate ({ params }) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Must be a number&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; /^\d+$/&lt;span&gt;.test(params.id)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用了validate方法，并把params传递进去，然后用正则进行了校验，如果正则返回了true正常进入页面，如果返回false进入404页面。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第七节：Nuxt的路由动画效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;路由的动画效果，也叫作页面的更换效果。Nuxt.js提供两种方法为路由提供动画效果，一种是全局的，一种是针对单独页面制作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.全局路由动画&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全局动画默认使用page来进行设置，例如现在我们为每个页面都设置一个进入和退出时的渐隐渐现的效果。我们可以先在根目录的assets/css下建立一个normailze.css文件。&lt;/p&gt;
&lt;p&gt;（1）添加样式文件&lt;/p&gt;
&lt;p&gt;/assets/css/normailze.css(没有请自行建立)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.page-enter-active, .page-leave-active &lt;/span&gt;{&lt;span&gt;
    transition&lt;/span&gt;:&lt;span&gt; opacity 2s&lt;/span&gt;;
}&lt;span&gt;
.page-enter, .page-leave-active &lt;/span&gt;{&lt;span&gt;
    opacity&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）文件配置&lt;/p&gt;
&lt;p&gt;然后在nuxt.config.js里加入一个全局的css文件就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;css:['assets/css/main.css'],&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候在页面切换的时候就会有2秒钟的动画切换效果了，但是你会发现一些页面是没有效果的，这是因为你没有是&lt;code&gt;&amp;lt;nuxt-link&amp;gt;&lt;/code&gt;组件来制作跳转链接。你需要进行更改。&lt;/p&gt;
&lt;p&gt;比如我们上节课作的动态路由新闻页，你就需要改成下面的链接。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;nuxt-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{name:'news-id',params:{id:123}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;News-1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;nuxt-link&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改过之后你就会看到动画效果了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.单独设置页面动效&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想给一个页面单独设置特殊的效果时，我们只要在css里改变默认的page，然后在页面组件的配置中加入transition字段即可。例如，我们想给about页面加入一个字体放大然后缩小的效果，其他页面没有这个效果。&lt;/p&gt;
&lt;p&gt;（1）在全局样式assets/main.css 中添加以下内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.test-enter-active, .test-leave-active &lt;/span&gt;{&lt;span&gt;
    transition&lt;/span&gt;:&lt;span&gt; all 2s&lt;/span&gt;;&lt;span&gt;
    font-size&lt;/span&gt;:&lt;span&gt;12px&lt;/span&gt;;
}&lt;span&gt;
.test-enter, .test-leave-active &lt;/span&gt;{&lt;span&gt;
    opacity&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
    font-size&lt;/span&gt;:&lt;span&gt;40px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）然后在about/index.vue组件中设置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export default &lt;/span&gt;{&lt;span&gt;
  transition&lt;/span&gt;:&lt;span&gt;'test'
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候就有了页面的切换独特动效了。&lt;/p&gt;
&lt;p&gt;总结：在需要使用的页面导入即可。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第八节：Nuxt的默认模版和默认布局&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在开发应用时，经常会用到一些公用的元素，比如网页的标题是一样的，每个页面都是一模一样的标题。这时候我们有两种方法，第一种方法是作一个公用的组件出来，第二种方法是修改默认模版。这两种方法各有利弊，比如公用组件更加灵活，但是每次都需要自己手动引入；模版比较方便，但是只能每个页面都引入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.默认模板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Nuxt为我们提供了超简单的默认模版订制方法，只要在根目录下创建一个app.html就可以实现了。现在我们希望每个页面的最上边都加入“ 学习nuxt.js” 这几个字，我们就可以使用默认模版来完成。&lt;/p&gt;
&lt;p&gt;app.html中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
   {{ HEAD }}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;学习nuxt.js&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {{ APP }}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的{{ HEAD }}读取的是nuxt.config.js里的信息，{{APP}} 就是我们写的pages文件夹下的主体页面了。需要注意的是HEAD和APP都需要大写，如果小写会报错的。&lt;/p&gt;
&lt;p&gt;注意：如果你建立了默认模板后，记得要重启服务器，否则显示不会成功；但是默认布局是不用重启服务器的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.默认布局&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认模板类似的功能还有默认布局，但是从名字上你就可以看出来，默认布局主要针对于页面的统一布局使用。它在位置根目录下的layouts/default.vue。需要注意的是在默认布局里不要加入头部信息，只是关于&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;标签下的内容统一订制。&lt;/p&gt;
&lt;p&gt;需求：我们在每个页面的最顶部放入“学习nuxt.js” 这几个字，看一下在默认布局里的实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;学习nuxt.js&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;nuxt&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的&lt;code&gt;&amp;lt;nuxt/&amp;gt;&lt;/code&gt;就相当于我们每个页面的内容，你也可以把一些通用样式放入这个默认布局里，但会增加页面的复杂程度。&lt;/p&gt;
&lt;p&gt;总结：要区分默认模版和默认布局的区别，模版可以订制很多头部信息，包括IE版本的判断；模版只能定制&lt;code&gt;&amp;lt;template&amp;gt;&lt;/code&gt;里的内容，跟布局有关系。在工作中修改时要看情况来编写代码。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第九节：Nuxt的错误页面和个性meta设置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当用户输入路由错误的时候，我们需要给他一个明确的指引，所以说在应用程序开发中404页面是必不可少的。Nuxt.js支持直接在默认布局文件夹里建立错误页面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.建立错误页面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在根目录下的layouts文件夹下建立一个error.vue文件，它相当于一个显示应用错误的组件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2 &lt;/span&gt;&lt;span&gt;v-if&lt;/span&gt;&lt;span&gt;=&quot;error.statusCode==404&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;404页面不存在&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2 &lt;/span&gt;&lt;span&gt;v-else&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;500服务器错误&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;nuxt-link &lt;/span&gt;&lt;span&gt;to&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;HOME&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;nuxt-link&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  props:[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码用v-if进行判断错误类型，需要注意的是这个错误是你需要在&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;里进行声明的，如果不声明程序是找不到error.statusCode的。&lt;/p&gt;
&lt;p&gt;这里我也用了一个&lt;code&gt;&amp;lt;nuxt-link&amp;gt;&lt;/code&gt;的简单写法直接跟上路径就可以了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.个性meta设置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;页面的Meta对于SEO的设置非常重要，比如你现在要作个新闻页面，那为了搜索引擎对新闻的收录，需要每个页面对新闻都有不同的title和meta设置。直接使用head方法来设置当前页面的头部信息就可以了。我们现在要把New-1这个页面设置成个性的meta和title。&lt;/p&gt;
&lt;p&gt;1.我们先把&lt;code&gt;pages/news/index.vue&lt;/code&gt;页面的链接进行修改一下，传入一个title，目的是为了在新闻具体页面进行接收title，形成文章的标题。&lt;/p&gt;
&lt;p&gt;/pages/news/index.vue&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;nuxt-link &lt;/span&gt;&lt;span&gt;:to&lt;/span&gt;&lt;span&gt;=&quot;{name:'news-id',params:{id:123,title:'nuxt.com'}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;News-1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;nuxt-link&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.第一步完成后，我们修改/pages/news/_id.vue，让它根据传递值变成独特的meta和title标签。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;News-Content [{{$route.params.id}}]&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Home&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  validate ({ params }) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Must be a number&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;/&lt;/span&gt;&lt;span&gt;^\d+$&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;.test(params.id)
  },
  data(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
      title:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.$route.params.title,
    }
  },
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;独立设置head信息&lt;/span&gt;
&lt;span&gt;  head(){
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;{
        title:&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.title,
        meta:[
          {hid:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,name:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;news&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,content:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;This is news page&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
        ]
      }
    }
}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：为了避免子组件中的meta标签不能正确覆盖父组件中相同的标签而产生重复的现象，建议利用 hid 键为meta标签配一个唯一的标识编号。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第十节：asyncData方法获取数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Nuxt.js贴心的为我们扩展了Vue.js的方法，增加了anyncData，异步请求数据。&lt;/p&gt;
&lt;p&gt;（1）创建远程数据&lt;/p&gt;
&lt;p&gt;在这里制作一些假的远程数据，我选择的网站是myjson.com，它是一个json的简单仓库，学习使用是非常适合的。 我们打开网站，在对话空中输入JSON代码，这个代码可以随意输入，key和value均采用字符串格式创建。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &quot;name&quot;: &quot;Nuxt&quot;,
  &quot;age&quot;: 18,
  &quot;interest&quot;: &quot;I love coding!&quot;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入后保存，网站会给你一个地址，这就是你这个JSON仓库的地址了。https://api.myjson.com/bins/1ctwlm&lt;/p&gt;
&lt;p&gt;（2）安装Axios&lt;/p&gt;
&lt;p&gt;Vue.js官方推荐使用的远程数据获取方式就Axios，所以我们安装官方推荐，来使用Axios。这里我们使用npm 来安装 axios。 直接在终端中输入下面的命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install axios --save
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;1.ansycData的promise方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在pages下面新建一个文件，叫做ansyData.vue。然后写入下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名：{{info.name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;年龄：{{info.age}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;兴趣：{{info.interest}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
import axios from &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;axios&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  data(){
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
         name:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello World&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
     }
  },
  asyncData(){
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; axios.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://api.myjson.com/bins/1ctwlm&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
      .then((res)&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;{
          console.log(res)
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {info:res.data}
      })
  }
}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这时候我们可以看到，浏览器中已经能输出结果了。asyncData的方法会把值返回到data中。是组件创建（页面渲染）之前的动作，所以不能使用this.info,&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
 return {info:res.data}相当于在data中多了一个info:''。&lt;p&gt;&lt;strong&gt;2.ansycData的await方法&lt;br/&gt;&lt;/strong&gt;当然上面的方法稍显过时，现在都在用ansyc…await来解决异步,改写上面的代码。
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名：{{info.name}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;年龄：{{info.age}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;兴趣：{{info.interest}}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h2&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
import axios from &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;axios&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {
  data(){
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
         name:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hello World&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
     }
  },
  async asyncData(){
      let {data}&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;await axios.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://api.myjson.com/bins/8gdmr&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {info: data}
  }
}
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第十一节：静态资源和打包&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.静态资源&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
（1）直接引入图片&lt;br/&gt;在网上任意下载一个图片，放到项目中的static文件夹下面，然后可以使用下面的引入方法进行引用
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;~static/logo.png&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“~”就相当于定位到了项目根目录，这时候图片路径就不会出现错误，就算打包也是正常的。&lt;/p&gt;
&lt;pre&gt;
（2）CSS引入图片&lt;br/&gt;如果在CSS中引入图片，方法和html中直接引入是一样的，也是用“~”符号引入。
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;style&amp;gt;
  .diss&lt;/span&gt;{&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt; 300px&lt;/span&gt;;&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
    background-image&lt;/span&gt;:&lt;span&gt; url('~static/logo.png')
  &lt;/span&gt;}&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时候在npm run dev 下是完全正常的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.打包&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用Nuxt.js制作完成后，你可以打包成静态文件并放在服务器上，进行运行。&lt;/p&gt;
&lt;p&gt;在终端中输入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm run generate
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在dist文件夹下输入live-server就可以了。&lt;/p&gt;
&lt;p&gt;总结：Nuxt.js框架非常简单，因为大部分的事情他都为我们做好了，我们只要安装它的规则来编写代码。&lt;/p&gt;
</description>
<pubDate>Thu, 29 Nov 2018 14:20:00 +0000</pubDate>
<dc:creator>吴封斌技术博客</dc:creator>
<og:description>第一节：nuxt.js相关概述 nuxt.js简单的说是Vue.js的通用框架，最常用的就是用来作SSR（服务器端渲染）.Vue.js是开发SPA（单页应用）的,Nuxt.js这个框架，用Vue开发多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bfwbfw/p/10040929.html</dc:identifier>
</item>
<item>
<title>程序员技术入股的那些坑 - 锋哥程序十年</title>
<link>http://www.cnblogs.com/bianchengniuren/p/10039853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bianchengniuren/p/10039853.html</guid>
<description>&lt;p&gt;从入职公司的第一天起，明仔就有一个终极梦想：技术入股某一家初创公司，然后跟着大老板把公司做大，最后股份变现，身家过亿。变身高富帅之后，明仔的第一愿望是向他从小学就开始暗恋的班花小花表白，娶她共度完美的人生。小花现在在深圳一家电子厂工作，据说很多工厂里的男生追她。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;顺利成为合伙人&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;明仔从事的技术方向比较偏门，经过几年的工作积累之后，明仔的技术已经远远超出同行。明仔成为公司的技术骨干，很多竞争对手都盯着明仔，要把明仔挖走。但是明仔不甘于一辈子打工，在寻找一个创业的机会。公司的一个客户大H觊觎明仔公司的技术很长时间了，邀请明仔加盟，答应给予适当的股份。明仔当机立断，决定加入。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;降薪算啥技术入股&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在入股的时候，老板大H找明仔谈话，希望明仔体谅一下公司，初创期降薪加盟。大H拍胸口承诺，等公司成长起来之后，一定会给明仔相应的补偿。&lt;strong&gt;明仔当面一口拒绝。&lt;/strong&gt;理由很简单，我这个是技术入股，不是薪资入股，降薪即意味着是把少领的工资投入公司做股份，所以不接受降薪。大H考虑了很久，“认同”了明仔的观点。于是答应给明仔10%的技术股份，邀请明仔加盟公司。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;不做股份变更逗我玩呢&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 大H邀请明仔加盟公司之后，去迟迟不见明仔辞职。大H有点着急了，怕事情会生出变故，于是约明仔出来喝酒。酒过三巡，大H和颜悦色的问明仔，什么时候辞职加入公司。明仔态度坚决的说：“等股份变更，拿到应有的股份之后，马上辞职。” 大H试探性的说：“股份可否等你进来公司再办手续？” 明仔一本正经的说：“这是不合理的，手续该办的还是应该先去办理，股份到账马上辞职。”大H拗不过明仔，于是和明仔去办理股份变更手续。公司原来注册资本500万，现在扩大注册资本到555万，明仔入股55万，占10%。明仔没有掏一分钱，于是高高兴兴的入职了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;保护好你的核心技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 明仔入职之后，很快利用过硬的技术，把产品线全部革新一遍。公司产品的竞争力把原来公司打的节节败退，公司获利颇丰。不知什么时候，大H把一个亲戚小A安排在明仔的部门，跟明仔学习技术。小A聪明伶俐，勤奋好学，在明仔毫无保留的培养之下，很快成长为公司的技术骨干。明仔的朋友曾经提醒明仔，让他提防提防。明仔哈哈一笑，觉得既然是公司的股东，就不应该有私心，需要毫无保留把公司搞好。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;釜底抽薪后患无穷&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 明仔带出一帮技术骨干之后，公司渐渐走上了正轨。老板看到明仔的作用渐渐没有以前大了，而且每年拿到不菲的分红。其他的员工拿的没有明仔多，加班又比明仔积极。大H渐渐对明仔不爽了。于是，大H新注册了一家公司，慢慢的把公司的业务搬了过去。明仔提出抗议，但是没有作用。明仔后悔当初把技术全部交出去了。明仔占股的公司渐渐沦为研发和售后的公司，公司每年的利润都所剩无几了。一次偶然的事件，明仔和大H闹翻了。都说涉及到利益的都是动刀子的大事，明仔终于相信了。明仔在这家公司看不到希望了。这时候有人来挖明仔，明仔决定果断走人，从头开始。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;想走，没那么容易&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 明仔放弃公司所有的股份，毅然出走。很快，明仔所在的新公司对大H构成了威胁，大H很生气，要给明仔点color see see。大H把明仔占股的公司做空，然后把公司做成负债。明仔需要承担55万股本的责任，所以明仔需要向公司注入实收资本55万，然后公司变卖资本还债。明仔把这几年的分红全部搭了进去，一夜回到解放前。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;教训总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;明仔在入股公司的时候，其实做的已经非常理性。唯一犯的错误，是在增资入股的时候，没有明确是技术入股。技术入股是指技术持有人（或者技术出资人）以技术成果作为无形资产作价出资公司的行为。那明仔在刚入股的时候，为什么不需要出一分钱呢？因为当时只是扩大了注册资本。在一般操作的时候，允许实收资本滞后缴纳。但是注册资本要和实收资本最终要达成一致，构成公司的有限责任，这就是有限责任公司。明仔当初以为不出钱，就是技术入股，实在太天真了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;后记&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;小花得知明仔的经历之后，深表同情。写信给明仔，答应做明仔的女朋友。小花现在在博主的公众号做小编，如果大家有什么问题可以去问她。公众号发送“相片”，可以看到小花的照片。详情看博主的简介。&lt;/p&gt;
</description>
<pubDate>Thu, 29 Nov 2018 14:16:00 +0000</pubDate>
<dc:creator>锋哥程序十年</dc:creator>
<og:description>从入职公司的第一天起，明仔就有一个终极梦想：技术入股某一家初创公司，然后跟着大老板把公司做大，最后股份变现，身家过亿。变身高富帅之后，明仔的第一愿望是向他从小学就开始暗恋的班花小花表白，娶她共度完美的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bianchengniuren/p/10039853.html</dc:identifier>
</item>
<item>
<title>【干货】.NET WebApi HttpMessageHandler管道 - 张子浩</title>
<link>http://www.cnblogs.com/ZaraNet/p/10041289.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZaraNet/p/10041289.html</guid>
<description>&lt;p&gt;&lt;span&gt;消息拦截器是一个类，接收 HTTP request并返回 HTTP response,Message handler 继承自抽象类 HttpMessageHandler，那么学习消息过滤器之前你应该了解下webapi的执行流程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201811/1366751-20181129205842793-1489098566.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上是webapi的执行流程，先是从response开始执行一套顺序之后通过network再回到了Request，其中经过了messageHandler，因为它是webapi架构中给我们可以自定义handler的地方，这和以往的webform差不多。都是基于http请求的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有可能你会说这和过滤器Aop模式差不多啊，但你可以看完这篇文章之后再比比谁强大，当然它两者的用处都不同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那消息拦截器有什么用呢，听名字我觉得你应该就知道是怎么回事，它是可以在客户端请求用修改请求信息的中间层，再次其中我们可以修改;添加 response headers，在到达 controller 之前，进行参数验证！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自定义  MessageHandler 需要继承&lt;code&gt; System.Net.Http.DelegatingHander &lt;/code&gt;并且重载 SendAsync 方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;public class MessageHandler1 : DelegatingHandler
{
  protected async override Task&amp;lt;HttpResponseMessage&amp;gt; SendAsync(
    HttpRequestMessage request, CancellationToken cancellationToken)
  {
    Debug.WriteLine(&quot;hello&quot;);
    var response = await base.SendAsync(request, cancellationToken);
    Debug.WriteLine(&quot;bye&quot;);
    return response;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 这是最基本的处理流程，当然自此期间你需要去添加配置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;public static class WebApiConfig
{
  public static void Register(HttpConfiguration config)
  {
    config.MessageHandlers.Add(new MessageHandler1());
    config.MessageHandlers.Add(new MessageHandler2());
  }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　在消息拦截器中常见的是要判断用户信息，因为像ActionFilterAttribute、ApiControllerActionInvoker、ExceptionFilterAttribute 这些都是在action之前的，那我们就要在之前进行判断。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 在HttpRequestMessage中包含了以下属性，这些你都是可以改的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201811/1366751-20181129213116523-1006840457.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 如何操作header？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt; protected async override Task&amp;lt;HttpResponseMessage&amp;gt; SendAsync(
      HttpRequestMessage request, CancellationToken cancellationToken)
        {
            HttpResponseMessage response = await base.SendAsync(request, cancellationToken);
            response.Headers.Add(&quot;X-Custom-Header&quot;, &quot;This is my custom header.&quot;);
            return response;
        }
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　首先调用sendAsync将请求传递给inner handler,让它返回响应信息，但是它在创建异步的时候，响应消息是不可用的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只能全局去配置吗？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;//路由中指定Message Handler
        config.Routes.MapHttpRoute(
            name: &quot;Route2&quot;,
            routeTemplate: &quot;api2/{controller}/{id}&quot;,
            defaults: new { id = RouteParameter.Optional },
            handler: new MessageHandler2() // per-route message handler
　　　　　);
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这时&lt;strong&gt;MessageHandler2替换默认的HttpControllerDispatcher&lt;/strong&gt;。这个栗子中MessageHandler2创建响应，匹配“Route2”的请求永远不会转到控制器。这使我们可以使用自己的自定义响应替换整个Web API控制器机制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不知道你有没有想过，如果你的webapi不支持一些特殊的请求，你该怎么办呢，这个时候呵呵，你应该知道了吧！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个实例中我们定义了一个集合，在post请求中，一定不是get，那么就有可能是put 或者delete等待的请求头，那么我们可以获取进行修改。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;public class MethodOverrideHandler : DelegatingHandler
        {
            readonly string[] _methods = { &quot;DELETE&quot;, &quot;HEAD&quot;, &quot;PUT&quot; };
            const string _header = &quot;X-HTTP-Method-Override&quot;;
            protected override Task&amp;lt;HttpResponseMessage&amp;gt; SendAsync(
                HttpRequestMessage request, CancellationToken cancellationToken)
            {
                if (request.Method == HttpMethod.Post &amp;amp;&amp;amp; request.Headers.Contains(_header))
                {
                    var method = request.Headers.GetValues(_header).FirstOrDefault();
                    if (_methods.Contains(method, StringComparer.InvariantCultureIgnoreCase))
                    {
                        request.Method = new HttpMethod(method);
                    }
                }
                return base.SendAsync(request, cancellationToken);
            }
        }
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;  那我们可以获取请求头，如何进行添加呢？？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;public class CustomHeaderHandler : DelegatingHandler 
{ 
    async protected override Task&amp;lt;HttpResponseMessage&amp;gt; SendAsync( 
            HttpRequestMessage request, CancellationToken cancellationToken) 
    { 
        HttpResponseMessage response = await base.SendAsync(request, cancellationToken); 
        response.Headers.Add(&quot;X-Custom-Header&quot;, &quot;This is my custom-header.&quot;); 
        return response; 
    } 
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　在以上代码中我们通过base.SendAsync调用内部消息处理器返回相应结果，base.SendAsync之前是不可响应获取消息的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个示例使用了&lt;strong&gt;await&lt;/strong&gt;关键字，以便在&lt;strong&gt;SendAsync&lt;/strong&gt;完成之后异步地执行任务。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;  protected override Task&amp;lt;HttpResponseMessage&amp;gt; SendAsync( 
        HttpRequestMessage request, CancellationToken cancellationToken) 
    { 
        return base.SendAsync(request, cancellationToken).ContinueWith( 
            (task) =&amp;gt; 
            { 
                HttpResponseMessage response = task.Result; 
                response.Headers.Add(&quot;X-Custom-Header&quot;, &quot;This is my custom header.&quot;); 
                return response; 
            } 
        ); 
    } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 29 Nov 2018 14:11:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>消息拦截器是一个类，接收 HTTP request并返回 HTTP response,Message handler 继承自抽象类 HttpMessageHandler，那么学习消息过滤器之前你应该了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZaraNet/p/10041289.html</dc:identifier>
</item>
<item>
<title>vue项目如何打包前后端不分离发布手把手教学apache、nginx - 薛小白</title>
<link>http://www.cnblogs.com/yangyangxxb/p/10041248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangyangxxb/p/10041248.html</guid>
<description>&lt;h2&gt;vue项目如何不分离发布&lt;/h2&gt;
&lt;p&gt;1、首先yarn build&lt;/p&gt;
&lt;p&gt;　　我用了vue-cli脚手架，bulid后的dist文件夹里的index.html有加版本号，那么为什么需要加版本号呢？&lt;/p&gt;
&lt;p&gt;　　a、回滚&lt;/p&gt;
&lt;p&gt;　　b、解决浏览器缓存的问题&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;2、我们使用apache或者nginx帮助我们&lt;/p&gt;
&lt;p&gt;2a、apache&lt;/p&gt;
&lt;p&gt;　　　　这里我用的是XAMPP&lt;/p&gt;
&lt;p&gt;　　　　1&amp;gt;把apache打开(我这里是点击start)&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459163/201811/1459163-20181129211526141-956346624.png&quot; alt=&quot;&quot; width=&quot;361&quot; height=&quot;324&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　2&amp;gt;点击后青青草原绿&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459163/201811/1459163-20181129211742870-901752026.png&quot; alt=&quot;&quot; width=&quot;347&quot; height=&quot;309&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　3&amp;gt;etc文件下的-&amp;gt;http.conf文件(不同人电脑这个文件的路径好像不一样，自行查找)&lt;/p&gt;
&lt;p&gt;            &lt;img src=&quot;https://img2018.cnblogs.com/blog/1459163/201811/1459163-20181129212111649-90921943.png&quot; alt=&quot;&quot; width=&quot;394&quot; height=&quot;342&quot;/&gt;&lt;/p&gt;


&lt;hr/&gt;

&lt;p&gt;　　　　4&amp;gt;打开该文件以后我们需要对文件进行部分修改&lt;/p&gt;
&lt;p&gt;　　　　　　4.1&amp;gt;首先找到DocumentRoot&lt;/p&gt;
&lt;p&gt;           　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1459163/201811/1459163-20181129212212308-66029237.png&quot; alt=&quot;&quot; width=&quot;271&quot; height=&quot;118&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　这两行的内容需要改变，可以任意建立一个文件，&lt;/p&gt;
&lt;p&gt;　　　　　　只要把build打包后的dist放在你建立的这个文件里就好，&lt;/p&gt;
&lt;p&gt;　　　　　　此处的两个路径都填你建立的这个文件的路径&lt;/p&gt;
&lt;p&gt;　　　　　　我此处填的是&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459163/201811/1459163-20181129213127833-1952575555.png&quot; alt=&quot;&quot; width=&quot;276&quot; height=&quot;67&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　有可能会提示你权限不足，已管理员身份重试即可&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459163/201811/1459163-20181129213330923-529745589.png&quot; alt=&quot;&quot; width=&quot;206&quot; height=&quot;62&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;　　　　　　4.2&amp;gt;找到你的listen ，最好设置成80&lt;/p&gt;

&lt;p&gt;　　　　5&amp;gt;此时没必要再用localhost打开你的项目，你可以使用hostadmin配置一个假域名，便于你调试使用&lt;/p&gt;

&lt;p&gt;　　　　6&amp;gt;但此时你用你的假域名打开不了你的项目，一片爆红包裹着你，此时你打开你的index.html你会发现的引入的js文件等等路径写的都是/../..，换了衣服的你他认不出来了，那么你就需要重新build再build之前在你的配置文件vue.config.js中配置baseUrl：‘／dist／’具体参照官网&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459163/201811/1459163-20181129213928770-915490643.png&quot; alt=&quot;&quot; width=&quot;639&quot; height=&quot;409&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　此时你惊喜地发现改了这个配置以后，你还需要改变你的vue-router的配置，需要配置apache&lt;/p&gt;
&lt;p&gt;　　　　　官网也给了&lt;/p&gt;
&lt;p&gt;　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459163/201811/1459163-20181129214216734-2032909848.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;315&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　把这一段话放在http.conf找个位置放下吧，然后修成改这个样子&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459163/201811/1459163-20181129214428986-1070405040.png&quot; alt=&quot;&quot; width=&quot;345&quot; height=&quot;238&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　7&amp;gt;apache反向代理配置　　　　&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;2b、nginx(部分步骤与2a重复所以简写)&lt;/p&gt;
&lt;p&gt;　　1&amp;gt;修改vue.config.js&lt;/p&gt;
&lt;p&gt;　　　　加上baseUrl:‘／dist／’&lt;/p&gt;

&lt;p&gt;　　2&amp;gt;修改路由&lt;/p&gt;
&lt;p&gt;　　　　修改router下的index.js&lt;/p&gt;
&lt;p&gt;　　　　原本是&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459163/201811/1459163-20181129214917355-1592499570.png&quot; alt=&quot;&quot; width=&quot;187&quot; height=&quot;241&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　改成&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459163/201811/1459163-20181129215013077-1825671776.png&quot; alt=&quot;&quot; width=&quot;195&quot; height=&quot;194&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　3&amp;gt;找到你nginx文件夹&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459163/201811/1459163-20181129215716909-1198184200.png&quot; alt=&quot;&quot; width=&quot;479&quot; height=&quot;366&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　在里面创建一个conf.d文件夹，文件夹里随意创建任意文件 &lt;/p&gt;
&lt;p&gt; 　　　　添加如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server { 
    listen &lt;/span&gt;80&lt;span&gt;; 
    server_name localhost;
     root 你的dist所在的文件夹的路径;             
    autoindex on; 
    expires 1s; 
    charset utf&lt;/span&gt;-8&lt;span&gt;;

    location &lt;/span&gt;/ajax { proxy_pass 你接口反向代理的target; }
&lt;span&gt;
    location &lt;/span&gt;/ { try_files $uri $uri/dist /dist/index.html; } 
}        
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;

&lt;p&gt;小小一总结&lt;/p&gt;
&lt;h2&gt;带二级目录的Apache配置&lt;/h2&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;step1: 修改 vue.config.js 添加配置 baseUrl: '/dist/',&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;step2: 修改 router/index.js const router = new VueRouter({ mode: 'history', base: '/dist/', routes })&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;step3: 修改apache 配置 添加：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;RewriteEngine On RewriteBase / RewriteRule ^index\.html$ - [L] RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteRule . /dist/index.html [L] -&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;step4: apache 反向代理配置&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;带二级目录的Nginx配置&lt;/h2&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;step1: 修改 vue.config.js 添加配置 baseUrl: '/dist/',&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;step2: 修改 router/index.js const router = new VueRouter({ mode: 'history', base: '/dist/', routes })&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;step3: 配置nginx 在本地目录下，创建conf.d文件夹，里面随意创建任意文件 添加如下配置： server { listen 80; server_name localhost; root dist文件夹(dist爸爸)所在的路径; autoindex on; expires 1s; charset utf-8;&lt;/p&gt;
&lt;p&gt;location /ajax { proxy_pass 反向代理的target; }&lt;/p&gt;
&lt;p&gt;location / { try_files $uri $uri/dist /dist/index.html; } }&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Thu, 29 Nov 2018 14:04:00 +0000</pubDate>
<dc:creator>薛小白</dc:creator>
<og:description>vue项目如何不分离发布 1、首先yarn build 我用了vue-cli脚手架，bulid后的dist文件夹里的index.html有加版本号，那么为什么需要加版本号呢？ a、回滚 b、解决浏览器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangyangxxb/p/10041248.html</dc:identifier>
</item>
</channel>
</rss>