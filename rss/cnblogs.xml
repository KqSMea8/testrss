<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>万恶之源 -  Python基础数据类型三 - Meets</title>
<link>http://www.cnblogs.com/guobaoyuan/p/9824286.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guobaoyuan/p/9824286.html</guid>
<description>&lt;h3&gt;字典&lt;/h3&gt;
&lt;p&gt;　　字典的简单介绍&lt;/p&gt;
&lt;p&gt;　　字典(dict)是python中唯⼀的⼀个映射类型.他是以{ }括起来的键值对组成.&lt;/p&gt;
&lt;p&gt;　　在dict中key是 唯⼀的.在保存的时候, 根据key来计算出⼀个内存地址. 然后将key-value保存在这个地址中.&lt;/p&gt;
&lt;p&gt;　　这种算法被称为hash算法, 所以, 切记, 在dict中存储的key-value中的key必须是可hash的, 如果你搞不懂什么是可哈希, 暂时可以这样记,&lt;/p&gt;
&lt;p&gt;　　可以改变的都是不可哈希的, 那么可哈希就意味着不可变. 这个是为了能准确的计算内存地址⽽规定的.&lt;/p&gt;
&lt;p&gt;　　已知的可哈希(不可变)的数据类型: int, str, tuple, bool 不可哈希(可变)的数据类型: list, dict, set&lt;/p&gt;
&lt;p&gt;　　语法:{'key1':1,'key2':2}&lt;/p&gt;
&lt;p&gt;　　注意: &lt;span&gt;key必须是不可变(可哈希)的. value没有要求.可以保存任意类型的数据&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 合法
dic = {123: 456, True: 999, &quot;id&quot;: 1, &quot;name&quot;: 'sylar', &quot;age&quot;: 18, &quot;stu&quot;: ['帅
哥', '美⼥'], (1, 2, 3): '麻花藤'}
print(dic[123])
print(dic[True])
print(dic['id'])
print(dic['stu'])
print(dic[(1, 2, 3)])

# 不合法
# dic = {[1, 2, 3]: '周杰伦'} # list是可变的. 不能作为key
# dic = {{1: 2}: &quot;哈哈哈&quot;} # dict是可变的. 不能作为key
dic = {{1, 2, 3}: '呵呵呵'} # set是可变的, 不能作为key
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意:&lt;span&gt;dict保存的数据不是按照我们添加进去的顺序保存的. 是按照hash表的顺序保存的. ⽽hash表 不是连续的. 所以&lt;span&gt;不能进⾏切片⼯作. 它只能通过key来获取dict中的数据&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字典操作:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;增&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
dic = {}

dic['name'] = '汪峰'
dic['age'] = 18
print(dic)

结果:
{'name': '汪峰', 'age': 18}

# 如果dict中没有出现这个key,就会将key-value组合添加到这个字典中

# 如果dict中没有出现过这个key-value. 可以通过setdefault设置默认值

s1 = dic.setdefault('王菲')
print(s1)
print(dic)
结果:
None    
# 返回的是添加进去的值
{'王菲': None}  
# 我们使用setdefault这个方法 里边放的这个内容是我们字典的健,这样我们添加出来的结果
就是值是一个None

dic.setdefault('王菲',歌手)    
# 这样就是不会进行添加操作了,因为王菲在dic这个字典中存在
# 总结: 当setdefault中第一个参数存在这个字典中就就不进行添加操作,否则就添加

dic1 = {}
s2 = dic1.setdefault('王菲','歌手')
print(s2)
print(dic1)
结果: 
歌手
{'王菲': '歌手'}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;删&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
dic = {'剑圣':'易','哈啥给':'剑豪','大宝剑':'盖伦'}

s = dic.pop('哈啥给')   # pop删除有返回值,返回的是被删的值
print(s)

print(dic)    # 打印删除后的字典

dic.popitem()  # 随机删除  python3.6是删除最后一个
print(dic)

dic.clear()  # 清空
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;改&lt;/strong&gt;　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
dic = {'剑圣':'易','哈啥给':'剑豪','大宝剑':'盖伦'}

dic['哈啥给'] = '剑姬'   # 当哈啥给是字典中的健这样写就是修改对应的值,如果不存在就是添加

print(dic)

dic.update({'key':'v','哈啥给':'剑姬'})

# 当update中的字典里没有dic中键值对就添加到dic字典中,如果有就修改里边的对应的值
print(dic)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;查&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
dic = {'剑圣':'易','哈啥给':'剑豪','大宝剑':'盖伦'}

s = dic['大宝剑']        #通过健来查看,如果这个健不在这个字典中.就会报错
print(s)

s1 = dic.get('剑圣')     #通过健来查看,如果这个健不在这个字典中.就会返回None
print(s1)

s2 = dic.get('剑姬','没有还查你是不是傻')  # 我们可以在get查找的时候自己定义返回的结果
print(s2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
dic = {'k1': &quot;v1&quot;, &quot;k2&quot;: &quot;v2&quot;, &quot;k3&quot;: [11,22,33]}
请在字典中添加一个键值对，&quot;k4&quot;: &quot;v4&quot;，输出添加后的字典
请在修改字典中 &quot;k1&quot; 对应的值为 &quot;alex&quot;，输出修改后的字典
请在k3对应的值中追加一个元素 44，输出修改后的字典
请在k3对应的值的第 1 个位置插入个元素 18，输出修改后的字典
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;其他操作&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
key_list = dic.keys()    
print(key_list)

结果:
dict_keys(['剑圣', '哈啥给', '大宝剑'])
# 一个高仿列表,存放的都是字典中的key

value_list = dic.values()
print(value_list)

结果:
dict_values(['易', '剑豪', '盖伦'])
#一个高仿列表,存放都是字典中的value

key_value_list = dic.items()
print(key_value_list)
结果:
dict_items([('剑圣', '易'), ('哈啥给', '剑豪'), ('大宝剑', '盖伦')])

# 一个高仿列表,存放是多个元祖,元祖中第一个是字典中的键,第二个是字典中的值　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;循环打印字典的值&lt;/p&gt;
&lt;p&gt;循环打印字典的键&lt;/p&gt;
&lt;p&gt;循环打印元祖形式的键值对&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('bcf5598c-347d-4033-bb55-46001ce18d95')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_bcf5598c-347d-4033-bb55-46001ce18d95&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_bcf5598c-347d-4033-bb55-46001ce18d95&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('bcf5598c-347d-4033-bb55-46001ce18d95',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_bcf5598c-347d-4033-bb55-46001ce18d95&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
dic = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;剑圣&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;易&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;哈啥给&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;剑豪&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;大宝剑&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;盖伦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dic:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)

结果:
易
剑豪
盖伦

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dic.keys():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)

结果:
易
剑豪
盖伦&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;循环打印字典中的键&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d3c13e25-80a4-4a33-8044-e456d4f74a93')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_d3c13e25-80a4-4a33-8044-e456d4f74a93&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d3c13e25-80a4-4a33-8044-e456d4f74a93&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d3c13e25-80a4-4a33-8044-e456d4f74a93',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d3c13e25-80a4-4a33-8044-e456d4f74a93&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
dic = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;剑圣&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;易&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;哈啥给&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;剑豪&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;大宝剑&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;盖伦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dic:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(dic[i])

结果:
易
剑豪
盖伦

  
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dic.values():   
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i) 

结果:
易
剑豪
盖伦&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;循环打印字典中的值&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('0c9b481a-90e7-4be1-8f2f-1c20c8aff033')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_0c9b481a-90e7-4be1-8f2f-1c20c8aff033&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0c9b481a-90e7-4be1-8f2f-1c20c8aff033&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('0c9b481a-90e7-4be1-8f2f-1c20c8aff033',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0c9b481a-90e7-4be1-8f2f-1c20c8aff033&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
dic = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;剑圣&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;易&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;哈啥给&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;剑豪&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;大宝剑&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;盖伦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dic.items():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)


结果:
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;剑圣&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;易&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;哈啥给&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;剑豪&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;大宝剑&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;盖伦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;循环打印元祖形式的键值对&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;解构&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
a,b = 1,2
print(a,b)
结果:
1 2

a,b = ('你好','世界')
print(a,b)
结果:
你好 世界


a,b = ['你好','大飞哥']
print(a,b)
结果:
你好 世界


a,b = {'汪峰':'北京北京','王菲':'天后'}
print(a,b)
结果:
汪峰 王菲
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;循环字典获取键和值&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
for k,v in dic.items():
    print('这是键',k)
    print('这是值',v)

结果:
这是键 剑圣
这是值 易
这是键 哈啥给
这是值 剑豪
这是键 大宝剑
这是值 盖伦
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;字典的嵌套&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
dic = {
    'name':'汪峰',
    'age':48,
    'wife':[{'name':'国际章','age':38}],
    'children':['第一个熊孩子','第二个熊孩子']
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取汪峰的妻子名字&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
d1 = dic['wife'][0]['name']
print(d1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取汪峰的孩子们&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
d2 = dic['children']
print(d2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取汪峰的第一个孩子&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
d3 = dic['children'][0]
print(d3)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;练习&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
dic1 = {
 'name':['alex',2,3,5],
 'job':'teacher',
 'oldboy':{'alex':['python1','python2',100]}
 }
1，将name对应的列表追加⼀个元素’wusir’。
2，将name对应的列表中的alex⾸字⺟⼤写。
3，oldboy对应的字典加⼀个键值对’⽼男孩’,’linux’。
4，将oldboy对应的字典中的alex对应的列表中的python2删除
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;小数据池&lt;/h3&gt;
&lt;p&gt;接下来我们学习下小数据池,在学小数据池之前我们来看下代码块&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;根据提示我们从官方文档找到了这样的说法：
A Python program &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; constructed &lt;span&gt;from&lt;/span&gt; code blocks. A block &lt;span&gt;is&lt;/span&gt; a piece of Python program text that &lt;span&gt;is&lt;/span&gt; executed as a unit. The following are blocks: a module, a function body, &lt;span&gt;and&lt;/span&gt; a &lt;span&gt;class&lt;/span&gt; definition. Each command typed interactively &lt;span&gt;is&lt;/span&gt; a block. A script file (a file given as standard input to the interpreter &lt;span&gt;or&lt;/span&gt; specified as a command line argument to the interpreter) &lt;span&gt;is&lt;/span&gt; a code block. A script command (a command specified on the interpreter command line with the ‘-c‘ option) &lt;span&gt;is&lt;/span&gt; a code block. The string argument passed to the built-&lt;span&gt;in&lt;/span&gt; functions eval() &lt;span&gt;and&lt;/span&gt; &lt;span&gt;exec&lt;/span&gt;() &lt;span&gt;is&lt;/span&gt;&lt;span&gt; a code block.
A code block &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; executed &lt;span&gt;in&lt;/span&gt; an execution frame. A frame contains some administrative information (used &lt;span&gt;for&lt;/span&gt; debugging) &lt;span&gt;and&lt;/span&gt; determines where &lt;span&gt;and&lt;/span&gt; how execution continues after the code block’s execution has completed.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的主要意思是：&lt;/p&gt;
&lt;p&gt;Python程序是由代码块构造的。块是一个python程序的文本，他是作为一个单元执行的。&lt;/p&gt;
&lt;p&gt;代码块：一个模块，一个函数，一个类，一个文件等都是一个代码块。&lt;/p&gt;
&lt;p&gt;而作为交互方式输入的每个命令都是一个代码块。&lt;/p&gt;
&lt;p&gt;什么叫交互方式？就是咱们在cmd中进入Python解释器里面，每一行代码都是一个代码块，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1122844/201810/1122844-20181021225033650-434262057.png&quot; alt=&quot;&quot; width=&quot;586&quot; height=&quot;252&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而对于一个文件中的两个函数，也分别是两个不同的代码块：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1122844/201810/1122844-20181021225230234-308782639.png&quot; alt=&quot;&quot; width=&quot;590&quot; height=&quot;124&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，那么现在我们了解了代码块，我们就来看看小数据池和代码块有啥关系,&lt;/p&gt;
&lt;h3&gt;id is ==&lt;/h3&gt;
&lt;p&gt;在Python中，id是什么？id是内存地址，比如你利用id()内置函数去查询一个数据的内存地址：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
name = 'meet'
s_id = id(name)   # 通过内置方法获取name变量对应的值在内存中的编号
print(s_id)       # 2055782908568 这就是name在内存中的编号
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么 is 是什么？ == 又是什么？&lt;/p&gt;
&lt;p&gt;== 是比较的两边的数值是否相等，而 is 是比较的两边的内存地址是否相等。 如果内存地址相等，那么这两边其实是指向同一个内存地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1122844/201810/1122844-20181021230329189-847869549.png&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;211&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以说如果内存地址相同，那么值肯定相同，但是如果值相同，内存地址不一定相同,如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1122844/201810/1122844-20181021230731563-1167155414.png&quot; alt=&quot;&quot; width=&quot;602&quot; height=&quot;163&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就很神奇了,刚刚还不是一个内存地址呢,现在怎么又是一个内存地址了,其中神奇之处就是我们的小数据池&lt;/p&gt;
&lt;p&gt;小数据池，也称为小整数缓存机制，或者称为驻留机制等等.  那么到底什么是小数据池？他有什么作用呢？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：小数据池，只针对，整数，字符串，bool值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;官方对于整数，字符串的小数据池是这么说的:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;对于整数，Python官方文档中这么说：
The current implementation keeps an array of integer objects &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; all integers between -5 &lt;span&gt;and&lt;/span&gt; 256, when you create an int &lt;span&gt;in&lt;/span&gt; that range you actually just get back a reference to the existing object. So it should be possible to change the value of 1. I suspect the behaviour of Python &lt;span&gt;in&lt;/span&gt; this case &lt;span&gt;is&lt;/span&gt;&lt;span&gt; undefined.

对于字符串：
Incomputer science, string interning &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; a method of storing only onecopy of each distinct string value, which must be immutable. Interning strings makes some stringprocessing tasks more time- &lt;span&gt;or&lt;/span&gt; space-efficient at the cost of requiring moretime when the string &lt;span&gt;is&lt;/span&gt; created &lt;span&gt;or&lt;/span&gt; interned. The distinct values are stored ina string intern pool. –引自维基百科
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在python中对-5到256之间的整数会被驻留在内存中. 将⼀定规则的字符串缓存. 在使⽤ 的时候, 内存中只会创建⼀个该数据的对象. 保存在⼩数据池中. 当使⽤的时候直接从⼩数据 池中获取对象的内存引⽤. ⽽不需要创建⼀个新的数据. 这样会节省更多的内存区域.&lt;/p&gt;
&lt;p&gt;优点:&lt;/p&gt;
&lt;p&gt;　　能够提⾼⼀些字符串, 整数的处理速度. 省略的创建对象的过程.&lt;/p&gt;
&lt;p&gt;缺点:&lt;/p&gt;
&lt;p&gt;　　在'池'中创建或者插入新的内容会花费更多的时间.&lt;/p&gt;
&lt;p&gt;对于数字:&lt;/p&gt;
&lt;p&gt;　　-5~256是会被加到⼩数据池中的. 每次使⽤都是同⼀个对象.&lt;/p&gt;
&lt;p&gt;对于字符串:&lt;/p&gt;
&lt;p&gt;　　1. 如果字符串的⻓度是0或者1, 都会默认进⾏缓存&lt;/p&gt;
&lt;p&gt;　　2. 字符串⻓度⼤于1, 但是字符串中只包含字⺟, 数字, 下划线时才会缓存&lt;/p&gt;
&lt;p&gt;　　3. ⽤乘法的到的字符串.&lt;/p&gt;
&lt;p&gt;　　　　①. 乘数为1, 仅包含数字, 字⺟, 下划线时会被缓存. 如果 包含其他字符, ⽽⻓度&amp;lt;=1 也会被驻存&lt;/p&gt;
&lt;p&gt;　　　　②. 乘数⼤于1 . 仅包含数字, 字⺟, 下划 线这个时候会被缓存. 但字符串⻓度不能⼤于20 4. 指定驻留. 我们可以通过sys模块中的intern()函数来指定要驻留的内容.&lt;/p&gt;
&lt;p&gt;OK. 到⽬前为⽌. 我们已经了解了python的⼩数据池的⼀些基本情况了. 但是!!!!&lt;/p&gt;
&lt;p&gt;还有最后⼀ 个问题. ⼩数据池和最开始的代码块有什么关系呢?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1122844/201810/1122844-20181021231811194-1062227580.png&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;262&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样的⼀段代码在命令⾏窗⼝和在py⽂件中. 出现的效果是完全不⼀样的.　　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意. 在py⽂件中.得到的结果是True, 但是在cmd中就不是了.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在代码块内的缓存机制是不⼀样的. 在执⾏同⼀个代码块的初始化对象的命令时, 会检 查是否其值是否已经存在, 如果存在, 会将其重⽤.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;换句话说: 执⾏同⼀个代码块时, 遇到初始 化对象的命令时，他会将初始化的这个变量与值存储在⼀个字典中, 在遇到新的变量时, 会先 在字典中查询记录,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果有同样的记录那么它会重复使⽤这个字典中的之前的这个值. 所以在 你给出的例⼦中, ⽂件执⾏时(同⼀个代码块) 会把a, b两个变量指向同⼀个对象.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是不同的代码块, 他就会看这个两个变量是否是满⾜⼩数据池的数据, 如果是满⾜ ⼩数据池的数据则会指向同⼀个地址.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以: a, b的赋值语句分别被当作两个代码块执⾏, 但是他们不满⾜⼩数据池的数据所以会得到两个不同的对象, 因⽽is判断返回False&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;集合(set)&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;set集合是python的⼀个基本数据类型. ⼀般不是很常⽤. set中的元素是不重复的.⽆序的.⾥ ⾯的元素必须是可hash的(int, str, tuple,bool), 我们可以这样来记. set就是dict类型的数据但 是不保存value, 只保存key. set也⽤{}表⽰&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意: &lt;span&gt;set集合中的元素必须是可hash的, 但是set本⾝是不可hash得.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;set是可变的.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
set1 = {'1','alex',2,True,[1,2,3]} # 报错
set2 = {'1','alex',2,True,{1:2}} # 报错
set3 = {'1','alex',2,True,(1,2,[2,3,4])} # 报错
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;set中的元素是不重复的, 且⽆序的. &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
s = {&quot;周杰伦&quot;, &quot;周杰伦&quot;, &quot;周星星&quot;}
print(s)
结果:
{'周星星', '周杰伦'}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使⽤这个特性.我们可以使⽤set来去掉重复&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# 给list去重复
lst = [45, 5, &quot;哈哈&quot;, 45, '哈哈', 50]
lst = list(set(lst)) # 把list转换成set, 然后再转换回list
print(lst)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;set集合增删改查&lt;/strong&gt;　　&lt;/p&gt;
&lt;p&gt;增加&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
s = {&quot;刘嘉玲&quot;, '关之琳', &quot;王祖贤&quot;}
s.add(&quot;郑裕玲&quot;)
print(s)
s.add(&quot;郑裕玲&quot;) # 重复的内容不会被添加到set集合中
print(s)
s = {&quot;刘嘉玲&quot;, '关之琳', &quot;王祖贤&quot;}
s.update(&quot;麻花藤&quot;) # 迭代更新
print(s)
s.update([&quot;张曼⽟&quot;, &quot;李若彤&quot;,&quot;李若彤&quot;])
print(s)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
s = {&quot;刘嘉玲&quot;, '关之琳', &quot;王祖贤&quot;,&quot;张曼⽟&quot;, &quot;李若彤&quot;}
item = s.pop() # 随机弹出⼀个.
print(s)
print(item)
s.remove(&quot;关之琳&quot;) # 直接删除元素
# s.remove(&quot;⻢⻁疼&quot;) # 不存在这个元素. 删除会报错
print(s)
s.clear() # 清空set集合.需要注意的是set集合如果是空的. 打印出来是set() 因为要和
dict区分的.
print(s) # set()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# set集合中的数据没有索引. 也没有办法去定位⼀个元素. 所以没有办法进⾏直接修改.
# 我们可以采⽤先删除后添加的⽅式来完成修改操作
s = {&quot;刘嘉玲&quot;, '关之琳', &quot;王祖贤&quot;,&quot;张曼⽟&quot;, &quot;李若彤&quot;}
# 把刘嘉玲改成赵本⼭
s.remove(&quot;刘嘉玲&quot;)
s.add(&quot;赵本⼭&quot;)
print(s)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# set是⼀个可迭代对象. 所以可以进⾏for循环
for el in s:
 print(el)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常⽤操作　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;58&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
s1 = {&quot;刘能&quot;, &quot;赵四&quot;, &quot;⽪⻓⼭&quot;}
s2 = {&quot;刘科⻓&quot;, &quot;冯乡⻓&quot;, &quot;⽪⻓⼭&quot;}
# 交集
# 两个集合中的共有元素
print(s1 &amp;amp; s2) # {'⽪⻓⼭'}
print(s1.intersection(s2)) # {'⽪⻓⼭'}
# 并集
print(s1 | s2) # {'刘科⻓', '冯乡⻓', '赵四', '⽪⻓⼭', '刘能'}
print(s1.union(s2)) # {'刘科⻓', '冯乡⻓', '赵四', '⽪⻓⼭', '刘能'}
# 差集
print(s1 - s2) # {'赵四', '刘能'} 得到第⼀个中单独存在的
print(s1.difference(s2)) # {'赵四', '刘能'}
# 反交集
print(s1 ^ s2) # 两个集合中单独存在的数据 {'冯乡⻓', '刘能', '刘科⻓', '赵四'}
print(s1.symmetric_difference(s2)) # {'冯乡⻓', '刘能', '刘科⻓', '赵四'}
s1 = {&quot;刘能&quot;, &quot;赵四&quot;}
s2 = {&quot;刘能&quot;, &quot;赵四&quot;, &quot;⽪⻓⼭&quot;}
# ⼦集
print(s1 &amp;lt; s2) # set1是set2的⼦集吗? True
print(s1.issubset(s2))
# 超集
print(s1 &amp;gt; s2) # set1是set2的超集吗? False
print(s1.issuperset(s2))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;set集合本⾝是可以发⽣改变的. 是不可hash的. 我们可以使⽤frozenset来保存数据. frozenset是不可变的. 也就是⼀个可哈希的数据类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
s = frozenset([&quot;赵本⼭&quot;, &quot;刘能&quot;, &quot;⽪⻓⼭&quot;, &quot;⻓跪&quot;])
dic = {s:'123'} # 可以正常使⽤了
print(dic)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个不是很常⽤. 了解⼀下就可以了&lt;/p&gt;

</description>
<pubDate>Sun, 21 Oct 2018 15:37:00 +0000</pubDate>
<dc:creator>Meets</dc:creator>
<og:description>字典 字典的简单介绍 字典(dict)是python中唯⼀的⼀个映射类型.他是以{ }括起来的键值对组成. 在dict中key是 唯⼀的.在保存的时候, 根据key来计算出⼀个内存地址. 然后将key</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guobaoyuan/p/9824286.html</dc:identifier>
</item>
<item>
<title>sharding jdbc之解析引擎 - ninan_ton</title>
<link>http://www.cnblogs.com/tzc1024/p/9825223.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tzc1024/p/9825223.html</guid>
<description>&lt;p&gt;&lt;span&gt;解析过程分为&lt;span&gt;词法解析&lt;/span&gt;和&lt;span&gt;语法解析&lt;/span&gt;。 解析引擎在 &lt;code&gt;parsing&lt;/code&gt; 包下，包含两大组件：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;Lexer：词法解析器。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Parser：SQL解析器。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;词法解析器用于将&lt;span&gt;SQL&lt;/span&gt;拆解为不可再分的原子符号，称为&lt;span&gt;Token&lt;/span&gt;。并根据不同数据库方言所提供的字典，将其归类为关键字，表达式，字面量和操作符。 再使用语法解析器将&lt;span&gt;SQL&lt;/span&gt;转换为抽象语法树。例如：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; id, name &lt;span&gt;FROM&lt;/span&gt; t_user &lt;span&gt;WHERE&lt;/span&gt; status &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ACTIVE&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;AND&lt;/span&gt; age &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;18&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;解析成的抽象语法树如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1051013/201810/1051013-20181021141202035-701216587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;两者都是解析器，区别在于 Lexer 只做词法的解析，不关注上下文，将字符串拆解成 N 个分词。而 Parser 在 Lexer 的基础上，进一步理解 SQL表示的行为 。 &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1.1 Lexer 词法解析器&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;作用&lt;/span&gt;：顺序&lt;/span&gt;&lt;/strong&gt;解析 SQL，将sql字符串分解成 N 个分词（token）。那么每个分词该如何表示呢？&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;1.1.1 token 和 tokenType&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;token用于描述当前分解出的词法，包含3个属性：&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;TokenType &lt;em&gt;type&lt;/em&gt; ：词法标记类型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;String &lt;em&gt;literals&lt;/em&gt; ：当前词法字面量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;int &lt;em&gt;endPosition&lt;/em&gt; ：&lt;em&gt;literals &lt;/em&gt;在 SQL 字符串中的位置&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;TokenType 用于描述当前token的类型，分成 4 大类：&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;DefaultKeyword ：词法关键词&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Literals ：词法字面量标记&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Symbol ：词法符号标记&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Assist ：词法辅助标记&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1051013/201810/1051013-20181021162921819-862564022.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;





&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1051013/201810/1051013-20181021163014950-1674131022.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;1.1.2 词法解析器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;由于不同数据库遵守的 SQL 规范有所不同，所以不同的数据库对应存在不同的 Lexer，维护了对应的dictionary。Lexer内部根据相应数据库的dictionary与sql语句生成一个Tokenizer分词器进行分词。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Tokenizer {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String input;
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字典&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; Dictionary dictionary;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;偏移量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; offset;
  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;6&quot;&gt;


&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;分词器具体的api如下：&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;int skipWhitespace()&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;跳过所有的空格 返回最后的偏移量&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;int skipComment()&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;跳过注释，并返回最终的偏移量&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;Token scanVariable()&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;获取变量，返回分词Token&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Token scanIdentifier()&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;返回关键词分词&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;Token scanHexDecimal()&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;扫描16进制返回分词&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Token scanNumber()&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;返回数字分词&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;Token scanChars()&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;返回字符串分词&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;Token scanSymbol()&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;返回词法符号标记分词&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;所有的分词结果都是按照TokenType进行标记返回Token，不同的分词类型，有不同的分词方法去处理并返回。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;核心代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Lexer.java&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; nextToken() {
        skipIgnoredToken();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isVariableBegin()) {
            currentToken &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tokenizer(input, dictionary, offset).scanVariable();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isNCharBegin()) {
            currentToken &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Tokenizer(input, dictionary, ++&lt;span&gt;offset).scanChars();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isIdentifierBegin()) {
            currentToken &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tokenizer(input, dictionary, offset).scanIdentifier();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isHexDecimalBegin()) {
            currentToken &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tokenizer(input, dictionary, offset).scanHexDecimal();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isNumberBegin()) {
            currentToken &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tokenizer(input, dictionary, offset).scanNumber();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isSymbolBegin()) {
            currentToken &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tokenizer(input, dictionary, offset).scanSymbol();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isCharsBegin()) {
            currentToken &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Tokenizer(input, dictionary, offset).scanChars();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isEnd()) {
            currentToken &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Token(Assist.END, &quot;&quot;&lt;span&gt;, offset);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SQLParsingException(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, Assist.ERROR);
        }
        offset &lt;/span&gt;=&lt;span&gt; currentToken.getEndPosition();

        System.out.println(currentToken.getLiterals() &lt;/span&gt;+ &quot; | &quot; + currentToken.getType() + &quot; | &quot; + currentToken.getEndPosition() + &quot; |&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;类继承图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1051013/201810/1051013-20181021150658564-504274936.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;总结：Lexer通过 &lt;code&gt;nextToken()&lt;/code&gt; 方法，不断解析出当前 Token。&lt;code&gt;Lexer的nextToken()&lt;/code&gt;方法里，使用 &lt;code&gt;skipIgnoredToken()&lt;/code&gt; 方法跳过忽略的 Token，通过 &lt;code&gt;isXxx()&lt;/code&gt; 方法判断好下一个 Token 的类型后，交给 Tokenizer 进行分词并返回 Token。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;1.2 SQLParser 语法解析器&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;语法解析器的作用是根据不同类型的sql语句在词法解析器的基础上，由不同类型的语法解析器解析成SQLStatement，具体语法解析类结构如图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1051013/201810/1051013-20181021225225532-1513196907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，不同类型的sql，不同厂商的数据库，存在不同的处理解析器去解析，解析完成之后，会将SQL解析成SQLStatement。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SQLParsingEngine，SQL 解析引擎。其 &lt;code&gt;parse()&lt;/code&gt; 方法作为 SQL 解析入口，本身不带复杂逻辑，通过调用对应的 SQLParser 进行 SQL 解析，返回SQLStatement。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RequiredArgsConstructor
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SQLParsingEngine {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; DatabaseType dbType;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String sql;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ShardingRule shardingRule;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ShardingTableMetaData shardingTableMetaData;
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Parse SQL.
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; useCache use cache or not
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; parsed SQL statement
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; SQLStatement parse(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; useCache) {
        Optional&lt;/span&gt;&amp;lt;SQLStatement&amp;gt; cachedSQLStatement =&lt;span&gt; getSQLStatementFromCache(useCache);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (cachedSQLStatement.isPresent()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cachedSQLStatement.get();
        }
        LexerEngine lexerEngine &lt;/span&gt;=&lt;span&gt; LexerEngineFactory.newInstance(dbType, sql);
        lexerEngine.nextToken();
        SQLStatement result &lt;/span&gt;=&lt;span&gt; SQLParserFactory.newInstance(dbType, lexerEngine.getCurrentToken().getType(), shardingRule, lexerEngine, shardingTableMetaData).parse();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (useCache) {
            ParsingResultCache.getInstance().put(sql, result);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;SQLStatement对象是个超类，具体实现类有很多。按照不同的语句，解析成不同的SQLStatement。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1051013/201810/1051013-20181021232351999-1493480598.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;sql语句解析的过程如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1051013/201810/1051013-20181021233330706-91450442.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;http://www.iocoder.cn/categories/Sharding-JDBC/&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/u/c6408f5e4b0e&lt;/p&gt;
</description>
<pubDate>Sun, 21 Oct 2018 15:35:00 +0000</pubDate>
<dc:creator>ninan_ton</dc:creator>
<og:description>1. 解析引擎 解析过程分为词法解析和语法解析。 解析引擎在 parsing 包下，包含两大组件： 词法解析器用于将SQL拆解为不可再分的原子符号，称为Token。并根据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tzc1024/p/9825223.html</dc:identifier>
</item>
<item>
<title>【神经网络】自编码聚类算法--DEC (Deep Embedded Clustering) - 文字妖精</title>
<link>http://www.cnblogs.com/wzyj/p/9827584.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wzyj/p/9827584.html</guid>
<description>&lt;p&gt;&lt;span&gt;1.算法描述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;span&gt;最近在做AutoEncoder的一些探索，看到2016年的一篇论文，虽然不是最新的，但是思路和方法值得学习。论文原文链接 &lt;a href=&quot;http://proceedings.mlr.press/v48/xieb16.pdf&quot; target=&quot;_blank&quot;&gt;http://proceedings.mlr.press/v48/xieb16.pdf&lt;/a&gt;，论文有感于t-SNE算法的t-分布，先假设初始化K个聚类中心，然后数据距离中心的距离满足t-分布，可以用下面的公式表示:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/377271/201810/377271-20181021220155834-1024912903.png&quot; alt=&quot;&quot;/&gt;其中 i表示第i样本,j表示第j个聚类中心, z表示原始特征分布经过Encoder之后的表征空间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$q_{ij}$可以解释为样本i属于聚类j的概率，属于论文上说的&quot;软分配&quot;的概念。那么“硬分配”呢?那就是样本一旦属于一个聚类，其余的聚类都不属于了，也就是其余聚类的概率为0。由于$\alpha$在有label的训练计划中，是在验证集上进行确定的，在该论文中，全部设置成了常数1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     然后神奇的事情发生了，作者发明了一个辅助分布也用来衡量样本属于某个聚类的分布，就是下面的公式了:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/377271/201810/377271-20181021222120457-1763370507.png&quot; alt=&quot;&quot;/&gt;，其中$f_{j}=\sum_{i}q_{ij}$&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也许你会疑问，上面这个玩意怎么来的?作者的论文中说主要考虑一下三点:&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;强化预测。q分布为软分配的概率，那么p如果使用delta分布来表示，显得比较原始。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;置信度越高，属于某个聚类概率越大。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;规范每个质心的损失贡献，以防止大类扭曲隐藏的特征空间。分子中那个$f_{j}$就是做这个的。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;假设分布有了，原始的数据分布也有了，剩下衡量两个分布近似的方法，作者使用了KL散度，公式如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/377271/201810/377271-20181021223111009-354569643.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;这个也是DEC聚类的损失函数。有了具体的公式，明确一下每次迭代更新需要Update的参数：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/377271/201810/377271-20181021223343852-201517302.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个公式是优化AE中的Encoder参数，第二个公式是优化聚类中心。也就是说作者同时优化了聚类和DNN的相关参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者设计的网络概念图如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/377271/201810/377271-20181021223727573-1521567551.png&quot; alt=&quot;&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   DEC算法由两部分组成，第一部分会预训练一个AE模型；第二部分选取AE模型中的Encoder部分，加入聚类层，使用KL散度进行训练聚类。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.实验分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;实验部分比较了几种算法，比较的指标是ACC，对比表格如下:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/377271/201810/377271-20181021224829070-1520193925.png&quot; alt=&quot;&quot; width=&quot;887&quot; height=&quot;213&quot;/&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;DEC的效果还是比较不错的，另外值得一提的是DEC w/o backprop算法，是将第一部分Encoder的参数固定之后，不再参加训练，只更新聚类中心的算法，从结果上看，并没有两者同时训练效果来的好。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.源码分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;论文使用的Caffe写的，对于我这种半路出家的和尚有点吃力，网上找了一个keras的实现代码，&lt;a href=&quot;https://github.com/XifengGuo/DEC-keras/blob/master/DEC.py&quot; target=&quot;_blank&quot;&gt;https://github.com/XifengGuo/DEC-keras/blob/master/DEC.py&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先是DEC的预训练的部分，预训练的模型先保存了起来方便训练聚类使用:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; pretrain(self, x, y=None, optimizer=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;adam&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, epochs=200, batch_size=256, save_dir=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;results/temp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;...Pretraining...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.autoencoder.compile(optimizer&lt;/span&gt;=optimizer, loss=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mse&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;span&gt;self.autoencoder.fit(x, x, batch_size&lt;/span&gt;&lt;/span&gt;&lt;span&gt;=batch_size, epochs=epochs, callbacks=&lt;/span&gt;&lt;span&gt;&lt;span&gt;cb)&lt;/span&gt;
        self.autoencoder.save_weights(save_dir &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/ae_weights.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.pretrained &lt;/span&gt;= True
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在进行训练之前，我们看一下作者构造的一个新的网络层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClusteringLayer(Layer):
    .....

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; build(self, input_shape):
        &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; len(input_shape) == 2&lt;span&gt;
        input_dim &lt;/span&gt;= input_shape[1&lt;span&gt;]
        self.input_spec &lt;/span&gt;= InputSpec(dtype=K.floatx(), shape=&lt;span&gt;(None, input_dim))&lt;br/&gt;&lt;span&gt;//在这里定义了需要训练更新的权重，就是说把K个聚类当作了“权重”来进行更新了&lt;/span&gt;
        &lt;span&gt;self.clusters &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= self.add_weight((self.n_clusters, input_dim), initializer='glorot_uniform', name='clusters')
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; self.initial_weights &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
            self.set_weights(self.initial_weights)
            &lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; self.initial_weights
        self.built &lt;/span&gt;=&lt;span&gt; True

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; call(self, inputs, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; student t-distribution, as same as used in t-SNE algorithm.
                 q_ij = 1/(1+dist(x_i, u_j)^2), then normalize it.
        Arguments:
            inputs: the variable containing data, shape=(n_samples, n_features)
        Return:
            q: student's t-distribution, or soft labels for each sample. shape=(n_samples, n_clusters)
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        q &lt;/span&gt;= 1.0 / (1.0 + (K.sum(K.square(K.expand_dims(inputs, axis=1) - self.clusters), axis=2) /&lt;span&gt; self.alpha))
        q &lt;/span&gt;**= (self.alpha + 1.0) / 2.0&lt;span&gt;
        q &lt;/span&gt;= K.transpose(K.transpose(q) / K.sum(q, axis=1&lt;span&gt;))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; q

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; compute_output_shape(self, input_shape):
        &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; input_shape &lt;span&gt;and&lt;/span&gt; len(input_shape) == 2
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; input_shape[0], self.n_clusters

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_config(self):
        config &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;n_clusters&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: self.n_clusters}
        base_config &lt;/span&gt;=&lt;span&gt; super(ClusteringLayer, self).get_config()
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; dict(list(base_config.items()) + list(config.items()))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来就是第二部分fit的过程了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; fit(self, x, y=None, maxiter=2e4, batch_size=256, tol=1e-3&lt;span&gt;,
            update_interval&lt;/span&gt;=140, save_dir=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./results/temp&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Step 1: initialize cluster centers using k-means&lt;/span&gt;
        &lt;span&gt;kmeans = KMeans(n_clusters=self.n_clusters, n_init=20)
        y_pred = kmeans.fit_predict(self.encoder.predict(x))
        y_pred_last = np.copy(y_pred)
        self.model.get_layer(name='clustering').set_weights([kmeans.cluster_centers_])

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Step 2: deep clustering&lt;/span&gt;
&lt;span&gt;    
        loss &lt;/span&gt;=&lt;span&gt; 0
        index &lt;/span&gt;=&lt;span&gt; 0
        index_array &lt;/span&gt;=&lt;span&gt; np.arange(x.shape[0])
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; ite &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(int(maxiter)):
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ite % update_interval ==&lt;span&gt; 0:
                q &lt;/span&gt;= self.model.predict(x, verbose=&lt;span&gt;0)
                p &lt;/span&gt;= self.target_distribution(q)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; update the auxiliary target distribution p&lt;/span&gt;

                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; evaluate the clustering performance&lt;/span&gt;
                y_pred = q.argmax(1&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; y &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
                    acc &lt;/span&gt;= np.round(metrics.acc(y, y_pred), 5&lt;span&gt;)
                    nmi &lt;/span&gt;= np.round(metrics.nmi(y, y_pred), 5&lt;span&gt;)
                    ari &lt;/span&gt;= np.round(metrics.ari(y, y_pred), 5&lt;span&gt;)
                    loss &lt;/span&gt;= np.round(loss, 5&lt;span&gt;)
                    logdict &lt;/span&gt;= dict(iter=ite, acc=acc, nmi=nmi, ari=ari, loss=&lt;span&gt;loss)
                    logwriter.writerow(logdict)
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Iter %d: acc = %.5f, nmi = %.5f, ari = %.5f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (ite, acc, nmi, ari), &lt;span&gt;'&lt;/span&gt;&lt;span&gt; ; loss=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, loss)

                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; check stop criterion&lt;/span&gt;
                delta_label = np.sum(y_pred != y_pred_last).astype(np.float32) /&lt;span&gt; y_pred.shape[0]
                y_pred_last &lt;/span&gt;=&lt;span&gt; np.copy(y_pred)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ite &amp;gt; 0 &lt;span&gt;and&lt;/span&gt; delta_label &amp;lt;&lt;span&gt; tol:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;delta_label &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, delta_label, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt; tol &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, tol)
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Reached tolerance threshold. Stopping training.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                    logfile.close()
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;

            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; train on batch&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; if index == 0:&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     np.random.shuffle(index_array)&lt;/span&gt;
            idx = index_array[index * batch_size: min((index+1) *&lt;span&gt; batch_size, x.shape[0])]
            &lt;span&gt;loss &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= self.model.train_on_batch(x=x[idx], y=&lt;/span&gt;&lt;span&gt;&lt;span&gt;p[idx])&lt;/span&gt;
            index &lt;/span&gt;= index + 1 &lt;span&gt;if&lt;/span&gt; (index + 1) * batch_size &amp;lt;= x.shape[0] &lt;span&gt;else&lt;/span&gt;&lt;span&gt; 0

            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; save intermediate model&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ite % save_interval ==&lt;span&gt; 0:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;saving model to:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, save_dir + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/DEC_model_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(ite) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
                self.model.save_weights(save_dir &lt;/span&gt;+ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/DEC_model_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(ite) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

            ite &lt;/span&gt;+= 1

        &lt;span&gt;return&lt;/span&gt; y_pred
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;文章只是简单分析了一下，具体细节还是看源码来得实在。&lt;/p&gt;

&lt;p&gt;想到的一些问题如下:&lt;/p&gt;
&lt;p&gt;1.DEC的假设分布从实验效果上看起来不错，是否存在其他的比较牛逼的分布呢?&lt;/p&gt;
&lt;p&gt;2.DEC聚类不能产生新的样本，这也是VADE类似的聚类算法的优势，抽空再看看。&lt;/p&gt;
&lt;p&gt;3.DEC的使用除了聚类，还有什么呢？个人能想到的一点就是做离散化，相比于AE的那种Encoder的抽象降唯来说，DEC可以产生离散的变量，而不是多维的连续变量。后续可以在工程中尝试一下。&lt;/p&gt;

</description>
<pubDate>Sun, 21 Oct 2018 15:12:00 +0000</pubDate>
<dc:creator>文字妖精</dc:creator>
<og:description>1.算法描述 最近在做AutoEncoder的一些探索，看到2016年的一篇论文，虽然不是最新的，但是思路和方法值得学习。论文原文链接 http://proceedings.mlr.pres</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wzyj/p/9827584.html</dc:identifier>
</item>
<item>
<title>软件工程师成长之悟 - 超大的雪童子</title>
<link>http://www.cnblogs.com/yangsy0915/p/9826772.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangsy0915/p/9826772.html</guid>
<description>&lt;p&gt;　　最近或许有伙伴发现，写技术实现及细节的变少了，更多是经历以及思想、规范。莫非是道则道，非常道，你道我也道？然，并不是：）。&lt;/p&gt;
&lt;p&gt;　　当入行四五年时，个人经历中，从14年开始实习工作到15年转正，各电信项目现场跑，开发、测试、产品部署及支持运维。16年银行实时系统开发、测试、运维、部署，最后推进了MapReduce与spark引擎的变更。再到17年来阿里至今，从0到1 负责系统及未来发展的设计、开发、测试及运维 以及 开始推广运营。每一个项目都带来巨大的成长，有时候感觉这些年对自己的确挺狠的，心疼的保住不胖不瘦的自己，但是带来的成长也是巨大的，这里的成长并不只是技术或架构能力的成长。更多的是从一个小白胆怯到一个相信自己，能够把控项目、团队合作、把控风险、把控情绪的过程。这个过程很痛苦，很锻炼人，但是却能让自己更加的无惧未来。 就像我的博客中的个性签名，这个世界上，没有无缘无故的恨，也没有无缘无故的爱，更没有无缘无故的横空出世。这仍然是一个相信汗水和泪水的世界，所有的'被看到',所有的'能发光'，都不过是在灰尘扑扑的日子里，不动声色，全力以赴的结果。那么在这里，分享一些自己的想法给大家：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、改变 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;            简短的两个字，其实并不那么容易做到。我们都来自不同的家庭环境、不同的教育背景、不同的经历，会拥有着不同的价值观、不同的思想、不同的理想，为着马斯洛需求层次中的某一层而努力。　　&lt;/p&gt;
&lt;p&gt;　        在每个通宵的夜晚，你是否也有过对人生的怀疑？是否有过，对未来的迷茫？又是否有过在种种迷茫、怀疑之下的坚持？又是否在坚持之后，能够带着前一次的自信，鼓起勇气，再次去挑战新的怀疑、新的迷茫以及困惑。举一个个人经历，在第一家公司时，更多的是产品研发部署实施为主。也许是年少轻狂，毕业不久为了女友裸辞，从北京到上海，新公司全部都是大数据技术，与曾经掌握的技能并不match。每天极为痛苦，因为你不再是应届毕业生，社招上来就要干活儿，对自己充斥着大量的怀疑，直到能够与小伙伴们承担整个数仓引擎改造。然而，到达一定时期后，觉得很舒服，拥有admin权限的你，拥有设计话语权的你，或许已经成为你的瓶颈。内心告诉我，要迎接挑战，要跳出舒适区，于是选择跳槽，简历投递时，点了阿里巴巴。（新人启示，不要觉得痛苦，觉得委屈，觉得压抑而放弃，每爬出来一个坑你就会看到更清晰的未来。任何的不舒服，不要直接认为自己不适合。换个态度去想，把它变舒服了，再去考虑你是不是更适合其他的。）&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;2、先成为专家&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们纵观软件行业，以我的认知来说，web技术，前端与后端开发，如果细分后端开发又分为客户端开发与服务端开发。 大数据技术，流处理（storm、flink、spark streaming....）、批处理(hadoop、spark batch....)、存储技术(mysql、oracle、hbase、分布式文件存储hdfs....)、消息中间件(floom、kafka....)。网络技术（socket、http、bio、nio、netty...），在各种技术应用开发的同时，也牵扯到各种数据结构、各种设计思想、数据字典设计、数据建模、数据架构等等等等。这里就牵扯到定位，就是未来你想要成为什么样的人。我记得曾经刚入行时，有一位微软的大牛曾经跟我说，不要什么都学，先成为专家，再成为百家。因为成为专家的历程中，必然会接触各种思想、理念，为触类旁通打好基础。那么无论系统开发也好、大数据开发也好、大数据技术也好、区块链、人工智能等等，专精于一个领域，必能小有所成。但下来，要说的是，技术也只是知识体系中的某一项。&lt;/p&gt;

&lt;p&gt;　 &lt;strong&gt;3、谦虚与合作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        我们搞技术的有一点，会非常崇拜技术牛逼的那个人，卧槽，你这都会，卧槽，这么牛逼，抱着大腿一起成长。但大家有没有仔细观察，大神的做事方法，大神的思维模式，同时会发现，技术大神一般都非常的谦虚，任由我们随意提出建议。而初出茅庐时，我们总担心身边的人觉得自己技术能力不行，担心人家笑话你。从而越来越不敢正视自己，推卸责任或是不敢承认是自己的问题，久而久之，我们的成长便会受限。 这里想说明一个观点便是，任何人说出的任何意见或观点，都一定有一定的理由在里面。不要一开始就反驳，或者一开始就否定，先思考是否是自己欠缺的，是的话，纳入自己的思路体系，不是的话，我们再就事论事的讨论。你的成长，与他人的看法无关。久而久之，你也会拥有谦虚的态度，也会拥有大神的思维模式。承认错误，这并不是懦弱，也不在于谁对谁错，而在于朝着同一目标前进。&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;4、消除焦虑感&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　行业有句话，35岁不转管理就会被替代。其实我一直有个疑问，35岁时，我相信软件工程师们都将成为某个领域或是某个业务线的架构师，那么架构师的定义是什么？系统架构师是一个既需要掌控整体又需要洞悉局部瓶颈并依据具体的业务场景给出解决方案的团队领导型人物。一个架构师得需要足够的想像力,能把各种目标需求进行不同维度的扩展，为目标客户提供更为全面的需求清单（来自百度百科） 。我相信，一个架构师会具有管理的特质，也会具有很强的合作意识、风险意识、架构思想及处事不惊的态度。前十几年丰富的开发、设计、架构能力，能够游刃有余的把控任何风险。同时因为看透技术本质，对于新兴背景下产出的技术也会触类旁通。它就是我们眼中的大神。一个优秀的架构师，对于无论需求、设计、开发、测试、运维、项目风险、沟通合作、业务背景的理解丝毫不会亚于某一项专项的业务人员（不然做出来的是客户不要的？），架构师的价值不亚于任何管理者。&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;5、体系总结 与 开放思维&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      这两年跟着师傅取经，有一个非常有用的方法，就是将自己学到的，实践到的，领悟到的画成知识图谱，时常温故。记得早年最笨的方法，就把一整本书先硬啃下来，工作实践后，再去啃一遍，直到融会贯通。后来当体系建立，在看相关书籍时，基本一遍看下来不再那么吃力。这时候千万不要以为自己会了，依旧开始第二遍细读，第三遍总结与知识图谱。但是软件工程的特性，必须实践后才会真正的领悟，那么看了后，只是做了简单的习题方法会不会没用？ 踏实下来，当你要用到的时候，你会发现，原来没那么难。&lt;/p&gt;
&lt;p&gt;      与此同时，我们容易被技术思维禁锢，大家都觉得做技术是有瓶颈的，那么有没有仔细思考过，到底瓶颈是在哪里？个人感觉，技术角度是创造、想象 与 推动。现在对于工程师的要求越来越高了，已经不像传统IT，做好一块儿就够了，更多时候我们需要和客户打交道 和 业务打交道 和 需求 产品 ，甚至有时候自己都会上去设计产品。这个思维方式的跳跃是很痛苦的，因为越是某项技术专家，越是无法理解业务是干嘛的，毕竟人的精力是有限的，注定会是某项技术的光辉支柱。但是如果不是对某项技术痴迷，想要成为统观全局的架构师，就需要不断地扩展，对于技术而言，也许技术专家是5分，那么你能达到3分。对于业务而言，能够洞察市场的动态。但同时还在于个人的视野、想象、背景、情商、修养、与格局，从而推动事物的发展。&lt;/p&gt;



</description>
<pubDate>Sun, 21 Oct 2018 14:47:00 +0000</pubDate>
<dc:creator>超大的雪童子</dc:creator>
<og:description>最近或许有伙伴发现，写技术实现及细节的变少了，更多是经历以及思想、规范。莫非是道则道，非常道，你道我也道？然，并不是：）。 当入行四五年时，个人经历中，从14年开始实习工作到15年转正，各电信项目现场</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangsy0915/p/9826772.html</dc:identifier>
</item>
<item>
<title>使用 Python 可以做什么？ - xinet</title>
<link>http://www.cnblogs.com/q735613050/p/9827415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/q735613050/p/9827415.html</guid>
<description>&lt;p&gt;翻译自 《Python学习手册(第5版)》&lt;/p&gt;
&lt;h2 id=&quot;systems-programming&quot;&gt;Systems Programming&lt;/h2&gt;
&lt;p&gt;Python 对操作系统服务的内置接口使其非常适合编写可移植、可维护的系统管理工具和实用程序 utilities (有时称为 shell 工具)。Python 程序可以搜索文件和目录树、启动其他程序、使用进程和线程进行并行处理等等。&lt;/p&gt;
&lt;p&gt;Python 的标准库带有 POSIX 绑定和对所有常用 OS 工具的支持: 环境变量、文件、套接字、管道、进程、多线程、正则表达式模式匹配、命令行参数、标准流接口、shell 命令发射器、文件名扩展、zip 文件实用程序、XML 和 JSON 分析器、CSV 文件处理程序等。此外, Python 的大部分系统接口设计为可移植; 例如, 复制目录树的脚本通常在所有主要 Python 平台上运行不变。EVE Online 采用 Stackless Python 的实现并提供了针对多处理需求的高级解决方案。&lt;/p&gt;
&lt;h2 id=&quot;guis-用户图形接口&quot;&gt;GUIs (用户图形接口)&lt;/h2&gt;
&lt;p&gt;Python 的简洁和快速周转也使它成为桌面上图形用户界面编程的好匹配。python 附带了一个标准面向对象的接口, 该 API 称为 tkinter (tkinter 2.X), 它允许 Python 程序实现具有本地外观和感觉的便携式 gui。Python/tkinter gui 在 Windows、X Windows ( Unix 和 Linux ) 和 Mac os (经典版和 OS x) 上运行不变。一个免费的扩展包, PMW, 添加高级小部件到 tkinter 工具包。此外, 基于 c++ 库的 wxPython GUI API 提供了一种在 Python 中构建便携式 gui 的替代工具包。&lt;/p&gt;
&lt;p&gt;更高级别的工具包 (如达博) 建立在基本 api (如 wxPython 和 tkinter) 之上。使用适当的库, 您还可以在 Python 中的其他工具包中使用 GUI 支持, 例如 Qt 与 PyQt、具有 PyGTK 的 GTK、带有 PyWin32 的 MFC、. NET 和 IronPython, 以及使用 Jython (2 章中描述的 Java 版本的 Python) 或 JPype 进行摆动。对于在 web 浏览器中运行或具有简单接口要求的应用程序, Jython 和 Python web 框架和服务器端 CGI 脚本提供其他用户界面选项。&lt;/p&gt;
&lt;h2 id=&quot;internet-scripting&quot;&gt;Internet Scripting&lt;/h2&gt;
&lt;p&gt;python 附带了标准的 Internet 模块, 允许 python 程序在客户端和服务器模式下执行各种网络任务。脚本可以通过套接字进行通信;提取发送到服务器端 CGI 脚本的表单信息;通过 FTP 传输文件;分析和生成 XML 和 JSON 文档;发送、接收、撰写和分析邮件; 按 URL 获取网页;解析获取的网页的 HTML;通过 XML (RPC、SOAP 和 Telnet) 进行通信等等。Python 的库使这些任务非常简单。&lt;/p&gt;
&lt;p&gt;不仅如此, Web 上还提供了大量的第三方工具, 用于 Python 中的 Internet 编程。例如, HTMLGen 系统生成基于 Python 类的描述的 HTML 文件, &lt;em&gt;mod_python&lt;/em&gt; 包在 Apache web 服务器中高效运行 Python, 并支持服务器端模板化及其 Python 服务器页面, 以及 Jython 系统提供无缝 Python/Java 集成, 并支持在客户端上运行的服务器端小程序的编码。&lt;/p&gt;
&lt;p&gt;此外, 对于 python, 如 Django, TurboGears, web2py, Pylons, Zope 和 WebWare, 完整的 web 开发框架包支持使用 python 快速构建全功能和生产质量的网站。其中许多功能包括对象关系映射器、模型/视图/控制器体系结构、服务器端脚本和模板以及 AJAX 支持, 以提供完整的企业级 web 开发解决方案。&lt;/p&gt;
&lt;p&gt;最近, Python 已扩展到丰富的 Internet 应用程序 (RIAs), 其中包括 IronPython 中的 Silverlight 和 pyjs (也称为睡衣 ( pyjamas)) 及其 Python 到 JavaScript 编译器、AJAX 框架和小部件集。Python 还已迁移到云计算、应用引擎以及前面的数据库部分中描述的其他内容。在 Web 潜在客户的位置, Python 很快就会跟随。&lt;/p&gt;
&lt;h2 id=&quot;component-integration-组件集成&quot;&gt;Component Integration (组件集成)&lt;/h2&gt;
&lt;p&gt;Python 在 c 和 c++ 系统中扩展和嵌入的能力使其成为一种灵活的胶水语言, 用于编写其他系统和组件的行为脚本。例如, 将 C 库集成到 python 使 python 能够测试和启动库的组件, 并在产品中嵌入 Python, 无需重新编译整个产品 (或根本不发运其源代码) 即可对现场自定义进行编码。&lt;/p&gt;
&lt;p&gt;诸如 SWIG 和 SIP 代码生成器之类的工具可以自动完成将编译的组件链接到 python 以便在脚本中使用所需的大部分工作, 而 Cython 系统允许程序员混合 python 和类似 C 的代码。更大的框架, 如 Python 在 Windows 上的 COM 支持、基于 Jython Java 的实现和 IronPython。基于 .NET 的实现提供了脚本组件的其他方法。例如, 在 Windows 上, Python 脚本可以使用框架来编写 Word 和 Excel 的脚本、访问 Silverlight 等。&lt;/p&gt;
&lt;h2 id=&quot;database-programming&quot;&gt;Database Programming&lt;/h2&gt;
&lt;p&gt;对于传统的数据库需求, 对于所有常用的关系数据库系统 (Sybase、Oracle、Informix、ODBC、MySQL、PostgreSQL、SQLite 等) 都有 Python 接口。python 世界还定义了一个可移植数据库 API, 用于从 Python 脚本访问 SQL 数据库系统, 在各种基础数据库系统上看起来相同。例如, 由于供应商接口实现了便携式 API, 编写用于与免费 MySQL 系统一起工作的脚本在其他系统 (如 Oracle) 上的工作基本不变;您通常需要做的就是更换基础供应商界面。自2.5 以来, 进程内 SQLite 嵌入式 SQL 数据库引擎是 Python 本身的标准部分, 支持原型设计和基本程序存储需求。&lt;/p&gt;
&lt;p&gt;在非 SQL 部分中, Python 的标准 &lt;code&gt;pickle&lt;/code&gt; 模块提供了一个简单的对象持久化系统-它允许程序轻松地将整个 Python 对象保存和还原到文件和类似文件的对象。在 Web 上, 您还可以找到名为 ZODB 和 Durus 的第三方开源系统, 为 Python 脚本提供完整的面向对象的数据库系统;其他, 如 SQLObject 和 SQLAlchemy, 实现对象关系映射器 (ORMs), 将 Python 的类模型移植到关系表上;PyMongo 是 MongoDB 的一个接口, 它是一种高性能、非 SQL、开放源码的 JSON 样式文档数据库, 它将数据存储在结构非常类似于 python 自己的列表和字典中, 其文本可以使用 python 自己的标准库 json 模块进行分析和创建。&lt;/p&gt;
&lt;p&gt;此外, 其他系统还提供了更专业的方法来存储数据, 包括在 Google App 引擎中使用数据存储, 通过 Python 类来建模和提供广泛的可扩展性, 以及其他新兴云存储选项, 如 Azure、PiCloud、OpenStack 和 Stackato。&lt;/p&gt;
&lt;h2 id=&quot;rapid-prototyping-快速原型&quot;&gt;Rapid Prototyping (快速原型)&lt;/h2&gt;
&lt;p&gt;对于 python 程序, 用 python 和 C 编写的组件看起来是一样的。因此, 最初可以在 Python 中原型系统, 然后将所选组件移动到编译语言 (如 c 或 c++) 以进行传递。与某些原型工具不同, Python 在原型凝固后不需要完全重写。不需要 C + + 等语言效率的系统部分可以保持在 Python 中编码, 便于维护和使用。&lt;/p&gt;
&lt;h2 id=&quot;numeric-and-scientific-programming&quot;&gt;Numeric and Scientific Programming&lt;/h2&gt;
&lt;p&gt;python 在数字编程中也被大量使用, 这是一种传统上不被认为是脚本语言范围的领域, 但已经发展成为 python 最引人注目的用例之一。这里突出的是, 前面提到的 Python 的 NumPy 高性能数字编程扩展包括诸如数组对象的高级工具、标准数学库的接口等等。通过将 python 与以编译语言编码的数字例程集成为速度, NumPy 将 python 转换为复杂而易于使用的数字编程工具, 通常可以替换传统编译语言 (如 FORTRAN 或 C++) 编写的现有代码。&lt;/p&gt;
&lt;p&gt;Python 支持动画、3D 可视化、并行处理等其他数字工具。例如, 流行的 SciPy 和 ScientificPython 扩展提供了更多的科学编程工具库, 并将 NumPy 作为核心组件使用。Python 的 PyPy 实现也在数字领域中得到了牵引, 部分原因是此域中常见的排序的大量算法代码可以在 PyPy 中快速运行, 通常速度快10X 到 100X。&lt;/p&gt;
&lt;h2 id=&quot;gaming-images-data-mining-robots-excel-等&quot;&gt;Gaming, Images, Data Mining, Robots, Excel 等&lt;/h2&gt;
&lt;p&gt;Python 通常应用在更多的域中, 而不是可以在这里覆盖。例如, 您将找到允许您使用 Python 执行以下操作的工具:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;游戏编程和多媒体：pygame, cgkit, pyglet, PySoy, Panda3D, ...&lt;/li&gt;
&lt;li&gt;通过 PySerial 扩展, 在 Windows、Linux 和更多端口上进行串口通信&lt;/li&gt;
&lt;li&gt;使用 PyRo 工具包进行机器人控制编程&lt;/li&gt;
&lt;li&gt;使用 NLTK 包进行自然语言分析&lt;/li&gt;
&lt;li&gt;树莓派 (Raspberry Pi) 和 Arduino 板上的仪器仪表工具&lt;/li&gt;
&lt;li&gt;移动 (Mobile) 计算: Python 端口到谷歌 Android 和苹果 iOS 平台&lt;/li&gt;
&lt;li&gt;Excel 电子表格功能和宏编程: PyXLL 或 DataNitro 加载项&lt;/li&gt;
&lt;li&gt;媒体文件内容和元数据标签处理 (Media file content and metadata tag processing): PyMedia, ID3, PIL/Pillow 等&lt;/li&gt;
&lt;li&gt;人工智能: PyBrain 神经网络库和 Milk 机器学习工具包&lt;/li&gt;
&lt;li&gt;专家系统: PyCLIPS, Pyke, Pyrolog, pyDatalog&lt;/li&gt;
&lt;li&gt;网络监视 (Network monitoring): zenoss, 使用 Python 进行编写和自定义&lt;/li&gt;
&lt;li&gt;Python 脚本设计和建模: PythonCAD、PythonOCC、FreeCAD 和其他&lt;/li&gt;
&lt;li&gt;文件处理和生成 (Document processing and generation): ReportLab, Sphinx, Cheetah, PyPDF 等等&lt;/li&gt;
&lt;li&gt;使用 Mayavi、matplotlib、VTK、VPython 等进行数据可视化&lt;/li&gt;
&lt;li&gt;xml 分析: xml 库包、xmlrpclib 模块和第三方扩展&lt;/li&gt;
&lt;li&gt;JSON, CSV 文件处理: &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;csv&lt;/code&gt; modules&lt;/li&gt;
&lt;li&gt;数据挖掘: 使用 Orange 框架、Pattern bundle、Scrapy 和自定义代码&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;h3 id=&quot;scikit-learn重点推荐&quot;&gt;Scikit-learn（重点推荐）&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/scikit-learn/scikit-learn&quot;&gt;Scikit-learn&lt;/a&gt; 是基于 Scipy 为机器学习建造的的一个 Python 模块，他的特色就是多样化的分类，回归和聚类的算法包括支持向量机，逻辑回归，朴素贝叶斯分类器，随机森林，Gradient Boosting，聚类算法和 DBSCAN。而且也设计出了 Python numerical 和 scientific libraries Numpy and Scipy&lt;/p&gt;
&lt;h3 id=&quot;keras深度学习&quot;&gt;Keras（深度学习）&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/fchollet/keras&quot;&gt;Keras&lt;/a&gt; 是基于 Theano, Tensorflow, CNTK 的一个深度学习框架，它的设计参考了 Torch，用 Python 语言编写，是一个高度模块化的神经网络库，支持 GPU 和 CPU。&lt;/p&gt;
&lt;h3 id=&quot;lasagne深度学习&quot;&gt;Lasagne（深度学习）&lt;/h3&gt;
&lt;p&gt;不只是一个美味的意大利菜，也是一个和 Keras 有着相似功能的深度学习库，但其在设计上与它们有些不同。&lt;/p&gt;
&lt;h3 id=&quot;pylearn2&quot;&gt;Pylearn2&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/lisa-lab/pylearn2&quot;&gt;Pylearn&lt;/a&gt; 是一个让机器学习研究简单化的基于 Theano 的库程序。它把深度学习和人工智能研究许多常用的模型以及训练算法封装成一个单一的实验包，如随机梯度下降。&lt;/p&gt;
&lt;h3 id=&quot;nupic&quot;&gt;NuPIC&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/numenta/nupic&quot;&gt;NuPIC&lt;/a&gt; 是一个以 HTM 学习算法为工具的机器智能平台。HTM 是皮层的精确计算方法。HTM 的核心是基于时间的持续学习算法和储存和撤销的时空模式。NuPIC 适合于各种各样的问题,尤其是检测异常和预测的流数据来源。&lt;/p&gt;
&lt;h3 id=&quot;nilearn&quot;&gt;Nilearn&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/nilearn/nilearn&quot;&gt;Nilearn&lt;/a&gt; 是一个能够快速统计学习神经影像数据的 Python 模块。它利用 Python 语言中的 scikit-learn 工具箱和一些进行预测建模，分类，解码，连通性分析的应用程序来进行多元的统计。&lt;/p&gt;
&lt;h3 id=&quot;pybrain&quot;&gt;PyBrain&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/pybrain/pybrain&quot;&gt;Pybrain&lt;/a&gt; 是基于 Python 语言强化学习，人工智能，神经网络库的简称。 它的目标是提供灵活、容易使用并且强大的机器学习算法和进行各种各样的预定义的环境中测试来比较你的算法。&lt;/p&gt;
&lt;h3 id=&quot;pattern&quot;&gt;Pattern&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/clips/pattern&quot;&gt;Pattern&lt;/a&gt; 是 Python 语言下的一个网络挖掘模块。它为数据挖掘，自然语言处理，网络分析和机器学习提供工具。它支持向量空间模型、聚类、支持向量机和感知机并且用KNN分类法进行分类。&lt;/p&gt;
&lt;h3 id=&quot;fuel&quot;&gt;Fuel&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/mila-udem/fuel&quot;&gt;Fuel&lt;/a&gt; 为你的机器学习模型提供数据。他有一个共享如MNIST, CIFAR-10 (图片数据集), Google's One Billion Words (文字)这类数据集的接口。你使用他来通过很多种的方式来替代自己的数据。&lt;/p&gt;
&lt;h3 id=&quot;bob&quot;&gt;Bob&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/idiap/bob&quot;&gt;Bob&lt;/a&gt; 是一个免费的信号处理和机器学习的工具。它的工具箱是用 Python 和 C++ 语言共同编写的，它的设计目的是变得更加高效并且减少开发时间，它是由处理图像工具,音频和视频处理、机器学习和模式识别的大量软件包构成的。&lt;/p&gt;
&lt;h3 id=&quot;skdata&quot;&gt;Skdata&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/jaberg/skdata&quot;&gt;Skdata&lt;/a&gt; 是机器学习和统计的数据集的库程序。这个模块对于玩具问题，流行的计算机视觉和自然语言的数据集提供标准的Python语言的使用。&lt;/p&gt;
&lt;h3 id=&quot;milk&quot;&gt;MILK&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/luispedro/milk&quot;&gt;MILK&lt;/a&gt; 是Python语言下的机器学习工具包。它主要是在很多可得到的分类比如SVMS,K-NN,随机森林，决策树中使用监督分类法。 它还执行特征选择。 这些分类器在许多方面相结合,可以形成不同的例如无监督学习、密切关系金传播和由MILK支持的K-means聚类等分类系统。&lt;/p&gt;
&lt;h3 id=&quot;iepy&quot;&gt;IEPY&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/machinalis/iepy&quot;&gt;IEPY&lt;/a&gt; 是一个专注于关系抽取的开源性信息抽取工具。它主要针对的是需要对大型数据集进行信息提取的用户和想要尝试新的算法的科学家。&lt;/p&gt;
&lt;h3 id=&quot;quepy&quot;&gt;Quepy&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/machinalis/quepy&quot;&gt;Quepy&lt;/a&gt; 是通过改变自然语言问题从而在数据库查询语言中进行查询的一个 Python 框架。他可以简单的被定义为在自然语言和数据库查询中不同类型的问题。所以，你不用编码就可以建立你自己的一个用自然语言进入你的数据库的系统。&lt;br/&gt;现在 Quepy 提供对于 Sparql 和 MQL 查询语言的支持。并且计划将它延伸到其他的数据库查询语言。&lt;/p&gt;
&lt;h3 id=&quot;hebel&quot;&gt;Hebel&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/hannes-brt/hebel&quot;&gt;Hebel&lt;/a&gt; 是在 Python 语言中对于神经网络的深度学习的一个库程序，它使用的是通过 PyCUDA 来进行 GPU 和 CUDA 的加速。它是最重要的神经网络模型的类型的工具而且能提供一些不同的活动函数的激活功能，例如动力，涅斯捷罗夫动力，信号丢失和停止法。&lt;/p&gt;
&lt;h3 id=&quot;mlxtend&quot;&gt;mlxtend&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/rasbt/mlxtend&quot;&gt;mlxtend&lt;/a&gt; 它是一个由有用的工具和日常数据科学任务的扩展组成的一个库程序。&lt;/p&gt;
&lt;h3 id=&quot;nolearn&quot;&gt;nolearn&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/dnouri/nolearn&quot;&gt;nolearn&lt;/a&gt; 容纳了大量能对你完成机器学习任务有帮助的实用程序模块。其中大量的模块和 scikit-learn 一起工作，其它的通常更有用。&lt;/p&gt;
&lt;h3 id=&quot;ramp&quot;&gt;Ramp&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/kvh/ramp&quot;&gt;Ramp&lt;/a&gt; 是一个在 Python 语言下制定机器学习中加快原型设计的解决方案的库程序。他是一个轻型的 pandas-based 机器学习中可插入的框架，它现存的Python语言下的机器学习和统计工具（比如scikit-learn,rpy2 等）Ramp 提供了一个简单的声明性语法探索功能从而能够快速有效地实施算法和转换。&lt;/p&gt;
&lt;h3 id=&quot;feature-forge&quot;&gt;Feature Forge&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/machinalis/featureforge&quot;&gt;Feature Forge&lt;/a&gt;一系列工具通过与 scikit-learn 兼容的 API，来创建和测试机器学习功能。&lt;/p&gt;
&lt;p&gt;这个库程序提供了一组工具，它会让你在许多机器学习程序使用中很受用。当你使用 scikit-learn 这个工具时，你会感觉到受到了很大的帮助。（虽然这只能在你有不同的算法时起作用。）&lt;/p&gt;
&lt;h3 id=&quot;rep&quot;&gt;REP&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/yandex/rep&quot;&gt;REP&lt;/a&gt; 是以一种和谐、可再生的方式为指挥数据移动驱动所提供的一种环境。&lt;/p&gt;
&lt;p&gt;它有一个统一的分类器包装来提供各种各样的操作，例如 TMVA, Sklearn, XGBoost, uBoost等等。并且它可以在一个群体以平行的方式训练分类器。同时它也提供了一个交互式的情节。&lt;/p&gt;
&lt;h3 id=&quot;python-学习机器样品&quot;&gt;Python 学习机器样品&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/awslabs/machine-learning-samples&quot;&gt;machine-learning-sample&lt;/a&gt; 用亚马逊的机器学习建造的简单软件收集。&lt;/p&gt;
&lt;h3 id=&quot;python-elm&quot;&gt;Python-ELM&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/q735613050/p/www.github.com/dclambert/Python-ELM&quot;&gt;Python-ELM&lt;/a&gt; 这是一个在 Python 语言下基于 scikit-learn 的极端学习机器的实现。&lt;/p&gt;
&lt;h3 id=&quot;gensim&quot;&gt;gensim&lt;/h3&gt;
&lt;p&gt;主题模型 python实现&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Scalable statistical semantics&lt;/li&gt;
&lt;li&gt;Analyze plain-text documents for semantic structure&lt;/li&gt;
&lt;li&gt;Retrieve semantically similar document&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 21 Oct 2018 14:33:00 +0000</pubDate>
<dc:creator>xinet</dc:creator>
<og:description>翻译自 《Python学习手册(第5版)》 Systems Programming Python 对操作系统服务的内置接口使其非常适合编写可移植、可维护的系统管理工具和实用程序 utilities (</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/q735613050/p/9827415.html</dc:identifier>
</item>
<item>
<title>viewport其实没那么难理解 - 辛月</title>
<link>http://www.cnblogs.com/chenwenhao/p/9827343.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenwenhao/p/9827343.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　在学习移动端布局的时候，你肯定听说过&lt;strong&gt;&quot;viewport&quot;&lt;/strong&gt;这个词，然后去问度娘或谷歌。你会惊奇的发现，这个&lt;strong&gt;viewport&lt;/strong&gt;不简单，居然有那么多兄弟——&lt;strong&gt;layout viewport、visual viewport、ideal viewport&lt;/strong&gt;。这些都是什么鬼，然后就硬着头皮去发现他们的不同，找了很多资料，很想搞懂他们，最后可能是越看越懵逼，或者就豁然开朗的懂了（我是觉得自己豁然开朗的懂了，所以才写博客记录一下感想，不对之处欢迎来喷...）。虽然自己也知道，移动端开发入门没那么难，一句代码搞定—— &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;strong&gt;&amp;lt;meta id=&quot;viewport&quot; name=&quot;viewport&quot; content=&quot;width=device-width; initial-scale=1.0; maximum-scale=1; user-scalable=no;&quot;&lt;/strong&gt;&amp;gt;&lt;/span&gt; 。可是不理解&lt;strong&gt;viewport&lt;/strong&gt;心里就是不爽，下面我就简单归纳一下自己的总结。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、各种浏览器默认viewport大小&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的&lt;strong&gt;viewport&lt;/strong&gt;设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的&lt;strong&gt;viewport&lt;/strong&gt;的宽度要小的。下图列出了一些设备上浏览器的默认viewport的宽度。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1062623/201810/1062623-20181021195339984-1458860663.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 2、css的1px不等于设备物理像素的1px&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;在早先的移动设备中，屏幕像素密度都比较低，如iphone3，它的分辨率为320x480，在iphone3上，一个css像素确实是等于一个屏幕物理像素的。后来随着技术的发展，移动设备的屏幕像素密度越来越高，从iphone4开始，苹果公司便推出了所谓的Retina屏，分辨率提高了一倍，变成640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，一个css像素是等于两个物理像素的。其他品牌的移动设备也是这个道理。例如安卓设备根据屏幕像素密度可分为ldpi、mdpi、hdpi、xhdpi等不同的等级，分辨率也是五花八门，安卓设备上的一个css像素相当于多少个屏幕物理像素，也因设备的不同而不同，没有一个定论。例如，在Retina屏的iphone上，devicePixelRatio的值为2，也就是说1个css像素相当于2个物理像素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　还有一个因素也会引起css中px的变化，那就是用户缩放。例如，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3、viewport三兄弟——&lt;strong&gt;layout viewport、visual viewport、ideal viewport&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;strong&gt;layout viewport由来：&lt;/strong&gt;&lt;/strong&gt;如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为viewport太窄而显示错乱（相当于resize浏览器的窗口变小了，之后div这样的block标签默认宽度auto变小了，页面就会乱），所以这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。浏览器默认的&lt;strong&gt;viewport&lt;/strong&gt;叫做 &lt;strong&gt;layout viewport&lt;/strong&gt;。这个&lt;strong&gt;layout viewport&lt;/strong&gt;的宽度可以通过 &lt;strong&gt;document.documentElement.clientWidth&lt;/strong&gt; 来获取。&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;strong&gt;　visual viewport由来&lt;/strong&gt;：&lt;strong&gt;layout viewport&lt;/strong&gt;的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表浏览器可视区域的大小，这个&lt;strong&gt;viewport&lt;/strong&gt;叫做 &lt;strong&gt;visual viewport。visual viewport&lt;/strong&gt;&lt;span&gt;的宽度可以通过&lt;strong&gt;window.innerWidth &lt;/strong&gt;来获取。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1062623/201810/1062623-20181021202736661-1047423497.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1062623/201810/1062623-20181021202746625-1595547175.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;其实上面俩张图还是很有误导性的。看下面这张图，没设置&amp;lt;meta&amp;gt;的情况下，同时，div宽度为auto时：（人家是刚刚好塞满的，俩种&lt;strong&gt;viewport&lt;/strong&gt;比例1:1）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1062623/201810/1062623-20181021212850797-1883068301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　ideal viewport由来&lt;/strong&gt;：现在我们已经有两个&lt;strong&gt;viewport&lt;/strong&gt;了：&lt;strong&gt;layout viewport&lt;/strong&gt; 和 &lt;strong&gt;visual viewport&lt;/strong&gt;。但浏览器觉得还不够，因为现在越来越多的网站都会为移动设备进行单独的设计，所以必须还要有一个能完美适配移动设备的&lt;strong&gt;viewport&lt;/strong&gt;。所谓的完美适配指的是，首先不需要用户缩&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 21 Oct 2018 14:21:00 +0000</pubDate>
<dc:creator>辛月</dc:creator>
<og:description>在学习移动端布局的时候，你肯定听说过&quot;viewport&quot;这个词，然后去问度娘或谷歌。你会惊奇的发现，这个viewport不简单，居然有那么多兄弟——layout viewport、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenwenhao/p/9827343.html</dc:identifier>
</item>
<item>
<title>设计模式之6大设计原则 - qingshanli</title>
<link>http://www.cnblogs.com/qingshanli/p/9808373.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qingshanli/p/9808373.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;&lt;span&gt;单一职责原则&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;单一职责原则(Single Responsibility Principle, SRP)的定义是: 应该有且仅有一个原因引起类或接口的变更。即一个类或接口只负责一个功能领域中的相应职责。&lt;/p&gt;
&lt;p&gt;单一职责原则提出了一个编写程序的标准, 它使类的复杂性降低、提高了代码的可读性、可维护性和可扩展性、并降低了类或接口变更而引起的风险。但在实际项目中, 我们通常对&quot;职责&quot;没有一个量化的标准, 比如一个类到底要负责哪些职责?这些职责应该怎么细化?这种不可度量的外部因素给单一职责原则的实践带来了一定的困难性。&lt;/p&gt;
&lt;p&gt;所以, 单一职责原则固然是一种非常好的理念, 但如果只会生搬硬套, 却又会引起类的剧增, 给维护带来很多不必要的麻烦, 而且过分细分类的职责(比如将一个类拆分成多个类, 类之间组合或聚合在一起)也会人为增加系统的复杂性。 &lt;/p&gt;
&lt;p&gt;综上所述, 单一职责原则由于&quot;职责&quot;的不可度量性, 需要设计人员具有较强的分析设计能力和相关实践能力。在实际运用中, 给出的建议是: 接口一定要做到单一职责, 类的设计尽量做到只有一个原因引起变更。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;里氏替换原则&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;里氏替换原则(Liskov Substitution Principle, LSP)最早是在1988年, 由麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的, 它有两种定义: &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一种定义: 如果对每一个类型为 T1的对象 o1，都有类型为 T2 的对象o2，使得以 T1定义的所有程序 P 在所有的对象 o1 都代换成 o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。&lt;/li&gt;
&lt;li&gt;第二种定义: 所有引用基类的地方必须能透明地使用其子类的对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第二种定义是最清晰明确的, 即在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误或异常，反过来则不成立，如果软件中使用的是一个子类对象的话，那么它不一定能够替换成它的基类对象。&lt;/p&gt;
&lt;p&gt;里氏替换原则为良好的继承定义了一个规范: &lt;strong&gt;子类可以扩展父类的功能, 但不能改变父类原有的功能。&lt;/strong&gt;具体可概括成以下4点: &lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;子类可以实现父类的抽象方法, 但不能覆写父类的非抽象方法&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Parent {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sum(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b;
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Son &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Parent {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; sum(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;doSomething, 不一定是求和, 即父类原有的功能已经改变&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; a -&lt;span&gt; b;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; study() {
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码所示, 父类中的 &lt;span class=&quot;cnblogs_code&quot;&gt;sum()&lt;/span&gt; 方法对两个参数进行求和, 子类覆写了父类的方法并且改变了父类的原有的功能, 子类中的 &lt;span class=&quot;cnblogs_code&quot;&gt;sum()&lt;/span&gt; 方法不再是简单的进行求和运算。此时我们在父类Parent出现的地方替换为子类Son, 用代码描述就是将 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;new&lt;/span&gt; Parent().sum()&lt;/span&gt; 替换为 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;new&lt;/span&gt; Son().sum()&lt;/span&gt; , 原有的求和运算也被替换成了减法或乘法运算, 很明显这是两个不同的业务, 这也就违背了前文中的&lt;strong&gt;&quot;所有引用基类的地方必须能透明地使用其子类的对象&quot;&lt;/strong&gt;这一定义。通常在实际业务中, 如果不得不覆写父类的方法, 可以有一个通用的做法: 令父类和子类都继承一个更通用的基类, 采用依赖、聚合、组合等关系代替原有的继承关系。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;子类中可以增加自己特有的方法&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;此时子类Son扩展了一个在父类中并不存在的 &lt;span class=&quot;cnblogs_code&quot;&gt;study()&lt;/span&gt; 方法, 如果我们在实际业务中将子类出现的地方 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;new&lt;/span&gt; Son().study()&lt;/span&gt; 替换成父类对象 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;new&lt;/span&gt; Parent().study()&lt;/span&gt; 就会产生 &lt;span class=&quot;cnblogs_code&quot;&gt;java.lang.NoSuchMethodException&lt;/span&gt; 异常, 这又进一步验证了前文中的&lt;strong&gt;&quot;如果软件中使用的是一个子类对象的话，那么它不一定能够替换成它的基类对象&quot;&lt;/strong&gt;这一反面论证。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;当子类方法重载父类方法时, 子类方法的前置条件（即方法的形参）要比父类方法的前置条件更宽松&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Parent {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; play(Map&amp;lt;String, String&amp;gt;&lt;span&gt; map) {
        System.out.println(&lt;/span&gt;&quot;父类方法被执行...&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Son &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Parent {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; play(HashMap&amp;lt;String, String&amp;gt;&lt;span&gt; map) {
        System.out.println(&lt;/span&gt;&quot;子类方法被执行...&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        HashMap&lt;/span&gt;&amp;lt;String, String&amp;gt; paramMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, String&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Parent().play(paramMap);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;父类方法被执行...&lt;/span&gt;
        &lt;span&gt;new&lt;/span&gt; Son().play(paramMap);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;子类方法被执行...&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上, 子类重载父类的方法, 且子类方法的前置条件比父类方法的前置条件更严格, 将父类对象替换成子类对象后, 父类原有的方法不再被执行, 业务发生了改变, 这就违背了&lt;strong&gt;里氏替换原则&lt;/strong&gt;的定义。但如果反过来, 子类方法的前置条件相对于父类更宽松, 将父类对象替换成子类对象后,  &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;new&lt;/span&gt; Son().play(paramMap)&lt;/span&gt; 调用的仍然是父类方法, 这就符合了&lt;strong&gt;&quot;所有引用基类的地方必须能透明地使用其子类的对象&quot;&lt;/strong&gt;这一定义。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;当子类方法实现父类抽象方法时，子类方法的后置条件(即方法的返回值)要比父类方法的后置条件更严格&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Parent {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getHobbys() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Son &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Parent {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt; getHobbys() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        List&lt;/span&gt;&amp;lt;String&amp;gt; hobbys = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Parent().getHobbys();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;List&amp;lt;String&amp;gt; hobbys = new Son().getHobbys();&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个很容易理解, 根据里氏替换原则的定义, 如果子类方法的后置条件比父类更宽松, 将父类对象替换成子类对象后, 就会发生编译异常, 因为子类引用指向了父类对象 &lt;span class=&quot;cnblogs_code&quot;&gt;ArrayList&amp;lt;String&amp;gt; hobbys = List&amp;lt;String&amp;gt;类引用指向的实例对象&lt;/span&gt; , 显然连基本的语法都不通过。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;综上所述, 我们在程序中应尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换基类对象, 另外在使用继承时遵循里氏替换原则来提高代码的健壮性。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;依赖倒置原则&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;依赖倒置原则(Dependency Inversion  Principle, DIP)的定义: 高层模块不应该依赖低层模块, 两者都应该依赖其抽象; 抽象不应该依赖细节; 细节应该依赖抽象。&lt;/p&gt;
&lt;p&gt;依赖倒置原则的核心思想就是&quot;&lt;strong&gt;面向接口编程&lt;/strong&gt;&quot;, 它是实现开闭原则的一种必要手段。下面通过一段简单的代码示例来说明&lt;strong&gt;面向接口编程&lt;/strong&gt;的好处。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Driver {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;司机的主要职责就是驾驶汽车&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; drive(Benz benz){
        benz.run();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BMW {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;宝马车当然也可以开动了&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        System.out.println(&lt;/span&gt;&quot;宝马汽车开始运行...&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Benz {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;汽车肯定会跑&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        System.out.println(&lt;/span&gt;&quot;奔驰汽车开始运行...&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Driver zhangSan &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Driver();
        Benz benz &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Benz();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;张三开奔驰车&lt;/span&gt;
&lt;span&gt;        zhangSan.drive(benz);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的高层模块业务类Client中, 司机类和奔驰类紧密耦合在一起, 司机只能开奔驰车, 如果后期业务发生变更, 需要司机开宝马车或法拉利, 就需要对司机类进行修改, 其结果就是大大降低了系统的可维护性、可扩展性和稳定性, 这显然也不符合&quot;&lt;strong&gt;面向对象设计&lt;/strong&gt;&quot;中的&lt;strong&gt;开闭原则&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而且在实际项目中, 经常是多个开发人员协作开发, 可能是A开发人员负责司机类模块, B开发人员负责汽车类模块, 因为司机类依赖汽车类, 所以A开发人员需要等待B开发人员完成汽车类的编写后才能开展自己的工作, 这就大大的拖延了项目的进度, 即&quot;增加了并行开发引起的风险&quot;。&lt;/p&gt;
&lt;p&gt;做过“Web Service&quot;开发的应该知道一个”契约优先“的原则, 就是先定义好&quot;WSDL&quot;接口, 制定好双方的开发协议, 然后再各自实现。依赖倒置原则也给出了一个相似的规约, 即大家都面向接口编程, 不用去关心接口下具体的实现细节。&lt;/p&gt;
&lt;p&gt;在上述代码示例中, 我们引入依赖倒置原则来对其进行重构, 重构后的UML类图如下: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278884/201810/1278884-20181021122154612-766594397.png&quot; alt=&quot;&quot; width=&quot;780&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时司机类不再直接依赖汽车类, 它们都依赖其各自实现的抽象接口, 而司机抽象接口又依赖汽车抽象接口。在高层业务模块中, 不用再关心低层的实现类细节, 基于接口编程, 司机的driver()方法形参类型设定为接口或抽象类, 后期如果有业务变动需要司机开宝马或法拉利, 只需要新增一个宝马类并在高层业务模块稍作修改即可, 而其他底层模块诸如Driver类则不需要做任何变动。另外在大型项目多人协作开发中, 大家也可以以此来约定好抽象类或接口, 然后各自根据定义好的接口进行具体实现, 就可以大大降低并行开发引起的风险。&lt;/p&gt;
&lt;p&gt;在前文中提到, 依赖倒置原则的核心思想就是面向接口编程, 即将具体类的对象通过&lt;strong&gt;依赖注入&lt;/strong&gt;的方式注入到其他对象中。&lt;strong&gt;依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象&lt;/strong&gt;。常用的注入方式有三种，分别是：&lt;strong&gt;构造注入，Setter方法注入和接口注入&lt;/strong&gt;。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。&lt;/p&gt;
&lt;p&gt;综上所述, 采用依赖倒置原则可以减少类间的耦合性, 提高系统的稳定性, 降低并行开发引起的风险, 提高代码的可读性和可维护性。&lt;/p&gt;
&lt;p&gt;在实践中, 依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即&lt;strong&gt;使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等&lt;/strong&gt;，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;接口隔离原则&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;接口隔离原则(Interface  Segregation Principle, ISP)的定义: 客户端不应该依赖它不需要的接口, 类间的依赖关系应该建立在最小的接口上。&lt;/p&gt;
&lt;p&gt;下面是引用&lt;a href=&quot;https://blog.csdn.net/lovelion/article/details/7562842&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/lovelion/article/details/7562842&lt;/a&gt;文章中的一段描述： &lt;/p&gt;
&lt;p&gt;根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。&lt;strong&gt;每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。&lt;/strong&gt;这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“&lt;strong&gt;角色隔离原则&lt;/strong&gt;”。&lt;/li&gt;
&lt;li&gt;如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指&lt;strong&gt;接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口&lt;/strong&gt;。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“&lt;strong&gt;定制服务&lt;/strong&gt;”，即为不同的客户端提供宽窄不同的接口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面通过一个简单的示例来说明接口隔离原则: &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278884/201810/1278884-20181021163735431-1566940436.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图这个设计未遵循接口隔离原则, 类A依赖接口I中的方法1、方法2、方法3，类B是对类A依赖的实现。类C依赖接口I中的方法1、方法4、方法5，类D是对类C依赖的实现。对于类B和类D来说，虽然他们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口I，所以也必须要实现这些用不到的方法。下面根据接口隔离原则, 对接口I进行拆分, 拆分后的类图如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278884/201810/1278884-20181021164307432-1961353540.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将接口I拆分成三个接口后, 类A和类C只能看到它所需要的方法, 同时拆分后的接口只专注为一个模块提供定制服务, 实现类也不用再实现和他职责无关的方法。&lt;/p&gt;
&lt;p&gt;综上所述, &lt;strong&gt;在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。&lt;/strong&gt;一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;迪米特法则&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;原文链接:&lt;a href=&quot;https://blog.csdn.net/lovelion/article/details/7563445&quot; target=&quot;_blank&quot;&gt; https://blog.csdn.net/lovelion/article/details/7563445&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;迪米特法则(Law of  Demeter, LoD)也称为最少知识原则, 通俗点来讲, 就是一个软件实体应当尽可能少地与其他实体发生相互作用&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。&lt;strong&gt;迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;迪米特法则还有几种定义形式，包括&lt;strong&gt;：&lt;/strong&gt;&lt;strong&gt;不要和“陌生人”说话&lt;/strong&gt;、&lt;strong&gt;只与你的直接朋友通信&lt;/strong&gt;等，在迪米特法则中，对于一个对象，其朋友包括以下几类：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当前对象本身(this)；&lt;/li&gt;
&lt;li&gt;以参数形式传入到当前对象方法中的对象；&lt;/li&gt;
&lt;li&gt;当前对象的成员对象；&lt;/li&gt;
&lt;li&gt;如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；&lt;/li&gt;
&lt;li&gt;当前对象所创建的对象。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。&lt;/p&gt;
&lt;p&gt;迪米特法则要求我们在设计系统时，&lt;strong&gt;应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用&lt;/strong&gt;。简言之，就是&lt;strong&gt;通过引入一个合理的第三者来降低现有对象之间的耦合度&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在将迪米特法则运用到系统设计中时，要注意下面的几点：&lt;strong&gt;在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及&lt;/strong&gt;；&lt;strong&gt;在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限&lt;/strong&gt;；&lt;strong&gt;在类的设计上，只要有可能，一个类型应当设计成不变类&lt;/strong&gt;；&lt;strong&gt;在对其他类的引用上，一个对象对其他对象的引用应当降到最低&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面通过一个简单实例来加深对迪米特法则的理解: &lt;/p&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;Sunny软件公司所开发CRM系统包含很多业务操作窗口，在这些窗口中，某些界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应，例如，当一个按钮(Button)被单击时，对应的列表框(List)、组合框(ComboBox)、文本框(TextBox)、文本标签(Label)等都将发生改变，在初始设计方案中，界面控件之间的交互关系可简化为如图1所示结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278884/201810/1278884-20181021175049363-224114405.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                                                                    图1 初始设计方案结构图&lt;/p&gt;
&lt;p&gt;在图1中，由于界面控件之间的交互关系复杂，导致在该窗口中增加新的界面控件时需要修改与之交互的其他控件的源代码，系统扩展性较差，也不便于增加和删除新控件。&lt;/p&gt;
&lt;p&gt;现使用迪米特对其进行重构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在本实例中，可以通过引入一个专门用于控制界面控件交互的中间类(Mediator)来降低界面控件之间的耦合度。引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码，重构后结构如图2所示： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278884/201810/1278884-20181021174441053-1473951325.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;开闭原则&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;开闭原则的定义(Open-Closed Principle, OCP): 一个软件实体如类、模块和函数应该对扩展开放, 对修改关闭。通俗点讲, 就是一个软件实体应该通过扩展来实现变化, 而不是通过修改已有的代码来实现变化。&lt;/p&gt;
&lt;p&gt;在一个软件的生命周期内, 业务需求发生变化是一个常态, 这就要求我们在系统设计时要主动拥抱变化, 而开闭原则就是为软件实体的未来变更而制定的对现行开发设计进行约束的一个规则。&lt;/p&gt;
&lt;p&gt;在前文中, 我们已介绍过其他5个原则,它们是指导设计的工具和方法, 而开闭原则是目标。单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。&lt;/p&gt;
&lt;p&gt;那么我们在实践中怎么运用这6大设计原则呢?这里有一篇文章对此阐述的非常形象生动, 就转载过来了: &lt;a href=&quot;https://blog.csdn.net/zhengzhb/article/details/7296944&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/zhengzhb/article/details/7296944&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278884/201810/1278884-20181021220303880-737564534.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1278884/201810/1278884-20181021220338852-517064178.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zhengzhb/article/category/926691/2&quot; target=&quot;_blank&quot;&gt;设计模式系列一&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/lovelion/article/category/738450/7&quot; target=&quot;_blank&quot;&gt;设计模式系列二&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zhengzhb/article/category/926691/2&quot; target=&quot;_blank&quot;&gt;设计模式之六大原则（转载）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/25843319/&quot; target=&quot;_blank&quot;&gt;&amp;lt;&amp;lt;设计模式之禅&amp;gt;&amp;gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 21 Oct 2018 14:13:00 +0000</pubDate>
<dc:creator>qingshanli</dc:creator>
<og:description>单一职责原则 单一职责原则(Single Responsibility Principle, SRP)的定义是: 应该有且仅有一个原因引起类或接口的变更。即一个类或接口只负责一个功能领域中的相应职责。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qingshanli/p/9808373.html</dc:identifier>
</item>
<item>
<title>perlin噪声 - 木的树</title>
<link>http://www.cnblogs.com/dojo-lzz/p/9827270.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dojo-lzz/p/9827270.html</guid>
<description>&lt;p&gt;手贱去点了图形学里面的噪声课程，然后一个周末就交代在这上面了，还是有些云里雾里。&lt;/p&gt;
&lt;p&gt;噪声就是给定一个输入变量，生成一个值在0~1范围内的伪随机变量的函数。在图形学中一般是输入一个坐标得到一个范围在0~1之间的变量，在利用各种颜色计算得到一些比较酷炫的效果，像火焰、云彩、地形等。下面就是perlin噪声生成个灰度图。&lt;/p&gt;

&lt;p&gt; 没啥意思是吧，那么看下面这个：&lt;/p&gt;

&lt;p&gt;现在说说最有名的噪声算法：perlin噪声又称柏林噪声，噪声鼻祖。柏林噪声是基于网格的，假想了一堆格网，每个格子由四个顶点组成（三维场景就是立方体，每个立方体由8个顶点组成）；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1797904-bfbbc85ed4afee99.png?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;em&gt;图1：小蓝点代表输入值在单元正方形里的空间坐标，其他4个点则是单元正方形的各顶点&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;每个顶点有一个伪随机向量（就是一个向量，由一个伪随机函数生成的，伪随机函数可以随便找一个，perlin老爷子也是随便找了一个）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1797904-ad4b0120e857b5d3.png?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;em&gt;图2：各顶点上的梯度向量随机选取结果&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 同时这四个顶点距离落在格网中的点，可以得到四个距离向量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1797904-6dde06b2b941253d.png?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;em&gt;图3:各个距离向量&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;将图2得到的梯度向量与图3的距离向量做点乘，由于都是单位向量点乘积在0-1之间。同时这个点最终的值由四个点乘积根据权重关系做差值得到。&lt;/p&gt;
&lt;p&gt;这个差值函数使用缓和曲线（ease curves）来计算它们的权重和。在原始的Perlin噪声实现中，缓和曲线是s(t)=3t2−2t3s(t)=3t2−2t3，在2002年的论文6中，Perlin改进为s(t)=6t5−15t4+10t3s(t)=6t5−15t4+10t3。（原文来自&lt;a href=&quot;https://blog.csdn.net/candycat1992/article/details/50346469&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;好了现在来看看第一个效果是怎么做出来的（至于第二个么，咳咳，等我完全看明白会写出来的）&lt;/p&gt;
&lt;p&gt;这个效果是来自&lt;a href=&quot;https://www.shadertoy.com/view/XdXGW8&quot; target=&quot;_blank&quot;&gt;ShaderToy&lt;/a&gt;中的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成一个伪随机向量，这个函数是找的一个伪随机函数，可以用其他的伪随机函数代替&lt;/span&gt;
vec2 hash( vec2 x )  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; replace this by something better&lt;/span&gt;
&lt;span&gt;{
    const vec2 k &lt;/span&gt;= vec2( 0.3183099, 0.3678794&lt;span&gt; );
    x &lt;/span&gt;= x*k +&lt;span&gt; k.yx;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; fract的作用是取小数，那么小数在0~1之间；乘以2再加-1，最终返回坐标范围在-1~1之间&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+&lt;span&gt;x.y)) );
}

&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; noise( &lt;span&gt;in&lt;/span&gt;&lt;span&gt; vec2 p )
{
    vec2 i &lt;/span&gt;= floor( p ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取一个格子&lt;/span&gt;
    vec2 f = fract( p ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取在格子内的位置&lt;/span&gt;
&lt;span&gt;    
    vec2 u &lt;/span&gt;= f*f*(3.0-2.0*f); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据权重的平滑函数&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mix( 
               mix( dot( hash( i &lt;/span&gt;+ vec2(0.0,0.0) ), f - vec2(0.0,0.0&lt;span&gt;) ), 
                     dot( hash( i &lt;/span&gt;+ vec2(1.0,0.0) ), f - vec2(1.0,0.0&lt;span&gt;) ),
                     u.x), &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将水平方向得到的两个点乘积根据水平方向的权重做差值&lt;/span&gt;
                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0&lt;span&gt;) ), 
                     dot( hash( i &lt;/span&gt;+ vec2(1.0,1.0) ), f - vec2(1.0,1.0&lt;span&gt;) ),
                     u.x), 
          u.y);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在竖直方向上对两个值按权重进行差值&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; mainImage( out vec4 fragColor, &lt;span&gt;in&lt;/span&gt;&lt;span&gt; vec2 fragCoord )
{
    vec2 p &lt;/span&gt;= fragCoord.xy / iResolution.xy; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 像素位置除以分辨率，坐标范围在0~1之间&lt;/span&gt;
&lt;span&gt;
    vec2 uv &lt;/span&gt;= p*vec2(iResolution.x/iResolution.y,1.0); // 这时u.x范围在0~宽高比之间，u.y在0~&lt;span&gt;1之间
    
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; f = 0.0&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; left: noise    &lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;( p.x&amp;lt;0.6 )&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 左边部分简单的生成单噪声&lt;/span&gt;
&lt;span&gt;    {
        f &lt;/span&gt;= noise( 32.0*uv ); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 32作为一个参数音箱噪音频率&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; right: fractal noise (4 octaves)&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 右边部分使用四个倍频在模拟效果&lt;/span&gt;
&lt;span&gt;    {
        uv &lt;/span&gt;*= 8.0&lt;span&gt;;
        mat2 m &lt;/span&gt;= mat2( 1.6,  1.2, -1.2,  1.6&lt;span&gt; );
        f  &lt;/span&gt;= 0.5000*noise( uv ); uv = m*&lt;span&gt;uv;
        f &lt;/span&gt;+= 0.2500*noise( uv ); uv = m*&lt;span&gt;uv;
        f &lt;/span&gt;+= 0.1250*noise( uv ); uv = m*&lt;span&gt;uv;
        f &lt;/span&gt;+= 0.0625*noise( uv ); uv = m*&lt;span&gt;uv;
    }

    f &lt;/span&gt;= 0.5 + 0.5*&lt;span&gt;f;
    
    f &lt;/span&gt;*= smoothstep( 0.0, 0.005, abs(p.x-0.6) );    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成中间那条黑线，smoothstep的作用看这里，https://blog.csdn.net/libing_zeng/article/details/68924521&lt;/span&gt;
&lt;span&gt;

 

    fragColor &lt;/span&gt;= vec4( f * iTime, f, f, 1.0&lt;span&gt; );
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 最后还是列一下大神们的文章：&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/candycat1992/article/details/50346469&quot; target=&quot;_blank&quot;&gt;【图形学】谈谈噪声&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/leoin2012/p/7218033.html&quot;&gt;一篇文章搞懂柏林噪声算法，附代码讲解&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/Memo/archive/2008/09/08/1286963.html&quot;&gt;[数学][转载][柏林噪声]&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 21 Oct 2018 14:10:00 +0000</pubDate>
<dc:creator>木的树</dc:creator>
<og:description>手贱去点了图形学里面的噪声课程，然后一个周末就交代在这上面了，还是有些云里雾里。 噪声就是给定一个输入变量，生成一个值在0~1范围内的伪随机变量的函数。在图形学中一般是输入一个坐标得到一个范围在0~1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dojo-lzz/p/9827270.html</dc:identifier>
</item>
<item>
<title>webpack4 系列教程(十四)：Clean Plugin and Watch Mode - GodBMW</title>
<link>http://www.cnblogs.com/geyouneihan/p/9827102.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geyouneihan/p/9827102.html</guid>
<description>&lt;blockquote readability=&quot;4.8093525179856&quot;&gt;
&lt;p&gt;作者按：因为教程所示图片使用的是 github 仓库图片，网速过慢的朋友请移步&lt;a href=&quot;https://godbmw.com/passage/73&quot;&gt;《webpack4 系列教程(十四)：Clean Plugin and Watch Mode》原文地址&lt;/a&gt;。更欢迎来我的小站看更多原创内容：&lt;a href=&quot;https://godbmw.com/&quot;&gt;godbmw.com&lt;/a&gt;，进行“姿势”交流 ♪(^∇^*)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;课程介绍和资料&quot;&gt;0. 课程介绍和资料&lt;/h2&gt;
&lt;p&gt;本节课的代码目录如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/webpack/webpack4%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/34.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本节课用的 plugin 和 loader 的配置文件&lt;code&gt;package.json&lt;/code&gt;如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;devDependencies&quot;: {
    &quot;clean-webpack-plugin&quot;: &quot;^0.1.19&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;,
    &quot;webpack&quot;: &quot;^4.16.1&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;什么是clean-plugin和watch-mode&quot;&gt;1. 什么是&lt;code&gt;Clean Plugin&lt;/code&gt;和&lt;code&gt;Watch Mode&lt;/code&gt;？&lt;/h2&gt;
&lt;p&gt;在实际开发中，由于需求变化，会经常改动代码，然后用 webpack 进行打包发布。由于改动过多，我们&lt;code&gt;/dist/&lt;/code&gt;目录中会有很多版本的代码堆积在一起，乱七八糟。&lt;/p&gt;
&lt;p&gt;为了让打包目录更简洁，&lt;strong&gt;这时候需要&lt;code&gt;Clean Plugin&lt;/code&gt;，在每次打包前，自动清理&lt;code&gt;/dist/&lt;/code&gt;目录下的文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除此之外，借助 webpack 命令本身的命令参数，&lt;strong&gt;可以开启&lt;code&gt;Watch Mode&lt;/code&gt;：监察你的所有文件,任一文件有所变动,它就会立刻重新自动打包。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;编写入口文件和-js-脚本&quot;&gt;2. 编写入口文件和 js 脚本&lt;/h2&gt;
&lt;p&gt;入口文件&lt;code&gt;app.js&lt;/code&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;console.log(&quot;This is entry js&quot;);

// ES6
import sum from &quot;./vendor/sum&quot;;
console.log(&quot;sum(1, 2) = &quot;, sum(1, 2));

// CommonJs
var minus = require(&quot;./vendor/minus&quot;);
console.log(&quot;minus(1, 2) = &quot;, minus(1, 2));

// AMD
require([&quot;./vendor/multi&quot;], function(multi) {
  console.log(&quot;multi(1, 2) = &quot;, multi(1, 2));
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;vendor/sum.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;export default function(a, b) {
  return a + b;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;vendor/multi.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;define(function(require, factory) {
  &quot;use strict&quot;;
  return function(a, b) {
    return a * b;
  };
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;vendor/minus.js&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;module.exports = function(a, b) {
  return a - b;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编写-webpack-配置文件&quot;&gt;3. 编写 webpack 配置文件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;CleanWebpackPlugin&lt;/code&gt;参数传入数组，其中每个元素是每次需要清空的文件目录。&lt;/p&gt;
&lt;p&gt;需要注意的是：&lt;strong&gt;应该把&lt;code&gt;CleanWebpackPlugin&lt;/code&gt;放在&lt;code&gt;plugin&lt;/code&gt;配置项的最后一个&lt;/strong&gt;，因为 webpack 配置是倒序的（最后配置的最先执行）。以保证每次正式打包前，先清空原来遗留的打包文件。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const webpack = require(&quot;webpack&quot;);
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);
const CleanWebpackPlugin = require(&quot;clean-webpack-plugin&quot;);

const path = require(&quot;path&quot;);

module.exports = {
  entry: {
    app: &quot;./app.js&quot;
  },
  output: {
    publicPath: __dirname + &quot;/dist/&quot;, // js引用路径或者CDN地址
    path: path.resolve(__dirname, &quot;dist&quot;), // 打包文件的输出目录
    filename: &quot;[name]-[hash:5].bundle.js&quot;,
    chunkFilename: &quot;[name]-[hash:5].chunk.js&quot;
  },
  plugins: [
    new HtmlWebpackPlugin({
      filename: &quot;index.html&quot;,
      template: &quot;./index.html&quot;,
      chunks: [&quot;app&quot;]
    }),
    new CleanWebpackPlugin([&quot;dist&quot;])
  ]
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行&lt;code&gt;webpack&lt;/code&gt;打包，在控制台会首先输出一段关于相关文件夹已经清空的的提示，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/webpack/webpack4%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/35.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;开启watch-mode&quot;&gt;4. 开启&lt;code&gt;Watch Mode&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;直接在&lt;code&gt;webpack&lt;/code&gt;命令后加上&lt;code&gt;--watch&lt;/code&gt;参数即可：&lt;code&gt;webpack --watch&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;控制台会提示用户“开启 watch”。我改动了一次文件，改动被 webpack 侦听到，就会自动重新打包。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/webpack/webpack4%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/36.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想看到详细的打包过程，可以使用：&lt;code&gt;webpack -w --progress --display-reasons --color&lt;/code&gt;。控制台就会以花花绿绿的形式展示出打包过程，看起来比较酷炫：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dongyuanxin/markdown-static/master/webpack/webpack4%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/37.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 21 Oct 2018 13:44:00 +0000</pubDate>
<dc:creator>GodBMW</dc:creator>
<og:description>作者按：因为教程所示图片使用的是 github 仓库图片，网速过慢的朋友请移步</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geyouneihan/p/9827102.html</dc:identifier>
</item>
<item>
<title>[代码结构设计]根据不同条件使用不同实现类的业务代码设计 - 云枭zd</title>
<link>http://www.cnblogs.com/fixzd/p/9827016.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fixzd/p/9827016.html</guid>
<description>&lt;p&gt;此时有一个场景，需要设计一个根据不同的状态和条件采用不同的业务处理方式。&lt;/p&gt;
&lt;p&gt;这样大家可能不是太理解。举个例子，现在大街小巷上的商户都采用了聚合支付的支付方式，聚合支付也就是商户柜台前放了一个支持支付宝、微信、京东钱包、银联等等的二维码，用户可以通过任意一款支付APP进行支付。&lt;/p&gt;

&lt;h2 id=&quot;思路&quot;&gt;思路①&lt;/h2&gt;
&lt;p&gt;对每个支付渠道进行定义枚举类型&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public enum PayWay {
    ALI_PAY,

    WECHAT_PAY;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在每个对应的service上定义注解，表示对应哪种支付方式&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Pay(PayWay.ALI_PAY)
public class AliPayServiceImpl implements PayService  {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是仔细思考后，还是存在一些问题&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果增加一个支付方式后还需要修改，&lt;code&gt;PayWay&lt;/code&gt;这个枚举类型&lt;/li&gt;
&lt;li&gt;在程序中，仍需要根据不同的条件做&lt;code&gt;if else&lt;/code&gt;判断&lt;code&gt;PayWay&lt;/code&gt;，增加支付方式还是得修改原有的判断逻辑。伪代码如下&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if(&quot;xxx&quot; == &quot;aliPay&quot;){
    
} else if(&quot;xxx&quot; == &quot;wechatPay&quot;){
    
}
//如果增加支付方式还是得增加else if&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;思路-1&quot;&gt;思路②&lt;/h2&gt;
&lt;p&gt;在思路①中存在一些问题，首当其冲的就是&lt;code&gt;if else&lt;/code&gt;判断问题。先思考一下这个&lt;code&gt;if else&lt;/code&gt;的作用是什么？&lt;/p&gt;
&lt;p&gt;答：根据思路①描述，这个&lt;code&gt;if else&lt;/code&gt;是用来确定采用哪种支付方式。&lt;/p&gt;
&lt;p&gt;我们可以将这块代码抽离出来，让对应的业务实现类实现自己的逻辑实现，然后根据返回值&lt;code&gt;true&lt;/code&gt; 或者&lt;code&gt;false&lt;/code&gt;决定是否过滤掉这个业务实现类。接口定义如下，&lt;code&gt;SupportBean&lt;/code&gt;是封装的一个实体&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean isSupport(SupportBean supportBean);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在各个业务实现类都实现自己的isSupport方法,伪代码如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public boolean isSupport(SupportBean supportBean) {
    if (supportBean.getType() == &quot;xxx&quot;){
        return true;
    }
    
    return false;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：只提供一个架子&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;接口定义&quot;&gt;接口定义&lt;/h2&gt;
&lt;p&gt;Service接口定义，一个业务执行方法execute（参数自行添加），一个isSupport方法（返回&lt;code&gt;true&lt;/code&gt;或者&lt;code&gt;false&lt;/code&gt;）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Service {

    void execute();

    boolean isSupport(SupportBean supportBean);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;业务实现类&quot;&gt;业务实现类&lt;/h2&gt;
&lt;p&gt;这里execute方法只是在控制台打印字符串。isSupport方法对SupportBean中的supportNum进行取余，判断余数是否等于0，是则返回true。&lt;/p&gt;
&lt;p&gt;类似的实现还有两个，这里就不贴出来了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class AServiceImpl implements Service {
    @Override
    public void execute() {
        System.out.println(&quot;A execute&quot;);
    }

    @Override
    public boolean isSupport(SupportBean supportBean) {
        return supportBean.getSupportNum() % 3 == 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来在定义一个帮助类&lt;/p&gt;
&lt;h2 id=&quot;帮助类&quot;&gt;帮助类&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class Helper {

    @Autowired
    private List&amp;lt;Service&amp;gt; services;

    public void execute(SupportBean supportBean){

        Service s = services.stream()
                .filter((service) -&amp;gt; service.isSupport(supportBean))
                .findFirst()//NPE异常
                .orElse(null);


        if (s != null){
            s.execute();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过工具类的execute方法来获取对应的业务实现类执行的结果，以及对传入的参数进行校验处理等。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;需要注意的是Lambda表达式的findFirst()会出现NullPointException异常。因为filter对list进行过滤，会存在过滤完list的长度为0，如果此时在调用findFirst则会抛出NullPointException。可以将上面的代码修改为如下代码，这样就可以避免NPE了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Service s = services.stream()
        .filter((service) -&amp;gt; service.isSupport(supportBean))
        .map(Optional::ofNullable)
        .findFirst()
        .flatMap(Function.identity())
        .orElse(null);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;添加一个springboot测试类和一个测试方法。&lt;/p&gt;
&lt;p&gt;在contextLoads测试中调用帮助类Helper的execute方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RunWith(SpringRunner.class)
@SpringBootTest
public class ApplicationTests {

    @Autowired
    private Helper Helper;

    @Test
    public void contextLoads() {
        Helper.execute(new SupportBean(3));
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;A execute&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;扩展&quot;&gt;扩展&lt;/h2&gt;
&lt;p&gt;在Lambda表达式中是先将业务实现类进行过滤，然后获取第一个业务实现类并执行。&lt;/p&gt;
&lt;p&gt;如果此时过滤存在多个业务实现类，而又不能确定优先级，这时需要如何进行扩展呢？&lt;/p&gt;
&lt;p&gt;其实很简单，先在Service接口中定义一个&lt;code&gt;getPriority&lt;/code&gt;方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int getPriority();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后各自的实现类实现对应的&lt;code&gt;getPriority&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;接着修改Lambda表达式即可，在filter后增加sorted方法即可对业务实现类进行排序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Service s = services.stream()
        .filter((service) -&amp;gt; service.isSupport(supportBean))
        .sorted(Comparator.comparing(Service::getPriority))
        .map(Optional::ofNullable)
        .findFirst()
        .flatMap(Function.identity())
        .orElse(null);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;整个大体框架基本都搭建完成，如需扩展只需要增加对应的业务实现类，而不用去修改其他类的代码。就连之前设计的枚举都可以不用，可扩展性大大提升。如需使用，只需修改对应的入参和对应的名称即可。&lt;br/&gt;&lt;a href=&quot;https://github.com/rainbowda/design/tree/master/extend_by_condition&quot;&gt;Github地址&lt;/a&gt;&lt;br/&gt;如果对你有收获，欢迎star、欢迎fork&lt;br/&gt;如果你也有类似的经验，欢迎加入，一起共建&lt;/p&gt;
</description>
<pubDate>Sun, 21 Oct 2018 13:34:00 +0000</pubDate>
<dc:creator>云枭zd</dc:creator>
<og:description>场景 此时有一个场景，需要设计一个根据不同的状态和条件采用不同的业务处理方式。 这样大家可能不是太理解。举个例子，现在大街小巷上的商户都采用了聚合支付的支付方式，聚合支付也就是商户柜台前放了一个支持支</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fixzd/p/9827016.html</dc:identifier>
</item>
</channel>
</rss>