<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java冒泡排序法升级版 - 王景林的博客</title>
<link>http://www.cnblogs.com/netlws/p/8537032.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/netlws/p/8537032.html</guid>
<description>&lt;p&gt; /*&lt;br/&gt;  * 冒泡排序之升级版,可比较整型数组、小数型数组&lt;br/&gt;  *&lt;br/&gt;  * */&lt;br/&gt; public static &amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; void BubbleGeneric(T[] arr) {&lt;br/&gt;  &lt;br/&gt;  T temp;&lt;br/&gt;  for (int i = 0; i &amp;lt; arr.length - 1; i++) {&lt;br/&gt;   for (int j = 0; j &amp;lt; arr.length - 1 - i; j++) {&lt;br/&gt;    if (arr[j + 1].compareTo(arr[i])&amp;lt;0) {&lt;/p&gt;
&lt;p&gt;     temp = arr[j + 1];&lt;br/&gt;     arr[j + 1] = arr[j];&lt;br/&gt;     arr[j] = temp;&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;  System.out.println(&quot;排序后的数组为：&quot; + Arrays.toString(arr));&lt;/p&gt;
&lt;p&gt; }&lt;/p&gt;
&lt;p&gt;方法调用：&lt;/p&gt;
&lt;p&gt;  Integer arrint[] = { 10, 2, 6, 9, 8 };  // 数组需要定义为引用类型、泛型参数需传递引用类型。&lt;br/&gt;  Double  arrddouble[] = {11.0,45.2,23.0,46.0,89.6};&lt;br/&gt; &lt;br/&gt;  BubbleGeneric(arrddouble);&lt;br/&gt;  BubbleGeneric(arrint);&lt;/p&gt;
</description>
<pubDate>Fri, 09 Mar 2018 15:51:00 +0000</pubDate>
<dc:creator>王景林的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/netlws/p/8537032.html</dc:identifier>
</item>
<item>
<title>SpringMVC 框架系列之初识与入门实例 - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/8537008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/8537008.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;微信公众号：compassblog&lt;/p&gt;
&lt;p&gt;欢迎关注、转发，互相学习，共同进步！&lt;/p&gt;
&lt;p&gt;有任何问题，请后台留言联系！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;1、SpringMVC 概述&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;（1）、 MVC：Model-View-Control&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Control 层属于框架性质，完成的主要工作是：封装 web 请求为一个数据对象、调用业务逻辑层来处理数据对象、返回处理数据结果及相应的视图给客户端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）、什么是 SpringMVC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring mvc 和 Struts2 都属于表现层的框架，是 Spring 框架的一部分，Spring 框架的 Control 层的核心是 DispatcherServlet，它的作用是将请求分发给不同的后端处理器。&lt;/p&gt;
&lt;p&gt;Spring 的 Control 层框架使用了后端控制器来映射处理器和视图解析器来共同完成 Control 层框架的主要工作。并且 spring 的 Control 层框架还真正地把业务层处理的数据结果和相应的视图拼成一个对象，即 ModelAndView 对象。&lt;/p&gt;
&lt;p&gt;SpringMVC 本身就是  Spring 的子项目，对 Spring 兼容性很好，因此也不需要做过多的配置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）SpringMVC 框架处理流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201803/1322792-20180309234103758-105967839.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2、SpringMVC 入门实例&lt;/h4&gt;
&lt;p&gt;（1）、创建 web  项目，导入所需要的 jar 包，如图下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201803/1322792-20180309234113344-146066257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）、创建 SpringMVC 的核心配置文件，具体配置如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;springmvc.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;beans &lt;span class=&quot;hljs-attr&quot;&gt;xmlns=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;xmlns:xsi=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot; &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:p=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/p&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;xmlns:context=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/context&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;xmlns:mvc=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/mvc&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;xsi:schemaLocation=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&lt;br/&gt;http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&lt;br/&gt;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&quot;&amp;gt;&lt;p&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;beans&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）、配置 SpringMVC 的前端控制器 DispatcherServlet，具体配置如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;web.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;web-app &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:xsi=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot; &lt;span class=&quot;hljs-attr&quot;&gt;xmlns=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://java.sun.com/xml/ns/javaee&quot; &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:web=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; &lt;span class=&quot;hljs-attr&quot;&gt;xsi:schemaLocation=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; &lt;span class=&quot;hljs-attr&quot;&gt;id=&lt;span class=&quot;hljs-string&quot;&gt;&quot;WebApp_ID&quot; &lt;span class=&quot;hljs-attr&quot;&gt;version=&lt;span class=&quot;hljs-string&quot;&gt;&quot;2.5&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;display-name&amp;gt;SpringmvcProject&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;display-name&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;welcome-file-list&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;welcome-file&amp;gt;index.html&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;welcome-file&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;welcome-file&amp;gt;index.htm&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;welcome-file&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;welcome-file&amp;gt;index.jsp&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;welcome-file&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;welcome-file&amp;gt;default.html&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;welcome-file&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;welcome-file&amp;gt;default.htm&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;welcome-file&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;welcome-file&amp;gt;default.jsp&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;welcome-file&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;welcome-file-list&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;servlet&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;servlet-name&amp;gt;springmvc&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;servlet-name&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;servlet-class&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;init-param&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;param-name&amp;gt;contextConfigLocation&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;param-name&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;param-value&amp;gt;classpath:springmvc.xml&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;param-value&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;init-param&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;servlet&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;servlet-mapping&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;servlet-name&amp;gt;springmvc&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;servlet-name&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;url-pattern&amp;gt;*.action&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;url-pattern&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;servlet-mapping&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;web-app&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）、在 /WEB-INF/ 目录下新建 jsp 目录，新建 jsp 文件，具体代码如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;itemList.jsp&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;%@ &lt;span class=&quot;hljs-attr&quot;&gt;page &lt;span class=&quot;hljs-attr&quot;&gt;language=&lt;span class=&quot;hljs-string&quot;&gt;&quot;java&quot; &lt;span class=&quot;hljs-attr&quot;&gt;contentType=&lt;span class=&quot;hljs-string&quot;&gt;&quot;text/html; charset=UTF-8&quot;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;pageEncoding=&lt;span class=&quot;hljs-string&quot;&gt;&quot;UTF-8&quot;%&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;%@ &lt;span class=&quot;hljs-attr&quot;&gt;taglib &lt;span class=&quot;hljs-attr&quot;&gt;uri=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://java.sun.com/jsp/jstl/core&quot; &lt;span class=&quot;hljs-attr&quot;&gt;prefix=&lt;span class=&quot;hljs-string&quot;&gt;&quot;c&quot; %&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;%@ &lt;span class=&quot;hljs-attr&quot;&gt;taglib &lt;span class=&quot;hljs-attr&quot;&gt;uri=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://java.sun.com/jsp/jstl/fmt&quot;  &lt;span class=&quot;hljs-attr&quot;&gt;prefix=&lt;span class=&quot;hljs-string&quot;&gt;&quot;fmt&quot;%&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;html&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;head&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;meta &lt;span class=&quot;hljs-attr&quot;&gt;http-equiv=&lt;span class=&quot;hljs-string&quot;&gt;&quot;Content-Type&quot; &lt;span class=&quot;hljs-attr&quot;&gt;content=&lt;span class=&quot;hljs-string&quot;&gt;&quot;text/html; charset=UTF-8&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;title&amp;gt;查询商品列表&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;title&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;head&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;body&amp;gt; &lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;form &lt;span class=&quot;hljs-attr&quot;&gt;action=&lt;span class=&quot;hljs-string&quot;&gt;&quot;${pageContext.request.contextPath }/item/queryitem.action&quot; &lt;span class=&quot;hljs-attr&quot;&gt;method=&lt;span class=&quot;hljs-string&quot;&gt;&quot;post&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;p&amp;gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;p&amp;gt;&lt;br/&gt;商品列表：&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;p&amp;gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;p&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;table &lt;span class=&quot;hljs-attr&quot;&gt;width=&lt;span class=&quot;hljs-string&quot;&gt;&quot;100%&quot; &lt;span class=&quot;hljs-attr&quot;&gt;border=&lt;span class=&quot;hljs-string&quot;&gt;1&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;tr&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;td&amp;gt;商品名称&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;td&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;td&amp;gt;商品价格&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;td&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;td&amp;gt;生产日期&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;td&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;td&amp;gt;商品描述&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;td&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;tr&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;c:forEach &lt;span class=&quot;hljs-attr&quot;&gt;items=&lt;span class=&quot;hljs-string&quot;&gt;&quot;${itemList }&quot; &lt;span class=&quot;hljs-attr&quot;&gt;var=&lt;span class=&quot;hljs-string&quot;&gt;&quot;item&quot;&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;tr&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;td&amp;gt;${item.name }&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;td&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;td&amp;gt;${item.price }&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;td&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;td&amp;gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;fmt:formatDate &lt;span class=&quot;hljs-attr&quot;&gt;value=&lt;span class=&quot;hljs-string&quot;&gt;&quot;${item.createtime}&quot; &lt;span class=&quot;hljs-attr&quot;&gt;pattern=&lt;span class=&quot;hljs-string&quot;&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;/&amp;gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;td&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;td&amp;gt;${item.detail }&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;td&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;tr&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;c:forEach&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;table&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;form&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;body&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;html&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（5）、创建 POJO 类，具体代码如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Items.java&lt;/code&gt;&lt;/p&gt;
&lt;pre readability=&quot;18.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;31&quot;&gt;package com.springmvc.pojo;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import java.util.Date;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Items {&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-title&quot;&gt;Items&lt;span class=&quot;hljs-params&quot;&gt;(Integer id, String name, Float price, Date createtime, String detail) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;super();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.id = id;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.name = name;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.price = price;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.createtime = createtime;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.detail = detail;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private Integer id;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private String name;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private Float price;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private String pic;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private Date createtime;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private String detail;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Integer &lt;span class=&quot;hljs-title&quot;&gt;getId&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return id;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setId&lt;span class=&quot;hljs-params&quot;&gt;(Integer id) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.id = id;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;getName&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return name;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setName&lt;span class=&quot;hljs-params&quot;&gt;(String name) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.name = name == &lt;span class=&quot;hljs-keyword&quot;&gt;null ? &lt;span class=&quot;hljs-keyword&quot;&gt;null : name.trim();&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Float &lt;span class=&quot;hljs-title&quot;&gt;getPrice&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return price;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setPrice&lt;span class=&quot;hljs-params&quot;&gt;(Float price) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.price = price;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;getPic&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return pic;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setPic&lt;span class=&quot;hljs-params&quot;&gt;(String pic) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.pic = pic == &lt;span class=&quot;hljs-keyword&quot;&gt;null ? &lt;span class=&quot;hljs-keyword&quot;&gt;null : pic.trim();&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Date &lt;span class=&quot;hljs-title&quot;&gt;getCreatetime&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return createtime;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setCreatetime&lt;span class=&quot;hljs-params&quot;&gt;(Date createtime) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.createtime = createtime;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;getDetail&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return detail;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setDetail&lt;span class=&quot;hljs-params&quot;&gt;(String detail) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this.detail = detail == &lt;span class=&quot;hljs-keyword&quot;&gt;null ? &lt;span class=&quot;hljs-keyword&quot;&gt;null : detail.trim();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（6）、创建 Controller 类，具体代码如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ItemController.java&lt;/code&gt;&lt;/p&gt;
&lt;pre readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;11&quot;&gt;package com.springmvc.controller;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import java.util.ArrayList;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import java.util.Date;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import java.util.List;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.stereotype.Controller;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.web.bind.annotation.RequestMapping;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.web.servlet.ModelAndView;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import com.springmvc.pojo.Items;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping(value = &lt;span class=&quot;hljs-string&quot;&gt;&quot;/itemlist.action&quot;)&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public ModelAndView &lt;span class=&quot;hljs-title&quot;&gt;itemList&lt;span class=&quot;hljs-params&quot;&gt;(){&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;ModelAndView mav = &lt;span class=&quot;hljs-keyword&quot;&gt;new ModelAndView();&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（7）、启动 Tomcat，并到浏览器地址栏测试，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3R4VBiavfDxuokgLoCSVq1LwBv2uIP816soAicWx0rWxnnBIE2nQW99o0oG0PufiaicAUBNEZiaZKWF8L2Xh2ickxwibQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.43108108108108106&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;740&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;3、SpringMVC 框架访问流程图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3R4VBiavfDxuokgLoCSVq1LwBv2uIP816Pniadic9ZIlUdialbsTFEDUng8ibibhibV7Giaib69o2TgEBT3GkjYzbfWIq2w/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.6237942122186495&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;622&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注：部分知识源于网络，侵权联删。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注微信公众号compassblog，后台回复 “SpringMVC系列一” 获取本项目源码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本系列后期仍会持续更新，欢迎关注！&lt;/p&gt;

&lt;p&gt;如果你认为这篇文章有用，欢迎转发分享给你的好友！&lt;/p&gt;
&lt;p&gt;本号文章可以任意转载，转载请注明出处！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;扫描关注微信公众号，了解更多&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201803/1322792-20180309234212704-687174474.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Mar 2018 15:43:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/8537008.html</dc:identifier>
</item>
<item>
<title>CentOS7使用dnf安装mysql - 不忘初心1223</title>
<link>http://www.cnblogs.com/vitasyuan/p/8536983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vitasyuan/p/8536983.html</guid>
<description>&lt;h2 id=&quot;安装mysql的yum仓库&quot;&gt;1.安装mysql的yum仓库&lt;/h2&gt;
&lt;p&gt;执行以下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum localinstall https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装mysql&quot;&gt;2.安装mysql&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;dnf install mysql-community-server&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;开启mysql服务&quot;&gt;3.开启mysql服务&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;service mysql start&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查找默认密码&quot;&gt;4.查找默认密码&lt;/h2&gt;
&lt;p&gt;为了加强安全性，MySQL5.7为root用户随机生成了一个密码，在error log中，关于error log的位置，如果安装的是RPM包，则默认是/var/log/mysqld.log。&lt;br/&gt;只有启动过一次mysql才可以查看临时密码，输入以下命令查看密码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;grep 'temporary password' /var/log/mysqld.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@VM_0_13_centos init.d]# grep 'temporary password' /var/log/mysqld.log                                                    
2018-03-09T13:03:32.859149Z 1 [Note] A temporary password is generated for root@localhost: IVXhn:4E3uQ4  &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;登陆mysql并且修改密码&quot;&gt;5.登陆mysql并且修改密码&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;ALTER USER 'root'@'localhost' IDENTIFIED BY 'root123';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改密码，会出现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ERROR 1819 (HY000): Your password does not satisfy the current policy requirements&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;必须修改两个全局参数：&lt;br/&gt;首先，修改validate_password_policy参数的值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; set global validate_password_policy=0; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再修改密码的长度&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set global validate_password_length=1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次执行修改密码就可以了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ALTER USER 'root'@'localhost' IDENTIFIED BY 'root123';&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;授权其他机器连接&quot;&gt;6.授权其他机器连接&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'passwort' WITH GRANT OPTION; //passwort改为mysql登陆密码

FLUSH  PRIVILEGES;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;密码设置的详细说明&quot;&gt;7.密码设置的详细说明&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.linuxidc.com/Linux/2016-01/127831.htm&quot; class=&quot;uri&quot;&gt;https://www.linuxidc.com/Linux/2016-01/127831.htm&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Mar 2018 15:35:00 +0000</pubDate>
<dc:creator>不忘初心1223</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vitasyuan/p/8536983.html</dc:identifier>
</item>
<item>
<title>Android外部存储 - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/8536868.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/8536868.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;WeTest 导读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;外部存储作为开发中经常接触的一个重要系统组成，在Android历代版本中，有过许许多多重要的变更。我也曾疑惑过，为什么一个简简单单外部存储，会存在存在这么多奇奇怪怪的路径：/sdcard、/mnt/sdacrd、/storage/extSdCard、/mnt/shell/emulated/0、/storage/emulated/0、/mnt/shell/runtime/default/emulated/0...其实，这背后代表了一项项技术的成熟与发布：模拟外部存储、多用户、运行时权限...&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、各版本外部存储特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、Android 4.0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● 支持模拟外部存储（通过FUSE实现）&lt;/p&gt;
&lt;p&gt;● 出现了主外部存储，以及二级外部存储（没有接口对外暴露）&lt;/p&gt;
&lt;p&gt;● 支持MTP（Media Transfer Protocol）、PTP协议（Picture Transfer Protocol）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、Android 4.1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● 开发者选项出现”强制应用声明读权限才可以进行读操作”的开关&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、Android 4.2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● 支持多用户，每个用户拥有独立的外部存储&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、Android 4.4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● 读操作需要声明READ_EXTERNAL_STORAGE权限&lt;/p&gt;
&lt;p&gt;● 应用读写在外部存储的应用目录（/sdcard/Android/&amp;lt;pkg&amp;gt;/）不需要声明权限&lt;/p&gt;
&lt;p&gt;● 增加了Context.getExternalFilesDirs() 接口，可以获取应用在主外部存储和其他二级外部存储下的files路径&lt;/p&gt;
&lt;p&gt;● 引入存储访问框架（SAF，Storage Access Framework）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309223657887-506668545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、Android 6.0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● 外部存储支持动态权限管理&lt;/p&gt;
&lt;p&gt;● Adoptable Storage特性&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、Android 7.0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● 引入作用域目录访问&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309223722418-1242175376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;补充一个点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果应用的minSdkVersion和targetSdkVersion设置成&amp;lt;=3，系统会默认授予READ_EXTERNAL_STORAGE权限。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、部分特性讲解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.模拟外部存储&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a. 必要性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● FAT32 属于微软专利，可能存在许可和法律问题（相关文章）；&lt;/p&gt;
&lt;p&gt;● 可以定制Android自己的外部存储访问规则；&lt;/p&gt;
&lt;p&gt;● 为多用户做铺垫；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b. 实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;系统/system/bin/sdcard守护进程，使用FUSE实现类FAT格式SD卡文件系统的模拟，也就是我们经常说的内置SD卡。（详细代码可以参考：/xref/system/core/sdcard/sdcard.c）&lt;/p&gt;

&lt;p&gt;用户空间文件系统（Filesystem in Userspace，简称FUSE）是一个面向类Unix计算机操作系统的软件接口，它使无特权的用户能够无需编辑内核代码而创建自己的文件系统。目前Linux通过内核模块对此进行支持。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309223806883-1714000861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sdcard守护进程模拟外部存储大致流程（Android 4.0为例）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● 首先，指定/data/media目录用于模拟外部存储。该路径的owner和group一般为media_rw，这样保证只有sdcard程序或root进程能够访问该目录。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309223835352-815948055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;● sdcard守护进程启动后，打开/dev/fuse设备。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309223850274-1669644554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;● 在/mnt/sdcard目录挂载fuse文件系统。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309223930554-977463261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;● 开线程，在线程中处理文件系统事件，并将结果写回。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309223947786-1643356738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;经过上面一系列步骤，sdcard进程在/mnt/sdcard路径上创建了一个FUSE文件系统，所有对/mnt/sdcard将转为事件由sdcard守护进程处理，并对应到/data/media目录。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;例如，应用创建/mnt/sdcard/a文件，实际是创建/data/media/a文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;c. 优点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● 模拟外部存储容量和/data分区是共享的，用户数据在内外存储的分配更加自由；&lt;/p&gt;
&lt;p&gt;● 模拟外部存储本身不可卸载，不会因为卸载导致应用访问出现问题，也减少了外部因素导致被破坏的情况；&lt;/p&gt;
&lt;p&gt;● 所有的访问都经过sdcard守护进程，Android可以定制访问规则；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;d. 劣势&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● 性能上存在一定损失&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;e. 影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● Android 6.0以后，由于动态权限管理的需要，会存在多个fuse挂载点，这导致inotify/FileObserver对外部存储进行文件事件监控时，会丢失事件。&lt;/p&gt;

&lt;p&gt;inotify是Linux核心子系统之一，做为文件系统的附加功能，它可监控文件系统并将异动通知应用程序。 —— 维基百科（&lt;a href=&quot;https://zh.wikipedia.org/wiki/Inotify&quot;&gt;https://zh.wikipedia.org/wiki/Inotify&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、多用户&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a. 支持版本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● Android 4.2开始支持多用户，但仅限平板；&lt;/p&gt;
&lt;p&gt;● Android 5.0开始，设备制造商可以在编译时候开启多用户模块；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b. 背景知识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● 绑定挂载——mount —bind&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MS_BIND&lt;/strong&gt; (Linux 2.4 onward)&lt;/p&gt;

&lt;p&gt;Perform a bind mount, making a file or a directory subtree visible at another point within a file system. Bind mounts may cross file system boundaries and span chroot(2) jails. The filesystemtype and dataarguments are ignored. Up until Linux 2.6.26, mountflagswas also ignored (the bind mount has the same mount options as the underlying mount point). ——&lt;strong&gt; mount(2) - Linux man page&lt;/strong&gt;&lt;a href=&quot;https://linux.die.net/man/2/mount&quot;&gt;（https://linux.die.net/man/2/mount）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图例&lt;/strong&gt;（来自https://xionchen.github.io/2016/08/25/linux-bind-mount）&lt;strong&gt;：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1) 将/home目录树bind到/mnt/backup：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309224030606-767807521.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;


&lt;p&gt;2) bind完成之后，对/mnt/backup的访问将等同于对/home的访问，原/mnt/backup变为不可见。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309224043816-723281872.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;● 挂载命名空间&lt;/p&gt;
&lt;p&gt;Mount namespaces provide isolation of the list of mount points seen by the processes in each namespace instance. Thus, the processes in each of the mount namespace instances will see distinct single-directory hierarchies. ——&lt;strong&gt;mount_namespaces(7) - Linux manual page - man7.org&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（http://man7.org/linux/man-pages/man7/mount_namespaces.7.html）&lt;/p&gt;

&lt;p&gt;通俗的讲，挂载命名空间实现了挂载点的隔离，在不同挂载命名空间的进程，看到的目录层次不同。&lt;/p&gt;

&lt;p&gt;● 挂载传播之共享挂载、从属挂载、私有挂载&lt;/p&gt;
&lt;p&gt;挂载命名空间实现了完全的隔离，但对于有些情况并不适用。例如在Linux系统上，进程A在命名空间1挂载了一张CD-ROM，这时候命名空间2因为隔离无法看到这张CD-ROM。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为了解决这个问题，引入了挂载传播（mount propagation）。传播挂载定义了挂载点的传播类型：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）共享挂载，此类型的挂载点会加入一个peer group，并会在group内传播和接收挂载事件；&lt;/p&gt;
&lt;p&gt;2）从属挂载，此类型的挂载点会加入一个peer group，并会接收group内的挂载事件，但不传播；&lt;/p&gt;
&lt;p&gt;3）共享/从属挂载，上面两种类型的共存体。可以从一个peer group（此时类型为从属挂载）接收挂载事件，再传播到另一个peer group；&lt;/p&gt;
&lt;p&gt;4）私有挂载，此类型的挂载点没有peer group，既不传播也不接收挂载事件；&lt;/p&gt;
&lt;p&gt;5）不可绑定挂载，不展开讲；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;peer group的形成条件为，一个挂载点被设置成共享挂载，并满足以下任意一种情况：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）挂载点在创建新的命名空间时被复制&lt;/p&gt;
&lt;p&gt;2）从该挂载点创建了一个绑定挂载&lt;/p&gt;

&lt;p&gt;另外再补充下传播类型的转换：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309224116556-427303076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1）如果一个共享挂载是peer group中仅存的挂载点，那么对它应用从属挂载将会导致它变为私有挂载。&lt;br/&gt;2）对一个非共享挂载类型的挂载点，应用从属挂载是无效的。&lt;/p&gt;

&lt;p&gt;背景知识讲到这里，其中挂载点的传播类型比较不好理解，但很重要，可以参考上面mount namespace的Linux Programmer’s Manual里面的例子（搜索MS_XXX example）进行学习：http://man7.org/linux/man-pages/man7/mount_namespaces.7.html&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;c. 实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;概括多用户的外部存储隔离实现：应用进程在创建时，创建了新的挂载命名空间，然后通过绑定挂载对应用暴露当前用户的外部存储空间。&lt;/p&gt;

&lt;p&gt;以Android 4.2代码为例【mountEmulatedStorage(dalvik_system_Zygote.cpp)】：&lt;/p&gt;

&lt;p&gt;● 首先获取用户id。在多用户下，用户id为应用uid/100000。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309224135562-184308706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;● 通过unshare方法创建新的挂载命名空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309224156146-1917615314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;● 获取外部存储相关的环境变量。EXTERNAL_STORAGE环境变量是从旧版本沿袭下来的环境变量，记录了外部存储的传统路径。EMULATED_STORAGE_SOURCE环境变量，记录绑定挂载的源路径，注意应用是没有权限进入这个目录的。EMULATED_STORAGE_TARGET记录绑定挂载的目标路径，应用获取的外部存储路径就在这个目录下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309224227939-1208544818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;● 准备挂载路径并进行绑定挂载。这里看mountMode为MOUNT_EXTERNAL_MULTIUSER时的执行分支，/mnt/shell/emulated/0将被绑定到/storage/emulated/0。如果是第二个用户，则是/mnt/shell/emulated/1绑定到/storage/emulated/1，数字就是用户id。注意这里是新的挂载命名空间，所以只有该应用看得到/storage/emulated/0下的绑定挂载，从adb shell下是看到的只能是个空目录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309224244293-76162200.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;● 为了兼容以前的版本，将用户的外部存储路径绑定到EXTERNAL_STORAGE环境变量指定的路径。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309224302532-1411229102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 动态权限管理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a.背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Android 6.0引入了运行时权限，允许用户对危险权限进行动态授权，这部分权限包含外部存储访问权限。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;b.实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;外部存储访问权限的动态授权，是利用FUSE和挂载命名空间这两个技术配合实现。&lt;br/&gt;通过下面这个提交记录（https://android.googlesource.com/platform/system/core/+/f38f29c87d97cea45d04b783bddbd969234b1030%5E%21/#F1），我们可以很清楚的了解整个实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309224333607-1866762106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;为了达到不杀死进程，就能够赋予进程读/写外置存储的目的，Android利用FUSE对/data/media模拟了三种访问视图，分别是default、read、write。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309224352386-1795100496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当应用被授予读/写权限时，vold子进程会切换到应用的挂载命名空间，将对应的视图重新绑定到应用的外部存储路径上。&lt;/p&gt;

&lt;p&gt;切换进程的挂载命名空间，需要内核版本在3.8及以上，切换函数为setns，ndk貌似没有对开发者暴露，但可以在源码里找到arm的实现，有需要直接编入就可以了，也就一个sys call。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309224412134-557504955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;c. 代码分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;● 源码版本：Android 6.0.0_r1&lt;/p&gt;
&lt;p&gt;● 首先从/xref/system/core/sdcard/sdcard.c开始分析，仅摘取部分代码，并加了些注释：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309224441375-1741428201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309224455082-1912425522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;● &lt;span&gt;应用进程创建时，大致流程如下（/xref/frameworks/base/core/jni/com_android_internal_os_Zygote.cpp）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）创建新的挂载命名空间；&lt;/p&gt;
&lt;p&gt;2）将之前的挂载命名空间在/storage下的挂载全部去除，排除影响；&lt;/p&gt;
&lt;p&gt;3）根据mount_mode，选择一个路径；&lt;/p&gt;
&lt;p&gt;4）将选择的路径绑定到/storage下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309224515405-271964536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;● &lt;span&gt;进程在运行时，当外部存储的访问许可发生改变（用户授权）时，基本流程如下（/xref/system/vold/VolumeManager.cpp）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1）获取init的挂载命名空间，为了对之后进程的挂载命2）名空间进行对比，如果一致，不重新绑定；&lt;/p&gt;
&lt;p&gt;3）遍历/proc下各个进程目录，根据uid进行筛选；&lt;/p&gt;
&lt;p&gt;找到对应的pid后，fork子进程进行重新挂载，这里用到setns进行挂载命名空间的切换；&lt;/p&gt;

&lt;p&gt;重新挂载部分的逻辑和应用进程创建时基本一致，不难理解。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/992994/201803/992994-20180309224537830-844429913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;腾讯WeTest提供上千台真实手机&lt;/strong&gt;，随时随地进行测试，保障应用/手游品质。节省百万硬件费用，加速敏捷研发流程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;同时腾讯WeTest兼容性测试团队积累了10年的手游测试经验&lt;/strong&gt;，旨在通过制定针对性的测试方案，精准选取目标机型，执行专业、完整的测试用例，来提前发现游戏版本的兼容性问题，针对性地做出修正和优化，来保障手游产品的质量。目前该团队已经支持所有腾讯在研和&lt;span&gt;运营的手游项目&lt;/span&gt;&lt;/p&gt;



</description>
<pubDate>Fri, 09 Mar 2018 14:50:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/8536868.html</dc:identifier>
</item>
<item>
<title>Python 学习笔记（二）开发环境的搭建 - 冰雪柔情的天空</title>
<link>http://www.cnblogs.com/wangruihua-521/p/8536433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangruihua-521/p/8536433.html</guid>
<description>
&lt;p&gt;安装Python &lt;/p&gt;
&lt;p&gt;windows 下安装：&lt;/p&gt;
&lt;p&gt;下载地址：https://www.python.org/downloads&lt;/p&gt;
&lt;p&gt;Python的版本&lt;/p&gt;
&lt;p&gt;3.x 是趋势&lt;/p&gt;
&lt;p&gt;2.x 还在被大量使用&lt;/p&gt;
&lt;p&gt;至于使用2.x 还是3.x ，我觉得两者没有太大的区别，学会了2.x 也会使用3.x的，只要开始学习就好了&lt;/p&gt;
&lt;p&gt;当前我使用的Python2.7.14&lt;/p&gt;
&lt;p&gt;选择 &lt;a href=&quot;https://www.python.org/ftp/python/2.7.14/python-2.7.14.amd64.msi&quot;&gt;Windows x86-64 MSI installer&lt;/a&gt;  msi 64位安装&lt;/p&gt;

&lt;p&gt;windows 下设置环境变量 两种方式&lt;/p&gt;
&lt;p&gt;1、Win+R   输入cmd   在命令提示框中输入 path=%path%;C:\Python27  (注：Python的安装目录)  Enter 键&lt;/p&gt;
&lt;p&gt;2、计算机右键属性，这种方法自己查&lt;/p&gt;

&lt;p&gt;Linux 或Unix 上一般会自带&lt;/p&gt;
&lt;p&gt;也可使用源安装&lt;/p&gt;
&lt;p&gt;下载源码压缩包&lt;/p&gt;
&lt;p&gt; 解压缩包&lt;/p&gt;
&lt;p&gt; 执行 ./configure 脚本&lt;/p&gt;
&lt;p&gt; make &lt;/p&gt;
&lt;p&gt; make install&lt;/p&gt;

&lt;p&gt;Python 的开发工具&lt;/p&gt;
&lt;p&gt;Python自带的IDLE(Python GUI)&lt;/p&gt;
&lt;p&gt;其他工具&lt;/p&gt;
&lt;p&gt;Anaconda(包管理必备)+Pycharm&lt;/p&gt;
&lt;p&gt;Sublime3&lt;/p&gt;
&lt;p&gt;PythonWin&lt;/p&gt;
&lt;p&gt;Eclipse +PyDev&lt;/p&gt;
&lt;p&gt;等&lt;/p&gt;

</description>
<pubDate>Fri, 09 Mar 2018 14:49:00 +0000</pubDate>
<dc:creator>冰雪柔情的天空</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangruihua-521/p/8536433.html</dc:identifier>
</item>
<item>
<title>用VSCode开发一个asp.net core 2.0+angular 5项目(4): Angular5全局错误处理 - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/8536350.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/8536350.html</guid>
<description>&lt;p&gt;第一部分: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/8478993.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/8478993.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第二部分: &lt;a href=&quot;http://www.cnblogs.com/cgzl/p/8481825.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cgzl/p/8481825.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第三部分: &lt;a href=&quot;https://www.cnblogs.com/cgzl/p/8525541.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/cgzl/p/8525541.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章将介绍angular 5的全局错误处理.&lt;/p&gt;
&lt;p&gt;需要使用到代码: &lt;a href=&quot;https://pan.baidu.com/s/1F0KjbwVE8_Tzfwy69Alp-A&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1F0KjbwVE8_Tzfwy69Alp-A&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参考文档: &lt;a href=&quot;https://angular.io/api/core/ErrorHandler&quot; target=&quot;_blank&quot;&gt;https://angular.io/api/core/ErrorHandler&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先按照文档在客户端项目建立app.error-handler.ts 文件:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import { ErrorHandler } from '@angular/core'&lt;span&gt;;

export class AppErrorHandler implements ErrorHandler {
    handleError(error: any): &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; {
        console.log(&lt;/span&gt;'ERROR Occurred.'&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里, 我们只写log.&lt;/p&gt;
&lt;p&gt;然后在app.module里面注册:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;providers: [
    TvNetworkService,
    &lt;strong&gt;{ provide: ErrorHandler, useClass: AppErrorHandler }&lt;/strong&gt;
  ],&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后把tv-network-list.component.ts里面到一个错误处理删除掉:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180309194420741-1665121211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在后端到Controller里面抛一个异常:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180309194544072-1527312880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们试一下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180309194713170-1894483544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到, 这个全局错误处理器正常到工作了.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先别急, 让我们在errorhandler里面使用toastr试试&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;app.error-handler.ts:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import { ErrorHandler } from '@angular/core'&lt;span&gt;;
import { ToastrService } from &lt;/span&gt;'ngx-toastr'&lt;span&gt;;

export class AppErrorHandler implements ErrorHandler {

    &lt;strong&gt;constructor(private toastr: ToastrService) { }&lt;/strong&gt;

    handleError(error: any): &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log('ERROR Occurred.');&lt;/span&gt;
        &lt;strong&gt;&lt;span&gt;this&lt;/span&gt;.toastr.error('发生了错误'&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;);&lt;/strong&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而这时回到浏览器之后, 发生了错误:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180309195202263-642691546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之所以发生这个错误, 是因为AppErrorHandler在angular引入Toastr模块之前就初始化了.&lt;/p&gt;
&lt;p&gt;我们可以这样处理:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
import { ErrorHandler, Injectable, Injector, Inject } from '@angular/core'&lt;span&gt;;
import { ToastrService, Toast } from &lt;/span&gt;'ngx-toastr'&lt;span&gt;;

&lt;strong&gt;@Injectable()&lt;/strong&gt;
export class AppErrorHandler implements ErrorHandler {

    constructor(&lt;strong&gt;private injector: Injector&lt;/strong&gt;) { }

    &lt;strong&gt;private get toastr(): ToastrService {
        &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;.injector.get(ToastrService);
    }&lt;/strong&gt;

    handleError(error: any): &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.toastr.error('发生了错误'&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用Injector来手动注入ToastrService.&lt;/p&gt;
&lt;p&gt;回到浏览器:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180309202230419-1891218957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并没有弹出错误信息!!!!, 但是来回切换菜单后, 开始显示错误信息了, 貌似有点迟钝.&lt;/p&gt;
&lt;p&gt;这是什么原因呢? 首先, 我们得了解以下这个东西:&lt;/p&gt;
&lt;h2&gt;Zone&lt;/h2&gt;
&lt;p&gt;首先到首先, 需要了解以下&lt;strong&gt;execution context&lt;/strong&gt;, 程序执行到上下文, 但是这些东西到定义看了之后可能会让人迷糊. 所以还是先看这段代码吧:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const Zone =&lt;span&gt; {
  run: (callback) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beforeTask) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beforeTask();
    }
    callback();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.afterTask) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.afterTask();
    }
  }
};

Zone.beforeTask &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;'Before Task.'&lt;span&gt;);
};
Zone.afterTask &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;'After Task.'&lt;span&gt;);
};
Zone.run(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;'Running...'&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;就是定义一个Zone, 它到run方法可以执行某个回调函数, 回调函数到前后还可以有一些预定义的函数, 如果它们存在就会被执行. 通过定义这些函数的内容, 我们就可以在执行run的回调前后添加自定义逻辑了.&lt;/p&gt;
&lt;p&gt;回到Angular, angular的变化检测(Change Detection)功能就用到了这些东西.&lt;/p&gt;
&lt;p&gt;比如angular的一个component有一个click事件, click()方法里更新了某些属性的值, 这个时候angular就需要进行变化检测, 如果真的发生了变化, 那么angular 就会更新dom, 这样我们就能看见页面的变化了. Angular用了这个猴子补丁, 使之运行在Zone里面, 当点击按钮的时候, 这段代码总是在Zone里面执行, 在执行完click处理方法之后, angular会执行变化检测动作.&lt;/p&gt;
&lt;p&gt;angular应该是这样来进行猴子补丁的:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
const Zone =&lt;span&gt; {
  run: (callback) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beforeTask) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beforeTask();
    }
    callback();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.afterTask) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.afterTask();
    }
  }
};

Zone.beforeTask &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;'Before Task.'&lt;span&gt;);
};
Zone.afterTask &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;'After Task.'&lt;span&gt;);
};
Zone.run(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;'Running...'&lt;span&gt;);
});

&lt;/span&gt;&lt;strong&gt;&lt;span&gt;var&lt;/span&gt; _setTimeout =&lt;span&gt; setTimeout;
setTimeout &lt;/span&gt;= (callback, timeout) =&amp;gt;&lt;span&gt; {
  Zone.run(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    _setTimeout(callback, timeout);
  });
};
click(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;'设置Timeout'&lt;span&gt;);
});&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于这个是异步的, 所以打印到控制台到顺序可能是: Before Task, After Task, 设置Timeout.&lt;/p&gt;
&lt;p&gt;js运行时里, 有一个信息队列. 任何时候出现一个异步操作, 队列里就会推进去一条信息, js运行时会训话这个队列, 一个个把消息推出队列, 然后调用这个消息到回调函数. 对于这个例子来说就是setTimeout().&lt;/p&gt;
&lt;p&gt;所以就出现了Zone.js这个库.&lt;/p&gt;
&lt;p&gt;Zone.js就是一个执行的上下文, 它可以在不同的异步操作之间进行持久性传递.&lt;/p&gt;
&lt;p&gt;Angular就使用了这个库, 在它之上建立了ngZone这个模块. 就这样angular在发生异步操作后进行到了变化检测.&lt;/p&gt;
&lt;p&gt;浏览器里面主要有这几种异步操作: dom事件, ajax请求, 定时回调之类的.&lt;/p&gt;
&lt;p&gt;回到项目里的app.error-handler.ts:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180309210825572-557876267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这句话呢就跑出了angular zone的范围...&lt;/p&gt;
&lt;p&gt;所以当错误发生的时候, toastr的error方法被调用了(状态改变了), 但是angular并不知道这个变化, 所以toastr通知没有显示.&lt;/p&gt;
&lt;p&gt;那如何解决呢?&lt;/p&gt;
&lt;p&gt;使用ngZone:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
import { ErrorHandler, Injectable, Injector, Inject, NgZone } from '@angular/core'&lt;span&gt;;
import { ToastrService, Toast } from &lt;/span&gt;'ngx-toastr'&lt;span&gt;;

@Injectable()
export class AppErrorHandler implements ErrorHandler {

    constructor(
        private injector: Injector,
        &lt;strong&gt;private ngZone: NgZone&lt;/strong&gt;
    ) { }

    private get toastr(): ToastrService {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.injector.get(ToastrService);
    }

    handleError(error: any): &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;strong&gt;&lt;span&gt;this&lt;/span&gt;.ngZone.run(() =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.toastr.error('发生了错误'&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;);
        });&lt;/strong&gt;
    }
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面试试页面:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180309211327654-1587486952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次没有任何问题了.&lt;/p&gt;

&lt;p&gt;您可以自己写一个后台api来记录日志, 但是这里我介绍一个专门做logging的云服务, &lt;strong&gt;sentry.io&lt;/strong&gt;. &lt;a href=&quot;https://sentry.io/&quot; target=&quot;_blank&quot;&gt;https://sentry.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先请您自己注册账户. &lt;/p&gt;
&lt;p&gt;然后创建一个项目, 选择angular:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180309211904065-341030640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后点击下面按钮Create Project.&lt;/p&gt;
&lt;p&gt;然后它给出了安装和配置的说明:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180309212012221-1610994030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先执行命令安装.&lt;/p&gt;
&lt;p&gt;然后, 配置:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;import * as Raven from 'raven-js'&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;;&lt;/strong&gt;
import { BrowserModule } from &lt;/span&gt;'@angular/platform-browser'&lt;span&gt;;
import { NgModule, ErrorHandler } from &lt;/span&gt;'@angular/core'&lt;span&gt;;
import { AppComponent } from &lt;/span&gt;'./app.component'&lt;span&gt;;

&lt;strong&gt;Raven
  .config(&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;'https://&lt;span&gt;fa66d9390ab04c7f8e8c82ad0613fb4e@sentry.io/301095&lt;/span&gt;'&lt;span&gt;)
  .install();
&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;
@NgModule({
  imports: [ BrowserModule ],
  declarations: [ AppComponent ],
  bootstrap: [ AppComponent ],
  providers: [ { provide: ErrorHandler, useClass: AppErrorHandler } ]
})
export class AppModule { }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照说明进行配置, 我们做一些调整, 这里红色部分是每个用户都不一样都.&lt;/p&gt;
&lt;p&gt;最后修改app.error-handler.ts:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
import { ErrorHandler, Injectable, Injector, Inject, NgZone } from '@angular/core'&lt;span&gt;;
import { ToastrService, Toast } from &lt;/span&gt;'ngx-toastr'&lt;span&gt;;
&lt;strong&gt;import &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;* as Raven from 'raven-js'&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;;&lt;/strong&gt;

@Injectable()
export class AppErrorHandler implements ErrorHandler {

    constructor(
        private injector: Injector,
        private ngZone: NgZone
    ) { }

    private get toastr(): ToastrService {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.injector.get(ToastrService);
    }

    handleError(error: any): &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; {
        &lt;strong&gt;Raven.captureException(error);
        &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ngZone.run(() =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.toastr.error('发生了错误'&lt;span&gt;);
        });
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回到浏览器的错误页面, 触发错误后, 大约几分钟后, 来到sentry.io网站查看:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180309213531826-1752346126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180309213428462-1962752471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201803/986268-20180309213450061-749570193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;今天先写到这, 明天后天写以下 angular5上传文件到asp.net core web api.&lt;/p&gt;
</description>
<pubDate>Fri, 09 Mar 2018 13:38:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/8536350.html</dc:identifier>
</item>
<item>
<title>winform自动更新程序实现 - OMango</title>
<link>http://www.cnblogs.com/OMango/p/8509436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/OMango/p/8509436.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、问题背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　本地程序在实际项目使用过程中，因为可以操作电脑本地的一些信息，并且对于串口、OPC、并口等数据可以方便的进行收发，虽然现在软件行业看着动不动都是互联网啊啥的，大有Web服务就是高大上的感觉，但是作为本地的应用还是有着非常重要的位置，特别是在制造业工厂里，车间里相关的程序。&lt;/p&gt;
&lt;p&gt;　　抛开一切业务上的功能不谈，本地程序一直比较诟病的地方就是在于软件的更新上，由于程序都在客户端电脑上运行，当需要更新的时候，就不得不由专门的实施人员过去，部署更新，无形中增加项目成本，SO，对于c/s程序的自动更新也是比较苦恼的问题，下面我就来稍微解析下，一个自动更新程序应该要怎么实现（&lt;strong&gt;PS：思路可能比较传统，欢迎大家拍砖提供更好的思路&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、自动更新的关注点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201803/465472-20180308231424807-828174153.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如图所示，对于一个自动更新程序，关注点应该都是以上几个点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;管理员权限，在win7以后，如果应用位置在C盘的话，每次操作目录都会申请管理员权限，emmmm，所以这个必须要考虑&lt;/li&gt;
&lt;li&gt;对于要实现一个较为通用的自动更新，应该要安装了.NetFrameWork的都要可以使用，并且方便使用&lt;/li&gt;
&lt;li&gt;更新程序同时要只能启动一个，不然肯定出事儿，虽然很少有会有人去点2次，但是还是要考虑&lt;/li&gt;
&lt;li&gt;界面要求上，更新说明以及进度条要显示&lt;/li&gt;
&lt;li&gt;很多时候可能我们也是需要一个静默更新的操作&lt;/li&gt;
&lt;li&gt;运行更新的时候，记得要关闭运行的程序，不然肯定更新失败&lt;/li&gt;
&lt;li&gt;对于更新失败，得有完善的回滚以及备份机制&lt;/li&gt;
&lt;li&gt;更新成功后，得可以启动对应的主程序&lt;/li&gt;
&lt;li&gt;有些 时候程序部分信息是记录在注册表里，如果注册表要修改咋办呢，so，对于注册表也得要支持&lt;/li&gt;
&lt;li&gt;有些时候程序更新到后面，会出现一些多余的DLL，这些DLL那也是要干掉滴（虽然觉得有点鸡肋）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　大概就是以上的一些点，这些是我自己思考的时候罗列出来的，可能比较乱，大家明白就好&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、设计说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201803/465472-20180308231140689-177075180.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　更新程序主要流程如图所示，大的流程方向上是比较简单的，但是如果深入后，还是有部分会比较复杂&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201803/465472-20180308234359134-829299039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　程序类的一些简单说明&lt;/p&gt;
&lt;p&gt;　　config.update：注册表的增删规则以及文件的删除规则，如下规则所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[regedit_del] //删除注册表
SOFTWARE\\XXX\\XXX,name
[regedit_add]//新增注册表
SOFTWARE\\XXX\\XXXX,name=John Doe 
[file_del] //删除文件
hello.dll
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Server.xml&amp;amp;RemoteInfo.cs：服务端的版本配置文件信息&lt;/p&gt;
&lt;p&gt;　　Local.xml&amp;amp;LocalInfo.cs：客户端的版本配置文件信息&lt;/p&gt;
&lt;p&gt;　　UpdateWork.cs：核心的更新方法，为了方便后续有界面定制化的需求，将更新相关的全部放在UpdateWork中，使用UpdateWork.Do方法就可以进行更新&lt;/p&gt;
&lt;p&gt;--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　一些细节说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、&lt;strong&gt;如何让程序尽量的方便集成？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　由于自动更新程序必须是要与主程序分开的，所以我们要让主程序启动更新程序的时候，将主程序自己的信息带进去，这样才可以尽可能的做到通用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 应用程序的主入口点。&lt;br/&gt;　　　　 /// &amp;lt;param name=&quot;args&quot;&amp;gt;[0]程序名称，[1]静默更新 0：否 1：是&amp;lt;/param&amp;gt;　
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        [STAThread]
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (f)
            {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (String.IsNullOrEmpty(args[&lt;span&gt;0&lt;/span&gt;]) == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
                    {
                        UpdateWork updateWork &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; UpdateWork(args[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (updateWork.UpdateVerList.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                        {
                            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 当前用户是管理员的时候，直接启动应用程序 
                             * 如果不是管理员，则使用启动对象启动程序，以确保使用管理员身份运行 
                             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得当前登录的Windows用户标示 &lt;/span&gt;
                            System.Security.Principal.WindowsIdentity identity =&lt;span&gt; System.Security.Principal.WindowsIdentity.GetCurrent();
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Windows用户主题 &lt;/span&gt;
&lt;span&gt;                            Application.EnableVisualStyles();
                            System.Security.Principal.WindowsPrincipal principal &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Security.Principal.WindowsPrincipal(identity);
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断当前登录用户是否为管理员 &lt;/span&gt;
                            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (principal.IsInRole(System.Security.Principal.WindowsBuiltInRole.Administrator))
                            {
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args[&lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                                {
                                    updateWork.Do();
                                }
                                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                {
                                    Application.EnableVisualStyles();
                                    Application.SetCompatibleTextRenderingDefault(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                                    Application.Run(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MainForm(updateWork));
                                }
                            }
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                            {
                                String result &lt;/span&gt;= Environment.GetEnvironmentVariable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;systemdrive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (AppDomain.CurrentDomain.BaseDirectory.Contains(result))
                                {
                                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建启动对象 &lt;/span&gt;
                                    ProcessStartInfo startInfo = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProcessStartInfo
                                    {
                                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置运行文件 &lt;/span&gt;
                                        FileName =&lt;span&gt; System.Windows.Forms.Application.ExecutablePath,
                                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置启动动作,确保以管理员身份运行 &lt;/span&gt;
                                        Verb = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;runas&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

                                        Arguments &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; + args[&lt;span&gt;0&lt;/span&gt;] + &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; + args[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
                                    };
                                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是管理员，则启动UAC &lt;/span&gt;
&lt;span&gt;                                    System.Diagnostics.Process.Start(startInfo);
                                }
                                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                {
                                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args[&lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                                    {
                                        updateWork.Do();
                                    }
                                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                    {
                                        Application.EnableVisualStyles();
                                        Application.SetCompatibleTextRenderingDefault(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                                        Application.Run(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MainForm(updateWork));
                                    }
                                }
                            }
                        }
                    }
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
                {
                    MessageBox.Show(ex.Message);
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　winform在启动的main方法里，有一个参数是args，这就是我们可以接收来自外界的参数，从代码中可以看到，总共传递进来的参数有2个，args[0]程序名称 args[1] 静默安装的配置信息,通过这2个参数，我们就可以将自动更新与主程序分开&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2、更新前备份&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 备份当前的程序目录信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; UpdateWork Bak()
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {

                LogTool.AddLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新程序：准备执行备份操作&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                DirectoryInfo di &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DirectoryInfo(AppDomain.CurrentDomain.BaseDirectory);
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; di.GetFiles())
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (item.Name != mainName)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前文件不需要备份&lt;/span&gt;
&lt;span&gt;                    {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (item.Name == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DotNetZip.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                        {
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        {
                            File.Copy(item.FullName, bakPath &lt;/span&gt;+ item.Name, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                        }
                    }
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件夹复制&lt;/span&gt;
                &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; di.GetDirectories())
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (item.Name != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bak&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;amp;&amp;amp; item.Name != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;temp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    {
                        CopyDirectory(item.FullName, bakPath);
                    }
                }
                LogTool.AddLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新程序：备份操作执行完成,开始关闭应用程序&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                OnUpdateProgess&lt;/span&gt;?.Invoke(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception EX)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; EX;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于自动更新来说，如果更新失败的话，我们需要保证，程序是可回滚的，那就需要在更新前要对程序进行一个备份，如代码所示，由于我这边用到了DotNetZip.dll，所以这个dll是不能备份的，不然恢复的时候由于自动更新程序还在跑，覆盖的时候会报错，上述代码逻辑还是很简单的，拷贝当前运行程序下的所有文件以及文件夹到备份目录（&lt;strong&gt;ps：由于windows的安全限制，c盘目录普通用户只有对temp文件夹有操作权限，so需要将bakPath设置到temp目录下，如下代码所示&lt;/strong&gt;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
String bakPath = Path.Combine(Environment.GetEnvironmentVariable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TEMP&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;MAutoUpdate\bak\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);//获取temp文件夹下的bak目录，如果不存在记得通过程序去创建
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　3、更新文件的下载&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 下载方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; UpdateWork DownLoad()
        {&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt; (WebClient web = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WebClient())
            {
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; UpdateVerList)
                {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                    {
                        LogTool.AddLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新程序：下载更新包文件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; item.ReleaseVersion);
                        web.DownloadFile(item.ReleaseUrl, tempPath &lt;/span&gt;+ item.ReleaseVersion + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.zip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        OnUpdateProgess&lt;/span&gt;?.Invoke(&lt;span&gt;60&lt;/span&gt; /&lt;span&gt; UpdateVerList.Count);
                    }
                    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
                    {
                        LogTool.AddLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新程序：更新包文件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + item.ReleaseVersion + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;下载失败,本次停止更新，异常信息：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message);
                        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
                    }
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　要更新嘛，那当然得有下载，索性.Net给我们提供了一个非常简单的下载玩意儿，WebClient，给url就下载，绝对不二话，WebClient本身也有不少的事件可以使用，这个大家自己摸索，由于更新可能会存在好几个包一起更新的情况，所以这边使用循环先将所有要更新的下载下来，这部分下载代码还是比较简单的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4、更新方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201803/465472-20180308235831183-911505347.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　流程如上图所示，文字表达捉急，只能靠图了，阿门&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt;&lt;span&gt; UpdateWork Update()
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; UpdateVerList)
            {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是覆盖安装的话，先删除原先的所有程序&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (item.UpdateMode == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cover&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    {
                        DelLocal();
                    }
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; path = tempPath + item.ReleaseVersion + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.zip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (ZipFile zip = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ZipFile(path))
                    {
                        LogTool.AddLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新程序：解压&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + item.ReleaseVersion + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.zip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        zip.ExtractAll(AppDomain.CurrentDomain.BaseDirectory, ExtractExistingFileAction.OverwriteSilently);
                        LogTool.AddLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新程序：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + item.ReleaseVersion + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.zip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;解压完成&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                        ExecuteINI();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行注册表等更新以及删除文件&lt;/span&gt;
&lt;span&gt;                    }
                    localInfo.LastUdpate &lt;/span&gt;=&lt;span&gt; item.ReleaseDate;
                    localInfo.LocalVersion &lt;/span&gt;=&lt;span&gt; item.ReleaseVersion;
                    localInfo.SaveXml();
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
                {
                    LogTool.AddLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新程序出现异常：异常信息：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message);
                    LogTool.AddLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新程序：更新失败，进行回滚操作&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    Restore();
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除下载的临时文件&lt;/span&gt;
                    LogTool.AddLog(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新程序：删除临时文件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; item.ReleaseVersion);
                    DelTempFile(item.ReleaseVersion &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.zip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除更新包&lt;/span&gt;
                    LogTool.AddLog(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;更新程序：临时文件删除完成&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; item.ReleaseVersion);
                }
            }
            OnUpdateProgess&lt;/span&gt;?.Invoke(&lt;span&gt;98&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;四、如何在程序中使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　新建winform项目后，在Main里加入以下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 应用程序的主入口点。
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;        [STAThread]
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
        {
            String path &lt;/span&gt;= AppDomain.CurrentDomain.BaseDirectory + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MAutoUpdate.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;同时启动自动更新程序&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (File.Exists(path))
            {
                ProcessStartInfo processStartInfo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProcessStartInfo()
                {
                    FileName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MAutoUpdate.exe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Arguments &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; MAutoUpdate.Test 1&lt;/span&gt;&lt;span&gt;&quot;//1表示静默更新 0表示弹窗提示更新&lt;/span&gt;&lt;span&gt;
                };
                Process proc &lt;/span&gt;=&lt;span&gt; Process.Start(processStartInfo);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (proc != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    proc.WaitForExit();
                }
            }
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            Application.Run(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Form1());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　更新界面图（可以自己改，这个反正很简单），细心的小伙伴们可能发现了，我这是有点魔方微信的图（ps：也是看了微信的升级后，突然想到我们项目里目前为止比较纠结的自动更新，所以趁着这几个晚上捣鼓出来）&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201803/465472-20180309000458453-125473296.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/465472/201803/465472-20180309000505966-2088377564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　花了大概三个晚上的时间捣鼓这个，里面其实考虑的因素还是很多，以前思考的时候不会深入思考，想着自动更新么 就是判断、更新启动结束，但是做下来，细节点真的是很多，后续可能会在公司内部项目里进行一个小的推广，看看符不符合真实的需求，&lt;strong&gt;由于个人原因，在测试上可能会有所不够，这个也是一个抛砖引玉，如果有小伙伴有更好更方便的升级方式，也请告知（ps:文字表达弱鸡，大家多多包涵）&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 　　项目地址：&lt;a href=&quot;https://github.com/Hello-Mango/MAutoUpdate&quot; target=&quot;_blank&quot;&gt;https://github.com/Hello-Mango/MAutoUpdate&lt;/a&gt;，代码比较乱，见谅&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;作者： Mango&lt;/p&gt;
&lt;p&gt;出处： &lt;a href=&quot;http://www.cnblogs.com/OMango/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/OMango/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于自己：专注.Net桌面开发以及Web后台开发，开始接触微服务、docker等互联网相关（最近被互联网架构搞的死去活来- -）&lt;/p&gt;
&lt;p&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接，如有问题， 可站内信告知.&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Mar 2018 13:01:00 +0000</pubDate>
<dc:creator>OMango</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/OMango/p/8509436.html</dc:identifier>
</item>
<item>
<title>MySQL定时备份数据库 - letcafe</title>
<link>http://www.cnblogs.com/gdyblog/p/mysqlautodump.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gdyblog/p/mysqlautodump.html</guid>
<description>&lt;h2&gt;1.1、 mysqldump命令备份数据&lt;/h2&gt;
&lt;p&gt;在MySQL中提供了命令行导出数据库数据以及文件的一种方便的工具&lt;strong&gt;mysqldump&lt;/strong&gt;,我们可以通过命令行直接实现数据库内容的导出dump,首先我们简单了解一下mysqldump命令用法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#MySQLdump常用
mysqldump &lt;/span&gt;-u root -p --databases 数据库1 数据库2 &amp;gt; xxx.sql
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.2、 mysqldump常用操作示例&lt;/h2&gt;
&lt;p&gt;1.备份全部数据库的数据和结构&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysqldump -uroot -p123456 -A &amp;gt; /data/mysqlDump/mydb.sql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.备份全部数据库的结构（加 -d 参数）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysqldump -uroot -p123456 -A -d &amp;gt; /data/mysqlDump/mydb.sql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.备份全部数据库的数据(加 -t 参数)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysqldump -uroot -p123456 -A -t &amp;gt; /data/mysqlDump/mydb.sql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.备份单个数据库的数据和结构(,数据库名mydb)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysqldump -uroot-p123456 mydb &amp;gt; /data/mysqlDump/mydb.sql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.备份单个数据库的结构&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysqldump -uroot -p123456 mydb -d &amp;gt; /data/mysqlDump/mydb.sql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.备份单个数据库的数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysqldump -uroot -p123456 mydb -t &amp;gt; /data/mysqlDump/mydb.sql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7.备份多个表的数据和结构（数据，结构的单独备份方法与上同）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysqldump -uroot -p123456 mydb t1 t2 &amp;gt; /data/mysqlDump/mydb.sql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8.一次备份多个数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysqldump -uroot -p123456 --databases db1 db2 &amp;gt; /data/mysqlDump/mydb.sql
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.3、 还原mysql备份内容&lt;/h2&gt;
&lt;p&gt;有两种方式还原，第一种是在MySQL命令行中，第二种是使用SHELL行完成还原&lt;/p&gt;
&lt;p&gt;1.在系统命令行中，输入如下实现还原：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysql -uroot -p123456 &amp;lt; /data/mysqlDump/mydb.sql
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.在登录进入mysql系统中,通过source指令找到对应系统中的文件进行还原：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; source /data/mysqlDump/mydb.sql
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在linux中，通常使用&lt;strong&gt;BASH&lt;/strong&gt;脚本对需要执行的内容进行编写，加上定时执行命令&lt;strong&gt;crontab&lt;/strong&gt;实现日志自动化生成。&lt;/p&gt;
&lt;p&gt;以下代码功能就是针对mysql进行备份，配合crontab，实现备份的内容为近一个月（31天）内的每天的mysql数据库记录。&lt;/p&gt;
&lt;h2&gt;2.1、 编写BASH维护固定数量备份文件&lt;/h2&gt;
&lt;p&gt;在Linux中，使用vi或者vim编写脚本内容并命名为：mysql_dump_script.sh&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;bash

#保存备份个数，备份31天数据
number&lt;/span&gt;=&lt;span&gt;31&lt;/span&gt;&lt;span&gt;
#备份保存路径
backup_dir&lt;/span&gt;=/root/&lt;span&gt;mysqlbackup
#日期
&lt;/span&gt;&lt;span&gt;dd&lt;/span&gt;=`&lt;span&gt;date&lt;/span&gt; +%Y-%m-%d-%H-%M-%&lt;span&gt;S`
#备份工具
tool&lt;/span&gt;=&lt;span&gt;mysqldump
#用户名
username&lt;/span&gt;=&lt;span&gt;root
#密码
password&lt;/span&gt;=&lt;span&gt;TankB214
#将要备份的数据库
database_name&lt;/span&gt;=&lt;span&gt;edoctor

#如果文件夹不存在则创建
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; [ ! -&lt;span&gt;d $backup_dir ]; 
&lt;/span&gt;&lt;span&gt;then&lt;/span&gt;     
    &lt;span&gt;mkdir&lt;/span&gt; -&lt;span&gt;p $backup_dir; 
&lt;/span&gt;&lt;span&gt;fi&lt;/span&gt;&lt;span&gt;

#简单写法  mysqldump &lt;/span&gt;-u root -p123456 users &amp;gt; /root/mysqlbackup/users-&lt;span&gt;$filename.sql
$tool &lt;/span&gt;-u $username -p$password $database_name &amp;gt; $backup_dir/$database_name-$&lt;span&gt;dd&lt;/span&gt;&lt;span&gt;.sql

#写创建备份日志
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create $backup_dir/$database_name-$dd.dupm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; $backup_dir/&lt;span&gt;log.txt

#找出需要删除的备份
delfile&lt;/span&gt;=`&lt;span&gt;ls&lt;/span&gt; -l -crt  $backup_dir&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.sql | awk '{print $9 }' | head -1`

#判断现在的备份数量是否大于$number
count=`ls -l -crt  $backup_dir/*.sql | awk '{print $9 }' | wc -l`

if [ $count -gt $number ]
then
  #删除最早生成的备份，只保留number数量的备份
  rm $delfile
  #写删除文件日志
  echo &quot;delete $delfile&quot; &amp;gt;&amp;gt; $backup_dir/log.txt
fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码主要含义如下：&lt;/p&gt;
&lt;p&gt;1.首先设置各项参数，例如number最多需要备份的数目，备份路径，用户名，密码等。&lt;/p&gt;
&lt;p&gt;2.执行mysqldump命令保存备份文件，并将操作打印至同目录下的log.txt中标记操作日志。&lt;/p&gt;
&lt;p&gt;3.定义需要删除的文件：通过ls命令获取第九列，即文件名列，再通过&lt;/p&gt;

&lt;p&gt;实现定义操作时间最晚的那个需要删除的文件。&lt;/p&gt;
&lt;p&gt;4.定义备份数量：通过ls命令加上&lt;/p&gt;

&lt;p&gt;统计以sql结尾的文件的行数。&lt;/p&gt;
&lt;p&gt;5.如果文件超出限制大小，就删除最早创建的sql文件&lt;/p&gt;
&lt;h2&gt;2.2、 使用crontab定期执行备份脚本&lt;/h2&gt;
&lt;p&gt;在LINUX中，周期执行的任务一般由cron这个守护进程来处理[ps -ef|grep cron]。cron读取一个或多个配置文件，这些配置文件中包含了命令行及其调用时间。&lt;br/&gt;cron的配置文件称为“crontab”，是“cron table”的简写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、cron服务&lt;/strong&gt;&lt;br/&gt;　　cron是一个linux下 的定时执行工具，可以在无需人工干预的情况下运行作业。&lt;br/&gt;　　service crond start    //启动服务&lt;br/&gt;　　service crond stop     //关闭服务&lt;br/&gt;　　service crond restart  //重启服务&lt;br/&gt;　　service crond reload   //重新载入配置&lt;br/&gt;　　service crond status   //查看服务状态 &lt;/p&gt;
&lt;h3&gt;二、crontab语法&lt;/h3&gt;
&lt;p&gt;crontab命令用于安装、删除或者列出用于驱动cron后台进程的表格。用户把需要执行的命令序列放到crontab文件中以获得执行。每个用户都可以有自己的crontab文件。/var/spool/cron下的crontab文件不可以直接创建或者直接修改。该crontab文件是通过crontab命令创建的。&lt;br/&gt;在crontab文件中如何输入需要执行的命令和时间。该文件中每行都包括六个域，其中前五个域是指定命令被执行的时间，最后一个域是要被执行的命令。&lt;br/&gt;每个域之间使用空格或者制表符分隔。格式如下： &lt;br/&gt;minute hour day-of-month month-of-year day-of-week commands &lt;br/&gt;合法值 00-59 00-23 01-31 01-12 0-6 (0 is sunday) &lt;br/&gt;除了数字还有几个个特殊的符号就是&quot;*&quot;、&quot;/&quot;和&quot;-&quot;、&quot;,&quot;，*代表所有的取值范围内的数字，&quot;/&quot;代表每的意思,&quot;/5&quot;表示每5个单位，&quot;-&quot;代表从某个数字到某个数字,&quot;,&quot;分开几个离散的数字。&lt;/p&gt;&lt;p&gt;-l 在标准输出上显示当前的crontab。 &lt;br/&gt;-r 删除当前的crontab文件。 &lt;br/&gt;-e 使用VISUAL或者EDITOR环境变量所指的编辑器编辑当前的crontab文件。当结束编辑离开时，编辑后的文件将自动安装。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、创建cron脚本&lt;/strong&gt;&lt;br/&gt;第一步：写cron脚本文件,命名为mysqlRollBack.cron。&lt;br/&gt;15,30,45,59 * * * * echo &quot;xgmtest.....&quot; &amp;gt;&amp;gt; xgmtest.txt  表示，每隔15分钟，执行打印一次命令 &lt;br/&gt;第二步：添加定时任务。执行命令 “crontab crontest.cron”。搞定 &lt;br/&gt;第三步：&quot;crontab -l&quot; 查看定时任务是否成功或者检测/var/spool/cron下是否生成对应cron脚本&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：这操作是直接替换该用户下的crontab，而不是新增&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定期执行编写的定时任务脚本（&lt;span&gt;记得先给shell脚本执行权限&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; * * * /root/mysql_backup_script.&lt;span&gt;sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;随后使用crontab命令定期指令编写的定时脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
crontab mysqlRollback.cron
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再通过命令检查定时任务是否已创建：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
crontab -l
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;附crontab的使用示例：&lt;/p&gt;
&lt;p&gt;1.每天早上6点 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0&lt;/span&gt; &lt;span&gt;6&lt;/span&gt; * * * &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Good morning.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; /tmp/test.txt &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意单纯echo，从屏幕上看不到任何输出，因为cron把任何输出都email到root的信箱了。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.每两个小时 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0&lt;/span&gt; */&lt;span&gt;2&lt;/span&gt; * * * &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Have a break now.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; /tmp/test.txt  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.晚上11点到早上8点之间每两个小时和早上八点 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;-&lt;span&gt;7&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;，&lt;span&gt;8&lt;/span&gt; * * * &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Have a good dream&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; /tmp/test.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;4.每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0&lt;/span&gt; &lt;span&gt;11&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; * &lt;span&gt;1&lt;/span&gt;-&lt;span&gt;3&lt;/span&gt; command line
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;5.1月1日早上4点 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;0&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; * command line SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果出现错误，或者有数据输出，数据作为邮件发给这个帐号 HOME=/ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;6.每小时执行/etc/cron.hourly内的脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;01&lt;/span&gt; * * * * root run-parts /etc/cron.hourly
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;7.每天执行/etc/cron.daily内的脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;02&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; * * * root run-parts /etc/cron.daily 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8.每星期执行/etc/cron.weekly内的脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; * * &lt;span&gt;0&lt;/span&gt; root run-parts /etc/cron.weekly 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;9.每月去执行/etc/cron.monthly内的脚本 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; * * root run-parts /etc/cron.monthly 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;注意: &quot;run-parts&quot;这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是文件夹名。 　 &lt;/p&gt;&lt;p&gt;10.每天的下午4点、5点、6点的5 min、15 min、25 min、35 min、45 min、55 min时执行命令。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;5&lt;/span&gt;，&lt;span&gt;15&lt;/span&gt;，&lt;span&gt;25&lt;/span&gt;，&lt;span&gt;35&lt;/span&gt;，&lt;span&gt;45&lt;/span&gt;，&lt;span&gt;55&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;，&lt;span&gt;17&lt;/span&gt;，&lt;span&gt;18&lt;/span&gt; * * * command
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;11.每周一，三，五的下午3：00系统进入维护状态，重新启动系统。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;00&lt;/span&gt; &lt;span&gt;15&lt;/span&gt; * * &lt;span&gt;1&lt;/span&gt;，&lt;span&gt;3&lt;/span&gt;，&lt;span&gt;5&lt;/span&gt; shutdown -r +&lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;12.每小时的10分，40分执行用户目录下的innd/bbslin这个指令： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;10&lt;/span&gt;，&lt;span&gt;40&lt;/span&gt; * * * * innd/bbslink
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;13.每小时的1分执行用户目录下的bin/account这个指令： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; * * * * bin/account
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以下是我的测试每分钟的截图效果，其对应代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
* * * * * /root/mysql_backup_script.&lt;span&gt;sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946524/201803/946524-20180309202837822-2083849497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的log.txt记录备份的操作详细日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/946524/201803/946524-20180309203027986-1051426928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;本文参考：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.MySQLdump常用命令：&lt;a href=&quot;https://www.cnblogs.com/smail-bao/p/6402265.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/smail-bao/p/6402265.html&lt;/a&gt; （博客园）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.利用Shell脚本实现对mysql数据库的备份：&lt;a href=&quot;https://www.cnblogs.com/mracale/p/7251292.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/mracale/p/7251292.html&lt;/a&gt;（博客园）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3.Linux下的Crontab定时执行任务命令详解：&lt;a href=&quot;https://www.cnblogs.com/longjshz/p/5779215.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/longjshz/p/5779215.html&lt;/a&gt;（博客园）&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 09 Mar 2018 12:43:00 +0000</pubDate>
<dc:creator>letcafe</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gdyblog/p/mysqlautodump.html</dc:identifier>
</item>
<item>
<title>编写第一个Flutter App（翻译） - 天天_byconan</title>
<link>http://www.cnblogs.com/tiantianbyconan/p/8535972.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiantianbyconan/p/8535972.html</guid>
<description>&lt;p&gt;博客搬迁至&lt;a href=&quot;http://blog.wangjiegulu.com&quot; class=&quot;uri&quot;&gt;http://blog.wangjiegulu.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;RSS订阅：&lt;a href=&quot;http://blog.wangjiegulu.com/feed.xml&quot; class=&quot;uri&quot;&gt;http://blog.wangjiegulu.com/feed.xml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下代码 Github 地址：&lt;a href=&quot;https://github.com/wangjiegulu/flutter_test_01&quot; class=&quot;uri&quot;&gt;https://github.com/wangjiegulu/flutter_test_01&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;0.9375&quot;&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://flutter.io/get-started/codelab/&quot; class=&quot;uri&quot;&gt;https://flutter.io/get-started/codelab/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个你创建第一个Flutter app的指南。如果你熟悉面向对象的代码，基本的编程概念，比如变量，循环，和条件，你就可以完成本教程。你不需要之前有Dart或者手机的编程经验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你将构建什么&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你将要实现一个简单的手机 app，为一个初创公司去生成一些推荐的名字。用户可以选择和取消选择这些名字，并保存最好的一些名字。代码一次生成10个名字。当用户滚动时，新的一批名字就会被生成。用户可以点击 app bar 右上角的按钮进入一个新的页面来仅展示被喜欢的名字。&lt;/p&gt;
&lt;p&gt;Gif 动图展示了 app 完成之后的运行效果。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://flutter.io/get-started/codelab/images/startup-namer-app.gif&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;你将学到什么&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Flutter app 的基础结构。&lt;/li&gt;
&lt;li&gt;查询和使用包来扩展特性。&lt;/li&gt;
&lt;li&gt;使用热重载来实现快速的开发周期。&lt;/li&gt;
&lt;li&gt;怎么去实现一个 stateful widget 。&lt;/li&gt;
&lt;li&gt;怎么去创建一个无限，懒加载的列表。&lt;/li&gt;
&lt;li&gt;怎么去创建和导航到第二个页面。&lt;/li&gt;
&lt;li&gt;怎么去使用 Theme 来改变 app 的外观。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;你将使用什么&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Flutter SDK：Flutter SDK 包括 Flutter 的引擎，framework， widget ，工具和 Dart SDK。这个 codelab 需要 v0.1.4 或者更新。&lt;/li&gt;
&lt;li&gt;Android Studio IDE：这个 codelab 具备 Android Studio IDE，但是你也可以使用其它的 IDE，或者使用命令行工作。&lt;/li&gt;
&lt;li&gt;你的 IDE 插件：你的 IDE 上面必须分别安装 Flutter 和 Dart 插件。除了 Android Studio，Flutter 和 Dart 插件在 &lt;a href=&quot;https://code.visualstudio.com/download&quot;&gt;VS Code&lt;/a&gt; 和 &lt;a href=&quot;https://www.jetbrains.com/idea/download/#section=mac&quot;&gt;IntelliJ&lt;/a&gt; IDE。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于怎么搭建你的环境，可以在  查看更多信息。&lt;/p&gt;

&lt;h2 id=&quot;第1步创建启动-flutter-app&quot;&gt;第1步：创建启动 Flutter app&lt;/h2&gt;
&lt;p&gt;根据 &lt;a href=&quot;https://flutter.io/get-started/test-drive/#create-app&quot;&gt;开始你的第一个 Flutter app&lt;/a&gt; 的介绍，创建一个简单，模版的 Flutter app。给项目取名为 &lt;strong&gt;startup_namer&lt;/strong&gt; (替换掉 &lt;em&gt;myapp&lt;/em&gt;)。您将修改这个 app 来创建完成的 app。&lt;/p&gt;
&lt;p&gt;在这个 codelab 中，你主要编辑 dart 代码存放处的 &lt;strong&gt;lib/main.dart&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;当复制代码到你的 app 中，缩进可能会歪斜。你可以使用 Flutter 工具来自动修正它们：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Android Studio / IntelliJ IDEA: 在 dart 代码上右键并选择 &lt;strong&gt;Reformat Code with dartfmt&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;VS Code: 右键并选择 &lt;strong&gt;Format Document&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Ternimal: 运行 flutter format 。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;替换 lib/main.dart。&lt;/p&gt;
&lt;p&gt;删除 &lt;strong&gt;lib/main.dart&lt;/strong&gt; 中的所有代码。使用下面的代码进行替换，它会在屏幕的中央展示 &quot;Hello World&quot;。&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;import 'package:flutter/material.dart';

void main() =&amp;gt; runApp(new MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return new MaterialApp(
      title: 'Welcome to Flutter',
      home: new Scaffold(
        appBar: new AppBar(
          title: new Text('Welcome to Flutter'),
        ),
        body: new Center(
          child: new Text('Hello World'),
        ),
      ),
    );
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;运行App，你将会看到如下的屏幕&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div&gt;&lt;img src=&quot;https://flutter.io/get-started/codelab/images/hello-world-screenshot.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;观察&quot;&gt;观察&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;这个例子创建了一个 Material app。&lt;a href=&quot;https://material.io/guidelines/&quot;&gt;Material&lt;/a&gt; 是手机和 web 上的标准的设计语言。Flutter 提供了丰富的 Material widget 。&lt;/li&gt;
&lt;li&gt;main 方法制定了一个宽箭头（&lt;code&gt;=&amp;gt;&lt;/code&gt;）标志，这是一行函数或者方法的简写。&lt;/li&gt;
&lt;li&gt;App 继承了 StatelessWidget，这使得 app 本身称为了一个 widget。在 Flutter 中，几乎所有一切都是 widget，包括 alignment, padding, 和 layout。&lt;/li&gt;
&lt;li&gt;Material 库中的 Scaffold，提供了一个默认的 app bar，title，和一个 body 属性，它持有了主页面的 widget 树。widget 的子树可能相当复杂。&lt;/li&gt;
&lt;li&gt;Widget 的主要的工作是提供一个 &lt;code&gt;build()&lt;/code&gt; 方法，它描述了如何根据其他较低级别的 widget 显示 widget。&lt;/li&gt;
&lt;li&gt;这个例子中的 widget 树的构成是一个中心的 widget 包含了一个文本的子 child widget。中心 widget 将它的 widget 子树对齐到屏幕的中心。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;第2步使用外部包&quot;&gt;第2步：使用外部包&lt;/h2&gt;
&lt;p&gt;在这一步，我将使用一个名为 &lt;strong&gt;english_words&lt;/strong&gt; 的开源包，它包含了几千个最常用的英文单词和常用的工具方法。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;https://pub.dartlang.org/flutter/&quot;&gt;pub.dartlang.org&lt;/a&gt;，你可以找到 &lt;a href=&quot;https://pub.dartlang.org/packages/english_words&quot;&gt;english_words&lt;/a&gt;，以及很多其它的开源包。&lt;/p&gt;
&lt;ol readability=&quot;15.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;pubspec 文件为 Flutter app 管理 assets。在 &lt;strong&gt;pubspec.yaml&lt;/strong&gt;，增加 &lt;strong&gt;english_words&lt;/strong&gt; (3.1.0或者更高) 到依赖列表。新增行在下面已被高亮：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode yaml&quot;&gt;
&lt;code class=&quot;sourceCode yaml&quot;&gt;&lt;span class=&quot;fu&quot;&gt;dependencies:&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;flutter:&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;sdk:&lt;/span&gt; flutter

&lt;span class=&quot;fu&quot;&gt;cupertino_icons:&lt;/span&gt; ^0.1.0
&lt;span class=&quot;fu&quot;&gt;english_words:&lt;/span&gt; ^3.1.0&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;在 Android Studio’s editor 视图查看 pubspec，点击右上角的 &lt;strong&gt;Packages get&lt;/strong&gt;。这会把包拉取到你的项目中。你会在控制台上看到以下信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flutter packages get
Running &quot;flutter packages get&quot; in startup_namer...
Process finished with exit code 0&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;在 &lt;strong&gt;lib/main.dart&lt;/strong&gt;，增加一个 &lt;code&gt;english_words&lt;/code&gt; 的导入，就如高亮展示的那样：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;import 'package:flutter/material.dart';
import 'package:english_words/english_words.dart';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于你的输入，Android Studio 针对库会给你一些导入的建议。然后将导入字符串呈现为灰色，让你知道倒入的库你没有使用它（目前为止）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;使用 English words 包生成文本，用来替换掉之前的 &quot;Hello World&quot; 字符串。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&quot;Pascal case&quot; （也称为 “大驼峰式命名法”），表示字符串中的每个单词，包括第一个单词，首字母大写。所以，“uppercamelcase” 就变成 “UpperCamelCase”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;做以下改变，如下面高亮处：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;import 'package:flutter/material.dart';
import 'package:english_words/english_words.dart';

void main() =&amp;gt; runApp(new MyApp());

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final wordPair = new WordPair.random();
    return new MaterialApp(
      title: 'Welcome to Flutter',
      home: new Scaffold(
        appBar: new AppBar(
          title: new Text('Welcome to Flutter'),
        ),
        body: new Center(
          //child: new Text('Hello World'), // Replace the highlighted text...
          child: new Text(wordPair.asPascalCase),  // With this highlighted text.
        ),
      ),
    );
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果 app 正在运行中，使用热重载按钮（&lt;img src=&quot;https://flutter.io/get-started/codelab/images/hot-reload-button.png&quot;/&gt;）来更新运行中的 app。每一次你点击了热重载，或者保存了项目，你将会看见不同的词对，它在运行的 app 中是随机的。这是因为词对在 build 方法中被生成。在每次 MaterialApp 需要渲染或者在 Flutter Inspector 中切换平台的时候。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div&gt;&lt;img src=&quot;https://flutter.io/get-started/codelab/images/step2-screenshot.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;问题&quot;&gt;问题？&lt;/h3&gt;
&lt;p&gt;如果你的 app 没有正确运行，排查错误。如果需要，请使用以下链接的代码来追踪。&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;State&lt;em&gt;less&lt;/em&gt; widget 是不可改变的，意味着它们的属性不能被修改 —— 所有值都是 final 的。&lt;/p&gt;
&lt;p&gt;State&lt;em&gt;ful&lt;/em&gt; widgets 维护了状态，它可能会在 widget 的生命周期内被修改。实现一个 statful widget 需要两个类：1）一个 StatefulWidget 类，用来创建一个实例 2）一个 State 类。StatefulWidget 类本身是不可变的，但 State 类在整个 widget 的生命周期中保持不变。&lt;/p&gt;
&lt;p&gt;在这一步中，你将会增加一个 stateful widget，RandomWords，增加它的 State class，RandomWordsState。State 类中将最终维护这个 widget 中推荐喜欢的词对。&lt;/p&gt;
&lt;ol readability=&quot;15&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;增加 stateful RandomWords widget 到你的 main.dart 中。它可以被放在任何地方，甚至 MyApp 之外，但是这里的解决方案放在了文件的底部。RandomWords widget 除了创建它的 State 类没有什么特别的。&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;class RandomWords extends StatefulWidget {
  @override
  createState() =&amp;gt; new RandomWordsState();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;增加 RandomWordsState 类。app 的大部分代码将会写在这个类中，它维护拉这个 widget 中的 state。这个类会保存生成的词对，会被用户无限滚动，用户通过列表切换中的心图标来添加或删除它们。&lt;/p&gt;
&lt;p&gt;你将逐步编写这个类。作为开始，通过以下高亮的文本来创建一个最小的 class：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;class RandomWordsState extends State&amp;lt;RandomWords&amp;gt; {
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;在增加了 state class 之后，IDE 警告这个类缺少一个 build 方法。然后，你将增加一个基本的 build 方法通过从 MyApp 转移生成词对的代码到 RandomWordsState 来生成词对：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;class RandomWordsState extends State&amp;lt;RandomWords&amp;gt; {
  @override
  Widget build(BuildContext context) {
    final wordPair = new WordPair.random();
    return new Text(wordPair.asPascalCase);
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;通过以下高亮改变，从 MyApp 中移除生成词对的代码：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final wordPair = new WordPair.random();  // Delete this line

    return new MaterialApp(
      title: 'Welcome to Flutter',
      home: new Scaffold(
        appBar: new AppBar(
          title: new Text('Welcome to Flutter'),
       ),
        body: new Center(
          //child: new Text(wordPair.asPascalCase), // Change the highlighted text to...
          child: new RandomWords(), // ... this highlighted text
        ),
      ),
    );
  }
}    &lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;重启 app，如果你尝试去热重载，你可能会看到一个警告：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Reloading...
Not all changed program elements ran during view reassembly; consider
restarting.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这可能是误报，但考虑重新启动以确保你的更改反映在 app UI 中。&lt;/p&gt;
&lt;p&gt;app 应该会跟以前一样，每次你热重载或者保存的时候展示一个词对。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://flutter.io/get-started/codelab/images/step3-screenshot.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;问题-1&quot;&gt;问题？&lt;/h3&gt;
&lt;p&gt;如果你的 app 没有正确运行，排查错误。如果需要，请使用以下链接的代码来追踪。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;第4步创建一个无限滚动的-listview&quot;&gt;第4步：创建一个无限滚动的 ListView&lt;/h2&gt;
&lt;p&gt;在这一步，你将扩展 RandomWordsState 来生成和展示一个列表的词对。当用户滚动时，展示在 ListView widget 的列表会无限滚动。ListView 的 &lt;code&gt;builder&lt;/code&gt; factory 构造方法允许你根据需要实现懒加载。&lt;/p&gt;
&lt;ol readability=&quot;31.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;在 RandomWordsState 类中增加一个 &lt;code&gt;_suggestions&lt;/code&gt; list 来保存推荐的词对。注意变量以下划线（&lt;code&gt;_&lt;/code&gt;）开头。在 Dart 语言中，以下划线作为前缀标志代表私有。&lt;/p&gt;
&lt;p&gt;也增加一个 &lt;code&gt;biggerFont&lt;/code&gt; 变量来使字体变大。&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;class RandomWordsState extends State&amp;lt;RandomWords&amp;gt; {
  final _suggestions = &amp;lt;WordPair&amp;gt;[];

  final _biggerFont = const TextStyle(fontSize: 18.0);
  ...
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;25&quot;&gt;
&lt;p&gt;在 RandomWordsState 类中增加一个 &lt;code&gt;_buildSuggestions()&lt;/code&gt; 方法。这个方法构建展示词对的 ListView。&lt;/p&gt;
&lt;p&gt;ListView 类提供了一个 builder 属性，&lt;code&gt;itemBuilder&lt;/code&gt;，以匿名方法的方式指定一个工厂构造器和回调方法。两个参数会被传入到方法中 —— BuildContext，和行迭代器，&lt;code&gt;i&lt;/code&gt;。迭代器从0开始，每一次方法被调用时递增，每个推荐词对配对一次。这个模型允许在用户滚动时推荐列表无限滚动。&lt;/p&gt;
&lt;p&gt;增加以下高亮行：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;class RandomWordsState extends State&amp;lt;RandomWords&amp;gt; {
  ...
  Widget _buildSuggestions() {
    return new ListView.builder(
      padding: const EdgeInsets.all(16.0),
      // The itemBuilder callback is called, once per suggested word pairing,
      // and places each suggestion into a ListTile row.
      // For even rows, the function adds a ListTile row for the word pairing.
      // For odd rows, the function adds a Divider widget to visually
      // separate the entries. Note that the divider may be difficult
      // to see on smaller devices.
      itemBuilder: (context, i) {
        // Add a one-pixel-high divider widget before each row in theListView.
        if (i.isOdd) return new Divider();

        // The syntax &quot;i ~/ 2&quot; divides i by 2 and returns an integer result.
        // For example: 1, 2, 3, 4, 5 becomes 0, 1, 1, 2, 2.
        // This calculates the actual number of word pairings in the ListView,
        // minus the divider widgets.
        final index = i ~/ 2;
        // If you've reached the end of the available word pairings...
        if (index &amp;gt;= _suggestions.length) {
          // ...then generate 10 more and add them to the suggestions list.
          _suggestions.addAll(generateWordPairs().take(10));
        }
        return _buildRow(_suggestions[index]);
      }
    );
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;_buildSuggestions&lt;/code&gt; 方法在每个词配对时调用。这个方法在一个 ListTile 中展示一个新的配对，在下一步中它允许你在行中增加交互。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;RandomWordsState&lt;/code&gt; 中增加一个 &lt;code&gt;_buildRow&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;class RandomWordsState extends State&amp;lt;RandomWords&amp;gt; {
  ...

  Widget _buildRow(WordPair pair) {
    return new ListTile(
      title: new Text(
        pair.asPascalCase,
        style: _biggerFont,
      ),
    );
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;使用 &lt;code&gt;_buildSuggestions()&lt;/code&gt; 来更新 RandomWordsState 的 build 方法，而不是直接调用生成词对的库。修改以下高亮改变：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;class RandomWordsState extends State&amp;lt;RandomWords&amp;gt; {
  ...
  @override
  Widget build(BuildContext context) {
    final wordPair = new WordPair.random(); // Delete these two lines.
    Return new Text(wordPair.asPascalCase);
    return new Scaffold (
      appBar: new AppBar(
        title: new Text('Startup Name Generator'),
      ),
    body: _buildSuggestions(),
    );
  }
  ...
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;更新 MyApp 的 build 方法。在 MyApp 中移除 Scaffold 和 AppBar 实例。这些应该由 RandomWordsState 去管理，这让在下一步中导航到另一个页面时修改 app bar 的名字更简单。&lt;/p&gt;
&lt;p&gt;用下面高亮的 build 方法替换原生的方法：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return new MaterialApp(
      title: 'Startup Name Generator',
      home: new RandomWords(),
    );
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;重启 app，你将看到一个词对列表。按你想要的去滚动列表，你会看到新的词对。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://flutter.io/get-started/codelab/images/step4-screenshot.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;问题-2&quot;&gt;问题？&lt;/h3&gt;
&lt;p&gt;如果你的 app 没有正确运行，排查错误。如果需要，请使用以下链接的代码来追踪。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;第5步增加交互&quot;&gt;第5步：增加交互&lt;/h2&gt;
&lt;p&gt;在这一步，你将在没行增加一个可点击的心型图标。当用户点击 list 中的每行时，切换它的 “喜欢” 状态，这会触发词对在保存的集合中增加或者删除。&lt;/p&gt;
&lt;ol readability=&quot;18&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;在 RandomWordsState 中增加一个 &lt;code&gt;_saved&lt;/code&gt; 集合。这个集合存储了用户喜欢了的词对。集合首选 List，因为正确的实现是 Set 不允许重复的条目。&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;class RandomWordsState extends State&amp;lt;RandomWords&amp;gt; {
  final _suggestions = &amp;lt;WordPair&amp;gt;[];

  final _saved = new Set&amp;lt;WordPair&amp;gt;();

  final _biggerFont = const TextStyle(fontSize: 18.0);
  ...
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在 &lt;code&gt;_buildRow&lt;/code&gt; 方法中，增加一个 &lt;code&gt;alreadySaved&lt;/code&gt; 检查来确保词对是否已经添加到喜欢集合中了。&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;Widget _buildRow(WordPair pair) {
  final alreadySaved = _saved.contains(pair);
  ...
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;在 &lt;code&gt;_buildRow()&lt;/code&gt;，增加一个心型的图标到 ListTile 来启用喜欢状态。稍后，你会在这个心型图标上增加一个交互。&lt;/p&gt;
&lt;p&gt;增加以下高亮：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;Widget _buildRow(WordPair pair) {
  final alreadySaved = _saved.contains(pair);
  return new ListTile(
    title: new Text(
      pair.asPascalCase,
      style: _biggerFont,
    ),
    trailing: new Icon(
      alreadySaved ? Icons.favorite : Icons.favorite_border,
      color: alreadySaved ? Colors.red : null,
    ),
  );
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;重启 app，现在你会看到每行都有心型图标，但是它们还不能交互。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;在 &lt;code&gt;_buildRow&lt;/code&gt; 方法中让心形图标可点击。如果一个词对已经被添加到喜欢集合，再次点击会从喜欢集合中删除。当心形图标被点击，调用&lt;code&gt;setState()&lt;/code&gt;方法来通知系统状态被改变。&lt;/p&gt;
&lt;p&gt;增加高亮行：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;Widget _buildRow(WordPair pair) {
  final alreadySaved = _saved.contains(pair);
  return new ListTile(
    title: new Text(
      pair.asPascalCase,
      style: _biggerFont,
    ),
    trailing: new Icon(
      alreadySaved ? Icons.favorite : Icons.favorite_border,
      color: alreadySaved ? Colors.red : null,
    ),
    onTap: () {
      setState(() {
        if (alreadySaved) {
          _saved.remove(pair);
        } else {
          _saved.add(pair);
        }
      });
    },
  );
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;在 Flutter 响应式风格框架中，调用 &lt;strong&gt;setState()&lt;/strong&gt; 触发 State 对象的 &lt;strong&gt;build()&lt;/strong&gt; 方法的调用，结果更新在 UI 中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;热重载 app，你应该会看到点击任意行来喜欢，取消喜欢条目。注意，点击一行会生成从心型图标发出的隐式墨迹飞溅动画。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://flutter.io/get-started/codelab/images/step5-screenshot.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;问题-3&quot;&gt;问题？&lt;/h3&gt;
&lt;p&gt;如果你的 app 没有正确运行，排查错误。如果需要，请使用以下链接的代码来追踪。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;第6步导航到新的页面&quot;&gt;第6步：导航到新的页面&lt;/h2&gt;
&lt;p&gt;在这一步，你将增加一个新的页面（在 Flutter 被称为 &lt;em&gt;router&lt;/em&gt;）用来展示喜欢的集合。你将会学习到怎么从首页导航到一个新的页面。&lt;/p&gt;
&lt;p&gt;在 Fluter，Navigator 管理包含了 app 路由页面的栈。压入一个页面到 Navigator 的栈，更新展示那个页面。从 Navigator 弹出一个页面，返回展示上一个页面。&lt;/p&gt;
&lt;ol readability=&quot;34&quot;&gt;&lt;li readability=&quot;14.5&quot;&gt;
&lt;p&gt;在 RandomWordsState 的 build 方法中增加一个列表图标到 AppBar 上。当用户点击这个列表图标，一个包含了喜欢的条目的新页面被压入到 Navigator，展示图标。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;一些widget属性接收单个 widget（&lt;strong&gt;child&lt;/strong&gt;），其它的属性，如 &lt;strong&gt;action&lt;/strong&gt;，接收一个数组 widgets（&lt;strong&gt;children&lt;/strong&gt;），通过中括号（[]）标明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 build 方法中增加图标和它对应的 action：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;class RandomWordsState extends State&amp;lt;RandomWords&amp;gt; {
  ...
  @override
  Widget build(BuildContext context) {
    return new Scaffold(
      appBar: new AppBar(
        title: new Text('Startup Name Generator'),
        actions: &amp;lt;Widget&amp;gt;[
          new IconButton(icon: new Icon(Icons.list), onPressed: _pushSaved),
        ],
      ),
      body: _buildSuggestions(),
    );
  }
  ...
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;在 RandomWordsState 类中增加一个 &lt;code&gt;_pushSaved()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;class RandomWordsState extends State&amp;lt;RandomWords&amp;gt; {
  ...
  void _pushSaved() {
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;热重载 app，列表图标出现在 app bar 上。点击它还不会发生任何事情，因为 &lt;code&gt;_pushSaved&lt;/code&gt; 方法是空的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;当用户点击 app bar 上的列表图标，构建一个页面并压入 Navigator 的栈中。这个 action 会改变屏幕去展示新的页面。&lt;/p&gt;
&lt;p&gt;新页面的内容在 MaterialPageRoute 的 &lt;code&gt;builder&lt;/code&gt; 属性中通过匿名方法构建。&lt;/p&gt;
&lt;p&gt;增加调用 &lt;code&gt;Navigator.push&lt;/code&gt;，如下高亮代码展示，把页面压入到 Navigator 的栈里。&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;void _pushSaved() {
  Navigator.of(context).push(
  );
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;增加 MaterialPageRoute 和它的 builder。现在，增加生成 ListTile 行的代码。ListTile 的 &lt;code&gt;divideTiles()&lt;/code&gt; 方法在每个 ListTile 之间添加水平间距。分割变量保存最后一行，由 convienice 函数 &lt;code&gt;toList()&lt;/code&gt; 转换为列表。&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;void _pushSaved() {
  Navigator.of(context).push(
    new MaterialPageRoute(
      builder: (context) {
        final tiles = _saved.map(
              (pair) {
            return new ListTile(
              title: new Text(
                pair.asPascalCase,
                style: _biggerFont,
              ),
            );
          },
        );
        final divided = ListTile
            .divideTiles(
          context: context,
          tiles: tiles,
        )
            .toList();
      },
    ),
  );
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;18&quot;&gt;
&lt;p&gt;builder 属性返回一个 Scaffold，包含了新页面的 app bar，名为 “Save Suggestions”。新页面 body 的构成是一个 ListView 包含了 ListTiles 行；每行由分隔符分割。&lt;/p&gt;
&lt;p&gt;增加以下高亮代码：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;void _pushSaved() {
  Navigator.of(context).push(
    new MaterialPageRoute(
      builder: (context) {
        final tiles = _saved.map(
              (pair) {
            return new ListTile(
              title: new Text(
                pair.asPascalCase,
                style: _biggerFont,
              ),
            );
          },
        );
        final divided = ListTile
            .divideTiles(
          context: context,
          tiles: tiles,
        )
            .toList();

        return new Scaffold(
          appBar: new AppBar(
            title: new Text('Saved Suggestions'),
          ),
          body: new ListView(children: divided),
        );
      },
    ),
  );
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;热重载 app，喜欢其中的一些条目并点击 app bar 上的列表图标。新页面展示出来，且包含了喜欢的条目。注意 Navigator 在 app bar 上增加了一个 “Back” 按钮。你不需要明确地实现 Navigator.pop。点击返回按钮来返回首页。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://flutter.io/get-started/codelab/images/step6a-screenshot.png&quot;/&gt;&lt;img src=&quot;https://flutter.io/get-started/codelab/images/step6b-screenshot.png&quot;/&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;问题-4&quot;&gt;问题？&lt;/h3&gt;
&lt;p&gt;如果你的 app 没有正确运行，排查错误。如果需要，请使用以下链接的代码来追踪。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;第7步使用-theme-来改变-ui&quot;&gt;第7步：使用 Theme 来改变 UI&lt;/h2&gt;
&lt;p&gt;在这一步，你将玩转 app 的 theme。&lt;strong&gt;Theme&lt;/strong&gt;会控制你的 app 的视觉和感觉。你可以使用默认的 theme，这依赖于物理设备或者模拟器，或者你可以自定义 theme 来反映出你的品牌。&lt;/p&gt;
&lt;ol readability=&quot;5.8778833107191&quot;&gt;&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;你可以很简单地通过配置 ThemeData 类来改变 app 的主题。你的 app当前使用的是默认的主题，但是你将修改主要颜色为白色。&lt;/p&gt;
&lt;p&gt;通过增加高亮的代码到 MyApop 来改变 app 的主题为白色：&lt;/p&gt;
&lt;pre class=&quot;dart&quot;&gt;
&lt;code&gt;class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return new MaterialApp(
      title: 'Startup Name Generator',
      theme: new ThemeData(
        primaryColor: Colors.white,
      ),
      home: new RandomWords(),
    );
  }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;热重载 app，注意，整个背景都是白色的，甚至是 app bar。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;作为读者的联系，使用 &lt;a href=&quot;https://docs.flutter.io/flutter/material/ThemeData-class.html&quot;&gt;ThemeData&lt;/a&gt; 来改变 UI 的其它方面。Material 库中的 &lt;a href=&quot;https://docs.flutter.io/flutter/material/Colors-class.html&quot;&gt;Colors&lt;/a&gt; 类提供了很多颜色常量可以使用，然后热重载使得 UI 实验变的又快又简单。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://flutter.io/get-started/codelab/images/step7-themes.png&quot;/&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;问题-5&quot;&gt;问题？&lt;/h3&gt;
&lt;p&gt;如果你的 app 没有正确运行，排查错误。如果需要，请使用以下链接的代码来追踪。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;干得不错&quot;&gt;干得不错&lt;/h2&gt;
&lt;p&gt;你已写了一个运行在 iOS 和 Android 的具有交互性的 Flutter app。在这个 codelab，你已经：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从头创建了一个 Flutter app。&lt;/li&gt;
&lt;li&gt;编写 Dart 代码。&lt;/li&gt;
&lt;li&gt;使用外部第三方库。&lt;/li&gt;
&lt;li&gt;使用热重载来进行快速的开发周期。&lt;/li&gt;
&lt;li&gt;实现了 stateful widget，给你的 app 增加了互动性。&lt;/li&gt;
&lt;li&gt;使用 ListView 和 ListTiles 创建了一个懒加载，无限滚动的列表。&lt;/li&gt;
&lt;li&gt;创建了一个页面，且增加了在主页和新的页面之前移动的逻辑。&lt;/li&gt;
&lt;li&gt;学习改变 app 主题外观和主题&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 09 Mar 2018 12:35:00 +0000</pubDate>
<dc:creator>天天_byconan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tiantianbyconan/p/8535972.html</dc:identifier>
</item>
<item>
<title>细说Ajax跨域 - 七月长安</title>
<link>http://www.cnblogs.com/julygift/p/8535450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/julygift/p/8535450.html</guid>
<description>&lt;h2 id=&quot;什么是跨域&quot;&gt;&lt;span&gt;一、什么是跨域&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;　　跨域问题来自于浏览器同源策略的限制，包括DOM同源限制和Ajax同源限制，本文探讨的是Ajax跨域。Ajax跨域指的是一个页面的Ajax只能请求和当前页面同源的数据，如果发现请求到的数据不符合要求，浏览器就会阻止返回的数据。所谓同源，指的是协议、域名、端口号都必须完全相同（同一IP的不同域名也是跨域）。同源策略的主要目的是防止CSRF攻击，它可以有效地避免由于恶意攻击带来的危险，浏览器同源策略使得网络访问更加安全。&lt;/p&gt;
&lt;p&gt;　　但是，实际开发与生产中，常常获取使用来自其他站点的资源，这时候就需要发起跨域请求，也就需要使用特殊的方法来处理，使得我们能够获得想要的数据。由此可知，跨域仅限于浏览器中，是由于浏览器对不同源数据的拦截产生的，跨域有时候是不可避免的，我们需要采取措施实现跨域请求。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、跨域构成条件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;浏览器限制&lt;/strong&gt;&lt;/span&gt;：浏览器本身限制跨域&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;跨域请求&lt;/span&gt;&lt;/strong&gt;：发起的请求是跨域的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;XHR（XMLHttpRequest）类型&lt;/span&gt;&lt;/strong&gt;：请求类型是XHR请求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　由上可知，解决跨域问题可以从上面三个方面着手，只需解决其一，则跨域问题也就不存在了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、跨域问题解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;浏览器限制方式&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　解决浏览器限制的方式可以通过命令：&lt;/p&gt;
&lt;p&gt;　　C:\Program Files (x86)\Google\Chrome\Application\chrome.exe --disable-web-security --user-data-dir=E:\chrome.log来解除浏览器默认的Web安全限制；这里使用chrome浏览器做了解释。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h2 id=&quot;跨域请求的方式&quot;&gt;&lt;span&gt;跨域请求方式&lt;/span&gt;&lt;/h2&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;CORS&quot;&gt;&lt;span&gt;&lt;strong&gt;　　CORS&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　CORS中文是“跨域资源共享”（Cross-origin resource sharing），是W3C支持的一种新的跨域方式，它与其它的方式不同的是，它是写入标准的跨域请求方式，现代浏览器普遍支持。它允许在服务器支持的前提之下，像发起普通ajax请求一样发送跨域请求。除了get请求CORS支持其它种类请求。&lt;/p&gt;
&lt;p&gt;　　CORS请求分为简单请求和非简单请求两种，简单请求需要满足以下两个条件：&lt;/p&gt;
&lt;p&gt;　　　　1）请求方法是以下三种方法之一：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;HEAD&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GET&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;POST&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　　　2）HTTP的头信息不超出以下几种字段：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Accept&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Accept-Language&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Content-Language&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Last-Event-ID&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　除此之外都是复杂请求，对于简单请求和复杂请求浏览器的处理方式不同。&lt;/p&gt;
&lt;p&gt;　　对于简单请求，浏览器会在请求头中添加Origin字段来指明本次请求源，服务器会对发来的请求进行检查，对于符合条件的请求，服务器会在返回头信息中添加&lt;strong&gt;Access-Control-Allow-&lt;/strong&gt;开头的相关字段。&lt;/p&gt;
&lt;p&gt;　　对于非简单请求，正式请求之前会增加一次OPTIONS请求来进行”预检”，此次请求会带上请求源，服务器会校验是否符合条件，如果不符合会返回一个不带任何CORS相关的头信息字段，浏览器就会知道请求不允许，触发错误，停止继续发送请求。&lt;/p&gt;
&lt;p&gt;　　CORS重点就在服务器上，只要配置了允许CORS，就可以正常发送请求，非常方便且安全性好，具体的服务器配置取决于服务端的不同实现。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　服务器代理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这是一种终极的解决方案，因为限制只存在于浏览器中，在其他环境下是不存在的，服务器中自然也不存在，所以只需要在服务器做好请求代理，请求变成同源（请求方式变成同源的请求，但资源依旧是跨域获取的）的自然就不存在问题了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　　　JSONP&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　首先最有名的一种方式就是JSONP，在学习JSONP之前首先要知道虽然浏览器有同源限制，但是有三个标签是不符合这种限制的&lt;code&gt;&amp;lt;img&amp;gt;标签&lt;/code&gt;的src（获取图片）属性，&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;的href（获取css）属性，&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;的src（获取javascript）属性，这是由他们的自身特性所决定的。而JSONP则是利用了script标签不限制同源的特点来实现的、也就是说JSONP发出的不是XHR请求，而是script请求。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;JSONP原理：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.JSONP发送的请求是script请求，区别于XHR请求，不存在跨域的问题。&lt;/p&gt;
&lt;p&gt;　　　　2. 普通的XHR请求返回的是JSON数据对象，JSONP返回的是一个JS脚本。&lt;/p&gt;
&lt;p&gt;　　　　3. 请求URL的不同，请求带有callback字段&lt;/p&gt;
&lt;p&gt;　　清楚了JSONP的原理之后，再看JSONP其实很简单了，下面来看一个简单的小例子。&lt;/p&gt;
&lt;p&gt;　　假设客户端需要获取的JSON数据{code: 200, data: “success”},一个简单的服务端实现如下（使用node.js原生http模块）&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;21&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;23&quot;&gt;
&lt;p&gt;&lt;span class=&quot;keyword&quot;&gt;const http = &lt;span class=&quot;built_in&quot;&gt;require(&lt;span class=&quot;string&quot;&gt;'http');&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;keyword&quot;&gt;const url = &lt;span class=&quot;built_in&quot;&gt;require(&lt;span class=&quot;string&quot;&gt;'url');&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;http.createServer(&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;req, res) =&amp;gt; {&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;keyword&quot;&gt;if (req.url.startsWith(&lt;span class=&quot;string&quot;&gt;'/test')) {&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;res.writeHead(&lt;span class=&quot;number&quot;&gt;200, {&lt;span class=&quot;string&quot;&gt;'Content-Type': &lt;span class=&quot;string&quot;&gt;'text/plain'});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;keyword&quot;&gt;const callback = url.parse(req.url, &lt;span class=&quot;literal&quot;&gt;true).query.callback;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;keyword&quot;&gt;const result = &lt;span class=&quot;string&quot;&gt;'{code: 200, data: &quot;success&quot;}';&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;keyword&quot;&gt;const jsonpCallback = &lt;span class=&quot;string&quot;&gt;`&lt;span class=&quot;subst&quot;&gt;${callback}(&lt;span class=&quot;subst&quot;&gt;${result})`&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;res.end(jsonpCallback);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}).listen(&lt;span class=&quot;number&quot;&gt;8888);&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;客户端的请求如下&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;javascript&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function &lt;span class=&quot;title&quot;&gt;jsonpCallback (&lt;span class=&quot;params&quot;&gt;res) {&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;javascript&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console.log(res);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;undefined&quot;&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script &lt;span class=&quot;attr&quot;&gt;src=&lt;span class=&quot;string&quot;&gt;&quot;http://127.0.0.1:8888/test?callback=jsonpCallback&quot;&amp;gt;&lt;span class=&quot;undefined&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　综合客户端和服务端的代码可以看出，在客户端，通过请求参数传递一个JSONP方法名，在服务器端，返回的结果使用指定的JSONP方法调用来包装，这样相当于请求了一段JS，而真正的返回结果可以通过函数调用参数来获取，这样就可以绕开浏览器同源限制，获取跨域请求结果。&lt;/p&gt;
&lt;p&gt;JSONP是一种常用的跨域方式，目前有很多前端的JSONP请求封装，它们通过通过动态创建script标签来实现，我们可以直接调用。JSONP方式兼容所有的浏览器，但是只支持get请求。&lt;/p&gt;
&lt;h3 id=&quot;jsonp弊端&quot;&gt;　　&lt;span&gt;JSONP弊端&lt;/span&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;服务器端需要改动。&lt;/li&gt;
&lt;li&gt;只支持GET方法。&lt;/li&gt;
&lt;li&gt;发送的不是XHR请求，无法使用各种XHR各种优势。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 09 Mar 2018 11:23:00 +0000</pubDate>
<dc:creator>七月长安</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/julygift/p/8535450.html</dc:identifier>
</item>
</channel>
</rss>