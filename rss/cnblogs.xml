<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>iOS开发证书和配置文件的使用 - 沉江小鱼</title>
<link>http://www.cnblogs.com/chenjiangxiaoyu/p/8284826.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenjiangxiaoyu/p/8284826.html</guid>
<description>&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;之前只是根据网上的流程完成了iOS项目的发布过程，对于证书和配置文件仍是一头雾水，这里参照别人的文章，简单了解一下，毕竟以后用的着。&lt;/p&gt;
&lt;p&gt;这里有几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么是iOS证书，它是如何与app应用关联的？&lt;/li&gt;
&lt;li&gt;iOS开发证书和生产证书有何区别，如何使用的？&lt;/li&gt;
&lt;li&gt;证书与配置文件(Provisioning Profiles)是什么关系，配置文件在Xcode中如何使用？&lt;/li&gt;
&lt;li&gt;证书以及配置文件如何申请？&lt;/li&gt;
&lt;li&gt;什么是Key Pair(公钥/私钥)？如何与证书关联的？&lt;/li&gt;
&lt;li&gt;签名的作用是什么？&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;1. 准备工作：&lt;/h2&gt;
&lt;p&gt;如果想要进行iOS开发，首先要具备下面一些条件：&lt;/p&gt;
&lt;h3&gt;1.1 首先要有苹果开发账号(Apple Developer Acount)&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;只有拥有开发者账号，才能申请开发/发布证书及相应配置文件。&lt;/li&gt;
&lt;li&gt;开发者账号个人或公司开发者账号$99和企业开发者账号$299两种类型。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;1.2 若要进行真机调试，必须至少拥有一台MAC电脑。&lt;/h3&gt;
&lt;h2&gt;2. 登录iOS Dev Center&lt;/h2&gt;
&lt;p&gt;如果已经拥有苹果开发者账号，直接登录苹果开发者中心申请开发证书。&lt;/p&gt;
&lt;p&gt;进入到证书申请界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114213755941-1600701951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面可以看到四个关键东西：Certficates(证书)、Identifiers(标识符)、Devices(设备)、Provisioning Profiles(供应配置文件)，我们分别介绍这四项。&lt;/p&gt;
&lt;h3&gt;2.1 Identifiers（标识符）&lt;/h3&gt;
&lt;p&gt;Identifiers即标识符，相当于身份证，用于创建以下三个ID：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;App IDs&lt;/li&gt;
&lt;li&gt;Pass Type IDs&lt;/li&gt;
&lt;li&gt;Website Push IDs&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;2.1.1 关于App IDs&lt;/h4&gt;
&lt;p&gt;其中，App ID是应用的唯一标识符：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;App ID和Xcode中的Bundle Identifier 是一致(Explicit)的或匹配(Wildcard)。&lt;/li&gt;
&lt;li&gt;App ID字符串通常以反域名(reverse-domain-name)格式的Company Identifier (Company ID) 作为前缀 (Prefix/Seed)，一般不超过255个ASCII字符&lt;/li&gt;
&lt;li&gt;用户可在Developer MemberCenter网站上注册(Register)或删除(Delete)已注册的App IDs。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114214548191-275266573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.1.2 创建App ID&lt;/h4&gt;
&lt;p&gt;在“Identifiers”一栏下选择“App IDs”，可查看所有已申请的App IDs，点击右上“+”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114220547894-1202883151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入Register IOS App ID 界面，在&quot;App ID Description&quot;栏下的“name”项中输入名称&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114220701019-806048122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;填写Bundle ID：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在&quot;Explicit App ID&quot; 栏下的“Bundle ID”项中输入 App ID (反域名格式，如com.company.test)&lt;/li&gt;
&lt;li&gt;这里的“Bundle ID” 对应Xocde的中的“Bundle identifier”&lt;/li&gt;
&lt;li&gt;Explicit App ID ：唯一的App ID，用于唯一标识一个应用程序。例如“com.apple.garageband”这个App ID，用于标识Bundle Identifier为&quot;com.apple.garageband&quot;的app。&lt;/li&gt;
&lt;li&gt;Wildcard App ID：含有通配符的App ID，用于标识一组应程序，例如“com.apple”（实际上是Application Identifier Prefix）表示所有应用程序；而“com.apple.”可以表示Bundle Identifier 以 “com.apple.”开头(苹果公司)的所有应用程序。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114222207363-39584221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&quot;App Services&quot;栏下选择应用要使用到的服务(如果要使用推送功能，勾选“Push Notifications”)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114222743238-498566386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;点击continue - 点击submit - 点击done，申请“App IDs”完成，点击 All IDs可查看申请的ID，点击该ID&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114222903597-2022812368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 Edit 可对该App ID进行编辑。&lt;/p&gt;
&lt;h3&gt;2.2 Certificates&lt;/h3&gt;
&lt;h4&gt;2.2.1 描述&lt;/h4&gt;
&lt;p&gt;iOS证书是用来证明iOS App内容(executable code)的合法性和完整性的数字证书。对于想安装到真机或发布到AppStore的应用程序，只有经过签名验证(Signature Validated)才能确保来源可信，并且保证App内容是完整、未经篡改的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数字证书是一个经证书授权中心数字签名的包含公开密钥拥有者信息已经公开密钥的文件。具有时效性，只在特定的时间段内有效。&lt;/li&gt;
&lt;li&gt;iOS证书分为两种：开发证书和生产证书。开发证书用于开发和调试应用程序，可用于联机调试。生产证书用来发布应用程序。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;2.2.2 生成证书请求文件(CSR)&lt;/h4&gt;
&lt;p&gt;可以通过KeyChain(钥匙串)证书助理从证书颁发机构请求证书。在iOS Dev Center中添加证书(Certificates)时，需要上传CSR文件。&lt;/p&gt;
&lt;p&gt;打开KeyChain(钥匙串)，点击菜单栏“钥匙串访问” - “证书助理” - “从证书颁发机构请求证书”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114223508176-609907064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;填写开发者账号邮件和常用名称，勾选“存储到磁盘”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114223550238-1163292953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续并选择存储位置后，KeyChain将生成一个包含开发者身份信息的CSR(Certificate Signing Request)文件。同时，KeyChain Access - keys（密钥）中增加一对 Public/Private Key Pair。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114223902019-2043325146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;私钥：始终保存在Mac OS的Keychain Access中，用于签名对外发布的App&lt;/li&gt;
&lt;li&gt;公约：一般随证书散步出去，对App签名进行校验认证。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;2.2.3 申请证书&lt;/h4&gt;
&lt;p&gt;进入iOS Dev Cneter，点击&quot;Certificate&quot; - &quot;All&quot;，点击右上角&quot;+&quot;（也可以点击“Certificate”下的“Development”或“Production”，直接选择申请开发证书或生产证书），进入如下界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114224153879-325435236.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择开发证书或者生产证书，这里以生产证书为例，继续：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114224239863-1016249951.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择App ID，即我们在“Identifiers”中创建的App ID，继续：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114224327301-530925463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里介绍的是如何生成证书请求文件，即我们在“2.2.2 生成证书请求文件(CSR)”中生成的.certSigningRequest文件，然后继续：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114224440379-1486003290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要添加的是你生成的证书请求文件(CSR)，“Choose File”选择生成的.certSigningRequest文件，点击&quot;Generate&quot;，如图申请开发证书完成，申请生产证书类似，这里不再赘述。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114224617535-284571569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以点击&quot;Download&quot;下载该开发证书，或者在“Certificates” - All 中查看该证书，并进行下载或删除。&lt;/p&gt;
&lt;p&gt;我们下载证书，然后需要双击 导入 钥匙串(KeyChain Access)，然后就可以在 KeyChain Access - 证书 中查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114224754379-2139833548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;展开安装的证书(ios_development.cer)前面的箭头，可以看到其对应的私钥，在 KeyChainAccess - &quot;密钥&quot;中展开创建CSR时生成的Key Pair中的私钥前面的箭头，就可以查到包含其对应公钥的证书。&lt;/p&gt;
&lt;h4&gt;2.2.4 导出证书&lt;/h4&gt;
&lt;p&gt;打开Keychain Access，选择安装成功的证书，右键选择“导出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114225029004-824253573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入名字，默认格式为.p12类型，选择”save“&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114225102722-454522597.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置密码，点击&quot;OK&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114225129207-944974469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.3 Devices&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Device 是指运行iOS系统用于开发调试App的设备，每台Apple设备使用UDID来唯一标识。&lt;/li&gt;
&lt;li&gt;设备的UDUD获取就不说了&lt;/li&gt;
&lt;li&gt;开发描述文件 (Provisioning Profiles)必须绑定设备，所以在申请开发描述文件之前，必须要添加调试的设备&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;2.3.1 添加调试设备&lt;/h4&gt;
&lt;p&gt;进入iOS Dev Center，”Devices“下选择”All“，可查看所有已添加的设备，点击右上角”+“添加新的调试设备：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114225447082-621007306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入”Name“和 UDID (可在xcode或者itunes中查看)后继续&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114225532019-1784187211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确认信息后，点击注册，完成添加。&lt;/p&gt;
&lt;h3&gt;2.4 Provisioning Profiles&lt;/h3&gt;
&lt;h4&gt;2.4.1 概念&lt;/h4&gt;
&lt;p&gt;Provisioning Profile文件包含了上述所有内容：证书、App ID、设备，后缀名为.mobileprovision&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个Provisioning Profile 对应一个Explicit App ID 或 WildCard App ID.&lt;/li&gt;
&lt;li&gt;Provisioning Profile 决定Xcode用哪个证书(公钥)/私钥组合来签名应用程序，将在应用程序打包时嵌入到.ipa包里&lt;/li&gt;
&lt;li&gt;Provisioning Profile把这些信息全部打包在一起，方便我们在调试和发布程序打包时使用，这样，只要在不同的情况下，选择不同的Provisioning Profile文件就可以了&lt;/li&gt;
&lt;li&gt;Provisioning Profile 也分为 Development 和 Distribution 两类，有效期同 Certificate一样。Development版本的ProvisioningProfile用于开发调试，Distribution版本的ProvisioningProfile主要用于提交App Store审核，其不指定开发测试的Devices.&lt;/li&gt;
&lt;li&gt;xcode 开发时，需在 XcodeTarget - build settings - code signing - provisioning profile 下配置对应的描述文件，然后在code signing identity 下拉可选择 identities from profile 即Provisioning Profile中包含的Certificates&lt;/li&gt;
&lt;li&gt;在XcodeTarget - build setting code signing - provisioning profile 可选择”Automatic“，xcode会根据该Target的”Bundle Identifier“选择默认的配置文件及证书。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114230332410-1020074538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.4.2 创建配置文件&lt;/h4&gt;
&lt;p&gt;打开iOS Dev Center，”Provisioning Profiles“ - all，点击右上角&quot;+&quot;，或直接点击”Development“ 或 ”Production“&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114230455582-1526704388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择开发或发布证书配置文件，这里以开发为例，点击iOS AppDevelopment，继续&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114230543644-265696289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择对应的App ID，继续&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114230612754-1552906122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择要关联的证书，可多选&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114230639410-230352748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择用于调试安装的设备(最多100台设备)，如果是生产证书配置文件，则不会出现该页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114230725926-248193747.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入文件名后，点击&quot;Generate&quot;，配置文件创建成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114230802097-1750366972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击&quot;DownLoad&quot;进行下载。&lt;/p&gt;
&lt;p&gt;如图下载到本地的Provisioning Profile，双击自动安装到Xcode中，在XcodeTarget-&amp;gt;Build Settings-&amp;gt;Code Signing-&amp;gt;Provisioning Profile中可看到此项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1031687/201801/1031687-20180114230905285-193521945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，选择此项配置文件，code signing identity 中会默认显示所关联的证书文件，即创建该配置文件时选择关联的证书，可以有多个，生产证书配置文件与之类似，不再多说。&lt;/p&gt;

</description>
<pubDate>Sun, 14 Jan 2018 15:12:00 +0000</pubDate>
<dc:creator>沉江小鱼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenjiangxiaoyu/p/8284826.html</dc:identifier>
</item>
<item>
<title>一步步教你开发、部署第一个去中心化应用 - 宠物商店 - Tiny熊</title>
<link>http://www.cnblogs.com/tinyxiong/p/8284820.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tinyxiong/p/8284820.html</guid>
<description>&lt;p&gt;今天我们来编写一个完整的去中心化（区块链）应用（Dapps）, 本文可以和&lt;a href=&quot;https://learnblockchain.cn/2017/11/24/init-env/&quot;&gt;编写智能合约&lt;/a&gt;结合起来看。&lt;/p&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;阅读本文前，你应该对以太坊、智能合约有所了解，如果你还不了解，建议你先看&lt;a href=&quot;https://learnblockchain.cn/2017/11/20/whatiseth/&quot;&gt;以太坊是什么&lt;/a&gt;&lt;br/&gt;除此之外，你最好还了解一些HTML及JavaScript知识。&lt;/p&gt;
&lt;p&gt;本文通过实例教大家来开发去中心化应用，应用效果如图：&lt;br/&gt;&lt;img src=&quot;https://learnblockchain.cn/images/Petshop.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从本文，你可以学习到：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;搭建智能合约开发环境&lt;/li&gt;
&lt;li&gt;创建Truffle项目&lt;/li&gt;
&lt;li&gt;编写智能合约&lt;/li&gt;
&lt;li&gt;编译和部署智能合约到区块链&lt;/li&gt;
&lt;li&gt;如何通过Web3和智能合约交互&lt;/li&gt;
&lt;li&gt;MetaMask 的使用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://xiaozhuanlan.com/blockchaincore&quot;&gt;小专栏&lt;/a&gt;用户在教程结尾处可以下载完整的Dapp代码。&lt;/p&gt;
&lt;h2 id=&quot;项目背景&quot;&gt;项目背景&lt;/h2&gt;
&lt;p&gt;Pete有一个宠物店，有16只宠物，他想开发一个去中心化应用，让大家来领养宠物。&lt;br/&gt;在truffle box中，已经提供了pet-shop的网站部分的代码，我们只需要编写合约及交互部分。&lt;/p&gt;
&lt;h2 id=&quot;环境搭建&quot;&gt;环境搭建&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;安装&lt;a href=&quot;https://nodejs.org/en/download/&quot;&gt;Node&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;安装 Truffle ：&lt;code&gt;npm install -g truffle&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;安装&lt;a href=&quot;http://truffleframework.com/ganache/&quot;&gt;Ganache&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Ganache（或Ganache CLI）已经取代了 testrpc。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;创建项目&quot;&gt;创建项目&lt;/h2&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;建立项目目录并进入&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt; mkdir pet-shop-tutorial
&amp;gt; cd pet-shop-tutorial&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用truffle unbox 创建项目&lt;br/&gt;```shell&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;truffle unbox pet-shop&lt;br/&gt;Downloading...&lt;br/&gt;Unpacking...&lt;br/&gt;Setting up...&lt;br/&gt;Unbox successful. Sweet!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Commands:&lt;/p&gt;
&lt;p&gt;Compile: truffle compile&lt;br/&gt;Migrate: truffle migrate&lt;br/&gt;Test contracts: truffle test&lt;br/&gt;Run dev server: npm run dev&lt;br/&gt;```&lt;br/&gt;这一步需要等待一会&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;也可以使用truffle init 来创建一个全新的项目。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;项目目录结构&quot;&gt;项目目录结构&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;contracts/&lt;/code&gt; 智能合约的文件夹，所有的智能合约文件都放置在这里，里面包含一个重要的合约Migrations.sol（稍后再讲）&lt;br/&gt;&lt;code&gt;migrations/&lt;/code&gt; 用来处理部署（迁移）智能合约 ，迁移是一个额外特别的合约用来保存合约的变化。&lt;br/&gt;&lt;code&gt;test/&lt;/code&gt; 智能合约测试用例文件夹&lt;br/&gt;&lt;code&gt;truffle.js/&lt;/code&gt; 配置文件&lt;/p&gt;
&lt;p&gt;其他代码可以暂时不用管&lt;/p&gt;
&lt;h2 id=&quot;编写智能合约&quot;&gt;编写智能合约&lt;/h2&gt;
&lt;p&gt;智能合约承担着分布式应用的后台逻辑和存储。智能合约使用solidity编写，可阅读&lt;br/&gt;[solidity系列文章]（&lt;a href=&quot;https://learnblockchain.cn/categories/ethereum/Solidity/&quot; class=&quot;uri&quot;&gt;https://learnblockchain.cn/categories/ethereum/Solidity/&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;在contracts目录下，添加合约文件Adoption.sol&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;pragma solidity &lt;span class=&quot;op&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.4.17&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

contract Adoption &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;

  address[&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;] &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; adopters&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;// 保存领养者的地址&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 领养宠物&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;adopt&lt;/span&gt;(uint petId) &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;returns&lt;/span&gt; (uint) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(petId &lt;span class=&quot;op&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; petId &lt;span class=&quot;op&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;// 确保id在数组长度内&lt;/span&gt;

    adopters[petId] &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;msg&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;sender&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;co&quot;&gt;// 保存调用这地址 &lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; petId&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;co&quot;&gt;// 返回领养者&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;getAdopters&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; view &lt;span class=&quot;at&quot;&gt;returns&lt;/span&gt; (address[&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;]) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; adopters&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;编译部署智能合约&quot;&gt;编译部署智能合约&lt;/h2&gt;
&lt;p&gt;Truffle集成了一个开发者控制台，可用来生成一个开发链用来测试和部署智能合约。&lt;/p&gt;
&lt;h3 id=&quot;编译&quot;&gt;编译&lt;/h3&gt;
&lt;p&gt;Solidity是编译型语言，需要把可读的Solidity代码编译为EVM字节码才能运行。&lt;br/&gt;dapp的根目录pet-shop-tutorial下，&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt; truffle compile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Compiling ./contracts/Adoption.sol...
Writing artifacts to ./build/contracts&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;部署&quot;&gt;部署&lt;/h3&gt;
&lt;p&gt;编译之后，就可以部署到区块链上。&lt;br/&gt;在migrations文件夹下已经有一个1_initial_migration.js部署脚本，用来部署Migrations.sol合约。&lt;br/&gt;Migrations.sol 用来确保不会部署相同的合约。&lt;/p&gt;
&lt;p&gt;现在我们来创建一个自己的部署脚本&lt;code&gt;2_deploy_contracts.js&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var Adoption = artifacts.require(&quot;Adoption&quot;);

module.exports = function(deployer) {
  deployer.deploy(Adoption);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在执行部署之前，需要确保有一个区块链运行, 可以使用&lt;br/&gt;&lt;a href=&quot;http://truffleframework.com/ganache/&quot;&gt;Ganache&lt;/a&gt;来开启一个私链来进行开发测试，默认会在7545端口上运行一个开发链。&lt;br/&gt;Ganache 启动之后是这样：&lt;br/&gt;&lt;img src=&quot;https://learnblockchain.cn/images/ganache-initial.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来执行部署命令:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;truffle&lt;/span&gt;  migrate&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行后，有一下类似的输出，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Using network 'develop'.

Running migration: 1_initial_migration.js
  Deploying Migrations...
  ... 0x3076b7dac65afc44ec51508bf6f2b6894f833f0f9560ecad2d6d41ed98a4679f
  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0
Saving successful migration to network...
  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956
Saving artifacts...
Running migration: 2_deploy_contracts.js
  Deploying Adoption...
  ... 0x2c6ab4471c225b5473f2079ee42ca1356007e51d5bb57eb80bfeb406acc35cd4
  Adoption: 0x345ca3e014aaf5dca488057592ee47305d9b3e10
Saving successful migration to network...
  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0
Saving artifacts...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在打开的Ganache里可以看到区块链状态的变化，现在产生了4个区块。&lt;br/&gt;&lt;img src=&quot;https://learnblockchain.cn/images/ganache-migrated.png&quot;/&gt;&lt;br/&gt;这时说明已经智能合约已经部署好了。&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;现在我们来测试一下智能合约，测试用例可以用 JavaScript or Solidity来编写，这里使用Solidity。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;test&lt;/code&gt;目录下新建一个&lt;code&gt;TestAdoption.sol&lt;/code&gt;，编写测试合约&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;
pragma solidity &lt;span class=&quot;op&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;fl&quot;&gt;0.4.17&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;truffle/Assert.sol&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;co&quot;&gt;// 引入的断言&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;truffle/DeployedAddresses.sol&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;// 用来获取被测试合约的地址&lt;/span&gt;
&lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;../contracts/Adoption.sol&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;// 被测试合约&lt;/span&gt;

contract TestAdoption &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  Adoption adoption &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Adoption&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;DeployedAddresses&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;Adoption&lt;/span&gt;())&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;co&quot;&gt;// 领养测试用例&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;testUserCanAdoptPet&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    uint returnedId &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;adoption&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;adopt&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    uint expected &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;Assert&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;equal&lt;/span&gt;(returnedId&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; expected&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Adoption of pet ID 8 should be recorded.&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;co&quot;&gt;// 宠物所有者测试用例&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;testGetAdopterAddressByPetId&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 期望领养者的地址就是本合约地址，因为交易是由测试合约发起交易，&lt;/span&gt;
    address expected &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    address adopter &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;adoption&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;adopters&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;Assert&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;equal&lt;/span&gt;(adopter&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; expected&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Owner of pet ID 8 should be recorded.&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 测试所有领养者&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;testGetAdopterAddressByPetIdInArray&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 领养者的地址就是本合约地址&lt;/span&gt;
    address expected &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    address[&lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;] memory adopters &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;adoption&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getAdopters&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;Assert&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;equal&lt;/span&gt;(adopters[&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; expected&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;Owner of pet ID 8 should be recorded.&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Assert.sol 及 DeployedAddresses.sol是Truffle框架提供，在test目录下并不提供truffle目录。&lt;/p&gt;
&lt;p&gt;TestAdoption合约中添加adopt的测试用例&lt;/p&gt;
&lt;h3 id=&quot;运行测试用例&quot;&gt;运行测试用例&lt;/h3&gt;
&lt;p&gt;在终端中，执行&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;truffle&lt;/span&gt; test&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果测试通过，则终端输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Using network 'develop'.

Compiling ./contracts/Adoption.sol...
Compiling ./test/TestAdoption.sol...
Compiling truffle/Assert.sol...
Compiling truffle/DeployedAddresses.sol...


  TestAdoption
    ✓ testUserCanAdoptPet (62ms)
    ✓ testGetAdopterAddressByPetId (53ms)
    ✓ testGetAdopterAddressByPetIdInArray (73ms)


  3 passing (554ms)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建用户接口和智能合约交互&quot;&gt;创建用户接口和智能合约交互&lt;/h2&gt;
&lt;p&gt;我们已经编写和部署及测试好了我们的合约，接下我们为合约编写UI，让合约真正可以用起来。&lt;/p&gt;
&lt;p&gt;在Truffle Box &lt;code&gt;pet-shop&lt;/code&gt;里，已经包含了应用的前端代码，代码在&lt;code&gt;src/&lt;/code&gt;文件夹下。&lt;/p&gt;
&lt;p&gt;在编辑器中打开&lt;code&gt;src/js/app.js&lt;/code&gt;&lt;br/&gt;可以看到用来管理整个应用的App对象，init函数加载宠物信息，就初始化&lt;a href=&quot;https://github.com/ethereum/web3.js/&quot;&gt;web3&lt;/a&gt;.&lt;br/&gt;web3是一个实现了与以太坊节点通信的库，我们利用web3来和合约进行交互。&lt;/p&gt;
&lt;h3 id=&quot;初始化web3&quot;&gt;初始化web3&lt;/h3&gt;
&lt;p&gt;接下来，我们来编辑app.js修改initWeb3():&lt;br/&gt;删除注释，修改为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;  initWeb3&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// Is there an injected web3 instance?&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;typeof&lt;/span&gt; web3 &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'undefined'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;va&quot;&gt;App&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;web3Provider&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;web3&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;currentProvider&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;co&quot;&gt;// If no injected web3 instance is detected, fall back to Ganache&lt;/span&gt;
      &lt;span class=&quot;va&quot;&gt;App&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;web3Provider&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Web3&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;providers&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;HttpProvider&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'http://localhost:7545'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    web3 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Web3&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;App&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;web3Provider&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;App&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;initContract&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码中优先使用&lt;a href=&quot;https://github.com/ethereum/mist&quot;&gt;Mist&lt;/a&gt; 或 &lt;a href=&quot;https://metamask.io/&quot;&gt;MetaMask&lt;/a&gt;提供的web3实例，如果没有则从本地环境创建一个。&lt;/p&gt;
&lt;h3 id=&quot;实例化合约&quot;&gt;实例化合约&lt;/h3&gt;
&lt;p&gt;使用truffle-contract会帮我们保存合约部署的信息，就不需要我们手动修改合约地址，修改initContract()代码如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;initContract&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;co&quot;&gt;// 加载Adoption.json，保存了Adoption的ABI（接口说明）信息及部署后的网络(地址)信息，它在编译合约的时候生成ABI，在部署的时候追加网络信息&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;$&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getJSON&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Adoption.json'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(data) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 用Adoption.json数据创建一个可交互的TruffleContract合约实例。&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; AdoptionArtifact &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; data&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;App&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;contracts&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;Adoption&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;TruffleContract&lt;/span&gt;(AdoptionArtifact)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// Set the provider for our contract&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;App&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;contracts&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;Adoption&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;setProvider&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;App&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;web3Provider&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// Use our contract to retrieve and mark the adopted pets&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;App&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;markAdopted&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;App&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;bindEvents&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;处理领养&quot;&gt;处理领养&lt;/h3&gt;
&lt;p&gt;修改markAdopted()代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;  markAdopted&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(adopters&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; account) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; adoptionInstance&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;App&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;contracts&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;Adoption&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;deployed&lt;/span&gt;().&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(instance) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      adoptionInstance &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; instance&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;co&quot;&gt;// 调用合约的getAdopters(), 用call读取信息不用消耗gas&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;adoptionInstance&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;getAdopters&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;call&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(adopters) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt; (i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;adopters&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (adopters[i] &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'0x0000000000000000000000000000000000000000'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;at&quot;&gt;$&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'.panel-pet'&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;eq&lt;/span&gt;(i).&lt;span class=&quot;at&quot;&gt;find&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'button'&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;text&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Success'&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;attr&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'disabled'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;catch&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(err) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;err&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;message&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改handleAdopt()代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;  handleAdopt&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(event) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;preventDefault&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; petId &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;parseInt&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;$&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;target&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;data&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'id'&lt;/span&gt;))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; adoptionInstance&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;co&quot;&gt;// 获取用户账号&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;web3&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;eth&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getAccounts&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(error&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; accounts) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (error) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(error)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    
      &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; account &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; accounts[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    
      &lt;span class=&quot;va&quot;&gt;App&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;contracts&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;Adoption&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;deployed&lt;/span&gt;().&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(instance) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        adoptionInstance &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; instance&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    
        &lt;span class=&quot;co&quot;&gt;// 发送交易领养宠物&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;adoptionInstance&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;adopt&lt;/span&gt;(petId&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; account&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(result) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;App&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;markAdopted&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;catch&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(err) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;err&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;message&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;在浏览器中运行&quot;&gt;在浏览器中运行&lt;/h2&gt;
&lt;h3 id=&quot;安装-metamask&quot;&gt;安装 MetaMask&lt;/h3&gt;
&lt;p&gt;MetaMask 是一款插件形式的以太坊轻客户端，开发过程中使用MetaMask和我们的dapp进行交互是个很好的选择，通过此&lt;a href=&quot;https://metamask.io/&quot;&gt;链接&lt;/a&gt;安装，安装完成后，浏览器工具条会显示一个小狐狸图标。&lt;/p&gt;
&lt;h3 id=&quot;配置钱包&quot;&gt;配置钱包&lt;/h3&gt;
&lt;p&gt;在接受隐私说明后，会出现页面如下：&lt;br/&gt;&lt;img src=&quot;https://learnblockchain.cn/images/metamask-initial.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们通过还原一个Ganache为我们创建好的钱包，作为我们的开发测试钱包。点击页面的** Import Existing DEN**，输入Ganache显示的助记词。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;candy maple cake sugar pudding cream honey rich smooth crumble sweet treat&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后自己想要的密码，点击OK。&lt;br/&gt;如图：&lt;br/&gt;&lt;img src=&quot;https://learnblockchain.cn/images/metamask-seed.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;连接开发区块链网络&quot;&gt;连接开发区块链网络&lt;/h3&gt;
&lt;p&gt;默认连接的是以太坊主网（左上角显示），选择&lt;strong&gt;Custom RPC&lt;/strong&gt;，添加一个网络：&lt;strong&gt;&lt;a class=&quot;uri&quot;&gt;http://127.0.0.1:7545**，点返回后，显示如下&lt;/a&gt;：&lt;br/&gt;&lt;img src=&quot;http://www.cnblogs.com/images/metamask-account1.png&quot;/&gt;&lt;br/&gt;这是左上角显示为&lt;/strong&gt;Private Network**，账号是Ganache中默认的第一个账号。&lt;/p&gt;
&lt;p&gt;至此MetaMask的安装，配置已经完成。&lt;/p&gt;
&lt;h3 id=&quot;安装和配置lite-server&quot;&gt;安装和配置lite-server&lt;/h3&gt;
&lt;p&gt;接下来需要本地的web 服务器提供服务的访问， Truffle Box &lt;strong&gt;pet-shop&lt;/strong&gt;里提供了一个&lt;strong&gt;lite-server&lt;/strong&gt;可以直接使用，我们看看它是如何工作的。&lt;br/&gt;&lt;strong&gt;bs-config.json&lt;/strong&gt;指示了lite-server的工作目录。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;server&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;&quot;baseDir&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;./src&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;./build/contracts&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;./src 是网站文件目录&lt;br/&gt;./build/contracts 是合约输出目录&lt;/p&gt;
&lt;p&gt;以此同时，在package.json文件的scripts中添加了dev命令：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode json&quot;&gt;
&lt;code class=&quot;sourceCode json&quot;&gt;&lt;span class=&quot;er&quot;&gt;&quot;scripts&quot;:&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;dev&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;lite-server&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;dt&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;echo &lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;Error: no test specified&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\&quot;&lt;/span&gt;&lt;span class=&quot;st&quot;&gt; &amp;amp;&amp;amp; exit 1&quot;&lt;/span&gt;
&lt;span class=&quot;fu&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;,&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当运行npm run dev的时候，就会启动lite-server&lt;/p&gt;
&lt;h3 id=&quot;启动服务&quot;&gt;启动服务&lt;/h3&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;npm&lt;/span&gt; run dev&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会自动打开浏览器显示我们的dapp，如本文的第一张图。&lt;br/&gt;现在领养一直宠物看看，当我们点击&lt;strong&gt;Adopt&lt;/strong&gt;时，MetaMask会提示我们交易的确认，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://learnblockchain.cn/images/metamask-transactionconfirm.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击Submit确认后，就可以看到成功领养了这次宠物。&lt;/p&gt;
&lt;p&gt;在MetaMask中，也可以看到交易的清单：&lt;br/&gt;&lt;img src=&quot;https://learnblockchain.cn/images/metamask-transactionsuccess.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，恭喜你，即将成为一名去中心化式应用开发者的你已经成为迈出了坚实的一步。&lt;br/&gt;如果学习中遇到问题，欢迎来我的&lt;strong&gt;&lt;a href=&quot;https://t.xiaomiquan.com/RfAu7uj&quot;&gt;知识星球&lt;/a&gt;&lt;/strong&gt;交流。&lt;/p&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://learnblockchain.cn/&quot;&gt;深入浅出区块链&lt;/a&gt; - 系统学习区块链，打造最好的区块链技术博客。&lt;/p&gt;
</description>
<pubDate>Sun, 14 Jan 2018 15:09:00 +0000</pubDate>
<dc:creator>Tiny熊</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tinyxiong/p/8284820.html</dc:identifier>
</item>
<item>
<title>VS2017编译SFML SDK配制环境详解 - 疯颠研究者</title>
<link>http://www.cnblogs.com/flowingwind/p/8284579.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flowingwind/p/8284579.html</guid>
<description>


&lt;p&gt;&lt;span&gt;&lt;span&gt;如果您在Visual Studio IDE（Visual C ++编译器）中使用SFML，本教程是第一个应该阅读的教程。&lt;/span&gt;&lt;span&gt;它将解释如何配置您的SFML项目。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;首先，您必须从&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;internal&quot; title=&quot;转到下载页面&quot; href=&quot;https://www.sfml-dev.org/download.php&quot;&gt;&lt;span class=&quot;internal&quot;&gt;&lt;span&gt;&lt;span&gt;下载页面&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;下载SFML SDK &lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;您必须下载与您的Visual C ++版本相匹配的软件包。&lt;/span&gt;&lt;span&gt;事实上，用VC ++ 10（Visual Studio 2010）编译的库不会与VC ++ 12（Visual Studio 2013）兼容。&lt;/span&gt;&lt;span&gt;如果没有为您的Visual C ++版本编译的SFML包，则必须 &lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;internal&quot; title=&quot;如何编译SFML&quot; href=&quot;https://www.sfml-dev.org/tutorials/2.4/compile-with-cmake.php&quot;&gt;&lt;span&gt;&lt;span&gt;自己构建SFML&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;a class=&quot;internal&quot; title=&quot;如何编译SFML&quot; href=&quot;https://www.sfml-dev.org/tutorials/2.4/compile-with-cmake.php&quot;&gt;自己构建SFML方法（如果有自己vs版本&lt;/a&gt;&lt;a class=&quot;internal&quot; title=&quot;如何编译SFML&quot; href=&quot;https://www.sfml-dev.org/tutorials/2.4/compile-with-cmake.php&quot;&gt;SDK&lt;/a&gt;&lt;a class=&quot;internal&quot; title=&quot;如何编译SFML&quot; href=&quot;https://www.sfml-dev.org/tutorials/2.4/compile-with-cmake.php&quot;&gt;可直接下载SDK使用跳过构建，直接看下文vs2017中SML SDK的配制）&lt;/a&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.官网下载SFML Source code 解压到任意路径 本例中放在d:/sfml&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.打开CMake 设置如下①&lt;strong&gt;&lt;span&gt;SFML Source code&lt;strong&gt;&lt;span&gt;路径&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;②工程生成路径③生成&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1309098/201801/1309098-20180114220053363-1882230755.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.第一次选择编译器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1309098/201801/1309098-20180114221742191-1793373910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.选择配制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1309098/201801/1309098-20180114220403160-1909015888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt; 配制说明，一般默认就可以了（建议改下生成路径默认在C：\ Program Files）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;table class=&quot;styled&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;span&gt;&lt;span&gt;变量&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;&lt;span&gt;&lt;span&gt;含义&lt;/span&gt;&lt;/span&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;28.180419781484&quot;&gt;&lt;tr class=&quot;one&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;CMAKE_BUILD_TYPE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;该选项选择构建配置类型。&lt;/span&gt;&lt;span&gt;有效值是“调试”和“释放”（还有其他类型，如“RelWithDebInfo”或“MinSizeRel”，但它们是为了更高级的构建）。&lt;/span&gt;&lt;span&gt;请注意，如果为支持多种配置（如Visual Studio）的IDE生成工作空间，则会忽略此选项，因为工作空间可以同时包含多个配置。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;two&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;这是安装路径。&lt;/span&gt;&lt;span&gt;默认情况下，它被设置为操作系统上最典型的安装路径（Linux和Mac OS X为“/ usr / local”，Windows为“C：\ Program Files”等）。&lt;/span&gt;&lt;span&gt;在构建SFML之后安装SFML并不是强制性的，因为您可以直接从构建它们的地方使用二进制文件。&lt;/span&gt;&lt;span&gt;这可能是一个更好的解决方案，但是，要正确安装它们，以便可以删除构建过程中生成的所有临时文件。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;one&quot; readability=&quot;7&quot;&gt;&lt;td&gt;&lt;code&gt;CMAKE_INSTALL_FRAMEWORK_PREFIX&lt;br/&gt;(Mac OS X only)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;这是框架的安装路径。&lt;/span&gt;&lt;span&gt;默认情况下，它被设置为根库文件夹ie / Library / Frameworks。&lt;/span&gt;&lt;span&gt;正如上面对CMAKE_INSTALL_PREFIX所述，在构建SFML之后并不强制安装SFML，但是这样做肯定是比较干净的。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;如果选择BUILD_FRAMEWORKS，则此路径也用于在系统上安装sndfile框架（Apple不提供所需的依赖项）和SFML作为框架。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;two&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;BUILD_SHARED_LIBS&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;这个布尔选项控制你是否将SFML构建为动态（共享）库，或者是静态的。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;此选项不应与SFML_USE_STATIC_STD_LIBS同时启用，它们是互斥的。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;one&quot; readability=&quot;6.3488372093023&quot;&gt;&lt;td&gt;&lt;code&gt;SFML_BUILD_FRAMEWORKS&lt;br/&gt;(Mac OS X only)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;这个布尔选项控制你是否构建SFML作为 &lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;external&quot; title=&quot;去苹果关于框架的文档&quot; href=&quot;http://developer.apple.com/library/mac/#documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html&quot;&gt;&lt;span&gt;&lt;span&gt;框架捆绑&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt; 或作为 &lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;external&quot; title=&quot;去苹果关于动态库的文档&quot; href=&quot;http://developer.apple.com/library/mac/#documentation/DeveloperTools/Conceptual/DynamicLibraries/000-Introduction/Introduction.html&quot;&gt;&lt;span&gt;&lt;span&gt;dylib二进制文件&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;构建框架需要选择BUILD_SHARED_LIBS。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;建议在发布应用程序时使用SFML作为框架。&lt;/span&gt;&lt;span&gt;但请注意，SFML不能作为框架在调试配置中构建。&lt;/span&gt;&lt;span&gt;在这种情况下，请使用dylib代替。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;two&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;SFML_BUILD_EXAMPLES&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;该布尔选项控制SFML示例是否与库一起构建。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;one&quot; readability=&quot;4.9043715846995&quot;&gt;&lt;td&gt;&lt;code&gt;SFML_BUILD_DOC&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;这个布尔选项控制你是否生成SFML文档。&lt;/span&gt;&lt;span&gt;请注意， &lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;external&quot; title=&quot;去doxygen网站&quot; href=&quot;http://www.doxygen.org/&quot;&gt;&lt;span&gt;&lt;span&gt;Doxygen&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;工具必须安装并可访问，否则启用此选项将产生错误。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;在Mac OS X上，您可以将经典Unix doxygen二进制文件安装到/ usr / bin或任何类似的目录中，或者将Doxygen.app安装到任何“应用程序”文件夹中，例如〜/ Applications。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;two&quot; readability=&quot;7&quot;&gt;&lt;td&gt;&lt;code&gt;SFML_USE_STATIC_STD_LIBS&lt;br/&gt;(Windows only)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;这个布尔选项选择链接到SFML的C / C ++运行时库的类型。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;TRUE静态链接标准库，这意味着SFML是独立的，不依赖于编译器特定的DLL。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;FALSE（缺省值）动态链接标准库，这意味着SFML依赖于编译器的DLL（用于Visual C ++的msvcrxx.dll / msvcpxx.dll，用于GCC的libgcc_s_xxx-1.dll / libstdc ++ - 6.dll）。&lt;/span&gt;&lt;span&gt;设置这个时要小心。&lt;/span&gt;&lt;span&gt;该设置必须符合您自己的项目设置，否则您的应用程序可能无法运行。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;此选项不应与BUILD_SHARED_LIBS同时启用，它们是互斥的。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;one&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;CMAKE_OSX_ARCHITECTURES&lt;br/&gt;(Mac OS X only)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;该设置指定了应该构建SFML的体系结构。&lt;/span&gt;&lt;span&gt;建议的值是“x86_64”，因为不再支持32位版本。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;two&quot; readability=&quot;6&quot;&gt;&lt;td&gt;&lt;code&gt;SFML_INSTALL_XCODE_TEMPLATES&lt;br/&gt;(Mac OS X only)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;这个布尔选项控制CMake是否将Xcode模板安装到你的系统上。&lt;/span&gt;&lt;span&gt;请确保/ Library / Developer / Xcode / Templates / SFML存在并且是可写的。&lt;/span&gt;&lt;span&gt;有关这些模板的更多信息，请参阅Mac OS X的“入门”教程。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;one&quot; readability=&quot;5&quot;&gt;&lt;td&gt;&lt;code&gt;SFML_INSTALL_PKGCONFIG_FILES&lt;br/&gt;(Linux shared libraries only)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;&lt;span&gt;这个布尔选项控制CMake是否将pkg-config文件安装到你的系统上。&lt;/span&gt;&lt;span&gt;pkg-config是一个为查询已安装库提供统一接口的工具。&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;修改改生成SDK的路径&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1309098/201801/1309098-20180114223236269-1950944749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt; 6. 选择Generate   完成后  选Open Project&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;7.生成 SFML SDK&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1309098/201801/1309098-20180114221329379-198120426.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1309098/201801/1309098-20180114221401879-1456598478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 9.在D:/sfml 2.0 文件夹即 是我们生成 的SFML SDK &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;首先要做的是选择要创建的项目类型：您必须选择“Win32应用程序”。&lt;/span&gt;&lt;span&gt;该向导提供了几个选项来定制项目：如果您需要控制台，请选择“控制台应用程序”;如果您不需要，请选择“Windows应用程序”。&lt;/span&gt;&lt;span&gt;如果您不希望被自动生成的代码烦恼，请选中“空项目”框。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;为了本教程的目的，您应该创建一个main.cpp文件并将其添加到项目中，以便我们可以访问C ++设置（否则Visual Studio不知道您将为此项目使用哪种语言）。&lt;/span&gt;&lt;span&gt;稍后我们将解释放入什么内容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在新建项目上右键的打开项目属性：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这些路径在“调试”和“发行版”配置中都是相同的，因此您可以为项目全局设置它们（“所有配置”）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1309098/201801/1309098-20180114223102222-546740292.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1309098/201801/1309098-20180114223415801-1262038053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到此ok！可以在vs2017 中畅玩 SFML SDK库了&lt;/p&gt;

</description>
<pubDate>Sun, 14 Jan 2018 14:41:00 +0000</pubDate>
<dc:creator>疯颠研究者</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flowingwind/p/8284579.html</dc:identifier>
</item>
<item>
<title>iOS学习——UIAlertController详解 - mukekeheart</title>
<link>http://www.cnblogs.com/mukekeheart/p/8275599.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mukekeheart/p/8275599.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　在开发中，弹出提示框是必不可少的。这两天项目中统一对已经被iOS API废弃的&lt;span class=&quot;pagetitle-name&quot;&gt;UIAlertView和&lt;/span&gt;&lt;span class=&quot;pagetitle-name&quot;&gt;UIActionSheet进行替换，我们知道，&lt;span class=&quot;pagetitle-name&quot;&gt;UIAlertView和&lt;span class=&quot;pagetitle-name&quot;&gt;UIActionSheet都已经被iOS的API所废弃了。在两者的API中都建议用UIAlertController替代，并通过设置不同的类型风格来选择是原先的&lt;span class=&quot;pagetitle-name&quot;&gt;UIAlertView或&lt;span class=&quot;pagetitle-name&quot;&gt;UIActionSheet的形式。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　之前项目中一直用的都是原先的&lt;span class=&quot;pagetitle-name&quot;&gt;UIAlertView和&lt;span class=&quot;pagetitle-name&quot;&gt;UIActionSheet风格，所以对UIAlertController的了解很少，这次也借着这次统一项目更新的机会对UIAlertController进行了一番学习和研究。&lt;/span&gt;&lt;/span&gt;UIAlertController是在iOS8.0中出现的一种统一的提示风格的界面，代替原来的&lt;span class=&quot;pagetitle-name&quot;&gt;UIAlertView和&lt;span class=&quot;pagetitle-name&quot;&gt;UIActionSheet两种类别&lt;/span&gt;&lt;/span&gt;。iOS中学习一个新知识最简单便捷的两种方法，一是看官网API，二是看应用示例代码。下面，我们也从这两个方面来学习一下UIAlertController。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　UIAlertController的API很简单，其&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uialertcontroller&quot; target=&quot;_blank&quot;&gt;官网API戳这里&lt;/a&gt;。关于UIAlertController的API也非常简单，所有内容如下图所示。从图中我们可以看到UIAlertController的内容主要分为五个部分：创建对象、配置UIAlertController对象的属性、配置UIAlertController上面的按钮、配置UIAlertController上面的文本框、常量。下面，我们结合实例对这些方法和常量进行学习。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/926487/201801/926487-20180114185602285-1552562535.png&quot; alt=&quot;&quot; width=&quot;422&quot; height=&quot;421&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　UIAlertController提示器的使用分为三步，&lt;span&gt;&lt;strong&gt;创建&lt;/strong&gt;&lt;/span&gt;UIAlertController提示器对象--&amp;gt;&lt;span&gt;配置&lt;/span&gt;UIAlertController提示器上的按钮--&amp;gt;&lt;span&gt;&lt;strong&gt;显示&lt;/strong&gt;&lt;/span&gt;UIAlertController提示器。　　&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;1.1  UIAlertController提示器对象的创建&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　UIAlertController提示器的创建主要是通过类方法来进行创建的，其中第一个参数是标题，第二个参数是内容信息，第三个参数&lt;/span&gt;&lt;span&gt;UIAlertControllerStyle则是选择所创建的UIAlertController对象的类型是UIAlertView 还是 UIActionSheet。UIAlertControllerStyle是一个枚举类型，其定义就是在UIAlertController.h文件中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
+ (instancetype)alertControllerWithTitle:(NSString *)title message:(NSString *)message preferredStyle:(UIAlertControllerStyle)preferredStyle;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;typedef NS_ENUM(NSInteger, UIAlertControllerStyle) {
    UIAlertControllerStyleActionSheet &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
    UIAlertControllerStyleAlert
} NS_ENUM_AVAILABLE_IOS(8_0);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;创建常用代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;UIAlertView风格&lt;/span&gt;
UIAlertController* alert = [UIAlertController alertControllerWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;My Alert&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                               message:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;This is an alert.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                               preferredStyle:UIAlertControllerStyleAlert];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;UIActionSheet风格&lt;/span&gt;
UIAlertController* alert = [UIAlertController alertControllerWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;My Alert&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                               message:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;This is an alert.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                               preferredStyle:UIAlertControllerStyleActionSheet];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.2 UIAlertController提示器的配置&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;在UIAlertController提示器中，我们常用的配置有两类，一是根据需要添加按钮，并味蕾个按钮添加点击事件；二是根据需要添加文本框，用于和用户进行更多的交互。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;1.2.1 UIAlertController上添加按钮&lt;/h3&gt;
&lt;p&gt;&lt;span&gt; 　　UIAlertController上的每一个按钮都是一个UIAlertAction，与UIAlertController的类型是UIAlertView 还是 UIActionSheet无关。UIAlertAction的定义也是就在UIAlertController.h文件中，如下。我们需要在UIAlertController提示器添加一个按钮时，先创建一个UIAlertAction，然后通过UIAlertController的 &lt;span class=&quot;cnblogs_code&quot;&gt;addAction:&lt;/span&gt; 方法将创建的UIAlertAction对象添加就OK了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
NS_CLASS_AVAILABLE_IOS(8_0) &lt;span&gt;@interface&lt;/span&gt; UIAlertAction : NSObject &amp;lt;NSCopying&amp;gt;

+ (instancetype)actionWithTitle:(nullable NSString *)title style:(UIAlertActionStyle)style handler:(&lt;span&gt;void&lt;/span&gt; (^ __nullable)(UIAlertAction *&lt;span&gt;action))handler;

@property (nullable, nonatomic, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;) NSString *&lt;span&gt;title;
@property (nonatomic, &lt;/span&gt;&lt;span&gt;readonly&lt;/span&gt;&lt;span&gt;) UIAlertActionStyle style;
@property (nonatomic, getter&lt;/span&gt;=&lt;span&gt;isEnabled) BOOL enabled;

&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　创建UIAlertAction对象直接用UIAlertAction的类方法就可以创建了，其中第一个参数是按钮的标题；第二个参数&lt;/span&gt;&lt;span&gt;UIAlertActionStyle&lt;/span&gt;&lt;span&gt;是选择按钮的风格类型，有三种选择：常规、取消和销毁风格类型；第三个参数是一个Block，定义了按钮的点击响应事件。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
+ (instancetype)actionWithTitle:(nullable NSString *)title style:(UIAlertActionStyle)style handler:(&lt;span&gt;void&lt;/span&gt; (^ __nullable)(UIAlertAction *action))handler; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　UIAlertActionStyle是一个枚举类型，其定义也是在UIAlertController.h文件中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;typedef NS_ENUM(NSInteger, UIAlertActionStyle) {
    UIAlertActionStyleDefault &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;常规类型，默认蓝色字体&lt;/span&gt;
    UIAlertActionStyleCancel,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消类型，默认蓝色字体     &lt;/span&gt;
    UIAlertActionStyleDestructive &lt;span&gt;//&lt;/span&gt;&lt;span&gt;销毁类型，默认红色字体，表示可能是要删除信息&lt;/span&gt;
} NS_ENUM_AVAILABLE_IOS(8_0);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　常规用法示例如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建对象&lt;/span&gt;
UIAlertController *alert =&lt;span&gt; [UIAlertController alertControllerWithTitle:nil message:nil preferredStyle:UIAlertControllerStyleActionSheet];
   
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加销毁按钮 &lt;/span&gt;
UIAlertAction* destructiveBtn = [UIAlertAction actionWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;销毁按钮&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style:UIAlertActionStyleDestructive handler:^(UIAlertAction *&lt;span&gt; action) {
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;UIAlertActionStyleDestructive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}];
[alert addAction: destructiveBtn];
    
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加默认按钮 &lt;/span&gt;
UIAlertAction* defaultBtn = [UIAlertAction actionWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;常规按钮&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style:UIAlertActionStyleDefault handler:^(UIAlertAction *&lt;span&gt; action) {
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;UIAlertActionStyleDefault&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}];
[alert addAction:albumBtn];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加取消按钮&lt;/span&gt;
UIAlertAction* cancelBtn = [UIAlertAction actionWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;取消按钮&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style:UIAlertActionStyleCancel handler:^(UIAlertAction *&lt;span&gt; action) {
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;UIAlertActionStyleCancel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}];
[alert addAction:cancelBtn];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;1.2.2 UIAlertController上添加文本框&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上面我们讲到了如何在&lt;/span&gt;&lt;span&gt;UIAlertController&lt;/span&gt;&lt;span&gt;提示器上添加按钮，但是有时候，我们需要在提示器上添加一个或多个文本框让用户填写一些信息，在UIAlertController中也提供了一个方法直接可以在提示器上添加文本框。只有一个参数，就是一个Block，用于我们队该文本框进行配置，比喻说其字体大小，行数限制等等，都可以在该Block中进行设置。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;)addTextFieldWithConfigurationHandler:(&lt;span&gt;void&lt;/span&gt; (^)(UITextField *textField))configurationHandler;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;span&gt;常见用法示例如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[alert addTextFieldWithConfigurationHandler:^(UITextField *&lt;span&gt; _Nonnull textField) {
        NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;添加一个textField就会调用 这个block&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;但是，值得注意的有两点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;文本框的添加只能是在UIAlertController的风格类型为UIAlertView时才有&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;文本框的添加多个&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;我们可以看到，在配置文本框这里还有一个参数是textFields，这各参数是一个只读数组类型，用于获取UIAlertController提示器上所有的文本框对象，这个经常在我们点击按钮时用这个来获取到每一个文本框，并取得用户填写的信息。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@property(nonatomic, &lt;span&gt;readonly&lt;/span&gt;) NSArray&amp;lt;UITextField *&amp;gt; *textFields;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 常见用法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
UIAlertController *alert = [UIAlertController alertControllerWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; message:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;message&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; preferredStyle:UIAlertControllerStyleAlert];
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加文本框    &lt;/span&gt;
[alert addTextFieldWithConfigurationHandler:^(UITextField *&lt;span&gt; _Nonnull textField) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置键盘输入为数字键盘&lt;/span&gt;
    textField.keyboardType =&lt;span&gt; UIKeyboardTypeNumberPad;
    textField.placeholder &lt;/span&gt;= &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;请填写&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}];

UIAlertAction &lt;/span&gt;*cancelBtn = [UIAlertAction actionWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;取消&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style:UIAlertActionStyleCancel handler:^(UIAlertAction *&lt;span&gt; _Nonnull action) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消&lt;/span&gt;
&lt;span&gt;}];
[alert addAction: cancelBtn];
    
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加确定按钮&lt;/span&gt;
UIAlertAction *confirmBtn = [UIAlertAction actionWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;确定&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style:UIAlertActionStyleDefault handler:^(UIAlertAction *&lt;span&gt; _Nonnull action) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本框结束编辑，收起键盘&lt;/span&gt;
&lt;span&gt;    [[alertVC.textFields firstObject] endEditing:YES];
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;%@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, [alert.textFields firstObject].text);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取文本框填写的内容    &lt;/span&gt;
    NSString *meetingId =&lt;span&gt; [alertVC.textFields firstObject].text.trim;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(meetingId.length &amp;gt; &lt;span&gt;12&lt;/span&gt;&lt;span&gt;){
        [weakSelf showHUDWithText:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;会议号过长&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        [weakSelf enterVideoMeeting:meetingId];
    }
}];
[alert addAction: confirmBtn];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.3 UIAlertController提示器的显示&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　UIAlertController提示器的显示则很简单，从提示器的类名UIAlertController可以看出，提示器是一个viewController，因此，要显示提示器，我们一般是是当前viewController的 &lt;span class=&quot;cnblogs_code&quot;&gt;presentViewController: animated: completion:&lt;/span&gt; 方法进行推出，我们创建的提示器。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 [self presentViewController:alert animated:YES completion:nil];
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.4 UIAlertController提示器的使用&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;常规使用示例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建对象 &lt;/span&gt;
UIAlertController *alertController = [UIAlertController alertControllerWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;显示的标题&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; message:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;标题的提示信息&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; preferredStyle:UIAlertControllerStyleAlert];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加取消类型按钮&lt;/span&gt;
[alertController addAction:[UIAlertAction actionWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;取消&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style:UIAlertActionStyleCancel handler:^(UIAlertAction *&lt;span&gt; _Nonnull action) {
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;点击取消&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}]];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加常规类型按钮&lt;/span&gt;
[alertController addAction:[UIAlertAction actionWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;确定&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style:UIAlertActionStyleDefault handler:^(UIAlertAction *&lt;span&gt; _Nonnull action) {
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;点击确认&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}]];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加销毁类型按钮&lt;/span&gt;
[alertController addAction:[UIAlertAction actionWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;警告&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style:UIAlertActionStyleDestructive handler:^(UIAlertAction *&lt;span&gt; _Nonnull action) {
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;点击警告&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}]];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加文本框&lt;/span&gt;
[alertController addTextFieldWithConfigurationHandler:^(UITextField *&lt;span&gt; _Nonnull textField) {
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;添加一个textField就会调用 这个block&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示&lt;/span&gt;
[self presentViewController:alertController animated:YES completion:nil];
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　运行的效果图如下图所示，左边是UIAlertView类型的效果图，右边是UIActionSheet类型的效果图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/926487/201801/926487-20180114214031285-2093351621.png&quot; alt=&quot;&quot; width=&quot;285&quot; height=&quot;506&quot;/&gt;   &lt;img src=&quot;http://images2017.cnblogs.com/blog/926487/201801/926487-20180114214058254-1712886878.png&quot; alt=&quot;&quot; width=&quot;284&quot; height=&quot;506&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二 UIAlertController中自定义&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; 　　在一般情况下，我们只要弹出系统自带的弹出框就可以。but，在某些情况下，万恶的UI会要求你修改显示文字的大小、颜色，虽然系统自带有一种红色字体的UIAlertAction，但是这种Action并不能放在Cancel位置，所以，更多时候，需要我们自己修改文字字体和颜色。可是在公开的API接口中好像并没有对应的方法，那么我们应该怎么做呢？主要的方法有两种：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;利用第三方控件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;利用KVC方法进行自定义修改&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;2.1 利用第三方控件进行UIAlertController属性的自定义&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;现在Github上有着众多的Alert控件（如SCLAlertView等），相信有很多都可以满足大家的需求，只要使用Cocoapods添加添加第三方库就可以了。在这里我们就不详细进行介绍了。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2.2 利用KVC方法进行UIAlertController属性的自定义&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　　有时候使用第三方控件会带来很多不必要的代码量和bug，所以能用系统自带的UIAlertController解决是最好的办法，这样当然也是可以的。苹果公司并没有完全的封死对UIAlertController的定制，而是修改为使用KVC的方法进行定制。如果要自定义标题和内容，可以通过NSAttributedString把字体和颜色设置好，然后在通过KVC的方法进行设置，就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
- (&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) test{ 
    UIAlertController &lt;/span&gt;*alertController = [UIAlertController alertControllerWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;提示&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; message:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;提示内容&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; preferredStyle:UIAlertControllerStyleAlert];
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:@&quot;提示内容&quot; preferredStyle:UIAlertControllerStyleActionSheet];  

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改title&lt;/span&gt;
    NSMutableAttributedString *alertControllerStr = [[NSMutableAttributedString alloc] initWithString:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;提示&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
    [alertControllerStr addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)];
    [alertControllerStr addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;] range:NSMakeRange(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)];
    [alertController setValue:alertControllerStr forKey:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;attributedTitle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改message&lt;/span&gt;
    NSMutableAttributedString *alertControllerMessageStr = [[NSMutableAttributedString alloc] initWithString:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;提示内容&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
    [alertControllerMessageStr addAttribute:NSForegroundColorAttributeName value:[UIColor greenColor] range:NSMakeRange(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)];
    [alertControllerMessageStr addAttribute:NSFontAttributeName value:[UIFont systemFontOfSize:&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;] range:NSMakeRange(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;)];
    [alertController setValue:alertControllerMessageStr forKey:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;attributedMessage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;常规按钮&lt;/span&gt;
    UIAlertAction *defaultAction = [UIAlertAction actionWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; style:UIAlertActionStyleDefault handler:nil];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;销毁按钮&lt;/span&gt;
    UIAlertAction *destructiveAction = [UIAlertAction actionWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Destructive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; style:UIAlertActionStyleDestructive handler:nil];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消按钮&lt;/span&gt;
    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Cancel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; style:UIAlertActionStyleCancel handler:nil];
    
    [alertController addAction:defaultAction];
    [alertController addAction:destructiveAction];
    [alertController addAction:cancelAction];
    
    [self presentViewController:alertController animated:YES completion:nil];
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 效果如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/926487/201801/926487-20180114222555785-1814275378.jpg&quot; alt=&quot;&quot; width=&quot;423&quot; height=&quot;333&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;除了可以修改提示器的标题和内容信息的颜色和字号，我们还可以修改按钮控件的颜色和字号，具体方法如下：&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改按钮&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (cancelAction valueForKey:&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;titleTextColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) {
    [cancelAction setValue:[UIColor redColor] forKey:&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;titleTextColor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　效果图如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/926487/201801/926487-20180114222619910-488611573.jpg&quot; alt=&quot;&quot; width=&quot;423&quot; height=&quot;326&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 14 Jan 2018 14:28:00 +0000</pubDate>
<dc:creator>mukekeheart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mukekeheart/p/8275599.html</dc:identifier>
</item>
<item>
<title>.NET Core单文件发布静态编译AOT CoreRT - LineZero</title>
<link>http://www.cnblogs.com/linezero/p/CoreRT.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linezero/p/CoreRT.html</guid>
<description>&lt;p&gt;.NET Core单文件发布静态编译AOT CoreRT，将.NET Core应用打包成一个可执行文件并包含运行时。&lt;/p&gt;
&lt;p&gt;支持Windows, MacOS and Linux x64 w/ RyuJIT codegen。&lt;/p&gt;
&lt;p&gt;示例项目：&lt;/p&gt;
&lt;p&gt;https://github.com/dotnet/corert/tree/master/samples/WebApi&lt;/p&gt;
&lt;p&gt;下面来实际体验。&lt;/p&gt;
&lt;p&gt;首先确保安装C++编译环境，以及.NET Core 2.0 以上版本SDK。&lt;/p&gt;
&lt;h2&gt;新建WebAPI应用&lt;/h2&gt;
&lt;p&gt;打开命令提示符，输入如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;dotnet new webapi -o zeroapi&lt;/p&gt;
&lt;p&gt;cd zeroapi&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新建WebAPI应用。&lt;/p&gt;
&lt;h2&gt;添加CoreRT到项目&lt;/h2&gt;
&lt;p&gt;目前CoreRT还是alpha版，在myget上有包。&lt;/p&gt;
&lt;p&gt;首先添加一个nuget.config&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;dotnet new nuget&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后在 &amp;lt;packageSources&amp;gt; 节点添加如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&amp;lt;add key=&quot;dotnet-core&quot; value=&quot;https://dotnet.myget.org/F/dotnet-core/api/v3/index.json&quot; /&amp;gt;&lt;br/&gt;&amp;lt;add key=&quot;nuget.org&quot; value=&quot;https://api.nuget.org/v3/index.json&quot; protocolVersion=&quot;3&quot; /&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着添加Microsoft.DotNet.ILCompiler包引用：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;dotnet add package Microsoft.DotNet.ILCompiler -v 1.0.0-alpha-*&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;替换默认services并处理反射&lt;/h2&gt;
&lt;p&gt;打开Startup.cs ,将 services.AddMvc(); 替换成 services.AddMvcCore().AddJsonFormatters();&lt;/p&gt;
&lt;p&gt;接着创建一个rd.xml 配置文件，用于反射处理运行时，确保反射程序集编译到程序中。&lt;/p&gt;
&lt;p&gt;rd.xml配置文件如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_695a68db-d9d0-468c-9272-d83ae5135322&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_695a68db-d9d0-468c-9272-d83ae5135322&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_695a68db-d9d0-468c-9272-d83ae5135322&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Directives&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;zeroapi&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Server.Kestrel.Core&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServer&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Server.Kestrel.Core.Internal.KestrelServerOptionsSetup&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Server.Kestrel&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Server.Kestrel.Transport.Libuv&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Server.Kestrel.Transport.Libuv.LibuvTransportFactory&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Server.Kestrel.Transport.Libuv.LibuvTransportOptions&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.DependencyInjection&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.DependencyInjection.DefaultServiceProviderFactory&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteExpressionBuilder&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteRuntimeResolver&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.DependencyInjection.ServiceLookup.CallSiteValidator&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.Options&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.Options.OptionsManager`1[[Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions,Microsoft.AspNetCore.Server.Kestrel.Core]]&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.Options.OptionsFactory`1[[Microsoft.AspNetCore.Server.Kestrel.Core.KestrelServerOptions,Microsoft.AspNetCore.Server.Kestrel.Core]]&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.Options.OptionsMonitor`1[[Microsoft.Extensions.Logging.Console.ConsoleLoggerOptions,Microsoft.Extensions.Logging.Console]]&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Mvc.Core&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Routing&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Routing.Internal.RoutingMarkerService&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Builder.RouterMiddleware&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Routing.Tree.TreeRouteBuilder&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Routing.DefaultInlineConstraintResolver&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Routing.RouteOptions&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Mvc.Formatters.Json&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Mvc.Formatters.Json.Internal.MvcJsonMvcOptionsSetup&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Mvc.MvcJsonOptions&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Authorization&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Authorization.DefaultAuthorizationPolicyProvider&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Authorization.AuthorizationOptions&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Http&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Http.HttpContextFactory&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Hosting&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.AspNetCore.Hosting.Internal.ApplicationLifetime&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.Logging.Abstractions&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.Logging.Logger`1[[Microsoft.AspNetCore.Hosting.Internal.WebHost,Microsoft.AspNetCore.Hosting]]&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.Logging&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.Logging.LoggerFactory&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.Logging.Console&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.Logging.Console.ConsoleLoggerOptions&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.Logging.Console.ConsoleLoggerProvider&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.Logging.Debug&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.Logging.Debug.DebugLogger&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.Logging.Debug.DebugLoggerProvider&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;System.Linq.Expressions&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;System.Linq.Expressions.ExpressionCreator`1[[Newtonsoft.Json.Serialization.ObjectConstructor`1[[System.Object,System.Private.CoreLib]],Newtonsoft.Json]]&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;System.Linq.Expressions.ExpressionCreator`1[[System.Func`2[[System.Object,System.Private.CoreLib],[System.Object,System.Private.CoreLib]],System.Private.CoreLib]]&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.ObjectPool&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.ObjectPool.DefaultObjectPoolProvider&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Newtonsoft.Json&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Newtonsoft.Json.Serialization.ObjectConstructor`1[[System.Object,System.Private.CoreLib]]&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;System.ComponentModel.TypeConverter&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;System.ComponentModel.TypeConverter&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;System.ComponentModel.StringConverter&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;System.ComponentModel.Int32Converter&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Assembly &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.Configuration.Json&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Type &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.Extensions.Configuration.Json.JsonConfigurationSource&quot;&lt;/span&gt;&lt;span&gt; Dynamic&lt;/span&gt;&lt;span&gt;=&quot;Required All&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Assembly&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Application&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Directives&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;其中如果你要替换成自己的程序，更改 &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;Assembly &lt;span class=&quot;pl-e&quot;&gt;Name=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;zeroapi&lt;span class=&quot;pl-pds&quot;&gt;&quot; &lt;span class=&quot;pl-e&quot;&gt;Dynamic=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;Required All&lt;span class=&quot;pl-pds&quot;&gt;&quot; /&amp;gt; 中的Name。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;打开zeroapi.csproj&lt;/p&gt;
&lt;p&gt;在&amp;lt;PropertyGroup&amp;gt;节点下将 &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;RdXmlFile&amp;gt;rd.xml&amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;RdXmlFile&amp;gt; 加入。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接着将 &amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.All&quot; Version=&quot;2.0.3&quot; /&amp;gt; 替换成如下：&lt;/p&gt;
&lt;div&gt;
&lt;blockquote&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore&quot; Version=&quot;2.0.1&quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.Mvc.Core&quot; Version=&quot;2.0.1&quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.Mvc.Formatters.Json&quot; Version=&quot;2.0.1&quot; /&amp;gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;接着将 ValuesController 更改一下，确保功能正常，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController
    {
        [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Hello() =&amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World! LineZero AOT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET api/values&lt;/span&gt;
        [HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/values&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AOT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CoreRT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET api/values/5&lt;/span&gt;
        [HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/values/{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Your value is &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; id;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序改造完成，接着最重要的发布。&lt;/p&gt;
&lt;h2&gt;还原并发布&lt;/h2&gt;
&lt;p&gt;发布之前，使用dotnet run 确保功能正常运行。&lt;/p&gt;
&lt;p&gt;发布请打开 &lt;strong&gt;x64 Native Tools Command Prompt for VS 2017 &lt;/strong&gt;，注意一定在此命令行发布。在开始菜单找到 Visual Studio 2017，打开就能找到。&lt;/p&gt;
&lt;p&gt;发布命令还是  dotnet publish -r &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;RID&lt;span class=&quot;pl-k&quot;&gt;&amp;gt; -c &lt;span class=&quot;pl-k&quot;&gt;&amp;lt;Configuration&lt;span class=&quot;pl-k&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;&lt;span class=&quot;pl-k&quot;&gt;这里发布Windows 64位 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;dotnet publish -r win-x64 -c release，初次的话会默认还原对应的包，需要一些时间。&lt;/p&gt;
&lt;p&gt;发布完成后，打开bin\x64\release\netcoreapp2.0\win-x64\publish 文件夹，里面zeroapi.exe即为最终文件，执行即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/443844/201801/443844-20180114215241722-1628454245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;可以看到最终大小为21m左右。然后访问http://localhost:5000/ 如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/443844/201801/443844-20180114214650738-1545675985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;控制台Demo&lt;/h2&gt;
&lt;p&gt;新建一个控制台应用，使用AOT发布。&lt;/p&gt;
&lt;p&gt;单纯控制台，没有反射的内容，无需要rd.xml 文件。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LineZero AOT Demo！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadKey();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终 dotnet publish -r win-x64 -c release 发布&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/443844/201801/443844-20180114215855363-216339349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终单个文件大小不到4m！&lt;/p&gt;
&lt;p&gt;目前该技术还是早期版本，期待微软最终带到正式版。&lt;/p&gt;
&lt;p&gt;GitHub：https://github.com/dotnet/corert&lt;/p&gt;
</description>
<pubDate>Sun, 14 Jan 2018 14:01:00 +0000</pubDate>
<dc:creator>LineZero</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linezero/p/CoreRT.html</dc:identifier>
</item>
<item>
<title>应用密码学初探 - 一面千人</title>
<link>http://www.cnblogs.com/Evsward/p/cryptography.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Evsward/p/cryptography.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关键字：密码学，密码算法，单向哈希函数，对称加密，非对称加密，数字签名，数字证书，Merkle树，同态加密&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在计算机科学中，密码学常常用来解决某些特定的难题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文件机密性，对于某些需要保密的文件的加密工作。&lt;/li&gt;
&lt;li&gt;鉴别真伪，也叫认证，防止文件被伪造。&lt;/li&gt;
&lt;li&gt;验证完整性，验证文件的完整性，传输中是否有破损。&lt;/li&gt;
&lt;li&gt;信用问题，也即不可抵赖性，这也是区块链要解决的关键问题，对于所有人的信用问题，那些承诺算不算数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;密码学可以细分为密码协议，密码技术以及密码算法，本文不会详尽学习密码学的所有角落，而是专门针对区块链应用到的密码学知识进行学习。&lt;/p&gt;
&lt;h2 id=&quot;密码算法&quot;&gt;密码算法&lt;/h2&gt;
&lt;h3 id=&quot;单向哈希函数&quot;&gt;单向哈希函数&lt;/h3&gt;
&lt;p&gt;博主曾在&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/search.html#%E6%95%A3%E5%88%97%E8%A1%A8&quot;&gt;查找算法&lt;/a&gt;那一章中详细地从数据结构原理分析了哈希算法。哈希算法在密码学中有着非常重要的位置，是很多密码算法的基础。它可以将任意长度的二进制明文映射为较短的（通常为固定长度的）二进制串（Hash值），并且不同的明文很难映射为相同的哈希值（如果不同的明文映射为相同的哈希值了，就出现了碰撞，在&lt;a href=&quot;http://www.cnblogs.com/Evsward/p/search.html#%E7%A2%B0%E6%92%9E&quot;&gt;查找算法&lt;/a&gt;那篇文章里面都做了详尽的分析。）所以，理想状态下，一个优秀的单向哈希函数包含以下几个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;正向快速：能够快速计算出给定明文映射的哈希值。&lt;/li&gt;
&lt;li&gt;逆向困难：很难通过一个哈希值来反推出它的明文。&lt;/li&gt;
&lt;li&gt;输入敏感：明文修改了哪怕一个字符，映射的哈希值可能有很大改动。&lt;/li&gt;
&lt;li&gt;冲突避免：不能发生碰撞。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际上，单向哈希函数在密码学中还有很多种名字：压缩函数、收缩函数、消息摘要、指纹、密码校验和、信息完整性检验、操作检验码。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;单向哈希函数的使用方法，通常都是一方对自己的明文进行映射得到哈希值，然后与另一方传过来的哈希值进行比对，如果一致，则说明两方的原文一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这种操作过程中，明文不会涉及到数据传输，传输的是哈希值，这就对数据进行了有效的保护。&lt;/p&gt;
&lt;h4 id=&quot;常见算法&quot;&gt;常见算法&lt;/h4&gt;
&lt;p&gt;密码学中常见的单向哈希算法有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MD4，已淘汰&lt;/li&gt;
&lt;li&gt;MD5，MD4的升级版，但是对于任意明文的哈希值碰撞，还是无法达到百分百。&lt;/li&gt;
&lt;li&gt;SHA，是一套哈希函数族，SHA-1已被淘汰，升级后的SHA-2包含SHA-224、SHA-256、SHA-384、SHA-512。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;以上单向哈希算法中，推荐使用SHA-256。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;单向哈希函数可以说是对原文的一种隐蔽或者混淆，常用于对口令的保存。例如用户登录网站需要通过用户名密码的验证，网站后台就可以通过单向哈希函数来保存密码的哈希值，及时被窃听者偷到数据，他也无法直接推出密码的原文是什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;风险与防御&quot;&gt;风险与防御&lt;/h4&gt;
&lt;p&gt;然而，现今网站太多，用户往往不具备很高的安全意识，所以很有可能他们的多个网站上面都采用相同的密码，并且这个密码本身的强度也不够，有人专门收集了这些常见密码，计算出对应的哈希值放在一个字典里面。这样通过哈希值可以快速比对出密码原文。这种空间换时间的攻击方法被称为字典攻击，有人升级了字典攻击，只保存一条哈希值的首位值，相对字典攻击节省了大量空间，升级后的字典攻击被称为彩虹表攻击。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;那么针对字典攻击以及彩虹表攻击，网站是否有有效的防御手段呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最有效的防御手段就是加盐（salt），即网站数据库保存的不是仅将密码映射出来的哈希值，而是密码明文再加上一段随机字符串（盐）之后的哈希值，同时将“盐”单独保存，这样一来字典里的哈希值就不再具备广泛性，从而也就失去了它的攻击能力。&lt;/p&gt;
&lt;h3 id=&quot;对称加密&quot;&gt;对称加密&lt;/h3&gt;
&lt;p&gt;单向哈希函数其实不算加密算法，因为它不能真正地对信息进行保护，它只能对数据进行哈希映射但不能翻译出原文。下面我们来介绍真正的加密算法技术，首先就是对称加密。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;对称加密，就是加解密使用的密钥相同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在单向哈希函数中，是没有密钥这个概念的，这也是它无法成为加密算法的原因之一。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果把对称算法看成保险柜，密钥就是保险柜的号码组合。知道号码组合的人能够打开保险柜，放入文件，再关闭它，然后另一个也知道号码组合的人可以打开保险柜，取出文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;常见算法-1&quot;&gt;常见算法&lt;/h4&gt;
&lt;p&gt;对称加密算法的计算效率高，加密强度高，所以它适用于大量数据的加解密过程，但是缺陷是它必须提前将密钥共享出去，这期间一旦泄露则文件无加密可言。对称加密算法有DES，3DES，AES，IDEA。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对称加密算法推荐使用AES和IDEA。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;风险与防御-1&quot;&gt;风险与防御&lt;/h4&gt;
&lt;p&gt;针对对称加密，通常会采用选择密文攻击，它是指窃听者任意收集一定量的密文信息，让这些密文通过自己尝试的一些加密算法来解密获得明文，一旦尝试成功，窃听者可以在不知道密钥的情况下即可获得真正有效数据的明文信息。&lt;/p&gt;
&lt;p&gt;有效办法是将明文信息先用单向哈希函数处理以后再进行加密传输，这样一来，窃听者即使试出了加密算法也无法对解密明文进行解析。&lt;/p&gt;
&lt;h3 id=&quot;非对称加密&quot;&gt;非对称加密&lt;/h3&gt;
&lt;p&gt;非对称加密是在对称加密之后诞生的算法，也叫做公开密钥算法，顾名思义，它的加密密钥和解密密钥是不同的，分别称为公钥和私钥。非对称加密算法要先通过随机数算法生成私钥，然后通过私钥生成公钥，将公钥公开出去，任何人都可以拿到公钥对数据进行加密，然而只有少部分持有结对私钥的人才能将文件解密。&lt;/p&gt;
&lt;h4 id=&quot;常见算法-2&quot;&gt;常见算法&lt;/h4&gt;
&lt;p&gt;非对称算法解决了密钥泄露的问题，但是它的加解密过程要比对称算法慢上几个数量级，同时加密强度也不如对称加密。非对称加密算法包括RSA、EIGamal、椭圆曲线、SM2等系列算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其中椭圆曲线又叫ECC算法，是当前比较推荐采用的非对称加密算法，另外SM2也可以。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;风险与防御-2&quot;&gt;风险与防御&lt;/h4&gt;
&lt;p&gt;针对非对称加密，通常会采用选择明文攻击。由于非对称加密公钥是公开的，窃听者就可以任意构造一个明文进行加密得到加密串，通过不断的尝试，窃听者可以掌握加密算法的一些信息，以方便日后破解同样加密算法加密的信息，最坏情况下，窃听者甚至可以直接获得解密的私钥。&lt;/p&gt;
&lt;p&gt;现在的RSA和ECC已经具备了一定的保护机制来避免这种攻击风险，手段就是对同样的明文使用同样的密钥进行多次加密，得到的结果却完全不同，这就给窃听者试图从加密串中获得规律带来了难度，避免了选择明文攻击。&lt;/p&gt;
&lt;h3 id=&quot;混合加密机制&quot;&gt;混合加密机制&lt;/h3&gt;
&lt;p&gt;其实上面针对选择明文攻击和选择密文攻击的处理方案都是混合加密机制的思想。混合加密机制结合了对称加密和非对称加密的优点。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;简单来讲，明文是靠对称加密算法加解密的，但是对称加密的密钥K是通过非对称加密进行发放，K通过公钥加密后的串是公开的，授权人必须通过自己持有的私钥来解密K，再用K来解密密文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;https协议&quot;&gt;HTTPS协议&lt;/h4&gt;
&lt;p&gt;举一个非常经典的例子就是HTTPS协议，它是基于HTTP协议，更加安全的协议，现已成为最普遍的web通讯协议。它定义的交互过程为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端浏览器发送明文信息到服务器，信息包括：随机数R1，建议加密类型，建议压缩算法，支持协议的最高版本。&lt;/li&gt;
&lt;li&gt;服务端返回明文信息，包括：选定协议版本，选定加密类型，选定压缩算法，随机数R2。&lt;/li&gt;
&lt;li&gt;客户端检查自身证书系统寻找该网站公钥，该证书是通过第三方CA来签发。&lt;/li&gt;
&lt;li&gt;证书没问题，客户端拿到该网站公钥，加密随机数R3发送给服务端。&lt;/li&gt;
&lt;li&gt;服务端通过自身私钥解密获得随机数R3。此时，客户端和服务端都有了R1,R2,R3。&lt;/li&gt;
&lt;li&gt;客户端和服务端均通过一个伪随机函数（参数一致结果则一致，并不是真随机），参数为R1,R2,R3，获得会话密钥MasterSecret。&lt;/li&gt;
&lt;li&gt;通过会话密钥MasterSecret，客户端和服务端的通信都通过对称加密算法进行保护。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上则是细致地分析了HTTPS协议的每个步骤的工作内容，可以看出，在保护对称算法密钥的这条路上，HTTPS真是不遗余力：它通过2个明文随机数加上一个非对称加密算法保护的随机数R3，在此基础上，将三个随机数进行了函数处理才得到最终的对称算法的密钥。即使外界知道加密协议版本，加密类型，压缩算法和前2个随机数，他们也不知道R3是多少，也就无法得知那个伪随机函数是怎么写的，所以会话密钥得到了更深层次的保护，外界只能看到被会话密钥加密后的密文，他们无法得知那个会话密钥是什么。&lt;/p&gt;
&lt;h2 id=&quot;安全技术&quot;&gt;安全技术&lt;/h2&gt;
&lt;h3 id=&quot;数字摘要&quot;&gt;数字摘要&lt;/h3&gt;
&lt;p&gt;数字摘要是单向哈希函数最重要的一个用途，也可被称为文件完整性测试。通过对原文进行哈希运算，获得唯一的摘要值来指代原文，数字摘要解决了确保内容未被篡改过的问题。我们在从网络上下载文件时，都会被提供一个数字摘要值，我们可以通过对下载到本地的文件进行运算得到本地摘要值，然后与网络提供的进行对比，如果一致说明文件未被篡改，不一致说明有篡改过。&lt;/p&gt;
&lt;h3 id=&quot;消息认证码&quot;&gt;消息认证码&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;全称为“基于Hash的消息认证码”，英文缩写HMAC。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本过程：对某个消息利用提前共享出来的对称密钥和Hash算法进行加密处理，得到HMAC值。该HMAC值持有方可以证明自己拥有共享的对称密钥，并且也可以利用HMAC确保消息内容未被篡改。&lt;/p&gt;
&lt;p&gt;典型的HMAC包含三个因素（K,H,Message）:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;K为提前共享的对称密钥。&lt;/li&gt;
&lt;li&gt;H为提前商定的Hash算法。&lt;/li&gt;
&lt;li&gt;Message为消息内容。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;消息认证码一般用于证明身份的场景。任何拿到K和H的授权人可以通过发送明文消息给另一方，另一方通过K,H,Message得到HMAC值返回前人，前面的人自己算出HMAC来比对，如果一致则说明是自己人，如果不一致则停止通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而，得到K和H的授权人可能不止一个，对于其中一个人来说，其他所有的授权人都是一样的，无法区分他们。这就引出了身份的进一步定义——数字签名的技术。&lt;/p&gt;
&lt;h3 id=&quot;数字签名&quot;&gt;数字签名&lt;/h3&gt;
&lt;p&gt;数字签名也有着签名的效力，它是基于非对称加密，既可证明某数字内容的完整性，又同时可以确认来源（或者作为证据，不可抵赖性），看上去它是以上两种技术的汇总升级版，既有数字摘要的文件完整性校验的功能，也有消息认证码的更明确的身份确认。下面是几点注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非对称加密中，公钥和私钥是一对一生成的，因此某个身份只会拥有唯一的一对密钥，与其他身份不同。&lt;/li&gt;
&lt;li&gt;非对称加密一般是公钥加密，私钥解密的，而数字签名中是私钥加密，公钥解密。是因为签名是为了外人确认我的身份，而外人只能看到公钥，所以我需要用我自己的私钥加密一串信息，外人拿到密文后用公钥解密得到信息。&lt;/li&gt;
&lt;li&gt;信息在用我的私钥加密以前，为了获得完整性功能加成，我要将信息做数字摘要，然后把摘要进行私钥加密，这样一来外人公钥解密获得的是数字摘要，通过比对数字摘要，一来可以确认我的身份，二来可以确定文件的完整。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;常见数字签名算法包括DSA和安全强度更高的ECDSA等。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：签名只是为了确认身份和文件完整性，而不是为了传输文件，切记切记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面来谈谈数字签名的安全性，它是由数学问题进行保障。目前常见的数字签名算法往往需要选取何时的随机数作为配置参数，配置参数不合理的使用或泄露都会造成安全漏洞，需要进行安全保护。之前索尼公司的PS3虽然采用了较为安全的ECDSA进行签名，然而错误地使用了重复的随机参数，最终导致私钥被破解，造成经济上的重大损失。&lt;/p&gt;
&lt;p&gt;下面介绍几种特殊的签名类型：&lt;/p&gt;
&lt;h4 id=&quot;盲签名&quot;&gt;盲签名&lt;/h4&gt;
&lt;p&gt;在数字摘要之前的原始内容本身就是一个密文，作为签名者的我无法看到原始内容，我只能将原始内容做摘要然后私钥加密摘要进行签名。外人通过找到对应我身份的公钥解密签名获得摘要值比对确定我的身份以及文件完整性。而对于文件内容本身，我和外人都无从得知，因为从摘要是很难逆向得到明文的，而且得到的也是原始内容的密文，又不知道如何解密。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;盲签名实现了对原始内容的保护，防止签名者看到原始内容，而且签名者也无法将签名内容和签名结果进行对应。&lt;br/&gt;典型的实现包括RSA的盲签名算法等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;多重签名&quot;&gt;多重签名&lt;/h4&gt;
&lt;p&gt;多重签名规定了总共n个签名者，收集到m个（n&amp;gt;=m&amp;gt;=1）签名并判断有效，则认为该文件合法。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;多重签名可以有效地被应用在多人投票共同决策的场景中。多重签名的主要目的是在身份和文件完整性验证的基础上，由多人投票确认签名文件本身是否合法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比特币交易中使用到的就是多重签名机制，可实现多人共同管理某个账户的比特币交易。也就是说当某个账户发生比特币交易的时候，多个人去记录这比交易形成交易文件，比特币规定，每笔交易的文件的格式内容是有一个最终标准的，只不过多人在形成这个文件的过程中要克服一些数学问题（挖矿），当他们中有一人完成了交易文件就会对它进行签名并广播，其他人收到签名以后会验证，如果签名没有问题，则该文件合法，所以这里对应的多重签名里的m值为1，有一个人的签名通过了，就可证明该文件合法，然后会将该交易文件合到比特币主区块链上去。&lt;/p&gt;
&lt;h4 id=&quot;群签名&quot;&gt;群签名&lt;/h4&gt;
&lt;p&gt;群签名即某个群组内的一个成员可以代表群组进行匿名签名。签名可以验证来自于该群组，却无法准确追踪到签名的是哪个具体成员。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;群签名需要一个群管理员来添加新的群成员，因此存在群管理员可能追踪到签名成员身份的风险。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;群组内的成员每人都有一个自己的私钥，而对于外人来讲，整个群组只有一个公钥，外人可以通过公钥来解密签名，匹配一致这说明是该群组的签名，然而该签名是群组内的某个人通过自己唯一的私钥进行的加密。类似于公钥对私钥是1对多的关系，真实的情况肯定还是一个公钥对一个私钥，那么这里的一对多是如何形成的呢？我想可能是对群组内的每个公钥做了一个处理，将群组内的公钥生成了一个统一的对外暴露的“群公钥”。&lt;/p&gt;
&lt;h4 id=&quot;环签名&quot;&gt;环签名&lt;/h4&gt;
&lt;p&gt;环签名属于一种简化的群签名。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;签名者首先选定一个临时的签名者集合，集合中包括签名者自身。然后签名者利用自己的私钥和签名集合中其他人的公钥就可以独立地产生签名，而无需他人的帮助。签名者集合中的其他成员可能并不知道自己被包含在最终的签名中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面来分析一波，环签名旨在某个签名者想匿名签名，他自己拉起来一个临时的群组，他能够获得群组内其他人的公钥，然后他用自己的私钥加密了文件，通过一种手段，提供给外人解密的公钥变成了其他人的公钥，这就让外人无法定位到签名者本人。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;环签名在保护匿名性方面有很多的用途。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数字证书&quot;&gt;数字证书&lt;/h2&gt;
&lt;p&gt;对于非对称加密算法和数字签名来说，很重要的一点就是公钥的分发。理论上任何人可以公开的拿到对方的私钥。然而在这种前提下，如果窃听者伪造了公钥，在传输过程中对真实数据进行了钓鱼篡改。一旦公钥出了问题，整个安全体系也将随之崩塌。因此维护公钥的正确性是非常重要的。数字证书就是为了解决这个问题。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;数字证书就可以证明某个公钥是某个实体（或组织或个人）的，并且确保一旦篡改能被探测出来，从而实现对用户公钥的安全分发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;证书保护的公钥分为两种，上面我们也都介绍过了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个是非对称加密中，用来加密的公钥。&lt;/li&gt;
&lt;li&gt;另一个是数字签名中，用来验证签名的解密公钥。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两种类型的公钥也可同时放在一个证书中。&lt;/p&gt;
&lt;p&gt;一般情况下，证书需要有证书认证机构（CA）来进行签发和背书。权威的证书认证机构包括DigiCert、GlobalSign、VeriSign等。用户也可以自行搭建本地CA系统，在私有网络中进行使用。目前证书的规范均采用X.509证书规范，该规范中规定了证书所包含的信息，有版本号，序列化，签名算法，颁发者，有效期，主体，主体的公钥信息，颁发者唯一号，主体唯一号，扩展。此外，证书的颁发者还需要对证书内容利用自己的公钥添加签名，以防止别人对证书内容进行篡改。X.509规范推荐使用PEM格式来存储证书相关文件。证书文件的文件名后缀一般为.crt或者.cer，对应私钥文件的文件名后缀一般为.key，证书请求文件的文件名后缀为.csr。有时候也统一用.pem作为文件名后缀。PEM格式采用文本方式进行存储，一般包括首尾标记和内容块，内容块采用Bash64进行编码。&lt;/p&gt;
&lt;h2 id=&quot;merkle树&quot;&gt;Merkle树&lt;/h2&gt;
&lt;p&gt;Merkle树，又叫哈希树，是一种典型的二叉树结构，由一个根结点、一组中间节点和一组叶节点组成。在区块链系统出现之前，广泛用于文件系统和P2P系统中。主要特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最下面的叶节点包含存储数据或哈希值。&lt;/li&gt;
&lt;li&gt;非叶子节点（包括中间节点和根结点）都是它的两个孩子节点内容的哈希值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Merkle树可以推广到多叉树的情形，此时非叶子节点的内容为它所有的孩子节点内容的哈希值。Merkle树逐层记录哈希值的特点，让它具有了一些独特的性质。例如，底层数据的任何变动，都会传递到其父节点，一层层沿着路径一直到树根。这意味着树根的值实际上代表了对底层所有数据的“数字摘要”。Merkle树的应用场景有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;快速比较大量数据：对每组数据排序后构建Merkle树结构。当两个Merkle树根相同时，两组数据也必然相同。否则，必然存在不同。由于Hash计算的过程可以十分迅速，预处理可以在短时间内完成。利用Merkle树结构能带来巨大的比较性能优势。&lt;/li&gt;
&lt;li&gt;快速定位修改：如果一个节点的数据被修改，那么它的父节点，父节点的父节点直到根节点，会一路收到影响。因此，一旦发现根节点的数值发生变化，可以快速定位到实际发生改变的数据块。&lt;/li&gt;
&lt;li&gt;零知识证明：如何向他人证明拥有的某组数据中包括给定的某个内容D0而不暴露其他任何内容？可以使用Merkle树，D0的拥有者通过验证生成的根节点的数值是否与提供的值一致，即可很容易检测提供者是否包含D0。而整个过程验证者无法获知其他内容。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;同态加密&quot;&gt;同态加密&lt;/h2&gt;
&lt;p&gt;同态加密是一种特殊的加密方法，允许对密文进行处理得到仍然是加密的结果。即对密文直接进行处理，跟对明文进行处理后再对处理结果加密，得到的结果相同。从抽象代数的角度将，保持了同态性。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;同态加密可以保证实现处理者无法访问到数据自身的信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文简单介绍了应用密码学中区块链相关的一些问题和算法。掌握这些知识，对于帮助理解区块链系统如何实现隐私保护和安全防护都很有好处。区块链技术中大量利用了现代密码学的已有成果，包括Hash，加解密，签名，Merkle树数据结构等。另一方面，区块链系统和诸多新的场景也对密码学和安全技术提出了很多新的需求，反过来也将促进相关学科的进一步发展。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;应用密码学（协议、算法与C源程序）&lt;/li&gt;
&lt;li&gt;区块链（原理、设计与应用）&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Sun, 14 Jan 2018 13:56:00 +0000</pubDate>
<dc:creator>一面千人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Evsward/p/cryptography.html</dc:identifier>
</item>
<item>
<title>聊聊ThreadLocal原理以及使用场景-JAVA 8源码 - 黄青石</title>
<link>http://www.cnblogs.com/huangqingshi/p/8284437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangqingshi/p/8284437.html</guid>
<description>&lt;p&gt;　　相信很多人知道ThreadLocal是针对每个线程的，但是其中的原理相信大家不是很清楚，那咱们就一块看一下源码。&lt;/p&gt;
&lt;p&gt;　　首先，我们先看看它的set方法。非常简单，从当前Thread中获取map。那么这个getMap方法是什么样的呢？咱们继续看。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
/**&lt;br/&gt;* Sets the current thread's copy of this thread-local variable&lt;br/&gt;* to the specified value.  Most subclasses will have no need to&lt;br/&gt;* override this method, relying solely on the {@link #initialValue}&lt;br/&gt;* method to set the values of thread-locals.&lt;br/&gt;*&lt;br/&gt;* @param value the value to be stored in the current thread's copy of&lt;br/&gt;*        this thread-local.&lt;br/&gt;*/&lt;br/&gt;public void set(T value) {&lt;br/&gt;Thread t = Thread.currentThread();&lt;br/&gt;ThreadLocalMap map = getMap(t);&lt;br/&gt;if (map != null)&lt;br/&gt;map.set(this, value);&lt;br/&gt;else&lt;br/&gt;createMap(t, value);&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从当前线程中去获取单钱线程的threadLocals. 继续跟进t.threadLocals。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Get the map associated with a ThreadLocal. Overridden in
     * InheritableThreadLocal.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt;  t the current thread
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the map
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    ThreadLocalMap getMap(Thread t) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t.threadLocals;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个threadLocals定义在Thread里边，也就是每个线程里边维护者自己的threadLocals，这样使得每个线程之间独立了。思路再次回头上边的set方法上，如果map不为null, 那么重新进行set操作，如果为空，则需要创建这个ThreadLocalMap。咱们看如何进行的创建。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ThreadLocal values pertaining to this thread. This map is maintained
     * by the ThreadLocal class. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    ThreadLocal.ThreadLocalMap threadLocals &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下为创建的过程，在ThreadLocalMap中有一个静态内部类，&lt;strong&gt;静态内部类和普通的类是一样的，静态属性和方法和静态内部类不一样&lt;/strong&gt;，这一点大家要注意。首先根据当前的ThreadLocal的实例获取当前的hashCode然后再与(初始容量-1）结果为7，Entry是ThreadLocalMap的静态内部类，类型为&lt;strong&gt;弱引用&lt;/strong&gt;，也就是说，如果里边的key为null时，该value就是过期的value, 后续将会被擦除。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
/**&lt;br/&gt;* Create the map associated with a ThreadLocal. Overridden in&lt;br/&gt;* InheritableThreadLocal.&lt;br/&gt;*&lt;br/&gt;* @param t the current thread&lt;br/&gt;* @param firstValue value for the initial entry of the map&lt;br/&gt;*/&lt;br/&gt;void createMap(Thread t, T firstValue) {&lt;br/&gt;t.threadLocals = new ThreadLocalMap(this, firstValue);&lt;br/&gt;}
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;p&gt;/**&lt;/p&gt;&lt;/span&gt;&lt;span&gt;
         * Construct a new map initially containing (firstKey, firstValue).
         * ThreadLocalMaps are constructed lazily, so we only create
         * one when we have at least one entry to put in it.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        ThreadLocalMap(ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt;&lt;span&gt; firstKey, Object firstValue) {
            table &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry[INITIAL_CAPACITY];
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = firstKey.threadLocalHashCode &amp;amp; (INITIAL_CAPACITY - 1&lt;span&gt;);
            table[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Entry(firstKey, firstValue);
            size &lt;/span&gt;= 1&lt;span&gt;;
            setThreshold(INITIAL_CAPACITY);
        }


&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * The entries in this hash map extend WeakReference, using
         * its main ref field as the key (which is always a
         * ThreadLocal object).  Note that null keys (i.e. entry.get()
         * == null) mean that the key is no longer referenced, so the
         * entry can be expunged from table.  Such entries are referred to
         * as &quot;stale entries&quot; in the code that follows.
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Entry &lt;span&gt;extends&lt;/span&gt; WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; The value associated with this ThreadLocal. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            Object value;

            Entry(ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt;&lt;span&gt; k, Object v) {
                &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(k);
                value &lt;/span&gt;=&lt;span&gt; v;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　刚才是如果map为空的时候，重新创建了一个ThreadLocalMap赋值给了当前的Thread, 如果当前thread的map不为空时，那么就需要获取当前的threadLocalMap,然后重新将值set上。&lt;/p&gt;
&lt;p&gt;　　这块是它的set方法，那么咱们看一个下get方法，获取当前的thread,并且从thread中获取threadLocalMap，然后取出其中的value，如果没有找到这个map的话，初始化一个key为ThreadLocal的实例放入到当前的thread中的ThreadLocalMap中，并且将value设置为null。最后将null返回给get方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Returns the value in the current thread's copy of this
     * thread-local variable.  If the variable has no value for the
     * current thread, it is first initialized to the value returned
     * by an invocation of the {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #initialValue} method.
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; the current thread's value of this thread-local
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T get() {
        Thread t &lt;/span&gt;=&lt;span&gt; Thread.currentThread();
        ThreadLocalMap map &lt;/span&gt;=&lt;span&gt; getMap(t);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            ThreadLocalMap.Entry e &lt;/span&gt;= map.getEntry(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
                T result &lt;/span&gt;=&lt;span&gt; (T)e.value;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; setInitialValue();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这块内容大致的方法基本上就是这么多，那么我们在什么场景下使用呢？&lt;/p&gt;
&lt;p&gt;　　一般在web应用中context可以使用。比如SimpleDateFormat是非线程安全的，那么我们就可以借助这个类去进行处理，为了显示不同的格式。我自己写了一个例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.hqs;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.SimpleDateFormat;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by huangqingshi on 2018/1/14.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadLocalExample {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SimpleDateFormat 不是线程安全的&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;SimpleDateFormat&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;SimpleDateFormat&amp;gt;&lt;span&gt;(){
        @Override
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; SimpleDateFormat initialValue() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleDateFormat();
        }
    };


    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SimpleDateFormat sdf &lt;/span&gt;=&lt;span&gt; threadLocal.get();
        sdf.applyPattern(&lt;/span&gt;&quot;yy/MM/dd&quot;&lt;span&gt;);
        System.out.println(sdf.format(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
        sdf.applyPattern(&lt;/span&gt;&quot;MM/dd/yyyy&quot;&lt;span&gt;);
        System.out.println(sdf.format(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date()));
    }

}&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;18/01/14&lt;br/&gt;01/14/2018&lt;/p&gt;
&lt;p&gt;Process finished with exit code 0&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　使用这个ThreadLocal的时候，需要注意一些内容：&lt;/p&gt;
&lt;p&gt;　　如果定义一些大量的线程变量的，可能会出现不能创建线程的异常，因为一些web server针对线程会定义线程池，当使用ThreadLocal创建了很多线程，处理的时间比较久，那么这些线程不会释放，结果会导致栈溢出，程序没有响应。此时需要注意使用的时候，尽可能让当前线程处理完成。&lt;/p&gt;
&lt;p&gt;　　还有可能会因此出现Perm溢出，比如ThreadLocal里边装入了一些静态的类，那么静态的类初始化的时候会在永久代，而且不会释放，那么创建对象的数量增多的话会导致线程出现这总异常，那么我们在这种情况下需要进行remove操作。如果ThreadLocal里边放入了一些基本类型话不会出现这种情况。&lt;/p&gt;
&lt;p&gt;　　还有一种情况就是如果线程中的对象需要进行数据共享的话需要将ThreadLocal设置为静态变量。&lt;/p&gt;
&lt;p&gt;　　好了，针对这块内容的分析和整理就这么多了，如果大家有什么问题的话，请告知~  谢谢。&lt;/p&gt;
</description>
<pubDate>Sun, 14 Jan 2018 13:27:00 +0000</pubDate>
<dc:creator>黄青石</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangqingshi/p/8284437.html</dc:identifier>
</item>
<item>
<title>优雅的处理Redis访问超时 - hystar</title>
<link>http://www.cnblogs.com/lsxqw2004/p/8284365.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsxqw2004/p/8284365.html</guid>
<description>&lt;p&gt;很长一段时间以来，一直在项目中使用Redis作为辅助存储，确切来说是利用Redis的内存存储，而不是将其作为缓存。比如常见的利用Set集合来判断某个数值是否存在，或者将来自不同请求的数据放在Redis中进行拼接然后一起写入MySQL等数据库。&lt;br/&gt;这种存储目的的使用要求对Redis的访问不能失败（如果作为缓存使用，是接受失败的），所以作为存储目的使用代码中要对请求Redis的代码进行异常处理以及重试等。&lt;br/&gt;在最初的代码中采用了最常见的方法如try ... catch ...处理异常，递归进行重试，类似：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;//伪代码
public void Process(int retry)
{
    if(retry&amp;gt;3)
    {
        //记录错误
        return;
    }
    try
    {
        //业务代码
    } 
    catch(Exception ex)
    {
        //重试
        ++retry;
        Process(retry);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后来有一天看到了园友&lt;a href=&quot;!http://www.cnblogs.com/CreateMyself/&quot;&gt;Jeffcky&lt;/a&gt;推荐的&lt;a href=&quot;!http://www.cnblogs.com/CreateMyself/p/7589397.html&quot;&gt;Polly&lt;/a&gt;库，瞬间眼前一亮，这才是我们处理异常和重试所需要的东西。&lt;br/&gt;关于Polly的使用，可以参考Jeffcky的博文或者Polly项目的&lt;a href=&quot;!https://github.com/App-vNext/Polly&quot;&gt;GitHub主页&lt;/a&gt;（文档很详细）。&lt;br/&gt;大致的代码结构如：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var tsArr = new TimeSpan[]
{
    TimeSpan.FromSeconds(1),
    TimeSpan.FromSeconds(1)
};
// 构造一种重试测试（其它可选的包括熔断等）
var policy = Policy
    .Handle&amp;lt;Exception&amp;gt;()
    .WaitAndRetryAsync(tsArr);

// 需要有Polly调用的业务代码，以异步方法为例
async Task SomeToInvoke()
{
       // 一些异步调用
}

// 使用Polly执行业务代码（如不需要捕获异常可选用其它重载）
var pollyRet = await policy.ExecuteAndCaptureAsync(SomeToInvoke);
// 处理返回值判断调用是否成功，或发生了什么异常&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面一步步来看博主的实现过程。&lt;/p&gt;
&lt;p&gt;先放上一些测试所用的代码，首先是创建Redis连接的接口和类，它们是从NopCommerce项目一个早起版本借(chao)鉴(xi)来的（文件名都没改，为了测试方便代码略有改动），一直用着没啥大问题就这样用了。&lt;/p&gt;
&lt;pre class=&quot;cashrp&quot;&gt;
&lt;code&gt;public interface IRedisConnectionWrapper : IDisposable
{
    IDatabase Database(int? db = null);
    IServer Server(EndPoint endPoint);
    EndPoint[] GetEndpoints();
    void FlushDb(int? db = null);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;charp&quot;&gt;
&lt;code&gt;public class RedisConnectionWrapper : IRedisConnectionWrapper
{
    private readonly Lazy&amp;lt;string&amp;gt; _connectionString;
    private readonly Lazy&amp;lt;string&amp;gt; _auth;

    private volatile ConnectionMultiplexer _connection;
    private readonly object _lock = new object();

    public RedisConnectionWrapper(string server, string pswd)
    {
        this._connectionString = new Lazy&amp;lt;string&amp;gt;(() =&amp;gt; server);
        this._auth = new Lazy&amp;lt;string&amp;gt;(() =&amp;gt; pswd);
    }

    private ConnectionMultiplexer GetConnection()
    {
        if (_connection != null &amp;amp;&amp;amp; _connection.IsConnected) return _connection;

        lock (_lock)
        {
            if (_connection != null &amp;amp;&amp;amp; _connection.IsConnected) return _connection;

            if (_connection != null)
            {
                _connection.Dispose();
            }

            var options = new ConfigurationOptions();
            options.EndPoints.Add(_connectionString.Value);
            if (!string.IsNullOrEmpty(_auth.Value))
                options.Password = _auth.Value;

            _connection = ConnectionMultiplexer.Connect(options);
        }

        return _connection;
    }

    public IDatabase Database(int? db = null)
    {
        return GetConnection().GetDatabase(db ?? -1);
    }

    public IServer Server(EndPoint endPoint)
    {
        return GetConnection().GetServer(endPoint);
    }

    public EndPoint[] GetEndpoints()
    {
        return GetConnection().GetEndPoints();
    }

    public void FlushDb(int? db = null)
    {
        var endPoints = GetEndpoints();

        foreach (var endPoint in endPoints)
        {
            Server(endPoint).FlushDatabase(db ?? -1);
        }
    }

    public void Dispose()
    {
        if (_connection != null)
        {
            _connection.Dispose();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于StackExchange.Redis来说是比较标准的连接创建方式，顺便看了下新版的NopCommerce代码中，代码有了些小改进，增加了一个双重锁。有需要的园友可以自行去下载新的。&lt;/p&gt;
&lt;p&gt;接着开始考虑重试问题，为了代码看起来更简洁，决定尝试通过动态代理将捕捉异常并重试的操作作为切面注入。说到动态代理，第一个想到肯定是Castle.Core（前身为CastleDynamicProxy）。动态代理可以选择接口或者是类，如果是类的话需要方法是虚方法。看了下StackExchange.Redis的代码，几个实现类都是internal，方法也都是非virtual。所以只能只能自己写一个类包一下。&lt;br/&gt;这个类就是一个壳，为了我们切面注入。下面的代码只保留的一个方法，其它的省略。另外Castle.Core的动态代理是不支持异步方法的，所以先用Redis的同步接口做下尝试。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class RedisDatabaseWrapper:IDatabase
{
    private IDatabase _redisDb;

    public RedisDatabaseWrapper(IRedisConnectionWrapper redisConnectionWrapper)
    {
        _redisDb = redisConnectionWrapper.Database();
    }

    public virtual bool SetContains(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)
    {
        return _redisDb.SetContains(key, value, flags);
    }

    // 省略其它所有方法...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装Castle.Core，并开始实现动态代理类。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class RetryByPollyInterceptor : IInterceptor
{
    public async void Intercept(IInvocation invocation)
    {
        var isAsync = IsAsyncMethod(invocation.Method);
        if (isAsync)
            InterceptAsync(invocation);
        else
            InterceptSync(invocation);
    }

    private void InterceptSync(IInvocation invocation)
    {
        var tsArr = new TimeSpan[]
        {
            TimeSpan.FromSeconds(1),
            TimeSpan.FromSeconds(1)
        };

        Action&amp;lt;Exception, TimeSpan, int, Context&amp;gt; action = (ex, ts, idx, ctx) =&amp;gt;
        {
            Console.WriteLine($&quot;Polly Exp:{ex.GetType()} {ex.Message} Try:{idx} &quot;);

            var invca = (IInvocation)ctx[&quot;inv&quot;];
            if (idx == 2)
            {
                var type = invca.Method.ReturnType;
                if (type == typeof(void)) return;
                var ret = type.IsValueType ? Activator.CreateInstance(type) : null;
                invca.ReturnValue = ret;
            }
        };

        var policy = Policy
            .Handle&amp;lt;TimeoutException&amp;gt;()
            .Or&amp;lt;RedisConnectionException&amp;gt;()
            .Or&amp;lt;Exception&amp;gt;()
            .WaitAndRetry(tsArr, action);

        void OrignalInvoke()
        {
            invocation.Proceed();
        }

        var pollyRet = policy.ExecuteAndCapture(OrignalInvoke, new Dictionary&amp;lt;string, object&amp;gt;() { [&quot;inv&quot;] = invocation });
        if (pollyRet.Outcome != OutcomeType.Successful)
        {
            Console.WriteLine($&quot;Polly Ret Type:{pollyRet.Outcome} Exp:{pollyRet.ExceptionType} Msg:{pollyRet.FinalException?.Message}&quot;);
        }
    }

    private void InterceptAsync(IInvocation invocation)
    {
            // 异步方法代理，下文会讨论
    }

    private static bool IsAsyncMethod(MethodInfo method)
    {
        return (
            method.ReturnType == typeof(Task) ||
            (method.ReturnType.IsGenericType &amp;amp;&amp;amp; method.ReturnType.GetGenericTypeDefinition() == typeof(Task&amp;lt;&amp;gt;))
        );
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意&lt;br/&gt;这个方法也是经过多次尝试才最终完成，可以看到这里预留了处理异步代理的方法，后文会详细说。对于同步方法这段代码可以完美的捕获异常并重试。不用在外侧代码进行catch。当然内部发生异常并多次重试仍失败后会返回非期望的结果，还是需要根据业务的需要对返回值进行判断。&lt;br/&gt;这段代码最值得注意的是这几行：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;Action&amp;lt;Exception, TimeSpan, int, Context&amp;gt; action = (ex, ts, idx, ctx) =&amp;gt;
{
    Console.WriteLine($&quot;Polly Exp:{ex.GetType()} {ex.Message} Try:{idx} &quot;);

    var invca = (IInvocation)ctx[&quot;inv&quot;];
    if (idx == 2)
    {
        var type = invca.Method.ReturnType;
        if (type == typeof(void)) return;
        var ret = type.IsValueType ? Activator.CreateInstance(type) : null;
        invca.ReturnValue = ret;
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们设置重试两次，当第二次发生异常时，我们强制给方法返回值赋一个返回值，这样可以让外部调用方法正常执行下去而不会由于无法获取代理方法的返回值而报空引用异常。&lt;/p&gt;
&lt;p&gt;接着看看其它组成部分。在博主目前大部分项目中都使用Autofac作为容器，我们需要注册一下用到的类。并且通过Autofac的Castle.Core插件，可以注册动态代理，这样就不用通过给类添加Attribute的方式来添加代理，这是个人比较喜欢的风格。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var builder = new ContainerBuilder();

builder.Register(c =&amp;gt; new RetryByPollyInterceptor()); //动态代理类

builder.RegisterType&amp;lt;RedisDatabaseWrapper&amp;gt;().As&amp;lt;IDatabase&amp;gt;().EnableInterfaceInterceptors().InterceptedBy(typeof(RetryByPollyInterceptor)).SingleInstance(); //添加动态代理

builder.RegisterType&amp;lt;RedisConnectionWrapper&amp;gt;().As&amp;lt;IRedisConnectionWrapper&amp;gt;()
    .WithParameters(new[]
    {
        new NamedParameter(&quot;server&quot;, &quot;127.0.0.1&quot;),
        new NamedParameter(&quot;pswd&quot;,&quot;&quot;),
    }).SingleInstance();

Container = builder.Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以用下面的代码来测试一下上面这些方法。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void ReadTest(long start, long end)
{
    for (var i = start; i &amp;lt;= end; i++)
    {
        var exists = _redisDb.SetContains(RedisKey, i);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用Windows版的Redis，直接运行redis-server.exe来启动服务。然后直接关闭redis-server程序来模拟服务端失败，或者直接禁用网卡来模拟网络失败。&lt;br/&gt;可以看到Polly会进行重试并且捕获异常，也就说在ReadTest中感知不到异常。&lt;/p&gt;
&lt;p&gt;搞定了同步方法，开始尝试动态代理异步方法。添加Redis异步接口的实现并注册：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class RedisDatabaseAsyncWrapper:IDatabaseAsync
{
    private IDatabase _redisDb;

    public RedisDatabaseAsyncWrapper(IRedisConnectionWrapper redisConnectionWrapper)
    {
        _redisDb = redisConnectionWrapper.Database();
    }
    
    public virtual async Task&amp;lt;bool&amp;gt; SetContainsAsync(RedisKey key, RedisValue value, CommandFlags flags = CommandFlags.None)
    {  
        return await _redisDb.SetContainsAsync(key, value, flags);
    }

    // 省略其它实现..
}

//注册异步实现
builder.RegisterType&amp;lt;RedisDatabaseAsyncWrapper&amp;gt;().As&amp;lt;IDatabaseAsync&amp;gt;().EnableInterfaceInterceptors().InterceptedBy(typeof(RetryByPollyInterceptor)).SingleInstance();

//异步代理
private void InterceptAsync(IInvocation invocation)
{
    var tsArr = new TimeSpan[]
    {
        TimeSpan.FromSeconds(1),
        TimeSpan.FromSeconds(1)
    };

    var policy = Policy
        .Handle&amp;lt;TimeoutException&amp;gt;()
        .Or&amp;lt;RedisConnectionException&amp;gt;()
        .Or&amp;lt;Exception&amp;gt;()
        .WaitAndRetry(tsArr);

    void OrignalInvoke()
    {
        try
        {
            invocation.Proceed();
        }
        catch (Exception e)
        {
            var geneType = invocation.Method.ReturnType.GenericTypeArguments[0];
            var ret = geneType.IsValueType ? Activator.CreateInstance(geneType) : null;
            invocation.ReturnValue = Task.FromResult(ret);

            Console.WriteLine(e);
        }
    }
    
    var pollyRet = policy.ExecuteAndCapture(OrignalInvoke,
        new Dictionary&amp;lt;string, object&amp;gt;() { [&quot;inv&quot;] = invocation });
    if (pollyRet.Outcome != OutcomeType.Successful)
    {
        Console.WriteLine(
            $&quot;Polly Ret Type:{pollyRet.Outcome} Exp:{pollyRet.ExceptionType} Msg:{pollyRet.FinalException?.Message}&quot;);

        var invca = (IInvocation)pollyRet.Context[&quot;inv&quot;];

        var type = invca.Method.ReturnType;
        if (type == typeof(void)) return;
        if (type.IsGenericType)
        {
            var geneType = invca.Method.ReturnType.GenericTypeArguments[0];
            var ret = geneType.IsValueType ? Activator.CreateInstance(geneType) : null;
            invca.ReturnValue = Task.FromResult(ret);
        }
        else
        {
            invca.ReturnValue = Task.FromResult(0);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里直接告诉各位我的尝试结果是无论如何都无法通过Polly来捕获异常。即上面代码中，&lt;code&gt;OrignalInvoke&lt;/code&gt;方法中&lt;code&gt;try...catch...&lt;/code&gt;抓不到异常，异常直接被扔给了外部方法。具体原因由于本人比较菜也比较懒没有仔细研究，大概可能就是用一个同步环境去调异步环境的方法没有特殊处理所以出的问题。有知道的园友评论中指点下。&lt;br/&gt;如果是把&lt;code&gt;invocation.Proceed()&lt;/code&gt;放在Task中，到是异常不会抛到外侧，但会因为被代理的方法取不到返回值而报空引用错误。原因大概应该是Castle.Core没有取到这个异步构造中的返回值。&lt;/p&gt;
&lt;p&gt;经过一番尝试后放弃。在查找解决方法的过程中还发现一个名为&lt;a href=&quot;!https://github.com/JSkimming/Castle.Core.AsyncInterceptor&quot;&gt;Castle.Core.AsyncInterceptor&lt;/a&gt;的库，给Castle.Core添加动态代理异步函数的功能，但此扩展的文档实在过长，而且粗略看了下还不支持针对Autofac等IoC容器的扩展，直接放弃。&lt;/p&gt;
&lt;p&gt;后来机缘巧合看到了园友Lemon大神的介绍其AspectCore库的&lt;a href=&quot;!http://www.cnblogs.com/liuhaoyang/p/aspectcore-getting-started.html&quot;&gt;文章&lt;/a&gt;。留言问了下对异步方法支持的情况，Lemon大神立刻给了回复，还附送了一些使用的特别提示。于是立马安装尝试。&lt;/p&gt;
&lt;p&gt;首先是最重要的代理方法，AspectCore原生对异步方法提供支持，代码写起来很简单：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class RetryByPollyAspectCoreInterceptor : AbstractInterceptorAttribute
{
    public override async Task Invoke(AspectContext context, AspectDelegate next)
    {
        var tsArr = new TimeSpan[]
        {
            TimeSpan.FromSeconds(1),
            TimeSpan.FromSeconds(1)
        };

        var policy = Policy
            .Handle&amp;lt;AspectInvocationException&amp;gt;(ex=&amp;gt;ex.InnerException?.GetType()==typeof(TimeoutException))
            .Or&amp;lt;AspectInvocationException&amp;gt;(ex=&amp;gt;ex.InnerException?.GetType()==typeof(RedisConnectionException))
            .WaitAndRetryAsync(tsArr);

        async Task OrignalInvoke()
        {
            await context.Invoke(next);
        }

        var pollyRet = await policy.ExecuteAndCaptureAsync(OrignalInvoke,new Dictionary&amp;lt;string, object&amp;gt;() { [&quot;ctx&quot;] = context});
        if (pollyRet.Outcome != OutcomeType.Successful)
        {
            Console.WriteLine($&quot;Polly Ret Type:{pollyRet.Outcome} Exp:{pollyRet.ExceptionType} Msg:{pollyRet.FinalException?.Message}&quot;);

            var ctx = (AspectContext)pollyRet.Context[&quot;ctx&quot;];
            var type = ctx.ProxyMethod.ReturnType;
            if (type == typeof(void)) return;
            if (type.IsGenericType)
            {
                var geneType = type.GenericTypeArguments[0];
                dynamic ret = geneType.IsValueType ? Activator.CreateInstance(geneType) : null;
                ctx.ReturnValue = Task.FromResult(ret);
            }
            else
            {
                var ret = type.IsValueType ? Activator.CreateInstance(type) : null;
                ctx.ReturnValue = Task.FromResult(ret);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AspectCore也有Autofac的扩展，注册也是非常简单：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;builder.RegisterDynamicProxy();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过AspectCore还是需要给被代理的类添加Attribute：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[RetryByPollyAspectCoreInterceptor]
public class RedisDatabaseAsyncWrapper:IDatabaseAsync
{
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;希望大神可以扩展AspectCore的Autofac插件实现无需Attribute的代理设置。&lt;/p&gt;
&lt;p&gt;最后可以使用下面的代码测试这个异步的重试实现：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public async Task ReadTestAsync(long start, long end)
{
    var total = end - start;
    for (var i = 0; i &amp;lt;= total; i++)
    {
        var item = i + start;
        var exists = await _redisDb.SetContainsAsync(RedisKey, item);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到代理方法完美的处理了异常。&lt;/p&gt;
&lt;p&gt;文末，在这个异步方法越来越多的新时代再次强烈推荐&lt;a href=&quot;!https://github.com/dotnetcore/AspectCore-Framework&quot;&gt;AspectCore&lt;/a&gt;。&lt;br/&gt;感谢各位大神提供了这么多好用的库。感谢各位园友阅读本文。&lt;/p&gt;
</description>
<pubDate>Sun, 14 Jan 2018 13:25:00 +0000</pubDate>
<dc:creator>hystar</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lsxqw2004/p/8284365.html</dc:identifier>
</item>
<item>
<title>Java设计模式总汇二（小白也要飞） - CMusketeer</title>
<link>http://www.cnblogs.com/cmusketeer/p/8270909.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmusketeer/p/8270909.html</guid>
<description>&lt;p&gt;PS：上一篇我介绍了适配器设计模式、单例设计模式、静态代理设计模式、简单工厂设计模式，如果没有看过第一篇的小火鸡可以点这个看看&lt;a href=&quot;http://www.cnblogs.com/cmusketeer/p/8146510.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cmusketeer/p/8146510.html&lt;/a&gt;。这篇介绍一下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;MVC设计模式&lt;/li&gt;
&lt;li&gt;中介者设计模式&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;1：MVC设计模式&lt;/h2&gt;
&lt;p&gt;MVC 模式代表 Model-View-Controller（模型-视图-控制器） 模式。这种模式用于应用程序的分层开发。如果做过web项目的话，就会知道一些框架，比如说SSH（SpringMVC+Spring+Hibernate），当然有的这里的SpringMVC也可以是Struts，因为这都是MVC分层的一个框架。在web里的MVC可能比较比较好理解，因为View这个层可以直接显示出来，Controller可以直接用servlet。我们看到的网页端就是一个很好的证明（View）。其实，这个mvc和web的mvc都是一个原理，也可以说就是一种演变。&lt;/p&gt;
&lt;ul class=&quot;list&quot;&gt;&lt;li&gt;&lt;strong&gt;Model（模型）&lt;/strong&gt; - 模型代表一个存取数据的对象，也可以夹杂这一些逻辑，在数据变化时更新控制器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;View（视图）&lt;/strong&gt; - 视图代表模型包含的数据的可视化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Controller（控制器）&lt;/strong&gt; - 控制器作用于模型和视图上。它控制数据流向模型对象，并在数据变化时更新视图。它使视图与模型分离开。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里我举一个简单的例子--用户（users）升级成为vip后刷新视图重新输入控制台。&lt;/p&gt;
&lt;p&gt;（1）Model类--Users.java&lt;/p&gt;
&lt;p&gt;　　该类只写了几个属性和set、get方法。包括名字、年龄、vip、描述。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package mvcmoshi;

public class Users {
        public String name;
        public int age;
        public boolean vip;
        public String describe;
        public String getName() {
                return name;
        }
        public void setName(String name) {
                this.name = name;
        }
        public int getAge() {
                return age;
        }
        public void setAge(int age) {
                this.age = age;
        }
        public boolean isVip() {
                return vip;
        }
        public void setVip(boolean vip) {
                this.vip = vip;
        }
        public String getDescribe() {
                return describe;
        }
        public void setDescribe(String describe) {
                this.describe = describe;
        }
        
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （2）视图层View&lt;/p&gt;
&lt;p&gt;UsersView.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package mvcmoshi;
/**
 * View层
 * 显示用户信息
 * */
public class UsersView {
        public void showView(String name,int age,boolean vip,String describe){
                System.out.println(&quot;用户资料调出&quot;);
                if(vip){
                        System.out.println(&quot;姓名：&quot;+name+&quot;，年龄：&quot;+age+&quot;，身份：尊贵Vip&quot;+&quot;,描述:&quot;+describe);
                }else{
                        System.out.println(&quot;姓名：&quot;+name+&quot;，年龄：&quot;+age+&quot;，身份：平民&quot;+&quot;,描述:&quot;+describe);

                }
                
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; (3)控制层&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package mvcmoshi;

import mvcmoshi.Users;

/**
 * 控制层 主要是写对View和Model的更新控制
 * 
 */
public class UsersController {
        public Users users;
        public UsersView userView;

        public UsersController(Users user, UsersView view) {
                this.users = user;
                this.userView = view;
        }

        public void setUsersName(String name) {
                users.setName(name);
        }

        public String getUsersName() {
                return users.getName();
        }

        public void setUsersAge(int age) {
                users.setAge(age);
        }

        public int getUsersAge() {
                return users.getAge();
        }

        public void setVip(boolean vip) {
                users.setVip(vip);
        }

        public boolean getVip() {
                return users.isVip();
        }

        public void setDescribe(String describe) {
                users.setDescribe(describe);
        }

        public String getDescribe() {
                return users.getDescribe();
        }

        /**
         * 更新方法 针对view中的方法
         */
        public void updateView() {
                userView.showView(users.getName(), users.getAge(), users.isVip(), users.getDescribe());
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这里写set和get方法，是因为控制层是更新数据一层，可以看出就算是在Controller里set和get，但对象依然是Users，在model（Users）类中取出数据在View中显示出来，这才是Controller做的事。上面什么都有了，那就开始测试一下吧，随便写一个带有main方法的类即可&lt;/p&gt;
&lt;p&gt;（4）测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package mvcmoshi;

public class MainShow {

        public static void main(String[] args) {
                // TODO Auto-generated method stub
                //对用户进行赋值
                Users usersModel=new Users();
                usersModel.setName(&quot;张三&quot;);
                usersModel.setAge(23);
                usersModel.setVip(false);
                usersModel.setDescribe(&quot;此人阴险狡诈，要小心。&quot;);
                
                UsersView usersView=new UsersView();
                
                UsersController usersController=new UsersController(usersModel, usersView);
                
                usersController.updateView();
                
                //更新数据
                usersModel.setVip(true);
                usersModel.setDescribe(&quot;此人乃是贵族vip&quot;);
                usersController.updateView();
        }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/1258190/201801/1258190-20180114152945410-611558078.png&quot; alt=&quot;&quot; width=&quot;618&quot; height=&quot;125&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 2：中介者设计模式&lt;/h2&gt;
&lt;p&gt;定义：中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。中介者模式属于行为型模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;意图：&lt;/strong&gt;用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要解决：&lt;/strong&gt;对象与对象之间存在大量的关联关系，这样势必会导致系统的结构变得很复杂，同时若一个对象发生改变，我们也需要跟踪与之相关联的对象，同时做出相应的处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;何时使用：&lt;/strong&gt;多个类相互耦合，形成了网状结构。&lt;/p&gt;
&lt;p&gt;上面就是中介者的定义和使用技能，用通俗的话来解释的话就是多个类直接相互影响的时候，在中间加入一个处理层来管理或者处理一些操作，比如说，&lt;span&gt;QQ聊天的时候，张三和李四聊天，相隔很远，他们只需要把说的话输入手机，对方就可以看到信息，这个手机就是一个中介者。&lt;/span&gt;也或者说，在很多人用手机聊天的过程中，两两相关，这就形成了网状结构，这时最好把两个人发送的数据都存在服务器上，然后通过服务器再往各处发放。下面我举一个简单的例子，这个例子很简单，主要是针对这个思想展开，代码就不复杂了。（红色为例子）&lt;/p&gt;
&lt;p&gt;（1）创建中介者类&lt;/p&gt;
&lt;p&gt;里面有一个是关于格式化时间的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package zhongjiezhe;

import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * 中介者 主要是协调各对象（如用户）之间的协作。
 */
public class Service {

        /**
         * 格式化时间
         */
        public static String getNowDate() {
                Date currentTime = new Date();
                SimpleDateFormat formatter = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
                String dateString = formatter.format(currentTime);
                return dateString;
        }

        /***
         * 显示消息方法
         */
        public void showMessage(User user, String message) {

                System.out.println(getNowDate() + &quot;&amp;lt;&quot; + user.getName() + &quot;&amp;gt;:&quot; + message);

        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （2）创建   人     类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package zhongjiezhe;

public class User {
        private String name;
        private String message;

        public String getName() {
                return name;
        }

        public void setName(String name) {
                this.name = name;
        }

        public User(String name) {
                this.name = name;
        }

        public String getMessage() {
                return message;
        }

        public void setMessage(String message) {
                this.message = message;
        }

        public void sendMessage() {
                Service service = new Service();
                service.showMessage(this, message);
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）测试 &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package zhongjiezhe;

public class MainShow {
        public static void main(String[] args) {
                User zhangsan=new User(&quot;张三&quot;);
                User lisi=new User(&quot;李四&quot;);
                
                zhangsan.setMessage(&quot;四哥，你下午有空吗？&quot;);
                lisi.setMessage(&quot;三弟呀，我下午有空&quot;);
                        
                zhangsan.sendMessage();
                lisi.sendMessage();
                
                zhangsan.setMessage(&quot;那好，你帮我修一下我的电脑&quot;);
                lisi.setMessage(&quot;没问题，记得请吃饭呦&quot;);
                        
                zhangsan.sendMessage();
                lisi.sendMessage();     
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1258190/201801/1258190-20180114211601410-1901240518.png&quot; alt=&quot;&quot; width=&quot;618&quot; height=&quot;170&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结：这个中介者模式按简单的说，就是这样的，因为我这个例子简单，所以有的小火鸡们会觉得不这样写也能达到我这个效果图，确实，我只是为了让大家一看就明白，主要是思想。有的时候我们可能一直这样写，但就是不知道这就是中介者模式。23中模式有的思路也有相似之处，这一个也是在中见加了一个中间层，静态代理也是加了中间层，然后中间层处理。中介者是一个处于众多对象中间，并处理对象之间的联系。本例子是两个人，如果是多个的话，中介者的作用就更明显了。&lt;/p&gt;

</description>
<pubDate>Sun, 14 Jan 2018 13:25:00 +0000</pubDate>
<dc:creator>CMusketeer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmusketeer/p/8270909.html</dc:identifier>
</item>
<item>
<title>6、ABPZero系列教程之拼多多卖家工具 框架后台的设置 - 李子深</title>
<link>http://www.cnblogs.com/shensigzs/p/8284339.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shensigzs/p/8284339.html</guid>
<description>&lt;p&gt;　　接着上篇文章，现在去修改注册登录逻辑代码还为时过早，我们还需要到后台去设置一些配置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/488385/201801/488385-20180114201814035-1065699973.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/488385/201801/488385-20180114201827863-2050424097.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;先配置好这2项设置，邮箱配置是为了验证注册时功能是否正常，下一篇文章需要用到。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：邮箱配置中的密码并不是QQ密码，而是在QQ邮箱中生成的授权码，具体获取请登录QQ邮箱查看&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/488385/201801/488385-20180114210108816-626764336.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入后台可以看到圈出来这些单词，我们的语言已经设置为简体中文，但一些地方没有中文出现，可能作者还没来得及更新语言文件，只得我们自己去完善了。&lt;/p&gt;
&lt;p&gt;这里我以“[Appearance]”为例，其它翻译以此类推即可。&lt;/p&gt;
&lt;p&gt;打开AbpZeroTemplate.xml语言文件，搜索：“Appearance”&lt;/p&gt;
&lt;p&gt;文件路径：D:\abp version\aspnet-zero-3.4.0\aspnet-zero-3.4.0\src\MyCompanyName.AbpZeroTemplate.Core\Localization\AbpZeroTemplate\AbpZeroTemplate.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;text &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Appearance&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Appearance&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看对应的内容是什么意思，英文好的可以翻译得更好，我只得借助翻译工具，这里我翻译出来是“外观”的意思。&lt;/p&gt;

&lt;p&gt;然后打开AbpZeroTemplate-zh-CN.xml语言文件，同样搜索：“Appearance”，如果没有找到，就在文件末尾添加这个键值对。&lt;/p&gt;
&lt;p&gt;文件路径：D:\abp version\aspnet-zero-3.4.0\aspnet-zero-3.4.0\src\MyCompanyName.AbpZeroTemplate.Core\Localization\AbpZeroTemplate\AbpZeroTemplate-zh-CN.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;text &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Appearance&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;外观&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后，保存生成项目，浏览器访问，可以看到”[Appearance]“已经变成”外观“，其它翻译重复此步骤即可。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/shensigzs/p/8277860.html&quot; target=&quot;_blank&quot;&gt;返回总目录&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 14 Jan 2018 13:12:00 +0000</pubDate>
<dc:creator>李子深</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shensigzs/p/8284339.html</dc:identifier>
</item>
</channel>
</rss>