<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[机器学习Lesson 2]代价函数之线性回归算法 - mantou叔叔</title>
<link>http://www.cnblogs.com/mantoudev/p/8654863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mantoudev/p/8654863.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本章内容主要是介绍：单变量线性回归算法（Linear regression with one variable）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;线性回归算法linear-regression&quot;&gt;1. 线性回归算法（linear regression）&lt;/h2&gt;
&lt;h3 id=&quot;预测房屋价格&quot;&gt;1.1 预测房屋价格&lt;/h3&gt;
&lt;p&gt;下图是俄勒冈州波特兰市的住房价格和面积大小的关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/03/25/15HwS.png&quot; alt=&quot;数据集包含俄勒冈州波特兰市的住房价格&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该问题属于监督学习中的回归问题，让我们来复习一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;监督学习（Supervised'Learning'）:对示例数据给出“正确答案”。&lt;/li&gt;
&lt;li&gt;回归问题（Regression 'Problem'）:根据之前的数据预测出一个准确的输出值 。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;训练集&quot;&gt;1.2 训练集&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/03/25/15bGR.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;m&lt;/strong&gt;=训练样本数量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;x's&lt;/strong&gt;=输入变量/特征量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;y's&lt;/strong&gt;=输出变量/目标变量，预测结果&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（x,y）表示一个训练样本。&lt;/p&gt;
&lt;p&gt;x(1) 指的是 第一个训练集里值为2104的输入值， 这个就是第一行里的x x(2) 等于1416。这是第二个x y(1) 等于460，这是第一个训练集样本的y值， 这就是(1)所代表的含义。&lt;/p&gt;
&lt;p&gt;这就是一个监督学习算法的工作方式，我们可以看到这里有我们的训练集里房屋价格，我们把它喂给我们的学习算法，然后输出一个函数。&lt;/p&gt;
&lt;p&gt;按照惯例，通常表示为小写h代表hypothesis(假设) h表示一个函数。输入是房屋尺寸大小，就像你朋友想出售的房屋。因此，h 根据输入的 x 值来得出 y 值。 y值对应房子的价格。所以h是一个从x到y的函数映射 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;y关于x的线性函数 ：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt; hθ(x)=θ0+θ1*x &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/H6qTdZmYEeaagxL7xdFKxA_2f0f671110e8f7446bb2b5b2f75a8874_Screenshot-2016-10-23-20.14.58.png?expiry=1522108800000&amp;amp;hmac=n2jAIIfSfl__6f9ev7dTWn2Hsog5VGA-Z0T87DHpiv8&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个模型被称为&lt;code&gt;线性回归(linear regression)模型&lt;/code&gt;。 这实际上是关于单个变量的线性回归，这个变量就是x 根据x来预测所有的价格函数。同时， 对于这种模型有另外一个名称，称作&lt;code&gt;单变量线性回归&lt;/code&gt; 单变量是对一个变量的一种特别的表述方式。总而言之 这就是线性回归。&lt;/p&gt;
&lt;h2 id=&quot;代价函数cost-function&quot;&gt;2. 代价函数(Cost Function)&lt;/h2&gt;
&lt;p&gt;任何能够衡量模型预测出来的值h(θ)与真实值y之间的差异的函数都可以叫做代价函数C(θ)，如果有多个样本，则可以将所有代价函数的取值求均值，记做J(θ)。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;J(θ0,θ1)=12m$\sum$i=1m(y^i−yi)2=12m∑i=1m(hθ(xi)−yi)2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/R2YF5Lj3EeajLxLfjQiSjg_110c901f58043f995a35b31431935290_Screen-Shot-2016-12-02-at-5.23.31-PM.png?expiry=1522108800000&amp;amp;hmac=8ZeyaUFzKWyJXCFkV4sjsT_K_gGKXPSUiYVrqNUJuLE&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;m：训练样本的个数；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;hθ(x)：用参数θ和x预测出来的y值；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;y：原训练样本中的y值，也就是标准答案&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;上角标(i)：第i个样本&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;代价函数1简化版当θ00时&quot;&gt;3. 代价函数1(简化版):当θ0=0时&lt;/h2&gt;
&lt;p&gt;hθ(x)=θ1x，如下图：&lt;/p&gt;
&lt;h5 id=&quot;重要公式&quot;&gt;重要公式&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/03/26/1aftG.md.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Hypothesis: 假设。这个例子中是尺寸对于房价关系的预测。&lt;/li&gt;
&lt;li&gt;Parameters: 参数。&lt;/li&gt;
&lt;li&gt;Cost Function：代价函数。&lt;/li&gt;
&lt;li&gt;Goal: 优化目标。代价最小化。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;斜率为1时的代价函数&quot;&gt;3.1 斜率为1时的代价函数&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/03/26/1aoPz.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;假设函数&quot;&gt;（1）假设函数&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;x轴为面积，y轴为房价&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设函数 h(x) 对于一个固定的θ1，这是一个关于x 的函数。 所以这个假设函数就是一个关于 x 这个房子大小的函数。&lt;/p&gt;
&lt;h5 id=&quot;代价函数&quot;&gt;（2）代价函数&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;x轴为假设函数的斜率，y即代价大小&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代价函数 J 是一个关于参数 θ1 的函数，而 θ1 控制着这条直线的斜率 。&lt;/p&gt;
&lt;h3 id=&quot;斜率为0.5时的代价函数&quot;&gt;3.2 斜率为0.5时的代价函数&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/03/26/1aiwn.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;斜率为0.5时，取3个样本（m=3）：（0.5，1），（1，2），（1.5，3）。套公式得出J(0.5)=0.58&lt;br/&gt;同理，J(0)=1/6(1²+2²+3²)=14/6，求出更多的点之后，我们得出类似以下函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/fph0S5tTEeajtg5TyD0vYA_9b28bdfeb34b2d4914d0b64903735cf1_Screenshot-2016-10-26-01.09.05.png?expiry=1522195200000&amp;amp;hmac=1xri9uBVBuQVe6ScQSTnCvlDDFoPmckT1XpI95sv5G8&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;学习算法的优化目标是我们想找到一个 θ1 的值，来将 J(θ1) 最小化。这是我们线性回归的目标函数。 上面的曲线中，让 J(θ1) 最小化的值是 θ1=1。这个确实就对应着最佳的通过了数据点的拟合直线 。这条直线就是由 θ1=1 的设定而得到的。 对于这个特定的训练样本，我们最后能够完美地拟合 这就是为什么最小化 J(θ1)，对应着寻找一个最佳拟合直线的目标。&lt;/p&gt;
&lt;h2 id=&quot;代价函数2完整版&quot;&gt;4. 代价函数2:完整版&lt;/h2&gt;
&lt;p&gt;包含θ0、θ1两个参数的代价函数呈现出来的是类似下图的三维曲面图，两个轴分别表示θ0、θ1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/03/26/1rDX6.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在ML中，一般使用轮廓图( contour plot 或 contour figure 的意思)描述该模型。&lt;/p&gt;
&lt;h3 id=&quot;轮廓图简介&quot;&gt;4.1 轮廓图简介&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/03/26/1r7za.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;右侧图形就是一个轮廓图，两个轴分别表示θ0和θ1。 而这些一圈一圈的椭圆形，每一个圈就表示J(θ0,θ1) 相同的所有点的集合。&lt;/p&gt;
&lt;p&gt;如图选取三个点，这三个点都表示相同的 J(θ0,θ1) 的值。横纵坐标分别是θ0, θ1 这三个点的 J(θ0,θ1) 值是相同的。我们需要算的代价函数即为圆心的点，此时我们的代价最小。&lt;/p&gt;
&lt;h3 id=&quot;第一组数据&quot;&gt;4.2 第一组数据&lt;/h3&gt;
&lt;p&gt;我们选取一组数据，&lt;code&gt;θ0=800&lt;/code&gt;，&lt;code&gt;θ1=-0.15&lt;/code&gt;，此时我们可以对应得到一个左边这样一条线。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax2x.com/2018/03/26/1rdmz.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以这组 θ0，θ1 为参数的这个假设 h(x) 并不是数据的较好拟合。并且你也发现了这个代价值 距离最小值点还很远。也就是说这个代价值还是算比较大的，因此不能很好拟合数据。&lt;/p&gt;
&lt;h3 id=&quot;第二组数据&quot;&gt;4.3 第二组数据&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/26RZhJ34EeaiZBL80Yza_A_0f38a99c8ceb8aa5b90a5f12136fdf43_Screenshot-2016-10-29-01.14.57.png?expiry=1522195200000&amp;amp;hmac=AL3qFB6_LzKcW_jSVemBAgtHpc1AwYHVvmb7V-d2UIQ&quot; alt=&quot;选取第二组数据&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;θ0=360&lt;/code&gt;，&lt;code&gt;θ1=0&lt;/code&gt;。我们可以得到&lt;code&gt;h(x)=360+0*x&lt;/code&gt;这样一条直线。同样不能很好的拟合数据。&lt;/p&gt;
&lt;h3 id=&quot;第三组数据&quot;&gt;4.4 第三组数据&lt;/h3&gt;
&lt;p&gt;最后一个例子：&lt;br/&gt;&lt;img src=&quot;https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/hsGgT536Eeai9RKvXdDYag_2a61803b5f4f86d4290b6e878befc44f_Screenshot-2016-10-29-09.59.41.png?expiry=1522195200000&amp;amp;hmac=hBDFyW_21XQnlj6qL-WMUTZv_UiegDc_L2M1Gic08EU&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个点其实不是最小值，但已经非常靠近最小值点了。 这个点对数据的拟合就很不错，它对应这样两个θ0 和 θ1 的值。同时也对应这样一个 h(x) 这个点虽然不在最小值点，但非常接近了。 因此误差平方和，或者说 训练样本和假设的距离的平方和，这个距离值的平方和 非常接近于最小值，尽管它还不是最小值。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;5. 小结&lt;/h2&gt;
&lt;p&gt;通过这些图形，本篇文章主要是帮助理解这些代价函数 J 所表达的值；它们是什么样的它们对应的假设是什么样的；以及什么样的假设对应的点更接近于代价函数J的最小值。&lt;/p&gt;
&lt;p&gt;我们真正需要的是一种有效的算法，能够自动地找出这些使代价函数J取最小值的参数θ0和θ1来。我们也不希望编个程序 把这些点画出来，然后人工的方法来读出这些点的数值，这很明显不是一个好办法。&lt;/p&gt;
&lt;p&gt;事实上在深入机器学习的过程中， 我们会遇到更复杂、更高维度、更多参数的情况。而这些情况是很难画出图的，因此更无法将其可视化，因此我们真正需要的，是编写程序来找出这些最小化代价函数的θ0和θ1的值。在后续文章中将介绍一种算法 能够自动地找出能使代价函数 J最小化的参数θ0和θ1的值。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本文资料部分来源于吴恩达 (Andrew Ng) 博士的斯坦福大学机器学习公开课视频教程。&lt;/p&gt;
&lt;p&gt;[1]网易云课堂机器学习课程：&lt;br/&gt;&lt;a href=&quot;http://open.163.com/special/opencourse/machinelearning.html&quot; class=&quot;uri&quot;&gt;http://open.163.com/special/opencourse/machinelearning.html&lt;/a&gt;&lt;br/&gt;[2]coursera课程：&lt;br/&gt;&lt;a href=&quot;https://www.coursera.org/learn/machine-learning/&quot; class=&quot;uri&quot;&gt;https://www.coursera.org/learn/machine-learning/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Mar 2018 15:33:00 +0000</pubDate>
<dc:creator>mantou叔叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mantoudev/p/8654863.html</dc:identifier>
</item>
<item>
<title>R语言-文本挖掘 - 月上贺兰</title>
<link>http://www.cnblogs.com/luhuajun/p/8654854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luhuajun/p/8654854.html</guid>
<description>&lt;p&gt;---恢复内容开始---&lt;/p&gt;
&lt;p&gt;案例1:对主席的新年致辞进行分词,绘制出词云&lt;/p&gt;
&lt;p&gt;掌握jieba分词的用法&lt;/p&gt;
&lt;p&gt;1.加载包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;library(devtools)
library(tm)
library(jiebaR)
library(jiebaRD)
library(tmcn)
library(NLP)&lt;br/&gt;library(wordcloud2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.导入数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
news &amp;lt;- readLines(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\Udacity\\Data Analysis High\\R\\R_Study\\高级课程代码\\数据集\\第一天\\2文本挖掘\\xitalk2017.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
head(news)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326190334397-918775898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.清洗数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 去除新闻中的英文&lt;/span&gt;
gsub(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[0-9,a-z,A-Z]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;,news) -&amp;gt;&lt;span&gt; news 
segword_tmp &lt;/span&gt;=&lt;span&gt;worker()
segword &lt;/span&gt;= segword_tmp &amp;lt;=&lt;span&gt; news
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 加载停用词表&lt;/span&gt;
stopwords = readLines(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\Udacity\\Data Analysis High\\R\\R_Study\\第一天数据\\中文停用词表.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
head(stopwords,&lt;/span&gt;10)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.移除感叹词&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
removewords &amp;lt;-&lt;span&gt; function(targetword,stopword){
  targetword &lt;/span&gt;= targetword[targetword%&lt;span&gt;in&lt;/span&gt;%stopword ==&lt;span&gt; F]
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(targetword)
}

segword2 &lt;/span&gt;&amp;lt;- sapply(X=segword, FUN =&lt;span&gt; removewords,stopwords)
head(segword2)


segword2[[&lt;/span&gt;1&lt;span&gt;]]
length(unlist(segword))
length(unlist(segword2))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326190713416-955186484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.绘制词云&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
letterCloud(word_freq, word = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,color = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;random-dark&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,backgroundColor = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;snow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
wordcloud2(word_freq, size &lt;/span&gt;= 1,shape = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;circle&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326190849276-375642154.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;案例2:通过拉勾网的数据进行分析,找出数据分析师相关的城市,薪水,工作年限等信息&lt;/p&gt;
&lt;p&gt;数据集下载：链接:&lt;a class=&quot;uri&quot; href=&quot;https://pan.baidu.com/s/1Bz7mA_dnvD1MGTVrZKyhPA&quot;&gt;https://pan.baidu.com/s/1Bz7mA_dnvD1MGTVrZKyhPA&lt;/a&gt; 密码:layp&lt;/p&gt;
&lt;p&gt;目的:掌握文本分析,数据报表结论展示&lt;/p&gt;
&lt;p&gt;数据集字段说明:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;字段      　　描述                        用途
id     　　  唯一标识         　　与数据库表主键功能类似，用于处理表关联
title       岗位名称      　　　　作为岗位的标识，与雇主和岗位描述组合成唯一标识
company     公司名称    　　　　　作为雇主的标识
salary      平均月薪(k)  　　　　 用于平均月薪的分析
city        工作所在城市    　　　用于分析地域
scale       规模     　　  　　　用于区别企业的指标
phase       融资&lt;/span&gt;/&lt;span&gt;发展阶段   　　　用于区别企业的指标
experience  职位经验要求    　　　分析工作经验的影响
education   学历要求     　　　　分析学历的影响
description 职位描述      　　　用于文本挖掘，做岗位需求技能分析&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.加载数据集&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;library(readxl)
library(jiebaR)
library(jiebaRD)
library(zoo)
library(VIM)
library(plyr)
library(ggplot2)
library(wordcloud2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.加载数据集&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
CN.df &amp;lt;- read_excel(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\\Udacity\\Data Analysis High\\R\\R_Study\\CN_lagou_jobdata.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,1&lt;span&gt;)

CN.df &lt;/span&gt;&amp;lt;- CN.df[,c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;experience&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;education&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;campany&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;scale&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;scale2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;phase&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)]
str(CN.df)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326213347258-758725620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.查看是否有缺失值,以及常用函数的定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看是否有缺失值&lt;/span&gt;
aggr(CN.df,prop=T,numbers=&lt;span&gt;T)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回分词频数表的排序&lt;/span&gt;
top.freq &amp;lt;- function(x,topn=&lt;span&gt;0){
  require(plyr)
  top.df &lt;/span&gt;&amp;lt;-&lt;span&gt; count(x) 
  top.df &lt;/span&gt;&amp;lt;- top.df[order(top.df$freq,decreasing =&lt;span&gt; TRUE),]
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(topn &amp;gt; 0) &lt;span&gt;return&lt;/span&gt;(top.df[1&lt;span&gt;:topn,])
  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;  &lt;span&gt;return&lt;/span&gt;&lt;span&gt;(top.df)
}

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 排序&lt;/span&gt;
reorder_size &amp;lt;- function(x,decreasing=&lt;span&gt;T){
  factor(x,levels &lt;/span&gt;= names(sort(table(x),decreasing=&lt;span&gt;decreasing)))
}

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ggplot自定义主题&lt;/span&gt;
my.ggplot.theme &amp;lt;- function(...,bg=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;){
  require(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;guid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  theme_classic(...)&lt;/span&gt;+&lt;span&gt;
    theme(rect &lt;/span&gt;= element_rect(fill =&lt;span&gt; bg),
          plot.title &lt;/span&gt;= element_text(hjust = 0.5&lt;span&gt;),
          text &lt;/span&gt;= element_text(family = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;STHeiti&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
          panel.background &lt;/span&gt;= element_rect(fill=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;transparent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#333333&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
          axis.line &lt;/span&gt;= element_line(color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#333333&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,size = 0.25&lt;span&gt;),
          legend.key &lt;/span&gt;= element_rect(fill=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;transparent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,colour = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;transparent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
          panel.border &lt;/span&gt;= element_rect(fill=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;transparent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,colour = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;transparent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
          panel.grid &lt;/span&gt;= element_line(colour = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;grey95&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
          panel.grid.major &lt;/span&gt;= element_line(colour = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;grey92&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,size = 0.25&lt;span&gt;),
          panel.grid.minor &lt;/span&gt;= element_line(colour = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;grey92&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,size = 0.1&lt;span&gt;))
}

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 多图展示&lt;/span&gt;
mutiplot &amp;lt;- function(...,plotlist=NULL,file,cols=1,layout=&lt;span&gt;NULL){
  library(grid)
  plots &lt;/span&gt;&amp;lt;-&lt;span&gt; c(list(...),plotlist)
  numPlots &lt;/span&gt;&amp;lt;-&lt;span&gt; length(plots)
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;is&lt;/span&gt;&lt;span&gt;.null(layout)){
    layout &lt;/span&gt;&amp;lt;- matrix(seq(1,cols*ceiling(numPlots/&lt;span&gt;cols)),
                     ncol &lt;/span&gt;=&lt;span&gt; cols,
                     nrow &lt;/span&gt;= ceiling(numPlots/&lt;span&gt;cols))
  }
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(numPlots == 1&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(plot[[1&lt;span&gt;]])
  }
  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
    grid.newpage()
    pushViewport(viewport(layout &lt;/span&gt;=&lt;span&gt; grid.layout(nrow(layout),ncol(layout))))
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i &lt;span&gt;in&lt;/span&gt; 1&lt;span&gt;:numPlots){
      matchidx &lt;/span&gt;&amp;lt;- as.data.frame(which(layout==i,arr.ind =&lt;span&gt; T))
      &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(plots[[i]],vp=viewport(layout.pos.row = matchidx$row,layout.pos.col =&lt;span&gt; matchidx$col))
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326214006519-55685442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:没有缺失值&lt;/p&gt;
&lt;p&gt;4.数据清洗整理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
cleaning &amp;lt;-&lt;span&gt; function(my.data){
  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 去掉重复值&lt;/span&gt;
  my.data &amp;lt;- my.data[!duplicated(my.data[c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;campany&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)]),]
  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算平均月薪&lt;/span&gt;
  max_sal &amp;lt;- as.numeric(sub(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;([0-9]*).*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\\1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,my.data$salary))
  min_sal &lt;/span&gt;&amp;lt;- as.numeric(sub(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.*-([0-9]*).*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\\1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,my.data$salary))
  my.data$avg_sal &lt;/span&gt;&amp;lt;- (max_sal+min_sal)/2
  
  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;清理不需要的字符,将需要分析的字符转换成因子&lt;/span&gt;
  my.data$city &amp;lt;- factor(gsub(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[/]*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,my.data$city))
  
  my.data$experience &lt;/span&gt;&amp;lt;- gsub(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;经验|[/ ]*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,my.data$experience)
  my.data$experience[my.data$experience &lt;/span&gt;%&lt;span&gt;in&lt;/span&gt;% c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;不限&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;应届毕业生&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)] &amp;lt;- &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1年以下&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  my.data$experience&lt;/span&gt;&amp;lt;-&lt;span&gt; factor(my.data$experience,
                              levels &lt;/span&gt;= c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1年以下&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1-3年&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3-5年&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;5-10年&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;10年以上&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
  my.data$education &lt;/span&gt;&amp;lt;- gsub(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;学历|及以上|[/ ]*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,my.data$education)
  my.data$education[my.data$education &lt;/span&gt;== &lt;span&gt;'&lt;/span&gt;&lt;span&gt;不限&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &amp;lt;- &lt;span&gt;'&lt;/span&gt;&lt;span&gt;大专&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
  my.data$education &lt;/span&gt;&amp;lt;-&lt;span&gt; factor(my.data$education,
                              levels &lt;/span&gt;= c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;大专&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;本科&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;硕士&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
  my.data$phase &lt;/span&gt;&amp;lt;- factor(gsub(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[\n]*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,my.data$phase),
                        levels&lt;/span&gt;=c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;不需要融资&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;未融资&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;天使轮&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A轮&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;B轮&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C轮&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D轮及以上&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;上市公司&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
  my.data$campany &lt;/span&gt;&amp;lt;- gsub(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[\n| ]*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,my.data$campany)
  my.data$scale &lt;/span&gt;&amp;lt;- factor(gsub(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.*(少于15人|15-50人|50-150人|150-500人|500-2000人|2000人以上).*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                                 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\\1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,paste(my.data$scale,my.data$scale2)),
                           levels &lt;/span&gt;=c(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;少于15人&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;15-50人&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;50-150人&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;150-500人&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;500-2000人&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2000人以上&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
  my.data$id &lt;/span&gt;&amp;lt;-&lt;span&gt; index(my.data)
  my.data &lt;/span&gt;&amp;lt;- droplevels(subset(my.data,select=-&lt;span&gt;scale2))
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(my.data)
}

CN.clean &lt;/span&gt;&amp;lt;-&lt;span&gt; cleaning(CN.df)
str(CN.clean)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326222351946-1992381770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:转化成结构化数据&lt;/p&gt;
&lt;p&gt;5.开始进行分词统计&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 采用默认的jieba分词器&lt;/span&gt;
engine &amp;lt;- worker(user = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E://Udacity//R//R-3.4.3//library//jiebaRD//dict//user.dict.utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 去除无关的词&lt;/span&gt;
word.lis &amp;lt;-&lt;span&gt; lapply(CN.clean$description, function(x){
  v &lt;/span&gt;&amp;lt;- gsub(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[\u4e00-\u9fa5|0-9|\\.|\\-]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;&lt;span&gt;,segment(x,engine))
  v &lt;/span&gt;&amp;lt;- v[v!=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;]
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(v)
})
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 所有的词语转化成大写,避免出现大小写的错误&lt;/span&gt;
segWord &amp;lt;-&lt;span&gt; toupper(unlist(word.lis))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 加载stop词语列表&lt;/span&gt;
stopWords &amp;lt;- toupper(readLines(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E://Udacity//R//R-3.4.3//library//jiebaRD//dict//stop_words.utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 过滤分词&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 此处确保我要得到的前15个关键技能是正确的数据分析技能&lt;/span&gt;
removewords &amp;lt;-&lt;span&gt; function(targetword,stopword){
  targetword &lt;/span&gt;= targetword[targetword%&lt;span&gt;in&lt;/span&gt;%stopword ==&lt;span&gt; F]
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(targetword)
}

segword&lt;/span&gt;&amp;lt;- sapply(X=segWord, FUN =&lt;span&gt; removewords,stopWords)

word_freq &lt;/span&gt;&amp;lt;- top.freq(unlist(segword),15&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 成有id和keyword构建的数据框&lt;/span&gt;
id &amp;lt;-&lt;span&gt; NULL
keyword &lt;/span&gt;&amp;lt;-&lt;span&gt; NULL
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; index(word.lis)){
  id &lt;/span&gt;&amp;lt;-&lt;span&gt; c(id,rep(i,length(word.lis[[i]])))
  keyword &lt;/span&gt;&amp;lt;-&lt;span&gt; c(keyword,word.lis[[i]])
}
keyword.df &lt;/span&gt;&amp;lt;- data.frame(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;=id,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;keyword&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;=&lt;span&gt;toupper(keyword))
keyword.df &lt;/span&gt;&amp;lt;- droplevels(keyword.df[keyword.df$keyword %&lt;span&gt;in&lt;/span&gt;%&lt;span&gt; word_freq$x,])

merge.df &lt;/span&gt;&amp;lt;- merge(CN.clean,keyword.df,by = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

summary(merge.df)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326223234252-1483662579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.生成词云的常用词&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;hljs&quot;/&gt;&lt;/span&gt;&lt;br/&gt;keys &amp;lt;- worker(type = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;keywords&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
               user &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E://Udacity//R//R-3.4.3//library//jiebaRD//dict//user.dict.utf8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
               topn &lt;/span&gt;= 20&lt;span&gt;,
               encoding &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
               stop_word &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E://Udacity//R//R-3.4.3//library//jiebaRD//dict//stop_words.utf8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
keyword.lis &lt;/span&gt;&amp;lt;-&lt;span&gt; lapply(CN.clean$description, function(x){
  v &lt;/span&gt;&amp;lt;- gsub(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[a-zA-Z|0-9|\\.|\\-]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;,keywords(x,keys))
  v &lt;/span&gt;&amp;lt;- v[v!=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;]
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(v)
})
keyword.lis &lt;/span&gt;&amp;lt;-&lt;span&gt; unlist(keyword.lis)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;形成词频表&lt;/span&gt;
&lt;span&gt;not&lt;/span&gt;.tool.keyword &amp;lt;-&lt;span&gt; top.freq(keyword.lis)
str(&lt;/span&gt;&lt;span&gt;not&lt;/span&gt;.tool.keyword)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326223554128-1105807600.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7.查看数据集&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;attach(CN.clean)&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;#观测数据清洗后的统计信息&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;summary(CN.clean[c(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;phase&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;scale&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;education&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;experience&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;avg_sal&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326223640067-643981822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8.通过数据集回答问题&lt;/p&gt;
&lt;p&gt;　　8.1&lt;code&gt;不同地区的数据分析师岗位的薪资和需求的分布&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建ggplot绘图对象&lt;/span&gt;
p.cn &amp;lt;- ggplot(CN.clean) +&lt;span&gt; my.ggplot.theme()

city.table &lt;/span&gt;&amp;lt;-&lt;span&gt; data.frame(prop.table(table(reorder_size(city,T))))
names(city.table)[&lt;/span&gt;1] &amp;lt;- &lt;span&gt;'&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
p1 &lt;/span&gt;&amp;lt;- ggplot(city.table,aes(x=city,y=Freq))+&lt;span&gt;
  my.ggplot.theme()&lt;/span&gt;+&lt;span&gt;
  geom_bar(fill&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;turquoise3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,stat = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  labs(x&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;城市&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;不同城市需求占总量的比率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  scale_y_continuous(labels &lt;/span&gt;=&lt;span&gt; scales::percent)

group_diff &lt;/span&gt;&amp;lt;- diff(range(avg_sal))/20&lt;span&gt;
p2 &lt;/span&gt;&amp;lt;- p.cn+geom_histogram(aes(x=avg_sal,y=&lt;span&gt;..density..),
                          binwidth &lt;/span&gt;= group_diff,fill=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;turquoise3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  stat_density(geom &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;line&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,position = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,aes(x=avg_sal),color=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;brown1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  labs(x&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;月薪(K/月)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
mutiplot(p1,p2,cols &lt;/span&gt;= 1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326225531469-59270294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326225547849-444382331.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:1.北京，上海，杭州，深圳，广州”占据了近90%的需求量,是数据分析师的首选&lt;/p&gt;
&lt;p&gt;　　　　 2.数据分析师平均月薪为18.22k，月薪的分布主要集中在10k~25k之间，拿到10k以上薪资的机会比较大&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
CN.clean$type&amp;lt;-&lt;span&gt; NA
CN.clean$type[CN.clean$city &lt;/span&gt;%&lt;span&gt;in&lt;/span&gt;% top.freq(city,5)$x] &amp;lt;- &lt;span&gt;'&lt;/span&gt;&lt;span&gt;top5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
CN.clean$type[&lt;/span&gt;&lt;span&gt;is&lt;/span&gt;.na(CN.clean$type)] &amp;lt;- &lt;span&gt;'&lt;/span&gt;&lt;span&gt;other&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
CN.clean$type &lt;/span&gt;&amp;lt;- factor(CN.clean$type,levels = c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;top5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;other&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
p.cn&lt;/span&gt;+geom_boxplot(aes(x=city,y=avg_sal,fill=CN.clean$type))+&lt;span&gt;
  labs(x&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;城市&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;月薪(K/月)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,fill=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;需求量排名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  theme(axis.text.x&lt;/span&gt;=element_text(angle = 30,hjust = 1) )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326225821932-1003973665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:需求量最多的5个城市的平均薪资均处于全国较高的水平，苏州是一个特例，需求量少，薪资高&lt;/p&gt;
&lt;p&gt;　　8.2 不同经验，数据分析岗位的需求分布以及对应的薪资分布&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
exp.table &amp;lt;-&lt;span&gt; prop.table(table(experience))
exp.table &lt;/span&gt;&amp;lt;-&lt;span&gt; as.data.frame(exp.table)
p3 &lt;/span&gt;&amp;lt;- ggplot(exp.table,aes(x=experience,y=Freq))+&lt;span&gt;
  my.ggplot.theme()&lt;/span&gt;+&lt;span&gt;
  geom_bar(fill&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;turquoise3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,stat = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  labs(x&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;工作经验&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;不同工作经验需求占总量的比率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  scale_y_continuous(labels &lt;/span&gt;=&lt;span&gt; scales::percent)
p4 &lt;/span&gt;&amp;lt;- p.cn + geom_boxplot(aes(x=experience,y=avg_sal),fill=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;turquoise3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  labs(x&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;工作经验&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;平均月薪(K/月)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
mutiplot(p3,p4,cols &lt;/span&gt;= 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326230158142-1789039457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:1.企业需要更有经验的分析师，主要需求集中在1-3年和3-5年经验&lt;/p&gt;
&lt;p&gt;　　　　 2.随着工作经验的增加，数据分析师的月薪有非常可观的增长&lt;/p&gt;
&lt;p&gt;　　8.3 不同学历，数据分析岗位的需求分布以及对应的薪资分布&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
edu.table &amp;lt;-&lt;span&gt; prop.table(table(education))
edu.table &lt;/span&gt;&amp;lt;-&lt;span&gt; as.data.frame(edu.table)
p5 &lt;/span&gt;&amp;lt;- ggplot(edu.table,aes(x=education,y=Freq))+&lt;span&gt;
  my.ggplot.theme()&lt;/span&gt;+&lt;span&gt;
  geom_bar(fill&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;turquoise3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,stat = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  labs(x&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;学历&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;不同学历占总量的比率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  scale_y_continuous(labels &lt;/span&gt;=&lt;span&gt; scales::percent)
p6 &lt;/span&gt;&amp;lt;- p.cn + geom_boxplot(aes(x=education,y=avg_sal),fill=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;turquoise3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  labs(x&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;学历&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;平均月薪(K/月)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
mutiplot(p5,p6,cols &lt;/span&gt;= 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326230550370-440585481.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:1.超过90%的岗位需要本科及以上的学历&lt;/p&gt;
&lt;p&gt;　　　　 2.学历随着工作经验的增长不是太明显&lt;/p&gt;
&lt;p&gt;　　8.4 不同企业规模，数据分析岗位的各项需求分布及薪资分布&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
scale.table &amp;lt;-&lt;span&gt; data.frame(prop.table(table(scale)))
p7 &lt;/span&gt;&amp;lt;- ggplot(scale.table,aes(x=scale,y=Freq))+&lt;span&gt;
  my.ggplot.theme()&lt;/span&gt;+&lt;span&gt;
  geom_bar(fill&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;turquoise3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,stat = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  labs(x&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;企业规模&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;不同企业规模需求占总量的比率&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  theme(axis.text.x &lt;/span&gt;= element_text(angle = 30,hjust = 1))+&lt;span&gt;
  scale_y_continuous(labels &lt;/span&gt;=&lt;span&gt; scales::percent)

  
p8 &lt;/span&gt;&amp;lt;- p.cn + geom_boxplot(aes(x=scale,y=avg_sal),fill=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;turquoise3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  labs(x&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;企业规模&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;平均月薪(K/月)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  theme(axis.text.x &lt;/span&gt;= element_text(angle = 30,hjust = 1&lt;span&gt;))
mutiplot(p7,p8,cols &lt;/span&gt;= 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326230806329-546371909.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:1.企业规模越大越需要数据分析师的岗位&lt;/p&gt;
&lt;p&gt;　　　　 2.企业的规模越大,薪水越高&lt;/p&gt;
&lt;p&gt;　　8.5企业规模与工作经验要求分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
sc.exp &amp;lt;- data.frame(prop.table(table(scale,experience),1&lt;span&gt;))
ggplot(data&lt;/span&gt;=sc.exp,aes(x=scale,y=Freq,fill=experience))+&lt;span&gt;
  my.ggplot.theme()&lt;/span&gt;+&lt;span&gt;
  geom_bar(stat &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  labs(x&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;企业规模&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;需求比例&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,fill=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;工作经验&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  geom_text(aes(label&lt;/span&gt;=paste(round(sc.exp$Freq,3)*100,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,sep = &lt;span&gt;''&lt;/span&gt;&lt;span&gt;)),
            colour&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;white&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,position = position_stack(.5),vjust=00)+&lt;span&gt;
  scale_y_continuous(labels &lt;/span&gt;= scales::percent)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326231127943-656110395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:综合来看50-150人的企业和2000人以上的企业对工作经验比较看重&lt;/p&gt;
&lt;p&gt;　　8.6 数据分析岗位对工具型技能的需求&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
key.df &amp;lt;-&lt;span&gt; data.frame(table(reorder_size(merge.df$keyword,TRUE)))
key.df$Freq &lt;/span&gt;&amp;lt;- key.df$Freq/&lt;span&gt;length(CN.clean$id)
ggplot(key.df)&lt;/span&gt;+my.ggplot.theme() +&lt;span&gt; 
  geom_bar(aes(x&lt;/span&gt;=Var1,y=Freq),fill = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;turquoise3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,stat = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt; 
  labs(x&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;工具型技能&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,y=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;不同技能需求占总岗位需求量的比率&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) +&lt;span&gt;
  theme(axis.text.x &lt;/span&gt;= element_text(angle = 30,hjust = 1))+&lt;span&gt;
  geom_text(aes(x&lt;/span&gt;=Var1,y=Freq,label=paste(round(key.df$Freq,3)*100,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,sep = &lt;span&gt;''&lt;/span&gt;)),vjust=-0.2)+&lt;span&gt;
  scale_y_continuous(labels &lt;/span&gt;= scales::percent)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326231340182-782993993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:SQL,R,Python,Excel是数据分析师的必备技能，超过78%的岗位都要求掌握SQL,SQL是数据分析师的必备技能,R语言的需求量居于第二&lt;/p&gt;
&lt;p&gt;　　8.7 工具型技能与薪资的分析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
merge.df$type &amp;lt;-&lt;span&gt; NA
merge.df$type[merge.df$keyword &lt;/span&gt;%&lt;span&gt;in&lt;/span&gt;% top.freq(merge.df$keyword,5)$x] &amp;lt;- &lt;span&gt;'&lt;/span&gt;&lt;span&gt;top5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
merge.df$type[&lt;/span&gt;&lt;span&gt;is&lt;/span&gt;.na(merge.df$type)] &amp;lt;- &lt;span&gt;'&lt;/span&gt;&lt;span&gt;other&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
merge.df$type &lt;/span&gt;&amp;lt;- factor(merge.df$type,levels = c(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;top5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;other&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
ggplot(merge.df)&lt;/span&gt;+my.ggplot.theme()+&lt;span&gt;
  geom_boxplot(aes(x&lt;/span&gt;=keyword,y=avg_sal,fill=merge.df$type))+&lt;span&gt;
  labs(x &lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;工具型技能&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,y=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;平均月薪(K/月)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,fill=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;需求量排名&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;
  theme(axis.text.x &lt;/span&gt;= element_text(angle = 30,hjust = 1))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326231537359-1542841953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:收入最高的数据分析技能是HADOOP,HIVE,SPARK,R,PYTHON&lt;/p&gt;
&lt;p&gt;　　8.8 绘制词云&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
wordcloud2(&lt;span&gt;not&lt;/span&gt;.tool.keyword,size = 0.9,fontFamily = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;微软雅黑&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173792/201803/1173792-20180326231702139-847566031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　结论:1.从地域上看北京,上海,深圳,广州,杭州市数据分析师的首选城市,苏州也是一个可选城市,但是需求量较低&lt;/p&gt;
&lt;p&gt;　　　　 2.从企业方来看,企业更需要具备工作经验,解决实际问题的人才,随着工作年限的增加,对应的薪资也有可观的增长&lt;/p&gt;
&lt;p&gt;　　　　 3.从大环境看,由于很多自动化分析软件的普及,使得现有的业务人员也可以快速的转行进行数据分析,所以对新手来说并不是很友好&lt;/p&gt;
&lt;p&gt;　　　　 4.50-150人的企业比较适合新人去锻炼增加经验值,此外越大的公司对数据分析人才的需求量越大&lt;/p&gt;
&lt;p&gt;　　　　 5.从分析师的角度来说则更需要注重项目的积累和新技术的掌握,相对于业务方向,数据挖掘会有更加可观的薪资&lt;/p&gt;
&lt;p&gt;　　　　 6.数据分析师需要掌握SQL,R,PYTHON,EXCEL四种必备工具,如果想转行大数据开发,则需要掌握HADOOP,HIVE,SPARK&lt;/p&gt;
&lt;p&gt;　　　　 7.数据分析师还需要注重逻辑思维、表达沟通、分析报告、报告书写等关键能力&lt;/p&gt;

</description>
<pubDate>Mon, 26 Mar 2018 15:31:00 +0000</pubDate>
<dc:creator>月上贺兰</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luhuajun/p/8654854.html</dc:identifier>
</item>
<item>
<title>Java高级篇（一）——线程 - 0o霏霏o0</title>
<link>http://www.cnblogs.com/adamjwh/p/8654008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adamjwh/p/8654008.html</guid>
<description>&lt;p&gt;　　前面我们系统的了解了Java的基础知识，本篇开始将进入到Java更深层次的介绍，我们先来介绍一下Java中的一个重要的概念——线程。&lt;/p&gt;
&lt;h2&gt;一、什么是线程&lt;/h2&gt;
&lt;p&gt;　　在了解线程前，我们首先要了解进程的概念。进程是操作系统调度和分配资源的基本单位，进程之间的通信需要通过专门的系统机制，比如消息、socket和管道来完成。而线程是比进程更小的执行单位，每个线程拥有自己的栈和寄存器等资源数据，多个线程之间共享进程的代码、数据和文件。&lt;/p&gt;
&lt;p&gt;　　那为什么要引入线程的概念？或者说线程有什么优点？&lt;/p&gt;
&lt;p&gt;　　举个简单的例子，我们在使用电脑时，可以使用它听歌，可以使用它打印文件，也可以使用它看电影，而这些活动完全可以同时进行，这种思想在Java中被称为并发，线程就是并发完成的每一件事情。&lt;/p&gt;
&lt;p&gt;　　线程的优点有如下几条：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个线程比创建一个进程的代价要小&lt;/li&gt;
&lt;li&gt;线程的切换比进程间的切换代价小&lt;/li&gt;
&lt;li&gt;充分利用多处理器&lt;/li&gt;
&lt;li&gt;数据共享（数据共享使得线程之间的通信比进程间的通信更高效）&lt;/li&gt;
&lt;li&gt;快速响应特性（在系统繁忙的情况下，进程通过独立的线程及时响应用户的输入 ）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　在单线程中，程序代码按调用顺序依次往下执行，如果需要一个进程同时完成多段代码的操作，就需要产生多线程。&lt;/p&gt;
&lt;h2&gt;二、线程的实现&lt;/h2&gt;
&lt;p&gt;　　在Java中主要提供了两种方式实现线程，下面分别介绍一下这两种方式。&lt;/p&gt;
&lt;h3&gt;　　1. 继承Thread类&lt;/h3&gt;
&lt;p&gt;　　在Java中可通过继承java.lang.Thread类来实现线程，语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　而完成线程真正功能的代码在run()方法中，且run()方法的语法格式固定，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　之后通过调用start()方法启动线程，如果start()方法调用一个已经启动的线程，会抛出IllegalThreadStateException异常。&lt;/p&gt;
&lt;p&gt;　　下面看一个实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyThread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         i++&lt;span&gt;;    
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        System.out.println(i);    
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         MyThread myThread1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         MyThread myThread2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         MyThread myThread3 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyThread();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        myThread1.start();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        myThread2.start();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        myThread3.start();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里定义了三个线程，分别执行start()方法，运行结果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1018770/201803/1018770-20180326211918465-1592834983.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果不调用start()方法，线程永远都不会启动，在主方法没有调用start()方法之前，Thread对象只是一个实例，而不是一个真正的线程。&lt;/p&gt;
&lt;h3&gt;　　2. 实现Runnable接口&lt;/h3&gt;
&lt;p&gt;　　我们知道每次只能继承一个类，如果此时要在使用线程的前提下还要继承其他类，就需要使用Runnable接口了。语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyThread &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果还要继承其他类，语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyThread &lt;span&gt;extends&lt;/span&gt; Object &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　实现Runnable接口的程序会创建一个Thread对象，并将Runnable对象与Thread对象相关联。例如如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable(){

　　@Override
&lt;/span&gt;&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
　　　　i&lt;/span&gt;++&lt;span&gt;;    
　　　　System.out.println(i);    
　　}
&lt;br/&gt;}).start();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在Thread对象中实现Runnable接口，并将其start()。&lt;/p&gt;
&lt;h2&gt;三、生命周期&lt;/h2&gt;
&lt;p&gt;　　线程的生命周期包含出生状态、就绪状态、运行状态、等待状态、休眠状态、阻塞状态和死亡状态7种状态。当用户创建线程时线程处于出生状态；在用户调用start()方法后线程处于就绪状态；当线程得到资源后进入运行状态；当在运行态调用wait()方法时线程处于等待状态，此时必须调用notify()方法才能被唤醒，notifyAll()可以唤醒所有处于等待状态下的线程；当线程调用sleep()方法时会进入休眠状态；如果一个线程在运行状态下发出输入/输出请求，该线程将进入阻塞状态，在其等待输入/输出结束时线程进入就绪状态；当线程的run()方法执行完毕时线程进入死亡状态。（具体内容可参考操作系统）&lt;/p&gt;
&lt;p&gt;　　下图为线程生命周期状态图，可对照上述文字加以理解。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1018770/201803/1018770-20180326213758422-1099741618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、线程的休眠/加入/中断/礼让&lt;/h2&gt;
&lt;h3&gt;　　1. 线程的休眠(sleep)&lt;/h3&gt;
&lt;p&gt;　　调用sleep()方法，该方法需要一个参数用于指定线程休眠时间，单位为ms，通常用在run()方法内的循环中被使用，注意要使用try···catch包围。语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(InterruptedException e) {
    e.printStackTrace();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用了sleep()方法的线程在一段时间内会醒来，但是并不能保证它醒来后进入运行状态，只能保证它进入就绪状态。&lt;/p&gt;
&lt;h3&gt;　　2. 线程的加入(join)&lt;/h3&gt;
&lt;p&gt;　　假设有一个线程A，现在需要插入线程B，并要求线程B先执行完毕，然后再继续执行线程A，此时可以使用join()方法来完成。当某个线程使用join()方法加入到另一个线程时，另一个线程会等待该线程执行完毕再继续执行。语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Thread.join();
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3. 线程的中断(stop/interrupt)&lt;/h3&gt;
&lt;p&gt;　　stop()方法可以停止线程，但JDK早已废除，同时也不建议使用stop()方法来停止一个线程的运行。可在run()方法中使用无限循环的形式，然后使用一个布尔型标记控制循环的停止。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; InterruptedTest &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isContinue = &lt;span&gt;false&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记变量，默认值为false&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;... 此部分代码省略&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(isContinue) {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为true时，停止线程&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     
&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果线程因为使用了sleep()或wait()方法进入了就绪状态，这时可以使用Thread类中的interrupt()方法使线程离开run()方法，同时结束线程，但会抛出InterruptedException异常。语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Thread.interrupt();
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　4. 程序的礼让(yield)&lt;/h3&gt;
&lt;p&gt;　　Thread类中提供了一种礼让方法yield()，用于给当前正处于运行状态下的线程一个提醒，告知它可以将资源礼让给其他线程。&lt;/p&gt;
&lt;p&gt;　　yield()方法使具有同样优先级的线程有进入可执行状态的机会，当当前线程放弃执行权时会再度回到就绪状态。&lt;/p&gt;
&lt;h2&gt;五、线程同步&lt;/h2&gt;
&lt;p&gt;　　多线程中，可能会发生两个线程抢占资源的问题，例如两个人同时过一个独木桥。所以Java提供线程同步机制来防止这些资源访问的冲突。&lt;/p&gt;
&lt;h3&gt;　　1. 线程同步机制&lt;/h3&gt;
&lt;p&gt;　　在多线程中，多个线程共享同一个资源可能会出现一些问题，比如下面这个例子，火车售票系统。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadSafeTest &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; num = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(num&amp;gt;0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     Thread.sleep(100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 System.out.println(&quot;车票剩余：&quot; + num-- + &quot;张&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         ThreadSafeTest test = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadSafeTest();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         Thread tA = &lt;span&gt;new&lt;/span&gt; Thread(test);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化4个线程&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         Thread tB = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(test);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         Thread tC = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(test);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         Thread tD = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(test);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         tA.start();        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动线程&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        tB.start();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        tC.start();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        tD.start();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     
&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行结果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1018770/201803/1018770-20180326224559584-1275137303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里出现了剩余-1张的情况，究其原因是因为同时创建了4个线程，都执行run()方法时，四个线程对num都有储存功能，当线程1执行run()方法时，还没来得及递减，此时线程2、3、4都进入了run()方法，发现num仍大于0，但此时线程1休眠时间已到，将num变量递减，同时线程2、3、4也对num变量进行递减操作，从而产生了负值。同理出现多次十张的情况也是互相抢占了资源。换句话说就是产生了资源冲突问题，为了解决这种问题，就需要给共享资源上一道锁。最简单的例子就是上洗手间，一个人进去后要将门锁上，当他出来时再将锁打开，然后其他人才可以进。&lt;/p&gt;
&lt;p&gt;　　我们使用同步块或同步方法来实现加锁操作。语法结构分别如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;synchronzied(Object) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;... &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
synchronzied &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可将上述代码改为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ThreadSafeTest &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable {

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = 10&lt;span&gt;;
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&quot;&quot;) {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加锁        &lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(num&amp;gt;0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        Thread.sleep(&lt;/span&gt;100&lt;span&gt;);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                        e.printStackTrace();
                    }
                    System.out.println(&lt;/span&gt;&quot;车票剩余：&quot; + num-- + &quot;张&quot;&lt;span&gt;);
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ThreadSafeTest test &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadSafeTest();
        Thread tA &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(test);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;实例化4个线程&lt;/span&gt;
        Thread tB = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(test);
        Thread tC &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(test);
        Thread tD &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(test);
        tA.start();        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动线程&lt;/span&gt;
&lt;span&gt;        tB.start();
        tC.start();
        tD.start();
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　也可以用同步方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doit() {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义同步方法&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(num&amp;gt;0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;100&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
    System.out.println(&lt;/span&gt;&quot;车票剩余：&quot; + num-- + &quot;张&quot;&lt;span&gt;);
    } 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　两种方法运行结果一致，运行结果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1018770/201803/1018770-20180326225706000-1175038514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;六、线程实例测试&lt;/h2&gt;
&lt;p&gt;　　下面举一个完整的例子。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;对归并排序使用多线程进行求解，排序数据量不少于&lt;/span&gt;&lt;/span&gt;&lt;span&gt;1M&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　1. 程序结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1018770/201803/1018770-20180326230951282-1717138315.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　2. MakeArrays.java&lt;/h3&gt;
&lt;p&gt;　　该类用于创建一个1M的随机测试数组，用于保证样本的统一性（串行与并行使用同一个数组）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Random;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MakeArrays {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; length = 1024*1024&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] makeArray() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[] array = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[length];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         
&lt;span&gt;10&lt;/span&gt;         Random random = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; x =&lt;span&gt; random.nextInt();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             array[i] =&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; array;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     
&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3. MergeSort.java&lt;/h3&gt;
&lt;p&gt;　　此部分用来编写归并排序算法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MergeSort {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; length =&lt;span&gt; array.length;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[] tmpArray = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[ length ];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         sort(array, tmpArray, 0, length-1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sort(&lt;span&gt;int&lt;/span&gt;[] array, &lt;span&gt;int&lt;/span&gt;[] tmpArray, &lt;span&gt;int&lt;/span&gt; left, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; right){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(left &amp;lt;&lt;span&gt; right){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; center = (left + right)/2;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取中间值&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             sort(array, tmpArray, left, center);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归分解&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             sort(array, tmpArray, center+1, right);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归分解&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             merge(array, tmpArray, left, center+1, right);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并排序&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; merge(&lt;span&gt;int&lt;/span&gt;[] array, &lt;span&gt;int&lt;/span&gt;[] tmpArray, &lt;span&gt;int&lt;/span&gt; leftStart, &lt;span&gt;int&lt;/span&gt; rightStart, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; rightEnd) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; leftEnd = rightStart - 1;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左侧数组截止下标&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; tmpPos = leftStart;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组坐标&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; total = rightEnd - leftStart + 1;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;需要合并的数组元素数量&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(leftStart &amp;lt;= leftEnd &amp;amp;&amp;amp; rightStart &amp;lt;=&lt;span&gt; rightEnd){
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(array[ leftStart ] &amp;lt;=&lt;span&gt; array[ rightStart ]){
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果左侧数组元素小于或等于右侧数组元素，将左侧数组元素的值存入临时数组，并移动左侧数组下标&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;                 tmpArray[ tmpPos++ ] = array[ leftStart++&lt;span&gt; ];
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果左侧数组元素大于右侧数组元素，将右侧数组元素的值存入临时数组，并移动右侧数组下标&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                 tmpArray[ tmpPos++ ] = array[ rightStart++&lt;span&gt; ];
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果左侧数组元素没有全部存入临时数组，将剩余元素循环写入临时数组&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(leftStart &amp;lt;=&lt;span&gt; leftEnd){
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             tmpArray[ tmpPos++ ] = array[ leftStart++&lt;span&gt; ];
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果右侧数组元素没有全部存入临时数组，将剩余元素循环写入临时数组&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(rightStart &amp;lt;=&lt;span&gt; rightEnd){
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             tmpArray[ tmpPos++ ] = array[ rightStart++&lt;span&gt; ];
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将临时数组中排序好的元素写入原数组&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; total; i++, rightEnd--&lt;span&gt; ){
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             array[ rightEnd ] =&lt;span&gt; tmpArray[ rightEnd ];
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　4. SerialDemo.java&lt;/h3&gt;
&lt;p&gt;　　该类为串行代码，即不使用线程的情况下直接调用归并排序算法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SerialDemo2_5 {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; mergeSort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;归并排序&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        MergeSort.sort(array);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     
&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　5. ThreadDemo.java&lt;/h3&gt;
&lt;p&gt;　　该类为并行代码，即使用多线程的情况下调用归并排序算法，这里以两个线程为例，将前面的1M的数组平均分为两份，分别交给这两个线程进行归并排序处理，然后再对其合并排序，得到最终的数组。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.CountDownLatch;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadDemo2_5 {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; mergeSort(&lt;span&gt;int&lt;/span&gt;[] array) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; length =&lt;span&gt; array.length;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; minLength = length/2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[] a = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[minLength];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;[] b = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[minLength];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;2; i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; start = minLength *&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; end = minLength * (i + 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(i==0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=start, k=0; j&amp;lt;end; j++,k++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     a[k] =&lt;span&gt; array[j];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(i==1&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=start, k=0; j&amp;lt;end; j++,k++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                     b[k] =&lt;span&gt; array[j];
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用CountDownLatch来确保两个子线程都处理完毕后才执行最后的归并操作&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         CountDownLatch latch = &lt;span&gt;new&lt;/span&gt; CountDownLatch(2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable(){
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                MergeSort.sort(a);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                latch.countDown();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }).start();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable(){
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                MergeSort.sort(b);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                latch.countDown();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }).start();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        latch.await();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; 
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并两个有序序列&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        merge(a, b, array);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并序列&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; merge(&lt;span&gt;int&lt;/span&gt;[] a1, &lt;span&gt;int&lt;/span&gt;[] a2, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] tmpArray){
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; length1 =&lt;span&gt; a1.length;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; length2 =&lt;span&gt; a2.length;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; left = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; right = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; pos = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(left &amp;lt; length1 &amp;amp;&amp;amp; right &amp;lt;&lt;span&gt; length2){
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(a1[left] &amp;lt;=&lt;span&gt; a2[right]){
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                 tmpArray[pos] =&lt;span&gt; a1[left];
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;                 left++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                 tmpArray[pos] =&lt;span&gt; a2[right];
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;                 right++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;             pos++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; 
&lt;span&gt;75&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(left &amp;lt;&lt;span&gt; length1){
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;             tmpArray[ pos++ ] = a1[ left++&lt;span&gt; ];
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; 
&lt;span&gt;79&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(right &amp;lt;&lt;span&gt; length2){
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;             tmpArray[ pos++ ] = a2[ right++&lt;span&gt; ];
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; 
&lt;span&gt;83&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;     
&lt;span&gt;85&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　6. Main.java&lt;/h3&gt;
&lt;p&gt;　　这里为主函数用于测试串行与并行的时间有何差别。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MainEx2_5 {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] array = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MakeArrays().makeArray();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * 测试函数
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * ms : currentTimeMillis
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * ns : nanoTime
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;         * 串行测试
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; startTime = System.currentTimeMillis();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取开始时间&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; SerialDemo2_5().mergeSort(array);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试的代码段&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; endTime = System.currentTimeMillis(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取结束时间&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         System.out.println(&quot;串行使用的时间： &quot;+(endTime-startTime)+&quot;ms&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;         * 线程测试
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; startTime1 = System.currentTimeMillis();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取开始时间&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadDemo2_5().mergeSort(array);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         }  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试的代码段&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; endTime1 = System.currentTimeMillis(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取结束时间&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         System.out.println(&quot;线程使用的时间： &quot;+(endTime1-startTime1)+&quot;ms&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　7. 运行结果&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1018770/201803/1018770-20180326231806593-867405148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从这里可以看出并行的时间比线程少了很多，提高了效率。&lt;/p&gt;

&lt;p&gt;　　这里再给另一种简单的代码，换了一种方法，可以自行理解。如下&lt;span&gt;&lt;span&gt;对随机产生的&lt;/span&gt;1M-10M&lt;/span&gt;&lt;span&gt;&lt;span&gt;的数组进行求和&lt;/span&gt;，这里只给出线程部分的代码（这个代码可以实现线程数自定）。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadDemo1_1 {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * 对数组求和
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; array 数组
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; threadCount 线程数
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 数组元素和
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; sumArray(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] array, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; threadCount) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (array == &lt;span&gt;null&lt;/span&gt; || array.length == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;数组长度必须大于0&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; RuntimeSave rd = &lt;span&gt;new&lt;/span&gt; RuntimeSave();     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存数据&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; lenPerThread = array.length / threadCount;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算每个线程的数组元素个数&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; threadCount; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; index =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                     &lt;span&gt;long&lt;/span&gt; s = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; start = index *&lt;span&gt; lenPerThread;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; end = start +&lt;span&gt; lenPerThread;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     
&lt;span&gt;26&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = start; j &amp;lt; end; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                         s +=&lt;span&gt; array[j];
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (rd) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                         rd.sum +=&lt;span&gt; s;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                         rd.finishThreadCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                };
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            }.start();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;    
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; remain = array.length % threadCount;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 剩余数组元素&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; s = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = array.length - remain; i &amp;lt; array.length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             s +=&lt;span&gt; array[i];  
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (rd) {  
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             rd.sum +=&lt;span&gt; s;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (rd.finishThreadCount !=&lt;span&gt; threadCount) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 Thread.sleep(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            }  
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        }  
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rd.sum;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;     * 保存运行时的相关数据
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; adamjwh
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RuntimeSave {
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; sum;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存求和&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; finishThreadCount;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已执行完毕的线程数&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Mon, 26 Mar 2018 15:28:00 +0000</pubDate>
<dc:creator>0o霏霏o0</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/adamjwh/p/8654008.html</dc:identifier>
</item>
<item>
<title>Django基础(三)：ORM - 带带大师兄丶</title>
<link>http://www.cnblogs.com/6324TV/p/8654799.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/6324TV/p/8654799.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;##################################################################
# PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET #
##################################################################

def all(self)
    # 获取所有的数据对象

def filter(self, &lt;/span&gt;*args, **&lt;span&gt;kwargs)
    # 条件查询
    # 条件可以是：参数，字典，Q

def exclude(self, &lt;/span&gt;*args, **&lt;span&gt;kwargs)
    # 条件查询
    # 条件可以是：参数，字典，Q

def select_related(self, &lt;/span&gt;*&lt;span&gt;fields)
    性能相关：表之间进行join连表操作，一次性获取关联的数据。

    总结：
    &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;. select_related主要针一对一和多对一关系进行优化。
    &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;. select_related使用SQL的JOIN语句进行优化，通过减少SQL查询的次数来进行优化、提高性能。

def prefetch_related(self, &lt;/span&gt;*&lt;span&gt;lookups)
    性能相关：多表连表操作时速度会慢，使用其执行多次SQL查询在Python代码中实现连表操作。

    总结：
    &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;. 对于多对多字段（ManyToManyField）和一对多字段，可以使用prefetch_related()来进行优化。
    &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;. prefetch_related()的优化方式是分别查询每个表，然后用Python处理他们之间的关系。

def annotate(self, &lt;/span&gt;*args, **&lt;span&gt;kwargs)
    # 用于实现聚合group by查询

    from django.db.models import Count, Avg, Max, Min, Sum

    v &lt;/span&gt;= models.UserInfo.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;u_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(uid=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;u_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    # SELECT u_id, COUNT(ui) AS `uid` FROM UserInfo GROUP BY u_id

    v &lt;/span&gt;= models.UserInfo.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;u_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(uid=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;u_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)).filter(uid__gt=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    # SELECT u_id, COUNT(ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) &lt;/span&gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

    v &lt;/span&gt;= models.UserInfo.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;u_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).annotate(uid=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;u_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,distinct=True)).filter(uid__gt=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    # SELECT u_id, COUNT( DISTINCT ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) &lt;/span&gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

def distinct(self, &lt;/span&gt;*&lt;span&gt;field_names)
    # 用于distinct去重
    models.UserInfo.objects.values(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).distinct()
    # &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt; distinct nid from userinfo

    注：只有在PostgreSQL中才能使用distinct进行去重

def order_by(self, &lt;/span&gt;*&lt;span&gt;field_names)
    # 用于排序
    models.UserInfo.objects.all().order_by(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

def extra(self, &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;=None, where=None, params=None, tables=None, order_by=None, select_params=&lt;span&gt;None)
    # 构造额外的查询条件或者映射，如：子查询

    Entry.objects.extra(&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select col from sometable where othercol &amp;gt; %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, select_params=(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,))
    Entry.objects.extra(where&lt;/span&gt;=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;headline=%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], params=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Lennon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
    Entry.objects.extra(where&lt;/span&gt;=[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo='a' OR bar = 'a'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;baz = 'a'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;])
    Entry.objects.extra(&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select id from tb where id &amp;gt; %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}, select_params=(&lt;span&gt;1&lt;/span&gt;,), order_by=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-nid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

 def reverse(self):
    # 倒序
    models.UserInfo.objects.all().order_by(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;-nid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).reverse()
    # 注：如果存在order_by，reverse则是倒序，如果多个排序则一一倒序


 def defer(self, &lt;/span&gt;*&lt;span&gt;fields):
    models.UserInfo.objects.defer(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    或
    models.UserInfo.objects.filter(...).defer(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    #映射中排除某列数据

 def only(self, &lt;/span&gt;*&lt;span&gt;fields):
    #仅取某个表中的数据
     models.UserInfo.objects.only(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
     或
     models.UserInfo.objects.filter(...).only(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

 def using(self, alias):
     指定使用的数据库，参数为别名（setting中的设置）


##################################################
# PUBLIC METHODS THAT RETURN A QUERYSET SUBCLASS #
##################################################

def raw(self, raw_query, params&lt;/span&gt;=None, translations=None, using=&lt;span&gt;None):
    # 执行原生SQL
    models.UserInfo.objects.raw(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from userinfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    # 如果SQL是其他表时，必须将名字设置为当前UserInfo对象的主键列名
    models.UserInfo.objects.raw(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;select id as nid from 其他表&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    # 为原生SQL设置参数
    models.UserInfo.objects.raw(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;select id as nid from userinfo where nid&amp;gt;%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, params=[&lt;span&gt;12&lt;/span&gt;&lt;span&gt;,])

    # 将获取的到列名转换为指定列名
    name_map &lt;/span&gt;= {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;first_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;last&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;last_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;bd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;birth_date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
    Person.objects.raw(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SELECT * FROM some_other_table&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, translations=&lt;span&gt;name_map)

    # 指定数据库
    models.UserInfo.objects.raw(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from userinfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, using=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    ################### 原生SQL ###################
    from django.db import connection, connections
    cursor &lt;/span&gt;= connection.cursor()  # cursor = connections[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].cursor()
    cursor.execute(&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;SELECT * from auth_user where id = %s&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;, [&lt;span&gt;1&lt;/span&gt;&lt;span&gt;])
    row &lt;/span&gt;= cursor.fetchone() # fetchall()/&lt;span&gt;fetchmany(..)


def values(self, &lt;/span&gt;*&lt;span&gt;fields):
    # 获取每行数据为字典格式

def values_list(self, &lt;/span&gt;*fields, **&lt;span&gt;kwargs):
    # 获取每行数据为元祖

def dates(self, field_name, kind, order&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ASC&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    # 根据时间进行某一部分进行去重查找并截取指定内容
    # kind只能是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;（年）, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;month&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;（年-月）, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;day&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;（年-月-&lt;span&gt;日）
    # order只能是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ASC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DESC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    # 并获取转换后的时间
        &lt;/span&gt;- year : 年-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;
        - month: 年-月-&lt;span&gt;01&lt;/span&gt;
        - day  : 年-月-&lt;span&gt;日

    models.DatePlus.objects.dates(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ctime&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;day&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DESC&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

def datetimes(self, field_name, kind, order&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ASC&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, tzinfo=&lt;span&gt;None):
    # 根据时间进行某一部分进行去重查找并截取指定内容，将时间转换为指定时区时间
    # kind只能是 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;year&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;month&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;day&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hour&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;minute&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;second&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    # order只能是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ASC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DESC&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    # tzinfo时区对象
    models.DDD.objects.datetimes(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ctime&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hour&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,tzinfo=&lt;span&gt;pytz.UTC)
    models.DDD.objects.datetimes(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ctime&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hour&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,tzinfo=pytz.timezone(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Asia/Shanghai&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;    pip3 &lt;span&gt;install&lt;/span&gt;&lt;span&gt; pytz
    import pytz
    pytz.all_timezones
    pytz.timezone(‘Asia&lt;/span&gt;/&lt;span&gt;Shanghai’)
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;
&lt;/span&gt;&lt;span&gt;
def none(self):
    # 空QuerySet对象


####################################
# METHODS THAT DO DATABASE QUERIES #
####################################

def aggregate(self, &lt;/span&gt;*args, **&lt;span&gt;kwargs):
   # 聚合函数，获取字典类型聚合结果
   from django.db.models import Count, Avg, Max, Min, Sum
   result &lt;/span&gt;= models.UserInfo.objects.aggregate(k=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;u_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, distinct=True), n=Count(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
   &lt;/span&gt;===&amp;gt; {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;k&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;4&lt;/span&gt;&lt;span&gt;}

def count(self):
   # 获取个数

def get(self, &lt;/span&gt;*args, **&lt;span&gt;kwargs):
   # 获取单个对象

def create(self, &lt;/span&gt;**&lt;span&gt;kwargs):
   # 创建对象

def bulk_create(self, objs, batch_size&lt;/span&gt;=&lt;span&gt;None):
    # 批量插入
    # batch_size表示一次插入的个数
    objs &lt;/span&gt;=&lt;span&gt; [
        models.DDD(name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r11&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
        models.DDD(name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r22&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    ]
    models.DDD.objects.bulk_create(objs, &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)

def get_or_create(self, defaults&lt;/span&gt;=None, **&lt;span&gt;kwargs):
    # 如果存在，则获取，否则，创建
    # defaults 指定创建时，其他字段的值
    obj, created &lt;/span&gt;= models.UserInfo.objects.get_or_create(username=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, defaults={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;email&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1111111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;u_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;t_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;&lt;span&gt;})

def update_or_create(self, defaults&lt;/span&gt;=None, **&lt;span&gt;kwargs):
    # 如果存在，则更新，否则，创建
    # defaults 指定创建时或更新时的其他字段
    obj, created &lt;/span&gt;= models.UserInfo.objects.update_or_create(username=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, defaults={&lt;span&gt;'&lt;/span&gt;&lt;span&gt;email&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1111111&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;u_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;t_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;&lt;span&gt;})

def first(self):
   # 获取第一个

def &lt;/span&gt;&lt;span&gt;last&lt;/span&gt;&lt;span&gt;(self):
   # 获取最后一个

def in_bulk(self, id_list&lt;/span&gt;=&lt;span&gt;None):
   # 根据主键ID进行查找
   id_list &lt;/span&gt;= [&lt;span&gt;11&lt;/span&gt;,&lt;span&gt;21&lt;/span&gt;,&lt;span&gt;31&lt;/span&gt;&lt;span&gt;]
   models.DDD.objects.in_bulk(id_list)

def delete(self):
   # 删除

def update(self, &lt;/span&gt;**&lt;span&gt;kwargs):
    # 更新

def exists(self):
   # 是否有结果

其他操作&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 26 Mar 2018 15:21:00 +0000</pubDate>
<dc:creator>带带大师兄丶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/6324TV/p/8654799.html</dc:identifier>
</item>
<item>
<title>C#设置和获取系统环境变量 - fsh001</title>
<link>http://www.cnblogs.com/fsh001/p/8654790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fsh001/p/8654790.html</guid>
<description>&lt;p&gt;1.前言&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;本来想拿学校机房的Android编辑器直接粘到自己电脑上用，发现它的eclipse是
32位的，而我的JDK是64位的，于是想到干脆装两个JDK，用C#做一个能够更改环
境变量的程序&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.代码&lt;/p&gt;
&lt;p&gt;Environment类下的静态方法&lt;/p&gt;
&lt;p&gt;获取环境变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
参数:
//   variable:
//     环境变量名。
//
//   target:
//     System.EnvironmentVariableTarget 值之一，环境变量的位置。
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置环境变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target);
参数:
//   variable:
//     环境变量名。
//
//   value:
//     要分配给 variable 的值。
//
//   target:
//     System.EnvironmentVariableTarget 值之一，环境变量的位置。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：这个设置环境变量的方法不用重启电脑也能生效！ (如果不加第三个参数则只会修改当前进程的环境变量)&lt;/p&gt;
</description>
<pubDate>Mon, 26 Mar 2018 15:19:00 +0000</pubDate>
<dc:creator>fsh001</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fsh001/p/8654790.html</dc:identifier>
</item>
<item>
<title>机器学习（1） - TensorflowSharp 简单使用与KNN识别MNIST流程 - 风口上的猪</title>
<link>http://www.cnblogs.com/haoyifei/p/8654743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haoyifei/p/8654743.html</guid>
<description>&lt;p&gt;机器学习是时下非常流行的话题，而Tensorflow是机器学习中最有名的工具包。TensorflowSharp是Tensorflow的C#语言表述。本文会对TensorflowSharp的使用进行一个简单的介绍。&lt;/p&gt;
&lt;p&gt;本文会先介绍Tensorflow的一些基本概念，然后实现一些基本操作例如数字相加等运算。然后，实现求两个点(x1,y1)和(x2,y2)的距离。最后，通过这些前置基础和一些C#代码，实现使用KNN方法识别MNIST手写数字集合（前半部分）。阅读本文绝对不需要任何机器学习基础，因为我现在也才刚刚入门，行文不准确之处难免，敬请见谅。&lt;/p&gt;
&lt;p&gt;本文的后半部分还在整理之中。&lt;/p&gt;
&lt;p&gt;
&lt;h2&gt;1. 什么是机器学习&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;用最最简单的话来说，机器学习就是不断改进一个模型的过程，使之可以更好的描述一组数据的内在规律。假设，我们拿到若干人的年龄(a1,a2,a3…)和他们的工资(b1,b2,b3…)，此时，我们就可以将这些点画在一个二维直角坐标系中，包括(a1,b1)，(a2,b2)等等。这些就称为输入或训练数据。&lt;/p&gt;
&lt;p&gt;我们可以用数学的最小二乘法拟合一条直线，这样就可以得到最好的可以描述这些数据的规律y=ax+b了。当然，因为我们有很多个点，所以它们可能不在一条直线上，因此任何的直线都不会过它们所有的点，即一定会有误差。&lt;/p&gt;
&lt;p&gt;但对于电脑来说，它可以使用一种截然不同的方式来得到y=ax+b中a，b的值。首先，它从一个随便指定的a和b出发（例如a=100,b=1），然后它算出y=100(a1)+1的值和b1的区别，y=100(a2)+1和b2的区别，等等。它发现误差非常大，此时，它就会调整a和b的值（通过某种算法），使得下一次的误差会变小。如果下次的误差反而变得更大了，那就说明，要么是初始值a,b给的不好，要么是y=ax+b可能不是一个好的模型，可能一个二次方程y=a^2+bx+c更好，等等。&lt;/p&gt;
&lt;p&gt;经过N轮调整（这称为模型的训练），误差的总和可能已经到了一个稳定的，较小的值。误差小时，a和b的调整相对当然也会较小。此时的a和b就会十分接近我们使用最小二乘法做出来的值，这时，就可以认为模型训练完成了。&lt;/p&gt;
&lt;p&gt;当然，这只是机器学习最简单的一个例子，使用的模型也只是线性的直线方程。如果使用更加复杂的模型，机器学习可以做出十分强大的事情。&lt;/p&gt;
&lt;p&gt;
&lt;h2&gt;2. 环境初始化&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;我使用VS2017创建一个新的控制台应用，然后，使用下面的命令安装TensorflowSharp：&lt;/p&gt;
&lt;p&gt;nuget install TensorFlowSharp&lt;/p&gt;
&lt;p&gt;TensorflowSharp的源码地址：&lt;a href=&quot;https://github.com/migueldeicaza/TensorFlowSharp&quot;&gt;https://github.com/migueldeicaza/TensorFlowSharp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果在运行时发现问题“找不到libtensorflow.dll”，则需要访问&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ci.tensorflow.org/view/Nightly/job/nightly-libtensorflow-windows/lastSuccessfulBuild/artifact/lib_package/libtensorflow-cpu-windows-x86_64.zip&quot;&gt;http://ci.tensorflow.org/view/Nightly/job/nightly-libtensorflow-windows/lastSuccessfulBuild/artifact/lib_package/libtensorflow-cpu-windows-x86_64.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载这个压缩包。然后，在下载的压缩包中的\lib中找到tensorflow.dll，将它改名为libtensorflow.dll，并在你的工程中引用它。&lt;/p&gt;
&lt;p&gt;这样一来，环境初始化就完成了。&lt;/p&gt;
&lt;p&gt;
&lt;h2&gt;3. TensorflowSharp中的概念&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;TensorflowSharp / Tensorflow中最重要的几个概念：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图（Graph）&lt;/strong&gt;：它包含了一个计算任务中的所有变量和计算方式。可以将它和C#中的表达式树进行类比。例如，一个1+2可以被看作为两个常量表达式，以一个二元运算表达式连接起来。在Tensorflow的世界中，则可以看成是两个tensor和一个op（operation的缩写，即操作）。简单来说，做一个机器学习的任务就是计算一张图。&lt;/p&gt;
&lt;p&gt;在计算图之前，当然要把图建立好。例如，计算（1+2）*3再开根号，是一个包括了3个tensor和3个Op的图。&lt;/p&gt;
&lt;p&gt;不过，Tensorflow的图和常规的表达式还有所不同，Tensorflow中的节点变量是可以被递归的更新的。我们所说的“训练”，也就是不停的计算一个图，获得图的计算结果，再根据结果的值调整节点变量的值，然后根据新的变量的值再重新计算图，如此重复，直到结果令人满意（小于某个阈值），或跑到了一个无穷大/小（这说明图的变量初始值设置的有问题），或者结果基本不变了为止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;会话（Session）&lt;/strong&gt;：为了获得图的计算结果，图必须在会话中被启动。图是会话类型的一个成员，会话类型还包括一个runner，负责执行这张图。会话的主要任务是在图运算时分配CPU或GPU。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;张量（tensor）:&lt;/strong&gt; Tensorflow中所有的输入输出变量都是张量，而不是基本的int，double这样的类型，即使是一个整数1，也必须被包装成一个0维的，长度为1的张量【1】。一个张量和一个矩阵差不多，可以被看成是一个多维的数组，从最基本的一维到N维都可以。张量拥有阶（rank），形状（shape），和数据类型。其中，形状可以被理解为长度，例如，一个形状为2的张量就是一个长度为2的一维数组。而阶可以被理解为维数。&lt;/p&gt;


&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;阶&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;数学实例&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;Python&lt;/strong&gt; &lt;strong&gt;例子&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;纯量 (只有大小)&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;s = 483&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;向量(大小和方向)&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;v = [1.1, 2.2, 3.3]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;矩阵(数据表)&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;13&quot;&gt;
&lt;p align=&quot;left&quot;&gt;m = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;18&quot;&gt;&lt;td&gt;
&lt;p align=&quot;left&quot;&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;3阶张量 (数据立体)&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;13&quot;&gt;
&lt;p align=&quot;left&quot;&gt;t = [[[2], [4], [6]], [[8], [10], [12]], [[14], [16], [18]]]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;Tensorflow中的运算（op）有很多很多种，最简单的当然就是加减乘除，它们的输入和输出都是tensor。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Runner：&lt;/strong&gt;在建立图之后，必须使用会话中的Runner来运行图，才能得到结果。在运行图时，需要为所有的变量和占位符赋值，否则就会报错。&lt;/p&gt;
&lt;p&gt;
&lt;h2&gt;4. TensorflowSharp中的几类主要变量&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;Const：常量，这很好理解。它们在定义时就必须被赋值，而且值永远无法被改变。&lt;/p&gt;
&lt;p&gt;Placeholder：占位符。这是一个在定义时不需要赋值，但在使用之前必须赋值（feed）的变量，通常用作训练数据。&lt;/p&gt;
&lt;p&gt;Variable：变量，它和占位符的不同是它在定义时需要赋值，而且它的数值是可以在图的计算过程中随时改变的。因此，占位符通常用作图的输入（即训练数据），而变量用作图中可以被“训练”或“学习”的那些tensor，例如y=ax+b中的a和b。&lt;/p&gt;
&lt;p&gt;
&lt;h2&gt;5. 基本运算&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;下面的代码演示了常量的使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基础常量运算，演示了常量的使用&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BasicOperation()
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; s = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TFSession())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; g =&lt;span&gt; s.Graph;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立两个TFOutput，都是常数&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; v1 = g.Const(&lt;span&gt;1.5&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; v2 = g.Const(&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立一个相加的运算&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; add =&lt;span&gt; g.Add(v1, v2);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得runner&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; runner =&lt;span&gt; s.GetRunner();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相加&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; runner.Run(add);
                
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得result的值2&lt;/span&gt;
                Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;相加的结果:{result.GetValue()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用占位符：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基础占位符运算&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BasicPlaceholderOperation()
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; s = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TFSession())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; g =&lt;span&gt; s.Graph;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;占位符 - 一种不需要初始化，在运算时再提供值的对象
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1*2的占位符&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; v1 = g.Placeholder(TFDataType.Double, &lt;span&gt;new&lt;/span&gt; TFShape(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; v2 = g.Placeholder(TFDataType.Double, &lt;span&gt;new&lt;/span&gt; TFShape(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立一个相乘的运算&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; add =&lt;span&gt; g.Mul(v1, v2);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得runner&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; runner =&lt;span&gt; s.GetRunner();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相加
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在这里给占位符提供值&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; data1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;[] { &lt;span&gt;0.3&lt;/span&gt;, &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt; };
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;[] { &lt;span&gt;0.4&lt;/span&gt;, &lt;span&gt;0.8&lt;/span&gt;&lt;span&gt; };

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; runner
                    .Fetch(add)
                    .AddInput(v1, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TFTensor(data1))
                    .AddInput(v2, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TFTensor(data2))
                    .Run();

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; dataResult = (&lt;span&gt;double&lt;/span&gt;[])result[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].GetValue();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得result的值&lt;/span&gt;
                Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;相乘的结果: [{dataResult[0]}, {dataResult[1]}]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的代码中，我们使用了fetch方法来获得数据。Fetch方法用来帮助取回操作的结果，上面的例子中操作就是add。我们看到，整个图的计算是一个类似管道的流程。在fetch之后，为占位符输入数据，最后进行运算。&lt;/p&gt;
&lt;p&gt;使用常量表示矩阵：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基础矩阵运算&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BasicMatrixOperation()
        {
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; s = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TFSession())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; g =&lt;span&gt; s.Graph;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1x2矩阵&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; matrix1 = g.Const(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;[,] { { &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt; } });

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2x1矩阵&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; matrix2 = g.Const(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;[,] { { &lt;span&gt;3&lt;/span&gt; }, { &lt;span&gt;4&lt;/span&gt;&lt;span&gt; } });

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; product =&lt;span&gt; g.MatMul(matrix1, matrix2);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; s.GetRunner().Run(product);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;矩阵相乘的值：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + ((&lt;span&gt;double&lt;/span&gt;[,])result.GetValue())[&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
            };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;6. 求两个点的距离（L1,L2）&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;求两点距离实际上就是若干操作的结合而已。我们知道，(x1,x2), (y1,y2)的距离为：&lt;/p&gt;
&lt;p&gt;Sqrt((x1-x2)^2 + (y1-y2)^2)&lt;/p&gt;

&lt;p&gt;因此，我们通过张量的运算，获得&lt;/p&gt;
&lt;p&gt;[x1-x2, y1-y2] (通过Sub)&lt;/p&gt;
&lt;p&gt;[(x1-x2)^2, (y1-y2)^2] (通过Pow)&lt;/p&gt;
&lt;p&gt;然后，把这两个数加起来，这需要ReduceSum运算符。最后开根就可以了。我们把整个运算赋给变量distance，然后fetch distance：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求两个点的L2距离&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DistanceL2(TFSession s, TFOutput v1, TFOutput v2)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; graph =&lt;span&gt; s.Graph;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义求距离的运算
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里要特别注意，如果第一个系数为double，第二个也需要是double，所以传入2d而不是2&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; pow =&lt;span&gt; graph.Pow(graph.Sub(v1, v2), graph.Const(2d));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ReduceSum运算将输入的一串数字相加并得出一个值（而不是保留输入参数的size）&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; distance =&lt;span&gt; graph.Sqrt(graph.ReduceSum(pow));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得runner&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; runner =&lt;span&gt; s.GetRunner();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求距离
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在这里给占位符提供值&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; data1 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;[] { &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt; };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;[] { &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;&lt;span&gt; };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; runner
                .Fetch(distance)
                .AddInput(v1, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TFTensor(data1))
                .AddInput(v2, &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TFTensor(data2))
                .Run();

            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;点v1和v2的距离为{result[0].GetValue()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，我们根据目前所学，实现KNN识别MNIST。&lt;/p&gt;
&lt;div readability=&quot;33&quot;&gt;
&lt;h2&gt;7. 实现KNN识别MNIST（1）&lt;/h2&gt;
&lt;p&gt;
&lt;h3&gt;什么是KNN&lt;/h3&gt;
&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;K最近邻(k-Nearest Neighbor，KNN)分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则认为该样本也属于这个类别。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/705562/201803/705562-20180326230529355-62663355.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　图中，绿色圆要被决定赋予哪个类，是红色三角形还是蓝色四方形？如果K=3，由于红色三角形所占比例为2/3，绿色圆将被赋予红色三角形那个类，如果K=5，由于蓝色四方形比例为3/5，因此绿色圆被赋予蓝色四方形类。&lt;/p&gt;
&lt;p&gt;在进行计算时，KNN就表现为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先获得所有的数据&lt;/li&gt;
&lt;li&gt;然后对一个输入的点，找到离它最近的K个点（通过L1或L2距离）&lt;/li&gt;
&lt;li&gt;然后，对这K个点所代表的值，找出最多的那个类，那么，这个输入的数据就被认为属于那个类&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对MNIST数据的KNN识别，在读入若干个输入数据（和代表的数字）之后，逐个读入测试数据。对每个测试数据，找到离他最近的K个输入数据（和代表的数字），找出最多的代表数字A。此时，测试数据就被认为代表数字A。因此，使用KNN识别MNIST数据就可以化为求两个点（群）的距离的问题。&lt;/p&gt;
&lt;p&gt;
&lt;h3&gt;MNIST数据集&lt;/h3&gt;
&lt;/p&gt;
&lt;p&gt;MNIST是一个非常有名的手写数字识别的数据集。它包含了6万张手写数字图片，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/705562/201803/705562-20180326230610416-1832235093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，对于我们人类而言，识别上面四幅图是什么数字是十分容易的，理由很简单，就是“看着像”。比如，第一张图看着就像5。但如果是让计算机来识别，它可无法理解什么叫看着像，就显得非常困难。实际上，解决这个问题有很多种方法，KNN是其中最简单的一种。除了KNN之外，还可以使用各种类型的神经网络。&lt;/p&gt;
&lt;p&gt;我们可以将每个图片看成一个点的集合。实际上，在MNIST输入中，图片被表示为28乘28的一个矩阵。例如，当我们成功读取了一张图之后，将它打印出来会发现结果是这样的（做了一些处理）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/705562/201803/705562-20180326230623731-1840875670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;其中，数字均为byte类型（0-255），数字越大，代表灰度越深。当然，0就代表白色了。因此，你可以想象上面的那张图就是一个手写的2。如果把上图的000换成3个空格可以看的更清楚：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/705562/201803/705562-20180326230632213-1664677338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于每张这样的图，MNIST提供了它的正确答案（即它应该是代表哪个数字），被称为label。上图的label显然就是2了。因此，每张输入的小图片都是一个28乘28的矩阵（含有784个数字），那么，我们当然也可以计算任意两个小图片的距离，它就是784个点和另外784个点的距离之和。&lt;strong&gt;因此，如果两张图的距离很小，那么它们就“看着像”。&lt;/strong&gt;在这里，我们可以有很多定义距离的方式，简单起见，我们就将两点的距离定义为L1距离，即直接相减之后取绝对值。例如，如果两个图片完全相同（784个数字位置和值都一样），那么它们的距离为0。如果它们仅有一个数字不同，一个是6，一个是8，那么它们的距离就是2。&lt;/p&gt;
&lt;p&gt;那么，在简单了解了什么是KNN之后，我们的任务就很清楚了:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获得数据&lt;/li&gt;
&lt;li&gt;把数据处理为一种标准形式&lt;/li&gt;
&lt;li&gt;拿出数据中的一部分（例如，5000张图片）作为KNN的训练数据，然后，再从数据中的另一部分拿一张图片A&lt;/li&gt;
&lt;li&gt;对这张图片A，求它和5000张训练图片的距离，并找出一张训练图片B，它是所有训练图片中，和A距离最小的那张（这意味着K=1）&lt;/li&gt;
&lt;li&gt;此时，就&lt;strong&gt;认为&lt;/strong&gt;&lt;strong&gt;A&lt;/strong&gt;&lt;strong&gt;所代表的数字等同于B&lt;/strong&gt;&lt;strong&gt;所代表的数字b&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果A的label&lt;strong&gt;真的是b&lt;/strong&gt;，那么就增加一次获胜次数 &lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过多次拿图片，我们就可以获得一个准确率（获胜的次数/拿图片的总次数）。最后程序的输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/705562/201803/705562-20180326230659493-1455734230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在下一篇文章中会详细分析如何实现整个流程。&lt;/p&gt;
</description>
<pubDate>Mon, 26 Mar 2018 15:08:00 +0000</pubDate>
<dc:creator>风口上的猪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haoyifei/p/8654743.html</dc:identifier>
</item>
<item>
<title>ArrayList 源码分析 - lwen</title>
<link>http://www.cnblogs.com/lwen/p/8654637.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwen/p/8654637.html</guid>
<description>&lt;h2 id=&quot;结构&quot;&gt;1. 结构&lt;/h2&gt;
&lt;p&gt;  首先我们需要对 ArrayList 有一个大致的了解就从结构来看看吧.&lt;/p&gt;
&lt;h3 id=&quot;继承&quot;&gt;1. 继承&lt;/h3&gt;
&lt;p&gt;  该类继承自 AbstractList 这个比较好说&lt;/p&gt;
&lt;h3 id=&quot;实现&quot;&gt;2. 实现&lt;/h3&gt;
&lt;p&gt;这个类实现的接口比较多，具体如下：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;首先这个类是一个 List 自然有 List 接口&lt;/li&gt;
&lt;li&gt;然后由于这个类需要进行随机访问，所谓随机访问就是用下标任一访问，所以实现了RandomAccess&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;然后就是两个集合框架肯定会实现的两个接口 Cloneable, Serializable 前面这个好说序列化一会我们具体再说说&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;主要字段&quot;&gt;3. 主要字段&lt;/h3&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;// 默认大小为10&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; DEFAULT_CAPACITY = &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;;
    &lt;span class=&quot;co&quot;&gt;// 空数组  &lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Object[] EMPTY_ELEMENTDATA = {};
    &lt;span class=&quot;co&quot;&gt;// 默认的空数组  这个是在传入无参的是构造函数会调用的待会再 add 方法中会看到&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
    &lt;span class=&quot;co&quot;&gt;// 用来存放 ArrayList 中的元素 注意他的修饰符是一个 transient 也就是不会自动序列化&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;transient&lt;/span&gt; Object[] elementData; 
    &lt;span class=&quot;co&quot;&gt;// 大小&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; size;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;主要方法&quot;&gt;4. 主要方法&lt;/h3&gt;
&lt;p&gt;下面的方法后面标有数字的就是表示重载方法&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ctor-3&lt;/li&gt;
&lt;li&gt;get&lt;/li&gt;
&lt;li&gt;set&lt;/li&gt;
&lt;li&gt;add-2&lt;/li&gt;
&lt;li&gt;remove-2&lt;/li&gt;
&lt;li&gt;clear&lt;/li&gt;
&lt;li&gt;addAll&lt;/li&gt;
&lt;li&gt;write/readObject&lt;/li&gt;
&lt;li&gt;fast-fail 机制&lt;/li&gt;
&lt;li&gt;subList&lt;/li&gt;
&lt;li&gt;iterator&lt;/li&gt;
&lt;li&gt;forEach&lt;/li&gt;
&lt;li&gt;sort&lt;/li&gt;
&lt;li&gt;removeIf&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;构造方法分析&quot;&gt;2. 构造方法分析&lt;/h2&gt;
&lt;h3 id=&quot;无参的构造方法&quot;&gt;1. 无参的构造方法&lt;/h3&gt;
&lt;p&gt;   里面只有一个操作就是把 &lt;code&gt;elementData&lt;/code&gt; 设置为 &lt;code&gt;DEFAULTCAPACITY_EMPTY_ELEMENTDATA&lt;/code&gt; 这个空数组。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 无参的构造函数，传入一个空数组  这时候会创建一个大小为10的数组，具体操作在 add 中&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ArrayList() {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;elementData&lt;/span&gt; = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;传入数组大小的构造&quot;&gt;2. 传入数组大小的构造&lt;/h3&gt;
&lt;p&gt;   这个就是 new 一个数组，如果数组大小为0就 赋值为 &lt;code&gt;EMPTY_ELEMENTDATA&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 按传入的参数创建新的底层数组&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ArrayList(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; initialCapacity) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (initialCapacity &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;elementData&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Object[initialCapacity];
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (initialCapacity == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;elementData&lt;/span&gt; = EMPTY_ELEMENTDATA;
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalArgumentException(&lt;span class=&quot;st&quot;&gt;&quot;Illegal Capacity: &quot;&lt;/span&gt;+
                                               initialCapacity);
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;传入-collection-接口&quot;&gt;3. 传入 Collection 接口&lt;/h3&gt;
&lt;p&gt;   在这个方法里面主要就是把这个 Collection 转成一个数组，然后把这个数组 copy 一下，如果这个接口的 size 为0 和上面那个方法一样传入 &lt;code&gt;EMPTY_ELEMENTDATA&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ArrayList(Collection&amp;lt;? &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; E&amp;gt; c) {
        elementData = c.&lt;span class=&quot;fu&quot;&gt;toArray&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((size = elementData.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;) != &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
            &lt;span class=&quot;co&quot;&gt;// c.toArray might (incorrectly) not return Object[] (see 6260652)&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 上面的注释的意思是说 jdk 有一个 bug 具体来说就是一个 Object 类型的数组不一定能够存放 Object类型的对象，有可能抛异常&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 主要是因为 Object 类型的数组可能指向的是他的子类的数组，存 Object 类型的东西会报错&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (elementData.&lt;span class=&quot;fu&quot;&gt;getClass&lt;/span&gt;() != Object[].&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;)
                &lt;span class=&quot;co&quot;&gt;// 这个操作是首先new 了新的数组，然后再调用 System.arraycopy 拷贝值。也就是产生新的数组&lt;/span&gt;
                elementData = Arrays.&lt;span class=&quot;fu&quot;&gt;copyOf&lt;/span&gt;(elementData, size, Object[].&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;// 传入的是空的就直接使用空数组初始化&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;elementData&lt;/span&gt; = EMPTY_ELEMENTDATA;
        }
    }
 &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   但是注意一点这里有一个 jdk 的 bug 也就是一个 Object 类型的数组不一定能够存放 Object类型的对象，有可能抛异常，主要是因为 Object 类型的数组可能指向的是他的子类的数组，存 Object 类型的东西会报错。 为了测试这个 bug 写了几行代码测试一下。这个测试是通不过的，就是存在上面的原因。&lt;/p&gt;
&lt;p&gt;   一个典型的例子就是 我们创建一个 string 类型的 list 然后调用 toArray 方法发现返回的是一个 string[] 这时候自然就不能随便存放元素了。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; A{
}

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; B &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; A {
}

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; JDKBug {

    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;test1&lt;/span&gt;() {
        B[] arrB = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; B[&lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;];
        A[] arrA = arrB;
        arrA[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]=&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;A&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;修改方法分析&quot;&gt;3. 修改方法分析&lt;/h2&gt;
&lt;h3 id=&quot;set-方法&quot;&gt;1. Set 方法&lt;/h3&gt;
&lt;p&gt;   这个方法也很简单 ，首先进行范围判断，然后就是直接更新下标即可。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;// 也没啥好说的就是，设置新值返回老值&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;fu&quot;&gt;set&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index, E element) {
        &lt;span class=&quot;fu&quot;&gt;rangeCheck&lt;/span&gt;(index);

        E oldValue = &lt;span class=&quot;fu&quot;&gt;elementData&lt;/span&gt;(index);
        elementData[index] = element;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; oldValue;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;adde-e-方法&quot;&gt;2. Add(E e) 方法&lt;/h3&gt;
&lt;p&gt;  这个方法首先调用了 &lt;code&gt;ensureCapacityInternal()&lt;/code&gt; 这个方法里面就判断了当前的 &lt;code&gt;elementData&lt;/code&gt; 是否等于 &lt;code&gt;DEFAULTCAPACITY_EMPTY_ELEMENTDATA&lt;/code&gt; 如果是的话，就把数组的大小设置为 10 然后进行扩容操作,这里刚好解释了为什么采用无参构造的List 的大小是 10 ，这里扩容操作调用的方法是 &lt;code&gt;ensureExplicitCapacity&lt;/code&gt; 里面就干了一件事如果用户指定的大小 大于当前长度就扩容，扩容的方法采用了 &lt;code&gt;Arrays.copy&lt;/code&gt; 方法，这个方法实现原理是 new 出一个新的数组，然后调用 &lt;code&gt;System.arraycopy&lt;/code&gt; 拷贝数组，最后返回新的数组。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(E e) {
        &lt;span class=&quot;co&quot;&gt;// 当调用了无参构造，设置大小为10&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;ensureCapacityInternal&lt;/span&gt;(size + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;// Increments modCount        &lt;/span&gt;
        elementData[size++] = e;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
    }

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ensureCapacityInternal&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; minCapacity) {
        &lt;span class=&quot;co&quot;&gt;// 如果当前数组是默认空数组就设置为 10和 size+1中的最小值&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 这也就是说为什么说无参构造 new 的数组大小是 10&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
            minCapacity = Math.&lt;span class=&quot;fu&quot;&gt;max&lt;/span&gt;(DEFAULT_CAPACITY, minCapacity);
        }

        &lt;span class=&quot;fu&quot;&gt;ensureExplicitCapacity&lt;/span&gt;(minCapacity);
    }

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ensureExplicitCapacity&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; minCapacity) {
        modCount++;

        &lt;span class=&quot;co&quot;&gt;// 若用户指定的最小容量 &amp;gt; 最小扩充容量，则以用户指定的为准，否则还是 10&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (minCapacity - elementData.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt; &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
            &lt;span class=&quot;fu&quot;&gt;grow&lt;/span&gt;(minCapacity);
    }
    
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;grow&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; minCapacity) {
        &lt;span class=&quot;co&quot;&gt;// overflow-conscious code&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; oldCapacity = elementData.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
        &lt;span class=&quot;co&quot;&gt;// 1.5倍增长&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (newCapacity - minCapacity &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
            newCapacity = minCapacity;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (newCapacity - MAX_ARRAY_SIZE &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
            newCapacity = &lt;span class=&quot;fu&quot;&gt;hugeCapacity&lt;/span&gt;(minCapacity);
        &lt;span class=&quot;co&quot;&gt;// minCapacity is usually close to size, so this is a win:&lt;/span&gt;
        elementData = Arrays.&lt;span class=&quot;fu&quot;&gt;copyOf&lt;/span&gt;(elementData, newCapacity);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;addint-index-e-e-方法&quot;&gt;3. Add(int index, E e) 方法&lt;/h3&gt;
&lt;p&gt;   这个方法比较简单和上面基本一样，然后只是最后放元素的时候的操作不一样，他是采用了 System.arraycopy 从自己向自己拷贝，目的就在于覆盖元素。 注意一个规律这里面只要涉及下标的操作的很多不是自己手写 for 循环而是采用类似的拷贝覆盖的方法。算是一个小技巧。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index, E element) {
        &lt;span class=&quot;fu&quot;&gt;rangeCheckForAdd&lt;/span&gt;(index);
        &lt;span class=&quot;fu&quot;&gt;ensureCapacityInternal&lt;/span&gt;(size + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);  &lt;span class=&quot;co&quot;&gt;// Increments modCount&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 覆盖&lt;/span&gt;
        System.&lt;span class=&quot;fu&quot;&gt;arraycopy&lt;/span&gt;(elementData, index, elementData, index + &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,
                         size - index);
        elementData[index] = element;
        size++;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;removeint-index&quot;&gt;4. remove(int index)&lt;/h3&gt;
&lt;p&gt;  同理这里面还是用了拷贝覆盖的技巧。 但是有一点注意的就是不用的节点需要手动的触发 gc ，这也是在 Efftive Java 中作者举的一个例子。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index) {
        &lt;span class=&quot;fu&quot;&gt;rangeCheck&lt;/span&gt;(index);
        modCount++;
        E oldValue = &lt;span class=&quot;fu&quot;&gt;elementData&lt;/span&gt;(index);
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; numMoved = size - index - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
        &lt;span class=&quot;co&quot;&gt;//覆盖&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (numMoved &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
            System.&lt;span class=&quot;fu&quot;&gt;arraycopy&lt;/span&gt;(elementData, index&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;, elementData, index,
                             numMoved);
        elementData[--size] = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// clear to let GC do its work&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; oldValue;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;removee-e&quot;&gt;5. remove(E e)&lt;/h3&gt;
&lt;p&gt;   这个方法操作很显然会判断 e 是不是 null 如果是 null 的话直接采用 &lt;code&gt;==&lt;/code&gt; 比较，否则的话就直接调用 &lt;code&gt;equals&lt;/code&gt; 方法然后执行拷贝覆盖。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(Object o) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (o == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; index &amp;lt; size; index++)
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (elementData[index] == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                    &lt;span class=&quot;co&quot;&gt;// 覆盖&lt;/span&gt;
                    &lt;span class=&quot;fu&quot;&gt;fastRemove&lt;/span&gt;(index);
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
                }
        } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; index &amp;lt; size; index++)
                &lt;span class=&quot;co&quot;&gt;// 调用 equals 方法&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (o.&lt;span class=&quot;fu&quot;&gt;equals&lt;/span&gt;(elementData[index])) {
                    &lt;span class=&quot;fu&quot;&gt;fastRemove&lt;/span&gt;(index);
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
                }
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;clear&quot;&gt;6. clear()&lt;/h3&gt;
&lt;p&gt;   这个方法就干了一件事，把数组中的引用全都设置为 null 以便 gc 。而不是仅仅把 size 设置为 0 。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// gc 所有节点&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;clear&lt;/span&gt;() {
        modCount++;
        &lt;span class=&quot;co&quot;&gt;// clear to let GC do its work&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; size; i++)
            elementData[i] = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        size = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;addallcollection-e&quot;&gt;7. addAll(Collection e)&lt;/h3&gt;
&lt;p&gt;   这个没啥好说的就是，采用转数组然后 copy&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;// 一个套路 只要涉及到 Collection接口的方法都是把这个接口转成一个数组然后对数组操作&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addAll&lt;/span&gt;(Collection&amp;lt;? &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; E&amp;gt; c) {
        Object[] a = c.&lt;span class=&quot;fu&quot;&gt;toArray&lt;/span&gt;();
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; numNew = a.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
        &lt;span class=&quot;fu&quot;&gt;ensureCapacityInternal&lt;/span&gt;(size + numNew);  &lt;span class=&quot;co&quot;&gt;// Increments modCount&lt;/span&gt;
        System.&lt;span class=&quot;fu&quot;&gt;arraycopy&lt;/span&gt;(a, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, elementData, size, numNew);
        size += numNew;
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; numNew != &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;访问方法分析&quot;&gt;4. 访问方法分析&lt;/h2&gt;
&lt;h3 id=&quot;get&quot;&gt;1. get&lt;/h3&gt;
&lt;p&gt;   直接访问数组下标。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;// 没啥好说的直接去找数组下标&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; index) {
        &lt;span class=&quot;fu&quot;&gt;rangeCheck&lt;/span&gt;(index);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;elementData&lt;/span&gt;(index);
    }
    &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;sublist&quot;&gt;2. subList&lt;/h3&gt;
&lt;p&gt;   这个方法的实现比较有意思，他不是直接截取一个新的 List 返回，而是在这个类的内部还有一个 subList 的内部类，然后这个类就记录了 subList 的开始结束下标，然后返回的是这个 subList 对象。你可能会想返回的 subList 他不是 List 不会有问题吗，这里这个 subList 是继承的 AbstractList 所以还是正确的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; List&amp;lt;E&amp;gt; &lt;span class=&quot;fu&quot;&gt;subList&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; fromIndex, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; toIndex) {
        &lt;span class=&quot;fu&quot;&gt;subListRangeCheck&lt;/span&gt;(fromIndex, toIndex, size);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SubList&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, fromIndex, toIndex);
    }
    &lt;span class=&quot;co&quot;&gt;// subList 返回的是一个位置标记实例，就是在原来的数组上放了一些标志，没有修改或者拷贝新的空间&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SubList &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; AbstractList&amp;lt;E&amp;gt; &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; RandomAccess {
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; AbstractList&amp;lt;E&amp;gt; parent;
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; parentOffset;
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; offset;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; size;
        &lt;span class=&quot;co&quot;&gt;// other functions .....&lt;/span&gt;
     }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;其他功能方法&quot;&gt;5. 其他功能方法&lt;/h2&gt;
&lt;h3 id=&quot;writereadobject&quot;&gt;1. write/readObject&lt;/h3&gt;
&lt;p&gt;  前面在介绍数据域的时候我就有标注 elementData 是一个 transition 的变量也就是在自动序列化的时候会忽略这个字段。&lt;/p&gt;
&lt;p&gt;   然后我们又在源码中找到到了 &lt;code&gt;write/readObject&lt;/code&gt; 方法，这两个方法是用来序列化 &lt;code&gt;elementData&lt;/code&gt; 中的每一个元素，也就是手动的对这个字段进行序列化和反序列化。这不是多此一举吗？&lt;/p&gt;
&lt;p&gt;   既然要将ArrayList的字段序列化（即将elementData序列化），那为什么又要用transient修饰elementData呢？&lt;/p&gt;
&lt;p&gt;   回想ArrayList的自动扩容机制，elementData数组相当于容器，当容器不足时就会再扩充容量，但是容器的容量往往都是大于或者等于ArrayList所存元素的个数。&lt;/p&gt;
&lt;p&gt;   比如，现在实际有了8个元素，那么elementData数组的容量可能是8x1.5=12，如果直接序列化elementData数组，那么就会浪费4个元素的空间，特别是当元素个数非常多时，这种浪费是非常不合算的。&lt;/p&gt;
&lt;p&gt;   所以ArrayList的设计者将elementData设计为transient，然后在writeObject方法中手动将其序列化，并且只序列化了实际存储的那些元素，而不是整个数组。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;writeObject&lt;/span&gt;(java.&lt;span class=&quot;fu&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;ObjectOutputStream&lt;/span&gt; s)
        &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; java.&lt;span class=&quot;fu&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;IOException&lt;/span&gt;{
        &lt;span class=&quot;co&quot;&gt;// Write out element count, and any hidden stuff&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; expectedModCount = modCount;
        s.&lt;span class=&quot;fu&quot;&gt;defaultWriteObject&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;// Write out size as capacity for behavioural compatibility with clone()&lt;/span&gt;
        s.&lt;span class=&quot;fu&quot;&gt;writeInt&lt;/span&gt;(size);
        &lt;span class=&quot;co&quot;&gt;// Write out all elements in the proper order.&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i&amp;lt;size; i++) {
            s.&lt;span class=&quot;fu&quot;&gt;writeObject&lt;/span&gt;(elementData[i]);
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (modCount != expectedModCount) {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ConcurrentModificationException();
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;fast-fail&quot;&gt;2. fast-fail&lt;/h3&gt;
&lt;p&gt;   所谓的 &lt;code&gt;fast-fail&lt;/code&gt; 就是在我们进行 &lt;code&gt;iterator&lt;/code&gt; 遍历的时候不允许调用 &lt;code&gt;Collection&lt;/code&gt; 接口的方法进行对容器修改，否则就会抛异常。这个实现的机制是在 &lt;code&gt;iterator&lt;/code&gt; 中维护了两个变量，分别是 &lt;code&gt;modCount&lt;/code&gt; 和 &lt;code&gt;expectedModCount&lt;/code&gt; 由于 &lt;code&gt;Collection&lt;/code&gt; 接口的方法在每次修改操作的时候都会对 &lt;code&gt;modCount++&lt;/code&gt; 所以如果在 &lt;code&gt;iterator&lt;/code&gt; 中检测到他们不相等的时候就抛异常。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Itr &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Iterator&amp;lt;E&amp;gt; {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; cursor;       &lt;span class=&quot;co&quot;&gt;// index of next element to return&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; lastRet = -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// index of last element returned; -1 if no such&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; expectedModCount = modCount;
        
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;checkForComodification&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (modCount != expectedModCount)
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ConcurrentModificationException();
        }
   }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;foreach&quot;&gt;3. forEach&lt;/h3&gt;
&lt;p&gt;   这个是一个函数式编程的方法，看看他的参数 &lt;code&gt;forEach(Consumer&amp;lt;? super E&amp;gt; action)&lt;/code&gt; 很有意思里面接受是一个函数式的接口，我们里面回调了 &lt;code&gt;Consumer&lt;/code&gt; 的 &lt;code&gt;accept&lt;/code&gt; 所以我们只需要传入一个函数接口就能对每一个元素处理。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;forEach&lt;/span&gt;(Consumer&amp;lt;? &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt; E&amp;gt; action) {
        Objects.&lt;span class=&quot;fu&quot;&gt;requireNonNull&lt;/span&gt;(action);
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; expectedModCount = modCount;
        &lt;span class=&quot;fu&quot;&gt;@SuppressWarnings&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;unchecked&quot;&lt;/span&gt;)
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; E[] elementData = (E[]) &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;elementData&lt;/span&gt;;
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; size = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; modCount == expectedModCount &amp;amp;&amp;amp; i &amp;lt; size; i++) {
            &lt;span class=&quot;co&quot;&gt;//回调&lt;/span&gt;
            action.&lt;span class=&quot;fu&quot;&gt;accept&lt;/span&gt;(elementData[i]);
        }
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (modCount != expectedModCount) {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ConcurrentModificationException();
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写了一段测试代码，但是这个方法不常用，主要是 Collection 是可以自己生成 Stream 对象，然后调用上面的方法即可。这里提一下。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ArrayListTest {

    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;foreach&lt;/span&gt;() {
        ArrayList&amp;lt;Integer&amp;gt; list = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();
        list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;);
        list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;);
        list.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;);
        list.&lt;span class=&quot;fu&quot;&gt;forEach&lt;/span&gt;(System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;::print);  &lt;span class=&quot;co&quot;&gt;//打印每一次元素。&lt;/span&gt;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;sort&quot;&gt;4. sort&lt;/h3&gt;
&lt;p&gt;底层调用了 Arrays.sort 方法没什么好说的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;(Comparator&amp;lt;? &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt; E&amp;gt; c) {
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; expectedModCount = modCount;
        Arrays.&lt;span class=&quot;fu&quot;&gt;sort&lt;/span&gt;((E[]) elementData, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, size, c);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (modCount != expectedModCount) {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ConcurrentModificationException();
        }
        modCount++;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;removeif&quot;&gt;5. removeIf&lt;/h3&gt;
&lt;p&gt;   这个和 forEach 差不多，就是回调写好了。&lt;/p&gt;
&lt;h2 id=&quot;vector&quot;&gt;6. Vector&lt;/h2&gt;
&lt;p&gt;以上基本是把 &lt;code&gt;ArrayList&lt;/code&gt; 的重要的方法和属性介绍完了，我们已经比较清楚他底层的实现和数据结构了。然后提到 &lt;code&gt;ArrayList&lt;/code&gt; 自然也少不了一个比较古老的容器 &lt;code&gt;Vector&lt;/code&gt; 这个容器真的和 &lt;code&gt;ArrayList&lt;/code&gt; 太像了。因为你会发现他们连继承和实现的接口都是一样的。但是也会有一些不同的地方，下面分条介绍一下。&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在 &lt;code&gt;Vector&lt;/code&gt; 中基本所有的方法都是 &lt;code&gt;synchronized&lt;/code&gt; 的方法，所以说他是线程安全的 &lt;code&gt;ArrayList&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;构造方法不一样，在属性中没有两个比较特殊的常量，所以说他的构造方法直接初始化一个容量为 10 的数组。然后他有四个构造方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;遍历的接口不一样。他还是有 &lt;code&gt;iterator&lt;/code&gt; 的但是他以前的遍历的方法是 &lt;code&gt;Enumeration&lt;/code&gt; 接口，通过 &lt;code&gt;elements&lt;/code&gt; 获取 &lt;code&gt;Enumeration&lt;/code&gt; 然后使用 &lt;code&gt;hasMoreElements&lt;/code&gt; 和 &lt;code&gt;nextElement&lt;/code&gt; 获取元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;缺少一些函数式编程的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 26 Mar 2018 14:46:00 +0000</pubDate>
<dc:creator>lwen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwen/p/8654637.html</dc:identifier>
</item>
<item>
<title>SpringBoot快速开发REST服务最佳实践 - JeffWong</title>
<link>http://www.cnblogs.com/jeffwongishandsome/p/quick-develop-rest-api-by-using-spring-boot.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jeffwongishandsome/p/quick-develop-rest-api-by-using-spring-boot.html</guid>
<description>&lt;h3&gt;一、为什么选择SpringBoot&lt;/h3&gt;
&lt;p&gt;Spring Boot是由&lt;a href=&quot;https://pivotal.io/&quot; target=&quot;_blank&quot;&gt;Pivotal&lt;/a&gt;团队提供的全新框架，被很多业内资深人士认为是可能改变游戏规则的新项目。早期我们搭建一个SSH或者Spring Web应用，需要非常繁琐的步骤，比如配置web.xml，配置数据库连接，配置事务，配置日志，配置Tomcat，装配Bean，声明和配置切面等等等等，如果项目过大多人协作各种冗长啰嗦的配置让人烦不胜烦，这么多年下来，给人一种Java就是大型配置文件的感觉。&lt;/p&gt;
&lt;p&gt;SpringBoot的设计目的是用来简化新Spring应用的初始搭建以及开发过程，吸引更多开发者的最大亮点之一是集成了自动配置的魔力。SpringBoot的四个主要新特性如下：&lt;/p&gt;
&lt;p&gt;1、Spring Boot Starter：它将常用的依赖分组进行了整合， 将其合并到一个依赖中， 这样就可以一次性添加到项目的Maven或Gradle构建中；Spring Boot通过提供众多起步依赖降低项目依赖的复杂度。起步依赖本质上是一个Maven项目对象模型（Project Object Model， POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。很多起步依赖的命名都暗示了它们提供的某种或某类功能。Spring Boot经过了足够的测试，确保引入的全部依赖都能相互兼容。这是一种解脱，只需指定起步依赖，不用担心自己需要维护哪些库，也不必担心它们的版本。&lt;br/&gt;2、&lt;strong&gt;&lt;span&gt;自动配置&lt;/span&gt;&lt;/strong&gt;：Spring Boot的自动配置特性利用了Spring 4对条件化配置的支持， 合理地推测应用所需的bean并自动化配置它们；最后， Spring Boot没有引入任何形式的代码生成，而是利用了Spring 4的条件化配置特性，以及Maven和Gradle提供的传递依赖解析，以此实现Spring应用程序上下文里的自动配置。简而言之， Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。每当应用程序启动的时候， Spring Boot的自动配置都要做将近200个这样的决定，涵盖安全、集成、持久化、 Web开发等诸多方面。所有这些自动配置就是为了尽量不让你自己写配置。&lt;br/&gt;3、命令行接口（Command-line interface， CLI）：Spring Boot的CLI发挥了Groovy编程语言的优势， 并结合自动配置进一步简化Spring应用的开发；&lt;br/&gt;4、Actuator： 它为Spring Boot应用添加了一定的管理特性。&lt;/p&gt;
&lt;p&gt;常见的搭建一个SpringBoot应用只要如下几步：&lt;/p&gt;
&lt;p&gt;1、打开http://start.spring.io/&lt;/p&gt;
&lt;p&gt;2、点击“Switch to the full version，选择Java版本，如1.8，选择好构建工具，如Maven或Gradle&lt;/p&gt;
&lt;p&gt;4、点击Generate Project下载项目压缩包&lt;/p&gt;
&lt;p&gt;5、解压后，使用eclipse或者intellij idea，导入项目即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32361/201803/32361-20180325163323474-1324453368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，对于经验丰富的老鸟，不需要打开网页再下载解压导入文件那么多步骤，通过Idea也可以一步一步构造SpringBoot项目。&lt;/p&gt;
&lt;h3&gt;二、工程结构&lt;/h3&gt;
&lt;p&gt;官方生成的SpringBoot项目，默认结构说明：&lt;/p&gt;
&lt;p&gt;1、src/main/java  程序开发以及主程序入口&lt;br/&gt;2、src/main/resources 配置文件&lt;br/&gt;3、src/test/java  测试程序&lt;/p&gt;
&lt;p&gt;src/main/java根目录下面，有如下Java类和包：&lt;/p&gt;
&lt;p&gt;1、Application.java 应用程序入口，包括一个静态main方法，可以做一些框架配置，比如mybatis、swagger等&lt;br/&gt;2、domain目录主要用于数据访问实体（DataObject）与数据访问层（Repository）&lt;br/&gt;3、service目录主要是业务逻辑相关的服务接口和实现&lt;br/&gt;4、controller负责页面访问控制，对外暴露API&lt;/p&gt;
&lt;p&gt;当然，我们需要参考成熟的项目结构或者根据个人经验来改造项目结构，本文的SpringBootDemo为了方便仅做简单调整，项目结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32361/201803/32361-20180325164735210-814400817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要包说明：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公共模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、common：公共类，如枚举，常量、业务无关的通用公共实体等&lt;/p&gt;
&lt;p&gt;2、util：常用实用的帮助类，如反射、字符串、集合、枚举、正则、缓存、队列等&lt;/p&gt;
&lt;p&gt;3、config：自定义的配置项，可从配置文件读取&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表现层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、controller：负责页面访问控制，对外暴露Rest API接口&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据访问层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、domain：数据对象实体DO，通常和数据表、视图或其他业务对象一一对应&lt;/p&gt;
&lt;p&gt;2、dao：数据访问对象，本文demo选择比较熟悉的mybatis作为ORM工具&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;业务逻辑层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、service：服务 contract是接口，impl是服务实现&lt;/p&gt;
&lt;p&gt;2、entity：实体 vo是服务可对外公开的实体；dto是数据传输对象，可在服务间传递；qo：查询对象，可以认为是查询条件的封装&lt;/p&gt;
&lt;p&gt;本文demo没有写dto和qo示例，很多中小型项目，entity其实是非常混乱的，实体设计和分层抽象有问题，有时候直接影响到业务逻辑复杂程度。&lt;/p&gt;
&lt;p&gt;关于工程结构，尤其是应用分层和领域实体抽象（数据访问对象DO和显示层对象VO等），强烈推荐大家参考&amp;lt;&amp;lt;阿里巴巴Java开发手册&amp;gt;&amp;gt;终极版本的工程结构一章。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/32361/201803/32361-20180325180229047-1840425404.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、MyBatis使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Maven依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e36fe952-de33-44ba-b38e-1e7af107f8f6')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_e36fe952-de33-44ba-b38e-1e7af107f8f6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e36fe952-de33-44ba-b38e-1e7af107f8f6&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e36fe952-de33-44ba-b38e-1e7af107f8f6',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e36fe952-de33-44ba-b38e-1e7af107f8f6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.mybatis.spring.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mybatis-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.2.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;数据库驱动：&lt;/p&gt;
&lt;p&gt;MySQL：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('41ea1ed3-3855-4b69-99ff-0058bcabe306')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_41ea1ed3-3855-4b69-99ff-0058bcabe306&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_41ea1ed3-3855-4b69-99ff-0058bcabe306&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('41ea1ed3-3855-4b69-99ff-0058bcabe306',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_41ea1ed3-3855-4b69-99ff-0058bcabe306&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mysql-connector-java&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;5.1.39&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;SQLServer：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2e45309a-e8f6-4026-b85d-1acc6a4f507f')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_2e45309a-e8f6-4026-b85d-1acc6a4f507f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2e45309a-e8f6-4026-b85d-1acc6a4f507f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2e45309a-e8f6-4026-b85d-1acc6a4f507f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2e45309a-e8f6-4026-b85d-1acc6a4f507f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.microsoft.sqlserver&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;mssql-jdbc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;6.4.0.jre8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;隆重公告，&lt;a href=&quot;http://www.cnblogs.com/jeffwongishandsome/p/Microsoft-JDBC-Driver-For-SQLServer.html&quot; target=&quot;_blank&quot;&gt;微软Microsoft JDBC Driver For SQL Server已发布到maven中央仓库&lt;/a&gt;，本文的demo选择的是SQLServer，主要是MySQL很多人都写了，资料太充足，不如试试不同的风格，而且我在前厂写的第一个线上SpringBoot应用也是访问SQLServer，demo就哪个好举例就用哪个了。&lt;/p&gt;
&lt;p&gt;配置文件中的配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e2c13779-a3f7-4ee2-9553-7aa3fc9e3bd2')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_e2c13779-a3f7-4ee2-9553-7aa3fc9e3bd2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e2c13779-a3f7-4ee2-9553-7aa3fc9e3bd2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e2c13779-a3f7-4ee2-9553-7aa3fc9e3bd2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e2c13779-a3f7-4ee2-9553-7aa3fc9e3bd2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;## MYSQL数据源配置
#spring.datasource.url&lt;/span&gt;=jdbc:mysql://localhost:3306/springbootdb?useUnicode=true&amp;amp;characterEncoding=&lt;span&gt;utf8
#spring.datasource.username&lt;/span&gt;=&lt;span&gt;root
#spring.datasource.password&lt;/span&gt;=123456&lt;span&gt;
#spring.datasource.driver-class-name&lt;/span&gt;=&lt;span&gt;com.mysql.jdbc.Driver

## MSSQL数据源配置
spring.datasource.url&lt;/span&gt;=jdbc:sqlserver://localhost&lt;span&gt;;&lt;/span&gt;&lt;span&gt;databaseName=TestDB&lt;/span&gt;
spring.datasource.username=&lt;span&gt;sa
spring.datasource.password&lt;/span&gt;=123456&lt;span&gt;
spring.datasource.driverClassName&lt;/span&gt;=&lt;span&gt;com.microsoft.sqlserver.jdbc.SQLServerDriver
spring.jpa.show-sql&lt;/span&gt;=&lt;span&gt;true
spring.jpa.hibernate.dialect&lt;/span&gt;=&lt;span&gt;org.hibernate.dialect.SQLServer2012Dialect
#spring.jpa.hibernate.ddl-auto &lt;/span&gt;=&lt;span&gt; create-drop

## Mybatis 配置
mybatis.typeAliasesPackage&lt;/span&gt;=&lt;span&gt;com.power.demo.domain
mybatis.mapperLocations&lt;/span&gt;=classpath:mapper/*.xml
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;Mapper配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('218db6c9-422e-4484-9d17-6a89acf22a48')&quot; readability=&quot;40&quot;&gt;&lt;img id=&quot;code_img_closed_218db6c9-422e-4484-9d17-6a89acf22a48&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_218db6c9-422e-4484-9d17-6a89acf22a48&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('218db6c9-422e-4484-9d17-6a89acf22a48',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_218db6c9-422e-4484-9d17-6a89acf22a48&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.power.demo.dao.GoodsDao&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;resultMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;BaseResultMap&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.power.demo.domain.GoodsDO&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;GoodsId&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;goodsId&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;GoodsCode&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;goodsCode&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;GoodsName&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;goodsName&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;GoodsType&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;goodsType&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;CreateTime&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;createTime&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;column&lt;/span&gt;&lt;span&gt;=&quot;Disabled&quot;&lt;/span&gt;&lt;span&gt; property&lt;/span&gt;&lt;span&gt;=&quot;disabled&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;resultMap&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parameterMap &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;Goods&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;com.power.demo.domain.GoodsDO&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;sql &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;Base_Column_List&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        GoodsId,GoodsCode,GoodsName,GoodsType,CreateTime,Disabled
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;sql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findGoodsByGoodsId&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;GoodsDO&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;java.lang.String&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include &lt;/span&gt;&lt;span&gt;refid&lt;/span&gt;&lt;span&gt;=&quot;Base_Column_List&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        FROM Goods WITH(NOLOCK) WHERE 1=1
        AND Disabled=0
        AND GoodsId = #{goodsId}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findGoodsByGoodsCode&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;GoodsDO&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;java.lang.String&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include &lt;/span&gt;&lt;span&gt;refid&lt;/span&gt;&lt;span&gt;=&quot;Base_Column_List&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        FROM Goods WITH(NOLOCK) WHERE 1=1
        AND Disabled=0
        AND GoodsCode = #{goodsCode}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findGoodsByGoodsType&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;GoodsDO&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;java.lang.Integer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include &lt;/span&gt;&lt;span&gt;refid&lt;/span&gt;&lt;span&gt;=&quot;Base_Column_List&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        FROM Goods WITH(NOLOCK) WHERE 1=1
        AND Disabled=0
        AND GoodsType = #{goodsType}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findAllGoods&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;GoodsDO&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        SELECT
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include &lt;/span&gt;&lt;span&gt;refid&lt;/span&gt;&lt;span&gt;=&quot;Base_Column_List&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;span&gt;
        FROM Goods WITH(NOLOCK) WHERE 1=1
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;insertGoods&quot;&lt;/span&gt;&lt;span&gt; parameterMap&lt;/span&gt;&lt;span&gt;=&quot;Goods&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

        INSERT INTO Goods (GoodsId,GoodsCode,GoodsName,GoodsType,CreateTime,Disabled)
        VALUES(#{goodsId},#{goodsCode},#{goodsName},#{goodsType},#{createTime},#{disabled})

    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;updateGoods&quot;&lt;/span&gt;&lt;span&gt; parameterMap&lt;/span&gt;&lt;span&gt;=&quot;Goods&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

        UPDATE Goods SET Disabled=#{disabled} WHERE GoodsId=#{goodsId}

    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;deleteGoods&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;java.lang.String&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

        DELETE FROM Goods WHERE GoodsId=#{goodsId}

    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;最后，在应用程序入口，添加一行注解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mapper 接口类扫描包配置&lt;/span&gt;
@MapperScan(&quot;com.power.demo.dao&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Application {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本文demo只提供了简单的CRUD，但是常见的开发还有很多东西要写。比如：&lt;/p&gt;
&lt;p&gt;如何做多库配置，如何动态拼接执行复杂SQL，如何批量插入，如何拿到运行时SQL语句，如何使用存储过程，如何进行数据缓存、如何使用事务等。&lt;/p&gt;
&lt;p&gt;这些遗留内容希望有心的你慢慢去发掘尝试了。&lt;/p&gt;
&lt;p&gt;推荐MyBatis代码生成器：&lt;a href=&quot;https://github.com/zouzg/mybatis-generator-gui&quot; target=&quot;_blank&quot;&gt;MyBatis Generator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32361/201803/32361-20180326123410446-2056354723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、API文档描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用应用广泛的Swagger，生成API文档。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/32361/201803/32361-20180325175205922-1740157440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Maven中添加依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('50204b44-f6ba-4280-aaba-ae083e5b90cd')&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_50204b44-f6ba-4280-aaba-ae083e5b90cd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_50204b44-f6ba-4280-aaba-ae083e5b90cd&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('50204b44-f6ba-4280-aaba-ae083e5b90cd',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_50204b44-f6ba-4280-aaba-ae083e5b90cd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;io.springfox&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;springfox-swagger2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.2.2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;io.springfox&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;springfox-swagger-ui&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.2.2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;需要在应用程序入口Application里面加一行注解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@EnableSwagger2
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Application {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 不要忘了Api说明和实体说明配置，demo提供了完整示例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;五、单元测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用Junit进行单元测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4a433d56-a8a8-4990-b6cb-9f40cb6e7de2')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_4a433d56-a8a8-4990-b6cb-9f40cb6e7de2&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4a433d56-a8a8-4990-b6cb-9f40cb6e7de2&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4a433d56-a8a8-4990-b6cb-9f40cb6e7de2',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4a433d56-a8a8-4990-b6cb-9f40cb6e7de2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by JeffWong.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RunWith(SpringRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@SpringBootTest
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CommonTests {


    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; testGoodsTypeEnum() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        GoodsType goodsType &lt;/span&gt;=&lt;span&gt; GoodsType.Discount;

        System.out.println(GoodsType.Normal.ordinal());&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
        System.out.println(GoodsType.Discount.ordinal());&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;
        System.out.println(goodsType.getCode());
        System.out.println(goodsType.getDescription());

        Assert.isTrue(goodsType.getCode() &lt;/span&gt;== 1024, &quot;折扣商品Code为1024&quot;&lt;span&gt;);


    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;如果需要单元测试的方法需要配置文件，那么test下也要有resources目录用于存放资源文件。&lt;/p&gt;
&lt;p&gt;本文demo提供了完整的各层单元测试方法，大家可以参考下。&lt;/p&gt;
&lt;p&gt;总结：使用SpringBoot全家桶，你可以快速上手开发Java的REST接口应用，配合Java8+的相关新特性，写Java也越来越省心（虽然Java8的lamda比较难受，Checked Exception层层感染有点受不了，Date非常不好用-_-），听说Java10要有var，估计还可以少写很多代码，而且VS也要支持Java了（不是J#），作为有丰富开发经验的.NET开发者，也就更加有尝试的冲动了。&lt;/p&gt;
&lt;p&gt;最后提供demo&lt;a href=&quot;https://files.cnblogs.com/files/jeffwongishandsome/springbootdemo.zip&quot; target=&quot;_blank&quot;&gt;下载&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&amp;lt;&amp;lt;阿里巴巴Java开发手册&amp;gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;&amp;lt;Spring in Action&amp;gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;&amp;lt;Spring Boot in Action&amp;gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/&quot; target=&quot;_blank&quot;&gt;https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/u/6a622d516e32&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/u/6a622d516e32&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://spring.io/&quot; target=&quot;_blank&quot;&gt;http://spring.io/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 26 Mar 2018 14:23:00 +0000</pubDate>
<dc:creator>JeffWong</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jeffwongishandsome/p/quick-develop-rest-api-by-using-spring-boot.html</dc:identifier>
</item>
<item>
<title>纯CSS制作各种各样的网页图标（三角形、暂停按钮、下载箭头、加号等） - BluesQian</title>
<link>http://www.cnblogs.com/QianBoy/p/8654425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/QianBoy/p/8654425.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180326212311642-1491897782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;&lt;br/&gt;&lt;/span&gt;.box{
&lt;/pre&gt;
&lt;pre&gt;
            width: 0;
            height: 0;
            border-top: 50px solid transparent;
            border-bottom: 50px solid transparent;
            border-left: 50px solid transparent;
            border-right: 50px solid red;
}
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180326212707875-1934938477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
 .box&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
            margin&lt;/span&gt;:&lt;span&gt; 100px auto&lt;/span&gt;;&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;&lt;span&gt;
            transform&lt;/span&gt;:&lt;span&gt; skew(-25deg)&lt;/span&gt;;
        }&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180326213118891-4278945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;style&amp;gt;
        .box&lt;/span&gt;{&lt;span&gt;
            width&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
            height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
            margin&lt;/span&gt;:&lt;span&gt; 100px auto&lt;/span&gt;;&lt;span&gt;
            color&lt;/span&gt;:&lt;span&gt; #000&lt;/span&gt;;&lt;span&gt;
            border&lt;/span&gt;:&lt;span&gt; 1px solid&lt;/span&gt;;&lt;span&gt;
            border-radius&lt;/span&gt;:&lt;span&gt; 50%&lt;/span&gt;;&lt;span&gt;
            outline&lt;/span&gt;:&lt;span&gt; 10px solid&lt;/span&gt;;&lt;span&gt;
            outline-offset&lt;/span&gt;:&lt;span&gt; -26px&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;暂停按钮的实现原理就是边框用border，里面的正方形用outline。因为outline有一个offset属性可以用来设置偏移量，并且是按照比例来的。&lt;/p&gt;
&lt;p&gt;其实如果再将outline-offset的值设置小一点，一个加好就出来了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180326213448649-1764983298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
    .box&lt;/span&gt;{&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
        height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
        margin&lt;/span&gt;:&lt;span&gt; 100px auto&lt;/span&gt;;&lt;span&gt;
        color&lt;/span&gt;:&lt;span&gt; #000&lt;/span&gt;;&lt;span&gt;
        border&lt;/span&gt;:&lt;span&gt; 1px solid&lt;/span&gt;;&lt;span&gt;
        border-radius&lt;/span&gt;:&lt;span&gt; 50%&lt;/span&gt;;&lt;span&gt;
        outline&lt;/span&gt;:&lt;span&gt; 10px solid&lt;/span&gt;;&lt;span&gt;
        outline-offset&lt;/span&gt;:&lt;span&gt; -35px&lt;/span&gt;;
    }&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果再将其旋转，就变成了一个关闭按钮&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180326213611250-2068594131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
    .box&lt;/span&gt;{&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
        height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
        margin&lt;/span&gt;:&lt;span&gt; 100px auto&lt;/span&gt;;&lt;span&gt;
        color&lt;/span&gt;:&lt;span&gt; #000&lt;/span&gt;;&lt;span&gt;
        border&lt;/span&gt;:&lt;span&gt; 1px solid&lt;/span&gt;;&lt;span&gt;
        border-radius&lt;/span&gt;:&lt;span&gt; 50%&lt;/span&gt;;&lt;span&gt;
        outline&lt;/span&gt;:&lt;span&gt; 10px solid&lt;/span&gt;;&lt;span&gt;
        outline-offset&lt;/span&gt;:&lt;span&gt; -35px&lt;/span&gt;;&lt;span&gt;
        transform&lt;/span&gt;:&lt;span&gt; rotate(45deg)&lt;/span&gt;;
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180326214045955-2102460616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
    .box&lt;/span&gt;{&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
        height&lt;/span&gt;:&lt;span&gt; 0px&lt;/span&gt;;&lt;span&gt;
        margin&lt;/span&gt;:&lt;span&gt; 100px auto&lt;/span&gt;;&lt;span&gt;
        box-shadow&lt;/span&gt;:&lt;span&gt; 36px 10px 0 3px red,
        36px 0 0 3px red,
        36px 20px 0 3px red&lt;/span&gt;;
    }&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180326214045955-2102460616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
    .box&lt;/span&gt;{&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; 30px&lt;/span&gt;;&lt;span&gt;
        height&lt;/span&gt;:&lt;span&gt; 3px&lt;/span&gt;;&lt;span&gt;
        margin&lt;/span&gt;:&lt;span&gt; 100px auto&lt;/span&gt;;&lt;span&gt;
        padding&lt;/span&gt;:&lt;span&gt; 2px 0&lt;/span&gt;;&lt;span&gt;
        border-top&lt;/span&gt;:&lt;span&gt; 3px solid red&lt;/span&gt;;&lt;span&gt;
        border-bottom&lt;/span&gt;:&lt;span&gt; 3px solid red&lt;/span&gt;;&lt;span&gt;
        background-clip&lt;/span&gt;:&lt;span&gt; content-box&lt;/span&gt;;&lt;span&gt;
        background-color&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;
    }&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180326214441074-1009957524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为box-shadow会按比例缩放，因此将第一个值设置为白色，然后将第二个值设置的比第一个值大就可以了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
    .box&lt;/span&gt;{&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; 30px&lt;/span&gt;;&lt;span&gt;
        height&lt;/span&gt;:&lt;span&gt; 30px&lt;/span&gt;;&lt;span&gt;
        margin&lt;/span&gt;:&lt;span&gt; 100px auto&lt;/span&gt;;&lt;span&gt;
        background-color&lt;/span&gt;:&lt;span&gt; #000&lt;/span&gt;;&lt;span&gt;
        border-radius&lt;/span&gt;:&lt;span&gt; 50%&lt;/span&gt;;&lt;span&gt;
        box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 0 5px #fff,0 0 0 10px #000&lt;/span&gt;;
    }&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180326221545601-1754825757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
    .box &lt;/span&gt;{&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; 30px&lt;/span&gt;;&lt;span&gt;
        height&lt;/span&gt;:&lt;span&gt; 30px&lt;/span&gt;;&lt;span&gt;
        margin&lt;/span&gt;:&lt;span&gt; 100px auto&lt;/span&gt;;&lt;span&gt;
        background-color&lt;/span&gt;:&lt;span&gt; #000&lt;/span&gt;;&lt;span&gt;
        border-radius&lt;/span&gt;:&lt;span&gt; 50%&lt;/span&gt;;&lt;span&gt;
        box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 0 5px #fff, 0 0 0 10px #000&lt;/span&gt;;&lt;span&gt;
        outline&lt;/span&gt;:&lt;span&gt; 36px solid #fff&lt;/span&gt;;&lt;span&gt;
        outline-offset&lt;/span&gt;:&lt;span&gt; -50px&lt;/span&gt;;
    }&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180326215111847-1486439464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
    .box &lt;/span&gt;{&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
        margin&lt;/span&gt;:&lt;span&gt; 100px auto&lt;/span&gt;;&lt;span&gt;
        border&lt;/span&gt;:&lt;span&gt; 3px solid red&lt;/span&gt;;&lt;span&gt;
        outline&lt;/span&gt;:&lt;span&gt; 6px dotted red&lt;/span&gt;;&lt;span&gt;
        outline-offset&lt;/span&gt;:&lt;span&gt; 6px&lt;/span&gt;;
    }&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180326215412051-582138998.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用border制作三角形，使用box-shadow制作正方形，主要用了偏移&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
    .box &lt;/span&gt;{&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
        margin&lt;/span&gt;:&lt;span&gt; 100px auto&lt;/span&gt;;&lt;span&gt;
        color&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;&lt;span&gt;
        border&lt;/span&gt;:&lt;span&gt; 8px solid transparent&lt;/span&gt;;&lt;span&gt;
        border-top&lt;/span&gt;:&lt;span&gt; 8px solid red&lt;/span&gt;;&lt;span&gt;
        box-shadow&lt;/span&gt;:&lt;span&gt; 0 -12px 0 -4px&lt;/span&gt;;
    }&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180326215655059-629991862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现这种效果的原理就是讲三角形设置成背景色，这样空心的三角形就出现了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
    .box &lt;/span&gt;{&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
        height&lt;/span&gt;:&lt;span&gt; 8px&lt;/span&gt;;&lt;span&gt;
        background-color&lt;/span&gt;:&lt;span&gt;orange&lt;/span&gt;;&lt;span&gt;
        border&lt;/span&gt;:&lt;span&gt; 8px solid transparent&lt;/span&gt;;&lt;span&gt;
        border-bottom&lt;/span&gt;:&lt;span&gt; 8px solid #fff&lt;/span&gt;;
    }&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180326215831502-639043533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个比较简单，就是通过渐变函数来实现，然后来个圆角边框&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
    .box &lt;/span&gt;{&lt;span&gt;
       width&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
        height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
        border-radius&lt;/span&gt;:&lt;span&gt; 50%&lt;/span&gt;;&lt;span&gt;
        background-image&lt;/span&gt;:&lt;span&gt; linear-gradient(to right,#ccc 50%,#000 50%)&lt;/span&gt;;
    }&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180326220121190-1466031728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;外圈利用圆角边框，里面的竖线用渐变来做，然后再用旋转属性即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
    .box &lt;/span&gt;{&lt;span&gt;
       width&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
        height&lt;/span&gt;:&lt;span&gt; 50px&lt;/span&gt;;&lt;span&gt;
        border-radius&lt;/span&gt;:&lt;span&gt; 50%&lt;/span&gt;;&lt;span&gt;
        border&lt;/span&gt;:&lt;span&gt;2px solid #000&lt;/span&gt;;&lt;span&gt;
        background&lt;/span&gt;:&lt;span&gt; linear-gradient(to right,#fff  45%,#000 45%,#000 45%,#fff 55%)&lt;/span&gt;;&lt;span&gt;
        transform&lt;/span&gt;:&lt;span&gt; rotate(40deg)&lt;/span&gt;;
    }&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180326220410985-624116116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然能做出一个三角形，那么就可以做出两个三角形。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
    .box &lt;/span&gt;{&lt;span&gt;
        width&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
        height&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
        margin&lt;/span&gt;:&lt;span&gt; 100px auto&lt;/span&gt;;&lt;span&gt;
        border&lt;/span&gt;:&lt;span&gt; 10px solid transparent&lt;/span&gt;;&lt;span&gt;
        border-left&lt;/span&gt;:&lt;span&gt; 10px solid red&lt;/span&gt;;&lt;span&gt;
        -webkit-box-reflect&lt;/span&gt;:&lt;span&gt; left 5px&lt;/span&gt;;&lt;span&gt;
        box-reflect&lt;/span&gt;:&lt;span&gt;left 5px&lt;/span&gt;;
    }&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要在Chrome浏览器中打开，因为其他浏览器或许不支持&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/755438/201803/755438-20180326220711197-277000581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;style&amp;gt;
    .box &lt;/span&gt;{&lt;span&gt;
       width&lt;/span&gt;:&lt;span&gt; 32px&lt;/span&gt;;&lt;span&gt;
        margin&lt;/span&gt;:&lt;span&gt; 100px auto&lt;/span&gt;;&lt;span&gt;
        border-top&lt;/span&gt;:&lt;span&gt; 50px solid transparent&lt;/span&gt;;&lt;span&gt;
        border-right&lt;/span&gt;:&lt;span&gt; 22px solid #096&lt;/span&gt;;&lt;span&gt;
        border-bottom-right-radius&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;;
    &lt;/span&gt;}&lt;span&gt;
&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 26 Mar 2018 14:18:00 +0000</pubDate>
<dc:creator>BluesQian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/QianBoy/p/8654425.html</dc:identifier>
</item>
<item>
<title>ASP.NET MVC编程——缓存 - 甜橙很酸</title>
<link>http://www.cnblogs.com/hdwgxz/p/8654224.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hdwgxz/p/8654224.html</guid>
<description>&lt;p&gt;Web&lt;span&gt;缓存分为服务端缓存和客户端缓存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1 &lt;span&gt;服务端缓存&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1&lt;span&gt;请求域内的缓存：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;HttpContext.Items&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;类型：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HttpContext.Items&lt;span&gt;的类型为&lt;/span&gt;IDictionary&lt;span&gt;，&lt;/span&gt;&lt;span&gt;且键和值都是&lt;/span&gt;object类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;访问性：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只存在于当前请求范围内。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
HttpContext.Items[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value = HttpContext.Items[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.2&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;用户域内的缓存：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;HttpContext.Session&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;类型：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HttpContext.Session&lt;span&gt;的类型为&lt;/span&gt;HttpSessionStateBase&lt;span&gt;，&lt;/span&gt;&lt;span&gt;这个类继承自&lt;/span&gt;ICollection, IEnumerable&lt;span&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;访问性：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只针对当前用户有效，无法跨用户级别访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;过期设置：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置过期时间，当过期时间到达时，服务器便销毁存储在&lt;/span&gt;Session里的对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
HttpContext.Session[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value = (&lt;span&gt;string&lt;/span&gt;)HttpContext.Session[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置超时时间为20分钟&lt;/span&gt;
HttpContext.Session.Timeout = &lt;span&gt;20&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;或配置
&lt;/span&gt;&amp;lt;system.web&amp;gt;
  &amp;lt;sessionState timeout=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&amp;lt;/system.web&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.3&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;应用程序域内的缓存：&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;HttpContext.Application&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;HttpContext.Cache&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;类型：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HttpContext.Application&lt;span&gt;类型为&lt;/span&gt;HttpApplicationStateBase&lt;span&gt;，&lt;/span&gt;&lt;span&gt;此类继承自&lt;/span&gt;NameObjectCollectionBase, ICollection, IEnumerableHttpContext.Cache&lt;span&gt;为&lt;/span&gt;Cache&lt;span&gt;类型，此类继承自&lt;/span&gt;IEnumerable&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;访问性：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;他们的生命周期和&lt;/span&gt;IIS工作进程一样长，但HttpContext.Cache&lt;span&gt;不能跨工作进程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;过期机制：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HttpContext.Cache&lt;span&gt;可以对缓存数据设置过期机制，有两种方式：一是最后一次访问之后多长时间过期，另一种是设定过期时间点。这两种过期策略不能同时使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;缓存依赖：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cache&lt;span&gt;提供了下面的方法来设置缓存依赖&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;public object Add(string key, object value, CacheDependency dependencies, DateTime absoluteExpiration, TimeSpan slidingExpiration, CacheItemPriority priority, CacheItemRemovedCallback onRemoveCallback)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者添加值的时候设置缓存依赖：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;public void Insert(string key, object value, CacheDependency dependencies);&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中我们可以通过&lt;/span&gt;dependencies&lt;span&gt;参数指定依赖的策略。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
HttpContext.Application[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value = (&lt;span&gt;string&lt;/span&gt;)HttpContext.Application[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
HttpContext.Cache[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value = (&lt;span&gt;string&lt;/span&gt;)HttpContext.Cache[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;];
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.4输出缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt;OutputCacheAttribute&lt;span&gt;属性将控制器操作渲染的操作结果保存到缓存过滤器。可以利用它实现甜甜圈洞缓存，即缓存部分内容，而允许外围数据变化。使用此特性的时候要注意：子操作的&lt;/span&gt; OutputCacheAttribute 仅支持 Duration、VaryByCustom 和 VaryByParam 值。不能为子操作设置 CacheProfile、Location、NoStore、SqlDependency、VaryByContentEncoding 或 VaryByHeader 值，否则会抛出异常。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是该特性的定义。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited = &lt;span&gt;true&lt;/span&gt;, AllowMultiple = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OutputCacheAttribute : ActionFilterAttribute, IExceptionFilter
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取或设置缓存持续时间（以秒为单位）&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Duration { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取或设置数据存储位置&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; OutputCacheLocation Location { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否存储缓存&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; NoStore { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取或设置基于参数变化的值&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; VaryByParam { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;缓存位置枚举值为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; OutputCacheLocation
{      
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出缓存可位于产生请求的浏览器客户端、参与请求的代理服务器（或任何其他服务器）或处理请求的服务器上。 此值对应于 System.Web.HttpCacheability.Public枚举值。&lt;/span&gt;
        Any = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出缓存位于产生请求的浏览器客户端上。 此值对应于System.Web.HttpCacheability.Private 枚举值。&lt;/span&gt;
        Client = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出缓存可存储在任何 HTTP 1.1 可缓存设备中，源服务器除外。 这包括代理服务器和发出请求的客户端。&lt;/span&gt;
        Downstream = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出缓存位于处理请求的 Web 服务器上。 此值对应于 System.Web.HttpCacheability.Server 枚举值。&lt;/span&gt;
        Server = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,       
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于请求的页，禁用输出缓存。 此值对应于 System.Web.HttpCacheability.NoCache 枚举值。&lt;/span&gt;
        None = &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,      
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出缓存只能存储在源服务器或发出请求的客户端中。 代理服务器不能缓存响应。 此值对应于 System.Web.HttpCacheability.Private和 System.Web.HttpCacheability.Server 枚举值的组合。&lt;/span&gt;
        ServerAndClient = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;例：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制器&lt;/span&gt;Home的CacheExe操作为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[OutputCache(Duration=&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult CacheExe()
{
    ViewBag.TimeNow &lt;/span&gt;= DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyyMMdd     hh:mm:ss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;视图&lt;/span&gt;Index.cshtml为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jumbotron&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;h1&amp;gt;ASP.NET&amp;lt;/h1&amp;gt;
    &amp;lt;p &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lead&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;ASP.NET &lt;span&gt;is&lt;/span&gt; a free web framework &lt;span&gt;for&lt;/span&gt; building great Web sites and Web applications &lt;span&gt;using&lt;/span&gt; HTML, CSS and JavaScript.&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://asp.net&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn btn-primary btn-lg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Learn more &amp;amp;raquo;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div &lt;span&gt;class&lt;/span&gt;=”part”&amp;gt;&lt;span&gt;
    @Html.Action(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CacheExe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&amp;lt;/div&amp;gt;
&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;row&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
......
&lt;/span&gt;&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;视图&lt;/span&gt;CacheExe.cshtml为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@{
    Layout &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&amp;lt;!DOCTYPE html&amp;gt;

&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width=device-width&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
    &amp;lt;h1&amp;gt;@ViewBag.TimeNow&amp;lt;/h1&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当渲染页面时，&lt;/span&gt;class为part的&amp;lt;div&amp;gt;部分从缓存中取值，其他部分动态变化。由于CacheExe&lt;span&gt;操作每调用一次就会计算一次当前时间，并将其付给&lt;/span&gt;ViewBag.TimeNow&lt;span&gt;，&lt;/span&gt;&lt;span&gt;那么如果在&lt;/span&gt;20s内刷新一次页面，显示的时间不变的话，就如我们设想的那样，系统将子操作调用的视图缓存了起来，过期时间为这里设置的20s&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.5甜甜圈缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只缓存页面的外围部分，允许一部分内容动态变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET MVC 不支持甜甜圈缓存，使用MvcDonutCachingNuGet包扩展了HTML方法，支持这种缓存方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2客户端缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;浏览器缓存&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;浏览器将从服务器获取的资源保存到本地，然后当再次发起请求并且请求&lt;/span&gt;url与以往请求url之一相同时，浏览器会优先查看本地磁盘，加载本地缓存资源。如果请求url不同，那么浏览器会获取网络资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;在服务器端设置&lt;/span&gt;http消息头&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常用设置举例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置是否可被客户端或代理缓存&lt;/span&gt;
&lt;span&gt;Response.Cache.SetCacheability(HttpCacheability.Public);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置过期时间&lt;/span&gt;
Response.Cache.SetMaxAge(TimeSpan.FromMinutes(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置绝对过期时间&lt;/span&gt;
Response.Cache.SetExpires(DateTime.Now.AddMinutes(&lt;span&gt;30&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;验证缓存数据的有效性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过服务端对&lt;/span&gt;http消息头进行设置，以便客户端可以验证数据有效性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常用设置举例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置Last-Modified HTTP标头&lt;/span&gt;
&lt;span&gt;Response.Cache.SetLastModified(DateTime.Now);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置ETag HTTP标头&lt;/span&gt;
Response.Cache.SetETag(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;uni:version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 26 Mar 2018 13:49:00 +0000</pubDate>
<dc:creator>甜橙很酸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hdwgxz/p/8654224.html</dc:identifier>
</item>
</channel>
</rss>