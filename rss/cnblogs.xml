<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>结合实例分析Android MVP的实现 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/8545734.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/8545734.html</guid>
<description>&lt;p&gt;　　最近阅读项目的源码，发现项目中有MVP的痕迹，但是自己却不能很好地理解相关的代码实现逻辑。主要原因是自己对于MVP的理解过于概念话，还没有真正操作过。本文打算分析一个MVP的简单实例，帮助自己更好的理解MVP的内在思想。&lt;/p&gt;
&lt;p&gt;　　对于什么是MVP，MVP和MVC的区别，MVP的有点，大家可以参考这篇文章：&lt;a href=&quot;http://kaedea.com/2015/10/11/android-mvp-pattern/&quot; target=&quot;_blank&quot;&gt;MVP 模式简单易懂的介绍方式&lt;/a&gt;。文章里面还有demo，可以帮助大家更好的理解。&lt;/p&gt;
&lt;p&gt;　　今天分析的是一个别人写的 demo，其实作者也有写文章来介绍（&lt;a href=&quot;http://blog.csdn.net/u011504118/article/details/49871211&quot; target=&quot;_blank&quot;&gt;Android MVP with Fragment and RecyclerView&lt;/a&gt;），那我为何还要自己来分析一遍呢？其实我已经仿照这个 demo 将 MVP 的思想用到了自己写的一个 demo 上。但是，时间长了，又忘记了，所以打算梳理下。当然，文章肯定不会跟作者的文章一样，得提出自己的思想。并且还对 demo 进行改造优化，使其更加符合MVP的思想。&lt;/p&gt;
&lt;p&gt;　　推荐先看前面两篇文章，再来看本文，这样能更好的理解文章的内容。&lt;/p&gt;
&lt;h2&gt;代码结构简析&lt;/h2&gt;
&lt;p&gt;　　首先我们来看代码的结构图。 从中可以看到有6个文件夹，与 MVP 模式相关的是后面三个文件夹。model 中存放的是与数据相关的类。Picture 是数据 model，其他几个类是负责下载Picture获取数据的。Presenter 中会引入 model 和 view 的引用，以此来控制 model 和 view。View中只有一个 PictureView 类，但是严格说来，应该把 PictureFragment 和 PictureAdapter 也放在文件夹 view 中，但是这样放也是可以的。&lt;img src=&quot;https://images2018.cnblogs.com/blog/916005/201803/916005-20180311163808569-2050228548.png&quot; alt=&quot;&quot; width=&quot;231&quot; height=&quot;302&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;实现逻辑&lt;/h2&gt;
&lt;h3&gt;  总体概要&lt;/h3&gt;
&lt;p&gt;　　这个项目要做的事情很简单，就是从网络下载图片，显示在手机上，点击图片，弹出一个 Toast。&lt;/p&gt;
&lt;h3&gt;  思路分析&lt;/h3&gt;
&lt;p&gt;　　MVP ？在这里 M 不就是图片，所以肯定会有一个 Picture 实体类。图片需要下载，因此，还要建立一个类用来控制，但是最终的调用下载是在 P 中。&lt;/p&gt;
&lt;p&gt;　　那 V ？就是 Fragment 啦，由 recyclerView 和 ProgressBar 构成的。PictureView 是一个接口，用于控制图片的展示等。但是也是在 P 中调用。&lt;/p&gt;
&lt;p&gt;　　最后就是 P 啦，封装了对 M, V 的操作，即 PicturePresenterImpl 这个类。&lt;/p&gt;
&lt;h3&gt;  代码实现&lt;/h3&gt;
&lt;p&gt;　　M的实现（只贴重要的代码）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PictureInteractorImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; PictureInteractor {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String[] pictureNames =&lt;span&gt; {
            &lt;/span&gt;&quot;Rocket in the universe&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;A scene in London&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;Moon over mountains&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;A simple moon&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;Sun and volcano&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;A collection of mountains&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;River between mountains&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;Some pine trees&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;On Small Town&quot;&lt;span&gt;,
            &lt;/span&gt;&quot;Volcanos reflection&quot;&lt;span&gt;
    };


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;  pictureImages[] =&lt;span&gt; {
            R.drawable.cohete_flat,
            R.drawable.london_flat,
            R.drawable.material_flat,
            R.drawable.moon_flat,
            R.drawable.mountain_flat,
            R.drawable.mountain_mo_flat,
            R.drawable.moutain_go_flat,
            R.drawable.pine_flat,
            R.drawable.towers_flat,
            R.drawable.vulcan_flat
    };

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; loadPictures(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; LoaderListener listener) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Handler(Looper.getMainLooper())
                .postDelayed(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                        listener.onFinish(createPictures());
                    }
                }, &lt;/span&gt;2000&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Picture&amp;gt;&lt;span&gt; createPictures() {
        ArrayList&lt;/span&gt;&amp;lt;Picture&amp;gt; pictures = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; pictureNames.length; i++&lt;span&gt;) {
            pictures.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Picture(pictureNames[i], pictureImages[i]));
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pictures;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;大家看上面的代码，只有 loadPictures 是来自于接口的，为啥 createPictures 方法不写在接口里呢？主要是因为写在接口的方法是要在 P 中调用的。如果不需要外部调用，就没必要接口里面了。&lt;/p&gt;

&lt;p&gt;　　V 的实现（只贴重要的代码）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; PictureView {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; showProgressBar();

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; hideProgressBar();

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; showMsg(String msg);

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; showPictures(List&amp;lt;Picture&amp;gt;&lt;span&gt; pictures);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　虽然 View  中只有 PictureView 一个类，但是从这个类可以对 view 要做的事一清二楚。&lt;/p&gt;
&lt;p&gt;　　P 的实现（只贴重要的代码）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PicturePresenterImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; PicturePresenter, LoaderListener {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; PictureView mPictureView;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; PictureInteractor mInteractor;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PicturePresenterImpl(PictureView pictureView) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mPictureView =&lt;span&gt; pictureView;
        mInteractor &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PictureInteractorImpl();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onResume() {
        mPictureView.showProgressBar();
        mInteractor.loadPictures(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onDestroy() {
        mPictureView &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onItemClick(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; pos) {
        mPictureView.showMsg(String.valueOf(pos));
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onFinish(List&amp;lt;Picture&amp;gt;&lt;span&gt; pictures) {
        mPictureView.hideProgressBar();
        mPictureView.showPictures(pictures);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　可以看出来，P 中其实就是对 M，V 的逻辑进行了封装，统一由其来掌控。&lt;/p&gt;
&lt;p&gt;　　最后来讲讲 fragment，内部引入了 P 。主要是由于 P 无法控制生命周期，所以需要借用 fragment 的生命周期来对整个过程进行控制。&lt;/p&gt;
&lt;h2&gt;疑问？&lt;/h2&gt;
&lt;p&gt;　　大家看了上面的demo，不觉得在 fragment 中，即夹杂着 V， 又有 P，这样其实不利于维护，尤其是后期当 view 越来越多的时候，那时候，还要把 view 的初始化等等都写在 fragment 中嘛？所以接下去要对 fragment 内容进行瘦身。那怎么瘦身呢？具体请看下文。&lt;/p&gt;
&lt;h2&gt;改造&lt;/h2&gt;
&lt;p&gt;　　改造后的结构，只在 view 中新建了一个 BasePageView 来处理 view 的初始化和控制逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/916005/201803/916005-20180311232713215-895367961.png&quot; alt=&quot;&quot; width=&quot;176&quot; height=&quot;241&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其代码具体如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BasePageView &lt;span&gt;extends&lt;/span&gt; FrameLayout &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; PictureView {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RecyclerView mRecyclerView;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ProgressBar mProgress;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; PictureAdapter mAdapter;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; PicturePresenter mPresenter;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Context mContext;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 构造函数。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; BasePageView(Context context){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(context, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    };

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BasePageView(Context context, AttributeSet attributeSet) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(context, attributeSet, 0&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BasePageView(Context context, AttributeSet attributeSet, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; defStyleAttr){
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context, attributeSet, defStyleAttr);
        init(context);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 初始化
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(Context context) {
        mContext &lt;/span&gt;=&lt;span&gt; context;
        inflate(mContext, R.layout.base_view_layout, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        mRecyclerView &lt;/span&gt;=&lt;span&gt; (RecyclerView) findViewById(R.id.recycler_view);
        mProgress &lt;/span&gt;=&lt;span&gt; (ProgressBar) findViewById(R.id.progress_bar);
        mRecyclerView.setLayoutManager(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinearLayoutManager(mContext));
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; showProgressBar() {
        mProgress.setVisibility(View.VISIBLE);
        mRecyclerView.setVisibility(View.INVISIBLE);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; hideProgressBar() {
        mProgress.setVisibility(View.INVISIBLE);
        mRecyclerView.setVisibility(View.VISIBLE);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; showMsg(String msg) {
        Toast.makeText(mContext, msg, Toast.LENGTH_LONG).show();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; showPictures(List&amp;lt;Picture&amp;gt;&lt;span&gt; pictures) {
        mAdapter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PictureAdapter(pictures);
        mAdapter.setRecyclerItemClickListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OnRecyclerItemClickListener() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onItemClick(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; pos) {
                mPresenter.onItemClick(pos);
            }
        });
        mRecyclerView.setAdapter(mAdapter);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这样当需要对视图进行更改的时候，只需要更改这个类就可以了，不用在跑到 fragment 中去了。&lt;/p&gt;
&lt;p&gt;于此同时，fragment 也瘦身成功了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PictureFragment &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Fragment{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; PicturePresenter mPresenter;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; PictureFragment newInstance() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PictureFragment();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PictureFragment() {
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        View view &lt;/span&gt;= inflater.inflate(R.layout.fragment_picture, container, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
       BasePageView basePageView &lt;/span&gt;=&lt;span&gt; (BasePageView) view.findViewById(R.id.baseView);
        mPresenter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PicturePresenterImpl(basePageView);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; view;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onResume() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onResume();
        mPresenter.onResume();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onDestroy() {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onDestroy();
        mPresenter.onDestroy();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　改造之后，是不是更好理解了啊。当我们需要对某一部分需要修改的时候，能够轻松定位要修改的地方。&lt;/p&gt;
&lt;p&gt;　　好了，通过改造之后，相信大家对 MVP 的理解也就更加深刻了。&lt;/p&gt;
&lt;p&gt;　　希望这篇文章对大家有所帮助。&lt;/p&gt;
</description>
<pubDate>Sun, 11 Mar 2018 15:49:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huansky/p/8545734.html</dc:identifier>
</item>
<item>
<title>SpringMVC 框架系列之组件概述与配置详解 - compassblog</title>
<link>http://www.cnblogs.com/compassblog/p/8547047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/compassblog/p/8547047.html</guid>
<description>&lt;p&gt;&lt;span&gt;在上一篇文章 &lt;/span&gt;&lt;span&gt;&lt;a title=&quot;SpringMVC 框架系列之初识与入门实例&quot; href=&quot;http://www.cnblogs.com/compassblog/p/8537008.html&quot;&gt;SpringMVC 框架系列之初识与入门实例&lt;/a&gt; &lt;/span&gt;&lt;span&gt;的实例中，我们已经知道，SpringMVC 框架是一个 web 层的框架，本篇文章就详细解释一下 SpringMVC 框架具体文件的配置以及相关组件的作用。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;h1springmvc&quot;&gt;&lt;span&gt;1、SpringMVC 架构详解&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（1）、SpringMVC 框架结构：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201803/1322792-20180311234330539-96266592.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（2）、SpringMVC 框架结构执行流程&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;用户发送请求至前端控制器 DispatcherServlet&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;处理器映射器根据请求 url 找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;DispatcherServlet 通过 HandlerAdapter 处理器适配器调用处理器&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;执行处理器(Controller，也叫后端控制器)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Controller 执行完成返回 ModelAndView&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;HandlerAdapter 将 controller 执行结果 ModelAndView 返回给 DispatcherServlet&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;ViewReslover 解析后返回具体 View&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;DispatcherServlet 对 View 进行渲染视图（即将模型数据填充至视图中）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;DispatcherServlet 响应用户&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h2springmvc&quot;&gt;&lt;span&gt;2、SpringMVC 框架组件概述&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）、DispatcherServlet：前端控制器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户请求到达前端控制器，它就相当于 MVC 模式中的 C 层，DispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）、HandlerMapping：处理器映射器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HandlerMapping 负责根据用户请求 url 找到 Handler 处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，如配置文件方式、实现接口方式、注解方式等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）、Handler：处理器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Handler 是继 DispatcherServlet 前端控制器的后端控制器，在 DispatcherServlet 的控制下 Handler 对具体的用户请求进行处理。由于 Handler 涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发 Handler 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）、HandlAdapter：处理器适配器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）、ViewResolver：视图解析器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View 视图对象，最后对View进行渲染将处理结果通过页面展示给用户。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）、View：视图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SpringMVC 框架提供了很多的 View 视图类型的支持，w而我们开发中最常用的视图是 jsp 。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;h3springmvc&quot;&gt;&lt;span&gt;3、SpringMVC 配置详解&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;springmvc.xml&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）、配置组件扫描器&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;context:component-scan &lt;span class=&quot;hljs-attr&quot;&gt;base-package=&lt;span class=&quot;hljs-string&quot;&gt;&quot;com.springmvc.controller&quot; /&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;（2）、配置处理器映射器&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;bean &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping&quot; /&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;（3）、配置处理器适配器&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;bean &lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter&quot; /&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;（4）、配置注解驱动&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;mvc:annotation-driven /&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;（5）、配置视图解析器&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;bean&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;class=&lt;span class=&quot;hljs-string&quot;&gt;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;最终 jsp 物理地址：前缀 + 逻辑视图名 + 后缀&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注：部分知识源于网络，侵权联删。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;扫描关注微信公众号，了解更多&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322792/201803/1322792-20180311234443461-1163116054.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 11 Mar 2018 15:45:00 +0000</pubDate>
<dc:creator>compassblog</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/compassblog/p/8547047.html</dc:identifier>
</item>
<item>
<title>C#多线程编程（5）--线程安全1 - JAZzzzzzzz</title>
<link>http://www.cnblogs.com/jazzpop/p/8547015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jazzpop/p/8547015.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;当你需要2个线程读写同一个数据时，就需要数据同步。线程同步的办法有：（1）原子操作；（2）锁。原子操作能够保证该操作在CPU内核中不会被“拆分”，锁能够保证只有一个线程访问该数据，其他线程在尝试获得有锁的数据时，会被拒绝，直到当前获得数据的线程将锁释放，其他线程才能够获得数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;为什么要线程同步？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　我们先看一个需要数据同步的例子，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args){
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    var t1 = &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(() =&amp;gt; { &lt;span&gt;if&lt;/span&gt; (flag) Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Flag&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); });
    var t2 = &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(() =&amp;gt; { flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;; });&lt;br/&gt;　　t1.Start();&lt;br/&gt;　　t2.Start();
    Console.ReadLine();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述例子中，t2线程将flag置为true，有可能发生：当t2打算执行flag = true时，t1执行了if(flag)语句，这造成了不可知的情况。此时就需要在t2执行时，若t1想要获取flag的值，要等到flag=true执行完成后，再执行，这就是所谓的“线程同步”，一个线程要等待另一个线程执行到某段代码后，再执行。线程同步能保证程序的执行符合“预想”--若t2没有执行，则flag为false，t2若已执行，则flag=true。线程同步是为了防止t2正在执行flag=true的时候，t1开始执行，此时flag应该是true，因为t2已经开始执行了，但是实际上flag=false，因为t2的flag=true没有执行完。解决的办法就是当t2执行flag=true时，将任何尝试读取flag的线程都阻塞，直到flag=true执行结束后，其他线程再执行。类似下面的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; m_lock =&lt;span&gt; GetSomeLock();&lt;br/&gt;pulick void Go(){&lt;br/&gt;　　var t1 = new Thread(()=&amp;gt;Go1());&lt;br/&gt;　　var t2 = new Thread(()=&amp;gt;Go2());&lt;br/&gt;　　t1.Star();&lt;br/&gt;　　t2.Start();&lt;br/&gt;}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Go1(){
    m_lock.&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flag) 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dosomething;　　&lt;/span&gt;
&lt;span&gt;    Console.WriteLine(flag);&lt;br/&gt;　　 m_lock.Unlock();
}
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Go2(){
    m_lock.&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
    flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    m_lock.Unlock();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在flag=true和if(flag)外面添加m_lock.lock()和m_lock.Unlock()就是为了保证线程同步。但是这样的同步带来的问题就是性能的下降，还有可能造成死锁。摘要中说过，线程同步有2个手段，上面介绍了锁，还有原子操作我没有介绍。在介绍原子操作之前，我介绍下关键字volatile。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;关键字volatile&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　该关键字能够作用在变量前，其意义是对该变量的读写操作都是原子操作，这种特性被称作“易变性”。&lt;/p&gt;
&lt;p&gt;　　编译器在编译过程中，会根据代码的具体情况进行适当“优化”，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Go(){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; value = &lt;span&gt;100&lt;/span&gt; * &lt;span&gt;1&lt;/span&gt; - &lt;span&gt;50&lt;/span&gt; * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; value; i++&lt;span&gt;)
        Console.WriteLine(i);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译器在看到有地方调用该方法，会跳过其中的语句，因为这段语句毫无意义，这当然是好的，编译器弥补了我们的错误。但是有的时候这种优化会造成我们不想要的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; s_stopWorker = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args){
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main:letting worker run for 5s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; t = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(Worker);
    t.Start();
    Thread.Sleep(&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);
    s_stopWorker &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main: waiting for worker to stop.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    t.Join();
}
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Worker(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; o){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (s_stopWorker) x++&lt;span&gt;;
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Worker: stopped when x = {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, x);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该段代码中，主线程阻塞5秒，然后s_stopWorker=true，本意是要中断t线程，让其显示数到的数后返回。但实际上编译器在看到while(s_stopWorker)时，又看到s_stopWorker在Worker方法中没有任何改变，因此该方法中对s_stopWorker的判断只会在最开始判断一次，若s_stopWorker=true，则进入死循环，若是false，则显示Worker stopped when x = 0之后该线程就返回了。若想实际看到运行效果，需要将改短代码放在.cs文件中，利用命令行编译该段代码。利用命令行编译代码要添加环境变量，变量的路径是C:\Windows\Microsoft.NET\Framework\v4.0.30319。然后就可以在命令行中编译该文件，注意要打开/platform:x86，其意义在《CLR via C#》29章中有解释，x86编译器比x64编译器更成熟，优化也更大胆。在命令行中输入 csc /platform:x86  你的cs文件的路径，之后在输入Program.exe（假设你的文件名字叫Program.cs），之后你会看到程序一直卡死在Main: waiting for worker to stop.之后一直没有出现数到的数字。&lt;/p&gt;
&lt;p&gt;　　下面来讨论如何解决这个问题。在System.Threading.Volatile中提供了2个静态方法，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Volatile{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Read(&lt;span&gt;ref&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; location);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Write(&lt;span&gt;ref&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; location,  &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; value);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两个方法能够阻止编译器对读和写进行优化，修改后的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; s_stopWorker = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args){
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main:letting worker run for 5s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; t = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(Worker);
    t.Start();
    Thread.Sleep(&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;防止优化&lt;/span&gt;
    Volatile.Write(&lt;span&gt;ref&lt;/span&gt; s_stopWorker, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Main: waiting for worker to stop.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    t.Join();
    Console.Read();
}
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Worker(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; o){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;防止优化&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (Volatile.Read(&lt;span&gt;ref&lt;/span&gt; s_stopWorker)) x++&lt;span&gt;;
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Worker: stopped when x = {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, x);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在s_stopWorker的读写处，都改用了Volatile类中的Read和Write方法。再次利用命令行编译该代码，会发现运行正常。很多时候我们搞不清到底该什么时候调用Volatile中的读写，什么时候该正常读写，于是C#提供了volatile关键字，该关键字能够保证对该变量的读写都是原子的，并且能够阻止对该方法进行优化。由于为了提高CPU的运行效率，现在的程序都是乱序执行，但是volatile能够保证该关键字之前的代码会在该关键字的变量读写时已经执行完成，该关键字修饰的变量以后的代码一定会在之后执行，而不会因乱序优化而在之前执行。我们去掉Volatile.Write和Read，然后将s_stopWorker前加上volatile关键字，运行上述代码，会发现结果正确。&lt;/p&gt;
&lt;p&gt;　　volatile关键字能够保证变量的线程安全，但是其缺点也是很明显的，将变量的每次读写都变成易变的读写，是对性能的浪费，因为这种情况极少发生。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; m = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
m&lt;/span&gt;=m+m;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;volatile会阻止优化&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通常，将一个变量增大一倍，只需要将该变量左移一位，就可以，但是volatile会阻止该优化。CPU会将m读入一个寄存器，然后读入另一个寄存器，然后在执行add，再将结果写入m。如果m不是int类型，而是更大的类型，则造成更大的浪费，如果在循环中，那真是杯具。&lt;/p&gt;
&lt;p&gt;另外C#不支持将有volatile修饰的变量以引用的形式传入方法，如Int32.TryParse(&quot;123&quot;, m);会得到一个警告，对volatile字段的引用将不被视为volatile。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;变量捕获（闭包）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　第一段代码中，flag变量被lamda表达式包含。程序并没有在主线程中执行，而是在t1和t2中执行，该变量已经脱离了它的作用域，为了保证flag变量能够生效，编译器负责延长flag的生命周期，以保证在t1和t2线程执行时，该变量能够被访问，这就是变量捕获，也叫“闭包”，可以利用IL反编译器查看上述代码的IL指令来验证。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1336022/201803/1336022-20180311201153943-439834566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图可以看到为了保证flag的生命周期编译器将2个lamda表达式（b_0和b_1）和flag用一个类包了起来，这样这3个的生命周期就一致了。这很好，因为不需要我们去关心在t1和t2获取flag值时，flag是否有效，编译器已经帮我们全做了。&lt;/p&gt;
&lt;p&gt;　　本文讲了线程安全的必要性以及线程安全的手段之一：volatile（易变性），还简单介绍了变量捕获。线程安全的内容还没讲完，预计分3-4篇博客来讲线程安全。欢迎小伙伴在评论区与我交流。&lt;/p&gt;
</description>
<pubDate>Sun, 11 Mar 2018 15:35:00 +0000</pubDate>
<dc:creator>JAZzzzzzzz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jazzpop/p/8547015.html</dc:identifier>
</item>
<item>
<title>Delphi基础-数据类型 - 舞动的代码</title>
<link>http://www.cnblogs.com/coder163/p/8546956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coder163/p/8546956.html</guid>
<description>&lt;h5 id=&quot;枚举类型&quot;&gt;枚举类型&lt;/h5&gt;
&lt;p&gt;　　Pascal程序不仅用于数值处理，还更广泛地用于处理非数值的数据。例如，性别、月份、星期几、颜色、单位名、学历、职业等。&lt;br/&gt;​&lt;/p&gt;
&lt;h6 id=&quot;枚举类型的定义&quot;&gt;1. 枚举类型的定义&lt;/h6&gt;
&lt;p&gt;格式:　type 枚举类型标识符=(标识符1,标识符2,…,标识符n)&lt;/p&gt;
&lt;h6 id=&quot;枚举类型特点&quot;&gt;2. 枚举类型特点&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;枚举元素只能是标识符； 定义枚举类型时列出的所有枚举元素构成了这种枚举类型的值域（取值范围）。例如，下列类型定义是合法的：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode pascal&quot;&gt;
&lt;code class=&quot;sourceCode pascal&quot;&gt; &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt;  
  days=(sun,mon,tue,wed,thu,fri,sat);  
  colors=(red,yellow,blue,white,black,green);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 而下列类型定义是错误的:&lt;/p&gt;
&lt;p&gt;`&lt;code&gt;Pascal type colortype=('red','yellow','blue','white'); numbers=(1,3,5,7,9);&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;枚举类型属于顺序类型&lt;br/&gt;根据定义类型时各枚举元素的排列顺序确定它们的序号，且序号从0开始。例如，定义type days=(sun,mon,tue,wed,thu,fri,sat); 则， ord(sun)=0,ord(mon)=1,……，以此类推。枚举类型中的第一个元素无前趋，最后一个元素无后继。pred(sat)=fri; succ(sun)=mon; ord(sat)=6;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;同一个枚举元素不能出现在两个或两个以上的枚举类型定义中。如下列定义是错误的:&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode pascal&quot;&gt;
&lt;code class=&quot;sourceCode pascal&quot;&gt;  &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; color1=(red,yellow,white);  
  color2=(blue,red,black);　
  &lt;span class=&quot;co&quot;&gt;// 因为red属于枚举类型color1和 color2  &lt;/span&gt;
  &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;枚举类型变量只能进行赋值运算和关系运算，不能进行算术运算和逻辑运算.　在枚举元素比较时，实际上是对其序号的比较。&lt;br/&gt;例如定义如下：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode pascal&quot;&gt;
&lt;code class=&quot;sourceCode pascal&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; 
        days=(sun,mon,tue,wed,thu,fri,sat);  
    　　colors=(red,yellow,blue,white,black,green);  
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; 
        color:colors;  
    　　 weekday:days;  
    　&lt;span class=&quot;co&quot;&gt;//则下面语句是合法的:  &lt;/span&gt;
    　weekday:=mon;  
    　if weekday=sun &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'rest'&lt;/span&gt;);  
    　&lt;span class=&quot;co&quot;&gt;//而下面语句是不合法的:  &lt;/span&gt;
        mon:=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;           &lt;span class=&quot;co&quot;&gt;//错把枚举值当成变量名；  &lt;/span&gt;
        weekday:=blue；   &lt;span class=&quot;co&quot;&gt;//枚举值blue不属于枚举变量weekday的值域；  &lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;read&lt;/span&gt;(color);      &lt;span class=&quot;co&quot;&gt;//枚举类型变量 不能用读语句进行赋值；  &lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;write&lt;/span&gt;(weekday); writeln(blue);&lt;span class=&quot;co&quot;&gt;//不能通过写语句输出枚举类型的变量值和枚举值。  &lt;/span&gt;
   
 &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;可以把变量的说明与类型的定义合并在一起，如:&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode pascal&quot;&gt;
&lt;code class=&quot;sourceCode pascal&quot;&gt;  　　var 
  　　    holiday,workday:(sun,mon,tue,wed,thu,fri,sat);  
  　　　   color:(red,yellow,blue,white,black,green); 
 
 &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;code&gt;对枚举数据的输入与输出可通过间接方式进行。输入时，一般可输入一个代码，通过程序进行转换，输出时，也只是打印出与枚举元素相对应的字符串。这在后面的例题中将有使用示例。  &lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;应用实例&quot;&gt;3. 应用实例&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;例1、输入今天是星期几的序号，输出明天是星期几的英文单词（星期天序号为0）。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode pascal&quot;&gt;
&lt;code class=&quot;sourceCode pascal&quot;&gt;  　　type weekday=(sun,mon,tue,wed,thu,fri,sat);  
  　　 &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i : &lt;span class=&quot;dt&quot;&gt;integer&lt;/span&gt;;  
  　　　　 today,tomorrow : weekday;  
  　　&lt;span class=&quot;kw&quot;&gt;begin&lt;/span&gt;  
  　　　writeln(&lt;span class=&quot;st&quot;&gt;'What date is it'&lt;/span&gt;); readln(i);  
  　　　&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; i &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;                              &lt;span class=&quot;co&quot;&gt;{ 根据输入转换成枚举型 }&lt;/span&gt;  
  　　　　&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:today:=sun;  
  　　　　&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:today:=mon;  
  　　　　&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;:today:=tue;  
  　　　　&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;:today:=wed;  
  　　　　&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;:today:=thu;  
  　　　　&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;:today:=fri;  
  　　　　&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;:today:=sat;  
  　　　&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;;  
  　　　if (today=sat) &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt; tomorrow:=sun  &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; tomorrow:=succ(today);  
  　　  &lt;span class=&quot;kw&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'The tomorrow is '&lt;/span&gt;);      
  　　　&lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; tomorrow &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;  
  　　　　sun:writeln(&lt;span class=&quot;st&quot;&gt;'sunday'&lt;/span&gt;);  
  　　　　mon:writeln(&lt;span class=&quot;st&quot;&gt;'monday'&lt;/span&gt;);  
  　　　　tue:writeln(&lt;span class=&quot;st&quot;&gt;'tuesday'&lt;/span&gt;);  
  　　　　wed:writeln(&lt;span class=&quot;st&quot;&gt;'wednesay'&lt;/span&gt;);  
  　　　　thu:writeln(&lt;span class=&quot;st&quot;&gt;'thursday'&lt;/span&gt;);  
  　　　　fri:writeln(&lt;span class=&quot;st&quot;&gt;'friday'&lt;/span&gt;);  
  　　　　sat:writeln(&lt;span class=&quot;st&quot;&gt;'saturday'&lt;/span&gt;);  
  　　　&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;;  
  　　&lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;.
 &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS: 枚举类型是一种有序类型，所以枚举类型的变量可以作为循环变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;子界类型&quot;&gt;子界类型&lt;/h5&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;如果我们定义一个变量为integer型，那么它的取值范围一般为-32768～32767。而事实上，每个程序中所用的变量的值都有一个确定的范围。 例如，人的年龄一般为1到120岁，一年中的月数为1到12月，一月中的天数为1到31天等等。&lt;br/&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果能在程序中对所用的变量的值域作具体规定，就便于检查出那些不合法的数据，这就能更好地保证程序运行的正确性且在一定程度上节省内存空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;子界类型能很好解决上面的问题。此外，在数组的定义中，常用到子界类型，以规定数组下标的范围。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;定义格式&quot;&gt;1. 定义格式&lt;/h6&gt;
&lt;p&gt;type 子界类型标识符=常量1..常量2&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 常量1称为子界的下界，常量2称为子界的上界；  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意事项：&lt;br/&gt;​&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;下界和上界必须是同一顺序类型（该类型称为子界类型的基类型），且上界的序号必须大于下界的序号。&lt;br/&gt;例如　type age=1..100;&lt;br/&gt;　　　 letter='a' ..'z';&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;可以直接在变量说明中定义子界类型。如：&lt;br/&gt;type letter='a'..' z ';&lt;br/&gt;　　　　　var ch1,ch2:letter;&lt;br/&gt;　　可以合并成:&lt;br/&gt;　　 var ch1,ch2:'a'..'d';&lt;/li&gt;
&lt;/ol&gt;&lt;h6 id=&quot;运算规则&quot;&gt;2. 运算规则&lt;/h6&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;凡可使用基类型的运算规则同样适用该类型的子界类型。&lt;br/&gt;例如，可以使用整型变量的地方，也可以使用以整型为基类型的子界类型数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;对基类型的运算规则同样适用于该类型的子界类型。&lt;br/&gt;例如，div，mod要求参加运算的数据为整, 因而也可以为整型的任何子界类型数据。&lt;br/&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;基类型相同的不同子界类型数据可以进行混合运算。&lt;br/&gt;例如：设有如下说明：&lt;br/&gt;　　var x:1..100;&lt;br/&gt;　　　　 y:1..500;&lt;br/&gt;　　　　 z:1..1000;&lt;br/&gt;　　　 a:integer;&lt;br/&gt;　　则下列语句是合法的： a:=Sqr(x)+y+z; z:=x+y&lt;br/&gt;　　下列语句: y:=x+z+a; 当x+y+a的值在1～500范围内时是合法的，否则会出错。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;应用举例&quot;&gt;3. 应用举例&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;例1、使用子界型情况语句，当输入月、日、年(10 30 1986)，输出30 Oct 1986。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode pascal&quot;&gt;
&lt;code class=&quot;sourceCode pascal&quot;&gt;  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt;
    month: &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;..&lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;;
    day: &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;..&lt;span class=&quot;dv&quot;&gt;31&lt;/span&gt;;
    year: &lt;span class=&quot;dv&quot;&gt;1900&lt;/span&gt;..&lt;span class=&quot;dv&quot;&gt;2003&lt;/span&gt;;

  &lt;span class=&quot;kw&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Enter date(mm dd yy):'&lt;/span&gt;);
    readln(month, day, year);
    &lt;span class=&quot;kw&quot;&gt;write&lt;/span&gt;(day);
    &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; month &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
      &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:
        &lt;span class=&quot;kw&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Jan'&lt;/span&gt;);
      &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;:
        &lt;span class=&quot;kw&quot;&gt;Write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Feb'&lt;/span&gt;);
      &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;:
        &lt;span class=&quot;kw&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Mar'&lt;/span&gt;);
      &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;:
        &lt;span class=&quot;kw&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Apr'&lt;/span&gt;);
      &lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;:
        &lt;span class=&quot;kw&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'May'&lt;/span&gt;);
      &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;:
        &lt;span class=&quot;kw&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Jun'&lt;/span&gt;);
      &lt;span class=&quot;dv&quot;&gt;7&lt;/span&gt;:
        &lt;span class=&quot;kw&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Jul'&lt;/span&gt;);
      &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;:
        &lt;span class=&quot;kw&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Aug'&lt;/span&gt;);
      &lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;:
        &lt;span class=&quot;kw&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Sep'&lt;/span&gt;);
      &lt;span class=&quot;dv&quot;&gt;10&lt;/span&gt;:
        &lt;span class=&quot;kw&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Oct'&lt;/span&gt;);
      &lt;span class=&quot;dv&quot;&gt;11&lt;/span&gt;:
        &lt;span class=&quot;kw&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Nov'&lt;/span&gt;);
      &lt;span class=&quot;dv&quot;&gt;12&lt;/span&gt;:
        &lt;span class=&quot;kw&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Dec'&lt;/span&gt;);
    &lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;;
 &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;例2、将一个四位的十六进制数转换成十进制数。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode pascal&quot;&gt;
&lt;code class=&quot;sourceCode pascal&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt;
      ch: &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;;
      n: &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;..&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;;
      d1, d2, d3, d4, t: &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;dv&quot;&gt;15&lt;/span&gt;;
      s: &lt;span class=&quot;dt&quot;&gt;real&lt;/span&gt;;

    &lt;span class=&quot;kw&quot;&gt;begin&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;Write&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'The hex number is '&lt;/span&gt;);
      &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; n := &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;begin&lt;/span&gt;                    &lt;span class=&quot;co&quot;&gt;{ 把四位的十六进制数分四次作为字符读入 }&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;Read&lt;/span&gt;(ch);
        &lt;span class=&quot;kw&quot;&gt;write&lt;/span&gt;(ch);   &lt;span class=&quot;co&quot;&gt;{ 分别转换为十进制的数d1,d2,d3,d4, }&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ch &amp;gt;= &lt;span class=&quot;st&quot;&gt;'0'&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;and&lt;/span&gt; (ch &amp;lt;= &lt;span class=&quot;st&quot;&gt;'9'&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt;
          t := ord(ch) - &lt;span class=&quot;dv&quot;&gt;48&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ch &amp;gt;= &lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;and&lt;/span&gt; (ch &amp;lt;= &lt;span class=&quot;st&quot;&gt;'z'&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt;
          t := ord(ch) - &lt;span class=&quot;dv&quot;&gt;87&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ch &amp;gt;= &lt;span class=&quot;st&quot;&gt;'A'&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;and&lt;/span&gt; (ch &amp;lt;= &lt;span class=&quot;st&quot;&gt;'Z'&lt;/span&gt;) &lt;span class=&quot;kw&quot;&gt;then&lt;/span&gt;
          t := ord(ch) - &lt;span class=&quot;dv&quot;&gt;55&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; n &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt;
          &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:
            di := t;
          &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;:
            d2 := t;
          &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;:
            d3 := t;
          &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;:
            d4 := t;
        &lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;;
      s := d1 * &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt; * &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt; * &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt; + d2 * &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt; * &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt; + d3 * &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt; + d4;
      writeln(&lt;span class=&quot;st&quot;&gt;'dec:'&lt;/span&gt;, s)
    &lt;span class=&quot;kw&quot;&gt;end&lt;/span&gt;.
 &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&quot;集合类型&quot;&gt;集合类型&lt;/h5&gt;
&lt;p&gt;集合是由具有某些共同特征的元素构成的一个整体。在pascal中，一个集合是由具有同一有序类型的一组数据元素所组成，这一有序类型称为该集合的基类型。。&lt;/p&gt;
&lt;h6 id=&quot;集合类型的定义和变量的说明&quot;&gt;1. 集合类型的定义和变量的说明&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;集合类型的一般形式为： set of 基类型;&lt;/li&gt;
&lt;li&gt;基类型可以是任意顺序类型, 而不能是实型或其它构造类型。同时，基类型的数据的序号不得超过255。例如下列说明是合法的:&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode pascal&quot;&gt;
&lt;code class=&quot;sourceCode pascal&quot;&gt;  &lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt;
    numbers = &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;..&lt;span class=&quot;dv&quot;&gt;9&lt;/span&gt;;
    ch = &lt;span class=&quot;kw&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;;
    day = (sun, mon, tue, wed, thu, fri, sat);
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt;
    s: numbers;
    c: ch;
    weekday: day;
 
 &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;可以将类型说明与变量说明合并在一起，如:&lt;br/&gt;```pascal&lt;br/&gt;var s:set of 0..9; { 子界型 }&lt;br/&gt;c:set of char;&lt;br/&gt;weekday: (sun,mon,tue,wed,thu,fri,sat); { 枚举型 }&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;```&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ps 注意：集合的元素个数不超过256个，因此 var s:set of integer; 是错误的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;集合的值&quot;&gt;2. 集合的值&lt;/h6&gt;
&lt;ol readability=&quot;11.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;集合的值放在一对方括号中，中间各元素之间用逗号隔开。如：[1,2,5] 和 ['a','e','i'] 都是集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在集合中可以没有任何元素，这样的集合称为空集。[] 空集&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;在集合中，如果元素的值是连续的，则可用子界型的表示方法表示。例如：　　&lt;br/&gt;［1,2,3,4,5, 10,15］　可以表示成： ［1..5,10,15］&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;集合的值与方括号内元素出现的次序无关。例如［1,5,8 ］和［5,1,8］的值相等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;在集合中同一元素的重复出现对集合的值没有影响。例如，［1,8,5,1,8］与［1,5,8］的值相等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;每个元素可用基类型所允许的表达式来表示。如 ［1,1+2,4］、［succ(ch)］&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h6 id=&quot;集合的运算&quot;&gt;3. 集合的运算&lt;/h6&gt;
&lt;p&gt;集合类型变量不能进行算术运算，集合是无序的，不能使用ord、pred、succ等函数。&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;赋值运算:只能通过赋值语句给集合变量赋值，不能通过读语句赋值，也不能通过写语句直接输出集合变量的值。如：&lt;br/&gt;集合变量赋值: c:=['2']; i:=[5]; w:=[];&lt;br/&gt;集合变量赋子界值: c:=['a'..'z']; i:=[1..7];&lt;br/&gt;集合变量赋枚举值: c:=['a','b','d','m']; i:=[2,4,6,8,10];&lt;br/&gt;函数赋值操作：&lt;br/&gt;添加一个集合元素 Include(s, 1);&lt;br/&gt;删除一个集合元素 Exclude(s, 1);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;集合的并、交、差运算&lt;br/&gt;可以对集合进行并(＋)、交(＊)、差 (－)三种运算，每种运算只有一个运算符、两个运算对象，运算结果仍为集合。注意它们与算术运算的区别。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;并运算 （关系代数运算符∪）&lt;br/&gt;A，B为两个集合，由集合A中的元素加上集合B中的与A不重复的所有元素组成的集合，称为集合A和B的并。即A+B，如：&lt;br/&gt;[X，Y，Z]+[X] 为 [X，Y，Z] { 两个集合中不重复的所有元素 }&lt;br/&gt;[1]+[4] 为[1，4]&lt;/li&gt;
&lt;li&gt;交运算 （关系代数运算符∩）&lt;br/&gt;A，B为两个集合，由既属于集合A中的元素又属于集合B中的所有元素组成的集合，称为集合A和B的交。即A&lt;em&gt;B，如：&lt;br/&gt;[X，Y，Z]&lt;/em&gt;[X] 为 [X] { 两个集合中的相同元素 }&lt;br/&gt;[X，Y，Z]*[M] 为 []&lt;/li&gt;
&lt;li&gt;差运算 （关系代数运算符-）&lt;br/&gt;A，B为两个集合，由集合A中的元素除去集合B中与A相同的元素组成的集合，称为集合A和B的差。即AB，如：&lt;br/&gt;[X，Y，Z]-[X] 为 [Y，Z ] { 在集合A中又不在集合B中的所有元素 }&lt;br/&gt;[X，Y，Z]-[M] 为 [X，Y，Z]&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;集合的关系运算： 运算结果为布尔值&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;关系运算符：= 相等、 &amp;lt;&amp;gt; 不相等 &amp;gt;= 包含，表示前者蕴含后者，相当于集合论中的 &amp;lt;= 包含于，表示前者蕴含于后者，相当于集合论中的 。&lt;br/&gt;例如：[a,b,c]=[b,c,a] 为true，元素个数相同，内容相同，不管排列顺序如何。&lt;br/&gt;[a,b,c]&amp;gt;=[a] 为true；&lt;br/&gt;[a,b]&amp;lt;=[a,b,c] 为true。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;in运算：in的右边为集合，左边为与集合基类型相同的表达式，为布尔值。in测试一个元素是否在集合中。相当于集合论中的∈。它们都是二目运算，且前４个运算符的运算对象都是相容　　的集合类型。例如：a in［b,c］ 为false。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;设集合a:=[1..10]； x 为integer，如x在集合a中即删除a中的元素x，否则把元素x添加到集合a中。程序段如下：&lt;br/&gt;if x in a then a:=a-[x] else a:=a+[x]&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 11 Mar 2018 15:19:00 +0000</pubDate>
<dc:creator>舞动的代码</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coder163/p/8546956.html</dc:identifier>
</item>
<item>
<title>RLS自适应滤波器中用矩阵求逆引理来避免求逆运算 - 爱酷媒</title>
<link>http://www.cnblogs.com/icoolmedia/p/matrix_inverse_lemma.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/icoolmedia/p/matrix_inverse_lemma.html</guid>
<description>&lt;p&gt;　　在RLS自适应滤波器的实现过程中，难免不涉及矩阵的求逆运算。而求逆操作双是非常耗时的，一个很自然的想法就是尽可能的避免直接对矩阵进行求逆运算。那么，在RLS自适应滤波器的实现中，有没有一种方法能避免直接求逆运算呢？答案当然是用的：使用矩阵求逆引理来避免对矩阵进行直接求逆。&lt;/p&gt;
&lt;p&gt;　　这里先对矩阵求逆引理做下介绍，也叫做&lt;strong&gt;Woodbury&lt;/strong&gt;矩阵恒等式（或者称做Sherman–Morrison formula，这里统一称矩阵求逆引理）在线性代数中：&lt;/p&gt;
&lt;p&gt;\[{\left( {A + UCV} \right)^{ - 1}} = {A^{ - 1}} - {A^{ - 1}}U{\left( {{C^{ - 1}} + V{A^{ - 1}}U} \right)^{ - 1}}V{A^{ - 1}}\]&lt;/p&gt;
&lt;p&gt;其中，&lt;strong&gt;A&lt;/strong&gt;、&lt;strong&gt;C&lt;/strong&gt;必须是可逆方阵，&lt;strong&gt;U&lt;/strong&gt;、&lt;strong&gt;V&lt;/strong&gt;可以是方阵也可以不是方阵。先不忙着记公式，这个不是最重要的，首先要弄明白的是，矩阵求逆引理的写成这个样子，它要解决的是什么样的问题，其思想是什么？&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;矩阵求逆引理要解决的问题是：已知一个高维矩阵A的逆矩阵，当A矩阵产生了一个非常小的变化（维数远低于A或者低于A）时，能不能根据已知的A的逆矩阵，求产生微小变化后的矩阵的逆。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　现在我们知道当然是可以的，这里的微小变化，指的就是恒等式中的矩阵UCV。&lt;/p&gt;
&lt;p&gt;　　知道了矩阵求逆引理解决的是什么样的问题，主要思想后，感觉还是有点不得足，最好能证明一下，好让自己有个“底”，同时满足下好奇心。知其然同时又知其所以然，有什么不好！这里只对其中一种证明方法做下详细的介绍，以方便理解，考虑以下方程组：&lt;/p&gt;
&lt;p&gt;\[\left\{ {\begin{array}{*{20}{c}}&lt;br/&gt;{AX + UY = I} \\&lt;br/&gt;{VX - {C^{ - 1}}Y = 0} \\&lt;br/&gt;\end{array}} \right.\]&lt;/p&gt;
&lt;p&gt;及其矩阵形式&lt;/p&gt;
&lt;p&gt;\[\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;A &amp;amp; U \\&lt;br/&gt;V &amp;amp; { - {C^{ - 1}}} \\&lt;br/&gt;\end{array}} \right]\left[ {\begin{array}{*{20}{c}}&lt;br/&gt;X \\&lt;br/&gt;Y \\&lt;br/&gt;\end{array}} \right] = \left[ {\begin{array}{*{20}{c}}&lt;br/&gt;I \\&lt;br/&gt;0 \\&lt;br/&gt;\end{array}} \right]\]&lt;/p&gt;
&lt;p&gt;根据第2个方程可知：$Y = CVX$，代入第1个方程得到$X = {A^{ - 1}}(I - UY)$，再将X的表达式代回第二个方程，得到&lt;/p&gt;
&lt;p&gt;\[{C^{ - 1}}Y = V{A^{ - 1}}(I - UY) = V{A^{ - 1}} - V{A^{ - 1}}UY\]&lt;/p&gt;
&lt;p&gt;将$V{A^{ - 1}}$与${C^{ - 1}}Y$交换等式两边位置&lt;/p&gt;
&lt;p&gt;\[V{A^{ - 1}} = {C^{ - 1}}Y + V{A^{ - 1}}UY = \left( {{C^{ - 1}} + V{A^{ - 1}}U} \right)Y\]&lt;/p&gt;
&lt;p&gt;可得到Y的表达式$Y = {\left( {{C^{ - 1}} + V{A^{ - 1}}U} \right)^{ - 1}}V{A^{ - 1}}$，这里将Y再次第1个方程$AX + UY = I$，得到&lt;/p&gt;
&lt;p&gt;\[\begin{array}{l}&lt;br/&gt;AX + U{\left( {{C^{ - 1}} + V{A^{ - 1}}U} \right)^{ - 1}}V{A^{ - 1}} = I \\&lt;br/&gt;AX = I - U{\left( {{C^{ - 1}} + V{A^{ - 1}}U} \right)^{ - 1}}V{A^{ - 1}} \\&lt;br/&gt;X = {A^{ - 1}}\left[ {I - U{{\left( {{C^{ - 1}} + V{A^{ - 1}}U} \right)}^{ - 1}}V{A^{ - 1}}} \right] \\&lt;br/&gt;X = {A^{ - 1}} - {A^{ - 1}}U{\left( {{C^{ - 1}} + V{A^{ - 1}}U} \right)^{ - 1}}V{A^{ - 1}} \\&lt;br/&gt;\end{array}\]&lt;/p&gt;
&lt;p&gt;　　关于其它证明部分，建议可以参考&lt;a href=&quot;https://en.wikipedia.org/wiki/Woodbury_matrix_identity&quot; target=&quot;_blank&quot;&gt;wiki中对Woodbury矩阵恒等式的介绍&lt;/a&gt;，里面有好几种不同的证明方法（直接证明、代数证明、矩阵分块推导、LDU分解推导），写的都非常好，建议喜欢追根究底的朋友认真看下。&lt;/p&gt;
&lt;p&gt;　　另外，矩阵求逆引理更通用的是二项式反转定理（Binomial inverse theorem），很多的变种都可以视为二项式反转定理的特殊情况，这些变种icoolmedia还没有整理完毕，先不一一说明了。&lt;/p&gt;

&lt;p&gt;　　下面就用矩阵求逆引理来解决RLS滤波器中的求逆问题，这里假定读者有最小二乘法的基础，首先给出更新滤波器输入向量相关矩阵的公式和矩阵求逆引理的表达式（下面的推导过程来自于Simon Haykin《自适应滤波器原理》第10章的学习）。&lt;/p&gt;
&lt;p&gt;\[{\bf{\Phi }}(n) = \lambda {\bf{\Phi }}(n - 1) + {\bf{u}}(n){{\bf{u}}^{\bf{H}}}(n)\]&lt;/p&gt;
&lt;p&gt;\[{{\bf{A}}^{ - 1}} = {\bf{B}} - {\bf{BC}}{\left( {{\bf{D}} + {{\bf{C}}^{\bf{H}}}{\bf{BC}}} \right)^{ - 1}}{{\bf{C}}^{\bf{H}}}{\bf{B}}\]&lt;/p&gt;
&lt;p&gt;　　可以看到，上面的矩阵求逆引理与本文开始里介绍的不同，这也是一个求逆引理的变种。不多做介绍，先记下来就好，后面另在博客中详述吧。如果设：${\bf{A}} = \Phi (n)$，${{\bf{B}}^{ - 1}} = \lambda \Phi (n - 1)$，${\bf{C}} = {\bf{u}}(n)$，${\bf{D}} = 1$。对波器输入向量相关矩阵迭代更新公式应用矩阵求逆引理公式，可得&lt;/p&gt;
&lt;p&gt;\[{{\bf{\Phi }}^{ - 1}}(n) = {\lambda ^{ - 1}}{{\bf{\Phi }}^{ - 1}}(n - 1) - \frac{{{\lambda ^{ - 2}}{{\bf{\Phi }}^{ - 1}}(n - 1){\bf{u}}(n){{\bf{u}}^{\bf{H}}}(n){{\bf{\Phi }}^{ - 1}}(n - 1)}}{{1 + {\lambda ^{ - 1}}{{\bf{u}}^{\bf{H}}}(n){{\bf{\Phi }}^{ - 1}}(n - 1){\bf{u}}(n)}}\]&lt;/p&gt;
&lt;p&gt;　　如果设&lt;/p&gt;
&lt;p&gt;\[{\bf{P}}(n) = {{\bf{\Phi }}^{ - 1}}(n)\]&lt;/p&gt;
&lt;p&gt;\[{\bf{k}}(n) = \frac{{{\lambda ^{ - 1}}{\bf{P}}(n){\bf{u}}(n)}}{{1 + {\lambda ^{ - 1}}{{\bf{u}}^{\bf{H}}}(n){{\bf{\Phi }}^{ - 1}}(n - 1){\bf{u}}(n)}}\]&lt;/p&gt;
&lt;p&gt;　　这里对增益&lt;strong&gt;k&lt;/strong&gt;(n)做如下变换，得到其简化形式：&lt;/p&gt;
&lt;p&gt;\[\begin{array}{l}&lt;br/&gt;{\bf{k}}(n) = {\lambda ^{ - 1}}{\bf{P}}(n - 1){\bf{u}}(n) - {\lambda ^{ - 1}}{\bf{k}}(n){{\bf{u}}^{\bf{H}}}(n){\bf{P}}(n - 1){\bf{u}}(n) \\&lt;br/&gt;= \left[ {{\lambda ^{ - 1}}{\bf{P}}(n - 1) - {\lambda ^{ - 1}}{\bf{k}}(n){{\bf{u}}^{\bf{H}}}(n){\bf{P}}(n - 1)} \right]{\bf{u}}(n) \\&lt;br/&gt;= {\bf{P}}(n){\bf{u}}(n) \\&lt;br/&gt;\end{array}\]&lt;/p&gt;
&lt;p&gt; 　　或者也可以表示为：${\bf{k}}(n) = {\Phi ^{ - 1}}(n - 1){\bf{u}}(n)$。由线性最小二乘估计可知，滤波器的系数估计表示为：${{\bf{\hat w}}(n) = {\Phi ^{ - 1}}(n){\bf{z}}(n)}$，把增益&lt;strong&gt;k&lt;/strong&gt;(n)代入，得到&lt;/p&gt;
&lt;p&gt;\[\begin{array}{l}&lt;br/&gt;{\bf{\hat w}}(n) = {\Phi ^{ - 1}}(n){\bf{z}}(n) = {\bf{P}}(n){\bf{z}}(n) = \lambda {\bf{P}}(n){\bf{z}}(n - 1) + {\bf{P}}(n){\bf{u}}(n){d^*}(n) \\&lt;br/&gt;= \lambda \left[ {{\lambda ^{ - 1}}{\bf{P}}(n - 1) - {\lambda ^{ - 1}}{\bf{k}}(n){{\bf{u}}^{\bf{H}}}(n){\bf{P}}(n - 1)} \right]{\bf{z}}(n - 1) + {\bf{P}}(n){\bf{u}}(n){d^*}(n) \\&lt;br/&gt;= {\bf{P}}(n - 1){\bf{z}}(n - 1) - {\bf{k}}(n){{\bf{u}}^{\bf{H}}}(n){\bf{P}}(n - 1){\bf{z}}(n - 1) + {\bf{P}}(n){\bf{u}}(n){d^*}(n) \\&lt;br/&gt;= {\Phi ^{ - 1}}(n - 1){\bf{z}}(n - 1) - {\bf{k}}(n){{\bf{u}}^{\bf{H}}}(n){\Phi ^{ - 1}}(n - 1){\bf{z}}(n - 1) + {\bf{P}}(n){\bf{u}}(n){d^*}(n) \\&lt;br/&gt;= {\bf{\hat w}}(n - 1) - {\bf{k}}(n){{\bf{u}}^{\bf{H}}}(n){\bf{\hat w}}(n - 1) + {\bf{P}}(n){\bf{u}}(n){d^*}(n) \\&lt;br/&gt;= {\bf{\hat w}}(n - 1) + \left[ {{\bf{k}}(n){d^*}(n) - {\bf{k}}(n){{\bf{u}}^{\bf{H}}}(n){\bf{\hat w}}(n - 1)} \right] \\&lt;br/&gt;= {\bf{\hat w}}(n - 1) + {\bf{k}}(n)\left[ {{d^*}(n) - {{\bf{u}}^{\bf{H}}}(n){\bf{\hat w}}(n - 1)} \right] \\&lt;br/&gt;= {\bf{\hat w}}(n - 1) + {\bf{k}}(n)\xi (n) \\&lt;br/&gt;\end{array}\]&lt;/p&gt;
&lt;p&gt; 　　这就是递归最小二乘（RLS）滤波器的系数更新公式，可以看到，这个过程，并没有对输入向量相关矩阵进行直接求逆，避免了直接求逆运算带来的复杂性。还有最后一个问题没有解决。&lt;strong&gt;P&lt;/strong&gt;的初始化问题，这里简单给出来：${\bf{\hat w}}(n) = 0$，${\bf{P}}(0) = {\delta ^{ - 1}}{\bf{I}}$ 。这里$\delta $是正则化参数，是为了在求解反问题或者最优化问题时解决不适定性，增加抗绕动能力时引入的，这里不做详细介绍。下面总结下递归最小二乘法的实现步骤。&lt;/p&gt;
&lt;p&gt;\[{\bf{k}}(n) = \frac{{{\lambda ^{ - 1}}{\bf{P}}(n){\bf{u}}(n)}}{{1 + {\lambda ^{ - 1}}{{\bf{u}}^{\bf{H}}}(n){\Phi ^{ - 1}}(n - 1){\bf{u}}(n)}}\]&lt;/p&gt;
&lt;p&gt;\[\begin{array}{l}&lt;br/&gt;\xi (n) = {d^*}(n) - {{\bf{u}}^{\bf{H}}}(n){\bf{\hat w}}(n - 1) \\&lt;br/&gt;{\bf{\hat w}}(n) = {\bf{\hat w}}(n - 1) + {\bf{k}}(n)\xi (n) \\&lt;br/&gt;{\bf{P}}(n) = {\lambda ^{ - 1}}{\bf{P}}(n - 1) - {\lambda ^{ - 1}}{\bf{k}}(n){{\bf{u}}^{\bf{H}}}(n){\bf{P}}(n - 1) \\&lt;br/&gt;\end{array}\]&lt;/p&gt;
&lt;p&gt;　　终于推导完毕，以上步骤的实现代码及工程可以在博文下面的QQ交流群的群文件中找到（TestRLS_using the matrix inversion lemma.rar）。本人水平有限，如以上证明和推导过程及代码如有错误之误，还请大家及时给予批评指正。&lt;/p&gt;
</description>
<pubDate>Sun, 11 Mar 2018 15:03:00 +0000</pubDate>
<dc:creator>爱酷媒</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/icoolmedia/p/matrix_inverse_lemma.html</dc:identifier>
</item>
<item>
<title>Struts2【OGNL、valueStack】就是这么简单 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/8546447.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/8546447.html</guid>
<description>&lt;p&gt;OGNL是Object Graphic Navigation Language 是操作对象属性的开源表达式。 Struts2框架使用OGNL作为默认的表达式语言。&lt;/p&gt;

&lt;p&gt;在学习JSP的时候，我们已经学习过了EL表达式。EL表达式用起来也十分简单...我们在Struts2框架中也是可以使用EL表达式的...那么OGNL表达式好在哪里呢？？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持对象方法调用，如xxx.doSomeSpecial()&lt;/li&gt;
&lt;li&gt;支持类静态的方法调用和值访问，表达式的格式【例如：&lt;a&gt;&quot;@@floor&lt;/a&gt;(10.9)&quot;就是调用Math.floor()的方法了】&lt;/li&gt;
&lt;li&gt;支持赋值操作和表达式串联【这个其实EL表达式也能做】&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;访问OGNL上下文（OGNL context）和ActionContext&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;操作集合对象【EL只能遍历集合，OGNL可以创建集合】&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OGNL是Struts2的默认表达式语言，OGNL是配搭Strut2的标签使用的..我们&lt;strong&gt;学习了OGNL表达式，就可以更好地理解Struts2标签的运行以及Struts2内部的存储结构.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在讲解OGNL表达式之前，我们先来看看valueStack对象...&lt;strong&gt;valueStack是Struts2数据存储的核心&lt;/strong&gt;...我们&lt;strong&gt;首先要知道数据是怎么存的，存到哪里，然后才讲解OGNL表达式是怎么取出数据的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;valueStack也被称作值栈对象..&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当用户访问Action，都会&lt;strong&gt;创建一个Action对象，ActionContext对象、valueStack对象&lt;/strong&gt;..&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Struts2把Action对象放进valueStack对象之中&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将valueStack放进request域中，传入JSP页面&lt;/strong&gt;(key: struts.valueStack)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JSP页面就可以使用OGNL表达式获取值栈中的数据了&lt;/strong&gt;！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170504132149121?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;获取valuestack对象&quot;&gt;获取valueStack对象&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;在Action中我们可以手动获取值栈对象，&lt;strong&gt;有两种方式获取&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;//获取值栈对象的2种方式&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getVs&lt;/span&gt;() {
        &lt;span class=&quot;co&quot;&gt;// 获取值栈对象，方式1：&lt;/span&gt;
        HttpServletRequest request = ServletActionContext.&lt;span class=&quot;fu&quot;&gt;getRequest&lt;/span&gt;();
        ValueStack vs1 = (ValueStack) request.&lt;span class=&quot;fu&quot;&gt;getAttribute&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;struts.valueStack&quot;&lt;/span&gt;);
        
        &lt;span class=&quot;co&quot;&gt;// 获取值栈对象，方式2： &lt;/span&gt;
        ActionContext ac = ActionContext.&lt;span class=&quot;fu&quot;&gt;getContext&lt;/span&gt;();
        ValueStack vs2 = ac.&lt;span class=&quot;fu&quot;&gt;getValueStack&lt;/span&gt;();
        
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(vs1 == vs2);&lt;span class=&quot;co&quot;&gt;//true&lt;/span&gt;
    }
    &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;valuestack内部存储结构&quot;&gt;valueStack内部存储结构&lt;/h2&gt;
&lt;p&gt;上面已经说了，用户访问Action时，会创建Action对象，valueStack对象。&lt;strong&gt;Struts2内部会将Action对象存到valueStack对象之中&lt;/strong&gt;...那么valueStack的存储结构是什么样的呢？？？我们来看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170504133033663?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;compoundroot&quot;&gt;&lt;strong&gt;CompoundRoot&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Action对象和Action的成员属性等值都是存到CompoundRoot下的&lt;/strong&gt;.该CompoundRoot继承着ArrayList，因此它是List结构的&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; CompoundRoot &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; ArrayList {}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h3 id=&quot;ognlcontext&quot;&gt;&lt;strong&gt;OgnlContext&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;OgnlContext对象存储着相关的域对象：request、response、session等数据,实现Map集合，是Map结构&lt;/strong&gt;..&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了让request、response等域对象可以存储多个值，值也是使用Map结构&lt;/strong&gt;...&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; OgnlContext &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Map {}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h3 id=&quot;小总结&quot;&gt;&lt;strong&gt;小总结&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170504133928989?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CompoundRoot保存着这样的数据：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Action对象以及Action对象的成员属性数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用ValueStack对象.push()进去的数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;使用ValueStack对象.set()进去的数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其他代理对象的数据&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OgnlContext保存着这样的数据：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;维护了CompoundRoot中所有的数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;request、response等域对象所有的数据&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;Struts2会将valueStack对象封装进request对象域中，传入JSP页面。&lt;/li&gt;
&lt;li&gt;valueStack存储着OgnlContext对象。&lt;/li&gt;
&lt;li&gt;OgnlContext对象维护了CompoundRoot对象的数据&lt;/li&gt;
&lt;li&gt;CompoundRoot存储着Action等数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是说&lt;strong&gt;通过OgnlContext对象可以获取大部分我们需要的数据了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么OGNL表达式是怎么取出OgnlContext对象中数据的呢？？下面我们通过&lt;strong&gt;硬编码的方式来讲解&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 1. Ognl表达式语言语言取值，取非根元素的值，必须用#号&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@throws Exception&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;testOgnl&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;co&quot;&gt;// 创建一个Ognl上下文对象&lt;/span&gt;
        OgnlContext context = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;OgnlContext&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;// 放入数据&lt;/span&gt;
        User user = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;User&lt;/span&gt;();
        user.&lt;span class=&quot;fu&quot;&gt;setId&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;);
        user.&lt;span class=&quot;fu&quot;&gt;setName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Jack&quot;&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;// 【往非根元素放入数据， 取值的时候表达式要用&quot;#&quot;】&lt;/span&gt;
        context.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;user&quot;&lt;/span&gt;, user);
        
        &lt;span class=&quot;co&quot;&gt;// 获取数据(map)&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 先构建一个Ognl表达式, 再解析表达式&lt;/span&gt;
        Object ognl = Ognl.&lt;span class=&quot;fu&quot;&gt;parseExpression&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;#user.name&quot;&lt;/span&gt;);
        Object value = Ognl.&lt;span class=&quot;fu&quot;&gt;getValue&lt;/span&gt;(ognl, context, context.&lt;span class=&quot;fu&quot;&gt;getRoot&lt;/span&gt;());
        
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(value);
    }
    
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 2. Ognl表达式语言语言取值，取根元素的值，不用带#号&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@throws Exception&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;testOgn2&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;co&quot;&gt;// 创建一个Ognl上下文对象&lt;/span&gt;
        OgnlContext context = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;OgnlContext&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;// 放入数据&lt;/span&gt;
        User user = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;User&lt;/span&gt;();
        user.&lt;span class=&quot;fu&quot;&gt;setId&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;100&lt;/span&gt;);
        user.&lt;span class=&quot;fu&quot;&gt;setName&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Jack&quot;&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;// 【往根元素放入数据】&lt;/span&gt;
        context.&lt;span class=&quot;fu&quot;&gt;setRoot&lt;/span&gt;(user);
        
        &lt;span class=&quot;co&quot;&gt;// 获取数据(map)&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 先构建一个Ognl表达式, 再解析表达式&lt;/span&gt;
        Object ognl = Ognl.&lt;span class=&quot;fu&quot;&gt;parseExpression&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;address.province&quot;&lt;/span&gt;);
        Object value = Ognl.&lt;span class=&quot;fu&quot;&gt;getValue&lt;/span&gt;(ognl, context, context.&lt;span class=&quot;fu&quot;&gt;getRoot&lt;/span&gt;());
        
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(value);
    }
    &lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是说，JSP页面中取出数据的时候，它会&lt;strong&gt;先构建一个OGNL表达式，再解析表达式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;如果是CompoundRoot类的数据，表达式不需要带#号&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果不是CompoundRoot类的数据，表达式需要带#号&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170504140143929?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaG9uXzN5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;例子&quot;&gt;例子：&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;

    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 页面： 必须要拿到ValueStack --&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;kw&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;1. 取根元素的值&lt;span class=&quot;kw&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;user.id&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt; 
     &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;user.name&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt; 
     &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;user.address&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt; 
     &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;user.address.city&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt; 
     &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;user.address.province&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt; 
     
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;2. 取非根元素的值&lt;span class=&quot;kw&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#request.cn&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#session.Session_data&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#application.Application_data&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;    &lt;span class=&quot;kw&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;
     
      &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 自动找request/session/application,找到后立刻返回 --&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#request_data&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#attr.Session_data&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#attr.Application_data&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;
      
      &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 获取请求的参数数据 --&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#parameters.userName&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
     
     &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- struts的调试标签：可以观测值栈数据 --&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:debug&amp;gt;&amp;lt;/s:debug&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 3.Ognl对 静态方法调用的支持&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@throws Exception&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;testOgn3&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; Exception {
        &lt;span class=&quot;co&quot;&gt;// 创建一个Ognl上下文对象&lt;/span&gt;
        OgnlContext context = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;OgnlContext&lt;/span&gt;();
        
        &lt;span class=&quot;co&quot;&gt;// Ognl表单式语言，调用类的静态方法&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;//Object ognl = Ognl.parseExpression(&quot;@Math@floor(10.9)&quot;);&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 由于Math类在开发中比较常用，所以也可以这样写&lt;/span&gt;
        Object ognl = Ognl.&lt;span class=&quot;fu&quot;&gt;parseExpression&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;@@floor(10.9)&quot;&lt;/span&gt;);
        Object value = Ognl.&lt;span class=&quot;fu&quot;&gt;getValue&lt;/span&gt;(ognl, context, context.&lt;span class=&quot;fu&quot;&gt;getRoot&lt;/span&gt;());
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(value);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;一、.构建 list集合&lt;span class=&quot;kw&quot;&gt;&amp;lt;/br&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:iterator&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; var=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;str&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;{'a','b'}&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#str&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/s:iterator&amp;gt;&lt;/span&gt;
    
     &lt;span class=&quot;kw&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;一、.构建 map集合&lt;span class=&quot;kw&quot;&gt;&amp;lt;/br&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:iterator&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; var=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#{'cn':'China','usa':'America'}&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#en.key&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;#en.value&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;  &lt;span class=&quot;kw&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;kw&quot;&gt;&amp;lt;/s:iterator&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;构建Map集合的时候，需要使用#号&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;#获取非根元素值 、 动态都建map集合&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;$ 在配置文件取值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;% 提供一个ognl表达式运行环境&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;kw&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;获取request域数据&lt;span class=&quot;kw&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- property 标签是对象类型的标签，默认支持ognl表达式, 会从根元素去China名称对应的值 --&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;China&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;        &lt;span class=&quot;kw&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 如果直接赋值，需要用单引号 --&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;'China'&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;      &lt;span class=&quot;kw&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;kw&quot;&gt;&amp;lt;s:property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;%{#request.cn}&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;       &lt;span class=&quot;kw&quot;&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;
     
     &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 值类型的标签，value值默认就是值类型，不支持ognl表达式 --&amp;gt;&lt;/span&gt;
     国家：&lt;span class=&quot;kw&quot;&gt;&amp;lt;s:textfield&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;txtCountry&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;%{#request.cn}&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/s:textfield&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章有错的地方欢迎指正，大家互相交流。&lt;strong&gt;习惯在微信看技术文章，想要获取更多的Java资源的同学，可以关注微信公众号:Java3y&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 11 Mar 2018 14:03:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/8546447.html</dc:identifier>
</item>
<item>
<title>SQL Server 扩展事件 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/5657906.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/5657906.html</guid>
<description>&lt;p&gt;SQL Server 扩展事件（Extended Event）是用于服务器的常规事件处理系统，是追踪SQL Server系统运行状态的神器，同时也是一个日志记录工具，扩展事件完全可以取代SQL追踪（SQL Trace），扩展事件的设计功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于扩展事件引擎不识别事件，因此，引擎可以将任何事件绑定到任何目标，因为引擎不受事件内容约束。&lt;/li&gt;
&lt;li&gt;事件与事件使用者不同，后者在扩展事件中称为“目标”（Target），也就是说任何目标可以接收任何事件。此外，引发的任何事件均可供目标自动使用，这样可以记录或提供额外的事件上下文。&lt;/li&gt;
&lt;li&gt;事件不同于在事件激发时要执行的操作。因此，任何操作可以与任何事件相关联。&lt;/li&gt;
&lt;li&gt;谓词可以动态筛选事件的激发，从而增强了扩展事件基础结构的灵活性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;扩展事件可以同步生成事件数据（并异步处理该数据），这为事件处理提供了灵活的解决方案。此外，扩展事件提供以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一种跨服务器系统处理事件的统一方法，同时使用户可以隔离特定的事件进行故障排除。&lt;/li&gt;
&lt;li&gt;与现有的 ETW 工具集成并支持现有的 ETW 工具。&lt;/li&gt;
&lt;li&gt;基于 Transact-SQL 的完全可配置的事件处理机制。&lt;/li&gt;
&lt;li&gt;可以动态监视活动进程，同时对这些进程的影响最小。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用TSQL创建扩展事件的过程比较复杂，但是，我们可以使用另外一种简单的方法：使用扩展时间的创建向导。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一，创建扩展事件的会话&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;step1，打开新建会话向导（New Session Wizard）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/628084/201607/628084-20160731190106184-1676862777.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step2，设置会话属性（Set Session Properties）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/628084/201607/628084-20160731190221559-1410399385.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step3，选择模板（Choose Template）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/628084/201607/628084-20160731190318731-175294211.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step4，选项捕获的事件（Select Events to Capture）&lt;/p&gt;
&lt;p&gt;该Tab分为两个Pane，左边Pane用于搜索Event，在Event library中，输入需要进行追踪的Event 名称，在选择一个Event之后，Wizard会显示出该Event的Description和 Event Fields，Event fields 是描述Event输出的字段。右边Pane用于列出已经选中的Events 列表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/628084/201607/628084-20160731190559450-39101170.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step5，选择捕获的字段（Capture Global Fields）&lt;/p&gt;
&lt;p&gt;选择Event发生时其他信息，这些信息一般跟Session相关，例如Database_id 和 Database_id 就是Event发生的database 信息。一般会将sql_text也选中，便于查看触发Event的SQL语句。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/628084/201607/628084-20160731191236013-1765947965.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step6，设置会话时间的过滤器（Set Session Event Filters）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/628084/201607/628084-20160731191546622-499727522.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step7，指定会话数据的存储（Specify Session Data Storage）&lt;/p&gt;
&lt;p&gt;制定输出数据存储的目标（target），该tab中列出 Event File target 和 ring buffer target。&lt;/p&gt;
&lt;p&gt;Event File target使用File来存储Session Output，当需要存储大量数据集时，使用该选项。&lt;/p&gt;
&lt;p&gt;Ring buffer target使用Memory buffer来存储Session Output，如果分配的memory buffer用完，target会将最老的Events删除，以容纳新的Events，使memory buffers中存储的是most recent data。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/628084/201607/628084-20160731191640731-1359581379.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Step8，查看扩展事件会话的汇总信息，开始创建事件会话。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二，查看扩展事件捕获的消息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SQL Server 扩展事件捕获的消息，叫做Target，使用Target来存储Events，Target 能够把捕获的消息存储到文件中（扩展名是 .xel），或 memoy buffer 中（Ring Buffer），Target能够以同步或异步方式处理数据，事件的数据都是以XML格式存储。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三，以文件存储Target的数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Target对于扩展事件产生的数据，总是先缓存在内存buffer中，等到内存buffers积累足够数量的数据之后，再将内存中的所有数据写入到文件中。文件中的数据滞后于内存 buffer，这就是异步写（Async Write），能够减少IO的次数，提高IO效率。事件文件类型的taget的扩展名是xel，以XML格式存储Target 数据，使用 sys.fn_xe_file_target_read_file 函数查看事件文件中存储的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，以Rollover 方式复用事件文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事件文件类型的Target 以 rollover 方式复用文件，例如，如果 max_rollover_files=3，那么系统中最多保留 3个 xel文件，文件命名：xxx_0.xel，xxx_1.xel，xxx_2.xel。当文件xxx_0.xel达到Max_File_Size时，Target执行一次rollover，将文件：xxx_0.xel删除，创建新文件：xxx_3.xel，并用该文件存储事件数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，从 sys.dm_xe_session_targets 中查看事件文件的存储路径&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; s.name &lt;span&gt;as&lt;/span&gt;&lt;span&gt; xe_session_name,
    &lt;/span&gt;&lt;span&gt;cast&lt;/span&gt;(st.target_data &lt;span&gt;as&lt;/span&gt; xml) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; target_data
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; sys.dm_xe_sessions s 
&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; sys.dm_xe_session_targets st 
    &lt;/span&gt;&lt;span&gt;on&lt;/span&gt; s.address&lt;span&gt;=&lt;/span&gt;&lt;span&gt;st.event_session_address
&lt;/span&gt;&lt;span&gt;where&lt;/span&gt; s.name&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xe_session_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3，从xel文件中检查target的输出&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;, &lt;span&gt;CAST&lt;/span&gt;(event_data &lt;span&gt;AS&lt;/span&gt; XML) &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;event_data_XML&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;FROM&lt;/span&gt; sys.fn_xe_file_target_read_file(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;file_name*.xel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;NULL&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;四，Ring Buffer Target&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ring buffer target将事件数据保存到内存中，事件数据以XML格式存储。一旦事件数据把分配的内存Buffers 用尽，那么最老的事件数据将被清除。&lt;/p&gt;
&lt;p&gt;1，存储模式&lt;/p&gt;
&lt;p&gt;ring buffer target简单地把数据存储到内存中，这种target模式能够采用两种模式来管理事件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一种模式是严格地先进先出（first-in first-out ，FIFO），也就是说，当分配的内存被target耗尽时，从内存中移除创建时间最早的事件。&lt;/li&gt;
&lt;li&gt;第二种模式是per-event 先进先出模式，也就是说，每一种类型的事件都持有一个计数。在这种模式下，当分配的内存被target耗尽时，每个类型中创建时间最早的事件从内存中被移除。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2，从 sys.dm_xe_session_targets 中查看target输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; name, target_name, &lt;span&gt;CAST&lt;/span&gt;(xet.target_data &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; xml)
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt; sys.dm_xe_session_targets &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; xet
&lt;/span&gt;&lt;span&gt;JOIN&lt;/span&gt; sys.dm_xe_sessions &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; xe
   &lt;/span&gt;&lt;span&gt;ON&lt;/span&gt; (xe.address &lt;span&gt;=&lt;/span&gt;&lt;span&gt; xet.event_session_address)
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; xe.name &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;session_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;五，使用SSMS查看Target数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过TSQL 脚本获取的Target 输出都是以XML格式显示的，通过View Target Data能够以 表格 方式查看Target的输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/628084/201802/628084-20180225144247522-1412651128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;六，查询会话（session）和 target&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，查看扩展事件的Session 配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt;&lt;span&gt; s.name,
    s.total_regular_buffers&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;s.regular_buffer_size&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1024&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;&lt;span&gt; total_regular_buffer_kb,
    s.total_buffer_size&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1024&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;&lt;span&gt; total_buffer_kb,
    s.buffer_policy_desc,
    s.flag_desc,
    s.dropped_event_count,
    s.dropped_buffer_count
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sys.dm_xe_sessions s
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;字段注释：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Regular buffer：&lt;/strong&gt;大多数时间下，扩展事件会话使用的是常规的buffer，这些buffer容量大，存储很多事件的信息。特别地，每一个扩展事件会话都会有三个或更多的buffer。常规buffer的分配是由SQL Server决定的，而SQL Server基于 MEMORY_PARTITION_MODE 选项来设置内存分区，常规buffer的size和 MAX_MEMORY选项的设置相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;buffer_policy_desc：用于表述当buffer耗尽时，扩展事件会话是如何处理新触发的事件：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Drop event&lt;/li&gt;
&lt;li&gt;Do not drop events&lt;/li&gt;
&lt;li&gt;Drop full buffer&lt;/li&gt;
&lt;li&gt;Allocate new buffer&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2，查看会话target的配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; s.name &lt;span&gt;as&lt;/span&gt;&lt;span&gt; xe_session_name,
    st.target_name,
    st.execution_count,
    st.execution_duration_ms&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;st.execution_count &lt;span&gt;as&lt;/span&gt;&lt;span&gt; avg_execution_ms,
    st.target_data
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; sys.dm_xe_session_targets st 
&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt;&lt;span&gt; sys.dm_xe_sessions s 
    &lt;/span&gt;&lt;span&gt;on&lt;/span&gt; st.event_session_address&lt;span&gt;=&lt;/span&gt;s.address
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当Target的名称是 event file 时，Session 输出的数据实际上是存储在Event file中。&lt;/p&gt;
&lt;p&gt;当Target的名称是 ring buffer时，Session 输出的数据存储在内存 buffers中，通过 sys.dm_xe_session_targets的 target_data 字段查看&lt;/p&gt;


&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/bb630339(v=sql.110).aspx&quot; target=&quot;_blank&quot;&gt;SQL Server Extended Events Targets&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/bb630378(v=sql.110).aspx&quot; target=&quot;_blank&quot;&gt;sys.dm_xe_sessions (Transact-SQL)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/bb677313(v=sql.110).aspx&quot; target=&quot;_blank&quot;&gt;sys.dm_xe_session_targets (Transact-SQL)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/cc280743(v=sql.110).aspx&quot; target=&quot;_blank&quot;&gt;sys.fn_xe_file_target_read_file (Transact-SQL)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.brentozar.com/archive/2015/01/query-extended-events-target-xml/&quot;&gt;How to Query Extended Events Target XML&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/grahamk/2009/09/23/realistic-troubleshooting-example-of-extended-events-xevent-usage-in-sql-server-2008-part-1/&quot; target=&quot;_blank&quot;&gt;Realistic troubleshooting example of extended events (XEvent) usage in SQL Server 2008 – Part 1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/grahamk/2009/09/29/using-xquery-to-query-extended-events-asynchronous-file-target-results/&quot; target=&quot;_blank&quot;&gt;Using Xquery to query Extended Events asynchronous file target results&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 11 Mar 2018 13:50:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/5657906.html</dc:identifier>
</item>
<item>
<title>从技术角度讨论微服务 - 编程玩家</title>
<link>http://www.cnblogs.com/Erik_Xu/p/8495939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Erik_Xu/p/8495939.html</guid>
<description>&lt;p&gt;　　本文希望从技术角度来探讨下微服务，因此，不会过多地谈及如何根据业务进行微服务划分，更多是介绍微服务的相关技术，微服务的业务划分方法可参考“领域驱动设计“相关方法论。&lt;/p&gt;


&lt;h2&gt;一、服务化&lt;/h2&gt;
&lt;p&gt;　　复杂的单体架构会有以下的挑战：&lt;/p&gt;
&lt;p&gt;　　（1）项目启动初期，需要寻找一个能尽量涵盖所有需求的开发语言，技术选型难度高；&lt;/p&gt;
&lt;p&gt;　　（2）工程庞大，组件、中间件繁多，编译时间长；开发环境复杂，需要安装大量的辅助软件，环境准备时间长；&lt;/p&gt;
&lt;p&gt;　　（3）团队无效沟通多，沟通成本高；&lt;/p&gt;
&lt;p&gt;　　（4）部署环境依赖大，某个组件的问题可能导致整个系统无法运行；&lt;/p&gt;
&lt;p&gt;　　（5）新功能添加或者bug修复的时候，会影响现有功能，引发新的（未知）问题，添加单元测试难度大；&lt;/p&gt;
&lt;p&gt;　　（6）版本回滚颗粒度大，灵活性差。&lt;/p&gt;

&lt;p&gt;　　以上几点都是实际项目中遇到的问题，如果你也遇到了同样的问题，那么服务化是较好的解决方案。&lt;/p&gt;
&lt;p&gt;　　服务化解耦后：&lt;/p&gt;
&lt;p&gt;　　（1）微服务可以根据自身业务特征选择合适的开发语言或数据库；&lt;/p&gt;
&lt;p&gt;　　（2）微服务的开发者只需要安装该服务相关的辅助软件；&lt;/p&gt;
&lt;p&gt;　　（3）沟通多集中在微服务团队中，与周边（或公共）微服务有交集时才产生相应的沟通；&lt;/p&gt;
&lt;p&gt;　　（4）部署环境依赖小，某个微服务部署失败仅影响该微服务（或周边几个微服务）；&lt;/p&gt;
&lt;p&gt;　　（5）功能调整，如果接口没有调整，基本不会影响其它微服务，添加单元测试、接口测试难度低，自动化（回归）测试覆盖率高；&lt;/p&gt;
&lt;p&gt;　　（6）版本回归最小单位为某个微服务，颗粒度小，可更好地实现蓝绿部署、A/B测试、灰度（金丝雀）发布。&lt;/p&gt;

&lt;h2&gt;二、容器化&lt;/h2&gt;
&lt;p&gt;　　容器（docker）具有轻量、环境依赖低、启动速度快等特点；&lt;/p&gt;
&lt;p&gt;　　虚拟化技术（openstack）负责IaaS层（存储、计算、网络）资源的调度；&lt;/p&gt;
&lt;p&gt;　　容器治理平台（Kubernetes、docker swarm）配合资源监控对容器进行灵活调度；&lt;/p&gt;
&lt;p&gt;　　以上3种技术极大地提高了微服务的横向（弹性）伸缩以及高可用的能力，使微服务具备更好的高并发处理能力。&lt;/p&gt;
&lt;p&gt;　　配合DevOps，CI/CD等工具及技术提升了团队快速响应、持续交付的能力。&lt;/p&gt;

&lt;p&gt;　　我认为，团队应该基于产品或项目实际情况选择合适的微服务程度。&lt;/p&gt;


&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201803/182190-20180304030906437-446844851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我认为，当前使用前后端分离的开发模式还是十分有好处的，关于前后端分离的描述，可参考我之前的&lt;a href=&quot;http://www.cnblogs.com/Erik_Xu/p/6241359.html&quot; target=&quot;_blank&quot;&gt;《浅谈开发模式及架构发展》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　Web A/B/C/...是几个纯前端项目，可以根据实际情况在不同项目中使用Angularjs、Vuejs或Reactjs等框架进行开发；&lt;/p&gt;
&lt;p&gt;　　API X/Y/Z/...是几个API项目，供Web或者App调用，可以根据实际情况使用.Net Core、Java或python等语言进行开发；&lt;/p&gt;
&lt;p&gt;　　也可以根据带宽或性能需要，让Web或API启动多份示例。&lt;/p&gt;

&lt;p&gt;　　基本交互：&lt;/p&gt;
&lt;p&gt;　　浏览器经过&lt;strong&gt;网关&lt;/strong&gt;从服务端获取网站的html及js（橙色箭头）；&lt;/p&gt;
&lt;p&gt;　　Web通过url或ajax经过&lt;strong&gt;网关&lt;/strong&gt;访问服务端API，App通过类Http Client方式经过&lt;strong&gt;网关&lt;/strong&gt;访问服务端API（灰色箭头）；&lt;/p&gt;
&lt;p&gt;　　API X/Y/Z/...注册到&lt;strong&gt;服务中心&lt;/strong&gt;（蓝色箭头）；&lt;/p&gt;
&lt;p&gt;　　Web A/B/C/...、API X/Y/Z/...从&lt;strong&gt;配置中心&lt;/strong&gt;读取各自的配置（紫色箭头）；&lt;/p&gt;
&lt;p&gt;　　API X通过&lt;strong&gt;服务中心&lt;/strong&gt;调用API Z（绿色箭头）。&lt;/p&gt;

&lt;p&gt;　　因此，微服务的三个基础组成部分分别是服务注册发现，配置管理以及网关。&lt;/p&gt;


&lt;h2&gt; 一、最简单的服务注册发现&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201803/182190-20180304033400786-1146388893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我认为最简单的服务注册发现是直接通过IP端口进行访问，这种方式适用于单个实例的服务，但如果API Y是多个实例，那么需要借助类似虚拟IP（VIP）等技术。&lt;/p&gt;

&lt;h2&gt; 二、基于中间件的服务注册发现&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201803/182190-20180304035651726-1762345962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　API Y实例1/2/.../n&lt;strong&gt;启动&lt;/strong&gt;时，会把自己的信息注册到服务中心（自上报）；API X需要调用API Y，会先从服务中心中获取API Y服务实例的IP端口列表；然后根据特定的策略（随机，网络情况，权重等）筛选出一个实例进行调用，负载均衡是在客户端（调用方）实现的。&lt;/p&gt;
&lt;p&gt;　　这种方式的典型代表是Spring Cloud Eureka，如果服务中心down掉了，那么会影响整个系统，因此，要保证服务中心的高可用；另外，需要有特定的jdk/sdk和服务中心进行交互，如Java的FeignClient（集成了ribbon实现服务的负载均衡），steeltoe的&lt;span class=&quot;pl-en&quot;&gt;DiscoveryHttpClientHandler（随机选择实现服务的负载均衡），有一定的语言侵入性。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;三、基于容器治理平台的服务注册发现&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201803/182190-20180304035701423-532997498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　API Y实例1/2/.../n&lt;strong&gt;部署启动&lt;/strong&gt;时，治理平台会给它们分配IP端口，并记录在服务中心；API X需要调用API Y，会基于dns，通过API Y的服务名或集群 IP（Cluster IP，类似于Virtual IP）加端口进行访问。负载均衡由治理平台负责，是在服务端（平台）实现的。&lt;/p&gt;
&lt;p&gt; 　　这种方式的典型代表是docker swarm以及Kubernetes，服务注册发现的高可用由平台保证，因为基于dns，普通的http客户端就可以进行Api访问，如java的restTemplate或C#的HttpClient，无语言侵入性，但负载均衡的灵活性比中间件的方式稍微低一些。&lt;/p&gt;


&lt;h2&gt; 一、最简单的配置管理&lt;/h2&gt;
&lt;p&gt;　　最简单的配置管理就是平时常用的配置管理，如java的application.properties、.net的web.config、.net core的appsettings.json等，基本是和应用程序一起，能够兼容多个环境（开发、测试、生产）。&lt;/p&gt;
&lt;p&gt;　　但当我们的程序需要启用多份的时候，这种简单的配置管理方式遇到了挑战，配置的更新需要&lt;strong&gt;手动更新&lt;/strong&gt;各个实例的配置文件，繁琐且容易出错（遗漏、修改错误或环境依赖）。&lt;/p&gt;
&lt;p&gt;　　这也是微服务中面临的一个主要挑战。&lt;/p&gt;

&lt;h2&gt;二、基于中间件的配置管理&lt;/h2&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201803/182190-20180311085920518-1039855533.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这种方式的典型代表是Spring Cloud Config Server。&lt;/p&gt;
&lt;p&gt;　　API X、Y...会通过Url访问配置中心，通过心跳（2s）来确认配置中心的健康以及检测配置内容的更新。&lt;/p&gt;
&lt;p&gt;　　其中，application.yaml用于保存各个微服务的公共配置，{服务名}.yaml用于保存微服务的私有配置。&lt;/p&gt;
&lt;p&gt;　　和Eureka一样，使用者需要自己保证Config Server的高可用，否则，配置中心down掉的话，整个系统的配置信息就会乱套；另外，也需要有特定的jdk/sdk和配置中心进行交互；配置文件的格式基本也限制于yaml格式。&lt;/p&gt;

&lt;h2&gt;三、基于容器治理平台的配置管理&lt;/h2&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201803/182190-20180311090152370-1092702578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这种方式的典型代表是Kubernetes ConfigMap。&lt;/p&gt;
&lt;p&gt;　　部署、升级、增加API X、Y...实例时，Kubernetes会按照设置，把对应的配置文件放置到容器（docker）指定的位置，也可以是环境变量。&lt;/p&gt;
&lt;p&gt;　　配置中心的高可用由治理平台保证，微服务不需要使用特定的jdk/sdk和配置中心交互，只需要解析本地路径的某些文件，文件格式可以根据需要选择（json,xml,yaml,properties）。&lt;/p&gt;
&lt;p&gt;　　微服务公共配置与私有配置也可以实现，但需要语言支持，比如.net core，详细的可以参考我之前的文章&lt;a href=&quot;http://www.cnblogs.com/Erik_Xu/p/7624323.html&quot; target=&quot;_blank&quot;&gt;《你可能不知道的.Net Core Configuration》&lt;/a&gt;。&lt;/p&gt;


&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/182190/201803/182190-20180311102821550-2127254415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　网关作为微服务的统一出口，一般需要完成以下任务：反向代理，跨域处理，负载均衡，流量控制，缓存，日志，公共功能（如认证）等，常用的网关中间件有Nginx，Spring Cloud Zuul，Kong，Ocelot等。&lt;/p&gt;
&lt;p&gt;　　或许有人会问，像公共功能（如认证）这些，在过滤器(filter)里做就好了啊，为什么要在网关做，没看出什么优势。&lt;em&gt;I think it is a good call.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　&lt;/em&gt;确实，像认证这些功能的确可以在过滤器里做，但是，如果过滤器需要升级，那么每个微服务都要进行升级；另外一种情况是，如果微服务是使用不同语言编写的，那么还需要提供多个版本的filter；更为恶劣的可能是该语言不支持filter，或者像单点登录这些公共模块没有提供该语言的jdk或sdk；还有一种比较特殊的情况是，可能在不同的环境系统需要有不同的认证机制，如对接第三方的认证系统。使用网关就能比较好的解决以上问题。&lt;/p&gt;


&lt;p&gt;　　既然可以通过部署一个网关，让所有请求都经过它来实现一些公共的功能，那么有没有可能使微服务的请求经过一个特定的“层”，来实现一些特定的功能（如调用链、熔断，服务调用认证，请求限制等）呢？答案是肯定的。&lt;/p&gt;
&lt;p&gt;　　我认为Kubernetes其中一个强大的设计是，它的最小单位是pod，而不是容器（container）；一个pod里面可以有多个容器，而且它们可以共享网络，共享存储。&lt;/p&gt;
&lt;p&gt;　　可以通过在pod里面部署一个业务容器，同时也部署一个小型的sidecar容器，让请求到达业务容器之前，先经过sidecar容器（起到了filter的作用），在sidecar容器中实现调用链、熔断，服务调用认证，请求限制等功能，这样就可以通过基于部署的方式解决语言限制的问题。&lt;/p&gt;
&lt;p&gt;　　目前可以选择Istio或Linkerd来实现上述效果。&lt;/p&gt;


&lt;p&gt;　　我认为，从架构的层面来看微服务架构，应该是这样的：&lt;/p&gt;
&lt;p&gt;　　扩展性：降低复杂系统的耦合度、沟通成本以及系统复杂度，需求快速响应；&lt;/p&gt;
&lt;p&gt;　　伸缩性：可以通过增加资源的方式来快速应对海量并发（仅仅是并发层面，大数据量还是需要根据业务进行分片或分割）；&lt;/p&gt;
&lt;p&gt;　　稳定性：微服务治理平台，PaaS平台保证了系统的高可用性，可以降低业务的中断时间；&lt;/p&gt;
&lt;p&gt;　　安全性：和传统架构的要求差别不大，但是由于网关和网格（Service Mesh）的存在，使得安全处理，APM等的实现更加简单。&lt;/p&gt;

&lt;p&gt;　　另外，我认为微服务可以通过&lt;strong&gt;部署&lt;/strong&gt;的方式来实现功能或模块的复用，一定程度上代替了过往通过jdk/sdk来实现共用的方式；使得开发更加灵活，也使得开发可以更加关注于业务，而非各种边边角角的公共（轮子）功能。&lt;/p&gt;
</description>
<pubDate>Sun, 11 Mar 2018 13:02:00 +0000</pubDate>
<dc:creator>编程玩家</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Erik_Xu/p/8495939.html</dc:identifier>
</item>
<item>
<title>2017读书书单 - 薰衣草的旋律</title>
<link>http://www.cnblogs.com/wangqiguo/p/8545818.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangqiguo/p/8545818.html</guid>
<description>&lt;p&gt;&lt;img title=&quot;2017读书书单&quot; src=&quot;https://images.cnblogs.com/cnblogs_com/wangqiguo/1176250/o_%e5%a4%a7%e5%9b%be.jpg&quot; alt=&quot;2017读书书单&quot; width=&quot;800&quot; height=&quot;441&quot;/&gt;&lt;/p&gt;
&lt;p&gt;貌似2017年读的都是经济与投资相关的书籍。对于投资我是一窍不通的，在股价低的时候买入，股价高的时候卖出，这是一个小孩子都明白的道理。对于经济，我认为一直是神秘莫测的东西。读了这些书之后，对于投资和经济学有了完全不一样的认识。经济学没有那么枯燥，投资也不必要天天研究K线图。读书不一定会让你成为投资大师，但是投资理财的理念会植根于你的心里。&lt;/p&gt;
&lt;p&gt;为什么选择了解这方面的知识? 对于大多数人来说，我们的收入基本上是从一份工作中得来的也就是获得薪水。然而就像我以前不懂投资理财一样，钱存在银行里面，随着时间的流逝，实际上是越来越贬值的。最直观的是以前100元可以买比较多东西，而现在基本买不了多少东西了，也就是说同样额度的钱的购买力(能买到的物品与服务)是越来越少的。这就是货币的贬值。货币贬值的速度大于存在银行获得的利息，钱就越来越不值钱了。所以必须要学习一些投资方式来抵抗这种贬值(通货膨胀)。我们是非常有必要去了解一些投资以及经济学的知识的。这至少会形成一种思维，让我们在平时的生活中，经常思考哪些投入值得，哪些不值得。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 聪明的投资者&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;2. 巴菲特之道&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;3. 巴菲特致股东的信&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;4. 彼得林奇的成功投资&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;5. 投资中最简单的事&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这几本书当中，除了《投资中最简单的事》以外，其他基本都是比较好的书籍。其中《聪明的投资者》应该说是一本比较基础系统的讲解投资的书籍，本书的作者格雷厄姆，是巴菲特的老师，价值投资者。这也是这本书的核心思想。投资是以深入分析为基础，确保本金安全，并获得适当的回报的投资行为，其他的都是投机。以深入分析为基础表示在你看来你知道你自己买的是什么。按照价值投资的理论，当我们购买股票的时候，我们实际上应该将自己当做这家公司的主人，公司的主人会轻易卖掉自己的公司吗？当然不会。就像我们买房子一样，我们大概不会在短时间内买房子，等价格上涨一点点之后就立刻出手卖掉吧。实际上该书不仅仅讲了股票，而且还讲了各种债券(政府债券，国债)。主动性投资与防御性投资。不同类型的公司的特点，以及安全边际的概念，可转换的证券，基金投资等。&lt;/p&gt;
&lt;p&gt;其实我觉得说我们要用先买房子的心态去买股票。买之前做好对公司的研究工作，一旦确定买入就应该希望长期持有。公司的基本面包括他所在的行业，产品，业绩，财务状况，负债情况，管理团队是否靠谱等等。那么是不是公司各方面情况都比较好，就应该买入呢，也不一定。如果股价太高的话也是不合适买入的。书中提出一个观点，一个公司股票的价格的浮动，始终是围绕其真实的价值的。即使短时偏离，最终还是会回到接近价值的价格上面去。所以我们应该购买其价值大于其价格的股票。也就是说其股价被低估了。如果价值小于股票的价格，那么股票的价格被高估了。相对于价值来说股票的价格越低，就越安全。&lt;/p&gt;
&lt;p&gt;股票的价格在市面上是公开的，可以通过各种渠道知晓。但是股票的价值如何确定呢，这个就需要通过一些方法去估计了。书里面也讲了很多估算公司真实价值的方法，比如最容易得到的是公司的财报，彼得林奇习惯于从日常工作生活中发现值得投资的好公司。&lt;/p&gt;
&lt;p&gt;我们是不是比专业的投资者要差? 完全不一定。由于专业的基金公司的经理受到来自客户的压力以及自己获利的私心，所以他们更容易鼓励客户频繁短线交易，这样他们可以获得更多的交易费用。&lt;/p&gt;
&lt;p&gt;如果你什么都不懂，而且比较厌恶风险，那么投资一些指数基金也是比较靠谱的。&lt;/p&gt;
&lt;p&gt;股票投资是一个比较复杂的领域，每个人可能都有自己的认识与投资方法，具体投资细节都是一个单独的领域，这些具体的投资方法，都可以通过专业的书籍学习。其实我觉得这些都是次要的，重要的是通过读书自己要形成投资的意识与思维，而不一定非要投资股票，投资房产，找一个靠谱有前途的公司工作也算是一种投资，努力学习提升能力投资自己。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6. 管道的故事&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本书以一个小故事开头，说明管道的重要性，而这里的管道是指我们的收入通道。书中讲了一个小故事，两兄弟所在的村子，有一天决定要将附近运河里面的水运到村里的蓄水池，他们接下了这项工作。A采用桶提水的方式，而B决定建设一条管道将水引入到蓄水池。在初期，A每天都有收入，而管道还没有完全建设好之前B则过的很辛苦。然而管道建设完成之后，却可以源源不断的为B带来收入，建设完成的管道，不管B是在睡觉，吃饭，旅行，管道都在源源不断为B产生收入。而A则不同。只要停止提水就没了收入。&lt;/p&gt;
&lt;p&gt;杠杆是一个物理学的概念，能够比较轻松省力的撬动大的物体。而在这里，我的理解是以较少的个人投入获得比较高的回报。&lt;/p&gt;
&lt;p&gt;时间杠杆：所有人的时间都是有限的，相等的。每个人每天只有24小时的时间，假设1小时工作有10美元的收入，就算一天不吃不喝不休息，就是240美元的收入。除非提高单位时间的收入值。因为我们不可能凭空生出多的时间。所谓杠杆时间是指杠杆别人的时间，如果你有一家餐厅，凭你自己一个人不可能做所有的事情，厨师，洗碗，服务员，切菜，收银等等。你可以雇佣多个工人来做这些事情，而你只需要付给他们薪水，用餐厅一天的纯收入减去你付出的薪水和其他成本，就是你的盈利。而实际上你是利用别人的时间来帮你赚钱。你可以用同样的方法开10间，甚至100间餐厅。如果完全依靠自己一个人一天24小时的时间这是不可能的。当然说的残酷一点，你的收入一部分来自于剥削工人们的劳动。&lt;/p&gt;
&lt;p&gt;杠杆金钱：最典型的例子就是股票市场里的投资了。如果1965年投资1万美元到巴菲特的公司，以后的几十年都不动它，到了1998年将会变成5100万美元。而贷款买房则是另一个典型的利用别人的金钱投资的例子了。当然，利用杠杆炒股票(贷款或者是借钱买股票)是要不得的，一旦亏损，将是一件很恐怖的事情。&lt;/p&gt;
&lt;p&gt;总之本书讲述了一个重要的观点，靠出卖自己的个人劳动时间去赚取薪水的方式并不是获得财富的方式，因为一旦你停止工作，你的收入将停止。而我认为作者想要描述的管道，则是那些并不是出卖个人劳动时间去获取收入的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;7. 复制猫营销101&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们大多数人都在模仿打工的轨道，而不是创造财富的轨道。我们打工所得到的是收入，或者薪水而不是财富。财富是什么? 财富不仅仅是钱，财富是拥有足够的时间和钱，使你可以在你想的时候做你想做的事情。财富并不是足够多的钱可以买任意的东西，因为人的欲望是无止境的，即使再有钱也不可能买下所有的东西。财富意味着选择的自由。大多数人靠打工换取收入实际上是通过个人的时间换取钱，只要是打工，不管你是一个小时5美元的清洁工还是一个小时500美元的心脏病医生。都是用个人时间换取金钱，只不过有的职业单价高罢了。换句话说，一个心脏病医生相当于一个高价码清洁工。这种通过投入时间换钱的方式，一旦你停止投入时间，例如生病或者意外。你的收入就停止了。&lt;/p&gt;
&lt;p&gt;本书的宗旨是告诉我们，要打破通过个人时间换取金钱的陷阱。通过杠杆的力量以少量的时间和少量的力气实现目标。一个工人通过时间来换取金钱时，他的收入只会线性增长，一个单位的时间换取一个单位的金钱。这个工人百分之百靠他的个人努力换取金钱。而一个公司的CEO则通过他的雇员来杠杆他的时间与才华。这样他10个小时的工作可以带来100个小时甚至1000个小时的报酬。如果福特是自己一个人来制造汽车他可以把利润的100%装进自己口袋，但是如果他独自工作，也许一年只能制造出1-2辆汽车。但是凭借杠杆的力量福特每年可以制造数以千计的汽车。投入自己的所有时间去赚100块钱，肯定是不如雇佣100个工人，从他们每个人身上赚1块钱的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;8. 富爸爸穷爸爸&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本书通过一系列的故事案例，模仿两个爸爸，一个穷爸爸，一个富爸爸的口吻告诉读者应该怎么样去思考以及积累财富。作者讲述了几个观点。&lt;/p&gt;
&lt;p&gt;不要为了钱去工作：其实作者想要表达的意思并不是说我们去工作不要在乎钱，我们工作当然是要报酬的，但是我们的思维里不能一直想着我要努力工作，加薪赚更多的钱。为什么呢，因为人们一旦思维里面只有努力工作赚钱的话，人们就只能忙着追求金钱与安定，根本没有其他空余的心思去思考别的机会了。所以我们应该练就发现机会把握机会的能力，而不是固化思维的陷入到只有努力工作-加薪-努力工作的死循环中。不要为了钱去工作的另一层含义则是我们不要总是想着怎么样通过工作去赚钱，这样我们就有时间与精力去学习别的领域的东西。&lt;/p&gt;
&lt;p&gt;学习财务知识：富爸爸告诉我们要学习理财知识，弄清楚资产与负债的区别。简而言之，资产就是流入到口袋里的钱，而负债则是从口袋中流出的钱。很多薪水越高的人其财富不一定比薪水低的人要多多少。原因在于薪水高的人其生活的各项开支也大。当你有钱之后你想换大房子，买更好的汽车，享受更高级的食品与各种服务，而真正积累下来的钱可能并没有多少。我们更应该买入资产，减少不必要的金钱流出(负债)。怎么买入资产？简单一点就是买入能够让钱流入口袋的东西。例如投资。我们知道如何挣钱，更应该懂得如何正确的花钱。即如何处理赚到的钱，防止这些钱从手中流出，而不是只知道越是努力的工作，却越是没有钱，实际上这是目前很多中产打工者的现状，赚的多，花的也多，资产比负债多不了多少，甚至负债更大。&lt;/p&gt;
&lt;p&gt;关注自己的事业：存在财务问题的人经常耗费一生为别人工作，一旦他们不能工作时就变得一无所有。当前的教育体系是致力于让学生们好好学习，然后找一份好的工作。职业与事业是有很大的差别的，关注职业是关注自己的工作，而关注自己的事业则是关注自己的资产项。我们不应该只是围绕着工资收入转，而应该把额外的收入用来购买可以产生收入的资产。我们应该控制自己的支出(那些容易贬值的却没有实际用处的购买项目)。资产有有那些呢？&lt;/p&gt;
&lt;p&gt;不需要我到场就可以正常运作的业务，我拥它们但是由别人经营和管理。(如果自己在那工作就不是事业而是职业)&lt;br/&gt;股票，债券，共同基金&lt;br/&gt;能够产生收入的房地产(房租，或者房子本身的升值)&lt;br/&gt;版税(音乐，手稿，专利)&lt;br/&gt;其他任何有价值，可产生收入或有增值潜力并有好销路的东西&lt;/p&gt;
&lt;p&gt;税收：我们有必要了解一些税收的知识，实际上现实中大部分的税收是通过中产阶级收取的，他们的所得税是更容易收取的，在发工资的时候就已经上交了。反而企业和富人们有各种各样的方法来避税。企业的税率比拿工资的人的税率要低得多。&lt;/p&gt;
&lt;p&gt;克服困难：恐惧心里。愤世嫉俗。懒惰。不良习惯与自负。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;9. 思考致富&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个人都希望富有，可是大多数人是晚上想想千条路，早上起来原地踏步。本书的书名是《思考致富》其实书中最多强调的不是告诉具体的致富方法。而是应该培养赚钱的欲望与决心。说起来容易，其实做起来却没那么简单。人人都希望赚钱，但是懒惰却是人的天性，人们普遍都安于现状。这是一本修心与考毅力的书籍，改变人的思维很难，可是不去尝试改变就不要羡慕别人的富有。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;10. 经济学原理.微观经济学&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;11. 经济学原理.宏观经济学&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经济学原理，这两本书可以说是两本非常好的经济学书籍，一点也不晦涩，就算没有任何经济学基础的人也可以看得懂。&lt;/p&gt;
&lt;p&gt;我们经常会有一个比较常见的困惑，为什么人们的薪水有高有低，为什么环卫工人的薪水比医生的低呢。有人解释说因为医生的技术含量比环卫工高。环卫工人的可替代性比医生强。或者环卫工人的学历普遍比医生低。我想说的是这些解释或多或少都有一些道理，可是并没有解释到本质原因。按照经济学原理中最核心的观点，主要原因是供给与需求的关系决定的。&lt;/p&gt;
&lt;p&gt;在一个大的商品市场中，一个商品的价格取决于其供给与需求的关系，供给越少需求量越大，价格当然越高。不管什么职业其薪水的规律也是如此。技术含量与学历的高低仅仅只是表象而已。我们知道很多行业都有蓬勃发展的上升时期，也有衰落期。同样一个工人随着年龄的增长技术是越来月纯熟，然而当行业衰退的时候，技术纯熟的老工人也面临下岗的危机。这说明也并不是技术含量越高薪水就越高。没有需求，无论多高的技术含量也卖不出价钱来。将美国最先进的核潜艇卖给非洲内陆的小国家，就算技术含量高也不一定卖的出去。&lt;/p&gt;
&lt;p&gt;贸易是双赢的，可以让所有人的状况都变的更好。没看此书之前我是不理解的，我们为什么要买泰国的大米，自己不是都可以种大米吗。其实这种分工可以让更专业的人做专业的事情。使得市场的总产值最大化，从而使每个人的生活更好。&lt;/p&gt;
&lt;p&gt;一个国家的生活水平取决于其生产物品与服务的能力。世界各国的生活水平的差别是巨大的，发达国家的人均年收入可以是贫穷国家的几十倍。那么用什么来解释各国之间的生活水平的巨大差别呢。生活水平的所有差别都可以归因于各国生产率的差别，即每一单位劳动投入所生产的物品与服务的数量的差别。&lt;/p&gt;
&lt;p&gt;货币是什么？货币是一种交换媒介，一种计价单位，一种价值储藏手段。当政府发行过多的货币时，货币贬值，物价上升。&lt;/p&gt;
&lt;p&gt;读经济学的书有什么收获？要说学了就立刻能发财，这当然是不可能的。但至少能看明白很多社会现象背后的原理甚至是一些经济政策。了解经济学当然是不能直接让你富有。但是却可以更加精明的参与经济，树立正确的财富价值观，这是最大的收获。&lt;/p&gt;
&lt;p&gt;开卷有益，读书是获取知识最直接的宝藏。&lt;/p&gt;
</description>
<pubDate>Sun, 11 Mar 2018 12:59:00 +0000</pubDate>
<dc:creator>薰衣草的旋律</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangqiguo/p/8545818.html</dc:identifier>
</item>
<item>
<title>haproxy的丰富特性简介 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8545723.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8545723.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8545723.html#blog1&quot;&gt;&lt;span&gt;1.简介&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8545723.html#blog2&quot;&gt;&lt;span&gt;2.haproxy的特性(1)：连接保持和连接关闭&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8545723.html#blog3&quot;&gt;&lt;span&gt;3.haproxy的特性(2)：会话保持&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8545723.html#blog3.1&quot;&gt;&lt;span&gt;3.1 源地址hash算法实现会话保持&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8545723.html#blog3/2&quot;&gt;&lt;span&gt;3.2 cookie实现会话保持&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8545723.html#blog3.3&quot;&gt;&lt;span&gt;3.3 stick table实现会话粘性&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8545723.html#blog3.4&quot;&gt;&lt;span&gt;3.4 session共享&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8545723.html#blog4&quot;&gt;&lt;span&gt;4.haproxy的特性(3)：后端健康状况检查和被检查&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8545723.html#blog5&quot;&gt;&lt;span&gt;5.haproxy的特性(4)：处理请求和响应报文&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8545723.html#blog6&quot;&gt;&lt;span&gt;6.haproxy的特性(5)：状态查看&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8545723.html#blog7&quot;&gt;&lt;span&gt;7.haproxy的特性(6)：ACL&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8545723.html#blog8&quot;&gt;&lt;span&gt;8.haproxy的特性(7)：连接重用功能&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;官方站点：&lt;span&gt;&lt;a href=&quot;http://www.haproxy.org/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.haproxy.org&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;haproxy是一款负载均衡软件，它工作在7层模型上，可以分析数据包中的应用层协议，并按规则进行负载。通常这类7层负载工具也称为反向代理软件，nginx是另一款著名的反向代理软件。&lt;/p&gt;
&lt;p&gt;haproxy支持使用splice()系统调用，它可以将数据在两个套接字之间在内核空间直接使用管道进行传递，无需再在&lt;code&gt;kernel buffer--&amp;gt;app buffer--&amp;gt;kernel&lt;/code&gt;之间来回复制复制数据，实现&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7615914.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;零复制转发&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;(Zero-copy forwarding)，还可以实现零复制启动(zero-starting)。haproxy默认对客户端的请求和对服务端的响应数据都开启了splice功能，它自身对数据状态进行判断，决定此数据是否启用splice()进行管道传递，这能极大提高性能。&lt;/p&gt;


&lt;p&gt;先说明说明HTTP协议事务模型。&lt;/p&gt;
&lt;p&gt;http协议是事务驱动的，意味着每个request产生且仅产生一个response。客户端发送请求时，将建立一个从客户端到服务端的TCP连接，客户端发送的每一个request都经过此连接传送给服务端，然后服务端发出response报文。随后这个TCP连接将关闭，下一个request将重新打开一个tcp连接进行传送。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[&lt;span class=&quot;hljs-link_label&quot;&gt;conn1&lt;/span&gt;][&lt;span class=&quot;hljs-link_reference&quot;&gt;req1&lt;/span&gt;]......[&lt;span class=&quot;hljs-link_label&quot;&gt;resp1&lt;/span&gt;][&lt;span class=&quot;hljs-link_reference&quot;&gt;close1&lt;/span&gt;][&lt;span class=&quot;hljs-link_label&quot;&gt;conn2&lt;/span&gt;][&lt;span class=&quot;hljs-link_reference&quot;&gt;req2&lt;/span&gt;]......[&lt;span class=&quot;hljs-link_label&quot;&gt;resp2&lt;/span&gt;][&lt;span class=&quot;hljs-link_reference&quot;&gt;close2&lt;/span&gt;]......
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种模式称为&lt;strong&gt;&quot;&lt;span&gt;http close&lt;/span&gt;&quot;&lt;/strong&gt;模式。这种模式下，有多少个http事务就有多少个连接，且每发出一个response就关闭一次tcp连接。这种情况下，客户端不知道response中body的长度。&lt;/p&gt;
&lt;p&gt;如果&quot;http close&quot;可以避免&quot;tcp连接随response而关闭&quot;，那么它的性能就可以得到一定程度的提升，因为频繁建立和关闭tcp连接消耗的资源和时间是较大的。&lt;/p&gt;
&lt;p&gt;那么如何进行提升？在server端发送response时给出&lt;code&gt;content-length&lt;/code&gt;的标记，让客户端知道还有多少内容没有接收到，没有接收完则tcp连接不关闭。这种模式称为&lt;strong&gt;&quot;&lt;span&gt;keep-alive&lt;/span&gt;&quot;&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[&lt;span class=&quot;hljs-link_label&quot;&gt;conn&lt;/span&gt;][&lt;span class=&quot;hljs-link_reference&quot;&gt;req1&lt;/span&gt;]...[&lt;span class=&quot;hljs-link_label&quot;&gt;resp1&lt;/span&gt;][&lt;span class=&quot;hljs-link_reference&quot;&gt;req2&lt;/span&gt;]...[&lt;span class=&quot;hljs-link_label&quot;&gt;resp2&lt;/span&gt;][&lt;span class=&quot;hljs-link_reference&quot;&gt;close&lt;/span&gt;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另一种提升&quot;http close&quot;的方式是&lt;strong&gt;&quot;&lt;span&gt;pipelining&lt;/span&gt;&quot;&lt;/strong&gt;模式。它仍然使用&quot;keep-alive&quot;模式，但是客户端不需要等待收到服务端的response后才发送后续的request。这在请求一个含有大量图片的页面时很有用。这种模式类似于累积报文数量成一批或完成后才一次性发送，能很好的提升性能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[&lt;span class=&quot;hljs-link_label&quot;&gt;conn&lt;/span&gt;][&lt;span class=&quot;hljs-link_reference&quot;&gt;req1&lt;/span&gt;][&lt;span class=&quot;hljs-link_label&quot;&gt;req2&lt;/span&gt;]...[&lt;span class=&quot;hljs-link_label&quot;&gt;resp1&lt;/span&gt;][&lt;span class=&quot;hljs-link_reference&quot;&gt;resp2&lt;/span&gt;][&lt;span class=&quot;hljs-link_label&quot;&gt;close&lt;/span&gt;]...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很多http代理不支持pipelining，因为它们无法将response和相应的request在一个http协议中联系起来，而haproxy可以在pipelinign模式下对报文进行重组。&lt;/p&gt;
&lt;p&gt;默认haproxy操作在keep-alive模式：对于每一个tcp连接，它处理每一个request和response，并且在发送response后连接两端都处于空闲状态一段时间，如果该连接的客户端发起新的request，则继续使用此连接。&lt;/p&gt;
&lt;p&gt;haproxy支持5种连接模式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;keep alive&lt;/code&gt;:分析并处理所有的request和response（默认），&lt;span&gt;&lt;strong&gt;后端为静态或缓存服务器建议使用此模式&lt;/strong&gt;&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tunnel&lt;/code&gt;:仅分析处理第一个request和response，剩余所有内容不进行任何分析直接转发。1.5版本之前此为默认，现在不建议设置为此模式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;passive close&lt;/code&gt;:在请求和响应首部加上&quot;connection:close&quot;标记的tunnel，在处理完第一个request和response后尝试关闭两端连接。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;server close&lt;/code&gt;:处理完第一个response后关闭和server端的连接，但和客户端的连接仍然保持，&lt;span&gt;&lt;strong&gt;后端为动态应用程序服务器组建议使用此模式&lt;/strong&gt;&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;forced close&lt;/code&gt;:传输完一个response后客户端和服务端都关闭连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;任何一个反向代理软件，都必须具备这个基本的功能。这主要针对后端是应用服务器的情况，如果后端是静态服务器或缓存服务器，无需实现会话保持，因为它们是&quot;&lt;strong&gt;&lt;span&gt;无状态&lt;/span&gt;&lt;/strong&gt;&quot;的。&lt;/p&gt;
&lt;p&gt;如果反向代理的后端提供的是&quot;有状态&quot;的服务或协议时，必须保证请求过一次的客户端能被引导到同义服务端上。只有这样，服务端才能知道这个客户端是它曾经处理过的，能查到并获取到和该客户端对应的上下文环境(session上下文)，有了这个session环境才能继续为该客户端提供后续的服务。&lt;/p&gt;
&lt;p&gt;如果不太理解，简单举个例子。客户端A向服务端B请求将C商品加入它的账户购物车，加入成功后，服务端B会在某个缓存中记录下客户端A和它的商品C，这个缓存的内容就是session上下文环境。而识别客户端的方式一般是设置session ID(如PHPSESSID、JSESSIONID)，并将其作为cookie的内容交给客户端。客户端A再次请求的时候(比如将购物车中的商品下订单)只要携带这个cookie，服务端B就可以从中获取到session ID并找到属于客户端A的缓存内容，也就可以继续执行下订单部分的代码。&lt;/p&gt;
&lt;p&gt;假如这时使用负载均衡软件对客户端的请求进行负载，如果这个负载软件只是简单地进行负载转发，就无法保证将客户端A引导到服务端B，可能会引导到服务端X、服务端Y，但是X、Y上并没有缓存和客户端A对应的session内容，当然也无法为客户端A下订单。&lt;/p&gt;
&lt;p&gt;因此，反向代理软件必须具备将客户端和服务端&quot;绑定&quot;的功能，也就是所谓的提供会话保持，让客户端A后续的请求一定转发到服务端B上。&lt;/p&gt;


&lt;p&gt;作为负载均衡软件，一般都会提供一种称为&lt;strong&gt;&quot;&lt;span&gt;源地址hash&quot;的调度算法&lt;/span&gt;&lt;/strong&gt;，将客户端的IP地址结合后端服务器数量和权重做散列计算，每次客户端请求时都会进行同样的hash计算，这样同一客户端总能得到相同的hash值，也就能调度到同一个服务端上。&lt;/p&gt;
&lt;p&gt;一般来说，&lt;strong&gt;&lt;span&gt;除非无路可选，都不应该选择类似源地址hash这样的算法&lt;/span&gt;&lt;/strong&gt;。因为只要后端服务器的权重发生任何一点改变，所有源IP地址的hash值几乎都会改变，这是非常大的动荡。&lt;/p&gt;


&lt;p&gt;作为反向代理软件，一般还提供一种&lt;span&gt;&lt;strong&gt;cookie绑定的功能实现会话保持&lt;/strong&gt;&lt;/span&gt;。反向代理软件为客户端A单独生成一个cookie1，或者直接修改应用服务器为客户端设置的cookie2，最后将cookie通过在响应报文中设置&quot;Set-Cookie&quot;字段响应给客户端。与此同时，反向代理软件会在内存中维持一张cookie表，这张表记录了cookie1或修改后的cookie2对应的服务端。只要客户端请求报文中的&quot;Cookie&quot;字段中携带了cookie1或cookie2属性的请求到达反向代理软件时，反向代理软件根据cookie表就能检索到对应的服务端是谁。&lt;/p&gt;
&lt;p&gt;需要注意的是，客户端收到的cookie可能来源有两类：一类是反向代理软件增加的，这时客户端收到的响应报文中将至少有两个&quot;Set-Cookie&quot;字段，其中一个是反代软件的，其他是应用服务器设置的；一类是反向代理软件在应用服务器设置的Cookie基础上修改或增加属性。&lt;/p&gt;
&lt;p&gt;例如，当配置haproxy插入cookie时，客户端从第一次请求到第二次请求被后端应用程序处理的过程大致如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180311135607279-885300829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;haproxy还提供另一种&lt;span&gt;&lt;strong&gt;stick table功能实现会话粘性(stickiness)&lt;/strong&gt;&lt;/span&gt;。这张stick-table表非常强大，它可以根据抽取客户端请求报文中的内容或者源IP地址或者抽取响应报文中的内容(例如应用服务器设置的Session ID这个cookie)作为这张表的key，将后端服务器的标识符ID作为key对应的value。只要客户端再次请求，haproxy就能对请求进行匹配(match)，无论是源IP还是cookie亦或是其它字符串作为key，总能匹配到对应的记录，而且匹配速度极快，再根据value转发给对应的后端服务器。&lt;/p&gt;
&lt;p&gt;例如，下图是一张最简单的stick table示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180311165525756-1913112954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该stick-table存储的key是客户端的源IP地址，当客户端第一次请求到达haproxy后，haproxy根据调度算法为其分配一个后端appserver1，当请求转发到达后端后，haproxy立即在stick table表中建立一条ip1和appserver1的粘性(stickiness)记录。之后，无论是否使用cookie，haproxy都能为该客户端找到它对应的后端服务器。&lt;/p&gt;
&lt;p&gt;stick table的强大远不止会话粘性。还可以根据需要定制要记录的计数器和速率统计器，例如在一个时间段内总共流入了多少个连接、平均每秒流入多少个连接、流入流出的字节数和平均速率、建立会话的数量和平均速率等。&lt;/p&gt;
&lt;p&gt;更强大的是，stick table可以在&quot;主主模型&quot;下进行stick记录复制(replication)，它不像session复制(copy)，节点一多，无论是节点还是网络带宽的压力都会暴增。haproxy每次推送的是stick table中的一条记录，而不是整表整表地复制，而且每条记录占用的空间很小(最小时每条记录50字节)，使得即使在非常繁忙的情况下，在几十台haproxy节点之间复制都不会占用太多网络带宽。借助stick table的复制，可以完完整整地实现haproxy&quot;主主模型&quot;，保证所有粘性信息都不会丢失，从而保证haproxy节点down掉也不会让客户端和对应的服务端失去联系。&lt;/p&gt;


&lt;p&gt;无论反向代理软件实现的会话保持能力有多强，功能有多多，只要后端是应用服务器，就一定是&quot;有状态&quot;的。有状态对于某些业务逻辑来说是必不可少的，但对架构的伸缩和高可用带来了不便。我们无法在架构中随意添加新的代理节点，甚至无法随意添加新的应用服务器，高可用的时候还必须考虑状态或者某些缓存内容是否会丢失。&lt;/p&gt;
&lt;p&gt;如果将所有应用服务器的session信息全部存储到一台服务器上(一般放在redis或数据库中)进行共享，每台应用服务器在需要获取上下文的时候从这台服务器上取，那么应用服务器在取session消息之前就是&quot;无状态&quot;的。&lt;/p&gt;
&lt;p&gt;例如，下面是一个后端使用session共享的示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180311170237221-389792366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用session share后，调度器无论将请求调度到哪个后端上，这个后端都能从session share服务器上获取到对应的session上下文。这样无状态的请求完全可以被任意负载，负载软件无需记住后端服务器，从而达到四层负载的效果。如果没有特殊需求(如处理7层协议)，这时可以使用LVS替代haproxy，因为在负载性能上，LVS比haproxy高好几个级别。&lt;/p&gt;
&lt;p&gt;session共享给架构带来的好处非常多，正如上面所说的，可以使用LVS进行极其高效的负载(前提是没有LVS无法实现的需求)，无论是负载节点还是应用服务器节点都可以随意增删服务器。而唯一需要保证的就是session共享服务器的高可用。&lt;/p&gt;


&lt;p&gt;任何一个负载均衡软件，都应该提供后端服务器健康状况检查的功能，即使自身没有，也必须能够借助其他第三方工具来实现。只有具备后端健康检查的功能，在后端某服务器down掉的时候，调度器才能将它从后端服务器组中踢出去，保证客户端的请求不会被调度到这台down掉的服务器上。&lt;/p&gt;
&lt;p&gt;haproxy为多种协议类型提供了健康状况检查的功能，除了最基本的基于tcp的检查，据我从官方手册上根据关键词的统计，还为以下几种协议提供健康检查：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;HTTP&lt;/li&gt;
&lt;li&gt;ldap&lt;/li&gt;
&lt;li&gt;mysql&lt;/li&gt;
&lt;li&gt;pgsql&lt;/li&gt;
&lt;li&gt;redis&lt;/li&gt;
&lt;li&gt;SPOP&lt;/li&gt;
&lt;li&gt;smtp&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果haproxy没有指定基于哪种协议进行检查，默认会使用tcp协议进行检查，这种检查的健康判断方式就是能否连上后端。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;backend static_group
    server staticsrv1 192.168.100.62:80 &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;check&lt;/span&gt; rise &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt; staticsrv2 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.63:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;check&lt;/span&gt; rise &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在server指令中的check设置的是是否开启健康检查功能，以及检查的时间间隔、判断多少次不健康后就认为后端下线了以及成功多少次后认为后端重新上线了。&lt;/p&gt;
&lt;p&gt;如果要基于其它协议检查，需要使用协议对应的option指令显式指定要检查的对象。且前提是server中必须指定check，这是控制检查与否的开关。例如，基于http协议检查：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;backend dynamic_group
    option httpchk     GET /index.php
    server appsrv1 192.168.100.60:80  &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;check&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt; appsrv2 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.61:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;check&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于基于http协议的检查，haproxy提供了多种判断健康与否的方式，可以通过返回状态码或拿状态码来进行正则匹配、通过判断响应体是否包含某个字符串或者对响应体进行正则匹配。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;backend dynamic_group1
    option httpchk     GET /index.php
    http-&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;check&lt;/span&gt; expect  &lt;span class=&quot;hljs-keyword&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt; appsrv1 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.60:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;check&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt; appsrv2 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.61:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;check&lt;/span&gt;
backend dynamic_group2
    &lt;span class=&quot;hljs-keyword&quot;&gt;option&lt;/span&gt; httpchk     &lt;span class=&quot;hljs-keyword&quot;&gt;GET&lt;/span&gt; /&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;.php
    http-&lt;span class=&quot;hljs-keyword&quot;&gt;check&lt;/span&gt; expect  ! &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; error
    &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt; appsrv1 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.60:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;check&lt;/span&gt;
    &lt;span class=&quot;hljs-keyword&quot;&gt;server&lt;/span&gt; appsrv2 &lt;span class=&quot;hljs-number&quot;&gt;192.168&lt;/span&gt;.100.61:&lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;check&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面两个后端组都指定了使用http协议进行检查，并分别使用&lt;code&gt;http-check expect&lt;/code&gt;指定了要检查到状态码200、响应体中不包含字符串&quot;error&quot;才认为健康。如果不指定&lt;code&gt;http-check expect&lt;/code&gt;指令，那么基于http协议检查的时候，只要状态码为2xx或3xx都认为是健康的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;haproxy除了具备检查后端的能力，还支持被检查，&lt;/strong&gt;&lt;/span&gt;只需要使用&lt;code&gt;monitor&lt;/code&gt;类的指令即可。所谓被检查，指的是haproxy可以指定一个检查自己的指标，自己获取检查结果，并将检查状态上报给它的前端或高可用软件，让它们很容易根据上报的结果(200或503状态码)判断haproxy是否健在。&lt;/p&gt;
&lt;p&gt;以下是两个被检查的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;frontend www
    mode http
    monitor-uri /haproxy_test

frontend www
   mode http
   acl site_dead nbsrv(dynamic) &lt;span class=&quot;hljs-keyword&quot;&gt;lt&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;
   acl site_dead nbsrv(static)  &lt;span class=&quot;hljs-keyword&quot;&gt;lt&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;
   monitor-uri   /site_alive
   monitor fail  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; site_dead
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个示例中，&quot;/haproxy_test&quot;是它的前端指定要检查的路径，此处haproxy对该uri路径进行监控，当该路径正常时，haproxy会告诉前段&quot;HTTP/1.0 200 OK&quot;，当不正常时，将&quot;HTTP/1.0 503 Service unavailable&quot;。&lt;/p&gt;
&lt;p&gt;第二个示例中，不仅监控了&quot;/site_alive&quot;，还监控了后端健康节点的数量。当dynamic或static后端组的健康节点数量少于2时，haproxy立即主动告诉前端&quot;HTTP/1.0 503 Service unavailable&quot;，否则返回给前端&quot;HTTP/1.0 200 OK&quot;。&lt;/p&gt;


&lt;p&gt;一个合格的反向代理软件，必须能够处理流入的请求报文和流出的响应报文。具备这些能力后，不仅可以按照需求改造报文，还能筛选报文，防止被恶意攻击。&lt;/p&gt;
&lt;p&gt;haproxy提供了很多处理请求、响应报文的功能性指令，还有一些所谓&quot;函数&quot;。&lt;/p&gt;
&lt;p&gt;大多数处理请求报文的函数都以&quot;req&quot;或&quot;capture.req.&quot;开头，处理响应报文的函数都以&quot;res.&quot;或&quot;capture.res.&quot;开头，这样的函数非常多，几乎可以实现任何想达到的功能。完整的指令集见官方手册：&lt;span&gt;&lt;a href=&quot;https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#7.3.2&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#7.3.2&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;a href=&quot;https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#7.3.2%E3%80%82&quot; target=&quot;_blank&quot;&gt;。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下是几个比较具有代表性的函数或指令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-title&quot;&gt;capture&lt;/span&gt; request header：捕获请求报文。  
capture response header：捕获响应报文。  
reqadd：在请求首部添加字段。  
rspadd：在响应首部添加字段。  
req.cook(name)：获取Cookie字段中的name属性的值。  
res.cook(name)：获取&lt;span class=&quot;hljs-string&quot;&gt;&quot;Set-Cookie&quot;&lt;/span&gt;字段中name属性的值。  
。。。。。。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上函数都是对7层协议进行处理。除此之外，haproxy还有非常多的函数可以分别处理4层、5层、6层协议。&lt;/p&gt;


&lt;p&gt;作为反向代理，必须具备查看自身和后端服务器的状态信息。&lt;/p&gt;
&lt;p&gt;haproxy提供了多种获取状态信息的方法：&lt;/p&gt;
&lt;ol readability=&quot;-1.3821805392732&quot;&gt;&lt;li&gt;使用&lt;code&gt;stats enable&lt;/code&gt;指令启用状态报告功能，这样就可以在浏览器中输入特定的url访问状态信息。&lt;/li&gt;
&lt;li&gt;提供了很多对前段状态和后端节点状态&lt;span&gt;&lt;strong&gt;取样调查&lt;/strong&gt;&lt;/span&gt;的函数。例如某指定后端或所有后端有多少个节点存活、某后端或所有后端已建立多少连接、后端还有多少连接槽位可以继续提供连接、前段建立了多少连接等等。指令集合参见官方手册：&lt;span&gt;&lt;a href=&quot;https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#7.3.2&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://cbonte.github.io/haproxy-dconv/1.7/configuration.html#7.3.2&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;提供了套接字状态查看、管理功能。也许很多人都不知道，默认配置文件中的&lt;code&gt;stat socket&lt;/code&gt;指令是干吗用的，其实这就是为系统管理员提供的接口。
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;global&lt;/span&gt;
 log         &lt;span class=&quot;hljs-number&quot;&gt;127.0&lt;/span&gt;.0.1 local2
 chroot      /&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt;/lib/haproxy
 pidfile     /&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt;/run/haproxy.pid
 maxconn     &lt;span class=&quot;hljs-number&quot;&gt;2000&lt;/span&gt;
 user        haproxy
 group       haproxy
 daemon
 stats socket /&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt;/lib/haproxy/stats
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们安装&quot;socat&quot;包(socket cat，在epel源提供该包)后，就可以通过socat命令来查看/var/lib/haproxy/stats这个状态套接字。例如，执行下面的命令可以获取到所有可执行的命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;help&quot;&lt;/span&gt; | socat unix:/&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt;/lib/haproxy/stats
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如，其中一条命令是&quot;show backend&quot;用来列出所有的backend，可以这样使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;show backend&quot;&lt;/span&gt; | socat unix:/&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt;/lib/haproxy/stats
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者也可以进入交互式操作模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;socat readline unix:&lt;span class=&quot;hljs-regexp&quot;&gt;/var/&lt;/span&gt;lib/haproxy/stats
&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;可以说，支持ACL的软件都是好软件，比如haproxy、varnish。&lt;/p&gt;
&lt;p&gt;ACL本意是access control list(访问控制列表)，用来定义一组黑名单或白名单。但显然，它绝不仅仅是为了黑白名单而存在的，有了ACL，可以随意按条件定制一组或多组列表。ACL存在的意义，就像是正则表达式存在的意义一样，极大程度上简化了软件在管理上的复杂度。&lt;/p&gt;
&lt;p&gt;在haproxy中，只要能在逻辑意义上进行分组的，几乎都可以使用ACL来定制。比如哪些IP属于A组，后端哪些节点是静态组，后端节点少于几个时属于dead状态等等。&lt;/p&gt;


&lt;p&gt;haproxy支持后端连接重用的功能。&lt;/p&gt;
&lt;p&gt;在默认情况下(不使用连接重用)，当某客户端的请求到来后，haproxy为了将请求转发给后端，会和后端某服务器建立一个TCP连接，并将请求调度到该服务器上，该客户端后续的请求也会通过该TCP连接转发给后端(假设没有采用关闭后端连接的http事务模型)。但在响应后和该客户端的下一个请求到来前，这个连接是空闲的。&lt;/p&gt;
&lt;p&gt;其实仔细想想，和后端建立的TCP连接仅仅只是为了调度转发，免去后续再次建立tcp连接的消耗。完全可以为其它客户端的请求调度也使用这个TCP连接，保证TCP连接资源不浪费。可以使用&lt;code&gt;http-reuse strategy_name&lt;/code&gt;指令设置连接重用的策略，而默认策略禁用连接重用。&lt;/p&gt;
&lt;p&gt;该指令有4个值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1).&lt;code&gt;never&lt;/code&gt;：这是默认设置。表示禁用连接重用，因为老版本的haproxy认为来源不同的请求不应该共享同一个后端连接。&lt;/li&gt;
&lt;li&gt;(2).&lt;code&gt;safe&lt;/code&gt;：这是建议使用的策略。&quot;安全&quot;策略下，haproxy为客户端的每个第一个请求都单独建立一个和后端的TCP连接，但是后续的请求则会重用和该后端的空闲TCP连接。&lt;span&gt;&lt;strong&gt;这样的转发不仅提高了资源使用率，还保持了keep-alive的功能。因此，safe策略配合http-keep-alive事务模式比http-server-close事务模式更高效，无论后端是静态、缓存还是动态应用服务器。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;(3).&lt;code&gt;aggressive&lt;/code&gt;：一种激进的策略，该策略的haproxy会重用空闲TCP连接来转发大多数客户端的第一次请求。之所以是大多数而不是所有，是因为haproxy会挑选那些已经被重用过至少一次的连接(即从建立开始转发过至少两次，不管源是否是同一客户端)进行重用，因为haproxy认为只有这样的连接才具有重用能力。&lt;/li&gt;
&lt;li&gt;(4).&lt;code&gt;always&lt;/code&gt;：它将总是为第一个请求重用空闲连接。当后端是缓存服务器时，这种策略比safe策略的性能要高许多，因为这样的请求行为都是一样的，且可以共享同一连接来获取资源。不过不建议使用这种策略，因为大多数情况下，它和aggressive的性能是一样的，但是却带来了很多风险。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，为了性能的提升，将它设置为safe或aggressive吧，同时再将http事务模型设置为http-keep-alive，以免后端连接在响应后立即被关闭。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8545723.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8545723.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 11 Mar 2018 12:38:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8545723.html</dc:identifier>
</item>
</channel>
</rss>