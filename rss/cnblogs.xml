<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>drbd(三)：drbd的状态说明 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8684648.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8684648.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a&gt;&lt;span&gt;本文目录：&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8684648.html#blog1&quot;&gt;&lt;span&gt;1.drbd配置文件&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8684648.html#blog2&quot;&gt;&lt;span&gt;2.状态&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8684648.html#blog2.1&quot;&gt;&lt;span&gt;2.1 连接状态(connect state,cs)和复制状态&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8684648.html#blog2.2&quot;&gt;&lt;span&gt;2.2 角色状态(roles,ro)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8684648.html#blog2.3&quot;&gt;&lt;span&gt;2.3 磁盘状态(disk state,ds)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8684648.html#blog2.4&quot;&gt;&lt;span&gt;2.4 IO状态标记&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8684648.html#blog2.5&quot;&gt;&lt;span&gt;2.5 性能指标&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;drbd有很多获取信息的方式。在drbd84和之前的版本，大多都使用&lt;code&gt;cat /proc/drbd&lt;/code&gt;来获取信息，多数情况下，这个文件展示的信息对于管理和维护drbd来说已经足够。&lt;/p&gt;
&lt;p&gt;例如以下是drbd84上两个volume的节点状态信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-property&quot;&gt;@drbd1&lt;/span&gt; ~]
&lt;span class=&quot;hljs-attribute&quot;&gt;version&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;8.4&lt;/span&gt;.10-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; (&lt;span class=&quot;hljs-attribute&quot;&gt;api&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;hljs-attribute&quot;&gt;proto&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;86&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;101&lt;/span&gt;)
GIT-&lt;span class=&quot;hljs-attribute&quot;&gt;hash&lt;/span&gt;: a4d5de01fffd7e4cde48a080e2c686f9e8cebf4c build &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; mockbuild@, &lt;span class=&quot;hljs-number&quot;&gt;2017&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;09&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;
 &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;hljs-attribute&quot;&gt;cs&lt;/span&gt;:Connected &lt;span class=&quot;hljs-attribute&quot;&gt;ro&lt;/span&gt;:Primary/Secondary &lt;span class=&quot;hljs-attribute&quot;&gt;ds&lt;/span&gt;:UpToDate/UpToDate C r-----
    &lt;span class=&quot;hljs-attribute&quot;&gt;ns&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;76408&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;nr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dw&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;76408&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;3441&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;al&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;bm&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;lo&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;pe&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ua&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ap&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ep&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;wo&lt;/span&gt;:f &lt;span class=&quot;hljs-attribute&quot;&gt;oos&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
 &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;: &lt;span class=&quot;hljs-attribute&quot;&gt;cs&lt;/span&gt;:Connected &lt;span class=&quot;hljs-attribute&quot;&gt;ro&lt;/span&gt;:Primary/Secondary &lt;span class=&quot;hljs-attribute&quot;&gt;ds&lt;/span&gt;:UpToDate/UpToDate C r-----
    &lt;span class=&quot;hljs-attribute&quot;&gt;ns&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;4957732&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;nr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dw&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;76324&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;4883249&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;al&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;29&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;bm&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;lo&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;pe&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ua&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ap&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ep&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;wo&lt;/span&gt;:f &lt;span class=&quot;hljs-attribute&quot;&gt;oos&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但从drbd9开始，/proc/drbd文件已经废弃了(其实从drbd84就已经废弃了，只不过仍然能获取信息)，因为drbd9中添加了几个新状态信息，也修改了一些信息的显示名称，而这个文件并没有&quot;跟上脚步&quot;。以下是drbd9中该文件展示的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-property&quot;&gt;@drbd91&lt;/span&gt; ~]
&lt;span class=&quot;hljs-attribute&quot;&gt;version&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;9.0&lt;/span&gt;.9-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; (&lt;span class=&quot;hljs-attribute&quot;&gt;api&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;/&lt;span class=&quot;hljs-attribute&quot;&gt;proto&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;86&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;112&lt;/span&gt;)
GIT-&lt;span class=&quot;hljs-attribute&quot;&gt;hash&lt;/span&gt;: f7b979e7af01813e031aac579140237640c94569 build &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; mockbuild@, &lt;span class=&quot;hljs-number&quot;&gt;2017&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;09&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;45&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;45&lt;/span&gt;
Transports (&lt;span class=&quot;hljs-attribute&quot;&gt;api&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;): tcp (&lt;span class=&quot;hljs-number&quot;&gt;9.0&lt;/span&gt;.9-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在drbd9中，更多的是使用&lt;code&gt;drbdadm&lt;/code&gt;或&lt;code&gt;drbdsetup&lt;/code&gt;来获取节点的状态信息。当然，在drbd84中也可以使用它们来获取详细的信息，只不过使用/proc/drbd既方便，又简洁，多数人都直接更愿意使用/proc/drbd。&lt;/p&gt;
&lt;p&gt;例如，使用drbdadm获取节点的基本信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;

[root@drbd90 ~]
rs0 role:Primary
  volume:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; disk:UpToDate
  volume:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; disk:UpToDate
  drbd91.longshuai.com role:Secondary
    volume:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; replication:SyncSource peer-disk:Inconsistent &lt;span class=&quot;hljs-keyword&quot;&gt;done&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0.43&lt;/span&gt;
    volume:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; replication:SyncSource peer-disk:Inconsistent &lt;span class=&quot;hljs-keyword&quot;&gt;done&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;23.72&lt;/span&gt;

[root@drbd90 ~]
drbdsetup status rs0 
rs0 role:Primary
  volume:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; disk:UpToDate
  volume:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; disk:UpToDate
  drbd91.longshuai.com role:Secondary
    volume:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; replication:SyncSource peer-disk:Inconsistent &lt;span class=&quot;hljs-keyword&quot;&gt;done&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;7.04&lt;/span&gt;
    volume:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; replication:SyncSource peer-disk:Inconsistent &lt;span class=&quot;hljs-keyword&quot;&gt;done&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;48.44&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用drbdsetup获取更详细的信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;######### drbdsetup status [

[root@drbd90 ~]# drbdsetup status rs0 
rs0 node-id:0 role:Primary suspended:no
    write-ordering:&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;flush&lt;/span&gt;
  volume:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; minor:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; disk:UpToDate
      &lt;span class=&quot;hljs-keyword&quot;&gt;size&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;4882432&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;read&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;537552&lt;/span&gt; written:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; al-writes:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; bm-writes:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;upper&lt;/span&gt;-pending:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;lower&lt;/span&gt;-pending:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; al-suspended:&lt;span class=&quot;hljs-keyword&quot;&gt;no&lt;/span&gt; blocked:&lt;span class=&quot;hljs-keyword&quot;&gt;no&lt;/span&gt;
  volume:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; minor:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; disk:UpToDate
      &lt;span class=&quot;hljs-keyword&quot;&gt;size&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;4882432&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;read&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;2811712&lt;/span&gt; written:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; al-writes:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; bm-writes:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;upper&lt;/span&gt;-pending:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;lower&lt;/span&gt;-pending:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; al-suspended:&lt;span class=&quot;hljs-keyword&quot;&gt;no&lt;/span&gt; blocked:&lt;span class=&quot;hljs-keyword&quot;&gt;no&lt;/span&gt;
  drbd91.longshuai.com node-id:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;connection&lt;/span&gt;:Connected role:Secondary congested:&lt;span class=&quot;hljs-keyword&quot;&gt;no&lt;/span&gt;
    volume:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; replication:SyncSource peer-disk:Inconsistent done:&lt;span class=&quot;hljs-number&quot;&gt;11.00&lt;/span&gt; resync-suspended:&lt;span class=&quot;hljs-keyword&quot;&gt;no&lt;/span&gt;
        received:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; sent:&lt;span class=&quot;hljs-number&quot;&gt;537096&lt;/span&gt; out-&lt;span class=&quot;hljs-keyword&quot;&gt;of&lt;/span&gt;-sync:&lt;span class=&quot;hljs-number&quot;&gt;4345336&lt;/span&gt; pending:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; unacked:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
    volume:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; replication:SyncSource peer-disk:Inconsistent done:&lt;span class=&quot;hljs-number&quot;&gt;57.58&lt;/span&gt; resync-suspended:&lt;span class=&quot;hljs-keyword&quot;&gt;no&lt;/span&gt;
        received:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; sent:&lt;span class=&quot;hljs-number&quot;&gt;2811256&lt;/span&gt; out-&lt;span class=&quot;hljs-keyword&quot;&gt;of&lt;/span&gt;-sync:&lt;span class=&quot;hljs-number&quot;&gt;2071176&lt;/span&gt; pending:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; unacked:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除此之外，还可以使用&lt;code&gt;drbd-overview&lt;/code&gt;获取一些简单的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@drbd91&lt;/span&gt; ~]
&lt;span class=&quot;hljs-constant&quot;&gt;NOTE&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;/span&gt; drbd-overview will be deprecated soon.
&lt;span class=&quot;hljs-constant&quot;&gt;Please&lt;/span&gt; consider using drbdtop.

 &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:rs0/&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;  &lt;span class=&quot;hljs-constant&quot;&gt;Connected&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;*) &lt;span class=&quot;hljs-constant&quot;&gt;Second&lt;/span&gt;/&lt;span class=&quot;hljs-constant&quot;&gt;Primar&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;UpToDa&lt;/span&gt;/&lt;span class=&quot;hljs-constant&quot;&gt;UpToDa&lt;/span&gt; 
 &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;hljs-symbol&quot;&gt;:rs0/&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;  &lt;span class=&quot;hljs-constant&quot;&gt;Connected&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;*) &lt;span class=&quot;hljs-constant&quot;&gt;Second&lt;/span&gt;/&lt;span class=&quot;hljs-constant&quot;&gt;Primar&lt;/span&gt; &lt;span class=&quot;hljs-constant&quot;&gt;UpToDa&lt;/span&gt;/&lt;span class=&quot;hljs-constant&quot;&gt;UpToDa&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;


&lt;p&gt;/proc/drbd文件中的状态信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-property&quot;&gt;@drbd1&lt;/span&gt; ~]
&lt;span class=&quot;hljs-attribute&quot;&gt;version&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;8.4&lt;/span&gt;.10-&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; (&lt;span class=&quot;hljs-attribute&quot;&gt;api&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;/&lt;span class=&quot;hljs-attribute&quot;&gt;proto&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;86&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;101&lt;/span&gt;)
GIT-&lt;span class=&quot;hljs-attribute&quot;&gt;hash&lt;/span&gt;: a4d5de01fffd7e4cde48a080e2c686f9e8cebf4c build &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; mockbuild@, &lt;span class=&quot;hljs-number&quot;&gt;2017&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;09&lt;/span&gt;-&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;23&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;
 &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;: &lt;span class=&quot;hljs-attribute&quot;&gt;cs&lt;/span&gt;:Connected &lt;span class=&quot;hljs-attribute&quot;&gt;ro&lt;/span&gt;:Primary/Secondary &lt;span class=&quot;hljs-attribute&quot;&gt;ds&lt;/span&gt;:UpToDate/UpToDate C r-----
    &lt;span class=&quot;hljs-attribute&quot;&gt;ns&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;76408&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;nr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dw&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;76408&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;dr&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;3441&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;al&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;bm&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;lo&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;pe&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ua&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ap&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;ep&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-attribute&quot;&gt;wo&lt;/span&gt;:f &lt;span class=&quot;hljs-attribute&quot;&gt;oos&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中第三行中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;0&lt;/code&gt;是drbd的次设备号(minor)，表示该行是/dev/drbd0资源的信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cs&lt;/code&gt;是connect state，即节点的连接状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ro&lt;/code&gt;是roles，即节点的角色状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ds&lt;/code&gt;是disk state，即磁盘的状态，也即drbd底层设备的状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C&lt;/code&gt;是drbd的复制协议，即A、B、C协议。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;r-----&lt;/code&gt;是IO标记，反应的是该资源的IO状态信息。共有6种IO状态标记符号。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第四行是drbd同步过程中的状态，总体概括为&quot;性能指标&quot;。&lt;/p&gt;
&lt;p&gt;以下翻译自官方手册： &lt;span&gt;&lt;a href=&quot;https://docs.linbit.com/docs/users-guide-8.4/#s-check-status&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;users-guide-8.4&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;a href=&quot;https://docs.linbit.com/docs/users-guide-9.0/#s-check-status&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;users-guide-9.0&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; 。如果有疑问，可从官方手册自行查找答案。&lt;/p&gt;

&lt;h2 id=&quot;2-1-connect-state-cs-&quot;&gt;2.1 连接状态(connect state,cs)和复制状态&lt;/h2&gt;
&lt;p&gt;节点间通过TCP连接进行通信，在建立连接、断开连接、特殊情况下有很多种连接状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;建立TCP连接后，还有称为&quot;DRBD&quot;的连接&lt;/span&gt;。&lt;/strong&gt;DRBD连接建立完成，表示元数据区、数据区等一切都已准备好，可以进行任何数据同步的操作。&lt;/p&gt;
&lt;p&gt;节点间的连接状态既可以从/proc/drbd文件中获取，也可以使用下面的命令来获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@drbd91&lt;/span&gt; ~]
Connected
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;drbd84中，将连接状态和复制状态全部都归类为连接状态。但在drbd9中，由于可以通过net指令定义多个drbd节点，它更网络对端和volume的概念。因此它将和连接关系不大的状态独立划分为&quot;复制状态(replication)&quot;中，例如同步、验证相关的状态。本文就懒得去区分它们了，都放在一起解释吧。&lt;/p&gt;
&lt;p&gt;有以下几种连接状态，其中最常捕获到的状态已经加粗显示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;WFConnection&lt;/code&gt;：&lt;span&gt;&lt;strong&gt;当前节点正在等待对端节点出现。例如对方节点&lt;code&gt;drbdadm down&lt;/code&gt;后，本节点将处于本状态。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StandAlone&lt;/code&gt;：&lt;span&gt;&lt;strong&gt;无连接。出现这种状态可能是因为：未连接过、使用&lt;code&gt;drbdadm disconnect&lt;/code&gt;断开连接、节点由于身份验证的原因未成功加入drbd集群使得连接被删除、脑裂后断开连接。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Disconnecting&lt;/code&gt;：断开连接的一个临时过渡状态。它很快就会切入下一状态就是StandAlone。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unconnected&lt;/code&gt;：尝试再次发起TCP连接时的一个临时连接状态(是连接超时后再次发送连接请求产生的状态)，它的下一个状态可能是WFConnection，也可能是WFReportParams。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Timeout&lt;/code&gt;：和对端通信超时时的临时状态。下一个状态就是Unconnection。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BrokenPipe&lt;/code&gt;：和对端连接丢失时的临时状态。下一个状态是Unconnection。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NetworkFailure&lt;/code&gt;：和对端连接丢失时的临时状态。下一个状态是Unconnection。(没错，和上面的一样)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ProtocolError&lt;/code&gt;：和对端连接丢失时的临时状态。下一个状态是Unconnection。(没错，还是和上面的一样)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TearDown&lt;/code&gt;：对端关闭TCP连接时的临时状态。下一个状态是Unconnection。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Connected&lt;/code&gt;：&lt;span&gt;&lt;strong&gt;DRBD连接已经建立完成，数据镜像已经激活成功。这个状态是drbd正常运行时的状态。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WFReportParams&lt;/code&gt;：TCP连接已经建立完成，该节点正在等待对端的第一个数据包。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StartingSyncS&lt;/code&gt;：全盘数据同步中。只有在初始化时才应该全盘同步。下一个状态是：SyncSource或PauseSyncS。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StartingSyncT&lt;/code&gt;：全盘数据同步中。只有在初始化时才应该全盘同步。下一个状态是：WFSyncUUID。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WFBitMapS&lt;/code&gt;：部分数据正在同步。下一个状态是：SyncSource或PauseSyncS。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WFBitMapT&lt;/code&gt;：部分数据正在同步。下一个状态是：WFSyncUUID。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;WFSyncUUID&lt;/code&gt;：同步马上就要开始了。下一个状态：SyncTarget或PauseSyncT。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SyncSource&lt;/code&gt;：&lt;span&gt;&lt;strong&gt;正在同步，且本节点是数据同步的源端。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SyncTartget&lt;/code&gt;：&lt;span&gt;&lt;strong&gt;正在同步，且本节点是数据同步的目标端。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PauseSyncS&lt;/code&gt;：本节点是同步的源端节点，但同步过程当前被暂停。出现这种状态的原因可能是当前同步进程依赖于另一个同步进程完成，或者使用&lt;code&gt;drbdadm pause-sync&lt;/code&gt;手动中断了同步操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PauseSyncT&lt;/code&gt;：本节点是同步的目标端，但同步过程当前被暂停。出现这种状态的原因可能是当前同步进程依赖于另一个同步进程完成，或者使用&lt;code&gt;drbdadm pause-sync&lt;/code&gt;手动中断了同步操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VerifyS&lt;/code&gt;：正在进行在线设备验证，且本节点将成为验证的源端。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VerifyT&lt;/code&gt;：正在进行在线设备验证，且本节点将成为验证的目标端。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在drbd9中，WFConnection状态改为connecting状态。删除了WFReportParams状态。添加了以下几个同步相关的状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Off&lt;/code&gt;：该卷组还未同步，因为连接未建立。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Established&lt;/code&gt;：&lt;strong&gt;&lt;span&gt;所有对该卷组的写操作已经在线完成同步。这是drbd正常运行时的状态。&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ahead&lt;/code&gt;：数据同步操作被挂起，因为网络套接字中达到了一定的堵塞程度，无法应付更多的负载。该状态需要配置&quot;on-congestion&quot;选项来启用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Behind&lt;/code&gt;：对端将数据同步操作挂起，因为网络套接字中达到了一定的堵塞程度，无法应付更多的负载。该状态需要在对端节点上配置&quot;on-congestion&quot;选项来启用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-2-roles-ro-&quot;&gt;2.2 角色状态(roles,ro)&lt;/h2&gt;
&lt;p&gt;资源的角色状态既可以从/proc/drbd文件中获取，也可以使用下面的命令来获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@drbd1&lt;/span&gt; ~]
Primary/Unknown
Primary/Unknown
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在角色状态信息中，本地节点总是标记在第一位，远程节点标记在结尾。&lt;/p&gt;
&lt;p&gt;可能的节点角色状态有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Primary&lt;/code&gt;：资源的primary角色，该角色状态下的drbd设备可以进行挂载、读、写等。在没有启用多主复制模型(dual-primary mode)，只能有一个primary节点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Secondary&lt;/code&gt;：资源的secondary角色。该角色状态下的drbd设备会接收来自primary端的数据更新(除非和对端不是primary)。且该角色的drbd设备不可挂载、不可读、不可写。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unknown&lt;/code&gt;：资源的角色未知。本地节点的角色状态绝对不可能会是这种状态。只有对端节点断开连接时对端节点才处于Unknown状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-3-disk-state-ds-&quot;&gt;2.3 磁盘状态(disk state,ds)&lt;/h2&gt;
&lt;p&gt;磁盘的状态既可以从/proc/drbd文件中获取，也可以使用下面的命令来获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;span class=&quot;hljs-preprocessor&quot;&gt;# drbdadm dstate &lt;span class=&quot;hljs-title&quot;&gt;&amp;lt;resource&amp;gt;&lt;/span&gt;&lt;/span&gt;
UpToDate/UpToDate
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在磁盘状态信息中，本地节点的磁盘状态总是标记在第一位，远程节点标记在结尾。这两端节点的状态信息都可能为以下值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Diskless&lt;/code&gt;：没有为DRBD驱动分配底层块设备。这意味着资源可能从没有和它的底层块设备进行关联绑定(attach)，也可能是手动detach解除了关联，还可能是出现了底层IO错误时自动detach。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Attaching&lt;/code&gt;：读取元数据时的一个短暂的状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Failed&lt;/code&gt;：本地块设备故障时的一个短暂的状态，下一个状态是:Diskless。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Negotiating&lt;/code&gt;：在已连接的DRBD设备上还要进行Attach时的一个短暂的状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Inconsistent&lt;/code&gt;：数据不一致。在双方节点(还未进行全盘同步之前)刚创建新的资源时会立即进入此状态。在某一端(目标段)正接收同步数据时，也会进入不一致状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Outdated&lt;/code&gt;：资源的数据是一致的，但是数据过期了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DUnknown&lt;/code&gt;：用于标识对端节点没有连接时的磁盘状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Consistent&lt;/code&gt;：连接断开时的数据处于一致性状态，当连接建立后，将决定数据是UpToDate还是Outdated状态。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UpToDate&lt;/code&gt;：资源的数据是一致的，且数据是最新的。这是drbd数据正常时的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-4-io-&quot;&gt;2.4 IO状态标记&lt;/h2&gt;
&lt;p&gt;IO状态标记表示的是当前资源的IO操作状态。共有6种状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;IO挂起&lt;/code&gt;：r或s都可能表示IO挂起，一般是r。r=running，s=suspended。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;串行重新同步&lt;/code&gt;：资源正在等待进行重新同步，但被&lt;code&gt;resync-after&lt;/code&gt;选项延迟了同步进度。该状态标记为&quot;a&quot;，通常该状态栏应该处于&quot;-&quot;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;对端初始化同步挂起&lt;/code&gt;：资源正在等待进行重新同步，但对端节点因为某些原因而IO挂起。该状态标记为&quot;p&quot;，通常该状态栏应该处于&quot;-&quot;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;本地初始化同步挂起&lt;/code&gt;：资源正在等待进行重新同步，但本节点因为某些原因而IO挂起。该状态标记为&quot;u&quot;，通常该状态栏应该处于&quot;-&quot;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;本地IO阻塞&lt;/code&gt;：通常该状态栏应该处于&quot;-&quot;。可能有以下几种标记：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;d&lt;/code&gt;：因为DRBD内部原因导致的IO阻塞。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;b&lt;/code&gt;：后端设备正处于IO阻塞。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt;：网络套接字阻塞。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;：网络套接字和后端块设备同时处于阻塞状态。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Activity Log更新挂起&lt;/code&gt;：当al更新被挂起时，处于该状态，标记为&quot;s&quot;，通常该状态栏应该处于&quot;-&quot;。(如果不知道什么是Active Log，请无视本标记)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;主要是一些计数器和计量器的值。&lt;/p&gt;
&lt;p&gt;请结合drbd原理图进行理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201803/733013-20180329153010222-1008430710.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;drbd84中使用缩写符号来标记性能指标，而drbd9中使用全称来表示。例如drbd84中的ns和drbd9中的send是同一个意思。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ns/send (network send)&lt;/code&gt;：通过网络连接发送给对端的数据量，单位为Kb。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nr/receive (network receive)&lt;/code&gt;：通过网络连接接收到对端发送来的数据量，单位为Kb。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dw/written (disk write)&lt;/code&gt;：该卷(volume)写入本地磁盘的数据量，单位为Kb。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dr/read (disk read)&lt;/code&gt;：该卷(volume)从本地磁盘读取的数据量，单位为Kb。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;al/al-writes (activity log)&lt;/code&gt;：元数据区中al更新的次数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bm/bm-writes (bit map)&lt;/code&gt;：元数据区中bitmap更新的次数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lo/lower-pending (local count)&lt;/code&gt;：DRBD发起的打开本地IO子系统的请求次数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pe/pending (pending)&lt;/code&gt;：本地发送给对端但却没有回复的次数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ua/unacked (unacknowledged)&lt;/code&gt;：接收到对端发送的请求但却没有给予回复的请求数量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ap/upper-pending (application pending)&lt;/code&gt;：转发给DRBD的IO块的请求，但DRBD还没给予回复的请求数量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ep (epochs)&lt;/code&gt;:epoch对象的数量。通常为1。drbd9中没有该指标。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wo/write-ordering (write order)&lt;/code&gt;:当前正在使用的write order方法：b(barrier), f(flush), d(drain)或n(none)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;oos/out-of-sync (out of sync)&lt;/code&gt;:当前不同步的数据量，单位为Kb。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面所有&quot;未给予回复&quot;的指标数量都表示动作还未完成，需要回复后才表示操作完成。这些未回复数值不能太大。&lt;/p&gt;
&lt;p&gt;此外，drbd9中添加了以下几个指标：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;resync-suspended&lt;/code&gt;：重新同步操作当前是否被挂起。可能的值为no/user/peer/dependency。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blocked&lt;/code&gt;：本地IO的拥挤情况。
&lt;ul&gt;&lt;li&gt;&lt;code&gt;no&lt;/code&gt;：本地IO不拥挤。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;upper&lt;/code&gt;：DRBD层之上的IO被阻塞。例如到文件系统上的IO阻塞。可能有以下几种原因：
&lt;ul&gt;&lt;li&gt;管理员使用&lt;code&gt;drbdadm suspend-io&lt;/code&gt;命令挂起了IO操作。&lt;/li&gt;
&lt;li&gt;短暂的IO阻塞，例如attach/detach导致的。&lt;/li&gt;
&lt;li&gt;删除了缓冲区。&lt;/li&gt;
&lt;li&gt;bitmap的IO等待。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lower&lt;/code&gt;：底层设备处于拥挤状态。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8684648.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8684648.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 15:00:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8684648.html</dc:identifier>
</item>
<item>
<title>fcode-页面九宫格自动锁屏jquery插件 - 修德己</title>
<link>http://www.cnblogs.com/lovefc/p/fcode.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lovefc/p/fcode.html</guid>
<description>&lt;h3&gt;fcode.js 自动锁屏插件&lt;/h3&gt;
&lt;p&gt;&lt;a class=&quot;fancybox&quot; href=&quot;https://t1.picb.cc/uploads/2018/03/31/2iZQfs.png&quot; rel=&quot;data-fancybox-gallery&quot;&gt;&lt;img src=&quot;https://t1.picb.cc/uploads/2018/03/31/2iZQfs.png&quot; alt=&quot;fcode-index&quot; width=&quot;600&quot;/&gt;&lt;/a&gt;&lt;a class=&quot;fancybox&quot; href=&quot;https://t1.picb.cc/uploads/2018/03/31/2iZ3Ue.jpg&quot; rel=&quot;data-fancybox-gallery&quot;&gt;&lt;img src=&quot;https://t1.picb.cc/uploads/2018/03/31/2iZ3Ue.jpg&quot; alt=&quot;fcode&quot; width=&quot;600&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;fcode.js是什么？&lt;/h4&gt;
&lt;p&gt;fcode.js是一款web页面九宫格自动锁屏js插件，依赖于jquery，&lt;/p&gt;
&lt;p&gt;会在设置的范围里，判断用户有无操作，然后执行锁屏的功能。&lt;/p&gt;
&lt;p&gt;就一个js文件，配置简单，操作方便，可以锁住任何页面，还支持在手机端的锁屏。&lt;/p&gt;
&lt;p&gt;此外，还支持更新密码，或者用来登录，都有相关的说明，特别简单，相信您看一下，就会明白！&lt;/p&gt;
&lt;p&gt;演示地址：&lt;a href=&quot;http://fcphp.cn/fcode&quot;&gt;http://fcphp.cn/fcode&lt;/a&gt;   demo请在http方式下访问&lt;/p&gt;
&lt;p&gt;码云地址：&lt;a title=&quot;https://gitee.com/lovefc/fcode&quot; href=&quot;https://gitee.com/lovefc/fcode&quot; target=&quot;_blank&quot;&gt;https://gitee.com/lovefc/fcode&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GITHUB  : &lt;a title=&quot;https://github.com/lovefc/fcode&quot; href=&quot;https://github.com/lovefc/fcode&quot; target=&quot;_blank&quot;&gt;https://github.com/lovefc/fcode&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;如何使用fcode？&lt;/h4&gt;
&lt;div class=&quot;solarized-dark&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
  &amp;lt;script src=&quot;js/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  
  &amp;lt;script src=&quot;js/fcode.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  
  &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
         fcode.Start(123); 
  &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;因为是使用的九宫格，所以密码就是对应着数字123456789，最上面一排从左到右代表1，2，3，中间代表4，5，6，最后一排代表7，8，9 所以相应的密码也要如此设置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;fcode的基本配置&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;fcode.js的基本配置非常简单，一看便知，便不多做介绍&lt;span class=&quot;hljs-tag&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;&lt;span class=&quot;hljs-value&quot;&gt;&lt;span class=&quot;http&quot;&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;solarized-dark&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
   &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;span&gt;        
       fcode.bgColor &lt;/span&gt;= '#FFF'; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;背景颜色&lt;/span&gt;
&lt;span&gt;
        fcode.fontColor &lt;/span&gt;= '#666';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;圆环颜色&lt;/span&gt;
&lt;span&gt;
        fcode.lineColor &lt;/span&gt;= &quot;#333&quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;连线的颜色&lt;/span&gt;
&lt;span&gt;
        fcode.lineErrorColor &lt;/span&gt;= &quot;#00a254&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连线错误颜色&lt;/span&gt;
&lt;span&gt;
        fcode.lineSuceessColor &lt;/span&gt;= &quot;#cc1c21&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连续正确颜色&lt;/span&gt;
&lt;span&gt;
        fcode.Time &lt;/span&gt;= 10;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;锁屏的时间,单位s&lt;/span&gt;
&lt;span&gt;
        fcode.bgImage &lt;/span&gt;= 'images/time.jpg'; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置背景图片，优先于背景颜色&lt;/span&gt;
&lt;span&gt;
        fcode.customHtml &lt;/span&gt;= 'lovefc';&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义九宫格解锁上方的html内容&lt;/span&gt;
&lt;span&gt;        
        fcode.Start(&lt;/span&gt;'123');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动运行&lt;/span&gt;
    &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里重点介绍一下fcode.Start这个函数的设置，这个函数是启动功能的，参数可以是密码，md5加密的密码，或者是一个api接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.普通密码形式。&lt;/p&gt;
&lt;div class=&quot;solarized-dark&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   fcode.Start('123');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动运行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这种方式，就是代表第一排滑动解锁，简单方便，缺点是能看到源码（虽然我已经屏蔽了源码查看，f12，右键查看的功能）&lt;/p&gt;
&lt;p&gt;2.md5加密形式，其实就是把上面的123md5加密一下，是小写的md5 32位加密方式，可以随便找个工具加密一下就行了，比如用这个，&lt;a href=&quot;http://tool.chinaz.com/tools/md5.aspx&quot;&gt;http://tool.chinaz.com/tools/md5.aspx&lt;/a&gt; 这种方式安全多了，而且可以免去配置api接口，不需要额外的脚本就能运行&lt;/p&gt;
&lt;div class=&quot;solarized-dark&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   fcode.Start('202cb962ac59075b964b07152d234b70');&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动运行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;3.第三种方式就是api接口形式的了，目前只提供了php的接口参考（本人做php的），地址一定要填写完整的接口地址，例如 &lt;a href=&quot;http://127.0.0.1/status.php&quot;&gt;http://127.0.0.1/status.php&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;solarized-dark&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   fcode.Start('http://127.0.0.1/status.php');
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;接口设计也是非常简单，没有什么复杂的地方，一看便知&lt;/p&gt;
&lt;div class=&quot;solarized-dark&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
  &amp;lt;?&lt;span&gt;php
   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 
    * 用来验证锁屏密码 
    * author:lovefc
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
 
   &lt;span&gt;$pwd&lt;/span&gt; = &lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_POST&lt;/span&gt;['pwd']) ? &lt;span&gt;$_POST&lt;/span&gt;['pwd']:&lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取传过来的密码&lt;/span&gt;

   &lt;span&gt;$time&lt;/span&gt; = &lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$_POST&lt;/span&gt;['time']) ? (int) &lt;span&gt;$_POST&lt;/span&gt;['time'] : 60;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取传过来的时间&lt;/span&gt;

  &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;empty&lt;/span&gt;(&lt;span&gt;$pwd&lt;/span&gt;)){      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;比对密码,看看是否相等&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;$pwd&lt;/span&gt;==1235789){          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置cookies,加上时间&lt;/span&gt;
          &lt;span&gt;setcookie&lt;/span&gt;(&quot;fcode_status&quot;,'lovefc', &lt;span&gt;time&lt;/span&gt;()+&lt;span&gt;$time&lt;/span&gt;);          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返会并输出ok&lt;/span&gt;
          &lt;span&gt;die&lt;/span&gt;('ok'&lt;span&gt;);
      }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;4.兼容性说明,测试支持ie10,ie11，火狐,谷歌!&lt;/p&gt;

&lt;p&gt;ps：本人原创的一款jquery插件！&lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 14:24:00 +0000</pubDate>
<dc:creator>修德己</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lovefc/p/fcode.html</dc:identifier>
</item>
<item>
<title>KS检验统计量的扩展应用（CMap） - dedication</title>
<link>http://www.cnblogs.com/datamining-bio/p/8684420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/datamining-bio/p/8684420.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;span&gt;KS检验统计量的扩展应用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　KS（Kolmogorov-Smirnov）检验是比较两个经验分布之间是否存在差异。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们设&lt;em&gt;X&lt;/em&gt;&lt;em&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;, X&lt;/em&gt;&lt;em&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;,&lt;/em&gt;&lt;em&gt;…, X&lt;/em&gt;&lt;em&gt;&lt;sub&gt;m&lt;/sub&gt;&lt;/em&gt;, &lt;em&gt;Y&lt;/em&gt;&lt;em&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;, Y&lt;/em&gt;&lt;em&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;,…, Y&lt;/em&gt;&lt;em&gt;&lt;sub&gt;m&lt;/sub&gt;&lt;/em&gt;为两个独立随机样本，分别满足假设&lt;em&gt;A&lt;/em&gt;&lt;em&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;和&lt;em&gt;A&lt;/em&gt;&lt;em&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;，分布函数分别为&lt;em&gt;F&lt;/em&gt;, &lt;em&gt;G&lt;/em&gt;。现在我们想知道的是&lt;em&gt;X&lt;/em&gt;和&lt;em&gt;Y&lt;/em&gt;的概率分布之间是否存在差异，我们建立以下假设&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;H&lt;sub&gt;0&lt;/sub&gt;：&lt;em&gt;F(&lt;/em&gt;&lt;em&gt;t&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;&lt;em&gt; &lt;/em&gt;=&lt;em&gt; G(t)&lt;/em&gt;,  for every &lt;em&gt;t&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;H&lt;sub&gt;1&lt;/sub&gt;：&lt;em&gt;F(&lt;/em&gt;&lt;em&gt;t&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;&lt;em&gt; &lt;/em&gt;≠&lt;em&gt; G(t)&lt;/em&gt;,  for at least one &lt;em&gt;t&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来我们要计算&lt;strong&gt;双边双样本统计量&lt;em&gt;J&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先我们需要获得&lt;em&gt;X&lt;/em&gt;,&lt;em&gt;Y&lt;/em&gt;样本的经验分布函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于任意一个实数&lt;em&gt;t&lt;/em&gt;, 有&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214307527-1487439135.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214347056-463719264.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;称&lt;em&gt;F&lt;/em&gt;&lt;em&gt;&lt;sub&gt;m&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;(&lt;/em&gt;&lt;em&gt;t&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;和&lt;em&gt;G&lt;/em&gt;&lt;em&gt;&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;(t)&lt;/em&gt;分别为样本&lt;em&gt;X&lt;/em&gt;和&lt;em&gt;Y&lt;/em&gt;的经验分布函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;d = greatest common divisor of &lt;em&gt;m&lt;/em&gt; and &lt;em&gt;n&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则统计量&lt;em&gt;J&lt;/em&gt;为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214416257-1771140976.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为了对于给定的样本X和Y精确地计算统计量J，我们将&lt;em&gt;X&lt;/em&gt;&lt;em&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;, X&lt;/em&gt;&lt;em&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;,&lt;/em&gt;&lt;em&gt;…, X&lt;/em&gt;&lt;em&gt;&lt;sub&gt;m&lt;/sub&gt;&lt;/em&gt;, &lt;em&gt;Y&lt;/em&gt;&lt;em&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;, Y&lt;/em&gt;&lt;em&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;,…, Y&lt;/em&gt;&lt;em&gt;&lt;sub&gt;n&lt;/sub&gt;&lt;/em&gt; 共N=(m+n)个样本观察值从小到大排序，得到Z&lt;sub&gt;(&lt;/sub&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;sub&gt;)&lt;/sub&gt; ≤ … ≤ Z&lt;sub&gt;(N)&lt;/sub&gt;，则统计量J的计算公式可以改写为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214447674-420288129.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设显著性水平为α，则当J≥j&lt;sub&gt;α&lt;/sub&gt;时拒绝H&lt;sub&gt;0&lt;/sub&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们举一个简单的例子，如下图1有两组数据，分别为有反馈和无反馈的观察值（不用弄清楚具体什么含义），两组样本量均为10.&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214532346-2104917014.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有&lt;em&gt;m&lt;/em&gt; = &lt;em&gt;n&lt;/em&gt; = 10,&lt;em&gt; N&lt;/em&gt; = (10 + 10) = 20，&lt;em&gt;d&lt;/em&gt; = 10，如下图2我们将这20个样本值排序，计算&lt;em&gt;F&lt;/em&gt;&lt;em&gt;&lt;sub&gt;10&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;(&lt;/em&gt;&lt;em&gt;t&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;, &lt;em&gt;G&lt;/em&gt;&lt;em&gt;&lt;sub&gt;10&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;(t)&lt;/em&gt;，以及差异的绝对值|&lt;em&gt;F&lt;/em&gt;&lt;em&gt;&lt;sub&gt;10&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;(Z&lt;/em&gt;&lt;em&gt;&lt;sub&gt;(i)&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;-&lt;em&gt;G&lt;/em&gt;&lt;em&gt;&lt;sub&gt;10&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;(Z&lt;/em&gt;&lt;em&gt;&lt;sub&gt;(i)&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;)&lt;/em&gt;|&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214547818-1917270776.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们发现样本差异最大的点在&lt;em&gt;Z&lt;/em&gt;&lt;em&gt;&lt;sub&gt;(&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;&lt;sub&gt;12&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;&lt;sub&gt;)&lt;/sub&gt;&lt;/em&gt;,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214640341-300224684.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;em&gt;Z&lt;/em&gt;&lt;em&gt;&lt;sub&gt;(&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;&lt;sub&gt;12&lt;/sub&gt;&lt;/em&gt;&lt;em&gt;&lt;sub&gt;)&lt;/sub&gt;&lt;/em&gt;处，观测值为2.69，在有反馈的那组，小于等于2.69的有3个观察值，无反馈的那组小于等于2.69的有9个观察值，它们之间的差异为6/10。统计量&lt;em&gt;J&lt;/em&gt;=6.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们发现KS检验是计算两个样本之间每个观察值的排序差异，即为一种排序相似性，CMap（生物信息常用的一种数据库）基于KS检验这样的一种性质，设计了一种基于排序的模式匹配算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们通过一个例子说明这种匹配算法。现在我们有两种数据，一种是药物作用下基因的表达值，一种是疾病状态下基因的表达值，表达值都是一些实数，基因在疾病状态下，某些基因表达量增加，而某些基因可能减少表达。我们的目的是通过这两种数据来看这种药物对这种疾病有没有潜在的治疗可能，我们判断的依据：疾病状态下如果使某些基因（或某个基因）的表达值增加，即不在正常状态下，而这些基因在药物作用下，表达值在正常水平以下，即该药物会抑制这些基因的表达，那么我们可以推断，如果得这种疾病，这些基因表达值高于正常水平，我们再使用那些可以抑制这些基因表达的药物，可能就会使这些基因的表达量降下来，从而达到治病的效果。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214719364-1054794144.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们来计算药物A对疾病D是否有治疗作用。如图3所示，我们将药物A作用下的表达值从小到大排序，疾病D状态下的基因表达值从大到小排序。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214750512-1335400033.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　图4所示，我们接下来从疾病D的数据中选出前/后S个，然后再与药物A所有基因求交集，得到Num个共同基因（记该集合为B），我们再根据这些基因在药物A下的表达值从小到大排序。接下来，我们用基于ks统计量的方法，计算Num个共同基因在药物和疾病之间的排序相似性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214839006-1908739860.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　if  a &amp;gt; b   KS&lt;sub&gt;Top/Bottom&lt;/sub&gt; = a&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　else       KS&lt;sub&gt;Top/Bottom&lt;/sub&gt; = -b&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　if  KS&lt;sub&gt;Top&lt;/sub&gt; * KS&lt;sub&gt;Bottom&lt;/sub&gt; &amp;lt; 0,   score = KS&lt;sub&gt;Top&lt;/sub&gt; – KS&lt;sub&gt;Bottom&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　else  score = 0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中i表示集合B中的第i个基因，Num表示集合B中基因个数，i_position表示基因i在药物A数据中的排序，geneNum表示药物A的基因总数，即M。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们先来看看图5所示top的情况。如果想让a取值大，那么i_position就应该尽可能的小，也就是说，存在一个基因G，该基因在疾病数据中为top，同时在药物数据中也在top的位置，我们称这种模式为top-top模式。如果希望b值较大，则i_position应该尽可能的大，这就说明，存在一个基因G`，它在疾病数据中为top，但在药物数据中为bottom，称这种情况为bottom-top模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　接下来我们看看图6的bottom情况。同样的，如果想让a取值较大，那么i_position就应该尽可能的小，也就是说，存在一个基因G，该基因在疾病数据中为bottom，但是在药物数据中处于top的位置，我们称这种模式为top-bottom模式。如果希望b值较大，则i_position应该尽可能的大，这就说明，存在一个基因G`，它在疾病数据中为bottom，同时在药物数据中也为bottom，称这种情况为bottom-bottom模式。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214928962-340823708.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 5&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331214945266-2003119409.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　根据上面解析，有四种模式，组合后也有四种模式，如下图7所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331215010815-1199662299.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331215031449-504801259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331215044925-1392225108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331215102891-1875919668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中第二和第三中模式匹配是没有意义的，比如第二种，top-bottom，bottom-bottom模式匹配，它说明有些基因在疾病状态下表达值增加，但是在药物作用下有些也会增加，有些减少，那么我们对该疾病作用该种药物，则会引起一些基因表达恢复正常，但是会使另一些基因表达量继续增加，可能会导致某些症状更严重。第一种匹配，top-top，bottom-bottom，则说明在疾病状态下表达值增加或减少的基因，在药物作用下刚好相反，那么这种药物就有治疗该疾病的潜在可能。第四种匹配：top-bottom，bottom-top，说明，在疾病状态下表达值增加或减少的基因，在该药物作用下也增加或减少，说明该药物的作用和疾病类似，即该药物绝对不能用于治疗该疾病。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们要选出第一和第四种匹配，这就要“-b”起作用了，第一种情况下，我们的KS&lt;sub&gt;Top&lt;/sub&gt; = a, KS&lt;sub&gt;Bottom&lt;/sub&gt; = -b，第四种情况刚好相反，它们刚好满足异号的条件，所以上面“-b”的作用是为了找出这两种匹配模式。那么我们如何知道药物A是可以治疗疾病D呢，还是加剧病情的呢？因为score=KS&lt;sub&gt;Top&lt;/sub&gt;-KS&lt;sub&gt;Bottom&lt;/sub&gt;，所以第一种情况，即治疗疾病，score是正数，而第四种情况，加剧病情，score为负数。并且score的绝对值越大，说明作用效果越明显（明显改善或明显加剧）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们再来看看计算b的公式，它将i减了1，即将集合B中的基因位置向前推了一位，这是为什么呢？我们看下图8的情况。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1362527/201803/1362527-20180331215135026-1073998294.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;图 8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当基因Q刚好在疾病中位于第N个，在药物数据中位于第M个，也就是说，该基因在疾病状态下被抑制，表达量非常少，而在药物作用下产生促进表达作用，表达量增加很多，很明显，该药物对该疾病的治疗效果应该很好，称为该疾病的特效药的可能性也很高，如果我们在计算b的时候，不减1，那么b=0，后面的异号条件也不满足，那么我们就漏掉了很好的这种情况，为了避免，就将集合B的基因位置向前推一个。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;M. Hollander, D. Wolfe, &lt;em&gt;Nonparametric Statistical Methods&lt;/em&gt; (Wiley, ed. 2,1999), pp. 178-185.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Lamb J, Crawford E D, Peck D, et al. The Connectivity Map: Using Gene-Expression Signatures to Connect Small Molecules, Genes, and Disease[J]. Science, 2006, 313(5795):1929-1935.&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 13:57:00 +0000</pubDate>
<dc:creator>dedication</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/datamining-bio/p/8684420.html</dc:identifier>
</item>
<item>
<title>ReentrantLock 与 AQS 源码分析 - lwen</title>
<link>http://www.cnblogs.com/lwen/p/8684307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwen/p/8684307.html</guid>
<description>&lt;h2 id=&quot;基本结构&quot;&gt;1. 基本结构&lt;/h2&gt;
&lt;p&gt;   重入锁 ReetrantLock，JDK 1.5新增的类，作用与synchronized关键字相当，但比synchronized更加灵活。ReetrantLock本身也是一种支持重进入的锁，即该锁可以支持一个线程对资源重复加锁，但是加锁多少次，就必须解锁多少次，这样才可以成功释放锁。&lt;/p&gt;
&lt;h3 id=&quot;继承&quot;&gt;1. 继承&lt;/h3&gt;
&lt;p&gt;没有继承任何类，因为很多操作都使用了组合完成。&lt;/p&gt;
&lt;h3 id=&quot;实现&quot;&gt;2. 实现&lt;/h3&gt;
&lt;p&gt;Lock, java.io.Serializable&lt;br/&gt;  这里着重介绍一下 Lock 接口，接口定义了几个必要的方法，也是在 ReentrantLock 中的重点需要分析的方法。&lt;br/&gt;   三类方法：获取锁、释放锁、获取条件。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;interface&lt;/span&gt; Lock {
    &lt;span class=&quot;co&quot;&gt;// 阻塞获取锁，如果获取不到锁就一直等待&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;();
    &lt;span class=&quot;co&quot;&gt;// 可中断获取锁，在获取锁的过程可以被中断，但是 Synchronized 是不可以&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lockInterruptibly&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; InterruptedException;
    &lt;span class=&quot;co&quot;&gt;// 非阻塞获取锁，没有获取到锁立即返回&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryLock&lt;/span&gt;();
    &lt;span class=&quot;co&quot;&gt;// 超时获取锁，没获取到锁等待一段时间&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryLock&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; time, TimeUnit unit) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; InterruptedException;
    &lt;span class=&quot;co&quot;&gt;// 解锁&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;unlock&lt;/span&gt;();
    &lt;span class=&quot;co&quot;&gt;// 等待唤醒机制的条件&lt;/span&gt;
    Condition &lt;span class=&quot;fu&quot;&gt;newCondition&lt;/span&gt;();
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面可以看到 Synchronized 和 Lock 的一些重要区别：&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Lock 的获取锁的过程是可以中断的，Synchronized 不可以，Synchronized 只能在 wait或同步代码块执行过程中才可以被中断。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;由于 Lock 显示的加锁，锁可以横跨几个方法，也就是临界区的位置可以更加自由。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Lock 支持超时获取锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;后面会看到 Lock 还支持公平及非公平锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;绑定多个 Condition 条件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;主要字段&quot;&gt;3. 主要字段&lt;/h3&gt;
&lt;p&gt;  很好，这个类的字段非常的少，真正起作用的字段只有一个 “锁” 字段。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;// 同步锁&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Sync sync;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   这个锁（Sync）是一个继承自 AQS 的抽象内部类，说明一下 AQS (AbstractQueuedSynchronizer) 一般被称为队列同步器，他是并发包中的核心组件，绝大多数锁机制都是采用的这个类来实现的。虽然看到他是一个抽象类，但是你会发现里面没有一个方法是抽象方法，他实现了锁机制中的必要的通用的方法，待会会专门讲这个类。不然 ReentrantLock 没办法说，ReentrantLock 里面的锁操作都是依赖于 AQS。&lt;/p&gt;
&lt;p&gt;   然后这个锁是有两个子类，分别是 &lt;code&gt;NonfairSync&lt;/code&gt; 和 &lt;code&gt;FairSync&lt;/code&gt; 从名字上也可以看出这两个类分别代表了 &lt;code&gt;公平锁&lt;/code&gt; 和 &lt;code&gt;非公平锁&lt;/code&gt; 。何为锁的公平性？ 实际上就是新来的线程需要征用锁必须要要等到先于他到达的线程获取并释放锁。也就是获取锁的过程是按照下来后到的顺序进行的，反之就称为非公平锁。后面我们会看到其实这两种锁不同就在于非公平锁在新线程创建后首先会直接进行锁的获取，如果没有获取到会进行一段时间的自旋，始终没获取到锁才进行等待状态。&lt;/p&gt;
&lt;p&gt;   一般而言，公平锁开销比非公平锁大，这也是比较符合我们的直观感受。公平锁是需要进行排队的，但在某些场景下，可能更注重时间先后顺序，那么公平锁自然是很好的选择。&lt;/p&gt;
&lt;p&gt;   好总结一下，在 ReentrantLock 中只维护了一个 “锁” 变量，这个锁是继承了 AQS 同步器，然后这个锁又有两种派生的锁：公平锁，非公平锁。那么 ReentrantLock 实现其实就有两种方式：公平锁，非公平锁。&lt;/p&gt;
&lt;h3 id=&quot;主要方法概览&quot;&gt;4. 主要方法概览&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;ctor-2&lt;/li&gt;
&lt;li&gt;lock&lt;/li&gt;
&lt;li&gt;lockInterruptibly&lt;/li&gt;
&lt;li&gt;tryLock&lt;/li&gt;
&lt;li&gt;tryLock(time)&lt;/li&gt;
&lt;li&gt;unlock&lt;/li&gt;
&lt;li&gt;newCondition&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;基础并发组件-aqs&quot;&gt;2. 基础并发组件 AQS&lt;/h2&gt;
&lt;h3 id=&quot;基本字段&quot;&gt;1. 基本字段&lt;/h3&gt;
&lt;h4 id=&quot;重要字段&quot;&gt;1. 重要字段&lt;/h4&gt;
&lt;p&gt;   AQS 是维护了一个同步队列（双向链表），这个队列里面线程都是需要竞争锁的，没有竞争到的就在同步队列中等待。&lt;code&gt;head&lt;/code&gt; 和 &lt;code&gt;tail&lt;/code&gt; 就指向队列的首尾。&lt;code&gt;state&lt;/code&gt; 是一个标志字段，表示当前有多少线程在临界区。一般来说 &lt;code&gt;state&lt;/code&gt; 只能是 0 或 1 但是由于锁是可重入的，所以也有大于 1 的情况。&lt;/p&gt;
&lt;p&gt;   除了一个同步队列还有 0~n 个等待队列，等待队列就是调用了 &lt;code&gt;await&lt;/code&gt; 方法的线程，会被挂到调用了 &lt;code&gt;await&lt;/code&gt; 的 &lt;code&gt;condition&lt;/code&gt; 上面的等待队列，所以有多少个 &lt;code&gt;condition&lt;/code&gt; 就有多少等待队列。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;//同步队列头指针&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; Node head;
    &lt;span class=&quot;co&quot;&gt;// 同步队列尾指针&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;transient&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; Node tail;
    &lt;span class=&quot;co&quot;&gt;// 状态标志，0 则没有线程在临界区，非零表示有 state 个线程在临界区（由于锁可重入）&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; state;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;node-节点&quot;&gt;2. Node 节点&lt;/h4&gt;
&lt;p&gt;  Node 节点也就是上文所提到的 &lt;code&gt;同步队列&lt;/code&gt; 和 &lt;code&gt;等待队列&lt;/code&gt; 中的元素，注意两个队列之间的元素类型是一样的因为他们之间会有相互移动转换的动作，这两个队列中的元素自然是线程，为了方便查找和表示 AQS 将线程封装到了 Node 节点中，构成双向队列。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Node {
        &lt;span class=&quot;co&quot;&gt;// 共享非 null/独占为 null  &lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node SHARED = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Node();
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node EXCLUSIVE = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

        &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * 线程状态&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         */&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CANCELLED =  &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; SIGNAL    = -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; CONDITION = -&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
        &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; PROPAGATE = -&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; waitStatus;
       &lt;span class=&quot;co&quot;&gt;// 双向链表  这两个指针用于同步队列构建链表使用的   下面还有一个 nextWaiter 是用来构建等待单链表队列&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; Node prev;
        &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; Node next;
        &lt;span class=&quot;co&quot;&gt;// 线程&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;volatile&lt;/span&gt; Thread thread;
        &lt;span class=&quot;co&quot;&gt;// 等待队列单链表&lt;/span&gt;
        Node nextWaiter;

        &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         * Returns true if node is waiting in shared mode.&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;         */&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;isShared&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; nextWaiter == SHARED;
        }

    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   可以看到上面有一个 &lt;code&gt;waitStatus&lt;/code&gt; 属性，代表了线程当前的状态，状态标识就是那些常量。具体如下：&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;SIGNAL: 正在执行的线程结束释放锁或者被取消执行，他必须唤醒后续的状态为 SIGNAL 节点&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;CANCELLED: 在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点， 其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;CONDITION: 该标识的结点处于等待队列中（不是同步队列），结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PROPAGATE:在共享模式中，该状态标识结点的线程处于可运行状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;0:代表初始化状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;   可以看到，Node 里面的主要字段就是一个状态标志位、一个线程的引用、用于构建链表的指针。注意，有三个指针，其中前两个 &lt;code&gt;next&lt;/code&gt; 和 &lt;code&gt;pre&lt;/code&gt; 是用来构建同步队列的（双向链表），后面 &lt;code&gt;nextWaiter&lt;/code&gt; 是用来构建等待队列。所以说虽然同步队列和等待队列使用的同一个数据类型，数据结构是不同的，并且在后面我们会看到等待队列中的节点只有两种状态 &lt;code&gt;Condition&lt;/code&gt; 和 &lt;code&gt;CANCELLED&lt;/code&gt; 前者表示线程已结束需要从等待队列中移除，后者表示条件结点等待被唤醒。&lt;/p&gt;
&lt;p&gt;  下面画图说明一下同步队列和等待队列的情况。&lt;br/&gt;等待队列&lt;br/&gt;&lt;img src=&quot;http://ojrw3x8j2.bkt.clouddn.com/18-3-30/81487339.jpg&quot;/&gt;&lt;br/&gt;同步队列&lt;br/&gt;&lt;img src=&quot;http://ojrw3x8j2.bkt.clouddn.com/18-3-30/91260714.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;conditionobject&quot;&gt;3. ConditionObject&lt;/h4&gt;
&lt;p&gt;   这个内部类是等待唤醒机制的核心，在他上面绑定了一个等待队列。在这个类中使用了两个指针（ &lt;code&gt;firstWaiter/lastWaiter&lt;/code&gt; ）指向队列的首尾。这里主要看一下 &lt;code&gt;await&lt;/code&gt; 、&lt;code&gt;signal&lt;/code&gt; 和 &lt;code&gt;signalAll&lt;/code&gt; 方法。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;await&lt;br/&gt;   当一个线程调用了await()相关的方法，那么首先构建一个Node节点封装当前线程的相关信息加入到等待队列中进行等待，并释放锁直到被唤醒（移动到同步队列）、中断、超时才被队列中移出。被唤醒后的第一件事是抢锁和检查是否被中断，然后才是移除队列。被唤醒时候的状态应该为 SIGNAL ，而在方法中执行的移除队列的操作就是移除状态非 Condition 的节点。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;await&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; InterruptedException {
            &lt;span class=&quot;co&quot;&gt;// 等待可中断&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (Thread.&lt;span class=&quot;fu&quot;&gt;interrupted&lt;/span&gt;())
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; InterruptedException();
            &lt;span class=&quot;co&quot;&gt;// 加入等待队列， new 新的 Node 做一个尾插入&lt;/span&gt;
            Node node = &lt;span class=&quot;fu&quot;&gt;addConditionWaiter&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;// 释放当前线程的锁，失败则将当前线程设置为取消状态&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; savedState = &lt;span class=&quot;fu&quot;&gt;fullyRelease&lt;/span&gt;(node);

            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; interruptMode = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
            &lt;span class=&quot;co&quot;&gt;// 如果没在同步队列就让线程等待也就是看是否被唤醒&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 如果有中断或者被唤醒那么退出循环&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;isOnSyncQueue&lt;/span&gt;(node)) {
                LockSupport.&lt;span class=&quot;fu&quot;&gt;park&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;);
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ((interruptMode = &lt;span class=&quot;fu&quot;&gt;checkInterruptWhileWaiting&lt;/span&gt;(node)) != &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
                    &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
            }
            &lt;span class=&quot;co&quot;&gt;// 运行到此处说明已经被唤醒了，因为结束了循环&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 唤醒后，首先自旋一下获取锁，同时判断是否中断&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;acquireQueued&lt;/span&gt;(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
                interruptMode = REINTERRUPT;
            &lt;span class=&quot;co&quot;&gt;// 清理队列中状态不是 Condition 的的任务，包括被唤醒的 SIGNAL 和 被取消的 CANCELLED&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (node.&lt;span class=&quot;fu&quot;&gt;nextWaiter&lt;/span&gt; != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                &lt;span class=&quot;fu&quot;&gt;unlinkCancelledWaiters&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;//被中断 抛异常&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (interruptMode != &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
                &lt;span class=&quot;fu&quot;&gt;reportInterruptAfterWait&lt;/span&gt;(interruptMode);
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;signal/doSignal/signalAll&lt;br/&gt;   执行 signal 首先进行锁的判断，如果没有获取到独占锁就直接抛出异常。这也就是为什么只有拥有锁的线程才能执行 signal ，然后获取等待队列中的第一个节点执行 doSignal。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;signal&lt;/span&gt;() {
            &lt;span class=&quot;co&quot;&gt;// 获取独占锁&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;isHeldExclusively&lt;/span&gt;())
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalMonitorStateException();
            &lt;span class=&quot;co&quot;&gt;// 唤醒等待队里中的第一个线程&lt;/span&gt;
            Node first = firstWaiter;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (first != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                &lt;span class=&quot;fu&quot;&gt;doSignal&lt;/span&gt;(first);
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   doSignal 方法主要就干了三个事 ：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将被唤醒的节点从等待队列中移除（while 循环体），如果被唤醒的节点被取消了就继续唤醒后面的节点（transferForSignal 返回 false）&lt;/li&gt;
&lt;li&gt;否则把这个节点加入到同步队列 （ enq 方法 ）&lt;/li&gt;
&lt;li&gt;当同步队列中当前节点的前驱被取消或者没办法唤醒时则唤醒这个线程 （ unpark ），这时候调用了 unpark 正好和 await 中的 park 相对应使得 await 的线程被唤醒，接着执行循环体判断自己已经被移入到同步队列了，接着就可以执行后面的获取锁的操作。&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt; &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;doSignal&lt;/span&gt;(Node first) {
            &lt;span class=&quot;kw&quot;&gt;do&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;// 头指针指向唤醒节点的下一个节点，并顺便判断等待队列是否空&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; ( (firstWaiter = first.&lt;span class=&quot;fu&quot;&gt;nextWaiter&lt;/span&gt;) == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                    lastWaiter = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                &lt;span class=&quot;co&quot;&gt;// 解除引用&lt;/span&gt;
                first.&lt;span class=&quot;fu&quot;&gt;nextWaiter&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            } &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;transferForSignal&lt;/span&gt;(first) &amp;amp;&amp;amp; (first = firstWaiter) != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;); &lt;span class=&quot;co&quot;&gt;//移入同步队列失败则继续唤醒下一个线程，否则唤醒成功&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 唤醒成功的线程不一定马上能开始执行，只有在前驱节点被取消或者没办法被唤醒时&lt;/span&gt;
   }
   
   
   &lt;span class=&quot;co&quot;&gt;//  将节点从等待队列移动到同步队列   成功返回 true 失败 false&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;transferForSignal&lt;/span&gt;(Node node) {
        &lt;span class=&quot;co&quot;&gt;// 在等待队列中的节点只有 condition 和 cancelled 两种状态，如果状态更新失败说明任务被取消&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 否则更新为初始状态   直接返回的话上面的 doSignal 就会继续唤醒后面的线程&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;compareAndSetWaitStatus&lt;/span&gt;(node, Node.&lt;span class=&quot;fu&quot;&gt;CONDITION&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;))
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
        &lt;span class=&quot;co&quot;&gt;// 把当前节点加入同步队列&lt;/span&gt;
        Node p = &lt;span class=&quot;fu&quot;&gt;enq&lt;/span&gt;(node);
        &lt;span class=&quot;co&quot;&gt;// 获取同步队列中倒数第二个节点的状态，当前节点的前驱&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ws = p.&lt;span class=&quot;fu&quot;&gt;waitStatus&lt;/span&gt;;
        &lt;span class=&quot;co&quot;&gt;// 如果前驱节点被取消或者在设置前驱节点状态为Node.SIGNAL状态失败时，唤醒被通知节点代表的线程&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ws &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; || !&lt;span class=&quot;fu&quot;&gt;compareAndSetWaitStatus&lt;/span&gt;(p, ws, Node.&lt;span class=&quot;fu&quot;&gt;SIGNAL&lt;/span&gt;))
            LockSupport.&lt;span class=&quot;fu&quot;&gt;unpark&lt;/span&gt;(node.&lt;span class=&quot;fu&quot;&gt;thread&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
    }
    
    
    &lt;span class=&quot;co&quot;&gt;// 插入一个节点到同步队列，如果同步队列是空的则加入一个空节点做为头结点&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 死循环保证肯定能插入    返回插入节点的前驱&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Node &lt;span class=&quot;fu&quot;&gt;enq&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node node) {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (;;) {
            Node t = tail;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (t == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) { &lt;span class=&quot;co&quot;&gt;// Must initialize&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;compareAndSetHead&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Node()))
                    tail = head;
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;// 这一步不需要 cas 是因为并发没关系，只是指向链表结尾，不会多线程更新问题&lt;/span&gt;
                node.&lt;span class=&quot;fu&quot;&gt;prev&lt;/span&gt; = t;
                &lt;span class=&quot;co&quot;&gt;// 可能有多个线程抢&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;compareAndSetTail&lt;/span&gt;(t, node)) {
                    t.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = node;
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; t;
                }
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   有一个小问题,就是在某个线程中执行了别人的 signal 不会导致当前线程立即放弃锁，之所以会这样正是由于 &lt;code&gt;ws &amp;gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)&lt;/code&gt; 这个判断，即前驱线程都结束了。比如下面的例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package util.AQSTest;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.TimeUnit;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.locks.Condition;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.locks.Lock;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.concurrent.locks.ReentrantLock;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// test signal 执行后不会导致当前线程立即释放锁&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; AQSTest {
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Lock lock = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ReentrantLock();
   &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Condition run1Cond = lock.&lt;span class=&quot;fu&quot;&gt;newCondition&lt;/span&gt;();
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Condition run2Cond = lock.&lt;span class=&quot;fu&quot;&gt;newCondition&lt;/span&gt;();

    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Runner1 &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Runnable {
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
            lock.&lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;runner 1 start&quot;&lt;/span&gt;);
                run1Cond.&lt;span class=&quot;fu&quot;&gt;await&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, TimeUnit.&lt;span class=&quot;fu&quot;&gt;SECONDS&lt;/span&gt;);
                run2Cond.&lt;span class=&quot;fu&quot;&gt;signal&lt;/span&gt;();
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;runner 1 exit&quot;&lt;/span&gt;);
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
                lock.&lt;span class=&quot;fu&quot;&gt;unlock&lt;/span&gt;();
            }

        }
    }

    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Runner2 &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; Runnable {
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
            lock.&lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;runner 2 start&quot;&lt;/span&gt;);
                run2Cond.&lt;span class=&quot;fu&quot;&gt;await&lt;/span&gt;();
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;runner 2 exit&quot;&lt;/span&gt;);
            } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {
                e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
            }&lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
                lock.&lt;span class=&quot;fu&quot;&gt;unlock&lt;/span&gt;();
            }

        }
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Runner1&lt;/span&gt;(),&lt;span class=&quot;st&quot;&gt;&quot;runner1&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;Runner2&lt;/span&gt;(),&lt;span class=&quot;st&quot;&gt;&quot;runner2&quot;&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出的结果始终是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;runner 1 start
runner 2 start
runner 1 exit
runner 2 exit&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;   我使用了工具对上面的代码进行了调试，大致说一下流程，顺便用来捋一捋等待唤醒机制。&lt;/p&gt;
&lt;p&gt;   首先 runner1 启动，获取到锁，打印出 “runner1 start” ，然后调用了 await 方法，此时 runner1 线程就执行了 AQS 中的 ConditionObject 中的 await 方法，该方法首先 new 了一个新的节点，把 runner1 封装到这个节点里面。挂在了 run1Con 的等待队列上，然后执行了释放锁并判断中断。紧接着 runner1 线程执行循环体判断是否被唤醒也就是是否在同步队列，显然这时候不在，就直接调用了 park 方法，执行休眠 1 秒钟操作， park 方法是 native 方法由操作系统实现。在上面线程释放锁的时候执行的操作是 &lt;code&gt;fullyRelease&lt;/code&gt; 这个方法调用了 &lt;code&gt;release&lt;/code&gt; 方法，而 &lt;code&gt;release&lt;/code&gt; 方法中释放了锁之后，会检查同步队列中是否还有以前因为没抢到锁而等待的线程，如果有执行 &lt;code&gt;unparkSuccessor&lt;/code&gt; 也就是唤醒同步队列中的后继线程。那么此时 runner2 会被唤醒，唤醒后就去抢锁，获取到 lock 锁后输出了 “runner2 start” ，然后 runner2 线程又会因为调用 &lt;code&gt;await&lt;/code&gt; 处于和 runner1 同样的境地，也就是被放入 run2Con 的等待队列。好！此时 runner1 的超时时间到了，就会被 unpark 这个 unpark 是被操作系统调用的，之后继续执行循环体发现超时时间小于等于 0 ，则调用 &lt;code&gt;transferAfterCancelledWait&lt;/code&gt; 里面调用了 &lt;code&gt;enq&lt;/code&gt; 就是加入同步队列，接着开始竞争锁，开始执行 run2Con 上的 signal 此时 signal 调用 doSignal 先执行 do while 中的循环体，runner2 从 run2Con 的等待队列上移除，然后执行 &lt;code&gt;transferForSignal&lt;/code&gt; 里面又调用了 &lt;code&gt;enq&lt;/code&gt; 将他加入同步队列，并返回同步队列中的前驱，前驱节点状态不是 Cancelled 或者 可以被置为 SIGNAL 则 signal 方法结束。接着打印了 “runner1 exit” 。接着需要执行 finally 里面的释放锁的操作了，显然 unlock 肯定调用了 release ，而 release 会唤醒同步队列中的后继的线程，那么位于同步队列中的 runner2 之前的 park 状态就会被打断，从而跳出 while 循环，执行获取锁的操作。打印出 “runner2 exit” ，最后释放锁整个程序结束。&lt;/p&gt;
&lt;p&gt;   现在总算是吧 Condition 的等待唤醒机制弄清楚了。也把 AQS 中的两个内部类的功能都解释完了。接下来就看 AQS 中的方法。&lt;/p&gt;
&lt;h3 id=&quot;重要方法&quot;&gt;2. 重要方法&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;get/setState&lt;/li&gt;
&lt;li&gt;release/tryRelease/unparkSuccessor/fullyRelease&lt;/li&gt;
&lt;li&gt;acquire/tryAcquire/addWaiter/tryQueued&lt;/li&gt;
&lt;li&gt;acquireShared&lt;/li&gt;
&lt;li&gt;releaseShared&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;   这些属于 AQS 中常用的方法，但是里面的核心方法都是模板方法，也就是说由继承他的子类来实现，所以只能看个大概的逻辑。一会等到讲 ReentrantLock 时再详细说这里面的方法。&lt;/p&gt;
&lt;h2 id=&quot;reentrantlock-内部类-syncfairsyncnofairsync&quot;&gt;3. ReentrantLock 内部类 Sync/fairSync/noFairSync&lt;/h2&gt;
&lt;h3 id=&quot;sync&quot;&gt;1. Sync&lt;/h3&gt;
&lt;p&gt;   这三个内部类实际上是继承自 AQS ，也就是说 ReentrantLock 是采用了 AQS 作为自己的核心并发控制组件完成的一系列的锁操作，及等待唤醒机制。&lt;/p&gt;
&lt;p&gt;   首先看一下 Sync 他是后面两个的父类，他直接继承自 AQS 。AQS 中留了几个比较重要的模板方法 tryAcquire 、tryRelease 。这个方法直接实现了一些在公平锁和非公平锁中的通用操作，也就是释放锁的操作 tryRelease 。&lt;/p&gt;
&lt;p&gt;   tryRelease 的实现很简单，主要就是依赖于 AQS 中的 state 属性，如果state 值减去要释放的信号量为 0 则释放成功，否则失败。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;        &lt;span class=&quot;co&quot;&gt;// 释放锁的公共操作&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryRelease&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; releases) {
            &lt;span class=&quot;co&quot;&gt;// 释放锁首先就是使用 AQS 中的 state 的值减去信号量 判断是否为0&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 如果是 0 则表明成功释放锁，独占线程设为 null，否则说明还占用锁&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c = &lt;span class=&quot;fu&quot;&gt;getState&lt;/span&gt;() - releases;
            &lt;span class=&quot;co&quot;&gt;// 必须获取到锁才能解锁，否则抛异常&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;() != &lt;span class=&quot;fu&quot;&gt;getExclusiveOwnerThread&lt;/span&gt;())
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalMonitorStateException();
            &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; free = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (c == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                free = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
                &lt;span class=&quot;fu&quot;&gt;setExclusiveOwnerThread&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;);
            }
            &lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(c);
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; free;
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;fairsync&quot;&gt;2. fairSync&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;amp;emsp;&amp;amp;emsp;  公平锁执行 lock 操作就是执行了 AQS 中的 acquire(1) 也就是请求一个锁资源。但是注意，在 AQS 中的 acquire 中的 tryAcquire 方法没有实现，所以必须由当前类实现。

&amp;amp;emsp;&amp;amp;emsp;  在 tryAcquire 中做的事情就是看是否有代码在临界区。没有则还要看同步队列中是否有线程等待，当只有这一个线程在获取锁的时候才能正常的获取锁，其他情况都失败。&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 公平锁&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; FairSync &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Sync {
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;() {
            &lt;span class=&quot;fu&quot;&gt;acquire&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        }

        &lt;span class=&quot;co&quot;&gt;// 没有代码在临界区或者是当前线程的重入 则获取成功，否则失败&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryAcquire&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; acquires) {
            &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Thread current = Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;();
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c = &lt;span class=&quot;fu&quot;&gt;getState&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;// 如果当前线程在获取锁的过程没有其他线程在临界区&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (c == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                &lt;span class=&quot;co&quot;&gt;// 如果同步队列中没有等待的线程，就设置 state ，并且当前线程设为独占线程&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;hasQueuedPredecessors&lt;/span&gt;() &amp;amp;&amp;amp; &lt;span class=&quot;fu&quot;&gt;compareAndSetState&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, acquires)) {
                    &lt;span class=&quot;fu&quot;&gt;setExclusiveOwnerThread&lt;/span&gt;(current);
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
                }
            }
            &lt;span class=&quot;co&quot;&gt;// 有程序在临界区，如果是当前线程可重入，加上请求的资源数&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (current == &lt;span class=&quot;fu&quot;&gt;getExclusiveOwnerThread&lt;/span&gt;()) {
                &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; nextc = c + acquires;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (nextc &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
                    &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Error(&lt;span class=&quot;st&quot;&gt;&quot;Maximum lock count exceeded&quot;&lt;/span&gt;);
                &lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(nextc);
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
            }
            &lt;span class=&quot;co&quot;&gt;// 竞争锁失败，因为他是公平的锁竞争&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;nofairsync&quot;&gt;3. noFairSync&lt;/h3&gt;
&lt;p&gt;同理，这个方法也需要实现 lock 和 tryAcquire 操作。在 lock 中直接判断是否有代码在临界区，没有则直接获取到锁，与公平锁不同的是：公平锁还判断了等待队列中是否有等待的线程。有在临界区的情况时执行 acquire 操作。同样的，首先要执行 tryAcquire 如果失败，加入同步队列并自旋获取锁。还是 tryAcquire 的实现，这里又调用了 nonfairTryAcquire。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;// 非公平锁&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; NonfairSync &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Sync {
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;() {
            &lt;span class=&quot;co&quot;&gt;// 如果没有代码在临界区 直接获取锁，独占&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;compareAndSetState&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;))
                &lt;span class=&quot;fu&quot;&gt;setExclusiveOwnerThread&lt;/span&gt;(Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;());
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
            &lt;span class=&quot;co&quot;&gt;// 有代码在临界区则执行尝试获取锁&lt;/span&gt;
                &lt;span class=&quot;fu&quot;&gt;acquire&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        }

        &lt;span class=&quot;co&quot;&gt;// 和公平锁中的 tryAcquire 一模一样只是少了关于同步队列中是否有等待线程的判断&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;tryAcquire&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; acquires) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;nonfairTryAcquire&lt;/span&gt;(acquires);
        }
    }
    
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;nonfairTryAcquire&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; acquires) {
            &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Thread current = Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;();
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; c = &lt;span class=&quot;fu&quot;&gt;getState&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;// 没有线程获取锁 直接获取到锁  和公平锁中的 tryAcquire 一模一样只是少了关于同步队列的判断&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (c == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;compareAndSetState&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, acquires)) {
                    &lt;span class=&quot;fu&quot;&gt;setExclusiveOwnerThread&lt;/span&gt;(current);
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
                }
            }
            &lt;span class=&quot;co&quot;&gt;// 重入锁&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (current == &lt;span class=&quot;fu&quot;&gt;getExclusiveOwnerThread&lt;/span&gt;()) {
                &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; nextc = c + acquires;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (nextc &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;// overflow&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Error(&lt;span class=&quot;st&quot;&gt;&quot;Maximum lock count exceeded&quot;&lt;/span&gt;);
                &lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(nextc);
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
            }
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   好了，现在我们 AQS 中的空的核心方法也被子类实现了，那么现在 fairSync 和 noFairSync 就算是一个完整的 AQS 了。此时看一下加解锁的流程。&lt;/p&gt;
&lt;p&gt;只说公平锁，因为非公平锁就只是少了一个判断。&lt;/p&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先 sync 调用 lock 方法，让后 lock 调用了 AQS 的 acquire(1) 也就是获取一个锁资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;acquire 就先调用 tryAcquire(1) 尝试获取锁，这时候代码又回调到 sync 中的实现的 tryAcquire 方法，这个方法先判断锁是否已经被别的线程使用，然后需要确定没有更早的线程在同步队列等待获取锁，才把当前线程设置为独占线程，并设置 state 值获取锁。但是如果有代码在临界区需要判断是否为当前线程，因为锁是可重入的。如果是当前线程则 state 加上请求锁的个数，返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这时候又回到 AQS 中，如果上面尝试获取锁的过程失败，就需要调用 addWaiter 将当前线程封装成一个独占节点，等待状态默认为 0，并且返回当前节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;加入同步队列后，再调用 acquireQueued 方法，当此线程是同步队列中等待的第一个线程则自旋尝试获取锁，毕竟很可能正在执行的线程马上就会释放锁了，再进行休眠不合适。如果自旋获取锁失败则判断节点状态是否为 SIGNAL 然后执行等待操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;锁获取成功则把当前节点设置为头结点，把 thread = null&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;至此，Acquire 方法执行结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后调用 unlock 方法解锁操作。&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;解锁操作就没那么麻烦，首先还是调用到了 AQS 中的 release 方法，这个方法首先尝试解锁当前线程，又回调到了 sync 中的 tryRelease 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;tryRelease 逻辑比较简单，使用 AQS 中的 state 减去释放的资源数，等于 0 代表完全释放，否则释放失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果 tryRelease 成功执行就要去唤醒同步队列中的后继节点，继续执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;至此，release 方法执行完毕。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;aqs-中的要方法&quot;&gt;4. AQS 中的要方法&lt;/h2&gt;
&lt;h3 id=&quot;getsetstate&quot;&gt;1. get/setState&lt;/h3&gt;
&lt;p&gt;  这两个方法主要是对 state 变量的 volatile 的读写，其实里面就就是普通的 get/set 方法。但是注意的一点就是 state 是 volatile 的。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;co&quot;&gt;// 对状态变量的 volatile 读写&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;getState&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; state;
    }
    &lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; newState) {
        state = newState;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;releasetryreleaseunparksuccessorfullyrelease&quot;&gt;2. release/tryRelease/unparkSuccessor/fullyRelease&lt;/h3&gt;
&lt;p&gt;   这几个方法在一起说主要是因为他们之间存在调用链，首先来看 release 这个方法我们在上面也分析了，里面调用了 tryRelease 、unparkSuccessor。 也就是首先调用 tryRelease 来释放当前线程的锁，如果释放成功就调用 unparkSuccessor 来唤醒同步队列中后继节点。其中 tryRelease 是由子类来实现，里面的主要逻辑就是看当前的 state 变量的值在修改过后是否为0 。这里还有一个 fullRelease 主要是在 ConditionObject 中调用的，当执行 await 的操作的时会执行此方法释放锁。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt; &lt;span class=&quot;co&quot;&gt;//  尝试释放锁&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;release&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; arg) {
        &lt;span class=&quot;co&quot;&gt;// 如果释放锁成功 唤醒同步队列中的后继节点&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;tryRelease&lt;/span&gt;(arg)) {
            Node h = head;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (h != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h.&lt;span class=&quot;fu&quot;&gt;waitStatus&lt;/span&gt; != &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
                &lt;span class=&quot;fu&quot;&gt;unparkSuccessor&lt;/span&gt;(h);
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
    }
    
    &lt;span class=&quot;co&quot;&gt;// 唤醒同步队列中的后继节点&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;unparkSuccessor&lt;/span&gt;(Node node) {
        &lt;span class=&quot;co&quot;&gt;// node 一般就是当前正在运行的线程&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ws = node.&lt;span class=&quot;fu&quot;&gt;waitStatus&lt;/span&gt;;
        &lt;span class=&quot;co&quot;&gt;// 当前线程置为初始状态   可以失败&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (ws &amp;lt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
            &lt;span class=&quot;fu&quot;&gt;compareAndSetWaitStatus&lt;/span&gt;(node, ws, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;);
        &lt;span class=&quot;co&quot;&gt;// 找到同步队列中的下一个节点&lt;/span&gt;
        Node s = node.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (s == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; || s.&lt;span class=&quot;fu&quot;&gt;waitStatus&lt;/span&gt; &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {  &lt;span class=&quot;co&quot;&gt;//没有下一个节点或者被取消&lt;/span&gt;
            s = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            &lt;span class=&quot;co&quot;&gt;// 从后往前找第一个没有被取消的线程&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (Node t = tail; t != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; t != node; t = t.&lt;span class=&quot;fu&quot;&gt;prev&lt;/span&gt;)
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (t.&lt;span class=&quot;fu&quot;&gt;waitStatus&lt;/span&gt; &amp;lt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
                    s = t;
        }
        &lt;span class=&quot;co&quot;&gt;// 唤醒那个线程&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (s != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            LockSupport.&lt;span class=&quot;fu&quot;&gt;unpark&lt;/span&gt;(s.&lt;span class=&quot;fu&quot;&gt;thread&lt;/span&gt;);
    }
    
    &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;fullyRelease&lt;/span&gt;(Node node) {
        &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; failed = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; savedState = &lt;span class=&quot;fu&quot;&gt;getState&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;release&lt;/span&gt;(savedState)) {
                failed = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; savedState;
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; IllegalMonitorStateException();
            }
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (failed)
                node.&lt;span class=&quot;fu&quot;&gt;waitStatus&lt;/span&gt; = Node.&lt;span class=&quot;fu&quot;&gt;CANCELLED&lt;/span&gt;;
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;acquiretryacquireaddwaiteracquirequeued&quot;&gt;3. acquire/tryAcquire/addWaiter/acquireQueued&lt;/h3&gt;
&lt;p&gt;这个和上面的一样，在执行了 acquire 后，会去调用子类复写的 tryAcquire 方法，这个方法就是看有否有代码块在临界区，没有的话直接获取锁（非公平锁），设置 state，有的话要判断是不是当前线程能否进行重入操作，否则就获取失败。失败后会调用 addWaiter ，new 一个新的节点加入到同步队列，接着调用了 acquireQueued 如果这个节点是同步队列中的第一个等待的线程（但不是第一个节点，因为第一个节点是 thread=null 的运行中的线程）就自旋一段时间看能否获取到锁。不能则 park 等待。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 获取锁&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;acquire&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; arg) {
        &lt;span class=&quot;co&quot;&gt;// 尝试获取锁 失败则加入同步队列 如果是同步队列中的第一个线程就自旋获取锁&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 上面的步骤的自旋获取锁阶段，返回的是是否需要中断，所以下面就进行 selfInterrupt&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// tryAcquire 是模板方法，因为对于公平锁和非公平锁获取锁方式不同&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;fu&quot;&gt;tryAcquire&lt;/span&gt;(arg) &amp;amp;&amp;amp; &lt;span class=&quot;fu&quot;&gt;acquireQueued&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;addWaiter&lt;/span&gt;(Node.&lt;span class=&quot;fu&quot;&gt;EXCLUSIVE&lt;/span&gt;), arg))
            &lt;span class=&quot;fu&quot;&gt;selfInterrupt&lt;/span&gt;();
    }
    
    
    &lt;span class=&quot;co&quot;&gt;// 创建一个节点放入到同步对列中   可传入是否为独占锁   返回当前节点&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Node &lt;span class=&quot;fu&quot;&gt;addWaiter&lt;/span&gt;(Node mode) {
        &lt;span class=&quot;co&quot;&gt;// 默认的 status 是 0&lt;/span&gt;
        Node node = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Node(Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;(), mode);
        &lt;span class=&quot;co&quot;&gt;// Try the fast path of enq; backup to full enq on failure&lt;/span&gt;
        Node pred = tail;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (pred != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            node.&lt;span class=&quot;fu&quot;&gt;prev&lt;/span&gt; = pred;
            &lt;span class=&quot;co&quot;&gt;// 把 tail 设置为 node 成功说明没有竞争&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;compareAndSetTail&lt;/span&gt;(pred, node)) {
                pred.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = node;
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; node;
            }
        }
        &lt;span class=&quot;co&quot;&gt;// 失败则就说明空队列   创建头结点&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;enq&lt;/span&gt;(node);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; node;
    }
    
     &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;acquireQueued&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node node, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; arg) {
        &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; failed = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; interrupted = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
            &lt;span class=&quot;co&quot;&gt;// 自旋获取锁&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (;;) {
                &lt;span class=&quot;co&quot;&gt;// 获取前驱节点&lt;/span&gt;
                &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; Node p = node.&lt;span class=&quot;fu&quot;&gt;predecessor&lt;/span&gt;();
                &lt;span class=&quot;co&quot;&gt;// 如果前驱是空的头结点，那么也就是说当前线程就是队列中的第一个线程 并尝试获取锁  成功的话方法返回中断情况&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp; &lt;span class=&quot;fu&quot;&gt;tryAcquire&lt;/span&gt;(arg)) {
                    &lt;span class=&quot;co&quot;&gt;// 把当前节点设置为头结点  thread=null 也就可以看做当前线程在运行，所以就不在同步队列&lt;/span&gt;
                    &lt;span class=&quot;fu&quot;&gt;setHead&lt;/span&gt;(node);
                    &lt;span class=&quot;co&quot;&gt;// gc&lt;/span&gt;
                    p.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// help GC&lt;/span&gt;
                    failed = &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;;
                    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; interrupted;
                }
                &lt;span class=&quot;co&quot;&gt;// 如果获取锁失败，检测为 SIGNAL 或者设置为 SIGNAL 然后让此线程等待 等待操作在 parkAndCheckInterrupt 中完成&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;shouldParkAfterFailedAcquire&lt;/span&gt;(p, node) &amp;amp;&amp;amp; &lt;span class=&quot;fu&quot;&gt;parkAndCheckInterrupt&lt;/span&gt;())
                    interrupted = &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;;
            }
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;// 失败 取消&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (failed)
                &lt;span class=&quot;fu&quot;&gt;cancelAcquire&lt;/span&gt;(node);
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;总结&quot;&gt;5. 总结&lt;/h2&gt;
&lt;p&gt;   其实到这里 ReentrantLock 已经讲完了，因为他底层全部调用的是 Sync 中的方法，也就是全都是调用了 AQS 中的方法。而 AQS 中的大部分重要的方法都已经看过了。&lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 13:29:00 +0000</pubDate>
<dc:creator>lwen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwen/p/8684307.html</dc:identifier>
</item>
<item>
<title>New UWP Community Toolkit - Carousel - shaomeng</title>
<link>http://www.cnblogs.com/shaomeng/p/8678625.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shaomeng/p/8678625.html</guid>
<description>&lt;p&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;New UWP Community Toolkit  V2.2.0 的版本发布日志中提到了 Carousel 的调整，本篇我们结合代码详细讲解  Carousel 的实现。&lt;/p&gt;
&lt;p&gt;Carousel 是一种传送带形态的控件，在图片展示类的应用中有非常多的应用，它拥有很好的流畅度，可以做很多的自定义，并集成了鼠标，触摸板，键盘等的操作。我们来看一下官方的介绍和官网示例中的展示：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;The &lt;code&gt;Carousel&lt;/code&gt; control provides a new control, inherited from the &lt;code&gt;ItemsControl&lt;/code&gt;, representing a nice and smooth carousel.&lt;br/&gt;This control lets you specify a lot of properties for a flexible layouting.&lt;br/&gt;The &lt;code&gt;Carousel&lt;/code&gt; control works fine with mouse, touch, mouse and keyboard as well.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180331151522768-562134355.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Source: &lt;a href=&quot;https://github.com/Microsoft/UWPCommunityToolkit/tree/master/Microsoft.Toolkit.Uwp.UI.Controls/Carousel&quot; target=&quot;_blank&quot;&gt;https://github.com/Microsoft/UWPCommunityToolkit/tree/master/Microsoft.Toolkit.Uwp.UI.Controls/Carousel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Doc: &lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/uwpcommunitytoolkit/controls/carousel&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/windows/uwpcommunitytoolkit/controls/carousel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Namespace: &lt;em&gt;Microsoft.Toolkit.Uwp.UI.Controls&lt;/em&gt;; Nuget: &lt;em&gt;Microsoft.Toolkit.Uwp.UI.Controls&lt;/em&gt;;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;开发过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先来看看 Carousel 的类结构组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Carousel.cs - Carousel 控件类，继承自 ItemsControl&lt;/li&gt;
&lt;li&gt;Carousel.xaml - Carousel 的样式文件，包含了 Carousel，CarouselItem，CarouselPanel 的样式&lt;/li&gt;
&lt;li&gt;CarouselItem.cs - CarouselItem 是 Carousel 控件的列表中的选择器 ItemTemplate&lt;/li&gt;
&lt;li&gt;CarouselPanel.cs - CarouselPanel 是 Carousel 控件的 ItemPanelTemplate&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180331153359461-1864216607.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面来看一下几个主要类中的主要代码实现，因为篇幅关系，我们只摘录部分关键代码实现：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. Carousel.cs &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在具体分析代码前，我们先看看 Carousel 类的组成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180331162516738-433380038.jpg&quot; alt=&quot;&quot; width=&quot;550&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，作为一个集合类控件，Carousel 也注册了 SelectedItem 和 SelectedIndex 依赖属性，并且因为控件可以控制元素的深度，旋转角度，动画时长和类型，列表方向等，注册了 TransitionDuration，ItemDepth，EasingFunction，ItemMargin，ItemRotationX，Orientation 等依赖属性。而部分依赖属性的 PropertyChanged 事件由 OnCarouselPropertyChanged(d, e) 来实现；&lt;/p&gt;
&lt;p&gt;下面来看一下 Carousel 类的构造方法：&lt;/p&gt;
&lt;p&gt;构造方法中，首先设置了样式，Tab 导航模式；定义了鼠标滚轮，鼠标点击和键盘事件，并注册了数据源变化事件来得到正确的 SelectedItem 和 SelectedIndex。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Carousel()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set style&lt;/span&gt;
    DefaultStyleKey = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Carousel);
    SetValue(AutomationProperties.NameProperty, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Carousel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    IsHitTestVisible &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    IsTabStop &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    TabNavigation &lt;/span&gt;=&lt;span&gt; KeyboardNavigationMode.Once;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Events registered&lt;/span&gt;
    PointerWheelChanged +=&lt;span&gt; OnPointerWheelChanged;
    PointerReleased &lt;/span&gt;+=&lt;span&gt; CarouselControl_PointerReleased;
    KeyDown &lt;/span&gt;+=&lt;span&gt; Keyboard_KeyUp;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register ItemSource changed to get correct SelectedItem and SelectedIndex&lt;/span&gt;
    RegisterPropertyChangedCallback(ItemsSourceProperty, (d, dp) =&amp;gt;&lt;span&gt; { ... });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在键盘按键抬起的事件处理中，分别对应 Down，Up，Right 和 Left 做了处理，我们只截取了 Down 的处理过程；可以看到，如果列表方向为纵向，则 Down 按键会触发 SelectedIndex++，也就是当前选择项下移一位；对应其他三个按键也是类似的操作；OnPointerWheelChanged 的实现方式类似，这里不赘述；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Keyboard_KeyUp(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, KeyRoutedEventArgs e)
{
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (e.Key)
    {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Windows.System.VirtualKey.Down:
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Windows.System.VirtualKey.GamepadDPadDown:
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; Windows.System.VirtualKey.GamepadLeftThumbstickDown:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Orientation ==&lt;span&gt; Orientation.Vertical)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SelectedIndex &amp;lt; Items.Count - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                {
                    SelectedIndex&lt;/span&gt;++&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e.OriginalKey !=&lt;span&gt; Windows.System.VirtualKey.Down)
                {
                    FocusManager.TryMoveFocus(FocusNavigationDirection.Down);
                }

                e.Handled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        ...
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着看一下 PrepareContainerForItemOverride(element, item) 方法，它为 Item 设置了初始的 3D 旋转的中心点，Item 变换的中心点；并根据当前选择项确定 Item 是否被选中；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PrepareContainerForItemOverride(DependencyObject element, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; item)
{
    &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.PrepareContainerForItemOverride(element, item);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; carouselItem =&lt;span&gt; (CarouselItem)element;
    carouselItem.Selected &lt;/span&gt;+=&lt;span&gt; OnCarouselItemSelected;

    carouselItem.RenderTransformOrigin &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Point(&lt;span&gt;0.5&lt;/span&gt;, &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;);

    carouselItem.IsTabStop &lt;/span&gt;= Items.IndexOf(item) ==&lt;span&gt; SelectedIndex;
    carouselItem.UseSystemFocusVisuals &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

    PlaneProjection planeProjection &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PlaneProjection();
    planeProjection.CenterOfRotationX &lt;/span&gt;= &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;;
    planeProjection.CenterOfRotationY &lt;/span&gt;= &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;;
    planeProjection.CenterOfRotationZ &lt;/span&gt;= &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; compositeTransform = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CompositeTransform();
    compositeTransform.CenterX &lt;/span&gt;= &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;;
    compositeTransform.CenterY &lt;/span&gt;= &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;;
    compositeTransform.CenterZ &lt;/span&gt;= &lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;;

    carouselItem.Projection &lt;/span&gt;=&lt;span&gt; planeProjection;
    carouselItem.RenderTransform &lt;/span&gt;=&lt;span&gt; compositeTransform;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (item ==&lt;span&gt; SelectedItem)
    {
        carouselItem.IsSelected &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. Carousel.xaml&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如上面类结构介绍时所说，Carousel.xaml 是 Carousel 控件的样式文件；下面代码中我把非关键部分用 ‘...’ 代替了，可以看到，主要是两个部分的样式：CarouselItem 和 Carousel，CarouselPanel 作为 Carousel 的 ItemsPanelTemplate；Carousel 控件的 easing mode 是 'EaseOut'。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ResourceDictionary &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;&lt;/span&gt;&lt;span&gt;
                    xmlns:x&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;&lt;/span&gt;&lt;span&gt;
                    xmlns:local&lt;/span&gt;&lt;span&gt;=&quot;using:Microsoft.Toolkit.Uwp.UI.Controls&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Style &lt;/span&gt;&lt;span&gt;TargetType&lt;/span&gt;&lt;span&gt;=&quot;local:CarouselItem&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Template&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ControlTemplate &lt;/span&gt;&lt;span&gt;TargetType&lt;/span&gt;&lt;span&gt;=&quot;local:CarouselItem&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid &lt;/span&gt;&lt;span&gt;BorderBrush&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding BorderBrush}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; BorderThickness&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding BorderThickness}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; Background&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{TemplateBinding Background}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;VisualStateManager.VisualStateGroups&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            ...
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;VisualStateManager.VisualStateGroups&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ContentPresenter &lt;/span&gt;&lt;span&gt;&lt;span&gt;...&lt;/span&gt;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ControlTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Style &lt;/span&gt;&lt;span&gt;TargetType&lt;/span&gt;&lt;span&gt;=&quot;local:Carousel&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;ItemsPanel&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ItemsPanelTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;local:CarouselPanel &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ItemsPanelTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;EasingFunction&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ExponentialEase &lt;/span&gt;&lt;span&gt;EasingMode&lt;/span&gt;&lt;span&gt;=&quot;EaseOut&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter &lt;/span&gt;&lt;span&gt;Property&lt;/span&gt;&lt;span&gt;=&quot;Template&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ControlTemplate &lt;/span&gt;&lt;span&gt;TargetType&lt;/span&gt;&lt;span&gt;=&quot;local:Carousel&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;gt; &lt;br/&gt;...&lt;/span&gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ControlTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter.Value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ResourceDictionary&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3. CarouselItem.cs&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在前面 Carousel.xaml 中我们看到了 CarouselItem 的样式，有针对 VisualStateManager 的样式状态，而 CarouselItem 类则定义了这些状态变化事件对应的处理方法。分别有 OnIsSelectedChanged，OnPointerEntered，OnPointerExited 和 OnPointerPressed，在触发这些状态时，CarouselItem 会对应切换到那个状态时的样式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CarouselItem()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set style&lt;/span&gt;
    DefaultStyleKey = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(CarouselItem);
    RegisterPropertyChangedCallback(SelectorItem.IsSelectedProperty, OnIsSelectedChanged);
}

&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnPointerEntered(PointerRoutedEventArgs e) {...}

&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnPointerExited(PointerRoutedEventArgs e) {...}

&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnPointerPressed(PointerRoutedEventArgs e) {...}

&lt;/span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; EventHandler Selected;

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnIsSelectedChanged(DependencyObject sender, DependencyProperty dp)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; item =&lt;span&gt; (CarouselItem)sender;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (item.IsSelected)
    {
        Selected&lt;/span&gt;?.Invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, EventArgs.Empty);
        VisualStateManager.GoToState(item, SelectedState, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        VisualStateManager.GoToState(item, NormalState, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4. CarouselPanel.cs &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同样在具体分析代码前，我们先看看 CarouselPanel 类的组成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180331165019279-668884720.jpg&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt; &lt;/p&gt;
&lt;p&gt;CarouselPanel 类继承自 Panel 类，可以看到它接收的事件响应，有 OnTapped，OnManipulationDelta 和 OnManipulationCompleted，分别对应点按，触摸移动和移动结束的处理。其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;OnTapped 的处理主要是根据当前控件的可视化范围和尺寸，判断点击的点对应哪个元素被选中；&lt;/li&gt;
&lt;li&gt;OnManipulationDelta 则是根据触控操作的方向和量度等，决定 Item 的动画幅度，动画速度和每个元素变换状态，以及选中元素的变化；&lt;/li&gt;
&lt;li&gt;OnManipulationCompleted 则是在触控结束后，确定结束动画，以及结束时应该选中那个元素；&lt;/li&gt;
&lt;li&gt;UpdatePosition() 方法则是在 OnManipulationDelta 方法触发到 first 或 last 元素时，需要重新设置动画；&lt;/li&gt;
&lt;li&gt;GetProjectionFromManipulation(sender, e) 则是在 OnManipulationDelta 方法中，根据当前触控的手势，决定当前 Item 的 Projection；&lt;/li&gt;
&lt;li&gt;GetProjectionFromSelectedIndex(i) 是根据当前选中的索引，来取得 Item 的 Projection；&lt;/li&gt;
&lt;li&gt;ApplyProjection(element, proj, storyboard) 是应用获取到的 Projection，包括旋转，变换等动画；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而因为 CarouselPanel 类继承自 Panel 类，所以它也重写了 MeasureOverride(availableSize) 和 ArrangeOverride(finalSize) 方法：&lt;/p&gt;
&lt;p&gt;MeasureOverride(availableSize) 方法的实现中，主要是根据宽度和高度是否设置为无限值，如果是，且方向和元素排列顺序一致，则尺寸为当前方向三个元素的宽度，然后把计算后的尺寸传出去；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Size MeasureOverride(Size availableSize)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; containerWidth =&lt;span&gt; 0d;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; containerHeight =&lt;span&gt; 0d;

    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (FrameworkElement container &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Children)
    {
        container.Measure(availableSize);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; get containerWidth and containerHeight for max&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; width =&lt;span&gt; 0d;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; height =&lt;span&gt; 0d;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; It's a Auto size, so we define the size should be 3 items&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;.IsInfinity(availableSize.Width))
    {
        width &lt;/span&gt;= Carousel.Orientation == Orientation.Horizontal ? containerWidth * (Children.Count &amp;gt; &lt;span&gt;3&lt;/span&gt; ? &lt;span&gt;3&lt;/span&gt;&lt;span&gt; : Children.Count) : containerWidth;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        width &lt;/span&gt;=&lt;span&gt; availableSize.Width;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; It's a Auto size, so we define the size should be 3 items&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;.IsInfinity(availableSize.Height))
    {
        height &lt;/span&gt;= Carousel.Orientation == Orientation.Vertical ? containerHeight * (Children.Count &amp;gt; &lt;span&gt;3&lt;/span&gt; ? &lt;span&gt;3&lt;/span&gt;&lt;span&gt; : Children.Count) : containerHeight;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        height &lt;/span&gt;=&lt;span&gt; availableSize.Height;
    }

    Clip &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; RectangleGeometry { Rect = &lt;span&gt;new&lt;/span&gt; Rect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, width, height) };

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Size(width, height);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ArrangeOverride(finalSize) 方法则是排列元素的处理，因为 Carousel 控件有动画处理，所以在排列时需要考虑到元素排列的动画，以及 Zindex；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Size ArrangeOverride(Size finalSize)
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; centerLeft = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; centerTop = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    Clip &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; RectangleGeometry { Rect = &lt;span&gt;new&lt;/span&gt; Rect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, finalSize.Width, finalSize.Height) };

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; Children.Count; i++&lt;span&gt;)
    {
        FrameworkElement container &lt;/span&gt;= Children[i] &lt;span&gt;as&lt;/span&gt;&lt;span&gt; FrameworkElement;
        ...
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; get the good center and top position
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Get rect position
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Placing the rect in the center of screen&lt;/span&gt;
&lt;span&gt;        ...
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Get the initial projection (without move)&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; proj =&lt;span&gt; GetProjectionFromSelectedIndex(i);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; apply the projection to the current object&lt;/span&gt;
&lt;span&gt;        ApplyProjection(container, proj);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; calculate zindex and opacity&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; zindex = (Children.Count * &lt;span&gt;100&lt;/span&gt;) -&lt;span&gt; deltaFromSelectedIndex;
        Canvas.SetZIndex(container, zindex);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; finalSize;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;调用示例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例中我们实现了横向的 Carousel 控件，作为一个图片列表，可以看到当前选中的 Item 的 ZIndex 是最高的，向两侧依次降低，而在滑动过程中，伴随着 3D 和变换的动画，ZIndex 也会一起变化，而滑动结束时，选中项重新计算，每一项的 Project 也会重新计算。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;    &amp;lt;&lt;/span&gt;&lt;span&gt;Border &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:Carousel &lt;/span&gt;&lt;span&gt;x:Name&lt;/span&gt;&lt;span&gt;=&quot;CarouselControl&quot;&lt;/span&gt;&lt;span&gt;
            InvertPositive&lt;/span&gt;&lt;span&gt;=&quot;True&quot;&lt;/span&gt;&lt;span&gt;
            ItemDepth&lt;/span&gt;&lt;span&gt;=&quot;238&quot;&lt;/span&gt;&lt;span&gt;
            ItemMargin&lt;/span&gt;&lt;span&gt;=&quot;-79&quot;&lt;/span&gt;&lt;span&gt;
            ItemRotationX&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt;
            ItemRotationY&lt;/span&gt;&lt;span&gt;=&quot;9&quot;&lt;/span&gt;&lt;span&gt;
            ItemRotationZ &lt;/span&gt;&lt;span&gt;=&quot;-3&quot;&lt;/span&gt;&lt;span&gt;
            Orientation&lt;/span&gt;&lt;span&gt;=&quot;Horizontal&quot;&lt;/span&gt;&lt;span&gt;
            SelectedIndex&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:Carousel.EasingFunction&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;CubicEase &lt;/span&gt;&lt;span&gt;EasingMode&lt;/span&gt;&lt;span&gt;=&quot;EaseOut&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;controls:Carousel.EasingFunction&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;controls:Carousel.ItemTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DataTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Image &lt;/span&gt;&lt;span&gt;Width&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt;
                        Height&lt;/span&gt;&lt;span&gt;=&quot;200&quot;&lt;/span&gt;&lt;span&gt;
                        VerticalAlignment&lt;/span&gt;&lt;span&gt;=&quot;Bottom&quot;&lt;/span&gt;&lt;span&gt;
                        Source&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Thumbnail}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                        Stretch&lt;/span&gt;&lt;span&gt;=&quot;Uniform&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DataTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;controls:Carousel.ItemTemplate&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;controls:Carousel&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Border&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Grid&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180331172015205-1667140444.jpg&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/306530/201803/306530-20180331172023042-2126072544.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;到这里我们就把 UWP Community Toolkit 中的 Carousel 控件的源代码实现过程和简单的调用示例讲解完成了，希望能对大家更好的理解和使用这个控件有所帮助，让你的图片列表控件更加炫酷灵动。欢迎大家多多交流，谢谢！&lt;/p&gt;
&lt;p&gt;最后，再跟大家安利一下 UWPCommunityToolkit 的官方微博：&lt;em&gt;&lt;strong&gt;&lt;a href=&quot;https://weibo.com/u/6506046490&quot; target=&quot;_blank&quot;&gt;https://weibo.com/u/6506046490&lt;/a&gt;, &lt;/strong&gt;&lt;/em&gt;大家可以通过微博关注最新动态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;衷心感谢 UWPCommunityToolkit 的作者们杰出的工作，Thank you so much, UWPCommunityToolkit authors!!!&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 13:23:00 +0000</pubDate>
<dc:creator>shaomeng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shaomeng/p/8678625.html</dc:identifier>
</item>
<item>
<title>SpringMVC DispatcherServlet 启动和加载过程（源码调试） - cyhbyw</title>
<link>http://www.cnblogs.com/cyhbyw/p/8683251.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyhbyw/p/8683251.html</guid>
<description>&lt;p&gt;&lt;span&gt;在阅读本文前，最好先阅读以下内容（当然，如果对 Servlet 已经有所了解，则可跳过）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/cyhbyw/p/8682078.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cyhbyw/p/8682078.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/cyhbyw/p/8682307.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cyhbyw/p/8682307.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/cyhbyw/p/8682632.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/cyhbyw/p/8682632.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;============分隔线==========================&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在使用 SpringMVC 进行 Web 开发时，通常在 web.xml 中配置的 Servlet  都是 org.springframework.web.servlet.DispatcherServlet，那这个 DispatcherServlet 又是如何被 Tomcat 容器（或者其它容器）启动并加载进来的呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;带着这个问题，写了个简单Demo进行源码调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Demo代码地址：&lt;a href=&quot;https://github.com/cyhbyw/springMVC_atguigu_TongGang&quot; target=&quot;_blank&quot;&gt;https://github.com/cyhbyw/springMVC_atguigu_TongGang&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Demo代码工程：springMVC_DebugSourceCode&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先从静态代码的角度，可以看到 DispatcherServlet 类的承继结构如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;HttpServlet 及以上部分是 Servlet 标准中提供的接口及类&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;DispatcherServlet、FrameworkServlet、HttpServletBean 三者是 SpringMVC 提供的类，且后者依次分别是前者的父类&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331165721020-650688731.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在开始源码调试：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先调用了 DispatcherServlet 的构造函数，并且从堆栈信息中可以看出，这是由 Tomcat 调用的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331170324115-531855404.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来当然是调用父类 FrameworkServlet 的构造函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331170425085-388280181.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;构造函数完成后，调用 Servlet 生命周期的 init() 方法；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提示，此处是 HttpServletBean 中的 init() 方法重写了GenericServlet中的 init() 方法；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就是之前说的，建议重写这个空的 init() 方法而不建议重写那个 init(ServletConfig config) 方法，看来 SpringMVC 也确实是这样做的；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来代码走到 Line136行，初始化容器Bean&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331170657355-1878681594.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 接下来代码走到 Line493 行，初始化Web应用上下文&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331171314843-432641736.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 接下来代码走到 Line552 行，创建Web应用上下文&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331171532925-154654577.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取到需要创建的Bean的Class&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331171756970-1328645337.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直接调用 getContextClass() 方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331171833484-1780115004.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而它内置的 contextClass 其实就是 &lt;span&gt;XmlWebApplicationContext&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331172046019-807436389.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; XmlWebApplicationContext 的继承结构如下图所示，不用说，肯定也是 ApplicationContext 家庭中的成员&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331172120157-660318964.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Line627 行就实例化了 XmlWebApplicationContext &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同时，代码会走到 Line633 行，配置并刷新Web应用上下文&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331172336571-1500912354.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Line655 添加了一个应用监听器；（重要，后面会取出来用到）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331202946166-835342657.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意，这里（SourceFilteringListener类中）&lt;span&gt;方法入参处的 ApplicationListener delegate = FrameworkServlet$ContextRefreshListener&lt;/span&gt;，且 SourceFilteringListener 类&lt;span&gt;成员变量中的 GenericApplicationListener delegate = GenericApplicationListenerAdapter；&lt;span&gt;同时&lt;span&gt;方法入参中的 delegate 会被 GenericApplicationListenerAdapter 包装后赋值给成员变量的 delegate&lt;span&gt;（有点绕，所以用了三种颜色以示区分）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以这样来记忆或理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一、对于 SourceFilteringListener 来说，其成员变量 delegate 的类型是 GenericApplicationListenerAdapter &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二、对于 GenericApplicationListenerAdapter  来说，它也有个叫做 delegate 的成员变量，且这个 delegate 的类型是 FrameworkServlet$ContextRefreshListener&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（虽然这两个同名叫做 delegate 的成员变量有点绕，但它们比较重要，后面会用到）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331181020531-642730249.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SourceFilteringListener 构造完成后，回到上一层方法调用处；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来，代码走到 Line667 行进行刷新&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331173916823-1329823931.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个 refresh() 方法是 Spring 中非常重要的一个方法，会调用多个方法执行多个动作，包括初始化BeanFactory、容器后处理器处理、初始化MessageSource、注册监听器等动作；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;refresh() 方法非常重要！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;refresh() 方法非常重要！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;refresh() 方法非常重要！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里，暂时关心的是，它会读取我们为 SpringMVC 所编写的配置文件中的内容（如 annotation-driven &amp;amp; default-servlet-handler 等，这属于上一篇文章的内容，具体可参见 &lt;a href=&quot;http://www.cnblogs.com/cyhbyw/p/8625554.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;strong&gt;这里&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后，它会调用 Line541 行的方法，完成刷新&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331172718168-1292921303.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过几个方法的调用，代码走到 Line136 ，并且此处的 listener=SourceFilteringListener（通过 Line125 获取到&lt;span&gt;之前添加进来的&lt;/span&gt;Listener，且这个 listener=SourceFilteringListener）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331181412565-737674119.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 然后调用 SourceFilteringListener 的 onApplicationEvent() 方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331181716850-1657987747.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;继续调用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331181828568-543238784.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;继续调用，注意当前类是 &lt;span&gt;SourceFilteringListener&lt;/span&gt;，且这个 delegate=GenericApplicationListenerAdapter（就是&lt;span&gt;之前设置进来的&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331181950805-1125931580.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在来到 &lt;span&gt;GenericApplicationListenerAdapter&lt;/span&gt; 类中，注意此处的 delegate=FrameworkServlet$ContextRefreshListener（&lt;span&gt;之前设置进来的&lt;/span&gt;），所以，实际上会调到 ContextRefreshListener 的 onApplicationEvent() 方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331182039563-1692979324.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进而调用到 FrameworkServlet 中内部类 ContextRefreshListener  的 onApplicationEvent() 方法，而它又是直接调用到 FrameworkServlet  的 onApplicationEvent() 方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331182230260-208378502.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个方法会调用到 onRefresh() 方法；而 FrameworkServlet 的 onRefresh() 方法默认实现为空（让子类扩展）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331182335688-1047630501.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自然，会调用到 DispatcherServlet 的 onRefresh() 方法上，而这个方法实际上调用了其它的一系列初始化方法，如 initHandlerMappings(context) &amp;amp; initHandlerAdapters(context)，这样在容器启动的过程中，就已经初始化完成 HandlerMapping &amp;amp; HandlerAdapter&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/319547/201803/319547-20180331182522906-2076203830.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此，DispatcherServlet 中与 Servlet 生命周期相关的 constructor() &amp;amp; init() 方法就已经基本完成了，接下来，就是对请求的响应，这会依次调用 Servlet 的 service() 方法，不属于本文范畴啦~~~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;简单总结起来，Tomcat 容器启动并加载 DispatcherServlet 时所做的主要工作如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;调用 DispatcherServlet 的构造器（当然也会调用父类的构造器，不过构造器默认实现为空；这个动作很短，基本上可以忽略）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用 GenericServlet 的 init() 方法，不过，这被 HttpServletBean 重写了；同时，重写的 HttpServletBean  的 init() 方法调用了 initServletBean() 方法；而 initServletBean() 方法会完成以下操作：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;span&gt;初始化（创建）一个 WebApplicationContext（实际上是 WebApplicationContext 类）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;调用 AbstractApplicationContext 的 refresh() 方法，完成 BeanFactory创建、读取 SpringMVC 配置文件内容、处理容器后处理器、初始化MessageResource、注册监听器等工作&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过上一步中读取到的内容，初始化 HandlerMapping &amp;amp; HandlerAdapter 等工作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;==上面3个步骤才是重要内容==&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;总的来说，DispatcherServlet 还是一个 Servlet，遵循 constructor() --&amp;gt; init() --&amp;gt; service() --&amp;gt; destroy() 方法的调用流程。只不过，它的这个 init() 方法确实比较复杂（这就是本文为什么会这么长的原因，不过，看到此处的读者，恭喜，您已经看完啦！）。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 31 Mar 2018 13:12:00 +0000</pubDate>
<dc:creator>cyhbyw</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cyhbyw/p/8683251.html</dc:identifier>
</item>
<item>
<title>钢条切割问题带你彻底理解动态规划 - Demon_Angel</title>
<link>http://www.cnblogs.com/DA799422035/p/8684219.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DA799422035/p/8684219.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;动态规划 （Dynamic Programming）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;什么是动态规划?&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;span&gt;动态规划算法通常基于一个递推公式及一个或多个初始状态。当前子问题的解将由上一个子问题的解推出。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;动态规划和分治法相似，都是通过分解，求解，并组合子问题来求解原问题。分治法将问题划分成相互独立互不相交的子问题，递归求解子问题，再将它们的解组合起来，求出原问题的解。与之相反，动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。在这种情况下，分治算法会做出许多不必要的工作，它会反复的求解那些公共子子问题。而动态规划算法对每个子子问题只求解一次，将结果保存到表格（数组）中，从而无需每次求解一个子子问题都要重新计算。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;动态规划之钢条切割问题&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;假定我们知道某公司出售一段长度为i英寸的钢条的价格为p[i](i=1,2,3….)钢条长度为整英寸如图给出价格表的描述（任意长度的钢条价格都有）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1349841/201803/1349841-20180331200247835-174919159.png&quot; alt=&quot;&quot; width=&quot;767&quot; height=&quot;82&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在先给一段长度为n的钢条，问怎么切割，获得的收益最大 rn?&lt;br/&gt;考虑n=4的时候，有以下8种切割方式&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1349841/201803/1349841-20180331200418572-1780592194.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假如一个最优解把n段切成了k段（1&amp;lt;=k&amp;lt;=n）,那么最优切割方案：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1349841/201803/1349841-20180331200707610-433609870.png&quot; alt=&quot;&quot;/&gt;   i及下标表示第i段的长度，n为钢条的总长度。&lt;/p&gt;
&lt;p&gt;最大收益：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1349841/201803/1349841-20180331200732634-389111847.png&quot; alt=&quot;&quot;/&gt;    p及下标表示第i段的收益，r为钢条的总收益。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;接下来对这个问题进行求解，我们先用普通的递归方法求解：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我们从钢条的左边切下长度为i的一段，只对右边剩下长度为n-i的一段继续进行切割，对左边的不再切割。&lt;/p&gt;
&lt;p&gt;这样，当第一段长度为n的时候，收益为p[n]，剩余长度为0，收益为0（这也是递归的基本问题），对应的总收益为p[n]。&lt;/p&gt;
&lt;p&gt;当第一段长度为i的时候，收益为p[i]，剩余长度为n-i，对应的总收益为p[i]加上剩余的n-i段再进行当第一段长度为i的时候，收益为p[i]，剩余长度为n-i-i，....直到剩余长度为0，收益为0。&lt;br/&gt;所以递归方程式为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1349841/201803/1349841-20180331201936992-1958160504.png&quot; alt=&quot;&quot;/&gt;    pi就是就是p[i],可以看出每次都要进行从1到n的遍历。&lt;/p&gt;
&lt;p&gt;代码实现 - 自顶向下递归实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; UpDown(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt; * p)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数n是长度，参数p是价格表&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (n == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归的基本问题&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; tempMaxPrice = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; n + &lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; maxPrice = p[i] + UpDown(n -&lt;span&gt; i, p);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (maxPrice &amp;gt;&lt;span&gt; tempMaxPrice)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             tempMaxPrice =&lt;span&gt; maxPrice;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; tempMaxPrice;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; p[&lt;span&gt;11&lt;/span&gt;]{ &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;17&lt;/span&gt;, &lt;span&gt;17&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt; };&lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引代表 钢条的长度，值代表价格&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     std::cout &amp;lt;&amp;lt; UpDown(&lt;span&gt;4&lt;/span&gt;,p) &amp;lt;&amp;lt;&lt;span&gt;std::endl;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;动态规划的方法进行求解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;上面的方法之所以效率很低，是因为它反复求解相同的子问题。比如求r[9]和r[8]的时候都求解了r[7],就是说r[7]被求解了两次。因此，动态规划算法安排求解的顺序，对每个子问题只求解一次，并将结果保存到数组中。如果随后再次需要此子问题的解，只需查找保存的结果，不必重新计算。因此动态规划的方法是付出额外的内存空间来节省计算时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;动态规划有两种等价的实现方法（我们使用上面的钢条切割问题为例，实现这两种方法）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种方法是 带备忘的自顶向下法：&lt;br/&gt;    此方法依然是按照自然的递归形式编写过程，但过程中会保存每个子问题的解（通常保存在一个数组中）。当需要计算一个子问题的解时，过程首先检查是否已经保存过此解。如果是，则直接返回保存的值，从而节省了计算时间；如果没有保存过此解，按照正常方式计算这个子问题。我们称这个递归过程是带备忘的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码实现 - 自顶向下动态规划实现&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; result[&lt;span&gt;11&lt;/span&gt;]{ &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; UpDown(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt;* p)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求得长度为n的最大收益&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (n == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (result[n] != &lt;span&gt;0&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里直接返回记录的结果&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result[n];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; tempMaxPrice = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; n + &lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; maxPrice = p[i] + UpDown(n -&lt;span&gt; i, p);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (maxPrice &amp;gt;&lt;span&gt; tempMaxPrice)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             tempMaxPrice =&lt;span&gt; maxPrice;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     result[n] = tempMaxPrice;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将计算过的长度为n的钢条切割的最大收益记录起来&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; tempMaxPrice;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; p[&lt;span&gt;11&lt;/span&gt;] = { &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;17&lt;/span&gt;, &lt;span&gt;17&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt; };&lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引代表 钢条的长度，值代表价格&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     std::cout &amp;lt;&amp;lt; UpDown(&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,p);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;第二种方法是 自底向上法（常用的方法）：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    首先恰当的定义子问题的规模，使得任何问题的求解都只依赖于更小的子问题的解。因而我们将子问题按照规模排序，按从小到大的顺序求解。当求解某个问题的时候，它所依赖的更小的子问题都已经求解完毕，结果已经保存到了数组中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码实现 - 自底向上动态规划实现&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; result[&lt;span&gt;11&lt;/span&gt;]{ &lt;span&gt;0&lt;/span&gt;&lt;span&gt; };
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BottomUp(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt;*&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; n + &lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; tempMaxPrice = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= i; j++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面取得 钢条长度为i的时候的最大收益&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; maxPrice = p[j] + result[i -&lt;span&gt; j];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (maxPrice &amp;gt;&lt;span&gt; tempMaxPrice)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 tempMaxPrice =&lt;span&gt; maxPrice;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         result[i] =&lt;span&gt; tempMaxPrice;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result[n];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; p[&lt;span&gt;11&lt;/span&gt;] = { &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;17&lt;/span&gt;, &lt;span&gt;17&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt; };&lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引代表 钢条的长度，值代表价格&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     std::cout &amp;lt;&amp;lt; BottomUp(&lt;span&gt;4&lt;/span&gt;&lt;span&gt;,p);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;可以看出自顶向下的动态规划求解和普通的递归求解差不多，不过动态规划递归调用时带了备忘录，记录了已经解决的问题，所以对于上文提到的r[7]，我们只求解了一次。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;自底向上的动态规划也用了备忘录，不过它只是迭代求解，并没有进行递归，所以这也是我们常用方法。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;span&gt;以上有什么不足的地方和应该改进的地方，欢迎各路大神批评指正，笔者一定虚心接受。谢谢！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Sat, 31 Mar 2018 13:11:00 +0000</pubDate>
<dc:creator>Demon_Angel</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DA799422035/p/8684219.html</dc:identifier>
</item>
<item>
<title>多目标跟踪(MOT)论文随笔-POI: Multiple Object Tracking with High Performance Detection and Appearance Feature - Ivon_Lee</title>
<link>http://www.cnblogs.com/yanwei-li/p/8683933.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanwei-li/p/8683933.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;转载请标明链接：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 多目标跟踪(MOT)论文随笔-POI: Multiple Object Tracking with High Performance Detection and Appearance Feature&quot; href=&quot;http://www.cnblogs.com/yanwei-li/p/8683933.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/yanwei-li/p/8683933.html&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网上已有很多关于MOT的文章，此系列仅为个人阅读随笔，便于初学者的共同成长。若希望详细了解，建议阅读原文。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文是tracking by detection 方法进行多目标跟踪的文章，最大的特点是使用了state-of-the-art的detection和feature来代替以往的方法，使用简单的匹配方法就能达到最好的水平。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;论文地址：&lt;a href=&quot;https://arxiv.org/pdf/1610.06136.pdf&quot; target=&quot;_blank&quot;&gt;https://arxiv.org/pdf/1610.06136.pdf&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Detection 以及  Appearance特征地址(Google Drive 需FQ)：&lt;a href=&quot;https://drive.google.com/open?id=0B5ACiy41McAHMjczS2p0dFg3emM&quot; target=&quot;_blank&quot;&gt;https://drive.google.com/open?id=0B5ACiy41McAHMjczS2p0dFg3emM&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt;&lt;span&gt;&lt;strong&gt;文章方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li lang=&quot;en-US&quot; value=&quot;1&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Detection部分&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;文章针对&lt;span lang=&quot;en-US&quot;&gt;MOT16&lt;span lang=&quot;en-US&quot;&gt;所使用的&lt;span lang=&quot;en-US&quot;&gt;MOTA&lt;span lang=&quot;en-US&quot;&gt;指标中的&lt;span lang=&quot;en-US&quot;&gt;FP&lt;span lang=&quot;en-US&quot;&gt;与&lt;span lang=&quot;en-US&quot;&gt;FN&lt;span lang=&quot;en-US&quot;&gt;，使用&lt;span lang=&quot;en-US&quot;&gt;Faster R-CNN + Skip pooling + multi-region &lt;span lang=&quot;en-US&quot;&gt;的方法来结合多尺度特征，从而降低&lt;span lang=&quot;en-US&quot;&gt;FP&lt;span lang=&quot;en-US&quot;&gt;与&lt;span lang=&quot;en-US&quot;&gt;FN&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;&lt;li lang=&quot;en-US&quot; value=&quot;2&quot;&gt;&lt;strong&gt;&lt;span&gt;Appearance 特征部分&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul type=&quot;disc&quot;&gt;&lt;li lang=&quot;en-US&quot;&gt;&lt;span&gt;使用类似于GoogLeNet的网络来提取128维的特征，并使用cosine距离来度量表观特征（与之前SORT文章所使用的方法类似）；&lt;/span&gt;&lt;/li&gt;
&lt;li lang=&quot;en-US&quot;&gt;&lt;span&gt;结合Softmax和Triplet loss来训练网络。其中Softmax loss用于保证appearance特征有良好的判别性，Triplet loss用来保证同一ID内的cosine距离足够小。（这里与SORT不同的是使用了Triplet loss来减小类内的cosine距离，相当于在training过程中使得特征更加针对于MOT的任务）。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol type=&quot;1&quot;&gt;&lt;li lang=&quot;en-US&quot; value=&quot;3&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Online Tracker&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;使用Kalman滤波来预测track，使用&lt;span lang=&quot;zh-CN&quot;&gt; &lt;span lang=&quot;en-US&quot;&gt;Kuhn-Munkres 算法来进行结合track和detection &lt;span lang=&quot;zh-CN&quot;&gt;（与SORT类似，不同的是SORT使用了&lt;span lang=&quot;en-US&quot;&gt;Hungarian算法来匹配&lt;span lang=&quot;zh-CN&quot;&gt;），具体步骤见下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;&lt;span&gt;构造相似度矩阵&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;计算track和detection间的关联度矩阵&lt;em&gt;&lt;span&gt;A&lt;sup&gt;t−1&lt;/sup&gt; = Affinity(T&lt;sup&gt;t−1&lt;/sup&gt;,D&lt;sup&gt;t&lt;/sup&gt;)&lt;/span&gt;&lt;/em&gt;。计算时结合运动（&lt;em&gt;&lt;span&gt;aff&lt;sub&gt;mot&lt;/sub&gt;&lt;/span&gt;&lt;/em&gt;），形状（&lt;em&gt;&lt;span&gt;aff&lt;sub&gt;shp&lt;/sub&gt;&lt;/span&gt;&lt;/em&gt;），和外观（&lt;em&gt;&lt;span&gt;aff&lt;sub&gt;app&lt;/sub&gt;&lt;/span&gt;&lt;/em&gt;）的关联度作为最后的关联度矩阵，具体计算如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1360490/201803/1360490-20180331194200330-690743352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1360490/201803/1360490-20180331194207590-1143283451.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1360490/201803/1360490-20180331194213993-785619798.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1360490/201803/1360490-20180331194226572-73722850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;&lt;span&gt;匹配track和detection&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;使用 Kuhn-Munkres 算法来匹配track和detection。由于&lt;span lang=&quot;zh-CN&quot;&gt;KM&lt;span lang=&quot;zh-CN&quot;&gt;算法是全局优化算法，在一些&lt;span lang=&quot;zh-CN&quot;&gt;detection&lt;span lang=&quot;zh-CN&quot;&gt;遗失时会出错。&lt;span lang=&quot;zh-CN&quot;&gt;因此我们&lt;span lang=&quot;zh-CN&quot;&gt;使用两步匹配的策略，首先根据阈值&lt;em&gt;T&lt;/em&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;em&gt;&lt;sub&gt;t&lt;/sub&gt;&lt;/em&gt;&lt;span lang=&quot;en-US&quot;&gt;=0.5&lt;span lang=&quot;zh-CN&quot;&gt;将&lt;span lang=&quot;zh-CN&quot;&gt;track&lt;span lang=&quot;zh-CN&quot;&gt;分为高质量的&lt;span lang=&quot;zh-CN&quot;&gt;track&lt;span lang=&quot;zh-CN&quot;&gt;和低质量的&lt;span lang=&quot;zh-CN&quot;&gt;track&lt;span lang=&quot;en-US&quot;&gt;(&lt;span lang=&quot;en-US&quot;&gt;大于阈值为高质量，小于为低质量&lt;span lang=&quot;en-US&quot;&gt;)&lt;span lang=&quot;zh-CN&quot;&gt;；然后首先匹配高质量的&lt;span lang=&quot;zh-CN&quot;&gt;track&lt;span lang=&quot;zh-CN&quot;&gt;和&lt;span lang=&quot;zh-CN&quot;&gt;detection&lt;span lang=&quot;zh-CN&quot;&gt;，再匹配前一步剩下的和低质量的&lt;span lang=&quot;zh-CN&quot;&gt;track&lt;span lang=&quot;zh-CN&quot;&gt;。T&lt;span lang=&quot;zh-CN&quot;&gt;rack的质量计算如下，其中&lt;span lang=&quot;zh-CN&quot;&gt;couples(trackleti)&lt;span lang=&quot;zh-CN&quot;&gt;包含了过往的所有匹配成功的&lt;span lang=&quot;zh-CN&quot;&gt;track&lt;span lang=&quot;zh-CN&quot;&gt;与&lt;span lang=&quot;zh-CN&quot;&gt;detection&lt;span lang=&quot;zh-CN&quot;&gt;的关联度&lt;span lang=&quot;zh-CN&quot;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1360490/201803/1360490-20180331194348628-1657219501.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul type=&quot;disc&quot;&gt;&lt;li&gt;&lt;span&gt;具体流程&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;具体流程见下表，其中&lt;span lang=&quot;zh-CN&quot;&gt;&lt;em&gt;w&lt;/em&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;em&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;/em&gt;&lt;span lang=&quot;en-US&quot;&gt;=0.5&lt;span lang=&quot;zh-CN&quot;&gt;,  &lt;em&gt;w&lt;/em&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;em&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;/em&gt;&lt;span lang=&quot;en-US&quot;&gt;=1.5&lt;span lang=&quot;zh-CN&quot;&gt;, &lt;em&gt;w&lt;/em&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;em&gt;&lt;sub&gt;3&lt;/sub&gt;&lt;/em&gt;&lt;span lang=&quot;en-US&quot;&gt;=1.2&lt;span lang=&quot;zh-CN&quot;&gt;, &lt;em&gt;τ&lt;/em&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;em&gt;&lt;sub&gt;t&lt;/sub&gt;&lt;/em&gt;&lt;span lang=&quot;en-US&quot;&gt;=0.5&lt;span lang=&quot;zh-CN&quot;&gt;, &lt;em&gt;τ&lt;/em&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;em&gt;&lt;sub&gt;a&lt;/sub&gt;&lt;/em&gt;&lt;span lang=&quot;en-US&quot;&gt;=0.4, &lt;span lang=&quot;zh-CN&quot;&gt;&lt;em&gt;τ&lt;/em&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;em&gt;&lt;sub&gt;m&lt;/sub&gt;&lt;/em&gt;&lt;span lang=&quot;en-US&quot;&gt;=100。&lt;span lang=&quot;zh-CN&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1360490/201803/1360490-20180331194643013-491471112.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt;&lt;strong&gt;&lt;span&gt;4. Offline Tracker&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;Offline Tracker 是基于&lt;span lang=&quot;zh-CN&quot;&gt;H&lt;span lang=&quot;zh-CN&quot;&gt;2&lt;span lang=&quot;zh-CN&quot;&gt;T&lt;span lang=&quot;zh-CN&quot;&gt;的改进版本，主要使用了&lt;span lang=&quot;en-US&quot;&gt;K-Dense Neighbors搜索算法，具体步骤见下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul type=&quot;disc&quot;&gt;&lt;li lang=&quot;en-US&quot;&gt;&lt;span&gt;使用了和Online Tracker相同的特征构建关联度矩阵。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;en-US&quot;&gt;文章提出两个阈值来解决&lt;span lang=&quot;zh-CN&quot;&gt;motion和平滑关联性对于过大target不稳定的问题。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在构建关联度矩阵时放弃了高阶信息，来减少矩阵维度并提高DN搜索的效率。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;具体步骤见下，由于主要着眼于Online &lt;span lang=&quot;en-US&quot;&gt;Track&lt;span lang=&quot;zh-CN&quot;&gt;，这里就不再详细展开，感兴趣的读者可以参考原文及其给出的参考文献。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1360490/201803/1360490-20180331194817656-363567322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;文章结果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;文章结果见下表，文章结果还是很不错的，在当时也达到了SOTA。不过相比于之前文章分析的SORT&lt;span lang=&quot;en-US&quot;&gt;(60Hz)&lt;span lang=&quot;zh-CN&quot;&gt;以及Deep &lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;SORT&lt;span lang=&quot;en-US&quot;&gt;(40Hz)&lt;span lang=&quot;zh-CN&quot;&gt;，此方法&lt;span lang=&quot;en-US&quot;&gt;(10Hz)&lt;span lang=&quot;zh-CN&quot;&gt;在实时性方面还是有比较大的差距。个人认为主要是由于检测部分以及用于提取appearance特征的GoogLeNet计算量较大所导致的，这个网络结构换为轻量级的网络即可，在此就不再赘述。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1360490/201803/1360490-20180331195022933-816287126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Sat, 31 Mar 2018 11:51:00 +0000</pubDate>
<dc:creator>Ivon_Lee</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yanwei-li/p/8683933.html</dc:identifier>
</item>
<item>
<title>有关java中的hashCode问题 - echoing</title>
<link>http://www.cnblogs.com/echoing/p/8683761.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/echoing/p/8683761.html</guid>
<description>&lt;h2 id=&quot;hashset集合存储数据的结构哈希表&quot;&gt;1. HashSet集合存储数据的结构（哈希表）&lt;/h2&gt;
&lt;h3 id=&quot;什么是哈希表&quot;&gt;1.1 什么是哈希表？&lt;/h3&gt;
&lt;p&gt;哈希表底层使用的也是数组机制，数组中也存放对象，而这些对象往数组中存放时的位置比较特殊，当需要把这些对象给数组中存放时，那么会根据这些对象的特有数据结合相应的算法，计算出这个对象在数组中的位置，然后把这个对象存放在数组中。而这样的数组就称为哈希数组，即就是哈希表。&lt;/p&gt;
&lt;h3 id=&quot;哈希表存储数据结构原理&quot;&gt;1.2 哈希表存储数据结构原理&lt;/h3&gt;
&lt;p&gt;当向哈希表中存放元素时，需要根据元素的特有数据结合相应的算法，这个算法其实就是Object类中的hashCode方法。由于任何对象都是Object类的子类，所以任何对象也拥有这个方法。即就是在给哈希表中存放对象时，会调用对象的hashCode方法，算出对象在表中的存放位置，这里需要注意，如果两个对象hashCode方法算出结果一样，这样现象称为哈希冲突，这时会调用对象的equals方法，比较这两个对象是不是同一个对象，如果equals方法返回的是true，那么就不会把第二个对象存放在哈希表中，如果返回的是false，就会把这个值存放在哈希表中。&lt;/p&gt;
&lt;h3 id=&quot;哈希表存储数据结构原理图&quot;&gt;1.3 哈希表存储数据结构原理图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/echoing/1167395/o_0xdkdns5wsx5kaj80si03v.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;hash&quot;&gt;2. hash&lt;/h2&gt;
&lt;p&gt;hash是散列的意思，就是把任意长度的输入，通过散列算法变换成固定长度的输出，该输出就是散列值。关于散列值，有以下几个关键结论：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果散列表中存在和散列原始输入&lt;code&gt;K&lt;/code&gt;相等的记录，那么&lt;code&gt;K&lt;/code&gt;必定在&lt;code&gt;f(K)&lt;/code&gt;的存储位置上&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;不同关键字经过散列算法变换后可能得到同一个散列地址，这种现象称为碰撞&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果两个hash值不同（前提是同一hash算法），那么这两个hash值对应的原始输入必定不同&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;hashcode&quot;&gt;3. hashCode&lt;/h2&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;hashCode的存在主要是为了查找的快捷性，hashCode是用来在散列存储结构中确定对象的存储地址的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果两个对象equals相等，那么这两个对象的hashCode一定也相同&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果对象的equals方法被重写，那么对象的hashCode方法也尽量重写&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果两个对象的hashCode相同，不代表两个对象就相同，只能说明这两个对象在散列存储结构中，存放于同一个位置&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果根据equals方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;hashcode作用&quot;&gt;4. hashCode作用&lt;/h2&gt;
&lt;p&gt;我们知道Set里面的元素是不可以重复的，那么如何做到？&lt;/p&gt;
&lt;p&gt;Set是根据equals()方法来判断两个元素是否相等的。比方说Set里面已经有1000个元素了，那么第1001个元素进来的时候，最多可能调用1000次equals方法，如果equals方法写得复杂，对比的东西特别多，那么效率会大大降低。使用HashCode就不一样了，比方说HashSet，底层是基于HashMap实现的，先通过HashCode取一个模，这样一下子就固定到某个位置了，如果这个位置上没有元素，那么就可以肯定HashSet中必定没有和新添加的元素equals的元素，就可以直接存放了，都不需要比较；如果这个位置上有元素了，逐一比较，比较的时候先比较HashCode，HashCode都不同接下去都不用比了，肯定不一样，HashCode相等，再equals比较，没有相同的元素就存，有相同的元素就不存。如果原来的Set里面有相同的元素，只要HashCode的生成方式定义得好（不重复），不管Set里面原来有多少元素，只需要执行一次的equals就可以了。这样一来，实际调用equals方法的次数大大降低，提高了效率。&lt;/p&gt;
&lt;h2 id=&quot;hashset存储javaapi中的类型元素&quot;&gt;5. HashSet存储JavaAPI中的类型元素&lt;/h2&gt;
&lt;p&gt;给HashSet中存储JavaAPI中提供的类型元素时，不需要重写元素的hashCode和equals方法，因为这两个方法，在JavaAPI的每个类中已经重写完毕，如String类、Integer类等。&lt;/p&gt;
&lt;p&gt;举个栗子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class HashSetDemo {
    public static void main(String[] args) {
        //创建HashSet对象
        HashSet&amp;lt;String&amp;gt; hs = new HashSet&amp;lt;String&amp;gt;();
        //给集合中添加自定义对象
        hs.add(&quot;zhangsan&quot;);
        hs.add(&quot;lisi&quot;);
        hs.add(&quot;wangwu&quot;);
        hs.add(&quot;zhangsan&quot;);
        //取出集合中的每个元素
        Iterator&amp;lt;String&amp;gt; it = hs.iterator();
        while(it.hasNext()){
            String s = it.next();
            System.out.println(s);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;wangwu&lt;br/&gt;lisi&lt;br/&gt;zhangsan&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;hashset存储自定义类型元素&quot;&gt;6. HashSet存储自定义类型元素&lt;/h2&gt;
&lt;p&gt;给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;p&gt;自定义Student类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Student {
    private String name;
    private int age;
    public Student(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    @Override
    public String toString() {
        return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
    }
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + age;
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        return result;
    }
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if(!(obj instanceof Student)){
            System.out.println(&quot;类型错误&quot;);
            return false;
        }
        Student other = (Student) obj;
        return this.age ==  other.age &amp;amp;&amp;amp; this.name.equals(other.name);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建HashSet集合，存储Student对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class HashSetDemo {
    public static void main(String[] args) {
        //创建HashSet对象
        HashSet&amp;lt;Student&amp;gt; hs = new&amp;lt;Student&amp;gt; HashSet();
        //给集合中添加自定义对象
        hs.add(new Student(&quot;zhangsan&quot;,21));
        hs.add(new Student(&quot;lisi&quot;,22));
        hs.add(new Student(&quot;wangwu&quot;,23));
        hs.add(new Student(&quot;zhangsan&quot;,21));
        //取出集合中的每个元素
        Iterator it = hs.iterator();
        while(it.hasNext()){
            Student s = (Student)it.next();
            System.out.println(s);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Student [name=lisi, age=22]&lt;br/&gt;Student [name=zhangsan, age=21]&lt;br/&gt;Student [name=wangwu, age=23]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在后面&quot;&gt;7. 写在后面&lt;/h2&gt;
&lt;p&gt;保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须重写hashCode和equals方法建立属于当前对象的比较方式。&lt;/p&gt;
</description>
<pubDate>Sat, 31 Mar 2018 11:11:00 +0000</pubDate>
<dc:creator>echoing</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/echoing/p/8683761.html</dc:identifier>
</item>
<item>
<title>maven的使用（基础1） - 左羽</title>
<link>http://www.cnblogs.com/1214804270hacker/p/8683763.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1214804270hacker/p/8683763.html</guid>
<description>&lt;p&gt;---恢复内容开始---&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　&lt;em&gt;这是我第一次写博客，这个想法源于我的师傅对我的建议，一是与大家一起进步，二是让自己养成总结的好习惯。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　&lt;/em&gt;&lt;span&gt;“如果你步入的maven的世界，你便打开了Java的另一扇大门”。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　&lt;/em&gt;这篇文章是面向没有接触过maven的同学们，对于maven玩的很溜的，请指出该文章的不足。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;caption&gt;&lt;span&gt;导读&lt;/span&gt;&lt;/caption&gt;
&lt;tbody readability=&quot;2&quot;&gt;&lt;tr align=&quot;left&quot; valign=&quot;middle&quot;&gt;&lt;td scope=&quot;row&quot; align=&quot;left&quot; valign=&quot;middle&quot;&gt;
&lt;h2&gt;&lt;span&gt;1.什么是maven？&lt;/span&gt;&lt;/h2&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;left&quot; valign=&quot;middle&quot; readability=&quot;2&quot;&gt;&lt;td scope=&quot;row&quot; align=&quot;left&quot; valign=&quot;middle&quot;&gt;
&lt;h2&gt;&lt;span&gt;2.为什么使用maven？&lt;/span&gt;&lt;/h2&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;left&quot; valign=&quot;middle&quot;&gt;&lt;td scope=&quot;row&quot; align=&quot;left&quot; valign=&quot;middle&quot;&gt;
&lt;h2&gt;&lt;span&gt;3.maven的安装。&lt;/span&gt;&lt;/h2&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;left&quot; valign=&quot;middle&quot;&gt;&lt;td scope=&quot;row&quot; align=&quot;left&quot; valign=&quot;middle&quot;&gt;
&lt;h2&gt;&lt;span&gt;4.maven初体验。&lt;/span&gt;&lt;/h2&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;left&quot; valign=&quot;middle&quot; readability=&quot;2&quot;&gt;&lt;td scope=&quot;row&quot; align=&quot;left&quot; valign=&quot;middle&quot;&gt;
&lt;h2&gt;&lt;span&gt;5.maven的基本指令。&lt;/span&gt;&lt;/h2&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;





&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;1.什么是maven？&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;maven就是一种项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建。说白了就是通过一个配置文件管理整个项目的build。它是一个主要服务于Java平台，出自Apach组织的开源的牛逼项目。主要功能是&lt;span&gt;项目构建、依赖管理、项目信息&lt;/span&gt;管理。具体关于maven的非技术历史，这里不多说，自行百度。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2.为什么使用maven？&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;因为maven是一款很强大的构建工具，能够帮我们自动化构建过程，从清理、编译、测试、生成报告、打包、部署等等，如果我们纯手动，会很浪费时间的，面向对象编程的优点在于模块化，提高复用性。那么maven就是这一系列操作的封装（我是这样认为的，如有不恰当之处，请指出），如果需要做这些操作，我们只需一个指令，maven就可以替我们完成这一系列操作，从而节省大量无意义的、机械的动作，提高编程效率，而不再是我们进行重复的设计，重复的编码，重复的文档 ......（此处省略n+1个文字，没错，maven就是这么强大）&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;3.maven的安装。&lt;/h2&gt;
&lt;p&gt;　　&lt;a title=&quot;maven下载页面&quot; href=&quot;http://maven.apache.org/download.cgi&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;点击这里进入maven下载页面&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　下载完成后，点击解压到指定的文件夹。解压完成后还没完...还要进行环境变量的配置。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331171952005-474408000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将maven安装的目录路径配置到环境变量，并给变量起名字（这是为了在以后升级时，仅将此处路径更改即可，而不必改动PATH路径的变量，我们要充分利用计算机内变量这一机制，这样可以大量减少我们的操作）。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331173243778-1311499703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将变量名配置到PATH的值内，这是为了无论我们在哪个位置都可以使用maven指令。接下来我们随手打开cmd，输入mvn -v，这是查看maven的版本，同时也是看一下我们环境变量是否配置成功。如果提示not found，就表示没有成功，自己再好好琢磨一下吧。&lt;/p&gt;
&lt;p&gt;　　如果配置成功，我们再dos窗口输入mvn help:system，这是打印所有java系统属性和环境变量，在这里是为了让maven第一次运行一个任务，将maven在你的计算机上能够有一个完整的结构。运行完之后，你的个人账户的所有应用配置文件夹（也就是C:\Users\%uname%\）下，会出现~.m2文件夹，这个就是maven在你电脑上，属于你的maven配置的文件夹。&lt;/p&gt;
&lt;p&gt;　　接下来我们来到你的%MAVEN_HOME%\config目录里，你会看到这些：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331173557054-34764982.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中，settings.xml将会时我们日后经常访问的文件，它时maven的配置文件，maven的设置全部来自该配置文件的参数配置。我们刚刚接触maven，我们只需对它来个初步设置，具体的其他设置我们日后再议。接下来我们将它复制到C:\Users\%uname%\.m2下，然后打开它，你会看到200~300行的代码，我们初学者只需添加一行代码即可：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331175304561-637499584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面已注释的代码说的很清楚，这个是maven在你计算机的本地仓库（就是项目所需的依赖在本地计算机的储存位置）的配置位置，默认在与该配置文件所在文件夹内的\repository文件夹内。而我不喜欢如此大的文件放在小小的C盘里，所以放到了D盘。到这里，我们maven的安装就完成了。&lt;/p&gt;

&lt;h2&gt;4.maven初体验&lt;/h2&gt;
&lt;p&gt;　　我们使用Myeclipse创建一个maven项目，（Myeclipse已集成maven），只需在配置里面把maven设置一下即可&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331182702128-529310759.png&quot; alt=&quot;&quot; width=&quot;619&quot; height=&quot;385&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将它设置为自己安装的maven，尽量不要使用自带maven（集成不代表自带）。&lt;/p&gt;
&lt;p&gt;　　然后File &amp;gt; New &amp;gt; Other &amp;gt; Maven &amp;gt; Maven Object ，先不要点击Create a simple project，那个以后再议，Next，然后选择maven-archetype-quickstart，在这里可以讲Archetype理解成Maven项目的模板，例如maven-archetype-quickstart就是最简单的Maven项目模板，只需提供基本的元素，如groupId,artifactId,version等，它就能生成项目的基本结构及POM文件。接下来的groupId,artifactId,version是maven的基本元素。&lt;/p&gt;
&lt;p&gt;　　groupId：指的是你属于哪些组织，在这里你可以写你的名字+域名归属的倒置。&lt;/p&gt;
&lt;p&gt;　　artifactId：指的是该项目的id。&lt;/p&gt;
&lt;p&gt;　　version：该项目的版本。&lt;/p&gt;
&lt;p&gt;　　然后就可以编辑pom.xml的代码了，如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 本项目基本坐标 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;cn.zuoyu.fistmaven&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hello-maven&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hello-maven&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;http://maven.apache.org&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 控制java版本 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;maven-compiler-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.3.2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;             
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.7&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后编写一个实体类和一个测试类，编写完之后，我们在该项目的目录下打开dos窗口，输入mvn test，可见：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331184212014-1280318104.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;386&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这是maven的测试，成功！&lt;/p&gt;
&lt;p&gt;　　接下来用maven制作jar包，当然前提是给项目加一个main方法，然后再pom.xml下加入一下代码，路径是main方法的路径，不要弄错了：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;maven-shade-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;executions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;execution&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;phase&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;package&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;phase&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;goals&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;goal&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;shade&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;goal&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;goals&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transformers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transformer &lt;/span&gt;&lt;span&gt;implementation&lt;/span&gt;&lt;span&gt;=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mainClass&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;cn.zuoyu.fistmaven.hello_maven.App&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mainClass&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;transformer&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;transformers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;execution&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;executions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个是maven里的maven-shade-plugin插件，用于将项目做成可执行的jar文件。&lt;/p&gt;
&lt;p&gt;　　我们再dos里输入mvn clean install，会看到：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331185438769-4896836.png&quot; alt=&quot;&quot; width=&quot;720&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后我们打开项目文件夹下的\target文件夹，会看到生成：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331185619366-1294232790.png&quot; alt=&quot;&quot; width=&quot;423&quot; height=&quot;140&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中hello-maven-0.0.1-SNAPSHOT.jar是带有Main-Class的可运行jar文件，而original-hello-maven-0.0.1-SNAPSHOT.jar是原始的可供其他项目使用的jar文件。&lt;/p&gt;
&lt;p&gt;　　如果我们在该文件夹打开dos输入java -jar hello-maven-0.0.1-SNAPSHOT.jar，可见：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331190159252-1540602341.png&quot; alt=&quot;&quot; width=&quot;524&quot; height=&quot;31&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以执行了。&lt;/p&gt;

&lt;h2&gt;　5.maven的基本指令。&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1. 编译测试代码：
mvn test-compile
2. 运行测试:
mvn test
3. 产生site：
mvn site
4. 打包：
mvn package
5. 在本地Repository中安装jar：
mvn install
6. 清除产生的项目：
mvn clean
7. 生成eclipse项目：
mvn eclipse:eclipse
8. 生成idea项目：
mvn idea:idea
9. 组合使用goal命令，如只打包不测试：
mvn -Dtest package
10. 编译测试的内容：
mvn test-compile
11. 只打jar包:
mvn jar:jar
12. 只测试而不编译，也不测试编译：
mvn test -skipping compile -skipping test-compile
13. 清除eclipse的一些系统设置:
mvn eclipse:clean 
14.查看当前项目已被解析的依赖：
mvn dependency:list&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ok了，今天的maven使用教程就到此为止了！！！&lt;/p&gt;
&lt;p&gt;　　如有不当地方可以邮件给我：&lt;span id=&quot;useraddr&quot; title=&quot;关联其他QQ邮箱&quot;&gt;zuoyuip@qq.com&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;---恢复内容结束---&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　&lt;em&gt;这是我第一次写博客，这个想法源于我的师傅对我的建议，一是与大家一起进步，二是让自己养成总结的好习惯。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　&lt;/em&gt;&lt;span&gt;“如果你步入的maven的世界，你便打开了Java的另一扇大门”。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;　　&lt;/em&gt;这篇文章是面向没有接触过maven的同学们，对于maven玩的很溜的，请指出该文章的不足。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;caption&gt;&lt;span&gt;导读&lt;/span&gt;&lt;/caption&gt;
&lt;tbody readability=&quot;2&quot;&gt;&lt;tr align=&quot;left&quot; valign=&quot;middle&quot;&gt;&lt;td scope=&quot;row&quot; align=&quot;left&quot; valign=&quot;middle&quot;&gt;
&lt;h2&gt;&lt;span&gt;1.什么是maven？&lt;/span&gt;&lt;/h2&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;left&quot; valign=&quot;middle&quot; readability=&quot;2&quot;&gt;&lt;td scope=&quot;row&quot; align=&quot;left&quot; valign=&quot;middle&quot;&gt;
&lt;h2&gt;&lt;span&gt;2.为什么使用maven？&lt;/span&gt;&lt;/h2&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;left&quot; valign=&quot;middle&quot;&gt;&lt;td scope=&quot;row&quot; align=&quot;left&quot; valign=&quot;middle&quot;&gt;
&lt;h2&gt;&lt;span&gt;3.maven的安装。&lt;/span&gt;&lt;/h2&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;left&quot; valign=&quot;middle&quot;&gt;&lt;td scope=&quot;row&quot; align=&quot;left&quot; valign=&quot;middle&quot;&gt;
&lt;h2&gt;&lt;span&gt;4.maven初体验。&lt;/span&gt;&lt;/h2&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;left&quot; valign=&quot;middle&quot; readability=&quot;2&quot;&gt;&lt;td scope=&quot;row&quot; align=&quot;left&quot; valign=&quot;middle&quot;&gt;
&lt;h2&gt;&lt;span&gt;5.maven的基本指令。&lt;/span&gt;&lt;/h2&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;





&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;1.什么是maven？&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;maven就是一种项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建。说白了就是通过一个配置文件管理整个项目的build。它是一个主要服务于Java平台，出自Apach组织的开源的牛逼项目。主要功能是&lt;span&gt;项目构建、依赖管理、项目信息&lt;/span&gt;管理。具体关于maven的非技术历史，这里不多说，自行百度。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;2.为什么使用maven？&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;因为maven是一款很强大的构建工具，能够帮我们自动化构建过程，从清理、编译、测试、生成报告、打包、部署等等，如果我们纯手动，会很浪费时间的，面向对象编程的优点在于模块化，提高复用性。那么maven就是这一系列操作的封装（我是这样认为的，如有不恰当之处，请指出），如果需要做这些操作，我们只需一个指令，maven就可以替我们完成这一系列操作，从而节省大量无意义的、机械的动作，提高编程效率，而不再是我们进行重复的设计，重复的编码，重复的文档 ......（此处省略n+1个文字，没错，maven就是这么强大）&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;3.maven的安装。&lt;/h2&gt;
&lt;p&gt;　　&lt;a title=&quot;maven下载页面&quot; href=&quot;http://maven.apache.org/download.cgi&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;点击这里进入maven下载页面&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　下载完成后，点击解压到指定的文件夹。解压完成后还没完...还要进行环境变量的配置。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331171952005-474408000.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将maven安装的目录路径配置到环境变量，并给变量起名字（这是为了在以后升级时，仅将此处路径更改即可，而不必改动PATH路径的变量，我们要充分利用计算机内变量这一机制，这样可以大量减少我们的操作）。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331173243778-1311499703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将变量名配置到PATH的值内，这是为了无论我们在哪个位置都可以使用maven指令。接下来我们随手打开cmd，输入mvn -v，这是查看maven的版本，同时也是看一下我们环境变量是否配置成功。如果提示not found，就表示没有成功，自己再好好琢磨一下吧。&lt;/p&gt;
&lt;p&gt;　　如果配置成功，我们再dos窗口输入mvn help:system，这是打印所有java系统属性和环境变量，在这里是为了让maven第一次运行一个任务，将maven在你的计算机上能够有一个完整的结构。运行完之后，你的个人账户的所有应用配置文件夹（也就是C:\Users\%uname%\）下，会出现~.m2文件夹，这个就是maven在你电脑上，属于你的maven配置的文件夹。&lt;/p&gt;
&lt;p&gt;　　接下来我们来到你的%MAVEN_HOME%\config目录里，你会看到这些：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331173557054-34764982.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中，settings.xml将会时我们日后经常访问的文件，它时maven的配置文件，maven的设置全部来自该配置文件的参数配置。我们刚刚接触maven，我们只需对它来个初步设置，具体的其他设置我们日后再议。接下来我们将它复制到C:\Users\%uname%\.m2下，然后打开它，你会看到200~300行的代码，我们初学者只需添加一行代码即可：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331175304561-637499584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面已注释的代码说的很清楚，这个是maven在你计算机的本地仓库（就是项目所需的依赖在本地计算机的储存位置）的配置位置，默认在与该配置文件所在文件夹内的\repository文件夹内。而我不喜欢如此大的文件放在小小的C盘里，所以放到了D盘。到这里，我们maven的安装就完成了。&lt;/p&gt;

&lt;h2&gt;4.maven初体验&lt;/h2&gt;
&lt;p&gt;　　我们使用Myeclipse创建一个maven项目，（Myeclipse已集成maven），只需在配置里面把maven设置一下即可&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331182702128-529310759.png&quot; alt=&quot;&quot; width=&quot;619&quot; height=&quot;385&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将它设置为自己安装的maven，尽量不要使用自带maven（集成不代表自带）。&lt;/p&gt;
&lt;p&gt;　　然后File &amp;gt; New &amp;gt; Other &amp;gt; Maven &amp;gt; Maven Object ，先不要点击Create a simple project，那个以后再议，Next，然后选择maven-archetype-quickstart，在这里可以讲Archetype理解成Maven项目的模板，例如maven-archetype-quickstart就是最简单的Maven项目模板，只需提供基本的元素，如groupId,artifactId,version等，它就能生成项目的基本结构及POM文件。接下来的groupId,artifactId,version是maven的基本元素。&lt;/p&gt;
&lt;p&gt;　　groupId：指的是你属于哪些组织，在这里你可以写你的名字+域名归属的倒置。&lt;/p&gt;
&lt;p&gt;　　artifactId：指的是该项目的id。&lt;/p&gt;
&lt;p&gt;　　version：该项目的版本。&lt;/p&gt;
&lt;p&gt;　　然后就可以编辑pom.xml的代码了，如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 本项目基本坐标 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;cn.zuoyu.fistmaven&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hello-maven&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hello-maven&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;http://maven.apache.org&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project.build.sourceEncoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 控制java版本 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;maven-compiler-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.3.2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;target&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;             
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;junit&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.7&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后编写一个实体类和一个测试类，编写完之后，我们在该项目的目录下打开dos窗口，输入mvn test，可见：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331184212014-1280318104.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;386&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这是maven的测试，成功！&lt;/p&gt;
&lt;p&gt;　　接下来用maven制作jar包，当然前提是给项目加一个main方法，然后再pom.xml下加入一下代码，路径是main方法的路径，不要弄错了：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;maven-shade-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;executions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;execution&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;phase&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;package&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;phase&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;goals&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;goal&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;shade&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;goal&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;goals&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transformers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;transformer &lt;/span&gt;&lt;span&gt;implementation&lt;/span&gt;&lt;span&gt;=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mainClass&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;cn.zuoyu.fistmaven.hello_maven.App&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mainClass&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;transformer&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;transformers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;execution&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;executions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个是maven里的maven-shade-plugin插件，用于将项目做成可执行的jar文件。&lt;/p&gt;
&lt;p&gt;　　我们再dos里输入mvn clean install，会看到：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331185438769-4896836.png&quot; alt=&quot;&quot; width=&quot;720&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后我们打开项目文件夹下的\target文件夹，会看到生成：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331185619366-1294232790.png&quot; alt=&quot;&quot; width=&quot;423&quot; height=&quot;140&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中hello-maven-0.0.1-SNAPSHOT.jar是带有Main-Class的可运行jar文件，而original-hello-maven-0.0.1-SNAPSHOT.jar是原始的可供其他项目使用的jar文件。&lt;/p&gt;
&lt;p&gt;　　如果我们在该文件夹打开dos输入java -jar hello-maven-0.0.1-SNAPSHOT.jar，可见：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201803/1113894-20180331190159252-1540602341.png&quot; alt=&quot;&quot; width=&quot;524&quot; height=&quot;31&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以执行了。&lt;/p&gt;

&lt;h2&gt;　5.maven的基本指令。&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1. 编译测试代码：
mvn test-compile
2. 运行测试:
mvn test
3. 产生site：
mvn site
4. 打包：
mvn package
5. 在本地Repository中安装jar：
mvn install
6. 清除产生的项目：
mvn clean
7. 生成eclipse项目：
mvn eclipse:eclipse
8. 生成idea项目：
mvn idea:idea
9. 组合使用goal命令，如只打包不测试：
mvn -Dtest package
10. 编译测试的内容：
mvn test-compile
11. 只打jar包:
mvn jar:jar
12. 只测试而不编译，也不测试编译：
mvn test -skipping compile -skipping test-compile
13. 清除eclipse的一些系统设置:
mvn eclipse:clean 
14.查看当前项目已被解析的依赖：
mvn dependency:list&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ok了，今天的maven使用教程就到此为止了！！！&lt;/p&gt;
&lt;p&gt;　　如有不当地方可以邮件给我：&lt;span id=&quot;useraddr&quot; title=&quot;关联其他QQ邮箱&quot;&gt;zuoyuip@qq.com&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 31 Mar 2018 11:11:00 +0000</pubDate>
<dc:creator>左羽</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1214804270hacker/p/8683763.html</dc:identifier>
</item>
</channel>
</rss>