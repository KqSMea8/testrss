<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>关于云Linux部署tomcat服务器（Maven的多模块war包） - 左羽</title>
<link>http://www.cnblogs.com/1214804270hacker/p/8978087.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1214804270hacker/p/8978087.html</guid>
<description>&lt;h2&gt;　　博主的运行环境：&lt;/h2&gt;
&lt;h4&gt;　　电脑系统： 　　Linux mint 18&lt;/h4&gt;
&lt;h4&gt;　　JDK版本：　　java version &quot;1.8.0_171&quot;&lt;/h4&gt;
&lt;h4&gt;　　Maven版本： 　　Apache Maven 3.5.3&lt;/h4&gt;
&lt;h2&gt;一、关于war包的生成：&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501221859922-542230996.png&quot; alt=&quot;&quot; width=&quot;262&quot; height=&quot;319&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如图，这是一个多模块项目，被分为前端和后端，生成的war包将在web部分生成，但是web部分对service部分有依赖，所以我们需要先将service部分的jar包生成才能保证web部分的war包成功生成：&lt;/p&gt;
&lt;p&gt;　　生成service部分的jar包：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501222520538-2016090372.png&quot; alt=&quot;&quot; width=&quot;364&quot; height=&quot;228&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　看到生成后，成功放置maven仓库：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501222627547-1966269047.png&quot; alt=&quot;&quot; width=&quot;363&quot; height=&quot;225&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接下来我们要生成web的war包了：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501222831334-309641787.png&quot; alt=&quot;&quot; width=&quot;366&quot; height=&quot;231&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以看到成功生成，且被放置在cn/zuoyu/ssm/ssm-web/下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501223026433-1872037977.png&quot; alt=&quot;&quot; width=&quot;369&quot; height=&quot;234&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么现在很多新手会问，单单部署web.war包，那么service的项目呢？要知道web对service是有很强的依赖的，我们来打开war包：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501224101065-1231248360.png&quot; alt=&quot;&quot; width=&quot;370&quot; height=&quot;237&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　清晰看到有四个文件夹&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501224224911-791298827.png&quot; alt=&quot;&quot; width=&quot;370&quot; height=&quot;230&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　看到WEB-INF目录下有我们想要知道的东西，那么service的class文件会不会在classes目录里呢？我们看看：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501224401867-1803750367.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个里面什么也没有，我们看看lib目录里有没有我们想要看到的东西：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501224515054-1434823656.png&quot; alt=&quot;&quot; width=&quot;365&quot; height=&quot;227&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　仔细看，会看到有ssm-service-0.0.1-SNAPSHOT.jar包，这个就是我们刚刚生成的service的jar包，那么我们看看这个包里面有没有我们想要的东西：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501224841755-903178640.png&quot; alt=&quot;&quot; width=&quot;372&quot; height=&quot;241&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　看到这里就明了，service的所以内容都在这个jar包里面，所以我们只需要部署这个web.war包即可。&lt;/p&gt;
&lt;h2&gt;二、上传到云Linux服务器：&lt;/h2&gt;
&lt;h4&gt;　　云服务器系统：　　contes 6.5&lt;/h4&gt;
&lt;h4&gt;　　JDK版本：　　java version &quot;1.8.0_112&quot;&lt;/h4&gt;
&lt;h4&gt;　　tomcat版本：　　Apache Tomcat/9.0.0.M15&lt;/h4&gt;
&lt;p&gt;　　首先我们要连接ssh：&lt;/p&gt;
&lt;p&gt;　　格式为#ssh  user@IpAddress&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501230111796-1256580068.png&quot; alt=&quot;&quot; width=&quot;362&quot; height=&quot;227&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们看一下tomcat的地址，并进入：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501230349525-1371963648.png&quot; alt=&quot;&quot; width=&quot;356&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们现在看一下webapps目录：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501230656645-331251226.png&quot; alt=&quot;&quot; width=&quot;360&quot; height=&quot;229&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　空的，除了自带其他都没有。现在我们要将本地的这个war包上传到云服务器这个目录下面（为了方便我将此war包改名为zuoyu.war并放到此目录下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501231211074-1356321668.png&quot; alt=&quot;&quot; width=&quot;359&quot; height=&quot;224&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在需要将它上传到云服务器：&lt;/p&gt;
&lt;p&gt;　　小插曲，如果我们从服务器上将文件传至本地　　&lt;span&gt;scp username@servername:/path/filename &lt;span&gt;/var/www/local_dir（本地目录）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　如果我们本地上传到服务器　　&lt;span&gt;scp /path/filename username@servername:/path&lt;br/&gt;&lt;/span&gt; 　　　　　　如果我们从服务器下载整个目录　　&lt;span&gt;scp -r username@servername:/var/www/remote_dir/（远程目录） /var/www/local_dir（本地目录）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　如果我们上传目录到服务器　　&lt;span&gt;scp  -r local_dir username@servername:remote_dir&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501232115736-518761378.png&quot; alt=&quot;&quot; width=&quot;376&quot; height=&quot;234&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上传成功！我们看一下服务器上有没有：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501232325534-745814073.png&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ok，上传成功，现在我们启动服务器！如果成功启动那么它会自动解压这个zuoyu.war包：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501232559917-2053182989.png&quot; alt=&quot;&quot; width=&quot;386&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以看到tomcat已经启动，我们看一下启动日志：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501233226969-1028223644.png&quot; alt=&quot;&quot; width=&quot;391&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　看一下webapps目录：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501233508680-2015605126.png&quot; alt=&quot;&quot; width=&quot;378&quot; height=&quot;308&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　很完整，我们浏览器访问一下试试：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1113894/201805/1113894-20180501233653244-260130901.png&quot; alt=&quot;&quot; width=&quot;477&quot; height=&quot;162&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　很完美！&lt;/p&gt;













</description>
<pubDate>Tue, 01 May 2018 15:39:00 +0000</pubDate>
<dc:creator>左羽</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1214804270hacker/p/8978087.html</dc:identifier>
</item>
<item>
<title>前端技术之_CSS详解第二天 - 我举个栗子</title>
<link>http://www.cnblogs.com/wanghui1234/p/8978003.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanghui1234/p/8978003.html</guid>
<description>&lt;p&gt;&lt;span&gt;html负责结构，css负责样式，js负责行为。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;css写在head标签里面，容器style标签。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先写选择器，然后写大括号，大括号里面是样式。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        body&lt;/span&gt;{&lt;span&gt;
            background-color&lt;/span&gt;:&lt;span&gt; pink&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;常见属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    h1&lt;/span&gt;{&lt;span&gt;
            color&lt;/span&gt;:&lt;span&gt;blue&lt;/span&gt;;&lt;span&gt;
            font-size&lt;/span&gt;:&lt;span&gt; 60px&lt;/span&gt;;&lt;span&gt;
            font-weight&lt;/span&gt;:&lt;span&gt; normal&lt;/span&gt;;&lt;span&gt;
            text-decoration&lt;/span&gt;:&lt;span&gt; underline&lt;/span&gt;;&lt;span&gt;
            font-style&lt;/span&gt;:&lt;span&gt; italic&lt;/span&gt;;
        }    
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1.1 标签选择器&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;就是用标签名来当做选择器。&lt;/p&gt;
&lt;p&gt;1） 所有标签都能够当做选择器，比如body、h1、dl、ul、span等等&lt;/p&gt;
&lt;p&gt;2） 不管这个标签藏的多深，都能够被选择上。&lt;/p&gt;
&lt;p&gt;3） 选择的是所有的，而不是某一个。所以是共性，而不是特性。&lt;/p&gt;
&lt;p&gt;比如网易，希望页面上所有的超级链接都没有下划线：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        a&lt;/span&gt;{
            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;去掉下划线：&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            text-decoration&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;; 
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1.2 id选择器&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;#表示选择id&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1  #lj1&lt;/span&gt;{&lt;span&gt;
2  font-size&lt;/span&gt;:&lt;span&gt; 60px&lt;/span&gt;;&lt;span&gt;
3  font-weight&lt;/span&gt;:&lt;span&gt; bold&lt;/span&gt;;&lt;span&gt;
4  color&lt;/span&gt;:&lt;span&gt;black&lt;/span&gt;;&lt;span&gt;
5  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1）任何的标签都可以有id，id的命名要以字母开头，可以有数字、下划线。大小写严格区别，也就是说mm和MM是两个不同的id。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）同一个页面内id不能重复，即使不一样的标签，也不能是相同的id。也就是说，如果有一个&lt;/span&gt;p的id叫做haha，这个页面内，其他所有的元素的id都不能叫做haha。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;1.3 类选择器&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        .teshu&lt;/span&gt;{&lt;span&gt;
            color&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;
        }&lt;span&gt;
        .zhongyao&lt;/span&gt;{&lt;span&gt;
            text-decoration&lt;/span&gt;:&lt;span&gt; underline&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h3 class=&quot;zhongyao&quot;&amp;gt;我是一个h3啊&amp;lt;/h3&amp;gt;
    &amp;lt;h3 class=&quot;teshu zhongyao&quot;&amp;gt;我是一个h3啊&amp;lt;/h3&amp;gt;
    &amp;lt;h3&amp;gt;我是一个h3啊&amp;lt;/h3&amp;gt;
    &amp;lt;p&amp;gt;我是一个段落啊&amp;lt;/p&amp;gt;
    &amp;lt;p class=&quot;teshu&quot;&amp;gt;我是一个段落啊&amp;lt;/p&amp;gt;
    &amp;lt;p class=&quot;teshu&quot;&amp;gt;我是一个段落啊&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;.就是类的符号&lt;/strong&gt;&lt;span&gt;。类的英语叫做&lt;/span&gt;class。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所谓的类，就是&lt;/span&gt;class属性，class属性和id非常相似，&lt;strong&gt;&lt;span&gt;任何的标签都可以携带&lt;/span&gt;class属性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class属性可以重复，比如，页面上可能有很多标签都有teshu这个类&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1  &amp;lt;h3&amp;gt;我是一个h3啊&amp;lt;/h3&amp;gt;
2  &amp;lt;h3 class=&quot;teshu&quot;&amp;gt;我是一个h3啊&amp;lt;/h3&amp;gt;
3  &amp;lt;h3&amp;gt;我是一个h3啊&amp;lt;/h3&amp;gt;
4  &amp;lt;p&amp;gt;我是一个段落啊&amp;lt;/p&amp;gt;
5  &amp;lt;p class=&quot;teshu&quot;&amp;gt;我是一个段落啊&amp;lt;/p&amp;gt;
6  &amp;lt;p class=&quot;teshu&quot;&amp;gt;我是一个段落啊&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;css里面用.来表示类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1  .teshu&lt;/span&gt;{&lt;span&gt;
2  color&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;&lt;span&gt;
3  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;同一个标签，可能同时属于多个类，用空格隔开&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 &amp;lt;h3 class=&quot;teshu zhongyao&quot;&amp;gt;我是一个h3啊&amp;lt;/h3&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样，这个&lt;/span&gt;h3&lt;strong&gt;&lt;span&gt;就同时属于&lt;/span&gt;teshu类，也同时属于zhongyao类&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;初学者常见的错误，就是写成了两个&lt;/span&gt;class：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 &amp;lt;h3 class=&quot;teshu&quot; class=&quot;zhongyao&quot;&amp;gt;我是一个h3啊&amp;lt;/h3&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;所以要总结两条：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1） class可以重复，也就是说，同一个页面上可能有多个标签同时属于某一个类；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2） 同一个标签可以同时携带多个类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类的使用，能够决定一个人的&lt;/span&gt;css水平。&lt;/p&gt;
&lt;p&gt;1） 不要去试图用一个类名，把某个标签的所有样式写完。这个标签要多携带几个类，共同造成这个标签的样式。&lt;/p&gt;
&lt;p&gt;2） 每一个类要尽可能小，有“公共”的概念，能够让更多的标签使用。&lt;/p&gt;
&lt;p&gt;正确使用公共类：案例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        .lv&lt;/span&gt;{&lt;span&gt;
            color&lt;/span&gt;:&lt;span&gt;green&lt;/span&gt;;
        }&lt;span&gt;
        .da&lt;/span&gt;{&lt;span&gt;
            font-size&lt;/span&gt;:&lt;span&gt; 60px&lt;/span&gt;;
        }&lt;span&gt;
        .xian&lt;/span&gt;{&lt;span&gt;
            text-decoration&lt;/span&gt;:&lt;span&gt; underline&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p class=&quot;lv da&quot;&amp;gt;段落1&amp;lt;/p&amp;gt;
    &amp;lt;p class=&quot;lv xian&quot;&amp;gt;段落2&amp;lt;/p&amp;gt;
    &amp;lt;p class=&quot;da xian&quot;&amp;gt;段落3&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;1.4到底用&lt;/span&gt;id还是用class？&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;答案：尽可能的用&lt;/span&gt;class，除非极特殊的情况可以用id。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因：&lt;/span&gt;id是js用的。也就是说，js要通过id属性得到标签，所以我们css层面尽量不用id，要不然js就很别扭。另一层面，我们会认为一个有id的元素，有动态效果。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就是一个标签，可以同时被多种选择器选择，标签选择器、&lt;/span&gt;id选择器、类选择器。这些选择器都可以选择上同一个标签，从而影响样式，这就是css的cascading“层叠式”的第一层含义。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;2.1 后代选择器&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ff3c292f-1035-4923-a27f-dbcb090c107c')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_ff3c292f-1035-4923-a27f-dbcb090c107c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ff3c292f-1035-4923-a27f-dbcb090c107c&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ff3c292f-1035-4923-a27f-dbcb090c107c',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ff3c292f-1035-4923-a27f-dbcb090c107c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
         .div1 .li2 p&lt;/span&gt;{&lt;span&gt;
             color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;
         }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div class=&quot;div1&quot;&amp;gt;
        &amp;lt;ul&amp;gt;
            &amp;lt;li&amp;gt;
                &amp;lt;p&amp;gt;段落&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;段落&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;段落&amp;lt;/p&amp;gt;
            &amp;lt;/li&amp;gt;
            &amp;lt;li class=&quot;li2&quot;&amp;gt;
                &amp;lt;p&amp;gt;段落&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;段落&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;段落&amp;lt;/p&amp;gt;
            &amp;lt;/li&amp;gt;
            &amp;lt;li&amp;gt;
                &amp;lt;p&amp;gt;段落&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;段落&amp;lt;/p&amp;gt;
                &amp;lt;p&amp;gt;段落&amp;lt;/p&amp;gt;
            &amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div&amp;gt;
        &amp;lt;p&amp;gt;段落&amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt;段落&amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt;段落&amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1  &amp;lt;style type=&quot;text/css&quot;&amp;gt;
2  .div1 p&lt;/span&gt;{&lt;span&gt;
3  color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;&lt;span&gt;
4  &lt;/span&gt;}&lt;span&gt;
5  &amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;空格就表示后代，&lt;/span&gt;.div1 p 就是.div1的后代所有的p。 &lt;/p&gt;
&lt;p&gt;强调一下，选择的是后代，不一定是儿子。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1    &amp;lt;div class=&quot;div1&quot;&amp;gt;
2        &amp;lt;ul&amp;gt;
3            &amp;lt;li&amp;gt;
4                &amp;lt;p&amp;gt;段落&amp;lt;/p&amp;gt;
5                &amp;lt;p&amp;gt;段落&amp;lt;/p&amp;gt;
6                &amp;lt;p&amp;gt;段落&amp;lt;/p&amp;gt;
7            &amp;lt;/li&amp;gt;
8        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后代选择器，就是一种平衡：共性、特性的平衡。当要把某一个部分的所有的什么，进行样式改变，就要想到后代选择器。&lt;/p&gt;
&lt;p&gt;后代选择器，描述的是祖先结构。&lt;/p&gt;
&lt;p&gt;能够被下面的选择器选择上：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1  .div1 p&lt;/span&gt;{&lt;span&gt;

2  color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;所以，看见这个选择器要知道是后代，而不是儿子。选择的是所有&lt;/span&gt;.div1“中的”p，就是后代p。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;2.2 交集选择器&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180501230606432-1366875053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2fc83b92-82c7-4368-85eb-c3aef213ff4d')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_2fc83b92-82c7-4368-85eb-c3aef213ff4d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2fc83b92-82c7-4368-85eb-c3aef213ff4d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2fc83b92-82c7-4368-85eb-c3aef213ff4d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2fc83b92-82c7-4368-85eb-c3aef213ff4d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        h3.special&lt;/span&gt;{&lt;span&gt;
            color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h3&amp;gt;我是标题&amp;lt;/h3&amp;gt;
    &amp;lt;h3 class=&quot;special&quot;&amp;gt;我是标题&amp;lt;/h3&amp;gt;
    &amp;lt;h3 class=&quot;special&quot;&amp;gt;我是标题&amp;lt;/h3&amp;gt;
    &amp;lt;p class=&quot;special&quot;&amp;gt;我是段落&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;我是段落&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;我是段落&amp;lt;/p&amp;gt;
    &amp;lt;a href=&quot;&quot; class=&quot;xixi&quot;&amp;gt;aaa&amp;lt;/a&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;选择的元素是同时满足两个条件：必须是&lt;/span&gt;h3标签，然后必须是special标签。&lt;/p&gt;
&lt;p&gt;交集选择器没有空格。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;交集选择器，我们一般都是以标签名开头，比如&lt;/span&gt;div.haha  比如p.special。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;2.3 并集选择器（分组选择器）&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2ce1a97f-2667-467f-90c5-f9064ff5fb8b')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_2ce1a97f-2667-467f-90c5-f9064ff5fb8b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2ce1a97f-2667-467f-90c5-f9064ff5fb8b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2ce1a97f-2667-467f-90c5-f9064ff5fb8b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2ce1a97f-2667-467f-90c5-f9064ff5fb8b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        h3,li&lt;/span&gt;{&lt;span&gt;
            color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h3&amp;gt;我是一个标题&amp;lt;/h3&amp;gt;
    &amp;lt;p&amp;gt;是一个段落&amp;lt;/p&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;我是一个列表&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 h3,li&lt;/span&gt;{&lt;span&gt;
2  color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;&lt;span&gt;
3 &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 用逗号就表示并集。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2.4 通配符*&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4416c93f-04f2-498b-b8ee-11ddbf858aac')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_4416c93f-04f2-498b-b8ee-11ddbf858aac&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4416c93f-04f2-498b-b8ee-11ddbf858aac&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4416c93f-04f2-498b-b8ee-11ddbf858aac',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4416c93f-04f2-498b-b8ee-11ddbf858aac&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        h3.*&lt;/span&gt;{&lt;span&gt;
            color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;
        }&lt;span&gt;
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;段落&amp;lt;/p&amp;gt;
    &amp;lt;h3&amp;gt;标题&amp;lt;/h3&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li&amp;gt;列表&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;列表&amp;lt;/li&amp;gt;
        &amp;lt;li&amp;gt;列表&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;*就表示所有元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 *&lt;/span&gt;{&lt;span&gt;
2  color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;&lt;span&gt;
3 &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效率不高，如果页面上的标签越多，效率越低，所以页面上不能出现这个选择器。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3.1 兼容问题介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们现在给大家介绍一下浏览器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IE： 微软的浏览器，随着操作系统安装的。所以每个windows都有IE浏览器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　windows xp 操作系统安装的IE6&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　windows vista 操作系统安装的IE7&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　windows 7 操作系统安装的IE8&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　windows 8 操作系统安装的IE9&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　windows10 操作系统安装的edge&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;浏览器兼容问题，要出，就基本上就是出在IE6、7身上，这两个浏览器是非常低级的浏览器。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180501231608758-279989842.jpg&quot; alt=&quot;&quot; width=&quot;742&quot; height=&quot;615&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;浏览器的市场占有率：&lt;/span&gt; &lt;a href=&quot;http://tongji.baidu.com/data/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://tongji.baidu.com/data/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HTML5浏览器打分：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://html5test.com/results/desktop.html&quot; target=&quot;_blank&quot;&gt;http://html5test.com/results/desktop.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3.2 儿子选择器&lt;/strong&gt;&lt;strong&gt;&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.ietester.cn/&quot; target=&quot;_blank&quot;&gt;http://www.ietester.cn/&lt;/a&gt;   测试工具&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 div&amp;gt;p&lt;/span&gt;{&lt;span&gt;
2  color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;&lt;span&gt;
3 &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;div的儿子p。和div的后代p的截然不同。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3.3 序选择器&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;IE8开始兼容；IE6、7都不兼容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选择第&lt;/span&gt;1个li：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1  &amp;lt;style type=&quot;text/css&quot;&amp;gt;
2  ul li:first-child&lt;/span&gt;{&lt;span&gt;
3  color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;&lt;span&gt;
4  &lt;/span&gt;}&lt;span&gt;
5  &amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;选择最后一个&lt;/span&gt;1i：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1  ul li:last-child&lt;/span&gt;{&lt;span&gt;
2  color&lt;/span&gt;:&lt;span&gt;blue&lt;/span&gt;;&lt;span&gt;
3  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由于浏览器的更新需要过程，所以现在如果公司还要求兼容&lt;/span&gt;IE6、7，那么就要自己写类名：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1    &amp;lt;ul&amp;gt;
2        &amp;lt;li class=&quot;first&quot;&amp;gt;项目&amp;lt;/li&amp;gt;
3        &amp;lt;li&amp;gt;项目&amp;lt;/li&amp;gt;
4        &amp;lt;li&amp;gt;项目&amp;lt;/li&amp;gt;
5        &amp;lt;li&amp;gt;项目&amp;lt;/li&amp;gt;
6        &amp;lt;li&amp;gt;项目&amp;lt;/li&amp;gt;
7        &amp;lt;li&amp;gt;项目&amp;lt;/li&amp;gt;
8        &amp;lt;li&amp;gt;项目&amp;lt;/li&amp;gt;
9        &amp;lt;li&amp;gt;项目&amp;lt;/li&amp;gt;
10        &amp;lt;li&amp;gt;项目&amp;lt;/li&amp;gt;
11        &amp;lt;li class=&quot;last&quot;&amp;gt;项目&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;用类选择器来选择第一个或者最后一个：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1        ul li.first&lt;/span&gt;{&lt;span&gt;
2            color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;&lt;span&gt;
3        &lt;/span&gt;}&lt;span&gt;
4
5        ul li.last&lt;/span&gt;{&lt;span&gt;
6            color&lt;/span&gt;:&lt;span&gt;blue&lt;/span&gt;;
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;3.4 下一个兄弟选择器&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;IE7开始兼容，IE6不兼容。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;+表示选择下一个兄弟&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
2        h3+p&lt;/span&gt;{&lt;span&gt;
3            color&lt;/span&gt;:&lt;span&gt;red&lt;/span&gt;;&lt;span&gt;
4        &lt;/span&gt;}&lt;span&gt;
    &amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;选择上的是&lt;/span&gt;h3元素后面紧挨着的第一个兄弟。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1    &amp;lt;h3&amp;gt;我是一个标题&amp;lt;/h3&amp;gt;
2    &amp;lt;p&amp;gt;我是一个段落&amp;lt;/p&amp;gt;
3    &amp;lt;p&amp;gt;我是一个段落&amp;lt;/p&amp;gt;
4    &amp;lt;p&amp;gt;我是一个段落&amp;lt;/p&amp;gt;
5    &amp;lt;h3&amp;gt;我是一个标题&amp;lt;/h3&amp;gt;
6    &amp;lt;p&amp;gt;我是一个段落&amp;lt;/p&amp;gt;
7    &amp;lt;p&amp;gt;我是一个段落&amp;lt;/p&amp;gt;
8    &amp;lt;p&amp;gt;我是一个段落&amp;lt;/p&amp;gt;
9    &amp;lt;h3&amp;gt;我是一个标题&amp;lt;/h3&amp;gt;
10    &amp;lt;p&amp;gt;我是一个段落&amp;lt;/p&amp;gt;
11    &amp;lt;p&amp;gt;我是一个段落&amp;lt;/p&amp;gt;
12    &amp;lt;p&amp;gt;我是一个段落&amp;lt;/p&amp;gt;
    &amp;lt;h3&amp;gt;我是一个标题&amp;lt;/h3&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;4.1 继承性&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;有一些属性，当给自己设置的时候，自己的后代都继承上了，这个就是继承性。&lt;/p&gt;
&lt;p&gt;哪些属性能继承？&lt;/p&gt;
&lt;p&gt;color、 text-开头的、line-开头的、font-开头的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;这些关于文字样式的，都能够继承；&lt;/span&gt; &lt;span&gt;所有关于盒子的、定位的、布局的属性都不能继承。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，如果我们的页面的文字，都是灰色，都是&lt;/span&gt;14px。那么就可以利用继承性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 body&lt;/span&gt;{&lt;span&gt;
2     color&lt;/span&gt;:&lt;span&gt;gray&lt;/span&gt;;&lt;span&gt;
3     font-size&lt;/span&gt;:&lt;span&gt;14px&lt;/span&gt;;&lt;span&gt;
4 &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继承性是从自己开始，直到最小的元素。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;5.2 层叠性&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;很多公司如果要笔试，那么一定会考层叠性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;层叠性：就是&lt;/span&gt;css处理冲突的能力。 所有的权重计算，没有任何兼容问题！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CSS像艺术家一样优雅，像工程师一样严谨。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当选择器，选择上了某个元素的时候，那么要这么统计权重：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;id的数量，类的数量，标签的数量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180501232559513-1766780518.png&quot; alt=&quot;&quot; width=&quot;685&quot; height=&quot;361&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果权重一样，那么以后出现的为准：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180501232643969-1993094053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果不能直接选中某个元素，通过继承性影响的话，那么权重是&lt;/span&gt;0。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180501232711773-795142341.png&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;446&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果大家都是&lt;/strong&gt;&lt;strong&gt;0，那么有一个就近原则：谁描述的近，听谁的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180501232737429-1123031600.png&quot; alt=&quot;&quot; width=&quot;647&quot; height=&quot;358&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;权重问题大总结：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1） 先看有没有选中，如果选中了，那么以（id数，类数，标签数）来计权重。谁大听谁的。如果都一样，听后写的为准。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2） 如果没有选中，那么权重是0。如果大家都是0，就近原则。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 案例1：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180501232858043-1627387883.png&quot; alt=&quot;&quot; width=&quot;704&quot; height=&quot;371&quot;/&gt;&lt;/p&gt;
&lt;p&gt;案例2：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180501232927768-825895495.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;440&quot;/&gt;&lt;/p&gt;

&lt;p&gt;案例3：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180501232957097-844495232.png&quot; alt=&quot;&quot; width=&quot;787&quot; height=&quot;461&quot;/&gt;&lt;/p&gt;

&lt;p&gt;案例4：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1322549/201805/1322549-20180501233015982-152651981.png&quot; alt=&quot;&quot; width=&quot;763&quot; height=&quot;437&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;继承性：好的事儿。继承从上到下，哪些能？哪些不能？&lt;/p&gt;
&lt;p&gt;层叠性：冲突，多个选择器描述了同一个属性，听谁的？&lt;/p&gt;

</description>
<pubDate>Tue, 01 May 2018 15:33:00 +0000</pubDate>
<dc:creator>我举个栗子</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wanghui1234/p/8978003.html</dc:identifier>
</item>
<item>
<title>“你什么意思”之基于RNN的语义槽填充(Pytorch实现) - llhthinker</title>
<link>http://www.cnblogs.com/llhthinker/p/8978029.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/llhthinker/p/8978029.html</guid>
<description>&lt;h2 id=&quot;任务&quot;&gt;1.1 任务&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;口语理解（Spoken Language Understanding, SLU）&lt;/strong&gt;作为语音识别与自然语言处理之间的一个新兴领域，其目的是为了让计算机从用户的讲话中理解他们的意图。SLU是口语对话系统（&lt;a href=&quot;https://en.wikipedia.org/wiki/Spoken_dialog_systems&quot;&gt;Spoken Dialog Systems&lt;/a&gt;）的一个非常关键的环节。下图展示了口语对话系统的主要流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/llhthinker/slot-filling/master/pictures/dialogue_system.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SLU主要通过如下三个子任务来理解用户的语言：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;领域识别(Domain Detection)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户意图检测(User Intent Determination)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语义槽填充(Semantic Slot Filling)&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;例如，用户输入“播放周杰伦的稻香”，首先通过领域识别模块识别为&quot;music&quot;领域，再通过用户意图检测模块识别出用户意图为&quot;play_music&quot;（而不是&quot;find_lyrics&quot; ），最后通过槽填充对将每个词填充到对应的槽中：&quot;播放[O] / 周杰伦[B-singer] / 的[O] / 稻香[B-song]&quot;。&lt;/p&gt;
&lt;p&gt;从上述例子可以看出，通常把领域识别和用户意图检测当做&lt;a href=&quot;http://www.cnblogs.com/llhthinker/p/8127788.html&quot;&gt;&lt;strong&gt;文本分类&lt;/strong&gt;&lt;/a&gt;问题，而把槽填充当做&lt;strong&gt;序列标注(Sequence Tagging)&lt;/strong&gt;问题，也就是把连续序列中每个词赋予相应的语义类别标签。本次实验的任务就是基于&lt;strong&gt;ATIS 数据集&lt;/strong&gt;进行语义槽填充。(&lt;strong&gt;完整代码地址&lt;/strong&gt;：&lt;a href=&quot;https://github.com/llhthinker/slot-filling&quot; class=&quot;uri&quot;&gt;https://github.com/llhthinker/slot-filling&lt;/a&gt;)&lt;/p&gt;
&lt;h2 id=&quot;数据集&quot;&gt;1.2 数据集&lt;/h2&gt;
&lt;p&gt;本次实验基于&lt;strong&gt;ATIS(Airline Travel Information Systems )&lt;/strong&gt;数据集。顾名思义，ATIS数据集的领域为&quot;Airline Travel&quot;。ATIS数据集采取流行的&quot;&lt;strong&gt;in/out/begin(IOB)&lt;/strong&gt;标注法&quot;: &quot;I-xxx&quot;表示该词属于槽xxx，但不是槽xxx中第一个词；&quot;O&quot;表示该词不属于任何语义槽；&quot;B-xxx&quot;表示该词属于槽xxx，并且位于槽xxx的首位。部分ATIS训练数据集如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;what    O
is  O
the O
arrival B-flight_time
time    I-flight_time
in  O
san B-fromloc.city_name
francisco   I-fromloc.city_name
for O
the O
DIGITDIGITDIGIT B-depart_time.time
am  I-depart_time.time
flight  O
leaving O
washington  B-fromloc.city_name&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ATIS数据集一共有&lt;strong&gt;83&lt;/strong&gt;种语义槽，因此序列标注的标签类别一共有&lt;span class=&quot;math inline&quot;&gt;\(83+83+1=167\)&lt;/span&gt;个。ATIS数据集分为训练集和测试集，数据规模如下表：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;句子总数&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;4978个&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;893个&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;词语总数&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;56590个&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;9198个&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;句子平均词数&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;11.4个&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;10.3个&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;上文中提到，通常把槽填充当做序列标注问题。很多机器学习算法都能够解决序列标注问题，包括HMM/CFG,hidden vector state(HVS)等生成式模型，以及CRF, SVM等判别式模型。本次实验主要参考论文&lt;a href=&quot;https://ieeexplore.ieee.org/abstract/document/6998838/&quot;&gt;《Using Recurrent Neural Networks for Slot Filling in Spoken Language Understanding 》&lt;/a&gt; ，基于RNN来实现语义槽填充。&lt;/p&gt;
&lt;p&gt;RNN可以分为简单RNN(Simple RNN)和门控机制RNN(Gated RNN)，前者的RNN单元完全接收上个时刻的输入；后者基于门控机制，通过学习到的参数自行决定上个时刻的输入量和当前状态的保留量。下面将介绍Elman-RNN, Jordan-RNN, Hybrid-RNN(Elman和Jordan结合)这三种简单RNN，以及经典的门控机制RNN：LSTM。&lt;/p&gt;
&lt;h2 id=&quot;elman-rnn&quot;&gt;2.1 Elman-RNN&lt;/h2&gt;
&lt;p&gt;Elman-RNN将当前时刻的输入&lt;span class=&quot;math inline&quot;&gt;\(x_t\)&lt;/span&gt;和上个时刻的隐状态输出&lt;span class=&quot;math inline&quot;&gt;\(h_{(t-1)}\)&lt;/span&gt;作为输入，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{split}\begin{array}{ll}h_t = \sigma(W_{ih} x_t + b_{ih} + W_{hh} h_{(t-1)} + b_{hh}) \end{array}\end{split}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/llhthinker/slot-filling/master/pictures/elman.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要说明的是，&lt;code&gt;Pytorch&lt;/code&gt;默认的&lt;a href=&quot;http://pytorch.org/docs/stable/nn.html#rnn&quot;&gt;RNN&lt;/a&gt;即为Elman-RNN，但是它只支持&lt;span class=&quot;math inline&quot;&gt;\(\tanh\)&lt;/span&gt;和ReLU两种激活函数。本次实验按照论文设置，激活函数均采取sigmoid函数，使用&lt;code&gt;Pytorch&lt;/code&gt;具体实现如下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ElmanRNNCell(nn.Module):
    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;, input_size, hidden_size):
        &lt;span class=&quot;bu&quot;&gt;super&lt;/span&gt;(ElmanRNNCell, &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;__init__&lt;/span&gt;()
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.hidden_size &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; hidden_size
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.i2h_fc1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; nn.Linear(input_size, hidden_size)
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.i2h_fc2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; nn.Linear(hidden_size, hidden_size)
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.h2o_fc &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; nn.Linear(hidden_size, hidden_size)

    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; forward(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;bu&quot;&gt;input&lt;/span&gt;, hidden):
        hidden &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; F.sigmoid(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.i2h_fc1(&lt;span class=&quot;bu&quot;&gt;input&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.i2h_fc2(hidden))
        output &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; F.sigmoid(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.h2o_fc(hidden))
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; output, hidden&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;jordan-rnn&quot;&gt;2.2 Jordan-RNN&lt;/h2&gt;
&lt;p&gt;Jordan-RNN将当前时刻的输入&lt;span class=&quot;math inline&quot;&gt;\(x_t\)&lt;/span&gt;和上个时刻的输出层输出&lt;span class=&quot;math inline&quot;&gt;\(y_{(t-1)}\)&lt;/span&gt;作为输入，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{split}\begin{array}{ll}h_t = \sigma(W_{ih} x_t + b_{ih} + W_{yh} y_{(t-1)} + b_{yh}) \end{array}\end{split}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/llhthinker/slot-filling/master/pictures/jordan.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;Pytorch&lt;/code&gt;具体实现如下，其中&lt;span class=&quot;math inline&quot;&gt;\(y_0\)&lt;/span&gt;初始化为可训练的参数:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; JordanRNNCell(nn.Module):
    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;, input_size, hidden_size):
        &lt;span class=&quot;bu&quot;&gt;super&lt;/span&gt;(JordanRNNCell, &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;__init__&lt;/span&gt;()
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.hidden_size &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; hidden_size
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.i2h_fc1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; nn.Linear(input_size, hidden_size) 
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.i2h_fc2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; nn.Linear(hidden_size, hidden_size)
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.h2o_fc &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; nn.Linear(hidden_size, hidden_size)
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.y_0 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; nn.Parameter(nn.init.xavier_uniform(torch.Tensor(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, hidden_size)), requires_grad&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;)

    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; forward(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;bu&quot;&gt;input&lt;/span&gt;, hidden&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;):
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; hidden &lt;span class=&quot;op&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;:
            hidden &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.y_0
        hidden &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; F.sigmoid(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.i2h_fc1(&lt;span class=&quot;bu&quot;&gt;input&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.i2h_fc2(hidden))
        output &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; F.sigmoid(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.h2o_fc(hidden))
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; output, output&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;hybrid-rnn&quot;&gt;2.4 Hybrid-RNN&lt;/h2&gt;
&lt;p&gt;Hybrid-RNN将当前时刻的输入&lt;span class=&quot;math inline&quot;&gt;\(x_t​\)&lt;/span&gt;，上个时刻的隐状态&lt;span class=&quot;math inline&quot;&gt;\(h_{(t-1)}​\)&lt;/span&gt; 以及上个时刻输出层输出&lt;span class=&quot;math inline&quot;&gt;\(y_{(t-1)}​\)&lt;/span&gt;作为输入，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{split}\begin{array}{ll}h_t = \sigma(W_{ih} x_t + b_{ih} + W_{hh} h_{(t-1)} + b_{hh} + W_{yh} y_{(t-1)} + b_{yh}) \end{array}\end{split}\]&lt;/span&gt; ，并且&lt;span class=&quot;math inline&quot;&gt;\(y_0\)&lt;/span&gt;初始化为可训练的参数。使用&lt;code&gt;Pytorch&lt;/code&gt;具体实现如下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;23&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; HybridRNNCell(nn.Module):
    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__init__&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;, input_size, hidden_size):
        &lt;span class=&quot;bu&quot;&gt;super&lt;/span&gt;(HybridRNNCell, &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;).&lt;span class=&quot;fu&quot;&gt;__init__&lt;/span&gt;()
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.hidden_size &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; hidden_size
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.i2h_fc1 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; nn.Linear(input_size, hidden_size)
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.i2h_fc2 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; nn.Linear(hidden_size, hidden_size)
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.i2h_fc3 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; nn.Linear(hidden_size, hidden_size)
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.h2o_fc &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; nn.Linear(hidden_size, hidden_size)
        &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.y_0 &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; nn.Parameter(nn.init.xavier_uniform(torch.Tensor(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, hidden_size)), requires_grad&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;)

    &lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; forward(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;, &lt;span class=&quot;bu&quot;&gt;input&lt;/span&gt;, hidden, output&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;):
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; output &lt;span class=&quot;op&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;None&lt;/span&gt;:
            output &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.y_0    
        hidden &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; F.sigmoid(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.i2h_fc1(&lt;span class=&quot;bu&quot;&gt;input&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.i2h_fc2(hidden)&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.i2h_fc3(output))
        output &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; F.sigmoid(&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.h2o_fc(hidden)) 
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; output, hidden&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;lstm&quot;&gt;2.5 LSTM&lt;/h2&gt;
&lt;p&gt;LSTM引入了&lt;strong&gt;记忆单元&lt;/strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(c_t\)&lt;/span&gt;和3种控制门，包括&lt;strong&gt;输入门&lt;/strong&gt;(input gate)&lt;span class=&quot;math inline&quot;&gt;\(i_t\)&lt;/span&gt;，&lt;strong&gt;遗忘门&lt;/strong&gt;(forget gate)&lt;span class=&quot;math inline&quot;&gt;\(f_t\)&lt;/span&gt;，&lt;strong&gt;输出门&lt;/strong&gt;(output gate)&lt;span class=&quot;math inline&quot;&gt;\(o_t\)&lt;/span&gt;， 首先，输入层接受当前时刻输入&lt;span class=&quot;math inline&quot;&gt;\(x_t\)&lt;/span&gt;和上个时刻隐状态输出&lt;span class=&quot;math inline&quot;&gt;\(h_{(t-1)}\)&lt;/span&gt;，通过&lt;span class=&quot;math inline&quot;&gt;\(\tanh\)&lt;/span&gt;激活函数得到记忆单元的输入&lt;span class=&quot;math inline&quot;&gt;\(g_t\)&lt;/span&gt;； 然后遗忘门&lt;span class=&quot;math inline&quot;&gt;\(f_t\)&lt;/span&gt;决定上个时刻记忆单元&lt;span class=&quot;math inline&quot;&gt;\(c_{(t-1)}\)&lt;/span&gt;的保留比例，输入门&lt;span class=&quot;math inline&quot;&gt;\(i_t\)&lt;/span&gt;决定当前时刻记忆单元的输入&lt;span class=&quot;math inline&quot;&gt;\(g_t\)&lt;/span&gt;的保留比例，两者相加得到当前的记忆单元&lt;span class=&quot;math inline&quot;&gt;\(c_t\)&lt;/span&gt;； 最后记忆单元&lt;span class=&quot;math inline&quot;&gt;\(c_t\)&lt;/span&gt;通过&lt;span class=&quot;math inline&quot;&gt;\(\tanh\)&lt;/span&gt;激活函数得到的值在输出门&lt;span class=&quot;math inline&quot;&gt;\(o_t\)&lt;/span&gt;的控制下得到最终的当前时刻隐状态&lt;span class=&quot;math inline&quot;&gt;\(h_t\)&lt;/span&gt;， 具体如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{split}\begin{array}{ll}i_t = \sigma(W_{ii} x_t + b_{ii} + W_{hi} h_{(t-1)} + b_{hi}) \\f_t = \sigma(W_{if} x_t + b_{if} + W_{hf} h_{(t-1)} + b_{hf}) \\g_t = \tanh(W_{ig} x_t + b_{ig} + W_{hg} h_{(t-1)} + b_{hg}) \\o_t = \sigma(W_{io} x_t + b_{io} + W_{ho} h_{(t-1)} + b_{ho}) \\c_t = f_t c_{(t-1)} + i_t g_t \\h_t = o_t \tanh(c_t)\end{array}\end{split}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Pytorch&lt;/code&gt;已经实现了&lt;a href=&quot;http://pytorch.org/docs/stable/nn.html#lstm&quot;&gt;LSTM&lt;/a&gt;, 只需要调用相应的API即可，调用的代码片段如下:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.rnn &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; nn.LSTM(input_size&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;embedding_dim,
                   hidden_size&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;hidden_size,
                   bidirectional&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;bidirectional,
                   batch_first&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;实验设置&quot;&gt;3.1 实验设置&lt;/h2&gt;
&lt;p&gt;实验基于&lt;code&gt;Python 3.6&lt;/code&gt; 和&lt;a href=&quot;http://pytorch.org/&quot;&gt;&lt;code&gt;Pytorch 0.4.0&lt;/code&gt;&lt;/a&gt;，为进行对照实验，下列设置针对所有RNN模型:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有RNN模型均只使用单层；&lt;/li&gt;
&lt;li&gt;词向量维度设置为100维，并且随机初始化，在训练过程中进行调整；&lt;/li&gt;
&lt;li&gt;隐状态维度设置为75维;&lt;/li&gt;
&lt;li&gt;采用带动量的随机梯度下降(SGD)，batch size为1，学习率(learning rate)为0.1，动量(momentum)为0.9并保持不变;&lt;/li&gt;
&lt;li&gt;epoch=10；&lt;/li&gt;
&lt;li&gt;每种RNN模型都实现单向(Single)和双向(Bi-Directional)，并分别训练。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;实验结果&quot;&gt;3.2 实验结果&lt;/h2&gt;
&lt;p&gt;在使用CPU的情况下，不同模型在测试集的&lt;span class=&quot;math inline&quot;&gt;\(F_1\)&lt;/span&gt;得分以及平均一个epoch训练时长的结果如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;Single&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;87.26&lt;/strong&gt; / &lt;strong&gt;438&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;87.90 / 487&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;88.46 / 494&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;92.16 / 3721&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;Bi-Directional&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;92.88 / 565&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;90.31 / 580&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;91.85 / 613&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;93.75&lt;/strong&gt; / &lt;strong&gt;4357&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从上表中可以看出：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于门控机制的LSTM由于其参数和运算步骤的增加，一个epoch的训练时长是另外三种Simple RNN的9倍左右，而&lt;span class=&quot;math inline&quot;&gt;\(F_1\)&lt;/span&gt;得分也比Simple RNN高；&lt;/li&gt;
&lt;li&gt;双向(Bi-Directional)RNN的&lt;span class=&quot;math inline&quot;&gt;\(F_1\)&lt;/span&gt;得分普遍比单向(Single)RNN高，而运行时间也多一些。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在使用同一块GPU的情况下，不同模型在测试集的&lt;span class=&quot;math inline&quot;&gt;\(F_1\)&lt;/span&gt;得分以及平均一个epoch训练时长的结果如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;Single&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;88.89 / 35.2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;88.36 / 41.3&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;89.65 / 43.5&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;92.44 / &lt;strong&gt;16.8&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;Bi-Directional&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;91.78 / 68.0&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;89.82 / 72.2&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;93.61 / 81.6&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&lt;strong&gt;94.26&lt;/strong&gt; / 18.7&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从上表中可以看出，即使是随机梯度下降(batch_size=1)，GPU的加速效果仍然相当明显。值得指出的是，虽然LSTM的运算步骤比其他三种Simple-RNN多，但是用时却是最少的，这可能是由于LSTM是直接调用&lt;code&gt;Pytorch&lt;/code&gt;的API，针对GPU有优化，而另外三种的都是自己实现的，GPU加速效果没有&lt;code&gt;Pytorch&lt;/code&gt;好。&lt;/p&gt;

&lt;p&gt;总的来说，将槽填充问题当做序列标注问题是一种有效的做法，而RNN能够较好的对序列进行建模，提取相关的上下文特征。双向RNN的表现优于单向RNN，而LSTM的表现优于Simple RNN。对于Simple RNN而言，Elman的表现不比Jordan差（甚至更好），而用时更少并且实现更简单，这可能是主流深度学习框架（&lt;code&gt;TensorFlow&lt;/code&gt; / &lt;code&gt;Pytorch&lt;/code&gt;等）的simple RNN是基于Elman的原因。而Hybrid作为Elman和Jordan的混合体，其训练时间都多余Elman和Jordan，&lt;span class=&quot;math inline&quot;&gt;\(F_1\)&lt;/span&gt;得分略有提升，但不是特别明显（使用CPU时的双向Elman表现比双向Hybrid好），需要更多实验进行验证。&lt;/p&gt;
&lt;p&gt;从实验设置可以看出，本次实验没有过多的调参。如果想取得更好的结果，可以进行更细致的调参，包括 ：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;改变词向量维度和隐状态维度；&lt;/li&gt;
&lt;li&gt;考虑采用预训练词向量，然后固定或者进行微调；&lt;/li&gt;
&lt;li&gt;采用正则化技术，包括L1/L2, Dropout, Batch Normalization, Layer Normalization等；&lt;/li&gt;
&lt;li&gt;尝试使用不同的优化器(如Adam)，使用mini-batch，调整学习率；&lt;/li&gt;
&lt;li&gt;增加epoch次数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外，可以考虑在输入时融入词性标注和命名实体识别等信息，在输出时使用Viterbi算法进行解码，也可以尝试不同形式的门控RNN（如GRU，LSTM变体等）以及采用多层RNN，并考虑是否使用残差连接等。&lt;/p&gt;

&lt;p&gt;Mesnil G, Dauphin Y, Yao K, et al. Using recurrent neural networks for slot filling in spoken language understanding[J]. IEEE/ACM Transactions on Audio, Speech, and Language Processing, 2015, 23(3): 530-539.&lt;/p&gt;
&lt;p&gt;Wikipedia. Recurrent neural network. &lt;a href=&quot;https://en.wikipedia.org/wiki/Recurrent_neural_network&quot; class=&quot;uri&quot;&gt;https://en.wikipedia.org/wiki/Recurrent_neural_network&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PyTorch documentation. Recurrent layers. &lt;a href=&quot;http://pytorch.org/docs/stable/nn.html#recurrent-layers&quot; class=&quot;uri&quot;&gt;http://pytorch.org/docs/stable/nn.html#recurrent-layers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hung-yi Lee. Machine Learning (2017,Spring). &lt;a href=&quot;http://speech.ee.ntu.edu.tw/~tlkagk/courses/ML_2017/Lecture/RNN.pdf&quot; class=&quot;uri&quot;&gt;http://speech.ee.ntu.edu.tw/~tlkagk/courses/ML_2017/Lecture/RNN.pdf&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;YUN-NUNG (VIVIAN) CHEN. Spring 105 - Intelligent Conversational Bot. &lt;a href=&quot;https://www.csie.ntu.edu.tw/~yvchen/s105-icb/doc/170321_LU.pdf&quot; class=&quot;uri&quot;&gt;https://www.csie.ntu.edu.tw/~yvchen/s105-icb/doc/170321_LU.pdf&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 01 May 2018 15:26:00 +0000</pubDate>
<dc:creator>llhthinker</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/llhthinker/p/8978029.html</dc:identifier>
</item>
<item>
<title>python3+django2 开发易语言网络验证（上） - 雪落忆海</title>
<link>http://www.cnblogs.com/xuepangzi/p/8978011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuepangzi/p/8978011.html</guid>
<description>&lt;p&gt;　　在某论坛中下载到一套php开发易语言网络验证的教程，照着看下来，花了两天的时间，结果发现教程里开发的网络验证，以及随着教程一起给学员的源码，都存在着根本用不了的bug！我想要看看能不能在原本的基础上修改，却出现了一大堆坑，不是这儿少个$ ，就是那少个 ;  要不就是哪{}包的不对了，擦，不是说php是世界上最好的语言吗？怎么感觉是世界上最坑的语言呢？&lt;/p&gt;
&lt;p&gt;　　也许因为一般的程序员都是从C启蒙，进而C++，后又转Java，忽然见到php，顿时感觉简单明快，好像见到亲人了似的；而我易语言启蒙，进而学python，连用到JavaScript我都神烦其要弄那么多花括号，还要声明变量什么的，简直麻烦透顶，更不用提php了，简直觉得php就是一块儿被烤化了的牛皮糖，黏黏糊糊，一坨代码扑过来，总有些边边角角bug的弄得你浑身难受。&lt;/p&gt;
&lt;p&gt;　　于是，我只好怒而用python，祭出django，开发一个易语言网络验证喽！其实这也是被逼无奈，毕竟，php垃圾是垃圾了点，好在开发完了，部署极为简单，而django项目的上线部署就……一言难尽了。&lt;/p&gt;

&lt;p&gt;（下载安装mysql、下载安装python3、下载安装pycharm注册激活什么的，在这里就不赘述了，就当大家都知道了哈）&lt;/p&gt;
&lt;h2&gt;1.新建数据库：&lt;/h2&gt;
&lt;p&gt;　　1.打开MySQL Command Line Client （windows 桌面→开始→所有程序→MySQL→MySQL Server5.7 目录下）&lt;/p&gt;
&lt;p&gt;　　2.输入数据库密码，进入数据库，然后敲代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
show databases; #看看mysql中已经有的数据库名，新建的数据库别起重名了
create database netauth; #创建数据库 netauth （netauth是数据库名，可以自定义）
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.新建django项目：&lt;/h2&gt;
&lt;h3&gt;　　1.新建django项目：打开pycharm→File→New Preject→Django→取个项目名：netauth→More Settings→取个app名：yanzheng&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282071/201805/1282071-20180501091451635-2064156507.png&quot; alt=&quot;&quot; width=&quot;617&quot; height=&quot;387&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　2.新建静态文件目录：static、media、log&lt;/h3&gt;
&lt;p&gt;　　1.新建目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282071/201805/1282071-20180501092406979-2072911543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2.在settings.py中配置目录，在settings.py的末尾，找到相关代码，补全为以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
STATIC_URL = '/static/'
STATICFILES_DIRS=(os.path.join(BASE_DIR,  'static'),)
TEMPLATE_DIRS = (os.path.join(BASE_DIR,  'templates'),)
MEDIA_URL=&quot;/media/&quot;
MEDIA_ROOT=os.path.join(BASE_DIR,&quot;media&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.在项目netauth目录下的urls.py中配置media路径，增加代码，补全为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
from django.contrib import admin
from django.urls import path

from django.views.static import serve
from netauth.settings import MEDIA_ROOT


urlpatterns = [
    path('admin/', admin.site.urls),
    #配置上传文件的访问处理函数
    path('media/&amp;lt;path:path&amp;gt;',serve,{'document_root':MEDIA_ROOT}),
]
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;补充：在settings.py中添加模板文件路径：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img id=&quot;code_img_closed_72c34337-be8f-4ef5-bfe9-df9e594c0f26&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt; &lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;　　3.建立django项目与mysql数据库链接：&lt;/h3&gt;
&lt;p&gt;　　1.在项目netauth目录下的__init__.py中加入代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
import pymysql
pymysql.install_as_MySQLdb()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.settings.py配置文件中找到DATABASE进行改写：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': &quot;netauth&quot;,
        'USER':'root',
        'PASSWORD':'（数据库密码）',
        'HOST':&quot;127.0.0.1&quot;,
        'PORT':'3306',
        'OPTIONS':{'init_command':'SET default_storage_engine=INNODB;'}
    }
}
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code_toolbar&quot;&gt;&lt;span class=&quot;cnblogs_code_copy&quot;&gt;&lt;a title=&quot;复制代码&quot;&gt;&lt;img src=&quot;https://common.cnblogs.com/images/copycode.gif&quot; alt=&quot;复制代码&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;　　3.打开Terminal 执行更新数据库的两条经典的命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
python manage.py makemigrations

python manage.py migrate
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282071/201805/1282071-20180501094108259-2062356468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;　　4.在pycharm直观的管理数据库（类似于php的phpadmin，然而没有那么难用）：&lt;/h3&gt;
&lt;p&gt;1.点击Database按钮→点击＋号→点击MySQL&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282071/201805/1282071-20180501095004649-1692640182.png&quot; alt=&quot;&quot; width=&quot;525&quot; height=&quot;397&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 2.输入数据库名、数据库用户名、数据库密码 → 点击Test Connection 按钮，提示Successful代表链接成功，点击ok即可！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282071/201805/1282071-20180501095446619-1846432928.png&quot; alt=&quot;&quot; width=&quot;836&quot; height=&quot;451&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.查看：再点击Database→点击netauth@localhost→点击netauth 即可看到django自动生成的十张表，可以随意点击进去查看，进行增删操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282071/201805/1282071-20180501095908989-1716366498.png&quot; alt=&quot;&quot; width=&quot;560&quot; height=&quot;419&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　 5.建立自定制的用户表：&lt;/h3&gt;
&lt;p&gt;1.在yanzheng/models.py中写代码：&lt;span&gt;from&lt;/span&gt; django.db &lt;span&gt;import&lt;/span&gt; &lt;span&gt;models&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.db &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.contrib.auth.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; AbstractUser
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; datetime &lt;span&gt;import&lt;/span&gt;&lt;span&gt; datetime
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create your models here.&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserProfile(AbstractUser):
    end_time&lt;/span&gt;=models.DateTimeField(default=datetime.now, verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;到期时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        verbose_name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户信息&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        verbose_name_plural&lt;/span&gt;=&lt;span&gt;verbose_name
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.username
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;2.在settings.py 中加入代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
AUTH_USER_MODEL=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yanzheng.UserProfile&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.开始→所有程序→MySQL→ MySQL Server 5.7→ 打开MySQL Command Line Client.exe 输入密码，进入操作界面，执行以下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除netauth数据库，再重建netauth，两次数据库名必须一样&lt;/span&gt;
&lt;span&gt;drop database netauth;
create database netauth;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.回到django项目下，打开Terminal终端，执行经典的更新数据命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;python manage.py makemigrations
python manage.py migrate&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　6.新建超级用户：&lt;/h3&gt;
&lt;p&gt;1.打开Terminal终端，执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;python manage.py createsuperuser

Username:用户名
Email:邮箱
Password：自定义一个不少于8位的密码（密码不显示的）
Password(again):确认密码&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.在settings.py找到LANGUAGE_CODE，将相关代码改为使用中文：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
LANGUAGE_CODE = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;zh-hans&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

TIME_ZONE &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Asia/Shanghai&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

USE_I18N &lt;/span&gt;=&lt;span&gt; True

USE_L10N &lt;/span&gt;=&lt;span&gt; True

USE_TZ &lt;/span&gt;= False
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.运行django项目：&lt;/p&gt;
&lt;p&gt;方法一：点击pycharm运行按钮&lt;/p&gt;
&lt;p&gt;方法二：执行命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
python manage.py runserver
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行成功后，只要浏览器访问：http://127.0.0.1:8000/admin就可以来到xadmin的后台管理界面，通过刚刚创建的超级用户账户密码就可以登录。&lt;/p&gt;

&lt;h3&gt;什么是xadmin：&lt;/h3&gt;
&lt;p&gt;　　网上有很多定义和解释，基本上都让不了解xadmin的人看完了更迷糊！既然是解释，就要让读者能一下子明白嘛！&lt;/p&gt;
&lt;p&gt;　　xadmin在python的领域就相当于php领域的dz论坛和WordPress的高度可定制版后台！&lt;/p&gt;
&lt;p&gt;　　更通俗点讲，xadmin就像是你的qq空间，但是比qq空间的可定制化高一千倍，能够方便的管理你的各种数据（类比于你qq空间中的日志、说说、签名、照片……）&lt;/p&gt;
&lt;h2&gt;1.django2下安装xadmin&lt;/h2&gt;
&lt;p&gt; 1.xadmin的django2下载地址：&lt;a href=&quot;https://github.com/sshwsfc/xadmin/tree/django2&quot;&gt;https://github.com/sshwsfc/xadmin/tree/django2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 2.打开地址→确认下载的是django2的，点击Clone or download→点击Download ZIP→选择下载到一个没有中文的目录下→点击下载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282071/201805/1282071-20180501103101089-154140457.png&quot; alt=&quot;&quot; width=&quot;748&quot; height=&quot;366&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.打开Terminal执行安装命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
pip install --cache-&lt;span&gt;dir
pip install d:&lt;/span&gt;/xadmin-django2.zip
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.安装一些必要的库文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;pip crispy_forms
pip reversion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5.打开settings.py 找到INSTALLED_APPS 追加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
INSTALLED_APPS =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.admin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.auth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.contenttypes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.sessions&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.messages&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django.contrib.staticfiles&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;yanzheng.apps.YanzhengConfig&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
 &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;追加代码:   &lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;xadmin&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;crispy_forms&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;reversion&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.给urls.py中增加两行代码，就算是给xadmin配置路由了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.contrib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; admin
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.urls &lt;span&gt;import&lt;/span&gt;&lt;span&gt; path
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;引入xadmin&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; xadmin

urlpatterns &lt;/span&gt;=&lt;span&gt; [
    path(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;admin/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, admin.site.urls),
 &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;配置xadmin路由   &lt;/span&gt;
    path(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xadmin/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, xadmin.site.urls),
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7.安装配置好了，不要忘了更新数据库，打开Terminal，执行经典的两条命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;python manage.py makemigrations
python manage.py migrate&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8.重新运行项目，浏览器访问http://127.0.0.1:8000/xadmin/  即可看到xadmin的登录界面（上次登录admin的时候如果没注销登出，因为cookie的缘故，会直接出现已经登录的界面。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282071/201805/1282071-20180501213328586-217679127.png&quot; alt=&quot;&quot; width=&quot;689&quot; height=&quot;354&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282071/201805/1282071-20180501213906553-1285513933.png&quot; alt=&quot;&quot; width=&quot;762&quot; height=&quot;347&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.django2下配置xadmin&lt;/h2&gt;
&lt;h3&gt;1.至此成功登录了，但是由于后面还要自定义一些xadmin的插件（比如一键导出生成的卡密插件），所以要将xadmin导入项目中：&lt;/h3&gt;
&lt;p&gt;1.在项目netauth目录下，新建apps和extra_apps，将yanzheng拖入apps目录下。&lt;/p&gt;
&lt;p&gt;2.在d盘目录下找到下载的xadmin-django2.zip，右键解压文件→确定，解压后的文件夹中，找到xadmin-django2/xadmin-django2目录下的xadmin文件夹，复制到项目中extra_apps目录下，注意Search for reference 和Open moved files in editer 都不要勾选！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282071/201805/1282071-20180501112233748-1724394628.png&quot; alt=&quot;&quot; width=&quot;906&quot; height=&quot;457&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.extra_apps右键→Mark Directory as→Sources Root（&lt;strong&gt;对apps目录也要做同样的事&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1282071/201805/1282071-20180501112735745-636071143.png&quot; alt=&quot;&quot; width=&quot;460&quot; height=&quot;464&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.在settings.py 中，找到：BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))，import sys 添加补全代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
import os,sys

# Build paths inside the project like this: os.path.join(BASE_DIR, ...)
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0,os.path.join(BASE_DIR,'apps'))
sys.path.insert(1,os.path.join(BASE_DIR,'extra_apps'))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;.5.打开Terminal终端，卸载最先安装的xadmin&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;pip uninstall xadmin
y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;不要觉得先安装，又导入，又卸载，这个过程有什么可以省略的，一步也不能少，不然掉到坑里，爬不上来哦。&lt;/h2&gt;

&lt;p&gt;1.在apps/yanzheng/models.py中，将网络验证相关的表建完（其实就俩表，还都很简单）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.db &lt;span&gt;import&lt;/span&gt;&lt;span&gt; models
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.contrib.auth.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; AbstractUser
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; datetime &lt;span&gt;import&lt;/span&gt;&lt;span&gt; datetime
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Create your models here.&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserProfile(AbstractUser):
    is_ban&lt;/span&gt;=models.BooleanField(default=False,verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;是否被禁&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    end_time&lt;/span&gt;=models.DateTimeField(default=datetime.now, verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;到期时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        verbose_name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户信息&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        verbose_name_plural&lt;/span&gt;=&lt;span&gt;verbose_name
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self.username


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cards(models.Model):

    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;充值卡&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    user&lt;/span&gt;=models.ForeignKey(UserProfile,verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;使用者&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,on_delete=&lt;span&gt;models.CASCADE)
    kacode&lt;/span&gt;=models.CharField(max_length=50,verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;卡密&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,default=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
    time&lt;/span&gt;=models.IntegerField(default=3600,verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;时长&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    is_used&lt;/span&gt;=models.BooleanField(default=False,verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;是否已经使用&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    add_time&lt;/span&gt;=models.DateTimeField(default=datetime.now,verbose_name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;生成时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Meta:
        verbose_name&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;卡密&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        verbose_name_plural&lt;/span&gt;=&lt;span&gt;verbose_name
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.kacode
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打开Terminal，执行数据更新命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;python manage.py makemigrations
python manage.py migrate&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;这里有一个坑：&lt;/h2&gt;
&lt;p&gt;　　数据更新的时候，如果数据类中，有DateTimeField字段，只能在第一次创建时，数据更新命令能成功，如果已经执行了数据更新命令，再修改DateTimeField字段的默认值，就会时间格式不对的错误，很烦人！&lt;/p&gt;
&lt;p&gt;　　解决办法：将apps/yanzheng/makemigrations目录下，除了__init__.py以外的文件都删掉，再执行数据更新命令，就可以了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1282071/201805/1282071-20180501231836690-512711057.png&quot; alt=&quot;&quot; width=&quot;376&quot; height=&quot;442&quot;/&gt;&lt;/p&gt;






</description>
<pubDate>Tue, 01 May 2018 15:25:00 +0000</pubDate>
<dc:creator>雪落忆海</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuepangzi/p/8978011.html</dc:identifier>
</item>
<item>
<title>ABP框架 - 模块系统 - lcyhjx</title>
<link>http://www.cnblogs.com/lcyhjx/p/8978010.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lcyhjx/p/8978010.html</guid>
<description>&lt;p&gt;ABP提供了基础设施功能来构建模块，并通过组合这些模块来创建应用。一个模块可以依赖于另一个模块。一般来讲，一个程序集被认为和定义成一个模块。如果你的应用包含多个程序集，那么你可以为每一个程序集都定义一个模块。&lt;/p&gt;

&lt;p&gt;ABP中的一个模块是由继承于AbpModule（AbpModule定义在ABP package中）的一个类来定义的。比如我们开发了一个博客模块，可以被不同的应用程序使用，那么一个最简单的博客模块定义如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class MyBlogApplicationModule : AbpModule
{
    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义模块的类有一个职责就是通过依赖注入来注册模块中的类型，如上代码所示:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，除此之外，它还可以配置应用程序，实现新的功能等等&lt;/p&gt;

&lt;p&gt;当应用程序启动和关闭时，ABP会调用模块中的一组特定方法PreInitialize、Initialize、PostInitialize、Shutdown。你可以重写这些方法来执行特定任务。&lt;/p&gt;
&lt;p&gt;ABP是根据模块之间的依赖顺序来执行模块的这些方法的。例如模块A依赖于模块B，那么模块B就会在模块A之前做初始化。当应用程序启动时，模块A和模块B中这些方法的执行顺序如下：PreInitialize-B--&amp;gt;PreInitialize-A--&amp;gt;Initialize-B--&amp;gt;Initialize-A--&amp;gt;PostInitialize-B--&amp;gt;PostInitialize-A&lt;/p&gt;
&lt;p&gt;当应用程序关闭时，过程与启动类似，只是执行顺序与启动时是相反的。&lt;/p&gt;
&lt;h3 id=&quot;preinitialize&quot;&gt;PreInitialize&lt;/h3&gt;
&lt;p&gt;当启动时，会首先调用PreInitialize方法，它在模块初始化之前执行，所以通常会将框架和模块的配置定义在这里。同时，一些在依赖注入之前执行的代码也会写在这里。例如你定义一个传统的类，那么你需要在这里调用 IocManager.AddConventionalRegisterer 方法来注册它。&lt;/p&gt;
&lt;h3 id=&quot;initialize&quot;&gt;Initialize&lt;/h3&gt;
&lt;p&gt;在Initialize方法中，会通过依赖注入注册模块中定义的类型，一般使用IocManager.RegisterAssemblyByConvention 方法来来注册，当然也可自定义类型注册。&lt;/p&gt;
&lt;h3 id=&quot;postinitialize&quot;&gt;PostInitialize&lt;/h3&gt;
&lt;p&gt;在启动过程中，这是最后一个被调用的方法。在这里可以安全的解析一个依赖。&lt;/p&gt;
&lt;h3 id=&quot;shutdown&quot;&gt;Shutdown&lt;/h3&gt;
&lt;p&gt;在应用关闭时，会调用此方法。&lt;/p&gt;

&lt;p&gt;一个模块可以依赖于另一个模块，你需要使用DependsOn特性来显示的定义模块间的依赖关系，如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[DependsOn(typeof(MyBlogCoreModule))]
public class MyBlogApplicationModule : AbpModule
{
    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，我们定义MyBlogApplicationModule模块依赖于MyBlogCoreModule模块，并且MyBlogCoreModule模块要在MyBlogApplicationModule模块之前进行初始化。&lt;/p&gt;
&lt;p&gt;ABP在启动模块中，自动的解析模块之间的依赖关系并初始化模块。启动模块是最后一个被初始化的模块。&lt;/p&gt;

&lt;p&gt;ABP可以在启动模块中检测、加载模块集，也可以动态的加载模块，这些动态加载的模块就称之为插件模块。&lt;/p&gt;
&lt;p&gt;在动态加载模块时，要指定插件模块的源，在AbpBootstrapper类中定义了一个属性PlugInSources, 就是用来指定插件模块的源。任何一个实现了IPlugInSource接口的类都可以用来定义插件模块的源。&lt;/p&gt;
&lt;p&gt;在ABP中提供了一个默认实现PlugInFolderSource， 用于从指定的文件夹中获取插件模块。&lt;/p&gt;
&lt;h3 id=&quot;asp.net-core&quot;&gt;ASP.NET CORE&lt;/h3&gt;
&lt;p&gt;在ABP ASP.NET Core模块的Startup类中，ABP为AddAbp扩展方法定义了添加插件模块源的选项:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.AddAbp&amp;lt;MyStartupModule&amp;gt;(options =&amp;gt;
{
    options.PlugInSources.Add(new FolderPlugInSource(@&quot;C:\MyPlugIns&quot;));
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以使用AddFolder扩展方法&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.AddAbp&amp;lt;MyStartupModule&amp;gt;(options =&amp;gt;
{
    options.PlugInSources.AddFolder(@&quot;C:\MyPlugIns&quot;);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;asp.net-mvc-web-api&quot;&gt;ASP.NET MVC, Web API&lt;/h3&gt;
&lt;p&gt;如果是ASP.NET MVC应用程序，我们可以重写global.asax中的Application_Start方法来添加插件模块的源:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class MvcApplication : AbpWebApplication&amp;lt;MyStartupModule&amp;gt;
{
    protected override void Application_Start(object sender, EventArgs e)
    {
        AbpBootstrapper.PlugInSources.AddFolder(@&quot;C:\MyPlugIns&quot;);
        //...
        base.Application_Start(sender, e);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;插件模块中的controllers&quot;&gt;插件模块中的Controllers&lt;/h3&gt;
&lt;p&gt;如果你在插件模块中定义了MVC / Web API Controllers， ASP.NET将不能检测到这些Controllers, 要解决这个问题，你需要修改global.asax代码文件如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System.Web;
using Abp.PlugIns;
using Abp.Web;
using MyDemoApp.Web;

[assembly: PreApplicationStartMethod(typeof(PreStarter), &quot;Start&quot;)]

namespace MyDemoApp.Web
{
    public class MvcApplication : AbpWebApplication&amp;lt;MyStartupModule&amp;gt;
    {
    }

    public static class PreStarter
    {
        public static void Start()
        {
            //...
            MvcApplication.AbpBootstrapper.PlugInSources.AddFolder(@&quot;C:\MyPlugIns\&quot;);
            MvcApplication.AbpBootstrapper.PlugInSources.AddToBuildManager();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在ABP中定义了两个接口IAssemblyFinder和ITypeFinder，这两个接口是ABP用来检测应用中的程序中的程序集和类型的。ABP为这两个接口提供了默认实现，在默认实现中，仅仅从上述模块（通过启动模块定义的模块依赖解析出的模块，以及插件模块）中来查找程序集和类型。如果想添加其他程序集，可以重写GetAdditionalAssemblies方法。&lt;/p&gt;

&lt;p&gt;在模块中可以定义自定义方法，模块中的自定义方法可以被其他依赖的模块调用。假设MyModule2模块依赖MyModule1模块，并且想在PreInitialize方法中调用MyModule1模块的自定义方法，如下代码所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class MyModule1 : AbpModule
{
    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }

    public void MyModuleMethod1()
    {
        //this is a custom method of this module
    }
}

[DependsOn(typeof(MyModule1))]
public class MyModule2 : AbpModule
{
    private readonly MyModule1 _myModule1;

    public MyModule2(MyModule1 myModule1)
    {
        _myModule1 = myModule1;
    }

    public override void PreInitialize()
    {
        _myModule1.MyModuleMethod1(); //Call MyModule1's method
    }

    public override void Initialize()
    {
        IocManager.RegisterAssemblyByConvention(Assembly.GetExecutingAssembly());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，我们通过构造函数注入将MyModule1模块注入到MyModule2模块，这样我们就可以在MyModule2模块总调用MyModule1的方法了，但是前提条件是MyModule2模块依赖MyModule1模块。&lt;/p&gt;

&lt;p&gt;ABP中建议使用启动配置(startup configuration)来配置模块&lt;/p&gt;

&lt;p&gt;定义模块的类会被自动注册为单例&lt;/p&gt;
</description>
<pubDate>Tue, 01 May 2018 15:15:00 +0000</pubDate>
<dc:creator>lcyhjx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lcyhjx/p/8978010.html</dc:identifier>
</item>
<item>
<title>CRM客户关系管理系统（八） - zhang_derek</title>
<link>http://www.cnblogs.com/derek1184405959/p/8976851.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/derek1184405959/p/8976851.html</guid>
<description>&lt;h2&gt;第八章、只读字段处理和filter_horizontal的实现&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 8.1.只读字段的处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;（1）kingadmin/admin_base.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; kingadmin/admin_base.py&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseKingAdmin(object):

    list_display &lt;/span&gt;=&lt;span&gt; []
    list_filter &lt;/span&gt;=&lt;span&gt; []
    search_fields &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;只读&lt;/span&gt;
    readonly_fields = []
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）crm/kingadmin.py&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180501172156723-768256328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; （3）kingadmin/form_handle.py&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180501172754645-1290862066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; （4）table_obj_change_component.html&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180501172941773-266104071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{#kingadmin/templates/kingadmin/table_obj_change_component.html#}

{% load kingadmin_tags %}
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-horizontal&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {% csrf_token %}
    {{ form_obj.errors }}
    {% for field in form_obj %}
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-sm-2 control-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ field.label }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-sm-10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            {{ field }}
            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;color: red;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ field.errors.0 }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {% endfor %}
    
    {% for field in admin_class.readonly_fields %}
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-sm-2 control-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ field }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-sm-10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{% get_obj_field_val form_obj field %}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {% endfor %}


    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-sm-offset-11 col-sm-10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-info&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Save&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （5）kingadmin_tags.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@register.simple_tag
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_obj_field_val(form_obj,field):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;获取只读字段的值&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt; getattr(form_obj.instance,field)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在修改的时候没问题，但是在添加的时候会报错（提示那两个只读字段为空，因为设置成了readonly_field，添加的时候确实没有添加值）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180501173245045-681437408.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;下面解决这个报错，在前后端都添加一个判断&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（4）kingadmin/views.py&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180501175535934-381970388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（5）form_handle.py&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180501175642710-1198422240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; （6）table_obj_change_component.html&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180501175741557-1708649379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在增加和修改就都没问题了&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.2.filter_horizontal的实现&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;默认咨询课程后台显示的样子&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180501180508106-395394251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 添加filter_horizontal（数据量大的时候很方便）后显示的样子（可以批量添加，还可以在里面搜索）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180501180742030-1644558031.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180501180910830-6548210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 下面我们在kingadmin中实现这个功能&lt;/p&gt;
&lt;p&gt; （1）kingadmin/admin_base.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; kingadmin/admin_base.py&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseKingAdmin(object):

    list_display &lt;/span&gt;=&lt;span&gt; []
    list_filter &lt;/span&gt;=&lt;span&gt; []
    search_fields &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;只读&lt;/span&gt;
    readonly_fields =&lt;span&gt; []
    filter_horizontal &lt;/span&gt;= []
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）crm/kingadmin.py&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180501201317093-1168203418.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; （3）kingadmin/kingadmin_tags.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@register.simple_tag
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_available_m2m_data(field_name,admin_class):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;返回的是m2m字段关联表的所有数据&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取字段的对象&lt;/span&gt;
    field_obj =&lt;span&gt; admin_class.model._meta.get_field(field_name)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;consult_courses = models.ManyToManyField('Course',verbose_name='咨询课程')&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;consult_courses是一个m2m，通过consult_courses对象获取到Course（也就是获取到所有咨询的课程）&lt;/span&gt;
    obj_list =&lt;span&gt; field_obj.related_model.objects.all()

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj_list
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）table_obj_change_component.html&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; 在生成field的时候判断在不在filter_horizontal里面，在的话就用我们设置的select下拉框，不在就默认的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; {% get_available_m2m_data field.name admin_class as available_m2m_data %}  后面的的 as &lt;span&gt;availavle_m2m_data&lt;/span&gt; 是定义一个变量（里面存了自定义模板标签里面返回的数据 return &lt;span&gt;&lt;strong&gt;&lt;span&gt;obj_list&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　　　因为在前端不能直接循环从后台返回的querysets数据（obj_list），所以前端在引用自定用模板标签的时候可以定义一个变量，里面就保存了所有后台传过来的数据&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{#kingadmin/templates/kingadmin/table_obj_change_component.html#}

{% load kingadmin_tags %}
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-horizontal&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {% csrf_token %}
    {{ form_obj.errors }}
    {% for field in form_obj %}
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-sm-2 control-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ field.label }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-sm-10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            {% if field.name in admin_class.filter_horizontal %}
                &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-lg-5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;multiple class=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% get_available_m2m_data field.name admin_class as available_m2m_data %}
                        {% for obj in available_m2m_data %}
                            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{{ obj.id }}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ obj }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% endfor %}
                    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-lg-5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            {% else %}
                {{ field }}
            {% endif %}
            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;color: red;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ field.errors.0 }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {% endfor %}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180501202555330-394379228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 右边添加一个select框（存放已选中的）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; kingadmin_tags.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@register.simple_tag
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_selected_m2m_data(field_name,form_obj,admin_class):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;返回已选的m2m数据&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取被选中的数据&lt;/span&gt;
    selected_data =&lt;span&gt; getattr(form_obj.instance,field_name).all()

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; selected_data
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;table_obj_change_component.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-lg-5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;multiple class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% get_selected_m2m_data field.name form_obj admin_class as selected_m2m_data %}
                        {% for obj in selected_m2m_data %}
                            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{{ obj.id }}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ obj }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% endfor %}
                    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;效果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;左边不应该显示已被选中的咨询课程了&lt;/li&gt;
&lt;li&gt;右边是已选中的咨询课程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180501204735828-1902114440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;通过集合求差集过滤出左边已选咨询课程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180501205622470-1472552357.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; kingadmin_tags.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@register.simple_tag
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_available_m2m_data(field_name,form_obj,admin_class):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;返回的是m2m字段关联表的所有数据&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取字段的对象&lt;/span&gt;
    field_obj =&lt;span&gt; admin_class.model._meta.get_field(field_name)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;consult_courses = models.ManyToManyField('Course',verbose_name='咨询课程')&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;consult_courses是一个m2m，通过consult_courses对象获取到Course（也就是获取到所有咨询的课程）&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;所有咨询课程的集合&lt;/span&gt;
    obj_list =&lt;span&gt; set(field_obj.related_model.objects.all())
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;选中的咨询课程集合&lt;/span&gt;
    selected_data =&lt;span&gt; set(getattr(form_obj.instance, field_name).all())
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回的时候，集合求差集，得到未选中的咨询课程（左边）&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; obj_list - selected_data
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180501210041074-1992895989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;js触发事件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;table_obj_change_component.html&lt;/p&gt;
&lt;p&gt;可以通过双击咨询课程，来选择&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{#kingadmin/templates/kingadmin/table_obj_change_component.html#}

{% load kingadmin_tags %}
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-horizontal&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt; onsubmit&lt;/span&gt;&lt;span&gt;=&quot;VerficationBeforeSubmit()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {% csrf_token %}
    {{ form_obj.errors }}
    {% for field in form_obj %}
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-sm-2 control-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ field.label }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-sm-10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            {% if field.name in admin_class.filter_horizontal %}
                &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-lg-5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;id_{{ field.name }}_from&quot;&lt;/span&gt;&lt;span&gt; multiple class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% get_available_m2m_data field.name form_obj admin_class as available_m2m_data %}
                        {% for obj in available_m2m_data %}
                            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{{ obj.id }}&quot;&lt;/span&gt;&lt;span&gt; ondblclick&lt;/span&gt;&lt;span&gt;=&quot;MoveSelectedOption(this,'id_{{ field.name }}_to')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ obj }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% endfor %}
                    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-lg-5&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;tag&lt;/span&gt;&lt;span&gt;=&quot;selected_m2m&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;id_{{ field.name }}_to&quot;&lt;/span&gt;&lt;span&gt; multiple class&lt;/span&gt;&lt;span&gt;=&quot;form-control&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;{{ field.name }}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% get_selected_m2m_data field.name form_obj admin_class as selected_m2m_data %}
                        {% for obj in selected_m2m_data %}
                            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;option &lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;=&quot;{{ obj.id }}&quot;&lt;/span&gt;&lt;span&gt; ondblclick&lt;/span&gt;&lt;span&gt;=&quot;MoveSelectedOption(this,'id_{{ field.name }}_fromm')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ obj }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                        {% endfor %}
                    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
            {% else %}
                {{ field }}
            {% endif %}
            &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;color: red;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ field.errors.0 }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    {% endfor %}

    {% if not admin_class.form_add %}     &lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;如果是修改表单&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;&lt;span&gt;
        {% for field in admin_class.readonly_fields %}
        &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;label &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-sm-2 control-label&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{{ field }}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-sm-10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;{% get_obj_field_val form_obj field %}&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        {% endfor %}
    {% endif %}

    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;form-group&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;col-sm-offset-11 col-sm-10&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;btn btn-info&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Save&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; MoveSelectedOption(ele,target_id){

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; new_target_id &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; $(ele).parent().attr(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; option &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;option value='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;$(ele).val() &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'ondblclick=MoveSelectedOption(this,'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;new_target_id&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;')&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; $(ele).text() &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/option&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; target_id).append(option);
        $(ele).remove();
    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; VerficationBeforeSubmit() {

        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;select[tag] option&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).prop(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;selected&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;现在保存的时候没有问题，但是 添加的时候会报错（因为添加的时候,值都是为空，获取不到filter_horizontal的值所有报错），下一章解决&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1299879/201805/1299879-20180501230616400-185227242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;代码已同步     &lt;a href=&quot;https://github.com/derek-zhang123/PerfectCRM&quot;&gt;num8 只读字段的处理；filter_horizontal的实现&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 01 May 2018 15:13:00 +0000</pubDate>
<dc:creator>zhang_derek</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/derek1184405959/p/8976851.html</dc:identifier>
</item>
<item>
<title>详解BLE 空中包格式—兼BLE Link layer协议解析 - iini</title>
<link>http://www.cnblogs.com/iini/p/8977806.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iini/p/8977806.html</guid>
<description>&lt;p&gt;BLE有几种空中包格式？常见的PDU命令有哪些？PDU和MTU的区别是什么？DLE又是什么？BLE怎么实现重传的？BLE ACK机制原理是什么？希望这篇文章能帮你回答以上问题。&lt;/p&gt;

&lt;p&gt;虽然BLE空中包（packet）涉及BLE协议栈link layer，L2CAP，SMP和ATT等各层次，但link layer跟空中包格式关系最紧密，掌握了BLE packet的格式，就很容易理解BLE link layer协议的工作原理，因此文章取名“详解BLE空中包格式—兼BLE link layer协议解析”&lt;/p&gt;
&lt;h2&gt;BLE Packet格式&lt;/h2&gt;
&lt;p&gt;BLE链路层（link layer）只定义了一种packet（空中包）格式，如下所示：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501220625616-319688615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;而且PDU（protocol data unit，协议数据单元）前两个字节固定为LL header（1个字节长）和payload length（1个字节长，又称data length），即上面的Packet可以展开为：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501220654580-1307125839.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;preamble&lt;/strong&gt;&lt;strong&gt;（前导帧）&lt;/strong&gt;为1个字节，根据Access Address第一个Bit，有两种取值情况：0x55或者0xAA（纯PHY层行为），如下所示：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501220718420-833878642.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;Access Address&lt;/strong&gt;用来标示接收者ID或者空中包身份，如前所示，BLE只有一种packet格式，根据Access Address的不同，又区分两种Packet类型：广播包和数据包：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;广播包&lt;/strong&gt;&lt;strong&gt;Access Address&lt;/strong&gt; &lt;strong&gt;固定为&lt;/strong&gt;&lt;strong&gt;0x8E89BED6&lt;/strong&gt;，广播包只能在广播信道（channel）上传输，即只能在&lt;strong&gt;37/38/39&lt;/strong&gt;&lt;strong&gt;信道上传输&lt;/strong&gt;。广播包发送给附近所有的observer（扫描者）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据包&lt;/strong&gt;&lt;strong&gt;Access Address&lt;/strong&gt;&lt;strong&gt;为一个&lt;/strong&gt;&lt;strong&gt;32bit&lt;/strong&gt;&lt;strong&gt;的随机值，&lt;/strong&gt;由Initiator生成。数据包，其实是数据信道上的空中包的简称，&lt;strong&gt;数据包只在数据信道上传输&lt;/strong&gt;，即除37/38/39之外的其余37信道（BLE总共占用40个信道）。每建立一次连接，重新生成一次Access address。数据包是给连接通信使用的，即用于master和slave之间通信的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;CRC&lt;/strong&gt;为24bit，初始向量为：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501220737366-1372005780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;蓝牙广播包&lt;/h2&gt;
&lt;p&gt;蓝牙广播包，全名蓝牙广播通道（channel）空中包，即在蓝牙广播通道（37/38/39信道（channel））上传输的空中包，为两种空中包的一种，其具体格式如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501220802861-406803904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Advertising Header&lt;/strong&gt;即前述的LL header，长度为一个字节，其每bit定义如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501220819948-1931243325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PDU Type为3bit，具体定义如下。可以看出&lt;strong&gt;扫描&lt;/strong&gt;&lt;strong&gt;PDU&lt;/strong&gt;&lt;strong&gt;和发起连接PDU&lt;/strong&gt;&lt;strong&gt;都属于广播包。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501220837661-1157401939.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;       注：&lt;strong&gt;CONNECT_REQ&lt;/strong&gt;&lt;strong&gt;也可写作CONNECT_IND&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;TxAdd/RxAdd，各占1bit，表示随后的Device Address字段代表的蓝牙MAC地址类型，值0代表Public地址，值1代表Random地址。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Payload length&lt;/strong&gt;定义如下所示，所以广播包PDU最长37个字节。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501220903693-1463482332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Device Address&lt;/strong&gt;，广播包中的强制字段，&lt;strong&gt;俗称蓝牙&lt;/strong&gt;&lt;strong&gt;MAC&lt;/strong&gt;&lt;strong&gt;地址&lt;/strong&gt;，如果是广播包，则是advertiser的MAC地址；如果是scan包或者连接请求包，则是scanner的MAC地址。蓝牙device address为&lt;strong&gt;6&lt;/strong&gt;&lt;strong&gt;个字节&lt;/strong&gt;，这样Advertising data最长为：&lt;strong&gt;37-6 = 31B&lt;/strong&gt;，这就是&lt;strong&gt;广播包数据最长只能&lt;/strong&gt;&lt;strong&gt;31&lt;/strong&gt;&lt;strong&gt;个字节的由来&lt;/strong&gt;。如前所述，device address分public和random两种，定义如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501221039361-578680930.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Random device address又有三种类型，定义如下所示：&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501221101958-748774067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Advertising data&lt;/strong&gt;我会另写一篇文章来详述，这里就不再介绍了。&lt;/p&gt;
&lt;p&gt;如下为一个完整的真实的广播包示例，注意：&lt;strong&gt;BLE&lt;/strong&gt;&lt;strong&gt;空中包采用小端模式。&lt;/strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201804/1366713-20180428222348224-876399692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AAD6BE898E600E3B75AB2A02E102010504FF5900&lt;strong&gt;53&lt;/strong&gt;8EC7B2
&lt;ul&gt;&lt;li&gt;AA – 前导帧(preamble)&lt;/li&gt;
&lt;li&gt;D6BE898E – 访问地址(access address)&lt;/li&gt;
&lt;li&gt;60 – LL帧头字段(LL header)&lt;/li&gt;
&lt;li&gt;0E – 有效数据包长度(payload length)&lt;/li&gt;
&lt;li&gt;3B75AB2A02E1 – 广播者设备地址(advertiser address)&lt;/li&gt;
&lt;li&gt;02010504FF5900&lt;strong&gt;53 –&lt;/strong&gt; &lt;strong&gt;广播数据&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;8EC7B2 – CRC24值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注：上述广播包是蓝牙4.x格式，蓝牙5.0广播包除了包含上述格式外（记住：蓝牙5是跟蓝牙4.x兼容的！），还有一些新的定义，以后我也会写一篇关于蓝牙5广播的文章来专门阐述蓝牙5扩展广播包。&lt;/p&gt;
&lt;h2&gt;蓝牙数据通道空中包（数据包）&lt;/h2&gt;
&lt;p&gt;与蓝牙广播包相对应，蓝牙数据包是另一种BLE packet。蓝牙数据包是蓝牙数据信道空中包的简称，表示空中包只在蓝牙数据信道上传输，即除37/38/39之外的其他37信道。从格式上来说，蓝牙数据包分空包（empty packet）和普通数据包（data packet）两种，空包格式如下。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501221137088-2085206158.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;由图可见，空包整个payload为空，故名空包。                      &lt;/p&gt;
&lt;p&gt;普通数据包格式如下所示：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501221300497-1341056700.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Data header&lt;/strong&gt;，即前述的LL header，在数据包中的定义如下所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501221322522-2083085698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;em&gt;LLID&lt;/em&gt;&lt;/strong&gt;（2bits）， link layer ID，对LL PDU进行分类：LL data PDU和LL control PDU。也就是说，普通的数据信道空中包包含LL数据包和LL控制包两种，具体定义如下所示。请大家注意分清data channel packet（数据信道空中包）和LL data packet（LL数据包）的区别，如前所示data channel packet包含LL data packet和LL control packet，LL data packet只是data channel packet的一种。在不引起上下文歧义的时候，我们把他们统一称作“数据包”。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501221347348-405766457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Link layer支持如下control PDU：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501221403138-138702083.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;em&gt;NESN/SN&lt;/em&gt;&lt;/strong&gt;，NESN和SN各占1bit。SN全称为sequence number，表示当前发送的packet编号。NESN，next expected sequence number，用来告知对方下一个期待的packet的编号。Link layer使用SN来告知对方这个packet是新数据包还是重传包，用NESN来告诉对方你之前发我的包已经收到了（相当于ACK的作用），我现在期待下一个新的数据包了，因此BLE没有专门的ACK包，它是通过NESN/SN来实现ACK和重传双重功能的。请参考如下表格，仔细揣摩NESN和SN是如何编码的，以同时完成ACK和重传功能。&lt;/li&gt;
&lt;/ul&gt;&lt;div align=&quot;center&quot;&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;97&quot;&gt;
&lt;p&gt;&lt;strong&gt;空中包编号&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;108&quot;&gt;
&lt;p&gt;&lt;strong&gt;传输方向&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;86&quot;&gt;
&lt;p&gt;&lt;strong&gt;NESN&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;92&quot;&gt;
&lt;p&gt;&lt;strong&gt;SN&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;81&quot;&gt;
&lt;p&gt;&lt;strong&gt;NESN&lt;/strong&gt;&lt;strong&gt;ꞌ&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71&quot;&gt;
&lt;p&gt;&lt;strong&gt;SN&lt;/strong&gt;&lt;strong&gt;ꞌ&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;97&quot;&gt;
&lt;p&gt;#1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;108&quot;&gt;
&lt;p&gt;M -&amp;gt; S&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;86&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;92&quot;&gt;
&lt;p&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;81&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;97&quot;&gt;
&lt;p&gt;#2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;108&quot;&gt;
&lt;p&gt;S -&amp;gt; M&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;86&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;92&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;81&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;97&quot;&gt;
&lt;p&gt;#3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;108&quot;&gt;
&lt;p&gt;M -&amp;gt; S&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;86&quot;&gt;
&lt;p&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;92&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;81&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71&quot;&gt;
&lt;p&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;97&quot;&gt;
&lt;p&gt;#4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;108&quot;&gt;
&lt;p&gt;S -&amp;gt; M&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;86&quot;&gt;
&lt;p&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;92&quot;&gt;
&lt;p&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;81&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;71&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;我们来分析#3数据包，#3是master发给slave的，那么#3的NESN和SN是如何确定的呢？其实#3的NESN和SN是通过比较#1和#2的NESN/SN的值来确定的，Master把#1传完之后，会把#1包的NESN和SN记录下来，即表格右边的NESNꞌ和SNꞌ。然后Master会拿SNꞌ跟#2的NESN相比，两者不等，说明slave已经收到了#1包，并期待master发一个新的包给它，此时Master会把SNꞌ增1，形成#3包的SN，表示这个数据包是一个新包，然后发出去；两者相等，说明slave没有收到#1包，此时master需要重传。Master还会拿NESNꞌ跟#2的SN相比，两者相等，说明#2包为新包，然后Master会把NESNꞌ增1，形成#3包的NESN发出去，告诉slave我已经收到#2包了并期待你的下一个包；两者不等，说明#2包为重传包。注意：大家可以从上述表格发现一个规律，就是同一方向相邻的两个数据包，他们的NESN和SN与另一个包的NESN和SN是相反的，比如#3 NESN = #1 #NESN ，#3 SN = #1 #SN ，同样#2和#4 各自的NESN和SN是相互相反的。&lt;/p&gt;
&lt;p&gt;我们可以用下面的流程图来描述上述过程。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501221432562-871777355.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;em&gt;MD&lt;/em&gt;&lt;/strong&gt;（1bit），more data，用来指示对方我还有数据包要传，请继续打开射频窗口准备接收。比如Nordic nRF51822一个connection interval可以发6个包或者更多的包（也就是说，一个connection event包含多个数据包交互），用的就是MD来实现的。以notify命令为例，设备（Server）notify第一个数据包并将MD置1，Client（比如手机）收到这个notify命令后，就知道Server还有数据包要传，此时手机可以继续发一个空包给设备，以让设备把第二个notify命令发过来，详情如下所示。注：Master为手机（Client），Slave为设备（Server）。&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501221501180-492948652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Payload Length or Data Length&lt;/strong&gt;，BT4.0/4.1定义如下所示，这就是蓝牙4.0/4.1一个包只能传20个字节的根源。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501221519397-1617265318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;BT4.2之后，Payload length 8 bits全部用来表示长度，这样的话，payload size最大可达251字节（255 – MIC size）。BLE连接建立之后，可以动态更改data length长度（默认为27字节），这个特性叫做&lt;strong&gt;Data Length Extension&lt;/strong&gt;&lt;strong&gt;（DLE&lt;/strong&gt;&lt;strong&gt;）&lt;/strong&gt;，DLE是通过Link layer命令：LL_LENGTH_REQ和LL_LENGTH_RSP来实现的。Data length直接跟蓝牙芯片的射频能力有关，像Nordic的nRF51822只支持BT4.1的Data length，就是因为PHY层已经做死了，无法扩展，但Nordic最新的nRF52832和nRF52840，就都支持DLE，即data length最大可到251字节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;L2CAP length&lt;/strong&gt;，2字节长度，表示后面information payload的长度，information payload最大长度除了受这个L2CAP length字段约束，同时还受MTU的限制。MTU，Maximum Transmission Unit，是ATT层与L2CAP层可以交互的最大数据长度，或者说是Client与Server可以交互的最大长度。&lt;/p&gt;
&lt;p&gt;总结一下，蓝牙spec里面定义了2个长度字段：LL data length和L2CAP length，同时ATT层还定义了一个MTU，以限制ATT PDU最大长度。LL data length可以通过LL_LENGTH_REQ和LL_LENGTH_RSP动态改变，MTU size则可以通过后面要讲到的Exchange MTU Request和Exchange MTU Response来改变，而L2CAP length无法动态改变，也就是说不能超过65535。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;L2CAP CID&lt;/strong&gt;，2字节长度，逻辑通道的ID，BLE使用固定的通道编号，定义如下所示：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501221542406-1709582830.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;BLE L2CAP Signaling Channel&lt;/em&gt;&lt;/strong&gt;支持的PDU命令只有三个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Command reject&lt;/li&gt;
&lt;li&gt;Connection parameter update request，更新连接参数，比如最小连接间隔，最大连接间隔，slave latency等&lt;/li&gt;
&lt;li&gt;Connection parameter update response，接受或者拒绝上面的请求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Security Manager Protocol&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;（SMP&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;）&lt;/em&gt;&lt;/strong&gt;用来实现配对和密钥分发的，SMP支持如下PDU命令：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501221608472-685507063.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Attribute Protocol&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;（ATT&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;）&lt;/em&gt;&lt;/strong&gt;，就是我们经常用到的应用层，应用数据就跟在ATT命令后面，ATT支持如下命令列表：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201805/1366713-20180501221626184-1521124503.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;如下为一个完整的真实的数据包示例，注意：&lt;strong&gt;BLE&lt;/strong&gt;&lt;strong&gt;空中包采用小端模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1366713/201804/1366713-20180428222526803-270666623.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AAAB5D65501E08040004001B130053D550F6
&lt;ul&gt;&lt;li&gt;AA – 前导帧(preamble)&lt;/li&gt;
&lt;li&gt;0x50655DAB – 访问地址(access address)&lt;/li&gt;
&lt;li&gt;1E – LL帧头字段(LL header)&lt;/li&gt;
&lt;li&gt;08 – 有效数据包长度(payload length)&lt;/li&gt;
&lt;li&gt;04000400 – ATT数据长度，以及L2CAP通道编号&lt;/li&gt;
&lt;li&gt;1B – notify command&lt;/li&gt;
&lt;li&gt;0x0013 – 电量数据handle&lt;/li&gt;
&lt;li&gt;0x53 – 真正要发送的电量数据&lt;/li&gt;
&lt;li&gt;0xF650D5 – CRC24值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 01 May 2018 14:19:00 +0000</pubDate>
<dc:creator>iini</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iini/p/8977806.html</dc:identifier>
</item>
<item>
<title>Arrays的二分查找 - tosser</title>
<link>http://www.cnblogs.com/tosser/p/8977800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tosser/p/8977800.html</guid>
<description>&lt;p&gt;　　二分查找也称为折半查找，是对有序元素查找的一种算法，在查找的过程中，不断的将搜索长度减半，因此效率不错。Java的JDK提供了二分法查找的算法，使用的方法是Arrays.binarySearch()。binarySearch()方法提供了多种数据类型的二分查找，比如实现了int、float、double、char、byte和Object类型，还提供了对泛型的支持。在JavaAPI手册中提供了接口说明，比如如下方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int &lt;/span&gt;binarySearch(&lt;span&gt;long&lt;/span&gt;[] a, &lt;span&gt;int&lt;/span&gt; fromIndex, &lt;span&gt;int&lt;/span&gt; toIndex, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; key)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int &lt;/span&gt;binarySearch(&lt;span&gt;long&lt;/span&gt;[] a, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; key)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int &lt;/span&gt;binarySearch(Object[] a, &lt;span&gt;int&lt;/span&gt; fromIndex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; toIndex, Object key)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int &lt;/span&gt;&lt;span&gt;binarySearch(Object[] a, Object key)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int &lt;/span&gt;binarySearch(&lt;span&gt;short&lt;/span&gt;[] a, &lt;span&gt;int&lt;/span&gt; fromIndex, &lt;span&gt;int&lt;/span&gt; toIndex, &lt;span&gt;short&lt;/span&gt;&lt;span&gt; key)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int &lt;/span&gt;binarySearch(&lt;span&gt;short&lt;/span&gt;[] a, &lt;span&gt;short&lt;/span&gt;&lt;span&gt; key)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;int &lt;/span&gt;binarySearch(T[] a, &lt;span&gt;int&lt;/span&gt; fromIndex, &lt;span&gt;int&lt;/span&gt; toIndex, T key, Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;&lt;span&gt; c)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;int &lt;/span&gt;binarySearch(T[] a, T key, Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt; c)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上是Arrays类中提供的部分关于binanrySearch()方法的定义，对于不同类型来说，基本提供了两种方法，第一种方法需要在调用时提供数组、开始下标、结束下标和查找的值，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; binarySearch(&lt;span&gt;long&lt;/span&gt;[] a, &lt;span&gt;int&lt;/span&gt; fromIndex, &lt;span&gt;int&lt;/span&gt; toIndex, &lt;span&gt;long&lt;/span&gt; key)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　另外一种查找的方法是提供数组和查找的值即可，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; binarySearch(&lt;span&gt;long&lt;/span&gt;[] a, &lt;span&gt;long&lt;/span&gt; key)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于这两种搜索方法，在Java中提供了统一的调用方法，可以查看其代码，在Java的安装目录下找到src.zip文件，该文件是Java的部分源码。将src.zip文件解压缩，在java/util/Arrays.java中可以找到以上两个方法的实现，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; binarySearch(&lt;span&gt;long&lt;/span&gt;[] a, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; key) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; binarySearch0(a, 0&lt;span&gt;, a.length, key);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; binarySearch(&lt;span&gt;long&lt;/span&gt;[] a, &lt;span&gt;int&lt;/span&gt; fromIndex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; toIndex,
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;                                &lt;span&gt;long&lt;/span&gt;&lt;span&gt; key) {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    rangeCheck(a.length, fromIndex, toIndex);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; binarySearch0(a, fromIndex, toIndex, key);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从代码中可以看到，两个方法最后都调用了binarySearch0()方法，但是在第二个binarySearch()方法中调用了rangeCheck()方法，该方法用于检查数组长度、开始下标和结束下标的正确性，rangeCheck()方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Checks that {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; fromIndex} and {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; toIndex} are in
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * the range and throws an exception if they aren't.
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rangeCheck(&lt;span&gt;int&lt;/span&gt; arrayLength, &lt;span&gt;int&lt;/span&gt; fromIndex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; toIndex) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (fromIndex &amp;gt;&lt;span&gt; toIndex) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &quot;fromIndex(&quot; + fromIndex + &quot;) &amp;gt; toIndex(&quot; + toIndex + &quot;)&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (fromIndex &amp;lt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayIndexOutOfBoundsException(fromIndex);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (toIndex &amp;gt;&lt;span&gt; arrayLength) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayIndexOutOfBoundsException(toIndex);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果调用第一个binarySearch()方法，数组长度、开始下标和结束下标是方法中自行获取的，因此不需要进行rangeCheck()，而调用第二个binarySearch()方法时，数组长度、开始下标和结束下标是调用时外部提供的，因此为了保证正确性进行了rangeCheck()。&lt;/p&gt;
&lt;p&gt;　　二分法真正的实现是binarySearch0()方法，根据不同的数据类型，binarySearch0()方法也提供了多种重载，这里只看long类型的实现，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; binarySearch0(&lt;span&gt;long&lt;/span&gt;[] a, &lt;span&gt;int&lt;/span&gt; fromIndex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; toIndex,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                                  &lt;span&gt;long&lt;/span&gt;&lt;span&gt; key) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; low =&lt;span&gt; fromIndex;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; high = toIndex - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (low &amp;lt;=&lt;span&gt; high) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; mid = (low + high) &amp;gt;&amp;gt;&amp;gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; midVal =&lt;span&gt; a[mid];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (midVal &amp;lt;&lt;span&gt; key)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             low = mid + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (midVal &amp;gt;&lt;span&gt; key)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             high = mid - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; mid; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; key found&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; -(low + 1);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; key not found.&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　二分查找的思路是从有序（从小到大）数组的中间位置开始查找，如果中间位置的数小于查找的目标值，则查找数组中间值右侧的部分，如果中间位置的数大于查找的目标值，则查找数组中间值左侧的部分，如果相等，则返回当前的下标，如果没有找到则返回一个负数。&lt;/p&gt;

&lt;p&gt;　　除了上面的实现外，还有一种针对泛型的binarySeach()的方法，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;int&lt;/span&gt; binarySearch(T[] a, &lt;span&gt;int&lt;/span&gt; fromIndex, &lt;span&gt;int&lt;/span&gt; toIndex, T key, Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;&lt;span&gt; c)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;int&lt;/span&gt; binarySearch(T[] a, T key, Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt; c)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在上面两个方法的定义中，最后一个参数是一个比较器，比较器的作用是比较两个元素的大小用的，查看以上两个方法的实现，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;int&lt;/span&gt; binarySearch(T[] a, T key, Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;&lt;span&gt; c) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; binarySearch0(a, 0&lt;span&gt;, a.length, key, c);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;int&lt;/span&gt; binarySearch(T[] a, &lt;span&gt;int&lt;/span&gt; fromIndex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; toIndex,
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;                                    T key, Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;&lt;span&gt; c) {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    rangeCheck(a.length, fromIndex, toIndex);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; binarySearch0(a, fromIndex, toIndex, key, c);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上两个方法同样调用了binarySearch0()方法，该binarySearch0()方法的实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;int&lt;/span&gt; binarySearch0(T[] a, &lt;span&gt;int&lt;/span&gt; fromIndex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; toIndex,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                                      T key, Comparator&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;&lt;span&gt; c) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; binarySearch0(a, fromIndex, toIndex, key);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; low =&lt;span&gt; fromIndex;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; high = toIndex - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (low &amp;lt;=&lt;span&gt; high) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; mid = (low + high) &amp;gt;&amp;gt;&amp;gt; 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         T midVal =&lt;span&gt; a[mid];
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; cmp =&lt;span&gt; c.compare(midVal, key);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (cmp &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             low = mid + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (cmp &amp;gt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             high = mid - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; mid; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; key found&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; -(low + 1);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; key not found.&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　观察代码的第12行，c是比较器，该比较器中提供了一个compare()方法用来比较两个元素的大小，如果midVal比key小，compare返回负数，如果midVal比key大，compare返回整数，如果midVal和key相等，compare则返回0。&lt;/p&gt;

&lt;p&gt;　　以上就是在学习Arrays工具类的使用时，顺便阅读了它的实现，而刚好又能看懂，所以记录在此！&lt;/p&gt;
</description>
<pubDate>Tue, 01 May 2018 14:18:00 +0000</pubDate>
<dc:creator>tosser</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tosser/p/8977800.html</dc:identifier>
</item>
<item>
<title>Redis从入门到精通：中级篇 - 五月的仓颉</title>
<link>http://www.cnblogs.com/xrq730/p/8944539.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xrq730/p/8944539.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;原文链接：http://www.cnblogs.com/xrq730/p/8944539.html，转载请注明出处，谢谢&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;本文目录&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上一篇文章以认识Redis为主，写了Redis系列的第一篇，现在开启第二部分的学习，在本文中，我们将看到以下内容：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Redis数据结构String、Hash、List、Set、SortedSet及相关操作，提一下Redis在3.2.0之后有新增了一种GEO的数据类型表示地理位置，不过本文这种数据结构略过&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis其他一些常用命令，分为Key操作与服务器操作&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis事务机制&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;主要以实战为主，希望通过本文可以让大家掌握Redis的基本使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本来这篇文章还准备加上Redis线程模型分析的，但是写完发现篇幅实在太长，就把Redis线程模型放到最后一篇中了，也挺好的，本文专注于对Redis命令的讲解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外说一下，本文讲Redis中的数据结构，但是&lt;span&gt;&lt;strong&gt;数据结构本身不在本文的讲解范围内&lt;/strong&gt;&lt;/span&gt;，如果想知道Hash、List、Set等数据结构特点及使用场景，可以自己查阅数据结构相关资料。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;String数据结构的基本操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先说一下数据结构String，这是Redis中最简单的一种数据结构，和MemCache数据结构是一样的，即Key-Value型的数据，根据Redis官方文档，&lt;span&gt;&lt;strong&gt;Value最大值为512M&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面用表格来看一下String操作的相关命令：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;用法&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;&lt;span&gt;SET&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）将字符串值Value关联到Key&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Key已关联则覆盖，无视类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）原本Key带有生存时间TTL，那么TTL被清除&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;SET key value [EX seconds] [PX milliseconds] [NX|XX]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;GET&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）返回key关联的字符串值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Key不存在返回nil&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）Key存储的不是字符串，返回错误，因为GET只用于处理字符串&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;GET key&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td&gt;&lt;span&gt;MSET&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）同时设置一个或多个Key-Value键值对&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）某个给定Key已经存在，那么MSET新值会覆盖旧值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）如果上面的覆盖不是希望的，那么使用MSETNX命令，所有Key都不存在才会进行覆盖&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）&lt;span&gt;&lt;strong&gt;MSET是一个原子性操作&lt;/strong&gt;&lt;/span&gt;，所有Key都会在同一时间被设置，不会存在有些更新有些没更新的情况&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;MSET key value [key value ...]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;MGET&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）返回一个或多个给定Key对应的Value&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）某个Key不存在那么这个Key返回nil&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;MGET key [key ...]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.5&quot;&gt;&lt;td&gt;&lt;span&gt;SETEX&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）将Value关联到Key&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）设置Key生存时间为seconds，单位为秒&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）如果Key对应的Value已经存在，则覆盖旧值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）SET也可以设置失效时间，但是不同在于SETNX是一个原子操作，即关联值与设置生存时间同一时间完成&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;SETEX key seconds value&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;&lt;span&gt;SETNX&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）将Key的值设置为Value，当且仅当Key不存在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）若给定的Key已经存在，SEXNX不做任何动作&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;SETNX key value&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;首先，演示一下SET、GET、SETEX的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201805/801753-20180501141734320-1955887322.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图中我们应该能看到SET、GET、SETNX几个命令的效果了，在这之外，专门提两点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Redis的命令不区分大小写&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis的Key区分大小写&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;接着我们演示一下SETEX命令的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201805/801753-20180501143219282-1842958527.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里顺带介绍了TIME命令，它返回的是当前服务器Unix时间戳，但单位为秒（通常Unix时间戳取的时间为毫秒）。看到设置Redis-Expire这个Key，马上获取不失效，第26秒获取的时候失效，关于失效，Redis的策略是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;被动触发，即GET的时候检查一下Key是否失效&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;主动触发，后台每1秒跑10次定时任务（通过redis.conf的hz参数配置，默认为10，这个上文没有写），随机选择100个设置了过期时间的Key，对过期的Key进行失效&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;最后看一下MGET和MSET命令：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201805/801753-20180501144140019-385848700.png&quot; alt=&quot;&quot; width=&quot;476&quot; height=&quot;197&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看到可以同时设置多个Key-Value，也可以同时获取多个Key对应的Value，再次注意，Redis的Key是严格区分大小写的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;特殊的String操作：INCR/DECR&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面介绍的是基本的Key-Value操作，下面介绍一种特殊的Key-Value操作即INCR/DECR，可以利用Redis自动帮助我们对一个Key对应的Value进行加减，用表格看一下相关命令：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;用法&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;&lt;span&gt;INCR&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）Key中存储的数字值+1，返回增加之后的值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）Key不存在，那么Key的值被初始化为0再执行INCR&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）如果值包含错误类型或者字符串不能被表示为数字，那么返回错误&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）值限制在64位有符号数字表示之内，即-9223372036854775808~9223372036854775807&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;INCR key&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;DECR&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）Key中存储的数字值-1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）其余同INCR&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;DECR key&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;INCRBY&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）将key所存储的值加上增量返回增加之后的值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）其余同INCR&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;INCRBY key increment&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;span&gt;DECRBY&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）将key所存储的值减去减量decrement&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）其余同INCR&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;DECRBY key decrement&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;下面实际看一下四个命令相关使用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201805/801753-20180501145346972-911355347.png&quot; alt=&quot;&quot; width=&quot;467&quot; height=&quot;177&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;INCR/DECR在实际工作中还是非常管用的，举两个例子：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;原先单机环境中统计在线人数，变成分布式部署之后可以使用INCR/DECR&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;由于Redis本身极高的读写性能，一些秒杀的场景库存增减可以基于Redis来做而不是直接操作DB&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Hash数据结构相关操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;接着讲一下Hash，Hash本质上和String是一样的，无非String是纯粹的Key-Value，Hash是外面套了一层东西，里面还是Key-Value，接着我们用表格看一下Hash数据结构的相关命令：&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;16.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;用法&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;HSET&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）将哈希表Key中的域field的值设为value&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）key不存在，一个新的Hash表被创建&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）field已经存在，旧的值被覆盖&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;HSET key field value&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;HGET&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;（1）返回哈希表key中给定域field的值&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;HGET key field&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;HDEL&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）删除哈希表key中的一个或多个指定域&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）不存在的域将被忽略&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;HDEL key filed [field ...]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;HEXISTS&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;（1）查看哈希表key中，给定域field是否存在，存在返回1，不存在返回0&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;HEXISTS key field&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt; HGETALL &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;（1）返回哈希表key中，所有的域和值 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;HGETALL key &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;&lt;span&gt;HINCRBY&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt; （1）为哈希表key中的域field加上增量increment&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）其余同INCR命令&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;HINCRYBY key filed increment &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;HKEYS&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;（1）返回哈希表key中的所有域 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;HKEYS key&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;HLEN&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;（1）返回哈希表key中域的数量 &lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;HLEN key &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;&lt;span&gt;HMGET&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）返回哈希表key中，一个或多个给定域的值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）如果给定的域不存在于哈希表，那么返回一个nil值&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;HMGET key field [field ...]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;&lt;span&gt;HMSET&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）同时将多个field-value对设置到哈希表key中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）会覆盖哈希表中已存在的域&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）key不存在，那么一个空哈希表会被创建并执行HMSET操作&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;&lt;span&gt;HMSET key field value [field value ...]&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;HVALS&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;（1）返回哈希表key中所有的域和值&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;HVALS key&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;同样的，实际看一下这些命令的相关使用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201805/801753-20180501154219532-1837944226.png&quot; alt=&quot;&quot; width=&quot;510&quot; height=&quot;437&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;稍乱，但是除了HMSET、HMGET以外把所有命令都演示到了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;List数据结构相关操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着我们看一下Redis中的List，相关命令有：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;25.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;用法&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;LPUSH&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;（1）将一个或多个值value插入到列表key的表头&lt;/p&gt;
&lt;p&gt;（2）如果有多个value值，那么各个value值按从左到右的顺序依次插入表头&lt;/p&gt;
&lt;p&gt;（3）key不存在，一个空列表会被创建并执行LPUSH操作&lt;/p&gt;
&lt;p&gt;（4）key存在但不是列表类型，返回错误&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;LPUSH key value [value ...]&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;LPUSHX&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;（1）将值value插入到列表key的表头，当且晋档key存在且为一个列表&lt;/p&gt;
&lt;p&gt;（2）key不存在时，LPUSHX命令什么都不做&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;LPUSHX key value&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;LPOP&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;（1）移除并返回列表key的头元素&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;LPOP key&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td&gt;LRANGE&lt;/td&gt;
&lt;td readability=&quot;14&quot;&gt;
&lt;p&gt;（1）返回列表key中指定区间内的元素，区间以偏移量start和stop指定&lt;/p&gt;
&lt;p&gt;（2）start和stop都以0位底&lt;/p&gt;
&lt;p&gt;（3）可使用负数下标，-1表示列表最后一个元素，-2表示列表倒数第二个元素，以此类推&lt;/p&gt;
&lt;p&gt;（4）start大于列表最大下标，返回空列表&lt;/p&gt;
&lt;p&gt;（5）stop大于列表最大下标，stop=列表最大下标&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;LRANGE key start stop&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;LREM&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;（1）根据count的值，移除列表中与value相等的元素&lt;/p&gt;
&lt;p&gt;（2）count&amp;gt;0表示从头到尾搜索，移除与value相等的元素，数量为count&lt;/p&gt;
&lt;p&gt;（3）count&amp;lt;0表示从从尾到头搜索，移除与value相等的元素，数量为count&lt;/p&gt;
&lt;p&gt;（4）count=0表示移除表中所有与value相等的元素&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;LREM key count value&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;LSET&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;（1）将列表key下标为index的元素值设为value&lt;/p&gt;
&lt;p&gt;（2）index参数超出范围，或对一个空列表进行LSET时，返回错误&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;LSET key index value&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;LINDEX&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;（1）返回列表key中，下标为index的元素&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;LINDEX key index&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;LINSERT&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;（1）将值value插入列表key中，位于pivot前面或者后面&lt;/p&gt;
&lt;p&gt;（2）pivot不存在于列表key时，不执行任何操作&lt;/p&gt;
&lt;p&gt;（3）key不存在，不执行任何操作&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;LINSERT key BEFORE|AFTER pivot value&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;LLEN&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;（1）返回列表key的长度&lt;/p&gt;
&lt;p&gt;（2）key不存在，返回0&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;LLEN key&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;LTRIM&lt;/td&gt;
&lt;td&gt;（1）对一个列表进行修剪，让列表只返回指定区间内的元素，不存在指定区间内的都将被移除&lt;/td&gt;
&lt;td&gt;LTRIM key start stop&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;RPOP&lt;/td&gt;
&lt;td&gt;（1）移除并返回列表key的尾元素&lt;/td&gt;
&lt;td&gt;RPOP key&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;RPOPLPUSH&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;在一个原子时间内，执行两个动作：&lt;/p&gt;
&lt;p&gt;（1）将列表source中最后一个元素弹出并返回给客户端&lt;/p&gt;
&lt;p&gt;（2）将source弹出的元素插入到列表desination，作为destination列表的头元素&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;RPOPLPUSH source destination&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;RPUSH&lt;/td&gt;
&lt;td&gt;（1）将一个或多个值value插入到列表key的表尾&lt;/td&gt;
&lt;td&gt;RPUSH key value [value ...]&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;RPUSHX&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;（1）将value插入到列表key的表尾，当且仅当key存在并且是一个列表&lt;/p&gt;
&lt;p&gt;（2）key不存在，RPUSHX什么都不做&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;RPUSHX key value&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;接着看一下这些命令的实际使用效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201805/801753-20180501162636412-1221287696.png&quot; alt=&quot;&quot; width=&quot;328&quot; height=&quot;510&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;工具所限，LSET、LINSERT、RPOPLPUSH几个命令没法演示，上面演示了其他的基本命令，应该足以理解Redis的List了，&lt;span&gt;&lt;strong&gt;操作List千万注意区分LPUSH、RPUSH两个命令，把数据添加到表头和把数据添加到表尾是完全不一样的两种结果&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外List还有BLPOP、BRPOP、BRPOPLPUSH三个命令没有说，它们是几个POP的阻塞版本，&lt;span&gt;&lt;strong&gt;即没有数据可以弹出的时候将阻塞客户端直到超时或者发现有可以弹出的元素为止&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;SET数据结构相关操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着我们看一下SET数据结构的相关操作：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;26.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;用法&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td&gt;SADD &lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;（1）将一个或多个member元素加入到key中，已存在在集合的member将被忽略&lt;/p&gt;
&lt;p&gt;（2）假如key不存在，则只创建一个只包含member元素做成员的集合&lt;/p&gt;
&lt;p&gt;（3）当key不是集合类型时，将返回一个错误 &lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;SADD key number [member ...] &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SCARD &lt;/td&gt;
&lt;td&gt; （1）返回key对应的集合中的元素数量&lt;/td&gt;
&lt;td&gt; SCARD key&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;SDIFF&lt;/td&gt;
&lt;td&gt; （1）返回一个集合的全部成员，该集合是第一个Key对应的集合和后面key对应的集合的差集&lt;/td&gt;
&lt;td&gt; SDIFF key [key ...]&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt; SDIFFSTORE&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;（1）和SDIFF类似，但结果保存到destination集合而不是简单返回结果集&lt;/p&gt;
&lt;p&gt;（2） destination如果已存在，则覆盖&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;SDIFFSTORE destionation key [key ...] &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt; SINTER&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt; （1）返回一个集合的全部成员，该集合是所有给定集合的交集&lt;/p&gt;
&lt;p&gt;（2）不存在的key被视为空集&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;SINTER key [key ...] &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;SINTERSTORE &lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;（1）和SINTER类似，但结果保存早destination集合而不是简单返回结果集&lt;/p&gt;
&lt;p&gt;（2）如果destination已存在，则覆盖&lt;/p&gt;
&lt;p&gt;（3）destination可以是key本身&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;SINTERSTORE destination key [key ...] &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SISMEMBER &lt;/td&gt;
&lt;td&gt;（1）判断member元素是否key的成员，0表示不是，1表示是 &lt;/td&gt;
&lt;td&gt;SISMEMBER key member &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;SMEMBERS&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt; （1）返回集合key中的所有成员&lt;/p&gt;
&lt;p&gt;（2）不存在的key被视为空集&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;SMEMBERS key &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td&gt;SMOVE &lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt;（1）原子性地将member元素从source集合移动到destination集合&lt;/p&gt;
&lt;p&gt;（2）source集合中不包含member元素，SMOVE命令不执行任何操作，仅返回0&lt;/p&gt;
&lt;p&gt;（3）destination中已包含member元素，SMOVE命令只是简单做source集合的member元素移除&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; SMOVE source desination member&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td&gt;SPOP&lt;/td&gt;
&lt;td readability=&quot;14&quot;&gt;
&lt;p&gt;（1）移除并返回集合中的一个随机元素，如果count不指定那么随机返回一个随机元素&lt;/p&gt;
&lt;p&gt;（2）count为正数且小于集合元素数量，那么返回一个count个元素的数组且数组中的&lt;span&gt;&lt;strong&gt;元素各不相同&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（3）count为正数且大于等于集合元素数量，那么返回整个集合&lt;/p&gt;
&lt;p&gt;（4）count为负数那么命令返回一个数组，数组中的&lt;span&gt;&lt;strong&gt;元素可能重复多次&lt;/strong&gt;&lt;/span&gt;，数量为count的绝对值&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;SPOP key [count]&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;SRANDMEMBER&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;（1）如果count不指定，那么返回集合中的一个随机元素&lt;/p&gt;
&lt;p&gt;（2）count同上&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;SRANDMEMBER key [count]&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;SREM&lt;/td&gt;
&lt;td&gt;（1）移除集合key中的一个或多个member元素，不存在的member将被忽略&lt;/td&gt;
&lt;td&gt;SREM key member [member ...]&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;SUNION&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;（1）返回一个集合的全部成员，该集合是所有给定集合的并集&lt;/p&gt;
&lt;p&gt;（2）不存在的key被视为空集&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;SUNION key [key ...]&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;SUNIONSTORE&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;（1）类似SUNION，但结果保存到destination集合而不是简单返回结果集&lt;/p&gt;
&lt;p&gt;（2）destination已存在，覆盖旧值&lt;/p&gt;
&lt;p&gt;（3）destination可以是key本身&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;SUNION destination key [key ...]&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;同样，实际测试一下Set：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201805/801753-20180501173626258-1019064680.png&quot; alt=&quot;&quot; width=&quot;421&quot; height=&quot;471&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了SINTER没有用到，其他应该比较全面地展示了Set的相关使用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;SortedSet数据结构相关操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据结构最后说一下SortedSet相关操作，最近有一个场景需要实现Redis分页+高效移除数据，一下子没找到好的数据结构，后来想起了SortedSet才解决了问题，看来积累与储备还是非常有用的，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SortedSet顾名思义，即有序的Set，看下相关命令：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;17&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;用法&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td&gt;ZADD&lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt;（1）将一个或多个member元素及其score值加入有序集key中&lt;/p&gt;
&lt;p&gt;（2）如果member已经是有序集的成员，那么更新member对应的score并重新插入member保证member在正确的位置上&lt;/p&gt;
&lt;p&gt;（3）score可以是整数值或双精度浮点数&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;ZADD key score member [[score member] [score member] ...]&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ZCARD&lt;/td&gt;
&lt;td&gt; （1）返回有序集key的元素个数&lt;/td&gt;
&lt;td&gt;ZCARD key &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; ZCOUNT &lt;/td&gt;
&lt;td&gt;（1） 返回有序集key中，score值&amp;gt;=min且&amp;lt;=max的成员的数量&lt;/td&gt;
&lt;td&gt;ZCOUNT key min max &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12.5&quot;&gt;&lt;td&gt;ZRANGE &lt;/td&gt;
&lt;td readability=&quot;14&quot;&gt;
&lt;p&gt; （1）返回有序集key中指定区间内的成员，成员位置按score从小到大排序&lt;/p&gt;
&lt;p&gt;（2）具有相同score值的成员按字典序排列&lt;/p&gt;
&lt;p&gt;（3）需要成员按score从大到小排列，使用ZREVRANGE命令&lt;/p&gt;
&lt;p&gt;（4）下标参数start和stop都以0为底，也可以用负数，-1表示最后一个成员，-2表示倒数第二个成员&lt;/p&gt;
&lt;p&gt;（5）可通过WITHSCORES选项让成员和它的score值一并返回&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;ZRANGE key start stop [WITHSCORES] &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;ZRANK&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt; （1）返回有序集key中成员member的排名，有序集成员按score值从小到大排列&lt;/p&gt;
&lt;p&gt;（2）排名以0为底，即score最小的成员排名为0&lt;/p&gt;
&lt;p&gt;（3）ZREVRANK命令可将成员按score值从大到小排名&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;ZRANK key number &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;ZREM&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;（1）移除有序集key中的一个或多个成员，不存在的成员将被忽略&lt;/p&gt;
&lt;p&gt;（2）当key存在但不是有序集时，返回错误 &lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;ZREM key member [member ...] &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;ZREMRANGEBYRANK&lt;/td&gt;
&lt;td&gt;（1）移除有序集key中指定排名区间内的所有成员 &lt;/td&gt;
&lt;td&gt;ZREMRANGEBYRANK key start stop &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;ZREMRANGEBYSCORE&lt;/td&gt;
&lt;td&gt;（1）移除有序集key中，所有score值&amp;gt;=min且&amp;lt;=max之间的成员 &lt;/td&gt;
&lt;td&gt;ZREMRANGEBYSCORE key min max &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;还有若干不是很常用的命令没有写，就略过了，有兴趣的可以自己看一下，接着看一下SortedSet实际使用：&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201805/801753-20180501180832146-1755889222.png&quot; alt=&quot;&quot; width=&quot;509&quot; height=&quot;236&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个地方排名的时候稍微注意下，和我们认为的排名有些微区别，比如1 1 2 3，由于有两个1，因此3正序的Rank应当为2（以0为下标），但实际上会是3，所以&lt;span&gt;&lt;strong&gt;Rank应当理解为元素在集合中的下标位置更加准确&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Redis的Key相关操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写完了Redis的数据结构，接着我们看下Redis的Key相关操作：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;17.5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;用法&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;DEL&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;（1）删除给定的一个或多个key&lt;/p&gt;
&lt;p&gt;（2）不存在的Key将被忽略&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;DEL key [key ...]&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;EXISTS&lt;/td&gt;
&lt;td&gt;（1）检查给定key是否存在&lt;/td&gt;
&lt;td&gt;EXISTS key&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;EXPIRE&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;（1）为给定key设置生存时间，key过期时它会被自动删除&lt;/p&gt;
&lt;p&gt;（2）对一个已经指定生存时间的Key设置执行EXPIRE，新的值会代替旧的值&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;EXPIRE key seconds&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;EXPIREAT&lt;/td&gt;
&lt;td&gt;（1）同EXPIRE，但此命令指定的是UNIX时间戳，单位为秒&lt;/td&gt;
&lt;td&gt;EXPIRE key timestamp&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td&gt;KEYS&lt;/td&gt;
&lt;td readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;（1）查找所有符合给定模式pattern的key，下面举一下例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）KEYS *匹配所有key&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）KEYS h?llo匹配hello、hallo、hxllo等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）KEYS h*llo匹配hllo、heeeeello等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）KEYS h[ae]llo匹配hello和hallo&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）特殊符号想当做查找内容经的使用\&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;KEYS pattern&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.5&quot;&gt;&lt;td&gt;
&lt;p&gt;MIGRATE &lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt; （1）原子性地将key从当前实例传送到目标实例指定的数据库上&lt;/p&gt;
&lt;p&gt;（2）原数据库Key删除，新数据库Key增加&lt;/p&gt;
&lt;p&gt;（3）阻塞进行迁移的两个实例，直到迁移成功、迁移失败、等待超时三个之一发生&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;MIGRATE host port key destination-db timeout [COPY] [REPLACE] &lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt; MOVE&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt; （1）将当前数据库的key移动到给定数据库的db中&lt;/p&gt;
&lt;p&gt;（2）执行成功的条件为当前数据库有key，给定数据库没有key&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;MOVE key db &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PERSIST &lt;/td&gt;
&lt;td&gt; （1）移除给定key的生存时间，将key变为持久的&lt;/td&gt;
&lt;td&gt;PERSIST key&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;RANDOMKEY&lt;/td&gt;
&lt;td&gt; （1）从当前数据库随机返回且不删除一个key，&lt;/td&gt;
&lt;td&gt;RANDOMKEY &lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;RENAME&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;（1）将key改名为newkey&lt;/p&gt;
&lt;p&gt;（2）当key和newkey相同或key不存在，报错&lt;/p&gt;
&lt;p&gt;（3）newkey已存在，RENAME将覆盖旧值&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;RENAME key newkey&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;TTL&lt;/td&gt;
&lt;td&gt;（1）以秒为单位，返回给定的key剩余生存时间&lt;/td&gt;
&lt;td&gt;TTL key&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PTTL&lt;/td&gt;
&lt;td&gt;（1）以毫秒为单位，返回给定的key剩余生存时间&lt;/td&gt;
&lt;td&gt;PTTL key&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;TYPE&lt;/td&gt;
&lt;td&gt;（1）返回key锁存储的值的类型&lt;/td&gt;
&lt;td&gt;TYPE key&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;简单看一下实际使用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201805/801753-20180501184358764-465054781.png&quot; alt=&quot;&quot; width=&quot;379&quot; height=&quot;347&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里特别注意KEYS命令，虽然KEYS命令速度非常快，但是当Redis中百万、千万甚至过亿数据的时候，扫描所有Redis的Key，速度仍然会下降，由于Redis是单线程模型，这将导致后面的命令阻塞直到KEYS命令执行完。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此&lt;span&gt;&lt;strong&gt;当Redis中存储的数据达到了一定量级（经验值从10W开始就值得注意了）的时候，必须警惕KEYS造成Redis整体性能下降&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;系统相关命令&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着介绍一下部分系统相关命令：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;21&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;命令&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;用法&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;BGREWRITEAOF&lt;/td&gt;
&lt;td&gt;（1）手动触发AOF重写操作，用于减小AOF文件体积&lt;/td&gt;
&lt;td&gt;BGREWRITEAOF&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;BGSAVE&lt;/td&gt;
&lt;td&gt;（1）后台异步保存当前数据库的数据到磁盘&lt;/td&gt;
&lt;td&gt;BGSAVE&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;CLIENT KILL&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;（1）关闭地址为ip:port的客户端&lt;/p&gt;
&lt;p&gt;（2）由于Redis为单线程设计，因此当当前命令执行完之后才会关闭客户端&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;CLIENT KILL ip:port&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CLIENT LIST&lt;/td&gt;
&lt;td&gt;（1）以可读的格式，返回所有连接到服务器的客户端信息和统计数据&lt;/td&gt;
&lt;td&gt;CLIENT LIST&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;CONFIG GET&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;（1）取得运行中的Redis服务器配置参数&lt;/p&gt;
&lt;p&gt;（2）支持*&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;CONFIG GET parameter&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CONFIG RESETSTAT&lt;/td&gt;
&lt;td&gt;（1）重置INFO命令中的某些统计数据，例如Keyspace hits、Keyspace misses等&lt;/td&gt;
&lt;td&gt;CONFIG RESETSTAT&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CONFIG REWRITE&lt;/td&gt;
&lt;td&gt;（1）对&lt;span&gt;&lt;strong&gt;启动Redis时指定的redis.conf文件进行改写&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;CONFIG REWRITE&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;CONFIG SET&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;（1）动态调整Redis服务器的配置而无需重启&lt;/p&gt;
&lt;p&gt;（2）修改后的配置&lt;span&gt;&lt;strong&gt;立即生效&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;CONFIG SET parameter value&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;SELECT&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;（1）切换到指定数据库，数据库索引index用数字指定，以0作为起始索引值&lt;/p&gt;
&lt;p&gt;（2）默认使用0号数据库&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;SELECT index&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;DBSIZE&lt;/td&gt;
&lt;td&gt;（1）返回当前数据库的Key的数量&lt;/td&gt;
&lt;td&gt;DBSIZE&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;DEBUG OBJECT&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;（1）这是一个调试命令，不应当被客户端使用&lt;/p&gt;
&lt;p&gt;（2）key存在时返回有关信息，key不存在时返回错误&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;DEBUG OBJECT key&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FLUSHALL&lt;/td&gt;
&lt;td&gt;（1）清空整个Redis服务器的数据&lt;/td&gt;
&lt;td&gt;FLUSHALL&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FLUSHDB&lt;/td&gt;
&lt;td&gt;（1）清空当前数据库中的所有数据&lt;/td&gt;
&lt;td&gt;FLUSHDB&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5.5&quot;&gt;&lt;td&gt;INFO&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;（1）以一种易于解释且易于阅读的格式，返回Redis服务器的各种信息和统计数值&lt;/p&gt;
&lt;p&gt;（2）通过给定可选参数section，可以让命令只返回某一部分信息&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;INFO [section]&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;LASTSAVE&lt;/td&gt;
&lt;td&gt;（1）返回最近一次Redis成功将数据保存到磁盘上的时间，以UNIX时间戳格式表示&lt;/td&gt;
&lt;td&gt;LASTSAVE&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;MONITOR&lt;/td&gt;
&lt;td&gt;（1）实时打印出Redis服务器接收到的命令，调试用&lt;/td&gt;
&lt;td&gt;MONITOR&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;SHUTDOWN&lt;/td&gt;
&lt;td readability=&quot;11&quot;&gt;
&lt;p&gt;（1）停止所有客户端&lt;/p&gt;
&lt;p&gt;（2）如果至少有一个保存点在等待，执行SAVE命令&lt;/p&gt;
&lt;p&gt;（3）如果AOF选项被打开，更新AOF文件&lt;/p&gt;
&lt;p&gt;（4）关闭Redis服务器&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;SHUTDOWN [SAVE|NOSAVE]&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;看下命令的使用演示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201805/801753-20180501194945754-2116988899.png&quot; alt=&quot;&quot; width=&quot;810&quot; height=&quot;211&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;SELECT命令忘了，想起来的时候数据库已经清空了就算了，使用SELECT后控制台会变成&quot;&lt;span&gt;&lt;strong&gt;127.0.0.1:6379[3]&amp;gt;&lt;/strong&gt;&lt;/span&gt;&quot;，即带上数据库的index。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Redis的事务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，本文简单说一下Redis的事务机制，首先Redis的事务是由DISCARD、EXEC、MULTI、UNWATCH、WATCH五个命令来保证的：&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr&gt;&lt;td&gt;命令&lt;/td&gt;
&lt;td&gt;描述&lt;/td&gt;
&lt;td&gt;用法&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td&gt;DISCARD&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;（1）取消事务&lt;/p&gt;
&lt;p&gt;（2）如果正在使用WATCH命令监视某个/某些key，那么取消所有监视，等同于执行UNWATCH&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;DISCARD&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;EXEC&lt;/td&gt;
&lt;td readability=&quot;9&quot;&gt;
&lt;p&gt;（1）执行所有事务块内的命令&lt;/p&gt;
&lt;p&gt;（2）如果某个/某些key正处于WATCH命令监视之下且事务块中有和这个/这些key相关的命令，那么&lt;span&gt;&lt;strong&gt;EXEC命令只在这个/这些key没有被其他命令改动的情况下才会执行并生效&lt;/strong&gt;&lt;/span&gt;，否则该事务被打断&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;EXEC&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5.5&quot;&gt;&lt;td&gt;MULTI&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;（1）标记一个事务块的开始&lt;/p&gt;
&lt;p&gt;（2）事务块内的多条命令会按照先后顺序被放入一个队列中，最后&lt;strong&gt;&lt;span&gt;由EXEC命令原子性地执行&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;MULTI&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;UNWATCH&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;（1）取消WATCH命令对所有key的监视&lt;/p&gt;
&lt;p&gt;（2）如果WATCH之后，EXEC/DISCARD命令先被执行了，UNWATCH命令就没必要执行了&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;UNWATCH&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;WATCH&lt;/td&gt;
&lt;td&gt;（1）监视一个/多个key，如果在事务执行之前这个/这些key被其他命令改动，那么事务将被打断&lt;/td&gt;
&lt;td&gt;WATCH key [key ...]&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;首先我们看一下事务没有被打断的情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201805/801753-20180501200542065-1733160911.png&quot; alt=&quot;&quot; width=&quot;244&quot; height=&quot;222&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看到开启事务之后，所有的命令返回的都是QUEUED，即放入队列，而不是直接执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着模拟一下事务被打断的情况，WATCH一下Number这个Key，我另外起了一个Redis客户端INCR了一下Number，结果为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801753/201805/801753-20180501200902932-187527951.png&quot; alt=&quot;&quot; width=&quot;242&quot; height=&quot;138&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看到，并没有命令被执行，返回nil即事务被打断。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着简单说一下事务，和数据库类似的，事务保证的是两点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;隔离&lt;/strong&gt;&lt;/span&gt;，所有命令序列化、按顺序执行，事务执行过程中不会被其他客户端发来的命令打断&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;原子性&lt;/span&gt;&lt;/strong&gt;，事务中的命令要么全部执行，要么全部不执行&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;另外，Redis的事务并不支持回滚，这个其实网上已经说法挺多了，大致上是两个原因：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Redis命令只会因为语法而失败（且这些问题不能再入队时被发现），或是命令用在了错误类型的键上面，也就是说，从实用性角度来说，失败的命令是由于编程错误造成的，而这些错误应该在开发的过程中被发现而不应该出现在生产环境中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Redis内部可以保持简单且快速，因为不需要对回滚进行支持&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;总而言之，对Redis来说，回滚无法解决编程错误带来的问题，因此还不如更简单、更快速地无回滚处理事务。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;下期预告&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后预告一下最后一篇文章会写的内容，四部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Redis线程模型&lt;/li&gt;
&lt;li&gt;Redis的RDB&lt;/li&gt;
&lt;li&gt;Redis的AOF&lt;/li&gt;
&lt;li&gt;Redis的集群方式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;喜欢的朋友可以关注一下最后一篇文章。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 01 May 2018 14:14:00 +0000</pubDate>
<dc:creator>五月的仓颉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xrq730/p/8944539.html</dc:identifier>
</item>
<item>
<title>JAVAEE——BOS物流项目11：在realm中授权、shiro的方法注解权限控制、shiro的标签权限控制、总结shiro的权限控制方式、权限管理 - kent鹏</title>
<link>http://www.cnblogs.com/xieyupeng/p/8977757.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xieyupeng/p/8977757.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1&lt;span&gt;、在&lt;/span&gt;&lt;span&gt;realm&lt;/span&gt;&lt;span&gt;中进行授权&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2&lt;span&gt;、使用&lt;/span&gt;&lt;span&gt;shiro&lt;/span&gt;&lt;span&gt;的方法注解方式权限控制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n &lt;span&gt;在&lt;/span&gt;spring&lt;span&gt;文件中配置开启&lt;/span&gt;&lt;span&gt;shiro&lt;/span&gt;&lt;span&gt;注解支持&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n &lt;span&gt;在&lt;/span&gt;Action&lt;span&gt;方法上使用注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3&lt;span&gt;、★使用&lt;/span&gt;&lt;span&gt;shiro&lt;/span&gt;&lt;span&gt;的标签进行权限控制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n &lt;span&gt;在页面引入&lt;/span&gt;shiro&lt;span&gt;的标签库&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n 在页面中使用标签&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4&lt;span&gt;、总结&lt;/span&gt;&lt;span&gt;shiro&lt;/span&gt;&lt;span&gt;提供的权限控制方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n URL&lt;span&gt;拦截权限控制&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n 方法注解权限控制&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n 页面标签权限控制&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n &lt;span&gt;代码级别权限控制&lt;/span&gt;(&lt;span&gt;了解&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5&lt;span&gt;、权限管理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n 初始化权限数据&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n 添加权限功能&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;n 权限分页查询&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在&lt;/span&gt;BOSRealm&lt;span&gt;中实现授权方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501215731088-508839516.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Todo&lt;span&gt;标识，用于提醒自己有部分代码是需要完善的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501215738468-1608329741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在&lt;/span&gt;Tasks&lt;span&gt;里面就会看见未完成的任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501215746292-270538822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;第一步：在&lt;/span&gt;spring&lt;span&gt;配置文件中开启&lt;/span&gt;&lt;span&gt;shiro&lt;/span&gt;&lt;span&gt;注解支持&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 开启shiro框架注解支持 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;defaultAdvisorAutoProxyCreator&quot;&lt;/span&gt;&lt;span&gt; 
        class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 必须使用cglib方式为Action对象创建代理对象 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;proxyTargetClass&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 配置shiro框架提供的切面类，用于创建代理对象 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;知识回顾：通知&lt;/span&gt;+&lt;span&gt;切入点&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;切面&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果设置成&lt;/span&gt;false&lt;span&gt;，那么会是&lt;/span&gt;&lt;span&gt;JDK&lt;/span&gt;&lt;span&gt;创建出的代理对象，使用的是接口实现，接口是没有实现方法的所以运行程序的时候会报错说找不到方法，因此这里要设置为&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;，用&lt;/span&gt;&lt;span&gt;CGLIB&lt;/span&gt;&lt;span&gt;来创建相应的代理对象，&lt;/span&gt;&lt;span&gt;CGLIB&lt;/span&gt;&lt;span&gt;是以继承的方式创建代理的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;proxyTargetClass&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;第二步：在&lt;/span&gt;Action&lt;span&gt;的方法上使用&lt;/span&gt;&lt;span&gt;shiro&lt;/span&gt;&lt;span&gt;注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501215831727-1732818794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501215838079-1085906281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第三步：在&lt;/span&gt;struts.xml&lt;span&gt;中配置全局异常捕获，当&lt;/span&gt;&lt;span&gt;shiro&lt;/span&gt;&lt;span&gt;框架抛出权限不足异常时，跳转到权限不足提示页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501215849326-1988635251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;第一步：在&lt;/span&gt;jsp&lt;span&gt;页面中引入&lt;/span&gt;&lt;span&gt;shiro&lt;/span&gt;&lt;span&gt;的标签库&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ taglib prefix&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shiro&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; uri&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://shiro.apache.org/tags&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第二步：使用&lt;/span&gt;shiro&lt;span&gt;的标签控制页面元素展示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501215910676-2085905940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p class=&quot;16&quot;&gt;l URL&lt;span&gt;拦截权限控制（基于过滤器实现）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501215919648-2120680940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;16&quot;&gt;l 方法注解权限控制（基于代理技术实现）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501215929937-1011380879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;16&quot;&gt;l 页面标签权限控制（标签技术实现）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501215938087-780334791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;16&quot;&gt;l 代码级别权限控制（基于代理技术实现）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501215945658-1635785728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;6.1 &lt;strong&gt;初始化权限数据&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;当项目上线后，如果正常运行，需要依赖一些基础数据支持。权限数据，就属于基础数据，因为系统的菜单是从权限表查询获得的。一般会提供&lt;/span&gt;sql&lt;span&gt;脚本文件，导入基础数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501215953376-690173074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501220001619-382259508.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;6.2 &lt;strong&gt;添加权限数据&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;页面：&lt;/span&gt;WEB-INF/pages/admin/function_add.jsp&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501220033768-535128278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第一步：修改页面中父功能点对应的&lt;/span&gt;combobox&lt;span&gt;，修改&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501220038757-726046693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501220048788-1755986772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第二步：创建&lt;/span&gt;FunctionAction&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Service&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Dao&lt;/span&gt;&lt;span&gt;，查询所有的权限，返回&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501220055479-663307458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第三步：配置&lt;/span&gt;struts.xml&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501220100537-785330920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501220107815-785145283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;第四步：为添加页面中保存按钮绑定事件，进行校验，如果校验通过就提交表单&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501220113396-137985328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501220118015-1601743361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;第五步：在&lt;/span&gt;FunctionAction&lt;span&gt;中创建&lt;/span&gt;&lt;span&gt;add&lt;/span&gt;&lt;span&gt;方法，添加权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501220122335-131071568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Service&lt;span&gt;代码：（注意：如果不进行非空判断，ParentFunction的值在用户没有对下拉框进行选择的时候是&quot;&quot;空，这个&quot;&quot;是存不进数据库的，会产生异常。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501220130327-1425546902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;6.3 &lt;strong&gt;权限分页查询&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;第一步：修改页面中&lt;/span&gt;datagrid&lt;span&gt;的&lt;/span&gt;&lt;span&gt;URL&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501220248435-771669347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;第二步：在&lt;/span&gt;Action&lt;span&gt;中提供分页查询方法（因为属性驱动的page属性，出现重名的情况，所以要手动给第二个page赋值，不然永远拿不到值）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1135185/201805/1135185-20180501220252436-274453129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 01 May 2018 14:04:00 +0000</pubDate>
<dc:creator>kent鹏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xieyupeng/p/8977757.html</dc:identifier>
</item>
</channel>
</rss>