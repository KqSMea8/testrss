<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>UML类图几种关系的总结 - Super猫小</title>
<link>http://www.cnblogs.com/Super-xing/p/9245768.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Super-xing/p/9245768.html</guid>
<description>&lt;p&gt;在UML类图中，常见的有以下几种关系: 泛化（Generalization）,  实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)&lt;/p&gt;
&lt;p&gt;         1. 泛化（Generalization）&lt;/p&gt;
&lt;p&gt;        【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。&lt;/p&gt;
&lt;p&gt;        【箭头指向】：带三角箭头的实线，箭头指向父类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.open-open.com/lib/uploadImg/20120201/20120201092740_578.gif&quot; alt=&quot;UML类图几种关系的总结&quot; width=&quot;202&quot; height=&quot;315&quot;/&gt; &lt;/p&gt;
&lt;p&gt; 2. 实现（Realization）&lt;/p&gt;
&lt;p&gt;        【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现.&lt;/p&gt;
&lt;p&gt;        【箭头指向】：带三角箭头的虚线，箭头指向接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.open-open.com/lib/uploadImg/20120201/20120201092741_47.gif&quot; alt=&quot;UML类图几种关系的总结&quot; width=&quot;204&quot; height=&quot;284&quot;/&gt; &lt;/p&gt;
&lt;p&gt; 3. 关联（Association)&lt;/p&gt;
&lt;p&gt;        【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。&lt;/p&gt;
&lt;p&gt;        【代码体现】：成员变量&lt;/p&gt;
&lt;p&gt;        【箭头及指向】：带普通箭头的实心线，指向被拥有者&lt;/p&gt;
&lt;p&gt;        上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。 &lt;/p&gt;
&lt;p&gt;        下图为自身关联： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.open-open.com/lib/uploadImg/20120201/20120201092741_335.gif&quot; alt=&quot;UML类图几种关系的总结&quot; width=&quot;233&quot; height=&quot;180&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        4. 聚合（Aggregation）&lt;/p&gt;
&lt;p&gt;        【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。&lt;/p&gt;
&lt;p&gt;        聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。&lt;/p&gt;
&lt;p&gt;        【代码体现】：成员变量&lt;/p&gt;
&lt;p&gt;        【箭头及指向】：带空心菱形的实心线，菱形指向整体&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.open-open.com/lib/uploadImg/20120201/20120201092741_681.gif&quot; alt=&quot;UML类图几种关系的总结&quot; width=&quot;389&quot; height=&quot;319&quot;/&gt; &lt;/p&gt;
&lt;p&gt;5. 组合(Composition)&lt;/p&gt;
&lt;p&gt;        【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。&lt;/p&gt;
&lt;p&gt;       组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。&lt;/p&gt;
&lt;p&gt;【代码体现】：成员变量&lt;/p&gt;
&lt;p&gt;【箭头及指向】：带实心菱形的实线，菱形指向整体&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.open-open.com/lib/uploadImg/20120201/20120201092741_278.gif&quot; alt=&quot;UML类图几种关系的总结&quot; width=&quot;218&quot; height=&quot;299&quot;/&gt;&lt;/p&gt;
&lt;p&gt;   6. 依赖(Dependency)&lt;/p&gt;
&lt;p&gt;        【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖.&lt;/p&gt;
&lt;p&gt;        【代码表现】：局部变量、方法的参数或者对静态方法的调用&lt;/p&gt;
&lt;p&gt;        【箭头及指向】：带箭头的虚线，指向被使用者&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.open-open.com/lib/uploadImg/20120201/20120201092741_129.gif&quot; alt=&quot;UML类图几种关系的总结&quot; width=&quot;196&quot; height=&quot;265&quot;/&gt; &lt;/p&gt;
&lt;p&gt;   各种关系的强弱顺序：&lt;/p&gt;
&lt;p&gt;        泛化 = 实现 &amp;gt; 组合 &amp;gt; 聚合 &amp;gt; 关联 &amp;gt; 依赖 &lt;/p&gt;
&lt;p&gt;        下面这张UML图，比较形象地展示了各种类图关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.open-open.com/lib/uploadImg/20120201/20120201092742_482.png&quot; alt=&quot;UML类图几种关系的总结&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;http://static.open-open.com/lib/uploadImg/20120201/20120201092741_41.gif&quot; alt=&quot;UML类图几种关系的总结&quot; width=&quot;558&quot; height=&quot;159&quot;/&gt; &lt;/p&gt;

</description>
<pubDate>Fri, 29 Jun 2018 15:18:00 +0000</pubDate>
<dc:creator>Super猫小</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Super-xing/p/9245768.html</dc:identifier>
</item>
<item>
<title>python3之MongoDB - Py.qi</title>
<link>http://www.cnblogs.com/zhangxinqi/p/9242687.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxinqi/p/9242687.html</guid>
<description>&lt;h3&gt;1、MongoDB简介&lt;/h3&gt;
&lt;p&gt;MongoDB 是由C++语言编写的，是一个基于分布式文件存储的开源数据库系统。&lt;/p&gt;
&lt;p&gt;在高负载的情况下，添加更多的节点，可以保证服务器性能。&lt;/p&gt;
&lt;p&gt;MongoDB 旨在为WEB应用提供可扩展的高性能数据存储解决方案。&lt;/p&gt;
&lt;p&gt;MongoDB 将数据存储为一个文档，数据结构由键值(key=&amp;gt;value)对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。&lt;/p&gt;
&lt;p&gt;主要特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MongoDB 是一个面向文档存储的数据库，操作起来比较简单和容易。&lt;/li&gt;
&lt;li&gt;你可以在MongoDB记录中设置任何属性的索引 (如：FirstName=&quot;Sameer&quot;,Address=&quot;8 Gandhi Road&quot;)来实现更快的排序。&lt;/li&gt;
&lt;li&gt;你可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性。&lt;/li&gt;
&lt;li&gt;如果负载的增加（需要更多的存储空间和更强的处理能力） ，它可以分布在计算机网络中的其他节点上这就是所谓的分片。&lt;/li&gt;
&lt;li&gt;Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组。&lt;/li&gt;
&lt;li&gt;MongoDb 使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段 。&lt;/li&gt;
&lt;li&gt;Mongodb中的Map/reduce主要是用来对数据进行批量处理和聚合操作。&lt;/li&gt;
&lt;li&gt;Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理。&lt;/li&gt;
&lt;li&gt;Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作。&lt;/li&gt;
&lt;li&gt;GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件。&lt;/li&gt;
&lt;li&gt;MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用即可。&lt;/li&gt;
&lt;li&gt;MongoDB支持各种编程语言:RUBY，PYTHON，JAVA，C++，PHP，C#等多种语言。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MongoDB工具：&lt;/p&gt;
&lt;p&gt;使用于MongoDB管理的工具包括监控工具和GUI&lt;/p&gt;
&lt;p&gt;监控：&lt;/p&gt;
&lt;p&gt;MongoDB提供了网络和系统监控工具Munin，它作为一个插件应用于MongoDB中。&lt;/p&gt;
&lt;p&gt;Gangila是MongoDB高性能的系统监视的工具，它作为一个插件应用于MongoDB中。&lt;/p&gt;
&lt;p&gt;基于图形界面的开源工具 Cacti, 用于查看CPU负载, 网络带宽利用率,它也提供了一个应用于监控 MongoDB 的插件。&lt;/p&gt;
&lt;p&gt;GUI：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Fang of Mongo – 网页式,由Django和jQuery所构成。&lt;/li&gt;
&lt;li&gt;Futon4Mongo – 一个CouchDB Futon web的mongodb山寨版。&lt;/li&gt;
&lt;li&gt;Mongo3 – Ruby写成。&lt;/li&gt;
&lt;li&gt;MongoHub – 适用于OSX的应用程序。&lt;/li&gt;
&lt;li&gt;Opricot – 一个基于浏览器的MongoDB控制台, 由PHP撰写而成。&lt;/li&gt;
&lt;li&gt;Database Master — Windows的mongodb管理工具&lt;/li&gt;
&lt;li&gt;RockMongo — 最好的PHP语言的MongoDB管理工具，轻量级, 支持多国语言.&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2、MongoDB安装&lt;/h3&gt;
&lt;p&gt;（1）windows平台安装MongoDB&lt;/p&gt;
&lt;p&gt;下载地址：https://www.mongodb.com/download-center#community&lt;/p&gt;
&lt;p&gt;直接下载安装文件，然后选择安装路径安装即可，安装完成后通过系统服务启动mongdb&lt;/p&gt;
&lt;p&gt;（2）linux平台安装MongoDB&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
# wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel62-&lt;span&gt;4.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.tgz
# tar xf mongodb&lt;/span&gt;-linux-x86_64-rhel62-&lt;span&gt;4.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.tgz 
# mv mongodb&lt;/span&gt;-linux-x86_64-rhel62-&lt;span&gt;4.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt; /usr/local/&lt;span&gt;mongod

#echo &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;export PATH=$PATH:/usr/local/mongodb/bin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;gt; /etc/&lt;span&gt;profile
# . &lt;/span&gt;/etc/&lt;span&gt;profile
#创建数据目录
# &lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; -p /data/&lt;span&gt;db
#启动服务
# mongod&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更多安装详细：&lt;a href=&quot;https://docs.mongodb.com/manual/installation/&quot; target=&quot;_blank&quot;&gt;https://docs.mongodb.com/manual/installation/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3、mongoDB基本操作&lt;/h3&gt;
&lt;p&gt;（1）创建操作&lt;/p&gt;
&lt;p&gt;创建或插入操作将新的文档添加到集合中，如果集合不存在则插入操作将创建该集合&lt;/p&gt;
&lt;p&gt;db.collection.insertOne()  插入单个文档&lt;/p&gt;
&lt;p&gt;db.collection.insertMany()   插入多个文档&lt;/p&gt;
&lt;p&gt;db.collection.insert()  将单个或多个文档插入到集合中&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&amp;gt; db.dba.insertOne({item:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;card&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,qty:15&lt;span&gt;})
{
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;acknowledged&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; : true,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;insertedId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : ObjectId(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5b35cabe638a2654f3efaa8f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
}
&lt;/span&gt;&amp;gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;指定_id插入文档&lt;/span&gt;
&amp;gt; db.dba.insertOne({_id:1,item:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,qty:100&lt;span&gt;})
{ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;acknowledged&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : true, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;insertedId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : 1&lt;span&gt; }

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;插入多个文档&lt;/span&gt;
&amp;gt; db.dba.insertMany([{_id:2,item:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,qty:88},{_id:3,item:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;javascript&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,qty:77},{_id:4,item:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;django&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,qty:66&lt;span&gt;}])
{ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;acknowledged&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : true, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;insertedIds&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : [ 2, 3, 4 ] }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）查询操作&lt;/p&gt;
&lt;p&gt;读取操作从集合中检索文档&lt;/p&gt;
&lt;p&gt;db.collection.find()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt; db.dba.find()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查询集合所有&lt;/span&gt;

&amp;gt; db.dba.find({_id:1})  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查询_id为1的文档&lt;/span&gt;

&amp;gt; db.dba.find({_id:{$gt:2} })  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查询_id大于2的文档&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）更新操作&lt;/p&gt;
&lt;p&gt;db.collection.updateOne()   更新单个文档&lt;/p&gt;
&lt;p&gt;db.collection.updateMany()  更新多个文档&lt;/p&gt;
&lt;p&gt;db.collection.replaceOne()  替换文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
db.dba.updateOne({item:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;},{$set:{qty:111}})  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;修改item为python的qty为111&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将data字段更新为当前日期，如果不存在则创建该字段&lt;/span&gt;
db.dba.updateOne({item:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},{$currentDate:{data:true}}) 

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将_id大于2的文档修改qty的值并设置date字段为当前时间&lt;/span&gt;
db.dba.updateMany({_id:{$gt:2}},{$set:{qty:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},$currentDate:{date:true}})

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将_id为1的字段替换掉&lt;/span&gt;
db.dba.replaceOne({_id:1},{_id:1,item:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,qty:333,data:2018})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）删除操作&lt;/p&gt;
&lt;p&gt;db.collection.deleteOne()   #删除一条文档&lt;/p&gt;
&lt;p&gt;db.collection.deleteMany()   #删除多条文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除指定条件的一条文档&lt;/span&gt;
db.dba.deleteOne({_id:1&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除集合所有文档&lt;/span&gt;
&lt;span&gt;db.dba.deleteMany({})

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;删除_id大于3的文档&lt;/span&gt;
db.dba.deleteMany({_id:{$gt:3}})
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、python使用MongoDB&lt;/h3&gt;
&lt;p&gt;（1）安装MongoDB驱动程序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
pip install pymongo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）链接MongoDB&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
client=pymongo.MongoClient(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,port=27017&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;
client=pymongo.MongoClient(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mongodb://localhost:27017/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（3）指定数据库&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
db=&lt;span&gt;client.dba
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;
db=client[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dba&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）指定集合&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
collection=&lt;span&gt;db.dba
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;
collection=db[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dba&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（5）插入数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;插入数据单条数据&lt;/span&gt;
student=&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:200&lt;span&gt;,
}
&lt;/span&gt;&lt;span&gt;#result=collection.insert(student)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;print(result)  #返回一个InsertOneResult实例&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;插入多条数据&lt;/span&gt;
suudentany=&lt;span&gt;[
    {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:2,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:300&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:3,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;javascript&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:400&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:4,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c++&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:500&lt;span&gt;}
]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;result=collection.insert_many(suudentany)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;print(result)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;print(result.inserted_ids) #显示插入数据id列表&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（6）查询数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
result=collection.find_one({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查询单条数据&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(type(result))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;返回字典类型&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查询多条数据，需要迭代读取&lt;/span&gt;
resultall=&lt;span&gt;collection.find()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; resultall:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(i)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;过滤查询匹配的文档&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
resultfiter=collection.find({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$gt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:300}})  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查询age大于300的文档&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; resultfiter:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)

&lt;/span&gt;&lt;span&gt;#
&lt;/span&gt;{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 3, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;javascript&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 400&lt;span&gt;}
{&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 4, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c++&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 500}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比较符号还有：$lt小于、$gt大于、$lte小于等于、$gte大于等于、$ne不等于、$in在范围内、$nin不在范围内&lt;/p&gt;
&lt;p&gt;另外还可以用正则匹配$regex&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
result=collection.find({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$regex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^p.*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}}) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;匹配以P开头的name&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他功能符号：$exists属性是否存在、$type类型判断、$mod数字余数、$text文本查询、$shere条件查询&lt;/p&gt;
&lt;p&gt;更多详细用法可以在MongoDB官网找到：&lt;a href=&quot;https://docs.mongodb.com/manual/reference/operator/query/&quot; target=&quot;_blank&quot;&gt;https://docs.mongodb.com/manual/reference/operator/query/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（7）计数&lt;/p&gt;
&lt;p&gt;要统计查询结果有多少条数据，可以调用count()方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
count=&lt;span&gt;collection.find().count()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;或者统计符合条件的数据&lt;/span&gt;
count=collection.find({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;age&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:20}).count()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（8）排序&lt;/p&gt;
&lt;p&gt;排序时，直接调用sort()方法，并在其中传入排序的字段及升降序标志即可&lt;/p&gt;
&lt;p&gt;pymongo.ASCENDING为升序，pymongo.DESCENDING为降序&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
results=collection.find().sort(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,pymongo.ASCENDING)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（9）偏移&lt;/p&gt;
&lt;p&gt;如只想去某几个元素，可以利用skip()方法偏移位置来忽略前面的元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
results=collection.find().sort(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,pymongo.ASCENDING).skip(2) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;只取第三个及后面的元素&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外还可以使用limit()方法指定要取的结果个数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
results=collection.find().sort(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,pymongo.ASCENDING).skip(2).limit(2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;只取两个结果&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（10）更新&lt;/p&gt;
&lt;p&gt;可以使用update()方法来更新数据，但此方法不够安全可以使用$set它只 更新存在文档内存在的字段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
result=collection.update({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;},{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:8&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;上面方法不安全，它会将除了_id和要更新的数据外的其他字段会被删除&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;使用$set会比较安全&lt;/span&gt;
result=collection.update({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;},{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$set&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:12}})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;官方推荐使用update_one()和update_many()方法，来严格控制影响的字段，它需要使用$类型的操作字符来作为字典的键名&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
result=collection.update_one({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_id&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:3},{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$set&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;javascript&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}})
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(result)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(result.matched_count,result.modified_count) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打印匹配的数据条数和影响的数据条数&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;updata_many()会将所有符合条件的数据都更新&lt;/span&gt;
result=collection.update_many({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$gt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:2}},{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$inc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:10}})  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;将所有date值大于2的文档加上10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（11）删除&lt;/p&gt;
&lt;p&gt;删除可以使用的方法有remove()符合条件的数据都会被删除，delete_one()值删除符合条件的第一条和delete_many()删除所有符合条件的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
result=collection.delete_one({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})  
result1&lt;/span&gt;=collection.delete_many({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$gt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:20}})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（12）其他操作&lt;/p&gt;
&lt;p&gt;pyMongo还提供了一些组合方法：&lt;/p&gt;
&lt;p&gt;find_one_and_delete()   查找后删除&lt;/p&gt;
&lt;p&gt;find_one_and_replace()  查找后替换&lt;/p&gt;
&lt;p&gt;find_one_and_update()  查找后更新&lt;/p&gt;
&lt;p&gt;create_index()   在集合上创建索引&lt;/p&gt;
&lt;p&gt;create_indexes()  在集合上创建一个或多个索引&lt;/p&gt;
&lt;p&gt;drop_index()  删除此集合上的索引&lt;/p&gt;
&lt;p&gt;更多集合操作方法：&lt;a href=&quot;http://api.mongodb.com/python/current/api/pymongo/collection.html&quot; target=&quot;_blank&quot;&gt;http://api.mongodb.com/python/current/api/pymongo/collection.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; pymongo的API文档：&lt;a href=&quot;http://api.mongodb.com/python/current/api/pymongo/index.html&quot; target=&quot;_blank&quot;&gt;http://api.mongodb.com/python/current/api/pymongo/index.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 Jun 2018 15:16:00 +0000</pubDate>
<dc:creator>Py.qi</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangxinqi/p/9242687.html</dc:identifier>
</item>
<item>
<title>java  类加载器、反射 - 鲁系大厨</title>
<link>http://www.cnblogs.com/wangrongchen/p/9242789.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangrongchen/p/9242789.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;字节码对象，当我们保存后程序产生的.class文件是编译后的文件，当我们运行程序的时候，程序去读取.class文件，这个文件会存到内存中，在堆中创建一个.class文件对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当程序要使用某个类的时候，该类还没有到内存中去，会通过加载，连接，初始化3步对这个类进行初始化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加载，将class文件对象加载到内存中去，创建一个class对象，任何类在被使用时都会创一个class对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连接，1.检验，检查语法是否有问题，跟其他类是否协调&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.准备，给静态成员变量初始化值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3.解析，将符号引用改成直接引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例如：int a = 1；解析就是把a直接改成1了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;类什么时候初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.创建类的时候&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.类的静态方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.类的静态成员变量赋值的时候&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.反射创建某个类的时候&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.调用某个类的子类的时候&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.直接运行程序的时候&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;类的加载器组成&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1269151/201806/1269151-20180629113705289-1584692499.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;反射&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 对于java中任意一个类，我们可以知道他的方法和属性，对于任意一个对象，我们可以调用他的方法和属性，解剖出来，这叫做java的反射机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;首先我们要获取这个类的字节码对象，对他进行操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有3种方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们先创建一个类person&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.orcale.damo01;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String name;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;静态代码块&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         System.out.println(&quot;空参构造&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Person(String name,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age=&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         System.out.println(&quot;有参构造&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Person(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age,String name){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.name=&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         System.out.println(&quot;有参构造&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat(){
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         System.out.println(&quot;吃饭&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; work(String name){
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         System.out.println(name+&quot;走路&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(String name){
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         System.out.println(name+&quot;跑步&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过对象获取字节码对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Person p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Class c = p.getClass();&lt;br/&gt;　 System.out.println(c);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过类名获取&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Class c1 = Person.&lt;span&gt;class&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过class的静态方法获取forName(完成的类名，包名)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Class c2 = Class.forName(&quot;com.orcale.damo01.Person&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; System.out.println(c2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取公共的构造方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Class c = Person.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Constructor con =&lt;span&gt;c.getConstructor(这里如果是有参构造就写参数);&lt;br/&gt;就表示为&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 Constructor con =c.getConstructor（Sting.calss,int.class）数据类型在前，class在后面，具体看构造参数
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;3&lt;/span&gt; System.out.println(con);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取所有的公共的构造方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     Class c = Person.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Constructor[] con =&lt;span&gt; c.getConstructors();   一个对象数组，把所有的构造方法都放进去
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Constructor co:con){
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;            System.out.println(co);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1269151/201806/1269151-20180629213217777-866289187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;获取公共的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Class c = Person.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Constructor con =c.getConstructor(String.&lt;span&gt;class&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为Person类中没有单独String name的构造方法，所以写了2个，&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         Object obj =&lt;span&gt; c.newInstance();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个对象祖宗类，然后用字节码对象获取方法
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;getMethod(&quot;第一个写需要调用的方法名字&quot;，写需要传入的参数)；&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;         Method me = c.getMethod(&quot;work&quot;, String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用方法用invoke方法（第一个写对象，第二个写需要传入的实参）&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt;         me.invoke(obj, &quot;小明&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1269151/201806/1269151-20180629214317609-821787198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;获取所有的公共方法和获取所有的公共构造方法差不多，整个数组遍历就可以了&lt;/p&gt;
&lt;p&gt;获取所有的公共成员变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Class c= Person.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Field[] f=&lt;span&gt; c.getFields();  //通过Field【】方法数组
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Field ff:f){
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;            System.out.println(ff);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取指定的公共成员变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Class c= Person.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Field f= c.getField(&quot;name&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         System.out.println(f);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改公共的成员变量赋值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Class c= Person.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Field f= c.getField(&quot;name&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         Object obj =&lt;span&gt; c.newInstance();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用set方法对name赋值，然后输出对象的属性&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         f.set(obj, &quot;小明&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         System.out.println(obj)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1269151/201806/1269151-20180629220016865-1499153850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;获取私有的构造方法&lt;/p&gt;
&lt;p&gt;原理是通过setAccessible方法，避开了对类的加载器对类的检查，不建议对私有的构造方法和属性操作，不然还私有干啥没有意义了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     Class c =Person.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         Constructor con = c.getDeclaredConstructor(&lt;span&gt;int&lt;/span&gt;.&lt;span&gt;class&lt;/span&gt;,String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         con.setAccessible(&lt;span&gt;true&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;暴力反射开关&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         Object obj =  con.newInstance(12,&quot;dd&quot;&lt;span&gt;);   
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         System.out.println(obj);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取私有的成员变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Class c= Person.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
        Field field &lt;/span&gt;= c.getDeclaredField(&quot;age&quot;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取私有的的成员变量&lt;/span&gt;
        Object obj =&lt;span&gt; c.newInstance();
        field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;暴力开关&lt;/span&gt;
        field.set(obj, 11&lt;span&gt;);   
        System.out.println(obj);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 练习：有一个AarrayList&amp;lt;String&amp;gt; list，然后往里面添加int类型数据，泛型擦除（字节码文件中没有泛型）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ArrayList&amp;lt;String&amp;gt; arr = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         arr.add(&quot;abc&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         Class c=&lt;span&gt; arr.getClass();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         Method addd = c.getMethod(&quot;add&quot;, Object.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         addd.invoke(arr, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Object obj:arr){
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;            System.out.println(obj);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 29 Jun 2018 14:45:00 +0000</pubDate>
<dc:creator>鲁系大厨</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangrongchen/p/9242789.html</dc:identifier>
</item>
<item>
<title>前端通信：ajax设计方案（七）--- 增加请求错误监控、前端负载均衡以、请求宕机切换以及迭代问题修复 - 仲强</title>
<link>http://www.cnblogs.com/GerryOfZhong/p/9245510.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GerryOfZhong/p/9245510.html</guid>
<description>&lt;p&gt;&lt;span&gt;距离上个迭代过了很长时间，中间经历了很多事情，也在每个空余时间构思了这个迭代的东西以及下个迭代要做的东西。时间周期稍微长了，望见谅。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且，至今这个开源库的start也已经到了&lt;span&gt;&lt;strong&gt;165&lt;/strong&gt;&lt;/span&gt;个了，会支持关注和研究的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;首先解决了上个迭代遇到的问题进行完善和修复&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 上个迭代做ajax timeout设置的时候，手抖将timeout不小心设置成timeoutEvent，这期做了修复&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 解决全局配置中配置额外参数，批量检查时会参数错误问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引入新的功能：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 增加浏览器发送请求的错误监控和搜集&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;应用场景：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前端开发依赖的东西比较多，比如宿主环境（浏览器）、以及数据接口（自己服务器或者第三方Api等等），上个迭代进行了浏览器错误搜集，可以分析用户在不同环境下宿主的使用率和差异以及问题。但是对于用户的数据请求一直没有做监控，因为用户在不同的场景、网络状况下乃至在开发或者发布中将接口地址写错了，导致出现问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全局配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;errStatus: {
  isOpenErr: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否开启错误搜集&lt;/span&gt;
  errURL: 'http://localhost:8072',    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 错误搜集地址&lt;/span&gt;
},&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;监控ajax请求的错误日志&lt;/span&gt;
    uploadAjaxError: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (obj) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤错误接口&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (initParam.errStatus.isOpenErr) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj.errUrl !==&lt;span&gt; initParam.errStatus.errURL) {
          tempObj.post(initParam.errStatus.errURL, obj)
        }
      }
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录错误信息，以便策略做判断&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (selfData.errAjax[obj.errUrl] ===&lt;span&gt; undefined) {
        selfData.errAjax[obj.errUrl] &lt;/span&gt;= 1&lt;span&gt;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        selfData.errAjax[obj.errUrl] &lt;/span&gt;+= 1&lt;span&gt;
      }

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否开启服务切换，以及验证策略切换&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (initParam.serviceSwitching.isOpen){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 验证策略&lt;/span&gt;
        selfData.isNeedSwitching =&lt;span&gt; initParam.serviceSwitching.strategies(selfData.errAjax)
      }

    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;覆盖面以及数据：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;请求的错误搜集，将覆盖4xx、5xx、0、onerror以及timeout状态&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PS：在浏览器api中，只读属性 XMLHttpRequest.status 返回了XMLHttpRequest 响应中的数字状态码。status 的值是一个无符号短整型。在请求完成前，status的值为0。值得注意的是，如果 XMLHttpRequest 出错，浏览器返回的 status 也为0。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;链接：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/status&quot; target=&quot;_blank&quot;&gt;XMLHttpRequest.status&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据上传格式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * 请求错误搜集
    *   type：错误类型
    *   errInfo：错误的请求参数
    *   errLine：请求状态
    *   Browser：宿主环境（浏览器）
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; 
  tool.uploadAjaxError({
      type: &lt;/span&gt;'request'&lt;span&gt;,    
      errInfo: JSON.stringify(ajaxSetting.data),
      errLine: xhr.status,
      Browser: navigator.userAgent
  })&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;a. onerror错误：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201806/801930-20180629174521309-99125186.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;b. 4XX错误、5XX错误、0错误&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201806/801930-20180629175950898-1406006391.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;c. timeout错误&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201806/801930-20180629193105480-760367639.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 2. 前端负载均衡（将请求均衡打到不同的服务器上）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 应用场景：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在很多公司更多使用ngx做负载均衡，使用node第一层hold住所有流量，然后通过ngx进行分发到不同的服务器上做负载，避免在一台服务器上读写造成资源竞争等等，结构如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201806/801930-20180629193926768-1108248063.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，如果在超大流量的一种状况下，前端作为请求的发出方，完全有能力在发出阶段就将请求打到不同的负载服务器上，然后再通过ngx再进行二次负载均衡，结构如下如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201806/801930-20180629195454027-544170126.png&quot; alt=&quot;&quot; width=&quot;392&quot; height=&quot;370&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;全局配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 负载均衡配置&lt;/span&gt;
&lt;span&gt;loadBalancing: {
  isOpen: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否开启负载&lt;/span&gt;
  cluster: ['http://localhost:8076','http://localhost:8099']  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 配置地址&lt;/span&gt;
},&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 判断是否为其他域的请求
     *
     * 改方法中处理负载均衡方案
     *    1. 对于前后端分离，直接请求域名的方案  支持
     *    2. 对于直接请求本服务器的请求，暂时不做处理，让ngx做负载均衡  不支持
     *
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    checkRealUrl: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (param, that) {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; temp;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (/http:\/\/|https:\/\//&lt;span&gt;.test(param.url)) {
        temp &lt;/span&gt;=&lt;span&gt; param.url;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 针对请求，负载均衡到配置域名  PS:负载均衡优先级 &amp;gt; 宕机切换优先级&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (param.errStatus.errURL !== temp){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 错误搜集接口都不走&lt;/span&gt;
          &lt;span&gt;if&lt;/span&gt; (param.loadBalancing.isOpen){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 负载打开肯定走负载&lt;/span&gt;
            temp = param.url.replace(/^(http:\/\/|https:\/\/)/, ''&lt;span&gt;)
              .replace(&lt;/span&gt;/^.*?\//, param.loadBalancing.cluster[tool.random(param.loadBalancing.cluster.length - 1, 0)] + '/$`'&lt;span&gt;)
          }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果负载没开，宕机切换打开，则走介个&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (param.serviceSwitching.isOpen &amp;amp;&amp;amp;&lt;span&gt; selfData.isNeedSwitching){
              temp &lt;/span&gt;= param.url.replace(/^(http:\/\/|https:\/\/)/, ''&lt;span&gt;)
                .replace(&lt;/span&gt;/^.*?\//, param.serviceSwitching.backupUrl + '/$`'&lt;span&gt;)
            }
          }
        }
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        temp &lt;/span&gt;= param.baseURL +&lt;span&gt; param.url
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (param.errStatus.errURL !==&lt;span&gt; temp){
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (param.loadBalancing.isOpen){
            temp &lt;/span&gt;= param.loadBalancing.cluster[tool.random(param.loadBalancing.cluster.length - 1, 0)] + param.baseURL +&lt;span&gt; param.url
          }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果负载没开，宕机切换打开，宕机策略成功则走介个&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (param.serviceSwitching.isOpen &amp;amp;&amp;amp;&lt;span&gt; selfData.isNeedSwitching){
              temp &lt;/span&gt;= param.serviceSwitching.backupUrl + param.baseURL +&lt;span&gt; param.url
            }
          }
        }
      }
      that.currentUrl &lt;/span&gt;=&lt;span&gt; temp
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; temp;
    },&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随机函数校验：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为前端需要通过一个伪随机数随机获取一个数值，然后通过这个数值去取负载配置的域名，为了保证随机打点的均衡性，这里将测试在指数级增长下随机打点5次的状况&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 伪随机数函数&lt;/span&gt;
&lt;span&gt;random(max, min) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.floor(Math.random() * (max - min + 1) +&lt;span&gt; min);
},&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;案例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;a. 随机5个，10次&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201806/801930-20180629201315995-1206442553.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;b. 随机5个，100次&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201806/801930-20180629201349963-1755814171.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;c. 随机5个，1000次&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201806/801930-20180629201416733-2063607961.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;d. 随机5个，10000次&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201806/801930-20180629201450187-56380986.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;e. 随机5个，100000次&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201806/801930-20180629201511647-1366480860.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;结果：在指数级增长的过程中，打点越来越均衡，相对伪随机数的分布取值也越来越均衡&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201806/801930-20180629202501075-1191831880.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201806/801930-20180629202558591-1459202328.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201806/801930-20180629202627339-2068049749.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201806/801930-20180629202648202-1065867603.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3.  宕机切换（支持策略）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 应用场景：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在日常用户使用请求接口的时候，用户在点击一个按钮的时候，如果一次接口请求失败，在人性角度去看，用户肯定会再一次去点击触发请求，多次按了都没效果，才会确认这个功能是没用的。如果，在这个时候，这个场景下，用一个正确的策略在用户点击时候，如果本地请求失败，支持切换备用域名，这样可以有效的挽回流失用户。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;全局配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 宕机切换&lt;/span&gt;
&lt;span&gt;serviceSwitching:{
  isOpen: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否开启&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 宕机策略（data为记录的错误请求以及数量，如果达到策略返回true，否则false）&lt;/span&gt;
  strategies:&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
    let num &lt;/span&gt;= 0
      &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data){
        num &lt;/span&gt;=&lt;span&gt; data[key]
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (num === 5&lt;span&gt;){
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
      }
     },
  backupUrl:&lt;/span&gt;'http://localhost:8033'     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 备用域名&lt;/span&gt;
},&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码实现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同负载均衡的那一大堆代码，可以向上看。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试案例（在策略中我绑定了如果错误连续积累5次之后将切换备用接口）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/801930/201806/801930-20180629204006236-1347804789.png&quot; alt=&quot;&quot; width=&quot;870&quot; height=&quot;724&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：这一期的迭代需求中已经将ajax所能涉及的应用场景全部挖掘的快消耗殆尽了，如果还有什么使用场景，可以去github提个issues。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;github地址：&lt;a href=&quot;https://github.com/GerryIsWarrior/ajax&quot; target=&quot;_blank&quot;&gt;https://github.com/GerryIsWarrior/ajax&lt;/a&gt;    可以点个&lt;span&gt;&lt;strong&gt;&lt;span&gt;star&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;，持续研究下去&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;号外：有一次的测试中，意外突然发现，一个使用过的请求对象是可以重复利用的，而且一套创建流程从2000多毫秒一下子降级到200毫秒了，so，下一次迭代将所一个请求连接池，重复利用每次创建完成的对象，将每次的请求速度缩短到更快的一个层次，期待中...&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 Jun 2018 13:37:00 +0000</pubDate>
<dc:creator>仲强</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GerryOfZhong/p/9245510.html</dc:identifier>
</item>
<item>
<title>浅析data:image/png;base64的应用 - Angel_Kitty</title>
<link>http://www.cnblogs.com/ECJTUACM-873284962/p/9245474.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ECJTUACM-873284962/p/9245474.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;偶尔加入一个网安群的时候，入群题目是这个：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANwAAAAoCAIAAAAaOwPZAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAQuSURBVHhe7ZptmoMgDIR7rh6o5+lpvEwP01XUGshAokgX+8z+7PKRTF6SoN7e/KMCnSlw68wemkMF3oSSEHSnAKHsLiQ0iFCSge4UIJTdhYQGEUoy0J0ChLK7kNAgQkkGulOAUHYXEhpEKMlAdwpcG8rhcRv/HkN3stIgW4F88DYoX89nObjmANuOc0eMXpHHcyX9+mowhgHKmdlChM0BZzvzet6DSSW7xjEWk8Hu+/O1x7zF1237/Uu4t/O46V6sZuARoZb9KqbO7On4rJlykqcYYnNAjSbx3Gmrj6WTzxirVlA+90F82G+nm4fX3zOxgqyKqRaUU7b8FpRDOeyjJa7k5oByT1yWse4mxfDC3NrrprnQtQeUMuUXoURmCGHdKfl/oTS8MElxu2mudO0BXUCZL8efVGU0EmsQjkGpM2H8y/CwGtW1C3el8ywxhHKWxgOlaPNj0VcRRW+OoiKvCXF0o6YeXWLQDaNQyMf1Clhsi22D9HUNXOBCVZamaBmiO5BxRdRQOt3M3oFUAD4/HDolSChx7AvXzRIJQtgsUfMu6HB+HglNLc5d5KiwpcAqTH7Idk/lvLD9Z0rUx4vYWL2UJ4WY6XbdL91ML57+EjsRNEMnw/LCrKklN9NNkbuLvKsdabjM/ZMByh+PDWuuw6kDEYXPzeSfzGARlNG1M1ENRCfGLlUuJ5MVTg+UyxGzC+1+KN/DkDyuTSVbqo7vNnagfKPTrH9b8pQtgQ/PRCifDTaUJaIWw8adUycklLrcppkyCZfkJ5cYlSZnQTkmsYf58OYAlMpg6JnlhYlC9uxhIdWvbr1NS8Ahc9pgQlkkai3fOorVUK4JGeYTJIgVTm+mnCqrmSfOgDJ0mOlOlhcmClk3M0KmPzeF0mnDGVB6LjqbmKB8p5GRQ34DStRCdpEpp5MRNWRNocwsjk9i7nyqugzPYTWUSZuqe0qVucAT5tgH9ITmxEdCdihjpcCVAgfI8uJ4pgx3K3UhgBeRQ9dtbJmjp1TnYmsKoSH1UGqKE23mxlrsri4yKsuAFnZ5BrAugypw0/IdSvHmxHJbEI6lREzj0asuOc7TR8BONdd9pNKCo4LRNY9CdgCEXjqObDhQvsFpy7z7DsqHP9khxp9DzNeKbSR+Iy3/n31tqVFYe17xFUZkTu507+4px4USFwBRm32lbzFyXphgRMtn3cwqqaef8a0UrMHlaJYM8RC1Iq2DeOXvKUdVjALmzromST8+4N+Egm9rrwzl/DpAVlddnE9su36Jyx6ECtkUxufaUMJOzfwQsxldUbnTLyO/ckCcNsS112yDmkkGF/4xKL8rHndrowChbKMrV61QgFBWiMepbRQglG105aoVChDKCvE4tY0ChLKNrly1QgFCWSEep7ZRgFC20ZWrVihAKCvE49Q2ChDKNrpy1QoF/gDXIhmWmc+CSAAAAABJRU5ErkJggg==
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;刚开始还是挺懵逼的，诶，是Base64编码嘛？看样子好像是图片转成Base64的，然后放在搜索引擎一回车，竟然是得到了入群密码，是不是有点神奇？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201806/1100338-20180629205200673-1703789451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咳咳，下面要进入重点了~~~&lt;/p&gt;
&lt;h2&gt;data:image/png;base64是什么？&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;翻阅了一些资料才知道，这是在RFC2397中定义的Data URI scheme，目的是将一些小的数据，直接嵌入到网页中，从而不用再从外部文件载入。&lt;/p&gt;
&lt;h3 align=&quot;left&quot;&gt;优点：   &lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;减少HTTP请求数，没有了TCP连接消耗和同一域名下浏览器的并发数限制。&lt;/li&gt;
&lt;li&gt;对于小文件会降低带宽。虽然编码后数据量会增加，但是却减少了http头，当http头的数据量大于文件编码的增量，那么就会降低带宽。&lt;/li&gt;
&lt;li&gt;对于HTTPS站点，HTTPS和HTTP混用会有安全提示，而HTTPS相对于HTTP来讲开销要大更多，所以Data URI在这方面的优势更明显。&lt;/li&gt;
&lt;li&gt;可以把整个多媒体页面保存为一个文件。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 align=&quot;left&quot;&gt;缺点：   &lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;无法被重复利用，同一个文档应用多次同一个内容，则需要重复多次，数据量大量增加，增加了下载时间。&lt;/li&gt;
&lt;li&gt;无法被独自缓存，所以其包含文档重新加载时，它也要重新加载。&lt;/li&gt;
&lt;li&gt;客户端需要重新解码和显示，增加了点消耗。&lt;/li&gt;
&lt;li&gt;不支持数据压缩，base64编码会增加1/3大小，而urlencode后数据量会增加更多。&lt;/li&gt;
&lt;li&gt;不利于安全软件的过滤，同时也存在一定的安全隐患。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 class=&quot;title&quot;&gt;Data URI Scheme的基本概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;《HTTP权威指南》对URI和URL的定义：&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;URI（Uniform Resource Identifier）:统一资源标识符,服务器资源名被称为统一资源标识符。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;URL（Uniform Resource Locator）:统一资源定位符，描述了一台特定服务器上某资源的特定位置。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;URN（Uniform Resource Name）:统一资源名称。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;strong&gt;URL组成：&lt;/strong&gt;&lt;/div&gt;
&lt;div readability=&quot;75.16613829998&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;协议://主机名[:端口]/ 路径/[:参数] [?查询]#Fragment

protocol :// hostname[:port] / path / [:parameters][?query]#fragment&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;URI,URL,URN三者关系：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
URL,URN是URI的子集
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1100338/201806/1100338-20180629210051023-770133130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;什么是Data URI Scheme&lt;/h2&gt;
&lt;p&gt;data URI scheme 允许我们使用内联（inline-code）的方式在网页中包含数据，目的是将一些小的数据，直接嵌入到网页中，从而不用再从外部文件载入。常用于将图片嵌入网页。&lt;/p&gt;
&lt;p&gt;传统的图片HTML是这样用的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
img src=&quot;images/image.png&quot;/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Data URI的图片内嵌式是这样用的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
img src=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANwAAAAoCAIAAAAaOwPZAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAQuSURBVHhe7ZptmoMgDIR7rh6o5+lpvEwP01XUGshAokgX+8z+7PKRTF6SoN7e/KMCnSlw68wemkMF3oSSEHSnAKHsLiQ0iFCSge4UIJTdhYQGEUoy0J0ChLK7kNAgQkkGulOAUHYXEhpEKMlAdwpcG8rhcRv/HkN3stIgW4F88DYoX89nObjmANuOc0eMXpHHcyX9+mowhgHKmdlChM0BZzvzet6DSSW7xjEWk8Hu+/O1x7zF1237/Uu4t/O46V6sZuARoZb9KqbO7On4rJlykqcYYnNAjSbx3Gmrj6WTzxirVlA+90F82G+nm4fX3zOxgqyKqRaUU7b8FpRDOeyjJa7k5oByT1yWse4mxfDC3NrrprnQtQeUMuUXoURmCGHdKfl/oTS8MElxu2mudO0BXUCZL8efVGU0EmsQjkGpM2H8y/CwGtW1C3el8ywxhHKWxgOlaPNj0VcRRW+OoiKvCXF0o6YeXWLQDaNQyMf1Clhsi22D9HUNXOBCVZamaBmiO5BxRdRQOt3M3oFUAD4/HDolSChx7AvXzRIJQtgsUfMu6HB+HglNLc5d5KiwpcAqTH7Idk/lvLD9Z0rUx4vYWL2UJ4WY6XbdL91ML57+EjsRNEMnw/LCrKklN9NNkbuLvKsdabjM/ZMByh+PDWuuw6kDEYXPzeSfzGARlNG1M1ENRCfGLlUuJ5MVTg+UyxGzC+1+KN/DkDyuTSVbqo7vNnagfKPTrH9b8pQtgQ/PRCifDTaUJaIWw8adUycklLrcppkyCZfkJ5cYlSZnQTkmsYf58OYAlMpg6JnlhYlC9uxhIdWvbr1NS8Ahc9pgQlkkai3fOorVUK4JGeYTJIgVTm+mnCqrmSfOgDJ0mOlOlhcmClk3M0KmPzeF0mnDGVB6LjqbmKB8p5GRQ34DStRCdpEpp5MRNWRNocwsjk9i7nyqugzPYTWUSZuqe0qVucAT5tgH9ITmxEdCdihjpcCVAgfI8uJ4pgx3K3UhgBeRQ9dtbJmjp1TnYmsKoSH1UGqKE23mxlrsri4yKsuAFnZ5BrAugypw0/IdSvHmxHJbEI6lREzj0asuOc7TR8BONdd9pNKCo4LRNY9CdgCEXjqObDhQvsFpy7z7DsqHP9khxp9DzNeKbSR+Iy3/n31tqVFYe17xFUZkTu507+4px4USFwBRm32lbzFyXphgRMtn3cwqqaef8a0UrMHlaJYM8RC1Iq2DeOXvKUdVjALmzromST8+4N+Egm9rrwzl/DpAVlddnE9su36Jyx6ECtkUxufaUMJOzfwQsxldUbnTLyO/ckCcNsS112yDmkkGF/4xKL8rHndrowChbKMrV61QgFBWiMepbRQglG105aoVChDKCvE4tY0ChLKNrly1QgFCWSEep7ZRgFC20ZWrVihAKCvE49Q2ChDKNrpy1QoF/gDXIhmWmc+CSAAAAABJRU5ErkJggg==&quot;/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Data URI的直接通过url传递方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANwAAAAoCAIAAAAaOwPZAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAQuSURBVHhe7ZptmoMgDIR7rh6o5+lpvEwP01XUGshAokgX+8z+7PKRTF6SoN7e/KMCnSlw68wemkMF3oSSEHSnAKHsLiQ0iFCSge4UIJTdhYQGEUoy0J0ChLK7kNAgQkkGulOAUHYXEhpEKMlAdwpcG8rhcRv/HkN3stIgW4F88DYoX89nObjmANuOc0eMXpHHcyX9+mowhgHKmdlChM0BZzvzet6DSSW7xjEWk8Hu+/O1x7zF1237/Uu4t/O46V6sZuARoZb9KqbO7On4rJlykqcYYnNAjSbx3Gmrj6WTzxirVlA+90F82G+nm4fX3zOxgqyKqRaUU7b8FpRDOeyjJa7k5oByT1yWse4mxfDC3NrrprnQtQeUMuUXoURmCGHdKfl/oTS8MElxu2mudO0BXUCZL8efVGU0EmsQjkGpM2H8y/CwGtW1C3el8ywxhHKWxgOlaPNj0VcRRW+OoiKvCXF0o6YeXWLQDaNQyMf1Clhsi22D9HUNXOBCVZamaBmiO5BxRdRQOt3M3oFUAD4/HDolSChx7AvXzRIJQtgsUfMu6HB+HglNLc5d5KiwpcAqTH7Idk/lvLD9Z0rUx4vYWL2UJ4WY6XbdL91ML57+EjsRNEMnw/LCrKklN9NNkbuLvKsdabjM/ZMByh+PDWuuw6kDEYXPzeSfzGARlNG1M1ENRCfGLlUuJ5MVTg+UyxGzC+1+KN/DkDyuTSVbqo7vNnagfKPTrH9b8pQtgQ/PRCifDTaUJaIWw8adUycklLrcppkyCZfkJ5cYlSZnQTkmsYf58OYAlMpg6JnlhYlC9uxhIdWvbr1NS8Ahc9pgQlkkai3fOorVUK4JGeYTJIgVTm+mnCqrmSfOgDJ0mOlOlhcmClk3M0KmPzeF0mnDGVB6LjqbmKB8p5GRQ34DStRCdpEpp5MRNWRNocwsjk9i7nyqugzPYTWUSZuqe0qVucAT5tgH9ITmxEdCdihjpcCVAgfI8uJ4pgx3K3UhgBeRQ9dtbJmjp1TnYmsKoSH1UGqKE23mxlrsri4yKsuAFnZ5BrAugypw0/IdSvHmxHJbEI6lREzj0asuOc7TR8BONdd9pNKCo4LRNY9CdgCEXjqObDhQvsFpy7z7DsqHP9khxp9DzNeKbSR+Iy3/n31tqVFYe17xFUZkTu507+4px4USFwBRm32lbzFyXphgRMtn3cwqqaef8a0UrMHlaJYM8RC1Iq2DeOXvKUdVjALmzromST8+4N+Egm9rrwzl/DpAVlddnE9su36Jyx6ECtkUxufaUMJOzfwQsxldUbnTLyO/ckCcNsS112yDmkkGF/4xKL8rHndrowChbKMrV61QgFBWiMepbRQglG105aoVChDKCvE4tY0ChLKNrly1QgFCWSEep7ZRgFC20ZWrVihAKCvE49Q2ChDKNrpy1QoF/gDXIhmWmc+CSAAAAABJRU5ErkJggg==
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在浏览器地址栏中输入以上代码，可直接显示那个flag！！！&lt;/p&gt;
&lt;h2&gt;Data URI的格式规范&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
data:[&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mime &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;][;charset=&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;][;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;],&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoded &lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

1.  data ：协议名称；

2.  [&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mime &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;] ：可选项，数据类型（image/png、text/plain等）

3.  [;charset=&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;] ：可选项，源文本的字符集编码方式

4.  [;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;] ：数据编码方式（默认US-ASCII，BASE64两种）

5.  ,&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;encoded &lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; ：编码后的数据
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;目前，Data URI scheme支持的类型有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;data:,                            文本数据
data:text/plain,                    文本数据
data:text/html,                  HTML代码
data:text/html;base64,            base64编码的HTML代码
data:text/css,                    CSS代码
data:text/css;base64,              base64编码的CSS代码
data:text/javascript,              Javascript代码
data:text/javascript;base64,        base64编码的Javascript代码
data:image/gif;base64,            base64编码的gif图片数据
data:image/png;base64,            base64编码的png图片数据
data:image/jpeg;base64,          base64编码的jpeg图片数据
data:image/x-icon;base64,          base64编码的icon图片数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;Data URI和MHTML两者的配合可以完整的解决所有的主流浏览器，它们由于无法被缓存和重复利用的缺陷，所以并不适合直接在页面中使用，但在CSS和JavaScript文件中对图片适当地使用有非常大的优越性：大大减少请求数，现在大型网站的CSS引用了大量的图片资源。CSS和JavaScript都可以被缓存，间接的实现了数据的缓存。利用CSS可以解决Data URI的重复利用问题。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;告别CSS Sprites，CSS Sprites的出现是为了减少请求数，但它除了带来在不确定情况下的异常外，CSSSprites还需要人为的图片合并，即使有合并工具也依旧必须人为地在如何有效的拼图上耗费大量的时间，并带来维护的困难。当你遵循一定的设计原则后， 你就可以完全抛弃CSS Sprites来编写CSS，最后使用工具在上传到服务器环节把图片转换成Data URI和MHTML，如《利用data-uri合并样式表和图片》中用python实现的工具，这可以节约大量的时间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;base64编码把图片文件增加了1/3，Data URI和MHTML同时使用相当于增加了2/3，但CSS和JavaScript可以使用gzip压缩，其可以节省2/3的数据量，所以使用gzip压缩后的最终数据量是(1 + 1/3) * 2 * (1/3) = 8/9，所以最终流量是减少的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;它把一些 8-bit 数据翻译成标准 ASCII 字符，网上有很多免费的base64 编码和解码的工具。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;在网页上显示出来的标准方法是：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=”data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANwAAAAoCAIAAAAaOwPZAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAQuSURBVHhe7ZptmoMgDIR7rh6o5+lpvEwP01XUGshAokgX+8z+7PKRTF6SoN7e/KMCnSlw68wemkMF3oSSEHSnAKHsLiQ0iFCSge4UIJTdhYQGEUoy0J0ChLK7kNAgQkkGulOAUHYXEhpEKMlAdwpcG8rhcRv/HkN3stIgW4F88DYoX89nObjmANuOc0eMXpHHcyX9+mowhgHKmdlChM0BZzvzet6DSSW7xjEWk8Hu+/O1x7zF1237/Uu4t/O46V6sZuARoZb9KqbO7On4rJlykqcYYnNAjSbx3Gmrj6WTzxirVlA+90F82G+nm4fX3zOxgqyKqRaUU7b8FpRDOeyjJa7k5oByT1yWse4mxfDC3NrrprnQtQeUMuUXoURmCGHdKfl/oTS8MElxu2mudO0BXUCZL8efVGU0EmsQjkGpM2H8y/CwGtW1C3el8ywxhHKWxgOlaPNj0VcRRW+OoiKvCXF0o6YeXWLQDaNQyMf1Clhsi22D9HUNXOBCVZamaBmiO5BxRdRQOt3M3oFUAD4/HDolSChx7AvXzRIJQtgsUfMu6HB+HglNLc5d5KiwpcAqTH7Idk/lvLD9Z0rUx4vYWL2UJ4WY6XbdL91ML57+EjsRNEMnw/LCrKklN9NNkbuLvKsdabjM/ZMByh+PDWuuw6kDEYXPzeSfzGARlNG1M1ENRCfGLlUuJ5MVTg+UyxGzC+1+KN/DkDyuTSVbqo7vNnagfKPTrH9b8pQtgQ/PRCifDTaUJaIWw8adUycklLrcppkyCZfkJ5cYlSZnQTkmsYf58OYAlMpg6JnlhYlC9uxhIdWvbr1NS8Ahc9pgQlkkai3fOorVUK4JGeYTJIgVTm+mnCqrmSfOgDJ0mOlOlhcmClk3M0KmPzeF0mnDGVB6LjqbmKB8p5GRQ34DStRCdpEpp5MRNWRNocwsjk9i7nyqugzPYTWUSZuqe0qVucAT5tgH9ITmxEdCdihjpcCVAgfI8uJ4pgx3K3UhgBeRQ9dtbJmjp1TnYmsKoSH1UGqKE23mxlrsri4yKsuAFnZ5BrAugypw0/IdSvHmxHJbEI6lREzj0asuOc7TR8BONdd9pNKCo4LRNY9CdgCEXjqObDhQvsFpy7z7DsqHP9khxp9DzNeKbSR+Iy3/n31tqVFYe17xFUZkTu507+4px4USFwBRm32lbzFyXphgRMtn3cwqqaef8a0UrMHlaJYM8RC1Iq2DeOXvKUdVjALmzromST8+4N+Egm9rrwzl/DpAVlddnE9su36Jyx6ECtkUxufaUMJOzfwQsxldUbnTLyO/ckCcNsS112yDmkkGF/4xKL8rHndrowChbKMrV61QgFBWiMepbRQglG105aoVChDKCvE4tY0ChLKNrly1QgFCWSEep7ZRgFC20ZWrVihAKCvE49Q2ChDKNrpy1QoF/gDXIhmWmc+CSAAAAABJRU5ErkJggg==” &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;data:image/png;base64相当于图片的Data URL，它是利用base64编码把图片数据翻译成标准ASCII字符，等同于&amp;lt;img src=&quot;images/image.png&quot;/&amp;gt; &lt;/p&gt;
&lt;p&gt;换句话说我们把图像文件的内容内置在 HTML 文件中，节省了一个 HTTP 请求。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;在 CSS 中使用：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;body &lt;/span&gt;{&lt;span&gt; background-image&lt;/span&gt;:&lt;span&gt; url(&quot;data:image/png&lt;/span&gt;;&lt;span&gt;base64,iVBORw0KGgoAAAANSUhEUgAAANwAAAAoCAIAAAAaOwPZAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAQuSURBVHhe7ZptmoMgDIR7rh6o5+lpvEwP01XUGshAokgX+8z+7PKRTF6SoN7e/KMCnSlw68wemkMF3oSSEHSnAKHsLiQ0iFCSge4UIJTdhYQGEUoy0J0ChLK7kNAgQkkGulOAUHYXEhpEKMlAdwpcG8rhcRv/HkN3stIgW4F88DYoX89nObjmANuOc0eMXpHHcyX9+mowhgHKmdlChM0BZzvzet6DSSW7xjEWk8Hu+/O1x7zF1237/Uu4t/O46V6sZuARoZb9KqbO7On4rJlykqcYYnNAjSbx3Gmrj6WTzxirVlA+90F82G+nm4fX3zOxgqyKqRaUU7b8FpRDOeyjJa7k5oByT1yWse4mxfDC3NrrprnQtQeUMuUXoURmCGHdKfl/oTS8MElxu2mudO0BXUCZL8efVGU0EmsQjkGpM2H8y/CwGtW1C3el8ywxhHKWxgOlaPNj0VcRRW+OoiKvCXF0o6YeXWLQDaNQyMf1Clhsi22D9HUNXOBCVZamaBmiO5BxRdRQOt3M3oFUAD4/HDolSChx7AvXzRIJQtgsUfMu6HB+HglNLc5d5KiwpcAqTH7Idk/lvLD9Z0rUx4vYWL2UJ4WY6XbdL91ML57+EjsRNEMnw/LCrKklN9NNkbuLvKsdabjM/ZMByh+PDWuuw6kDEYXPzeSfzGARlNG1M1ENRCfGLlUuJ5MVTg+UyxGzC+1+KN/DkDyuTSVbqo7vNnagfKPTrH9b8pQtgQ/PRCifDTaUJaIWw8adUycklLrcppkyCZfkJ5cYlSZnQTkmsYf58OYAlMpg6JnlhYlC9uxhIdWvbr1NS8Ahc9pgQlkkai3fOorVUK4JGeYTJIgVTm+mnCqrmSfOgDJ0mOlOlhcmClk3M0KmPzeF0mnDGVB6LjqbmKB8p5GRQ34DStRCdpEpp5MRNWRNocwsjk9i7nyqugzPYTWUSZuqe0qVucAT5tgH9ITmxEdCdihjpcCVAgfI8uJ4pgx3K3UhgBeRQ9dtbJmjp1TnYmsKoSH1UGqKE23mxlrsri4yKsuAFnZ5BrAugypw0/IdSvHmxHJbEI6lREzj0asuOc7TR8BONdd9pNKCo4LRNY9CdgCEXjqObDhQvsFpy7z7DsqHP9khxp9DzNeKbSR+Iy3/n31tqVFYe17xFUZkTu507+4px4USFwBRm32lbzFyXphgRMtn3cwqqaef8a0UrMHlaJYM8RC1Iq2DeOXvKUdVjALmzromST8+4N+Egm9rrwzl/DpAVlddnE9su36Jyx6ECtkUxufaUMJOzfwQsxldUbnTLyO/ckCcNsS112yDmkkGF/4xKL8rHndrowChbKMrV61QgFBWiMepbRQglG105aoVChDKCvE4tY0ChLKNrly1QgFCWSEep7ZRgFC20ZWrVihAKCvE49Q2ChDKNrpy1QoF/gDXIhmWmc+CSAAAAABJRU5ErkJggg==&quot;);&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于移动端的性能可以参考 Peter McLachlan在13年写的一片文章：&lt;a href=&quot;https://link.jianshu.com/?t=http://www.mobify.com/blog/data-uris-are-slow-on-mobile/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://www.mobify.com/blog/data-uris-are-slow-on-mobile/&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1200&quot; data-height=&quot;900&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1790518-03ce4f648645583e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; width=&quot;506&quot; height=&quot;380&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/1790518-03ce4f648645583e.png&quot; data-original-width=&quot;1200&quot; data-original-height=&quot;900&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;86151&quot;/&gt;&lt;/div&gt;
&lt;h2 class=&quot;image-view&quot; data-width=&quot;1200&quot; data-height=&quot;900&quot;&gt;参考文献&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 29 Jun 2018 13:23:00 +0000</pubDate>
<dc:creator>Angel_Kitty</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ECJTUACM-873284962/p/9245474.html</dc:identifier>
</item>
<item>
<title>React学习及实例开发（三）——用react-router跳转页面 - 麦豇豆</title>
<link>http://www.cnblogs.com/MaiJiangDou/p/9245063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MaiJiangDou/p/9245063.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;本文基于React v16.4.1&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;初学react，有理解不对的地方，欢迎批评指正^_^&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;一、定义路由&lt;/h3&gt;
&lt;p&gt;1、安装react-router&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install react-router@&lt;span&gt;3.0&lt;/span&gt;.&lt;span&gt;5&lt;/span&gt; --save
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：react-router 4.x版本改动较大，这里用的是3.x版本。&lt;/p&gt;
&lt;p&gt;2、新建几个页面（用来跳转，不需要什么内容），例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import React, { Component } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; PageOne extends Component{
    render(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(
            &lt;/span&gt;&amp;lt;h3&amp;gt;page &lt;span&gt;1&lt;/span&gt;&amp;lt;/h3&amp;gt;&lt;span&gt;      
        )
    }
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; PageOne;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、新建一个router.js文件，将上面新建的页面加入路由。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;这里是要通过侧边栏改变Content部分的内容，App是包含有侧边栏的页面，所以其他page要嵌套在App里面。&lt;/li&gt;
&lt;li&gt;IndexRoute可以定义默认路由&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
import React, { Component } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
import { Router, Route, browserHistory, IndexRoute } &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react-router&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
import App &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./App&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
import PageOne &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./pages/PageOne&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
import PageTwo &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./pages/PageTwo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
import PageThree &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./pages/PageThree&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Routers extends Component {
    render(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;(
            &lt;/span&gt;&amp;lt;Router history={ browserHistory }&amp;gt;
                &amp;lt;Route path=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; component={App}&amp;gt;
                    &amp;lt;IndexRoute component={PageOne} /&amp;gt;
                    &amp;lt;Route path=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;page1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; component={PageOne} /&amp;gt;
                    &amp;lt;Route path=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;page2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; component={PageTwo} /&amp;gt;
                    &amp;lt;Route path=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;page3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; component={PageThree} /&amp;gt;    
                &amp;lt;/Route&amp;gt;
            &amp;lt;/Router&amp;gt;&lt;span&gt; 
        )
    }   
}
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; Routers;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、在入口文件index.js中引入路由&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import React &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
import ReactDOM &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react-dom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
import &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./index.css&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
import Routers &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./router&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
import registerServiceWorker &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./registerServiceWorker&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;

ReactDOM.render(&lt;/span&gt;&amp;lt;Routers /&amp;gt;, document.getElementById(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;));
registerServiceWorker();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;二、路由跳转&lt;/h3&gt;
&lt;p&gt;1、为侧边栏添加路由链接，例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;Menu.Item key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
   &amp;lt;Link to=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/page1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;Icon type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pie-chart&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;&amp;lt;span&amp;gt;Option &lt;span&gt;1&lt;/span&gt;&amp;lt;/span&amp;gt;&amp;lt;/Link&amp;gt;
&amp;lt;/Menu.Item&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、在Content中加入 this.props.children ，路由会指出相应的children&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;Content&amp;gt;&lt;span&gt;
     {&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props.children}
&lt;/span&gt;&amp;lt;/Content&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1110154/201806/1110154-20180629192811004-1444872749.png&quot; alt=&quot;&quot; width=&quot;486&quot; height=&quot;385&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;END-------------------------------------&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 Jun 2018 11:30:00 +0000</pubDate>
<dc:creator>麦豇豆</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MaiJiangDou/p/9245063.html</dc:identifier>
</item>
<item>
<title>【Python开发】Python中数据分析环境的搭建 - 昕-2008</title>
<link>http://www.cnblogs.com/Belter/p/9244997.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Belter/p/9244997.html</guid>
<description>&lt;p&gt;&lt;span&gt;注&lt;/span&gt;：无论是任何一门语言，刚开始入门的时候，语言运行环境的搭建都是一件不轻松的事情。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;Python的运行环境&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;要运行或写Python代码，就需要Python的运行环境，主要的Python有以下三类：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;原生态的Python：就是直接从Python的官网下载，然后安装使用。这类方法最简单直接，但是后期不容易维护；&lt;/li&gt;
&lt;li&gt;一些其他类型的Python发行本：这种类型的Python一般与一些package和其他工具整合在一起，类似于定制版的Python，易于安装和使用，例如用的比较多的Anaconda发行版；&lt;/li&gt;
&lt;li&gt;使用docker来提供Python的运行环境：使用该方法，不用在自己电脑上直接安装Python的，只用在docker中构建好相应的Python的image就好了。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;回想自己使用Python的过程，一开始也是直接到Python的官网上下载最新版本的安装包。安装完Python后，添加环境变量，在cmd中用pip一个一个安装需要使用的package。每次都是重复这样的过程，有时候会遇到一些莫名其妙的问题，比如某些package无法安装成功；有时候只能下源码自己编译安装。有时候还会需要不同版本的Python，电脑里就会出现多个版本的Python。&lt;/p&gt;
&lt;p&gt;现在后面两类方法用的比较多。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;关于开发环境&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;还记得有段时间接触到Java，一直分不清楚JRE和JDK的区别。现在终于搞明白了，JRE是运行是Java运行环境（Java Runtime Environment），可以用来运行Java的代码；JDK是Java开发工具包（Java Developer's Kit），即Java的开发环境，主要用来写代码。&lt;/p&gt;
&lt;p&gt;写代码时，有一个好的集成开发环境（integrated development environment，IDE）会让我们事半功倍，包括但不限于以下这些优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;语法检查；&lt;/li&gt;
&lt;li&gt;提示及命令补全；&lt;/li&gt;
&lt;li&gt;好看的配色和字体；&lt;/li&gt;
&lt;li&gt;强大的debug功能；&lt;/li&gt;
&lt;li&gt;对大型project的管理功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我用的比较多的IDE包括：PyCharm，Spyder和Jupyter notebook.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PyCharm在开发大型项目时是首选，但是平时分析数据时就显得有些笨重了；&lt;/li&gt;
&lt;li&gt;Spyder主要用于科学计算(与RStudio非常像，可以单行运行)；但是对内存要求比较大，数据量比较大的时候容易崩溃；&lt;/li&gt;
&lt;li&gt;Jupyter notebook算是新生代的数据科学界的IDE，非常适合做数据分析。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;span&gt;Anaconda发行版&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt; Anaconda是一种Python语言的免费增值开源发行版，用于进行大规模数据处理, 预测分析, 和科学计算, 致力于简化包的管理和部署。Anaconda使用软件包管理系统Conda进行包管理。——wiki&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 上面是wiki中对Anaconda Python发行版的介绍，其特点就是：为数据科学而定制的版本，利用conda来管理package比原生态的pip更方便。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;完整版本的Anaconda&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;完整版本的Anaconda比较大，最新版的600多兆(windows, 64-Bit, Python3.6)，该版本不仅包括Python，还有预装好的100多个package，省去了自己安装包的麻烦。但是体积比较大，通常很多包都用不到。&lt;/p&gt;
&lt;p&gt;下载链接：https://www.anaconda.com/download/&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;Miniconda&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Minicoda只包含conda, Python和少量的包，大小只有50几兆。安装好Miniconda后，可以使用conda install来安装其他python的包&lt;/p&gt;
&lt;p&gt;下载链接：https://conda.io/miniconda.html&lt;/p&gt;

&lt;p&gt;下面以Miniconda为例，安装和配置Python的运行环境及开发环境（windows 7, 64位）&lt;/p&gt;
&lt;h5&gt;1. 安装miniconda&lt;/h5&gt;
&lt;p&gt;打开上面的链接，下载想要安装的版本后进行安装。&lt;/p&gt;
&lt;p&gt;更多参考安装指南：https://conda.io/docs/user-guide/install/index.html&lt;/p&gt;
&lt;p&gt;安装完成后，在开始菜单可以看到下面的标志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1035701/201806/1035701-20180629164842999-1173827116.png&quot; alt=&quot;&quot; width=&quot;293&quot; height=&quot;599&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;2. 安装需要的package&lt;/h5&gt;
&lt;p&gt;点击上面的Anaconda Prompt，打开anaconda的命令行工具。在这个命令行中可以直接使用conda：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;- conda env list: 列出所有的虚拟环境；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;- conda list: 列出当前虚拟环境中已经安装的包；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;- conda search packagex: 搜索包packagex，会返回不同版本的包，可以使用&quot;packagex==x.y&quot;来指定安装x.y版；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;- conda install packagex: 安装包packagex.  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1035701/201806/1035701-20180629165516771-1763604525.png&quot; alt=&quot;&quot; width=&quot;670&quot; height=&quot;438&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看到，现在只有一个虚拟环境——base，在这个环境中有30个预装的包。&lt;/p&gt;
&lt;p&gt;下面安装常用的几个用于数据分析的工具包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1035701/201806/1035701-20180629171317883-406132664.png&quot; alt=&quot;&quot; width=&quot;672&quot; height=&quot;439&quot;/&gt;&lt;/p&gt;

&lt;p&gt;指定安装0.19.1版的scikit-learn: &lt;span&gt;conda install scikit-learn==0.19.1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1035701/201806/1035701-20180629171910585-488512216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;conda作为anaconda中Python包管理工具，还有其他很多功能，可参考：&lt;/p&gt;
&lt;p&gt;https://conda.io/docs/commands.html&lt;/p&gt;
&lt;p&gt;https://conda.io/docs/_downloads/conda-cheatsheet.pdf&lt;/p&gt;

&lt;h5&gt; 3. 安装jupyter notebook&lt;/h5&gt;
&lt;p&gt;安装jupyter notebook的命令：&lt;span&gt;conda install jupyter&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;安装后，可以看到开始菜单多了一个图标：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1035701/201806/1035701-20180629181323022-593992548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h5&gt;4. 运行jupyter notebook&lt;/h5&gt;
&lt;p&gt;使用时，可以直接从开始菜单中的&quot;Jupyter Notebook&quot;启动，或是在命令行中输入jupyter notebook。打开后，会在浏览器中打开一个页面：&lt;/p&gt;
&lt;p&gt;链接默认为：&lt;span&gt;http://localhost:8888/tree&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1035701/201806/1035701-20180629181725945-1949721709.png&quot; alt=&quot;&quot; width=&quot;889&quot; height=&quot;253&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击图中框出来的&quot;New&quot;菜单，选择&quot;Python 3&quot;就可以打开一个新的notebook&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1035701/201806/1035701-20180629182021809-1308465161.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1035701/201806/1035701-20180629182107306-412551681.png&quot; alt=&quot;&quot; width=&quot;865&quot; height=&quot;240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时就可以写代码了！&lt;/p&gt;
&lt;p&gt;退出时，关闭相应的cmd窗口就可以了。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;Jupyter Notebook&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;
&lt;p&gt;对于Jupyter Notebook，完全值得单独拿出来说说。&lt;/p&gt;
&lt;p&gt;jupyter notebook是一个交互式的IDE，虽然不像PyCharm这种重型IDE那么强大，但是仍然可以当做IDE来用，而且有一些特色非常适合用来进行数据分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以单行运行代码，这样就可以一行一行的检查代码，查看运行结果，反复尝试；&lt;/li&gt;
&lt;li&gt;每次运行后变量都保存在内存中，因此可以重复使用（这对于一些比较耗时的计算过程，尤其有用）；&lt;/li&gt;
&lt;li&gt;可以写markdown格式的注释，这样就可以将整个分析过程非常清晰的表达出来；&lt;/li&gt;
&lt;li&gt;可以利用Mathjax展示数学公式；&lt;/li&gt;
&lt;li&gt;可以插入图片等，可以制作出图和代码并茂的非常精致的笔记和文档（有很多已经出版的书都是完全使用notebook来写作的）.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是个人感觉jupyter notebook并不适用代码量比较大的工程类项目。&lt;/p&gt;
&lt;p&gt;自己最近几个月一直在使用这个工具，但是还没有系统的研究过。这里先放几个链接，后面再来补充：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;知乎上的一个介绍：https://www.zhihu.com/question/37490497/answer/212044783(你为什么使用 jupyter ，进行分析，而不是用 python 脚本或仅仅利用 excel ？ - 子珂的回答)&lt;/li&gt;
&lt;li&gt;datacamp中介绍Jupyter Notebook的文章（包括如何运行R代码）：https://www.datacamp.com/community/tutorials/tutorial-jupyter-notebook&lt;/li&gt;
&lt;li&gt;另一篇文章（包括快捷键，其他注意事项等）：https://www.dataquest.io/blog/jupyter-notebook-tutorial/&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外，JupyterLab:被称为下一代Jupyter，对原来的Jupyter Notebook做了很多改进。&lt;/p&gt;
&lt;p&gt;参考文档：https://jupyterlab.readthedocs.io/en/latest/&lt;/p&gt;
&lt;p&gt;安装：conda install -c conda-forge jupyterlab&lt;/p&gt;
&lt;p&gt;运行：jupyter lab&lt;/p&gt;

&lt;p&gt;&amp;lt;完&amp;gt;&lt;/p&gt;
</description>
<pubDate>Fri, 29 Jun 2018 11:07:00 +0000</pubDate>
<dc:creator>昕-2008</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Belter/p/9244997.html</dc:identifier>
</item>
<item>
<title>网络爬虫之scrapy框架设置代理 - 人生不如戏</title>
<link>http://www.cnblogs.com/fu-yong/p/9244967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fu-yong/p/9244967.html</guid>
<description>&lt;h2&gt;前戏&lt;/h2&gt;
&lt;h3&gt;os.environ()简介&lt;/h3&gt;
&lt;p&gt;os.environ()可以获取到当前进程的环境变量，注意，是当前进程。&lt;/p&gt;
&lt;p&gt;如果我们在一个程序中设置了环境变量，另一个程序是无法获取设置的那个变量的。&lt;/p&gt;
&lt;p&gt;环境变量是以一个字典的形式存在的，可以用字典的方法来取值或者设置值。&lt;/p&gt;
&lt;h3&gt;os.environ() key字段详解&lt;/h3&gt;
&lt;p&gt;windows：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
os.environ['HOMEPATH']:当前用户主目录。
os.environ['TEMP']:临时目录路径。
os.environ[PATHEXT']:可执行文件。
os.environ['SYSTEMROOT']:系统主目录。
os.environ['LOGONSERVER']:机器名。
os.environ['PROMPT']:设置提示符。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;linux：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
os.environ['USER']:当前使用用户。
os.environ['LC_COLLATE']:路径扩展的结果排序时的字母顺序。
os.environ['SHELL']:使用shell的类型。
os.environ['LAN']:使用的语言。
os.environ['SSH_AUTH_SOCK']:ssh的执行路径。
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;内置的方式&lt;/h2&gt;
&lt;h3&gt;原理&lt;/h3&gt;
&lt;p&gt;scrapy框架内部已经实现了设置代理的方法，它的原理是从环境变量中取出设置的代理，然后再使用，&lt;/p&gt;
&lt;p&gt;所以我们只需要在程序执行前将代理以键值对的方式设置到环境变量中即可。&lt;/p&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;第一种方式：&lt;/strong&gt;&lt;strong&gt;直接添加键值对的方式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class ChoutiSpider(scrapy.Spider):
        name = 'chouti'
        allowed_domains = ['chouti.com']
        start_urls = ['https://dig.chouti.com/']
        cookie_dict = {}

        def start_requests(self):
                import os
                os.environ['HTTPS_PROXY'] = &quot;http://username:password@192.168.11.11:9999/&quot;
                os.environ['HTTP_PROXY'] = '19.11.2.32',
                for url in self.start_urls:
                        yield Request(url=url,callback=self.parse)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;第二种方式：设置meta参数的方式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class ChoutiSpider(scrapy.Spider):
        name = 'chouti'
        allowed_domains = ['chouti.com']
        start_urls = ['https://dig.chouti.com/']
        cookie_dict = {}

        def start_requests(self):
                for url in self.start_urls:
                        yield Request(url=url,callback=self.parse,meta={'proxy':'&quot;http://username:password@192.168.11.11:9999/&quot;'})
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;自定义方式&lt;/h2&gt;
&lt;h3&gt;原理&lt;/h3&gt;
&lt;p&gt;我们可以根据内部实现的添加代理的类（中间件）的实现方法，来对它进行升级，比如内部的方式一次只能使用一个代理，&lt;/p&gt;
&lt;p&gt;我们可以弄一个列表，装很多代理地址，然后随机选取一个代理，这样可以防止请求过多被封ip&lt;/p&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;58&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class ChoutiSpider(scrapy.Spider):
        name = 'chouti'
        allowed_domains = ['chouti.com']
        start_urls = ['https://dig.chouti.com/']
        cookie_dict = {}

        def start_requests(self):
                for url in self.start_urls:
                        yield Request(url=url,callback=self.parse,meta={'proxy':'&quot;http://username:password@192.168.11.11:9999/&quot;'})

                        import base64
                        import random
                        from six.moves.urllib.parse import unquote
                        try:
                                from urllib2 import _parse_proxy
                        except ImportError:
                                from urllib.request import _parse_proxy
                        from six.moves.urllib.parse import urlunparse
                        from scrapy.utils.python import to_bytes

                        class XXProxyMiddleware(object):

                                def _basic_auth_header(self, username, password):
                                        user_pass = to_bytes(
                                                '%s:%s' % (unquote(username), unquote(password)),
                                                encoding='latin-1')
                                        return base64.b64encode(user_pass).strip()

                                def process_request(self, request, spider):
                                        PROXIES = [
                                                &quot;http://username:password@192.168.11.11:9999/&quot;,
                                                &quot;http://username:password@192.168.11.12:9999/&quot;,
                                                &quot;http://username:password@192.168.11.13:9999/&quot;,
                                                &quot;http://username:password@192.168.11.14:9999/&quot;,
                                                &quot;http://username:password@192.168.11.15:9999/&quot;,
                                                &quot;http://username:password@192.168.11.16:9999/&quot;,
                                        ]
                                        url = random.choice(PROXIES)

                                        orig_type = &quot;&quot;
                                        proxy_type, user, password, hostport = _parse_proxy(url)
                                        proxy_url = urlunparse((proxy_type or orig_type, hostport, '', '', '', ''))

                                        if user:
                                                creds = self._basic_auth_header(user, password)
                                        else:
                                                creds = None
                                        request.meta['proxy'] = proxy_url
                                        if creds:
                                                request.headers['Proxy-Authorization'] = b'Basic ' + creds
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写完类之后需要在settings文件里配置一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
DOWNLOADER_MIDDLEWARES = {
   'spider.xxx.XXXProxyMiddleware': 543,
}
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 29 Jun 2018 11:00:00 +0000</pubDate>
<dc:creator>人生不如戏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fu-yong/p/9244967.html</dc:identifier>
</item>
<item>
<title>COMCMS_CORE 起步篇，如何运行和部署 - 漫遊者</title>
<link>http://www.cnblogs.com/m5v8/p/9244920.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/m5v8/p/9244920.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;前言：关于最近开源后，不少朋友问，怎么我下载下来，运行不了。或者怎么没有左边菜单。货不对板？还是我吃了数据？&lt;/p&gt;
&lt;p&gt;感言：开源不容易，更不容易的是，明明毫无保留，还这么大误会，真是泪奔.....&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了。步入正题：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、本地运行调试&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.5454545454545&quot;&gt;
&lt;p&gt;前提准备：项目GitHub库地址：&lt;a href=&quot;https://github.com/hogenwang/comcms_core&quot; target=&quot;_blank&quot;&gt;https://github.com/hogenwang/comcms_core&lt;/a&gt;  ；VS2017安装好了，Mysql 5.7 安装好了；dotnet core 2.1.1 SDK 安装好了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、拉去或者下载源代码，这个就不教了，如果这还不会，我劝你还是放弃吧。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/107254/201806/107254-20180629181625996-2124640855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、双击COMCMS_NETCORE.sln 打开，并修改配置文件：appsettings.json&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/107254/201806/107254-20180629181800010-1859524063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &quot;dbconn&quot;&lt;span&gt;: {
      &lt;/span&gt;&quot;connectionString&quot;: &quot;Server=.;Port=3306;Database=comcms2;Uid=root;Pwd=root;&quot;&lt;span&gt;,
      &lt;/span&gt;&quot;providerName&quot;: &quot;MySql.Data.MySqlClient&quot;&lt;span&gt;
    },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里修改成你自己的，并且提前建立好数据库。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、将data目录下的comcmscore.sql 导入到数据库，可以通过Navicat工具，或者PHPMyadmin等，任意&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、运行，或者右键任意一个view文件，使用xxx浏览：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/107254/201806/107254-20180629182115175-755258780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5、打开后台并登录。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;http://localhost:11079/AdminCP/Login&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/107254/201806/107254-20180629182401123-177690737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，恭喜你，已经成功了一半了！小心翼翼输入：admin和admin，按一下【登录】。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/107254/201806/107254-20180629182451518-297951266.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;二、如何部署到windows server 服务器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前提当然还是需要下载最新的runtime和hosting。为了方便，你也可以直接安装最新的sdk。因为sdk本身就包含了runtime。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;哪里可以下载到最新的？好吧，请到这里去找：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/core/tree/master/release-notes&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/dotnet/core/tree/master/release-notes&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你原来已经安装了，打开提示502.5错误，大部分情况，你可以直接安装最新的rumtime和hosting，是可以解决问题的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/107254/201806/107254-20180629184207216-517565850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其他的数据安装如上面....&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、发布网站：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/107254/201806/107254-20180629183445699-309763673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/107254/201806/107254-20180629183458505-1884114257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、随后将发布后的所有文件复制到服务器上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/107254/201806/107254-20180629183609193-2117564923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、IIS新建一个应用池，选择：无托管代码、集成模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/107254/201806/107254-20180629183649492-1767156150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、新建一个网站，指定到这个目录：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/107254/201806/107254-20180629183736436-1650314361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、随后修改配置，浏览网站即可。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;如果有其他的问题，可以加QQ群：1600800&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 29 Jun 2018 10:43:00 +0000</pubDate>
<dc:creator>漫遊者</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/m5v8/p/9244920.html</dc:identifier>
</item>
<item>
<title>hive优化分享 - 999.感冒灵</title>
<link>http://www.cnblogs.com/SunHuaJ/p/9244899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SunHuaJ/p/9244899.html</guid>
<description>&lt;p&gt;粘贴一下我在部门中的一次hive优化的分享。&lt;/p&gt;


&lt;p&gt;hive构建在hadoop基础上，利用分布式存储，通过mr引擎实现对大数据的计算。MR会频繁地读写磁盘而且MR任务的启动成本很高。对于hive优化显得尤为重要。而优化的核心就是更好地利用hadoop的分布式特性和hive的有点。本篇从IO、参数设置、案例实战来说明如何优化我们的hive。受限于个人能力，如有不足之处，还望指出，一起沟通讨论。&lt;/p&gt;


&lt;p&gt;　　A、通过列裁剪，只读取需要的列[对select * 的做法应进行严格要求，甚至禁止]&lt;/p&gt;
&lt;p&gt;　　B、 join操作前，应提前处理表，只读取需要的列，并对数据进行梳理。&lt;/p&gt;
&lt;p&gt; 　　   原：select A.char1,B.char2&lt;/p&gt;
&lt;p&gt;    　　     from A join B&lt;/p&gt;
&lt;p&gt;    　　           on A.id=B.id&lt;/p&gt;
&lt;p&gt;   　　      where A.disabled=0 and B.disabled=0&lt;/p&gt;
&lt;p&gt;  　　  优：select A.char1,B.char2&lt;/p&gt;
&lt;p&gt;  　　        from&lt;/p&gt;
&lt;p&gt;     　　          (&lt;/p&gt;
&lt;p&gt;    　　            select id,char1&lt;/p&gt;
&lt;p&gt;            　　      from a&lt;/p&gt;
&lt;p&gt;     　　            where a.disabled=0&lt;/p&gt;
&lt;p&gt;    　　           ) A&lt;/p&gt;
&lt;p&gt;  　　             join&lt;/p&gt;
&lt;p&gt;       　　        (&lt;/p&gt;
&lt;p&gt;     　　           select id,char2&lt;/p&gt;
&lt;p&gt;          　　        from b&lt;/p&gt;
&lt;p&gt;     　　            where b.disabled=0&lt;/p&gt;
&lt;p&gt;      　　         ) B&lt;/p&gt;
&lt;p&gt;   　　            on A.id=B.id&lt;/p&gt;
&lt;p&gt;　　C、选择合适的存储类型&lt;/p&gt;
&lt;p&gt;　　　　建议使用orc存储格式，作为默认设置[支持切片，有压缩，提高查询速度]。创建表时，指定stored as orcfile&lt;/p&gt;
&lt;p&gt;　　D、走分区[可选]&lt;/p&gt;
&lt;p&gt;　　　　减少读取更多的分区文件，极大地有帮助！处理分区时，不可对分区字段进行操作，否则将会导致全表扫描。&lt;/p&gt;

&lt;p&gt;  　　A、left semi join取代in&lt;/p&gt;
&lt;p&gt; 　　   根据测试，对于在大数据量中查询某些取值时，有效提升查询效率。[测试：从erp_fct_order表中，查找若干数据。left semi join 使用了100'+,in耗时300'+]&lt;/p&gt;
&lt;p&gt; 　　 B、map join&lt;/p&gt;
&lt;p&gt;   　　 当小表与大表进行关联时，通过map join，使左表进入内存，与右表进行关联。这个阶段不涉及reduce。&lt;/p&gt;
&lt;p&gt;   　　 通过设置set hive.auto.convert.join=true;[默认]&lt;/p&gt;
&lt;p&gt;       　　     set hive.mapjoin.smalltable.filesize=2500000;[25M,通过配置该属性来确定使用该优化的表的大小，如果表的大小小于此值就会被加载进内存中]&lt;/p&gt;

&lt;h2&gt;  reducer数量&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;    　　我们执行语句时，总会看到这个： &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   　　 Number of reduce tasks determined at compile time: 1&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  　　  In order to change the average load for a reducer (in bytes):&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   　　   set hive.exec.reducers.bytes.per.reducer=&amp;lt;number&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 　　   In order to limit the maximum number of reducers:&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 　　     set hive.exec.reducers.max=&amp;lt;number&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    　　In order to set a constant number of reducers:&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;     　　 set mapreduce.job.reduces=&amp;lt;number&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    　　Starting Job = job_1515122600431_869586, Tracking URL = http://hadoop04:8088/proxy/application_1515122600431_869586/&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    　　上面其实就是，hadoop确定reduce的数量的方式。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   　　 N=min(hive.exec.reducers.max,总数据量大小/hive.exec.reducers.bytes.per.reducer),默认情况下，hive.exec.reducers.max=999，hive.exec.reducers.bytes.per.reducer=1G;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    　　我们也可以强制指定reduce数量，mapreduce.job.reduces=N。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    　　需要注意的是，有的reduce为0，有的只为1。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    　　为0，即为该任务只有map，没有reduce。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　    为1，即为全局，如order by、count、笛卡尔积。&lt;/p&gt;
&lt;h2&gt;  mapper的数量&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;    　　map端处理文件时，将对文件进行拆分成若干个task数。而如何拆分，这本身和文件的存储类型相关。hive系统默认的类型为org.apache.hadoop.hive.ql.io.CombineHiveInputFormat[set hive.input.format;]，当我们不指定存储类型时，hive将根据文件本身设置对应的存储类型。如：org.apache.hadoop.mapred.TextInputFormat。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    　　继承了FileInputFormat的切分算法：splitSize = max{split.size,min{goalSize,blockSize}}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    　　若格式为:HiveInputFormat&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    　　split.size:mapred.min.split.size,默认为1。切片最小大小，没有什么能比这个更小的了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  　　  goalSize:目标大小，为用户设置的map task数与实际大小决定。goalSize=总大小/设置的mapred.map.tasks的大小[默认为2]&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    　　blockSize:块大小[set dfs.block.size]，当前我们系统的块为：128M&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    　　所以，当我们没有设置最小的切片大小时，切片的大小，取决于文件大小、设置的mapred.map.tasks数、块大小.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   　　 例如：一个文件如果是300M，则切片大小为：splitSize=max{1,min{300/2,128}}=128M,则3个map对应的文件大小为：128,128,46&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   　　 若格式为：TextInputFormat：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   　　 split.size:mapred.max.split.size，[当前系统为256M],则splitSize为max{256,min{300/2,128}}=256,则只有一个map.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    小结&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　mapper的数量合适，单个mapper处理的数据量合适；拆分大小尽量与block数据块相同，避免一个拆分块大小有多个 hdfs 块，且位于不同数据节点，从而降低网络 IO。如果想减少mapper的数据量，一般只要将mapred.max.split.size设置的更大就可以了。&lt;/p&gt;
&lt;h2&gt;  合并小文件&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;　　hive基于NameNode进行调度管理和任务分发，NameNode本身是有瓶颈的，有固定的大小。在hadoop任务中，NameNode加载必要的信息，其中包括各个文件的元数据（位置、大小、块信息等）。一般情况下，当文件数达到1000W时，所占用的NameNode内存达到3G，将带来性能下降。Hadoop本身对大文件具有很高的处理能力，但在mr任务过程中，map任务和reduce任务都会带来小文件的问题。当小文件作为输入，由map来进行处理时，启用map带来的时间比处理更耗时。此外，reduce数量多的话，产生的小文件也会增多。&lt;/p&gt;
&lt;h3&gt;　　输入时合并&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;　　set mapred.max.split.size=256000000;-- 每个Map最大输入大小，决定合并后的文件数      &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　set mapred.min.split.size.per.node=100000000; -- 一个节点上split的至少的大小 ，决定了多个data node上的文件是否需要合并 [当前设置为:1，默认设置。设置该参数，一定要设置下方的rack参数，否则报错。]&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　set mapred.min.split.size.per.rack=100000000; -- 一个交换机下split的至少的大小，决定了多个交换机上的文件是否需要合并 [当前设置为:1，默认设置]&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　set hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat; -- 执行Map前进行小文件合并[经过测试，设置上面的参数就能够让小文件进行合并了。]&lt;/p&gt;
&lt;h3&gt;　　输出时合并&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;　　set hive.merge.mapfiles=true; -- 在map-only job后合并文件，默认true&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　set hive.merge.mapredfiles=true; -- 在map-reduce job后合并文件，默认false&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　set hive.merge.size.per.task=256000000; -- 合并后每个文件的大小，默认256000000&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　set hive.merge.smallfiles.avgsize=16000000; -- 平均文件大小,当结果文件小于该值时，将进行合并&lt;/p&gt;
&lt;h2&gt;数据倾斜&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;    原因：当我们进行join操作时，会在map端根据key的hash值，shuffle到某一个reduce上去，在reduce端做join连接操作，内存中缓存join左边的表，遍历右边的表，一次做join操作。所以在做join操作时候，将数据量多的表放在join的右边。当数据量比较大，并且key分布不均匀，大量的key都shuffle到一个reduce上了，就出现了数据的倾斜。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    场景&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    key为空:当join的key存在空值时，这些值会被hash到同一个reduce中，导致数据倾斜。遇到这样的情况，建议区分空和非空&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    count(distinct):数据聚合类的操作sum、count，因为已经在map端做了聚合操作了，到reduce端的数据相对少一些[主要设置参数为:1.set hive.map.aggr=true;默认值，是否在map端进行聚合;2.set hive.groupby.mapaggr.checkinterval = 100000;默认值，在 Map 端进行聚合操作的条目数目],不会出现这个问题。当distinct时，会对group by后的字段和distinct的字段进行hash，如果存在大量重复值，则会导致数据倾斜。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    遇到倾斜时set hive.groupby.skewindata = true;[负载均衡，默认为false。查询计划会有两个 MR Job。第一个 MR Job 中，Map 的输出结果集合会随机分布到 Reduce 中，每个 Reduce 做部分聚合操作，并输出结果，这样处理的结果是相同的 Group By Key 有可能被分发到不同的 Reduce 中，从而达到负载均衡的目的；第二个 MR Job 再根据预处理的数据结果按照 Group By Key 分布到 Reduce 中（这个过程可以保证相同的 Group By Key 被分布到同一个 Reduce 中），最后完成最终的聚合操作]&lt;/p&gt;
&lt;h2&gt;常用参数设置及说明&lt;/h2&gt;
&lt;p&gt;--类型：输入时合并小文件&lt;/p&gt;
&lt;p&gt;　　set hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat; ----可在map端进行合并，减少小文件&lt;/p&gt;
&lt;p&gt;　　set mapred.max.split.size=256000000;  ----设置一个合理的数值，最大的切片数据。影响map的个数 &lt;/p&gt;
&lt;p&gt;　　set mapred.min.split.size.per.node=134217728;  ----一个节点上的最小切片大小。设置为block大小&lt;/p&gt;
&lt;p&gt;　　set mapred.min.split.size.per.rack=256000000;  ----一个交换机上的最小切片大小&lt;/p&gt;
&lt;p&gt;--类型：资源占用量&lt;/p&gt;
&lt;p&gt;　　set mapreduce.map.memory.mb=5120;&lt;/p&gt;
&lt;p&gt;　　set mapreduce.reduce.memory.mb=5120;&lt;/p&gt;
&lt;p&gt;--类型：设置最大值&lt;/p&gt;
&lt;p&gt;　　set mapreduce.job.reduces=80;  ----用来对reduer数量进行控制，但设置的过大，不设置效果更好&lt;/p&gt;
&lt;p&gt;　　set hive.exec.reducers.max=80; ----最大的reduce数&lt;/p&gt;
&lt;p&gt;--类型：mapjoin&lt;/p&gt;
&lt;p&gt;　　set hive.auto.convert.join=true;&lt;/p&gt;
&lt;p&gt;　　set hive.mapjoin.smalltable.filesize=2500000;&lt;/p&gt;
&lt;p&gt;--类型：输出时合并&lt;/p&gt;
&lt;p&gt;　　set hive.merge.mapfiles=true; -- 在map-only job后合并文件，默认true&lt;/p&gt;
&lt;p&gt;　　set hive.merge.mapredfiles=true; -- 在map-reduce job后合并文件，默认false&lt;/p&gt;
&lt;p&gt;　　set hive.merge.size.per.task=256000000; -- 合并后每个文件的大小，默认256000000&lt;/p&gt;
&lt;p&gt;　　set hive.merge.smallfiles.avgsize=16000000; -- 平均文件大小,当结果文件小于该值时，将进行合并&lt;/p&gt;
&lt;p&gt; --类型：并发及并发数&lt;/p&gt;
&lt;p&gt;　　set hive.exec.parallel=true;&lt;/p&gt;
&lt;p&gt;　　set hive.exec.parallel.thread.number=16;&lt;/p&gt;
&lt;h2&gt;补充&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;     在写sql的过程中，有时候会用到排序。但是在hive中用order by排序，将带来一个问题。只有一个reduce。往往带来性能的较差。Hive为查询提供了其他排序方式。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　Order by：全局，一个reduce【不建议】&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　Distribute by ：map的输出排序，排序后，将对应的key通过hash放入到reduce中&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　Sort by：局部排序，在每个reduce中实现排序。当reduce数只有一个时，sort by和order by结果没有什么差异【建议】&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       Cluster by：分桶中用到，用来指定分桶的字段。cluster by  key = distribute by key sort by key desc  ，是一个简写。cluster by只能降序排序。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;原创博客，转载请注明出处！欢迎邮件沟通：shj8319@sina.com&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Fri, 29 Jun 2018 10:37:00 +0000</pubDate>
<dc:creator>999.感冒灵</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SunHuaJ/p/9244899.html</dc:identifier>
</item>
</channel>
</rss>