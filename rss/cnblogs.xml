<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>java设计模式-工厂模式（springweb为例子） - firs大风吹</title>
<link>http://www.cnblogs.com/sundaymorning/p/7489348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sundaymorning/p/7489348.html</guid>
<description>&lt;p&gt;一般而言，工厂模式分为3种，简单工厂模式，工厂方法模式，抽象工厂模式。这三种工厂模式逐层深入吧。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;一，从springWeb.jar包使用抽象工厂模式的一个例子聊起&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;之前对spring各种痴迷，所以在需要发送http请求时，用了spring自带的http客户端，上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.URI;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.nio.charset.Charset;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.HttpMethod;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.client.ClientHttpRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.client.ClientHttpRequestFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.client.ClientHttpResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.http.client.SimpleClientHttpRequestFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.util.StreamUtils;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        
        URI uri &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; URI(&quot;https://www.cnblogs.com/&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建一个抽象ClientHttpRequest工厂&lt;/span&gt;
        ClientHttpRequestFactory chrf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleClientHttpRequestFactory();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生产一个抽象ClientHttpRequest&lt;/span&gt;
        ClientHttpRequest req =&lt;span&gt; chrf.createRequest(uri, HttpMethod.GET);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ClientHttpRequest执行execute方法&lt;/span&gt;
        ClientHttpResponse res =&lt;span&gt; req.execute();
        InputStream is &lt;/span&gt;=&lt;span&gt; res.getBody();
        String strBody &lt;/span&gt;= StreamUtils.copyToString(is, Charset.forName(&quot;UTF-8&quot;&lt;span&gt;));
        is.close();
        System.out.println(strBody);
        
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上UML图，首先是工厂类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/814519/201710/814519-20171027211038523-1077013420.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;产品类，因为产品类有点小复杂，先看产品类接口的定义，看这个产品类的定义，你会觉得spring搞那么复杂干嘛，为啥不直接开一个统一的接口HttpRequest，&lt;/p&gt;
&lt;p&gt;把httpOutputMessage里面的getBody放进去就好了。&lt;/p&gt;
&lt;p&gt;其实仔细想想，spring之所以这么设计，是遵循&lt;strong&gt;“接口隔离原则”。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为啥要遵循这个原则呢？因为看完spring-web-release.jar包后你会发现，httpMessage被三个接口所extends，分别是HttpOutputMessage，HttpInputMessage,HttpRequest。&lt;/p&gt;
&lt;p&gt;这三个接口有十多个实现类，如果并在一起，在三个接口中就需要重复写3次。&lt;/p&gt;
&lt;p&gt;再聊聊HttpOutputMessage，HttpInputMessage，这两个接口对于springMVC来说是重中之重，是springMVC传输的载体，后面我们聊springMVC框架时还会遇到他们。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/814519/201710/814519-20171027213914789-1400688467.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看具体的产品实现类，笔者比较喜欢把方法也放进类图里面，所以稍微显得有点臃肿。前面我们看到，clientHttpRequest接口一共有5个接口方法需要子类去实现。&lt;/p&gt;
&lt;p&gt;我猜想spring是这样子想的：&lt;/p&gt;
&lt;p&gt;1，先定义几个抽象类implement那个ClientHttpRequest接口，然后在抽象类中对clientHttpRequest中做基本的实现，和之前笔者分析spring.core.io包里面想法一模一样。&lt;/p&gt;
&lt;p&gt;这是用到设计模式中的&lt;strong&gt;“模版方法”&lt;/strong&gt;模式，不过模版方法比较简单，就不单独开帖聊了。&lt;/p&gt;
&lt;p&gt;2，5个接口方法中，在AbstractClientHttpRequest中实现了&lt;strong&gt;getHeaders(),getBody(),execute()&lt;/strong&gt;3个方法，&lt;/p&gt;
&lt;p&gt;然后还不省事地给他的子类添加了两个抽象方法&lt;strong&gt;getBodyInternal(HttpHeaders headers)，executeInternal(HttpHeaders headers)&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;再悄悄地告诉你，这两个抽象方法分别有一个抽象类和两个具体实现类实现了该抽象方法，也就是我们的产品实现类的类图还没有画完，下图只是画了冰山一角而已，不过管中窥豹可见一斑，将就看看吧。&lt;/p&gt;
&lt;p&gt;3.剩下的两个接口方法，&lt;strong&gt;getURI，getMethod()&lt;/strong&gt;方法在&lt;strong&gt;SimpleStreamingClientHttpRequest&lt;/strong&gt;具体的实现类中实现。&lt;/p&gt;
&lt;p&gt;4,最后再分析下&lt;strong&gt;SimpleBufferingClientHttpRequest&lt;/strong&gt;这个最底层的实现类。&lt;strong&gt;getURI，getMethod()&lt;/strong&gt;是在这个&lt;strong&gt;SimpleBufferingClientHttpRequest底层类&lt;/strong&gt;实现的。同时第2点提到的两个不省事的抽象方法在&lt;strong&gt;SimpleBufferingClientHttpRequest&lt;/strong&gt;的父抽象类&lt;strong&gt;AbstractBufferingClientHttpRequest&lt;/strong&gt;已经进行了具体的实现。&lt;/p&gt;
&lt;p&gt;5.总结，&lt;strong&gt;&lt;span&gt;以上几个类基本上一个接口方法对应着一个@Override&lt;/span&gt;&lt;/strong&gt;，我猜想这是为了符合&lt;strong&gt;里氏替换原则&lt;/strong&gt;（每个父类能用的地方，他的子类替换过去不会有任何影响）。&lt;/p&gt;
&lt;p&gt;其实我挺期待父类override祖父类的接口方法，而后，孙子类再override父类的方法的，好像很少有这种用法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/814519/201710/814519-20171027225426508-533645492.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;spring用到的这种工厂模式，应该是属于最复杂的&lt;strong&gt;抽象工厂模式&lt;/strong&gt;吧，继承树，产品族什么的，真的好复杂。&lt;/p&gt;
&lt;p&gt;回到刚开始的需求，其实如果只是要发起一个简单的http请求，用工厂方法模式或者简单工厂模式就可以了吧。&lt;/p&gt;
&lt;h3&gt;二：工厂方法模式和简单工厂模式&lt;/h3&gt;
&lt;p&gt;举个栗子，我们来砍掉上述抽象工厂的产品族等等的一些为了拓展而抽象出的类和接口，类图会变成这个样子。&lt;/p&gt;
&lt;p&gt;笔者故意比上面的类图多画了一个工厂实现类，让ClientHttpRequestFactory这个接口不会显得很鸡肋。用工厂方法模式其实已经能很大程度地增加程序的拓展性了。&lt;/p&gt;
&lt;p&gt;将OkHttp3ClientHttpRequestFactory这个工厂具体实现类删掉，就变成了简单工厂模式的类图了。&lt;/p&gt;
&lt;p&gt;至此，3种工厂模式已经介绍完了，如有错漏，还请各位博友批评指正。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/814519/201710/814519-20171027234026180-1854251824.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Oct 2017 15:51:00 +0000</pubDate>
<dc:creator>firs大风吹</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sundaymorning/p/7489348.html</dc:identifier>
</item>
<item>
<title>Ardupilot设备驱动  IIC、SPI、USART - 前端人生</title>
<link>http://www.cnblogs.com/BlogsOfLei/p/7745636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BlogsOfLei/p/7745636.html</guid>
<description>&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;设备代码层次结构&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ Ardupilot设备驱动代码的层次结构采用 前端实现 和 后端实现 分割，前端库主要供机器代码层调用，后端库主要供前端调用。这里前端可以理解为应用层，后端理解为驱动层，前端调用后端代码，实际是驱动层提供接口供应用层使用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/940230/201710/940230-20171027232335555-884887501.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;C:/Users/Awesome/Desktop/Ardupilot%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/360%E6%88%AA%E5%9B%BE20171027135930919.jpg&quot;&gt;&lt;img alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 前端调用后端代码之前，系统会通过自动检测设备或者通过用户配置的参数创建并且启动一个或者多个后端对象。用户自定义参数(_TYPE)，例如RNGFND_TYPE。每个后端对象都会保存在前端创建的指针数组中( _drivers[])。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;设备驱动代码被调用方式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;​ 图中左边的后端设备驱动代码运行于后台线程中，主要实现从外部设备读取原始数据，转化为标准单位，并且将处理后的数据存储在缓冲区中。具体的飞行控制器代码通过调用前端代码获取最新的设备数据，并在主线程中周期处理运行(400HZ for copter)。例如从传感器的前端代码中读取加速度计、陀螺仪数据等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/940230/201710/940230-20171027232348961-1275905416.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;其中，为了不阻碍主线程的运行，IIC和SPI通信在后台线程中运行。但主线程中可以调用USART接口函数，因为为底层的串行驱动程序本身在后台收集数据保存在一个缓冲区中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;飞行控制上层代码调用设备前段代码示例&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;sensors.cpp文件中包含有调用设备驱动前端代码，例如飞控控制以20HZ的频率调用read_rangefinder()函数而读取高度数据，而该函数内部则调用了rangefinder.update() 和rangefinder.set_estimated_terrain_height()前端代码来获取数据。摘取代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;span&gt;/*&lt;br/&gt;&lt;span&gt;  read the rangefinder and update height estimate&lt;br/&gt;&lt;span&gt; */&lt;br/&gt;&lt;span&gt;void Plane::read_rangefinder(void)&lt;br/&gt;&lt;span&gt;{&lt;br/&gt;&lt;span&gt; /* notify the rangefinder of our approximate altitude above ground to allow it     to power on*/&lt;br/&gt;&lt;span&gt; /* during low-altitude flight when configured to power down during higher-altitude flight*/&lt;br/&gt;&lt;span&gt; &lt;span class=&quot;cm-tab&quot;&gt;   float height;&lt;br/&gt;&lt;span&gt;#if AP_TERRAIN_AVAILABLE&lt;br/&gt;&lt;span&gt;    if (terrain.status() == AP_Terrain::TerrainStatusOK &amp;amp;&amp;amp; terrain.height_above_terrain(height, true)) {&lt;br/&gt;&lt;span&gt;        rangefinder.set_estimated_terrain_height(height);&lt;br/&gt;&lt;span&gt;    } else&lt;br/&gt;&lt;span&gt;#endif&lt;br/&gt;&lt;span&gt;    {&lt;br/&gt;&lt;span&gt;        /* use the best available alt estimate via baro above home*/&lt;br/&gt;&lt;span&gt;        if (flight_stage == AP_Vehicle::FixedWing::FLIGHT_LAND) {&lt;br/&gt;&lt;span&gt;            /* ensure the rangefinder is powered-on when land alt is higher than home altitude.&lt;br/&gt;&lt;span&gt;            This is done using the target alt which we know is below us and we are sinking to &lt;span class=&quot;cm-tab&quot;&gt;  &lt;span class=&quot;cm-tab&quot;&gt;    &lt;span class=&quot;cm-tab&quot;&gt;     it*/&lt;br/&gt;&lt;span&gt;            height = height_above_target();&lt;br/&gt;&lt;span&gt;        } else {&lt;br/&gt;&lt;span&gt;            /* otherwise just use the best available baro estimate above home.*/&lt;br/&gt;&lt;span&gt;            height = relative_altitude;&lt;br/&gt;&lt;span&gt;        }&lt;br/&gt;&lt;span&gt;        rangefinder.set_estimated_terrain_height(height); //设置地形估计高度&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    rangefinder.update();&lt;span class=&quot;cm-tab&quot;&gt;   //通过传感器更新高度数据&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    if ((rangefinder.num_sensors() &amp;gt; 0) &amp;amp;&amp;amp; should_log(MASK_LOG_SONAR)) {&lt;br/&gt;&lt;span&gt;        Log_Write_Sonar();&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    rangefinder_height_update();&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;以下代码为rangefinder.update()函数内部实现&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;span&gt;/* &lt;br/&gt;&lt;span&gt;   update the state of the sensor by usart&lt;br/&gt;&lt;span&gt;*/&lt;br/&gt;&lt;span&gt;void AP_RangeFinder_LightWareSerial::update(void)&lt;br/&gt;&lt;span&gt;{&lt;br/&gt;&lt;span&gt;//获取缓冲区中获取的原始数据，并且将处理后的数据保存至distance_cm中，数据为true，否则为false&lt;br/&gt;&lt;span&gt;    if (get_reading(state.distance_cm)) {  &lt;br/&gt;&lt;span&gt;        // update range_valid state based on distance measured&lt;br/&gt;&lt;span&gt;        last_reading_ms = AP_HAL::millis(); //获取当前系统运行时间        &lt;br/&gt;&lt;span&gt;        update_status();&lt;span class=&quot;cm-tab&quot;&gt;    /*判断distance_cm数据情况，高于最大测量范围或者小于最小测量范围或者数据正常*/&lt;br/&gt;&lt;span&gt;    } else if (AP_HAL::millis() - last_reading_ms &amp;gt; 200) { /* 超过200ms缓冲没有数据 */&lt;br/&gt;&lt;span&gt;        set_status(RangeFinder::RangeFinder_NoData);&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;串口设备后端实现示例&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;此处以获取LightWare数据为例，首先需通过serial_manager类和用户设置的参数获取串口设备对象实例。代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;br/&gt;&lt;span&gt;/* &lt;br/&gt;&lt;span&gt;   The constructor also initialises the rangefinder. Note that this&lt;br/&gt;&lt;span&gt;   constructor is not called until detect() returns true, so we&lt;br/&gt;&lt;span&gt;   already know that we should setup the rangefinder&lt;br/&gt;&lt;span&gt;*/&lt;br/&gt;&lt;span&gt;AP_RangeFinder_LightWareSerial::AP_RangeFinder_LightWareSerial(RangeFinder::RangeFinder_State &amp;amp;_state, AP_SerialManager &amp;amp;serial_manager) : AP_RangeFinder_Backend(_state)&lt;br/&gt;&lt;span&gt;{&lt;br/&gt;&lt;span&gt;    uart = serial_manager.find_serial(AP_SerialManager::SerialProtocol_Lidar, 0);&lt;br/&gt;&lt;span&gt;    if (uart != nullptr) {&lt;br/&gt;&lt;span&gt; uart-&amp;gt;begin(serial_manager.find_baudrate(AP_SerialManager::SerialProtocol_Lidar, 0));&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;前端代码在读取串口数据之前，需每次调用update()方法获取串口接受缓冲区中的数据，update方法中则调用的get_reading()方法将数据读取的内存中进行数据处理。其中关于update的代码可见之前的rangefinder.update()代码的实现，另外get_reading()代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;span&gt;// read - return last value measured by sensor&lt;br/&gt;&lt;span&gt;bool AP_RangeFinder_LightWareSerial::get_reading(uint16_t &amp;amp;reading_cm)&lt;br/&gt;&lt;span&gt;{&lt;br/&gt;&lt;span&gt;    if (uart == nullptr) {&lt;br/&gt;&lt;span&gt;        return false;&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    // read any available lines from the lidar&lt;br/&gt;&lt;span&gt;    float sum = 0;&lt;br/&gt;&lt;span&gt;    uint16_t count = 0;&lt;br/&gt;&lt;span&gt;    int16_t nbytes = uart-&amp;gt;available(); //检测串口接收缓冲区中的数据个数&lt;br/&gt;&lt;span&gt;    while (nbytes-- &amp;gt; 0) { //将缓冲区的数据读出，可能会读到多组数据&lt;br/&gt;&lt;span&gt;        char c = uart-&amp;gt;read();  //获取一个字符&lt;br/&gt;&lt;span&gt;        if (c == '\r') {  &lt;span class=&quot;cm-tab&quot;&gt;  &lt;span class=&quot;cm-tab&quot;&gt;    //一组数据以'\r'为结尾&lt;br/&gt;&lt;span&gt;            linebuf[linebuf_len] = 0;&lt;br/&gt;&lt;span&gt;            sum += (float)atof(linebuf); //将浮点字符串转换成字符串&lt;br/&gt;&lt;span&gt;            count++;&lt;br/&gt;&lt;span&gt;            linebuf_len = 0;&lt;br/&gt;&lt;span&gt;        } else if (isdigit(c) || c == '.') { //判断数据是否有效&lt;br/&gt;&lt;span&gt;            linebuf[linebuf_len++] = c;&lt;br/&gt;&lt;span&gt;            if (linebuf_len == sizeof(linebuf)) {&lt;br/&gt;&lt;span&gt;                // too long, discard the line&lt;br/&gt;&lt;span&gt;                linebuf_len = 0;&lt;br/&gt;&lt;span&gt;            }&lt;br/&gt;&lt;span&gt;        }&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    // we need to write a byte to prompt another reading&lt;br/&gt;&lt;span&gt;    uart-&amp;gt;write('d');&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    if (count == 0) {&lt;br/&gt;&lt;span&gt;        return false; //无数据返回false&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;    reading_cm = 100 * sum / count;  //单位换算成cm，并且求多组数据的平均值&lt;br/&gt;&lt;span&gt;    return true; //有数据返回true&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;因系统中每个串口都有自己接收缓冲区，所以主线程中可以直接调用get_reading()方法，而不影响其性能。而IIC和SPI通信则需要通过另外的机制来获取数据。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;IIC后端代码实例&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;前端代码通过指定IIC设备的地址而对IIC实例对象进行初始化，初始化代码位于RangeFinder.cpp文件中的RangeFinder::detect_instance(uint8_t instance)函数中：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;span&gt;case RangeFinder_TYPE_LWI2C:&lt;br/&gt;&lt;span&gt;        if (state[instance].address) {&lt;br/&gt;&lt;span&gt;#ifdef HAL_RANGEFINDER_LIGHTWARE_I2C_BUS&lt;br/&gt;&lt;span&gt;        _add_backend(AP_RangeFinder_LightWareI2C::detect(state[instance],&lt;br/&gt;&lt;span&gt;        hal.i2c_mgr-&amp;gt;get_device(HAL_RANGEFINDER_LIGHTWARE_I2C_BUS, state[instance].address)));&lt;br/&gt;&lt;span&gt;#else&lt;br/&gt;&lt;span&gt; if (!_add_backend(AP_RangeFinder_LightWareI2C::detect(state[instance],&lt;br/&gt;&lt;span&gt;      hal.i2c_mgr-&amp;gt;get_device(1, state[instance].address)))) {&lt;br/&gt;&lt;span&gt;       _add_backend(AP_RangeFinder_LightWareI2C::detect(state[instance],&lt;br/&gt;&lt;span&gt;       hal.i2c_mgr-&amp;gt;get_device(0, state[instance].address)));&lt;br/&gt;&lt;span&gt; }&lt;br/&gt;&lt;span&gt;#endif&lt;br/&gt;&lt;span&gt;  }&lt;br/&gt;&lt;span&gt;&lt;span class=&quot;cm-tab&quot;&gt;    break;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;其中代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;hal.i2c_mgr-&amp;gt;get_device(HAL_RANGEFINDER_LIGHTWARE_I2C_BUS, state[instance].address)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;通过指定IIC地址在总线上得到对应设备。指定设备之后，则可以通过调用相应的后端代码来初始化该设备与读取数据。代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;br/&gt;&lt;span&gt;void AP_RangeFinder_LightWareI2C::init()&lt;br/&gt;&lt;span&gt;{&lt;br/&gt;&lt;span&gt;    // call timer() at 20Hz 以20HZ的频率执行定时器回调函数&lt;br/&gt;&lt;span&gt;    _dev-&amp;gt;register_periodic_callback(50000,&lt;br/&gt;&lt;span&gt;                                     FUNCTOR_BIND_MEMBER(&amp;amp;AP_RangeFinder_LightWareI2C::timer, void));&lt;br/&gt;&lt;span&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;// read - return last value measured by sensor&lt;br/&gt;&lt;span&gt;bool AP_RangeFinder_LightWareI2C::get_reading(uint16_t &amp;amp;reading_cm)&lt;br/&gt;&lt;span&gt;{&lt;br/&gt;&lt;span&gt;    be16_t val;&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    if (state.address == 0) {&lt;br/&gt;&lt;span&gt;        return false;&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    // read the high and low byte distance registers&lt;br/&gt;&lt;span&gt;    bool ret = _dev-&amp;gt;read((uint8_t *) &amp;amp;val, sizeof(val));&lt;br/&gt;&lt;span&gt;    if (ret) {&lt;br/&gt;&lt;span&gt;        // combine results into distance&lt;br/&gt;&lt;span&gt;        reading_cm = be16toh(val);&lt;br/&gt;&lt;span&gt;    }&lt;br/&gt;&lt;span&gt;&lt;span&gt;​&lt;br/&gt;&lt;span&gt;    return ret;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;而定时回调函数中则调用了get_reading()方法获取IIC设备的数据。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;SPI后端代码实例&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;以MPU9250 IMU后端代码介绍SPI总线后端代码的编写。获取SPI设备对象的初始化代码类似于IIC，代码位于AP_InertialSensor.cpp文件AP_InertialSensor::detect_backends(void)函数中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block&quot;&gt;
&lt;span&gt;_add_backend(AP_InertialSensor_Invensense::probe(*this, hal.spi-&amp;gt;get_device(HAL_INS_MPU9250_NAME))); //获取SPI设备&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;此外，在后台线程中start()方法会自动调用对SPI总线上对应设备(此处为MPU9250)进行初始化和配置。程序中使用信号量区别SPI总线上的不同设备。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;img alt=&quot;&quot;/&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/940230/201710/940230-20171027232419101-1393965879.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;其中，_read_sample()方法被注册以1000HZ的频率被调用。__block_read()方法则主要从传感器寄存器中获取数据供上层代码处理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果添加新的设备驱动程序代码，则在代码中绝对不能有任何的等待或者线程休眠代码，因为这样会影响其他线程所使用的总线。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;如果想将新的驱动代码加入的工程中，则必须在make.inc和wscript文件中编写相应的工程代码，这两个文件位于对应的飞行器代码目录下(ArduPlane、ArduCopter...)。这样新编写的驱动才会参与工程代码的编译，最后一同生成可执行的二进制文件。后续可将该文件烧写至飞控处理器中运行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Oct 2017 15:25:00 +0000</pubDate>
<dc:creator>前端人生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BlogsOfLei/p/7745636.html</dc:identifier>
</item>
<item>
<title>[原创]Nginx监控-Nginx+Telegraf+Influxb+Grafana - Eric zhou</title>
<link>http://www.cnblogs.com/tianqing/p/7745436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianqing/p/7745436.html</guid>
<description>&lt;p&gt;搭建了Nginx集群后，需要继续深入研究的就是日常Nginx监控。&lt;/p&gt;
&lt;p&gt;Nginx如何监控？相信百度就可以找到：nginx-status&lt;/p&gt;
&lt;p&gt;通过Nginx-status，实时获取到Nginx监控数据后，如何和现有监控系统集成？一个很好的解决方案：&lt;/p&gt;
&lt;p&gt;Nginx+Telegraf+Influxdb+Grafana&lt;/p&gt;
&lt;p&gt;即通过Telegraf监控插件定时收集Nginx的监控状态，存储到时序数据库Influxdb中，然后通过Grafana展现即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、Nginx启用nginx-status功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;源码编译安装的nginx，那么需要在编译的时候加上对应的模块  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
./configure --with-http_stub_status_module 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 ./configure --help 能看到更多的模块支持。然后编译安装即可。&lt;/p&gt;
&lt;p&gt;如果是直接 apt-get install 安装的 nginx，那么使用命令来查看是否支持 stub_status 这个模块。&lt;/p&gt;
&lt;p&gt;如下命令： &lt;strong&gt;nginx –V&lt;/strong&gt; 看看是否有 --with-http_stub_status_module 这个模块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/23525/201710/23525-20171027221417789-1395642040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改Nginx配置文件：在Server章节中增加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
       location /nginx-&lt;span&gt;status {
       allow &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;允许的IP&lt;/span&gt;
&lt;span&gt;       deny all;
       stub_status on;
       access_log off;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Reload 重启Nginx，查看Nginx-Status&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/23525/201710/23525-20171027221507461-1897160224.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出信息的说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;active connections – 活跃的连接数量
server accepts handled requests — 总共处理了11989个连接 , 成功创建11989次握手, 总共处理了11991个请求
reading — 读取客户端的连接数.
writing — 响应数据到客户端的数量
waiting — 开启 keep&lt;/span&gt;-alive 的情况下,这个值等于 active – (reading+writing), 意思就是 Nginx 已经处理完正在等候下一次请求指令的驻留连接.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;二、Telegraf安装配置Nginx监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于Telegraf的安装，请参考官方介绍&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.influxdata.com/time-series-platform/telegraf/&quot; target=&quot;_blank&quot;&gt;https://www.influxdata.com/time-series-platform/telegraf/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/23525/201710/23525-20171027221838539-653635704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dl.influxdata.com/telegraf/releases/telegraf-1.4.3-1.x86_64.rpm&lt;/span&gt;
&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;yum&lt;/span&gt; localinstall telegraf-&lt;span&gt;1.4&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;.x86_64.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，在配置文件teldgraf.conf中配置Influxdb连接&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/23525/201710/23525-20171027222108758-643988878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;增加对Nginx的监控&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/23525/201710/23525-20171027222215195-1860282575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置完成，重启telegraf服务即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、Grafana集成Nginx监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Grafana中支持Influxdb数据源，配置上上个步骤的Influxdb数据源之后，我们定制Nginx监控图表：&lt;/p&gt;
&lt;p&gt;数据源：Influxdb&lt;/p&gt;
&lt;p&gt;FROM：nginx&lt;/p&gt;
&lt;p&gt;SELECT：field（accepts）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/23525/201710/23525-20171027223852867-1293350182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/23525/201710/23525-20171027222635820-853167670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;展现效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/23525/201710/23525-20171027222653117-934344544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上我们通过Nginx+Telegraf+Influxb+Grafana，实现了Nginx的监控,非常方便。&lt;/p&gt;

&lt;p&gt;周国庆&lt;/p&gt;
&lt;p&gt;2017/10/27&lt;/p&gt;

</description>
<pubDate>Fri, 27 Oct 2017 14:28:00 +0000</pubDate>
<dc:creator>Eric zhou</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tianqing/p/7745436.html</dc:identifier>
</item>
<item>
<title>初探性能优化——2个月到4小时的性能提升 - 闪客sun</title>
<link>http://www.cnblogs.com/flashsun/p/7744466.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flashsun/p/7744466.html</guid>
<description>&lt;p&gt;　　一直不知道性能优化都要做些什么，从哪方面思考，直到最近接手了一个公司的小项目，可谓麻雀虽小五脏俱全。让我这个编程小白学到了很多性能优化的知识，或者说一些思考方式。真的感受到任何一点效率的损失放大一定倍数时，将会是天文数字。最初我的程序计算下来需要跑&lt;strong&gt;2个月&lt;/strong&gt;才能跑完，经过2周不断地调整架构和细节，将性能提升到了&lt;strong&gt;4小时&lt;/strong&gt;完成。&lt;/p&gt;
&lt;p&gt;　　很多心得体会，希望和大家分享，也希望多多批评指正，共同进步。&lt;/p&gt;
&lt;h2&gt;项目描述&lt;/h2&gt;
&lt;p&gt;我将公司的项目内容抽象，大概是要做&lt;strong&gt;这样一件事情&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　1. 数据库A中有2000万条用户数据&lt;br/&gt;　　2. 将数据库A中的用户读出，为每条用户生成guid，并保存到数据库B中&lt;br/&gt;　　3. 同时在数据库A中生成关联表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1096103/201710/1096103-20171027173049711-831516049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目&lt;strong&gt;要求&lt;/strong&gt;为：&lt;/p&gt;
&lt;p&gt;　　1. 将用户存入数据库B的过程需要&lt;strong&gt;调用sdk&lt;/strong&gt;的注册接口，不允许直接操作jdbc进行插入&lt;br/&gt;　　2. 数据要求&lt;strong&gt;可恢复&lt;/strong&gt;：再次运行要跳过已成功的数据；出错的数据要进行持久化以便下次可以选择恢复该部分数据&lt;br/&gt;　　3. 数据要保证&lt;strong&gt;一致性&lt;/strong&gt;：在不出错的情况下，数据库B的用户必然一一对应数据库A的关联表。如果出错，那么正确的数据加上记录下来的出错数据后要保证一致性。&lt;br/&gt;　　4. &lt;strong&gt;速度&lt;/strong&gt;要尽可能块：共2000万条数据，在保证正确性的前提下，至多一天内完成&lt;/p&gt;

&lt;h2&gt;第一版，面向过程——2个月&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;特征：&lt;/strong&gt;面向过程、单一线程、不可拓展、极度耦合、逐条插入、数据不可恢复&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1096103/201710/1096103-20171027182311305-876812468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最初的一版简直是汇聚了一个项目的所有缺点。整个流程就是从A库读出一条数据，立刻做处理，然后调用接口插入B库，然后在拼一个关联表的sql语句，插入A库。没有计数器，没有错误信息处理。这样下来的代码最终&lt;strong&gt;预测2000万条数据要处理2个月&lt;/strong&gt;。如果中间哪怕一条数据出错，又要重新再来2个月。简直可怕。&lt;/p&gt;
&lt;p&gt;　　这个流程图就等同于废话，是完全基于&lt;strong&gt;面向过程&lt;/strong&gt;的思想，整个代码就是在一个大main方法里写的，实际业务流程完全等同于代码的流程。思考起来简单，但实现和维护起来极为困难，代码结构冗长混乱。而且几乎是不可扩展的。暂且不谈代码的设计美观，它的&lt;strong&gt;效率如此低&lt;/strong&gt;下主要有一下几点：&lt;/p&gt;
&lt;p&gt;　　1. 每一条数据的速度受制于整个链条中&lt;strong&gt;最慢的一环&lt;/strong&gt;。试想假如有一条A库插入关联表的数据卡住了，等待将近1分钟（夸张了点），那这一分钟jvm完全就在傻等，它完全可以继续进行之前的两步。正如你等待鸡蛋煮熟的过程中可以同时去做其他的事一样。&lt;br/&gt;　　2. 向B库插入用户需要调用sdk（HTTP请求）接口，那每一次调用都需要&lt;strong&gt;建立连接，等待响应，再释放链接&lt;/strong&gt;。正如你要给朋友送一箱苹果，你分成100次每次只送一个，时间全搭载路上了。&lt;/p&gt;

&lt;h2&gt;第二版，面向对象——21天&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;特征：&lt;/strong&gt;面向对象、单一线程、可拓展、略微耦合、批量插入、数据可恢复&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1096103/201710/1096103-20171027185842820-424776781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;架构设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　根据第一版设计的问题，第二版有了一些改进。当然最明显的就是从面向过程的思想转变为面向对象。&lt;/p&gt;
&lt;p&gt;　　我将整个过程抽离出来，分配给不同的对象去处理。这样，我所分配的对象时这样的：&lt;br/&gt;　　&lt;strong&gt;1. 一个配置对象&lt;/strong&gt;：&lt;strong&gt;BatchStrategy&lt;/strong&gt;。负责从配置文件中读取本次任务的策略并传递给执行者，配置包括基础配置如总条数，每次批量查询的数量，每次批量插入的数量。还有一些数据源方面的，如来源表的表名、列名、等，这样如果换成其他数据库的类似导入，就能供通过配置进行拓展了。&lt;br/&gt;　　&lt;strong&gt;2. 三个执行者：&lt;/strong&gt;整个执行过程可以分成三个部分：读数据--处理数据--写数据，可以分别交给三个对象&lt;strong&gt;Reader，Processor，Writer&lt;/strong&gt;进行。这样如果某一处逻辑变了，可以单独进行改变而不影响其他环节。&lt;br/&gt;　　&lt;strong&gt;3. 一个失败数据处理类：ErrorHandler&lt;/strong&gt;。这样每当有数据出现异常时，便把改数据扔给这个类，在这给类中进行写入日志，或者其他的处理办法。在一定程度上将失败数据的处理解耦。&lt;/p&gt;
&lt;p&gt;　　这种设计很大程度上解除了耦合，尤其是失败数据的处理基本上完全解耦。但由于整个执行过程仍然是需要有一个main来分别调用三个对象处理任务，因此三者之间还是没有完全解耦，main部分的逻辑依然是面向过程的思想，比较复杂。即使把main中执行的逻辑抽出一个service，这个问题依然没有解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效率问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　由于将第一版的逐条插入改为&lt;strong&gt;批量插入&lt;/strong&gt;。其中sdk接口部分是批量传入一组数据，&lt;strong&gt;减少了http请求&lt;/strong&gt;的次数。生成关联表的部分是用了&lt;strong&gt;jdbc batch&lt;/strong&gt;操作，将之前逐条插入的excute改为excuteBatch，效率提升很明显。这两部分批量带来的效率提升，将原本需要两个月时间的代码，提升到了21天，但依然是天文数字。&lt;/p&gt;
&lt;p&gt;　　可以看出，本次效率提升仅仅是在减少http请求次数，优化sql的插入逻辑方面做出来努力，但依然没有解决第一版的一个致命问题，就是一次循环的速度依然&lt;strong&gt;受制于整个链条中最慢的一环，&lt;/strong&gt;三者没有解耦也可以从这一点看出，&lt;strong&gt;在其他两者没有将工作做完时，就只能傻等&lt;/strong&gt;，这是效率损失最严重的地方了。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;第三版，完全解耦（队列+多线程）——3天&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;特征：&lt;/strong&gt;面向对象、多线程、可拓展、完全解耦、批量插入、数据可恢复&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1096103/201710/1096103-20171027193816117-862940678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;架构设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;该版并没有代码实现，但确是过度到下一版的重要思考过程，故记录在次。这一版本较上一版的重大改进之处有两点：&lt;strong&gt;队列和多线程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;队列：&lt;/strong&gt;其中队列的使用使上一版未完全解耦的执行类之间，实现了&lt;strong&gt;完全解耦&lt;/strong&gt;，将同步过程变为异步，同时也是多线程能够使用的前提。Reader做的事就是读取数据，并放入队列，至于它的下一个环节Processor如何处理队列的数据，它完全不用理会，这时便可以继续读取数据。这便做到了完全解耦，处理队列的数据也能够使用多线程了。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;多线程&lt;/strong&gt;：Processor和Writer所做的事情，就是读取自身队列中的数据，然后处理。只不过Processor比Writer还承担了一个往下一环队列里放数据的过程。此处的队列用的是多线程安全队列&lt;strong&gt;ConcurrentLinkedQueue。&lt;/strong&gt;因此可以肆无忌惮地使用多线程来执行这两者的任务。由于各个环节之间的完全解耦，某一环上的偶尔卡主并不再影响整个过程的进度，所以效率提升不知一两点。&lt;/p&gt;
&lt;p&gt;　　还有一点就是数据的可恢复性在这个设计中有了保障，成功过的&lt;strong&gt;用户&lt;/strong&gt;被保存起来以便再次运行不会冲突，失败的&lt;strong&gt;关联表&lt;/strong&gt;数据也被记录下来，在下次运行时Writer会先将这一部分加入到自己的队列里，整个数据的正确性就有了一个不是特别完善的方案，效率也有了可观的提升。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效率问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　虽然效率从21天提升到了3天，但我们还要思考一些问题。实际在执行的过程中发现，&lt;strong&gt;Writer所完成的数据总是紧跟在Processor之后&lt;/strong&gt;。这就说明Processor的处理速度要慢于Writer，因为Processor插入数据库之前还要走一段注册用户的业务逻辑。这就有个问题，当上一环的速度慢过下一环时，还有必要进行批量的操作么？答案是不需要的。试想一下，如果你在生产线上，你的上一环2秒钟处理一个零件，而你的速度是1秒钟一个。这时即使你的批量处理速度更快，从系统最优的角度考虑，你也应该来一个零件就马上处理，而不是等积攒到100个再批量处理。&lt;/p&gt;
&lt;p&gt;　　还有一个问题是，我们从未考虑过&lt;strong&gt;Reader&lt;/strong&gt;的性能。实际上我用的是&lt;strong&gt;limit&lt;/strong&gt;操作来批量读取数据库，而mysql的limit是先全表查再截取，当起始位置很大时，就会越来越慢。0-1000万还算轻松，但1000万到2000万简直是“寸步难行”。所以最终效率的瓶颈反而落到了&lt;strong&gt;读库操作&lt;/strong&gt;上。&lt;/p&gt;

&lt;h2&gt;第四版，高度抽象（一键启动）——4小时&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;特征：&lt;/strong&gt;面向接口、多线程、可拓展、完全解耦、批量或逐条插入、数据可恢复、优化查询的limit操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;架构的思考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　优雅的代码应该是整洁而美妙，不应是冗长而复杂的。这一版将会设计出简洁度如第一版，而性能和拓展性超越所有版本的架构。&lt;/p&gt;
&lt;p&gt;　　通过总结前三版特征，我发现不论是Reader，Processor，Writer，都有共同的特征：&lt;strong&gt;启动任务、处理任务、结束任务。&lt;/strong&gt;而Reader和Processor又有一个共同的可以&lt;strong&gt;向下一道工序传递数据&lt;/strong&gt;，&lt;strong&gt;通知下一道工序数据传递结束&lt;/strong&gt;的功能。他们就像生产线上的一个个工序，相互关联而又各自独立地运行着。每一道工序都可以启动，疯狂地处理任务，直到上一道工序通知结束为止。而第一个发起通知结束的便是Reader，之后便一个通知下一个，直到整个工序停止，这个过程就是美妙的。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1096103/201710/1096103-20171027202227101-1629244417.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　因此我们可以将这三者都看做是&lt;strong&gt;Job&lt;/strong&gt;，除了&lt;strong&gt;Reader&lt;/strong&gt;外又都有与上一道工序交互的能力（其实&lt;strong&gt;Reader&lt;/strong&gt;的上一道工序就是数据库），因此便有了如下的接口设计。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1096103/201710/1096103-20171027202904508-437968721.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt; * 工作步骤接口.
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Job {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stop();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; finish();
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * 可交互的（传入，通知结束）.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Interactive&amp;lt;T&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * 开放与外界交互的通道
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; openInteract();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * 接收外界传来的数据
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; t
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; receive(T t);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * 关闭交互的通道
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; closeInteract();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;     * 是否处于可交互的状态
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true可交互的 false不可交互的活已关闭交互状态
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isInteractive();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　有了这样的接口设计，不论实现类具体怎么写，主方法已经可以写出了，变得异常整洁有序。&lt;/p&gt;
&lt;p&gt;　　只提炼主干部分，去掉了一些细枝末节，如日志输出、时间记录等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;         Job reader =&lt;span&gt; Reader.getInstance();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Job processor =&lt;span&gt; Processor.getInstance();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Job writer =&lt;span&gt; Writer.getInstance();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        reader.init();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        processor.init();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        writer.init();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        start(reader, processor, processor, processor, writer, writer);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start(Job... jobs){
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Job job:jobs) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                job.start();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        thread.start();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }    
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来就是具体实现类的问题了，这里实现类主要实现的是三个功能：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1. 接收上一环的数据&lt;/strong&gt;：属于&lt;strong&gt;Interactive&lt;/strong&gt;接口的&lt;strong&gt;receive&lt;/strong&gt;方法的实现，基于之前的设计，即是对象中有一个&lt;strong&gt;ConcurrentLinkedQueue&lt;/strong&gt;类型的属性，用来接收上一环传来的数据。&lt;br/&gt;&lt;strong&gt;　　2. 处理数据并传递给下一环&lt;/strong&gt;：在每一个（有下一环的）对象属性中，放入下一环的对象。如&lt;strong&gt;Reader&lt;/strong&gt;中要有&lt;strong&gt;Processor&lt;/strong&gt;对象，&lt;strong&gt;Processor&lt;/strong&gt;要有&lt;strong&gt;Writer&lt;/strong&gt;，一旦有数据需要加入下一环的队列，调用其&lt;strong&gt;receiive&lt;/strong&gt;方法即可。&lt;br/&gt;&lt;strong&gt;　　3. 告诉下一环我结束了&lt;/strong&gt;：本任务结束时，调用下一环对象的&lt;strong&gt;closeInteractive&lt;/strong&gt;方法。而每个对象判断自身结束的方法视情况而定，比如&lt;strong&gt;Reader&lt;/strong&gt;结束的条件是批量读取的数据超过了一开始设置的&lt;strong&gt;total&lt;/strong&gt;，说明数据读取完毕，可以结束。而&lt;strong&gt;Processor&lt;/strong&gt;结束的条件是，它被上一环通知了结束，并且从自己的队列中&lt;strong&gt;poll&lt;/strong&gt;不出东西了，证明应该结束，结束后再通知下一环节。这样整个工序就安全有序地退出了。不过由于是多线程，所以Processor不能贸然通知Writer结束信号，需要在Processor内部弄一个计数器，只有计数器达到预期的数量的那个线程的Processor，才能发起结束通知。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效率问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　正如上一版提出的，&lt;strong&gt;Processor&lt;/strong&gt;的处理速度要慢于&lt;strong&gt;Writer&lt;/strong&gt;，所以&lt;strong&gt;Writer&lt;/strong&gt;并不需要用&lt;strong&gt;batch&lt;/strong&gt;去处理数据的插入，该成逐条插入反而是提高性能的一种方式。&lt;/p&gt;
&lt;p&gt;　　大数据量limit操作十分耗时，由于测试部分只是在&lt;strong&gt;前&lt;/strong&gt;几百万条测试，所以还是大大低估了效率的损失。在&lt;strong&gt;后&lt;/strong&gt;几百万条可以说每一次limit的读取都寸步难行。考虑到这个问题，我选去了唯一一个有索引并且稍稍易于排序的字段“&lt;strong&gt;用户的手机号&lt;/strong&gt;”，（不想吐槽它们设计表的时候居然没有自增id。。。），每次全表将手机号&lt;strong&gt;排序&lt;/strong&gt;，再limit查询。查询之后将最后一条的手机号保存起来，成为当前读取的&lt;strong&gt;最后一条数据的一个标识&lt;/strong&gt;。下次再limit操作就可以从这个手机号之后开始查询了。这样每次查询不论从哪里开始，速度都是一样的。虽然前面部分的数据速度与之前的方案相比慢了不少，但却完美解决了大数据量limit操作的超长等待时间，预防了危险的发生。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;至此，项目架构再次简洁起来，但同第一版相比，已经不是同一级别的简洁了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1096103/201710/1096103-20171027214946398-34326498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;关于继续优化的思考&lt;/h2&gt;
&lt;p&gt;1. Reader部分是单线程在处理，由于读取是从数据库中，并不是队列中，因此设计成多线程有些麻烦，但并不是不可，这里是优化点&lt;/p&gt;
&lt;p&gt;2. 日志部分占有很大一部分比例，2000万条读、处理、写就要有至少6000万次日志输出。如果设计成异步处理，效率会提升不少。&lt;/p&gt;
&lt;p&gt;这就是我本次项目优化的心得体会，还望各位大神予以指点。因为代码是公司为了避嫌，就不发到github了，感兴趣的大神可以私聊。&lt;/p&gt;
</description>
<pubDate>Fri, 27 Oct 2017 13:51:00 +0000</pubDate>
<dc:creator>闪客sun</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flashsun/p/7744466.html</dc:identifier>
</item>
<item>
<title>温故而知新 Volley源码解读与思考 - sphere</title>
<link>http://www.cnblogs.com/sphere/p/7745304.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sphere/p/7745304.html</guid>
<description>&lt;p&gt;　　相比新的网络请求框架Volley真的很落后，一无是处吗，要知道Volley是由google官方推出的，虽然推出的时间很久了，但是其中依然有值得学习的地方。  从命名我们就能看出一些端倪，volley中文意为群射，齐射，即它适合通信频繁但是数据量不大的网络请求操作，至于为什么我们解读完源码就知道了。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　回想下使用Volley的过程：比如请求一个网页的内容。&lt;/p&gt;
&lt;p&gt;　　1. 创建RequestQueue对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 RequestQueue mQueue = Volley.newRequestQueue(MyApplication.getInstance());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2. 先创建一个StringRequest对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('2595f2e1-d100-427a-9c2c-9e5f11c0e3cb')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_2595f2e1-d100-427a-9c2c-9e5f11c0e3cb&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2595f2e1-d100-427a-9c2c-9e5f11c0e3cb&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('2595f2e1-d100-427a-9c2c-9e5f11c0e3cb',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2595f2e1-d100-427a-9c2c-9e5f11c0e3cb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; StringRequest stringRequest = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringRequest(
            Request.Method.GET,
            &lt;/span&gt;&quot;https://www.baidu.com&quot;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Response.Listener&amp;lt;String&amp;gt;&lt;span&gt;() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onResponse(String response) {
                    Log.d(TAG, &lt;/span&gt;&quot;current thread :&quot; + Thread.currentThread().getName());  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; main thread&lt;/span&gt;
&lt;span&gt;                    ((TextView)findViewById(R.id.content)).setText(response);
                }
            },
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Response.ErrorListener() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onErrorResponse(VolleyError error) {
                    Log.d(TAG, &lt;/span&gt;&quot;error :&quot; +&lt;span&gt; error.getMessage());
                }
            }
    ) ;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　3.  将请求对象添加到mQueue中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mQueue.add(stringRequest);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　如下流程描述请自行结合Volley中的源码阅读：&lt;/p&gt;
&lt;p&gt;　　首先我们要构造RequestQueue， 其内部封装了缓存请求队列：&lt;/p&gt;
&lt;p&gt;　　首先我们要构造&lt;span lang=&quot;EN-US&quot;&gt;RequestQueue， 其内部封装了缓存请求队列&lt;span lang=&quot;EN-US&quot;&gt;PriorityBlockingQueue&amp;lt;Request&amp;lt;?&amp;gt;&amp;gt; mCacheQueue 和网络请求队列 &lt;span lang=&quot;EN-US&quot;&gt;PriorityBlockingQueue&amp;lt;Request&amp;lt;?&amp;gt;&amp;gt; mNetworkQueue，同时也封装了一条缓存调度线程&lt;span lang=&quot;EN-US&quot;&gt;mCacheDispatcher和若干条网络请求调度线程 &lt;span lang=&quot;EN-US&quot;&gt;NetworkDispatcher[] mDispatchers，虽然&lt;span lang=&quot;EN-US&quot;&gt;RequestQueue的构造方法是&lt;span lang=&quot;EN-US&quot;&gt;public，但是我们还是调用&lt;span lang=&quot;EN-US&quot;&gt;Volley的&lt;span lang=&quot;EN-US&quot;&gt;newRequestQueue方法，因为在&lt;span lang=&quot;EN-US&quot;&gt;newRequestQueue方法有些重要的处理，比如设置&lt;span lang=&quot;EN-US&quot;&gt;DiskBasedCache的目录， 添加请求的&lt;span lang=&quot;EN-US&quot;&gt;User-agent，判断&lt;span lang=&quot;EN-US&quot;&gt;SDK的版本号，如果是&lt;span lang=&quot;EN-US&quot;&gt;2.3(API=9)以下则使用&lt;span lang=&quot;EN-US&quot;&gt;HttpClient， 如果是&lt;span lang=&quot;EN-US&quot;&gt;&amp;gt;=2.3的版本&lt;span lang=&quot;EN-US&quot;&gt;,则使用&lt;span lang=&quot;EN-US&quot;&gt;HttpUrlConnection，接着构建&lt;span lang=&quot;EN-US&quot;&gt;RequestQueue对象，并调用其&lt;span lang=&quot;EN-US&quot;&gt;start方法，创建并启动缓存调度线程和网络请求调度线程，目前的版本是&lt;span lang=&quot;EN-US&quot;&gt;1条缓存线程和&lt;span lang=&quot;EN-US&quot;&gt;4条网络请求线程。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　接着查看RequestQueue.add的相关逻辑：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 将构造的Request添加到RequestQueue中，即调用RequestQueue.add方法，这里会将请求先Add到一个Set集合中，即Set&amp;lt;Request&amp;lt;?&amp;gt;&amp;gt; mCurrentRequests中，然后判断是否禁用了缓存，如果禁用缓存则直接添加到mNetworkQueue中， 又因为NetworkDispatcher调度线程run方法中是while死循环，会一直取队列中的对象，故加入网络请求队列后，就相当于直接发起了网络请求。 而如果允许缓存，即Request.shouldCache返回true，则判断Map(Map&amp;lt;String,Queue&amp;lt;Request&amp;lt;?&amp;gt;&amp;gt; mWaitingRequests中是否有相同的请求，判断的标准就是请求的url，即request.getCacheKey()),如果mWaitingRequests中存在，则做提示处理，如果不存在则将请求添加到map中做记录，并执行mCacheQueue.add(request)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; 　　请求加入了CacheQueue队列中，则缓存调度线程就可以从队列中取出requeset做处理。查看缓存调度线程CacheDispatcher的run方法，while循环中的逻辑如下，先取出缓存queue中的请求对象request，根据请求的url得到cache， 判断cache中entry是否为空，如果为空则说明没有缓存，则将请求添加到mNetworkQueue中，mNetworkQueue.put(request), 交由网络请求线程处理。如果有缓存，判断缓存是否过期，如果过期则同上，如果缓存可用，则取出缓存中数据做解析并返回，即调用request.parseNetworkResponse方法，解析之后调用mDelivery.postResponse方法做结果的投递，这里就将操作从子线程转移到主线程了，具体是由mDelivery去处理切换的操作， mDelivery(具体实现类是ExecutorDelivery)内部封装了Handler和Executor，将最终解析出的结果投递到主线程handler.post(runnable)， 此handler是主线程的handler，构造RequestQueue队列时创建了主线程的Handler对象了，代码如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;public RequestQueue(Cache cache, Network network, int threadPoolSize) {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        this(cache, network, threadPoolSize,&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;                new ExecutorDelivery(new Handler(Looper.getMainLooper())));&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;}&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    5. 当请求添加到网络请求队列queue之后，在NetworkDispatcher的run方法中执行真正的网络请求，首先会判断线程是否退出了，或者request是否被取消了等逻辑，一切ok则执行mNetwork.performRequest(request),发起网络请求，然后解析结果，做缓存操作，派发解析结果到主线程等等&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;// 这里注意BlockingQueue的add offer put//// remove poll take peek等方法的区别&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　1.add 将元素插入queue中，如果立即可行且不违反容量规则返回true，如果当前没有可用空间，则抛出IllegalStateExecption&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;        2.offer 与add方法类似，但是使用有限制容量的queue时，此方法通常优于add方法，后者可能可能无法插入元素，只是抛出一个异常&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;　　3. put 插入元素到queue尾部，如果空间不够，则等待空间变得可用&lt;/p&gt;
&lt;p&gt;　　-----------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt; 　  4. remove 移除元素，返回true如果queue总包含此元素&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       5.poll  获取并移除头部元素， E poll(), 如果queue为空，则返回null&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　6.take  获取并移除头部元素，如果没有则等待直到有头部元素变得可用, E take() throws InterruptedException。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　7.peek 只是获取头部元素，并不做移除操作，如果queue为空，则返回null。&lt;/p&gt;
&lt;p class=&quot;MsoNormal&quot; align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p&gt;缓存执行流程&lt;/p&gt;
&lt;p&gt;    上面简要分析了请求执行的过程，那么Volley是如何实现缓存和获取缓存的呢，我们接着分析，试想我们第一次请求某个网络资源时，必然是没有缓存的,那么最终会走到网络调用线程NetworkDispatcher  run方法中的逻辑，执行网络请求拿到NetworkResponse，然后解析networkResponse，即调用request的parseNetworkResponse得到Response对象，然后判断request是否允许缓存，如果需要缓存且response中的Cache.Entry即缓存对象不为空，则做缓存的操作。Cache.Entry对象cacheEntry什么时候被赋值的呢？就是在parseNetworkResponse返回Response对象的过程中，构造Response对象调用Response.success(result, HttpHeaderParser.parseCacheHeaders(response));, success函数的第二参数即为cacheEntry，查看parseCacheHeaders方法可以看到，entry中包含有data, etag,softTtl,lastModified,responseHeaders等数据。我们要缓存就是上边的cacheEntry，对应代码中的mCache.put(request.getCacheKey(), response.cacheEntry); 这里的mCache又是什么呢。查找mCache的源头又回到了Volley.newRequestQueue方法中，这里构建RequestQueue时传入了DiskBasedCache,那么看来mCache的具体实现类就是DiskBasedCache了。查看DiskBasedCache的源码，可以看到其默认缓存路径是/data/data/packagename/cache/volley/  ， 默认的缓存大小为10M,其中最关键的就是put方法，put(String key, Entry entry) ,此方法首先会根据entry中data数组的长度判断是否能够缓存得下，也就是缓存后是否超过了设定的最大缓存容量值。具体在pruneINeed中做判断，如果超过最大值，则会按顺序依次从已缓存的文件中做删除操作(PS：如何做到按顺序删除呢，因为在putEntry方法中将key和cacheHeader的信息存储在了LinkedHashMap中了， 所以删除的时候才能依次按照缓存的先后顺序删除，最先缓存的先被删除掉)，直到缓存本次data不再超过最大值为止，然后创建一个File对象存储缓存数据，File的name是将Url字符串的前半部分的hashcode加上字符串后半部分的hashcode组合而成，具体请查看getFilenameForKey(String key)方法，然后构建FileOutputStream对象分别将CacheHeader信息和data数据部分信息写入文件，如果写入的过程中发生了异常，则会做删除文件的处理。至于读取的操作请查看get方法.&lt;/p&gt;

&lt;p&gt;其实说了这么多，还是下面这张流程图的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/651797/201710/651797-20171027202402836-762965466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;现在来做下问题总结:&lt;/p&gt;
&lt;p&gt;1. 为什么说Volley不适合大文件的下载等操作，而是数据量小的通信网络场景？&lt;/p&gt;
&lt;p&gt;　　因为从Volley的源码中我们可以发现，其内部执行网络请求的线程是固定数量4条线程，如果下载大文件可能就会导致线程被长时间占用，后面排队的Request可能长时间得不到执行，且在Volley内部有缓存机制，如果大文件也允许缓存，而设定的最大缓存容量值较小，则可能发生长时间的IO操作（因为可能超过最大容量而要做删除文件操作），导致应用性能下降。&lt;/p&gt;
&lt;p&gt;2. Volley中的缓存调度线程和网络调用线程的run方法中是while死循环，什么时候退出，也就是缓存和网络调度线程什么时候结束工作？&lt;/p&gt;
&lt;p&gt;　　其实在run方法的内部有相关逻辑， 比如NetworkDispatcher的run方法中，会捕获InterruptedException异常，在异常处理中判断mQuit的值，如果为true则直接返回。而调用Interrupt方法和设置mQuit值的处理就在NetworkDispatcher对应的quit() 方法中。&lt;/p&gt;
&lt;p&gt;3.  可否将处理网络请求的线程改成线程池ThreadPoolExecutor？&lt;/p&gt;
&lt;p&gt;　　可以改，但是即使改为线程池实现，性能可能也不会有提升，一方面对于手机cpu来说其核心数是有限的，如果线程池内的线程数配置的较大，则网络请求时可能导致线程的频繁的发生切换，而线程的切换是有开销的。&lt;/p&gt;
&lt;p&gt;4. Volley可否加载较大的图片，比如十几M，几十M等？&lt;/p&gt;
&lt;p&gt;　　因为Volley中解析完数据是要保存在byte[] data，中的，所以如果数据过大则有可能发生ＯＯＭ异常。&lt;/p&gt;
&lt;p&gt;5. 使用Volley时应该在哪里创建RequestQueue合适?&lt;/p&gt;
&lt;p&gt;　　具体可以在自定义的Application中，主要是传递给newRequestQueue的Context应该使用ApplicationContext，这样可以避免可能发生的内存泄漏的情况，试想如果持有Activity的context那么Volley内部的工作没有做完则一直持有Activity，导致Activity无法释放，故在自定义的Apllication初始化一个全局的请求队列即可。&lt;/p&gt;
&lt;p&gt;6. onResponse是在主线程中执行，但是返回结果后还需要做耗时操作怎么办？&lt;/p&gt;
&lt;p&gt;　　从Volley的源码中我们能够知道派发器mDelivery的是ExecutorDelivery，其默认实现是传递主线程的handler的构造方法，而ExecutorDelivery的内部还有一个传递executor的构造方法，只要构建一个的executor，在new RequestQueue时，让 mDelivery = new ExecutorDelivery(executor), 那么onResponse最终就在executor的线程中执行， 不再是主线程了。&lt;/p&gt;
&lt;p&gt;7. Volley有什么优缺点。&lt;/p&gt;
&lt;p&gt;　　优点：　　&lt;/p&gt;
&lt;p&gt;　　还是那句： 适合网络通信频繁，但是通信数据量不大的请求，不适合大文件的下载。&lt;/p&gt;
&lt;p&gt;　　可以缓存http请求，过滤重复请求（一般网络请求框架也都支持）&lt;/p&gt;
&lt;p&gt;      支持请求的优先级&lt;/p&gt;
&lt;p&gt;　  支持取消请求的API，可以取消单个请求，也可以设置取消请求的范围域&lt;/p&gt;
&lt;p&gt;      基于接口的设计，使扩展相对容易（比如写一个XMLRequest类 继承Request，实现onResponse方法和parseNetworkResponse方法）&lt;/p&gt;
&lt;p&gt;　　缺点：&lt;/p&gt;
&lt;p&gt;　　对于文件的上传和下载支持的不好&lt;/p&gt;
&lt;p&gt;　　与Apache的Httpclient 和 HttpUrlConnection耦合较紧密&lt;/p&gt;
&lt;p&gt;　　Android 6.0系统移除对HttpClient的支持，所以要使用Volley，需要配置org.apache.http.legacy.jar的引用&lt;/p&gt;
&lt;p&gt;　　对http的支持不够完善。&lt;/p&gt;

&lt;p&gt;待补充。。。&lt;/p&gt;







</description>
<pubDate>Fri, 27 Oct 2017 13:38:00 +0000</pubDate>
<dc:creator>sphere</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sphere/p/7745304.html</dc:identifier>
</item>
<item>
<title>Yii2之组件的注册与创建 - 编程人，在天涯</title>
<link>http://www.cnblogs.com/wujuntian/p/7745136.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wujuntian/p/7745136.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;　　今天本来打算研究一下&lt;/span&gt;yii2.0&lt;span&gt;的&lt;/span&gt;&lt;span&gt;AR&lt;/span&gt;&lt;span&gt;模型的实现原理，然而，计划赶不上变化，突然就想先研究一下&lt;/span&gt;&lt;span&gt;yii2.0&lt;/span&gt;&lt;span&gt;的数据库组件创建的过程。通过对&lt;/span&gt;&lt;span&gt;yii&lt;/span&gt;&lt;span&gt;源码的学习，了解了&lt;/span&gt;&lt;span&gt;yii&lt;/span&gt;&lt;span&gt;组件注册与创建的过程，并发现原来&lt;/span&gt;&lt;span&gt;yii&lt;/span&gt;&lt;span&gt;组件注册之后并不是马上就去创建的，而是待到实际需要使用某个组件的时候再去创建对应的组件实例的。本文大概记录一下这个探索的过程。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　要了解&lt;/span&gt;yii&lt;span&gt;组件的注册与创建，当然要从&lt;/span&gt;&lt;span&gt;yii&lt;/span&gt;&lt;span&gt;入口文件&lt;/span&gt;&lt;span&gt;index.php&lt;/span&gt;&lt;span&gt;说起了，整个文件代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&lt;span&gt;&amp;lt;?php
defined('YII_DEBUG') or define('YII_DEBUG', true);
defined('YII_ENV') or define('YII_ENV', 'dev');

require(__DIR__ . '/../../vendor/autoload.php');
require(__DIR__ . '/../../vendor/yiisoft/yii2/Yii.php');
require(__DIR__ . '/../../common/config/bootstrap.php');
require(__DIR__ . '/../config/bootstrap.php');

$config = yii\helpers\ArrayHelper::merge(
    require(__DIR__ . '/../../common/config/main.php'),
    require(__DIR__ . '/../../common/config/main-local.php'),
    require(__DIR__ . '/../config/main.php'),
    require(__DIR__ . '/../config/main-local.php')
);

(new yii\web\Application($config))-&amp;gt;run();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;可以看到入口文件引入了几个配置文件，并将所有配置文件的内容都合并到&lt;/span&gt;$config&lt;span&gt;这个配置数组中，然后使用这个配置数组作为参数去创建一个应用实例。若将这个配置数组打印出来，就会看到，“&lt;/span&gt;&lt;span&gt;components&lt;/span&gt;&lt;span&gt;”下标对应的元素包含了&lt;/span&gt;&lt;span&gt;yii&lt;/span&gt;&lt;span&gt;组件的参数信息（这里只截图一小部分）：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/747151/201710/747151-20171027202436351-644998183.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这些组件的信息是在引入进来的几个配置文件中配置的，&lt;/span&gt;Yii&lt;span&gt;组件就是使用这些参数信息进行注册与创建的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　接下来就进入&lt;/span&gt;yii\web\Application&lt;span&gt;类的实例化过程了，&lt;/span&gt;&lt;span&gt;yii\web\Application&lt;/span&gt;&lt;span&gt;类没有构造函数，但是它继承了&lt;/span&gt;&lt;span&gt;\yii\base\Application&lt;/span&gt;&lt;span&gt;类：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/747151/201710/747151-20171027202541226-1354486903.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以会自动执行&lt;/span&gt;\yii\base\Application&lt;span&gt;类的构造函数：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&lt;span&gt;public function __construct($config = [])
{
    Yii::$app = $this;
    static::setInstance($this);

    $this-&amp;gt;state = self::STATE_BEGIN;

    $this-&amp;gt;preInit($config);

    $this-&amp;gt;registerErrorHandler($config);

    Component::__construct($config);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这里要顺便说一下预初始化方法&lt;/span&gt;preInit()&lt;span&gt;，它的代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&lt;span&gt;public function preInit(&amp;amp;$config)
{
    /* 此处省略对$config数组的预处理操作代码 */

    // merge core components with custom components
    foreach ($this-&amp;gt;coreComponents() as $id =&amp;gt; $component) {
        if (!isset($config['components'][$id])) {
            $config['components'][$id] = $component;
        } elseif (is_array($config['components'][$id]) &amp;amp;&amp;amp; !isset($config['components'][$id]['class'])) {
            $config['components'][$id]['class'] = $component['class'];
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　这个函数对传递给构造函数的配置数组&lt;/span&gt;$config&lt;span&gt;进行了一些预处理操作（这里省略了），最后使用&lt;/span&gt;&lt;span&gt;coreComponents()&lt;/span&gt;&lt;span&gt;方法返回的数组对&lt;/span&gt;&lt;span&gt;$config&lt;/span&gt;&lt;span&gt;数组进行了完善，&lt;/span&gt;&lt;span&gt;coreComponents()&lt;/span&gt;&lt;span&gt;方法是这样的：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&lt;span&gt;public function coreComponents()
{
    return [
        'log' =&amp;gt; ['class' =&amp;gt; 'yii\log\Dispatcher'],
        'view' =&amp;gt; ['class' =&amp;gt; 'yii\web\View'],
        'formatter' =&amp;gt; ['class' =&amp;gt; 'yii\i18n\Formatter'],
        'i18n' =&amp;gt; ['class' =&amp;gt; 'yii\i18n\I18N'],
        'mailer' =&amp;gt; ['class' =&amp;gt; 'yii\swiftmailer\Mailer'],
        'urlManager' =&amp;gt; ['class' =&amp;gt; 'yii\web\UrlManager'],
        'assetManager' =&amp;gt; ['class' =&amp;gt; 'yii\web\AssetManager'],
        'security' =&amp;gt; ['class' =&amp;gt; 'yii\base\Security'],
    ];
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;其实就是一些核心组件的配置，也就是说这些组件是可以不需要我们在配置文件中配置的，&lt;/span&gt;yii&lt;span&gt;会自动进行注册。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　好了，回到&lt;/span&gt;\yii\base\Application&lt;span&gt;类的构造函数，这个函数最后调用了&lt;/span&gt;&lt;span&gt;\yii\base\Component&lt;/span&gt;&lt;span&gt;类的构造函数，但&lt;/span&gt;&lt;span&gt;\yii\base\Component&lt;/span&gt;&lt;span&gt;类是没有构造函数的，不过它继承了&lt;/span&gt;&lt;span&gt;\yii\base\Object&lt;/span&gt;&lt;span&gt;类：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/747151/201710/747151-20171027203159726-2045349696.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以也自动执行了&lt;/span&gt;\yii\base\Object&lt;span&gt;类的构造函数：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&lt;span&gt;public function __construct($config = [])
{
    if (!empty($config)) {
        Yii::configure($this, $config);
    }
    $this-&amp;gt;init();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这里主要是调用了&lt;/span&gt;\yii\BaseYii&lt;span&gt;类的静态方法&lt;/span&gt;&lt;span&gt;configure()&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&lt;span&gt;public static function configure($object, $properties)
{
    foreach ($properties as $name =&amp;gt; $value) {
        $object-&amp;gt;$name = $value;
    }

    return $object;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这个方法就是循环入口文件&lt;/span&gt;(new yii\web\Application($config))-&amp;gt;run();&lt;span&gt;中的&lt;/span&gt;&lt;span&gt;$config&lt;/span&gt;&lt;span&gt;数组（这个数组的结构参见本文第一个截图），以数组键名作为对象属性名，对应的键值作为对象属性值进行赋值操作。所以当循环到组件配置参数的时候是这样子的：&lt;/span&gt;&lt;span&gt;$object-&amp;gt;components = $value&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;$value&lt;/span&gt;&lt;span&gt;为所有组件的配置数组），也就是对&lt;/span&gt;&lt;span&gt;$object&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;components&lt;/span&gt;&lt;span&gt;属性进行赋值操作，那这个&lt;/span&gt;&lt;span&gt;$object&lt;/span&gt;&lt;span&gt;是哪个类的对象呢？回想最初调用的源头，其实它就是入口文件中需要进行实例化的&lt;/span&gt;&lt;span&gt;\yii\web\Application&lt;/span&gt;&lt;span&gt;类的对象啊。然而，这个类和它的祖先类都没有&lt;/span&gt;&lt;span&gt;components&lt;/span&gt;&lt;span&gt;这个成员变量啊，不急，又要进行一番继承套路了，顺着&lt;/span&gt;&lt;span&gt;yii\web\Application&lt;/span&gt;&lt;span&gt;类的继承关系一层一层往上找可以发现&lt;/span&gt;&lt;span&gt;\yii\web\Application&lt;/span&gt;&lt;span&gt;类最终也继承了&lt;/span&gt;&lt;span&gt;\yii\base\Object&lt;/span&gt;&lt;span&gt;类，\yii\base\Object类是支持属性的，所以yii\web\Application类也支持属性（关于属性，可以参考我的另一篇博文：&lt;a title=&quot;Yii2之属性&quot; href=&quot;http://www.cnblogs.com/wujuntian/p/7491725.html&quot; target=&quot;_blank&quot;&gt;yii2之属性&lt;/a&gt;），当赋值操作找不到&lt;/span&gt;&lt;span&gt;components&lt;/span&gt;&lt;span&gt;成员变量时会调用&lt;/span&gt;&lt;span&gt;setComponents()&lt;/span&gt;&lt;span&gt;方法，又去找这个方法的所在，终于在它的祖先类&lt;/span&gt;&lt;span&gt;\yii\di\ServiceLocator&lt;/span&gt;&lt;span&gt;中找到了&lt;/span&gt;&lt;span&gt;setComponents()&lt;/span&gt;&lt;span&gt;方法，没错，对应用实例的&lt;/span&gt;&lt;span&gt;components&lt;/span&gt;&lt;span&gt;属性进行赋值操作其实就是调用这个方法！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　好了，现在就来看看&lt;/span&gt;setComponents()&lt;span&gt;这个方法到底干了啥：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&lt;span&gt;public function setComponents($components)
{
    foreach ($components as $id =&amp;gt; $component) {
        $this-&amp;gt;set($id, $component);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;其实很简单，就是循环各个组件的配置数组，调用&lt;/span&gt;set()&lt;span&gt;方法，&lt;/span&gt;&lt;span&gt;set()&lt;/span&gt;&lt;span&gt;方法如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&lt;span&gt;public function set($id, $definition)
{
    unset($this-&amp;gt;_components[$id]);

    if ($definition === null) {
        unset($this-&amp;gt;_definitions[$id]);
        return;
    }

    if (is_object($definition) || is_callable($definition, true)) {
        // an object, a class name, or a PHP callable
        $this-&amp;gt;_definitions[$id] = $definition;
    } elseif (is_array($definition)) {
        // a configuration array
        if (isset($definition['class'])) {
            $this-&amp;gt;_definitions[$id] = $definition;
        } else {
            throw new InvalidConfigException(&quot;The configuration for the \&quot;$id\&quot; component must contain a \&quot;class\&quot; element.&quot;);
        }
    } else {
        throw new InvalidConfigException(&quot;Unexpected configuration type for the \&quot;$id\&quot; component: &quot; . gettype($definition));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;其实就是把组件配置存入&lt;/span&gt;$_definitions&lt;span&gt;这个私有成员变量（即注册），然后呢？然后就没有下文了。。。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;搞了半天，原来&lt;/span&gt;yii&lt;span&gt;创建应用实例的时候只是进行组件的注册，并没有实际创建组件，那么组件实例是什么时候进行创建的？在哪里进行创建的呢？别急。从上面推导的这个过程我们知道&lt;/span&gt;&lt;span&gt;\yii\di\ServiceLocator&lt;/span&gt;&lt;span&gt;类是&lt;/span&gt;&lt;span&gt;\yii\web\Application&lt;/span&gt;&lt;span&gt;类的祖先类，所以其实&lt;/span&gt;&lt;span&gt;yii&lt;/span&gt;&lt;span&gt;的应用实例其实就是一个服务定位器，比如我们想访问数据库组件的时候，我们可以这样来访问：&lt;/span&gt;&lt;span&gt;Yii::$app-&amp;gt;db&lt;/span&gt;&lt;span&gt;，这个&lt;/span&gt;&lt;span&gt;Yii::$app&lt;/span&gt;&lt;span&gt;就是&lt;/span&gt;&lt;span&gt;yii&lt;/span&gt;&lt;span&gt;应用实例，也就是&lt;/span&gt;&lt;span&gt;\yii\web\Application&lt;/span&gt;&lt;span&gt;类的实例，但是&lt;/span&gt;&lt;span&gt;\yii\web\Application&lt;/span&gt;&lt;span&gt;类和它的父类、祖先类都找不到&lt;/span&gt;&lt;span&gt;db&lt;/span&gt;&lt;span&gt;这个属性啊。哈哈，别忘了，&lt;/span&gt;&lt;span&gt;php&lt;/span&gt;&lt;span&gt;读取不到类属性的时候会调用魔术方法&lt;/span&gt;&lt;span&gt;__get()&lt;/span&gt;&lt;span&gt;，所以开始查找&lt;/span&gt;&lt;span&gt;\yii\web\Application&lt;/span&gt;&lt;span&gt;继承关系最近的祖先类中的&lt;/span&gt;&lt;span&gt;__get()&lt;/span&gt;&lt;span&gt;方法，最后在&lt;/span&gt;&lt;span&gt;\yii\di\ServiceLocator&lt;/span&gt;&lt;span&gt;类中找到了，也就是说，&lt;/span&gt;&lt;span&gt;Yii::$app-&amp;gt;db&lt;/span&gt;&lt;span&gt;最终会调用&lt;/span&gt;&lt;span&gt;\yii\di\ServiceLocator&lt;/span&gt;&lt;span&gt;类中的&lt;/span&gt;&lt;span&gt;__get()&lt;/span&gt;&lt;span&gt;方法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&lt;span&gt;public function __get($name)
{
    if ($this-&amp;gt;has($name)) {
        return $this-&amp;gt;get($name);
    } else {
        return parent::__get($name);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;__get()&lt;span&gt;方法首先调用&lt;/span&gt;&lt;span&gt;has()&lt;/span&gt;&lt;span&gt;方法（这个不再贴代码了）判断组件是否已注册，若已注册则调用&lt;/span&gt;&lt;span&gt;get()&lt;/span&gt;&lt;span&gt;方法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&lt;span&gt;public function get($id, $throwException = true)
{
    if (isset($this-&amp;gt;_components[$id])) {
        return $this-&amp;gt;_components[$id];
    }

    if (isset($this-&amp;gt;_definitions[$id])) {
        $definition = $this-&amp;gt;_definitions[$id];
        if (is_object($definition) &amp;amp;&amp;amp; !$definition instanceof Closure) {
            return $this-&amp;gt;_components[$id] = $definition;
        } else {
            return $this-&amp;gt;_components[$id] = Yii::createObject($definition);
        }
    } elseif ($throwException) {
        throw new InvalidConfigException(&quot;Unknown component ID: $id&quot;);
    } else {
        return null;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;其中私有成员变量&lt;/span&gt;$_components&lt;span&gt;是存储已经创建的组件实例的，若发现组件已经创建过则直接返回组件示例，否则使用&lt;/span&gt;&lt;span&gt;$_definitions&lt;/span&gt;&lt;span&gt;中对应组件的注册信息，调用&lt;/span&gt;&lt;span&gt;\yii\BaseYii::createObject()&lt;/span&gt;&lt;span&gt;方法进行组件创建，这个方法最终会调用依赖注入容器&lt;/span&gt;&lt;span&gt;\yii\di\Container&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;get()&lt;/span&gt;&lt;span&gt;方法，接着就是依赖注入创建对象的过程了，关于这个过程已经在我的上一篇博文中讲解过了，可以参考一下：&lt;/span&gt;&lt;a title=&quot;yii2之依赖注入与依赖注入容器&quot; href=&quot;http://www.cnblogs.com/wujuntian/p/7520090.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;yii2&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;a title=&quot;yii2之依赖注入与依赖注入容器&quot; href=&quot;http://www.cnblogs.com/wujuntian/p/7520090.html&quot; target=&quot;_blank&quot;&gt;之依赖注入与依赖注入容器&lt;/a&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　好了，&lt;/span&gt;yii&lt;span&gt;组件注册与创建的整个过程就是这样的。最后总结一下，其实&lt;/span&gt;&lt;span&gt;yii&lt;/span&gt;&lt;span&gt;创建应用实例的时候只是进行了各个组件的注册，也就是将组件的配置信息存入&lt;/span&gt;&lt;span&gt;\yii\di\ServiceLocator&lt;/span&gt;&lt;span&gt;类的私有成员变量&lt;/span&gt;&lt;span&gt;$_definitions&lt;/span&gt;&lt;span&gt;中，并没有进行实际创建，等到程序运行过程中真正需要使用到某个组件的时候才根据该组件在&lt;/span&gt;&lt;span&gt;$_definitions&lt;/span&gt;&lt;span&gt;中保存的注册信息使用依赖注入容器&lt;/span&gt;&lt;span&gt;\yii\di\Container&lt;/span&gt;&lt;span&gt;进行组件实例的创建，然后把创建的实例存入私有成员变量&lt;/span&gt;&lt;span&gt;$_components&lt;/span&gt;&lt;span&gt;，这样下次访问相同组件的时候就可以直接返回组件实例，而不再需要执行创建过程了。&lt;/span&gt;&lt;span&gt;yii&lt;/span&gt;&lt;span&gt;的这个组件注册与创建机制其实是大有裨益的，试想一下，如果在应用实例创建的时候就进行所有组件的创建，将会大大增加应用实例创建的时间，用户每次刷新页面都会进行应用实例的创建的，也就是说用户每刷新一次页面都很慢，这用户体验就很不好了，而且很多情况下有很多组件其实是没有使用到的，但是我们还是花了不少时间去创建这些组件，这是很不明智的，所以&lt;/span&gt;&lt;span&gt;yii&lt;/span&gt;&lt;span&gt;的做法就是：先把组件参数信息保存起来，需要使用到哪些组件再去创建相应的实例，大大节省了应用创建的时间，同时也节省了内存，这种思路是很值得我们学习的！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 27 Oct 2017 12:48:00 +0000</pubDate>
<dc:creator>编程人，在天涯</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wujuntian/p/7745136.html</dc:identifier>
</item>
<item>
<title>基于ElementUI的网站换主题的一些思考与实现 - weiqinl</title>
<link>http://www.cnblogs.com/weiqinl/p/7732892.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weiqinl/p/7732892.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;web应用程序，切换主题，给其换肤，是一个比较常见的需求。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如何能快速的切换主题色？(只有固定的一种皮肤)&lt;/li&gt;
&lt;li&gt;如果又想把主题色切换为以前的呢？（有多种可切换的皮肤）&lt;/li&gt;
&lt;li&gt;该以何种方式编写标签的css属性？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;快速切换主题这个需求，它考验了项目的CSS代码，是否具有可维护性、可扩展性。&lt;br/&gt;css要如何编写，才能达到这两点呢，我还在研究学习当中，可以参考&lt;a href=&quot;http://www.zcfy.cc/article/structuring-css-in-large-projects-1202.html&quot;&gt;在大型项目中组织CSS&lt;/a&gt;。&lt;br/&gt;本来，此文想写这个的，发现道行不够(┬＿┬)，我还是写如何实现的，比较好。&lt;/p&gt;
&lt;p&gt;想要换主色调，其实就是换一种风格样式，最终都是换css。&lt;br/&gt;我看目前比较流行的几种切换主题的方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有样式的css模版都在项目中，根据条件，给body添加class，通过不同的class来显示不同的样式。&lt;/li&gt;
&lt;li&gt;通过引用不同的link文件，达到效果。&lt;/li&gt;
&lt;li&gt;ElementUI的这种方式，详情见&lt;a href=&quot;https://github.com/ElemeFE/element/issues/3054&quot;&gt;ISSUE&lt;/a&gt;&lt;br/&gt;（1） 先把默认主题文件中涉及到颜色的 CSS 值替换成关键词&lt;br/&gt;（2） 根据用户选择的主题色生成一系列对应的颜色值&lt;br/&gt;（3） 把关键词再换回刚刚生成的相应的颜色值&lt;br/&gt;（4） 直接在页面上加 style 标签，把生成的样式填进去&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我目前用的是第一种方式，把操作过程记录下来，方便以后查看。&lt;/p&gt;
&lt;h2 id=&quot;如何增加主题文件-具体操作过程&quot;&gt;如何增加主题文件-具体操作过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/564792/201710/564792-20171027190425523-1992772762.gif&quot; alt=&quot;动态换肤.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;a href=&quot;https://github.com/weiqinl/vue-element-admin&quot;&gt;此项目UI&lt;/a&gt;是在elementUI基础上建立的，所以，我们可以通过element提供的方法，来&lt;a href=&quot;http://element.eleme.io/#/zh-CN/component/custom-theme&quot;&gt;自定义主题&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;生成自定义主题文件&quot;&gt;生成自定义主题文件&lt;/h3&gt;
&lt;p&gt;使用工具下载自定义主题文件，并命名为&lt;code&gt;wq-variables.css&lt;/code&gt;。以后我们如果想要增加主题文件，只需要修改变量文件中各个变量所对应的值。&lt;/p&gt;
&lt;h3 id=&quot;编译主题&quot;&gt;编译主题&lt;/h3&gt;
&lt;p&gt;我们利用&lt;a href=&quot;http://element.eleme.io/#/zh-CN/component/custom-theme#an-zhuang-gong-ju&quot;&gt;工具&lt;/a&gt;来编译主题。&lt;br/&gt;在终端，将刚刚修改好的变量文件，通过命令&lt;code&gt;node_modules/.bin/et -c wq-variables.css&lt;/code&gt;来编译主题。&lt;/p&gt;
&lt;h3 id=&quot;给自定义主题增加命名空间&quot;&gt;给自定义主题增加命名空间&lt;/h3&gt;
&lt;p&gt;默认情况下，编译的主题目录会放在&lt;code&gt;./theme&lt;/code&gt;下。由于，我们是通过改变css的命名空间来切换主题的，那么，我们就需要为刚生成的主题增加命名空间。主题文件内容很多，如果手动一个个添加命名空间，工作量巨大，这个时候，可以使用另一个&lt;a href=&quot;https://github.com/weiqinl/tool-web/tree/master/gulpcsswrap&quot;&gt;给css增加命名空间的工具&lt;/a&gt;。下载这个项目，然后只需要修改&lt;code&gt;gulpfile.js&lt;/code&gt;文件中3处内容，就可以得到想要的内容，这里注意，本项目css自定义的命名空间统一为&lt;code&gt;custom-******&lt;/code&gt;,其中&lt;code&gt;******&lt;/code&gt;建议使用主题色的16进制编码,也可以使用其他字符串，但是要和radio标签统一。&lt;/p&gt;
&lt;h3 id=&quot;引用自定义主题&quot;&gt;引用自定义主题&lt;/h3&gt;
&lt;p&gt;自定义主题文件，已经有了，只剩下如何引入使用了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在&lt;code&gt;App.vue&lt;/code&gt;中import新增的主题样式（这个也可以写在topbar.vue文件中，到底哪种好些，我也不清楚）&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;./src/components/nav/topbar/topbar.vue&lt;/code&gt;中，添加对应的radio标签&lt;br/&gt;经过以上两步，就可以正常使用了。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;如何处理与自定义主题不同部分的样式&quot;&gt;如何处理与自定义主题不同部分的样式&lt;/h3&gt;
&lt;p&gt;可以新建一个css文件，然后在其中编写样式，之后在入口文件引入就ok了。&lt;/p&gt;
&lt;p&gt;具体效果，可查看于此网站：&lt;br/&gt;&lt;a href=&quot;http://weiqinl.com/vue-element-admin/&quot; class=&quot;uri&quot;&gt;http://weiqinl.com/vue-element-admin/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此做法参考于：&lt;br/&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000009762198#articleHeader2&quot;&gt;基于Element的动态换肤&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Oct 2017 11:05:00 +0000</pubDate>
<dc:creator>weiqinl</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weiqinl/p/7732892.html</dc:identifier>
</item>
<item>
<title>大数据量样本随机采样-蓄水池算法 - 笨兔勿应</title>
<link>http://www.cnblogs.com/bentuwuying/p/7744652.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bentuwuying/p/7744652.html</guid>
<description>&lt;p&gt;最近在个性化推荐系统的优化过程中遇到一些问题，大致描述如下：目前在我们的推荐系统中，各个推荐策略召回的item相对较为固定，这样就会导致一些问题，用户在多个推荐场景（如果多个推荐场景下使用了相同的召回策略）、多次请求时得到的结果也较为固定，对流量的利用效率会有所降低；尤其对于行为较少的用户，用来作为trigger的行为数据本身就很少，这样就使得召回item同质化较为严重，使得第一个问题更加明显。&lt;/p&gt;
&lt;p&gt;目前的解决方法是，在推荐策略的召回阶段加入一定的随机机制，使得用户在多个场景、多次请求时能后给用户展示相似但不完全雷同的结果 。所以问题就转化为在N个召回结果（召回结果需要适当地扩大）中随机抽样出K个结果，两个难点：&lt;/p&gt;
&lt;p&gt;1. N的值很大时，直接在N个数中取K个数实际是比较慢的，再加上我们这里还要求是不重复的采样，这就导致每次产生的随机数采样的结果与之前采样的某一个结果一致就需要重新进行采样，这就导致线上计算的性能会受到影响，这个影响随着N的增加会越来越严重。所以我们需要有一种时间复杂度较小的采样算法，如O(N)的时间复杂度。&lt;/p&gt;
&lt;p&gt;2. 对于推荐策略召回的结果，其实每个item是具有不同的权重（相似度）的，所以我们也可以利用到这部分信息，即在抽样时并不是等概率采样，而是带权重的概率采样。&lt;/p&gt;

&lt;p&gt;对于第一个问题，我们可以使用蓄水池算法来解决。首先先看这个问题的简化版，即从n个数中随机采样出1个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法：&lt;/strong&gt;我们总是选择第一个对象，以1/2的概率选择第二个，以1/3的概率选择第三个，以此类推，以1/m的概率选择第m个对象。当该过程结束时，每一个对象具有相同的选中概率，即1/n，证明如下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明：&lt;/strong&gt;第m个对象最终被选中的概率P=选择m的概率*其后面所有对象不被选择的概率，即&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/995611/201710/995611-20171027181737664-637974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再来看对应的&lt;strong&gt;蓄水池抽样问题&lt;/strong&gt;，即从n个数中随机采样k个数。可以类似的思路解决。先把读到的前k个对象放入“水库”，对于第k+1个对象开始，以k/(k+1)的概率选择该对象，以k/(k+2)的概率选择第k+2个对象，以此类推，以k/m的概率选择第m个对象（m&amp;gt;k）。如果m被选中，则随机替换水库中的一个对象。最终每个对象被选中的概率均为k/n，证明如下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明：&lt;/strong&gt;第m个对象被选中的概率=选择m的概率*（其后元素不被选择的概率+其后元素被选择的概率*不替换第m个对象的概率），即&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/995611/201710/995611-20171027181753070-859131193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际代码实现还是比较简单的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; List&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; sampleList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;sampleNum; ++&lt;span&gt;i) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    sampleList.add(rawList.get(i));
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=sampleNum; i&amp;lt;rawListSize; ++&lt;span&gt;i) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; j = r.nextInt(i+1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (j &amp;lt;&lt;span&gt; sampleNum) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        sampleList.remove(j);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        sampleList.add(rawList.get(i));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来看看第二个问题，这就涉及到了带权重的概率抽样问题了。那有没有在蓄水池算法基础上的带权重概率的抽样算法呢？当然是有的，想要详细了解的可以直接看paper《Weighted random sampling with a reservoir》。&lt;/p&gt;
&lt;p&gt;首先对于每个样本，都具有一个权重Wi，我们可以针对这个权重值做一个变换作为每个样本的得分：sampleScore = random(0, 1)^(1/Wi)。然后采样过程与之前的一致，也是对每个样本进行顺序读取。对前k个样本维护一个最小堆（针对sampleScore排序），然后对于后续的样本，每次来一个样本，都将这个新样本的sampleScore与之前的最小样本的sampleScore进行比较，如果比最小sampleScore要大，则推出这个最小值，压入这个新样本并继续维护这个最小堆，直到所有样本都被遍历过一次。&lt;/p&gt;
&lt;p&gt;具体的代码实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
Comparator&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; cmp = &lt;span&gt;new&lt;/span&gt; Comparator&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; compare(Map&amp;lt;String, Object&amp;gt; e1, Map&amp;lt;String, Object&amp;gt;&lt;span&gt; e2) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Double.compare((&lt;span&gt;double&lt;/span&gt;)e1.get(sampleScoreField), (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)e2.get(sampleScoreField));
        }
};
PriorityQueue&lt;/span&gt;&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; pq = &lt;span&gt;new&lt;/span&gt; PriorityQueue&amp;lt;&amp;gt;&lt;span&gt;(sampleNum, cmp);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;sampleNum; ++&lt;span&gt;i) {
    Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; item =&lt;span&gt; rawList.get(i);
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sampleScore = Math.pow(r.nextDouble(), 1.0/(0.001+MapUtils.getDoubleValue(item, weightField, 0.0&lt;span&gt;)));
    item.put(sampleScoreField, sampleScore);
    pq.add(item);
}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=sampleNum; i&amp;lt;rawListSize; ++&lt;span&gt;i) {
    Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; item =&lt;span&gt; rawList.get(i);
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sampleScore = Math.pow(r.nextDouble(), 1.0/(0.001+MapUtils.getDoubleValue(item, weightField, 0.0&lt;span&gt;)));
    item.put(sampleScoreField, sampleScore);
    Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; minItem =&lt;span&gt; pq.peek();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sampleScore &amp;gt; (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;)minItem.get(sampleScoreField)) {
        pq.remove();
        pq.add(item);
    }
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;版权声明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   本文由&lt;a href=&quot;http://www.cnblogs.com/bentuwuying&quot; target=&quot;_blank&quot;&gt;笨兔勿应&lt;/a&gt;所有，发布于&lt;a href=&quot;http://www.cnblogs.com/bentuwuying&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/bentuwuying&lt;/a&gt;。如果转载，请注明出处，在未经作者同意下将本文用于商业用途，将追究其法律责任。&lt;/p&gt;


</description>
<pubDate>Fri, 27 Oct 2017 10:41:00 +0000</pubDate>
<dc:creator>笨兔勿应</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bentuwuying/p/7744652.html</dc:identifier>
</item>
<item>
<title>HTML5的Websocket（理论篇 I） - 大转转FE</title>
<link>http://www.cnblogs.com/zhuanzhuanfe/p/7744577.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuanzhuanfe/p/7744577.html</guid>
<description>&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;** 先请来TA的邻居：**&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;http&lt;/strong&gt;：无状态、基于&lt;strong&gt;tcp&lt;/strong&gt;请求/响应模式的&lt;strong&gt;应用层&lt;/strong&gt;协议 （A:哎呀，上次你请我吃饭了么? B:我想想, 上次请你吃了么） &lt;strong&gt;tcp&lt;/strong&gt;：面向连接、保证高可靠性(数据无丢失、数据无失序、数据无错误、数据无重复到达) &lt;strong&gt;传输层&lt;/strong&gt;协议。（看啊，大阅兵，如此规整有秩序）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;为什么要引入Websocket：&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;RFC开篇介绍：本协议的目的是为了解决基于浏览器的程序需要拉取资源时必须发起多个HTTP请求和长时间的轮询的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;long poll(长轮询): 客户端发送一个request后，服务器拿到这个连接，如果有消息，才返回response给客户端。没有消息，就一直不返回response。之后客户端再次发送request, 重复上次的动作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1203274/201710/1203274-20171027175147351-940576441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上可以看出，http协议的特点是服务器不能主动联系客户端，只能由客户端发起。它的被动性预示了在完成双向通信时需要不停的连接或连接一直打开，这就需要服务器快速的处理速度或高并发的能力，是非常消耗资源的。&lt;/p&gt;
&lt;p&gt;这个时候，Websocket出现了。&lt;/p&gt;
&lt;h2&gt;Websocket是什么：&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;RFC中写到：WebSocket协议使在控制环境下运行不受信任代码的客户端和能够选择与那些代码通信的远程主机之间能够双向通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对，划重点：&lt;strong&gt;双向通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Websocket在连接之后，客户端可以主动发送消息给服务器，服务器也可以&lt;strong&gt;主动向客户端推送消息&lt;/strong&gt;。比如：预订车票信息，除了我们发请求询问车票如何，当然更希望如果有新消息，可以直接通知我们。&lt;/p&gt;
&lt;p&gt;其特点：&lt;/p&gt;
&lt;p&gt;（1）握手阶段采用 HTTP 协议，默认端口是80和443&lt;/p&gt;
&lt;p&gt;（2）建立在TCP协议基础之上，和http协议同属于应用层&lt;/p&gt;
&lt;p&gt;（4）可以发送文本，也可以发送二进制数据&lt;/p&gt;
&lt;p&gt;（5）没有同源限制，客户端可以与任意服务器通信&lt;/p&gt;
&lt;p&gt;（6）协议标识符是ws（如果加密，为wss），如&lt;a&gt;ws://localhost:8023&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单来说，Websocket协议分为两部分：握手和数据传输。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1203274/201710/1203274-20171027175157914-424674544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Websocket API：&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里是指客户端 API。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;WebSocket 构造函数&lt;/h4&gt;
&lt;pre class=&quot;code highlight white plaintext&quot;&gt;
&lt;code&gt;通过调用WebSocket构造函数来创建一个WebSocket实例对象，建立客户端与服务器的连接。
&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  const ws = &lt;span&gt;new&lt;/span&gt; WebSocket('ws://localhost:8023');
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Websocket事件&lt;/h3&gt;
&lt;pre class=&quot;code highlight white plaintext&quot;&gt;
&lt;code&gt;WebSocket 是纯事件驱动，通过监听事件可以处理到来的数据和改变的连接状态。服务端发送数据后，消息和事件会异步到达。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要指定多个回调函数，可以使用addEventListener方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ws.addEventListener('open', e =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  ws.send(`Hello ${e}`);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; });
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当open事件触发时，意味着握手阶段已结束。服务端已经处理了连接的请求，可以准备收发数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接受文本消息的事件处理：&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; ws.onmessage = e =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     const data =&lt;span&gt; e.data;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; data === &quot;string&quot;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         console.log(&quot;Received string message &quot;&lt;span&gt;,data);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Blob) {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         console.log(&quot;Received blob message &quot;&lt;span&gt;, data);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;服务器数据可能是文本，也可能是二进制数据，有Blob和ArrayBuffer两种类型，在读取到数据之前需要决定好数据的类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;异常处理&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; ws.onerror = e =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     console.log(&quot;WebSocket Error: &quot;&lt;span&gt; , e);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    handleErrors(e);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;WebSocket 规范中定义了ping 帧 和pong 帧，可以用来做心跳重连，网络状态查询等，但是目前 浏览器只会自动发送pong帧，而不会发ping 帧。（有兴趣可详查ping和pong帧）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭连接处理&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; ws.onclose = e =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     const code =&lt;span&gt; e.code;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     const reason =&lt;span&gt; e.reason;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     console.log(&quot;Connection close&quot;&lt;span&gt;, code, reason);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;WebSocket 方法：&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;WebSocket 对象有两个方法：send 和 close&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送一个文本消息&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; ws.send(&quot;this is websocket&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在open事件的回调中调用send()方法传送数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; const ws = &lt;span&gt;new&lt;/span&gt; WebSocket('ws://localhost:8023'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; ws.onopen = e =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     console.log('Connection success'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    ws.send(`Hello ${e}`);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果想通过响应其他事件发送消息，可通过判断当前的Websocket的readyState属性。接下来会说到readyState.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;ws.close();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1000是状态码，代表正常结束。&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; ws.close(1000, &quot;Closing normally&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;WebSocket 属性&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;readyState：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;readyState值表示连接状态，是只读属性。它有以下四个值：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;WebSocket.CONNECTING ：连接正在进行，但还没有建立 WebSocket.OPEN ：连接已经建立，可以发送消息 WebSocket.CLOSING ：连接正在进行关闭握手 WebSocket.CLOSED ：连接已经关闭或不能打开&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除了在open事件回调中调用send方法，可通过判断readyState值来发送消息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; bindEventHandler(data) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ws.readyState ===&lt;span&gt; WebSocket.OPEN) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        ws.send(data);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ws.onopen = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     setInterval( &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存未满的时候发送&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (ws.bufferedAmount &amp;lt; 1024 * 5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;            ws.send(data);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     }, 2000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;** 接下来，我们说说握手阶段过程。**&lt;/p&gt;
&lt;p&gt;当我们创建Websocket实例对象与服务器建立连接时，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  const ws = &lt;span&gt;new&lt;/span&gt; WebSocket('ws://localhost:8023');
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;首先客户端向服务器发起一个握手请求，其请求报文的内容如下：&lt;/p&gt;
&lt;pre class=&quot;code highlight white plaintext&quot;&gt;
&lt;code&gt;GET /game HTTP/1.1
Host: 10.242.17.102:8023
Cache-Control: no-cache
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Protocol: game
Sec-WebSocket-Version: 10
Origin: http://192.168.185.16
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从请求头中可以看出，其实是一个基于http的握手请求。与通常的http请求不同的是，增加了一些头信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Upgrade字段: 通知服务器，现在要使用一个升级版协议 - Websocket。&lt;/li&gt;
&lt;li&gt;Sec-WebSocket-Key: 是一个Base64编码的值，这个是浏览器随机生成,通知服务器，需要验证下是否可以进行Websocket通信&lt;/li&gt;
&lt;li&gt;Sec_WebSocket-Protocol: 是用户自定义的字符串，用来标识服务所需要的协议&lt;/li&gt;
&lt;li&gt;Sec-WebSocket-Version: 通知服务器所使用的协议版本&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;服务器响应：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;code highlight white plaintext&quot;&gt;
&lt;code&gt;当服务器返回以下内容，就表示已经接受客户端请求啦，可以建立Websocket通信啦。
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;code highlight white plaintext&quot;&gt;
&lt;code&gt;HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: SIEylb7zRYJAEgiqJXaOW3V+ZWQ=

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;101 状态码，表示要转换协议啦&lt;/li&gt;
&lt;li&gt;Upgrde: 通知客户端将要升级成Websocket协议&lt;/li&gt;
&lt;li&gt;Sec-WebSocket-Accept： 经过服务器确认，并且加密过后的 Sec-WebSocket-Key。用来证明客户端和服务器之间能进行通信了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1203274/201710/1203274-20171027175209445-1545729289.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，客户端和服务器握手成功建立了Websocket连接，通信不再使用http数据帧，而采用Websocket独立的数据帧。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;以上是Websocket协议的基础理论篇I, 欢迎小伙伴儿们接力(理论篇II, 实战篇神马的), 一起学习一起积累~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt; 如果你喜欢我们的文章，关注我们的公众号和我们互动吧。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1203274/201709/1203274-20170929105350169-1798795184.jpg&quot; alt=&quot;&quot; width=&quot;344&quot; height=&quot;344&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 27 Oct 2017 09:57:00 +0000</pubDate>
<dc:creator>大转转FE</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuanzhuanfe/p/7744577.html</dc:identifier>
</item>
<item>
<title>javascript 之作用域-06 - 风吹De麦浪</title>
<link>http://www.cnblogs.com/CandyManPing/p/7744514.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CandyManPing/p/7744514.html</guid>
<description>&lt;p&gt;作用域是指变量和函数可访问范围，他规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。&lt;/p&gt;
&lt;p&gt;作用域有两种工作模式：&lt;/p&gt;
&lt;p&gt;静态作用域 ：又称为词法作用域，在编译阶就可以决定变量的引用，由程序定义的位置决定，和代码执行顺序无关，用嵌套的方式解析。&lt;/p&gt;
&lt;p&gt;动态作用域 ：在程序运行时候，和代码的执行顺序决定，用动态栈动态管理。&lt;/p&gt;

&lt;p&gt;JavaScript 采用的是词法作用域，函数的作用域在函数编译时的时候就决定了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; a = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         console.log(a);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; fo() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; a = 20&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        run();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    fo();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行 run函数，先从run 函数内部查找是否有局部变量 a，如果没有，就根据代码书写位置，向上查找变量a，也就是a等于10，所以结果会打印 10。&lt;/p&gt;
&lt;p&gt;假设JavaScript采用动态作用域，让我们分析下执行过程：&lt;/p&gt;
&lt;p&gt;执行run 函数，依然是从run 函数内部查找是否有局部变量 a。如果没有，就从调用函数的作用域，也就是fo函数内部查找 a变量，所以结果会打印 20。&lt;/p&gt;
&lt;p&gt;前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 10。&lt;/p&gt;

&lt;p&gt;ES5在词法作用域工作模式（一种规则）下又分为全局作用域和函数作用域，没有块作用域（es6以后有）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/825196/201710/825196-20171027174044664-1559383145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;全局作用域：该作用域的变量、对象在任何地方都是可见的，变量没有在函数内声明或者声明的时候&lt;strong&gt;没有带var&lt;/strong&gt;就是全局变量，拥有全局作用域，&lt;strong&gt;window&lt;/strong&gt;对象的所有属性拥有全局作用域，在代码任何地方都可以访问。&lt;/p&gt;
&lt;p&gt;在客户端javascript 中，表示的浏览器窗口中window对象充当了全局对象，拥有全局作用域。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; a = 10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         console.log(a);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; fo() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; a = 20&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        run();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    fo();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;span&gt;12&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt;13&lt;/span&gt;     console.log(a)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;全局变量a ，在run函数以及第二个&amp;lt;script&amp;gt;代码块中也是可见的；&lt;/p&gt;
&lt;p&gt;函数作用域：在函数内声明的变量，那么在函数内及其子函数内都是可见的，在函数外是不可见的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; fo(){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; myName='Joel'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     console.log(myName)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ReferenceError: myName is not defined&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;块级作用域是指在{...}内的代码块，每一段代码块都有各自的作用域，且声明的变量在代码块外是不可见的 如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; run(){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; a=10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; b=10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;        console.log(b);//如果存在块作用域，那么这里打印这个b是会报错的
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;单纯的作用域还是好理解，javascript的作用域是静态作用域，即&lt;span&gt;&lt;strong&gt;应该关心代码的位置而不是调用的位置&lt;/strong&gt;&lt;/span&gt; 如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;script&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; x=10&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; fn(){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        console.log(x);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; show(f){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; x=20&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;          f()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     show(fn);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 27 Oct 2017 09:47:00 +0000</pubDate>
<dc:creator>风吹De麦浪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CandyManPing/p/7744514.html</dc:identifier>
</item>
</channel>
</rss>