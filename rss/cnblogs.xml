<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java基础（四）线程快速了解 - python修行路</title>
<link>http://www.cnblogs.com/zhaof/p/9278865.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaof/p/9278865.html</guid>
<description>&lt;p data-source-line=&quot;3&quot;&gt;开始整理线程之前，之前有个命令忘记整理了，先整理一下jar命令的使用&lt;/p&gt;

&lt;h2 id=&quot;toc_1&quot;&gt;Jar包&lt;/h2&gt;
&lt;p&gt;其实可以理解是java的压缩包&lt;br/&gt;方便使用，只要在classpath设置jar路径即可&lt;br/&gt;数据库驱动，ssh框架等都是以jar包体现的&lt;/p&gt;
&lt;p&gt;打包方式一：将指定的class文件打入到jar包中&lt;br/&gt;jar cvf xxx.jar Xxx.class yyy.class&lt;/p&gt;
&lt;p&gt;打包方式二：将某个目录下的所有文件打入到jar包中&lt;br/&gt;jar cvf xxx.jar -C xxx/.&lt;/p&gt;
&lt;p&gt;查看jar文件：&lt;br/&gt;jar -tf xxx.jar&lt;/p&gt;
&lt;p&gt;运行jar包中的类：&lt;br/&gt;java -cp xxx.jar xx.xx.xx(完整的类名)&lt;/p&gt;
&lt;p&gt;常用的jar命令参数：&lt;br/&gt;c：创建压缩文件&lt;br/&gt;f:指定存档名称&lt;br/&gt;v:显示详细信息&lt;br/&gt;m:加入自定义清单&lt;/p&gt;
&lt;p&gt;指定清单文件（xxx.jar/META-INF/MNIFEST.MF）的入口类&lt;br/&gt;jar cvfe classess.jar com.zhaofan.PackagDemo1 classes/.&lt;br/&gt;这样我们就可以通过java -jar xxx.jar直接执行&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;线程&lt;/h2&gt;
&lt;p&gt;进程：运行时概念，运行的应用程序&lt;br/&gt;线程：应用程序内部并发执行的代码段，共享内存&lt;/p&gt;
&lt;p&gt;这里几个关键词&lt;br/&gt;yield: 放弃cpu抢占权&lt;br/&gt;join:等待指定的线程执行完&lt;br/&gt;sleep:静态方法，让线程休眠毫秒数&lt;br/&gt;daemo:守护线程&lt;/p&gt;
&lt;p&gt;最简单的线程代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study_java.ex9;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadDemo1 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        Mythread t1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Mythread();
        t1.start();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Mythread &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            System.out.println(&lt;/span&gt;&quot;MyThread&quot;&lt;span&gt;);
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;join的一个简单实用例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study_java.ex9;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadDemo2 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        Player p1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Player(&quot;aa&quot;,5000&lt;span&gt;);
        Player p2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Player(&quot;bb&quot;,8000&lt;span&gt;);
        Player p3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Player(&quot;cc&quot;,2000&lt;span&gt;);
        Player p4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Player(&quot;dd&quot;,3000&lt;span&gt;);
        p1.start();
        p2.start();
        p3.start();
        p4.start();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            p1.join();
            p2.join();
            p3.join();
            p3.join();
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){

        }


        System.out.println(&lt;/span&gt;&quot;人到了，开始玩游戏&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Player &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; time;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Player(String name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; time){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.time =&lt;span&gt; time;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        System.out.println(&lt;/span&gt;&quot;玩家：&quot;+name + &quot;出发了&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            Thread.sleep(time);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){

        }
        System.out.println(&lt;/span&gt;&quot;玩家：&quot;+name + &quot;到了&quot;&lt;span&gt;);


    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;守护线程的一个使用例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study_java.ex9;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThraedDemo3 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        Room r1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Room(&quot;no1&quot;,15000&lt;span&gt;);
        Waiter w1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Waiter();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;w1.setDaemon(true); 设置守护线程&lt;/span&gt;
&lt;span&gt;        r1.start();
        w1.start();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Room &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String no;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; time;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Room(String no, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; time){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.no =&lt;span&gt; no;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.time =&lt;span&gt; time;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        System.out.println(&lt;/span&gt;&quot;no&quot; + &quot;号房间正在唱歌&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            Thread.sleep(time);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){

        }
        System.out.println(&lt;/span&gt;&quot;no&quot; + &quot;买单&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Waiter &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Waiter(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.setDaemon(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            System.out.println(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; java.util.Date());
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){

            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;任何一个对象都可以是锁，信号灯，其实就是一个参照物&lt;br/&gt;一个锁的代码例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study_java.ex9;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadDemo4 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        Saler s1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Saler(&quot;a1&quot;&lt;span&gt;);
        Saler s2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Saler(&quot;a2&quot;&lt;span&gt;);
        s1.start();
        s2.start();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Saler &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 锁&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; Object lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tickts = 100&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Saler(String name){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tick =&lt;span&gt; getTickts();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tick &amp;gt; 0&lt;span&gt;){
                System.out.println(name&lt;/span&gt;+&quot;:&quot;+&lt;span&gt; tick);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取票&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getTickts(){
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (lock){
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; currTicket =&lt;span&gt; tickts;
            tickts &lt;/span&gt;--&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; currTicket;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一种方法是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getTickts(){
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; currTicket =&lt;span&gt; tickts;
   tickts &lt;/span&gt;--&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; currTicket;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样也能实现锁的机制，但是注意这里必须是static&lt;/p&gt;
&lt;p&gt;我们整理一个新的写法，把票池单独写出来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreadDemo2 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        TicketPool pool &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TicketPool();
        Saler s1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Saler(&quot;s1&quot;&lt;span&gt;,pool);
        Saler s2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Saler(&quot;s2&quot;&lt;span&gt;,pool);
        s1.start();
        s2.start();
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 票池&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TicketPool {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tickets = 100&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从票池取票&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getTickets(){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ticket =&lt;span&gt; tickets;
        tickets &lt;/span&gt;-= 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ticket;
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 售票员&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Saler &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; TicketPool pool = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Saler(String name, TicketPool tp){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.pool =&lt;span&gt; tp;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; no =&lt;span&gt; pool.getTickets();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (no &amp;gt; 0&lt;span&gt; ){
                System.out.println(name &lt;/span&gt;+ &quot;:&quot; +&lt;span&gt; no);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两个小的练习熟悉上面知识点的使用：&lt;br/&gt;车过山洞的问题，山洞同时只允许一个车通过，现在有多辆车，不同的车通过的时间不同，代码实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study_java.ex11;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CarCave {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        Cave cave &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cave();
        Car car1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Car(cave,10000,&quot;奥迪&quot;&lt;span&gt;);
        Car car2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Car(cave,8000,&quot;奔驰&quot;&lt;span&gt;);
        Car car3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Car(cave,6000,&quot;宝马&quot;&lt;span&gt;);
        Car car4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Car(cave,2000,&quot;悍马&quot;&lt;span&gt;);
        car1.start();
        car2.start();
        car3.start();
        car4.start();

    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cave{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; crossCar(Car car){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
            System.out.println(car.name&lt;/span&gt;+&quot;：开始过山洞了&quot;&lt;span&gt;);
            Thread.sleep(car.time);
            System.out.println(car.name&lt;/span&gt;+&quot;：开始出山洞了&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){

        }


    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Car &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Cave cave;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; time;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Car(Cave cave ,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; time,String name){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cave =&lt;span&gt; cave;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.time =&lt;span&gt; time;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        cave.crossCar(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二个小练习是我们经常遇到的场景，取票问题，现在有一个取票机，但是有五十个人要取票，实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study_java.ex11;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TicketDemo1 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        TicketMachine m &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TicketMachine();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;50;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Person(m,&quot;tom&quot;+&lt;span&gt;i).start();
        }
    }
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 取票机&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; TicketMachine{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ticketNo = 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印票号&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; printTicktNo(){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; currTicketNo =&lt;span&gt; ticketNo;
        ticketNo &lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; currTicketNo;
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TicketMachine m;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(TicketMachine m,String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.m =&lt;span&gt; m;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; no =&lt;span&gt; m.printTicktNo();
        System.out.println(name&lt;/span&gt;+ &quot;:&quot; +&lt;span&gt; no);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;生产者消费者模型&lt;/h3&gt;
&lt;p&gt;通过上面的知识点，写一个生产者好消费者模型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study_java.ex11;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.LinkedList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PCDemo1 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        MyList myList &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyList();

        Productor p &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Productor(myList);
        Consumer c &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Consumer(myList);
        Consumer c2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Consumer(myList);
        Consumer c3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Consumer(myList);
        p.start();
        c.start();
        c2.start();
        c3.start();
    }

}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyList{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Max = 100&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;Integer&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addLast(Integer i){
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (list){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (list.size() &amp;lt;&lt;span&gt; Max){
                    list.add(i);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            }
        }


    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;  Integer removeFirst(){
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; (list){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;list.isEmpty()){
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; list.remove(0&lt;span&gt;);
                }
            }
        }
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Productor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MyList myList;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Productor(MyList myList){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.myList =&lt;span&gt; myList;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            myList.addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer(i));
            System.out.println(&lt;/span&gt;&quot;生产者生产了&quot;+i+&quot;号&quot;&lt;span&gt;);
            i&lt;/span&gt;++&lt;span&gt;;
        }
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Consumer &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MyList myList;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Consumer(MyList myList){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.myList =&lt;span&gt; myList;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; no =&lt;span&gt; myList.removeFirst();
            System.out.println(&lt;/span&gt;&quot;消费者消费了&quot;+no+&quot;号&quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生产者消费者而改进版本：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study_java.ex11;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.LinkedList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PCDemo5 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        Pool pool &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Pool();
        Producter p1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Producter(pool);
        Consumer c1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Consumer(pool);
        p1.start();
        c1.start();

    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Pool{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;Integer&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Max = 100&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addLast(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (list.size() &amp;gt;=&lt;span&gt; Max){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.wait();
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
                    e.printStackTrace();
                }
            }
            list.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Integer(n));

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.notifyAll();
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; remove(){
        &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (list.size() == 0&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.wait();
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
                    e.printStackTrace();
                }

            }
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; no = list.remove(0&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.notifyAll();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; no;
        }
    }

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生产者&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Producter &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Pool pool;
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i = 1&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Producter(Pool pool){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.pool =&lt;span&gt; pool;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            pool.addLast(i&lt;/span&gt;++&lt;span&gt;);
            System.out.println(&lt;/span&gt;&quot;生产者生产了&quot;+i+&quot;号&quot;&lt;span&gt;);
        }
    }

}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 消费者&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt; Consumer &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Pool pool;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Consumer(Pool pool){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.pool =&lt;span&gt; pool;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; no =&lt;span&gt; pool.remove();
            System.out.println(&lt;/span&gt;&quot;消费者消费了&quot;+no+&quot;号&quot;&lt;span&gt;);
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;wait()：让当前线程进入到锁对象的等待队列里，同时释放锁旗标。这个方法是当前锁对象的方法&lt;br/&gt;wait这里还可以添加参数wait(int n) :等待指定的时间片,等待队列中的线程最多等待n毫秒&lt;/p&gt;
&lt;p&gt;notify():这个方法是当前锁对象的方法,注意这里并不会释放锁&lt;br/&gt;notifyAll():通知等待队列中的所有线程都可以抢占cpu运行，通知需要获得对象的监控权&lt;/p&gt;
&lt;p&gt;sleep:当前CPU的抢占权，和锁对象的监控权无关。&lt;br/&gt;Thread.currentThread().getName():获取当前线程名字&lt;br/&gt;Thread.currentThread().setName():设置当前线程名字&lt;/p&gt;
&lt;p&gt;priority:1-10从低到高，默认是5&lt;br/&gt;Thread.currentThread().getPriority():设置当前线程优先级&lt;/p&gt;
&lt;p&gt;线程状态：&lt;br/&gt;BLOCKED: 阻塞&lt;br/&gt;NEW:新建&lt;br/&gt;RUNNABL:执行&lt;br/&gt;TERMINATED:已经终止&lt;br/&gt;TIMED_WAITING:限时等待&lt;br/&gt;WAITING:等待&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/997599/201807/997599-20180707234935082-972628071.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;创建一个线程的另外一种方式：&lt;br/&gt;实现Runnable接口&lt;br/&gt;1. 子类覆盖接口中的run方法&lt;br/&gt;2. 通过Thread类创建线程，并将实现了Runnable接口的子类对象作为参数传递给Thread类的构造函数&lt;br/&gt;3. Thread类对象调用start方法开启线程&lt;/p&gt;
&lt;p&gt;代码例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; study_java.ex11;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RunnableDemo1 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
        MyRunnabl m &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyRunnabl();
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(m).start();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; MyRunnabl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){
        System.out.println(&lt;/span&gt;&quot;hello world&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;同步（synchronized）&lt;/h3&gt;
&lt;p&gt;synchronized(对象)&lt;br/&gt;{&lt;br/&gt;需要同步的代码&lt;br/&gt;}&lt;br/&gt;同步的特点：&lt;br/&gt;同步的前提是：&lt;br/&gt;需要两个或者两个以上的线程&lt;br/&gt;多个线程使用的同一个锁&lt;/p&gt;
&lt;p&gt;同步的弊端：&lt;br/&gt;当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的额运行效率&lt;/p&gt;

</description>
<pubDate>Sat, 07 Jul 2018 15:51:00 +0000</pubDate>
<dc:creator>python修行路</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhaof/p/9278865.html</dc:identifier>
</item>
<item>
<title>MySQL中间件之ProxySQL(2)：初试读写分离 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9278839.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9278839.html</guid>
<description>&lt;p&gt;这里通过一个简单的示例实现ProxySQL的读写分离功能，算是ProxySQL的快速入门。即使是快速入门，需要配置的内容也很多，包括：后端MySQL配置、监控配置、发送SQL语句的用户、SQL语句的路由规则。所以，想要实现一个ProxySQL+MySQL，即使只实现最基本的功能，步骤也是挺多的，不过配置的逻辑都很简单。&lt;/p&gt;
&lt;p&gt;实验环境：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Proxysql&lt;/td&gt;
&lt;td&gt;192.168.100.21&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Master&lt;/td&gt;
&lt;td&gt;192.168.100.22&lt;/td&gt;
&lt;td&gt;110&lt;/td&gt;
&lt;td&gt;刚安装的全新MySQL实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Slave1&lt;/td&gt;
&lt;td&gt;192.168.100.23&lt;/td&gt;
&lt;td&gt;120&lt;/td&gt;
&lt;td&gt;刚安装的全新MySQL实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Slave2&lt;/td&gt;
&lt;td&gt;192.168.100.24&lt;/td&gt;
&lt;td&gt;130&lt;/td&gt;
&lt;td&gt;刚安装的全新MySQL实例&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201807/733013-20180707232048823-185148.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了演示完整的过程，这里把后端MySQL主从复制的基本配置步骤也列出来了。如了解配置过程，可跳过主从配置的部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意点：slave节点需要设置&lt;/strong&gt;&lt;code&gt;read_only=1&lt;/code&gt;。如果后端是PXC/MGR/MariaDB Galera，则无需手动设置，因为会自动设置。&lt;/p&gt;

&lt;h2 id=&quot;配置后端的主从复制&quot;&gt;1.1 配置后端的主从复制&lt;/h2&gt;
&lt;p&gt;提供3个MySQL节点的配置文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 以下是Master的配置文件
[mysqld]
datadir=/data
socket=/data/mysql.sock
server-id=110            
log-bin=/data/master-bin 
sync-binlog=1            
log-error=/data/error.log
pid-file=/data/mysqld.pid


# 以下是slave1的配置文件
[mysqld]
datadir=/data
socket=/data/mysql.sock  
server-id=120            
relay_log=/data/relay-log
log-error=/data/error.log
pid-file=/data/mysqld.pid
read_only=1

# 以下是slave2的配置文件
[mysqld]
datadir=/data
socket=/data/mysql.sock
server-id=130            
relay_log=/data/relay-log
log-error=/data/error.log
pid-file=/data/mysqld.pid
read_only=1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为3个MySQL节点提供数据目录/data&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mkdir /data
chown -R mysql.mysql /data&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化三个MySQL节点。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mysqld --initialize-insecure --user=mysql --datadir=/data&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动3个MySQL节点的mysqld服务。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;systemctl start mysqld&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;连上master，修改root密码，创建用于复制的用户repl。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;# 以下在master上执行
mysql&amp;gt; alter user root@localhost identified by 'P@ssword1!';

mysql&amp;gt; create user repl@'192.168.100.%' identified by 'P@ssword1!';
mysql&amp;gt; grant replication slave on *.* to repl@'192.168.100.%';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;连上两个slave，开启复制线程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 以下在两个slave节点上都执行
change master to 
    master_host='192.168.100.22',
    master_user='repl',
    master_password='P@ssword1!',
    master_port=3306,
    master_log_file='master-bin.000001',
    master_log_pos=4;

start slave;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如此配置之后，3个MySQL节点就保持了同步。&lt;/p&gt;

&lt;h2 id=&quot;向proxysql中添加mysql节点&quot;&gt;1.2 向ProxySQL中添加MySQL节点&lt;/h2&gt;
&lt;p&gt;首先启动ProxySQL。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;service proxysql start&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动后会监听两个端口，默认为6032和6033。6032端口是ProxySQL的管理端口，6033是ProxySQL对外提供服务的端口。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@s1 ~]# netstat -tnlp
Active Internet connections (only servers)
Proto Recv-Q Send-Q Local Address  Foreign Address  State   PID/Program name
tcp        0      0 0.0.0.0:6032   0.0.0.0:*        LISTEN  1231/proxysql   
tcp        0      0 0.0.0.0:6033   0.0.0.0:*        LISTEN  1231/proxysql   
tcp        0      0 0.0.0.0:22     0.0.0.0:*        LISTEN  1152/sshd       
tcp        0      0 127.0.0.1:25   0.0.0.0:*        LISTEN  2151/master     
tcp6       0      0 :::22          :::*             LISTEN  1152/sshd       
tcp6       0      0 ::1:25         :::*             LISTEN  2151/master  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用mysql客户端连接到ProxySQL的管理接口(admin interface)，该接口的默认管理员用户和密码都是admin。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@s1 ~]# mysql -uadmin -padmin -P6032 -h127.0.0.1 --prompt 'admin&amp;gt; '&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我这里重新设置了提示符。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;admin&amp;gt; show databases;
+-----+---------------+-------------------------------------+
| seq | name          | file                                |
+-----+---------------+-------------------------------------+
| 0   | main          |                                     |
| 2   | disk          | /var/lib/proxysql/proxysql.db       |
| 3   | stats         |                                     |
| 4   | monitor       |                                     |
| 5   | stats_history | /var/lib/proxysql/proxysql_stats.db |
+-----+---------------+-------------------------------------+
5 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ProxySQL提供了几个库，每个库都有各自的意义。本文只是快速入门文章，不会详细介绍每个库中的每个表以及每个字段，不过在接下来的文章中，我会详细介绍到每个字段，因为每个字段都重要。&lt;/p&gt;
&lt;p&gt;在本文，主要修改main和monitor数据库中的表。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;admin&amp;gt; show tables from main;
+--------------------------------------------+
| tables                                     |
+--------------------------------------------+
| global_variables                           |
| mysql_collations                           |
| mysql_group_replication_hostgroups         |
| mysql_query_rules                          |
| mysql_query_rules_fast_routing             |
| mysql_replication_hostgroups               |
| mysql_servers                              |
| mysql_users                                |
| proxysql_servers                           |
| runtime_checksums_values                   |
| runtime_global_variables                   |
| runtime_mysql_group_replication_hostgroups |
| runtime_mysql_query_rules                  |
| runtime_mysql_query_rules_fast_routing     |
| runtime_mysql_replication_hostgroups       |
| runtime_mysql_servers                      |
| runtime_mysql_users                        |
| runtime_proxysql_servers                   |
| runtime_scheduler                          |
| scheduler                                  |
+--------------------------------------------+

admin&amp;gt; show tables from monitor;
+------------------------------------+
| tables                             |
+------------------------------------+
| mysql_server_connect_log           |
| mysql_server_group_replication_log |
| mysql_server_ping_log              |
| mysql_server_read_only_log         |
| mysql_server_replication_lag_log   |
+------------------------------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;runtime_&lt;/code&gt;开头的是运行时的配置，这些是不能修改的。要修改ProxySQL的配置，需要修改了非&lt;code&gt;runtime_&lt;/code&gt;表，修改后必须执行&lt;code&gt;LOAD ... TO RUNTIME&lt;/code&gt;才能加载到RUNTIME生效，执行&lt;code&gt;save ... to disk&lt;/code&gt;才能将配置持久化保存到磁盘。具体操作见后文。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;insert into mysql_servers(hostgroup_id,hostname,port) values(10,'192.168.100.22',3306);
insert into mysql_servers(hostgroup_id,hostname,port) values(10,'192.168.100.23',3306);
insert into mysql_servers(hostgroup_id,hostname,port) values(10,'192.168.100.24',3306);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注：上面语句中没有先切换到main库也执行成功了，因为ProxySQL内部使用的SQLite3数据库引擎，和MySQL的解析方式是不一样的。即使执行了&lt;code&gt;USE main&lt;/code&gt;语句也是无任何效果的，但不会报错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;查看这3个节点是否插入成功，以及它们的状态。请认真读一读每个字段的名称，混个眼熟。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;admin&amp;gt; select * from mysql_servers\G
*************************** 1. row ***************************
       hostgroup_id: 10
           hostname: 192.168.100.22
               port: 3306
             status: ONLINE
             weight: 1
        compression: 0
    max_connections: 1000
max_replication_lag: 0
            use_ssl: 0
     max_latency_ms: 0
            comment: 
*************************** 2. row ***************************
       hostgroup_id: 10
           hostname: 192.168.100.23
               port: 3306
             status: ONLINE
             weight: 1
        compression: 0
    max_connections: 1000
max_replication_lag: 0
            use_ssl: 0
     max_latency_ms: 0
            comment: 
*************************** 3. row ***************************
       hostgroup_id: 10
           hostname: 192.168.100.24
               port: 3306
             status: ONLINE
             weight: 1
        compression: 0
    max_connections: 1000
max_replication_lag: 0
            use_ssl: 0
     max_latency_ms: 0
            comment: 
3 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改后，加载到RUNTIME，并保存到disk。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;load mysql servers to runtime;
save mysql servers to disk;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;监控后端mysql节点&quot;&gt;1.3 监控后端MySQL节点&lt;/h2&gt;
&lt;p&gt;添加节点之后，还需要监控后端节点。对于后端是主从复制的环境来说，这是必须的，因为ProxySQL需要通过每个节点的&lt;code&gt;read_only&lt;/code&gt;值来自动调整它们是属于读组还是写组。&lt;/p&gt;
&lt;p&gt;首先在后端master节点上创建一个用于监控的用户名(只需在master上创建即可，因为会复制到slave上)，这个用户名只需具有&lt;code&gt;USAGE&lt;/code&gt;权限即可。如果还需要监控复制结构中slave是否严重延迟于master(先混个眼熟：这个俗语叫做&quot;拖后腿&quot;，术语叫做&quot;replication lag&quot;)，则还需具备&lt;code&gt;replication client&lt;/code&gt;权限。这里直接赋予这个权限。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;# 在master上执行：
mysql&amp;gt; create user monitor@'192.168.100.%' identified by 'P@ssword1!';
mysql&amp;gt; grant replication client on *.* to monitor@'192.168.100.%';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后回到ProxySQL上配置监控。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;set mysql-monitor_username='monitor';
set mysql-monitor_password='P@ssword1!';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上设置实际上是在修改global_variables表，它和下面两个语句是等价的：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;UPDATE global_variables SET variable_value='monitor'
 WHERE variable_name='mysql-monitor_username';

UPDATE global_variables SET variable_value='P@ssword1!'
 WHERE variable_name='mysql-monitor_password';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改后，加载到RUNTIME，并保存到disk。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;load mysql variables to runtime;
save mysql variables to disk;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;验证监控结果：ProxySQL监控模块的指标都保存在monitor库的log表中。&lt;/p&gt;
&lt;p&gt;以下是连接是否正常的监控(对connect指标的监控)：(在前面可能会有很多connect_error，这是因为没有配置监控信息时的错误，配置后如果connect_error的结果为NULL则表示正常)&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;admin&amp;gt; select * from mysql_server_connect_log;
+----------------+------+------------------+-------------------------+---------------+
| hostname       | port | time_start_us    | connect_success_time_us | connect_error |
+----------------+------+------------------+-------------------------+---------------+
| 192.168.100.22 | 3306 | 1530968712977867 | 4174                    | NULL          |
| 192.168.100.23 | 3306 | 1530968712988986 | 4908                    | NULL          |
| 192.168.100.24 | 3306 | 1530968713000074 | 3044                    | NULL          |
| 192.168.100.22 | 3306 | 1530968772978982 | 3407                    | NULL          |
| 192.168.100.23 | 3306 | 1530968772989627 | 3404                    | NULL          |
| 192.168.100.24 | 3306 | 1530968773000778 | 3444                    | NULL          |
+----------------+------+------------------+-------------------------+---------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是对心跳信息的监控(对ping指标的监控)：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;admin&amp;gt; select * from mysql_server_ping_log;       
+----------------+------+------------------+----------------------+-------------+
| hostname       | port | time_start_us    | ping_success_time_us | ping_error  |
+----------------+------+------------------+----------------------+-------------+
| 192.168.100.22 | 3306 | 1530968712666540 | 452                  | NULL        |
| 192.168.100.23 | 3306 | 1530968712668779 | 458                  | NULL        |
| 192.168.100.24 | 3306 | 1530968712671541 | 324                  | NULL        |
| 192.168.100.22 | 3306 | 1530968722667071 | 1190                 | NULL        |
| 192.168.100.23 | 3306 | 1530968722669574 | 1162                 | NULL        |
| 192.168.100.24 | 3306 | 1530968722673162 | 1380                 | NULL        |
| 192.168.100.22 | 3306 | 1530968732668840 | 1065                 | NULL        |
| 192.168.100.23 | 3306 | 1530968732670709 | 1054                 | NULL        |
| 192.168.100.24 | 3306 | 1530968732672703 | 1040                 | NULL        |
+----------------+------+------------------+----------------------+-------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，read_only和replication_lag的监控日志都为空。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;admin&amp;gt; select * from mysql_server_read_only_log;
Empty set (0.00 sec)

admin&amp;gt; select * from mysql_server_replication_lag_log;
Empty set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是因为还没有对ProxySQL中的节点分组：writer_hostgroup、reader_hostgroup。设置分组信息，需要修改的是main库中的mysql_replication_hostgroups表，该表只有3个字段：第一个字段名为writer_hostgroup，第二个字段为reader_hostgroup，第三个字段为注释字段，可随意写。&lt;/p&gt;
&lt;p&gt;例如，指定写组的id为10，读组的id为20。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;insert into mysql_replication_hostgroups values(10,20);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在该配置加载到RUNTIME生效之前，先查看下各mysql server所在的组。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;admin&amp;gt; select hostgroup_id,hostname,port,status,weight from mysql_servers; 
+--------------+----------------+------+--------+--------+
| hostgroup_id | hostname       | port | status | weight |
+--------------+----------------+------+--------+--------+
| 10           | 192.168.100.22 | 3306 | ONLINE | 1      |
| 10           | 192.168.100.23 | 3306 | ONLINE | 1      |
| 10           | 192.168.100.24 | 3306 | ONLINE | 1      |
+--------------+----------------+------+--------+--------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3个节点都在hostgroup_id=10的组中。&lt;/p&gt;
&lt;p&gt;现在，将刚才&lt;code&gt;mysql_replication_hostgroups&lt;/code&gt;表的修改加载到RUNTIME生效。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;load mysql servers to runtime;
save mysql servers to disk;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;一加载，Monitor模块就会开始监控后端的read_only值，当监控到read_only值后，就会按照read_only的值将某些节点自动移动到读/写组。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，此处所有节点都在&lt;code&gt;id=10&lt;/code&gt;的写组，slave1和slave2都是slave，它们的read_only=1，这两个节点将会移动到&lt;code&gt;id=20&lt;/code&gt;的组。如果一开始这3节点都在&lt;code&gt;id=20&lt;/code&gt;的读组，那么移动的将是Master节点，会移动到&lt;code&gt;id=10&lt;/code&gt;的写组。&lt;/p&gt;
&lt;p&gt;看结果：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;admin&amp;gt; select hostgroup_id,hostname,port,status,weight from mysql_servers;
+--------------+----------------+------+--------+--------+
| hostgroup_id | hostname       | port | status | weight |
+--------------+----------------+------+--------+--------+
| 10           | 192.168.100.22 | 3306 | ONLINE | 1      |
| 20           | 192.168.100.23 | 3306 | ONLINE | 1      |
| 20           | 192.168.100.24 | 3306 | ONLINE | 1      |
+--------------+----------------+------+--------+--------+&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;admin&amp;gt; select * from mysql_server_read_only_log;
+----------------+------+------------------+-----------------+-----------+--------+
| hostname       | port | time_start_us    | success_time_us | read_only | error  |
+----------------+------+------------------+-----------------+-----------+--------+
| 192.168.100.22 | 3306 | 1530970372197917 | 8487            | 0         | NULL   |
| 192.168.100.23 | 3306 | 1530970372198992 | 7907            | 1         | NULL   |
| 192.168.100.24 | 3306 | 1530970372199835 | 8064            | 1         | NULL   |
| 192.168.100.22 | 3306 | 1530970373698824 | 10078           | 0         | NULL   |
| 192.168.100.23 | 3306 | 1530970373699825 | 9845            | 1         | NULL   |
| 192.168.100.24 | 3306 | 1530970373700786 | 10745           | 1         | NULL   |
+----------------+------+------------------+-----------------+-----------+--------+&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;配置mysql_users&quot;&gt;1.4 配置mysql_users&lt;/h2&gt;
&lt;p&gt;上面的所有配置都是关于后端MySQL节点的，现在可以配置关于SQL语句的，包括：发送SQL语句的用户、SQL语句的路由规则、SQL查询的缓存、SQL语句的重写等等。&lt;/p&gt;
&lt;p&gt;本小节是SQL请求所使用的用户配置，例如root用户。这要求我们需要先在后端MySQL节点添加好相关用户。这里以root和sqlsender两个用户名为例。&lt;/p&gt;
&lt;p&gt;首先，在master节点上执行：(只需master执行即可，会复制给两个slave)&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;grant all on *.* to root@'192.168.100.%' identified by 'P@ssword1!';
grant all on *.* to sqlsender@'192.168.100.%' identified by 'P@ssword1!';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后回到ProxySQL，配置mysql_users表，将刚才的两个用户添加到该表中。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;insert into mysql_users(username,password,default_hostgroup) values('root','P@ssword1!',10);
insert into mysql_users(username,password,default_hostgroup) values('sqlsender','P@ssword1!',10);
load mysql users to runtime;
save mysql users to disk;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mysql_users表有不少字段，最主要的三个字段为&lt;code&gt;username&lt;/code&gt;、&lt;code&gt;password&lt;/code&gt;和&lt;code&gt;default_hostgroup&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;username&lt;/strong&gt;：前端连接ProxySQL，以及ProxySQL将SQL语句路由给MySQL所使用的用户名。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;password&lt;/strong&gt;：用户名对应的密码。可以是明文密码，也可以是hash密码。如果想使用hash密码，可以先在某个MySQL节点上执行&lt;code&gt;select password(PASSWORD)&lt;/code&gt;，然后将加密结果复制到该字段。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;default_hostgroup&lt;/strong&gt;：该用户名默认的路由目标。例如，指定root用户的该字段值为10时，则使用root用户发送的SQL语句默认情况下将路由到&lt;code&gt;hostgroup_id=10&lt;/code&gt;组中的某个节点。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;admin&amp;gt; select * from mysql_users\G
*************************** 1. row ***************************
              username: root
              password: P@ssword1!
                active: 1            #  注意本行
               use_ssl: 0
     default_hostgroup: 10
        default_schema: NULL
         schema_locked: 0
transaction_persistent: 1            #  注意本行
          fast_forward: 0
               backend: 1
              frontend: 1
       max_connections: 10000
*************************** 2. row ***************************
              username: sqlsender
              password: P@ssword1!
                active: 1
               use_ssl: 0
     default_hostgroup: 10
        default_schema: NULL
         schema_locked: 0
transaction_persistent: 1
          fast_forward: 0
               backend: 1
              frontend: 1
       max_connections: 10000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然本文不详细介绍mysql_users表，但上面标注了&quot;注意本行&quot;的两个字段必须要引起注意。&lt;/p&gt;
&lt;p&gt;只有&lt;code&gt;active=1&lt;/code&gt;的用户才是有效的用户。&lt;/p&gt;
&lt;p&gt;至于&lt;code&gt;transaction_persistent&lt;/code&gt;字段，当它的值为1时，表示事务持久化：当某连接使用该用户开启了一个事务后，那么在事务提交/回滚之前，所有的语句都路由到同一个组中，避免语句分散到不同组。在以前的版本中，默认值为0，不知道从哪个版本开始，它的默认值为1。我们期望的值为1，所以在继续下面的步骤之前，先查看下这个值，如果为0，则执行下面的语句修改为1。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;update mysql_users set transaction_persistent=1 where username='root';
update mysql_users set transaction_persistent=1 where username='sqlsender';
load mysql users to runtime;
save mysql users to disk;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，另开一个终端，分别使用root用户和sqlsender用户测试下它们是否能路由到默认的&lt;code&gt;hostgroup_id=10&lt;/code&gt;(它是一个写组)读、写数据。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@s1 ~]# mysql -uroot -pP@ssword1! -P6033 -h127.0.0.1 -e &quot;select @@server_id&quot;
+-------------+
| @@server_id |
+-------------+
|         110 |
+-------------+

[root@s1 ~]# mysql -uroot -pP@ssword1! -P6033 -h127.0.0.1 -e &quot;create database proxy_test&quot;

[root@s1 ~]# mysql -uroot -pP@ssword1! -P6033 -h127.0.0.1 -e &quot;show databases;&quot;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| proxy_test         |
| sys                |
+--------------------+

[root@s1 ~]# mysql -usqlsender -pP@ssword1! -P6033 -h127.0.0.1 -e '\
                        use proxy_test;\
                        create table t(id int);' 

[root@s1 ~]# mysql -usqlsender -pP@ssword1! -P6033 -h127.0.0.1 -e 'show tables from proxy_test;'
+-------------------------+
| Tables_in_proxy_test    |
+-------------------------+
| t                       |
+-------------------------+&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;读写分离配置路由规则&quot;&gt;1.5 读写分离：配置路由规则&lt;/h2&gt;
&lt;p&gt;ProxySQL的路由规则非常灵活，可以基于用户、基于schema以及基于每个语句实现路由规则的定制。&lt;/p&gt;
&lt;p&gt;本文作为入门文章，实现一个最简单的语句级路由规则，从而实现读写分离。&lt;strong&gt;必须注意，这只是实验，实际的路由规则绝不应该仅根据所谓的读、写操作进行分离，而是从各项指标中找出压力大、执行频繁的语句单独写规则、做缓存等等&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;和查询规则有关的表有两个：&lt;code&gt;mysql_query_rules&lt;/code&gt;和&lt;code&gt;mysql_query_rules_fast_routing&lt;/code&gt;，后者是前者的扩展表，1.4.7之后才支持该快速路由表。本文只介绍第一个表。&lt;/p&gt;
&lt;p&gt;插入两个规则，目的是将select语句分离到&lt;code&gt;hostgroup_id=20&lt;/code&gt;的读组，但由于select语句中有一个特殊语句&lt;code&gt;SELECT...FOR UPDATE&lt;/code&gt;它会申请写锁，所以应该路由到&lt;code&gt;hostgroup_id=10&lt;/code&gt;的写组。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;insert into mysql_query_rules(rule_id,active,match_digest,destination_hostgroup,apply)
VALUES (1,1,'^SELECT.*FOR UPDATE$',10,1),
       (2,1,'^SELECT',20,1);

load mysql query rules to runtime;
save mysql query rules to disk;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;select ... for update&lt;/code&gt;规则的rule_id必须要小于普通的select规则的rule_id，因为ProxySQL是根据rule_id的顺序进行规则匹配的。&lt;/p&gt;
&lt;p&gt;再来测试下，读操作是否路由给了&lt;code&gt;hostgroup_id=20&lt;/code&gt;的读组。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@s1 ~]# mysql -uroot -pP@ssword1! -P6033 -h127.0.0.1 -e 'select @@server_id'
mysql: [Warning] Using a password on the command line interface can be insecure.
+-------------+
| @@server_id |
+-------------+
|         120 |
+-------------+

[root@s1 ~]# mysql -uroot -pP@ssword1! -P6033 -h127.0.0.1 -e 'select @@server_id'
mysql: [Warning] Using a password on the command line interface can be insecure.
+-------------+
| @@server_id |
+-------------+
|         130 |
+-------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读操作已经路由给读组，再看看写操作。这里以事务持久化进行测试。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@s1 ~]# mysql -uroot -pP@ssword1! -P6033 -h127.0.0.1 -e '\
                        start transaction;\
                        select @@server_id;\
                        commit;\
                        select @@server_id;'

+-------------+
| @@server_id |
+-------------+
|         110 |
+-------------+
+-------------+
| @@server_id |
+-------------+
|         120 |
+-------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，一切都按照预期进行。&lt;/p&gt;
&lt;p&gt;最后，如果想查看路由的信息，可查询stats库中的&lt;code&gt;stats_mysql_query_digest&lt;/code&gt;表。以下是该表的一个输出格式示例(和本文无关)。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;admin&amp;gt; SELECT hostgroup hg,
              sum_time,
              count_star,
              digest_text 
       FROM stats_mysql_query_digest
       ORDER BY sum_time DESC;
+----+----------+------------+-------------------------------------------------------------+
| hg | sum_time | count_star | digest_text                                                 |
+----+----------+------------+-------------------------------------------------------------+
| 2  | 14520738 | 50041      | SELECT c FROM sbtest1 WHERE id=?                            |
| 1  | 3142041  | 5001       | COMMIT                                                      |
| 1  | 2270931  | 5001       | SELECT c FROM sbtest1 WHERE id BETWEEN ? AND ?+? ORDER BY c |
| 1  | 2021320  | 5003       | SELECT c FROM sbtest1 WHERE id BETWEEN ? AND ?+?            |
| 1  | 1768748  | 5001       | UPDATE sbtest1 SET k=k+? WHERE id=?                         |
| 1  | 1697175  | 5003       | SELECT SUM(K) FROM sbtest1 WHERE id BETWEEN ? AND ?+?       |
| 1  | 1346791  | 5001       | UPDATE sbtest1 SET c=? WHERE id=?                           |
| 1  | 1263259  | 5001       | DELETE FROM sbtest1 WHERE id=?                              |
| 1  | 1191760  | 5001       | INSERT INTO sbtest1 (id, k, c, pad) VALUES (?, ?, ?, ?)     |
| 1  | 875343   | 5005       | BEGIN                                                       |
+----+----------+------------+-------------------------------------------------------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，MySQL的读写分离尝鲜结束。该系列后面的文章将详细介绍ProxySQL的各个方面。&lt;/p&gt;
</description>
<pubDate>Sat, 07 Jul 2018 15:36:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9278839.html</dc:identifier>
</item>
<item>
<title>聊一个自己写的MVC框架 - jolivan</title>
<link>http://www.cnblogs.com/Jolivan/p/9275459.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jolivan/p/9275459.html</guid>
<description>&lt;p&gt;　　也有个一周没有更新博客了，其实我没有偷懒，因为之前一直在看Spring源码，所以想着去写一个类Spring的框架，也没有给自己定什么高的要求，简单实现MVC、AOP、IOC等功能就行。现在这个框架基本上已经成型了，自己也测试过了，因此拿出来和大家分享一下。&lt;/p&gt;
&lt;p&gt;　　我本文就不写标题了，因为自己的思路是跟着代码走的，所以可能说着说着MVC就跳到DI那一块了。首先我在开始的时候，也是跟随着大部分人的思路，先从DispatcherServlet入手。因为为DispatcherServlet是和用户交互的。和DispatcherServlet交互的有四个模块，分别是：HandlerMapping、HandlerAdapter、ViewResolver、ModelAndView，我定义了四个类分别对应着这四个模块，先不说他们是怎么工作的，先聊一下DispatcherServlet。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1204324/201807/1204324-20180706200335527-544316209.png&quot; alt=&quot;&quot; width=&quot;646&quot; height=&quot;476&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　它和HandlerMapping先进行交互，然后HandlerMapping处理拿到对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initHandlerMappings(LusheApplicationContext context) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按照我们通常的理解应该是一个Map，Map&amp;lt;String,Method&amp;gt; map;map.put(url,Method)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先从容器中取到所有的实例&lt;/span&gt;
        String [] beanNames =&lt;span&gt; context.getBeanDefinitionNames();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String beanName : beanNames) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;到了MVC层，对外提供的方法只有一个getBean方法&lt;/span&gt;
                Object proxy =&lt;span&gt; context.getBean(beanName);
                Object originObject &lt;/span&gt;=&lt;span&gt; LusheAopProxyUtils.getOriginObject(proxy);

                Class&lt;/span&gt;&amp;lt;?&amp;gt; clazz =&lt;span&gt; originObject.getClass();

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!clazz.isAnnotationPresent(Controller.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }

                String baseUrl &lt;/span&gt;= &quot;&quot;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (clazz.isAnnotationPresent(RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
                    RequestMapping requestMapping &lt;/span&gt;= clazz.getAnnotation(RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                    baseUrl &lt;/span&gt;=&lt;span&gt; requestMapping.value();
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;扫描所有的public方法&lt;/span&gt;
                Method[] methods =&lt;span&gt; clazz.getMethods();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Method method : methods) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!method.isAnnotationPresent(RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }

                    RequestMapping requestMapping &lt;/span&gt;= method.getAnnotation(RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                    String regex &lt;/span&gt;= (&quot;/&quot; + baseUrl + requestMapping.value().replaceAll(&quot;\\*&quot;, &quot;.*&quot;)).replaceAll(&quot;/+&quot;, &quot;/&quot;&lt;span&gt;);
                    Pattern pattern &lt;/span&gt;=&lt;span&gt; Pattern.compile(regex);
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handlerMappings.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LusheHandlerMapping(pattern, originObject, method));
                    System.out.println(&lt;/span&gt;&quot;Mapping: &quot; + regex + &quot; , &quot; +&lt;span&gt; method);
                }
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            e.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我是这么处理的，我只给Servlet获得实例的接口，然后再让它来解析这些实例，放到定义好的HandlerMapping数组中。那么这里就要考虑给getBean的类了，之前在Spring中他们是在一个终极父类里定义到了这个方法，我的处理是简化，直接定义一个ApplicationContext，把它当做BeanFactory，所有的处理都在这里面进行，对外给出getBean方法。那么来看一下ApplicationContext这个类。按照Spring的思想，首先是定义一个refresh方法，它的作用就是：根据XML文件定义的属性来进行IOC容器的初始化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; refresh(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定位&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.reader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeanDefinitionReader(configureLocations);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载&lt;/span&gt;
        List&amp;lt;String&amp;gt; beanDefinitions = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.reader.loadBeanDefinitions();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册&lt;/span&gt;
&lt;span&gt;        doRegisty(beanDefinitions);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;依赖注入(lazy-init = false),自动调用getBean方法&lt;/span&gt;
&lt;span&gt;        doDependencyInjection();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我按照定位、加载、注册和依赖注入四部分来处理。首先是定位，就是对配置文件进行定位读取解析，这里自己定义了一个BeanDefinitionReader的类，把配置文件存放在它内部一个Properties变量中。并且把配置文件中划好的包中的类给拿出来，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doScanner(String packName) {
        URL url &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.getClass().getClassLoader().getResource(&quot;/&quot; + packName.replaceAll(&quot;\\.&quot;,&quot;/&quot;&lt;span&gt;));

        File classDir &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(url.getFile());

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(File file : classDir.listFiles()) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(file.isDirectory()) {
                doScanner(packName &lt;/span&gt;+ &quot;.&quot; +&lt;span&gt; file.getName());
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                registyBeanClasses.add(packName &lt;/span&gt;+ &quot;.&quot; + file.getName().replace(&quot;.class&quot;,&quot;&quot;&lt;span&gt;));
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后是加载，在BeanDefinitionReader里，我将属性和类名做成一个Map，存放起来。之后就是注册，还是在BeanDefinitionReader中，因为我之前已经将属性和名称做成了一个Map，这样我可以通过类名就能得到它对应的BeanDefinition。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LusheBeanDefinition registerBean(String className) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.registyBeanClasses.contains(className)) {
            LusheBeanDefinition lusheBeanDefinition &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LusheBeanDefinition();
            lusheBeanDefinition.setBeanClassName(className);
            lusheBeanDefinition.setFactoryBeanName(StringUtils.lowerFirstCase(className.substring(className.lastIndexOf(&lt;/span&gt;&quot;.&quot;) + 1&lt;span&gt;)));
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; lusheBeanDefinition;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　回到ApplicationContext的refresh方法，把我们所有定义好的BeanDefinition放到BeanDefinitionMap中，也就是Spring的Cache里。因为之前只是将所有的BeanDefinition放进去，还没有做进一步的处理，因此就在这一块进行处理了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doRegisty(List&amp;lt;String&amp;gt;&lt;span&gt; beanDefinitions){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(String className : beanDefinitions) {
                Class&lt;/span&gt;&amp;lt;?&amp;gt; beanClass =&lt;span&gt; Class.forName(className);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是不是接口，如果是接口，则用其实现类来实现&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(beanClass.isInterface()) {
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;beanName 为类名首字母小写
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义beanName&lt;/span&gt;
                LusheBeanDefinition lusheBeanDefinition = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.reader.registerBean(className);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(lusheBeanDefinition != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    beanDefinitionMap.put(lusheBeanDefinition.getFactoryBeanName(), lusheBeanDefinition);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接口注入&lt;/span&gt;
                Class&amp;lt;?&amp;gt;[] interfaces =&lt;span&gt; beanClass.getInterfaces();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(Class&amp;lt;?&amp;gt;&lt;span&gt; interf : interfaces) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多个接口功能相同
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果多个属性类只能覆盖，因为Spring没有那么智能&lt;/span&gt;
                    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanDefinitionMap.put(interf.getName(), lusheBeanDefinition);
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先看看是不是个接口，如果是，就直接跳过，因为我会在后面给每个类的每个接口赋予相同的BeanDefinition，这里的确有一点瑕疵，但是我也在思考更好地处理办法。最后我得到的BeanDefinitionMap，这里注册的功能就完成了。&lt;/p&gt;
&lt;p&gt;　　然后就是依赖注入这块，我是这么做的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; populateBean(String beanName, Object instance) {
        Class clazz &lt;/span&gt;=&lt;span&gt; instance.getClass();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(clazz.isAnnotationPresent(Controller.&lt;span&gt;class&lt;/span&gt;) || clazz.isAnnotationPresent(Service.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取所有字段&lt;/span&gt;
            Field[] fields =&lt;span&gt; clazz.getDeclaredFields();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Field field : fields) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(field.isAnnotationPresent(AutoWried.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
                    AutoWried autoWried &lt;/span&gt;= field.getAnnotation(AutoWried.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                    String autoWriedBeanName &lt;/span&gt;=&lt;span&gt; autoWried.value().trim();

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(autoWriedBeanName.equals(&quot;&quot;&lt;span&gt;)) {
                        autoWriedBeanName &lt;/span&gt;=&lt;span&gt; field.getType().getName();
                    }

                    field.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        field.set(instance,&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.beanWrapperMap.get(autoWriedBeanName).getWrapperInstance());
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IllegalAccessException e) {
                        e.printStackTrace();
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　先不说这个，因为这里我们还没有得到Instance，我是通过反射获得的这个实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object instantionBean(LusheBeanDefinition lusheBeanDefinition) {
        String className &lt;/span&gt;=&lt;span&gt; lusheBeanDefinition.getBeanClassName();
        Object beanInstance &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;beanCacheMap.containsKey(className)) {
                    Class&lt;/span&gt;&amp;lt;?&amp;gt; clazz =&lt;span&gt; Class.forName(className);
                    beanInstance &lt;/span&gt;=&lt;span&gt; clazz.newInstance();
                    beanCacheMap.put(className, beanInstance);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    beanInstance &lt;/span&gt;=&lt;span&gt; beanCacheMap.get(className);
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; beanInstance;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　然后再看一下依赖注入这一块，也就是populateBean，会传入一个bean的实例并拿到它的类，如果这个类已经声明为Controller或者Service类，那么就把它所有的字段拿出来，如果某个字段被标注为AutoWried，那么就从包装Map中把实例给拿出来，具体的实现就是这样的。&lt;/p&gt;
&lt;p&gt;　　上面提到包装类BeanWrapper,它的作用就是方便对其进行功能拓展，比如说增加AOP切点之类的。我是这么构造一个包装类实例的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LusheBeanWrapper(Object Instance) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加动态代理&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.wrapperInstance =&lt;span&gt; aopProxy.getProxy(Instance);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原始对象&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.originalInstance =&lt;span&gt; Instance;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我包装类的构造函数是传入一个原始类实例，然后并将这个实例保存起来，然后通过AOP模块的动态代理拿到包装类实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里传入原始对象，Spring中传入的事ClassLoader&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getProxy(Object object) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; object;
        Class&lt;/span&gt;&amp;lt;?&amp;gt; clazz = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.target.getClass();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Proxy.newProxyInstance(clazz.getClassLoader(),clazz.getInterfaces(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Spring中在Aop动态代理创建的时候传入的是ClassLoader，而我这里为了简便直观，传入的是原始类实例，然后拿到这个实例的类，并调用Proxy的newProxyInstance方法获得这个被代理对象。接下来就是讨论AOP是如何实现的，也就是如何对原始方法进行增强的。下面是我AopProxy类中invoke方法，它的作用就是对被代理对象切入点方法进行增强。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;之前&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(aopConfigure.contains(method)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于某个方法，看看是不是切入点&lt;/span&gt;
            LusheAopConfigure.LusheAspect aspect =&lt;span&gt; aopConfigure.get(method);

            aspect.getPoints()[&lt;/span&gt;0&lt;span&gt;].invoke(aspect.getAspect(),args);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反射调用原始方法&lt;/span&gt;
        Object obj = method.invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.target, args);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;之后&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(aopConfigure.contains(method)) {
            LusheAopConfigure.LusheAspect aspect &lt;/span&gt;=&lt;span&gt; aopConfigure.get(method);

            aspect.getPoints()[&lt;/span&gt;1&lt;span&gt;].invoke(aspect.getAspect(),args);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以考虑一下为什么这么写
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里面用到了循环&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先来解释一下AopConfigure这个类的作用，它是对ApplicationContext中expression的封装，对目标代理对象的一个方法增强，增强的方法就是自己定义逻辑。配置文件告诉我们哪些类哪些方法需要增强和需要增强的内容，我用一个Map去存放这些信息，key是目标对象的方法名，value是我自己定义的一个实体Bean，存放的用来增强的类和它的方法（这里我只是简单的定义了两个：before和after）。之后再回到上面的那个invoke方法，这里是这么处理的，首先看一下这个方法是不是一个需要增强的方法，如果是，那么先搞定before方法增强，然后这个方法的执行，最后执行方法后增强。&lt;/p&gt;
&lt;p&gt;　　最后再回到getBean，当我们使用到这个方法的时候，默认已经完成了IOC容器的初始化和AOP切面方法增强，最后getBean返回给DispatcherServlet的，并不是原始的BeanInstance，而是一个BeanWrapper的实例，换句话说，getBean的作用就是传入一个Bean的类名，然后读取BeanDefinition的信息，通过反射机制创建实例并返回。在这个框架中，用到了Spring中用到的思想，它用BeanMapper把原始Bean包装起来（具体怎么包装我在上面已经说了），然后作用是不仅保存了之前的OP关系，而且方便了之后的拓展和增强。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getBean(String beanName) {
        LusheBeanPostProcessor lusheBeanPostProcessor &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LusheBeanPostProcessor();

        LusheBeanDefinition lusheBeanDefinition &lt;/span&gt;=&lt;span&gt; beanDefinitionMap.get(beanName);
        Object beanInstance &lt;/span&gt;=&lt;span&gt; instantionBean(lusheBeanDefinition);
        lusheBeanPostProcessor.postProcessBeforeInitialization(beanInstance,beanName);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(beanInstance == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        LusheBeanWrapper lusheBeanWrapper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LusheBeanWrapper(beanInstance);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成通知事件&lt;/span&gt;

        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            lusheBeanWrapper.setAopConfigure(instantionAopConfigure(lusheBeanDefinition));
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }

        lusheBeanWrapper.setLusheBeanPostProcessor(lusheBeanPostProcessor);

        beanWrapperMap.put(beanName, lusheBeanWrapper);

        lusheBeanPostProcessor.postProcessAfterInitialization(beanInstance,beanName);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;populateBean(beanName,beanInstance);&lt;/span&gt;

        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; beanWrapperMap.get(beanName).getWrapperInstance();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先从已经初始化好的BeanDefinitionMap中拿到BeanDefinition，然后调用instantionBean方法拿到实例Bean（这个方法的介绍在上面），如果这个实例存在，那我们就对它进行包装并进行AOP方法切入点的增强（前提是有），并将生成的包装实例放在Map中保存，并返回包装器中的包装实例，可以肯定的说，实例的类不是原始类，而是一个动态代理生成的类，类似以$Proxy0这种。&lt;/p&gt;
&lt;p&gt;　　回到DispatcherServlet的initHandlerMapping方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initHandlerMappings(LusheApplicationContext context) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按照我们通常的理解应该是一个Map，Map&amp;lt;String,Method&amp;gt; map;map.put(url,Method)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先从容器中取到所有的实例&lt;/span&gt;
        String [] beanNames =&lt;span&gt; context.getBeanDefinitionNames();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String beanName : beanNames) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;到了MVC层，对外提供的方法只有一个getBean方法&lt;/span&gt;
                Object proxy =&lt;span&gt; context.getBean(beanName);
                Object originObject &lt;/span&gt;=&lt;span&gt; LusheAopProxyUtils.getOriginObject(proxy);

                Class&lt;/span&gt;&amp;lt;?&amp;gt; clazz =&lt;span&gt; originObject.getClass();

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!clazz.isAnnotationPresent(Controller.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }

                String baseUrl &lt;/span&gt;= &quot;&quot;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (clazz.isAnnotationPresent(RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
                    RequestMapping requestMapping &lt;/span&gt;= clazz.getAnnotation(RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                    baseUrl &lt;/span&gt;=&lt;span&gt; requestMapping.value();
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;扫描所有的public方法&lt;/span&gt;
                Method[] methods =&lt;span&gt; clazz.getMethods();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Method method : methods) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!method.isAnnotationPresent(RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
                        &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    }

                    RequestMapping requestMapping &lt;/span&gt;= method.getAnnotation(RequestMapping.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
                    String regex &lt;/span&gt;= (&quot;/&quot; + baseUrl + requestMapping.value().replaceAll(&quot;\\*&quot;, &quot;.*&quot;)).replaceAll(&quot;/+&quot;, &quot;/&quot;&lt;span&gt;);
                    Pattern pattern &lt;/span&gt;=&lt;span&gt; Pattern.compile(regex);
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.handlerMappings.add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; LusheHandlerMapping(pattern, originObject, method));
                    System.out.println(&lt;/span&gt;&quot;Mapping: &quot; + regex + &quot; , &quot; +&lt;span&gt; method);
                }
            }
        }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
            e.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们通过getBean拿到实例，然后拿到他的原始类实例，我是这么处理的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 找到代理对象的原始对象
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; proxy
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object getOriginObject(Object proxy) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是代理对象&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;isProxy(proxy)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxy;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getProxyTargetObject(proxy);
        }
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isProxy(Object object) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Proxy.isProxyClass(object.getClass());
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object getProxyTargetObject(Object proxy) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在代理模式中看到过，原始类的信息就被存放在类型为InvocationHandler的变量中，名字就叫h&lt;/span&gt;
        Field h = proxy.getClass().getSuperclass().getDeclaredField(&quot;h&quot;&lt;span&gt;);
        h.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        LusheAopProxy  aopProxy &lt;/span&gt;=&lt;span&gt; (LusheAopProxy)h.get(proxy);
        Field target &lt;/span&gt;= aopProxy.getClass().getDeclaredField(&quot;target&quot;&lt;span&gt;);
        target.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; target.get(proxy);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为在动态代理的过程中，原始类的信息就已经被存放在InvocationHandler中了，所以就很方便的拿到了。&lt;/p&gt;
&lt;p&gt;　　再回来，我首先判断一下这个类是不是Controller，不是就走了，是的话，再看一下它的方法中，哪个是RequestMapping方法，将他存放起来。&lt;/p&gt;
&lt;p&gt;　　然后是调用initHandlerAdapters方法，完成存放的方法的参数的处理。&lt;/p&gt;
&lt;p&gt;　　最后再说一下类是怎么和AOP配置匹配起来的，这里我建立了一个instantionAopConfigure方法，在建立BeanWrapper的时候调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; LusheAopConfigure instantionAopConfigure(LusheBeanDefinition beanDefinition) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        LusheAopConfigure aopConfigure &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LusheAopConfigure();
        String expression &lt;/span&gt;= reader.getConfigure().getProperty(&quot;pointCut&quot;&lt;span&gt;);

        String[] before &lt;/span&gt;= reader.getConfigure().getProperty(&quot;aspectBefore&quot;).split(&quot;\\#&quot;&lt;span&gt;);
        String[] after &lt;/span&gt;= reader.getConfigure().getProperty(&quot;aspectAfter&quot;).split(&quot;\\#&quot;&lt;span&gt;);

        String className &lt;/span&gt;=&lt;span&gt; beanDefinition.getBeanClassName();

        Class&lt;/span&gt;&amp;lt;?&amp;gt; clazz =&lt;span&gt; Class.forName(className);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析成正则去匹配&lt;/span&gt;
        Pattern pattern =&lt;span&gt; Pattern.compile(expression);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指出切面类,因为我们在上面已经将切面方法的位置分成了两部分，第一部分是包类名，第二部分是方法名
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因此我们这里就取第一部分就可以了，然后因为两个切面方法属于一个类，为了方便，就拿第一个就可以了。&lt;/span&gt;
        Class&amp;lt;?&amp;gt; aspectClass = Class.forName(before[0&lt;span&gt;]);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿出被代理类的所有方法
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;举例：com.spring.test.LusheMVC.framework.context.LusheApplication.getBean(java.lang.String)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;而我们的正则是：
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;public.* com\.spring\.test\.LusheMVC\.demo\.service\..*ServiceImpl\..*\(.*\)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个肯定匹配不上 而
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;com.spring.test.LusheMVC.demo.service.impl.DemoServiceImpl.get(java.lang.String)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个就匹配上了&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Method method : clazz.getMethods()) {
            Matcher matcher &lt;/span&gt;=&lt;span&gt; pattern.matcher(method.toString());

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果匹配上了&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(matcher.matches()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把能满足切面规则的类添加到AOP配置中&lt;/span&gt;
&lt;span&gt;                aopConfigure.put(method,clazz.newInstance()
                        ,&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Method[]{aspectClass.getMethod(before[1]),aspectClass.getMethod(after[1&lt;span&gt;])});
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; aopConfigure;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先拿到切点类的定义，用来做正则判断，格式类似于&lt;span&gt;public.* com\.spring\.test\.LusheMVC\.demo\.service\..*ServiceImpl\..*\(.*\)，&lt;span&gt;然后拿出增强内容方法的信息（就是before和after的信息），并将它们处理到String数组里，第一个位置放的是类名，第二个是方法名。然后将BeanDefinition中存放的类名拿出来生成这个类的Class，将起所有方法拿出来进行正则匹配，如果匹配到了，说明这个方法是个切入点，需要被增强，那么就将这个信息存起来，处理完所有的之后，将这些内容给BeanWrapper，它会在AOP的时候用到。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　差不多就说这些吧，如果有补充我会更新的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 07 Jul 2018 14:56:00 +0000</pubDate>
<dc:creator>jolivan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Jolivan/p/9275459.html</dc:identifier>
</item>
<item>
<title>补习系列-springboot项目基础搭建课 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/9278686.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/9278686.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;springboot 最近火的不行，目前几乎已经是 spring 家族最耀眼的项目了。抛开微服务、技术社区这些推广因素不说，框架本身的确有非常多的优点。比如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;更简化的配置，摒除了许多繁杂的xml配置(事实证明，越简单的东西越容易让人记住)；&lt;/li&gt;
&lt;li&gt;内置Servlet容器，不再依赖外部环境&lt;/li&gt;
&lt;li&gt;大量的starter模块，随手拈来&lt;/li&gt;
&lt;li&gt;支持热部署&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;作为一名老程序员来说，仍然需要保持一个积极学习的态度。&lt;br/&gt;哎，简单点说就是少点伤感，认清现实。你曾经引以为傲的某某EE 技术已经被颠覆了，赶紧换车道 .....&lt;/p&gt;
&lt;p&gt;废话不多说，以下内容主要讲的是怎么利用springboot 这个脚手架搭建一个最精简的项目。&lt;br/&gt;其中几个模块会非常实用，这包括结构、配置、日志、部署..&lt;/p&gt;
&lt;h2 id=&quot;一基础结构&quot;&gt;一、基础结构&lt;/h2&gt;
&lt;p&gt;springboot 项目仍然是使用maven 进行初始化及构建，下面是一个典型的结构：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;pom.xml&lt;/td&gt;
&lt;td&gt;依赖文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;src/main/java&lt;/td&gt;
&lt;td&gt;代码目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;src/main/resources&lt;/td&gt;
&lt;td&gt;配置目录，包含application.properties、log4j2.xml&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;src/main/build&lt;/td&gt;
&lt;td&gt;定义构建文件目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;src/test/java&lt;/td&gt;
&lt;td&gt;测试代码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;src/test/resources&lt;/td&gt;
&lt;td&gt;测试配置&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;大致看一下就行了，不了解maven的话，&lt;a href=&quot;https://www.w3cschool.cn/maven/u7oe1ht0.html&quot;&gt;点击这里&lt;/a&gt;先学习入门，项目的构建工具是一定要先了解的。&lt;br/&gt;可以通过eclipse 或idea 创建一个maven项目，再引入springboot依赖，pom文件的定义参考如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;project
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;
    xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&amp;gt;
   &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
   &amp;lt;groupId&amp;gt;org.zales&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;dmo-boot&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;spring-boot.version&amp;gt;1.5.1.RELEASE&amp;lt;/spring-boot.version&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;!-- springboot application dependencies --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-dependencies&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring-boot.version}&amp;lt;/version&amp;gt;
            &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
            &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- springweb --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring-boot.version}&amp;lt;/version&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;!-- exclude the default logging module --&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;spring-boot-starter-logging&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- log4j2 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-log4j2&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring-boot.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- springboot test --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring-boot.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- used for livereload --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring-boot.version}&amp;lt;/version&amp;gt;
            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- used for template --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring-boot.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;source&amp;gt;${java.version}&amp;lt;/source&amp;gt;
                    &amp;lt;target&amp;gt;${java.version}&amp;lt;/target&amp;gt;
                    &amp;lt;encoding&amp;gt;${project.build.sourceEncoding}&amp;lt;/encoding&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;springboot 官方的示例是让你继承一个spring-boot-parent，但这个很鸡肋，通常的项目都会有自己的继承结构。&lt;br/&gt;所以我们间接利用spring-boot-dependencies将所有依赖引入，其他模块的引入都是按需。&lt;br/&gt;&lt;strong&gt;maven-compiler-plugin&lt;/strong&gt;的定义用于将项目指定为&lt;a href=&quot;(https://www.cnblogs.com/littleatp/p/5812767.html)&quot;&gt;Java1.8的编译级别&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他途径&lt;/strong&gt;&lt;br/&gt;你还可以利用spring的在线网站初始化一个springboot项目，&lt;a href=&quot;https://start.spring.io/&quot;&gt;点击这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二添加代码&quot;&gt;二、添加代码&lt;/h2&gt;
&lt;p&gt;启动代码非常简单，新建一个名为&quot;DemoBoot**的类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 入口类
 *
 */
@SpringBootApplication
public class DemoBoot {

    public static void main(String[] args) throws Exception {
        SpringApplication app = new SpringApplication(DemoBoot.class);

        // 指定PID生成，默认输出到application.pid
        app.addListeners(new ApplicationPidFileWriter());
        app.run(args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再创建一个&lt;strong&gt;DemoController&lt;/strong&gt;类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Controller
public class DemoController {
    
    @RequestMapping(&quot;/&quot;)
    @ResponseBody
    String home() {
        return &quot;Hello World! &quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们已经完成了框架代码！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;热部署&lt;/strong&gt;&lt;br/&gt;我们在定义项目依赖时添加了springboot-devtools，该模块可以实现热部署的功能，即在开发过程中可以不重启应用令代码生效，非常方便&lt;br/&gt;livereload 组件会定时扫描类路径下的class，一旦发现变更即重启服务，默认1000毫秒检测一次。&lt;br/&gt;在定义依赖时指定optional 选项使得该模块仅在开发时启用。&lt;br/&gt;livereload 在扫描会自动忽略以下范围的变更：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;META-INF/maven/**
META-INF/resources/**
resources/**,static/**
public/**
templates/**
**/*Test.class
**/*Tests.class
git.properties
META-INF/build-info.properties &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三应用配置&quot;&gt;三、应用配置&lt;/h2&gt;
&lt;p&gt;在src/main/resources/下新建一个application.properties文件，内容如下：&lt;br/&gt;&lt;strong&gt;application.properties&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server.address=0.0.0.0
server.port=8090&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;server.address&lt;/td&gt;
&lt;td&gt;监听地址，不配置或0.0.0.0即不限制&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;server.port&lt;/td&gt;
&lt;td&gt;监听端口&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;此时在IDE执行&quot;DemoBoot&quot;，你应该可以看到一些描述程序启动的日志信息，访问本机的8090端口能看到&quot;HelloWorld“输出。&lt;/p&gt;
&lt;p&gt;application.properties可包含大量的配置，你可以在&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html&quot;&gt;这里&lt;/a&gt;找到全部的配置&lt;/p&gt;
&lt;h2 id=&quot;四日志配置&quot;&gt;四、日志配置&lt;/h2&gt;
&lt;p&gt;接下来需要为应用准备一个日志配置用于定制，springboot 默认是使用logback的，但由于更加熟悉log4j的缘故，我们选用了log4j2.x&lt;br/&gt;在src/main/resources/下新建一个log4j2.xml文件，内容如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;log4j2.xml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;Configuration status=&quot;INFO&quot; monitorInterval=&quot;300&quot;&amp;gt;  
    &amp;lt;properties&amp;gt;  
        &amp;lt;property name=&quot;LOG_ROOT&quot;&amp;gt;log&amp;lt;/property&amp;gt;  
        &amp;lt;property name=&quot;FILE_NAME&quot;&amp;gt;application&amp;lt;/property&amp;gt;  
    &amp;lt;/properties&amp;gt;  
    &amp;lt;Appenders&amp;gt;  
        &amp;lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&amp;gt;  
            &amp;lt;PatternLayout pattern=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS}–[%t] %-5level -%l - %msg%n&quot; /&amp;gt;  
        &amp;lt;/Console&amp;gt;  
        &amp;lt;RollingRandomAccessFile name=&quot;MainFile&quot;  
            fileName=&quot;${LOG_ROOT}/${FILE_NAME}.log&quot;  
            filePattern=&quot;${LOG_ROOT}/$${date:yyyy-MM}/${FILE_NAME}-%d{yyyy-MM-dd HH}-%i.log&quot;&amp;gt;  
            &amp;lt;PatternLayout  
                pattern=&quot;%d{yyyy-MM-dd HH:mm:ss.SSS}–[%t] %-5level -%l - %msg%n&quot; /&amp;gt;  
            &amp;lt;Policies&amp;gt;  
                &amp;lt;TimeBasedTriggeringPolicy interval=&quot;1&quot; /&amp;gt;  
                &amp;lt;SizeBasedTriggeringPolicy size=&quot;50 MB&quot; /&amp;gt;  
            &amp;lt;/Policies&amp;gt;  
            &amp;lt;DefaultRolloverStrategy max=&quot;20&quot; /&amp;gt;  
        &amp;lt;/RollingRandomAccessFile&amp;gt;  
    &amp;lt;/Appenders&amp;gt;  

    &amp;lt;Loggers&amp;gt;  
        &amp;lt;Logger name=&quot;org.zales&quot; level=&quot;info&quot; additivity=&quot;true&quot;&amp;gt;  
            &amp;lt;AppenderRef ref=&quot;MainFile&quot; /&amp;gt;  
        &amp;lt;/Logger&amp;gt;  
        &amp;lt;Root level=&quot;info&quot;&amp;gt;  
            &amp;lt;AppenderRef ref=&quot;Console&quot; /&amp;gt;  
            &amp;lt;AppenderRef ref=&quot;MainFile&quot; /&amp;gt;  
        &amp;lt;/Root&amp;gt;  
    &amp;lt;/Loggers&amp;gt;  
&amp;lt;/Configuration&amp;gt;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里配置了两个日志记录方式，Console是控制台打印，RollingRandomAccessFile 指向一个日志文件，我们为该日志文件设定了滚动的规则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当大小超过50M时会生成新的日志；&lt;/li&gt;
&lt;li&gt;每小时生成一个新的日志；&lt;br/&gt;指定了最多存在20个日志文件。&lt;br/&gt;之后，我们为主模块(这里是org.zales，你可以定义自己的包名)和ROOT都分别做了关联和日志级别定义。&lt;br/&gt;关于log4j2的用法，可以&lt;a href=&quot;https://www.cnblogs.com/littleatp/p/9260784.html&quot;&gt;参考这个文章&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;五打包部署&quot;&gt;五、打包部署&lt;/h2&gt;
&lt;p&gt;应用最终需要发布到某个环境，那么我们怎么对springboot应用进行打包呢？&lt;br/&gt;利用&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/maven-plugin/repackage-mojo.html&quot;&gt;spring-boot-maven-plugin&lt;/a&gt;可以将springboot项目达成jar包。&lt;br/&gt;随后执行&lt;strong&gt;&lt;em&gt;java -jar xxx.jar&lt;/em&gt;&lt;/strong&gt;的方式即可以启动应用。&lt;br/&gt;这看起来好像很美好，但真实的项目发布并非这么简单。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先是配置，springboot的maven插件会将所有配置文件都打进jar包内，而某些配置可能与环境相关。&lt;br/&gt;比如应用端口，安全证书、或是日志配置等，这时我们希望在jar包外部存放这些文件；&lt;/li&gt;
&lt;li&gt;其次是执行脚本，在云环境上发布应用，通常需要提供启停脚本，包括一些监控功能脚本，这些需要作为项目打包的一部分&lt;/li&gt;
&lt;li&gt;最后，将应用程序发布为tgz或zip格式的压缩包会更加灵活，你可以添加更多的东西。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为实现灵活的打包方式，我们需要同时引用spring-boot-maven-plugin和maven-assembly-plugin两个插件，如下：&lt;br/&gt;&lt;strong&gt;pom.xml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;!-- build for springboot jar --&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;executions&amp;gt;
                    &amp;lt;execution&amp;gt;
                        &amp;lt;goals&amp;gt;
                            &amp;lt;goal&amp;gt;repackage&amp;lt;/goal&amp;gt;
                        &amp;lt;/goals&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt;
            &amp;lt;/plugin&amp;gt;
            &amp;lt;!-- build for application package --&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.4&amp;lt;/version&amp;gt;
                &amp;lt;executions&amp;gt;
                    &amp;lt;execution&amp;gt;
                        &amp;lt;id&amp;gt;bundle&amp;lt;/id&amp;gt;
                        &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
                        &amp;lt;goals&amp;gt;
                            &amp;lt;goal&amp;gt;single&amp;lt;/goal&amp;gt;
                        &amp;lt;/goals&amp;gt;
                        &amp;lt;configuration&amp;gt;
                            &amp;lt;descriptors&amp;gt;
                                &amp;lt;descriptor&amp;gt;${basedir}/src/main/build/assembly.xml&amp;lt;/descriptor&amp;gt;
                            &amp;lt;/descriptors&amp;gt;
                        &amp;lt;/configuration&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;plugin可以实现在maven的某个生命周期绑定一组动作，如上面的两个插件都绑定到了package阶段，执行顺序由声明的先后决定。&lt;br/&gt;于是项目在执行&lt;strong&gt;&lt;em&gt;mvn package&lt;/em&gt;&lt;/strong&gt;这样的命令时，会先执行springboot插件的repackage动作，将程序打包成jar文件；随后通过assembly插件执行bundle任务，&lt;br/&gt;再作最终的组装。&lt;br/&gt;&lt;strong&gt;&lt;em&gt;/src/main/build/assembly.xml&lt;/em&gt;&lt;/strong&gt;定义了程序包的结构，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;assembly xmlns=&quot;http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2&quot;
          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
          xsi:schemaLocation=&quot;http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd&quot;&amp;gt;
    &amp;lt;id&amp;gt;bundle&amp;lt;/id&amp;gt;
    &amp;lt;formats&amp;gt;
        &amp;lt;format&amp;gt;tar.gz&amp;lt;/format&amp;gt;
    &amp;lt;/formats&amp;gt;
    &amp;lt;includeBaseDirectory&amp;gt;false&amp;lt;/includeBaseDirectory&amp;gt; &amp;lt;!-- disable the creation of root's distribution dir in the archive --&amp;gt;

     &amp;lt;fileSets&amp;gt;  
        &amp;lt;!-- config files --&amp;gt;
        &amp;lt;fileSet&amp;gt;  
            &amp;lt;directory&amp;gt;${basedir}/src/main/build/config&amp;lt;/directory&amp;gt;  
            &amp;lt;excludes&amp;gt;&amp;lt;/excludes&amp;gt;  
             &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;application*.properties&amp;lt;/include&amp;gt;
                &amp;lt;include&amp;gt;log4j2.xml&amp;lt;/include&amp;gt; 
            &amp;lt;/includes&amp;gt;
            &amp;lt;fileMode&amp;gt;0644&amp;lt;/fileMode&amp;gt;
            &amp;lt;outputDirectory&amp;gt;/&amp;lt;/outputDirectory&amp;gt;  
        &amp;lt;/fileSet&amp;gt;  
        &amp;lt;!-- scripts --&amp;gt;
        &amp;lt;fileSet&amp;gt;
            &amp;lt;directory&amp;gt;${basedir}/src/main/build/bin&amp;lt;/directory&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;*.sh&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
            &amp;lt;fileMode&amp;gt;0755&amp;lt;/fileMode&amp;gt;
            &amp;lt;outputDirectory&amp;gt;/&amp;lt;/outputDirectory&amp;gt;
        &amp;lt;/fileSet&amp;gt;
        &amp;lt;!-- executable jar --&amp;gt;
         &amp;lt;fileSet&amp;gt;
            &amp;lt;directory&amp;gt;${project.build.directory}&amp;lt;/directory&amp;gt;
            &amp;lt;outputDirectory&amp;gt;/&amp;lt;/outputDirectory&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;${project.artifactId}-${project.version}.jar&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
            &amp;lt;fileMode&amp;gt;0755&amp;lt;/fileMode&amp;gt;
        &amp;lt;/fileSet&amp;gt;
    &amp;lt;/fileSets&amp;gt;  

&amp;lt;/assembly&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;assembly文件的定义比较简单，目标程序包中除了jar文件之外，还会包含几个脚本和配置文件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;启动脚本&lt;br/&gt;&lt;strong&gt;&lt;em&gt;/src/main/build/bin/start.sh&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;nohup java -jar dmo-boot-0.0.1-SNAPSHOT.jar &amp;gt; console.log &amp;amp;
tail -n100 -f console.log&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;停止脚本&lt;br/&gt;&lt;strong&gt;&lt;em&gt;/src/main/build/bin/stop.sh&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;kill `cat application.pid`
rm application.pid&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;配置文件&lt;br/&gt;&lt;strong&gt;&lt;em&gt;/src/main/build/application.properties&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;em&gt;/src/main/build/log4j2.xml&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最终执行&quot;mvn package&quot;打包，会输出压缩包文件，结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dmo-boot.0.0.1-SNAPSHOT.jar
application.properties
log4j2.xml
start.sh
stop.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本文将一个springboot项目从初始化、开发、配置、打包的整个流程进行了详细介绍，希望读者对该框架能产生整体性的了解。&lt;br/&gt;由于篇幅有限，部分章节仅做了简单说明。springboot是一个优秀的脚手架，借助于框架可以快速的完成各种特性的实现。&lt;br/&gt;在随后的文章里，将会跟大家一起继续深入学习，欢迎随时关注&quot;美码师的补习系列-springboot篇&quot;&lt;/p&gt;
</description>
<pubDate>Sat, 07 Jul 2018 14:36:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleatp/p/9278686.html</dc:identifier>
</item>
<item>
<title>iOS11.2-11.3.1进行越狱及问题 - WillkYang</title>
<link>http://www.cnblogs.com/yate1996/p/9278682.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yate1996/p/9278682.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;设备环境：Electra、iOS11.13.1&lt;br/&gt;PS:Electra最新版本进行越狱只支持11.14以下的版本、同时这是不完美越狱，每次重启手机都需要重新越狱，最后，由于Electra版本推出仓促，一次成功率较低。仅建议喜欢瞎折腾的童鞋尝试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;越狱结果截图&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/459563-bcfea6aaa489b018.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;进入&lt;a href=&quot;https://coolstar.org/electra/&quot;&gt;Electra&lt;/a&gt;官网下载Electra ipa文件，注意官网有两种方法，笔者此次使用的是第二个版本(Non Dev Accont)的文件&lt;br/&gt;&lt;img src=&quot;http://ou0bp2mrg.bkt.clouddn.com/2018-07-07-15309740484873.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载完后安装到手机上，方法很多&lt;br/&gt;iOS开发者可直接进行重签名安装&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;codesign -f -s ‘iPhone Developer: xxx(xxx)’ —entitlements xxx.entitlements xxx.app&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没有开发者账号的可以使用工具&lt;a href=&quot;http://www.cydiaimpactor.com/&quot;&gt;Cydia Impactor&lt;/a&gt;辅助安装，下载安装后打开，设备连接电脑，直接将ipa文件拉入软件中即可，或者菜单栏选择install package，之后需要输入apple账号密码。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/459563-a6dfd19f9a653401.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装后打开Electra，建议手机先重启等待一分钟，开启飞行模式，关闭Siri，然后开始越狱，理想情况下，第一次开始后手机自动重启完会多了一个Cydia，此时手机还未越狱成功，Cydia打开会闪退。当然这一步成功装上cydia的概率不高，要么直接报错，要么在1/3进度处手机立即被重启，这些都属于失败的情况，此时需要重启（也许可以不用），等待一分钟以上，再次重新点击越狱，直接看到cydia。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/459563-99892d8619f548c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;如果在此处重启，大概率本次操作失败，需要重来&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里，你需要能看到cydia，否则请回到步骤3继续。重新打开Electra，再次按下按钮，情况基本和步骤上一致，也是如果在1/3处重启则视为失败，能走到2/3基本就成功了，手机自动重启后，cydia可以打开，不闪退。&lt;/p&gt;
&lt;p&gt;此时，如果cydia正常打开并使用，那么恭喜，越狱过程已经结束。可直接忽略下面的步骤。&lt;/p&gt;
&lt;p&gt;如果打开的cydia没有连接到网络，如下图。则断开WIFI，在打开的cydia页面上，上拉控制中心，开启飞行模式，关闭，打开，这时候应该会有提醒，接着到手机设置重的移动数据网络打开cydia的联网权限即可使用。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/459563-f9bd9c74764ff6e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;再一次温馨提示：当前Electra越狱成功率较低，基本需要很多次尝试后才能越狱成功，要有耐心，如果能一次成功，那你肯定是被选中的人～&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 07 Jul 2018 14:33:00 +0000</pubDate>
<dc:creator>WillkYang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yate1996/p/9278682.html</dc:identifier>
</item>
<item>
<title>Mybatis（一）走进Mybatis与FisrtExample - 苦水润喉</title>
<link>http://www.cnblogs.com/zhangyinhua/p/9278676.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyinhua/p/9278676.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;一直在使用，从未系统的总结起来。所以这里给大家带来的是mybatis的总结，系统大家能够对这个框架有一定的系统的学习与认识。&lt;br/&gt;mybatis和Hibernate应该是现在主流的ORM框架了。&lt;br/&gt;mybatis学习的步骤：&lt;br/&gt;mybatis入门 --&amp;gt; 全局配置文件和映射文件详解 --&amp;gt; 高级映射(一对一，一对多，多对多) --&amp;gt;延迟加载机制 --&amp;gt;一级缓存，&lt;br/&gt;二级缓存(整合ehcache) --&amp;gt; spring整合mybatis --&amp;gt; 逆向工程&lt;/p&gt;
&lt;h2 id=&quot;一mybatis简介&quot;&gt;一、Mybatis简介&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Mybatis是Apache的一个Java开源项目，是一个支持动态Sql语句的持久层框架。Mybatis可以将Sql语句配置在XML文件中，避免&lt;br/&gt;将Sql语句硬编码在Java类中。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;MyBatis 是支持普通 SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis 消除了几乎所有的JDBC代码和参数的手工设置&lt;br/&gt;以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Ordinary Java&lt;br/&gt;Objects，普通的 Java对象）映射成数据库中的记录。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结一下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1）支持普通sql查询&lt;/li&gt;
&lt;li&gt;2）高级映射&lt;/li&gt;
&lt;li&gt;3）存储过程&lt;/li&gt;
&lt;li&gt;4）消除了几乎所有jdbc代码和参数的手工设置以及结果集的检索&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二mybatis与jdbchibernate的区别&quot;&gt;二、Mybatis与JDBC、Hibernate的区别&lt;/h2&gt;
&lt;h3 id=&quot;mybatis与jdbc的区别&quot;&gt;2.1 Mybatis与JDBC的区别&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Mybatis通过参数映射方式，可以将参数灵活的配置在SQL语句中的配置文件中，避免在Java类中配置参数（JDBC）&lt;/li&gt;
&lt;li&gt;Mybatis通过输出映射机制，将结果集的检索自动映射成相应的Java对象，避免对结果集手工检索（JDBC）&lt;/li&gt;
&lt;li&gt;Mybatis可以通过Xml配置文件对数据库连接进行管理。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三感受jdbc和mybatis&quot;&gt;三、感受JDBC和Mybatis&lt;/h2&gt;
&lt;p&gt;MyBatis 是来和数据库打交道。那么在这之前，我们是使用 JDBC 来对数据库进行增删改查等一系列操作的，而我们之所以会放弃&lt;br/&gt;使用 JDBC，转而使用 MyBatis 框架，这是为什么呢？&lt;br/&gt;为什么使用Mybatis比JDBC直接连接方便和性能上好很多呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新建Person实体类&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Person {
    private Long pid;
    private String pname;
    public Long getPid() {
        return pid;
    }
    public void setPid(Long pid) {
        this.pid = pid;
    }
    public String getPname() {
        return pname;
    }
    public void setPname(String pname) {
        this.pname = pname;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;JDBC 查询操作&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
 
import javax.swing.DebugGraphics;
 
import com.ys.bean.Person;
 
public class CRUDDao {
    //MySQL数据库驱动
    public static String driverClass = &quot;com.mysql.jdbc.Driver&quot;;
    //MySQL用户名
    public static String userName = &quot;root&quot;;
    //MySQL密码
    public static String passWord = &quot;654321&quot;;
    //MySQL URL
    public static String url = &quot;jdbc:mysql://localhost:3306/study&quot;;
    //定义数据库连接
    public static Connection conn = null;
    //定义声明数据库语句,使用 预编译声明 PreparedStatement提高数据库执行性能
    public static PreparedStatement ps = null;
    //定义返回结果集
    public static ResultSet rs = null;
    /**
     * 查询 person 表信息
     * @return：返回 person 的 list 集合
     */
    public static List&amp;lt;Person&amp;gt; readPerson(){
        List&amp;lt;Person&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
        try {
            //加载数据库驱动
            Class.forName(driverClass);
            //获取数据库连接
            conn = DriverManager.getConnection(url, userName, passWord);
            //定义 sql 语句,?表示占位符
            String sql = &quot;select * from person where pname=?&quot;;
            //获取预编译处理的statement
            ps = conn.prepareStatement(sql);
            //设置sql语句中的参数，第一个为sql语句中的参数的?(从1开始)，第二个为设置的参数值
            ps.setString(1, &quot;qzy&quot;);
            //向数据库发出 sql 语句查询，并返回结果集
            rs = ps.executeQuery();
            while (rs.next()) {
                Person p = new Person();
                p.setPid(rs.getLong(1));
                p.setPname(rs.getString(2));
                list.add(p);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally{
            //关闭数据库连接
            if(rs!=null){
                try {
                    rs.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            if(ps!=null){
                try {
                    ps.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
            if(conn!=null){
                try {
                    conn.close();
                } catch (SQLException e) {
                    e.printStackTrace();
                }
            }
        }
         
        return list;
    }
 
    public static void main(String[] args) {
        System.out.println(CRUDDao.readPerson());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;分析问题&lt;br/&gt;1）问题一：数据库连接，使用时就创建，使用完毕就关闭，这样会对数据库进行频繁的获取连接和关闭连接，造成数据库资源浪费，&lt;br/&gt;影响数据库性能。&lt;br/&gt;设想解决：使用数据库连接池管理数据库连接&lt;br/&gt;2）问题二：将 sql 语句硬编码到程序中，如果sql语句修改了，那么需要重新编译 Java 代码，不利于系统维护&lt;br/&gt;设想解决：将 sql 语句配置到 xml 文件中，即使 sql 语句变化了，我们也不需要对 Java 代码进行修改，重新编译&lt;br/&gt;3）问题三：在 PreparedStatement 中设置参数，对占位符设置值都是硬编码在Java代码中，不利于系统维护&lt;br/&gt;　设想解决：将 sql 语句以及占位符和参数都配置到 xml 文件中&lt;br/&gt;4）问题四：从 resultset 中遍历结果集时，对表的字段存在硬编码，不利于系统维护&lt;br/&gt;设想解决：将查询的结果集自动映射为 Java 对象&lt;br/&gt;5）问题五：重复性代码特别多，频繁的 try-catch&lt;br/&gt;设想解决：将其整合到一个 try-catch 代码块中&lt;br/&gt;6）问题六：缓存做的很差，如果存在数据量很大的情况下，这种方式性能特别低&lt;br/&gt;设想解决：集成缓存框架去操作数据库&lt;br/&gt;7）问题七：sql 的移植性不好，如果换个数据库，那么sql 语句可能要重写&lt;br/&gt;设想解决：在 JDBC 和 数据库之间插入第三方框架，用第三方去生成 sql 语句，屏蔽数据库的差异&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四基于xml的mybatis入门实例&quot;&gt;四、基于XML的Mybatis入门实例&lt;/h2&gt;
&lt;h3 id=&quot;创建数据库表&quot;&gt;4.1 创建数据库表&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/zJ3u7pU.png&quot;/&gt;&lt;br/&gt;创建完成，随便写几条数据进去。&lt;/p&gt;
&lt;h3 id=&quot;创建一个java项目并导入相应的jar包&quot;&gt;4.2 创建一个Java项目，并导入相应的jar包&lt;/h3&gt;
&lt;p&gt;备注：log4j和Junit不是必须的，但是我们为了查看日志以及便于测试，加入了这两个jar包&lt;br/&gt;目录结构：&lt;br/&gt;&lt;img src=&quot;https://i.imgur.com/4P6M08P.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;项目中添加数据库配置文件-mybatis-configuration.xml&quot;&gt;4.3 项目中添加数据库配置文件 mybatis-configuration.xml&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;

    &amp;lt;!-- 注意：environments标签，当mybatis和spring整合之后，这个标签是不用配置的 --&amp;gt;

    &amp;lt;!-- 可以配置多个运行环境，但是每个 SqlSessionFactory 实例只能选择一个运行环境
      一、development:开发模式
       二、work：工作模式--&amp;gt;
    &amp;lt;environments default=&quot;development&quot;&amp;gt;
        &amp;lt;!--id属性必须和上面的default一样  --&amp;gt;
        &amp;lt;environment id=&quot;development&quot;&amp;gt;
            &amp;lt;!--事务管理器
                一、JDBC：这个配置直接简单使用了 JDBC 的提交和回滚设置。它依赖于从数据源得到的连接来管理事务范围
                二、MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接。而它会让容器来管理事务的整个生命周期
                    比如 spring 或 JEE 应用服务器的上下文，默认情况下，它会关闭连接。然而一些容器并不希望这样，
                    因此如果你需要从连接中停止它，就可以将 closeConnection 属性设置为 false，比如：
                    &amp;lt;transactionManager type=&quot;MANAGED&quot;&amp;gt;
                        &amp;lt;property name=&quot;closeConnection&quot; value=&quot;false&quot;/&amp;gt;
                    &amp;lt;/transactionManager&amp;gt;
              --&amp;gt;
            &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt;
            &amp;lt;!--dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象源  --&amp;gt;
            &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
                &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
                &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/study&quot;/&amp;gt;
                &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
                &amp;lt;property name=&quot;password&quot; value=&quot;654321&quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;

    &amp;lt;mappers&amp;gt;
        &amp;lt;!-- 注册userMapper.xml文件，
        userMapper.xml位于com.lance.mybatis这个包下，所以resource写成com/lance/mybatis/userMapper.xml--&amp;gt;
        &amp;lt;mapper resource=&quot;com/lance/mybatis/mapper/userMapper.xml&quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义表对应的实体类&quot;&gt;4.4 定义表对应的实体类&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;package com.lance.mybatis.bean;

import java.util.Date;


public class User {
    private int id;
    private String username;
    private int password;
    private String sex;
    private Date birthday;
    private String address;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public int getPassword() {
        return password;
    }

    public void setPassword(int password) {
        this.password = password;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;id=&quot; + id +
                &quot;, username='&quot; + username + '\'' +
                &quot;, password=&quot; + password +
                &quot;, sex='&quot; + sex + '\'' +
                &quot;, birthday=&quot; + birthday +
                &quot;, address='&quot; + address + '\'' +
                '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义操作-user-表的sql映射文件usermapper.xml&quot;&gt;4.5 定义操作 user 表的sql映射文件userMapper.xml&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;com.lance.mybatis.mapper.userMapper&quot;&amp;gt;

    &amp;lt;!-- 根据 id 查询 user 表中的数据
        id:唯一标识符，此文件中的id值不能重复
        resultType:返回值类型，一条数据库记录也就对应实体类的一个对象
        parameterType:参数类型，也就是查询条件的类型
   --&amp;gt;
    &amp;lt;select id=&quot;selectUserById&quot;
            resultType=&quot;com.lance.mybatis.bean.User&quot; parameterType=&quot;int&quot;&amp;gt;
        &amp;lt;!-- 这里和普通的sql 查询语句差不多，后面的 #{id}表示占位符，里面不一定要写id,写啥都可以，但是不要空着 --&amp;gt;
        select * from user where id = #{id}
    &amp;lt;/select&amp;gt;


    &amp;lt;!-- 查询 user 表的所有数据
        注意：因为是查询所有数据，所以返回的应该是一个集合,这个集合里面每个元素都是User类型
     --&amp;gt;
    &amp;lt;select id=&quot;selectUserAll&quot; resultType=&quot;com.lance.mybatis.bean.User&quot;&amp;gt;
        select * from user
    &amp;lt;/select&amp;gt;

    &amp;lt;!-- 模糊查询：根据 user 表的username字段
            下面两种写法都可以，但是要注意
            1、${value}里面必须要写value，不然会报错
            2、${}表示拼接 sql 字符串，将接收到的参数不加任何修饰拼接在sql语句中
            3、使用${}会造成 sql 注入
     --&amp;gt;
    &amp;lt;select id=&quot;selectLikeUserName&quot; resultType=&quot;com.lance.mybatis.bean.User&quot; parameterType=&quot;String&quot;&amp;gt;
        select * from user where username like '%${value}%'
        &amp;lt;!-- select * from user where username like #{username} --&amp;gt;
    &amp;lt;/select&amp;gt;

    &amp;lt;!-- 向 user 表插入一条数据 --&amp;gt;
    &amp;lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.lance.mybatis.bean.User&quot;&amp;gt;
        &amp;lt;!-- 将插入的数据主键返回到 user 对象中
             keyProperty:将查询到的主键设置到parameterType 指定到对象的那个属性
             select LAST_INSERT_ID()：查询上一次执行insert 操作返回的主键id值，只适用于自增主键
             resultType:指定 select LAST_INSERT_ID() 的结果类型
             order:AFTER，相对于 select LAST_INSERT_ID()操作的顺序
         --&amp;gt;
        &amp;lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&amp;gt;
            select LAST_INSERT_ID()
        &amp;lt;/selectKey&amp;gt;
        insert into user(username,password,sex,birthday,address)
        value(#{username},#{password},#{sex},#{birthday},#{address})
    &amp;lt;/insert&amp;gt;

    &amp;lt;!-- 根据 id 更新 user 表的数据 --&amp;gt;
    &amp;lt;update id=&quot;updateUserById&quot; parameterType=&quot;com.lance.mybatis.bean.User&quot;&amp;gt;
        update user set username=#{username} where id=#{id}
    &amp;lt;/update&amp;gt;

    &amp;lt;!-- 根据 id 删除 user 表的数据 --&amp;gt;
    &amp;lt;delete id=&quot;deleteUserById&quot; parameterType=&quot;int&quot;&amp;gt;
        delete from user where id=#{id}
    &amp;lt;/delete&amp;gt;
&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;向-mybatis-configuration.xml-配置文件中注册-usermapper.xml-文件&quot;&gt;4.6 向 mybatis-configuration.xml 配置文件中注册 userMapper.xml 文件&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/pOz5I9M.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;测试功能类&quot;&gt;4.7 测试功能类&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;package com.lance.mybatis.test;

import com.lance.mybatis.bean.User;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Before;
import org.junit.Test;

import java.io.InputStream;
import java.util.Date;
import java.util.List;

/**
 * @author lance(ZYH)
 * @function
 * @date 2018-07-07 21:10
 */
public class MybatisTest {
    SqlSession session = null;

    @Before
    public void init() {
        //定义mybatis全局配置文件
        String resource = &quot;com/lance/mybatis/config/mybatis-configuration.xml&quot;;
        //加载 mybatis 全局配置文件
        InputStream inputStream = MybatisTest.class.getClassLoader()
                .getResourceAsStream(resource);
        //构建sqlSession的工厂
        SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        //根据 sqlSessionFactory 产生 session
        session = sessionFactory.openSession();
    }

    //根据id查询user表数据
    @Test
    public void getUserById() {
               /*这个字符串由 userMapper.xml 文件中 两个部分构成
            &amp;lt;mapper namespace=&quot;com.lance.mybatis.userMapper&quot;&amp;gt; 的 namespace 的值
            &amp;lt;select id=&quot;selectUserById&quot; &amp;gt; id 值*/
        String statement = &quot;com.lance.mybatis.mapper.userMapper.selectUserById&quot;;
        User user = session.selectOne(statement, 1);
        System.out.println(user);
        session.close();
    }

    //查询所有user表所有数据
    @Test
    public void testSelectUserAll() {
        String statement = &quot;com.lance.mybatis.mapper.userMapper.selectUserAll&quot;;
        List&amp;lt;User&amp;gt; listUser = session.selectList(statement);
        for (User user : listUser) {
            System.out.println(user);
        }

        session.close();

    }

    //模糊查询：根据 user 表的username字段
    @Test
    public void testSelectLikeUserName(){
        String statement = &quot;com.lance.mybatis.mapper.userMapper.selectLikeUserName&quot;;
        List&amp;lt;User&amp;gt; listUser = session.selectList(statement, &quot;%张%&quot;);
        for(User user : listUser){
            System.out.println(user);
        }
        session.close();

    }

    //向 user 表中插入一条数据
    @Test
    public void testInsertUser(){
        String statement = &quot;com.lance.mybatis.mapper.userMapper.insertUser&quot;;
        User user = new User();
        user.setUsername(&quot;刘美玲&quot;);
        user.setPassword(98766);
        user.setSex(&quot;女&quot;);
        user.setAddress(&quot;河南省啥子去&quot;);
        session.insert(statement, user);
        //提交插入的数据
        session.commit();
        session.close();
    }

    //根据 id 更新 user 表的数据
    @Test
    public void testUpdateUserById(){
        String statement = &quot;com.lance.mybatis.mapper.userMapper.updateUserById&quot;;
        //如果设置的 id不存在，那么数据库没有数据更改
        User user = new User();
        user.setId(4);
        user.setUsername(&quot;jim&quot;);
        session.update(statement, user);
        session.commit();
        session.close();
    }

    //根据 id 删除 user 表的数据
    @Test
    public void testDeleteUserById(){
        String statement = &quot;com.lance.mybatis.mapper.userMapper.deleteUserById&quot;;
        session.delete(statement,4);
        session.commit();
        session.close();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五总结&quot;&gt;五、总结&lt;/h2&gt;
&lt;h3 id=&quot;插入数据之后的主键值&quot;&gt;5.1 插入数据之后的主键值&lt;/h3&gt;
&lt;p&gt;1）数据库设置主键自增机制&lt;br/&gt;　userMapper.xml 文件中定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 向 user 表插入一条数据 --&amp;gt;
    &amp;lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.ys.po.User&quot;&amp;gt;
        &amp;lt;!-- 将插入的数据主键返回到 user 对象中
             keyProperty:将查询到的主键设置到parameterType 指定到对象的那个属性
             select LAST_INSERT_ID()：查询上一次执行insert 操作返回的主键id值，只适用于自增主键
             resultType:指定 select LAST_INSERT_ID() 的结果类型
             order:AFTER，相对于 select LAST_INSERT_ID()操作的顺序
         --&amp;gt;
        &amp;lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&amp;gt;
            select LAST_INSERT_ID()
        &amp;lt;/selectKey&amp;gt;
        insert into user(username,password,sex,birthday,address)
            value(#{username},#{password},#{sex},#{birthday},#{address})
    &amp;lt;/insert&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）非自增主键机制&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 向 user 表插入一条数据 --&amp;gt;
    &amp;lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.ys.po.User&quot;&amp;gt;
        &amp;lt;!-- 将插入的数据主键返回到 user 对象中
        流程是：首先通过 select UUID()得到主键值，然后设置到 user 对象的id中，在进行 insert 操作
             keyProperty:将查询到的主键设置到parameterType 指定到对象的那个属性
             select UUID()：得到主键的id值，注意这里是字符串
             resultType:指定 select UUID() 的结果类型
             order:BEFORE，相对于 select UUID()操作的顺序
         --&amp;gt;
        &amp;lt;selectKey keyProperty=&quot;id&quot; resultType=&quot;String&quot; order=&quot;BEFORE&quot;&amp;gt;
            select UUID()
        &amp;lt;/selectKey&amp;gt;
        insert into user(id,username,passwor,sex,birthday,address)
            value(#{id},#{username},#{password},#{sex},#{birthday},#{address})
    &amp;lt;/insert&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;特殊总结&quot;&gt;5.2 特殊总结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;parameterType:指定输入参数的类型&lt;/li&gt;
&lt;li&gt;resultType:指定输出结果的类型，在select中如果查询结果是集合，那么也表示集合中每个元素的类型&lt;/li&gt;
&lt;li&gt;使用#{}:表示占位符，用来接收输入参数，类型可以是简单类型，pojo,HashMap等等&lt;br/&gt;如果接收简单类型，#{}可以写成 value 或者其他名称&lt;br/&gt;如果接收 pojo 对象值，通过 OGNL 读取对象中的属性值，即属性.属性.属性...的方式获取属性值&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;使用${}:表示一个拼接符，会引起 sql 注入，不建议使用&lt;br/&gt;用来接收输入参数，类型可以是简单类型，pojo,HashMap等等&lt;br/&gt;如果接收简单类型，${}里面只能是 value&lt;br/&gt;如果接收 pojo 对象值，通过 OGNL 读取对象中的属性值，即属性.属性.属性...的方式获取属性值&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 07 Jul 2018 14:32:00 +0000</pubDate>
<dc:creator>苦水润喉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangyinhua/p/9278676.html</dc:identifier>
</item>
<item>
<title>Android 视频播放器 (二)：使用MediaPlayer播放视频 - 灰色飘零</title>
<link>http://www.cnblogs.com/renhui/p/9269040.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renhui/p/9269040.html</guid>
<description>&lt;p&gt;在 &lt;a id=&quot;cb_post_title_url&quot; href=&quot;https://www.cnblogs.com/renhui/p/9267778.html&quot;&gt;Android 视频播放器 (一)：使用VideoView播放视频&lt;/a&gt; 我们讲了一下如何使用VideoView播放视频，了解了基本的播放器的一些知识和内容。也知道VideoView内部封装的就是MediaPlayer，本文就介绍如何使用MediaPlayer播放视频。&lt;/p&gt;

&lt;p&gt;MediaPlayer是Android中的一个多媒体播放类，其提供的API能满足简单的大部分音视频的播放需求。&lt;/p&gt;
&lt;p&gt;下面简单介绍一下MediaPlayer：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MediaPlayer是使用Surface进行视频的展示的。&lt;/li&gt;
&lt;li&gt;MediaPlayer只支持mp4、avi、3gp格式的视频，支持格式相对单一。&lt;/li&gt;
&lt;li&gt;MediaPlayer可以播放网络视频，支持的网络视频的协议为：Http协议和RTSP协议两种。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MediaPlayer 的提供的方法如下：&lt;/p&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;ul&gt;&lt;li&gt;void setDataSource(String path) ：通过一个具体的路径来设置MediaPlayer的数据源，path可以是本地的一个路径，也可以是一个网络路径&lt;/li&gt;
&lt;li&gt;void setDataSource(Context context, Uri uri)： 通过给定的Uri来设置MediaPlayer的数据源，这里的Uri可以是网络路径或是一个ContentProvider的Uri。&lt;/li&gt;
&lt;li&gt;void setDataSource(MediaDataSource dataSource) ：通过提供的MediaDataSource来设置数据源&lt;/li&gt;
&lt;li&gt;void setDataSource(FileDescriptor fd)： 通过文件描述符FileDescriptor来设置数据源&lt;/li&gt;
&lt;li&gt;int getCurrentPosition() ：获取当前播放的位置&lt;/li&gt;
&lt;li&gt;int getAudioSessionId() ：返回音频的session ID&lt;/li&gt;
&lt;li&gt;int getDuration() ：得到文件的时间&lt;/li&gt;
&lt;li&gt;TrackInfo[] getTrackInfo() ：返回一个track信息的数组&lt;/li&gt;
&lt;li&gt;boolean isLooping ()： 是否循环播放&lt;/li&gt;
&lt;li&gt;boolean isPlaying()： 是否正在播放&lt;/li&gt;
&lt;li&gt;void pause () ：暂停&lt;/li&gt;
&lt;li&gt;void start () ：开始&lt;/li&gt;
&lt;li&gt;void stop () ： 停止&lt;/li&gt;
&lt;li&gt;void prepare()： 同步的方式装载流媒体文件。&lt;/li&gt;
&lt;li&gt;void prepareAsync()： 异步的方式装载流媒体文件。&lt;/li&gt;
&lt;li&gt;void reset()： 重置MediaPlayer至未初始化状态。&lt;/li&gt;
&lt;li&gt;void release ()： 回收流媒体资源。&lt;/li&gt;
&lt;li&gt;void seekTo(int msec)： 指定播放的位置（以毫秒为单位的时间）&lt;/li&gt;
&lt;li&gt;void setAudioStreamType(int streamtype) ：指定流媒体类型&lt;/li&gt;
&lt;li&gt;void setLooping(boolean looping) ：设置是否单曲循环&lt;/li&gt;
&lt;li&gt;void setNextMediaPlayer(MediaPlayer next) ： 当前这个MediaPlayer播放完毕后，MediaPlayer next开始播放&lt;/li&gt;
&lt;li&gt;void setWakeMode(Context context, int mode)：设置CPU唤醒的状态。&lt;/li&gt;
&lt;li&gt;setOnBufferingUpdateListener(MediaPlayer.OnBufferingUpdateListener listener) ：网络流媒体的缓冲变化时回调 &lt;/li&gt;
&lt;li&gt;setOnCompletionListener(MediaPlayer.OnCompletionListener listener) ：网络流媒体播放结束时回调&lt;/li&gt;
&lt;li&gt;setOnErrorListener(MediaPlayer.OnErrorListener listener) ：发生错误时回调 &lt;/li&gt;
&lt;li&gt;setOnPreparedListener(MediaPlayer.OnPreparedListener listener)：当装载流媒体完毕的时候回调。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Android通过MediaPlayer控制播放器的状态的方式来控制媒体文件的播放，其中： &lt;/p&gt;
&lt;ul&gt;&lt;li&gt;prepare()和prepareAsync() 提供了同步和异步两种方式设置播放器进入prepare状态，需要注意的是，如果MediaPlayer实例是由create方法创建的，那么第一次启动播放前不需要再调用prepare（）了，因为create方法里已经调用过了。&lt;/li&gt;
&lt;li&gt;start()是真正启动文件播放的方法， &lt;/li&gt;
&lt;li&gt;pause()和stop()比较简单，起到暂停和停止播放的作用， &lt;/li&gt;
&lt;li&gt;seekTo()是定位方法，可以让播放器从指定的位置开始播放，需要注意的是该方法是个异步方法，也就是说该方法返回时并不意味着定位完成，尤其是播放的网络文件，真正定位完成时会触发OnSeekComplete.onSeekComplete()，如果需要是可以调用setOnSeekCompleteListener(OnSeekCompleteListener)设置监听器来处理的。 &lt;/li&gt;
&lt;li&gt;release()可以释放播放器占用的资源，一旦确定不再使用播放器时应当尽早调用它释放资源。 &lt;/li&gt;
&lt;li&gt;reset()可以使播放器从Error状态中恢复过来，重新会到Idle状态。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用MediaPlayer播放视频的步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建MediaPlayer对象，并让它加载指定的视频文件；&lt;/li&gt;
&lt;li&gt;在界面布局文件中定义SurfaceView控件，或在程序中创建SurfaceView控件，并为SurfaceView的SurfaceHolder添加Callback监听器；&lt;/li&gt;
&lt;li&gt;调用MediaPlayer对象的setDisney(SurfaceHolder sh)方法将所播放的视频图像输出到指定的SurfaceView控制；&lt;/li&gt;
&lt;li&gt;调用MediaPlayer的start()、stop()、pause()方法来控制视频播放。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下图是一个MediaPlayer对象被支持的播放控制操作驱动的声明周期和状态。其中，椭圆代表MediaPlayer可能驻留的状态，弧线表示驱动MediaPlayer在各个状态之间迁移的播放控制操作。这里有两种类型的弧线。由单箭头开始的弧线代表同步方法调用，而以双箭头开头的弧线代表异步方法调用。&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/682616/201807/682616-20180707210703147-1545561806.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面我们将展示如何使用MediaPlayer播放香港卫视的视频流：&lt;/p&gt;
&lt;h3&gt;1. 声明权限&lt;/h3&gt;
&lt;p&gt;需要在AndroidManifest.xml添加权限。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;uses-permission &lt;/span&gt;&lt;span&gt;android:name&lt;/span&gt;&lt;span&gt;=&quot;android.permission.INTERNET&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. 编写SurfaceView布局&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;android.support.constraint.ConstraintLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:tools&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/tools&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
    tools:context&lt;/span&gt;&lt;span&gt;=&quot;.MainActivity&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout
        &lt;/span&gt;&lt;span&gt;android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SurfaceView
            &lt;/span&gt;&lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/surface_view&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;&lt;span&gt;
            android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;195dp&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;android.support.constraint.ConstraintLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. 编写播放视频代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public class MainActivity extends AppCompatActivity implements SurfaceHolder.Callback {

    SurfaceView surfaceView;

    SurfaceHolder surfaceHolder;

    MediaPlayer mediaPlayer;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        surfaceView = findViewById(R.id.surface_view);

        surfaceHolder = surfaceView.getHolder();

        surfaceHolder.addCallback(this);

        mediaPlayer = new MediaPlayer();

        try {
            mediaPlayer.setDataSource(&quot;http://live.hkstv.hk.lxdns.com/live/hks/playlist.m3u8&quot;);
        } catch (IOException e) {
            e.printStackTrace();
        }
        mediaPlayer.setOnPreparedListener(new MediaPlayer.OnPreparedListener() {
            @Override
            public void onPrepared(MediaPlayer mp) {
                mp.start();
            }
        });
    }

    @Override
    public void surfaceCreated(SurfaceHolder holder) {
        Surface surface = holder.getSurface();
        mediaPlayer.setSurface(surface);
        mediaPlayer.prepareAsync();
    }

    @Override
    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {

    }

    @Override
    public void surfaceDestroyed(SurfaceHolder holder) {

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div&gt;

&lt;ol&gt;&lt;li readability=&quot;-0.5&quot;&gt;在使用start()播放流媒体之前，需要装载流媒体资源。这里最好使用prepareAsync()用异步的方式装载流媒体资源。因为流媒体资源的装载是会消耗系统资源的，在一些硬件不理想的设备上，如果使用prepare()同步的方式装载资源，可能会造成UI界面的卡顿，这是非常影响用于体验的。因为推荐使用异步装载的方式，为了避免还没有装载完成就调用start()而报错的问题，需要绑定MediaPlayer.setOnPreparedListener()事件，它将在异步装载完成之后回调。异步装载还有一个好处就是避免装载超时引发ANR（(Application Not Responding）错误。
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mediaPlayer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MediaPlayer();
mediaPlayer.setDataSource(path);
mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过异步的方式装载媒体资源&lt;/span&gt;
&lt;span&gt;mediaPlayer.prepareAsync();
mediaPlayer.setOnPreparedListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OnPreparedListener() {                    
     @Override
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onPrepared(MediaPlayer mp) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 装载完毕回调&lt;/span&gt;
&lt;span&gt;          mediaPlayer.start();
     }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li readability=&quot;-1.5&quot;&gt;使用完MediaPlayer需要回收资源。MediaPlayer是很消耗系统资源的，所以在使用完MediaPlayer，不要等待系统自动回收，最好是主动回收资源
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (mediaPlayer != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; mediaPlayer.isPlaying()) {
      mediaPlayer.stop();
      mediaPlayer.release();
      mediaPlayer &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 07 Jul 2018 14:28:00 +0000</pubDate>
<dc:creator>灰色飘零</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renhui/p/9269040.html</dc:identifier>
</item>
<item>
<title>关于单元测试的思考--Asp.Net Core单元测试最佳实践 - 李玉宝</title>
<link>http://www.cnblogs.com/yubaolee/p/DotNetCoreUnitTest.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yubaolee/p/DotNetCoreUnitTest.html</guid>
<description>&lt;p&gt;&lt;span&gt;在我们码字过程中，单元测试是必不可少的。但在从业过程中，很多开发者却对单元测试望而却步。有些时候并不是不想写，而是常常会碰到下面这些问题，让开发者放下了码字的脚步：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;这个类初始数据太麻烦，你看：new MyService(new User(&quot;test&quot;,1), new MyDAO(new Connection(......)),new ToManyPropsClass(......) .....) 。我：。。。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;这个代码内部逻辑都是和Cookie有关，我单元测试不好整啊，还是得启动到浏览器里一个按钮一个按钮点。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;这个代码内部读了配置文件，单元测试也不能给我整个配置文件啊？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;这个代码主要是验证WebAPI入口得模型绑定，必须得调用一次啊？&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这些问题确实存在，但它们阻止不了我们那颗要写单元测试的心。单元测试的优点很多，你或许可以不管。但至少能让你从那些需要在浏览器里点击10多下的操作里解脱出来。&lt;span&gt;&lt;strong&gt;本文从一个简单的逻辑测试出发，慢慢拉开测试的大幕，让你爱上测试。文章主要是传播一些单元测试的理念，其次才是介绍asp.net core中的单元测试。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文使用的环境为asp.net core 2.1 webapi，所有代码都发布到github:&lt;a href=&quot;https://github.com/yubaolee/DotNetCoreUnitTestSamples&quot; target=&quot;_blank&quot;&gt;https://github.com/yubaolee/DotNetCoreUnitTestSamples&lt;/a&gt; 项目依赖的包为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.AspNetCore.TestHost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.NET.Test.Sdk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;15.5.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Moq&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4.8.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NUnit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.9.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NUnit3TestAdapter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.9.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Linq&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4.3.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以直接修改csproj文件，也可以nuget导入。&lt;/p&gt;
&lt;p&gt;测试的业务逻辑为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserService{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CheckLogin(UserInfo user)
        {&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; user.Name ==&lt;span&gt; user.Password;  &lt;span&gt;//登录逻辑，&lt;span&gt;为了看着舒服，少点&lt;/span&gt;&lt;/span&gt;
        }
    }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserInfo{
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Password { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试的WebAPI控制器如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ControllerBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserService _service;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ValuesController(UserService service)
        {
            _service &lt;/span&gt;=&lt;span&gt; service;
        }

        [HttpGet]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;checklogin&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CheckLogin([FromQuery]UserInfo user)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _service.CheckLogin(user);
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;普通业务的单元测试&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestService
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserService _service;

        [SetUp]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Init()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server = &lt;span&gt;new&lt;/span&gt; TestServer(WebHost.CreateDefaultBuilder().UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;());
            _service &lt;/span&gt;= server.Host.Services.GetService&amp;lt;UserService&amp;gt;&lt;span&gt;();
        }
        [Test]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestLogin()
        {
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; result = _service.CheckLogin(&lt;span&gt;new&lt;/span&gt; UserInfo { Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yubao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yubao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            Assert.IsTrue(result);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;在做业务测试过程中要善于使用注入功能，而不是使用new对象的方式&lt;/strong&gt;&lt;/span&gt;，比如这里的Host.Services.GetService，防止出现new MyService(new User(&quot;test&quot;,1), new MyDAO(new Connection(......)),new ToManyPropsClass(......) .....)这种尴尬。用的越多你就越能体会这种做法的好处。我在&lt;a href=&quot;https://gitee.com/yubaolee/OpenAuth.Core&quot; target=&quot;_blank&quot;&gt;openauth.net&lt;/a&gt;中使用的是autofac的AutofacServiceProvider。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;测试Controller&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;很多时候我们需要测试顶层的controller（八成是controller里混的有业务逻辑）。这时我们可以快速的写出下面的测试代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestController
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ValuesController _controller;

        [SetUp]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Init()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server = &lt;span&gt;new&lt;/span&gt; TestServer(WebHost.CreateDefaultBuilder().UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;());
            _controller &lt;/span&gt;= server.Host.Services.GetService&amp;lt;ValuesController&amp;gt;&lt;span&gt;();
        }
        [Test]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestLogin()
        {
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; result = _controller.CheckLogin(&lt;span&gt;new&lt;/span&gt; UserInfo{Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yubao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yubao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;});
            Assert.IsTrue(result);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这段代码在JAVA spring mvc框架下是没有问题的，但在asp.net core 中，你会发现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/42655/201807/42655-20180706150115296-1292315701.jpg&quot; alt=&quot;&quot; width=&quot;752&quot; height=&quot;80&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取不到controller？&lt;span&gt;&lt;strong&gt;spring mvc的理念就是万物皆服务，哪怕是一个controller也是一个普通的服务。但微软不喜欢这样，默认时它要掌控controller的生死&lt;/strong&gt;&lt;/span&gt;（&lt;a href=&quot;https://www.strathweb.com/2016/03/the-subtle-perils-of-controller-dependency-injection-in-asp-net-core-mvc/&quot; target=&quot;_blank&quot;&gt;The Subtle Perils of Controller Dependency Injection in ASP.NET Core MVC&lt;/a&gt; 有人在声讨微软了）。所以我们不能通过普通的ServicCollection来注入和获取它，除非你指明Controller As Service，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc().AddControllersAsServices().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这时即可顺利测试通过。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;测试含有HTTP上下文的业务逻辑，比如Cookie、URL中的QueryString&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在平时的代码过程中，常常会和HTTP上下文HttpContext打交道，最常见的如request、response、cookie、querystring等，比如我们新的逻辑：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserService
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IHttpContextAccessor _httpContextAccessor;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserService(IHttpContextAccessor httpContextAccessor)
        {
            _httpContextAccessor &lt;/span&gt;=&lt;span&gt; httpContextAccessor;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsLogin()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _httpContextAccessor.HttpContext.Request.Cookies[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] != &lt;span&gt;null;&lt;/span&gt;&lt;span&gt;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这时如何测试呢？&lt;span&gt;&lt;strong&gt;马丁福勒在他的大作《企业应用架构模式》中明确指出“测试桩”的概念，来应对这种情况。各种Mock框架应运而生&lt;/strong&gt;&lt;/span&gt;。比如我最喜欢的Moq：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestCookie
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; UserService _service;

        [SetUp]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Init()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpContextAccessorMock = &lt;span&gt;new&lt;/span&gt; Mock&amp;lt;IHttpContextAccessor&amp;gt;&lt;span&gt;();
            httpContextAccessorMock.Setup(x &lt;/span&gt;=&amp;gt; x.HttpContext.Request.Cookies[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]).Returns(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yubaolee&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; server = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestServer(WebHost.CreateDefaultBuilder()
                .ConfigureServices(u &lt;/span&gt;=&amp;gt;u.AddScoped(x =&amp;gt;&lt;span&gt;httpContextAccessorMock.Object))
                .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;());
            _service &lt;/span&gt;= server.Host.Services.GetService&amp;lt;UserService&amp;gt;&lt;span&gt;();
        }
        [Test]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestLogin()
        {
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; result =&lt;span&gt; _service.IsLogin();
            Assert.IsTrue(result);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;  测试一次HTTP请求&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;&lt;strong&gt;有时我们需要测试Mvc框架的模型绑定，看看一次客户端的请求是否能被正确解析，亦或者测试WebAPI入口的一些Filter AOP等是否被正确触发，这时就需要测试一次HTTP请求&lt;/strong&gt;&lt;/span&gt;。从严格意义上来讲这种测试已经脱离的单元测试的范畴，属于集成测试。但这种测试代码可以节省我们大量的重复劳动。asp.net core中可以通过TestServer快速实现这种模拟：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestHttpRequest
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TestServer _testServer;

        [SetUp]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Init()
        {
            _testServer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; TestServer(WebHost.CreateDefaultBuilder().UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;());
        }
        [Test]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; TestLogin()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; client =&lt;span&gt; _testServer.CreateClient();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = client.GetStringAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/values/checklogin?name=yubao&amp;amp;password=yubao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(result.Result);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在进行单元测试的过程中，测试的理念（或者TDD的思维？）异常重要，它能帮助你构建和谐优美的代码。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 07 Jul 2018 14:23:00 +0000</pubDate>
<dc:creator>李玉宝</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yubaolee/p/DotNetCoreUnitTest.html</dc:identifier>
</item>
<item>
<title>Java并发编程之CyclicBarrier源码分析 - 狂小白</title>
<link>http://www.cnblogs.com/huangjuncong/p/9278623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangjuncong/p/9278623.html</guid>
<description>&lt;p&gt;&lt;strong&gt;JUC 中 回环屏障 CyclicBarrier 的使用与分析，它也可以实现像 CountDownLatch 一样让一组线程全部到达一个状态后再全部同时执行，但是 CyclicBarrier 可以被复用。那么 CyclicBarrier 内部的实现与 CountDownLatch 有何不同那？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　CounDownLatch在解决多个线程同步方面相对于调用线程的 join 已经提供了不少改进，但是CountDownLatch的计数器是一次性的，也就是等到计数器变为0后，再调用CountDownLatch的await （）和countDown()方法都会立刻返回，这就起不到线程同步的效果了。CyclicBarrier类的功能不限于CountDownLatch所提供的功能，从字面意思理解CyclicBarrier是回环屏障的意思，它可以实现让一组线程全部达到一个状态后再全部同时执行。这里之所以叫做回环是因为当所有等待线程执行完毕之后，重置CyclicBarrier的状态后可以被重用。下图演示了这一过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180707204048053-1599130210.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一.CyclicBarrier的实现原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　为了能一览CyclicBarrier的架构设计，下面先看下CyclicBarrier的类图，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180707205012500-972613654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上面类图，可以知道CyclicBarrier 内部并不是直接使用AQS实现，而是使用了独占锁ReentrantLock来实现的同步；parties用来记录线程个数，用来表示需要多少线程先调用await后，所有线程才会冲破屏障继续往下运行；而 count 一开始等一parties，每当线程调用await方法后就递减 1 ，当为 0 的时候就表示所有线程都到了屏障点，另外你可能会疑惑为何维护parties 和 count 这两个变量，只有count 不就行了吗？别忘了CyclicBarries是可以被复用的，使用两个变量原因是用parties始终来记录总的线程个数，当count计数器变为 0 后，会使用parties 赋值给count，已达到复用的作用。这两个变量是在构造CyclicBarries对象的时候传递的，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; CyclicBarrier(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; parties, Runnable barrierAction) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parties &amp;lt;= &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.parties =&lt;span&gt; parties;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.count =&lt;span&gt; parties;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.barrierCommand =&lt;span&gt; barrierAction;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里还有一个变量barrierConmmand也通过构造函数传递而来，这是一个任务，这个任务的执行时机是当所有线程都达到屏障点后。另外CyclicBarrier内部使用独占锁Lock来保证同时只有一个线程调用await方法时候才可以返回，使用lock首先保证了更新计数器count 的原子性，另外使用lock的条件变量 trip 支持了 线程间使用 notify，await 操作进行同步。&lt;/p&gt;
&lt;p&gt;最后变量generation内部就一个变量broken用来记录当前屏障是否被打破，另外注意这里broken并没有被声明为volatile ，这是因为锁内使用变量不需要。源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Generation {
        boolean broken &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来重点看一下CyclicBarrier的几个重要的函数，如下：&lt;/p&gt;
&lt;p&gt;　　1.int await() 当前线程调用 CyclicBarrier 的该方法时候，当前线程会被阻塞，知道满足下面条件之一才会返回：（1）parties 个线程都调用了 await()方法，也就是线程都到了屏障点。（2）其他线程调用了当前线程的interrupt（）方法中断了当前线程，则当前线程会抛出InterruptedException 异常返回。（3）当前屏障点关联的Generation对象的broken标志被设置为true的时候，会抛出 BrokenBarrierException 异常。源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;&lt;span&gt;() throws InterruptedException, BrokenBarrierException {
   &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; dowait(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;0L&lt;/span&gt;&lt;span&gt;);
   } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException toe) {
       &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(toe); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; cannot happen&lt;/span&gt;
&lt;span&gt;   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正如上面代码可以知道内部调用了dowait 方法，第一个参数false说明不设置超时时间，这时候第二个参数没有意义。&lt;/p&gt;

&lt;p&gt;　　2.boolean await(long timeout, TimeUnit unit) 当前线程调用 CyclicBarrier 的该方法时候当前线程会被阻塞，直到满足下面条件之一才会返回： （1） parties 个线程都调用了 await() 函数，也就是线程都到了屏障点，这时候返回 true。 (2) 当设置的超时时间到了后返回 false (3) 其它线程调用了当前线程的 interrupt（）方法中断了当前线程，则当前线程会抛出 InterruptedException 异常返回。 （4） 当前屏障点关联的 Generation 对象的 broken 标志被设置为 true 时候，会抛出 BrokenBarrierException 异常。源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;await&lt;/span&gt;(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; timeout, TimeUnit unit)
        throws InterruptedException,
               BrokenBarrierException,
               TimeoutException {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; dowait(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, unit.toNanos(timeout));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正如上面代码可以知道内部调用了dowait 方法，第一个参数true说明设置超时时间，这时候第二个参数是超时时间。&lt;/p&gt;

&lt;p&gt;　　3.int dowait(boolean timed, long nanos) 该方法是实现 CyclicBarrier 的核心功能，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; dowait(boolean timed, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nanos) throws InterruptedException, BrokenBarrierException,
               TimeoutException {
        final ReentrantLock &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt; = &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
             ...

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(1)如果index==0说明所有线程都到到了屏障点，则执行初始化时候传递的任务&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; index = --&lt;span&gt;count;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index == &lt;span&gt;0&lt;/span&gt;) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; tripped&lt;/span&gt;
                boolean ranAction = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;(2)执行任务&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (command != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        command.run();
                    ranAction &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（3）激活其它调用await而被阻塞的线程，并重置CyclicBarrier&lt;/span&gt;
&lt;span&gt;                    nextGeneration();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ranAction)
                        breakBarrier();
                }
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (4)如果index!=0&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（5）没有设置超时时间，&lt;/span&gt;
                     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;timed)
                        trip.&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt;();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（6）设置了超时时间&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (nanos &amp;gt; &lt;span&gt;0L&lt;/span&gt;&lt;span&gt;)
                        nanos &lt;/span&gt;=&lt;span&gt; trip.awaitNanos(nanos);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException ie) {
                    ...
                }
                    ...
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;.unlock();
        }
  }

   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; nextGeneration() {
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（7）唤醒条件队列里面阻塞线程&lt;/span&gt;
&lt;span&gt;       trip.signalAll();
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;（8） 重置CyclicBarrier&lt;/span&gt;
       count =&lt;span&gt; parties;
       generation &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Generation();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码是dowait方法的主干代码，当一个线程调用了dowait方法后首先会获取独占锁lock，如果创建CyclicBarrier的时候传递的参数为 10 ，那么后面 9 个调用线程会被阻塞；然后当前获取线程对计数器count进行递减操作，递减后的count = index = 9 ，因为 index != 0 ，所以当前线程会执行代码（4）。如果是无参数的当前线程调用的是无参数的await()方法，则这里 timed = false，所以当前线程会被放入条件变量trip的阻塞队列，当前线程会被挂起并释放获取的Lock锁；如果调用的有参数的await 方法 则timed = true，则当前线程也会被放入条件变量阻塞队列并释放锁的资源，但是不同的是当前线程会在指定时间超时后自动激活。&lt;/p&gt;
&lt;p&gt;当第一个获取锁的线程由于被阻塞释放锁后，被阻塞的 9 个线程中有一个会竞争到lock锁，然后执行第一个线程同样的操作，直到最后一个线程获取到lock的时候，已经有 9 个线程被放入了Lock 的条件队列里面，最后一个线程 count 递减后，count = index 等于 0 ，所以执行代码（2），如果创建CyclicBarrier的时候传递了任务，则在其他线程被唤醒前先执行任务，任务执行完毕后再执行代码（3），唤醒其他 9 个线程，并重置CyclicBarrier，然后这 10个线程就可以继续向下执行了。&lt;/p&gt;

&lt;p&gt;到目前位置理解了CyclicBarrier的原理后，接下来用几个例子来加深对CyclicBarrier的理解，下面例子我们要实现的是使用两个线程去执行一个被分解的任务 A，当两个线程把自己的任务都执行完毕后在对它们的结果进行汇总处理。例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.hjc;

import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/7.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CyclicBarrierTest1 {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个CyclicBarrier实例,添加一个所有子线程全部到达屏障后执行的一个任务&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; CyclicBarrier cyclicBarrier = &lt;span&gt;new&lt;/span&gt; CyclicBarrier(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; task1 merge result&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    });

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws InterruptedException {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个线程个数固定为2的线程池&lt;/span&gt;
        ExecutorService executorService = Executors.newFixedThreadPool(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加入线程A到线程池&lt;/span&gt;
        executorService.submit(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; task1-1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; enter in barrier&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    cyclicBarrier.&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt;();
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; enter out barrier&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                    e.printStackTrace();
                }
            }
        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加入线程B到线程池&lt;/span&gt;
        executorService.submit(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; task1-2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; enter in barrier&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    cyclicBarrier.&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt;();
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; enter out barrier&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                    e.printStackTrace();
                }
            }
        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭线程池&lt;/span&gt;
&lt;span&gt;        executorService.shutdown();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180707220105680-512975119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如上代码创建了一个 CyclicBarrier 对象，第一个参数为计数器初始值，第二个参数 Runable 是指当计数器为 0 时候需要执行的任务。main 函数里面首先创建了固定大小为 2 的线程池，然后添加两个子任务到线程池，每个子任务在执行完自己的逻辑后会调用 await 方法。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;一开始计数器为 2，当第一个线程调用 await 方法时候，计数器会递减为 1，由于计数器不为 0，所以当前线程就到了屏障点会被阻塞，然后第二个线程调用 await 时候，会进入屏障，计数器也会递减现在计数器为 0，就会去执行在 CyclicBarrier 构造时候的任务，执行完毕后就会退出屏障点，并且会唤醒被阻塞的第一个线程，这时候第一个线程也会退出屏障点继续向下运行。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;上面的例子说明了多个线程之间是相互等待的，假如计数器为 N，那么调用 await 方法的前面 N-1 的线程都会因为到达屏障点被阻塞，当第 N 个线程调用 await 后，计数器为 0 了，这时候第 N 个线程才会发出通知唤醒前面的 N-1 个线程。也就是全部线程达到屏障点时候才能一块继续向下执行，对与这个例子来说使用 CountDownLatch 也可以达到类似输出结果。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;下面在放个例子来说明 CyclicBarrier 的可复用性。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;假设一个任务由阶段 1、阶段 2、阶段 3 组成，每个线程要串行的执行阶段 1 和 2 和 3，多个线程执行该任务时候，必须要保证所有线程的阶段 1 全部完成后才能进行阶段 2 执行，所有线程的阶段 2 全部完成后才能进行阶段 3 执行，下面使用 CyclicBarrier 来完成这个需求。例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.hjc;

import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by cong on 2018/7/7.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CyclicBarrierTest2 {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个CyclicBarrier实例&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; CyclicBarrier cyclicBarrier = &lt;span&gt;new&lt;/span&gt; CyclicBarrier(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) throws InterruptedException {

        ExecutorService executorService &lt;/span&gt;= Executors.newFixedThreadPool(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加入线程A到线程池&lt;/span&gt;
        executorService.submit(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() +  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; step1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    cyclicBarrier.&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt;();

                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() +  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; step2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    cyclicBarrier.&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt;();

                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() +  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; step3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;                    e.printStackTrace();
                }
            }
        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加入线程B到线程池&lt;/span&gt;
        executorService.submit(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() +  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; step1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    cyclicBarrier.&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt;();

                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() +  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; step2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    cyclicBarrier.&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt;();

                    System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(Thread.currentThread() +  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; step3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;                    e.printStackTrace();
                }
            }
        });

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭线程池&lt;/span&gt;
&lt;span&gt;        executorService.shutdown();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1202638/201807/1202638-20180707220739202-1997365803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;如上代码，在每个子线程执行完 step1 后都调用了 await 方法，所有线程都到达屏障点后才会一块往下执行，这就保证了所有线程完成了 step1 后才会开始执行 step2，然后在 step2 后面调用了 await 方法，这保证了所有线程的 step2 完成后，线程才能开始 step3 的执行，这个功能使用单个 CountDownLatch 是无法完成的。&lt;/p&gt;
</description>
<pubDate>Sat, 07 Jul 2018 14:10:00 +0000</pubDate>
<dc:creator>狂小白</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangjuncong/p/9278623.html</dc:identifier>
</item>
<item>
<title>Python3 与 C# 扩展之～基础衍生 - 鲲逸鹏</title>
<link>http://www.cnblogs.com/dotnetcrazy/p/9278573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotnetcrazy/p/9278573.html</guid>
<description>&lt;pre&gt;
[(1, 1, 1),
 (1, 1, 2),
 (1, 2, 1),
 (1, 2, 2),
 (1, 3, 1),
 (1, 3, 2),
 (2, 1, 1),
 (2, 1, 2),
 (2, 2, 1),
 (2, 2, 2),
 (2, 3, 1),
 (2, 3, 2),
 (3, 1, 1),
 (3, 1, 2),
 (3, 2, 1),
 (3, 2, 2),
 (3, 3, 1),
 (3, 3, 2),
 (4, 1, 1),
 (4, 1, 2),
 (4, 2, 1),
 (4, 2, 2),
 (4, 3, 1),
 (4, 3, 2)]
&lt;/pre&gt;</description>
<pubDate>Sat, 07 Jul 2018 13:51:00 +0000</pubDate>
<dc:creator>鲲逸鹏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dotnetcrazy/p/9278573.html</dc:identifier>
</item>
</channel>
</rss>