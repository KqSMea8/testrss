<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>eclipse中将项目打包成jar的两种方法，及其问题与解决方法 - 天厌之</title>
<link>http://www.cnblogs.com/tianyanzhi/p/8067239.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianyanzhi/p/8067239.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一种：利用eclipse中自带的export功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一种方法分两种情况先来看第一种情况：&lt;strong&gt;没有引用外部jar的项目打包&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤一：&lt;/strong&gt;右键点击项目选择导出（export），选择java&amp;gt;jar文件(不是选择可运行jar文件)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1266294/201712/1266294-20171219184139037-829991110.png&quot; alt=&quot;&quot; width=&quot;399&quot; height=&quot;648&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1266294/201712/1266294-20171219184253131-117653222.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤二：&lt;/strong&gt;选择你要导出的项目以及文件，指定文件导出路径。连续点击两个下一步后到第四步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1266294/201712/1266294-20171219184505006-548040916.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p id=&quot;s4&quot;&gt;&lt;strong&gt;步骤三：&lt;/strong&gt;选择主类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1266294/201712/1266294-20171219185040240-174840904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照以上步骤即可&lt;span&gt;完成对&lt;/span&gt;一个不引用外部jar项目的打包。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;第二种情况：&lt;strong&gt;&lt;strong&gt;没有引用外部jar的项目打包&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当我们引用了外部jar后，使用eclipse自带的export打包略显繁琐。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;步骤一：&lt;/strong&gt;准备主清单文件 “ &lt;strong&gt;MAINFEST.MF&lt;/strong&gt; ”，放在项目的文件夹下面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MAINFEST.MF是jar的配置文件，第一行定义版本，第二行指出外部jar的路径，第三行是主类指示，第四行是空行。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Manifest-Version: &lt;span&gt;1.0&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; Class-Path: lib/&lt;span&gt;RXTXcomm.jar
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; Main-Class: com.main.Client&lt;br/&gt;4 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;值得注意的是，MAINFEST.MF编写需要严格规范，稍有不慎将会导致jar执行无效&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;第一行不能空，行与行之间不能有空行，每一行的最后一个字符不能是空格
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;最后一行一定是空行
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;每个属性的名称和值之间（冒号后面）一定要有空格
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 文件的每一行都不能超过72个字节（一般是70个ASCII字母加上回车换行符）；如果72个字节不够用，则另起一行并以空格开头：以空格开头的行都被视为前一行的续行。
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;详细规则这篇文章有讲到 &lt;a href=&quot;https://www.2cto.com/kf/201305/208332.html&quot; target=&quot;_blank&quot;&gt;MANIFEST.MF文件编写的注意事项&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤二：&lt;/strong&gt;与没有外部jar的项目一样，像上面那样先执行到&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/tianyanzhi/p/8067239.html#s4&quot;&gt;步骤三&lt;/a&gt;&lt;/span&gt;，不同的是要选着现有的清单，然后点击完成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1266294/201712/1266294-20171219222116240-602832622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以上就是第一种方法的两种情况，至此，我们已经可以生成jar包了。（如何运行jar文件？点击 &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/tianyanzhi/p/8067239.html#q1&quot;&gt;这里&lt;/a&gt;&lt;/span&gt;）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 第一种：利用eclipse插件Fat jar打包jar&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 步骤一：&lt;/strong&gt;先给eclipse安装好&lt;strong&gt;Fat jar插件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Fat jar 更新站点：  &lt;strong&gt;http://kurucz-grafika.de/fatjar&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1266294/201712/1266294-20171219222954225-938963403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;待文件加载出来后点击全部选中，一直下一步知道完成，会提示重启，安装完成。（Fat jar安装报错？点击 &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/tianyanzhi/p/8067239.html#q2&quot;&gt;这里&lt;/a&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤二：&lt;/strong&gt;右键点击项目名称，会看到&lt;strong&gt;build fat jar&lt;/strong&gt;，点击&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1266294/201712/1266294-20171219224123365-697112152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;步骤三：&lt;/strong&gt;配置jar的存放位置以及main类。&lt;/p&gt;
&lt;p&gt;红框内为必填，main-class点击browse选择主类。（无法点击browse？点击 &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/tianyanzhi/p/8067239.html#q3&quot;&gt;此处&lt;/a&gt;&lt;/span&gt; 查看解决方法）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1266294/201712/1266294-20171219224354881-465153087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;步骤四：&lt;/strong&gt;选择要打包的文件以及外部jar，点击完成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1266294/201712/1266294-20171219224826959-2037407500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;至此，我们完成了用fat jar插件打包含有外部jar的项目工程。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt; 中途可能遇到的问题以及解决方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;q1&quot;&gt; 问题一：&lt;strong&gt;打包好jar 文件后如何运行？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;第一种方法：cmd下直接键入Java -jar xxx.jar  开始运行。（可能需要切换盘符与文件夹，方法点 &lt;a href=&quot;https://jingyan.baidu.com/article/5552ef473e2df6518ffbc916.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;这里&lt;/span&gt;&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1266294/201712/1266294-20171219225758756-232110319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（如图是放在C盘用户&amp;gt;chen下面的jar）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;第二种方法：新建一个批处理文件，内容：Java -jar xxx.jar。放在与jar包同一个文件夹下面即可，然后双击运行查看效果。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1266294/201712/1266294-20171219230350459-1657706975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p id=&quot;q2&quot;&gt;问题二：&lt;strong&gt;安装Fat jar提示出错怎么办？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;在eclipse中&lt;/p&gt;
&lt;p&gt;Help -&amp;gt; Install New Software... -&amp;gt; Work with&lt;/p&gt;
&lt;p&gt;-&amp;gt; 选择“The Eclipse Project Updates - http://download.eclipse.org/eclipse/updates/4.7”&lt;/p&gt;
&lt;p&gt;-&amp;gt; 勾选&quot;Eclipse Tests,tools, Examples, and Extras&quot; 下的 &quot;Eclipse 2.0 Style Plugin Support&quot;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1266294/201712/1266294-20171219231225615-233700824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完后再安装Fat jar即可&lt;/p&gt;

&lt;p id=&quot;q3&quot;&gt; 问题三：&lt;strong&gt;为什么我的main-class无法browse文件？&lt;/strong&gt;（猜测可能有eclipse与Fat jar的版本兼容问题）&lt;/p&gt;
&lt;p&gt; 解决方法：&lt;/p&gt;
&lt;p&gt;先用eclipse自带的export查看main-class名字（export方法如 &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/tianyanzhi/p/8067239.html#s4&quot;&gt;上面&lt;/a&gt;&lt;/span&gt;），再复制粘贴填下去继续步骤。&lt;/p&gt;
&lt;p&gt;一般main-class为 &lt;span&gt;&lt;strong&gt;包名.主类名&lt;/strong&gt;&lt;/span&gt; ，可能不带Java、main等后缀&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1266294/201712/1266294-20171219232058928-2019469472.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;注：文中所用到的软件及版本如下&lt;/p&gt;
&lt;p&gt;eclips oxygen with官译插件&lt;/p&gt;
&lt;p&gt;jdk 9&lt;/p&gt;
&lt;p&gt;Fat jar插件&lt;/p&gt;

</description>
<pubDate>Tue, 19 Dec 2017 15:48:00 +0000</pubDate>
<dc:creator>天厌之</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tianyanzhi/p/8067239.html</dc:identifier>
</item>
<item>
<title>PHP之外观模式 - feiffy</title>
<link>http://www.cnblogs.com/feifeifanye/p/8068327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feifeifanye/p/8068327.html</guid>
<description>&lt;h3 id=&quot;外观facade模式&quot;&gt;外观(Facade)模式&lt;/h3&gt;
&lt;p&gt;当使用子系统的代码时，你也许会发现自己过于深入地调用子系统的逻辑代码。如果子系统代码总是在不断变化，而你的代码却又在许多不同地方与子系统代码交互，那么随着子系统的发展，你也许会发现维护代码变得非常困难。&lt;/p&gt;
&lt;p&gt;在项目中集成复杂的第三方代码，或在系统中逐渐形成大量仅在系统自身内部有用的代码，在这些情况下，你总可以应用外观模式，为复杂的系统创建一个简单、清晰的接口。&lt;/p&gt;
&lt;p&gt;假设有下面一段很乱的代码，其功能是从文件中获取log信息并将它转换为对象：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; getProductFileLines&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$file&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
{
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$file&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; getProductObjectFromID&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$id&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$productname&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
{
    &lt;span class=&quot;co&quot;&gt;// 一些数据库查询&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Product&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$id&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$productname&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; getNameFromLine&lt;span class=&quot;ot&quot;&gt;()&lt;/span&gt;
{
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;preg_match&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/.*-(.*)\s\d+/&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$array&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;str_replace&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'_'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;' '&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$array&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]);&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; getIDFromLine&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
{
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;fu&quot;&gt;preg_match&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/^(\d{1,3})-/&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$array&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;))&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$array&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;];&lt;/span&gt;
    }
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Product&lt;span class=&quot;ot&quot;&gt;()&lt;/span&gt;
{
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$id&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$name&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__construct&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$id&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$name&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
    {
        &lt;span class=&quot;kw&quot;&gt;$this&lt;/span&gt;-&amp;gt;id = &lt;span class=&quot;kw&quot;&gt;$id&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;$this&lt;/span&gt;-&amp;gt;id = &lt;span class=&quot;kw&quot;&gt;$name&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们的目的是将包含类似下面数据的文件转换为一个对象数组：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 234-ladies_jumper 55
 532-gents_hat 44&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端使用该功能时要调用所有的方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&lt;span class=&quot;kw&quot;&gt;$lines&lt;/span&gt; = getProductFileLines&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'text.txt'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;$objects&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$lines&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
    &lt;span class=&quot;kw&quot;&gt;$id&lt;/span&gt; = getIDFromLine&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;$name&lt;/span&gt; = getNameFromLine&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;$objects&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$id&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt; = getProductObjectFromID&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$id&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$name&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果在项目中直接调用这些方法，那么我们的代码会和子系统紧紧耦合在一起。当子系统变化时，或者我们决定将其与子系统完全断开时，代码就会出问题。&lt;/p&gt;
&lt;p&gt;下面这个简单的类为上面的过程式代码提供了一个接口：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProductFacade
{
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$products&lt;/span&gt; = &lt;span class=&quot;fu&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;
    
    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;__construct&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$file&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
    {
        &lt;span class=&quot;kw&quot;&gt;$this&lt;/span&gt;-&amp;gt;&lt;span class=&quot;fu&quot;&gt;file&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;$file&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;$this&lt;/span&gt;-&amp;gt;compile&lt;span class=&quot;ot&quot;&gt;();&lt;/span&gt;
    }

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; complie&lt;span class=&quot;ot&quot;&gt;()&lt;/span&gt;
    {
        &lt;span class=&quot;kw&quot;&gt;$lines&lt;/span&gt; = getProductFileLines&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$this&lt;/span&gt;-&amp;gt;line&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$lines&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;$id&lt;/span&gt; = getIDFromLine&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;$name&lt;/span&gt; = getNameFromLine&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$line&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;$this&lt;/span&gt;-&amp;gt;products&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$id&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;]&lt;/span&gt; = getProductObjectFromID&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$id&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$name&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
        }
    }

    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; getProducts&lt;span class=&quot;ot&quot;&gt;()&lt;/span&gt;
    {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$this&lt;/span&gt;-&amp;gt;products&lt;span class=&quot;ot&quot;&gt;;&lt;/span&gt;
    }

    &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; getProduct&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$id&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;)&lt;/span&gt;
    {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;$this&lt;/span&gt;-&amp;gt;product&lt;span class=&quot;ot&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;$id&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;];&lt;/span&gt;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，从一个log文件访问Product对象就简单多了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode php&quot;&gt;
&lt;code class=&quot;sourceCode php&quot;&gt;&lt;span class=&quot;kw&quot;&gt;$facade&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ProductFacade&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'test.txt'&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;$facade&lt;/span&gt;-&amp;gt;getProduct&lt;span class=&quot;ot&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;234&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;);&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;外观模式的好处：(1)对于调用者来说，访问代码变得简洁、非常方便.(2),由于只在一个地方调用子系统，减少了出错的可能.(3),Facade类还能使调用者避免不正确地使用内部方法，从而减少错误的发生。&lt;/p&gt;
&lt;p&gt;注1：这是《深入PHP：面对对象、模式与实践》第十章的部分内容（其他的都看不懂，逃～）&lt;br/&gt;注2：此文章也可以在我单独的博客里面看到: &lt;a href=&quot;https://feiffy.cc/%E3%80%8A%E6%B7%B1%E5%85%A5PHP%EF%BC%9A%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E3%80%81%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B#.E5.A4.96.E8.A7.82.28Facade.29.E6.A8.A1.E5.BC.8F&quot;&gt;https://feiffy.cc/%E3%80%8A%E6%B7%B1%E5%85%A5PHP%EF%BC%9A%E9%9D%A2%E5%AF%B9%E5%AF%B9%E8%B1%A1%E3%80%81%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%AE%9E%E8%B7%B5%E3%80%8B#.E5.A4.96.E8.A7.82.28Facade.29.E6.A8.A1.E5.BC.8F&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Dec 2017 15:43:00 +0000</pubDate>
<dc:creator>feiffy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feifeifanye/p/8068327.html</dc:identifier>
</item>
<item>
<title>AspNet Core Api Restful +Swagger  发布IIS  实现微服务之旅   （二） - 乐途</title>
<link>http://www.cnblogs.com/szlblog/p/8068311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/szlblog/p/8068311.html</guid>
<description>&lt;p&gt;上一步我们创建好CoreApi&lt;/p&gt;
&lt;p&gt;接下来在框架中加入 Swagger  并发布  到 IIS&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）首先点击依赖项》管理Nuget包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1027558/201712/1027558-20171219224218256-677869701.png&quot; alt=&quot;&quot; width=&quot;338&quot; height=&quot;143&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）输入 Swashbuckle.aspnetCore  比如：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1027558/201712/1027558-20171219224359131-647329100.png&quot; alt=&quot;&quot; width=&quot;834&quot; height=&quot;408&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中两个Swagger 插件需要我们安装   &lt;span&gt;注意：我这里已经安装过显示的是 卸载&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; （3） 在框架中 添加Swagger 注解的帮助类   HttpHeaderOperation  下面是我完整的.CS文件&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_38668675-3f5d-4a52-9207-176276cd25fc&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_38668675-3f5d-4a52-9207-176276cd25fc&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_38668675-3f5d-4a52-9207-176276cd25fc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加引用&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Swashbuckle.AspNetCore.Swagger;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Swashbuckle.AspNetCore.SwaggerGen;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Authorization;
&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; WebCoreApi
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpHeaderOperation : IOperationFilter
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 实现接口
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;operation&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Apply(Operation operation, OperationFilterContext context)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (operation.Parameters == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                operation.Parameters &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;IParameter&amp;gt;&lt;span&gt;();
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionAttrs =&lt;span&gt; context.ApiDescription.ActionAttributes();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isAuthorized = actionAttrs.Any(a =&amp;gt; a.GetType() == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(AuthorizeAttribute));

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isAuthorized == &lt;span&gt;false&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供action都没有权限特性标记，检查控制器有没有&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerAttrs =&lt;span&gt; context.ApiDescription.ControllerAttributes();

                isAuthorized &lt;/span&gt;= controllerAttrs.Any(a =&amp;gt; a.GetType() == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(AuthorizeAttribute));
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isAllowAnonymous = actionAttrs.Any(a =&amp;gt; a.GetType() == &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(AllowAnonymousAttribute));

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isAuthorized &amp;amp;&amp;amp; isAllowAnonymous == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
            {
                operation.Parameters.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; NonBodyParameter()
                {
                    Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authorization&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加Authorization头部参数&lt;/span&gt;
                    In = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Type &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    Required &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                });
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（4） 添加 Swagger 的·服务方法 在  Startup中的  ConfigureServices方法里&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_5fc87bcd-c473-417f-87f6-5738f932570d&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5fc87bcd-c473-417f-87f6-5738f932570d&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5fc87bcd-c473-417f-87f6-5738f932570d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc();
            services.AddSwaggerGen(x &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                x.SwaggerDoc(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Info
                {
                    Version &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;版本号&lt;/span&gt;
                    Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Szl接口文档&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标题&lt;/span&gt;
                    Description = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RESTful API &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    TermsOfService &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务的条件
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一个参数Name 创建人名称/也可以是 负责人名称     第二个参数 联系邮箱&lt;/span&gt;
                    Contact = &lt;span&gt;new&lt;/span&gt; Contact { Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Su&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Email = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;szl_0000@126.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; }
                });

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取设置配置信息的 的路径对象   swagger界面配置&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; basePath =&lt;span&gt; PlatformServices.Default.Application.ApplicationBasePath;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xmlPath = Path.Combine(basePath, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AspNetCoreApiSwagger.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                x.IncludeXmlComments(xmlPath);
                x.OperationFilter&lt;/span&gt;&amp;lt;HttpHeaderOperation&amp;gt;(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加httpHeader参数&lt;/span&gt;
&lt;span&gt;            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（5）添加 Swagger 启动项 在  Startup中的  Configure方法里&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_3d51ea2e-b78b-443c-8699-87d02503175f&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3d51ea2e-b78b-443c-8699-87d02503175f&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3d51ea2e-b78b-443c-8699-87d02503175f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseMvc();
            app.UseSwagger();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定站点&lt;/span&gt;
            app.UseSwaggerUI(x =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;做出一个限制信息 描述&lt;/span&gt;
                x.SwaggerEndpoint(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/swagger/v1/swagger.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TwBusManagement API V1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示在发出请求时发送的标题&lt;/span&gt;
&lt;span&gt;                x.ShowRequestHeaders();

            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（6） 在框架自动生成的 Api 控制器里Post的方法上加入 注解（其他方法也可以，我只是举例）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_815423a2-4d44-4ec4-bdeb-768f254f5fd1&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_815423a2-4d44-4ec4-bdeb-768f254f5fd1&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_815423a2-4d44-4ec4-bdeb-768f254f5fd1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; AspNet Core  Post请求
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;User类&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;remarks&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;访问参数
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;     POST 
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;     {  
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;        &quot;value&quot;: &quot;0e7ad584-7788-4ab1-95a6-ca0a5b444cbb&quot;,  
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;     }  
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;   
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/remarks&amp;gt;&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;response code=&quot;201&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;返回新创建项&lt;/span&gt;&lt;span&gt;&amp;lt;/response&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;response code=&quot;400&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;如果为空时&lt;/span&gt;&lt;span&gt;&amp;lt;/response&amp;gt;&lt;/span&gt; 
&lt;span&gt;
        [HttpPost]
        [ProducesResponseType(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(User), &lt;span&gt;201&lt;/span&gt;&lt;span&gt;)]
        [ProducesResponseType(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(User), &lt;span&gt;400&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Post([FromBody]User value)
        {
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;注解的含义如下&lt;/p&gt;
&lt;p&gt;summary 用来描述 方法的作用&lt;/p&gt;
&lt;p&gt;remarks 用来描述传入的参数格式/也可以把调用的值放入里面&lt;/p&gt;
&lt;p&gt;response 定义两个返回状态&lt;/p&gt;
&lt;p&gt;User 类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_32cbc470-0a23-4004-9725-743f9db5e97b&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_32cbc470-0a23-4004-9725-743f9db5e97b&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_32cbc470-0a23-4004-9725-743f9db5e97b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户ID
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; UserID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户名称
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; UserName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户年龄
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; UserAge { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;（7）在框架中   添加 AspNetCoreApiSwagger.xml 文件  一定要注意的是  xml 文件必须定义一个根节点 不然会报错  ，XML的属性   改为 始终复制   （XML文件在 第四步骤中有用到）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1027558/201712/1027558-20171219230013178-546823215.png&quot; alt=&quot;&quot; width=&quot;669&quot; height=&quot;102&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1027558/201712/1027558-20171219230044521-1943278547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（8）设置 项目的生成 输出路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1027558/201712/1027558-20171219231949803-302205997.png&quot; alt=&quot;&quot; width=&quot;788&quot; height=&quot;303&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（9）  发布   以文件夹发布就行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1027558/201712/1027558-20171219232101381-1670565755.png&quot; alt=&quot;&quot; width=&quot;1067&quot; height=&quot;215&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（10）部署IIS 说一下注意点     改成无托管代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1027558/201712/1027558-20171219232239303-219860094.png&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（11）打开IIS服务  中的模块&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1027558/201712/1027558-20171219232712053-1977097293.png&quot; alt=&quot;&quot; width=&quot;934&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（12）查看是否有  AspNetCoreModule  没有进行安装 我是在国外的网站下载的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1027558/201712/1027558-20171219232821631-356555212.png&quot; alt=&quot;&quot; width=&quot;1450&quot; height=&quot;295&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（13）  如果在运行部署的API  发生了错误&lt;/p&gt;
&lt;p&gt;我们在  Program  中加入  如代码所示  可以帮助我们准确定义的问题所在&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_956f3011-4c3c-4009-b849-18f3b9b5e2bf&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_956f3011-4c3c-4009-b849-18f3b9b5e2bf&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_956f3011-4c3c-4009-b849-18f3b9b5e2bf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            BuildWebHost(args).Run();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHost BuildWebHost(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
            WebHost.CreateDefaultBuilder(args)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发布程序出现错误帮助定位详细错误信息
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; .UseKestrel()
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.UseContentRoot(Directory.GetCurrentDirectory())
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.UseSetting(&quot;detailedErrors&quot;, &quot;true&quot;)
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;.UseIISIntegration()&lt;/span&gt;
&lt;span&gt;
      .CaptureStartupErrors(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
                .Build();



    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;OK  今天就完成了，&lt;/p&gt;

&lt;p&gt;以后会描述一下 框架的基础知识  比如  应用程序的启动、日子、路由、静态文件、WebSockteS  等，&lt;/p&gt;
&lt;p&gt;等到基础描述过后，在框架中加入一些我闷在实战中用到的，希望大家多多指出错误不足之处，这是我的学习。&lt;/p&gt;

</description>
<pubDate>Tue, 19 Dec 2017 15:39:00 +0000</pubDate>
<dc:creator>乐途</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/szlblog/p/8068311.html</dc:identifier>
</item>
<item>
<title>从零开始构建docker基础镜像 - 风雨咒之无上密籍</title>
<link>http://www.cnblogs.com/flowerbirds/p/8067900.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flowerbirds/p/8067900.html</guid>
<description>&lt;p&gt;　&lt;span&gt;段子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　今年基本已经结束了，我问了很多朋友今年挣钱了没？大多朋友都有挣，而且挣得五花八门：有挣个屁的，有挣个锤子的，有挣个毛的，更有甚者挣个妹的，奢侈之极！最恐怖的是挣个鬼的！有的还可以，挣个球，下午我碰见一朋友，问今年挣了吗？他望着天空喃喃自语：挣个鸟！看吧，只要肯努力，什么都能挣到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　年末将至，忽然发现，从创建开始到现在，整整一年时间，没有写过多少东西。为了留下一点痕迹，也是为了整理一下自己的收获，为17年画上一笔浓郁的色彩。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最近在看一本入门级机器学习的书，里面的案例基本上是python实现的，所以想搭建python相关的环境，然后又想偷懒，有一个运行环境，可以轻松安装和编写使用，也可以在其他地方使用，编写工具首选jupyter notebook，当然，在大多数的书中也是比较推荐这个工具，自己之前也使用过，觉得不错。还有个问题就是想在其他地方使用python环境和这个工具，不需要重复安装，此刻，我想到的是docker。之前对docker只是简单的理解，为此，特意学习了一下docker，现做分享。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1089791/201712/1089791-20171219213634646-1910850634.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;上图就是docker的图标，这个图标对docker的含义阐释的还是比较全面：小鲸鱼代表的是船，船上的就是集装箱，所有的东西不管是什么，只要装在集装箱中，就可以方便的运输。docker公司的口号是Build，Ship，and Run Any App，Anywhere。docker的本意是码头工人，而在这里说是集装箱的话，比较贴切。所有需要运行的环境和程序，装入docker，然后需要运行的时候，就运行这个特定的docker容器，提供特定的服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　docker的通俗解析：&lt;a title=&quot;docker&quot; href=&quot;https://www.zhihu.com/question/22969309&quot; target=&quot;_blank&quot;&gt;点击这里&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　刚开始的时候，搞不清楚docker和虚拟机有什么区别，总感觉docker能干的事虚拟机也能，并且在使用的时候，总按照虚拟机的操作思路去做。那docker为什么会出现？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我在docker的官方网站找到了两张关于虚拟机和容器的区别：&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;容器 VS 虚拟机&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1089791/201712/1089791-20171219215101271-57007469.png&quot; alt=&quot;VM&quot; width=&quot;500&quot;/&gt;        &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1089791/201712/1089791-20171219215121100-452629993.png&quot; alt=&quot;COntainer&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　关于容器：&lt;a title=&quot;容器&quot; href=&quot;https://www.docker-cn.com/what-container&quot; target=&quot;_blank&quot;&gt;点击这里&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于docker做了简单的了解之后，就需要实际去体验一下安装和构建容器，本例使用centos6.5：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.安装docker相关软件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@bogon ubuntu-&lt;span&gt;16.04&lt;/span&gt;]# &lt;strong&gt;rpm -ivh http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dl.Fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm&lt;/span&gt;&lt;/strong&gt;
Retrieving http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dl.Fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm&lt;/span&gt;
warning: /var/tmp/rpm-tmp.KYucBm: Header V3 RSA/&lt;span&gt;SHA256 Signature, key ID 0608b895: NOKEY
Preparing...                ########################################### [&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;%&lt;span&gt;]
   &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;:epel-release           ########################################### [&lt;span&gt;100&lt;/span&gt;%&lt;span&gt;]
[root@bogon ubuntu&lt;/span&gt;-&lt;span&gt;16.04&lt;/span&gt;]# &lt;span&gt;yum&lt;/span&gt; -y &lt;span&gt;install&lt;/span&gt; docker-&lt;span&gt;io
Loaded plugins: fastestmirror, refresh&lt;/span&gt;-&lt;span&gt;packagekit, security
Loading mirror speeds from cached hostfile
...

Complete&lt;/span&gt;!&lt;span&gt;
[root@bogon ubuntu&lt;/span&gt;-&lt;span&gt;16.04&lt;/span&gt;&lt;span&gt;]# service docker start
Starting cgconfig service:                                 [  OK  ]
Starting docker:                                       [  OK  ]
[root@bogon ubuntu&lt;/span&gt;-&lt;span&gt;16.04&lt;/span&gt;&lt;span&gt;]# chkconfig docker on
[root@bogon ubuntu&lt;/span&gt;-&lt;span&gt;16.04&lt;/span&gt;]#&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;使用service docker status查看docker服务状态的时候，发现没有启动 &lt;strong&gt;docker dead but pid file exists&lt;/strong&gt;，执行docker相关命令（如docker ps）的时候会出现&lt;strong&gt;Cannot connect to the Docker daemon. Is 'docker -d' running on this host?&lt;/strong&gt;，需要解决这个问题，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@bogon ubuntu-&lt;span&gt;16.04&lt;/span&gt;&lt;span&gt;]# service docker status
docker dead but pid &lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt; exists
[root@bogon ubuntu&lt;/span&gt;-&lt;span&gt;16.04&lt;/span&gt;]#&lt;span&gt;yum&lt;/span&gt;-config-manager --&lt;span&gt;enable public_ol6_latest
Loaded plugins: fastestmirror, refresh&lt;/span&gt;-&lt;span&gt;packagekit
[root@bogon ubuntu&lt;/span&gt;-&lt;span&gt;16.04&lt;/span&gt;]# &lt;span&gt;yum&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; -y device-mapper-event-&lt;span&gt;libs
Loaded plugins: fastestmirror, refresh&lt;/span&gt;-&lt;span&gt;packagekit, security
...&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.构建基础镜像&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;在使用docker的时候后，可以通过命令docker pull &amp;lt;镜像名称&amp;gt;从镜像库中获取，但是有时候会出现网络问题或是其他原因，导致无法拉取，在docker中国官网介绍使用通过 Docker 官方镜像加速来解决无法拉取：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;您可以使用以下命令直接从该镜像加速地址进行拉取：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;$ docker pull registry.docker-cn.com/myname/myrepo:mytag&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;例如:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;code&gt;$ docker pull registry.docker-cn.com/library/ubuntu:16.04&lt;/code&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　原文如下：&lt;a title=&quot;Docker 中国官方镜像加速&quot; href=&quot;https://www.docker-cn.com/registry-mirror&quot; target=&quot;_blank&quot;&gt;点击这里&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　而在本文中，我使用Dockerfile来构建基础镜像ubuntu 16.04（xenial），其对应的Dockerfile的Github地址为：&lt;a title=&quot;(xenial/Dockerfile)&quot; href=&quot;https://github.com/tianon/docker-brew-ubuntu-core/blob/1637ff264a1654f77807ce53522eff7f6a57b773/xenial/Dockerfile&quot; target=&quot;_blank&quot;&gt;点击这里&lt;/a&gt;，搜索方式为在&lt;a href=&quot;http://www.cnblogs.com/flowerbirds/p/hub.docker.com&quot; target=&quot;_blank&quot;&gt;hub.docker.com&lt;/a&gt;中搜索ubuntu，即可看见对应的镜像信息。Dockerfile内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
FROM scratch
ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /

# a few minor docker-specific tweaks
# see https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap
RUN set -xe \
        \
# https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L40-L48
        &amp;amp;&amp;amp; echo '#!/bin/sh' &amp;gt; /usr/sbin/policy-rc.d \
        &amp;amp;&amp;amp; echo 'exit 101' &amp;gt;&amp;gt; /usr/sbin/policy-rc.d \
        &amp;amp;&amp;amp; chmod +x /usr/sbin/policy-rc.d \
        \
# https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L54-L56
        &amp;amp;&amp;amp; dpkg-divert --local --rename --add /sbin/initctl \
        &amp;amp;&amp;amp; cp -a /usr/sbin/policy-rc.d /sbin/initctl \
        &amp;amp;&amp;amp; sed -i 's/^exit.*/exit 0/' /sbin/initctl \
        \
# https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L71-L78
        &amp;amp;&amp;amp; echo 'force-unsafe-io' &amp;gt; /etc/dpkg/dpkg.cfg.d/docker-apt-speedup \
        \
# https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L85-L105
        &amp;amp;&amp;amp; echo 'DPkg::Post-Invoke { &quot;rm -f /var/cache/apt/archives/*.deb /var/cache/apt/archives/partial/*.deb /var/cache/apt/*.bin || true&quot;; };' &amp;gt; /etc/apt/apt.conf.d/docker-clean \
        &amp;amp;&amp;amp; echo 'APT::Update::Post-Invoke { &quot;rm -f /var/cache/apt/archives/*.deb /var/cache/apt/archives/partial/*.deb /var/cache/apt/*.bin || true&quot;; };' &amp;gt;&amp;gt; /etc/apt/apt.conf.d/docker-clean \
        &amp;amp;&amp;amp; echo 'Dir::Cache::pkgcache &quot;&quot;; Dir::Cache::srcpkgcache &quot;&quot;;' &amp;gt;&amp;gt; /etc/apt/apt.conf.d/docker-clean \
        \
# https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L109-L115
        &amp;amp;&amp;amp; echo 'Acquire::Languages &quot;none&quot;;' &amp;gt; /etc/apt/apt.conf.d/docker-no-languages \
        \
# https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L118-L130
        &amp;amp;&amp;amp; echo 'Acquire::GzipIndexes &quot;true&quot;; Acquire::CompressionTypes::Order:: &quot;gz&quot;;' &amp;gt; /etc/apt/apt.conf.d/docker-gzip-indexes \
        \
# https://github.com/docker/docker/blob/9a9fc01af8fb5d98b8eec0740716226fadb3735c/contrib/mkimage/debootstrap#L134-L151
        &amp;amp;&amp;amp; echo 'Apt::AutoRemove::SuggestsImportant &quot;false&quot;;' &amp;gt; /etc/apt/apt.conf.d/docker-autoremove-suggests

# delete all the apt list files since they're big and get stale quickly
RUN rm -rf /var/lib/apt/lists/*
# this forces &quot;apt-get update&quot; in dependent images, which is also good

# enable the universe
RUN sed -i 's/^#\s*\(deb.*universe\)$/\1/g' /etc/apt/sources.list

# make systemd-detect-virt return &quot;docker&quot;
# See: https://github.com/systemd/systemd/blob/aa0c34279ee40bce2f9681b496922dedbadfca19/src/basic/virt.c#L434
RUN mkdir -p /run/systemd &amp;amp;&amp;amp; echo 'docker' &amp;gt; /run/systemd/container

# overwrite this with 'CMD []' in a dependent Dockerfile
CMD [&quot;/bin/bash&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;现在对Dockerfile中的相关命令解释一下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;FROM&lt;/strong&gt; 指的是依赖的基础镜像，如scratch表示的是空白的，从零开始的。依赖的镜像可以是本地的，也可以是远程库的&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;ADD&lt;/strong&gt; 指的是添加本地文件到镜像中，如果遇到linux可解压格式文件，会自动解压，这就是为什么整个文件中没有对tar.gz进行显式解压&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;RUN&lt;/strong&gt; 运行命令，如安装软件的相关命令&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;CMD&lt;/strong&gt; 设置启动Container时默认执行的命令，这个可以在启动容器时覆盖&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　目前，这个Dockerfile中涉及的命令就这几个，其他等以后遇到再进行说明。解释完毕，开始构建：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@bogon ubuntu-&lt;span&gt;16.04&lt;/span&gt;]# docker &lt;span&gt;ps&lt;/span&gt;&lt;span&gt;
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[root@bogon ubuntu&lt;/span&gt;-&lt;span&gt;16.04&lt;/span&gt;&lt;span&gt;]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
[root@bogon ubuntu&lt;/span&gt;-&lt;span&gt;16.04&lt;/span&gt;]# &lt;span&gt;pwd&lt;/span&gt;
/home/ml/ubuntu-&lt;span&gt;16.04&lt;/span&gt;&lt;span&gt;
[root@bogon ubuntu&lt;/span&gt;-&lt;span&gt;16.04&lt;/span&gt;]# ll -&lt;span&gt;h
total 40M
&lt;/span&gt;-rw-rw-r--. &lt;span&gt;1&lt;/span&gt; ml ml &lt;span&gt;2&lt;/span&gt;.8K Dec &lt;span&gt;19&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt;&lt;span&gt; Dockerfile
&lt;/span&gt;-rw-rw-r--. &lt;span&gt;1&lt;/span&gt; ml ml  40M Dec &lt;span&gt;19&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;39&lt;/span&gt; ubuntu-xenial-core-cloudimg-amd64-root.&lt;span&gt;tar&lt;/span&gt;&lt;span&gt;.gz
[root@bogon ubuntu&lt;/span&gt;-&lt;span&gt;16.04&lt;/span&gt;&lt;span&gt;]# 
[root@bogon ubuntu&lt;/span&gt;-&lt;span&gt;16.04&lt;/span&gt;]# docker build -t ubuntu:&lt;span&gt;16.04&lt;/span&gt;&lt;span&gt; .
Sending build context to Docker daemon &lt;/span&gt;&lt;span&gt;41.94&lt;/span&gt;&lt;span&gt; MB
Sending build context to Docker daemon 
Step &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt; : FROM scratch
 &lt;/span&gt;---&amp;gt;&lt;span&gt; 
Step &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; : ADD ubuntu-xenial-core-cloudimg-amd64-root.&lt;span&gt;tar&lt;/span&gt;.gz /
 ---&amp;gt;&lt;span&gt; 537c2f6dd023
Removing intermediate container dee7679a7ee2
Step &lt;/span&gt;&lt;span&gt;2&lt;/span&gt; : RUN set -xe &amp;amp;&amp;amp; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#!/bin/sh&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;gt; /usr/sbin/policy-rc.d &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;exit 101&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;gt;&amp;gt; /usr/sbin/policy-rc.d &amp;amp;&amp;amp; &lt;span&gt;chmod&lt;/span&gt; +x /usr/sbin/policy-rc.d &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span&gt;dpkg-divert --local --rename --add /sbin/initctl &amp;amp;&amp;amp; &lt;span&gt;cp&lt;/span&gt; -a /usr/sbin/policy-rc.d /sbin/initctl     &amp;amp;&amp;amp; &lt;span&gt;sed&lt;/span&gt; -i &lt;span&gt;'&lt;/span&gt;&lt;span&gt;s/^exit.*/exit 0/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; /sbin/initctl  &amp;amp;&amp;amp; \&lt;/span&gt;&lt;br/&gt;&lt;span&gt; ...---&amp;gt; Running &lt;span&gt;in&lt;/span&gt;&lt;span&gt; 41d719b68981
&lt;/span&gt;+ &lt;span&gt;echo&lt;/span&gt; #!/bin/&lt;span&gt;sh&lt;/span&gt;
+ &lt;span&gt;echo&lt;/span&gt; exit &lt;span&gt;101&lt;/span&gt;
+ &lt;span&gt;chmod&lt;/span&gt; +x /usr/sbin/policy-&lt;span&gt;rc.d
&lt;/span&gt;+ dpkg-divert --local --rename --add /sbin/&lt;span&gt;initctl
Adding &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;local diversion of /sbin/initctl to /sbin/initctl.distrib&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
+ &lt;span&gt;cp&lt;/span&gt; -a /usr/sbin/policy-rc.d /sbin/&lt;span&gt;initctl
&lt;/span&gt;+ &lt;span&gt;sed&lt;/span&gt; -i s/^exit.*/exit &lt;span&gt;0&lt;/span&gt;/ /sbin/&lt;span&gt;initctl
&lt;/span&gt;+ &lt;span&gt;echo&lt;/span&gt; force-unsafe-&lt;span&gt;io
&lt;/span&gt;+ &lt;span&gt;echo&lt;/span&gt; DPkg::Post-Invoke { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rm -f /var/cache/apt/archives/*.deb /var/cache/apt/archives/partial/*.deb /var/cache/apt/*.bin || true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;; };
&lt;/span&gt;+ &lt;span&gt;echo&lt;/span&gt; APT::Update::Post-Invoke { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rm -f /var/cache/apt/archives/*.deb /var/cache/apt/archives/partial/*.deb /var/cache/apt/*.bin || true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;; };
&lt;/span&gt;+ &lt;span&gt;echo&lt;/span&gt; Dir::Cache::pkgcache &lt;span&gt;&quot;&quot;&lt;/span&gt;; Dir::Cache::srcpkgcache &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;+ &lt;span&gt;echo&lt;/span&gt; Acquire::Languages &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;+ &lt;span&gt;echo&lt;/span&gt; Acquire::GzipIndexes &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;; Acquire::CompressionTypes::Order:: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;+ &lt;span&gt;echo&lt;/span&gt; Apt::AutoRemove::SuggestsImportant &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
 &lt;/span&gt;---&amp;gt;&lt;span&gt; c49bdbf61888
Removing intermediate container 41d719b68981
Step &lt;/span&gt;&lt;span&gt;3&lt;/span&gt; : RUN &lt;span&gt;rm&lt;/span&gt; -rf /var/lib/apt/lists&lt;span&gt;/*&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
 ---&amp;gt; Running in 6389964016a2
 ---&amp;gt; 4508181f7442
Removing intermediate container 6389964016a2
Step 4 : RUN sed -i 's/^#\s*\(deb.*universe\)$/\1/g' /etc/apt/sources.list
 ---&amp;gt; Running in cbed2b28c988
 ---&amp;gt; 8eed06df8f19
Removing intermediate container cbed2b28c988
Step 5 : RUN mkdir -p /run/systemd &amp;amp;&amp;amp; echo 'docker' &amp;gt; /run/systemd/container
 ---&amp;gt; Running in aff40dbc6e05
 ---&amp;gt; 19c96e7912a4
Removing intermediate container aff40dbc6e05
Step 6 : CMD /bin/bash
 ---&amp;gt; Running in 2469ee9d7251
 ---&amp;gt; 77e565a65647
Removing intermediate container 2469ee9d7251
Successfully built 77e565a65647
[root@bogon ubuntu-16.04]# docker images 
REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
ubuntu              16.04               77e565a65647        33 seconds ago      110.5 MB
[root@bogon ubuntu-16.04]#&lt;/span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;从构建日志可以看出，每条命令为一个step，执行完成之后会产生一个id，类似于6389964016a2，其实，这就是镜像的分层，一层层堆积在一起。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　到此，一个ubuntu16.04版的docker镜像构建完成，那么接下来就是运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.运行镜像&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　使用docker run命令运行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@bogon ubuntu-&lt;span&gt;16.04&lt;/span&gt;]# docker run -it ubuntu:&lt;span&gt;16.04&lt;/span&gt;&lt;span&gt;
root@5ea0b95e8641:&lt;/span&gt;/# &lt;span&gt;cat&lt;/span&gt; /etc/&lt;span&gt;issue
Ubuntu &lt;/span&gt;&lt;span&gt;16.04&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;&lt;span&gt; LTS \n \l

root@5ea0b95e8641:&lt;/span&gt;/# &lt;span&gt;ps&lt;/span&gt; -&lt;span&gt;ef
UID         PID   PPID  C STIME TTY          TIME CMD
root          &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;47&lt;/span&gt; ?        &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; /bin/&lt;span&gt;bash
root         &lt;/span&gt;&lt;span&gt;11&lt;/span&gt;      &lt;span&gt;1&lt;/span&gt;  &lt;span&gt;0&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;47&lt;/span&gt; ?        &lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;ps&lt;/span&gt; -&lt;span&gt;ef
root@5ea0b95e8641:&lt;/span&gt;/# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　其中5ea0b95e8641为当前容器的ID，进入容器查看所有进程，pid为1的时bash，linux不应该时init吗？其实，这就是容器与虚拟机的差别，容器的init进程就是主机上docker服务进程，每个容器只是一个进程而已。其中的参数-it指的是前端打开并分配一个终端，-d为在后台运行，我们试试当前这个可不可以使用-d：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@bogon ~]# docker run -d ubuntu:&lt;span&gt;16.04&lt;/span&gt;&lt;span&gt;
43ae7ded8e6920b55b8e744b52ffce37b89b25182fcacdc10a5414e6621abff3
[root@bogon &lt;/span&gt;~]# docker &lt;span&gt;ps&lt;/span&gt;&lt;span&gt;
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
[root@bogon &lt;/span&gt;~]# docker run -d ubuntu:&lt;span&gt;16.04&lt;/span&gt; /bin/&lt;span&gt;bash
77f3ec2ebfb3f154772683eeea8ca7e2ba3b7756b1488f5f09818af424e0298e
[root@bogon &lt;/span&gt;~]# docker &lt;span&gt;ps&lt;/span&gt;&lt;span&gt;
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;可以明显的开出来，使用-d后，docker ps查不到任何运行的容器，如果使用-it的话，在别的shell下使用docker ps查看：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@bogon ml]# docker &lt;span&gt;ps&lt;/span&gt;&lt;span&gt;
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
8341a332c788        ubuntu:&lt;/span&gt;&lt;span&gt;16.04&lt;/span&gt;        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/bash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;         &lt;span&gt;18&lt;/span&gt; seconds ago      Up &lt;span&gt;18&lt;/span&gt; seconds                           drunk_cori  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;可以看到，有容器在运行，因为我们没有退出。由此可以看出，容器其实以进程方式运行，执行完成/bin/bash之后，进程消亡，所以容器也就不存在，如果容器里面是一个tomcat服务，则是另外一种情况了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;基础镜像基本构建完成，后面的环境搭建，都将基于这个镜像构建。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 19 Dec 2017 15:32:00 +0000</pubDate>
<dc:creator>风雨咒之无上密籍</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flowerbirds/p/8067900.html</dc:identifier>
</item>
<item>
<title>CSS中line-height与vertical-align - 若若若邪</title>
<link>http://www.cnblogs.com/jaycewu/p/8068130.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jaycewu/p/8068130.html</guid>
<description>&lt;blockquote readability=&quot;0.65217391304348&quot;&gt;
&lt;p&gt;参考文章：&lt;br/&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNzAzMDY1NQ==&amp;amp;mid=206445305&amp;amp;idx=1&amp;amp;sn=899beb2d7e98194c000f9818c79f7778&amp;amp;scene=0#wechat_redirect&quot;&gt;深入了解CSS的line-height属性&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://mxd.tencent.com/vertical-align&quot;&gt;Vertical-Align: 你需要知道的所有事【译】&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://christopheraue.net/2014/03/05/vertical-align/&quot;&gt;Vertical-Align: All You Need To Know&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;什么是行间距或者行高line-height&quot;&gt;1、什么是行间距或者行高（line-height）&lt;/h3&gt;
&lt;p&gt;line-height是指文本行基线间的垂直距离。&lt;/p&gt;
&lt;h4 id=&quot;顶线中线基线底线&quot;&gt;1.1、顶线，中线，基线，底线&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-757a5ead60960914.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上到下分别是顶线，中线，基线，底线。vertical-align的四个属性top,middle,baseline,bottom就是与这四条线有关。&lt;/p&gt;
&lt;h4 id=&quot;行高行距半行距&quot;&gt;1.2、行高，行距，半行距&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;行高是指上下文本行基线间的垂直距离。（上图中两条红线间的垂直距离）&lt;/li&gt;
&lt;li&gt;行距是指一行底线到下一行顶线的垂直距离。（第一条粉线和第二条绿线间的垂直距离）&lt;/li&gt;
&lt;li&gt;半行距就是行距/2。(图中可以看出，半行距=(行高-字体size)/2 )&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-0d6db0a0be6aea55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;内容区行内框行框&quot;&gt;1.3、内容区，行内框，行框&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-c2700d187c56e2ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内容区：顶线和底线包裹的区域（字体的size）&lt;/li&gt;
&lt;li&gt;行内框：在没有其他因素影响的时候（padding等），行内框等于内容区。而设定行高时行内框高度不变，半行距分别增加/减少到内容区的上下两边（深蓝色区域）行框（line box）。（字体size不变，修改行高就是修改行距）&lt;/li&gt;
&lt;li&gt;行框：行框高度等于本行内所有元素中行内框最大的值（以行高值最大的行内框为基准，其他行内框采用自己的对齐方式向基准对齐，最终计算行框的高度），当有多行内容时，每行都会有自己的行框。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;line-height的设置&quot;&gt;1.4、line-height的设置&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;百分比方式设置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
  121212
  &amp;lt;p&amp;gt;121212&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;body{
  font-size:16px;
  line-height:120%;
}
p{
  font-size:32px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;line-height的百分比（120%）和body的字体大小（16px），被用来计算（16*120=19.2），这个值会被层叠下去的元素所继承。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-64f8ac452bd0518e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-78b4087a3cd4be60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;p{
  font-size:32px;
  line-height:60px;
  padding:10px
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终盒模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-0c2e089a48a24e41.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-433cdef3b48b6d29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;盒模型中，内容（不是上文说的内容区，上文的内容区是顶线与底线间的区域）的高度等于line-height的值。为什么会有margin？浏览器默认P的上下margin是1em,设置了P的font-size是32px,所以1em=32px。上下margin就是32px。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;长度方式（px）设置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
  121212
  &amp;lt;p&amp;gt;121212&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;body{
  font-size:16px;
  line-height:20px;
}
p{
  font-size:32px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-10466171680bb1e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-f96f2fa3cd805769.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值normal&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
  121212
  &amp;lt;p&amp;gt;121212&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;body{
  font-size:16px;
  line-height:normal;
}
p{
  font-size:32px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-07ca5eb22b4f162d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;body&quot;/&gt;&lt;/p&gt;
&lt;p&gt;body的line的line-height是22px,所以normal等于1.375&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-6f20ee57b87ffe34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;p的line-height：32px*1.375=44px（normal并不是精确的等于1.375）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-fa34a0ff48157fea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;纯数字&lt;/strong&gt;&lt;br/&gt;就是将normal改为一个想要的准确数字。&lt;/p&gt;
&lt;h4 id=&quot;各种box&quot;&gt;1.5、各种BOX&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
  &amp;lt;p&amp;gt;这个&amp;lt;em&amp;gt;强调&amp;lt;/em&amp;gt; 元素为行内元素&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;body{
  font-size:16px;
  line-height:1.5;
}
p{
  font-size:32px;
  padding:10px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-6da3ca94f2274bd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;containing box&lt;/strong&gt;&lt;br/&gt;p就是一个containing box，包含了其他boxs。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;inline box&lt;/strong&gt;&lt;br/&gt;在段落内，有一系列的inline box,inline box不会让内容成块显示，而是排成一行。“强调”是一种inline box,“这个”，“元素为行内元素”为一种匿名inline box。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;line box&lt;/strong&gt;&lt;br/&gt;多个inline box组成line box，多个line box组成containing box。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Content Area&lt;/strong&gt;&lt;br/&gt;Content Area是围绕着文字的一种看不见的box,高度取决与font-size&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;inline box与line-height&lt;/strong&gt;&lt;br/&gt;font-size:32px，line-height:48px，行间距=48px-32px=16px，半行间距=8px。&lt;br/&gt;半行间距会用在Content Area的顶部和底部。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-54c422b0a06e7682.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;这里inline box的高度就是line-height。inline box包着Content Area&lt;/p&gt;
&lt;p&gt;但是，当line-height小于font-size。line box的高度还是line-height,所以line-box的高度小于Content Area的高度，Content Area会溢出line-box。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-3c057a9446434303.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;inline box 与line box&lt;/strong&gt;&lt;br/&gt;line box的高度取决于他内部最高的inline box。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-bc4f96a4733b1fc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-fbe2f27a7b3c5d2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-3f348ef9d532567b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-d7d9db120455ff05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;vertical-align&quot;&gt;2、vertical-align&lt;/h3&gt;
&lt;p&gt;vertical-align是用来对齐内联级元素的。设置为以下display属性的元素，它们都被认为属于内联级元素。&lt;strong&gt;inline&lt;/strong&gt;、&lt;strong&gt;inline-block&lt;/strong&gt; or &lt;strong&gt;inline-table&lt;/strong&gt; (本文中不涉及此种情况)：&lt;/p&gt;
&lt;p&gt;inline内联元素基本上是包裹文本的标签。&lt;/p&gt;
&lt;p&gt;inline-block内联块元素则如它们的名字所示：拥有内联特性的块元素。他们可以有width和height（可能是由自己的内容定义），以及padding、border和margin。&lt;/p&gt;
&lt;p&gt;内联级元素彼此紧挨着放在一行中。一旦有更多的元素被放置到当前行中，一个新的行将会在它下面创建。所有这些行有所谓的“行框”，行框中包含所有的内容。不同大小的内容意味着不同高度的行框。在下面的插图中，行框的顶部和底部都是用红线表示的。&lt;br/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-7aab0dba5bc20d39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在行框中，元素的vertical-align属性是负责垂直对齐的。那么，到底元素垂直对齐的参照物是什么？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参照物：父元素的基线和外边缘&lt;/strong&gt;&lt;br/&gt;看看元素的基线和行框的外观：&lt;br/&gt;&lt;strong&gt;inline元素&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-08b7390e62d919fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三行并排的文本。行框的顶部和底部边缘用红线表示，字体的高度由绿线表示，基线由一条蓝线表示。在左边，有一个line-height设置为与字体font-size大小相同高度的文本，绿线和红线重叠在一条线上。在中间，line-height是字体的两倍大。在右边，line-height是字体大小的一半大。&lt;/p&gt;
&lt;p&gt;内联元素（display:inline）的外边缘与其行高的顶部和底部边缘对齐，行高可以小于字体的高度。所以，行框就是上面的图中的红线。&lt;/p&gt;
&lt;p&gt;内联元素的基线是字符放置的位置线（字母x底部所在的水平线），即图中的蓝线。粗略地说，基线是在字体1/2高度的下面的某个地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;inline-block元素&lt;/strong&gt;：&lt;br/&gt;inline-block因为已经有宽和高，可能存在多行，每行都有自己的基线和行框，所以会比较特殊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-924628ed8ffdeee1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中，最外层是div，里面分别是三个inline-block的span，黄色为border，绿色为padding，蓝色为content area（一个span，其中有一个字母“C”）。左边的inline-block的span的内容（span）是一个正常文档流元素。中间的inline-block的span还额外加了overflow: hidden。右边的inline-block的span包含一个流外的span(但内容区域有一个高度)(译者注：流内的元素必须是普通文档流（normal flow）中的元素，流外的元素必须是浮动或绝对定位的元素以及根元素。)。蓝线为每个inline-block的span的基线。内联块元素的外边缘是其margin框的顶部和底部边缘，即图中的红线。&lt;/p&gt;
&lt;p&gt;内联块元素（上图三个inline-block的span）的基线取决它包含的内容是否在文档流中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在流内内容的情况下，内联块元素的基线是正常流中最后一个内容元素的基线（左边的例子）。对于这最后一个元素，它的基线是根据它自己的规则找到的。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;demo1&quot;&amp;gt;
  x&amp;lt;span&amp;gt;
    x&amp;lt;span style=&quot;display:inline-block;height:30px;width:100px;background-color:blue&quot;&amp;gt;x&amp;lt;/span&amp;gt;
    x
  &amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;.demo1 span{
  display:inline-block;
  background-color:silver;
  height:90px;
  
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-e1f47b4cd9e6e5d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;灰色背景的元素内部有三个子元素，两个“x”,一个span。元素的基线就是最后一个正常流元素（“x”）的基线。&lt;br/&gt;修改元素的长度，使其内容出现多行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-62c45b8a73e166db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最外面的X怎么也跟着移动了？这涉及行框基线的移动，下文细说。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;在流内内容但内联块元素有overflow:hidden属性的情况下，基线是内联块元素margin框的底部边缘（例如在中间的图）。&lt;br/&gt;修改上面的例子样式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.demo1&amp;gt;span{
  display:inline-block;
  background-color:silver;
  height:90px;
  width:100px;
  margin:10px;
  overflow:hidden;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-97fa3f9c028cfce8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;通过最外面的x大致知道行框的基线位置，就是内联块元素的下外边距的地方，也是内联块元素元素的基线位置。&lt;br/&gt;&lt;strong&gt;一开始此处有疑惑&lt;/strong&gt;：内联块元素元素的基线跑到了下外边距处，那么元素里面的内容不应该以这条基线做定位吗？群里问了大佬，内联块元素已经设了宽高，可能有多行（即使只有一行），每行有各自的行框，然后又根据规则定位了，跟内联块元素的基线已经没有关系。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在流外内容的情况下，基线是内联块元素margin框的底部边缘（例如在右边）。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;demo1&quot;&amp;gt;
  x&amp;lt;span&amp;gt;
  &amp;lt;span style=&quot;display:inline-block;height:30px;width:100px;background-color:blue;&quot;&amp;gt;x&amp;lt;/span&amp;gt;
  &amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;.demo1&amp;gt;span{
  display:inline-block;
  background-color:silver;
  height:90px;
  width:100px;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-1bf79648253f0178.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加上浮动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;demo1&quot;&amp;gt;
  x&amp;lt;span&amp;gt;
  &amp;lt;span style=&quot;display:inline-block;height:30px;width:100px;background-color:blue;float:left&quot;&amp;gt;x&amp;lt;/span&amp;gt;
  &amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-e1340e0337c09cb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;行框的基线是可变的&lt;/strong&gt;&lt;br/&gt;当使用vertical-align时，基线放置在哪里可能是最令人疑惑的部分。它需要满足vertical-align的值和行框的高度等所有条件。基线的位置犹如是方程中的一个自由参数。&lt;/p&gt;
&lt;p&gt;行框的基线是看不见的，但你可以使它很容易看到。只要在文本行的开头添加一个字符，像我增加了一个“X”的字母。如果这个字符不以任何方式对齐，它将默认地坐在基线上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-17a321a13fb1de4e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;围绕着行框的基线的部分（绿线），我们可以称其为文本框。文本框可以简单地被认为是行框内的内联元素，没有任何对齐。文本框的高度等于它的父元素的字体大小。因此，文本框只围住了行框内的无格式文本。由于这个文本框是绑在基线上的，当基线移动时它将移动。（注：此文本框在W3C规范中称为“strut（支柱）”）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vertical-align的值&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;1）将元素的基线，参照父元素的基线对齐&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-be511377e0cbfe01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;baseline：元素的基线与父元素的基线对齐。&lt;/p&gt;
&lt;p&gt;sub：元素的基线偏移到父元素的基线之下。&lt;/p&gt;
&lt;p&gt;sup：元素的基线偏移到父元素的基线之上。&lt;/p&gt;
&lt;p&gt;：元素的基线相对于父元素的基线偏移了一个百分比（该百分比是对比元素自身的line-height计算得出）。&lt;/p&gt;
&lt;p&gt;：元素的基线相对于父元素的基线偏移了一个绝对长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）将元素的中心点，参照父元素的基线对齐&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-7e62e2f007fae25b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;middle：将元素的顶部和底部之间的中心点，对齐父元素的基线之上x-height的1/2之处（x-height为字母x的字符高度）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）将元素的外边缘，参照父元素的文本框对齐&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-ad50fa22b3971468.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;text-top：将元素的顶部边缘，对齐到父元素的文本框的顶部边缘。&lt;/p&gt;
&lt;p&gt;text-bottom：将元素的底部边缘，对齐到父元素的文本框的底部边缘。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）将元素的外边缘，参照父元素行框的外边缘对齐&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-22702eed5b65c234.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;top：元素的顶部边缘对齐到父元素的顶部边缘。&lt;/p&gt;
&lt;p&gt;bottom：元素的底部边缘对齐到父元素的底部边缘。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基线的移动&lt;/strong&gt;&lt;br/&gt;如果一行中有一个高个的元素占据了整行的高度，那么vertical-align对它没有影响。它的顶部和底部没有空间让它移动。为了满足行框基线的对齐方式，行框的基线必须移动。矮个元素设置了vertical-align: baseline。在左边，高个元素设置了vertical-align: text-bottom。在右边，高个元素设置了vertical-align: text-top。你可以看到右边的基线跳起来了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-c1814fe05aab774b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（左）将两个元素放在一行中并设置vertical-align ，它们会使得行框的基线移动到符合它俩的对齐规则之处，然后行框的高度也会随之调整。（中）添加第三个元素，不超越行框的边缘，既不影响行框的高度，也不影响基线的位置。（右）添加第三个元素，如果它超出了行框的边缘，行框的高度和基线调整。在这种情况下，我们的前两个元素也会跟着发生变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-2116d86a4125a740.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内联级元素底部的小间隙&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-09bed4e30dbca377.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;列表项坐在基线上。下面的一点空间，是文本的基线以下预留的depth（在W3C规范中，一个字体的基线以上称为characteristic height，基线以下称为depth）。想要去掉这个depth空隙，有解决的办法吗？只要移动基线的位置就可以，例如通过设置列表项目vertical-align: middle&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;水平垂直居中&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;div class=&quot;box&quot;&amp;gt;
        &amp;lt;div class=&quot;content&quot;&amp;gt;
          自适应垂直居中
        &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;html{
  height:100%;
}
body{   
   height: 100%;  
   width: 100%;  
}
.box{
   display:inline-block;
   text-align: center;
   width:50%;
   height:50%;
   background-color:#e1e3cd;
   overflow:hidden;
}
.box:after{
    content:&quot;&quot;;
    display:inline-block;
    height:100%;
    vertical-align:middle;
}
.content{
    vertical-align:middle;
    background-color:silver;
    display: inline-block;
    width: 50%;
    height:50%;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2125695-0ebe9d2f22f572c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要将content水平垂直居中定位在box里，利用vertical-align是其中一种方法。原理是：vertical-align：middle（将元素的顶部和底部之间的中心点，对齐父元素的基线之上x-height的1/2之处（x-height为字母x的字符高度）。），content肯定是要垂直居中的，那只能修改行框的基线位置（&lt;strong&gt;注意：不是修改box的基线，box具有宽高，它里面的内容可能会有多行，每行有各自的行框，box的基线已经不会影响内容的布局，但是box的基线还是会受里面内容的影响（内联块元素的基线是正常流中最后一个内容元素的基线）&lt;/strong&gt;），使其位于box的垂直中心位置。修改行框的基线，只要在box内加一个高度为100%的空元素，然后设置vertical-align:middle，添加的元素已经占满整个行框高度，而只要移动行框的基线，就可以满足定位规则，所以行框的基线就被移动到box垂直中心位置。content再按规则对齐到行框基线上就可以了。&lt;/p&gt;
</description>
<pubDate>Tue, 19 Dec 2017 14:47:00 +0000</pubDate>
<dc:creator>若若若邪</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jaycewu/p/8068130.html</dc:identifier>
</item>
<item>
<title>线性回归模型----机器学习随笔三 - 蜡笔小鸡</title>
<link>http://www.cnblogs.com/LingoXu/p/8046741.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LingoXu/p/8046741.html</guid>
<description>&lt;p&gt;在前两篇博文中，主要对感知器的模型推导做了一些阐述，并顺手实现了算法。&lt;/p&gt;
&lt;p&gt;可以发现单个感知器算法的实现过程中，权值调整的收敛条件，是依靠一个比较绝对的判断的，这个绝对的意思就是：训练数据绝对正确（我们不断地迭代修改权值，当响应与训练数据的期望一致时，停止迭代）。&lt;/p&gt;
&lt;p&gt;这在数据比较工整的时候，效果还不错。如果我们的训练数据里包含了错误的分类，这样绝对的收敛条件仍然是正确的吗？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;申明：本博文的公式仅仅是用来辅助推导的，如果看不懂，只要明白这个公式的意义就行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然如果有兴趣的，可以自己尝试一下推导这些公式&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;2.1直观印象&lt;/h2&gt;
&lt;p&gt;线性回归可以直观的展示如下所示&lt;/p&gt;
&lt;p&gt;我们可以看出线性回归的直接作用就是找出一条“最佳的直线”，预测出y（纵坐标）于x（横坐标）的关系。&lt;/p&gt;
&lt;p&gt;这里并不会有很多的数学公式来定义这个“最佳直线”，可以用一句话来说清楚这个“最佳”-----最接近数据本身要表达的意义。&lt;/p&gt;
&lt;p&gt;那这些数据要表达的意义是什么呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/901606/201712/901606-20171219194256631-1466329402.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;

&lt;p&gt;我们来想想一下这个场景，我们测量一个通过电阻的电流 于 电阻两端的电压（不断地增加电流大小，测出电阻两端地电压）。&lt;/p&gt;
&lt;p&gt;电压于电阻的关系 可以看成一条直线 y=ax。&lt;/p&gt;
&lt;p&gt;由于环境地温度或者湿度等等因素地影响，测出的电压-电流关系 并不是一条工整的直线（如上图所示）。&lt;/p&gt;
&lt;p&gt;那么是不是就无法测量出电阻的大小了呢？（电压除以电流）&lt;/p&gt;
&lt;p&gt;答案是否定的，假如环境的误差是随机产生的，那么在这个环境中测量出的数据，是服从正态分布的（如下图所示）&lt;/p&gt;
&lt;p&gt;如下所示，我们可以这么理解：假如环境对每次的测量的干扰是随机的（本次测量与上次产生误差的概率相同），数据的均值是不发生变化的（数据的真实意义），测量出的数据有68.2%的数据落在一倍均方差范围之内，99.7%的数据落在3倍均方差的范围之内。（2倍的情况大家可以自己算一下）&lt;/p&gt;
&lt;p&gt;如果都明白了这个关系，我们可以尝试一下，用这个方法，去倾听数据要表达的真是意思了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/901606/201712/901606-20171219201624943-1814591168.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;2.2 高斯分布&lt;/h2&gt;
&lt;p&gt;如下所示，就是高斯分布的函数了。&lt;/p&gt;
&lt;p&gt;我们发现这个高斯函数少了一个表示数据均值的 参数u,大家简单理解为u=0即可。&lt;/p&gt;
&lt;p&gt;一定要刨根问到底，我个人的理解是这样的，高斯分布专注于研究数据噪声，对样本的均值并不感兴趣。找到能产生最小噪声的位置（数据出现概率最大的位置），一定就是数据的真实意义所在的位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/901606/201712/901606-20171219204451381-758135316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公式中的ε表示测量误差&lt;/p&gt;


&lt;h2&gt;2.3 测量误差&lt;/h2&gt;
&lt;p&gt;在提测量误差之前，我们先给出线性回归的模型如下：&lt;/p&gt;
&lt;p&gt;求和符号表示多维数据，一维的就仅仅是d=w*x+ε&lt;/p&gt;
&lt;p&gt;x表示输入数据，w表示回归系数（权值），d表示数据的期望响应（不是统计学上的期望值，而是我们数据的真实测量结果）&lt;/p&gt;
&lt;p&gt;w*x 表示回归模型的计算结果（测量结果）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/901606/201712/901606-20171219210618521-1718605451.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们将误差带入高斯函数中。得到如下所示的形式，这表示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/901606/201712/901606-20171219211832021-54544607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在回归模型中，这表示为观测密度，用通俗的话说就是，&lt;span&gt;取一个权值（回归系数）此时权值固定，计算出正确结果的（观测）概率。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我们上面说的模型，关注于观测误差（模型计算的预测结果与真实测量结果）这个层面的问题。&lt;/p&gt;
&lt;p&gt;但是我们要考虑一点，计算出正确结果是否是随意取一个权值就可以呢，如果权值的选择是错误的，计算出正确结果的概率还是如上面的公式那样吗？&lt;/p&gt;
&lt;p&gt;假如权值选择是错误的,但是由于权值的误差存在,导致模型能够计算出正确结果。这样的情况，我们并没有排除。&lt;/p&gt;
&lt;p&gt;毕竟我们直观的感受就是，这次测量正确的概率是多少。&lt;/p&gt;
&lt;p&gt;例如早晨上班迟到这个事件。&lt;/p&gt;
&lt;p&gt;假如迟到与是否睡过头/路上是否堵车2个事件相关，并且遇到睡过头+堵车同时发生在你的身上，你才会迟到。&lt;/p&gt;
&lt;p&gt;那么我们要计算你迟到的概率，就必须将你睡过头的概率与堵车的概率相乘。这才是你迟到的概率。&lt;/p&gt;

&lt;p&gt;同理，要知道一个回归模型的预测结果是否正确，就需要&lt;span&gt;回归系数正确+观测结果正确这两个条件同时满足&lt;/span&gt;。回归模型预测的正确的概率，如下所示，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/901606/201712/901606-20171219214609740-771411454.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;上面这个公式给表明 回归模型计算正确结果的概率 ，不仅仅与观测密度有关，还要乘以一个权值被正确选择的概率。&lt;/p&gt;
&lt;p&gt;这  &lt;img src=&quot;http://images2017.cnblogs.com/blog/901606/201712/901606-20171219220308803-67804378.png&quot; alt=&quot;&quot;/&gt;可以理解为回归系数正确的概率（实际上表示回归系数）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/901606/201712/901606-20171219214805521-578066488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最终化简为如下形式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/901606/201712/901606-20171219221440771-1095492816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这个公式表达的意思为：模型预测正确的概率与式子右边的指数函数成正比。&lt;/p&gt;

&lt;p&gt;回到正题，我们要计算出能够使整个概率达到最大值的回归系数（权值）w。&lt;/p&gt;
&lt;p&gt;这里用一个数学变换，将这个问题转换为找到回归系数，使下式的能取到最小值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/901606/201712/901606-20171219222000537-208263361.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/901606/201712/901606-20171219222822240-115619844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上市所述，我们引入了一个参数 λ，这个表示我们对模型误差大小的定义。&lt;/p&gt;
&lt;p&gt;假如我们对模型非常有信心（我们的数据采集非常的顺利，几乎能肉眼看出数据关系的），那么可以取λ=0；&lt;/p&gt;
&lt;p&gt;另一种情况就是相反的，我们的数据采集过程中存在大量的干扰项，那么可以取λ为无穷大。&lt;/p&gt;
&lt;p&gt;λ的取值范围[0,∞)，这在机器学习中是一个非常重要的参数。&lt;/p&gt;


&lt;h2&gt;2.4 回顾&lt;/h2&gt;

&lt;p&gt;1 根据线性回归的直观显示，去寻找数据要表达的真正意义；&lt;/p&gt;
&lt;p&gt;2 根据对随机实验的特性，我们找到了定义误差的方法，并且拿到了趁手的工具（高斯分布函数），凭曲线救国，去寻早能使回归模型误差最小的的回归系数。&lt;/p&gt;
&lt;p&gt;3 分析事件的相关性，确认更加具有普遍性的函数关系。&lt;/p&gt;
&lt;p&gt;4 归化问题为一个求二次函数的最小值问题&lt;/p&gt;

</description>
<pubDate>Tue, 19 Dec 2017 14:38:00 +0000</pubDate>
<dc:creator>蜡笔小鸡</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LingoXu/p/8046741.html</dc:identifier>
</item>
<item>
<title>再说Postgres中的高速缓存(cache) - 非我在</title>
<link>http://www.cnblogs.com/flying-tiger/p/8038202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flying-tiger/p/8038202.html</guid>
<description>&lt;p&gt;表的模式信息存放在系统表中，因此要访问表，就需要首先在系统表中取得表的模式信息。对于一个PostgreSQL系统来说，对于系统表和普通表模式的访问是非常频繁的。为了提高这些访问的效率，PostgreSQL设立了高速缓存(Cache)来提高访问效率。&lt;/p&gt;
&lt;p&gt;Cache中包括一个&lt;strong&gt;系统表元组Cache(SysCache)&lt;/strong&gt;和一个&lt;strong&gt;表模式信息Cache(RelCache)&lt;/strong&gt;。其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SysCache中存放的是最近使用过的&lt;strong&gt;系统表的元组&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;RelCache中包含所有最近访问过的&lt;strong&gt;表的模式信息(包含系统表的信息)&lt;/strong&gt;。RelCache中存放的不是元组，而是RelationData数据结构,每一个RelationData结构表示一个表的模式信息，这些信息都由系统表元组中的信息构造而来。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;值得注意的是，两种Cache都不是所有进程共享的。每一个PostgreSQL的进程都维护着自己的SysCache和RelCache。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;SysCache主要用于缓存系统表元组。从实现上看SysCache就是一个数组，数组的长度为预定义的系统表的个数。在PostgreSQL9.5.6中实现了55个系统表，因此SysCache数组具有55个元素，每个元素的数据结构为CatCache,该结构体内使用Hash来存储被缓存的系统表元组，每一个系统表唯一地对应一个SysCache数组中的CatCache结构。每个CatCache都有若干个(不超过4个）査找关键字，这些关键字及其组合可以用来在CatCache中查找系统表元组，在初始化数据集簇时会在这些关键字上为系统表创建索引。&lt;/p&gt;
&lt;p&gt;其中涉及到的数据类型的简要意义如下，我们先有个印象，以免后面遇到了感到奇怪和陌生：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
 *      struct catctup:         individual tuple in the cache.
 *      struct catclist:        list of tuples matching a partial key.
 *      struct catcache:        information for managing a cache.
 *      struct catcacheheader:  information for managing all the caches.
 */&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;syscache初始化&quot;&gt;1.1 SysCache初始化&lt;/h2&gt;
&lt;p&gt;在Postgres进程初始化时（在InitProgres中），将会对SysCache进行初始化。SysCache的初始化实际上是填充SysCache数组中每个元素的CatCache结构的过程，主要任务是将査找系统表元组的关键字信息写入SysCache数组元素中。这样通过指定的关键字可以快速定位到系统表元组的存储位置。&lt;br/&gt;CatCache的数据结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct catcache
{
    int         id;             /* cache identifier --- see syscache.h */
    slist_node  cc_next;        /* list link */
    const char *cc_relname;     /* name of relation the tuples come from */
    Oid         cc_reloid;      /* OID of relation the tuples come from */
    Oid         cc_indexoid;    /* OID of index matching cache keys */
    bool        cc_relisshared; /* is relation shared across databases? */
    TupleDesc   cc_tupdesc;     /* tuple descriptor (copied from reldesc) */
    int         cc_ntup;        /* # of tuples currently in this cache */
    int         cc_nbuckets;    /* # of hash buckets in this cache */
    int         cc_nkeys;       /* # of keys (1..CATCACHE_MAXKEYS) */
    int         cc_key[CATCACHE_MAXKEYS];       /* AttrNumber of each key */
    PGFunction  cc_hashfunc[CATCACHE_MAXKEYS];  /* hash function for each key */
    ScanKeyData cc_skey[CATCACHE_MAXKEYS];      /* precomputed key info for
                                                 * heap scans */
    bool        cc_isname[CATCACHE_MAXKEYS];    /* flag &quot;name&quot; key columns */
    dlist_head  cc_lists;       /* list of CatCList structs */
#ifdef CATCACHE_STATS
    long        cc_searches;    /* total # searches against this cache */
    long        cc_hits;        /* # of matches against existing entry */
    long        cc_neg_hits;    /* # of matches against negative entry */
    long        cc_newloads;    /* # of successful loads of new entry */

    /*
     * cc_searches - (cc_hits + cc_neg_hits + cc_newloads) is number of failed
     * searches, each of which will result in loading a negative entry
     */
    long        cc_invals;      /* # of entries invalidated from cache */
    long        cc_lsearches;   /* total # list-searches */
    long        cc_lhits;       /* # of matches against existing lists */
#endif
    dlist_head *cc_bucket;      /* hash buckets */
} CatCache;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在SysCache.c文件中已经将所有系统表的CatCache信息存储在一个名为cacheinfo的静态数组&lt;br/&gt;中，每个系统表的CatCache信息用一个数组元素来描述，其数据类型为cachedesc：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct cachedesc
{
    Oid         reloid;         /* OID of the relation being cached */
    Oid         indoid;         /* OID of index relation for this cache */
    int         nkeys;          /* # of keys needed for cache lookup */
    int         key[4];         /* attribute numbers of key attrs */
    int         nbuckets;       /* number of hash buckets for this cache */
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Postgres进程初始化时，会调用InitCatalogCache函数对SysCache数组进行初始化，并建立由CacheHdr记录的CatCache链表。&lt;/p&gt;
&lt;p&gt;InitCatalogCache函数中对SysCache的初始化主要分为以下儿个步骤：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;1)根据cacheinfo为SysCache数组分配空间，这里将SysCache的长度设置为和cacheinfo数组相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;2)循环调用InitCatcache函数根据cacheinfo中的每一个元素生成CatCache结构并放人SysCache数组的对应位置中。InitCatcache每调用一次将处理一个cachedesc结构。该函数根据cachedesc中要求的Hash桶的数量&lt;br/&gt;为即将建立的CatCache结构分配内存，并根据cachedesc结构中的信息填充CatCache的各个字段。&lt;br/&gt;最后将生成的CatCache链接在CacheHdr所指向的链表的头部。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在InitCatalogCache函数中实际只完成了SysCache初始化的第一个阶段，在稍后被调用的函数&lt;br/&gt;RelationCachelnitializePhase2(负责 RelCache 的初始化)还将调用InitCalcachePhase2进行第二阶段也是最后的SysCache初始化工作。InitCatcachePhase2将依次完善SysCache数组中的CatCache结构，&lt;br/&gt;主要是根据对应的系统表填充CatCache结构中的元组描述符(cc_tupdesc)、系统表名(cc_relname)、査找关键字的相关字段(cc_hashfunc、cc_isname、cc_skey)等。&lt;/p&gt;
&lt;p&gt;SysCache数组初始化完成之后，CalCache内是没有任何元组的，但是随着系统运行时对于系统表元组的访问，CatCache中的系统表元组会逐渐增多。&lt;/p&gt;
&lt;h2 id=&quot;catcache中缓存元组的组织&quot;&gt;1.2 CatCache中缓存元组的组织&lt;/h2&gt;
&lt;p&gt;CatCache中对缓存元组的组织可以看上图。CatCache中的cc_bucket是一个可变数组。cc_bucket数组中的每一个元素都表示一个Hash桶，元组的键值通过Hash函数可以映射到cc_bucket数组的下标。每一个Hash桶都被组织成一个双向链表(Dlist)，其中的节点为Dlist_node类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;struct dlist_node
{
    dlist_node *prev;
    dlist_node *next;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具有同一个hash值得元组被缓存在同一个hash桶中，每一个hash桶中的缓存元组都被先包装成Dlist_node结构并链接成一个链表。因此在査找某一个元组时，需要先计算其Hash键值并通过键值找到其所在的Hash桶，之后要遍历Hash桶的链表逐一比对缓存元组。为了尽最减少遍历Hash桶的代价，在组织Hash桶中链表时，会将这一次命中的缓存元组移动到链表的头部，这样下一次査找同一个元组时可以在尽可能少的时间内命中。&lt;/p&gt;
&lt;p&gt;CatCache中的缓存元组将先被包装成CatCTup形式，然后加人到其所在Hash桶的链表中。在CatCTup中通过my_cache和cache_elem分别指向该缓存元组所在的CatCache及Hash桶链表中的节点。一个被标记为“死亡”的CalCTup(dead字段为真)并不会实际从CatCache中删除，但是在后续的査找中它不会被返回。“死亡&quot;的缓存元组将一直被保留在CatCache中，直到没有人访问它，即其refcount变为0。但如果“死亡”元组同时也属于一个CatCList,则必须等到CatCList和CatCTup的refcount都变为0时才能将其从CatCache中清除。CatCTup的negative字段表明该缓存元组是否为一个“负元组”，所谓负元组就是实际并不存在于系统表中，但是其键值曾经用于在CatCache中进行査找的元组。负元组只有键值，其他属性均为空。负元组的存在是为了避免反复到物理表中去査找不存在的元组所带来的I/O开销。&lt;/p&gt;
&lt;p&gt;catctup的数据结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct catctup
{
    int         ct_magic;       /* for identifying CatCTup entries */
#define CT_MAGIC   0x57261502
    CatCache   *my_cache;       /* link to owning catcache */

    dlist_node  cache_elem;     /* list member of per-bucket list */

    struct catclist *c_list;    /* containing CatCList, or NULL if none */

    int         refcount;       /* number of active references */
    bool        dead;           /* dead but not yet removed? */
    bool        negative;       /* negative cache entry? */
    uint32      hash_value;     /* hash value for this tuple's keys */
    HeapTupleData tuple;        /* tuple management header */
} CatCTup;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在catcache中査找元组&quot;&gt;1.3 在CatCache中査找元组&lt;/h2&gt;
&lt;p&gt;在CatCache中査找元组有两种方式：&lt;strong&gt;精确匹配&lt;/strong&gt;和&lt;strong&gt;部分匹配&lt;/strong&gt;。前者用于给定CatCache所需的所有键值，并返回CatCache中能完全匹配这个键值的元组；而后者只需要给出部分键值，并将部分匹配的元组以一个CatCList的方式返回。&lt;/p&gt;
&lt;p&gt;精确匹配査找由函数SearchCatCache函数实现，其函数原型如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SearchCatcache (CatCache* Cache .Datum vl, Datum v2 .Datum v3, Datum v4)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，vl、v2、v3和v4都用于査找元组的键值，分别对应该Cache中记录的元组搜索键。可以看到，SearehCatcache最多可以使用4个属性的键值进行査询，4个参数分别对应该CatCache数据结构中CC_key字段定义的査找键。&lt;/p&gt;
&lt;p&gt;SearchCatCache需要在一个给定的CatCache中査找元组，为了确定要在哪个CatCache中进行査找，还需要先通过CacheHdr遍历SysCache中所有的CatCache结构体，并根据査询的系统表名或系&lt;br/&gt;统表OID找到对应的CatCache。&lt;/p&gt;
&lt;p&gt;SearchCatCache在给定的CatCache中査找元组的过程如下：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;1) 对所査找元组的键值进行Hash,按照Hash值得到该CatCache在cc_bucket数组中对应的&lt;br/&gt;Hash桶的下标。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;2) 遍历Hash桶链找到满足査询需求的Dlist(CatCTup类型的属性cache_elem就是Dlist的节点dlist_node)并遍历，CatCTup中的HeapTupleData就是要査找的元组头部。另外，还要将该dlist_node移到链表头&lt;br/&gt;部并将CatCache的cc_hits(命中计数器)加1。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;3) 如果在Hash桶链中无法找到满足条件的元组，则需要进一步对物理系统表进行扫描，以确认要査找的元组是确实不存在还是没有缓存在CatCache中。如果扫描物理系统表能够找到满足条件的元组，则需要将该元组包装成Dlelem之后加人到其对应的Hash桶内链表头部。如果在物理系统表中找不到要査找的元组，则说明该元组确实不存在，此时构建一个只有键值但没有实际元组的“负元组”，并将它包装好加人到Hash桶内链表头部。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从SearchCatCache的査找过程可以看到，由于CatCache只是一个缓存，因此即使在其中找不到某个元组也不能确定该元组是否存在于系统表中，还需要进一步扫描物理系统表来査找该元组。但是，如果在CatCache中为这个不存在的元组放置一个“负元组”则可避免这些额外的开销，因为每次査找同一个不存在的元组时将会得到这个“负元组”，此时即可判定要査找的元组并不存在于系统表中，因而不用进一步去扫描物理系统表确认，从而造成浪费。&lt;/p&gt;
&lt;p&gt;要注意SearchCatCache的调用者不能修改返回的元组，并且使用完之后要调用ReleaseCatCache将其释放。&lt;/p&gt;
&lt;p&gt;在CatCache中，部分匹配使用另外一个函数SearchCatcacheList,该函数产生一个CatCList结构。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct catclist
{
    int         cl_magic;       /* for identifying CatCList entries */
#define CL_MAGIC   0x52765103
    CatCache   *my_cache;       /* link to owning catcache */

    dlist_node  cache_elem;     /* list member of per-catcache list */
    int         refcount;       /* number of active references */
    bool        dead;           /* dead but not yet removed? */
    bool        ordered;        /* members listed in index order? */
    short       nkeys;          /* number of lookup keys specified */
    uint32      hash_value;     /* hash value for lookup keys */
    HeapTupleData tuple;        /* header for tuple holding keys */
    int         n_members;      /* number of member tuples */
    CatCTup    *members[FLEXIBLE_ARRAY_MEMBER]; /* members */
} CatCList;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中以链表的方式存放了在Cache中找到的元组。CatCLUt中的tuple字段记录的是一个“负元组”，它仅仅用来存放该CatCList所用到的键值，没有其他用途。CatCLUt中所包含的元组实际通过members字段表示的变长数据来记录，该数组的实际长度由n_membera字段记录。&lt;/p&gt;
&lt;p&gt;SearchCatcacheList函数也会先计算査找键的Hash值，不过该函数首先会在CatCache的cc_lists字段中记录的CatCLlst链表中査找以前是否缓存了该査找键的结果，该査找过程将使用CatCList中tuple字段指向的元组与査找键进行Hash值比较。如果能够找到匹配该Hash值的CatCList,则cc_hits加1并将该CatCList移到ccjists所指向链表的头部，然后返回找到的CatCList。如果在CatCache中找不到CatCList,则扫描物理系统表并构建相应的CatCList并将它加人到ccjists所指向链表的头部。&lt;/p&gt;
&lt;p&gt;同样，SearchCatcacheList的调用者不能修改返回的CatCList对象或者里面的元组，并且使用完之后要调用ReleaseCatCacheList将其释放。&lt;/p&gt;
&lt;p&gt;最后，我们给一张SysCache相关的内存结构图吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/579102/201712/579102-20171219210126303-547155707.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;对RelCache的管理比SysCache要简单许多，原因在于大多数时候RelCache中存储的RelationData 的结构是不变的，因此 PostgreSQL 仅用一个 Hash 表来维持这样一个结构。对 RelCache 的査找、插人、删除、修改等操作也非常简单。当需要打开一个表时，首先在RelCache中寻找该表的RelationData结构，如果没有找到，则创建该结构并加人到RelCache中。&lt;/p&gt;
&lt;p&gt;和SysCache的初始化类似，RelCache的初始化同样也在InitPostgres函数中进行，同样分为两个阶段：RelationCachelnitialize 和 ReIationCacheInitializePhase2。&lt;/p&gt;
&lt;p&gt;InitPostgres会调用函数RelationCachelnitialize对ReiCache进行第一阶段初始化，该函数将为该进程创建一个Hash表，其Hash键为表的OID,并设置Hash函数为oid_hash。Hash表的创建在函数hash_create中实现，该函数将创建一个标准Hash表结构体HTAB。&lt;/p&gt;
&lt;p&gt;在完成了 Hash表的创建后，InitPostgres将调用RelationCachelnitializePhase进人第二阶段的初始化。该函数将必要的系统表和系统表索引的模式信息加人到RelCache中，这个过程通过函数RelationCacheInitializePhase2 来实现。这个阶段会确保 pg_class、pg_attribute、pg_proc、pg_type 四个系统表及相关索引的模式信息被加人到RelCache。在PostgreSQL中，使用一个文件pgJntemaLinit来记录系统表RelationData结构体，若该文件存在且未损坏，则将其内容直接读人RelCache中。否则，分别建立 pg_class、pg__atlribute、pg_proc、pg_type 及其索引的 RelationData 结构，加入到 RelCache上的Hash表中，并重写pg_internal.init文件。&lt;/p&gt;
&lt;p&gt;当RelCache初始化完成后，我们就可以使用它来査找表的模式信息。RelCache的主要操作包括：&lt;/p&gt;
&lt;h2 id=&quot;插人新打开的表&quot;&gt;2.1 插人新打开的表&lt;/h2&gt;
&lt;p&gt;当打开新的表时，要把它的RelationData加人到RelCache中。该操作通过宏RelationCachelnsert来实现：首先，根据关系表OID在Hash表中找到对应的位置，调用函数hasf^search,指定査询模式为HASH_ENTER，该模式下若发现OID对应的Hash桶已存在，则返回其指针；否则创建一个新的空的hash桶，返回其指针。然后将返回的指针强制转换为RelIdCacheEnt，然后把打开表的RelationData陚值给reldesc字段。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct relidcacheent
{
    Oid         reloid;
    Relation    reldesc;
} RelIdCacheEnt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;査找hash表&quot;&gt;2.2 査找Hash表&lt;/h2&gt;
&lt;p&gt;査找Hash表通过定义宏RelationldCacheLookup (ID，RELATION)来实现，调用函数hash_search，指定査询模式为HASH_FIND,若找到ID对应的RelldCacheEnt，则将其iddesc字段的值賦值给 RELATION;否则，设置RELATION为NULL。&lt;/p&gt;
&lt;h2 id=&quot;从hash表中删除元素&quot;&gt;2.3 从Hash表中删除元素&lt;/h2&gt;
&lt;p&gt;从Hash表中删除元素通过定义宏RelationCacheDelete(RELATION)来实现，调用函数hash_search,指定査询模式为HASH_REVOKE,在该模式下，若找到对应的Hash桶，则将其删除；否则&lt;br/&gt;返回NULL。&lt;/p&gt;
&lt;p&gt;Hash表实际上扮演了 RelCache索引的角色，所有对于RelCache的査找都是通过Hash表辅助进行的。&lt;/p&gt;

&lt;p&gt;其实楼主还想谢谢Cache信息的同步，因为Cacahe中的信息可能会变化，而Cache都是进程独立的，在一个进程中对某个Cache中的信息进行了修改，当然是应当尽可能快地反映到其他进程中。因此IPC(进程间通信)将是我下一个关注的话题，当然这个比较难，可能要憋一会儿了。&lt;/p&gt;
</description>
<pubDate>Tue, 19 Dec 2017 14:06:00 +0000</pubDate>
<dc:creator>非我在</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flying-tiger/p/8038202.html</dc:identifier>
</item>
<item>
<title>使用 dotnet core 和 Azure PaaS服务进行devOps开发（Web API 实例） - 陈希章</title>
<link>http://www.cnblogs.com/chenxizhang/p/8067824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenxizhang/p/8067824.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：陈希章 发表于 2017年12月19日&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;引子&lt;/h2&gt;
&lt;p&gt;这一篇文章将用一个完整的实例，给大家介绍如何基于dotnet core（微软.NET的最新版本，支持跨平台，跨设备的应用开发，详情请参考 https://www.microsoft.com/net 开发一个Web API Service，并且利用Azure的PaaS服务来实现部署，以及持续的开发运营（devops）。&lt;/p&gt;
&lt;blockquote readability=&quot;5.6166007905138&quot;&gt;
&lt;p&gt;这篇文章的难度不高，但会作为一个操作指南，后续很多文章，如果涉及到这块基础工作，都会引用这篇文章。本文所演示的范例代码，可以通过 &lt;a href=&quot;https://github.com/chenxizhang/dotnetcoreapisample&quot;&gt;https://github.com/chenxizhang/dotnetcoreapisample&lt;/a&gt; 下载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;1、安装dotnet core SDK&lt;/h2&gt;
&lt;p&gt;目前的最新版本是2.1.3，你可以根据需要下载到不同的版本，请注意安装SDK，而不是Runtime。&lt;/p&gt;
&lt;h2&gt;2、安装开发工具 visual studio code&lt;/h2&gt;
&lt;p&gt;这个工具同样是支持跨平台的，请通过下面的地址下载安装：&lt;a href=&quot;https://code.visualstudio.com/Download&quot;&gt;https://code.visualstudio.com/Download&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;3、创建Web API 项目&lt;/h2&gt;
&lt;p&gt;在命令行工具中运行 dotnet new webapi –o dotnetcoreapisample&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/devopsguide/blob/master/images/2017-12-19-15-58-46.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/devopsguide/raw/master/images/2017-12-19-15-58-46.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;4、运行Web API 项目&lt;/h2&gt;
&lt;p&gt;即便不做任何修改，在命令行工具中运行dotnet run即可运行这个项目。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/devopsguide/blob/master/images/2017-12-19-15-59-42.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/devopsguide/raw/master/images/2017-12-19-15-59-42.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在浏览器中访问 &lt;a href=&quot;http://localhost:5000/api/values&quot;&gt;http://localhost:5000/api/values&lt;/a&gt; 如果你也看到下面的效果，恭喜你，你的项目已经运行成功了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/devopsguide/blob/master/images/2017-12-19-16-00-07.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/devopsguide/raw/master/images/2017-12-19-16-00-07.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在命令行中输入 code . 会自动打开Visual Studio Code。如果你打开Controllers目录下面的ValuesController.cs 文件，你可以看到如下代码，跟上面的网页返回结果对照一下，你会觉得现在编写一个Web API 真的非常简单啊。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/devopsguide/blob/master/images/2017-12-19-16-00-40.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/devopsguide/raw/master/images/2017-12-19-16-00-40.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;5、增加数据实体&lt;/h2&gt;
&lt;p&gt;虽然上面的代码能运行，但我们真正要做的一个Web API服务，是希望能给用户提供创建订单，修改订单，查询订单，甚至删除订单的服务。所以，请先删除掉上面这个ValuesController.cs 文件。我会演示怎么样一步一步地将一个订单服务实现出来。&lt;/p&gt;
&lt;p&gt;所有的服务都离不开数据，我们将使用Entity Framework来实现数据层服务。所以我们要先定义订单这个数据接口的实体。&lt;/p&gt;
&lt;p&gt;请增加一个目录，Models，然后增加第一个代码文件 Order.cs&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace dotnetcoreapisample.Models
{

    using System;

    public class Order{
        public int Id { get; set; }

        public DateTime OrderDate { get; set; }

        public int Quantity { get; set; }

        public decimal UnitPrice { get; set; }

        public string Product { get; set; }

    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;6、创建数据服务&lt;/h2&gt;
&lt;p&gt;光有数据实体是不够的，我们还需要定义一个数据服务，或者也可以成为数据上下文服务。请在Models目录中，再创建下面这样一个类：SampleDbContext.cs&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace  dotnetcoreapisample.Models{

    using System;
    using Microsoft.EntityFrameworkCore;
    using System.Linq;
   
    public class SampleDbContext:DbContext{

        public SampleDbContext(DbContextOptions&amp;lt;SampleDbContext&amp;gt; options):base(options){
            
        }


        public DbSet&amp;lt;Order&amp;gt; Orders { get; set; }


    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;7、注入数据服务&lt;/h2&gt;
&lt;p&gt;dotnet core提供了一种非常好的编程模型，我们可以在程序启动的时候，将必要的数据服务对象注入进去，然后在后续的业务服务中就可以直接使用它。&lt;/p&gt;
&lt;p&gt;定位到Startup.cs这个文件，在顶部先添加两个命名空间的引用 &lt;code&gt;using Microsoft.EntityFrameworkCore;&lt;/code&gt; 和 &lt;code&gt;using dotnetcoreapisample.Models;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后在 ConfigureServices 这个方法里面，第一行添加如下代码 &lt;code&gt;services.AddDbContext&amp;lt;SampleDbContext&amp;gt;(_=&amp;gt;_.UseInMemoryDatabase(&quot;Sample&quot;));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这句代码的意思是，使用一个在内存中的数据库。作为快速开发和测试目的，这是最方面的。当然，如果你真的想要有一个实际的数据库文件，Entity Framework支持几乎所有的数据源，尤其是对sqlite和SQL Server的支持非常好，请参考 &lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/data/ef-rp/intro&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;8、创建Web API 服务&lt;/h2&gt;
&lt;p&gt;这是最后一步了，请在Controllers目录中增加一个OrderController.cs的文件，代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;using Microsoft.AspNetCore.Mvc;
using dotnetcoreapisample.Models;
using System.Collections.Generic;
using System.Linq;

namespace dotnetcoreapisample.Controllers
{
    [Route(&quot;api/[controller]&quot;)]
    public class OrdersController:Controller{

        private SampleDbContext context;
        public OrdersController(SampleDbContext ctx){
            context = ctx;
        }

        [HttpGet]
        public IEnumerable&amp;lt;Order&amp;gt; Get(){
            return context.Orders;
        }

        [HttpGet(&quot;{id}&quot;)]
        public Order Get(int id){
            return context.Orders.FirstOrDefault(x=&amp;gt;x.Id == id);
        }

        [HttpPost]
        public void Post([FromBody]Order value){
            context.Orders.Add(value);
            context.SaveChanges();
        }

        [HttpPut(&quot;{id}&quot;)]
        public void Put(int id,[FromBody]Order value){
            var found = context.Orders.FirstOrDefault(x=&amp;gt;x.Id == id);
            if(found!=null){
                found.OrderDate = value.OrderDate;
                found.Product =value.Product;
                found.Quantity =value.Quantity;
                found.UnitPrice =value.UnitPrice;

                context.SaveChanges();
            }
        }

        [HttpDelete(&quot;{id}&quot;)]
        public void Delete(int id){
            var found = context.Orders.FirstOrDefault(x=&amp;gt;x.Id == id);
            context.Orders.Remove(found);
            context.SaveChanges();
        }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;9、运行和测试Web API服务&lt;/h2&gt;
&lt;p&gt;完成上面的工作后，你就可以通过按下F5键（或者执行dotnet run命令）运行这个项目了。我用Fiddler来模拟用户请求，下面展示了四个不同的脚本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建订单&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们使用POST方法发起请求，地址是&lt;a href=&quot;http://localhost:5000/api/orders%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E8%AF%B7%E6%B1%82%E7%9A%84%E6%AD%A3%E6%96%87%E9%87%8C%E9%9D%A2%E7%94%A8JSON%E6%A0%BC%E5%BC%8F%E8%A1%A8%E7%A4%BA%E4%B8%80%E4%B8%AA%E8%AE%A2%E5%8D%95%E4%BF%A1%E6%81%AF&quot;&gt;http://localhost:5000/api/orders，然后在请求的正文里面用JSON格式表示一个订单信息&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/devopsguide/blob/master/images/2017-12-19-16-29-14.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/devopsguide/raw/master/images/2017-12-19-16-29-14.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查询订单&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们使用GET方法发起请求，地址也是&lt;a href=&quot;http://localhost:5000/api/orders%EF%BC%8C%E5%9C%A8%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%B4%E9%83%A8%E9%87%8C%E9%9D%A2%E8%AE%BE%E7%BD%AEContent-Type%E4%B8%BA&quot;&gt;http://localhost:5000/api/orders，在请求的头部里面设置Content-Type为&lt;/a&gt;application/json&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/devopsguide/blob/master/images/2017-12-19-16-31-46.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/devopsguide/raw/master/images/2017-12-19-16-31-46.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此时我们可以看到，系统已经创建了一个订单，编号为1（这是自动编号的）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改订单&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们使用PUT方法发起请求，地址是&lt;a href=&quot;http://localhost:5000/api/orders/1%EF%BC%8C%E5%9C%A8%E8%AF%B7%E6%B1%82%E7%9A%84%E6%AD%A3%E6%96%87%E9%87%8C%E9%9D%A2%EF%BC%8C%E6%88%91%E5%B0%86%E8%A6%81%E4%BF%AE%E6%94%B9%E7%9A%84%E8%AE%A2%E5%8D%95%E4%BF%A1%E6%81%AF%E7%94%A8JSON%E8%A1%A8%E7%A4%BA%EF%BC%8C%E8%AF%B7%E6%B3%A8%E6%84%8F%EF%BC%8C%E6%88%91%E5%B0%86%E5%8D%95%E4%BB%B7%E4%BB%8E200%E4%BF%AE%E6%94%B9%E4%B8%BA400&quot;&gt;http://localhost:5000/api/orders/1，在请求的正文里面，我将要修改的订单信息用JSON表示，请注意，我将单价从200修改为400&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/devopsguide/blob/master/images/2017-12-19-16-34-23.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/devopsguide/raw/master/images/2017-12-19-16-34-23.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果再次查询订单，你可以看到数据已经修改了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/devopsguide/blob/master/images/2017-12-19-16-34-58.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/devopsguide/raw/master/images/2017-12-19-16-34-58.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;删除订单&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后，我们可以通过DELETE方法发起请求，给定地址是 &lt;a href=&quot;http://localhost:5000/api/orders/1&quot;&gt;http://localhost:5000/api/orders/1&lt;/a&gt; 来完成删除一个订单的操作&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/devopsguide/blob/master/images/2017-12-19-16-36-18.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/devopsguide/raw/master/images/2017-12-19-16-36-18.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一切看起来还不错，接下来给大家介绍一下如何采用Azure云平台进行部署，以及通过Azure的PaaS服务实现开发运营一体会（devops）的实践。&lt;/p&gt;
&lt;h2&gt;10、创建Azure的应用程序服务（App Service）&lt;/h2&gt;
&lt;p&gt;传统的情况，开发人员（和测试人员）做到上面这一步，工作就算结束了。他们会将代码签入到代码库，然后愉快地打卡下班。接下来的工作是什么呢？运维人员会准备虚拟机，安装必要的软件，然后将代码下载下来，编译之后将得到的文件复制到服务器的某个文件夹，沐浴更衣烧香拜佛之后，很有可能Web服务器能正常地启动起来，如果不能，他们就要顶着巨大的压力，跟开发人员打电话，委婉地要求对方帮忙检查一下问题，但是很可能得到的答复是：你是怎么弄的呢，这个明明在我的机器是跑的好好的？上帝保佑，如果这次部署是成功的，但下次如果要更新一个版本，可能是再一次的痛苦的过程。如果说，在以前的时候我们的软件更新并不频繁，这种痛苦还是可以接受的话，现在随着互联网应用开发模式的兴起，业务需求可能三天两头的变化，如此的开发运营割裂的状况，是远远达不到要求的。这也是业界呼唤有更好的工作方式的一个根本原因，devops也就是这么样兴起的。&lt;/p&gt;
&lt;p&gt;理论其实并不高深，关键看怎么能有效地实现开发和运维的一体化，很大程度上，这个当然取决于平台和工具，其根本在于要实现智能和自动化。另外，devops会逼迫我们重新对应用架构进行一些思考，模组化和微服务化会成为一个自然而然的选择。这个我在后面会有专门的文章给大家解读。本文先用实例来让大家感受一下。&lt;/p&gt;
&lt;p&gt;我这里推荐的平台是微软的Azure云平台，它不仅仅是一个强大的IaaS平台，提供了全球质量保证和安全合规的基础架构服务（计算，网络，存储等），同时更重要的是，它是一个PaaS平台，对于广大的业务应用开发人员来说，使用Azure提供的工具，可以事半功倍地实现devops，将更多精力集中在应用逻辑而不是服务器配置、监测、部署更新等工作上面。&lt;/p&gt;
&lt;p&gt;闲话少说，如果你还没有Azure账号，可以申请试用。接下来可以参考我的步骤来看看如何将我们刚才创建的这个Web API项目部署到Azure，并且实现基于代码更新的应用自动发布。&lt;/p&gt;
&lt;p&gt;登录到Azure的管理门户后，选择“应用程序服务”，然后添加一个“Web应用”&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/devopsguide/blob/master/images/2017-12-19-20-22-11.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/devopsguide/raw/master/images/2017-12-19-20-22-11.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在接下来的窗口中完成资源配置，请注意，作为测试场景的话，你甚至可以选择免费的一种应用服务计划。这里还可以打开Application Insight（这个目前也是免费的服务）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/devopsguide/blob/master/images/2017-12-19-20-32-30.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/devopsguide/raw/master/images/2017-12-19-20-32-30.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;配置这个应用服务的部署选择，此时逐渐解开了Azure 作为 devops 平台的面纱了。在下图中可以选择“本地Git存储库”作为部署源&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/devopsguide/blob/master/images/2017-12-19-20-36-25.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/devopsguide/raw/master/images/2017-12-19-20-36-25.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;虽然你可以看到很多其他的选项，但本篇文章是入门的，所以不做一一展开。下面我们设置一下部署的凭据。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/devopsguide/blob/master/images/2017-12-19-20-43-23.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/devopsguide/raw/master/images/2017-12-19-20-43-23.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;完成上面这些配置后，我们回到Web应用的概述页面，你会发现现在多出来一个可以用来远程部署的Git存储库地址，请将这个地址复制下来。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/devopsguide/blob/master/images/2017-12-19-20-44-01.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/devopsguide/raw/master/images/2017-12-19-20-44-01.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;11、配置和远程部署&lt;/h2&gt;
&lt;p&gt;回到之前的Visual Studio Code的界面，打开命令行窗口，通过&lt;code&gt;git init&lt;/code&gt; 命令初始化本地的git存储库，然后执行&lt;code&gt;git add *&lt;/code&gt;和&lt;code&gt;git commit -m 'init'&lt;/code&gt; 这两条命令完成初始化提交到本地。最后，通过下面的命令添加远程存储库。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/devopsguide/blob/master/images/2017-12-19-20-48-09.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/devopsguide/raw/master/images/2017-12-19-20-48-09.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来，运行 &lt;code&gt;git push azure master&lt;/code&gt;这条命令，此时会弹出一个对话框，请输入上一步创建的用户名和密码，这个提交过程可能会比较长，尤其是第一次。这是因为它不仅仅会将代码上传到代码库，而且后台会启动一系列的操作，来进行编译和部署。下面是在我这边的输出结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PS C:\temp\dotnetcoreapisample&amp;gt; git push azure master
Counting objects: 9, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (7/7), done.
Writing objects: 100% (9/9), 7.90 KiB | 899.00 KiB/s, done.
Total 9 (delta 5), reused 0 (delta 0)
remote: Updating branch 'master'.
remote: Updating submodules.
remote: Preparing deployment for commit id '3adc61d27e'.
remote: Generating deployment script.
remote: Running deployment command...
remote: Handling ASP.NET Core Web Application deployment.
remote: ............................................................
remote:   Restoring packages for D:\home\site\repository\dotnetcoreapisample.csproj...
remote:   Restore completed in 755.48 ms for D:\home\site\repository\dotnetcoreapisample.csproj.
remote: .....
remote:   Generating MSBuild file D:\home\site\repository\obj\dotnetcoreapisample.csproj.nuget.g.props.
remote:   Generating MSBuild file D:\home\site\repository\obj\dotnetcoreapisample.csproj.nuget.g.targets.
remote:   Restore completed in 10.36 sec for D:\home\site\repository\dotnetcoreapisample.csproj.
remote: .............................................................
remote: Microsoft (R) Build Engine version 15.4.8.50001 for .NET Core
remote: Copyright (C) Microsoft Corporation. All rights reserved.
remote:
remote: ................................................
remote:   dotnetcoreapisample -&amp;gt; D:\home\site\repository\bin\Release\netcoreapp2.0\dotnetcoreapisample.dll
remote: ...........
remote:   dotnetcoreapisample -&amp;gt; D:\local\Temp\8d546e10a232b37\
remote: KuduSync.NET from: 'D:\local\Temp\8d546e10a232b37' to: 'D:\home\site\wwwroot'
remote: Copying file: 'dotnetcoreapisample.deps.json'
remote: Copying file: 'dotnetcoreapisample.dll'
remote: Copying file: 'dotnetcoreapisample.pdb'
remote: Copying file: 'dotnetcoreapisample.PrecompiledViews.dll'
remote: Copying file: 'dotnetcoreapisample.PrecompiledViews.pdb'
remote: Copying file: 'dotnetcoreapisample.runtimeconfig.json'
remote: Finished successfully.
remote: Running post deployment command(s)...
remote: Deployment successful.
To https://dotnetcoreapisample.scm.azurewebsites.net:443/dotnetcoreapisample.git
   37b30a5..3adc61d  master -&amp;gt; master

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以很清楚地看到代码上传后，触发了一个部署的事件，该部署脚本先会拉取所有依赖的包，然后执行构建，最后将文件复制到指定的一个目录。这种自动化的过程就是devops的基石。当然，现在的dotnet core的平台无关性也给部署带来了极大的便利。&lt;/p&gt;
&lt;h2&gt;12、查看Web API的运行结果&lt;/h2&gt;
&lt;p&gt;在完成部署后，我们回到Azure的门户，在应用服务的“部署选项”可以看到已经部署的记录，最新的一次部署被标记为 “活动”状态。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/devopsguide/blob/master/images/2017-12-19-21-14-16.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/devopsguide/raw/master/images/2017-12-19-21-14-16.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;点击某一次部署，还可以看到详细信息&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/devopsguide/blob/master/images/2017-12-19-21-16-24.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/devopsguide/raw/master/images/2017-12-19-21-16-24.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果我们对于当前这次部署不满意，还可以随时选择其他部署，并且选择“重新部署”操作，这样就可以快速进行应用的回滚。&lt;/p&gt;
&lt;p&gt;好了，我们最后可以在浏览中输入 &lt;a href=&quot;https://dotnetcoreapisample.azurewebsites.net/api/orders&quot;&gt;https://dotnetcoreapisample.azurewebsites.net/api/orders&lt;/a&gt; ，如果返回一个空白的数组“[]” ，说明这个服务是正常工作的。因为我们使用的是内存数据库，所以每次部署后，都会将数据清空，这就是为什么第一次返回空白数组的原因。&lt;/p&gt;
&lt;h2&gt;结语&lt;/h2&gt;
&lt;p&gt;使用Azure的PaaS服务来部署Web 应用，通过简单配置后，开发人员只需要关注代码本身，在本地调试后，将代码推送到Azure，后台将自动进行构建和部署，由于有版本控制，所以随时可以根据需要进行前滚和回滚。基于Azure平台进行应用开发，无缝地融入了devops，可以极大地改善开发和运维流程，提高研发效率和质量。本文只是一个开始，我在后续还会介绍各种不同的场景。&lt;/p&gt;
</description>
<pubDate>Tue, 19 Dec 2017 13:28:00 +0000</pubDate>
<dc:creator>陈希章</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenxizhang/p/8067824.html</dc:identifier>
</item>
<item>
<title>剖析大数据平台的数据采集 - 张逸</title>
<link>http://www.cnblogs.com/wayfarer/p/data-ingestion-for-big-data.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wayfarer/p/data-ingestion-for-big-data.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我在一次社区活动中做过一次分享，演讲题目为《大数据平台架构技术选型与场景运用》。在演讲中，我主要分析了大数据平台架构的生态环境，并主要以数据源、数据采集、数据存储与数据处理四个方面展开分析与讲解，并结合具体的技术选型与需求场景，给出了我个人对大数据平台的理解。本文讲解数据采集部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;数据采集的设计，几乎完全取决于数据源的特性，毕竟数据源是整个大数据平台蓄水的上游，数据采集不过是获取水源的管道罢了。&lt;/p&gt;
&lt;p&gt;在数据仓库的语境下，ETL基本上就是数据采集的代表，包括数据的提取（Extract)、转换(Transform)和加载(Load)。在转换的过程中，需要针对具体的业务场景对数据进行治理，例如进行非法数据监测与过滤、格式转换与数据规范化、数据替换、保证数据完整性等。&lt;/p&gt;
&lt;p&gt;但是在大数据平台下，由于数据源具有更复杂的多样性，数据采集的形式也变得更加复杂而多样，当然，业务场景也可能变得迥然不同。下图展现了大数据平台比较典型的数据采集架构：&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/526/201712/526-20171219212526959-915741606.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;￼&lt;br/&gt;以下是几种比较典型的业务场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景1：&lt;/strong&gt;为了提升业务处理的性能，同时又希望保留历史数据以备数据挖掘与分析。&lt;/p&gt;
&lt;p&gt;业务处理场景访问的数据库往往是RDB，可伸缩性较差，又需要满足查询与其他数据操作的实时性，这就需要定期将超过时间期限的历史数据执行清除。但是在大数据场景下，这些看似无用的历史数据又可能是能够炼成黄金的沙砾。因而需要实时将RDB的数据同步到HDFS中，让HDFS成为备份了完整数据的冗余存储。在这种场景下，数据采集就仅仅是一个简单的同步，无需执行转换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景2：&lt;/strong&gt;数据源已经写入Kafka，需要实时采集数据&lt;/p&gt;
&lt;p&gt;在考虑流处理的业务场景，数据采集会成为Kafka的消费者，就像一个水坝一般将上游源源不断的数据拦截住，然后根据业务场景做对应的处理（例如去重、去噪、中间计算等），之后再写入到对应的数据存储中。这个过程类似传统的ETL，但它是流式的处理方式，而非定时的批处理Job。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景3：&lt;/strong&gt;数据源为视频文件，需提取特征数据&lt;/p&gt;
&lt;p&gt;针对视频文件的大数据处理，需要在Extract阶段加载图片后，然后根据某种识别算法，识别并提取图片的特征信息，并将其转换为业务场景需要的数据模型。在这个场景下，数据提取的耗时相对较长，也需要较多的内存资源。如果处理不当，可能会成为整个数据阶段的瓶颈。&lt;/p&gt;
&lt;p&gt;在数据采集阶段，一个棘手问题是增量同步，尤其针对那种可变（即可删除、可修改）的数据源。在我们无法掌控数据源的情况下，通常我们会有三种选择：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;放弃同步，采用直连形式；&lt;/li&gt;
&lt;li&gt;放弃增量同步，选用全量同步；&lt;/li&gt;
&lt;li&gt;编写定期Job，扫描数据源以获得delta数据，然后针对delta数据进行增量同步&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;坦白说，这三种选择皆非最佳选择，但我也未尝发现有更好的方案。如果数据源端可以控制，我们当然也可以侦听数据源的变更，然后执行Job来更新采集后存储的数据。这些又可能牵涉到数据存储的选型，假设我们选择了Parquet格式作为数据存储，则Parquet是不允许变更的。若要应对这种场景，或许应该考虑ORC格式。&lt;/p&gt;
&lt;p&gt;为了更高效地完成数据采集，通常我们需要将整个流程切分成多个阶段，在细分的阶段中可以采用并行执行的方式。在这个过程中，可能牵涉到Job的创建、提交与分发，采集流程的规划，数据格式的转换等。除此之外，在保证数据采集的高性能之外，还要考虑数据丢失的容错。&lt;/p&gt;
</description>
<pubDate>Tue, 19 Dec 2017 13:27:00 +0000</pubDate>
<dc:creator>张逸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wayfarer/p/data-ingestion-for-big-data.html</dc:identifier>
</item>
<item>
<title>基于Java使用Snmp4j进行监控与采集(snmptrap、snmpwalk、snmpget) - 玉树临枫</title>
<link>http://www.cnblogs.com/yuanfy008/p/8046189.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanfy008/p/8046189.html</guid>
<description>&lt;p&gt;之前有在弄监控服务器这块的工作，今天来整体总结下。因为有些服务器（路由器、交换机等都是基于snmp协议的）必须使用snmp协议去监控采集和接收信息，所以必须去了解snmp相关内容，以及如何在基于java上开发。关于了解snmp相关内容，必看《SNMP简单网络管理协议》这本书里面介绍的很详细，另外推荐这位前辈的博文写的很到位&lt;a href=&quot;http://www.cnblogs.com/xdp-gacl/p/3978825.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt; 《snmp学习总结》&lt;/span&gt;&lt;/a&gt;。关于snmp4j的介绍也可以看看前面这位前辈关于&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/xdp-gacl/p/3978825.html&quot; target=&quot;_blank&quot;&gt; 《snmp学习总结》&lt;/a&gt;&lt;/span&gt;的最后一篇博文&lt;a href=&quot;http://www.cnblogs.com/xdp-gacl/p/4187089.html&quot; target=&quot;_blank&quot;&gt;《snmp4j介绍》&lt;/a&gt;。当然本篇主要记录如何基于Java如何使用snmp4j去开发实现监控与采集，下面我们直接结合源码以及实例讲解：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、针对源码进行分析：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、核心对象SNMP的初始化。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　源码中有四种初始化方法及四个构造函数，其实都大同小异：参数少的就必须后续添加，参数多的必须提前初始化。&lt;br/&gt;       &lt;img src=&quot;http://images2017.cnblogs.com/blog/690169/201712/690169-20171218163108943-752559989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们先看看第一个无参构造函数，源码很简单，但是注释很多，所以看源码必须要先看注释。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;   * Creates a {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Snmp} instance that uses a
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;   * {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; MessageDispatcherImpl} with no message processing
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;   * models and no security protols (by default). You will have to add
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;   * those by calling the appropriate methods on
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;   * {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #getMessageDispatcher()}.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;   * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;   * At least one transport mapping has to be added before {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #listen()}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;   * is called in order to be able to send and receive SNMP messages.
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;   * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;   * To initialize a {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; Snmp} instance created with this constructor
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;   * follow this sample code:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;   * &amp;lt;pre&amp;gt;
&lt;/span&gt;&lt;span&gt;14    * Transport transport = ...;
15    * Snmp snmp = new Snmp();
16    * SecurityProtocols.getInstance().addDefaultProtocols();
17    * MessageDispatcher disp = snmp.getMessageDispatcher();
18    * disp.addMessageProcessingModel(new MPv1());
19    * disp.addMessageProcessingModel(new MPv2c());
20    * snmp.addTransportMapping(transport);
21    * OctetString localEngineID = new OctetString(
22    *    MPv3.createLocalEngineID());
23    *    // For command generators, you may use the following code to avoid
24    *    // engine ID clashes:
25    *    // MPv3.createLocalEngineID(
26    *    //   new OctetString(&quot;MyUniqueID&quot;+System.currentTimeMillis())));
27    * USM usm = new USM(SecurityProtocols.getInstance(), localEngineID, 0);
28    * disp.addMessageProcessingModel(new MPv3(usm));
29    * snmp.listen();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;   * &amp;lt;/pre&amp;gt;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;    &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Snmp() {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.messageDispatcher = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageDispatcherImpl();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (SNMP4JSettings.getSnmp4jStatistics() !=&lt;span&gt; SNMP4JSettings.Snmp4jStatistics.none) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;       counterSupport =&lt;span&gt; CounterSupport.getInstance();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从上面注释中可以看出要初始化snmp需要设置messageDispatcher里面的参数和TransportMapping参数，如果没有设置好这个两个参数，发送报文时会报错（见下面案例）.所以我们可以直接使用第三个构造函数。&lt;/p&gt;
&lt;p&gt;　　接下来我们来看第二个构造函数Snmp(TransportMapping&amp;lt;? extends Address&amp;gt; transportMapping)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;   * Creates a &amp;lt;code&amp;gt;Snmp&amp;lt;/code&amp;gt; instance that uses a
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;   * &amp;lt;code&amp;gt;MessageDispatcherImpl&amp;lt;/code&amp;gt; with all supported message processing
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;   * models and the default security protols for dispatching.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;   * &amp;lt;p&amp;gt;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;   * To initialize a &amp;lt;code&amp;gt;Snmp&amp;lt;/code&amp;gt; instance created with this constructor
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;   * follow this sample code:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;   * &amp;lt;pre&amp;gt;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;   * Transport transport = ...;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;   * Snmp snmp = new Snmp(transport);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;   * OctetString localEngineID =
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;   *   new OctetString(snmp.getMPv3().getLocalEngineID());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;   * USM usm = new USM(SecurityProtocols.getInstance(), localEngineID, 0);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;   * SecurityModels.getInstance().addSecurityModel(usm);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;   * snmp.listen();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;   * &amp;lt;/pre&amp;gt;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;   *
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;   * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; transportMapping TransportMapping
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;   *    the initial &amp;lt;code&amp;gt;TransportMapping&amp;lt;/code&amp;gt;. You can add more or remove
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;   *    the same later.
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;    &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; Snmp(TransportMapping&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Address&amp;gt;&lt;span&gt; transportMapping) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;&lt;span&gt;    initMessageDispatcher()&lt;/span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (transportMapping != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;      addTransportMapping(transportMapping);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initMessageDispatcher() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.messageDispatcher.addCommandResponder(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.messageDispatcher.addMessageProcessingModel(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MPv2c());
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.messageDispatcher.addMessageProcessingModel(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MPv1());
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.messageDispatcher.addMessageProcessingModel(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MPv3());
    SecurityProtocols.getInstance().addDefaultProtocols();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从源码中可以看到它帮我们设置了messageDispatcher里面的参数，只要我们提供TransportMapping参数即可。第四个构造函数Snmp(MessageDispatcher messageDispatcher)其实跟第一个类似同样需要提供两个参数，所以第三个和第四个就列出来了。其中涉及到接口有MessageDispatcher接口、MessageProcessingModel接口，涉及到的类有MPv1、MPv2和MPv3分别对应snmp版本v1、v2c和v3。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @description MessageDispatcher接口定义了处理传入的SNMP消息并将其分派到感兴趣的CommandResponder实例的实例的公共服务。它还提供了一个发送出去的SNMP消息的服务。
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; MessageDispatcher &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; TransportListener {}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @description MessageProcessingModel 接口为所有SNMP消息处理模型定义了通用方法。
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; MessageProcessingModel {}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @description TransportMapping定义了SNMP传输映射的公共接口。传输映射只能支持单个传输协议。
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; TransportMapping&amp;lt;A &lt;span&gt;extends&lt;/span&gt; Address&amp;gt; {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;2、核心对象Target&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我们先看下Target对象下的继承关系。其中主要用到的子对象是CommunityTarget和UserTarget，CommunityTarget用于SNMPv1和SNMPv2c这两个版本，而UserTarget用于SNMPV3版本。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;http://images2017.cnblogs.com/blog/690169/201712/690169-20171218171949475-741679695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在初始化CommunityTarget时默认使用的是snmpv1(适用于snmpv2).&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
   * Default constructor.
   &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CommunityTarget() {
    setVersion(SnmpConstants.version1);
    setSecurityLevel(SecurityLevel.NOAUTH_NOPRIV);
    setSecurityModel(SecurityModel.SECURITY_MODEL_SNMPv1);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;3、核心对象PDU&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/690169/201712/690169-20171218173722912-1136639021.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　跟Target一样，针对snmp的不同版本是使用不同的子类去实现。PDUv1用于SNMPv1和SNMPv2c这两个版本，而ScopedPDU用于SNMPV3版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、案例分析：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;1、snmpGet功能测试：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　第一步：要初始snmp并开启监听。其中有点不同的是，为了支持snmpv3版本的处理需要增加用户并设置安全名称和加密算法。（关于那些静态变量的值，最好放到配置文件中显得灵活点）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外再说明下：snmp是基于udp协议发送报文的，且snmp端口默认为161。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SnmpUtil {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger log = LoggerFactory.getLogger(SnmpUtil.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Snmp snmp = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String community = &quot;public&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String ipAddress = &quot;udp:10.10.112.105/&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * @description 初始化snmp
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; YuanFY
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     * @date 2017年12月16日 上午10:28:01
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@version&lt;/span&gt;&lt;span&gt; 1.0
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initSnmp() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、初始化多线程消息转发类&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             MessageDispatcher messageDispatcher = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageDispatcherImpl(); 
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其中要增加三种处理模型。如果snmp初始化使用的是Snmp(TransportMapping&amp;lt;? extends Address&amp;gt; transportMapping) ,就不需要增加 &lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             messageDispatcher.addMessageProcessingModel(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MPv1());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             messageDispatcher.addMessageProcessingModel(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MPv2c());
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当要支持snmpV3版本时，需要配置user&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             OctetString localEngineID = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OctetString(MPv3.createLocalEngineID());
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             USM usm = &lt;span&gt;new&lt;/span&gt; USM(SecurityProtocols.getInstance().addDefaultProtocols(), localEngineID, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             UsmUser user = &lt;span&gt;new&lt;/span&gt; UsmUser(&lt;span&gt;new&lt;/span&gt; OctetString(&quot;SNMPV3&quot;), AuthSHA.ID, &lt;span&gt;new&lt;/span&gt; OctetString(&quot;authPassword&quot;&lt;span&gt;), 
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 PrivAES128.ID, &lt;span&gt;new&lt;/span&gt; OctetString(&quot;privPassword&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            usm.addUser(user.getSecurityName(), user);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             messageDispatcher.addMessageProcessingModel(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MPv3(usm));
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、创建transportMapping&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             UdpAddress updAddr = (UdpAddress) GenericAddress.parse(&quot;udp:10.10.112.177/161&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             TransportMapping&amp;lt;?&amp;gt; transportMapping = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultUdpTransportMapping(updAddr);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、正式创建snmp&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             snmp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Snmp(messageDispatcher, transportMapping);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启监听&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            snmp.listen();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;strong&gt;其中要注意的是UdpAddress updAddr = (UdpAddress) GenericAddress.parse(&quot;udp:10.10.112.177/161&quot;); 只能指定本机ip，要么不要设置地址。请看DefaultUdpTransportMapping的源码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;   * Creates a UDP transport on the specified address. The address will not be
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;   * reused if it is currently in timeout state (TIME_WAIT).
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;   *
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;   * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; udpAddress
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;   *    &lt;span&gt;the local address for sending and receiving of UDP messages.
&lt;/span&gt;&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;   * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;   *    if socket binding fails.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;    &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; DefaultUdpTransportMapping(UdpAddress udpAddress) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(udpAddress);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     socket = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DatagramSocket(udpAddress.getPort(),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                                udpAddress.getInetAddress());
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　第二步： 根据snmp版本创建Target对象，其中针对snmpV3版本需要设置安全级别和安全名称，其中安全名称是创建snmp指定user设置的new OctetString(&quot;SNMPV3&quot;)，针对snmpv1和snmpv2c需要设置团体名。另外必须设置ipAddress，且对应的主机要配置snmp否则获取不到值。如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Target createTarget(&lt;span&gt;int&lt;/span&gt; version, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; port) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Target target = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!(version == SnmpConstants.version3 || version == SnmpConstants.version2c || version ==&lt;span&gt; SnmpConstants.version1)) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             log.error(&quot;参数version异常&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (version ==&lt;span&gt; SnmpConstants.version3) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             target = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserTarget();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;snmpV3需要设置安全级别和安全名称，其中安全名称是创建snmp指定user设置的new OctetString(&quot;SNMPV3&quot;)&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            target.setSecurityLevel(SecurityLevel.AUTH_PRIV);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             target.setSecurityName(&lt;span&gt;new&lt;/span&gt; OctetString(&quot;SNMPV3&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;snmpV1和snmpV2需要指定团体名名称&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             target = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CommunityTarget();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             ((CommunityTarget)target).setCommunity(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OctetString(community));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (version ==&lt;span&gt; SnmpConstants.version2c) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                target.setSecurityModel(SecurityModel.SECURITY_MODEL_SNMPv2c);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        target.setVersion(version);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须指定，没有设置就会报错。&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         target.setAddress(GenericAddress.parse(ipAddress+&lt;span&gt;port));
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         target.setRetries(5&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         target.setTimeout(3000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; target;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　第三步：创建报文。其中要注意的是pdu可以设置类型，如果想要用snmpget方法，就设置PDU.GET.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; PDU createPDU(&lt;span&gt;int&lt;/span&gt; version, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; type, String oid){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         PDU pdu = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (version ==&lt;span&gt; SnmpConstants.version3) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             pdu = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ScopedPDU();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             pdu = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PDUv1();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        pdu.setType(type);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以添加多个变量oid&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         pdu.add(&lt;span&gt;new&lt;/span&gt; VariableBinding(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OID(oid)));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pdu;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;最后一步发送报文也是最重要的一步，需要前面三步的支撑才能进行。如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; snmpGet(String oid){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、初始化snmp,并开启监听&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            initSnmp();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、创建目标对象&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             Target target =&lt;span&gt; createTarget(SnmpConstants.version2c, SnmpConstants.DEFAULT_COMMAND_RESPONDER_PORT);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、创建报文&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             PDU pdu =&lt;span&gt; createPDU(SnmpConstants.version2c, PDU.GET, oid);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             System.out.println(&quot;-------&amp;gt; 发送PDU &amp;lt;-------&quot;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、发送报文，并获取返回结果&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             ResponseEvent responseEvent =&lt;span&gt; snmp.send(pdu, target);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             PDU response =&lt;span&gt; responseEvent.getResponse();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             System.out.println(&quot;返回结果：&quot; +&lt;span&gt; response);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;strong&gt;　测试如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        snmpGet(&lt;/span&gt;&quot;1.3.6.1.2.1.1.1.0&quot;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;output&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
-------&amp;gt; 发送PDU &amp;lt;-------&lt;span&gt;
返回结果：RESPONSE[requestID&lt;/span&gt;=1344419162, errorStatus=Success(0), errorIndex=0, VBS[&lt;span&gt;1.3.6.1.2.1.1.1.0&lt;/span&gt; = Linux localhost.localdomain 3.10.0-327.36.2.el7.x86_64 #1 SMP Mon Oct 10 23:08:37 UTC 2016 x86_64]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;从中可以得知，snmpget是可以根据指定的oid获取其对应的内容的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2、SNMPWalk功能测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　查看了下PDU的源码，发现没有对应snmpwalk的类型，所以使用getNext类型来实现snmpwalk功能。&lt;br/&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/690169/201712/690169-20171219174716756-169295141.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; snmpWalk(String oid) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、初始化snmp,并开启监听&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            initSnmp();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、创建目标对象&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             Target target =&lt;span&gt; createTarget(SnmpConstants.version2c, SnmpConstants.DEFAULT_COMMAND_RESPONDER_PORT);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、创建报文&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             PDU pdu =&lt;span&gt; createPDU(SnmpConstants.version2c, PDU.GETNEXT, oid);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             System.out.println(&quot;-------&amp;gt; 发送PDU &amp;lt;-------&quot;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4、发送报文，并获取返回结果&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; matched = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (matched) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 ResponseEvent responseEvent =&lt;span&gt; snmp.send(pdu, target);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (responseEvent == &lt;span&gt;null&lt;/span&gt; || responseEvent.getResponse() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 PDU response =&lt;span&gt; responseEvent.getResponse();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 String nextOid = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 Vector&amp;lt;? &lt;span&gt;extends&lt;/span&gt; VariableBinding&amp;gt; variableBindings =&lt;span&gt; response.getVariableBindings();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; variableBindings.size(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     VariableBinding variableBinding =&lt;span&gt; variableBindings.elementAt(i);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                     Variable variable =&lt;span&gt; variableBinding.getVariable();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     nextOid =&lt;span&gt; variableBinding.getOid().toDottedString();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是这个节点下的oid则终止遍历，否则会输出很多，直到整个遍历完。&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;nextOid.startsWith(oid)) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         matched = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                    //System.out.println(variable);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;matched) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                pdu.clear();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 pdu.add(&lt;span&gt;new&lt;/span&gt; VariableBinding(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OID(nextOid)));
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 System.out.println(&quot;返回结果：&quot; +&lt;span&gt; response);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated catch block&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;snmpGet(&quot;1.3.6.1.2.1.1.1.0&quot;);&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         snmpWalk(&quot;1.3.6.1.2.1.25.3.3.1.2&quot;);//CPU的当前负载，N个核就有N个负载&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
-------&amp;gt; 发送PDU &amp;lt;-------
&lt;/pre&gt;
&lt;p&gt;返回结果：RESPONSE[requestID=1014693266, errorStatus=Success(0), errorIndex=0, VBS[1.3.6.1.2.1.25.3.3.1.2.196608 = 1]]&lt;br/&gt;返回结果：RESPONSE[requestID=1014693268, errorStatus=Success(0), errorIndex=0, VBS[1.3.6.1.2.1.25.3.3.1.2.196609 = 0]]&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　用命令获取的结果是跟代码输出的结果是一样的，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/690169/201712/690169-20171219175521787-2147029078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;3、前面两个案例都是跟采集有关，接下来介绍如何监控接收服务器发过来的故障然后提示个用户，这就需要用到snmptrap了。接下来我们直接看案例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　处理流程：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1、必须实现CommandResponder接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2、初始化snmp并开启监听。这步跟上面初始化一样，只是面对并发的情况使用MultiThreadedMessageDispatcher进行信息处理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3、将当前实现CommandResponder的对象添加至snmp的addCommandResponder才能接收到信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4、处理接收到信息，通知用户。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.yuanfy.study.snmp;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.CommandResponder;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.CommandResponderEvent;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.MessageDispatcher;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.MessageDispatcherImpl;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.PDU;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.Snmp;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.TransportMapping;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.mp.MPv1;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.mp.MPv2c;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.mp.MPv3;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.security.AuthSHA;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.security.PrivAES128;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.security.SecurityProtocols;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.security.USM;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.security.UsmUser;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.smi.GenericAddress;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.smi.OctetString;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.smi.UdpAddress;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.transport.DefaultUdpTransportMapping;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.util.MultiThreadedMessageDispatcher;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.snmp4j.util.ThreadPool;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SnmpTrapHandler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CommandResponder{
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger log = LoggerFactory.getLogger(SnmpTrapHandler.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; threadNum = 200&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String ipAddress = &quot;udp:10.10.112.177/162&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Snmp snmp = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init(){
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、初始化多线程消息转发类&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         ThreadPool threadPool = ThreadPool.create(&quot;SnmpTrap&quot;&lt;span&gt;, threadNum);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         MessageDispatcher messageDispatcher = &lt;span&gt;new&lt;/span&gt; MultiThreadedMessageDispatcher(threadPool, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageDispatcherImpl()); 
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其中要增加三种处理模型。如果snmp初始化使用的是Snmp(TransportMapping&amp;lt;? extends Address&amp;gt; transportMapping) ,就不需要增加 &lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         messageDispatcher.addMessageProcessingModel(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MPv1());
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         messageDispatcher.addMessageProcessingModel(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MPv2c());
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         OctetString localEngineID = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OctetString(MPv3.createLocalEngineID());
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         USM usm = &lt;span&gt;new&lt;/span&gt; USM(SecurityProtocols.getInstance().addDefaultProtocols(), localEngineID, 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         UsmUser user = &lt;span&gt;new&lt;/span&gt; UsmUser(&lt;span&gt;new&lt;/span&gt; OctetString(&quot;SNMPV3&quot;), AuthSHA.ID, &lt;span&gt;new&lt;/span&gt; OctetString(&quot;authPassword&quot;&lt;span&gt;), 
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             PrivAES128.ID, &lt;span&gt;new&lt;/span&gt; OctetString(&quot;privPassword&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        usm.addUser(user.getSecurityName(), user);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         messageDispatcher.addMessageProcessingModel(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MPv3(usm));
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、创建transportMapping&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         TransportMapping&amp;lt;?&amp;gt; transportMapping = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             UdpAddress updAddr = (UdpAddress) GenericAddress.parse(System.getProperty(&quot;snmp4j.listenAddress&quot;&lt;span&gt;, ipAddress));
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             transportMapping = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultUdpTransportMapping(updAddr);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、正式创建snmp&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;             snmp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Snmp(messageDispatcher, transportMapping);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启监听&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            snmp.listen();
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) { 
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             log.error(&quot;初始化transportMapping失败：&quot;&lt;span&gt;, e.getMessage());
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     
&lt;span&gt;62&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start() {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;        init();
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一定要将当前对象添加至commandResponderListeners中&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;         snmp.addCommandResponder(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         System.out.println(&quot;开始监听trap信息：&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;     * 处理信息方法
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;71&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processPdu(CommandResponderEvent event) {
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;         String version = &lt;span&gt;null&lt;/span&gt;&lt;span&gt; ;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;         String community = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (event.getPDU().getType() ==&lt;span&gt; PDU.V1TRAP) {
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;             version = &quot;v1&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;             community = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(event.getSecurityName());
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (event.getPDU().getType() ==&lt;span&gt; PDU.TRAP){
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (event.getSecurityModel() == 2&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;                 version = &quot;v2&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;                 community = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(event.getSecurityName());
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;                 version = &quot;v3&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt;         System.out.println(&quot;接收到的trap信息：[发送来源=&quot;+event.getPeerAddress()+&quot;,snmp版本=&quot;+version+&quot;,团体名=&quot;+community+&quot;, 携带的变量=&quot;+event.getPDU().getVariableBindings()+&quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;89&lt;/span&gt;         SnmpTrapHandler handler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SnmpTrapHandler();
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; &lt;span&gt;        handler.start();
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;92&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/690169/201712/690169-20171219194347959-1368060088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/690169/201712/690169-20171219194405037-990330870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Dec 2017 11:45:00 +0000</pubDate>
<dc:creator>玉树临枫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanfy008/p/8046189.html</dc:identifier>
</item>
</channel>
</rss>