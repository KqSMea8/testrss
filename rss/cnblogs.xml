<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>编码最佳实践——Liskov替换原则 - CoderFocus</title>
<link>http://www.cnblogs.com/songwenjie/p/9583525.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/songwenjie/p/9583525.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180904/dJBa3fF2li.jpg?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Liskov替换原则（Liskov Substitution Principle）是一组用于创建&lt;strong&gt;继承层次结构&lt;/strong&gt;的指导原则。按照Liskov替换原则创建的继承层次结构中，客户端代码能够放心的使用它的任意类或子类而不担心所期望的行为。&lt;/p&gt;
&lt;h2 id=&quot;liskov替换原则定义&quot;&gt;Liskov替换原则定义&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果S是T的子类型，那么所有的T类型的对象都可以在不破坏程序的情况下被S类型的对象替换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;基类型：客户端引用的类型（T）。子类型可以重写（或部分定制）客户端所调用的基类的任意方法。&lt;/li&gt;
&lt;li&gt;子类型：继承自基类型（T）的一组类（S）中的任意一个。客户端不应该，也不需要知道它们实际调用哪个具体的子类型。无论使用的是哪个子类型实例，客户端代码所表现的行为都是一样的。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;liskov替换原则的规则&quot;&gt;Liskov替换原则的规则&lt;/h2&gt;
&lt;p&gt;要应用Liskov替换原则就必须遵守两类规则：&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;契约规则（与类的期望有关）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;子类型不能加强前置条件&lt;/li&gt;
&lt;li&gt;子类型不能削弱后置条件&lt;/li&gt;
&lt;li&gt;子类型必须保持超类型中的数据不变式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.&lt;strong&gt;变体规则（与代码中能被替换的类型有关）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;子类型的方法参数必须是支持逆变的&lt;/li&gt;
&lt;li&gt;子类型的返回类型必须是支持协变的&lt;/li&gt;
&lt;li&gt;子类型不能引发不属于已有异常层次结构中的新异常&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;契约&quot;&gt;契约&lt;/h2&gt;
&lt;p&gt;我们经常会说，要面向接口编程或面向契约编程。然后，除了表面上的方法签名，&lt;strong&gt;接口所表达的只是一个不够严谨的契约概念&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;作为方法编写者，要确保方法名称能反应出它的真实目的，同时参数名称要尽可能使描述性的。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public decimal CalculateShippingCost(int count,decimal price)
{
    return count * price;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而，方法签名并没有包含方法的契约信息。比如price参数是decimal类型的，这就表明任何decimal类型的值都是有限的。但是price参数的意义是价格，显然价格不能是负数。为了做到这一点，要在方法内部实现一个前置条件。&lt;/p&gt;
&lt;h3 id=&quot;前置条件&quot;&gt;前置条件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;前置条件（precondition）是一个能保障方法稳定无错运行的先决条件&lt;/strong&gt;。所有方法在被调用钱都要求某些前置条件为真。&lt;/p&gt;
&lt;p&gt;引发异常是一种强制履行契约的高效方式：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ShippingStrategy
{
    public decimal CalculateShippingCost(int count,decimal price)
    {
        if(price &amp;lt;= Decimal.Zero)
        {
            throw new Exception();
        }
        return count * price;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更好的方式是提供详尽的前置条件校验失败原因，便于客户端快速排查问题。此处抛出参数超出了有效范围，并且明确指出了是哪一个参数。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ShippingStrategy
{
    public decimal CalculateShippingCost(int count, decimal price)
    {
        if (price &amp;lt;= Decimal.Zero)
        {
            throw new ArgumentOutOfRangeException(&quot;price&quot;, &quot;price must be positive and non-zero&quot;);
        }
        return count * price;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了这些前置条件，客户端代码就必须在调用方法钱确保它们传递的参数值要处于有效范围内。当然，所有在前置条件中检查的状态必须是公开可访问的。私有状态不应该是前置条件检查的目标，只有方法参数和类的公共属性才应该有前置条件。&lt;/p&gt;
&lt;h3 id=&quot;后置条件&quot;&gt;后置条件&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;后置条件会在方法退出时检测一个对象是否处于一个无效的状态&lt;/strong&gt;。只要方法内改动了状态，就用可能因为方法逻辑错误导致状态无效。&lt;/p&gt;
&lt;p&gt;方法的尾部临界子句是一个后置条件，它能确保返回值处于有效范围内。该方法的签名无法保证返回值必须大于零，要达到这个目的，必须通过客户端履行方法的契约来保证。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ShippingStrategy
{
    public decimal CalculateShippingCost(int count, decimal price)
    {
        if (price &amp;lt;= Decimal.Zero)
        {
            throw new ArgumentOutOfRangeException(&quot;price&quot;, &quot;price must be positive and non-zero&quot;);
        }
    
        decimal cost = count * price;
    
        if (cost &amp;lt;= Decimal.Zero)
        {
            throw new ArgumentOutOfRangeException(&quot;cost&quot;, &quot;cost must be positive and non-zero&quot;);
        }
        return cost;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数据不变式&quot;&gt;数据不变式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;数据不变式（data invariant）是一个在对象生命周期内始终保持为真的一个谓词；该谓词条件在对象构造后一直超出其作用范围前的这段时间都为真&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;数据不变式都是与期望的对象内部状态有关，例如税率为正值且不为零。在构造函数中设置税率，只需要在构造函数中增加一个防卫子句就可以防止将其设置为无效值。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ShippingStrategy
{
    protected decimal flatRate;
    public ShippingStrategy(decimal flatRate)
    {
        if(flatRate &amp;lt;= Decimal.Zero)
        {
            throw new ArgumentOutOfRangeException(&quot;flatRate&quot;, &quot;flatRate must be positive and non-zero&quot;);
        }
        this.flatRate = flatRate;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为flatRate是一个受保护的成员变量，所以客户端只能通过构造函数来设置它。如果传入构造函数的值是有效的，就保证了ShippingStrategy对象在整个生命周期内的flatRate值都是有效的，因为客户没有地方可以修改它。但是，如果把flatRate定义为公共并且可设置的属性，为了保证数据不变式，就必须将防卫子句布置到属性设置器内。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ShippingStrategy
{
    private decimal flatRate;
    public decimal FlatRate
    {
        get
        {
            return flatRate;
        }
        set
        {
            if (value &amp;lt;= Decimal.Zero)
            {
                throw new ArgumentOutOfRangeException(&quot;flatRate&quot;, &quot;flatRate must be positive and non-zero&quot;);
            }
            flatRate = value;
        }
    }
    public ShippingStrategy(decimal flatRate)
    {
        this.FlatRate = flatRate;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;liskov契约规则&quot;&gt;Liskov契约规则&lt;/h3&gt;
&lt;p&gt;在适当的时候，子类被允许重写父类的方法实现，此时才有机会修改其中的契约。&lt;strong&gt;Liskov替换原则明确规定一些变更是被禁止的，因为它们会导致原来使用超类实例的客户端代码在切换至子类时必须要做更改&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;1.子类型不能加强前置条件&lt;/p&gt;
&lt;p&gt;当子类重写包含前置条件的超类方法时，绝不应该加强现有的前置条件，这样做&lt;strong&gt;会影响到那些已经假设超类为所有方法定义了最严格的前置条件契约的客户端代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180904/H8ceL0igJC.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class WorldWideShippingStrategy : ShippingStrategy
{
    public override decimal CalculateShippingCost(int count, decimal price)
    {
        if (price &amp;lt;= Decimal.Zero)
        {
            throw new ArgumentOutOfRangeException(&quot;price&quot;, &quot;price must be positive  and non-zero&quot;);
        }
        if (count &amp;lt;= 0)
        {
            throw new ArgumentOutOfRangeException(&quot;count&quot;, &quot;count must be positive  and non-zero&quot;);
        }
        return count * price;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.子类型不能削弱后置条件&lt;/p&gt;
&lt;p&gt;与前置条件相反，不能削弱后置条件。因为已有的客户端代码在原有的超类切换至新的子类时很可能会出错。&lt;/p&gt;
&lt;p&gt;原有的方法后置条件是方法的返回值必须大于零，映射到现实场景就是购物金额不能为负数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180904/H8ceL0igJC.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class WorldWideShippingStrategy : ShippingStrategy
{
    public override decimal CalculateShippingCost(int count, decimal price)
    {
        if (price &amp;lt;= Decimal.Zero)
        {
            throw new ArgumentOutOfRangeException(&quot;price&quot;, &quot;price must be positive  and non-zero&quot;);
        }
      
        decimal cost = count * price;

        return cost;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.子类型必须保持超类型中的数据不变式&lt;/p&gt;
&lt;p&gt;在创建新的子类时，它必须继续遵守基类中的所有数据不变式。这里是很容易出问题的，因为子类有很多机会来改变基类中的私有数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180904/H8ceL0igJC.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ShippingStrategy
{
    public ShippingStrategy(decimal flatRate)
    {
        if (flatRate &amp;lt; Decimal.Zero)
        {
            throw new ArgumentOutOfRangeException(&quot;flatRate&quot;, &quot;flatRate must be positive and non-zero&quot;);
        }
        this.flatRate = flatRate;
    }

    protected decimal flatRate;
}

public class WorldWideShippingStrategy : ShippingStrategy
{
    public WorldWideShippingStrategy(decimal flatRate) : base(flatRate)
    {
    }

    public  decimal FlatRate
    {
        get
        {
            return base.flatRate;
        }
        set
        {
            base.flatRate = value;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一种普遍的模式是，私有的字段有对应的受保护的或者公共的属性，属性的设置器中包含的防卫子句用来保护属性相关的数据不变式。&lt;strong&gt;更好的方式是，在基类中控制字段的可见性并只允许引入防卫子句的属性设置器访问该字段，将来所有的子类都不再需要防卫子句检查&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/Snipaste_2018-09-04_10-55-50.png?imageMogr2/thumbnail/x200/interlace/1/blur/1x0/quality/75&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ShippingStrategy
{
    public ShippingStrategy(decimal flatRate)
    {
        this.FlatRate = flatRate;
    }

    private decimal flatRate;
    protected decimal FlatRate
    {
        get
        {
            return flatRate;
        }
        set
        {
            if (value &amp;lt; Decimal.Zero)
            {
                throw new ArgumentOutOfRangeException(&quot;flatRate&quot;, &quot;flatRate must be positive and non-zero&quot;);
            }
            flatRate = value;
        }
    }
}

public class WorldWideShippingStrategy : ShippingStrategy
{
    public WorldWideShippingStrategy(decimal flatRate) :base(flatRate)
    {
    }

    public new decimal FlatRate
    {
        get
        {
            return base.FlatRate;
        }
        set
        {
            base.FlatRate = value;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;协变和逆变&quot;&gt;协变和逆变&lt;/h2&gt;
&lt;p&gt;Liskov替换原则的剩余原则都与协变和逆变相关。首先要明确变体（variance）这个概念，变体这个术语主要应用于复杂层次类型结构中&lt;strong&gt;以定义子类型的期望类型&lt;/strong&gt;，有点类似于多态。在C#语言中，变体的实现有协变和逆变两种。&lt;/p&gt;
&lt;h3 id=&quot;协变&quot;&gt;协变&lt;/h3&gt;
&lt;p&gt;下图展示了一个非常小的类层次结构，包含了基（超）类Supertype和子类Subtype。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180904/Fg6ggAcKbc.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多态是一种子类型被看做基类型实例的能力&lt;/strong&gt;。任何能够接受Supertype类型实例的方法也可以接受Subtype类型实例，客户端不需要做类型转换，也不需要知道任何子类相关的信息。&lt;/p&gt;
&lt;p&gt;如果我们引入一个通过&lt;strong&gt;泛型参数&lt;/strong&gt;使用Supertype和Subtype的类型时，就进入了变体（variance）的主题。因为有了协变，一样可以用到多态这个强大的特性。当有方法需要ICovariant的实例时，完全可以使用ICovariant的实例替代之。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180904/iam3cm5Egj.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举一个从仓储库中获取对象的例子帮助理解：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Entity
{
    public Guid ID { get; set; }

    public string Name { get; set; }
}

public class User:Entity
{
    public string Email { get; set; }

    public DateTime DateOfBirth { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为User类和Entity类之间是继承关系，所以我们也想在仓储实现上存在继承层次结构，通过重写基类方法返回不同具体类型对象。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class EntityRepository
{
    public virtual Entity GetByID(Guid ID)
    {
        return new Entity();
    }
}

public class UserRepository : EntityRepository
{
    public override User GetByID(Guid ID)
    {
        return new User();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180904/H8ceL0igJC.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果就会发现编译不通过。&lt;strong&gt;因为不使用泛型类型，C#方法的返回类型就不是协变的。&lt;/strong&gt;换句话说，这种情况下（普通类）的继承是不具备协变能力的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180904/G2cam02Jhk.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/Snipaste_2018-09-04_10-55-50.png?imageMogr2/thumbnail/x200/interlace/1/blur/1x0/quality/75&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有两种方案可以解决此问题：&lt;/p&gt;
&lt;p&gt;1.可以将UserRepository类的GetByID方法的返回类型修改回Entity类型，然后在该方法返回的地方应用多态将Entity类型的实例装换为User类型的实例。这种方式虽然客户解决问题，但是对于客户端并不友好，因为客户端必须自己做实例类型转换。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class UserRepository : EntityRepository
{
    public override Entity GetByID(Guid ID)
    {
        return new User();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.可以把EntityRepository重新定义为一个需要泛型的类型，把Entity类型作为泛型参数传入。这个泛型参数是可以协变的，UserRepository子类可以为User类指定超类型。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface IEntityRepository&amp;lt;out T&amp;gt; where T:Entity
{
    T GetByID(Guid ID);
}

public class EntityRepository : IEntityRepository&amp;lt;Entity&amp;gt;
{
    public Entity GetByID(Guid ID)
    {
        return new Entity();
    }
}


public class UserRepository : IEntityRepository&amp;lt;User&amp;gt;
{
    public User GetByID(Guid ID)
    {
        return new User();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新的UserRepository类的客户端无需再做向下的类型转换，因为直接得到就是User类型对象，而不是Entity类型对象。EntityRepository和UserRepository两个类的父子继承关系也得以保留。&lt;/p&gt;
&lt;h3 id=&quot;逆变&quot;&gt;逆变&lt;/h3&gt;
&lt;p&gt;协变是与方法返回类型的处理有关，而逆变是与方法参数类型的处理有关。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180904/FFCHdAd5F3.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，泛型参数由关键字in标记，表示它是可逆变的。这表明层析结构已经被颠倒了：IContravariant成为了超类，IContravariant则变成了子类。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public interface IEqualityComparer&amp;lt;in T&amp;gt; where T:Entity
 {
     bool Equals(T left, T right);
 }

 public class EntityEqualityComparer : IEqualityComparer&amp;lt;Entity&amp;gt;
 {
     public bool Equals(Entity left, Entity right)
     {
         return left.ID == right.ID;
     }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;IEqualityComparer&amp;lt;User&amp;gt; userComparer = new EntityEqualityComparer();
User user1 = new User();
User user2 = new User();
userComparer.Equals(user1, user2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180904/H8ceL0igJC.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果没有逆变（接口定义中泛型参数前的in 关键字），编译时会直接报错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180904/4JHaiHmBf5.png?imageslim&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;错误信息告诉我们，无法将EntityEqualityComparer转换为IEqualityComparer类型。直觉就是这样，因为Entity是基类，User是子类型。而如果IEqualityComparer支持逆变，现有的继承层次结构会被颠倒。此时可以&lt;strong&gt;向需要具体类型参数的地方传入更通用的类型&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;不变性&quot;&gt;不变性&lt;/h3&gt;
&lt;p&gt;除了逆变和协变的行为外，类型本身具有不变性。这里的不变性是指“&lt;strong&gt;不会生成变体&lt;/strong&gt;”。既不可协变也不可逆变，必定是个非变体。具体到实现层面，定义中没有对in和out关键字的引用，这二者分别用来指定逆变和协变。&lt;strong&gt;C#语言的方法参数类型和返回类型都是不可变的，只有在设计泛型时才能将类型定义为可协变的或可逆变的&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;liskov类型系统规则&quot;&gt;Liskov类型系统规则&lt;/h3&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;子类型的方法参数必须是支持逆变的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;子类型的返回类型必须是支持协变的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;子类型不能引发不属于已有异常层次结构中的新异常&lt;/p&gt;
&lt;p&gt;异常机制的主旨就是&lt;strong&gt;将错误的汇报和处理环节分隔开&lt;/strong&gt;。捕获异常后不做任何处理或只捕获最通用的Exception基类都是不可取的，二者结合就更糟糕了。从SystemException派生出来的异常基本都是根本无法处理和恢复的情况。好的做法总是从ApplicationException类派生自己的异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;Liskov替换原则是SOLID原则中最复杂的一个。需要理解契约和变体的概念才可以应用Liskov替换原则编写具有更高自适应能力的代码。&lt;strong&gt;理想情况下，不论运行时使用的是哪个具体的子类型，客户端都可以只引用一个基类或接口而无需担心行为变化。&lt;/strong&gt;任何对Liskov替换原则定义规则的违背都应该被看作技术债务，应该尽早的偿还掉这些技术债务，否则后患无穷。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;《C#敏捷开发实践》&lt;/p&gt;
&lt;div class=&quot;esa-post-signature&quot; readability=&quot;32.697318007663&quot;&gt;
&lt;p&gt;作者：&lt;a href=&quot;http://songwenjie.cnblogs.com/&quot; target=&quot;_blank&quot;&gt;CoderFocus&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微信公众号：&lt;br/&gt;&lt;img src=&quot;http://songwenjie.vip/blog/180511/AFdec5f65k.jpg?imageslim&quot; title=&quot;关注公众号，获取最新更新&quot;/&gt;&lt;/p&gt;
&lt;p&gt;声明：本文为博主学习感悟总结，水平有限，如果不当，欢迎指正。如果您认为还不错，不妨点击一下下方的&lt;span onclick=&quot;Digg();&quot;&gt;【&lt;span&gt;推荐&lt;/span&gt;】&lt;/span&gt;按钮，谢谢支持。转载与引用请注明作者及出处。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 17 Sep 2018 22:54:00 +0000</pubDate>
<dc:creator>CoderFocus</dc:creator>
<og:description>Liskov替换原则（Liskov Substitution Principle）是一组用于创建 继承层次结构 的指导原则。按照Liskov替换原则创建的继承层次结构中，客户端代码能够放心的使用它的任</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/songwenjie/p/9583525.html</dc:identifier>
</item>
<item>
<title>给刚工作不久的程序猿同学的一封信 - 虚无境</title>
<link>http://www.cnblogs.com/xuwujing/p/9665966.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuwujing/p/9665966.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前一段时间，看到某篇文章，讲的是某个同学在刚开始工作的时候，因不太懂职场的一些规则，所以和领导闹得不太愉快，最后不欢而散。这里不讨论是非对错，只简单的谈下如何在工作中应该注意的一些细节而已。本篇文章仅代表个人观点，如有不妥，望请见谅！&lt;/p&gt;
&lt;h2 id=&quot;建议&quot;&gt;建议&lt;/h2&gt;
&lt;p&gt;本文主要讲得的是在工作中应该注意的一些东西，或者说是一些建议！&lt;br/&gt;这里分为主要的三个部分讲解，在工作中的事情，与同事的相处，以及和领导的相处。&lt;/p&gt;
&lt;h3 id=&quot;工作&quot;&gt;工作&lt;/h3&gt;
&lt;p&gt;在工作中，我们主要的工作是完成上级分配的任务。但是这些任务有轻有重，量大或量小。如果是该公司的老员工的话，一般能够分辨出这些任务的轻重缓急以及任务所需要完成的周期，但是新员工，特别是刚参加工作不久的同学来说呢，是很难判断出来的，有时会在蒙蔽的情况下接下任务，但是没有在规定期限中完成，搞不好就会被领导叫到小黑屋里训话 ::&amp;gt;_&amp;lt;:: 。。。&lt;br/&gt;如果这时由老员工进行相应指导的话，会好上不少，但是也可能还是会出现这种情况。所以这里整理了一下自己的一些经验，希望能够帮到需要的同学。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、 明确项目周期&lt;/strong&gt;&lt;br/&gt;一般领导在进行任务分配的时候，会有相应期限的，基本不可能不说期限的，若真的出现这种情况，可以适当的进行提醒，免得出现日后问起但是又未完成的尴尬境况。&lt;/p&gt;
&lt;p&gt;在确认任务的时间的时候，如果不确定多久能够完成，条件允许的情况下可以问问相应的老员工，然后再结合自身的情况进行调整，千万不要以老员工完成的期限的作为期限，因为大部分情况下他们的经验以及业务都会比你熟悉，相应花费的时间会比你少很多的，这点尤其注意!!! 还有需注意的是，在不熟的时候，可以适当在预计完成期限上加上几天，以应对不时之需。因为大部分的时候，并不是一帆风顺的。。。&lt;/p&gt;
&lt;p&gt;如果有多个任务，记得分清&lt;strong&gt;轻重缓急&lt;/strong&gt;以及总任务周期。例如A任务的周期是3天，是重要并且紧急的，B任务的周期是5天，是重要但不紧急的，所以你实际应该花费的是8天来完成，而不是5天，这两个应该记得严格区分开，不然到时会非常惨的，领导可能只会记得规定的日期，并不会记得为什么这么定。至于为什么这么说， 因为本人曾经犯下过这种错，最后不得不一直加班而去完成 ::&amp;gt;_&amp;lt;::。。。&lt;/p&gt;
&lt;p&gt;如果和同事合作进行开发，若不清楚相应的业务，所以无法知道具体完成所需的时间，那么最好将此交给熟悉的同事来确认。也不要因为简单就直接确认完成期限，可能里面埋藏着暂时无法看到的坑。记住一点，不要因为自己的缘故而耽误别人以及整个项目的完成计划，一两次可能还会体谅，但是多了可能就不会受待见了。&lt;/p&gt;
&lt;p&gt;最后，说点非常重要的建议。很多情况下，项目并不能在规定周期内完成，因为会有各种各样的事情干扰，比如，改需求，突然有其他的事情之类的，所以在有突发事件，不要默默的继续，记得要及时提出来，如果没有提出来，哪怕加班累死的做也依旧也没作为，领导一般也不会给你好脸色，对他们来说，重要的是结果，而不是过程。当然，如果的确是项目周期短，在这过程中也遇到突发事件，也提出了，也努力加班了，还是没能完成，这种情况一般领导也不会过多责怪的。但是若未提出，也未加班，也没能完成， 这种情况大多数领导都不会给好脸色的。。。所以，记得有困难及时提出!!!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、了解项目需求&lt;/strong&gt;&lt;br/&gt;正所谓无需求不开发。如果没有相应的需求以及文档下来，我们开发可以理直气壮的说不开发。&lt;br/&gt;当然这是个玩笑 ~_~ ，很多情况下，需求只有领导讲述，然后你得认真听讲，理解需求之后在进行开发，好一点的会有相应的需求文档(吐槽下，大部分需求文档真的写得不咋地)，再好一点的就是整个项目的流程以及完整的需求文档。&lt;br/&gt;当然这里我们主要做的是真正的了解需求，从而进行开发，而不是了解一点皮毛，然后没头没脑的编写代码。那么应该怎么真正的了解需求呢？如果条件允许，有相应的流程和文档，一般是可以了解的，不过目前很多公司都不满足，需求仅仅靠领导的讲述，我们了解的需求也就只是领导的讲述，如果领导讲述的比较明白的那还好，若没有讲述明白，或者自己没有完全理解的话，这时最好就不要进行相应的开发，可以先整理一下思路，找出你所了解这个需求的具体事项以及需要注意的东西，整理好了思路之后，带着疑问在和领导进行相应的沟通，直到彻底了解，也就是你能够开发领导想要的东西。记住一点，很多情况下，通过一次沟通得到信息往往只有不到全部60%，剩下的需要继续沟通或者通过其它方式获得，所以在开发前确保能够了解需求，不然可能会开发出一个与之前指定不符的东西！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、学会问问题&lt;/strong&gt;&lt;br/&gt;问问题这点在工作中很常见，其实我觉得这种也没必要拿出来讲。但是很多情况下，真的会遇到一些不会问问题的同学，会感觉到很麻烦，所以这里也顺便说下，如何问问题。&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;首先在问问题之前，先整理一下思路，有多少问题要问，想要得到什么样的结果，然后讲这些罗列出来，整理好之后再去问。而不是有问题就问，然后又出现其它的问题，然后继续问，这样没完没了，会让人很厌烦的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;问问题最好是选择题，其次是填空题，继而是议论题，最次就是空想题，也就是空乏的问题，很不好回答的那种。问问题是需要一定的技巧的，如果可以的话，给别人选择题最好，毕竟相比而言是最好做的，也是最省时间的 ; 其次就是填空题，也可以说是选项多一些的选择题，只不过不知道这这选项而已；然后就是以论题，虽然是麻烦点，但是知道是讨论啥；最次就是空想题，问问题的人不清楚自己究竟想要什么，需要你来解答，但是你连问题是怎么样的，都不知道怎么解答，这点就好像不在一个频道上，很是烦恼，举个例子，A同学问B同学，你觉得xxx应该怎么搞? B同学就问，xxx是什么，然后A同学就说xxx就是，或者说你应该知道啊，然后B同学依旧不太懂xxx是啥，然后说搞什么，然后A 同学就说 xxx应该你觉得怎么搞啊。。。此处省略800字。 虽然举得例子不太恰当，但是真的遇到过这种类似的。。。很是让人无语。&lt;br/&gt;如果可以的话，给人选择题做最好，比如，C同学问D同学，在某个项目运行中出现的一个bug，我觉得可能是这几个原因造成的，你觉得是哪一种呢?然后D同学就指出其中一个，最后C同学就按照D同学指出的这个去排查问题，最后完美解决。&lt;br/&gt;当然以上示例只是打个比方，只是告诉一下问问题的一些技巧，这样问问题也不会让人觉得厌烦，可能还会很高兴的一起解决下。所以学会问问题的技巧，会在工作中更加得心应手的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;问问题需要看准时机。不要再别人忙的时候或者心情不好的时候询问，除非特别需要，而且问问题之前自己最好努力的尝试过了，实在是无法解决的情况下，不要什么都没尝试就去询问，这样对自己，对他人都不友好。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;与同事相处&quot;&gt;与同事相处&lt;/h3&gt;
&lt;p&gt;其实与同事相处这块，想必不同的人有不同的见解，这些见解并无对错之分，只有适合和不适合而已。这里也就只是简单的谈谈我对同事之间相处的一些看法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、友好相处&lt;/strong&gt;&lt;br/&gt;虽然这个可能是个废话，但是与同事之间友好相处会很大程度上提升自己。无论是在工作中，还是在生活中，至于提升有多大，这点因个人而已。除非是实在无法相处，否则最好不要和同事直接闹得不愉快。至于后果如何，这点想必不用多说了吧。&lt;br/&gt;工作中相处最好礼貌，面带笑容，哪怕和某同事不和。有句话说爱笑的人，人缘不会太差，所以除非必要，笑着工作总比愁眉苦脸或冷漠要好很多吧。&lt;br/&gt;对同事做得好的一面，不要吝啬赞美；做得不好的一面，不要进行耻笑。在 &lt;strong&gt;&amp;lt;人性的弱点&amp;gt;&lt;/strong&gt;中有句话很印象很深刻，大体如下:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;赞美总比批评要好，赞美可能会多一个朋友，但是批评可能就会多一个朋友。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;二、不要过于依赖&lt;/strong&gt;&lt;br/&gt;很多同学在进入一家公司之后，一般会由一个老员工进行携带。这个老员工可能在今后的工作中会与你进行接触，而你也有很多工作上的事情需要想他进行请教，可能久而久之，你就会对他过于依赖，甚至是过度依赖。但是最好不要这样，毕竟很多时候你们并不能在一起长久的工作，这时就需要独立出来，能够独立的完成份内的工作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、不要打探隐私&lt;/strong&gt;&lt;br/&gt;这个就如小标题所言，不要随意打探别人的隐私。比如询问工资、家庭、出身等等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、不要背后议论&lt;/strong&gt;&lt;br/&gt;这个也如小标题所言，不要因为和某个同事相处不愉快，就在背后和其他的同事进行议论。这种话最好少提，这个是职场大忌！&lt;/p&gt;
&lt;h3 id=&quot;与领导相处&quot;&gt;与领导相处&lt;/h3&gt;
&lt;p&gt;这里也来到正片了，也就是如何和领导好好相处。因为我没当过领导，或者说没有真正的管理过人(学校的那种不算的)，所以这里就以被管理者的身份来进行看待。&lt;br/&gt;这里简单的说下我们领导的印象。在我的看法中，有这四种领导：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有能力有态度&lt;/li&gt;
&lt;li&gt;有能力无态度&lt;/li&gt;
&lt;li&gt;无能力有态度&lt;/li&gt;
&lt;li&gt;无能力无态度&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注: 这里的能力和态度并不单纯的如字面所说。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有能力有态度&lt;/strong&gt;这种领导表示除了技术或管理方面之外，在用人方面也很有一套，能够让下属各司其职，做擅长的事情，并且能够能够合理的分配相应的任务，并且对待下属很好，能够倾听下属的想法，能够和下属开玩笑，能欧一起玩，能够对犯错的下属一定的宽容。。。&lt;br/&gt;总而言之，就是 工作中是个好的领导，私下是个可以知心朋友的这种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有能力无态度&lt;/strong&gt;&lt;br/&gt;能力和上面基本一致，但是无态度并不表示态度不好，这里的无态度表示的是并不能很好的和下属融入一起，有种微妙的隔阂在其中。&lt;br/&gt;总而言之，就是工作中算是个好的领导，但是私下就可能没什么交集了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无能力有态度&lt;/strong&gt;&lt;br/&gt;态度和第一种基本差不多，区别是能力方面。这里的无能力并不代表真的没有什么能力，这里只是表示的是在某些方面有所欠缺，或者说是对工作上还不太真正了解，这种一般是刚做领导不久的，可能日后会发展成第一种。&lt;br/&gt;总而言之，就是工作中算是不错的领导，但是可能因为能力方面让下属吃点苦头。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无能力无态度&lt;/strong&gt;&lt;br/&gt;这里的&lt;strong&gt;无能力和无态度&lt;/strong&gt;，可以说是2、3种的一个结合体。但是又不绝对，上限接近第一种，至于下限嘛。。。就说不好的那种。&lt;br/&gt;这种领导可能是我们遇到最多的一种，总感觉和这种领导没什么话说，也没有什么感情，甚至相处不来的直接不欢而散。会在背后经常进行议论或进行吐槽。&lt;br/&gt;总而言之，工作中只能说是中规中矩，私下基本没有交集，很有很能在今后的人生中回想，只是人生中的一个过客，并没留下重要的痕迹。&lt;/p&gt;
&lt;p&gt;这四种领导中，第一种最好，能遇到可以说是非常的幸运，在其手下工作是很舒心的事情，一般只要按照要求完成事情，过得就会不错，即使因个人原因而导致项目出现问题，也能够愉快的解决。 由于私下交流不错，即使离职以后也会经常联系，但是这种却很少；&lt;br/&gt;第二种一般在大公司中算是比较多的，在其手下工作也很不错，做事也很舒心，不过因个人原因而导致项目出现问题，可能就会受罚。 但是因为没有私下交流，可能不在其工作之后，会删除其联系方式，不在联系；&lt;br/&gt;第三种也算是比较多的，因能力问题，可能在其手下做事可能会遇到被坑的情况，不过即使因此也不会有太多的不愉快。 因为私交也不错，在私下也经常联系；&lt;/p&gt;
&lt;p&gt;第四种可能就是最多的，好一点的还能够做同事相处，差一点的可能入职不久就会离职，这种领导就非常需要一些相处的技巧了，当然这些技巧也适应与所有的领导。&lt;/p&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;按时完成任务&lt;br/&gt;和这种领导相处，最重要的一点是，任务的完成度，只要任务完成的情况能够达到他所要求的，那么便不会因此相处不太愉快。还有由于私交不算很好，所以在很多情况下，只会看中结果，而不看重过程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;抓住重点&lt;br/&gt;虽然是废话，但是还是要说。进行工作汇报的时候，如果摸不清属性，最好能够简洁的对工作进度进行汇报，不要搞一些花里胡哨的东西。要突出重点！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;做事认真负责&lt;br/&gt;还是废话，也就是自己负责的东西一定要做好，并且负责。如果因为自己的问题导致出现了问题，及时承认错误并解决，哪怕不是自己的问题，只要能解决。因为对于他来说，出现了问题不可怕，可怕的是问题没有及时解决。所以在出现的问题之后，最好先解决再来谈是什么原因导致的，谁应该负责。虽然很多情况下，会背负莫名其妙的锅，但是解决问题之后再来丢锅总比先丢锅在来解决问题好。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;不要顶撞领导&lt;br/&gt;如字面所说，除非实在是受不了了。和领导闹得不愉快最终对自己不好，无论是你的错还是他的错。人潜意识总会认为自己没错，所以下意识的会认为是别人的错误，所以在出现这种情况时，首先解决，解决不了，提出，谁错的问题在解决之后再提，不过记得不要太直接，如果事情不大，可以忽略。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其他的可能还有，不过暂时我就想这么多了。这其中的一些问题自己也没回答好，希望不要介意。总之，这篇文章主要在工作中，学会与人好好相处，最重要的秘诀就是&lt;strong&gt;微笑&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;
&lt;p&gt;上述中是个人好的想法，如果觉得不错，那么到这就可以结束了。&lt;br/&gt;因为接下来说的就是另一种了，也可以说是一些牢骚吧。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;有能力者改变环境，没能力者被环境改变，千古不变的真理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工作之前，以为自己工作之后不会成为那种虚伪的人，但是工作之后却又不得不改变，最终成为以前自己的讨厌的那种虚伪的人。或许我还是没有找到适合自己生活的方法吧！很想，很想活的简单，获得洒脱，不在掩饰自己真正的个性，不想做一个虚伪的人。但是，但是却又不得不做成一个这样的人，因为这是&lt;strong&gt;大家&lt;/strong&gt;希望看到的，&lt;strong&gt;社会&lt;/strong&gt;希望看到的，但不是我希望看到的。工作快三年了，个性正在慢慢的被同化。现在为了生活而奔波忙碌，所以带上假面适应社会，不然会显得不合群。现在也没找到工作和生活的一个平衡点，生活慢慢的被工作所压迫，可能最终会带上这个假面一直过下去吧。。。&lt;/p&gt;
&lt;p&gt;上述中，纯属个人&lt;strong&gt;无病呻吟&lt;/strong&gt;，有些羞耻，本想删除，但是还是留着吧！也许能够遇到同样的人，也许可以得到一些有用的建议。至于如何，以后再看吧！&lt;/p&gt;
&lt;h3 id=&quot;音乐推荐&quot;&gt;音乐推荐&lt;/h3&gt;
&lt;p&gt;写完刚好听到这首音乐，觉得不错，于是分享！&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;原创不易，如果感觉不错，希望给个推荐！您的支持是我写作的最大动力！&lt;br/&gt;版权声明:&lt;br/&gt;作者：虚无境&lt;br/&gt;博客园出处：&lt;a href=&quot;http://www.cnblogs.com/xuwujing&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/xuwujing&lt;/a&gt;&lt;br/&gt;CSDN出处：&lt;a href=&quot;http://blog.csdn.net/qazwsxpcm&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qazwsxpcm&lt;/a&gt;　&lt;br/&gt;个人博客出处：&lt;a href=&quot;http://www.panchengming.com&quot; class=&quot;uri&quot;&gt;http://www.panchengming.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Sep 2018 16:54:00 +0000</pubDate>
<dc:creator>虚无境</dc:creator>
<og:description>前言 前一段时间，看到某篇文章，讲的是某个同学在刚开始工作的时候，因不太懂职场的一些规则，所以和领导闹得不太愉快，最后不欢而散。这里不讨论是非对错，只简单的谈下如何在工作中应该注意的一些细节而已。本篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuwujing/p/9665966.html</dc:identifier>
</item>
<item>
<title>中高级前端应该必会，js实现事件委托代理、切换样式、元素获取相对于文档位置等 - 小结巴巴吧</title>
<link>http://www.cnblogs.com/jiebba/p/9663268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiebba/p/9663268.html</guid>
<description>&lt;h3&gt;1、介绍&lt;/h3&gt;
&lt;p&gt;　　随着组件开发大流行，现在三大框架已经基本占领了整个前端。&lt;/p&gt;
&lt;p&gt;　　这时候，我们要是引入一个 jq 是不是先得你的项目非常臃肿，jq 也很不适合。&lt;/p&gt;
&lt;p&gt;　　这个时候，你就需要来增加你 js 的功底。&lt;/p&gt;

&lt;h3&gt;2、各种操作&lt;/h3&gt;

&lt;h4&gt;　　1、事件委托&lt;/h4&gt;
&lt;h4&gt;　　案例分析：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;ul id= &quot;list&quot;&amp;gt;
    &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;    
    &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;    
    &amp;lt;li&amp;gt;4&amp;lt;/li&amp;gt;    
    &amp;lt;li&amp;gt;5&amp;lt;/li&amp;gt;    
&amp;lt;/ul&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如上面的页面机构，我们需要个每一个 li 添加同一个事件。&lt;/p&gt;
&lt;p&gt;　　常规操作：&lt;/p&gt;
&lt;p&gt;　　选择出所有的 li 标签，然后为所有的标签都添加这个事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
var liList = document.querySelectorAll('#list li')
liList.foreach(function(item,index)=&amp;gt;{
　　item.addEventListener('click',doSomething)
})
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　很简单，也是非常好的。&lt;/p&gt;
&lt;p&gt;　　但是当这里的 li 标签多了之后，那么你获取所有的 li 标签并绑定事件就会变慢，也就是说性能就会不好了。&lt;/p&gt;
&lt;p&gt;　　这个时候该如何处理呢？&lt;/p&gt;

&lt;h4&gt;　　事件委托：&lt;/h4&gt;
&lt;p&gt;　　解释下事件委托吧，可能新手不知道。&lt;/p&gt;
&lt;p&gt;　　就是把子元素想要绑定的事件，绑定到子元素的父元素上面。&lt;/p&gt;
&lt;p&gt;　　然后当事件触发的时候，通过事件冒泡来获取到当前事件源对应的的元素。(事件冒泡和捕获如果不知道还是需要补习下的)&lt;/p&gt;
&lt;p&gt;　　代码展示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
var liList = document.querySelectorAll('#list')
liList.addEventListener('click',function(e)=&amp;gt;{ 
    if(e.target &amp;amp;&amp;amp; e.target.nodeName.toUpperCase == 'LI'){
　　　　console.log('你点击了'+e.target.innerText )
　　}
})
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　给一个比较完整的例子，没有验证...&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
function delegate(element, eventName, name, func) {
        element.addEventListener(eventName, function (e) {
                var target = e.target, parent = target;
                while (target &amp;amp;&amp;amp; parent != element) {
                        if (parent.nodeName.toLowerCase() == name) {
                                e.target = parent
                                func.apply(parent,e);
                                break;
                        }
                        parent = parent.parentNode;
                }
        });
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　上面的例子，name 字段可以是 类命，id 的值，也可以是 标签。&lt;/p&gt;
&lt;p&gt;　　自行修改，更灵活。。&lt;/p&gt;

&lt;h4&gt;　　总结：&lt;/h4&gt;
&lt;p&gt;　　事件代理委托主要是通过给父元素绑定事件。&lt;/p&gt;
&lt;p&gt;　　通过事件的冒泡来确定当前的事件源。&lt;/p&gt;
&lt;p&gt;　　确定事件源，并执行具柄。&lt;/p&gt;



&lt;h4&gt;　　2、es5 的元素获取、class 的操作&lt;/h4&gt;

&lt;h4&gt;　　es5 的元素获取&lt;/h4&gt;

&lt;p&gt;　　在之前我一直都是使用的 es3 做元素获取的，如：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
document.getElementById(id)
document.getElementsByClassName(class)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面的相信是大家以前最熟悉的 js 获取方法。&lt;/p&gt;
&lt;p&gt;　　但是在 es5 出来后，你会惊奇的觉得 Jquery 选择器可以被替代了&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
document.querySelector(selector)
document.querySelectorAll(selector)
// 例如
document.querySelector('.classs p')  // 获取 class 类下面的 p 标签
// 可以看到和 jquery 选择器差不多，只是功能精简了
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　上面很清楚的可以知道：&lt;/p&gt;
&lt;p&gt;　　querySelector 是获取单个元素&lt;/p&gt;
&lt;p&gt;　　querySelectorAll 是获取多个匹配元素&lt;/p&gt;
&lt;p&gt;　　最大的变化就是 selector。&lt;/p&gt;
&lt;p&gt;　　它可以是 .className  、  #id   、也可以是多级选择  .className p&lt;/p&gt;


&lt;h4&gt;　　class 类的一些 es5 操作 &lt;/h4&gt;

&lt;p&gt;　　Dom 的 classList 属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;div id = &quot;test&quot; class = &quot;red big hot&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;获取样式类列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　document.querySelector('test').classList&lt;/p&gt;
&lt;p&gt;　　这里会返回一个 TokenList 也就是是个类数组：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
{
　　0:red,
　　1:big,
　　2:hot,
　　length:3,
　　value:'red big hot'
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;　　添加类名&lt;/h4&gt;
&lt;p&gt;　　document.querySelector('test').classList.add('good','new')&lt;/p&gt;
&lt;p&gt;　　添加类 good ， new 。如果类名已经存在，则不添加&lt;/p&gt;

&lt;h4&gt;　　移除某类&lt;/h4&gt;
&lt;p&gt;　　document.querySelector('test').classList.remove('good','new')　　&lt;/p&gt;
&lt;p&gt;　　移除 good ， new 类。移除不存在的类，会报错&lt;/p&gt;

&lt;h4&gt;　　切换类&lt;/h4&gt;
&lt;p&gt;　　document.querySelector('test').classList.toggle('good')&lt;/p&gt;
&lt;p&gt;　　切换 good 类。如果 good 存在返回true，否则false&lt;/p&gt;

&lt;h4&gt;　　判断是否存在某类&lt;/h4&gt;
&lt;p&gt;　　document.querySelector('test').classList.contains('good')&lt;/p&gt;
&lt;p&gt;　　返回 boolean 值。&lt;/p&gt;


&lt;h4&gt;　　3、获取元素在父元素中第几个&lt;/h4&gt;

&lt;p&gt;　　其实这个在现在的组件模式中很容易实现。&lt;/p&gt;
&lt;p&gt;　　但是 js 中是如是实现的呢 ？&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
 &amp;lt;ul&amp;gt;
　　&amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
　　&amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
　　&amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　获取方法及其封装：&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
function index(parent,son) {
       return [].indexOf.call(parent.children,son);
   }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　如上面：&lt;/p&gt;
&lt;p&gt;　　parent 是父元素，son 很显然是子元素&lt;/p&gt;



&lt;h4&gt;　　4、元素相对于文档 / 窗口视图的位置 &lt;/h4&gt;

&lt;p&gt; 　&lt;strong&gt;　相对于文档的位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　在 jquery 中我们实现的方法是 $(s).offset() 来回去相对于文档的位置。&lt;/p&gt;
&lt;p&gt;　　那 js 中如何实现的呢？&lt;/p&gt;

&lt;p&gt;　　代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
const getDocPosition = (element) =&amp;gt; {
    let eleCom = element;
    if (typeof element === 'string') eleCom = document.querySelector(eleCom);
    let x = eleCom.offsetLeft;
    let y = eleCom.offsetTop;
    let parent = eleCom.offsetParent;
    while (parent) {
        x += parent.offsetLeft;
        y += parent.offsetTop;
        parent = parent.offsetParent;
    }
    return {
        x,
        y,
    };
};
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　代码很简单：&lt;/p&gt;
&lt;p&gt;　　可以看出，通过不断的获取 offsetLeft / offsetTop ，并且与它的父元素相加。&lt;/p&gt;
&lt;p&gt;　　直到相加到顶级元素为止。 &lt;/p&gt;


&lt;p&gt;　　&lt;strong&gt;相对于窗口视图位置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　getBoundingClientRect用于获取某个元素相对于视窗的位置集合。集合中有top, right, bottom, left等属性。&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://images0.cnblogs.com/blog2015/678562/201504/262132219001037.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
rectObject = object.getBoundingClientRect();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　  rectObject.top：元素上边到视窗上边的距离;&lt;/p&gt;
&lt;p&gt;　  rectObject.right：元素右边到视窗左边的距离;&lt;/p&gt;
&lt;p&gt;　  rectObject.bottom：元素下边到视窗上边的距离;&lt;/p&gt;
&lt;p&gt;　  rectObject.left：元素左边到视窗左边的距离;&lt;/p&gt;

&lt;h4&gt;　　如果你看过 lazyImg 图片的懒加载，你们就会发现，他的实现原理就是这个。&lt;/h4&gt;
&lt;h4&gt;　　当它图片出现在窗口的视图中，就会加载真的图片资源。 &lt;/h4&gt;


&lt;h5&gt;　　后续继续添加常用的、容易忘的一些 js 功能。&lt;/h5&gt;

&lt;p&gt;　　&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 中高级前端应该必会，js实现事件委托代理、切换样式、元素获取相对于文档位置等&quot; href=&quot;https://www.cnblogs.com/jiebba/p/9663268.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/jiebba/p/9663268.html&lt;/a&gt; &lt;/p&gt;
&lt;h3&gt;   我的博客 ： &lt;a href=&quot;https://gilea.cn/index&quot; target=&quot;_blank&quot;&gt; XiaoLong's Blog&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;   &lt;a href=&quot;https://www.cnblogs.com/jiebba&quot; target=&quot;_blank&quot;&gt;博客园小结巴巴： https://www.cnblogs.com/jiebba&lt;/a&gt;&lt;/h3&gt;

</description>
<pubDate>Mon, 17 Sep 2018 16:19:00 +0000</pubDate>
<dc:creator>小结巴巴吧</dc:creator>
<og:description>1、介绍 随着组件开发大流行，现在三大框架已经基本占领了整个前端。 这时候，我们要是引入一个 jq 是不是先得你的项目非常臃肿，jq 也很不适合。 这个时候，你就需要来增加你 js 的功底。 2、各种</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiebba/p/9663268.html</dc:identifier>
</item>
<item>
<title>如何在MongoDB设计存储你的数据（JSON化）？ - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/9665695.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/9665695.html</guid>
<description>&lt;h2&gt;第一步 定义要描述的数据集&lt;/h2&gt;
&lt;p&gt;当我们决定将数据存储下来的时候，我们首先要回答的一个问题就是：“我打算存储什么样的数据？这些数据之间有什么关系？实体之间有什么关系？实体的属性之间有什么关系”。&lt;/p&gt;
&lt;p&gt;为了说明问题，我们这儿举例的场景是要描述 库存清单的数据库，库存清单数据 包括 物料名称、数量、规格大小、状态、标签说明、等级。&lt;/p&gt;
&lt;p&gt;如下list是我们希望关于库存清单的部分格式数据&lt;/p&gt;
&lt;table class=&quot;colwidths-auto guide-tablenate docutils&quot; border=&quot;1&quot;&gt;&lt;thead valign=&quot;bottom&quot;&gt;&lt;tr class=&quot;row-odd&quot;&gt;&lt;th class=&quot;head&quot;&gt;name&lt;/th&gt;
&lt;th class=&quot;head&quot;&gt;quantity&lt;/th&gt;
&lt;th class=&quot;head&quot;&gt;size&lt;/th&gt;
&lt;th class=&quot;head&quot;&gt;status&lt;/th&gt;
&lt;th class=&quot;head&quot;&gt;tags&lt;/th&gt;
&lt;th class=&quot;head&quot;&gt;rating&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody valign=&quot;top&quot;&gt;&lt;tr class=&quot;row-even&quot;&gt;&lt;td&gt;journal&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;14x21,cm&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;brown, lined&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-odd&quot;&gt;&lt;td&gt;notebook&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;8.5x11,in&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;college-ruled,perforated&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-even&quot;&gt;&lt;td&gt;paper&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;8.5x11,in&lt;/td&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;watercolor&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-odd&quot;&gt;&lt;td&gt;planner&lt;/td&gt;
&lt;td&gt;75&lt;/td&gt;
&lt;td&gt;22.85x30,cm&lt;/td&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;2019&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;row-even&quot;&gt;&lt;td&gt;postcard&lt;/td&gt;
&lt;td&gt;45&lt;/td&gt;
&lt;td&gt;10x,cm&lt;/td&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;double-sided,white&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;





&lt;p&gt;（备注： cm 为长度单位，厘米；in 也是长度单位：1in=25.4mm==2.54cm）&lt;/p&gt;
&lt;h2&gt;第二步 JSON 化 思维&lt;/h2&gt;
&lt;p&gt;上面表中的size 和 tags 栏位 都存储了多个值，例如Size 既有大小 的数字描述还有它们单位的描述，tags 这种标签的说明更是难以统一，可能此物料只有一个属性说明，而其他物料可能有多个属性的说明。这种字段如果在关系型数据库中存储，假设存储在一个字段中，那么查询起来比较费时，模式化也比较困难。如果拆开放到不同的表中，完整性就不是很好，表的设计也是难以清晰，表Join查询也会有性能下降。&lt;/p&gt;
&lt;p&gt;在MongoDB 数据中，数据都是以文档的形式存储的。这些文档都是以JSON(JavaScript Object Notation)格式设计存在的【物理盘上实际是以BSON格式存储的】。JSON文档支持内嵌字段。因此，我们可以将关联性强的数据或同一个List中的数据存储在同一个文档中，此时，不再需要存储在SQL数据库中多个表中【如果在SQL数据库，需要多个表，来描述关联】。&lt;/p&gt;
&lt;p&gt;JSON 格式就是将数据存为 键/值对 。在JOSN文档中，键和值 之间用 冒号（:）隔开；一个个键/值之间用逗号（,）隔开，同一个文档中的一组键/值包含在一个花括号（{}）中。&lt;/p&gt;
&lt;p&gt;例如，下面List中的 &lt;code class=&quot;docutils literal&quot;&gt;name&lt;/code&gt; 和 &lt;code class=&quot;docutils literal&quot;&gt;quantity&lt;/code&gt; 字段数据 JSON化，&lt;/p&gt;
&lt;table class=&quot;colwidths-auto guide-tablenate-odd docutils&quot; border=&quot;1&quot;&gt;&lt;thead valign=&quot;bottom&quot;&gt;&lt;tr class=&quot;row-odd&quot;&gt;&lt;th class=&quot;head&quot;&gt;name&lt;/th&gt;
&lt;th class=&quot;head&quot;&gt;quantity&lt;/th&gt;
&lt;th class=&quot;head&quot;&gt;size&lt;/th&gt;
&lt;th class=&quot;head&quot;&gt;status&lt;/th&gt;
&lt;th class=&quot;head&quot;&gt;tags&lt;/th&gt;
&lt;th class=&quot;head&quot;&gt;rating&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody valign=&quot;top&quot;&gt;&lt;tr class=&quot;row-even&quot;&gt;&lt;td&gt;notebook&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;8.5x11,in&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;college-ruled,perforated&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;p&gt;将这两个栏位JOSN化，就是下面这个形式：&lt;/p&gt;
&lt;pre&gt;
&lt;em&gt;&lt;span class=&quot;p&quot;&gt;{&lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;notebook&quot;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;qty&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;mi&quot;&gt;50&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;h2&gt; 第三步 针对多值字段，选择合适的数据模型&lt;/h2&gt;
&lt;p&gt;针对多值的字段，我们可以从内嵌模型、数组 List 模型两种数据模型中选择一种。&lt;/p&gt;
&lt;p&gt;例如上面 库存清单数据的那个例子，我们可以将Size，设计成内嵌模型，这个Size 可以有三个属性：高、宽、计量单位。&lt;/p&gt;
&lt;pre&gt;
&lt;em&gt;&lt;span class=&quot;p&quot;&gt;{ &lt;span class=&quot;s2&quot;&gt;&quot;h&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;mi&quot;&gt;11&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;w&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;mf&quot;&gt;8.5&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;uom&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;in&quot; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;p&gt; 一些商品原料，可能又多个等级得分，我们可以将这些等级得分存储在一个数组list中，例如上面例子中的ratings栏位。&lt;/p&gt;
&lt;pre&gt;
&lt;em&gt;&lt;span class=&quot;p&quot;&gt;[ &lt;span class=&quot;p&quot;&gt;{ &lt;span class=&quot;s2&quot;&gt;&quot;score&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;mi&quot;&gt;8 &lt;span class=&quot;p&quot;&gt;}, &lt;span class=&quot;p&quot;&gt;{ &lt;span class=&quot;s2&quot;&gt;&quot;score&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;mi&quot;&gt;9 &lt;span class=&quot;p&quot;&gt;} &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;p&gt;上面例子中的tags 也可以存放在数组list中&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;p&quot;&gt;&lt;em&gt;[ &lt;/em&gt;&lt;span class=&quot;s2&quot;&gt;&lt;em&gt;&quot;college-ruled&quot;&lt;/em&gt;&lt;span class=&quot;p&quot;&gt;&lt;em&gt;, &lt;/em&gt;&lt;span class=&quot;s2&quot;&gt;&lt;em&gt;&quot;perforated&quot; &lt;/em&gt;&lt;span class=&quot;p&quot;&gt;&lt;em&gt;]&lt;br/&gt;&lt;/em&gt;&lt;br/&gt;那么其中的关于notebook的记录数据 如下&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;table class=&quot;colwidths-auto guide-tablenate docutils&quot; border=&quot;1&quot;&gt;&lt;tbody valign=&quot;top&quot;&gt;&lt;tr class=&quot;row-odd&quot;&gt;&lt;td&gt;notebook&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;8.5x11,in&lt;/td&gt;
&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;college-ruled,perforated&lt;/td&gt;
&lt;td&gt;8，9&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre readability=&quot;10&quot;&gt;
&lt;span class=&quot;p&quot; readability=&quot;14&quot;&gt;&lt;p&gt;而将其 JOSN 化后，要存的文档样式如下：&lt;/p&gt;&lt;p&gt;&lt;em&gt;{
 &lt;span class=&quot;s2&quot;&gt;&quot;name&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;notebook&quot;&lt;span class=&quot;p&quot;&gt;,
 &lt;span class=&quot;s2&quot;&gt;&quot;qty&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;mi&quot;&gt;50&lt;span class=&quot;p&quot;&gt;,
 &lt;span class=&quot;s2&quot;&gt;&quot;rating&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;p&quot;&gt;[ &lt;span class=&quot;p&quot;&gt;{ &lt;span class=&quot;s2&quot;&gt;&quot;score&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;mi&quot;&gt;8 &lt;span class=&quot;p&quot;&gt;}, &lt;span class=&quot;p&quot;&gt;{ &lt;span class=&quot;s2&quot;&gt;&quot;score&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;mi&quot;&gt;9 &lt;span class=&quot;p&quot;&gt;} &lt;span class=&quot;p&quot;&gt;],
 &lt;span class=&quot;s2&quot;&gt;&quot;size&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;p&quot;&gt;{ &lt;span class=&quot;s2&quot;&gt;&quot;height&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;mi&quot;&gt;11&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;width&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;mf&quot;&gt;8.5&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;unit&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;in&quot; &lt;span class=&quot;p&quot;&gt;},
 &lt;span class=&quot;s2&quot;&gt;&quot;status&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;A&quot;&lt;span class=&quot;p&quot;&gt;,
 &lt;span class=&quot;s2&quot;&gt;&quot;tags&quot;&lt;span class=&quot;o&quot;&gt;: &lt;span class=&quot;p&quot;&gt;[ &lt;span class=&quot;s2&quot;&gt;&quot;college-ruled&quot;&lt;span class=&quot;p&quot;&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;perforated&quot;&lt;span class=&quot;p&quot;&gt;]
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;s2&quot;&gt;&lt;span class=&quot;p&quot;&gt;&lt;span class=&quot;s2&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;p&quot; readability=&quot;4&quot;&gt;&lt;br/&gt;以上过程就是数据记录的JSON过程、文档化过程。&lt;p&gt;注： 以上内容作者翻译自 MongoDB 官网，网址为 https://docs.mongodb.com/guides/server/introduction。&lt;br/&gt;因作者非专业翻译人员，难免有错误或不准确的地方，请见谅。 &lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 17 Sep 2018 16:10:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>第一步 定义要描述的数据集 当我们决定将数据存储下来的时候，我们首先要回答的一个问题就是：“我打算存储什么样的数据？这些数据之间有什么关系？实体之间有什么关系？实体的属性之间有什么关系”。 为了说明问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/9665695.html</dc:identifier>
</item>
<item>
<title>DirectX11 With Windows SDK--13 动手实现一个简易Effects框架、阴影效果绘制 - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/9665452.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/9665452.html</guid>
<description>&lt;p&gt;到现在为止，所有的教程项目都没有使用Effects11框架类来管理资源。因为在D3DCompile API (#47)版本中，如果你尝试编译fx_5_0的效果文件，会收到这样的警告：&lt;br/&gt;&lt;code&gt;X4717: Effects deprecated for D3DCompiler_47&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在未来的版本中，D3DCompiler可能会停止对FX11的支持，所以我们需要自行去管理各种特效，并改用HLSL编译器去编译每一个着色器。同时，在阅读本章之前，你需要先学习本系列前面的一些重点章节再继续：&lt;/p&gt;
&lt;p&gt;在DirectXTK中的&lt;code&gt;Effects.h&lt;/code&gt;可以看到它实现了一系列Effects管理类，相比&lt;code&gt;Effects11&lt;/code&gt;框架库，它缺少了反射机制，并且使用的是它内部已经写好、编译好的着色器。DirectXTK的Effects也只不过是为了简化游戏开发流程而设计出来的。当然，里面的一部分源码实现也值得我们去学习。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意：这章经历了一次十分大的改动，原先所使用的BasicFX类因为在后续的章节中发现很难扩展，所以进行了一次大幅度重构。并会逐渐替换掉后面教程的项目源码所使用的BasicFX。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这一章的学习过后，你将会理解&lt;code&gt;Effects11&lt;/code&gt;的一部分运作机制是怎样的。而关于它的反射机制、着色器编译部分不会进行探讨。&lt;/p&gt;
&lt;p&gt;这篇教程还会提到用深度/模板状态去实现简单的阴影效果，但不会深入数学公式原理。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;目前的&lt;code&gt;RenderStates&lt;/code&gt;类存放有比较常用的各种状态，原来在&lt;code&gt;Effects11&lt;/code&gt;框架下是可以在fx文件初始化各种渲染状态，并设置到&lt;code&gt;Technique11&lt;/code&gt;中。但现在我们只能在C++代码层中一次性创建好各种所需的渲染状态：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class RenderStates
{
public:
    template &amp;lt;class T&amp;gt;
    using ComPtr = Microsoft::WRL::ComPtr&amp;lt;T&amp;gt;;

    static bool IsInit();

    static void InitAll(ComPtr&amp;lt;ID3D11Device&amp;gt; device);
    // 使用ComPtr无需手工释放

public:
    static ComPtr&amp;lt;ID3D11RasterizerState&amp;gt; RSWireframe;       // 光栅化器状态：线框模式
    static ComPtr&amp;lt;ID3D11RasterizerState&amp;gt; RSNoCull;          // 光栅化器状态：无背面裁剪模式
    static ComPtr&amp;lt;ID3D11RasterizerState&amp;gt; RSCullClockWise;   // 光栅化器状态：顺时针裁剪模式

    static ComPtr&amp;lt;ID3D11SamplerState&amp;gt; SSLinearWrap;         // 采样器状态：线性过滤
    static ComPtr&amp;lt;ID3D11SamplerState&amp;gt; SSAnistropicWrap;     // 采样器状态：各项异性过滤

    static ComPtr&amp;lt;ID3D11BlendState&amp;gt; BSNoColorWrite;     // 混合状态：不写入颜色
    static ComPtr&amp;lt;ID3D11BlendState&amp;gt; BSTransparent;      // 混合状态：透明混合
    static ComPtr&amp;lt;ID3D11BlendState&amp;gt; BSAlphaToCoverage;  // 混合状态：Alpha-To-Coverage

    static ComPtr&amp;lt;ID3D11DepthStencilState&amp;gt; DSSWriteStencil;     // 深度/模板状态：写入模板值
    static ComPtr&amp;lt;ID3D11DepthStencilState&amp;gt; DSSDrawWithStencil;  // 深度/模板状态：对指定模板值的区域进行绘制
    static ComPtr&amp;lt;ID3D11DepthStencilState&amp;gt; DSSNoDoubleBlend;    // 深度/模板状态：无二次混合区域
    static ComPtr&amp;lt;ID3D11DepthStencilState&amp;gt; DSSNoDepthTest;      // 深度/模板状态：关闭深度测试
    static ComPtr&amp;lt;ID3D11DepthStencilState&amp;gt; DSSNoDepthWrite;     // 深度/模板状态：仅深度测试，不写入深度值
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的设置可以参照源码或者上一章内容。&lt;/p&gt;

&lt;p&gt;该Effects框架支持的功能如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;管理/修改常量缓冲区的内容，并进行应用(Apply)&lt;/li&gt;
&lt;li&gt;编译HLSL着色器而不是fx文件&lt;/li&gt;
&lt;li&gt;管理/使用四种渲染状态&lt;/li&gt;
&lt;li&gt;切换渲染模式(涉及到渲染管线各种资源的绑定、切换)&lt;/li&gt;
&lt;li&gt;仅更新修改的变量所对应的常量缓冲区块&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不过它也有这样的缺陷：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个特效类对应一套着色器和所使用的常量缓冲区，所属着色器代码的变动很可能会引起对框架类的修改，因为缺乏反射机制而导致灵活性差。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;文件结构&quot;&gt;文件结构&lt;/h2&gt;
&lt;p&gt;首先是文件结构：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201809/1172605-20180917170305383-402439896.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中能够暴露给程序使用的只有头文件&lt;code&gt;Effects.h&lt;/code&gt;，里面可以存放多套不同的特效框架类的声明，而关于每个框架类的实现部分都应当用一个独立的源文件存放。而&lt;code&gt;EffectHelper.h&lt;/code&gt;则是用来帮助管理常量缓冲区的，服务于各种框架类的实现部分以及所属的源文件，因此不应该直接使用。&lt;/p&gt;
&lt;p&gt;理论上它也是可以做成静态库使用的，然后着色器代码稳定后也不应当变动。在使用的时候只需要包含头文件&lt;code&gt;Effects.h&lt;/code&gt;即可。&lt;/p&gt;

&lt;p&gt;该头文件包含了一些有用的东西，但它需要在包含特效类实现的源文件中使用，且必须晚于Effects.h包含。&lt;/p&gt;
&lt;h2 id=&quot;在堆上进行类的内存对齐&quot;&gt;在堆上进行类的内存对齐&lt;/h2&gt;
&lt;p&gt;有些类型需要在堆上按16字节对齐，比如&lt;code&gt;XMVECTOR&lt;/code&gt;和&lt;code&gt;XMMATRIX&lt;/code&gt;，虽然说拿这些对象作为类的成员不太合适，毕竟分配在堆上的话基本上无法保证内存按16字节对齐了，但还是希望能够做到。在VS的&lt;code&gt;corecrt_malloc.h&lt;/code&gt;(只要有包含&lt;code&gt;stdlib.h&lt;/code&gt;, &lt;code&gt;malloc.h&lt;/code&gt;之一的头文件都可以)中有这样的一个函数：&lt;code&gt;_aligned_malloc&lt;/code&gt;，它可以指定需要分配的内存字节大小以及按多少字节对齐。其中对齐值必须为2的整数次幂的字节数。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void * _aligned_malloc(  
    size_t size,        // [In]分配内存字节数
    size_t alignment    // [In]按多少字节内存来对齐
);  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若一个类中包含有已经指定内存对齐的成员，则需要优先把这些成员放到最前。&lt;/p&gt;
&lt;p&gt;然后与之对应的就是&lt;code&gt;_aligned_free&lt;/code&gt;函数了，它可以释放之前由&lt;code&gt;_aligned_malloc&lt;/code&gt;分配得到的内存。&lt;/p&gt;
&lt;p&gt;下面是类模板&lt;code&gt;AlignedType&lt;/code&gt;的实现，让需要内存对齐的类去继承该类即可。它重载了&lt;code&gt;operator new&lt;/code&gt;和&lt;code&gt;operator delete&lt;/code&gt;的实现：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 若类需要内存对齐，从该类派生
template&amp;lt;class DerivedType&amp;gt;
struct AlignedType
{
    static void* operator new(size_t size)
    {
        const size_t alignedSize = __alignof(DerivedType);

        static_assert(alignedSize &amp;gt; 8, &quot;AlignedNew is only useful for types with &amp;gt; 8 byte alignment! Did you forget a __declspec(align) on DerivedType?&quot;);

        void* ptr = _aligned_malloc(size, alignedSize);

        if (!ptr)
            throw std::bad_alloc();

        return ptr;
    }

    static void operator delete(void * ptr)
    {
        _aligned_free(ptr);
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，继承&lt;code&gt;AlignedType&lt;/code&gt;的类或者其成员必须本身有&lt;code&gt;__declspec(align)&lt;/code&gt;的标识。若是内部成员，在所有包含该标识的值中最大的&lt;code&gt;align&lt;/code&gt;值 必须是2的整数次幂且必须大于8。&lt;/p&gt;
&lt;p&gt;下面演示了正确的和错误的行为：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 错误！VertexPosColor按4字节对齐！
struct VertexPosColor : AlignedType&amp;lt;VertexPos&amp;gt;
{
    XMFLOAT3 pos;
    XMFLOAT4 color;
};

// 正确！Data按16字节对齐，因为pos本身是按16字节对齐的。
struct Data : AlignedType&amp;lt;VertexPos&amp;gt;
{
    XMVECTOR pos;
    int val;
};

// 正确！Vector类按16字节对齐
__declspec(align(16))
struct Vector : AlignedType&amp;lt;Vector&amp;gt;
{
    float x;
    float y;
    float z;
    float w;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里&lt;code&gt;AlignedType&amp;lt;T&amp;gt;&lt;/code&gt;主要是用于&lt;code&gt;BasicObjectFX::Impl&lt;/code&gt;类，因为其内部包含了&lt;code&gt;XMVECTOR&lt;/code&gt;和&lt;code&gt;XMMATRIX&lt;/code&gt;类型的成员，且该类需要分配在堆上。&lt;/p&gt;
&lt;h2 id=&quot;常量缓冲区管理&quot;&gt;常量缓冲区管理&lt;/h2&gt;
&lt;p&gt;一个常量缓冲区可能会被创建、更新或者绑定到管线。若常量缓冲区的值没有发生变化，我们不希望它进行无意义的更新。我们可以使用一个&lt;code&gt;dirty&lt;/code&gt;标记，确认它是否被修改过。常量缓冲区的任一内部成员发生修改的话，我们就将数据更新到常量缓冲区并恢复该标记。&lt;/p&gt;
&lt;p&gt;首先是抽象基类&lt;code&gt;CBufferBase&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct CBufferBase
{
    template&amp;lt;class T&amp;gt;
    using ComPtr = Microsoft::WRL::ComPtr&amp;lt;T&amp;gt;;

    bool isDirty;
    ComPtr&amp;lt;ID3D11Buffer&amp;gt; cBuffer;

    virtual void CreateBuffer(ComPtr&amp;lt;ID3D11Device&amp;gt; device) = 0;
    virtual void UpdateBuffer(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext) = 0;
    virtual void BindVS(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext) = 0;
    virtual void BindHS(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext) = 0;
    virtual void BindDS(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext) = 0;
    virtual void BindGS(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext) = 0;
    virtual void BindCS(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext) = 0;
    virtual void BindPS(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext) = 0;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这么做是为了方便我们放入数组进行遍历。&lt;/p&gt;
&lt;p&gt;然后是派生类&lt;code&gt;CBufferObject&lt;/code&gt;，&lt;code&gt;startSlot&lt;/code&gt;指定了HLSL对应cbuffer的索引，&lt;code&gt;T&lt;/code&gt;则是C++对应的结构体，存储临时数据：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template&amp;lt;UINT startSlot, class T&amp;gt;
struct CBufferObject : CBufferBase
{
    T data;

    void CreateBuffer(ComPtr&amp;lt;ID3D11Device&amp;gt; device) override
    {
        if (cBuffer != nullptr)
            return;
        D3D11_BUFFER_DESC cbd;
        ZeroMemory(&amp;amp;cbd, sizeof(cbd));
        cbd.Usage = D3D11_USAGE_DEFAULT;
        cbd.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
        cbd.CPUAccessFlags = 0;
        cbd.ByteWidth = sizeof(T);
        HR(device-&amp;gt;CreateBuffer(&amp;amp;cbd, nullptr, cBuffer.GetAddressOf()));
    }

    void UpdateBuffer(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext) override
    {
        if (isDirty)
        {
            isDirty = false;
            deviceContext-&amp;gt;UpdateSubresource(cBuffer.Get(), 0, nullptr, &amp;amp;data, 0, 0);
        }
    }

    void BindVS(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext) override
    {
        deviceContext-&amp;gt;VSSetConstantBuffers(startSlot, 1, cBuffer.GetAddressOf());
    }

    void BindHS(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext) override
    {
        deviceContext-&amp;gt;HSSetConstantBuffers(startSlot, 1, cBuffer.GetAddressOf());
    }

    void BindDS(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext) override
    {
        deviceContext-&amp;gt;DSSetConstantBuffers(startSlot, 1, cBuffer.GetAddressOf());
    }

    void BindGS(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext) override
    {
        deviceContext-&amp;gt;GSSetConstantBuffers(startSlot, 1, cBuffer.GetAddressOf());
    }

    void BindCS(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext) override
    {
        deviceContext-&amp;gt;CSSetConstantBuffers(startSlot, 1, cBuffer.GetAddressOf());
    }

    void BindPS(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext) override
    {
        deviceContext-&amp;gt;PSSetConstantBuffers(startSlot, 1, cBuffer.GetAddressOf());
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于常量缓冲区临时变量的修改则在后续的内容。&lt;/p&gt;

&lt;p&gt;首先是抽象基类&lt;code&gt;IEffects&lt;/code&gt;，它仅允许被移动，并且仅包含&lt;code&gt;Apply&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class IEffect
{
public:
    // 使用模板别名(C++11)简化类型名
    template &amp;lt;class T&amp;gt;
    using ComPtr = Microsoft::WRL::ComPtr&amp;lt;T&amp;gt;;

    IEffect() = default;

    // 不支持复制构造
    IEffect(const IEffect&amp;amp;) = delete;
    IEffect&amp;amp; operator=(const IEffect&amp;amp;) = delete;

    // 允许转移
    IEffect(IEffect&amp;amp;&amp;amp; moveFrom) = default;
    IEffect&amp;amp; operator=(IEffect&amp;amp;&amp;amp; moveFrom) = default;

    virtual ~IEffect() = default;

    // 更新并绑定常量缓冲区
    virtual void Apply(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext) = 0;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原来的&lt;code&gt;ID3DX11EffectPass&lt;/code&gt;包含的方法&lt;code&gt;Apply&lt;/code&gt;用于在各个着色器阶段绑定所需要的常量缓冲区、纹理等资源，并更新之前有所修改的常量缓冲区。现在我们实现Effects框架中的&lt;code&gt;Apply&lt;/code&gt;方法也是这么做的。&lt;/p&gt;
&lt;p&gt;然后是派生类&lt;code&gt;BasicObjectFX&lt;/code&gt;，从它的方法来看，包含了单例获取、渲染状态的切换、修改常量缓冲区某一成员的值、应用变更四个大块：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class BasicObjectFX : public IEffect
{
public:
    // 使用模板别名(C++11)简化类型名
    template &amp;lt;class T&amp;gt;
    using ComPtr = Microsoft::WRL::ComPtr&amp;lt;T&amp;gt;;

    BasicObjectFX();
    virtual ~BasicObjectFX() override;

    BasicObjectFX(BasicObjectFX&amp;amp;&amp;amp; moveFrom);
    BasicObjectFX&amp;amp; operator=(BasicObjectFX&amp;amp;&amp;amp; moveFrom);

    // 获取单例
    static BasicObjectFX&amp;amp; Get();

    

    // 初始化Basix.fx所需资源并初始化渲染状态
    bool InitAll(ComPtr&amp;lt;ID3D11Device&amp;gt; device);


    //
    // 渲染模式的变更
    //

    // 默认状态来绘制
    void SetRenderDefault(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext);
    // Alpha混合绘制
    void SetRenderAlphaBlend(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext);
    // 无二次混合
    void SetRenderNoDoubleBlend(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext, UINT stencilRef);
    // 仅写入模板值
    void SetWriteStencilOnly(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext, UINT stencilRef);
    // 对指定模板值的区域进行绘制，采用默认状态
    void SetRenderDefaultWithStencil(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext, UINT stencilRef);
    // 对指定模板值的区域进行绘制，采用Alpha混合
    void SetRenderAlphaBlendWithStencil(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext, UINT stencilRef);
    // 2D默认状态绘制
    void Set2DRenderDefault(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext);
    // 2D混合绘制
    void Set2DRenderAlphaBlend(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext);

    

    //
    // 矩阵设置
    //

    void XM_CALLCONV SetWorldMatrix(DirectX::FXMMATRIX W);
    void XM_CALLCONV SetViewMatrix(DirectX::FXMMATRIX V);
    void XM_CALLCONV SetProjMatrix(DirectX::FXMMATRIX P);
    void XM_CALLCONV SetWorldViewProjMatrix(DirectX::FXMMATRIX W, DirectX::CXMMATRIX V, DirectX::CXMMATRIX P);

    void XM_CALLCONV SetTexTransformMatrix(DirectX::FXMMATRIX W);

    void XM_CALLCONV SetReflectionMatrix(DirectX::FXMMATRIX R);
    void XM_CALLCONV SetShadowMatrix(DirectX::FXMMATRIX S);
    void XM_CALLCONV SetRefShadowMatrix(DirectX::FXMMATRIX RefS);
    
    //
    // 光照、材质和纹理相关设置
    //

    // 各种类型灯光允许的最大数目
    static const int maxLights = 5;

    void SetDirLight(size_t pos, const DirectionalLight&amp;amp; dirLight);
    void SetPointLight(size_t pos, const PointLight&amp;amp; pointLight);
    void SetSpotLight(size_t pos, const SpotLight&amp;amp; spotLight);

    void SetMaterial(const Material&amp;amp; material);

    void SetTexture(ComPtr&amp;lt;ID3D11ShaderResourceView&amp;gt; texture);

    void XM_CALLCONV SetEyePos(DirectX::FXMVECTOR eyePos);



    //
    // 状态开关设置
    //

    void SetReflectionState(bool isOn);
    void SetShadowState(bool isOn);
    

    // 应用常量缓冲区和纹理资源的变更
    void Apply(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext);
    
private:
    class Impl;
    std::unique_ptr&amp;lt;Impl&amp;gt; pImpl;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;XM_CALLCONV&lt;/code&gt;即在第六章之前提到的&lt;code&gt;__vectorcall&lt;/code&gt;或&lt;code&gt;__fastcall&lt;/code&gt;约定。&lt;/p&gt;
&lt;p&gt;然后来到&lt;code&gt;BasicObjectFX.cpp&lt;/code&gt;，首先包含了对应HLSL五个&lt;code&gt;cbuffer&lt;/code&gt;的C++结构体：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &quot;Effects.h&quot;
#include &quot;EffectHelper.h&quot;
#include &quot;Vertex.h&quot;
#include &amp;lt;d3dcompiler.h&amp;gt;
#include &amp;lt;experimental/filesystem&amp;gt;
using namespace DirectX;
using namespace std::experimental;

//
// 这些结构体对应HLSL的结构体，仅供该文件使用。需要按16字节对齐
//

struct CBChangesEveryDrawing
{
    DirectX::XMMATRIX world;
    DirectX::XMMATRIX worldInvTranspose;
    DirectX::XMMATRIX texTransform;
    Material material;
};

struct CBDrawingStates
{
    int isReflection;
    int isShadow;
    DirectX::XMINT2 pad;
};

struct CBChangesEveryFrame
{
    DirectX::XMMATRIX view;
    DirectX::XMVECTOR eyePos;
};

struct CBChangesOnResize
{
    DirectX::XMMATRIX proj;
};


struct CBChangesRarely
{
    DirectX::XMMATRIX reflection;
    DirectX::XMMATRIX shadow;
    DirectX::XMMATRIX refShadow;
    DirectionalLight dirLight[BasicObjectFX::maxLights];
    PointLight pointLight[BasicObjectFX::maxLights];
    SpotLight spotLight[BasicObjectFX::maxLights];
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;EffectHelper.h&lt;/code&gt;需要放在&lt;code&gt;Effects.h&lt;/code&gt;之后。&lt;/p&gt;
&lt;p&gt;这5个结构体都放在源文件是因为这些结构体仅限于在该文件种使用。&lt;/p&gt;
&lt;h2 id=&quot;basicobjectfximpl类&quot;&gt;BasicObjectFX::Impl类&lt;/h2&gt;
&lt;p&gt;之前在&lt;code&gt;BasicObjectFX&lt;/code&gt;中声明了&lt;code&gt;Impl&lt;/code&gt;类，主要目的是为了将类的成员和方法定义都转移到源文件中。不仅可以减少&lt;code&gt;BasicObjectFX&lt;/code&gt;类的压力，还可以避免暴露上面的五个结构体。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BasicObjectFX::Impl&lt;/code&gt;类包含一切所需资源，以及一个编译着色器的方法：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//
// BasicObjectFX::Impl 需要先于BasicObjectFX的定义
//

class BasicObjectFX::Impl : public AlignedType&amp;lt;BasicObjectFX::Impl&amp;gt;
{
public:
    // 必须显式指定
    Impl() = default;
    ~Impl() = default;

    // objFileNameInOut为编译好的着色器二进制文件(.*so)，若有指定则优先寻找该文件并读取
    // hlslFileName为着色器代码，若未找到着色器二进制文件则编译着色器代码
    // 编译成功后，若指定了objFileNameInOut，则保存编译好的着色器二进制信息到该文件
    // ppBlobOut输出着色器二进制信息
    HRESULT CreateShaderFromFile(const WCHAR* objFileNameInOut, const WCHAR* hlslFileName, LPCSTR entryPoint, LPCSTR shaderModel, ID3DBlob** ppBlobOut);

public:
    // 需要16字节对齐的优先放在前面
    CBufferObject&amp;lt;0, CBChangesEveryDrawing&amp;gt; cbDrawing;      // 每次对象绘制的常量缓冲区
    CBufferObject&amp;lt;1, CBDrawingStates&amp;gt;       cbStates;       // 每次绘制状态变更的常量缓冲区
    CBufferObject&amp;lt;2, CBChangesEveryFrame&amp;gt;   cbFrame;        // 每帧绘制的常量缓冲区
    CBufferObject&amp;lt;3, CBChangesOnResize&amp;gt;     cbOnResize;     // 每次窗口大小变更的常量缓冲区
    CBufferObject&amp;lt;4, CBChangesRarely&amp;gt;       cbRarely;       // 几乎不会变更的常量缓冲区
    BOOL isDirty;                                           // 是否有值变更
    std::vector&amp;lt;CBufferBase*&amp;gt; cBufferPtrs;                  // 统一管理下面所有的常量缓冲区


    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; vertexShader3D;              // 用于3D的顶点着色器
    ComPtr&amp;lt;ID3D11PixelShader&amp;gt;  pixelShader3D;               // 用于3D的像素着色器
    ComPtr&amp;lt;ID3D11VertexShader&amp;gt; vertexShader2D;              // 用于2D的顶点着色器
    ComPtr&amp;lt;ID3D11PixelShader&amp;gt;  pixelShader2D;               // 用于2D的像素着色器

    ComPtr&amp;lt;ID3D11InputLayout&amp;gt;  vertexLayout2D;              // 用于2D的顶点输入布局
    ComPtr&amp;lt;ID3D11InputLayout&amp;gt;  vertexLayout3D;              // 用于3D的顶点输入布局

    ComPtr&amp;lt;ID3D11ShaderResourceView&amp;gt; texture;               // 用于绘制的纹理

};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;着色器的编译方法这里不再赘述。&lt;/p&gt;
&lt;h2 id=&quot;构造析构单例&quot;&gt;构造/析构/单例&lt;/h2&gt;
&lt;p&gt;这里用一个匿名空间保管单例对象的指针。当有一个实例被构造出来的时候就会给其赋值。后续就不允许再被实例化了，可以使用&lt;code&gt;Get&lt;/code&gt;方法获取该单例。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;namespace
{
    // BasicObjectFX单例
    static BasicObjectFX * pInstance = nullptr;
}

BasicObjectFX::BasicObjectFX()
{
    if (pInstance)
        throw std::exception(&quot;BasicObjectFX is a singleton!&quot;);
    pInstance = this;
    pImpl = std::make_unique&amp;lt;BasicObjectFX::Impl&amp;gt;();
}

BasicObjectFX::~BasicObjectFX()
{
}

BasicObjectFX::BasicObjectFX(BasicObjectFX &amp;amp;&amp;amp; moveFrom)
{
    pImpl.swap(moveFrom.pImpl);
}

BasicObjectFX &amp;amp; BasicObjectFX::operator=(BasicObjectFX &amp;amp;&amp;amp; moveFrom)
{
    pImpl.swap(moveFrom.pImpl);
    return *this;
}

BasicObjectFX &amp;amp; BasicObjectFX::Get()
{
    if (!pInstance)
        throw std::exception(&quot;BasicObjectFX needs an instance!&quot;);
    return *pInstance;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;basicobjectfxinitall方法&quot;&gt;BasicObjectFX::InitAll方法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;BasicObjectFX::InitAll&lt;/code&gt;方法负责创建出所有的着色器和常量缓冲区，以及所有的渲染状态：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;bool BasicObjectFX::InitAll(ComPtr&amp;lt;ID3D11Device&amp;gt; device)
{
    if (!device)
        return false;

    ComPtr&amp;lt;ID3DBlob&amp;gt; blob;

    // 创建顶点着色器(2D)
    HR(pImpl-&amp;gt;CreateShaderFromFile(L&quot;HLSL\\BasicObject_VS_2D.vso&quot;, L&quot;HLSL\\BasicObject_VS_2D.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.GetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, pImpl-&amp;gt;vertexShader2D.GetAddressOf()));
    // 创建顶点布局(2D)
    HR(device-&amp;gt;CreateInputLayout(VertexPosNormalTex::inputLayout, ARRAYSIZE(VertexPosNormalTex::inputLayout),
        blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), pImpl-&amp;gt;vertexLayout2D.GetAddressOf()));

    // 创建像素着色器(2D)
    HR(pImpl-&amp;gt;CreateShaderFromFile(L&quot;HLSL\\BasicObject_PS_2D.pso&quot;, L&quot;HLSL\\BasicObject_PS_2D.hlsl&quot;, &quot;PS&quot;, &quot;ps_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreatePixelShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, pImpl-&amp;gt;pixelShader2D.GetAddressOf()));

    // 创建顶点着色器(3D)
    HR(pImpl-&amp;gt;CreateShaderFromFile(L&quot;HLSL\\BasicObject_VS_3D.vso&quot;, L&quot;HLSL\\BasicObject_VS_3D.hlsl&quot;, &quot;VS&quot;, &quot;vs_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreateVertexShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, pImpl-&amp;gt;vertexShader3D.GetAddressOf()));
    // 创建顶点布局(3D)
    HR(device-&amp;gt;CreateInputLayout(VertexPosNormalTex::inputLayout, ARRAYSIZE(VertexPosNormalTex::inputLayout),
        blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), pImpl-&amp;gt;vertexLayout3D.GetAddressOf()));

    // 创建像素着色器(3D)
    HR(pImpl-&amp;gt;CreateShaderFromFile(L&quot;HLSL\\BasicObject_PS_3D.pso&quot;, L&quot;HLSL\\BasicObject_PS_3D.hlsl&quot;, &quot;PS&quot;, &quot;ps_5_0&quot;, blob.ReleaseAndGetAddressOf()));
    HR(device-&amp;gt;CreatePixelShader(blob-&amp;gt;GetBufferPointer(), blob-&amp;gt;GetBufferSize(), nullptr, pImpl-&amp;gt;pixelShader3D.GetAddressOf()));


    // 初始化
    RenderStates::InitAll(device);

    pImpl-&amp;gt;cBufferPtrs.assign({
        &amp;amp;pImpl-&amp;gt;cbDrawing, 
        &amp;amp;pImpl-&amp;gt;cbFrame, 
        &amp;amp;pImpl-&amp;gt;cbStates, 
        &amp;amp;pImpl-&amp;gt;cbOnResize, 
        &amp;amp;pImpl-&amp;gt;cbRarely});

    // 创建常量缓冲区
    for (auto&amp;amp; pBuffer : pImpl-&amp;gt;cBufferPtrs)
    {
        pBuffer-&amp;gt;CreateBuffer(device);
    }

    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;各种渲染状态的切换&quot;&gt;各种渲染状态的切换&lt;/h2&gt;
&lt;p&gt;下面所有的渲染模式使用的是线性Wrap采样器。&lt;/p&gt;
&lt;h3 id=&quot;basicfxsetrenderdefault方法--默认渲染&quot;&gt;BasicFX::SetRenderDefault方法--默认渲染&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;BasicObjectFX::SetRenderDefault&lt;/code&gt;方法使用了默认的3D像素着色器和顶点着色器，并且其余各状态都保留使用默认状态：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicObjectFX::SetRenderDefault()
{
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexLayout3D.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mVertexShader3D.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    md3dImmediateContext-&amp;gt;PSSetShader(mPixelShader3D.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;PSSetSamplers(0, 1, RenderStates::SSLinearWrap.GetAddressOf());
    md3dImmediateContext-&amp;gt;OMSetDepthStencilState(nullptr, 0);
    md3dImmediateContext-&amp;gt;OMSetBlendState(nullptr, nullptr, 0xFFFFFFFF);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicobjectfxsetrenderalphablend方法--alpha透明混合渲染&quot;&gt;BasicObjectFX::SetRenderAlphaBlend方法--Alpha透明混合渲染&lt;/h3&gt;
&lt;p&gt;该绘制模式关闭了光栅化裁剪，并采用透明混合方式。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicObjectFX::SetRenderAlphaBlend()
{
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexLayout3D.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mVertexShader3D.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;RSSetState(RenderStates::RSNoCull.Get());
    md3dImmediateContext-&amp;gt;PSSetShader(mPixelShader3D.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;PSSetSamplers(0, 1, RenderStates::SSLinearWrap.GetAddressOf());
    md3dImmediateContext-&amp;gt;OMSetDepthStencilState(nullptr, 0);
    md3dImmediateContext-&amp;gt;OMSetBlendState(RenderStates::BSTransparent.Get(), nullptr, 0xFFFFFFFF);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicobjectfxsetrendernodoubleblend方法--无重复混合单次混合&quot;&gt;BasicObjectFX::SetRenderNoDoubleBlend方法--无重复混合(单次混合)&lt;/h3&gt;
&lt;p&gt;该绘制模式用于绘制阴影，防止过度混合。需要指定绘制区域的模板值。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicObjectFX::SetRenderNoDoubleBlend(UINT stencilRef)
{
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexLayout3D.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mVertexShader3D.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;RSSetState(RenderStates::RSNoCull.Get());
    md3dImmediateContext-&amp;gt;PSSetShader(mPixelShader3D.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;PSSetSamplers(0, 1, RenderStates::SSLinearWrap.GetAddressOf());
    md3dImmediateContext-&amp;gt;OMSetDepthStencilState(RenderStates::DSSNoDoubleBlend.Get(), stencilRef);
    md3dImmediateContext-&amp;gt;OMSetBlendState(RenderStates::BSTransparent.Get(), nullptr, 0xFFFFFFFF);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicobjectfxsetwritestencilonly方法--仅写入模板值&quot;&gt;BasicObjectFX::SetWriteStencilOnly方法--仅写入模板值&lt;/h3&gt;
&lt;p&gt;该模式用于向模板缓冲区写入用户指定的模板值，并且不写入到深度缓冲区和后备缓冲区。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicObjectFX::SetWriteStencilOnly(UINT stencilRef)
{
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexLayout3D.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mVertexShader3D.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    md3dImmediateContext-&amp;gt;PSSetShader(mPixelShader3D.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;PSSetSamplers(0, 1, RenderStates::SSLinearWrap.GetAddressOf());
    md3dImmediateContext-&amp;gt;OMSetDepthStencilState(RenderStates::DSSWriteStencil.Get(), stencilRef);
    md3dImmediateContext-&amp;gt;OMSetBlendState(RenderStates::BSNoColorWrite.Get(), nullptr, 0xFFFFFFFF);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicobjectfxsetrenderdefaultwithstencil方法--对指定模板值区域进行常规绘制&quot;&gt;BasicObjectFX::SetRenderDefaultWithStencil方法--对指定模板值区域进行常规绘制&lt;/h3&gt;
&lt;p&gt;该模式下，仅对模板缓冲区的模板值和用户指定的相等的区域进行常规绘制。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicObjectFX::SetRenderDefaultWithStencil(UINT stencilRef)
{
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexLayout3D.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mVertexShader3D.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;RSSetState(RenderStates::RSCullClockWise.Get());
    md3dImmediateContext-&amp;gt;PSSetShader(mPixelShader3D.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;PSSetSamplers(0, 1, RenderStates::SSLinearWrap.GetAddressOf());
    md3dImmediateContext-&amp;gt;OMSetDepthStencilState(RenderStates::DSSDrawWithStencil.Get(), stencilRef);
    md3dImmediateContext-&amp;gt;OMSetBlendState(nullptr, nullptr, 0xFFFFFFFF);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicobjectfxsetrenderalphablendwithstencil方法--对指定模板值区域进行alpha透明混合绘制&quot;&gt;BasicObjectFX::SetRenderAlphaBlendWithStencil方法--对指定模板值区域进行Alpha透明混合绘制&lt;/h3&gt;
&lt;p&gt;该模式下，仅对模板缓冲区的模板值和用户指定的相等的区域进行Alpha透明混合绘制。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicObjectFX::SetRenderAlphaBlendWithStencil(UINT stencilRef)
{
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexLayout3D.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mVertexShader3D.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;RSSetState(RenderStates::RSNoCull.Get());
    md3dImmediateContext-&amp;gt;PSSetShader(mPixelShader3D.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;PSSetSamplers(0, 1, RenderStates::SSLinearWrap.GetAddressOf());
    md3dImmediateContext-&amp;gt;OMSetDepthStencilState(RenderStates::DSSDrawWithStencil.Get(), stencilRef);
    md3dImmediateContext-&amp;gt;OMSetBlendState(RenderStates::BSTransparent.Get(), nullptr, 0xFFFFFFFF);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicobjectfxset2drenderdefault方法--2d默认绘制&quot;&gt;BasicObjectFX::Set2DRenderDefault方法--2D默认绘制&lt;/h3&gt;
&lt;p&gt;该模式使用的是2D顶点着色器和像素着色器，并修改为2D输入布局。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicObjectFX::Set2DRenderDefault()
{
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexLayout2D.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mVertexShader2D.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;RSSetState(nullptr);
    md3dImmediateContext-&amp;gt;PSSetShader(mPixelShader2D.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;PSSetSamplers(0, 1, RenderStates::SSLinearWrap.GetAddressOf());
    md3dImmediateContext-&amp;gt;OMSetDepthStencilState(nullptr, 0);
    md3dImmediateContext-&amp;gt;OMSetBlendState(nullptr, nullptr, 0xFFFFFFFF);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;basicobjectfxset2drenderalphablend方法--2d透明混合绘制&quot;&gt;BasicObjectFX::Set2DRenderAlphaBlend方法--2D透明混合绘制&lt;/h3&gt;
&lt;p&gt;相比上面，多了透明混合状态。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicObjectFX::Set2DRenderAlphaBlend()
{
    md3dImmediateContext-&amp;gt;IASetInputLayout(mVertexLayout2D.Get());
    md3dImmediateContext-&amp;gt;VSSetShader(mVertexShader2D.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;RSSetState(RenderStates::RSNoCull.Get());
    md3dImmediateContext-&amp;gt;PSSetShader(mPixelShader2D.Get(), nullptr, 0);
    md3dImmediateContext-&amp;gt;PSSetSamplers(0, 1, RenderStates::SSLinearWrap.GetAddressOf());
    md3dImmediateContext-&amp;gt;OMSetDepthStencilState(nullptr, 0);
    md3dImmediateContext-&amp;gt;OMSetBlendState(RenderStates::BSTransparent.Get(), nullptr, 0xFFFFFFFF);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;更新常量缓冲区&quot;&gt;更新常量缓冲区&lt;/h2&gt;
&lt;p&gt;下面这些所有的方法会更新&lt;code&gt;CBufferObject&lt;/code&gt;中的临时数据，数据脏标记被设为&lt;code&gt;true&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void XM_CALLCONV BasicObjectFX::SetWorldMatrix(DirectX::FXMMATRIX W)
{
    auto&amp;amp; cBuffer = pImpl-&amp;gt;cbDrawing;
    cBuffer.data.world = W;
    cBuffer.data.worldInvTranspose = XMMatrixTranspose(XMMatrixInverse(nullptr, W));
    pImpl-&amp;gt;isDirty = cBuffer.isDirty = true;
}

void XM_CALLCONV BasicObjectFX::SetViewMatrix(FXMMATRIX V)
{
    auto&amp;amp; cBuffer = pImpl-&amp;gt;cbFrame;
    cBuffer.data.view = V;
    pImpl-&amp;gt;isDirty = cBuffer.isDirty = true;
}

void XM_CALLCONV BasicObjectFX::SetProjMatrix(FXMMATRIX P)
{
    auto&amp;amp; cBuffer = pImpl-&amp;gt;cbOnResize;
    cBuffer.data.proj = P;
    pImpl-&amp;gt;isDirty = cBuffer.isDirty = true;
}

void XM_CALLCONV BasicObjectFX::SetWorldViewProjMatrix(FXMMATRIX W, CXMMATRIX V, CXMMATRIX P)
{
    pImpl-&amp;gt;cbDrawing.data.world = W;
    pImpl-&amp;gt;cbDrawing.data.worldInvTranspose = XMMatrixTranspose(XMMatrixInverse(nullptr, W));
    pImpl-&amp;gt;cbFrame.data.view = V;
    pImpl-&amp;gt;cbOnResize.data.proj = P;

    auto&amp;amp; pCBuffers = pImpl-&amp;gt;cBufferPtrs;
    pCBuffers[0]-&amp;gt;isDirty = pCBuffers[1]-&amp;gt;isDirty = pCBuffers[3]-&amp;gt;isDirty = true;
    pImpl-&amp;gt;isDirty = true;
}

void XM_CALLCONV BasicObjectFX::SetTexTransformMatrix(FXMMATRIX W)
{
    auto&amp;amp; cBuffer = pImpl-&amp;gt;cbDrawing;
    cBuffer.data.texTransform = W;
    pImpl-&amp;gt;isDirty = cBuffer.isDirty = true;
}

void XM_CALLCONV BasicObjectFX::SetReflectionMatrix(FXMMATRIX R)
{
    auto&amp;amp; cBuffer = pImpl-&amp;gt;cbRarely;
    cBuffer.data.reflection = R;
    pImpl-&amp;gt;isDirty = cBuffer.isDirty = true;
}

void XM_CALLCONV BasicObjectFX::SetShadowMatrix(FXMMATRIX S)
{
    auto&amp;amp; cBuffer = pImpl-&amp;gt;cbRarely;
    cBuffer.data.shadow = S;
    pImpl-&amp;gt;isDirty = cBuffer.isDirty = true;
}

void XM_CALLCONV BasicObjectFX::SetRefShadowMatrix(DirectX::FXMMATRIX RefS)
{
    auto&amp;amp; cBuffer = pImpl-&amp;gt;cbRarely;
    cBuffer.data.refShadow = RefS;
    pImpl-&amp;gt;isDirty = cBuffer.isDirty = true;
}

void BasicObjectFX::SetDirLight(size_t pos, const DirectionalLight &amp;amp; dirLight)
{
    auto&amp;amp; cBuffer = pImpl-&amp;gt;cbRarely;
    cBuffer.data.dirLight[pos] = dirLight;
    pImpl-&amp;gt;isDirty = cBuffer.isDirty = true;
}

void BasicObjectFX::SetPointLight(size_t pos, const PointLight &amp;amp; pointLight)
{
    auto&amp;amp; cBuffer = pImpl-&amp;gt;cbRarely;
    cBuffer.data.pointLight[pos] = pointLight;
    pImpl-&amp;gt;isDirty = cBuffer.isDirty = true;
}

void BasicObjectFX::SetSpotLight(size_t pos, const SpotLight &amp;amp; spotLight)
{
    auto&amp;amp; cBuffer = pImpl-&amp;gt;cbRarely;
    cBuffer.data.spotLight[pos] = spotLight;
    pImpl-&amp;gt;isDirty = cBuffer.isDirty = true;
}

void BasicObjectFX::SetMaterial(const Material &amp;amp; material)
{
    auto&amp;amp; cBuffer = pImpl-&amp;gt;cbDrawing;
    cBuffer.data.material = material;
    pImpl-&amp;gt;isDirty = cBuffer.isDirty = true;
}

void BasicObjectFX::SetTexture(ComPtr&amp;lt;ID3D11ShaderResourceView&amp;gt; texture)
{
    pImpl-&amp;gt;texture = texture;
}

void XM_CALLCONV BasicObjectFX::SetEyePos(FXMVECTOR eyePos)
{
    auto&amp;amp; cBuffer = pImpl-&amp;gt;cbFrame;
    cBuffer.data.eyePos = eyePos;
    pImpl-&amp;gt;isDirty = cBuffer.isDirty = true;
}

void BasicObjectFX::SetReflectionState(bool isOn)
{
    auto&amp;amp; cBuffer = pImpl-&amp;gt;cbStates;
    cBuffer.data.isReflection = isOn;
    pImpl-&amp;gt;isDirty = cBuffer.isDirty = true;
}

void BasicObjectFX::SetShadowState(bool isOn)
{
    auto&amp;amp; cBuffer = pImpl-&amp;gt;cbStates;
    cBuffer.data.isShadow = isOn;
    pImpl-&amp;gt;isDirty = cBuffer.isDirty = true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;basicobjectfxapply方法--应用缓冲区纹理资源并进行更新&quot;&gt;BasicObjectFX::Apply方法--应用缓冲区、纹理资源并进行更新&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;BasicObjectFX::Apply&lt;/code&gt;首先将所需要用到的缓冲区绑定到渲染管线上，并设置纹理，然后才是视情况更新常量缓冲区。&lt;/p&gt;
&lt;p&gt;下面的缓冲区数组索引值同时也对应了之前编译期指定的&lt;code&gt;startSlot&lt;/code&gt;值。&lt;/p&gt;
&lt;p&gt;首先检验总的脏标记是否为&lt;code&gt;true&lt;/code&gt;，若有任意数据被修改，则检验每个常量缓冲区的脏标记，并根据该标记决定是否要更新常量缓冲区。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void BasicObjectFX::Apply(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext)
{
    auto&amp;amp; pCBuffers = pImpl-&amp;gt;cBufferPtrs;
    // 将缓冲区绑定到渲染管线上
    pCBuffers[0]-&amp;gt;BindVS(deviceContext);
    pCBuffers[1]-&amp;gt;BindVS(deviceContext);
    pCBuffers[2]-&amp;gt;BindVS(deviceContext);
    pCBuffers[3]-&amp;gt;BindVS(deviceContext);
    pCBuffers[4]-&amp;gt;BindVS(deviceContext);

    pCBuffers[0]-&amp;gt;BindPS(deviceContext);
    pCBuffers[1]-&amp;gt;BindPS(deviceContext);
    pCBuffers[2]-&amp;gt;BindPS(deviceContext);
    pCBuffers[4]-&amp;gt;BindPS(deviceContext);

    // 设置纹理
    deviceContext-&amp;gt;PSSetShaderResources(0, 1, pImpl-&amp;gt;texture.GetAddressOf());

    if (pImpl-&amp;gt;isDirty)
    {
        pImpl-&amp;gt;isDirty = false;
        for (auto&amp;amp; pCBuffer : pCBuffers)
        {
            pCBuffer-&amp;gt;UpdateBuffer(deviceContext);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，目前&lt;code&gt;BasicFX&lt;/code&gt;能做的事情还是比较有限的，并且还需要随着HLSL代码的变动而随之调整。更多的功能会在后续教程中实现。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;XMMatrixShadow&lt;/code&gt;可以生成阴影矩阵，根据光照类型和位置对几何体投影到平面上的。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;XMMATRIX XMMatrixShadow(
    FXMVECTOR ShadowPlane,      // 平面向量(nx, ny, nz, d)
    FXMVECTOR LightPosition);   // w = 0时表示平行光方向， w = 1时表示光源位置&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常指定的平面会稍微比实际平面高那么一点点，以避免深度缓冲区资源争夺导致阴影显示有问题。&lt;/p&gt;
&lt;h2 id=&quot;使用模板缓冲区防止过度混合&quot;&gt;使用模板缓冲区防止过度混合&lt;/h2&gt;
&lt;p&gt;一个物体投影到平面上时，投影区域的某些位置可能位于多个三角形之内，这会导致这些位置会有多个像素通过测试并进行混合操作，渲染的次数越多，显示的颜色会越黑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201807/1172605-20180729185331925-791778554.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用模板缓冲区来解决这个问题。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在之前的例子中，我们用模板值为0的区域表示非镜面反射区，模板值为1的区域表示为镜面反射区；&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;RenderStates::DSSNoDoubleBlend&lt;/code&gt;的深度模板状态，当给定的模板值和深度/模板缓冲区的模板值一致时，通过模板测试并对模板值加1，绘制该像素的混合，然后下一次由于给定的模板值比深度/模板缓冲区的模板值小1，不会再通过模板测试，也就阻挡了后续像素的绘制；&lt;/li&gt;
&lt;li&gt;应当先绘制镜面的阴影区域，再绘制正常的阴影区域。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;着色器代码的变化&quot;&gt;着色器代码的变化&lt;/h2&gt;
&lt;p&gt;Basic_PS_2D.hlsl文件变化如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &quot;Basic.fx&quot;

// 像素着色器(2D)
float4 PS_2D(Vertex2DOut pIn) : SV_Target
{
    float4 color = tex.Sample(sam, pIn.Tex);
    clip(color.a - 0.1f);
    return color;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Basic_PS_3D.hlsl文件变化如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &quot;Basic.fx&quot;

// 像素着色器(3D)
float4 PS_3D(Vertex3DOut pIn) : SV_Target
{
    // 提前进行裁剪，对不符合要求的像素可以避免后续运算
    float4 texColor = tex.Sample(sam, pIn.Tex);
    clip(texColor.a - 0.1f);

    // 标准化法向量
    pIn.NormalW = normalize(pIn.NormalW);

    // 顶点指向眼睛的向量
    float3 toEyeW = normalize(gEyePosW - pIn.PosW);

    // 初始化为0 
    float4 ambient = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 diffuse = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 spec = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 A = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 D = float4(0.0f, 0.0f, 0.0f, 0.0f);
    float4 S = float4(0.0f, 0.0f, 0.0f, 0.0f);
    int i;


    // 强制展开循环以减少指令数
    [unroll]
    for (i = 0; i &amp;lt; gNumDirLight; ++i)
    {
        ComputeDirectionalLight(gMaterial, gDirLight[i], pIn.NormalW, toEyeW, A, D, S);
        ambient += A;
        diffuse += D;
        spec += S;
    }
    
    [unroll]
    for (i = 0; i &amp;lt; gNumPointLight; ++i)
    {
        PointLight pointLight = gPointLight[i];
        // 若当前在绘制反射物体，需要对光照进行反射矩阵变换
        [flatten]
        if (gIsReflection)
        {
            pointLight.Position = (float3) mul(float4(pointLight.Position, 1.0f), gReflection);
        }

        ComputePointLight(gMaterial, pointLight, pIn.PosW, pIn.NormalW, toEyeW, A, D, S);
        ambient += A;
        diffuse += D;
        spec += S;
    }
    
    [unroll]
    for (i = 0; i &amp;lt; gNumSpotLight; ++i)
    {
        SpotLight spotLight = gSpotLight[i];
        // 若当前在绘制反射物体，需要对光照进行反射矩阵变换
        [flatten]
        if (gIsReflection)
        {
            spotLight.Position = (float3) mul(float4(spotLight.Position, 1.0f), gReflection);
        }

        ComputeSpotLight(gMaterial, spotLight, pIn.PosW, pIn.NormalW, toEyeW, A, D, S);
        ambient += A;
        diffuse += D;
        spec += S;
    }
    

    
    float4 litColor = texColor * (ambient + diffuse) + spec;
    litColor.a = texColor.a * gMaterial.Diffuse.a;
    return litColor;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Basic_VS_2D.hlsl变化如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &quot;Basic.fx&quot;

// 顶点着色器(2D)
Vertex2DOut VS_2D(Vertex2DIn pIn)
{
    Vertex2DOut pOut;
    pOut.PosH = float4(pIn.Pos, 1.0f);
    pOut.Tex = mul(float4(pIn.Tex, 0.0f, 1.0f), gTexTransform).xy;
    return pOut;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Basic_VS_3D.hlsl变化如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &quot;Basic.fx&quot;

// 顶点着色器(3D)
Vertex3DOut VS_3D(Vertex3DIn pIn)
{
    Vertex3DOut pOut;
    
    float4 posW = mul(float4(pIn.PosL, 1.0f), gWorld);
    // 若当前在绘制反射物体，先进行反射操作
    [flatten]
    if (gIsReflection)
    {
        posW = mul(posW, gReflection);
    }
    // 若当前在绘制阴影，先进行投影操作
    [flatten]
    if (gIsShadow)
    {
        posW = (gIsReflection ? mul(posW, gRefShadow) : mul(posW, gShadow));
    }

    pOut.PosH = mul(mul(posW, gView), gProj);
    pOut.PosW = mul(float4(pIn.Pos, 1.0f), gWorld).xyz;
    pOut.NormalW = mul(pIn.NormalL, (float3x3) gWorldInvTranspose);
    pOut.Tex = mul(float4(pIn.Tex, 0.0f, 1.0f), gTexTransform).xy;
    return pOut;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;由于&lt;code&gt;GameObject&lt;/code&gt;类也承担了绘制方法，那么最后的&lt;code&gt;Apply&lt;/code&gt;也需要交给游戏对象来调用。因此&lt;code&gt;GameObject::Draw&lt;/code&gt;方法变更如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void GameObject::Draw(ComPtr&amp;lt;ID3D11DeviceContext&amp;gt; deviceContext, BasicObjectFX&amp;amp; effect)
{
    // 设置顶点/索引缓冲区
    UINT strides = sizeof(VertexPosNormalTex);
    UINT offsets = 0;
    deviceContext-&amp;gt;IASetVertexBuffers(0, 1, mVertexBuffer.GetAddressOf(), &amp;amp;strides, &amp;amp;offsets);
    deviceContext-&amp;gt;IASetIndexBuffer(mIndexBuffer.Get(), DXGI_FORMAT_R16_UINT, 0);

    // 更新数据并应用
    effect.SetWorldMatrix(XMLoadFloat4x4(&amp;amp;mWorldMatrix));
    effect.SetTexTransformMatrix(XMLoadFloat4x4(&amp;amp;mTexTransform));
    effect.SetTexture(mTexture);
    effect.SetMaterial(mMaterial);
    effect.Apply(deviceContext);

    deviceContext-&amp;gt;DrawIndexed(mIndexCount, 0, 0);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;现在场景只有墙体、地板、木箱和镜面。&lt;/p&gt;
&lt;h2 id=&quot;第1步-镜面区域写入模板缓冲区&quot;&gt;第1步: 镜面区域写入模板缓冲区&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// *********************
// 1. 给镜面反射区域写入值1到模板缓冲区
// 

mBasicObjectFX.SetWriteStencilOnly(md3dImmediateContext, 1);
mMirror.Draw(md3dImmediateContext, mBasicObjectFX);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;第2步-绘制不透明的反射物体&quot;&gt;第2步: 绘制不透明的反射物体&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// ***********************
// 2. 绘制不透明的反射物体
//

// 开启反射绘制
mBasicObjectFX.SetReflectionState(true);
mBasicObjectFX.SetRenderDefaultWithStencil(md3dImmediateContext, 1);

mWalls[2].Draw(md3dImmediateContext, mBasicObjectFX);
mWalls[3].Draw(md3dImmediateContext, mBasicObjectFX);
mWalls[4].Draw(md3dImmediateContext, mBasicObjectFX);
mFloor.Draw(md3dImmediateContext, mBasicObjectFX);
mWoodCrate.Draw(md3dImmediateContext, mBasicObjectFX);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180806100250622-1140608.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;第3步-绘制不透明反射物体的阴影&quot;&gt;第3步: 绘制不透明反射物体的阴影&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// ***********************
// 3. 绘制不透明反射物体的阴影
//

mWoodCrate.SetMaterial(mShadowMat);
mBasicObjectFX.SetShadowState(true);    // 反射开启，阴影开启            
mBasicObjectFX.SetRenderNoDoubleBlend(md3dImmediateContext, 1);

mWoodCrate.Draw(md3dImmediateContext, mBasicObjectFX);

// 恢复到原来的状态
mBasicObjectFX.SetShadowState(false);
mWoodCrate.SetMaterial(mWoodCrateMat);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180806100307497-1926071541.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;第4步-绘制透明镜面&quot;&gt;第4步: 绘制透明镜面&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// ***********************
// 4. 绘制透明镜面
//

// 关闭反射绘制
mBasicObjectFX.SetReflectionState(false);
mBasicObjectFX.SetRenderAlphaBlendWithStencil(md3dImmediateContext, 1);

mMirror.Draw(md3dImmediateContext, mBasicObjectFX);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180806100330291-1987680964.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;第5步绘制不透明的正常物体&quot;&gt;第5步：绘制不透明的正常物体&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// ************************
// 5. 绘制不透明的正常物体
//
mBasicObjectFX.SetRenderDefault(md3dImmediateContext);

for (auto&amp;amp; wall : mWalls)
    wall.Draw(md3dImmediateContext, mBasicObjectFX);
mFloor.Draw(md3dImmediateContext, mBasicObjectFX);
mWoodCrate.Draw(md3dImmediateContext, mBasicObjectFX);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180806100358937-547733777.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;第6步绘制不透明正常物体的阴影&quot;&gt;第6步：绘制不透明正常物体的阴影&lt;/h2&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// ************************
// 6. 绘制不透明正常物体的阴影
//
mWoodCrate.SetMaterial(mShadowMat);
mBasicObjectFX.SetShadowState(true);    // 反射关闭，阴影开启
mBasicObjectFX.SetRenderNoDoubleBlend(md3dImmediateContext, 0);

mWoodCrate.Draw(md3dImmediateContext, mBasicObjectFX);

mBasicObjectFX.SetShadowState(false);       // 阴影关闭
mWoodCrate.SetMaterial(mWoodCrateMat);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180806100421189-250732809.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终绘制效果如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1172605/201808/1172605-20180806100816518-1270531534.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意该样例只生成点光灯到地板的阴影。你可以用各种摄像机模式来进行测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2018/9/17：该教程后面14, 15, 17, 19章还没有及时更换为新的框架，需要一段时间进行替换。并且篇幅庞大难免有遗漏错误之处，望谅解。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Sep 2018 15:56:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<og:description>前言 到现在为止，所有的教程项目都没有使用Effects11框架类来管理资源。因为在D3DCompile API ( 47)版本中，如果你尝试编译fx_5_0的效果文件，会收到这样的警告： 在未来的版</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-Jun/p/9665452.html</dc:identifier>
</item>
<item>
<title>关于SQL优化这些你了解吗？ - 狼图的点滴</title>
<link>http://www.cnblogs.com/wind-june/p/9638356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wind-june/p/9638356.html</guid>
<description>&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　在当今这个互联网的时代无非要解决两大难题，其一是信息安全，其二就是数据的存储。而信息安全则是在数据存储的基础之上。一个公司从刚开始成立到发展成一个有上百人甚至上千人团队的时候，公司的业务量是呈上升趋势，客户及用户也会越来越多；之前设计的表结构可能会显得不合理，表与表之间的联系没有一个稳定的业务功能划分，从而表现出来的是相关表的备用字段越来越不够用甚至新加字段，最坏的情况就是不同业务表之间会有数据冗杂。从而暴露出一些设计的问题，这也就是SQL优化点之一：数据库表结构设计的合理性。近年来大数据越来越火，而大数据也是为了解决数据的存储的手段之一，其目的是从海量的数据中收集到有价值的信息然后存储到数据库中，因为数据量大传统的数据库无法储存那么多的信息所以需要分析有价值的信息后再做决定是否持久化。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;优化点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;前提必备知识&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　学会是用explain关键词查看SQL语句性能，explain好像是从MYSQL5.6.3开始支持 select、update、delete语句分析，之前只支持select语句。现在我们普遍都是用5.7，所以的话不需要太担心。这里的话不详细讲如何解读explain输出的性能信息。请参看博客文档：&lt;a title=&quot;Mysql优化之Explain解读&quot; href=&quot;https://www.cnblogs.com/wind-june/p/9644163.html&quot; target=&quot;_blank&quot;&gt;《MySQL优化之Explain命令解读》&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;优化之一 - 从数据库设计方面考虑&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;span&gt;表与表之间的业务联系要明确：表之间其实是有业务联系的，比如：class(primary key:class_id,所有班级信息表)、student(primary key:student_num,所有学生信息表)、student_class(primary key:stu_class_id,所有学生所在班级信息表)着三张表，如果现在需要一张老师对应哪个班级的班主任的信息表；那么此时正确的方法是：新建 teacher、teacher_class表，而不是直接把老师的信息插入到student表中然后用一个字段来标识是老师还是学生。可能你看到这个你会想 “我肯定会按正确的那种方式啊”，但是这只是举一个例子，其实在实际项目开发过程中表与表结构往往不会那么单一，这个时候你就会犯错误而用字段标识。但是也不能说是不能用字段标识，这个要看字段标识的两种信息对应的业务是否有交叉点来取舍。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;表字段尽量使用数值型：因为数值型字段在MySQL底层应用的时候相比string类型的话性能更好；具体为什么性能更好就需要了解MySQL底层机制了，反正记住这点就好。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;属性尽量使用定长：以减少占用储存空间；如果你定义了一个 order_id varchar(32) ,当在存储的时候有一条记录的order_id=20180910242360，此时order_id实际占用了14个字节但是这个字段的属性长度是32，所以还有18个字节长度是无用的但却占用着内存空间。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;建立合理的索引：索引就是用某种数据结构来查找对应的信息，从而减低时间复杂度提高查找效率。建立索引的前提也要明确，综合考虑再打算是否需要建立索引，毕竟索引是需要占用存储空间的，有时候牺牲的空间却换不回时间。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;优化之二 - 从SQL语句优化方面考虑&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　1. 尽量将要输出的字段写出来；不要使用 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; xxxxx&lt;/span&gt; ；这种形式的语句。我在这测试时是使用*代替，但是记住在生产环境上尽量将字段替代*。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2. 合理使用连表查询；不仅是表的连接需要较大的内存消耗另外一方面如果表设计的不是很合理也会导致索引无效从而造成极坏的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3. 查询的时候要注意是否走索引：假如你在name列建立了一个 name_index索引，查询你使用 &lt;span class=&quot;cnblogs_code&quot;&gt;name &lt;span&gt;Like&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%xxxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/span&gt; 或者 &lt;span class=&quot;cnblogs_code&quot;&gt;name &lt;span&gt;Like&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%xxxx%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/span&gt; 这种模糊查询，那么此时&lt;span&gt;可能就不会走索引&lt;/span&gt;；你应该这样  &lt;span class=&quot;cnblogs_code&quot;&gt;name &lt;span&gt;Like&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxxx%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/span&gt; 。以下就是实际的一个例子：　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　建立索引：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;-- 为cust_third_acct 建立一个普通索引&lt;br/&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt;
cust_info
&lt;/span&gt;&lt;span&gt;add&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; cust_third_acct_index(cust_third_acct);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a：通过SQL查询信息： &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sp_tunnel_user &lt;span&gt;where&lt;/span&gt; cust_third_acct &lt;span&gt;like&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0200%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;　&lt;/span&gt; 　以下就是满足查询条件的部分信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485316/201809/1485316-20180914002846654-960933309.png&quot; alt=&quot;&quot; width=&quot;1450&quot; height=&quot;218&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　b：分析Like'%xxxx%'的查询性能： &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sp_tunnel_user &lt;span&gt;where&lt;/span&gt; cust_third_acct &lt;span&gt;like&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%0200%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;&lt;/span&gt;  通过Explain性能分析命令可以知道：在这种查询条件下并没有执行索引，type=all表明该语句执行的时候进行的是全表扫描；虽然我们在 &lt;span class=&quot;cnblogs_code&quot;&gt;cust_third_acct&lt;/span&gt;  这个字段建立了索引，但是 &lt;span class=&quot;cnblogs_code&quot;&gt;possible_keys&lt;span&gt;=&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;/span&gt; 则说明了 用 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;like&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%0200%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/span&gt; 这种形式的条件是一定无法使用到  &lt;span class=&quot;cnblogs_code&quot;&gt;cust_third_acct_index&lt;/span&gt;  这个索引。(其他字段的解析请参照&lt;a title=&quot;Mysql优化之Explain解读&quot; href=&quot;https://www.cnblogs.com/wind-june/p/9644163.html&quot; target=&quot;_blank&quot;&gt;《MySQL优化之Explain命令解读》&lt;/a&gt;这篇文章，这里不做过多的分析)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485316/201809/1485316-20180914003134702-2013756600.png&quot; alt=&quot;&quot; width=&quot;1453&quot; height=&quot;165&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　c：分析Like'xxxx%'的查询性能： &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sp_tunnel_user &lt;span&gt;where&lt;/span&gt; cust_third_acct &lt;span&gt;like&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0200%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;&lt;/span&gt;  与b查询语句相比这个查询的  &lt;span class=&quot;cnblogs_code&quot;&gt;possible_keys&lt;span&gt;=&lt;/span&gt;cust_third_acct_index&lt;/span&gt;  ，这说明这个语句可能会用到 &lt;span class=&quot;cnblogs_code&quot;&gt;cust_third_acct_index&lt;/span&gt; 这个索引，但是key=null表明在实际的执行过程中并没有用到  &lt;span class=&quot;cnblogs_code&quot;&gt;cust_third_acct_index&lt;/span&gt;  索引；刚才我们也说了这种条件查询只是可能会走索引但是不一定发生，这个跟MySQL的存储引擎相关，但是我们使用的时候尽量以这种方式去查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485316/201809/1485316-20180914003235870-239123373.png&quot; alt=&quot;&quot; width=&quot;1452&quot; height=&quot;176&quot;/&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4. 使用索引遵循最佳左前缀特性，建立联合索引的时候将常用的属性放在左边。比如：我们需在在一张表的 cust_id 和 cust_tp 建立一个联合索引 cust_id_type,设定cust_id（不是唯一） 是比较常用的那么我们就将cust_id放在左边。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　建立联合索引：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;-- 为cust_id与cust_tp建立一个联合索引&lt;br/&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt;
cust_info
&lt;/span&gt;&lt;span&gt;add&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;  cust_id_type(cust_id,cust_tp);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5.使用符合索引的时候需要注意：使用联合索引需要从左往右不间断，索引才会生效，也就是说&lt;span&gt;联合索引&lt;/span&gt;使用的时候&lt;span&gt;必须要连续但不要求全部使用&lt;/span&gt;。如：以上4我们建立了一个  &lt;span class=&quot;cnblogs_code&quot;&gt;cust_id_type&lt;/span&gt;  索引,当我们在使用的时候如果where条件中只使用了 cust_id,那么也会走索引；如果where条件中只使用了 cust_tp，那么这条语句不会走索引，以下就是一个实例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a：&lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; sp_tunnel_user &lt;span&gt;where&lt;/span&gt; cust_id=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;8888888888&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; and cust_tp=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;04&lt;/span&gt;&lt;span&gt;'；&lt;/span&gt;&lt;/span&gt;  当查询条件用到cust_id与cust_tp两个字段并且cust_id在前面的时候，就会用到联合索引；通过 key=cust_id_type可以看到实际执行过程中是用到索引了的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485316/201809/1485316-20180914011326215-802475011.png&quot; alt=&quot;&quot; width=&quot;1448&quot; height=&quot;160&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　b：&lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; sp_tunnel_user &lt;span&gt;where&lt;/span&gt; cust_id=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;8888888888&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; ;&lt;/span&gt;  当查询条件只用到cust_id一个字段时，也用到了联合索引；通过 key=cust_id_type可以看到实际执行过程中是用到索引了的，这就是左前缀原则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485316/201809/1485316-20180914011106477-1429097473.png&quot; alt=&quot;&quot; width=&quot;1450&quot; height=&quot;169&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　c：&lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; sp_tunnel_user &lt;span&gt;where&lt;/span&gt; cust_tp=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;04&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; ;&lt;/span&gt;  当查询条件只用到cust_tp一个字段时，但却没有用到索引；通过 key=null 可以看到实际执行过程并没有用到索引，这也是左前缀原则。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485316/201809/1485316-20180914011132541-1229370959.png&quot; alt=&quot;&quot; width=&quot;1453&quot; height=&quot;164&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;优化之三&lt;/strong&gt; &lt;strong&gt;- 读写分离与分库分表&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　当数据量达到一定的数量之后，限制数据库存储性能的就不再是数据库层面的优化就能够解决的；这个时候往往采用的是读写分离与分库分表同时也会结合缓存一起使用，而这个时候数据库层面的优化只是基础。读写分离适用于较小一些的数据量；分表适用于中等数据量；而分库与分表一般是结合着用，这就适用于大数据量的存储了，这也是现在大型互联网公司解决数据存储的方法之一。至于怎么读写分离、怎么分表、怎么分库，这里不做过多的阐述后续文章会有相关知识分享。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Sep 2018 15:51:00 +0000</pubDate>
<dc:creator>狼图的点滴</dc:creator>
<og:description>在当今这个互联网的时代无非要解决两大难题，其一是信息安全，其二就是数据的存储。而信息安全则是在数据存储的基础之上。一个公司从刚开始成立到发展成一个有上百人甚至上千人团队的时候，公司的业务量是呈上升趋势</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wind-june/p/9638356.html</dc:identifier>
</item>
<item>
<title>ReentrantLock实现原理 - 卫旗</title>
<link>http://www.cnblogs.com/weiqihome/p/9665718.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weiqihome/p/9665718.html</guid>
<description>&lt;h2 id=&quot;ReentrantLock实现原理-1.1synchronized的局限性&quot;&gt;1.1 synchronized的局限性&lt;/h2&gt;
&lt;p&gt;　　synchronized是java内置的关键字，它提供了一种独占的加锁方式。synchronized的获取和释放锁有JVM实现，用户不需要显式的释放锁，非常方便，然而synchronized也有一定的局限性，例如：&lt;/p&gt;
&lt;p&gt;　　1、当线程尝试获取锁的时候，如果获取不到锁就会一直阻塞。&lt;/p&gt;
&lt;p&gt;　　2、如果获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁会一直等待。&lt;/p&gt;
&lt;p&gt;　　JDK1.5之后发布的concurrent包，提供了Lock接口，用来提供更多扩展的加锁功能。Lock弥补了synchronized的局限性，提供了更加细粒度的加锁功能。&lt;/p&gt;
&lt;h2 id=&quot;ReentrantLock实现原理-1.2Lock简介&quot;&gt;1.2 Lock简介&lt;/h2&gt;
&lt;p&gt;Lock的API如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201809/811336-20180917225749197-1828692794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中最常用的就是lock和unlock操作了。因为使用lock时，需要手动的释放锁，所以需要使用try..catch来包住业务代码，并且在final中释放锁。典型使用如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; Lock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test(){
    lock.lock();
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
        doSomeThing();
    }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ignored&lt;/span&gt;
    }&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        lock.unlock();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　AbstarctQueuedSynchronizer简称AQS，是一个用于构建锁和同步容器的框架。事实上concurrent包内许多类都是基于AQS构建的，例如ReentrantLock，Semphore，CountDownLatch，ReentrantReadWriteLock，FutureTask等。AQS解决了在实现同步容器时大量的细节问题。&lt;/p&gt;
&lt;p&gt;　　AQS使用一个FIFO队列表示排队等待锁的线程，队列头结点称作“哨兵节点”或者“哑结点”，它不与任何线程关联。其他的节点与等待线程关联，每个阶段维护一个等待状态waitStatus。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201809/811336-20180917230446754-176956049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　AQS中还有一个表示状态的字段state，例如ReentrantLock用它来表示线程重入锁的次数，Semphore用它表示剩余的许可数量，FutureTask用它表示任务的状态。对state变量值的更新都采用CAS操作保证更新操作的原子性。&lt;/p&gt;
&lt;p&gt;　　AbstractQueuedSynchronized继承了AbstractOwnableSynchronized，这个类只有一个变量：exclusiveOwnerThread，表示当前占用该锁的线程，并且提供了相应的get，set方法。&lt;/p&gt;
&lt;p&gt;　　理解AQS可以帮助我们更好的理解JUC包中的同步容器。&lt;/p&gt;

&lt;h2 id=&quot;ReentrantLock实现原理-3.1基础知识&quot; class=&quot;diff-block-target&quot;&gt;3.1 基础知识&lt;/h2&gt;
&lt;p&gt;　　ReentrantLock是Lock的默认实现之一。那么Lock()和unlock(）是怎样实现的呢？首先我们要弄清楚几个概念&lt;/p&gt;
&lt;p&gt;　　1、可重入锁。可重入锁是指一个线程可以多次获取同一把锁。ReentrantLock和Synchronized都是可重入锁。&lt;/p&gt;
&lt;p&gt;　　2、可中断锁。可中断锁是指线程尝试获取锁的过程是否可以响应终端。synchronized是不可中断锁，而ReentrantLock则提供了中断功能。&lt;/p&gt;
&lt;p&gt;　　3、公平锁与非公平锁。公平所指多个线程同时尝试获取同一把锁时，获取锁的顺序按照线程达到的顺序，而非公平锁则允许线程“插队”。synchronized是非公平锁，而ReentrantLock的默认实现是非公平锁，但是也可以设置为公平锁。&lt;/p&gt;
&lt;p&gt;　　4、CAS操作(CompareAndSwap)。CAS操作简单的说就是比较并交换。CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” Java并发包(java.util.concurrent)中大量使用了CAS操作,涉及到并发的地方都调用了sun.misc.Unsafe类方法进行CAS操作。&lt;/p&gt;
&lt;h2 id=&quot;ReentrantLock实现原理-3.2内部结构&quot; class=&quot;diff-block-target diff-block-context&quot;&gt;3.2 内部结构&lt;/h2&gt;
&lt;p&gt;　　ReentrantLock提供了两个构造器，分别是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ReentrantLock() {
    sync &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NonfairSync();
}
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ReentrantLock(&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; fair) {
    sync &lt;/span&gt;= fair ? &lt;span&gt;new&lt;/span&gt; FairSync() : &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NonfairSync();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　默认构造器初始化为NonfairSync对象，即非公平锁，而带参数的构造器可以指定使用公平锁和非公平锁。由lock()和unlock的源码可以看到，它们只是分别调用了sync对象的lock()和release(1)方法。&lt;/p&gt;
&lt;p&gt;　　Sync是ReentrantLock的内部类，它的结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201809/811336-20180917231512390-658385817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到Sync扩展了AbstractQueuedSynchronizer。&lt;/p&gt;
&lt;h2 id=&quot;ReentrantLock实现原理-3.3NonfairSync&quot; class=&quot;diff-block-target diff-block-context&quot;&gt;3.3 NonfairSync&lt;/h2&gt;
&lt;p&gt;　　我们从源代码出发，分析非公平锁获取锁和释放锁的过程。 &lt;/p&gt;
&lt;h3 id=&quot;ReentrantLock实现原理-3.3.1lock()&quot; class=&quot;diff-block-target diff-block-context&quot;&gt;3.3.1 lock() &lt;/h3&gt;
&lt;p&gt;　　lock()源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; lock() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compareAndSetState(0, 1&lt;span&gt;))
        setExclusiveOwnerThread(Thread.currentThread());
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        acquire(&lt;/span&gt;1&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　首先用一个CAS操作，判断state是否是0（表示当前锁未被占用），如果是0则把它置为1，并且设置当前线程为该锁的独占线程，表示获取锁成功。当多个线程同时尝试占用同一个锁时，CAS操作只能保证一个线程操作成功，剩下的只能乖乖的去排队啦。&lt;/p&gt;
&lt;p&gt;　　“非公平”即体现在这里，如果占用锁的线程刚释放锁，state置为0，而排队等待锁的线程还未唤醒时，新来的线程就直接抢占了该锁，那么就“插队”了。&lt;/p&gt;
&lt;p&gt;　　若当前有三个线程去竞争锁，假设线程A的CAS操作成功了，拿到了锁开开心心的返回了，那么线程B和C则设置state失败，走到了else里面。我们往下看acquire。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;acquire(arg)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; acquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp;&lt;span&gt;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;1. 第一步。尝试去获取锁。如果尝试获取锁成功，方法直接返回。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;tryAcquire(arg)&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; nonfairTryAcquire(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; acquires) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前线程&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; Thread current =&lt;span&gt; Thread.currentThread();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取state变量值&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; getState();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c == 0) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有线程占用锁&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (compareAndSetState(0&lt;span&gt;, acquires)) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;占用锁成功,设置独占线程为当前线程&lt;/span&gt;
&lt;span&gt;            setExclusiveOwnerThread(current);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (current == getExclusiveOwnerThread()) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前线程已经占用该锁&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; nextc = c +&lt;span&gt; acquires;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nextc &amp;lt; 0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; overflow&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&quot;Maximum lock count exceeded&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新state值为新的重入次数&lt;/span&gt;
&lt;span&gt;        setState(nextc);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取锁失败&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　非公平锁tryAcquire的流程是：检查state字段，若为0，表示锁未被占用，那么尝试占用，若不为0，检查当前锁是否被自己占用，若被自己占用，则更新state字段，表示重入锁的次数。如果以上两点都没有成功，则获取锁失败，返回false。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. &lt;/strong&gt;第二步，入队。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/strong&gt;由于上文中提到线程A已经占用了锁，所以B和C执行tryAcquire失败，并且入等待队列。如果线程A拿着锁死死不放，那么B和C就会被挂起。&lt;/p&gt;
&lt;p class=&quot;diff-block-target diff-block-context&quot;&gt;先看下入队的过程。&lt;/p&gt;
&lt;p class=&quot;diff-block-target diff-block-context&quot;&gt;先看addWaiter(Node.EXCLUSIVE)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 将新节点和当前线程关联并且入队列
 * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; mode 独占/共享
 * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 新节点
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Node addWaiter(Node mode) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化节点,设置关联线程和模式(独占 or 共享)&lt;/span&gt;
    Node node = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node(Thread.currentThread(), mode);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取尾节点引用&lt;/span&gt;
    Node pred =&lt;span&gt; tail;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尾节点不为空,说明队列已经初始化过&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (pred != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        node.prev &lt;/span&gt;=&lt;span&gt; pred;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置新节点为尾节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetTail(pred, node)) {
            pred.next &lt;/span&gt;=&lt;span&gt; node;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尾节点为空,说明队列还未初始化,需要初始化head节点并入队新节点&lt;/span&gt;
&lt;span&gt;    enq(node);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;B、C线程同时尝试入队列，由于队列尚未初始化，tail==null，故至少会有一个线程会走到enq(node)。我们假设同时走到了enq(node)里。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 初始化队列并且入队新节点
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; Node enq(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; Node node) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始自旋&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
        Node t &lt;/span&gt;=&lt;span&gt; tail;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Must initialize
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果tail为空,则新建一个head节点,并且tail指向head&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (compareAndSetHead(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node()))
                tail &lt;/span&gt;=&lt;span&gt; head;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            node.prev &lt;/span&gt;=&lt;span&gt; t;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; tail不为空,将新节点入队&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (compareAndSetTail(t, node)) {
                t.next &lt;/span&gt;=&lt;span&gt; node;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里体现了经典的自旋+CAS组合来实现非阻塞的原子操作。由于compareAndSetHead的实现使用了unsafe类提供的CAS操作，所以只有一个线程会创建head节点成功。假设线程B成功，之后B、C开始第二轮循环，此时tail已经不为空，两个线程都走到else里面。假设B线程compareAndSetTail成功，那么B就可以返回了，C由于入队失败还需要第三轮循环。最终所有线程都可以成功入队。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201809/811336-20180917232605000-1883174482.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;3. &lt;strong&gt;第三步，挂起。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;B和C相继执行acquireQueued(final Node node, int arg)。这个方法让已经入队的线程尝试获取锁，若失败则会被挂起。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 已经入队的线程尝试获取锁
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; acquireQueued(&lt;span&gt;final&lt;/span&gt; Node node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记是否成功获取锁&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; interrupted = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记线程是否被中断过&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Node p = node.predecessor(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取前驱节点
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果前驱是head,即该结点已成老二，那么便有资格去尝试获取锁&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp;&lt;span&gt; tryAcquire(arg)) {
                setHead(node); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取成功,将当前节点设置为head节点&lt;/span&gt;
                p.next = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原head节点出队,在某个时间点被GC回收&lt;/span&gt;
                failed = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取成功&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; interrupted; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回是否被中断过&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断获取失败后是否可以挂起,若可以则挂起&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;span&gt;
                    parkAndCheckInterrupt())
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程若被中断,设置interrupted为true&lt;/span&gt;
                interrupted = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)
            cancelAcquire(node);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　code里的注释已经很清晰的说明了acquireQueued的执行流程。假设B和C在竞争锁的过程中A一直持有锁，那么它们的tryAcquire操作都会失败，因此会走到第2个if语句中。我们再看下shouldParkAfterFailedAcquire和parkAndCheckInterrupt都做了哪些事吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 判断当前线程获取锁失败之后是否需要挂起.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; shouldParkAfterFailedAcquire(Node pred, Node node) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前驱节点的状态&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; ws =&lt;span&gt; pred.waitStatus;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ws ==&lt;span&gt; Node.SIGNAL)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前驱节点状态为signal,返回true&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前驱节点状态为CANCELLED&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (ws &amp;gt; 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从队尾向前寻找第一个状态不为CANCELLED的节点&lt;/span&gt;
        &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            node.prev &lt;/span&gt;= pred =&lt;span&gt; pred.prev;
        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (pred.waitStatus &amp;gt; 0&lt;span&gt;);
        pred.next &lt;/span&gt;=&lt;span&gt; node;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将前驱节点的状态设置为SIGNAL&lt;/span&gt;
&lt;span&gt;        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}
  
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 挂起当前线程,返回线程中断状态并重置
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; parkAndCheckInterrupt() {
    LockSupport.park(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Thread.interrupted();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　线程入队后能够挂起的前提是，它的前驱节点的状态为SIGNAL，它的含义是“Hi，前面的兄弟，如果你获取锁并且出队后，记得把我唤醒！”。所以shouldParkAfterFailedAcquire会先判断当前节点的前驱是否状态符合要求，若符合则返回true，然后调用parkAndCheckInterrupt，将自己挂起。如果不符合，再看前驱节点是否&amp;gt;0(CANCELLED)，若是那么向前遍历直到找到第一个符合要求的前驱，若不是则将前驱节点的状态设置为SIGNAL。&lt;/p&gt;
&lt;p&gt;　　 整个流程中，如果前驱结点的状态不是SIGNAL，那么自己就不能安心挂起，需要去找个安心的挂起点，同时可以再尝试下看有没有机会去尝试竞争锁。&lt;/p&gt;
&lt;p&gt;　　最终队列可能会如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201809/811336-20180917232950037-78637699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　线程B和C都已经入队，并且都被挂起。当线程A释放锁的时候，就会去唤醒线程B去获取锁啦。&lt;/p&gt;
&lt;h3 id=&quot;ReentrantLock实现原理-3.3.2unlock()&quot; class=&quot;diff-block-target diff-block-context&quot;&gt;3.3.2 unlock()&lt;/h3&gt;
&lt;p&gt;　　unlock相对于lock就简单很多。源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unlock() {
    sync.release(&lt;/span&gt;1&lt;span&gt;);
}
  
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; release(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; arg) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (tryRelease(arg)) {
        Node h &lt;/span&gt;=&lt;span&gt; head;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h.waitStatus != 0&lt;span&gt;)
            unparkSuccessor(h);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　如果理解了加锁的过程，那么解锁看起来就容易多了。流程大致为先尝试释放锁，若释放成功，那么查看头结点的状态是否为SIGNAL，如果是则唤醒头结点的下个节点关联的线程，如果释放失败那么返回false表示解锁失败。这里我们也发现了，每次都只唤起头结点的下一个节点关联的线程。&lt;/p&gt;
&lt;p&gt;　　最后我们再看下tryRelease的执行过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 释放当前线程占用的锁
 * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; releases
 * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 是否释放成功
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryRelease(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; releases) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算释放后state值&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; c = getState() -&lt;span&gt; releases;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不是当前线程占用锁,那么抛出异常&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Thread.currentThread() !=&lt;span&gt; getExclusiveOwnerThread())
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalMonitorStateException();
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; free = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c == 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 锁被重入次数为0,表示释放成功&lt;/span&gt;
        free = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 清空独占线程&lt;/span&gt;
        setExclusiveOwnerThread(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新state值&lt;/span&gt;
&lt;span&gt;    setState(c);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; free;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里入参为1。tryRelease的过程为：当前释放锁的线程若不持有锁，则抛出异常。若持有锁，计算释放后的state值是否为0，若为0表示锁已经被成功释放，并且则清空独占线程，最后更新state值，返回free。 &lt;/p&gt;
&lt;h3 id=&quot;ReentrantLock实现原理-3.3.3小结&quot;&gt;3.3.3 小结&lt;/h3&gt;
&lt;p&gt;    用一张流程图总结一下非公平锁的获取锁的过程。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811336/201809/811336-20180917233520814-2039195145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ReentrantLock实现原理-3.4FairSync&quot; class=&quot;diff-block-target diff-block-context&quot;&gt;3.4 FairSync&lt;/h2&gt;
&lt;p&gt;    公平锁和非公平锁不同之处在于，公平锁在获取锁的时候，不会先去检查state状态，而是直接执行aqcuire(1)，这里不再赘述。  &lt;/p&gt;

&lt;p&gt;　　在ReetrantLock的tryLock(long timeout, TimeUnit unit) 提供了超时获取锁的功能。它的语义是在指定的时间内如果获取到锁就返回true，获取不到则返回false。这种机制避免了线程无限期的等待锁释放。那么超时的功能是怎么实现的呢？我们还是用非公平锁为例来一探究竟。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryLock(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; timeout, TimeUnit unit)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; sync.tryAcquireNanos(1&lt;span&gt;, unit.toNanos(timeout));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还是调用了内部类里面的方法。我们继续向前探究：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAcquireNanos(&lt;span&gt;int&lt;/span&gt; arg, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nanosTimeout)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted())
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; tryAcquire(arg) ||&lt;span&gt;
        doAcquireNanos(arg, nanosTimeout);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的语义是：如果线程被中断了，那么直接抛出InterruptedException。如果未中断，先尝试获取锁，获取成功就直接返回，获取失败则进入doAcquireNanos。tryAcquire我们已经看过，这里重点看一下doAcquireNanos做了什么。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 在有限的时间内去竞争锁
 * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 是否获取成功
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; doAcquireNanos(&lt;span&gt;int&lt;/span&gt; arg, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; nanosTimeout)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 起始时间&lt;/span&gt;
    &lt;span&gt;long&lt;/span&gt; lastTime =&lt;span&gt; System.nanoTime();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线程入队&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; Node node =&lt;span&gt; addWaiter(Node.EXCLUSIVE);
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 又是自旋!&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取前驱节点&lt;/span&gt;
            &lt;span&gt;final&lt;/span&gt; Node p =&lt;span&gt; node.predecessor();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果前驱是头节点并且占用锁成功,则将当前节点变成头结点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp;&lt;span&gt; tryAcquire(arg)) {
                setHead(node);
                p.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; help GC&lt;/span&gt;
                failed = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果已经超时,返回false&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (nanosTimeout &amp;lt;= 0&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 超时时间未到,且需要挂起&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;span&gt;
                    nanosTimeout &lt;/span&gt;&amp;gt;&lt;span&gt; spinForTimeoutThreshold)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 阻塞当前线程直到超时时间到期&lt;/span&gt;
                LockSupport.parkNanos(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, nanosTimeout);
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; now =&lt;span&gt; System.nanoTime();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新nanosTimeout&lt;/span&gt;
            nanosTimeout -= now -&lt;span&gt; lastTime;
            lastTime &lt;/span&gt;=&lt;span&gt; now;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Thread.interrupted())
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;相应中断&lt;/span&gt;
                &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InterruptedException();
        }
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (failed)
            cancelAcquire(node);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　doAcquireNanos的流程简述为：线程先入等待队列，然后开始自旋，尝试获取锁，获取成功就返回，失败则在队列里找一个安全点把自己挂起直到超时时间过期。这里为什么还需要循环呢？因为当前线程节点的前驱状态可能不是SIGNAL，那么在当前这一轮循环中线程不会被挂起，然后更新超时时间，开始新一轮的尝试。&lt;/p&gt;
</description>
<pubDate>Mon, 17 Sep 2018 15:45:00 +0000</pubDate>
<dc:creator>卫旗</dc:creator>
<og:description>1 synchronized和lock 1.1 synchronized的局限性 synchronized是java内置的关键字，它提供了一种独占的加锁方式。synchronized的获取和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weiqihome/p/9665718.html</dc:identifier>
</item>
<item>
<title>Netty实现简单HTTP代理服务器 - ZepheryWen</title>
<link>http://www.cnblogs.com/w1570631036/p/9665385.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/w1570631036/p/9665385.html</guid>
<description>&lt;p&gt;自上次使用Openresty+Lua+Nginx的来加速自己的网站，用上了比较时髦的技术，感觉算是让自己的网站响应速度达到极限了，直到看到了Netty，公司就是打算用Netty来替代Openresty这一套，所以，自己也学了好久，琢磨了好一趟才知道怎么用，现在用来写一套HTTP代理服务器吧，之后再测试一下性能。&lt;/p&gt;
&lt;p&gt;之前相关的文章如下：&lt;br/&gt;&lt;a href=&quot;http://www.wenzhihuai.com/getblogdetail.html?blogid=645&quot;&gt;【网页加速】lua redis的二次升级&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/w1570631036/p/8449373.html&quot;&gt;使用Openresty加快网页速度&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一netty中的http&quot;&gt;一、Netty中的HTTP&lt;/h2&gt;
&lt;p&gt;参考自《Netty实战》&lt;/p&gt;
&lt;h4 id=&quot;一个完整的httprequest请求&quot;&gt;一个完整的HttpRequest请求&lt;/h4&gt;
&lt;p&gt;FullHttpRequest:&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/20180917105954482007021.png&quot;/&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;HTTP Request 第一部分是包含的头信息&lt;/li&gt;
&lt;li&gt;HttpContent 里面包含的是数据，可以后续有多个 HttpContent 部分&lt;/li&gt;
&lt;li&gt;LastHttpContent 标记是 HTTP request 的结束，同时可能包含头的尾部信息&lt;/li&gt;
&lt;li&gt;完整的 HTTP request&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;一个完整的httpresponse请求&quot;&gt;一个完整的HttpResponse请求&lt;/h4&gt;
&lt;p&gt;FullHttpResponse:&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/20180917110022386437025.png&quot;/&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;HTTP response 第一部分是包含的头信息&lt;/li&gt;
&lt;li&gt;HttpContent 里面包含的是数据，可以后续有多个 HttpContent 部分&lt;/li&gt;
&lt;li&gt;LastHttpContent 标记是 HTTP response 的结束，同时可能包含头的尾部信息&lt;/li&gt;
&lt;li&gt;完整的 HTTP response&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二netty实现http代理服务器的流程&quot;&gt;二、Netty实现HTTP代理服务器的流程&lt;/h2&gt;
&lt;p&gt;在实现Http代理服务器之前，我们先来查看一下Netty实现代理服务器的完整流程：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/20180909110242297408748.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Netty的Http服务的流程是：&lt;br/&gt;1、Client向Server发送http请求，在通常的情况中，client一般指的是浏览器，也可以由自己用netty实现一个客户端。此时，客户端需要用到HttpRequestEncoder将http请求进行编码。&lt;br/&gt;2、Server端对http请求进行解析，服务端中，需要用到HttpRequestDecoder来对请求进行解码，然后实现自己的业务需求。&lt;br/&gt;3、Server端向client发送http响应，处理完业务需求后，将相应的内容，用HttpResponseEncoder进行编码，返回数据。&lt;br/&gt;4、Client对http响应进行解析，用HttpResponseDecoder进行解码。&lt;/p&gt;
&lt;p&gt;而Netty实现Http代理服务器的过程跟上面的所说无意，只不过是在自己的业务层增加了回源到tomcat服务器这一过程。结合上自己之前实现过的用OpenResty+Nginx来做代理服务器这一套，此处的Netty实现的过程也与此类似。此处粘贴一下OpenResty+Nginx实现的流程图：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upyuncdn.wenzhihuai.com/201862519474.png!/scale/80&quot;/&gt;&lt;/div&gt;
&lt;p&gt;而使用了Netty之后，便是将中间的OpenResty+Nginx换成了Netty，下面我们来看一下具体的实现过程。&lt;/p&gt;
&lt;h2 id=&quot;三主要代码如下&quot;&gt;三、主要代码如下：&lt;/h2&gt;
&lt;h4 id=&quot;httpserver&quot;&gt;HttpServer&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class HttpServer {
    public void start(int port) throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap();
            b.group(bossGroup, workerGroup)
                    .handler(new LoggingHandler(LogLevel.DEBUG))
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
                        @Override
                        public void initChannel(SocketChannel ch)
                                throws Exception {
                            // server端发送的是httpResponse，所以要使用HttpResponseEncoder进行编码
                            ch.pipeline().addLast(
                                    new HttpResponseEncoder());
                            // server端接收到的是httpRequest，所以要使用HttpRequestDecoder进行解码
                            ch.pipeline().addLast(
                                    new HttpRequestDecoder());
                            ch.pipeline().addLast(
                                    new HttpServerHandler());
                            //增加自定义实现的Handler
                            ch.pipeline().addLast(new HttpServerCodec());
                        }
                    }).option(ChannelOption.SO_BACKLOG, 128)
                    .childOption(ChannelOption.SO_KEEPALIVE, true);
            ChannelFuture f = b.bind(port).sync();

            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }

    public static void main(String[] args) throws Exception {
        HttpServer server = new HttpServer();
        server.start(8080);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;httpserverhandler&quot;&gt;HttpServerHandler&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
public class HttpServerHandler extends ChannelInboundHandlerAdapter {

    private RedisUtil redisUtil = new RedisUtil();

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg)
            throws Exception {
        if (msg instanceof HttpRequest) {
            DefaultHttpRequest request = (DefaultHttpRequest) msg;
            String uri = request.uri();
            if (&quot;/favicon.ico&quot;.equals(uri)) {
                return;
            }
            log.info(new Date().toString());
            Jedis jedis = redisUtil.getJedis();
            String s = jedis.get(uri);
            if (s == null || s.length() == 0) {
                //这里我们的处理是回源到tomcat服务器进行抓取，然后
                //将抓取的内容放回到redis里面
                try {
                    URL url = new URL(&quot;http://119.29.188.224:8080&quot; + uri);
                    log.info(url.toString());
                    URLConnection urlConnection = url.openConnection();
                    HttpURLConnection connection = (HttpURLConnection) urlConnection;
                    connection.setRequestMethod(&quot;GET&quot;);
                    //连接
                    connection.connect();
                    //得到响应码
                    int responseCode = connection.getResponseCode();
                    if (responseCode == HttpURLConnection.HTTP_OK) {
                        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader
                                (connection.getInputStream(), StandardCharsets.UTF_8));
                        StringBuilder bs = new StringBuilder();
                        String l;
                        while ((l = bufferedReader.readLine()) != null) {
                            bs.append(l).append(&quot;\n&quot;);
                        }
                        s = bs.toString();
                    }
                    jedis.set(uri, s);
                    connection.disconnect();
                } catch (Exception e) {
                    log.error(&quot;&quot;, e);
                    return;
                }
            }
            jedis.close();
            FullHttpResponse response = new DefaultFullHttpResponse(
                    HTTP_1_1, OK, Unpooled.wrappedBuffer(s != null ? s
                    .getBytes() : new byte[0]));
            response.headers().set(CONTENT_TYPE, &quot;text/html&quot;);
            response.headers().set(CONTENT_LENGTH,
                    response.content().readableBytes());
            response.headers().set(CONNECTION, HttpHeaderValues.KEEP_ALIVE);
            ctx.write(response);
            ctx.flush();
        } else {
            //这里必须加抛出异常，要不然ab测试的时候一直卡住不动，暂未解决
            throw new Exception();
        }
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        ctx.flush();
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
            throws Exception {
        ctx.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四性能测试&quot;&gt;四、性能测试&lt;/h2&gt;
&lt;p&gt;下面的是ab测试，在1GHz、2G内存的centos7机器（阿里云服务器）下进行测试，测试命令ab -c 100 -n 10000 localhost:8000/，并发数为100，总数为10000。&lt;/p&gt;
&lt;p&gt;性能：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/201809171028141608056843.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;整体响应时间的分布比（单位：ms）：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://image.wenzhihuai.com/images/201809171028471308532170.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;看完之后，我自己也震惊了，Netty实现的不仅稳定、吞吐率还比OpenResty的高出一倍，OpenResty的居然还有那么多的失败次数，不知是不是我的代码的问题还是测试例子不规范，至今，我还是OpenResty的脑残粉。总体的来说，Netty实现的服务器性能还是比较强的，不仅能够快速地开发高性能的面向协议的服务器和客户端，还可以在Netty上轻松实现各种自定义的协议。&lt;/p&gt;
&lt;h2 id=&quot;五源码地址&quot;&gt;五、源码地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Zephery/myway&quot; class=&quot;uri&quot;&gt;https://github.com/Zephery/myway&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;《Netty实战》&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/wangshuang1631/article/details/73251180/&quot;&gt;基于Netty4构建HTTP服务----浏览器访问和Netty客户端访问&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 17 Sep 2018 15:43:00 +0000</pubDate>
<dc:creator>ZepheryWen</dc:creator>
<og:description>自上次使用Openresty+Lua+Nginx的来加速自己的网站，用上了比较时髦的技术，感觉算是让自己的网站响应速度达到极限了，直到看到了Netty，公司就是打算用Netty来替代Openresty</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/w1570631036/p/9665385.html</dc:identifier>
</item>
<item>
<title>Kail更新源、输入法、浏览器 - ZTZ-99</title>
<link>http://www.cnblogs.com/lwenwu/p/9665679.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwenwu/p/9665679.html</guid>
<description>&lt;h3&gt;&lt;span&gt;更新源&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;kali官方的更新源：图中的&lt;span lang=&quot;EN-US&quot;&gt;kali-rolling是&lt;span lang=&quot;EN-US&quot;&gt;kali目前最新的代号，&lt;span lang=&quot;EN-US&quot;&gt;kali有两个代号&lt;span lang=&quot;EN-US&quot;&gt;(codename)：&lt;span lang=&quot;EN-US&quot;&gt;sana和&lt;span lang=&quot;EN-US&quot;&gt;kali-rolling；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917232800155-2028603352.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看自己的&lt;span lang=&quot;EN-US&quot;&gt;kali linux源版本：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917232826614-643046054.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改&lt;span lang=&quot;EN-US&quot;&gt;sources.list文件：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;vim /etc/apt/sources.list&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后选择添加以下源：&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#中科大&lt;span lang=&quot;EN-US&quot;&gt;kali源 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;deb http://mirrors.ustc.edu.cn/kali kali main non-free contrib&lt;br/&gt;deb-src http://mirrors.ustc.edu.cn/kali kali main non-free contrib&lt;br/&gt;deb http://mirrors.ustc.edu.cn/kali-security kali/updates main contrib non-free&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#新加坡&lt;span lang=&quot;EN-US&quot;&gt;kali源 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;deb http://mirror.nus.edu.sg/kali/kali/ kali main non-free contrib&lt;br/&gt;deb-src http://mirror.nus.edu.sg/kali/kali/ kali main non-free contrib&lt;br/&gt;deb http://security.kali.org/kali-security kali/updates main contrib non-free&lt;br/&gt;deb http://mirror.nus.edu.sg/kali/kali-security kali/updates main contrib non-free&lt;br/&gt;deb-src http://mirror.nus.edu.sg/kali/kali-security kali/updates main contrib non-free&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#阿里云&lt;span lang=&quot;EN-US&quot;&gt;kali源 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;deb http://mirrors.aliyun.com/kali kali main non-free contrib&lt;br/&gt;deb-src http://mirrors.aliyun.com/kali kali main non-free contrib&lt;br/&gt;deb http://mirrors.aliyun.com/kali-security kali/updates main contrib non-free&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#163 Kali源 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;deb http://mirrors.163.com/debian wheezy main non-free contrib&lt;br/&gt;deb-src http://mirrors.163.com/debian wheezy main non-free contrib&lt;br/&gt;deb http://mirrors.163.com/debian wheezy-proposed-updates main non-free contrib&lt;br/&gt;deb-src http://mirrors.163.com/debian wheezy-proposed-updates main non-free contrib&lt;br/&gt;deb-src http://mirrors.163.com/debian-security wheezy/updates main non-free contrib&lt;br/&gt;deb http://mirrors.163.com/debian-security wheezy/updates main non-free contrib&lt;br/&gt;#auto&lt;br/&gt;deb http://http.kali.org/kali kali-rolling main non-free contrib&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#中科大 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib&lt;br/&gt;deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#浙大 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free&lt;br/&gt;deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#东软大学 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib&lt;br/&gt;deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#重庆大学 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;deb http://http.kali.org/kali kali-rolling main non-free contrib&lt;br/&gt;deb-src http://http.kali.org/kali kali-rolling main non-free contrib&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;#官方源 &lt;span lang=&quot;EN-US&quot;&gt;&lt;br/&gt;#deb http://http.kali.org/kali kali-rolling main non-free contrib&lt;br/&gt;#deb-src http://http.kali.org/kali kali-rolling main non-free contrib&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;更新操作系统&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;apt-get update&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装完成第一条执行的命令也是必须执行的命令，刷新系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;apt-get upgrade 升级系统上安装的所有软件包，升级不成功回滚到原状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917232852344-1800511988.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;apt-get dist-upgrade升级整个&lt;span lang=&quot;EN-US&quot;&gt;Kali Linux系统，跨版本升级的方式，不仅可以升级所有软件包，还可以解决升级过程中可能出现的软件冲突。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917232917930-2112809638.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：提示是否？、继续执行升级过程？并显示需要升级的大小及额外需要的空间大小。直接回车。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：第一次更新完成再次执行更新源的命令，确保所有软件保持最新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;Kali更新内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917232931741-1873251415.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更新完成按&lt;span lang=&quot;EN-US&quot;&gt;q键完成安装。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;安装中文输入法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;apt-get install ibus ibus-libpinyin&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后重启操作系统，点击桌面右上角的设置&lt;span lang=&quot;EN-US&quot;&gt;&amp;gt;区域和语言，在输入源中添加汉语（拼音）即可：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917232948098-2129700382.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过快捷键&lt;span lang=&quot;EN-US&quot;&gt;Win+Space（空格）即可切换输入法进行输入。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;浏览器更改语言&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;1、 打开终端，输入 &lt;span lang=&quot;EN-US&quot;&gt;apt -y install firefox-esr-l10n-zh-cn，（下载安装语言包）。&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917233008439-1779589911.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;2、 打开火狐浏览器，选择右上角的菜单，选择“&lt;span lang=&quot;EN-US&quot;&gt;Preferences（首选项）”。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917233044892-1924452507.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt;3、 选择“内容”&lt;span lang=&quot;EN-US&quot;&gt;--&amp;gt;在语言栏点击“选择”，选择“中文&lt;span lang=&quot;EN-US&quot;&gt;/中国 &lt;span lang=&quot;EN-US&quot;&gt;[zh-cn]”，点击“确定”，重启浏览器即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;EN-US&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917233107166-174192432.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917233143360-768723473.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1488047/201809/1488047-20180917233153081-2069491343.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 17 Sep 2018 15:34:00 +0000</pubDate>
<dc:creator>ZTZ-99</dc:creator>
<og:description>更新源 kali官方的更新源：图中的kali-rolling是kali目前最新的代号，kali有两个代号(codename)：sana和kali-rolling； 查看自己的kali linux源版本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwenwu/p/9665679.html</dc:identifier>
</item>
<item>
<title>设计模式之单利模式（C#语言描述，附视频下载地址） - 猫咪闯天下</title>
<link>http://www.cnblogs.com/caoruipeng/p/9665534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caoruipeng/p/9665534.html</guid>
<description>&lt;p&gt;今天来介绍所有设计模式中结构最简单的设计模式&lt;strong&gt;单例模式&lt;/strong&gt;，它的核心结构中只包含一个被称为单例类的特殊类。&lt;/p&gt;
&lt;p&gt;要想完成单例类的设计，我们要遵循一下原则即可：&lt;/p&gt;
&lt;p&gt;1、一个类只能有一个实例&lt;/p&gt;
&lt;p&gt;2、确保该实例对外有一个访问入口（保证我们的系统可以从这个入口拿到该类的唯一实例）&lt;/p&gt;
&lt;p&gt;3、将单例类的构造函数私有化（private），当构造函数被私有化之后，外部无法通过&lt;strong&gt;new 单例类()&lt;/strong&gt;的方法来实例化该类。既然外部无法直接实例化该类，那就要求该类的实例要自己去创建了~&lt;/p&gt;
&lt;p&gt;下面我们先看一个最简单的单例类的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    /// &amp;lt;summary&amp;gt;
    /// 单例类
    /// &amp;lt;/summary&amp;gt;
    public class Singleton
    {
        private Singleton instance = null;
        //构造函数私有化
        private Singleton()
        {
 
        }
        //外部通过该类的唯一入口（GetInstance方法）获得单例类的实例
        public Singleton GetInstance()
        {
            if (instance == null)
                instance = new Singleton();
            return instance;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实上面的代码只是简单的介绍单例类的写法，下面我们来介绍一下饿汉式单例和懒汉式单例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    /// &amp;lt;summary&amp;gt;
    /// 饿汉式单例类
    /// &amp;lt;/summary&amp;gt;
    public class Singleton
    {
        private static Singleton instance = new Singleton();
        //构造函数私有化
        private Singleton()
        {
 
        }
        //外部通过该类的唯一入口（GetInstance方法）获得单例类的实例
        public Singleton GetInstance()
        {
            return instance;
        }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;饿汉式单例类在类初始化的时候，直接new了一个单例类的实例并赋值给静态私有变量，因为静态变量归类所有，所以程序自始至终只会有一个实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、懒汉式单例类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的代码看上去很完美，并没有什么问题。但是大家可以想一个问题，在高并发大流量的情况下，如果多个应用程序对该类进行实例化时（并发调用GetInstance方法时），有可能会导致单例类创建多个实例。所以，为了解决并发创建多个实例的问题，我们可以对实例的创建过程加锁。这就衍生出来了懒汉式单例类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    /// &amp;lt;summary&amp;gt;
    /// 懒汉式单例类（高并发处理）
    /// &amp;lt;/summary&amp;gt;
    public class Singleton
    {
        private static Singleton instance = null;
        private static readonly object syncRoot = new object();
        //构造函数私有化
        private Singleton()
        {
 
        }
        //外部通过该类的唯一入口（GetInstance方法）获得单例类的实例
        public static Singleton GetInstance()
        {
            if (instance == null)
            {
                lock (syncRoot)//加锁之后只允许单线程访问，但是此处可能有其他的并发现成在此处等待执行
                {
                    //因为锁外面有可能并发线程在等待执行，为了防止线程实例化类之后，后面的线程继续实例化对象，应该在加一层判断
                    if (instance == null)
                    {
                        instance = new Singleton();
                    }
                }
            }
            return instance;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　视频学习下载地址：&lt;a href=&quot;http://www.seekwd.com/article/details/4072&quot; target=&quot;_blank&quot;&gt;单例模式&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 17 Sep 2018 15:22:00 +0000</pubDate>
<dc:creator>猫咪闯天下</dc:creator>
<og:description>今天来介绍所有设计模式中结构最简单的设计模式单例模式，它的核心结构中只包含一个被称为单例类的特殊类。 要想完成单例类的设计，我们要遵循一下原则即可： 1、一个类只能有一个实例 2、确保该实例对外有一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/caoruipeng/p/9665534.html</dc:identifier>
</item>
</channel>
</rss>