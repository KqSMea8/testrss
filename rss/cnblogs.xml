<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Net Core集成Exceptionless分布式日志功能以及全局异常过滤 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/9339017.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/9339017.html</guid>
<description>&lt;blockquote readability=&quot;7.2727272727273&quot;&gt;
&lt;p&gt;相信很多朋友都看过我的上篇关于Exceptionless的简单入门教程[asp.Net Core免费开源分布式异常日志收集框架Exceptionless安装配置以及简单使用图文教程][&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9193723.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/9193723.html&lt;/a&gt;] 上篇文章只是简单的介绍了Exceptionless是什么？能做什么呢？以及怎么进行本地部署和异常提交的简单用法，而这篇文章将带你探讨一下Exceptionless的异常收集高级用法以及你熟悉的类似NLog的日志用法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇文章有一部分内容翻译自官方文档，[点我阅读][&lt;a href=&quot;https://github.com/exceptionless/Exceptionless.Net/wiki/Sending-Events&quot; class=&quot;uri&quot;&gt;https://github.com/exceptionless/Exceptionless.Net/wiki/Sending-Events&lt;/a&gt;] 英语好的可以自行阅读 。当然中间很多代码我都进行了重构，还有参考周旭龙的代码，进行了简单地封装，同时加入了为webapi加入异常全局过滤器进行异常日志的记录。希望对大家有所帮助。&lt;/p&gt;
&lt;blockquote readability=&quot;2.125&quot;&gt;
&lt;p&gt;本文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9339017.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/9339017.html&lt;/a&gt;&lt;br/&gt;作者：依乐祝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;手动发送错误&quot;&gt;手动发送错误&lt;/h3&gt;
&lt;p&gt;上篇文章介绍了，导入命名空间后，并使用如下代码就可以简单地提交异常日志：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;try {
    throw new ApplicationException(Guid.NewGuid().ToString());
} catch (Exception ex) {
    ex.ToExceptionless().Submit();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;发送附加信息&quot;&gt;发送附加信息&lt;/h3&gt;
&lt;p&gt;当然你还可以为发送的事件添加额外的标记信息，比如坐标，标签，以及其他的用户相关的信息等等&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;try {
    throw new ApplicationException(&quot;Unable to create order from quote.&quot;);
} catch (Exception ex) {
    ex.ToExceptionless()
        // 设置一个ReferenceId方便查找
        .SetReferenceId(Guid.NewGuid().ToString(&quot;N&quot;))
        // 添加一个不包含CreditCardNumber属性的对象信息
        .AddObject(order, &quot;Order&quot;, excludedPropertyNames: new [] { &quot;CreditCardNumber&quot; }, maxDepth: 2)
        // 设置一个名为&quot;Quote&quot;的编号
        .SetProperty(&quot;Quote&quot;, 123)
        // 添加一个名为“Order”的标签
        .AddTags(&quot;Order&quot;)
        //  标记为关键异常
        .MarkAsCritical()
        // 设置一个位置坐标
        .SetGeo(43.595089, -88.444602)
        // 在你的系统中设置userid并提供一个有好的名字，俗称昵称
        .SetUserIdentity(user.Id, user.FullName)
        // 为异常信息添加一些用户描述信息.
        .SetUserDescription(user.EmailAddress, &quot;I tried creating an order from my saved quote.&quot;)
        // 提交.
        .Submit();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;统一修改未处理的异常报告&quot;&gt;统一修改未处理的异常报告&lt;/h3&gt;
&lt;p&gt;你可以在通过SubmittingEvent 事件设置全局的忽略异常信息添加一些自定义信息等等&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;
 #region Exceptionless配置
            ExceptionlessClient.Default.Configuration.ApiKey = exceptionlessOptions.Value.ApiKey;
            ExceptionlessClient.Default.Configuration.ServerUrl = exceptionlessOptions.Value.ServerUrl;
            ExceptionlessClient.Default.SubmittingEvent += OnSubmittingEvent;
            app.UseExceptionless();
#endregion

 /// &amp;lt;summary&amp;gt;
        /// 全局配置Exceptionless
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;sender&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;e&quot;&amp;gt;&amp;lt;/param&amp;gt;
        private void OnSubmittingEvent(object sender, EventSubmittingEventArgs e)
        {
            // 只处理未处理的异常
            if (!e.IsUnhandledError)
                return;

            // 忽略404错误
            if (e.Event.IsNotFound())
            {
                e.Cancel = true;
                return;
            }

            // 忽略没有错误体的错误
            var error = e.Event.GetError();
            if (error == null)
                return;
            // 忽略 401 (Unauthorized) 和 请求验证的错误.
            if (error.Code == &quot;401&quot; || error.Type == &quot;System.Web.HttpRequestValidationException&quot;)
            {
                e.Cancel = true;
                return;
            }
            // Ignore any exceptions that were not thrown by our code.
            var handledNamespaces = new List&amp;lt;string&amp;gt; { &quot;Exceptionless&quot; };
            if (!error.StackTrace.Select(s =&amp;gt; s.DeclaringNamespace).Distinct().Any(ns =&amp;gt; handledNamespaces.Any(ns.Contains)))
            {
                e.Cancel = true;
                return;
            }
            // 添加附加信息.
            //e.Event.AddObject(order, &quot;Order&quot;, excludedPropertyNames: new[] { &quot;CreditCardNumber&quot; }, maxDepth: 2);
            e.Event.Tags.Add(&quot;MunicipalPublicCenter.BusinessApi&quot;);
            e.Event.MarkAsCritical();
            //e.Event.SetUserIdentity();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配合使用-nlog-或-log4net&quot;&gt;配合使用 NLog 或 Log4Net&lt;/h3&gt;
&lt;p&gt;有时候，程序中需要对日志信息做非常详细的记录，比如在开发阶段。这个时候可以配合 log4net 或者 nlog 来联合使用 exceptionless，详细可以查看这个官方的 [示例][&lt;a href=&quot;https://github.com/exceptionless/Exceptionless.Net/tree/master/samples/Exceptionless.SampleConsole&quot; class=&quot;uri&quot;&gt;https://github.com/exceptionless/Exceptionless.Net/tree/master/samples/Exceptionless.SampleConsole&lt;/a&gt;]。&lt;/p&gt;
&lt;p&gt;如果你的程序中有在短时间内生成大量日志的情况，比如一分钟产生上千的日志。这个时候你需要使用内存存储（in-memory store）事件，这样客户端就不会将事件系列化的磁盘，所以会快很多。这样就可以使用Log4net 或者 Nlog来将一些事件存储到磁盘，另外 Exceptionless 事件存储到内存当中。&lt;/p&gt;
&lt;h3 id=&quot;exceptionless-日志记录的封装&quot;&gt;Exceptionless 日志记录的封装&lt;/h3&gt;
&lt;ol readability=&quot;25&quot;&gt;&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;首先简单地封装一个ILoggerHelper接口&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
    /// lzhu
    /// 2018.7.19
    /// 日志接口
    /// &amp;lt;/summary&amp;gt;
    public interface ILoggerHelper
    {
        /// &amp;lt;summary&amp;gt;
        /// 记录trace日志
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;source&quot;&amp;gt;信息来源&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志内容&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;args&quot;&amp;gt;标记&amp;lt;/param&amp;gt;
        void Trace(string source, string message, params string[] args);
        /// &amp;lt;summary&amp;gt;
        /// 记录debug信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;source&quot;&amp;gt;信息来源&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志内容&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;args&quot;&amp;gt;标记&amp;lt;/param&amp;gt;
        void Debug(string source, string message, params string[] args);
        /// &amp;lt;summary&amp;gt;
        /// 记录信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;source&quot;&amp;gt;信息来源&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志内容&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;args&quot;&amp;gt;标记&amp;lt;/param&amp;gt;
        void Info(string source, string message, params string[] args);
        /// &amp;lt;summary&amp;gt;
        /// 记录警告日志
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;source&quot;&amp;gt;信息来源&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志内容&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;args&quot;&amp;gt;标记&amp;lt;/param&amp;gt;
        void Warn(string source, string message, params string[] args);
        /// &amp;lt;summary&amp;gt;
        /// 记录错误日志
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;source&quot;&amp;gt;信息来源&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志内容&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;args&quot;&amp;gt;标记&amp;lt;/param&amp;gt;
        void Error(string source, string message, params string[] args);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;34&quot;&gt;
&lt;p&gt;既然有了接口，那么当然得实现它了&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
    /// lzhu
    /// 2018.7.19
    /// Exceptionless日志实现
    /// &amp;lt;/summary&amp;gt;
    public class ExceptionlessLogger : ILoggerHelper
    {
        /// &amp;lt;summary&amp;gt;
        /// 记录trace日志
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;source&quot;&amp;gt;信息来源&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志内容&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;args&quot;&amp;gt;添加标记&amp;lt;/param&amp;gt;
        public void Trace(string source,string message, params string[] args)
        {
            if (args != null &amp;amp;&amp;amp; args.Length &amp;gt; 0)
            {
                ExceptionlessClient.Default.CreateLog(source, message, LogLevel.Trace).AddTags(args).Submit();

            }
            else
            {
                ExceptionlessClient.Default.SubmitLog(source, message, LogLevel.Trace);
            }
        }
        /// &amp;lt;summary&amp;gt;
        /// 记录debug信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;source&quot;&amp;gt;信息来源&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志内容&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;args&quot;&amp;gt;标记&amp;lt;/param&amp;gt;
        public void Debug(string source, string message, params string[] args)
        {
            if (args != null &amp;amp;&amp;amp; args.Length &amp;gt; 0)
            {
                ExceptionlessClient.Default.CreateLog(source, message, LogLevel.Debug).AddTags(args).Submit();
            }
            else
            {
                ExceptionlessClient.Default.SubmitLog(source, message, LogLevel.Debug);
            }
        }
        /// &amp;lt;summary&amp;gt;
        /// 记录信息
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;source&quot;&amp;gt;信息来源&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志内容&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;args&quot;&amp;gt;标记&amp;lt;/param&amp;gt;
        public void Info(string source, string message, params string[] args)
        {
            if (args != null &amp;amp;&amp;amp; args.Length &amp;gt; 0)
            {
                ExceptionlessClient.Default.CreateLog(source, message, LogLevel.Info).AddTags(args).Submit();
            }
            else
            {
                ExceptionlessClient.Default.SubmitLog(source, message, LogLevel.Info);
            }
        }
        /// &amp;lt;summary&amp;gt;
        /// 记录警告日志
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;source&quot;&amp;gt;信息来源&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志内容&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;args&quot;&amp;gt;标记&amp;lt;/param&amp;gt;
        public void Warn(string source, string message, params string[] args)
        {
            if (args != null &amp;amp;&amp;amp; args.Length &amp;gt; 0)
            {
                ExceptionlessClient.Default.CreateLog(source, message, LogLevel.Warn).AddTags(args).Submit();
            }
            else
            {
                ExceptionlessClient.Default.SubmitLog(source, message, LogLevel.Warn);
            }
        }
        /// &amp;lt;summary&amp;gt;
        /// 记录错误日志
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;source&quot;&amp;gt;信息来源&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;message&quot;&amp;gt;日志内容&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;args&quot;&amp;gt;标记&amp;lt;/param&amp;gt;
        public void Error(string source, string message, params string[] args)
        {
            if (args != null &amp;amp;&amp;amp; args.Length &amp;gt; 0)
            {
                ExceptionlessClient.Default.CreateLog(source, message, LogLevel.Error).AddTags(args).Submit();
            }
            else
            {
                ExceptionlessClient.Default.SubmitLog(source, message, LogLevel.Error);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当然实现好了，可别忘了依赖注入哦&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; //注入ExceptionlessLogger服务
            services.AddSingleton&amp;lt;ILoggerHelper, ExceptionlessLogger&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;12&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;这时候该写一个全局异常过滤器了&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
    /// lzhu
    /// 2018.7.19
    /// 定义全局过滤器
    /// &amp;lt;/summary&amp;gt;
    public class GlobalExceptionFilter : IExceptionFilter
    {

        private readonly ILoggerHelper _loggerHelper;
        //构造函数注入ILoggerHelper
        public GlobalExceptionFilter(ILoggerHelper loggerHelper)
        {
            _loggerHelper = loggerHelper;
        }

        public void OnException(ExceptionContext filterContext)
        {
            _loggerHelper.Error(filterContext.Exception.TargetSite.GetType().FullName, filterContext.Exception.ToString(), MpcKeys.GlobalExceptionCommonTags, filterContext.Exception.GetType().FullName);
            var result = new BaseResult()
            {
                errcode = ResultCodeAddMsgKeys.CommonExceptionCode,//系统异常代码
                errmsg= ResultCodeAddMsgKeys.CommonExceptionMsg,//系统异常信息
            };
            filterContext.Result = new ObjectResult(result);
            filterContext.HttpContext.Response.StatusCode = (int)HttpStatusCode.InternalServerError;
            filterContext.ExceptionHandled = true;
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;全局过滤器写好了，怎么让它生效呢，客观别急啊，上正菜&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  //添加验证
            services.AddMvc(options=&amp;gt; {
                options.Filters.Add&amp;lt;GlobalExceptionFilter&amp;gt;();
            }).AddFluentValidation();&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;哈哈，没什么说的了，代码都已经写好了，剩下的就是上代码测试结果了。我这里只是简单地api测试下，万能的ValuesController登场：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; // GET api/values/5
        [HttpGet(&quot;{id}&quot;)]
        public ActionResult&amp;lt;string&amp;gt; Get(int id)
        {
            //try
            //{
            throw new Exception($&quot;测试抛出的异常{id}&quot;);
            //}
            //catch (Exception ex)
            //{
            //    ex.ToExceptionless().Submit();
            //}
            //return &quot;Unknown Error!&quot;;

        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是直接抛出异常，不进行trycatch,这时候异常会被全局过滤器捕获，然后放到Exceptionless的Log里面，别问我为什么会在log里面，因为我全局过滤器代码里面已经写明了，不明白的回去看代码，然后看接口调用的实现方法。下面上结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201807/1377250-20180719230822995-1262896673.png&quot; alt=&quot;1532012181451&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;点进去，看看详细信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201807/1377250-20180719230822444-554363347.png&quot; alt=&quot;1532012249948&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;4.7964601769912&quot;&gt;&lt;li readability=&quot;12.470796460177&quot;&gt;
&lt;p&gt;再测试下使用try catch捕获的异常处理，这时候异常信息会被提交到Exception这个里面。直接上代码吧&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// GET api/values/5
        [HttpGet(&quot;{id}&quot;)]
        public ActionResult&amp;lt;string&amp;gt; Get(int id)
        {
            try
            {
                throw new Exception($&quot;测试抛出的异常{id}&quot;);
            }
            catch (Exception ex)
            {
                ex.ToExceptionless().Submit();
            }
            return &quot;Unknown Error!&quot;;

        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到exceptionless里面看看不活的异常吧。打字很累直接上图吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201807/1377250-20180719230821803-1365020670.png&quot; alt=&quot;1532012444443&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点进去看看详细信息，有三个tab，下面之粘贴一个图片了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1377250/201807/1377250-20180719230821285-1959372186.png&quot; alt=&quot;1532012508157&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;最后源码就不上了因为上面代码很清楚了&quot;&gt;最后，源码就不上了，因为上面代码很清楚了&lt;/h3&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本文没有对Exceptionless进行过多地介绍，因为博主的[上篇文章][&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9193723.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/9193723.html&lt;/a&gt;] 已经进行了详细的介绍。直接切入正题，先对官方高级用法进行了简单地翻译。然后对Exceptionless Log这个eventtype进行了简单地封装，让你可以像使用NLog一样很爽的使用Exceptionless。最后通过一个asp.net core web api的项目进行了演示，在全局过滤器中利用封装的Log方法进行全局异常的捕获。希望对大家使用Exceptionless有所帮助。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 19 Jul 2018 23:26:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/9339017.html</dc:identifier>
</item>
<item>
<title>优雅的类写法 - 我是leon</title>
<link>http://www.cnblogs.com/walls/p/9339300.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/walls/p/9339300.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;虽然现在已经是ES6的时代，但是，还是有必要了解下ES5是怎么写一个类的。&lt;br/&gt;本文详述JavaScript面向对象编程中的类写法，并分步骤讲述如何写出优雅的类。&lt;/p&gt;
&lt;h2 id=&quot;一例子&quot;&gt;一、例子&lt;/h2&gt;
&lt;p&gt;例子为一个轻提示组件&lt;code&gt;Toast&lt;/code&gt;。&lt;br/&gt;需要实现的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;on&lt;/code&gt;方法，显示提示&lt;/li&gt;
&lt;li&gt;&lt;code&gt;off&lt;/code&gt;方法，隐藏提示&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init&lt;/code&gt;方法，初始化提示语&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Toast(option){
  this.prompt = '';
  this.elem = null;
  this.init(option);
}

Toast.prototype = {
  // 构造器
  constructor: Toast,
  // 初始化方法
  init: function(option){
    this.prompt = option.prompt || '';
    this.render();
    this.bindEvent();
  },
  // 显示
  show: function(){
    this.changeStyle(this.elem, 'display', 'block');
  },
  // 隐藏
  hide: function(){
    this.changeStyle(this.elem, 'display', 'none');
  },
  // 画出dom
  render: function(){
    var html = '';
    this.elem = document.createElement('div');
    this.changeStyle(this.elem, 'display', 'none');

    html += '&amp;lt;a class=&quot;J-close&quot; href=&quot;javascript:;&quot;&amp;gt;x&amp;lt;/a&amp;gt;'
    html += '&amp;lt;p&amp;gt;'+ this.prompt +'&amp;lt;/p&amp;gt;';
    
    this.elem.innerHTML = html;

    return document.body.appendChild(this.elem);
  },
  // 绑定事件
  bindEvent: function(){
    var self = this;
    
    this.addEvent(this.elem, 'click', function(e){
      if(e.target.className.indexOf('J-close') != -1){
        console.log('close Toast!');
        self.hide();
      }
    });
  },
  // 添加事件方法
  addEvent: function(node, name, fn){
    var self = this;
    
    node.addEventListener(name, function(){
      fn.apply(self, Array.prototype.slice.call(arguments));
    }, false);
  },
  // 改变样式
  changeStyle: function(node, key, value){
      node.style[key] = value;
  }
};

var T = new Toast({prompt:'I\'m Toast!'});
T.show();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二类的构成&quot;&gt;二、类的构成&lt;/h2&gt;
&lt;p&gt;JavaScript的类，是用&lt;code&gt;函数对象&lt;/code&gt;来实现。&lt;br/&gt;类的实例化形式如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var T = new Toast();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的重点，就是&lt;code&gt;Function&lt;/code&gt;的编写。&lt;/p&gt;
&lt;p&gt;类分为两部分：&lt;code&gt;constructor&lt;/code&gt;+&lt;code&gt;prototype&lt;/code&gt;。也即&lt;code&gt;构造器&lt;/code&gt;+&lt;code&gt;原型&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;构造器&quot;&gt;2.1 构造器&lt;/h3&gt;
&lt;p&gt;构造器从直观上来理解，就是写在&lt;strong&gt;函数内部的代码&lt;/strong&gt;。&lt;br/&gt;从Toast例子上看，构造器就是以下部分：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Toast(option){
  this.prompt = '';
  this.elem = null;
  this.init(option);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;this&lt;/code&gt;,指向的是实例化的类。&lt;br/&gt;每次通过&lt;code&gt;new Toast()&lt;/code&gt;的方式进行实例化，&lt;strong&gt;构造器都会执行一遍&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;原型&quot;&gt;2.2 原型&lt;/h3&gt;
&lt;p&gt;原型上的方法和变量的声明，都是通过&lt;code&gt;Toast.prototype.*&lt;/code&gt;的方式。&lt;br/&gt;那么在原型上普通的写法如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;Toast.prototype.hide = function(){/*code*/}
Toast.prototype.myValue = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，该写法不好的地方：就是每次都要写前半部分&lt;code&gt;Toast.prorotype&lt;/code&gt;，略显累赘。&lt;br/&gt;在代码压缩优化方面也不友好，无法做到最佳的压缩。&lt;br/&gt;改进的方式如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;Toast.prorotype = {
  constructor: Toast,
  hide: function(){/*code*/},
  myValue: 1 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的优化，是把原型指向一个新的空对象&lt;code&gt;{}&lt;/code&gt;。&lt;br/&gt;带来的好处，就是可以用&lt;code&gt;{key:value}&lt;/code&gt;的方式写原型上的方法和变量。&lt;br/&gt;但是，这种方式会改变原型上构造器&lt;code&gt;prototype.constructor&lt;/code&gt;的指向。&lt;br/&gt;如果不重新显式声明&lt;code&gt;constructor&lt;/code&gt;的指向，&lt;code&gt;Toast.constructor.prototype.constructor&lt;/code&gt;的会隐式被指向&lt;code&gt;Object&lt;/code&gt;。而正确的指向，应该是&lt;code&gt;Toast&lt;/code&gt;。&lt;br/&gt;虽然通过&lt;code&gt;new&lt;/code&gt;实例化没有出现异常，但是在类继承方面，&lt;code&gt;constructor&lt;/code&gt;的指向异常，会产生不正确的继承判断结果。这是我们不希望看到的。&lt;br/&gt;所以，需要修正&lt;code&gt;constructor&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;构造器和原型的不同&quot;&gt;2.3 构造器和原型的不同&lt;/h3&gt;
&lt;p&gt;原型上的方法和变量，是该类所有实例化对象&lt;strong&gt;共享&lt;/strong&gt;的。也就是说，只有一份。&lt;br/&gt;而构造器内的代码块，则是每个实例化对象&lt;strong&gt;单独占有&lt;/strong&gt;。不管是否用&lt;code&gt;this.**&lt;/code&gt;方式，还是私有变量的方式，都是独占的。&lt;br/&gt;所以，在写一个类的时候，需要考虑该新增属性是共享的，还是独占的。以此，决定在构造器还是原型上进行声明。&lt;/p&gt;
&lt;h2 id=&quot;三代码规范&quot;&gt;三、代码规范&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;类的命名规范，业界有不成文的规定，就是首字母大写。&lt;/li&gt;
&lt;li&gt;原型上的私有方法，默认以下划线开始。这种只是团队合作方面有review代码的好处，实际上还是暴露出来的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四使实例化与new无关&quot;&gt;四、使实例化与new无关&lt;/h2&gt;
&lt;p&gt;类的实例化，一个强制要求的行为，就是需要使用new操作符。如果不使用new操作符，那么构造器内的this指向，将不是当前的实例化对象。&lt;br/&gt;优化的方式，就是使用&lt;code&gt;instanceof&lt;/code&gt;做一层防护。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Toast(option){
  if(!(this instanceof Toast)){
    return new Toast(option);
  }
  
  this.prompt = '';
  this.elem = null;
  this.init(option);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述代码可以看出，使用这个技巧，可以防止团队一些大头虾出现使用错误实例化方式，导致代码污染的问题。&lt;br/&gt;这种忍者技巧很酷，但从另一方面考虑，还是希望使用者可以用正确的方式去实例化类。&lt;br/&gt;所以，改成以下这种防护方式&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function Toast(option){
  if(!(this instanceof Toast)){
    throw new Error('Toast instantiation error');
  }
  
  this.prompt = '';
  this.elem = null;
  this.init(option);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，把锅甩回去，岂不是更妙👽&lt;/p&gt;
</description>
<pubDate>Thu, 19 Jul 2018 17:35:00 +0000</pubDate>
<dc:creator>我是leon</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/walls/p/9339300.html</dc:identifier>
</item>
<item>
<title>4.ASP.NET全栈开发之在MVC中使用服务端验证（二） - Gxqsd</title>
<link>http://www.cnblogs.com/Gxqsd/p/9339219.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Gxqsd/p/9339219.html</guid>
<description>
&lt;p&gt;首先声明，这篇博文是完善.ASP.NET全栈开发之在MVC中使用服务端验证 的，所以重复内容，我就不过多的阐述，很多问题都是在实践中去发现，然后再去完善，这篇博文也一样，建立在已阅 “.ASP.NET全栈开发之在MVC中使用服务端验证” 的基础上。&lt;/p&gt;
&lt;p&gt;在上一篇中，虽然我们完成了服务端验证，但我们还是需要在Action里调用验证器来进行验证，像这样。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult ValidatorTest(Person model)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ValidatorHub.PersonValidator.Validate(model);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.IsValid)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Redirect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ValidatorErrorHandler(result);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很可恶，如果我需要验证，我需要在每一个Action 里像这样写，一次实验也就罢了，如果真要在每个Action里像这样干，我想到时候你一定会很讨厌这些代码的。至少我是这样认为。所以我很讨厌我之前的写法。&lt;/p&gt;
&lt;p&gt;现在我想干嘛呢？我们知道其实MVC内置了一个数据校验。这里不过多介绍它，（偶尔适当的照照轮子，也有许多好处的）。这里简单描述下它的用法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult ValidatorTest(Person model)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ModelState.IsValid)
            {
                &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; ok&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和咱们之前那样写比起来是精简了许多，但我还是觉得吧，他还是要在每个Action 里调用ModelState.IsValid，虽然只有一个if，但这不是我想要的，我希望它能像这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult ValidatorTest(Person model)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  一大堆代码
            &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; Redirect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不要影响我正常的编程，而我也不去做哪些重复的事。&lt;/p&gt;
&lt;p&gt;换句话说，其实就是在执行我Action之前就去把数据给校验了。&lt;/p&gt;
&lt;p&gt;于是我们想到了MVC给我们提供的Filter，OnActionExecuting，打开我们的ControllerEx，在里面重写OnActionExecuting，他有一个参数ActionExecutingContext，通过名字我们大致了解了，这个参数是个Action相关的上下文，那他一定装了Action相关的数据&lt;/p&gt;
&lt;p&gt;我就不墨迹了，先直接上代码，其实这些代码也只是我刚刚才写出来的而已，我对这个参数也不是很了解，通过一个一个去尝试，慢慢得就试出来了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActionExecuting(ActionExecutingContext filterContext)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; existError = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt;&lt;span&gt; filterContext.ActionParameters.Values)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; modelValidatorPropertyInfo = &lt;span&gt;this&lt;/span&gt;.ValidatorHub.GetType().GetProperty(value.GetType().Name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Validator&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (modelValidatorPropertyInfo != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; modelValidator = modelValidatorPropertyInfo.GetValue(&lt;span&gt;this&lt;/span&gt;.ValidatorHub) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; IValidator;

                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; validateResult =&lt;span&gt; modelValidator.Validate(value);

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;validateResult.IsValid)
                    {
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ValidatorErrorHandler(validateResult);
                        existError &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    }

                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (existError)
            {
                ViewData[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; DicError;

                filterContext.Result &lt;/span&gt;=&lt;span&gt; View();
            }

            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnActionExecuting(filterContext);

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 OnActionExecuting 里，我们首先定义了一个existError，用来判断是否验证失败的，然后我们遍历了 filterContext.ActionParameters.Values&lt;/p&gt;
&lt;p&gt;在filterContext 里，我们看到ActionParameters 是关于Action的参数的，通过调试我发现，他是一个集合，其键是参数名，比如拿我们这个Person来讲。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult ValidatorTest(Person model)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  一大堆代码
            &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; Redirect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;filterContext.ActionParameters 集合里就有一个数据，其键是&quot;model&quot; 值呢 model&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173592/201807/1173592-20180719235057481-189982412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以呢我们通过遍历filterContext.ActionParameters.Value 就能取出每一个Action的所有参数了，而每一个参数通过.getType().Name 则能取出他的类型名，比如这里model类型是Person 所以filterContext.ActionParameters[&quot;model&quot;].GetType().Name 就是“Person”了。&lt;/p&gt;
&lt;p&gt;知道了实体是什么类型，如何获取具体验证器呢？想想我们的验证器配置 Person = PersonValidator 那太简单了，这不是一对一的关系嘛，但总不可能通过一个switch 去工厂返回吧，那这样还需要维护一个工厂方法。当然不是咯，这就要用到咱.NET 提供的强大反射技术&lt;/p&gt;
&lt;p&gt;有时候我们有一个匿名对象，是一个object的时候，又不知道它具体是什么类型，如何取它的属性呢？&lt;/p&gt;
&lt;p&gt;我这有一个方法，他能解决这个问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReflectHelper
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; GetPropertyByAnonymousObject(&lt;span&gt;string&lt;/span&gt; propertyName, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; property = obj.GetType().GetProperties().Where(p =&amp;gt; p.Name ==&lt;span&gt; propertyName).FirstOrDefault();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (property == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}对象未定义{1}属性&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, nameof(obj), nameof(propertyName)));
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; property.GetValue(obj);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从使用上，传递一个属性名和对象进来，返回一个object的属性。&lt;/p&gt;
&lt;p&gt;我们看看内部都做了些什么。&lt;/p&gt;
&lt;p&gt;首先获取类型，然后获取执行的属性，诶，这个属性可不是真的属性哦，这个是PropertyInfo类型，是反射里的数据类型，它不是真正的属性值，但我们如果想要获取真正的属性值怎么办呢？其实只需要调用他的GetValue就行了，他有一个参数，这个参数是指获取那个对象上的属性，于是把object传进去就行。&lt;/p&gt;
&lt;p&gt;有了这个基础，反观我们的目的，知道了Person，有一个对象叫ValidatotHub 里面有个属性PersonValidator ，所以我们只需要获取一个叫ValidatorHub对象里的PersonValidator属性就行了。（Person是可替换的，是根据参数类型来的，前面已经解释过了，这里以Person举例）&lt;/p&gt;
&lt;p&gt;现在有个问题了，我们取到的PersonValidator 是一个object类型的，object类型我可不好使用啊，我们又不能显示的转换为具体类型，因为谁知道具体类型是啥呢。如果写死了就凉了。那肯定也不能用个switch来维护啊，那样不又增加工作量了吗。&lt;/p&gt;
&lt;p&gt;我们慢慢发现PersonValidator继承自AbstractValidator&amp;lt;Person&amp;gt; 很显然它的基类也需要一个具体类型，不行，继续往上走，诶，发现了AbstractValidator&amp;lt;T&amp;gt;继承自IValidator，并且IValidator定义了Validate方法。这不就好了吗，我as 为IValidator类型，就可以用了。这里使用了（里氏转换原则）。我尽量写得通俗易懂，也将许多基础东西提一下，但不肯能面面俱到，所以还是建立在一部分基础之上的。（当然更重要的一点是，通过这次遇到的问题让我以后在设计泛型类结构的时候，都要去继承一个非泛型的接口，如果FluentValidator没有继承自IValidator 而只是继承自IValidator&amp;lt;T&amp;gt;其实从简单使用上来讲，并没有什么影响啊，但到了我们刚刚这里，问题就出来了，所以这也是给我们狠狠地上了一课啊）&lt;/p&gt;
&lt;p&gt;现在我就可以在这里进行验证了，我们知道value 就是那个model 所以直接对他进行验证，验证会返回一个ValidationResult类型接下来的事我就不解释了，相信上一章已经讲得很清楚了。最后根据是否存在错误在进行提前处理，如果有错误的话就直接返回视图呈现错误了，连咱们的Action都不执行了。好了，到这里咱们昨天讲得OnActionExecuted 可以直接Delete拉 。&lt;/p&gt;
&lt;p&gt;我们现在把ValidatorTest里的验证代码都去掉来测试一下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult ValidatorTest(Person model)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt; 
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  一大堆代码
            &lt;/span&gt;&lt;span&gt;//
&lt;/span&gt;            &lt;span&gt;return&lt;/span&gt; Redirect(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.baidu.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 ValidatorTest 里打上断点，然后什么都不填，直接提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173592/201807/1173592-20180720002057244-973719130.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173592/201807/1173592-20180720002121955-126162847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;断点没触发，但错误消息已呈现。多试几次~.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173592/201807/1173592-20180720002200232-1351747719.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173592/201807/1173592-20180720002209741-1158195720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样没触发。&lt;/p&gt;
&lt;p&gt;那我们来一次正确的验证。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1173592/201807/1173592-20180720002258400-703756518.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;断点触发了。并且值都通过了校验&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1173592/201807/1173592-20180720002401756-1787484011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;F5放行，最终我们的页面跳转到了 www.baidu.com。&lt;/p&gt;
&lt;p&gt;好了，小伙伴们还不快去改改代码造就幸福生活。&lt;/p&gt;

</description>
<pubDate>Thu, 19 Jul 2018 16:26:00 +0000</pubDate>
<dc:creator>Gxqsd</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Gxqsd/p/9339219.html</dc:identifier>
</item>
<item>
<title>公共服务设计之商品服务设计雏形 - 叶小钗</title>
<link>http://www.cnblogs.com/yexiaochai/p/9339220.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yexiaochai/p/9339220.html</guid>
<description>&lt;p&gt;&amp;#13;
                                    &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;×&lt;/span&gt;&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;&lt;/button&gt;&amp;#13;
                                    &lt;h4 class=&quot;modal-title&quot;&gt;&amp;#13;
                                        请完成人机识别验证&amp;#13;
                                    &lt;/h4&gt;&amp;#13;
                                &lt;/p&gt;
                                &lt;div class=&quot;modal-body&quot; readability=&quot;33&quot;&gt;
                                    
                                    &lt;p&gt;&amp;#13;
                                        &lt;span id=&quot;geetestLoading&quot;&gt; 验证码组件加载中,请稍后...&lt;/span&gt;&amp;#13;
                                    &lt;/p&gt;
                                &lt;/div&gt;
                            </description>
<pubDate>Thu, 19 Jul 2018 16:26:00 +0000</pubDate>
<dc:creator>叶小钗</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://passport.cnblogs.com/user/signin?ReturnUrl=http%3A%2F%2Fwww.cnblogs.com%2Fyexiaochai%2Fp%2F9339220.html&amp;AspxAutoDetectCookieSupport=1</dc:identifier>
</item>
<item>
<title>手把手教你学会用Spring AOP - 姜小泮</title>
<link>http://www.cnblogs.com/jpcflyer/p/9339104.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jpcflyer/p/9339104.html</guid>
<description>&lt;p&gt;&lt;span&gt;        用了Spring很长时间了，一直想写些AOP的东西，但一直没有空闲，直到现在项目稍微进入正轨了，才赶紧写写。废话不多说，先从AOP入门开始，后面再介绍AOP的原理（JDK动态代码和CGLIB动态代码的知识）。注：该部分适合于未接触过Spring AOP的童鞋，如果是AOP老手，请直接绕过，不用打招呼^^&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       请尊重作者劳动成果，转载请标明原文链接：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 手把手教你学会用Spring AOP&quot; href=&quot;https://www.cnblogs.com/jpcflyer/p/9339104.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/jpcflyer/p/9339104.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、环境准备&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1.在Spring官网（地址见本文最后）下载springframework相关jar包，下载完后的jar包里面会包含aop/aspects/context/beans/core等相关的jar。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       2.在AspectJ官网（AOP依赖包，地址见本文最后）下载AspectJ.jar，目前最新稳定版是1.9.1。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       3.在Eclipse中，新建java project，然后在根目录下新建lib目录，并将第1步中下载的jar包全部copy到lib目录下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       4.将第2步下载的AspectJ.jar解压，并将解压后的aspectjrt.jar、aspectjweaver.jar两个jar包copy到lib目录下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       5.项目右键-build path-libraries-add jars，然后选择lib中的全部jar包，点击确定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       6.在项目根目录下新建配置文件applicationContext.xml，文件内容暂时为空，到此环境准备完毕。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、代码示例&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       了解AOP的童鞋都知道，使用AOP的方式有多少，这里建议使用配置文件的方式，能够减少对代码的注入，比较简洁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1.新建切面类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_0c8cd8d7-6770-4975-bf54-7a3c1ba76a4c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0c8cd8d7-6770-4975-bf54-7a3c1ba76a4c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_0c8cd8d7-6770-4975-bf54-7a3c1ba76a4c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.JoinPoint;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.aspectj.lang.ProceedingJoinPoint;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AspectAdvice {

     &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 前置通知
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; jp
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doBefore(JoinPoint jp) {
        System.out.println(&lt;/span&gt;&quot;===========进入before advice============ \n&quot;&lt;span&gt;);

        System.out.print(&lt;/span&gt;&quot;准备在&quot; + jp.getTarget().getClass() + &quot;对象上用&quot;&lt;span&gt;);
        System.out.print(jp.getSignature().getName() &lt;/span&gt;+ &quot;方法进行对 '&quot;&lt;span&gt;);
        System.out.print(jp.getArgs()[&lt;/span&gt;0] + &quot;'进行删除！\n\n&quot;&lt;span&gt;);

        System.out.println(&lt;/span&gt;&quot;要进入切入点方法了 \n&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 后置通知
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; jp
     *            连接点
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; result
     *            返回值
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doAfter(JoinPoint jp, String result) {
        System.out.println(&lt;/span&gt;&quot;==========进入after advice=========== \n&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;切入点方法执行完了 \n&quot;&lt;span&gt;);

        System.out.print(jp.getArgs()[&lt;/span&gt;0] + &quot;在&quot;&lt;span&gt;);
        System.out.print(jp.getTarget().getClass() &lt;/span&gt;+ &quot;对象上被&quot;&lt;span&gt;);
        System.out.print(jp.getSignature().getName() &lt;/span&gt;+ &quot;方法删除了&quot;&lt;span&gt;);
        System.out.print(&lt;/span&gt;&quot;只留下：&quot; + result + &quot;\n\n&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 环绕通知
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; pjp
     *            连接点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doAround(ProceedingJoinPoint pjp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        System.out.println(&lt;/span&gt;&quot;===========进入around环绕方法！=========== \n&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用目标方法之前执行的动作&lt;/span&gt;
        System.out.println(&quot;调用方法之前: 执行！\n&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用方法的参数&lt;/span&gt;
        Object[] args =&lt;span&gt; pjp.getArgs();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用的方法名&lt;/span&gt;
        String method =&lt;span&gt; pjp.getSignature().getName();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取目标对象&lt;/span&gt;
        Object target =&lt;span&gt; pjp.getTarget();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行&lt;/span&gt;
        Object result =&lt;span&gt; pjp.proceed();

        System.out.println(&lt;/span&gt;&quot;输出：&quot; + args[0] + &quot;;&quot; + method + &quot;;&quot; + target + &quot;;&quot; + result + &quot;\n&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;调用方法结束：之后执行！\n&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 异常通知
     * 
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; jp
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; e
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doThrow(JoinPoint jp, Throwable e) {
        System.out.println(&lt;/span&gt;&quot;删除出错啦&quot;&lt;span&gt;);
    }


}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       2.新建业务类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_29c4e5d9-c364-48e9-b5e2-86058b1b892a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_29c4e5d9-c364-48e9-b5e2-86058b1b892a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_29c4e5d9-c364-48e9-b5e2-86058b1b892a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AspectBusiness {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String delete(String obj) {
        System.out.println(&lt;/span&gt;&quot;==========调用切入点：&quot; + obj + &quot;说：你敢删除我！===========\n&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj + &quot;：瞄～&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String add(String obj) {
        System.out.println(&lt;/span&gt;&quot;================这个方法不能被切。。。============== \n&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj + &quot;：瞄～ 嘿嘿！&quot;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String modify(String obj) {
        System.out.println(&lt;/span&gt;&quot;=================这个也设置加入切吧====================\n&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj + &quot;：瞄改瞄啊！&quot;&lt;span&gt;;
    }


}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       3.在applicationContext.xml中添加如下内容&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_2d7c1889-4826-411b-b1c8-48b07bcd8d30&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2d7c1889-4826-411b-b1c8-48b07bcd8d30&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_2d7c1889-4826-411b-b1c8-48b07bcd8d30&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
       xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;=&lt;span&gt;&quot;
&lt;/span&gt;       http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans &lt;/span&gt;
       http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd &lt;/span&gt;
       http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop &lt;/span&gt;
       http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop.xsd&quot;&lt;/span&gt;
      &amp;gt;

&amp;lt;!-- bean definitions here --&amp;gt;



    &amp;lt;!-- 声明一个业务类 --&amp;gt;
    &amp;lt;bean id=&quot;aspectBusiness&quot; &lt;span&gt;class&lt;/span&gt;=&quot;test.AspectBusiness&quot; /&amp;gt;

    &amp;lt;!-- 声明通知类 --&amp;gt;
    &amp;lt;bean id=&quot;aspectAdvice&quot; &lt;span&gt;class&lt;/span&gt;=&quot;test.AspectAdvice&quot; /&amp;gt;

    &amp;lt;aop:config&amp;gt;
        &amp;lt;aop:aspect id=&quot;businessAspect&quot; ref=&quot;aspectAdvice&quot;&amp;gt;
            &amp;lt;!-- 配置指定切入的对象 --&amp;gt;
            &amp;lt;aop:pointcut id=&quot;point_cut&quot; expression=&quot;execution(* test.*.*(..))&quot; /&amp;gt;
            &amp;lt;!--&lt;span&gt; 只匹配add方法作为切入点
            &lt;/span&gt;&amp;lt;aop:pointcut id=&quot;except_add&quot; expression=&quot;execution(* test.*.add(..))&quot; /&amp;gt;
             --&amp;gt;

            &amp;lt;!-- 前置通知 --&amp;gt;
            &amp;lt;aop:before method=&quot;doBefore&quot; pointcut-ref=&quot;point_cut&quot; /&amp;gt;
            &amp;lt;!-- 后置通知 returning指定返回参数 --&amp;gt;
            &amp;lt;aop:after-returning method=&quot;doAfter&quot;&lt;span&gt;
                pointcut&lt;/span&gt;-ref=&quot;point_cut&quot; returning=&quot;result&quot; /&amp;gt;
            &amp;lt;aop:around method=&quot;doAround&quot; pointcut-ref=&quot;point_cut&quot;/&amp;gt;
            &amp;lt;aop:after-throwing method=&quot;doThrow&quot; pointcut-ref=&quot;point_cut&quot; throwing=&quot;e&quot;/&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       4.新建测试类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;span&gt;&lt;img id=&quot;code_img_closed_f03504dd-f506-4e05-9e93-52b55be1e4d5&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f03504dd-f506-4e05-9e93-52b55be1e4d5&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_f03504dd-f506-4e05-9e93-52b55be1e4d5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collection;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.LinkedList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.support.ClassPathXmlApplicationContext;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StringTest {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        ApplicationContext context &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;&lt;span&gt;);
        AspectBusiness business &lt;/span&gt;= (AspectBusiness) context.getBean(&quot;aspectBusiness&quot;&lt;span&gt;);
        business.delete(&lt;/span&gt;&quot;猫&quot;&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、运行结果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       运行结果如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;===========进入before advice============&lt;span&gt; 

准备在class test.AspectBusiness对象上用delete方法进行对 &lt;/span&gt;'猫'&lt;span&gt;进行删除！

要进入切入点方法了 

&lt;/span&gt;===========进入around环绕方法！===========&lt;span&gt; 

调用方法之前: 执行！

&lt;/span&gt;==========调用切入点：猫说：你敢删除我！===========&lt;span&gt;

输出：猫;delete;test.AspectBusiness@3b69e7d1;猫：瞄～

调用方法结束：之后执行！

&lt;/span&gt;==========进入after advice===========&lt;span&gt; 

切入点方法执行完了 

猫在class test.AspectBusiness对象上被delete方法删除了只留下：&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       这样AOP的示例就算完成了，本篇先不介绍切面、通知、切入点等的相关概念了，这些概念在百度上可谓信手拈来，如果有不了解，可以自行百度。本篇先写到这里，后续再介绍AOP的相关原理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;       参考资料：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1. Spring官网：https://spring.io/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       2. Spring4.0官网下载地址：https://repo.spring.io/webapp/#/artifacts/browse/tree/General/libs-release-local/org/springframework/spring/5.0.0.RELEASE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       3. AspectJ最新稳定版官网下载地址：http://www.eclipse.org/aspectj/downloads.php#stable_release&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 19 Jul 2018 16:05:00 +0000</pubDate>
<dc:creator>姜小泮</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jpcflyer/p/9339104.html</dc:identifier>
</item>
<item>
<title>以LeetCode为例——如何发送GraphQL Query获取数据 - zxzhang</title>
<link>http://www.cnblogs.com/ZhaoxiCheung/p/9333476.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhaoxiCheung/p/9333476.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;  &lt;a href=&quot;http://graphql.cn/&quot;&gt;GraphQL&lt;/a&gt; 是一种用于 API 的查询语言，是由 Facebook 开源的一种用于提供数据查询服务的抽象框架。在服务端 API 开发中，很多时候定义一个接口返回的数据相对固定，因此要获得更多信息或者只想得到某部分信息时，基于 RESTful API 的接口就显得不那么灵活。而 GraphQL 对 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。&lt;br/&gt;  目前，LeetCode 和 GitHub 都借助 GraphQL 来设计，提供了更大的灵活性，对于想借助 GitHub 来了解 GraphQL 可直接访问 &lt;a href=&quot;https://developer.github.com/v4/&quot;&gt;GraphQL API v4&lt;/a&gt; ，或者参考 &lt;a href=&quot;https://www.jianshu.com/p/af7ac20f2c64&quot;&gt;GraphQL 实战：Github V4 API使用&lt;/a&gt;。而对于在 LeetCode 上使用 GraphQL 查询，相对资料少一些，因此在这，我主要以 LeetCode 为例，来做讲解（其实是因为自己业余刷题时突发奇想，想写一个爬虫。&lt;/p&gt;
&lt;h2 id=&quot;过程&quot;&gt;过程&lt;/h2&gt;
&lt;p&gt;  如果直接搜索以 Java 语言为载体的 GraphQL 的话，一大部分搜索结果都是介绍使用 &lt;a href=&quot;https://github.com/graphql-java/graphql-java&quot;&gt;graphql-java&lt;/a&gt; 来搭建查询服务，而我们的目的是利用 GraphQL 来获取想要的数据，并非自己搭建一个查询服务，因此如果一开始就选错了工具，就会导致后面的方向都是错误的。&lt;br/&gt;  以 LeetCode 第一题 &lt;a href=&quot;https://leetcode.com/problems/two-sum/description/&quot;&gt;1.Two Sum&lt;/a&gt; 为例，获取其后端发送过来的数据。利用 F12 功能调出如下界面，选 Network&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/885804/201807/885804-20180719223855159-919972190.png&quot;/&gt;&lt;br/&gt;找到 graphql 文件（有好多 graphql 文件，可以依次点击查找自己想要的那个，这里找到包含有题目信息的），从 preview 中我们可以看到 data 返回了题目相关的信息&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/885804/201807/885804-20180719224356473-18415864.png&quot;/&gt;&lt;br/&gt;  那么，如何构造 GraphQL Query 来获取信息呢？从 Header 中的 &lt;strong&gt;Request Payload&lt;/strong&gt; 中我们可以看到一个&lt;code&gt;query&lt;/code&gt;的字段，这是我们要构造的 GraphQL Query 的一个重要信息。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/885804/201807/885804-20180719232018633-1699302590.png&quot;/&gt;&lt;br/&gt;  我们并不一开始就用代码来获取题目信息，而是先利用 Postman 来看看如何获取题目信息。右键 Network 下的 graphql 文件—&amp;gt;Copy—&amp;gt;Copy as cURL(bash)，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/885804/201807/885804-20180719232607953-589650086.png&quot;/&gt;&lt;br/&gt;之后，打开 Postman—&amp;gt;左上角Import—&amp;gt;Paste Raw Text粘贴，从 Body中可以看到，构造好了的 GraphQL Query 与我们在 &lt;strong&gt;Request Payload&lt;/strong&gt; 中看到的 &lt;code&gt;query&lt;/code&gt; 的字段相仿（因为有一点需要更改的细节）&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/885804/201807/885804-20180719233123295-581471877.png&quot;/&gt;&lt;br/&gt;当然，如果不想直接粘贴复制的 cURL，那么我们可以自己在 Postman 中写 Header 和 Body，需要注意的是这边的 &lt;code&gt;Content-Type&lt;/code&gt;是&lt;code&gt;application/graphql&lt;/code&gt;，Body 中的 GraphQL 构造，参照 &lt;strong&gt;Request Payload&lt;/strong&gt; 中的&lt;code&gt;query&lt;/code&gt;的字段来构造&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/885804/201807/885804-20180719233438003-1026573385.png&quot;/&gt;&lt;br/&gt;获取到的结果如下：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/885804/201807/885804-20180719233742759-660254344.png&quot;/&gt;&lt;br/&gt;我们在实际中，可能并不需要提供的所有信息，只想要某一部分，那么只需更改&lt;code&gt;query&lt;/code&gt;即可，这也是 GraphQL 的强大之处。比如我们只想要题目的&lt;code&gt;content&lt;/code&gt;信息，那么其&lt;code&gt;query&lt;/code&gt;则为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;query{question(titleSlug:&quot;two-sum&quot;) {content}}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;p&gt;在上边，已经利用 Postman 查询到想要的数据了，而现在我们要做的就是用代码将上述操作展示出来。这边，使用 OkHttp 来进行题目信息获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import okhttp3.*;
import org.jsoup.Connection;
import org.jsoup.Jsoup;


import java.io.IOException;
import java.util.Map;

import static java.lang.System.out;

public class Question {
    public static void main(String... args) throws IOException {
        String questionUrl = &quot;https://leetcode.com/problems/two-sum/description/&quot;;
        String graphqlUrl = &quot;https://leetcode.com/graphql&quot;;
        Connection.Response response = Jsoup.connect(questionUrl)
                .method(Connection.Method.GET)
                .execute();

        Map&amp;lt;String,String&amp;gt;cookies = response.cookies();
        for (Map.Entry&amp;lt;String,String&amp;gt;entry:cookies.entrySet()){
            //out.println(entry.getKey() + &quot;: &quot; + entry.getValue());
        }
        String csrftoken = response.cookie(&quot;csrftoken&quot;);
        String __cfduid = response.cookie(&quot;__cfduid&quot;);

        OkHttpClient client = new OkHttpClient.Builder()
                .followRedirects(false)
                .followSslRedirects(false)
                .build();

        String postBody = &quot;query{\n&quot; +
                &quot;  question(titleSlug:\&quot;two-sum\&quot;) {\n&quot; +
                &quot;    content\n&quot; +
                &quot;  }\n&quot; +
                &quot;}\n&quot;;

        Request request = new Request.Builder()
                .addHeader(&quot;Content-Type&quot;,&quot;application/graphql&quot;)
                .addHeader(&quot;Referer&quot;,questionUrl)
                .addHeader(&quot;Cookie&quot;,&quot;__cfduid=&quot; + __cfduid + &quot;;&quot; + &quot;csrftoken=&quot; + csrftoken)
                .addHeader(&quot;x-csrftoken&quot;,csrftoken)
                .url(graphqlUrl)
                .post(RequestBody.create(MediaType.parse(&quot;application/graphql; charset=utf-8&quot;),postBody))
                .build();

        Response response1 = client.newCall(request).execute();
        //out.println(response1.headers());
        out.println(response1.body().string());

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/885804/201807/885804-20180719235031045-199371891.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 19 Jul 2018 15:52:00 +0000</pubDate>
<dc:creator>zxzhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZhaoxiCheung/p/9333476.html</dc:identifier>
</item>
<item>
<title>ReentrantLock(重入锁)功能详解和应用演示 - takumiCX</title>
<link>http://www.cnblogs.com/takumicx/p/9338983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/takumicx/p/9338983.html</guid>
<description>&lt;h2 id=&quot;reentrantlock简介&quot;&gt;1. ReentrantLock简介&lt;/h2&gt;
&lt;p&gt;jdk中独占锁的实现除了使用关键字synchronized外,还可以使用ReentrantLock。虽然在性能上ReentrantLock和synchronized没有什么区别，但ReentrantLock相比synchronized而言功能更加丰富，使用起来更为灵活，也更适合复杂的并发场景。&lt;/p&gt;
&lt;h2 id=&quot;reentrantlock和synchronized的相同点&quot;&gt;2. ReentrantLock和synchronized的相同点&lt;/h2&gt;
&lt;h4 id=&quot;reentrantlock是独占锁且可重入的&quot;&gt;2.1 ReentrantLock是独占锁且可重入的&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public class ReentrantLockTest {

    public static void main(String[] args) throws InterruptedException {

        ReentrantLock lock = new ReentrantLock();

        for (int i = 1; i &amp;lt;= 3; i++) {
            lock.lock();
        }

        for(int i=1;i&amp;lt;=3;i++){
            try {

            } finally {
                lock.unlock();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码通过&lt;code&gt;lock()&lt;/code&gt;方法先获取锁三次，然后通过&lt;code&gt;unlock()&lt;/code&gt;方法释放锁3次，程序可以正常退出。从上面的例子可以看出,ReentrantLock是可以重入的锁,当一个线程获取锁时,还可以接着重复获取多次。在加上ReentrantLock的的独占性，我们可以得出以下ReentrantLock和synchronized的相同点。&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;1.ReentrantLock和synchronized都是独占锁,只允许线程互斥的访问临界区。但是实现上两者不同:synchronized加锁解锁的过程是隐式的,用户不用手动操作,优点是操作简单，但显得不够灵活。一般并发场景使用synchronized的就够了；ReentrantLock需要手动加锁和解锁,且解锁的操作尽量要放在finally代码块中,保证线程正确释放锁。ReentrantLock操作较为复杂，但是因为可以手动控制加锁和解锁过程,在复杂的并发场景中能派上用场。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;2.ReentrantLock和synchronized都是可重入的。synchronized因为可重入因此可以放在被递归执行的方法上,且不用担心线程最后能否正确释放锁；而ReentrantLock在重入时要却确保重复获取锁的次数必须和重复释放锁的次数一样，否则可能导致其他线程无法获得该锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;reentrantlock相比synchronized的额外功能&quot;&gt;2. ReentrantLock相比synchronized的额外功能&lt;/h2&gt;
&lt;h4 id=&quot;reentrantlock可以实现公平锁&quot;&gt;2.1 ReentrantLock可以实现公平锁。&lt;/h4&gt;
&lt;p&gt;公平锁是指当锁可用时,在锁上等待时间最长的线程将获得锁的使用权。而非公平锁则随机分配这种使用权。和synchronized一样，默认的ReentrantLock实现是非公平锁,因为相比公平锁，非公平锁性能更好。当然公平锁能防止饥饿,某些情况下也很有用。在创建ReentrantLock的时候通过传进参数&lt;code&gt;true&lt;/code&gt;创建公平锁,如果传入的是&lt;code&gt;false&lt;/code&gt;或没传参数则创建的是非公平锁&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ReentrantLock lock = new ReentrantLock(true);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续跟进看下源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Creates an instance of {@code ReentrantLock} with the
 * given fairness policy.
 *
 * @param fair {@code true} if this lock should use a fair ordering policy
 */
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到公平锁和非公平锁的实现关键在于成员变量&lt;code&gt;sync&lt;/code&gt;的实现不同,这是锁实现互斥同步的核心。以后有机会我们再细讲。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个公平锁的例子&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class ReentrantLockTest {

    static Lock lock = new ReentrantLock(true);

    public static void main(String[] args) throws InterruptedException {

        for(int i=0;i&amp;lt;5;i++){
            new Thread(new ThreadDemo(i)).start();
        }

    }

    static class ThreadDemo implements Runnable {
        Integer id;

        public ThreadDemo(Integer id) {
            this.id = id;
        }

        @Override

      public void run() {
            try {
                TimeUnit.MILLISECONDS.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            for(int i=0;i&amp;lt;2;i++){
                lock.lock();
                System.out.println(&quot;获得锁的线程：&quot;+id);
                lock.unlock();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;公平锁结果&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180719230013861-1075860918.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们开启5个线程,让每个线程都获取释放锁两次。为了能更好的观察到结果,在每次获取锁前让线程休眠10毫秒。可以看到线程几乎是轮流的获取到了锁。如果我们改成非公平锁,再看下结果&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;非公平锁结果&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180719230043730-1158282129.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;线程会重复获取锁。如果申请获取锁的线程足够多,那么可能会造成某些线程长时间得不到锁。这就是非公平锁的“饥饿”问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;公平锁和非公平锁该如何选择&lt;br/&gt;大部分情况下我们使用非公平锁，因为其性能比公平锁好很多。但是公平锁能够避免线程饥饿，某些情况下也很有用。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;reentrantlock可中断响应&quot;&gt;2.2 .ReentrantLock可中断响应&lt;/h4&gt;
&lt;p&gt;当使用synchronized实现锁时,阻塞在锁上的线程除非获得锁否则将一直等待下去，也就是说这种无限等待获取锁的行为无法被中断。而ReentrantLock给我们提供了一个可以响应中断的获取锁的方法&lt;code&gt;lockInterruptibly()&lt;/code&gt;。该方法可以用来解决死锁问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;响应中断的例子&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class ReentrantLockTest {
    static Lock lock1 = new ReentrantLock();
    static Lock lock2 = new ReentrantLock();
    public static void main(String[] args) throws InterruptedException {

        Thread thread = new Thread(new ThreadDemo(lock1, lock2));//该线程先获取锁1,再获取锁2
        Thread thread1 = new Thread(new ThreadDemo(lock2, lock1));//该线程先获取锁2,再获取锁1
        thread.start();
        thread1.start();
        thread.interrupt();//是第一个线程中断
    }

    static class ThreadDemo implements Runnable {
        Lock firstLock;
        Lock secondLock;
        public ThreadDemo(Lock firstLock, Lock secondLock) {
            this.firstLock = firstLock;
            this.secondLock = secondLock;
        }
        @Override
        public void run() {
            try {
                firstLock.lockInterruptibly();
                TimeUnit.MILLISECONDS.sleep(10);//更好的触发死锁
                secondLock.lockInterruptibly();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                firstLock.unlock();
                secondLock.unlock();
                System.out.println(Thread.currentThread().getName()+&quot;正常结束!&quot;);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;结果&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180719230113736-1002051172.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;构造死锁场景:创建两个子线程,子线程在运行时会分别尝试获取两把锁。其中一个线程先获取锁1在获取锁2，另一个线程正好相反。如果没有外界中断，该程序将处于死锁状态永远无法停止。我们通过使其中一个线程中断，来结束线程间毫无意义的等待。被中断的线程将抛出异常，而另一个线程将能获取锁后正常结束。&lt;/p&gt;
&lt;h4 id=&quot;获取锁时限时等待&quot;&gt;2.3 获取锁时限时等待&lt;/h4&gt;
&lt;p&gt;ReentrantLock还给我们提供了获取锁限时等待的方法&lt;code&gt;tryLock()&lt;/code&gt;,可以选择传入时间参数,表示等待指定的时间,无参则表示立即返回锁申请的结果:true表示获取锁成功,false表示获取锁失败。我们可以使用该方法配合失败重试机制来更好的解决死锁问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;更好的解决死锁的例子&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class ReentrantLockTest {
    static Lock lock1 = new ReentrantLock();
    static Lock lock2 = new ReentrantLock();
    public static void main(String[] args) throws InterruptedException {

        Thread thread = new Thread(new ThreadDemo(lock1, lock2));//该线程先获取锁1,再获取锁2
        Thread thread1 = new Thread(new ThreadDemo(lock2, lock1));//该线程先获取锁2,再获取锁1
        thread.start();
        thread1.start();
    }

    static class ThreadDemo implements Runnable {
        Lock firstLock;
        Lock secondLock;
        public ThreadDemo(Lock firstLock, Lock secondLock) {
            this.firstLock = firstLock;
            this.secondLock = secondLock;
        }
        @Override
        public void run() {
            try {
                while(!lock1.tryLock()){
                    TimeUnit.MILLISECONDS.sleep(10);
                }
                while(!lock2.tryLock()){
                    lock1.unlock();
                    TimeUnit.MILLISECONDS.sleep(10);
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            } finally {
                firstLock.unlock();
                secondLock.unlock();
                System.out.println(Thread.currentThread().getName()+&quot;正常结束!&quot;);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;结果&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180719230215064-1644661582.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;线程通过调用&lt;code&gt;tryLock()&lt;/code&gt;方法获取锁,第一次获取锁失败时会休眠10毫秒,然后重新获取，直到获取成功。第二次获取失败时,首先会释放第一把锁,再休眠10毫秒,然后重试直到成功为止。线程获取第二把锁失败时将会释放第一把锁，这是解决死锁问题的关键,避免了两个线程分别持有一把锁然后相互请求另一把锁。&lt;/p&gt;
&lt;h2 id=&quot;结合condition实现等待通知机制&quot;&gt;3. 结合Condition实现等待通知机制&lt;/h2&gt;
&lt;p&gt;使用synchronized结合Object上的wait和notify方法可以实现线程间的等待通知机制。ReentrantLock结合Condition接口同样可以实现这个功能。而且相比前者使用起来更清晰也更简单。&lt;/p&gt;
&lt;h4 id=&quot;condition使用简介&quot;&gt;3.1 Condition使用简介&lt;/h4&gt;
&lt;p&gt;Condition由ReentrantLock对象创建,并且可以同时创建多个&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static Condition notEmpty = lock.newCondition();

static Condition notFull = lock.newCondition();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Condition接口在使用前必须先调用ReentrantLock的lock()方法获得锁。之后调用Condition接口的await()将释放锁,并且在该Condition上等待,直到有其他线程调用Condition的signal()方法唤醒线程。使用方式和wait,notify类似。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个使用condition的简单例子&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class ConditionTest {

    static ReentrantLock lock = new ReentrantLock();
    static Condition condition = lock.newCondition();
    public static void main(String[] args) throws InterruptedException {

        lock.lock();
        new Thread(new SignalThread()).start();
        System.out.println(&quot;主线程等待通知&quot;);
        try {
            condition.await();
        } finally {
            lock.unlock();
        }
        System.out.println(&quot;主线程恢复运行&quot;);
    }
    static class SignalThread implements Runnable {

        @Override
        public void run() {
            lock.lock();
            try {
                condition.signal();
                System.out.println(&quot;子线程通知&quot;);
            } finally {
                lock.unlock();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;运行结果&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180719230234682-2105208491.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;使用condition实现简单的阻塞队列&quot;&gt;3.2 使用Condition实现简单的阻塞队列&lt;/h4&gt;
&lt;p&gt;阻塞队列是一种特殊的先进先出队列,它有以下几个特点&lt;br/&gt;1.入队和出队线程安全&lt;br/&gt;2.当队列满时,入队线程会被阻塞;当队列为空时,出队线程会被阻塞。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;阻塞队列的简单实现&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class MyBlockingQueue&amp;lt;E&amp;gt; {

    int size;//阻塞队列最大容量

    ReentrantLock lock = new ReentrantLock();

    LinkedList&amp;lt;E&amp;gt; list=new LinkedList&amp;lt;&amp;gt;();//队列底层实现

    Condition notFull = lock.newCondition();//队列满时的等待条件
    Condition notEmpty = lock.newCondition();//队列空时的等待条件

    public MyBlockingQueue(int size) {
        this.size = size;
    }

    public void enqueue(E e) throws InterruptedException {
        lock.lock();
        try {
            while (list.size() ==size)//队列已满,在notFull条件上等待
                notFull.await();
            list.add(e);//入队:加入链表末尾
            System.out.println(&quot;入队：&quot; +e);
            notEmpty.signal(); //通知在notEmpty条件上等待的线程
        } finally {
            lock.unlock();
        }
    }

    public E dequeue() throws InterruptedException {
        E e;
        lock.lock();
        try {
            while (list.size() == 0)//队列为空,在notEmpty条件上等待
                notEmpty.await();
            e = list.removeFirst();//出队:移除链表首元素
            System.out.println(&quot;出队：&quot;+e);
            notFull.signal();//通知在notFull条件上等待的线程
            return e;
        } finally {
            lock.unlock();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public static void main(String[] args) throws InterruptedException {

    MyBlockingQueue&amp;lt;Integer&amp;gt; queue = new MyBlockingQueue&amp;lt;&amp;gt;(2);
    for (int i = 0; i &amp;lt; 10; i++) {
        int data = i;
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    queue.enqueue(data);
                } catch (InterruptedException e) {

                }
            }
        }).start();

    }
    for(int i=0;i&amp;lt;10;i++){
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    Integer data = queue.dequeue();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;运行结果&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1422237/201807/1422237-20180719230254831-1756382721.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;4. 总结&lt;/h2&gt;
&lt;p&gt;ReentrantLock是可重入的独占锁。比起synchronized功能更加丰富，支持公平锁实现，支持中断响应以及限时等待等等。可以配合一个或多个Condition条件方便的实现等待通知机制。&lt;/p&gt;
</description>
<pubDate>Thu, 19 Jul 2018 15:11:00 +0000</pubDate>
<dc:creator>takumiCX</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/takumicx/p/9338983.html</dc:identifier>
</item>
<item>
<title>【java爬虫】---爬虫+jsoup轻松爬博客 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/9338834.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/9338834.html</guid>
<description>&lt;p&gt;      最近的开发任务主要是爬虫爬新闻信息，这里主要用到技术就是jsoup，jsoup 是一款 Java的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过&lt;/p&gt;
&lt;p&gt;DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。这篇文章就讲通过jsoup爬虫的实际案例，下一篇再讲jsoup的具体文档。&lt;/p&gt;
&lt;p&gt;主要爬虫对象就以我之前写的一篇博客：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/qdhxhz/p/9230805.html&quot;&gt;【java提高】---java反射机制&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;主要爬区的信息有&lt;/p&gt;
&lt;p&gt;    （1）该文章的标题&lt;/p&gt;
&lt;p&gt;    （2）该文章的二类标题&lt;/p&gt;
&lt;p&gt;    （3）发表时间&lt;/p&gt;
&lt;p&gt;    （4）阅读数量&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;一、案例演示&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;1、代码部分&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.jincou.pachong;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.jsoup.Jsoup;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.jsoup.nodes.Document;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.jsoup.nodes.Element;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.jsoup.select.Elements;

 &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
  * 这个案例你只需要看结果，具体的jsoup介绍下一篇博客会详细介绍
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Pachong {
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]){     
    
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个就是博客中的java反射的url     &lt;/span&gt;
     &lt;span&gt;final&lt;/span&gt; String url=  &quot;https://www.cnblogs.com/qdhxhz/p/9230805.html&quot;&lt;span&gt;;
         
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先获得的是整个页面的html标签页面&lt;/span&gt;
         Document doc =&lt;span&gt; Jsoup.connect(url).get();
        
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取正文标题，因为整片文章只有标题是用h1标签&lt;/span&gt;
         Elements btEl = doc.select(&quot;H1&quot;&lt;span&gt;);
         String  bt&lt;/span&gt;=&lt;span&gt;btEl.text();
         System.out.println(&lt;/span&gt;&quot;========正文标题======：&quot;&lt;span&gt;); 
         System.out.println(bt); 
                
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取二级标题&lt;/span&gt;
         Elements ejbtEls = doc.select(&quot;H2&quot;&lt;span&gt;);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为整片文章有多个二级标题所以进行拼接&lt;/span&gt;
         StringBuilder  ejbts=&lt;span&gt;new&lt;/span&gt;&lt;span&gt;  StringBuilder();
         &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Element el :ejbtEls) {
             ejbts.append(el.text());
             ejbts.append(&lt;/span&gt;&quot;\n&quot;&lt;span&gt;);
         }
        String ejbt&lt;/span&gt;=&lt;span&gt;ejbts.toString();
        System.out.println(&lt;/span&gt;&quot;=======二级标题=========：&quot;&lt;span&gt;); 
        System.out.println(ejbt); 
                   
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取时间&lt;/span&gt;
       Elements timeEl = doc.select(&quot;#post-date&quot;&lt;span&gt;);
       String  time&lt;/span&gt;=&lt;span&gt;timeEl.text();
       System.out.println(&lt;/span&gt;&quot;========发布时间=========：&quot;&lt;span&gt;); 
       System.out.println(&lt;/span&gt;&quot;发布时间：&quot; +&lt;span&gt; time); 
      
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取阅读数量&lt;/span&gt;
       Elements readEl = doc.select(&quot;#post_view_count&quot;&lt;span&gt;);
       String  read&lt;/span&gt;=&lt;span&gt;readEl.text();
       System.out.println(&lt;/span&gt;&quot;========阅读数量=========：&quot;&lt;span&gt;); 
      System.out.println(&lt;/span&gt;&quot;阅读数量：&quot; +&lt;span&gt; read); 
       
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }
 }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、运行结果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201807/1090617-20180719220010592-445218999.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;span&gt;我们发现该篇文章的信息都已经爬到了，但是为什么阅读数量是...&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、案例讲解&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;       首先我们要知道：jsoup 是一款Java 的&lt;span&gt;HTML解析器&lt;/span&gt;，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可&lt;span&gt;通过DOM，CSS以及类似于jQuery的操作方法来取出和操&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作数据。&lt;span&gt;上面这两点很关键，具体&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;细说。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1、如何爬到正文标签&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;     我们看到正文标题的html标签是h1标签，所以我们只要获得H1标签元素，就可以爬到文本。那么同样的二级标签也是通过H2标签爬到就可以。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201807/1090617-20180719221325723-751677140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、如何获得发布时间&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    &lt;span&gt;因为时间的标签id是&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;post-date，所以可以通过id获得该标签元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201807/1090617-20180719221811986-85197320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;3、为什么阅读数量是...&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;  我们看到页面阅读是有的，但爬虫爬到确实...？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201807/1090617-20180719222142225-1728201670.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      这是为什么呢，这点很重要。那是因为该静态页面初始加载的时候是没有阅读数量的，阅读数量是后来接口重新调取的。什么意思呢？其实很好理解所以你写一篇文章的时候像标题，内容，时间&lt;/p&gt;
&lt;p&gt;等等是不太会变动的，但是你的阅读数量每访问一次都会改变，所以不可能把阅读数量和文章放在一张表里，而是分开放然后id关联就可以。这样就避免每次update文章表。所以静态页面初始是没有&lt;/p&gt;
&lt;p&gt;阅读数量的。&lt;/p&gt;
&lt;p&gt;那如何验证是不是这样。请看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201807/1090617-20180719223148478-1892366830.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     我们发现初始的html页面的阅读量和评论都是没有的，而是默认...,所以上面爬到的就是...&lt;/p&gt;
&lt;p&gt;     那如何能爬到真实的阅读量呢，这个就需要知道它真实的接口是什么，然后通过其它工具来爬，我们看下获取阅读量的真实接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1090617/201807/1090617-20180719223811553-444726996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然知道阅读量的真实接口，那么爬到它也就简单了。&lt;/p&gt;
&lt;p&gt;注意：&lt;span&gt;通过这里我们要明白，只有html元素有的情况下，才能通过jsoup来爬虫，如果是这接口获得的数据，那么通过jsoup是无法获取到的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;有关jsoup也是自己的理解，如有不正确请留言指点。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;想太多，做太少，中间的落差就是烦恼。想没有烦恼，要么别想，要么多做。中校【9】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 19 Jul 2018 14:50:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/9338834.html</dc:identifier>
</item>
<item>
<title>【Java入门提高篇】Day25 史上最详细的HashMap红黑树解析 - 弗兰克的猫</title>
<link>http://www.cnblogs.com/mfrank/p/9227097.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfrank/p/9227097.html</guid>
<description>&lt;p&gt;　　当当当当当当当，好久不见，最近又是换工作，又是换房子，忙的不可开交，断更了一小段时间，最重要的一篇迟迟出不来，每次都犹抱琵琶半遮面，想要把它用通俗易懂的方式进行说明，确实有一定的难度，可愁煞我也，但自己挖的坑，哭着也要把它补上。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180625234554119-1548105832.png&quot; alt=&quot;&quot;/&gt;请允许我当一回标题党。&lt;/p&gt;
&lt;p&gt;　　好了，言归正传，本篇主要内容便是介绍HashMap的男二号——TreeNode（男一号还是给Node吧，毕竟是TreeNode的爷爷，而且普通节点一般来说也比TreeNode要多），本篇主要从以下几个方面介绍：&lt;/p&gt;
&lt;p&gt;　　1.红黑树介绍&lt;/p&gt;
&lt;p&gt;　　2.TreeNode结构&lt;/p&gt;
&lt;p&gt;　　3.树化的过程&lt;/p&gt;
&lt;p&gt;　　4.红黑树的左旋和右旋&lt;/p&gt;
&lt;p&gt;　　5.TreeNode的左旋和右旋&lt;/p&gt;
&lt;p&gt;　　6.红黑树的插入&lt;/p&gt;
&lt;p&gt;　　7.TreeNode的插入&lt;/p&gt;
&lt;p&gt;　　8.红黑树的删除&lt;/p&gt;
&lt;p&gt;　　9.TreeNode的删除&lt;/p&gt;
&lt;p&gt;　　讲解红黑树的部分算是理论部分，讲解TreeNode的部分则是代码实践部分，配合服用效果更加。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180625235628621-1512974820.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　保守估计，仔细食用本篇大约需要半小时，请各位细细品尝。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719223614146-292186441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;红黑树介绍&lt;/h2&gt;
&lt;p&gt;　　什么是红黑树？嗯，首先，它是一颗树，所谓的树，便是长的像这样的东西&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719223635037-1249032958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180625235951335-1438523857.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　不像树？emmmm，你把它想象成一颗倒过来的树就好了，A~H都是树的节点，每个节点有零个或者多个子节点，或者说多个孩子，但除了根节点以外，每个节点都只有一个父节点，也称只有一个父亲（老王嘿嘿一笑&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719223653993-1157249254.png&quot; alt=&quot;&quot;/&gt;）。最上面的A是根节点，最下面的D、H、F、G是叶子节点。每一个非根节点有且只有一个父节点；树是具有一层一层的层次结构，这里A位于第一层，B、C位于第二层，依次类推。将左边的B节点部分（包括BDEH）拿出来，则又是一颗树，称为树的子树。&lt;/p&gt;
&lt;p&gt;　　好了，知道树是什么东西了，那么红黑树是什么样的呢？&lt;/p&gt;
&lt;p&gt;　　红黑树，本质上来说是一颗二叉搜索树。嗯，还是先说说这个二叉搜索树吧。二叉代表它的节点最多有两个子节点，而且左右有顺序，不能颠倒，分别叫左孩子和右孩子，这两个节点互为兄弟节点，嗯，其实叫法根现实里的叫法差不多，以下图为例，4、9互为兄弟，7是他们的父亲，9是2的叔叔，8是2的堂兄弟&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180625235628621-1512974820.png&quot; alt=&quot;&quot;/&gt;，很简单吧。说完了称谓，再来说说用途，既然叫做搜索树表示它的用途是为了更快的搜索和查找而设计的，所以这棵树本身满足一定的排序规则，即树中的任何节点的值大于它的左孩子，且小于它的右孩子。 任意节点的左、右子树也分别为二叉查找树。嗯，结合下图意会一下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180626005359234-143383116.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　而红黑树，就跟它的名字一样，又红又黑，红黑并进，理实交融，节点是非红即黑的，看起来就像这样&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719223751700-870405580.png&quot; alt=&quot;&quot;/&gt;：&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201806/1043143-20180626004222951-1996840383.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　红黑树的主要特性:&lt;br/&gt;　　（1）每个节点要么是黑色，要么是红色。（节点非黑即红）&lt;br/&gt;　　（2）根节点是黑色。&lt;br/&gt;　　（3）每个叶子节点（NIL）是黑色。 &lt;br/&gt;　　（4）如果一个节点是红色的，则它的子节点必须是黑色的。（也就是说父子节点不能同时为红色）&lt;br/&gt;　　（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。（这一点是平衡的关键）&lt;/p&gt;
&lt;p&gt;　　说简单也简单，其实就是一颗比较平衡的又红又黑的二叉树嘛。&lt;/p&gt;
&lt;h2&gt;TreeNode结构&lt;/h2&gt;
&lt;p&gt;　　既然我们已经知道红黑树长什么样了，那么我们再来看看HashMap中的TreeNode代码里是如何表示的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用于Tree bins 的Entry。 扩展LinkedHashMap.Entry（进而扩展Node），因此可以用作常规节点或链接节点的扩展。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TreeNode&amp;lt;K,V&amp;gt; &lt;span&gt;extends&lt;/span&gt; LinkedHashMap.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; parent;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 红黑树父节点&lt;/span&gt;
        TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; left;
        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; right;
        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; prev;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除后需要取消链接&lt;/span&gt;
        &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; red;
        TreeNode(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash, K key, V val, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(hash, key, val, next);
        }&lt;br/&gt;　　　　 //省略后续代码&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　TreeNode继承自LinkedHashMap中的内部类——LinkedHashMap.Entry，而这个内部类又继承自Node，所以算是Node的孙子辈了。我们再来看看它的几个属性，parent用来指向它的父节点，left指向左孩子，right指向右孩子，prev则指向前一个节点（原链表中的前一个节点），注意，这些字段跟Entry，Node中的字段一样，是使用默认访问权限的，所以子类可以直接使用父类的属性。&lt;/p&gt;
&lt;h2&gt;树化的过程&lt;/h2&gt;
&lt;p&gt;　　在前几篇中已经有所介绍，当HashMap桶中的元素个数超过一定数量时，就会树化，也就是将链表转化为红黑树的结构。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719223820739-1226100695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; putVal(hash(key), key, value, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; V putVal(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onlyIfAbsent,
                   &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) {
        ...省略部分代码...
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; binCount = 0; ; ++&lt;span&gt;binCount) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = p.next) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        p.next &lt;/span&gt;= newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当桶中元素个数超过阈值（8）时就进行树化&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (binCount &amp;gt;= TREEIFY_THRESHOLD - 1&lt;span&gt;)
                            treeifyBin(tab, hash);
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
         ...省略部分代码...
    }

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; treeifyBin(Node&amp;lt;K,V&amp;gt;[] tab, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n, index; Node&amp;lt;K,V&amp;gt;&lt;span&gt; e;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tab == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) &amp;lt;&lt;span&gt; MIN_TREEIFY_CAPACITY)
            resize();
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((e = tab[index = (n - 1) &amp;amp; hash]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; hd = &lt;span&gt;null&lt;/span&gt;, tl = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将节点替换为TreeNode&lt;/span&gt;
                TreeNode&amp;lt;K,V&amp;gt; p = replacementTreeNode(e, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tl == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;　　　　　　　　　　　　//hd指向头结点
                    hd &lt;/span&gt;=&lt;span&gt; p;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里其实是将单链表转化成了双向链表，tl是p的前驱，每次循环更新指向双链表的最后一个元素，用来和p相连，p是当前节点&lt;/span&gt;
                    p.prev =&lt;span&gt; tl;
                    tl.next &lt;/span&gt;=&lt;span&gt; p;
                }
                tl &lt;/span&gt;=&lt;span&gt; p;
            } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((e = e.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((tab[index] = hd) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将链表进行树化&lt;/span&gt;
&lt;span&gt;                hd.treeify(tab);
        }
    }  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　从代码中可以看到，在treeifyBin函数中，先将所有节点替换为TreeNode，然后再将单链表转为双链表，方便之后的遍历和移动操作。而最终的操作，实际上是调用TreeNode的方法treeify进行的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; treeify(Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] tab) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;树的根节点&lt;/span&gt;
            TreeNode&amp;lt;K,V&amp;gt; root = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x是当前节点，next是后继&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt; x = &lt;span&gt;this&lt;/span&gt;, next; x != &lt;span&gt;null&lt;/span&gt;; x =&lt;span&gt; next) {
                next &lt;/span&gt;= (TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;)x.next;
                x.left &lt;/span&gt;= x.right = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果根节点为null，把当前节点设置为根节点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    x.parent &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    x.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    root &lt;/span&gt;=&lt;span&gt; x;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    K k &lt;/span&gt;=&lt;span&gt; x.key;
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; h =&lt;span&gt; x.hash;
                    Class&lt;/span&gt;&amp;lt;?&amp;gt; kc = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里循环遍历，进行二叉搜索树的插入&lt;/span&gt;
                    &lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt; p =&lt;span&gt; root;;) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p指向遍历中的当前节点，x为待插入节点，k是x的key，h是x的hash值，ph是p的hash值，dir用来指示x节点与p的比较，-1表示比p小，1表示比p大，不存在相等情况，因为HashMap中是不存在两个key完全一致的情况。&lt;/span&gt;
                        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; dir, ph;
                        K pk &lt;/span&gt;=&lt;span&gt; p.key;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((ph = p.hash) &amp;gt;&lt;span&gt; h)
                            dir &lt;/span&gt;= -1&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ph &amp;lt;&lt;span&gt; h)
                            dir &lt;/span&gt;= 1&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果hash值相等，那么判断k是否实现了comparable接口，如果实现了comparable接口就使用compareTo进行进行比较，如果仍旧相等或者没有实现comparable接口，则在tieBreakOrder中比较&lt;/span&gt;
                        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((kc == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt;
                                  (kc &lt;/span&gt;= comparableClassFor(k)) == &lt;span&gt;null&lt;/span&gt;) ||&lt;span&gt;
                                 (dir &lt;/span&gt;= compareComparables(kc, k, pk)) == 0&lt;span&gt;)
                            dir &lt;/span&gt;=&lt;span&gt; tieBreakOrder(k, pk);

                        TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; xp =&lt;span&gt; p;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((p = (dir &amp;lt;= 0) ? p.left : p.right) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            x.parent &lt;/span&gt;=&lt;span&gt; xp;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dir &amp;lt;= 0&lt;span&gt;)
                                xp.left &lt;/span&gt;=&lt;span&gt; x;
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                xp.right &lt;/span&gt;=&lt;span&gt; x;&lt;br/&gt;　　　　　　　　　　　　　　　　 //进行插入平衡处理
                            root &lt;/span&gt;=&lt;span&gt; balanceInsertion(root, x);
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                }
            }&lt;br/&gt;　　　　　　　//确保给定节点是桶中的第一个元素
            moveRootToFront(tab, root);
        }    
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里不是为了整体排序，而是为了在插入中保持一致的顺序&lt;/span&gt;
     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; tieBreakOrder(Object a, Object b) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; d;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用两者的类名进行比较，如果相同则使用对象默认的hashcode进行比较&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (a == &lt;span&gt;null&lt;/span&gt; || b == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt;
                (d &lt;/span&gt;=&lt;span&gt; a.getClass().getName().
                 compareTo(b.getClass().getName())) &lt;/span&gt;== 0&lt;span&gt;)
                d &lt;/span&gt;= (System.identityHashCode(a) &amp;lt;= System.identityHashCode(b) ?
                     -1 : 1&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; d;
        }  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里的逻辑其实不复杂，仅仅是循环遍历当前树，然后找到可以该节点可以插入的位置，依次和遍历节点比较，比它大则跟其右孩子比较，小则与其左孩子比较，依次遍历，直到找到左孩子或者右孩子为null的位置进行插入。&lt;/p&gt;
&lt;p&gt;　　真正复杂一点的地方在于balanceInsertion函数，这个函数中，将红黑树进行插入平衡处理，保证插入节点后仍保持红黑树的性质。这个函数稍后在TreeNode的插入中进行介绍，这里先看看moveRootToFront，这个函数是将root节点移动到桶中的第一个元素，也就是链表的首节点，这样做是因为在判断桶中元素类型的时候会对链表进行遍历，将根节点移动到链表前端可以确保类型判断时不会出现错误。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 把给定节点设为桶中的第一个元素
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;        
    &lt;span&gt;static&lt;/span&gt; &amp;lt;K,V&amp;gt; &lt;span&gt;void&lt;/span&gt; moveRootToFront(Node&amp;lt;K,V&amp;gt;[] tab, TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; root) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; tab != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; index = (n - 1) &amp;amp;&lt;span&gt; root.hash;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;first指向链表第一个节点&lt;/span&gt;
                TreeNode&amp;lt;K,V&amp;gt; first = (TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;)tab[index];
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root !=&lt;span&gt; first) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果root不是第一个节点，则将root与第一个节点位置互换&lt;/span&gt;
                    Node&amp;lt;K,V&amp;gt;&lt;span&gt; rn;
                    tab[index] &lt;/span&gt;=&lt;span&gt; root;
                    TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; rp =&lt;span&gt; root.prev;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((rn = root.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        ((TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;)rn).prev =&lt;span&gt; rp;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        rp.next &lt;/span&gt;=&lt;span&gt; rn;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (first != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        first.prev &lt;/span&gt;=&lt;span&gt; root;
                    root.next &lt;/span&gt;=&lt;span&gt; first;
                    root.prev &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里是防御性编程，校验更改后的结构是否满足红黑树和双链表的特性
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为HashMap并没有做并发安全处理，可能在并发场景中意外破坏了结构&lt;/span&gt;
                &lt;span&gt;assert&lt;/span&gt;&lt;span&gt; checkInvariants(root);
            }
        }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;红黑树的左旋和右旋&lt;/h2&gt;
&lt;p&gt;　　左旋和右旋，顾名思义嘛，就是将节点以某个节点为中心向左或者向右进行旋转操作以保持二叉树的平衡，让我们看图说话&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719224136408-508018236.png&quot; alt=&quot;&quot;/&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180717135149338-1921395779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180717135200454-1697647783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　图画的有点大。将就着看一下吧，左旋和右旋相当于以要旋转的节点为中心，将子树（以该节点的父节点为根的子树）整体向左旋转，该节点变成子树的根节点，原来的根节点变成了左孩子，如果该节点原来有左孩子，则将其变为该节点左孩子的右孩子。说起来好像有点绕，可以联系图进行形象化的理解，当节点C向左旋转之后，它的左孩子D可以理解为因为重力作用掉到A的右孩子位置，嗯，就是这样。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719224801913-1141386044.png&quot; alt=&quot;&quot;/&gt;右旋也是类似理解即可。&lt;/p&gt;
&lt;h2&gt;TreeNode的左旋和右旋&lt;/h2&gt;
&lt;p&gt;　　了解了左旋和右旋，让我们看看代码里是怎样实现的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 左旋
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &amp;lt;K,V&amp;gt; TreeNode&amp;lt;K,V&amp;gt; rotateLeft(TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; root,
                                              TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; p) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的p即上图的A节点，r指向右孩子即C，rl指向右孩子的左孩子即D，pp为p的父节点&lt;/span&gt;
            TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; r, pp, rl;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (r = p.right) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((rl = p.right = r.left) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    rl.parent &lt;/span&gt;=&lt;span&gt; p;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将p的父节点的孩子节点指向r&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ((pp = r.parent = p.parent) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    (root &lt;/span&gt;= r).red = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pp.left ==&lt;span&gt; p)
                    pp.left &lt;/span&gt;=&lt;span&gt; r;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    pp.right &lt;/span&gt;=&lt;span&gt; r;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将p置为r的左节点&lt;/span&gt;
                r.left =&lt;span&gt; p;
                p.parent &lt;/span&gt;=&lt;span&gt; r;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 右旋
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;static&lt;/span&gt; &amp;lt;K,V&amp;gt; TreeNode&amp;lt;K,V&amp;gt; rotateRight(TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; root,
                                               TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; p) {
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的p即上图的A节点，l指向左孩子即C，lr指向左孩子的右孩子即E，pp为p的父节点&lt;/span&gt;
            TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; l, pp, lr;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (l = p.left) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((lr = p.left = l.right) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    lr.parent &lt;/span&gt;=&lt;span&gt; p;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((pp = l.parent = p.parent) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    (root &lt;/span&gt;= l).red = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (pp.right ==&lt;span&gt; p)
                    pp.right &lt;/span&gt;=&lt;span&gt; l;
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    pp.left &lt;/span&gt;=&lt;span&gt; l;
                l.right &lt;/span&gt;=&lt;span&gt; p;
                p.parent &lt;/span&gt;=&lt;span&gt; l;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实，也很简单嘛。23333 　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719224215023-516685596.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;红黑树的插入&lt;/h2&gt;
&lt;p&gt;　　现在来看看一个比较麻烦一点的操作，红黑树的插入，首先找到这个节点要插入的位置，即一层一层比较，大的放右边，小的放左边，直到找到为null的节点放入即可，但是如何在插入的过程保持红黑树的特性呢，想想好像比较头疼，但是再仔细想想其实就会发现，其实只有这么几种情况：&lt;/p&gt;
&lt;p&gt;　　1.插入的为根节点，则直接把颜色改成黑色即可。&lt;/p&gt;
&lt;p&gt;　　2.插入的节点的父节点是黑色节点，则不需要调整，因为插入的节点会初始化为红色节点，红色节点是不会影响树的平衡的。&lt;/p&gt;
&lt;p&gt;　　3.插入的节点的祖父节点为null，即插入的节点的父节点是根节点，直接插入即可（因为根节点肯定是黑色）。&lt;/p&gt;
&lt;p&gt;　　4.插入的节点父节点和祖父节点都存在，并且其父节点是祖父节点的左节点。这种情况稍微麻烦一点，又分两种子情况：&lt;/p&gt;
&lt;p&gt;　　　　i.插入节点的叔叔节点是红色，则将父亲节点和叔叔节点都改成黑色，然后祖父节点改成红色即可。&lt;/p&gt;
&lt;p&gt;　　　　ii.插入节点的叔叔节点是黑色或不存在：&lt;/p&gt;
&lt;p&gt;　　　　　　a.若插入节点是其父节点的右孩子，则将其父节点左旋，&lt;/p&gt;
&lt;p&gt;　　　　　　b.若为左孩子，则将其父节点变成黑色节点，将其祖父节点变成红色节点，然后将其祖父节点右旋。&lt;/p&gt;
&lt;p&gt;　　5.插入的节点父节点和祖父节点都存在，并且其父节点是祖父节点的右节点。这种情况跟上面是类似的，分两种子情况：&lt;/p&gt;
&lt;p&gt;　　　　i.插入节点的叔叔节点是红色，则将父亲节点和叔叔节点都改成黑色，然后祖父节点改成红色即可。&lt;/p&gt;
&lt;p&gt;　　　　ii.插入节点的叔叔节点是黑色或不存在：&lt;/p&gt;
&lt;p&gt;　　　　　　a.若插入节点是其父节点的左孩子，则将其父节点右旋&lt;/p&gt;
&lt;p&gt;　　　　　　b.若为右孩子，则将其父节点变成黑色节点，将其祖父节点变成红色节点，然后将其祖父节点左旋。&lt;/p&gt;
&lt;p&gt;　　然后重复进行上述操作，直到变成1或2情况时则结束变换。说半天，可能还是云里雾里，一图胜千言，让我们从无到有构建一颗红黑树，假设插入的顺序为：10，5，9，3，6，7，19，32，24，17（数字是我拍脑袋瞎想的。）&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719224258128-564157705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　先来插个10，为情景1，直接改成黑色即可，再插入5，为情景2，比10小，放到10的左孩子位置，插入9，比10小，但是比5大，放到5的右孩子位置，此时，为情景4iia，左旋后变成了情景4iib，变色右旋即可完成转化。插入3后为情景4i，将父节点和叔叔节点同时变色即可，插入6不需要调整，插入7后为情景5i，变色即可。插入19不需要调整，插入32，变成了5iib，左旋变色即可，插入24，变成5iia，右旋后变成5i，变色即可，最后插入17，完美。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180717135851407-469306294.png&quot; alt=&quot;&quot; width=&quot;875&quot; height=&quot;309&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180717135859873-859397966.png&quot; alt=&quot;&quot; width=&quot;898&quot; height=&quot;274&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180717135905643-473262190.png&quot; alt=&quot;&quot; width=&quot;998&quot; height=&quot;270&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180718102117876-751491712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180718102204970-108750217.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　看图说话是不是就简单明了了，看在我画图这么辛苦的份上，点个关注给个赞可好（滑稽）。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719224328484-1527173379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;TreeNode的插入&lt;/h2&gt;
&lt;p&gt;　　了解了红黑树的删除之后，我们再来看下TreeNode中是怎样用代码实现的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;static&lt;/span&gt; &amp;lt;K,V&amp;gt; TreeNode&amp;lt;K,V&amp;gt; balanceInsertion(TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; root,
                                                    TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; x) {
            x.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; xp, xpp, xppl, xppr;;) {&lt;br/&gt;//情景1：父节点为null
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((xp = x.parent) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    x.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
                }&lt;br/&gt;　　　　　　　　　 //情景2，3：父节点是黑色节点或者祖父节点为null
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!xp.red || (xpp = xp.parent) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root;&lt;br/&gt;　　　　　　　　　　//情景4：插入的节点父节点和祖父节点都存在，并且其父节点是祖父节点的左节点
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xp == (xppl =&lt;span&gt; xpp.left)) {&lt;br/&gt;　　　　　　　　　　　　//情景4i：插入节点的叔叔节点是红色
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((xppr = xpp.right) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; xppr.red) {
                        xppr.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        xp.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        xpp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        x &lt;/span&gt;=&lt;span&gt; xpp;
                    }&lt;br/&gt;　　　　　　　　　　　　//情景4ii：插入节点的叔叔节点是黑色或不存在
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;　　　　　　　　　　　　　　//情景4iia：插入节点是其父节点的右孩子
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x ==&lt;span&gt; xp.right) {
                            root &lt;/span&gt;= rotateLeft(root, x =&lt;span&gt; xp);
                            xpp &lt;/span&gt;= (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : xp.parent;
                        }&lt;br/&gt;　　　　　　　　　　　　　　//情景4iib：插入节点是其父节点的左孩子
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            xp.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xpp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                xpp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                                root &lt;/span&gt;=&lt;span&gt; rotateRight(root, xpp);
                            }
                        }
                    }
                }&lt;br/&gt;　　　　　　　　　 //情景5：插入的节点父节点和祖父节点都存在，并且其父节点是祖父节点的右节点
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;　　　　　　　　　　　　//情景5i：插入节点的叔叔节点是红色
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xppl != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; xppl.red) {
                        xppl.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        xp.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        xpp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        x &lt;/span&gt;=&lt;span&gt; xpp;
                    }&lt;br/&gt;　　　　　　　　　　　　//情景5ii：插入节点的叔叔节点是黑色或不存在
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;·　　　　　　　　　　　　　　//情景5iia：插入节点是其父节点的左孩子　
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x ==&lt;span&gt; xp.left) {
                            root &lt;/span&gt;= rotateRight(root, x =&lt;span&gt; xp);
                            xpp &lt;/span&gt;= (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : xp.parent;
                        }&lt;br/&gt;　　　　　　　　　　　　　　//情景5iib：插入节点是其父节点的右孩子
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            xp.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xpp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                                xpp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                                root &lt;/span&gt;=&lt;span&gt; rotateLeft(root, xpp);
                            }
                        }
                    }
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其实就是一毛一样的，对号入座即可。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719224344101-982941197.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;红黑树的删除&lt;/h2&gt;
&lt;p&gt;　　讲完插入，接下来我们来说说删除，删除的话，比插入还要复杂一点，请各位看官先深呼吸，做好阅读准备。&lt;/p&gt;
&lt;p&gt;　　之前已经说过，红黑树是一颗特殊的二叉搜索树，所以进行删除操作时，其实是先进行二叉搜索树的删除，然后再进行调整。所以，其实这里分为两部分内容：1.二叉搜索树的删除，2.红黑树的删除调整。&lt;/p&gt;
&lt;p&gt;　　二叉搜索树的删除主要有这么几种情景：&lt;/p&gt;
&lt;p&gt;　　情景1：待删除的节点无左右孩子。&lt;/p&gt;
&lt;p&gt;　　情景2：待删除的节点只有左孩子或者右孩子。&lt;/p&gt;
&lt;p&gt;　　情景3：待删除的节点既有左孩子又有右孩子。&lt;/p&gt;
&lt;p&gt;　　对于情景1，直接删除即可，情景2，则直接把该节点的父节点指向它的左孩子或者右孩子即可，情景3稍微复杂一点，需要先找到其右子树的最左孩子（或者左子树的最右孩子），即左（右）子树中序遍历时的第一个节点，然后将其与待删除的节点互换，最后再删除该节点（如果有右子树，则右子树上位）。总之，就是先找到它的替代者，找到之后替换这个要删除的节点，然后再把这个节点真正删除掉。&lt;/p&gt;
&lt;p&gt;　　其实二叉搜索树的删除总体来说还是比较简单的，删除完之后，如果替代者是红色节点，则不需要调整，如果是黑色节点，则会导致左子树和右子树路径中黑色节点数量不一致，需要进行红黑树的调整，跟上面一样，替代节点为其父节点的左孩子与右孩子的情况类似，所以这里只说其为左孩子的情景（PS:上一步的寻找替换节点使用的是右子树的最左节点，所以该节点如果有孩子，只能是右孩子）：&lt;/p&gt;
&lt;p&gt;　　情景1：只有右孩子且为红色，直接用右孩子替换该节点然后变成黑色即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719092859077-455815721.png&quot; alt=&quot;&quot; width=&quot;615&quot; height=&quot;330&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　（D代表替代节点，即要被删除的节点，之前在经过二叉搜索树的删除后，D节点其实已经被删除了，这里为了方便理解这个变化过程，所以把这个节点也画出来了，所以当前的初始状态是待删除节点与其替换节点互换位置与颜色之后的状态）&lt;/p&gt;
&lt;p&gt;　　情景2：只有右孩子且为黑色，那么删除该节点会导致父节点的左子树路径上黑色节点减一，此时只能去借助右子树，从右子树中借一个红色节点过来即可，具体取决于右子树的情况，这里又分成两种：&lt;/p&gt;
&lt;p&gt;　　　　i.兄弟节点是红色，则此时父节点是黑色，且兄弟节点肯定有两个孩子，且兄弟节点的左右子树路径上均有两个黑色节点，此时只需将兄弟节点与父节点颜色互换，然后将父节点左旋，左旋后，兄弟节点的左子树SL挂到了父节点p的右孩子位置，这时会导致p的右子树路径上的黑色节点比左子树多一，此时再SL置为红色即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719214140303-507970717.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;　　　　ii.兄弟节点是黑色，那么就只能打它孩子的主意了，这里主要关注远侄子（兄弟节点的右孩子，即SR）的颜色情况，这里分成两种情况：&lt;/p&gt;
&lt;p&gt;　　　　　　a.远侄子SR是黑色，近侄子任意（白色代表颜色可为任意颜色），则先将S转为红色，然后右旋，再将SL换成P节点颜色，P涂成黑色，S也涂成黑色，再进行左旋即可。其实简单说就是SL上位，替换父节点位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719214715292-764463825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　b.远侄子SR为红色，近侄子任意（该子树路径中有且仅有一个黑色节点），则先将兄弟节点与父节点颜色互换，将SR涂成黑色，再将父节点左旋即可。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719214928467-1870569067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　emmmm...好像也不是很麻烦嘛（逃）。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719224357701-1504779388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;TreeNode的删除节点&lt;/h2&gt;
&lt;p&gt;　　TreeNode删除节点其实也是两步走，先进行二叉搜索树的删除，然后再进行红黑树的调整，跟之前的情况分析是一致的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; removeTreeNode(HashMap&amp;lt;K,V&amp;gt; map, Node&amp;lt;K,V&amp;gt;[] tab, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; movable) {

     ......

     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p是待删除节点，replacement用于后续的红黑树调整，指向的是p或者p的继承者。
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果p是叶子节点，p==replacement，否则replacement为p的右子树中最左节点&lt;/span&gt;
     &lt;span&gt;if&lt;/span&gt; (replacement !=&lt;span&gt; p) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若p不是叶子节点，则让replacement的父节点指向p的父节点&lt;/span&gt;
        TreeNode&amp;lt;K,V&amp;gt; pp = replacement.parent =&lt;span&gt; p.parent;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pp == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            root &lt;/span&gt;=&lt;span&gt; replacement;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; pp.left)
            pp.left &lt;/span&gt;=&lt;span&gt; replacement;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            pp.right &lt;/span&gt;=&lt;span&gt; replacement;
        p.left &lt;/span&gt;= p.right = p.parent = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若待删除的节点p时红色的，则树平衡未被破坏，无需进行调整。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则删除节点后需要进行调整&lt;/span&gt;
    TreeNode&amp;lt;K,V&amp;gt; r = p.red ?&lt;span&gt; root : balanceDeletion(root, replacement);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p为叶子节点，则直接将p从树中清除&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (replacement == p) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; detach&lt;/span&gt;
        TreeNode&amp;lt;K,V&amp;gt; pp =&lt;span&gt; p.parent;
        p.parent &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; pp.left)
                pp.left &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; pp.right)
                pp.right &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　麻烦的地方就在删除节点后的调整了，所有逻辑都在balanceDeletion函数里，两个参数分别表示根节点和删除节点的继承者，来看看它的具体实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &amp;lt;K,V&amp;gt; TreeNode&amp;lt;K,V&amp;gt; balanceDeletion(TreeNode&amp;lt;K,V&amp;gt; root, TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; x) {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt; xp, xpl, xpr;;)  {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x为空或x为根节点，直接返回&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (x == &lt;span&gt;null&lt;/span&gt; || x ==&lt;span&gt; root)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root; 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x为根节点，染成黑色，直接返回（因为调整过后，root并不一定指向删除操作过后的根节点，如果之前删除的是root节点，则x将成为新的根节点）&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((xp = x.parent) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            x.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;; 
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果x为红色，则无需调整，返回&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (x.red) {
            x.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; root; 
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x为其父节点的左孩子&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((xpl = xp.left) ==&lt;span&gt; x) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果它有红色的兄弟节点xpr，那么它的父亲节点xp一定是黑色节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((xpr = xp.right) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; xpr.red) { 
                xpr.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                xp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;; 
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对父节点xp做左旋转&lt;/span&gt;
                root =&lt;span&gt; rotateLeft(root, xp); 
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新将xp指向x的父节点，xpr指向xp新的右孩子&lt;/span&gt;
                xpr = (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : xp.right; 
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果xpr为空，则向上继续调整，将x的父节点xp作为新的x继续循环&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (xpr == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                x &lt;/span&gt;=&lt;span&gt; xp; 
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//sl和sr分别为其近侄子和远侄子&lt;/span&gt;
                TreeNode&amp;lt;K,V&amp;gt; sl = xpr.left, sr =&lt;span&gt; xpr.right;&lt;br/&gt;　　　　　　　　　　　　
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((sr == &lt;span&gt;null&lt;/span&gt; || !sr.red) &amp;amp;&amp;amp;&lt;span&gt;
                    (sl &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;sl.red)) {
                    xpr.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若sl和sr都为黑色或者不存在，即xpr没有红色孩子，则将xpr染红&lt;/span&gt;
                    x = xp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;本轮结束，继续向上循环&lt;/span&gt;
&lt;span&gt;                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则的话，就需要进一步调整&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (sr == &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;sr.red) { 
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sl != &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若左孩子为红，右孩子不存在或为黑&lt;/span&gt;
                            sl.red = &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左孩子染黑&lt;/span&gt;
                        xpr.red = &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将xpr染红&lt;/span&gt;
                        root = rotateRight(root, xpr); &lt;span&gt;//右旋&lt;/span&gt;
                        xpr = (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ?
                            &lt;span&gt;null&lt;/span&gt; : xp.right;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右旋后，xpr指向xp的新右孩子，即上一步中的sl&lt;/span&gt;
&lt;span&gt;                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xpr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        xpr.red &lt;/span&gt;= (xp == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;false&lt;/span&gt; : xp.red; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;xpr染成跟父节点一致的颜色，为后面父节点xp的左旋做准备&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; ((sr = xpr.right) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                            sr.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;xpr新的右孩子染黑，防止出现两个红色相连&lt;/span&gt;
&lt;span&gt;                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        xp.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将xp染黑，并对其左旋，这样就能保证被删除的X所在的路径又多了一个黑色节点，从而达到恢复平衡的目的&lt;/span&gt;
                        root =&lt;span&gt; rotateLeft(root, xp);
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;到此调整已经完毕，进入下一次循环后将直接退出&lt;/span&gt;
                    x =&lt;span&gt; root;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x为其父节点的右孩子，跟上面类似&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; symmetric&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (xpl != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; xpl.red) {
                xpl.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                xp.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                root &lt;/span&gt;=&lt;span&gt; rotateRight(root, xp);
                xpl &lt;/span&gt;= (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : xp.left;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xpl == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                x &lt;/span&gt;=&lt;span&gt; xp;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt; sl = xpl.left, sr =&lt;span&gt; xpl.right;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((sl == &lt;span&gt;null&lt;/span&gt; || !sl.red) &amp;amp;&amp;amp;&lt;span&gt;
                    (sr &lt;/span&gt;== &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;sr.red)) {
                    xpl.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    x &lt;/span&gt;=&lt;span&gt; xp;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sl == &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;sl.red) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                            sr.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        xpl.red &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        root &lt;/span&gt;=&lt;span&gt; rotateLeft(root, xpl);
                        xpl &lt;/span&gt;= (xp = x.parent) == &lt;span&gt;null&lt;/span&gt; ?
                            &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : xp.left;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xpl != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        xpl.red &lt;/span&gt;= (xp == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;false&lt;/span&gt;&lt;span&gt; : xp.red;
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((sl = xpl.left) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                            sl.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        xp.red &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                        root &lt;/span&gt;=&lt;span&gt; rotateRight(root, xp);
                    }
                    x &lt;/span&gt;=&lt;span&gt; root;
                }
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　呼。。。终于。。酝酿了好多天的一篇文章总算是写完了，为了尽量确认转换的准确性，找了很多资料进行参考，过程中花了不少时间，曾多次准备放弃。。。不过总算是没有死在娘胎里，也算是完成了一桩心事，开心。&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719224418617-1782235223.png&quot; alt=&quot;&quot;/&gt;.&lt;/p&gt;
&lt;p&gt;　　之后还会继续更新，欢迎大家继续关注。也欢迎大家前来打脸&lt;img src=&quot;https://images2018.cnblogs.com/blog/1043143/201807/1043143-20180719224705363-1506878908.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 19 Jul 2018 14:49:00 +0000</pubDate>
<dc:creator>弗兰克的猫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mfrank/p/9227097.html</dc:identifier>
</item>
<item>
<title>关于JavaScript中this的软绑定 - 酥风</title>
<link>http://www.cnblogs.com/su-feng/p/9338911.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/su-feng/p/9338911.html</guid>
<description>&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;首先，什么是软绑定？&lt;/h3&gt;
&lt;p&gt;所谓软绑定，是和硬绑定相对应的一个词，在详细解释软绑定之前，我们先来看看硬绑定。在JavaScript中，this的绑定是动态的，在函数被调用的时候绑定，它指向什么完全取决于函数在哪里调用，情况比较复杂，光是绑定规则就有默认绑定、隐式绑定、显式绑定、new绑定等，而硬绑定是显式绑定中的一种，通常情况下是通过调用函数的 &lt;span class=&quot;cnblogs_code&quot;&gt;apply()&lt;/span&gt; 、 &lt;span class=&quot;cnblogs_code&quot;&gt;call()&lt;/span&gt; 或者ES5里提供的 &lt;span class=&quot;cnblogs_code&quot;&gt;bind()&lt;/span&gt; 方法来实现硬绑定的。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;硬绑定有什么问题，为什么需要软绑定&lt;/h3&gt;
&lt;p&gt;上述三个方法好是好，可以按照自己的想法将函数的this强制绑定到指定的对象上（除了使用new绑定可以改变硬绑定外），但是硬绑定存在一个问题，就是会降低函数的灵活性，并且在硬绑定之后无法再使用隐式绑定或者显式绑定来修改this的指向。&lt;/p&gt;
&lt;div readability=&quot;26.708342909676&quot;&gt;
&lt;p&gt;在这种情况下，被称为软绑定的实现就出现了，也就是说，通过软绑定，我们希望this在默认情况下不再指向全局对象（非严格模式）或 &lt;span class=&quot;cnblogs_code&quot;&gt;undefined&lt;/span&gt; （严格模式），而是指向两者之外的一个对象（这点和硬绑定的效果相同），但是同时又保留了隐式绑定和显式绑定在之后可以修改this指向的能力。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;软绑定的具体实现&lt;/h3&gt;
&lt;p&gt;在这里，我用的是《你不知道的JavaScript 上》中的软绑定的代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;Function.prototype.softBind){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Function.prototype.softBind=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; fn=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; args=Array.prototype.slice.call(arguments,1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; bound=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; fn.apply(
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 (!&lt;span&gt;this&lt;/span&gt;||&lt;span&gt;this&lt;/span&gt;===(window||global))?obj:&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                args.concat.apply(args,arguments)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            );
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         bound.prototype=&lt;span&gt;Object.create(fn.prototype);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bound;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们先来看一下效果，之后再讨论它的实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(){
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     console.log(&quot;name: &quot;+&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; obj1={name:&quot;obj1&quot;&lt;span&gt;},
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     obj2={name:&quot;obj2&quot;&lt;span&gt;},
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     obj3={name:&quot;obj3&quot;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; fooOBJ=&lt;span&gt;foo.softBind(obj1);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; fooOBJ();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;name: obj1&quot; 在这里软绑定生效了，成功修改了this的指向，将this绑定到了obj1上&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; obj2.foo=&lt;span&gt;foo.softBind(obj1);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; obj2.foo();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;name: obj2&quot; 在这里软绑定的this指向成功被隐式绑定修改了，绑定到了obj2上&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; fooOBJ.call(obj3);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;name: obj3&quot; 在这里软绑定的this指向成功被硬绑定修改了，绑定到了obj3上&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; setTimeout(obj2.foo,1000);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;name: obj1&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;回调函数相当于一个隐式的传参，如果没有软绑定的话，这里将会应用默认绑定将this绑定到全局环
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;境上，但有软绑定，这里this还是指向obj1&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到软绑定生效了。下面我们来具体看一下 &lt;span class=&quot;cnblogs_code&quot;&gt;softBind()&lt;/span&gt; 的实现。&lt;/p&gt;

&lt;div readability=&quot;13.250491545419&quot;&gt;
&lt;p&gt;在第一行，先通过判断，如果函数的原型上没有 &lt;span class=&quot;cnblogs_code&quot;&gt;softBind()&lt;/span&gt; 这个方法，则添加它，然后通过 &lt;span class=&quot;cnblogs_code&quot;&gt;Array.prototype.slice.call(arguments,1)&lt;/span&gt; 获取传入的外部参数，这里这样做其实为了函数柯里化，也就是说，允许在软绑定的时候，事先设置好一些参数，在调用函数的时候再传入另一些参数（关于函数柯里化大家可以去网上搜一下详细的讲解）最后返回一个 &lt;span class=&quot;cnblogs_code&quot;&gt;bound&lt;/span&gt; 函数形成一个闭包，这时候，在函数调用 &lt;span class=&quot;cnblogs_code&quot;&gt;softBind()&lt;/span&gt; 之后，得到的就是 &lt;span class=&quot;cnblogs_code&quot;&gt;bound&lt;/span&gt; 函数，例如上面的 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;var&lt;/span&gt; fooOBJ=foo.softBind(obj1)&lt;/span&gt; 。&lt;/p&gt;

&lt;div readability=&quot;12.193850964044&quot;&gt;
&lt;p&gt;在 &lt;span class=&quot;cnblogs_code&quot;&gt;bound&lt;/span&gt; 函数中，首先会判断调用软绑定之后的函数（如fooOBJ）的调用位置，或者说它的this的指向，如果 &lt;span class=&quot;cnblogs_code&quot;&gt;!&lt;span&gt;this&lt;/span&gt;&lt;/span&gt; （this指向undefined）或者 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;this&lt;/span&gt;===(window||global)&lt;/span&gt; （this指向全局对象），那么就将函数的this绑定到传入 &lt;span class=&quot;cnblogs_code&quot;&gt;softBind&lt;/span&gt; 中的参数obj上。如果此时this不指向undefind或者全局对象，那么就将this绑定到现在正在指向的函数（即隐式绑定或显式绑定）。 &lt;span class=&quot;cnblogs_code&quot;&gt;fn.apply&lt;/span&gt; 的第二个参数则是运行 &lt;span class=&quot;cnblogs_code&quot;&gt;foo&lt;/span&gt; 所需要的参数，由上面的args（外部参数）和内部的arguments（内部参数）连接成，也就是上面说的柯里化。&lt;/p&gt;

&lt;div readability=&quot;9.6305031446541&quot;&gt;
&lt;p&gt;其实在第一遍看这个函数时，也有点迷，有一些疑问，比如 &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;var&lt;/span&gt; fn=&lt;span&gt;this&lt;/span&gt;&lt;/span&gt; 这句，在 &lt;span class=&quot;cnblogs_code&quot;&gt;foo&lt;/span&gt; 通过 &lt;span class=&quot;cnblogs_code&quot;&gt;foo.softBind()&lt;/span&gt; 调用 &lt;span class=&quot;cnblogs_code&quot;&gt;softBind&lt;/span&gt; 的时候，fn到底指向谁呢？是指向foo还是指向softBind？我们可以写个demo测试，然后可以很清晰地看出fn指向什么：&lt;/p&gt;
&lt;div readability=&quot;9.0392156862745&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; a=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; foo.a=3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; Function.prototype.softBind=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; fn=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        console.log(fn.a);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; Function.prototype.a=4&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; Function.prototype.softBind.a=5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; foo.softBind()();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; Function.prototype.softBind()();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div readability=&quot;10.713245997089&quot;&gt;
&lt;p&gt;可以看出，fn（或者说this）的指向还是遵循this的绑定规则的， &lt;span class=&quot;cnblogs_code&quot;&gt;softBind&lt;/span&gt; 函数定义在Function的原型 &lt;span class=&quot;cnblogs_code&quot;&gt;Function.prototype&lt;/span&gt; 中，但是JavaScript中函数永远不会“属于”某个对象（不像其他语言如java中类里面定义的方法那样），只是对象内部引用了这个函数，所以在通过下面两种方式调用时，fn（或者说this）分别隐式绑定到了 &lt;span class=&quot;cnblogs_code&quot;&gt;foo&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;Function.prototype&lt;/span&gt; ，所以分别输出3和4。后面的 &lt;span class=&quot;cnblogs_code&quot;&gt;fn.apply()&lt;/span&gt; 也就相当于 &lt;span class=&quot;cnblogs_code&quot;&gt;foo.apply()&lt;/span&gt; 。&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


</description>
<pubDate>Thu, 19 Jul 2018 14:49:00 +0000</pubDate>
<dc:creator>酥风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/su-feng/p/9338911.html</dc:identifier>
</item>
</channel>
</rss>