<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>用信号量为共享内存添加同步机制 - tp_16b</title>
<link>http://www.cnblogs.com/tp-16b/p/8992092.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tp-16b/p/8992092.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;进程间通信的方式中，我们将多个进程共享同一块存储区来进行数据交换的方式称为共享内存通信。源于它直接将“内存”共享的特殊机制，它成为最快的一种&lt;strong&gt;&lt;span&gt;IPC通信方式&lt;/span&gt;&lt;/strong&gt;；然而它也不完美，它虽快，但是没有同步机制；通常在一个服务进程对共享存储区还未完成写操作之前，客户进程是不应当去取这些数据的，可没了同步，那可就乱了套了。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;这种情况不是我们所愿意看到的，所以基于此 我们常常需要为用到的共享内存段添加上同步的机制，使之“完美”起来。通常呢，实现同步我们很自然地会想到信号量，是的，这里我就是这么干的。用基于信号量的PV操作实现完成一个带同步机制的共享内存段，这样它就可以像一个“fifo”队列一样了，并且它传输效率还会表现得非常不错，虽然它还比较简陋～。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;信号量及相关函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;先来说说用到的信号量及处理函数吧。信号量和其它的IPC结构（前面总结过管道、消息队列）不同。它本质就是一个计数器，用于为多个进程提供对共享数据对象的访问。通常进程为了获得共享的资源，需要执行以下操作：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;①测试控制该资源的信号量&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;②若此信号量&amp;gt;0,则进程可以使用该资源。此种情况下，进程会将信号量值减1，表明它使用了一个资源单位。&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;③否则，此信号量的值为0，则使该进程进入休眠状态，直至信号量值&amp;gt;1。如果有进程正在休眠状态等待此信号量，则唤醒它们&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;还有就是为了正确的实现信号量，信号量值的测试及减1操作还应当是原子的。为此，信号量通常是在内核中实现的。一般而言，信号量初值可以是任意一个正值，该值表明有多少个共享资源单位可供共享应用。然而遗憾的是，这里我用到的&lt;span&gt;XSI信号量也是有缺陷的。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;这源于①信号量并非是单个非负值，它被定义为一个可能含有多个信号量值的集合。通常在创建信号量的时候，对该集合中信号量数量进行指定 ②信号量创建独立于它的初始化。这是最致命的，因为这将导致的是不能原子的创建一个信号量集合，并对该集合中的各个信号量值赋初值。③有的程序1在终止时可能并没有释放掉已经分配给它的信号量。&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;而对于信号处理函数通常有3个，首先是&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;1.&lt;span&gt;&lt;strong&gt;&lt;strong&gt;semget函数&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;作用：创建一个新的信号量或取得一个已有的信号量&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
原型：&lt;strong&gt;&lt;span&gt;int&lt;/span&gt; semget(key_t key, &lt;span&gt;int&lt;/span&gt; nsems, &lt;span&gt;int&lt;/span&gt; semflg)&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;int nsems   //它代表信号量集合中有多少个信号量。如果是创建新集合，则必须指定它；如果是引用现有的信号集（通常客户进程中），则将其指定为0.&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;int semflg  //和前面IPC机制类似，用来初始化信号集维护的semid_ds结构中的ipc_perm结构成员sem_perm。通常用IPC_CREAT|0644创建，要直接打开已存在的话 也直接填0就好&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.&lt;span&gt;semctl函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用途：&lt;span&gt;该函数用来直接控制信号量信息.也就是直接删除信号量或者初始化信号量.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
原型：&lt;strong&gt;&lt;span&gt;int&lt;/span&gt; semctl(&lt;span&gt;int&lt;/span&gt; semid, &lt;span&gt;int&lt;/span&gt; semnum, &lt;span&gt;int&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; cmd, ...)&lt;/strong&gt;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　int semid   &lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;semget函数返回的信号量标识符.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　int semnum,  //它代表要给该信号量集中的第几个信号量设置初值&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　int cmd　　 //通常用&lt;span&gt;SETVAL&lt;span&gt;/&lt;/span&gt;GETVAL&lt;/span&gt;&lt;span&gt;&lt;span&gt;设置和获取信号量集中的一个单独的信号量&lt;/span&gt;。&lt;span&gt;具体还有&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('82951ccf-1e1a-4ab7-87f4-efdc57e99a33')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_82951ccf-1e1a-4ab7-87f4-efdc57e99a33&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_82951ccf-1e1a-4ab7-87f4-efdc57e99a33&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('82951ccf-1e1a-4ab7-87f4-efdc57e99a33',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_82951ccf-1e1a-4ab7-87f4-efdc57e99a33&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
IPC_STAT &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取一个信号量集的数据结构semid_ds，并将其存储在semun中的buf参数中。&lt;/span&gt;
&lt;span&gt;
IPC_SET  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置信号量集的数据结构semid_ds中的元素ipc_perm，其值取自semun中的buf参数。&lt;/span&gt;
IPC_RMID  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将信号量集从内存中删除。&lt;/span&gt;
&lt;span&gt; 
GETALL  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于读取信号量集中的所有信号量的值。&lt;/span&gt;
&lt;span&gt;
GETNCNT  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回正在等待资源的进程数目。&lt;/span&gt;
&lt;span&gt;
GETPID  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回最后一个执行semop操作的进程的PID。&lt;/span&gt;
&lt;span&gt;
GETVAL   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回信号量集中的一个单个的信号量的值。&lt;/span&gt;
&lt;span&gt;
GETZCNT  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回这在等待完全空闲的资源的进程数目。&lt;/span&gt;
&lt;span&gt;
SETALL   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置信号量集中的所有的信号量的值。&lt;/span&gt;
&lt;span&gt;
SETVAL   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置信号量集中的一个单独的信号量的值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;cmd的种类&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;如果有第四个参数，取决于所请求的命令，如果使用该参数，它通常是一个&lt;span&gt;union semum&lt;/span&gt;结构，定义如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;union semun
{    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; val;    &lt;span&gt;&lt;span&gt;&lt;span&gt;/*&lt;span&gt; Value for SETVAL &lt;span&gt;*/&lt;span&gt;通常就要它就够了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; semid_ds *&lt;span&gt;buf;    
    unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *&lt;span&gt;arry;    
};  &lt;br/&gt;&lt;span&gt;赋值形式:semun.val = 2  //初值放在val中&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;执行PV操作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.&lt;span&gt;semop函数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;用途：用来改变信号量的值，该函数是具有原子性的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;原型：int&lt;/span&gt; semop(&lt;span&gt;int&lt;/span&gt; semid, &lt;span&gt;struct&lt;/span&gt; sembuf *sops, size_t nsops)&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;参数：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　&lt;span&gt;&lt;span&gt;sem_id&lt;/span&gt;　　 //是由semget函数返回的信号量标识符.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;struct sembuf *sops&lt;/span&gt; //sops是一个指针，指向一个有sembuf结构表示的信号量操作数组，本质上就代表了一个数组地址。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　size_t nsops    //&lt;span&gt;相当于数组元素个数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;该第二个参数维护数据结构struct sembuf定义如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
struct sembuf
{
      unsigned short sem_num;  /* semaphore number */除非使用一组信号量，否则它为0  
      short          sem_op;   /* semaphore operation */ p -1,  v  1
      short          sem_flg;  /* operation flags */  填 0就好 SEM_NOWAIT   SEM_UNDO
}&lt;br/&gt;注意这当中的sem_op参数，信号量集合中的各个成员的操作都应由相应的sem_op值规定。此值可正可负可为0，相应的值就代表对于进程中占用的资源数量，同时这&lt;br/&gt;值会加到信号量值上，若指定undo标志，还从信号量调整值上减去sem_op.
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;&lt;span&gt;&lt;span&gt;共享内存增添同步机制&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt; 下面开始操作这段共享内存，使其带有同步，然后模拟重现我们操作系统书上的那个经典的生产消费者问题，并且解决它。这里我画个图帮助整理思路：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201805/1272978-20180511174331191-1777862897.png&quot; alt=&quot;&quot; width=&quot;703&quot; height=&quot;391&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，定义出一个管理内存段的“shmfifo”结构，该结构中具体又用一个shm_head结构来管理数据读写的位置信息和大小。同时，shimfifo结构中还维护了3个用于解决互斥和同步的信号量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201805/1272978-20180511221357939-1202985631.png&quot; alt=&quot;&quot; width=&quot;475&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;维护的shm_head结构存放在共享内存的头部，当写入的数据从payload处开始写入，每次写入之后，便更新头部的wr_idx位，payload可由_head+1得到；同样，最开始读出数据时也是从payload处开始读，每次读完便更新wr_idx。好，到这里就有了大致的思路。于是可以实现出来它的头文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
 #ifndef __SHMFIFO_H__
 #define __SHMFIFO_H__
 
 #include &amp;lt;sys/ipc.h&amp;gt;
 #include &amp;lt;string.h&amp;gt;
 #include &amp;lt;stdlib.h&amp;gt;
 #include &amp;lt;stdio.h&amp;gt;
 #include &amp;lt;sys/ipc.h&amp;gt;
 #include &amp;lt;sys/sem.h&amp;gt;
 #include &amp;lt;sys/shm.h&amp;gt;
 
 typedef struct shmhead {
     int rd_idx; // 读入数据索引
     int wr_idx; // 写数据索引
     int blocks; // 存数据块数量
     int blksz;  // 每个数据块大小
 }shmhead_t;
 
 typedef struct shmfifo {
     shmhead_t *p_head;    // 共享内存的起始地址
     char *     p_payload; // 有效数据的起始地址
     int shmid;            // 打开的共享内存id
     int sem_mutex;        // 互斥量 
     int sem_empty;        // 还剩多少个可以消费&lt;br/&gt;int sem_full; // 剩余多少个地方可以生产
 }shmfifo_t;
 
 // 初始化函数
 shmfifo_t *shmfifo_init(key_t key, int blocks, int blksz);
 // 放入数据
 void shmfifo_put(shmfifo_t *fifo, const void *buf);
 // 取得数据
 void shmfifo_get(shmfifo_t *fifo, void *buf);
 // 结构销毁 
 void shmfifo_destroy(shmfifo_t *fifo);
 
 #endif //__SHMFIFO_H__
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 紧接着要考虑就该结构的初始化。首先，肯定是先要为结构开出空间来，其大小不难分析应该为shm_head大小加上blocks*blksz，其次就是一步步对这些变量和信号进行初始化了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;紧接着，对于放数据和取数据就依葫芦画瓢就好了，值得注意就是对信号量的处理，进行PV操作时，针对写数据时，我们需要先P(sem_empty)保证先有地方可以放数据，其次才进行P（sem_mutex）保证互斥性。否则，会因为在放入数据是进行了P（sem_mutex）操作,进而使取数据进程阻塞在信号量sem_mutex&amp;lt;0条件上，然后放数据完成，进行V(sem_full)后再进行V(sem_mutex)；在进行取数据操作时同理。基于此，便可有以下代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;94&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
 #include &quot;shmfifo.h&quot;
 
 typedef union semun{
     int val;
 }semun;
 
 // 初始化
 shmfifo_t* shmfifo_init(key_t key, int blocks, int blksz)
 {
     shmfifo_t *p = malloc(sizeof(shmfifo_t));
 
     int shmid = shmget(key, 0, 0);
     int len = sizeof(shmhead_t) + blocks*blksz; //共享内存段大小
 
     if(shmid == -1 )  // 内存段不存在，创建
     {   
         shmid = shmget(key, len, IPC_CREAT|0644);
         if ( shmid == -1) perror(&quot;shmget&quot;),exit(1);
 
         //初始化内存段头
         p-&amp;gt;p_head = shmat(shmid, NULL, 0); //将开出的内存段挂载到进程地址空间
         p-&amp;gt;p_head-&amp;gt;rd_idx = 0;
         p-&amp;gt;p_head-&amp;gt;wr_idx = 0;
         p-&amp;gt;p_head-&amp;gt;blocks = blocks;
         p-&amp;gt;p_head-&amp;gt;blksz  = blksz;
         //初始化后段
         p-&amp;gt;p_payload = (char*)(p-&amp;gt;p_head+1);
         p-&amp;gt;shmid = shmid;
         p-&amp;gt;sem_mutex = semget(key,   1, IPC_CREAT|0644);
         p-&amp;gt;sem_empty = semget(key+1, 1, IPC_CREAT|0644);
         p-&amp;gt;sem_full  = semget(key+2, 1, IPC_CREAT|0644);
 
         semun su = {1}; //设置互斥信号量初值为1
         semctl(p-&amp;gt;sem_mutex, 0, SETVAL, su);
 
         su.val = blocks;
         semctl(p-&amp;gt;sem_empty, 0, SETVAL, su);
 
         su.val = 0; //初始不能消费
         semctl(p-&amp;gt;sem_full, 0, SETVAL, su);
     }
     else   //内存段存在 ,打开 
     { 
         p-&amp;gt;p_head = shmat(shmid, NULL, 0);
         p-&amp;gt;p_payload = (char*)(p-&amp;gt;p_head+1);
         p-&amp;gt;shmid = shmid;
         p-&amp;gt;sem_mutex = semget(key,   0, 0); //
         p-&amp;gt;sem_empty = semget(key+1, 0, 0);
         p-&amp;gt;sem_full  = semget(key+2, 0, 0);
     }
     return p;
 }
 
 static void P(int id)
 {
     struct sembuf sb[1] = {0,-1, 0};
     semop(id, sb, 1);
 }
 
 static void V(int id)
 {
     struct sembuf sb[1] = {0, 1, 0};
     semop(id, sb, 1);
 }
 
 // 放入数据
 void shmfifo_put(shmfifo_t *fifo, const void *buf)
 {
     P(fifo-&amp;gt;sem_empty);  //有多少地方可供生产,确保有空位生产
     P(fifo-&amp;gt;sem_mutex); //保证进程互斥
     memcpy(fifo-&amp;gt;p_payload + fifo-&amp;gt;p_head-&amp;gt;wr_idx * fifo-&amp;gt;p_head-&amp;gt;blksz, //写入位置
             buf, 
             fifo-&amp;gt;p_head-&amp;gt;blksz);  //每次写入一个数据块大小
 
     fifo-&amp;gt;p_head-&amp;gt;wr_idx = (fifo-&amp;gt;p_head-&amp;gt;wr_idx+1)
         %fifo-&amp;gt;p_head-&amp;gt;blocks;  //取模，保证数据存满时，转从payload处写数据
 
     V(fifo-&amp;gt;sem_full);
     V(fifo-&amp;gt;sem_mutex);
 }
 
 // 取得数据
 void shmfifo_get(shmfifo_t* pFifo, void *buf)
 {
     P(pFifo-&amp;gt;sem_full);  //确保有数据可取
     P(pFifo-&amp;gt;sem_mutex);
     //从内存段读取，拷入buf中   
     memcpy(buf, 
             pFifo-&amp;gt;p_payload + pFifo-&amp;gt;p_head-&amp;gt;rd_idx* pFifo-&amp;gt;p_head-&amp;gt;blksz,
             pFifo-&amp;gt;p_head-&amp;gt;blksz);   
 
     pFifo-&amp;gt;p_head-&amp;gt;rd_idx = (pFifo-&amp;gt;p_head-&amp;gt;rd_idx+1)
         %pFifo-&amp;gt;p_head-&amp;gt;blocks;  //取模，保证数据存满时，转从payload处取数据
 
     V(pFifo-&amp;gt;sem_empty);
     V(pFifo-&amp;gt;sem_mutex);
 }
 
 // 销毁 
 void shmfifo_destroy(shmfifo_t* pFifo)
 {
     shmdt(pFifo-&amp;gt;p_head);  //取消内存段挂载
     shmctl(pFifo-&amp;gt;shmid, IPC_RMID, 0); //释放掉该内存段
     //删除信号量
     semctl(pFifo-&amp;gt;sem_mutex, 0, IPC_RMID, 0);
     semctl(pFifo-&amp;gt;sem_empty, 0, IPC_RMID, 0);
     semctl(pFifo-&amp;gt;sem_full, 0, IPC_RMID, 0);
 
     free(pFifo);
 }                                                                                                          
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 最后就是分别实现get.c和put.c进行验证，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; get.c&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:cpp;collapse:true;;gutter:true;&quot;&gt;
 #include &quot;shmfifo.h&quot;                                         
 #include &amp;lt;unistd.h&amp;gt;
 
 typedef struct Products{
     int id;
     char pro_name[10];
 }Pro;
 
 int main()
 {
     shmfifo_t* fifo = shmfifo_init(12345, 3, sizeof(Pro));
     Pro p;
 
     while( 1){
         memset(&amp;amp;p, 0x00, sizeof(p));
         shmfifo_get(fifo, &amp;amp;p);
         printf(&quot;id:%d, 产品名：%s\n&quot;, p.id, p.pro_name);
         sleep(1);
     }
     shmfifo_destroy(fifo);
 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; put.c&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:cpp;collapse:true;;gutter:true;&quot;&gt;
 #include &quot;shmfifo.h&quot;                                             
 
 typedef struct Product
 {
     int id;
     char pro_name[10];
 }Pro;
 
 int main()
 {
     shmfifo_t *fifo = shmfifo_init(12345, 4, sizeof(Pro));
     Pro p;
 
     for (int i=0; i&amp;lt;20; ++i)
     {
         memset(&amp;amp;p, 0x00, sizeof(p));
         sprintf(p.pro_name, &quot;iphone%d&quot;, i);
         p.id = i+1;
         shmfifo_put(fifo, &amp;amp;p);
         printf(&quot;put %d ok\n&quot;, i);
     }
 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 验证同步，当写进程结束，读数据进程便阻塞&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201805/1272978-20180512005617214-1304844163.png&quot; alt=&quot;&quot; width=&quot;747&quot; height=&quot;370&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 验证互斥，进程1写第9个数据时，我另开启了一进程写数据，从右侧可见这两进程是交替进行写操作的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1272978/201805/1272978-20180512004853412-235451245.png&quot; alt=&quot;&quot; width=&quot;747&quot; height=&quot;392&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 11 May 2018 17:00:00 +0000</pubDate>
<dc:creator>tp_16b</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tp-16b/p/8992092.html</dc:identifier>
</item>
<item>
<title>2018年，传言QQ首次被神秘黑客DDOS攻击，Python可以实现？ - Python新世界</title>
<link>http://www.cnblogs.com/xinshiye/p/9027110.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xinshiye/p/9027110.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1395794/201805/1395794-20180511235740992-155766988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于2018-5-10日晚&lt;/p&gt;
&lt;p&gt;网络流传黑客DDOS攻击了QQ服务器，导致大家聊天发送内容时出现感叹号。我们都知道一般情况下出现感叹号都是你的网络不稳定，或者...别人已经删除你了。然而昨晚很奇怪，发出的内容出现感叹号，但是内容的确是真的发出去了，也就是说别人接受到了你的内容。&lt;/p&gt;
&lt;p&gt;看看当时的情况：&lt;/p&gt;
&lt;p&gt;我非常同情下面这位学生。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/2a4cb35062e4449ea981827569ef0a9d.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/0459e078bee648cdb260d366859753f4.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;别人人确实可以看得到他发出的带感叹号的消息。绝非PS ，真的很滑稽！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/27cea7da6c5042bea0650b06affbca68.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有QQ换锅换盆换洗衣粉牙膏的，各个都是人才！&lt;/p&gt;
&lt;p&gt;现在我们看看网络上的人怎么说：&lt;/p&gt;
&lt;p&gt;一部分人在讨论这个是黑客利用DDOS攻击造成的，说QQ要关闭，当然同时也有人说这个是谣言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/0677ab64077f411688d9f02399d1a8a1.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面这个小朋友更加恐怖了，对网友散播说是他用DDOS攻击造成的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/510ae3b2f31f4c54a7b5737b825221fc.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;手机QQ官方已经更新了一天微博如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://5b0988e595225.cdn.sohucs.com/images/20180510/1170b553fbef4de987557de74fe3f133.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/8af516e085c54217b685713d5b4d73a1.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/5bf96f15986f4be0abc581b3e8542680.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;谣言止于智者，腾讯那么大一个平台谁敢无故去攻击？服务器出现一点波动都是正常的，天有不测风云！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/fc3e1282d8574cdab161a388b20c5a9c.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以我们这些网民坚决：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/ac21138ff8544f958617e599600354cf.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好啦，不聊了，不然本着学习Python黑客的心来的朋友都看不下去了。&lt;/p&gt;
&lt;p&gt;现在开始我们的Python教程：&lt;/p&gt;
&lt;p&gt;本例子包含两个python小程序，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/aece3e6e03dc4858ab69124d150bc896.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/3cff51ae293647c5a4a0ea5971a5d3a4.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/0eb815735d494327a33d6a7fe7943f96.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/c9a6d39f27224e86bb73fbca9681934a.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;黑客们如何运行这个Python程序？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/35d0662e24b24ed99b41d7defb7a689f.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/2f783ff13e0e4f72b1561e3fd003d7a1.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个简单的DOS攻击程序&lt;/p&gt;
&lt;p&gt;DoS, Denial of Service, 拒绝服务，一种常用来使服务器或网络瘫痪的网络攻击手段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/a5db68f233034c1282a7b40ca7424799.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/85e28ce8d27449e6bc0c37de4ece46f2.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/dae95f1039ad40d58d5e78746de25f84.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行方法与上面的那个雷同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/872d11ae30af4d1aaea60e1e891a749f.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整合网络僵尸与DoS攻击——DDoS&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/77e6671a7a0d4d65a93046a94e598b68.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/492dbffeb3d54a039cde7bcda3809664.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/dcae6696ab5c43f9adbe08f0a20b152c.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;亦称作洪水攻击。DoS攻击与DDoS攻击的区别就是，它是一对一的攻击，而DDoS是分布式的攻击。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/9d48d4b96ba04b1885fd2dcc5700e510.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/9bedd531ffaa42889de06e7b8c32c750.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是黑客基于python实现的DDoS网络攻击。&lt;/p&gt;
&lt;p&gt;网络安全人人有责，望共同维护网络安全！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://5b0988e595225.cdn.sohucs.com/images/20180510/d13a50cd5b8f4943a5a031dc0d3de18b.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 11 May 2018 15:58:00 +0000</pubDate>
<dc:creator>Python新世界</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xinshiye/p/9027110.html</dc:identifier>
</item>
<item>
<title>学HTTP协议所要知道的基础知识(微总结) - 汪凡</title>
<link>http://www.cnblogs.com/wf-skylark/p/9027079.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wf-skylark/p/9027079.html</guid>
<description>&lt;h2&gt;&lt;span&gt;1、网络本质&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;进行资源共享和信息传输。&lt;/h4&gt;
&lt;h2&gt;2、基于网络的应用程序的本质&lt;/h2&gt;
&lt;h4&gt;就是获取数据和传输数据给用户使用。&lt;/h4&gt;
&lt;h2&gt;3、TCP/IP协议栈工作流程&lt;/h2&gt;
&lt;h4&gt;实体层是不属于TCP/IP协议栈的一层。也就是说TCP/IP协议栈共计四层。&lt;br/&gt;首先得接入网络，局域网或者广域网，在计算机接入网络的时候，也就是插入网线的时候本地路由器中的  &lt;br/&gt;路由表会更新数据，通过一定淘汰机制算法删除很久没有使用过的计算机ip以及mac地址，并对新加入组的计算&lt;br/&gt;机新分配ip，在分配ip的过程中，路由表会通过ARP协议（地址解析协议）得到新接入计算机的mac地址，并存入&lt;br/&gt;mac地址以及分配的ip地址。&lt;br/&gt;首先A用户使用应用程序产生数据，并通过应用层约定的规则（即应用层协议）发送数据，数据进行第一次封&lt;br/&gt;装形成head和data。再通过传输层确定目标计算机所需要接受数据的端口再次进行编码第二次封装，利用传输层&lt;br/&gt;约定的规则（即传输层协议，tcp/udp）发送数据，数据到达网络层，网络层通过ip协议确认要发送数据的目标ip，&lt;br/&gt;然后通过数据链路层的mac地址，数据链路层把数据通过以太网协议第三次封装成帧，帧也分head（标头，固定长&lt;br/&gt;度18字节）和data（数据，最短46字节，最长1500字节），超出则分成多个帧进行发送。再通过实体层进行第四次&lt;br/&gt;封装，把数据利用实体层协议封装成1或者0高低电位，这里可能会使用差分曼彻斯特等编码方式，数据这时候通过&lt;br/&gt;网线或者电磁波到达路由或者交换机，路由首先查看目标ip是否在本组局域网内，通过目标ip地址以及发送方ip地&lt;br/&gt;址对本地子网掩码进行与（and）运算，如果运算结果相等则说明目标主机在此局域网之内，则直接通过路由表确定&lt;br/&gt;ip以及mac信息发送数据。如果不相等则路由器继续向上层发送这次发送的数据，直到某个结点有属于目标ip的信息&lt;br/&gt;时，进行接收，并再次通过实体层-&amp;gt;数据链路层-&amp;gt;网络层-&amp;gt;传输层-&amp;gt;应用层的方式进行四次拆包，找到ip-&amp;gt;确认mac&lt;br/&gt;地址-&amp;gt;确认端口信息，接收数据到B用户使用的应用程序上，再由应用程序展现到B用户面前。&lt;/h4&gt;
&lt;h2&gt;4、网络五层&lt;/h2&gt;
&lt;h3&gt;1）应用层：&lt;/h3&gt;
&lt;h4&gt;应用层决定了向用户提供应用服务时通信的活动，HTTP 协议也处于该层。&lt;/h4&gt;
&lt;h3&gt;2）传输层：&lt;/h3&gt;
&lt;h4&gt;传输层对上层应用层提供处于网络连接中的两台计算机之间端口到端口的数据传输。在传输层有两个性质不同的协议： TCP 和 UDP 。&lt;/h4&gt;
&lt;h3&gt;3）网络层：&lt;/h3&gt;
&lt;h4&gt;网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（ip地址到ip地址）到达对方计算机，&lt;br/&gt;并把数据包传送给对方。&lt;br/&gt;与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。&lt;/h4&gt;
&lt;h3&gt;4）链路层：&lt;/h3&gt;
&lt;h4&gt;用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、网卡及光纤等物理可见部分（还包括连接器等一切传输媒介）。&lt;br/&gt;硬件上的范畴均在链路层的作用范围之内。&lt;/h4&gt;
&lt;h3&gt;5）实体层：&lt;/h3&gt;
&lt;h4&gt;负责通过物理手段将电脑连接起来，并传输0和1的电信号。&lt;/h4&gt;
&lt;h2&gt;5、Html，即超文本&lt;/h2&gt;
&lt;h4&gt;超级文本，把线性的文本变成非线性的文本，带跳转。&lt;/h4&gt;
&lt;h2&gt;6、HTTP协议&lt;/h2&gt;
&lt;h4&gt;HTTP协议是在 TCP/IP 协议族的基础上运作的，是TCP/IP的一个子集。&lt;br/&gt;是在应用层上对服务器，客户端进行数据传输方式，传输格式约束和规定的一个协议，具体格式和流程&lt;br/&gt;在下面说明。&lt;/h4&gt;
&lt;h2&gt;7、服务器、服务、服务器程序&lt;/h2&gt;
&lt;h4&gt;服务器可以理解成一台比较厉害的主机，服务器对每个客户端提供服务，针对客户端请求的服务，&lt;br/&gt;由服务器程序调用对应的服务，给客户端提供服务。&lt;/h4&gt;
&lt;h2&gt;8、浏览器———&amp;gt;服务器 请求 响应&lt;/h2&gt;
&lt;h4&gt;客户端发起对服务器的请求，发送请求报文，服务器接收到请求报文，如果发送不带Cookie的报文(例如初次登录)&lt;br/&gt;，服务器会设置Cookie并记录，并回复响应报文，并对比请求头中的缓存数据，如果记录的最后一次修改时间等于服务&lt;br/&gt;器最后一次修改时间或者资源戳和服务器一致，则不返回新页面，客户端继续使用原来的界面，否则返回新页面。&lt;/h4&gt;
&lt;h2&gt;9、url&lt;/h2&gt;
&lt;h4&gt;url格式：schema://host[:port#]/path/../[?query-string][#anchor]&lt;/h4&gt;
&lt;h4&gt;i. schema：使用的协议，http、https。 https就是安全的http协议&lt;br/&gt;ii. host:表示请求服务器的域名或者ip地址&lt;br/&gt;iii. port：端口号，默认是80&lt;br/&gt;iv. path：请求资源的路径&lt;br/&gt;v. query-string:发送给服务器的数据&lt;br/&gt;vi. anchor:锚，跟服务器无关，只跟客户端有关&lt;/h4&gt;
&lt;h4&gt;url举例：http://www.mywebsit.com/sj/test/test.html?name=zhangsan&amp;amp;age=18&lt;/h4&gt;&lt;p&gt;schema:http&lt;br/&gt;host:www.mywebsit.com&lt;br/&gt;port:80&lt;br/&gt;path:sj/test/test.html&lt;br/&gt;query-string:name=zhangsan&amp;amp;age=18
&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;10、报文相关信息补充：&lt;/h2&gt;
&lt;h3&gt;请求报文：&lt;/h3&gt;
&lt;h4&gt;​请求报文有4部分：&lt;/h4&gt;
&lt;h4&gt;​1、Request line(请求行)&lt;/h4&gt;&lt;p&gt;结构：Method/path-to-resource HTTP/Version-number
&lt;/p&gt;&lt;h4&gt;Method:请求方法：Get、Post&lt;br/&gt;Get 获取服务器的数据&lt;br/&gt;Post 提交数据到服务器&lt;/h4&gt;
&lt;h4&gt;Path-to-resource:请求资源的路径url&lt;/h4&gt;
&lt;h4&gt;Version-number:版本号 一般HTTP/1.1&lt;/h4&gt;
&lt;h4&gt;2、Request header(请求头)&lt;/h4&gt;&lt;p&gt;Accept：浏览器接收的数据类型&lt;br/&gt;Accept-Encoding：浏览器能够接收数据的编码格式&lt;br/&gt;Accept-Language:浏览器支持的语言&lt;br/&gt;Accept-Charset：浏览器能够接收的字符集类型&lt;br/&gt;User_Agent:用户代理，告诉服务器客户端的浏览器信息和操作系统信息&lt;br/&gt;Connection:keep alive(长连接和短连接)&lt;br/&gt;Host:主机地址&lt;br/&gt;Cookie：用户识别(保存用户名)
&lt;/p&gt;&lt;h4&gt;3、空行&lt;/h4&gt;
&lt;h4&gt;4、Request body(请求体）&lt;/h4&gt;
&lt;h3&gt;&lt;br/&gt;响应报文：&lt;/h3&gt;
&lt;h4&gt;响应报文也分为四部分：&lt;/h4&gt;
&lt;h4&gt;1、Response line(响应行)&lt;/h4&gt;
&lt;h4&gt;结构：HTTP/Version-number status-code message&lt;/h4&gt;
&lt;h4&gt;HTTP/version number ：版本号 一般HTTP/1.1&lt;/h4&gt;
&lt;h4&gt;Status code ：状态码&lt;/h4&gt;
&lt;h4&gt;a)状态码作用：服务器用来告诉浏览器是否产生了浏览器预期的Response&lt;br/&gt;b)状态码类别：1XX 2XX 3XX 4XX 5XX&lt;/h4&gt;
&lt;h4&gt;i. 1XX:提示信息，表示服务器已经接收到浏览器的请求，继续处理&lt;br/&gt;ii. 2XX:处理成功，表示浏览器的请求已经成功被接收、并正确处理&lt;br/&gt;iii.3XX:重定向，表示需要进行更进一步的处理&lt;br/&gt;iv. 4XX客户端请求错误,表示客户端请求出现错误&lt;br/&gt;v. 5XX服务器端错误，服务器未能正确处理客户端请求&lt;/h4&gt;
&lt;h3&gt;常见状态码解释：&lt;/h3&gt;
&lt;h4&gt;i.    200   OK ：表示客户端请求被成功接收，并将响应数据发送给客户端&lt;br/&gt;ii.   302   Found ：重定向，新的URL会在Response中返回，浏览器将会自动向新的URL发送请求。&lt;br/&gt;iii.  304   Not Modified ：表示信息已经被缓存了，还可以继续使用&lt;br/&gt;iv.  403   Forbidden ：服务器接收到客户端请求，但拒绝为客户端提供服务&lt;br/&gt;v.   404   Not Found ：表示客户端请求的资源不存在（url输错了）&lt;br/&gt;vi.  500   Internet Server Error ：服务器发生了不可预期的错误&lt;/h4&gt;
&lt;h4&gt;Message:状态码对应的状态信息&lt;/h4&gt;
&lt;h4&gt;2、Response header(响应头)&lt;/h4&gt;&lt;p&gt;Date：消息生成时间&lt;br/&gt;Content-type:响应数据的类型&lt;br/&gt;Transfer-encoding：分块传输&lt;br/&gt;Last-Modified: Fri, 13 Apr 2018 06:43:31 GMT :服务器记录的文件最后一次修改的时间&lt;br/&gt;Content-type:响应报文的body的内容类型&lt;br/&gt;Etag：资源戳，与请求报文的if-none_match配合使用&lt;br/&gt;Set-Cookie:将Cookie数据发送到浏览器，并要求浏览器进行记录&lt;br/&gt;Content-Encoding：服务器响应给浏览器的文件的压缩方式&lt;br/&gt;Content-Language:服务器告诉浏览器响应的语言&lt;br/&gt;Server：服务器告诉浏览器当前服务器的信息&lt;br/&gt;Location：重定向的url&lt;/p&gt;&lt;p&gt;3、空行
&lt;/p&gt;&lt;h4&gt;4、Request body(响应体)&lt;/h4&gt;
&lt;h4&gt;用户看到的内容，一般使用静态或者动态的网页代码&lt;/h4&gt;

</description>
<pubDate>Fri, 11 May 2018 15:51:00 +0000</pubDate>
<dc:creator>汪凡</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wf-skylark/p/9027079.html</dc:identifier>
</item>
<item>
<title>Spring温故而知新 – AOP代理 - 仍是少年</title>
<link>http://www.cnblogs.com/ashleyboy/p/9027072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ashleyboy/p/9027072.html</guid>
<description>&lt;h3&gt;AOP的概念&lt;/h3&gt;
&lt;p&gt;AOP：Aspect-Oriented Programming（面向切面编程），维基百科的解释如下：Aspect是一种新的模块化机制，用来描述分散在对象、类或者函数中的横切关注点，从关注点中分离出横切关注点是面向切面的程序设计的核心概念。分离关注点使解决特定领域问题的代码从业务逻辑中独立出来，业务逻辑的代码中不在含有针对特定领域问题的代码的调用，业务逻辑同特定领域问题的关系通过切面来封装、维护，这样原本分散在整个应用程序中的变动就可以很好地管理起来。从AOP的角度，应用可以分为横切关注点和业务逻辑代码，实际开发中，这些横切关注点往往会直接嵌入到业务逻辑代码中，面向切面编程就是要解决把横切关注点与业务逻辑相分离&lt;/p&gt;
&lt;p&gt;实现方式：&lt;/p&gt;
&lt;p&gt;Spring默认使用 JDK 动态代理作为AOP的代理，缺陷是目标类的类必须实现接口，否则不能使用JDK动态代理。如果需要代理的是类而不是接口，那么Spring会默认使用CGLIB代理，关于两者的区别：jdk动态代理是通过java的反射机制来实现的,目标类必须要实现接口，cglib是针对类来实现代理的，他的原理是动态的为指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。&lt;/p&gt;
&lt;h3&gt;JDK动态代理&lt;/h3&gt;
&lt;p&gt;Jdk动态代理是在程序运行过程中，根据目标类实现的接口来动态生成代理类的class文件,使用主要涉及两个类：&lt;/p&gt;
&lt;p&gt;InvocationHandler接口： 它提供了一个invoke(Object obj,Method method, Object[] args)方法供实现者提供相应的代理逻辑的实现。可以对实际的实现进行一些特殊的处理其中参数&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　Object obj ：被代理的目标类&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　Method method： 需要执行的目标类的方法&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　Object[] args ：目标方法的参数&lt;/p&gt;
&lt;p&gt;Proxy类：提供一个方法newProxyInstance (ClassLoader loader, Class[] interfaces, InvocationHandler h)来获得动态代理类&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; OrderService {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createOrder(); 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OrderServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; OrderService {
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createOrder() {
        System.out.println(&lt;/span&gt;&quot;creating order&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderLogger {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; beforeCreateOrder(){
        System.out.println(&lt;/span&gt;&quot;before create order&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; afterCreateOrder(){
        System.out.println(&lt;/span&gt;&quot;after create order&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sl.aop;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ServiceProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object targetClass;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; OrderLogger orderLogger;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ServiceProxy(Object targetClass,OrderLogger orderLogger) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.targetClass =&lt;span&gt; targetClass;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.orderLogger =&lt;span&gt; orderLogger;
    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取代理&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object GetDynamicProxy()
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Proxy.newProxyInstance(targetClass.getClass().getClassLoader(), &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过这个ClassLoader生成代理对象&lt;/span&gt;
                targetClass.getClass().getInterfaces(),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代理类已实现的接口&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;动态代理调用方法是关联的InvocationHandler,最终通过此InvocationHandler的invoke方法执行真正的方法&lt;/span&gt;
&lt;span&gt;    }
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现相应的代理逻辑&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.orderLogger.beforeCreateOrder();
        Object result&lt;/span&gt;=&lt;span&gt; method.invoke(targetClass, args);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.orderLogger.afterCreateOrder();
        
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sl.aop;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AopTest {
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Testdynamicproxy() {

        OrderServiceImpl serviceImpl &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderServiceImpl();
        OrderLogger logger &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderLogger();
        OrderService service &lt;/span&gt;= (OrderService) &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceProxy(serviceImpl, logger).GetDynamicProxy();
        service.createOrder();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180511233345910-707141223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这个其实还是有点困惑，Proxy.&lt;em&gt;newProxyInstance&lt;/em&gt;&lt;em&gt;（）&lt;/em&gt;这个返回的是什么？ Invoke方法在哪里调用的？我们看一下JDK源码：看看DK动态代理的过程是什么样的：&lt;/p&gt;
&lt;p&gt;根据源码内部的函数调用Proxy.newProxyInstance()-&amp;gt;Proxy.getProxyClass0()-&amp;gt;WeakCache.get() ，先定位到&lt;/p&gt;
&lt;p&gt;WeakCache.class:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(K key, P parameter) {
        Objects.requireNonNull(parameter);

        expungeStaleEntries();

        Object cacheKey &lt;/span&gt;=&lt;span&gt; CacheKey.valueOf(key, refQueue);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; lazily install the 2nd level valuesMap for the particular cacheKey&lt;/span&gt;
        ConcurrentMap&amp;lt;Object, Supplier&amp;lt;V&amp;gt;&amp;gt; valuesMap =&lt;span&gt; map.get(cacheKey);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (valuesMap == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            ConcurrentMap&lt;/span&gt;&amp;lt;Object, Supplier&amp;lt;V&amp;gt;&amp;gt;&lt;span&gt; oldValuesMap
                &lt;/span&gt;=&lt;span&gt; map.putIfAbsent(cacheKey,
                                  valuesMap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;&lt;span&gt;());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldValuesMap != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                valuesMap &lt;/span&gt;=&lt;span&gt; oldValuesMap;
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; create subKey and retrieve the possible Supplier&amp;lt;V&amp;gt; stored by that
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; subKey from valuesMap&lt;/span&gt;
        Object subKey =&lt;span&gt; Objects.requireNonNull(subKeyFactory.apply(key, parameter));
        Supplier&lt;/span&gt;&amp;lt;V&amp;gt; supplier =&lt;span&gt; valuesMap.get(subKey);
        Factory factory &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (supplier != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; supplier might be a Factory or a CacheValue&amp;lt;V&amp;gt; instance&lt;/span&gt;
                V value =&lt;span&gt; supplier.get();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else no supplier in cache
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; or a supplier that returned null (could be a cleared CacheValue
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; or a Factory that wasn't successful in installing the CacheValue)

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; lazily construct a Factory&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (factory == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                factory &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Factory(key, parameter, subKey, valuesMap);
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (supplier == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                supplier &lt;/span&gt;=&lt;span&gt; valuesMap.putIfAbsent(subKey, factory);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (supplier == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; successfully installed Factory&lt;/span&gt;
                    supplier =&lt;span&gt; factory;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else retry with winning supplier&lt;/span&gt;
            } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (valuesMap.replace(subKey, supplier, factory)) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; successfully replaced
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; cleared CacheEntry / unsuccessful Factory
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; with our Factory&lt;/span&gt;
                    supplier =&lt;span&gt; factory;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; retry with current supplier&lt;/span&gt;
                    supplier =&lt;span&gt; valuesMap.get(subKey);
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到函数return value;  而 V value = supplier.get();   继续往下读可以发现 supper=factory,实际上是一个Factory对象,那么继续查看Factory.get()方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; V get() { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; serialize access
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; re-check&lt;/span&gt;
            Supplier&amp;lt;V&amp;gt; supplier =&lt;span&gt; valuesMap.get(subKey);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (supplier != &lt;span&gt;this&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; something changed while we were waiting:
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; might be that we were replaced by a CacheValue
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; or were removed because of failure -&amp;gt;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; return null to signal WeakCache.get() to retry
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the loop&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else still us (supplier == this)

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; create new value&lt;/span&gt;
            V value = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                value &lt;/span&gt;=&lt;span&gt; Objects.requireNonNull(valueFactory.apply(key, parameter));
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; remove us on failure&lt;/span&gt;
                    valuesMap.remove(subKey, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the only path to reach here is with non-null value&lt;/span&gt;
            &lt;span&gt;assert&lt;/span&gt; value != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wrap value with CacheValue (WeakReference)&lt;/span&gt;
            CacheValue&amp;lt;V&amp;gt; cacheValue = &lt;span&gt;new&lt;/span&gt; CacheValue&amp;lt;&amp;gt;&lt;span&gt;(value);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; try replacing us with CacheValue (this should always succeed)&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (valuesMap.replace(subKey, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, cacheValue)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; put also in reverseMap&lt;/span&gt;
&lt;span&gt;                reverseMap.put(cacheValue, Boolean.TRUE);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AssertionError(&quot;Should not reach here&quot;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; successfully replaced us with new CacheValue -&amp;gt; return the value
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wrapped by it&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Return value；那么直接查看赋值语句：value = Objects.requireNonNull(valueFactory.apply(key, parameter)); valueFactory又什么鬼？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; WeakCache(BiFunction&amp;lt;K, P, ?&amp;gt;&lt;span&gt; subKeyFactory,
                     BiFunction&lt;/span&gt;&amp;lt;K, P, V&amp;gt;&lt;span&gt; valueFactory) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.subKeyFactory =&lt;span&gt; Objects.requireNonNull(subKeyFactory);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.valueFactory =&lt;span&gt; Objects.requireNonNull(valueFactory);
    }

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; WeakCache&amp;lt;ClassLoader, Class&amp;lt;?&amp;gt;[], Class&amp;lt;?&amp;gt;&amp;gt;  &lt;span&gt;proxyClassCache &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; WeakCache&amp;lt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; KeyFactory(), &lt;span&gt;new&lt;/span&gt; ProxyClassFactory());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以知道valueFactory是ProxyClassFactory类型对象，直接查看ProxyClassFactory. Apply()方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt; apply(ClassLoader loader, Class&amp;lt;?&amp;gt;&lt;span&gt;[] interfaces) {

            Map&lt;/span&gt;&amp;lt;Class&amp;lt;?&amp;gt;, Boolean&amp;gt; interfaceSet = &lt;span&gt;new&lt;/span&gt; IdentityHashMap&amp;lt;&amp;gt;&lt;span&gt;(interfaces.length);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt;&lt;span&gt; intf : interfaces) {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                 * Verify that the class loader resolves the name of this
                 * interface to the same Class object.
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                Class&lt;/span&gt;&amp;lt;?&amp;gt; interfaceClass = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    interfaceClass &lt;/span&gt;= Class.forName(intf.getName(), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, loader);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException e) {
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (interfaceClass !=&lt;span&gt; intf) {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
                        intf &lt;/span&gt;+ &quot; is not visible from class loader&quot;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                 * Verify that the Class object actually represents an
                 * interface.
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;interfaceClass.isInterface()) {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
                        interfaceClass.getName() &lt;/span&gt;+ &quot; is not an interface&quot;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                 * Verify that this interface is not a duplicate.
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (interfaceSet.put(interfaceClass, Boolean.TRUE) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
                        &lt;/span&gt;&quot;repeated interface: &quot; +&lt;span&gt; interfaceClass.getName());
                }
            }

            String proxyPkg &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; package to define proxy class in&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; accessFlags = Modifier.PUBLIC |&lt;span&gt; Modifier.FINAL;

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
             * Record the package of a non-public proxy interface so that the
             * proxy class will be defined in the same package.  Verify that
             * all non-public proxy interfaces are in the same package.
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt;&lt;span&gt; intf : interfaces) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; flags =&lt;span&gt; intf.getModifiers();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Modifier.isPublic(flags)) {
                    accessFlags &lt;/span&gt;=&lt;span&gt; Modifier.FINAL;
                    String name &lt;/span&gt;=&lt;span&gt; intf.getName();
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = name.lastIndexOf('.'&lt;span&gt;);
                    String pkg &lt;/span&gt;= ((n == -1) ? &quot;&quot; : name.substring(0, n + 1&lt;span&gt;));
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (proxyPkg == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        proxyPkg &lt;/span&gt;=&lt;span&gt; pkg;
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pkg.equals(proxyPkg)) {
                        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(
                            &lt;/span&gt;&quot;non-public interfaces from different packages&quot;&lt;span&gt;);
                    }
                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (proxyPkg == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if no non-public proxy interfaces, use com.sun.proxy package&lt;/span&gt;
                proxyPkg = ReflectUtil.PROXY_PACKAGE + &quot;.&quot;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
             * Choose a name for the proxy class to generate.
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;long&lt;/span&gt; num =&lt;span&gt; nextUniqueNumber.getAndIncrement();
            String proxyName &lt;/span&gt;= proxyPkg + proxyClassNamePrefix +&lt;span&gt; num;

            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
             * Generate the specified proxy class.
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;byte&lt;/span&gt;[] proxyClassFile =&lt;span&gt; ProxyGenerator.generateProxyClass(
                proxyName, interfaces, accessFlags);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; defineClass0(loader, proxyName,
                                    proxyClassFile, &lt;/span&gt;0&lt;span&gt;, proxyClassFile.length);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassFormatError e) {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
                 * A ClassFormatError here means that (barring bugs in the
                 * proxy class generation code) there was some other
                 * invalid aspect of the arguments supplied to the proxy
                 * class creation (such as virtual machine limitations
                 * exceeded).
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException(e.toString());
            }
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接画重点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;byte&lt;/span&gt;[] proxyClassFile =&lt;span&gt; ProxyGenerator.generateProxyClass(
                proxyName, interfaces, accessFlags);

&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; defineClass0(loader, proxyName,
                                    proxyClassFile, &lt;/span&gt;0, proxyClassFile.length);
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;调用ProxyGenerator.generateProxyClass最终动态生成一个代理类，但是似乎并未找到何处调用了invoke方法；参考CSDN: &lt;a href=&quot;https://blog.csdn.net/jiankunking/article/details/52143504&quot;&gt;https://blog.csdn.net/jiankunking/article/details/52143504&lt;/a&gt;这边文章，尝试将这个动态生成的二进制字节码输出到本地，并反编译出来一看究竟，测试代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AopTest {
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Testdynamicproxy() {

        OrderServiceImpl serviceImpl &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderServiceImpl();
        OrderLogger logger &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderLogger();
        OrderService service &lt;/span&gt;= (OrderService) &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceProxy(serviceImpl, logger).GetDynamicProxy();
        service.createOrder();
        //输出动态代理类字节码
        createProxyClassFile();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createProxyClassFile(){  
        String name &lt;/span&gt;= &quot;ProxyObject&quot;&lt;span&gt;;  
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] data = ProxyGenerator.generateProxyClass(name,&lt;span&gt;new&lt;/span&gt; Class[]{OrderService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;});  
        FileOutputStream out &lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;  
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {  
            out &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; FileOutputStream(name+&quot;.class&quot;&lt;span&gt;);  
            System.out.println((&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; File(&quot;hello&quot;&lt;span&gt;)).getAbsolutePath());  
            out.write(data);  
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (FileNotFoundException e) {  
            e.printStackTrace();  
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {  
            e.printStackTrace();  
        }&lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {  
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;null&lt;/span&gt;!=out) &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {  
                out.close();  
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {  
                e.printStackTrace();  
            }  
        }  
    } 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;使用java Decompiler工具将这个二进制class文件反编译查看：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180511234023310-926742201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;具体动态代理类ProxyObject.java：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.sl.aop.OrderService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.InvocationHandler;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Proxy;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.UndeclaredThrowableException;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProxyObject
  &lt;/span&gt;&lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Proxy
  &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; OrderService
{
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m1;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m2;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m3;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Method m0;
  
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ProxyObject(InvocationHandler paramInvocationHandler)
  {
    &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(paramInvocationHandler);
  }
  
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object paramObject)
  {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ((Boolean)&lt;span&gt;this&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m1, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[] { paramObject })).booleanValue();
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (Error|&lt;span&gt;RuntimeException localError)
    {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; localError;
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable localThrowable)
    {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(localThrowable);
    }
  }
  
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String toString()
  {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (String)&lt;span&gt;this&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m2, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (Error|&lt;span&gt;RuntimeException localError)
    {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; localError;
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable localThrowable)
    {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(localThrowable);
    }
  }
  
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createOrder()
  {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m3, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (Error|&lt;span&gt;RuntimeException localError)
    {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; localError;
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable localThrowable)
    {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(localThrowable);
    }
  }
  
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode()
  {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ((Integer)&lt;span&gt;this&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m0, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)).intValue();
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (Error|&lt;span&gt;RuntimeException localError)
    {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; localError;
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable localThrowable)
    {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(localThrowable);
    }
  }
  
  &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt;
  {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    {
      m1 &lt;/span&gt;= Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, &lt;span&gt;new&lt;/span&gt; Class[] { Class.forName(&quot;java.lang.Object&quot;&lt;span&gt;) });
      m2 &lt;/span&gt;= Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, &lt;span&gt;new&lt;/span&gt; Class[0&lt;span&gt;]);
      m3 &lt;/span&gt;= Class.forName(&quot;com.sl.aop.OrderService&quot;).getMethod(&quot;createOrder&quot;, &lt;span&gt;new&lt;/span&gt; Class[0&lt;span&gt;]);
      m0 &lt;/span&gt;= Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, &lt;span&gt;new&lt;/span&gt; Class[0&lt;span&gt;]);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (NoSuchMethodException localNoSuchMethodException)
    {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchMethodError(localNoSuchMethodException.getMessage());
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException localClassNotFoundException)
    {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoClassDefFoundError(localClassNotFoundException.getMessage());
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;终于看到关于invoke的部分了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; createOrder()
  {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
    {
      &lt;/span&gt;&lt;span&gt;this.h.invoke(this, m3, null);
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (Error|&lt;span&gt;RuntimeException localError)
    {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; localError;
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable localThrowable)
    {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UndeclaredThrowableException(localThrowable);
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;实际上动态代理类继承自Proxy，并且实现了目标类继承的接口，在createOrder方法中调用了invoke方法，实现了切面逻辑的植入，这里也回答了一个问题，为什么JDK动态代理的目标类必须是实现接口的，因为代理类其实是针对接口代理，而不是针对类来代理的，动态代理类自己继承自Proxy,Java也不允许多重继承。动态代理类和目标类其实是各自实现了接口，代理类通过InvocationHandler.invoke实现对目标类方法的调用。&lt;/p&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;CGLIB&lt;/span&gt;动态代理&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;CGLIB代理是通过使用一个字节码处理框架ASM，来转换字节码并生成新的类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，实现织如如横切逻辑 ，效率上比使用反射技术的JDK动态代理要高，但是由于CGLIB的原理是动态为目标类生成子类代理类，所以不能为声明为final的方法进行代理。其使用主要涉及两个类：&lt;/p&gt;
&lt;p&gt;MethodInterceptor接口：该接口提供一个方法intercept(Object arg0, Method arg1, Object[] arg2, MethodProxy arg3)主要用于拦截目标类方法的调用&lt;/p&gt;
&lt;p&gt;　　　　　　　　Object arg0, ：被代理的目标类&lt;/p&gt;
&lt;p&gt; 　　　　　　　   Method arg1, 委托方法&lt;/p&gt;
&lt;p&gt;　　　　　　　　Object[] arg2, 方法参数&lt;/p&gt;
&lt;p&gt;　　　　　　　　MethodProxy arg3 ：代理方法的MethodProxy对象&lt;/p&gt;
&lt;p&gt;Enhancer类：用于创建代理类&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;实现MethodInterceptor接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sl.aop;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.lang.reflect.Method;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.Enhancer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.MethodInterceptor;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cglib.proxy.MethodProxy;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CglibServiceProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MethodInterceptor {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object targetClass;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; OrderLogger orderLogger;
    
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CglibServiceProxy(Object targetClass,OrderLogger orderLogger) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.targetClass =&lt;span&gt; targetClass;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.orderLogger =&lt;span&gt; orderLogger;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
     * 创建代理对象 
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object getInstance() { 
        Enhancer enhancer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Enhancer();  
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置目标类（需要被代理的类）  &lt;/span&gt;
        enhancer.setSuperclass(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.targetClass.getClass());
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 回调方法  &lt;/span&gt;
        enhancer.setCallback(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建代理对象  &lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; enhancer.create();  
    }  
  
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 
     * 拦截所有目标类方法的调用 
     *
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object intercept(Object arg0, Method arg1, Object[] arg2, MethodProxy arg3) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        orderLogger.beforeCreateOrder();  
        
        Object o1 &lt;/span&gt;=&lt;span&gt; arg3.invokeSuper(arg0, arg2);
        
        orderLogger.afterCreateOrder();  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o1;  
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;测试方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Testdynamicproxy() {
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &lt;/span&gt;&quot;D:\\class&quot;&lt;span&gt;);
        OrderServiceImpl serviceImpl &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderServiceImpl();
        OrderLogger logger &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; OrderLogger();
        CglibServiceProxy proxy &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CglibServiceProxy(serviceImpl,logger);  
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过生成子类的方式创建代理类  &lt;/span&gt;
        OrderServiceImpl proxyImp =&lt;span&gt; (OrderServiceImpl)proxy.getInstance();
        proxyImp.createOrder();
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;结果：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/577318/201805/577318-20180511234652906-687667373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后两种代理对比一下：&lt;/p&gt;
&lt;p&gt;JDK动态代理：代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理  优点：不需要硬编码接口，代码复用率高，缺点：只能够代理实现了接口的委托类 &lt;/p&gt;
&lt;p&gt;CGLIB动态代理：&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代理  优点：可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口，缺点：不能对final类以及final方法进行代理&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 11 May 2018 15:50:00 +0000</pubDate>
<dc:creator>仍是少年</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ashleyboy/p/9027072.html</dc:identifier>
</item>
<item>
<title>总结Array类型中常用的方法 - 逆旅wy</title>
<link>http://www.cnblogs.com/gja1026/p/9026781.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gja1026/p/9026781.html</guid>
<description>&lt;p data-source-line=&quot;1&quot;&gt;&lt;span&gt;　　Array类型应该是 ECMAScript 中最常用的类型之一了，并且它定义的数组与其他语言有着相当大的区别。数组是数据的有序集合，我们可以通过下标对指定位置的数据进行读&lt;/span&gt;&lt;span&gt;写；特别的是，在 ECMAScript 中，数组的每一项可以保存任何类型的数据，数组的大小可以动态调整，它可以随着数据的添加自动增长来容纳新增的数据，从而变得更加灵活。&lt;/span&gt;&lt;span&gt;下面总结了Array类型常见的一些方法。&lt;/span&gt;&lt;/p&gt;
&lt;h3 data-source-line=&quot;3&quot;&gt;&lt;strong&gt;一、&lt;/strong&gt;栈方法&lt;/h3&gt;
&lt;p&gt;　　push() , pop() 这两个方法可以使数组的行为类似于“栈”这种数据结构，“栈”是一种 LIFO (Last-In-First-Out)后进先出的数据结构。&lt;/p&gt;
&lt;h4&gt;1.1 push()&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;参数：任意数量的元素；&lt;/li&gt;
&lt;li&gt;作用：逐个添加到数组末尾；&lt;/li&gt;
&lt;li&gt;返回值：修改后的数组的长度；&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;1.2 pop()&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;参数：无；&lt;/li&gt;
&lt;li&gt;作用：移除数组的最后一项，减少数组的length值；&lt;/li&gt;
&lt;li&gt;返回值：被移除的项；&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_5bed700c-c835-4177-b5a9-332d260cca9a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5bed700c-c835-4177-b5a9-332d260cca9a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5bed700c-c835-4177-b5a9-332d260cca9a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; let arr = [&quot;hello&quot;, &quot;world&quot;, &quot;Jingan&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     
&lt;span&gt; 3&lt;/span&gt; let length = arr.push(&quot;!&quot;, 1, &quot;China&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; console.log(length); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; console.log(length === arr.length); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; let deleteItem =&lt;span&gt; arr.pop();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; console.log(length === arr.length); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; console.log(deleteItem); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;China&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; console.log(arr.length); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;push(),pop()&lt;/span&gt;&lt;/div&gt;

&lt;h3 data-source-line=&quot;3&quot;&gt;二、队列方法&lt;/h3&gt;
&lt;p data-source-line=&quot;3&quot;&gt;　　队列”这种数据结构的访问规则是 FIFO (First-In-First-Out先进先出)，队列列表的末端添加元素，从列表的从头部开始删除。&lt;/p&gt;
&lt;p data-source-line=&quot;33&quot;&gt;　　我们已经知道 push() 可以向数组的末端添加元素，结合方法 shift() 便可以将一个数组的操作模拟成队列。&lt;/p&gt;
&lt;h4 data-source-line=&quot;33&quot;&gt;2.1 shift()&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;参数：无；&lt;/li&gt;
&lt;li&gt;作用：移除数组的第一项并返回该值；&lt;/li&gt;
&lt;li&gt;返回值：被移除的项；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　除此之外，还有一个 unshift() 方法，使用该方法和 pop() 方法组合可以将数组从相反的方向来模拟队列，即在数组顶端(index=0)添加元素，从数组末端移除元素。&lt;/p&gt;
&lt;h4 data-source-line=&quot;33&quot;&gt;2.2 unshift()&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;参数：任意数量的元素；&lt;/li&gt;
&lt;li&gt;作用：逐个添加到数组头部；&lt;/li&gt;
&lt;li&gt;返回值：修改后的数组的长度；&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_2eb02fc9-7aa2-4621-946e-77bfaebfbbcb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2eb02fc9-7aa2-4621-946e-77bfaebfbbcb&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2eb02fc9-7aa2-4621-946e-77bfaebfbbcb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; let fruits = [&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; console.log(fruits.length); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正向队列&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; let count = fruits.push(&quot;grape&quot;, &quot;watermelon&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 推入两项&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; console.log(count); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;  
&lt;span&gt; 8&lt;/span&gt; let item = fruits.shift(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移除第一项&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; console.log(item); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;apple&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; console.log(fruits.length); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反向队列&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; let colors = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; let count_2 = colors.unshift(&quot;blue&quot;, &quot;red&quot;, &quot;black&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 推入三项&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; console.log(count_2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; count_2 = colors.unshift(&quot;white&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; console.log(count_2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; let item_2 =&lt;span&gt; colors.pop();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; console.log(item_2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;balck&quot;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; console.log(colors.lenght);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;shift(), unshift()&lt;/span&gt;&lt;/div&gt;

&lt;h3 data-source-line=&quot;3&quot;&gt;三、重排序方法&lt;/h3&gt;
&lt;h4&gt;3.1 reverse()&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;参数：无；&lt;/li&gt;
&lt;li&gt;作用：将数组反转，原数组发生改变；&lt;/li&gt;
&lt;li&gt;返回值：返回反转后的数组；&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_2b302154-21e7-4810-996f-399bc6229439&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2b302154-21e7-4810-996f-399bc6229439&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2b302154-21e7-4810-996f-399bc6229439&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; arr = [1, 3, 5, &quot;apple&quot;, 34&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;arr.reverse();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; console.log(arr); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [34, &quot;apple&quot;, 5, 3, 1]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;reverse()&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;3.2 sort()&lt;/h4&gt;
&lt;p&gt;　　默认情况：sort() 方法按升序排列数组项，sort() 方法会调用每个数组项的 toString() 方法，然后比较依次字符串的 unicode 编码值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_5d798204-dd0f-4ac2-983e-52f38b4040f8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5d798204-dd0f-4ac2-983e-52f38b4040f8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5d798204-dd0f-4ac2-983e-52f38b4040f8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; arr = [1, 3, 5, &quot;apple&quot;, 34&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;arr.sort();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; console.log(arr); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [1, 3, 34, 5, &quot;apple&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;sort()&lt;/span&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;90&quot;&gt;　　这样比较会产生问题，所以通常情况下，我们常常将一个比较函数传递给 sort() 方法，以便我们自定义比较的方式。&lt;/p&gt;
&lt;p data-source-line=&quot;92&quot;&gt;比较函数传递两个参数：first, second;&lt;/p&gt;
&lt;ol data-source-line=&quot;93&quot;&gt;&lt;li&gt;如果 first 应该在 second 之前则返回负数；&lt;/li&gt;
&lt;li&gt;first 与 second 相等返回 0；&lt;/li&gt;
&lt;li&gt;first 应该在 second 后面则返回正数；&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_94c57454-10e0-4c52-99c0-915552edf4b9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_94c57454-10e0-4c52-99c0-915552edf4b9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_94c57454-10e0-4c52-99c0-915552edf4b9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; compare(first, second) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; return first - second; // 升序&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; second- first;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 降序&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; arr = [11, 3, 53, 1, 34&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; console.log(arr.sort(compare)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [53, 34, 11, 3, 1]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;sort()&lt;/span&gt;&lt;/div&gt;

&lt;h3 data-source-line=&quot;3&quot;&gt;四、操作方法&lt;/h3&gt;
&lt;h4&gt;4.1 concat()&lt;/h4&gt;
&lt;p&gt;　　该方法首先会创建一个当前数组的复本，然后将接受到的参数添加到这个复本的末尾。最后返回新构建的数组；注意原来那个数组是没有改变的，我们所做的改变都是在原数组的复本上进行操作的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;&lt;img id=&quot;code_img_closed_c1fc3716-21e9-428a-9041-408234c6792e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c1fc3716-21e9-428a-9041-408234c6792e&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c1fc3716-21e9-428a-9041-408234c6792e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; let arr =  [1, 2, 3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; let arr_2 = arr.concat(4, [2, 4, 5&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; console.log(arr);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [1, 2, 3]&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; console.log(arr_2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [1, 2, 3, 4, 2, 4, 5]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;concat()&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt; 4.2 slice()&lt;/h4&gt;
&lt;p data-source-line=&quot;115&quot;&gt;　　基于当前数组来创建指定的新数组。起始和结束位置作为参数，注意该方法也不会影响原数组。　　&lt;/p&gt;
&lt;ul data-source-line=&quot;117&quot;&gt;&lt;li&gt;一个参数： 返回参数指定的开始位置到数组末尾的所有项；&lt;/li&gt;
&lt;li&gt;两个参数： 返回起始位置到结束位置（不包括结束位置）范围内的所有项；&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_2f4fad66-a7e5-4538-8d57-ee1332918f14&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2f4fad66-a7e5-4538-8d57-ee1332918f14&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2f4fad66-a7e5-4538-8d57-ee1332918f14&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; let arr = [&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;, &quot;srawberry&quot;, &quot;watermelon&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; let arr_01 = arr.slice(2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; let arr_02 = arr.slice(1, 3&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; console.log(arr_01); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;banana&quot;, &quot;srawberry&quot;, &quot;watermelon&quot;]&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; console.log(arr_02); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;orange&quot;, &quot;banana&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;slice()&lt;/span&gt;&lt;/div&gt;
&lt;h4 data-source-line=&quot;3&quot;&gt;4.3 splice()&lt;/h4&gt;
&lt;p&gt;　　这个方法应该是最强大的数组方法了吧，并且还没有之一。主要有三种用途：&lt;/p&gt;
&lt;ul data-source-line=&quot;129&quot;&gt;&lt;li&gt;&lt;strong&gt;删除&lt;/strong&gt;：可以删除任意数量的项，两个参数：要删除的第一项的位置和要删除的个数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;插入&lt;/strong&gt;：可以向数组中插入任意数量的项，至少三个参数：起始位置、0（要删除的项数）、要插入的项。如果要插入多个项，可以在继续传入参数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;替换&lt;/strong&gt;：可以向指定位置删除任意数量的项，并且同时插入任意数量的项。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　注意splice()方法始终都会返回一个数组，该数组中包含从原数组中删除的项（若没有删除，则返回空数组）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46.5&quot;&gt;&lt;img id=&quot;code_img_closed_a200033d-0067-44a6-993c-d9dd8d8de7c1&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a200033d-0067-44a6-993c-d9dd8d8de7c1&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a200033d-0067-44a6-993c-d9dd8d8de7c1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;88&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; let arr = [&quot;apple&quot;, &quot;orange&quot;, &quot;banana&quot;, &quot;srawberry&quot;, &quot;watermelon&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; let item = arr.splice(0, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; console.log(item); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;apple&quot;]&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; console.log(arr); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;orange&quot;, &quot;banana&quot;, &quot;srawberry&quot;, &quot;watermelon&quot;]&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; item = arr.splice(1, 0, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; console.log(item); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [];&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; console.log(arr); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;orange&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;banana&quot;, &quot;srawberry&quot;, &quot;watermelon&quot;]&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; item = arr.splice(1, 3, &quot;苹果&quot;, &quot;香蕉&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; console.log(item); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; console.log(arr); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [&quot;orange&quot;, &quot;苹果&quot;, &quot;香蕉&quot;, &quot;banana&quot;, &quot;srawberry&quot;, &quot;watermelon&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;splice()&lt;/span&gt;&lt;/div&gt;

&lt;h3 data-source-line=&quot;3&quot;&gt;五、位置方法&lt;/h3&gt;
&lt;p data-source-line=&quot;150&quot;&gt;　　indexOf() 和 lastIndexOf()，这两个方法都接受两个参数：要查找的项和（可选的）查找其实位置的索引。&lt;/p&gt;
&lt;p data-source-line=&quot;152&quot;&gt;　　这两个方法的返回值是查找的项在数组中的位置，若没有则返回-1。注意在第一个参数比较数组的每一项时，是采用的全等操作符。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_93db40c5-76a1-4f43-9da2-1985cc7abd95&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_93db40c5-76a1-4f43-9da2-1985cc7abd95&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_93db40c5-76a1-4f43-9da2-1985cc7abd95&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; let arr = [&quot;apple&quot;, &quot;orange&quot;, &quot;100&quot;, 2, 3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; let index = arr.indexOf(100&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; console.log(index); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -1&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; index = arr.indexOf(&quot;orange&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; console.log(index); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;indexOf&lt;/span&gt;&lt;/div&gt;

&lt;h3 data-source-line=&quot;3&quot;&gt;六、迭代方法&lt;/h3&gt;
&lt;p data-source-line=&quot;162&quot;&gt;　　以下这5个迭代方法都可以传入两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this的值。在每一项上运行的函数中会接受三个参数：数组项的值、位置、数组对象本身。以下方法都不会改变原来的数组。&lt;/p&gt;
&lt;p data-source-line=&quot;164&quot;&gt;&lt;strong&gt;6.1 every()&lt;/strong&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;164&quot;&gt;　　对数组中的每一项都运行指定的函数，如果该函数对每一项都返回 true，则返回 true。&lt;/p&gt;
&lt;p data-source-line=&quot;167&quot;&gt;&lt;strong&gt;6.2 some()&lt;/strong&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;167&quot;&gt;　　如果该函数对任意一项返回 true，则返回 true。&lt;/p&gt;
&lt;p data-source-line=&quot;170&quot;&gt;&lt;strong&gt;6.3 filter()&lt;/strong&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;170&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　 filter 译为“过滤”，也就是说该方法可以利用指定的函数来确定返回的数组中是否包含某一项，它返回一个数组。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;173&quot;&gt;&lt;strong&gt;6.4 map()&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;173&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　该方法也是返回一个数组，而这个数组的每一项都是原始数组的每一项经过函数运行后的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;176&quot;&gt;&lt;strong&gt;6.5 forEach()&lt;/strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p data-source-line=&quot;176&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;　　将数组的每一项传入函数中，没有返回值，类似于使用 for 循环遍历数组。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;&lt;img id=&quot;code_img_closed_a0df2caf-f1d9-45ed-a384-bae2f2d7b940&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a0df2caf-f1d9-45ed-a384-bae2f2d7b940&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a0df2caf-f1d9-45ed-a384-bae2f2d7b940&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; let numbers = [1, 2, 3, 4, 15, 16&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; let everyResult = numbers.every(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item, index, array) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; (item &amp;gt; 3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; console.log(everyResult); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; let someResult = numbers.some(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (item, index, array) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; (item &amp;gt; 3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; console.log(someResult); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; biggerThan_10(item, index, array) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (item &amp;gt; 10&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; let filterResult =&lt;span&gt; numbers.filter(biggerThan_10);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; console.log(filterResult); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [15, 16]&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; doubleItems(item, index, array) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; item * 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; let mapResult =&lt;span&gt; numbers.map(doubleItems);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; console.log(mapResult); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [2, 4, 6, 8, 30, 32]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;迭代方法&lt;/span&gt;&lt;/div&gt;

&lt;h3 data-source-line=&quot;3&quot;&gt;七、归并方法&lt;/h3&gt;
&lt;p data-source-line=&quot;207&quot;&gt;　　两个归并数组的方式：reduce()、reduceRight()，这两个方法都会迭代数组的所有项，然后返回一个最终值。reduce() 从数组的第一项开始，逐个遍历到最后。reduceRight()相反。&lt;/p&gt;
&lt;p data-source-line=&quot;209&quot;&gt;　　两个方法的都接受两个参数：每一项上调用的函数和（可选的）作为归并的初始值。 每一项上调用的函数有四个参数：前一个值、当前值、索引、数组对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46.5&quot;&gt;&lt;img id=&quot;code_img_closed_8bb0991c-5e85-463e-8ba4-b94ae935865a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8bb0991c-5e85-463e-8ba4-b94ae935865a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8bb0991c-5e85-463e-8ba4-b94ae935865a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;88&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; let numbers = [1, 2, 3, 4&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; let result = numbers.reduce(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(pre, cur, index, array){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     console.log(&quot;pre: &quot; + pre + &quot;, cur: &quot; + cur + &quot;, index: &quot; +&lt;span&gt; index);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; pre +&lt;span&gt; cur;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; console.log(result); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次归并的输出：&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pre: 1, cur2, index:1&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pre: 3, cur3, index:2&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pre: 6, cur4, index:3&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传入归并的初始值&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; let result_2 = numbers.reduce(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(pre, cur, index, array){
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     console.log(&quot;pre: &quot; + pre + &quot;, cur: &quot; + cur + &quot;, index: &quot; +&lt;span&gt; index);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; pre +&lt;span&gt; cur;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; }, 1000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; console.log(result_2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1010&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次归并的输出：&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pre: 1000, cur: 1, index: 0&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pre: 1001, cur: 2, index: 1&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pre: 1003, cur: 3, index: 2&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pre: 1006, cur: 4, index: 3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;reduce()&lt;/span&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;238&quot;&gt;　　以上JavaScript中Array类型的常见方法，通过这些方法能够使我们在实际中更加方便的操作数组。&lt;/p&gt;
&lt;p data-source-line=&quot;240&quot;&gt;　　最近在学习《JavaScript高级程序设计》这本书，以上内容整理自该书第五章，与Array的更多方法可以&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/&quot;&gt;参考MDN&lt;/a&gt;。&lt;/p&gt;

</description>
<pubDate>Fri, 11 May 2018 15:41:00 +0000</pubDate>
<dc:creator>逆旅wy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gja1026/p/9026781.html</dc:identifier>
</item>
<item>
<title>数据准备:数据预处理 - hbsygfz</title>
<link>http://www.cnblogs.com/hbsygfz/p/9026998.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hbsygfz/p/9026998.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据预处理&lt;/strong&gt;是指因为算法或者分析需要，对经过数据质量检查后的数据进行转换、衍生、规约等操作的过程。整个数据预处理工作主要包括&lt;strong&gt;五个方面内容&lt;/strong&gt;：简单函数变换、标准化、衍生虚拟变量、离散化、降维。本文将作展开介绍，并提供基于Python的代码实现。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简单函数变换&quot;&gt;1. 简单函数变换&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简单函数变换&lt;/strong&gt;是指对原始数据直接使用某些数学函数进行转换，主要用于&lt;strong&gt;将不具有正态分布的数据变换成具有正态分布&lt;/strong&gt;，同时也可以用于&lt;strong&gt;对数据进行压缩&lt;/strong&gt;，比如&lt;span class=&quot;math inline&quot;&gt;\(10^8和10^9\)&lt;/span&gt;更关注的是相对差距而不是绝对差距，可以通过取对数变换实现。&lt;br/&gt;常用的函数包括：&lt;span class=&quot;math inline&quot;&gt;\(log(x)、x^k、e^x、\frac {1}{x}、\sqrt{x}、sinx\)&lt;/span&gt;等。&lt;br/&gt;简单函数变换会改变的原始数据的分布特征，因此使用前必须深入了解数据特征变化是否会影响到后续的分析。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;## 导入库
import pandas as pd
import numpy as np
## 读取数据
dataset = pd.read_excel(&quot;/labcenter/python/dataset2.xlsx&quot;)

## 简单函数变换
dataset['new_col2'] = np.log10(dataset['col2'])      #取10为底的对数
dataset['new_col2'] = np.exp(dataset['col2'],2)      #取平方
dataset['new_col2'] = np.exp(dataset['col2'])        #取e为的底的指数
dataset['new_col2'] = 1 / dataset['col2']            #取倒数
dataset['new_col2'] = np.sqrt(dataset['col2'])       #开方
dataset['new_col2'] = np.sin(dataset['col2'])        #取正弦&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;标准化&quot;&gt;2. 标准化&lt;/h2&gt;
&lt;p&gt;标准化，是为了处理&lt;strong&gt;不同规模和量纲&lt;/strong&gt;的数据，使其缩放到相同的数据区间和范围，以减少规模、量纲、分布差异等对分析建模的影响。&lt;strong&gt;常用的标准化方法有以下三种&lt;/strong&gt;：&lt;/p&gt;
&lt;h3 id=&quot;离差标准化&quot;&gt;2.1 离差标准化&lt;/h3&gt;
&lt;p&gt;离差标准化，又称&lt;strong&gt;最大值最小值标准化（Max-Min）&lt;/strong&gt;，即基于原始数据的最大值、最小值对数据进行线性变换，&lt;strong&gt;变换后，数据完全落入[0,1]区间内&lt;/strong&gt;。&lt;br/&gt;&lt;strong&gt;公式：&lt;/strong&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[x'= \frac {(x-min)}{(max-min)}\]&lt;/span&gt;&lt;br/&gt;其中，原始数据x，其最大值、最小值分别为max、min，转换后数据为x'。&lt;br/&gt;&lt;strong&gt;优点：&lt;/strong&gt;能够将数据归一化，同时能较好的保持原始数据的分布结构；&lt;br/&gt;&lt;strong&gt;缺点：&lt;/strong&gt;容易受极端值的影响，极端值会使大部分数据接近于0并且差距很小，同时在出现最值范围以外的数据时变换结果会产生错误；&lt;br/&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：适合数据比较集中的情况。&lt;/p&gt;
&lt;h3 id=&quot;标准差标准化&quot;&gt;2.2 标准差标准化&lt;/h3&gt;
&lt;p&gt;标准差标准化，即&lt;strong&gt;Z-Score标准化&lt;/strong&gt;，即基于原始数据的均值和标准差对数据进行标准化，&lt;strong&gt;标准化后，数据呈正态分布&lt;/strong&gt;。&lt;br/&gt;&lt;strong&gt;公式：&lt;/strong&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[x'= \frac {(x-μ)}{σ}\]&lt;/span&gt;&lt;br/&gt;其中，原始数据x，其均值、标准差分别为μ、σ，转换后数据为x'。&lt;br/&gt;&lt;strong&gt;缺点：&lt;/strong&gt;是一种中心化方法，会改变原始数据的分布结构。&lt;br/&gt;&lt;strong&gt;适用场景&lt;/strong&gt;：适合数据的最值未知，且可能出现离群点的情况。&lt;/p&gt;
&lt;h3 id=&quot;绝对值最大标准化&quot;&gt;2.3 绝对值最大标准化&lt;/h3&gt;
&lt;p&gt;绝对值最大标准化，即&lt;strong&gt;MaxAbs标准化&lt;/strong&gt;，即基于原始数据绝对值的最大值对数据进行标准化，&lt;strong&gt;变换后，数据完全落入[-1,1]区间内&lt;/strong&gt;。&lt;br/&gt;&lt;strong&gt;公式：&lt;/strong&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[x'= \frac {x}{maxAbs}\]&lt;/span&gt;&lt;br/&gt;其中，原始数据x，其绝对值的最大值为maxAbs，转换后数据为x'。&lt;br/&gt;&lt;strong&gt;优点：&lt;/strong&gt;不会破坏原始数据的分布结构；&lt;br/&gt;&lt;strong&gt;适用场景：&lt;/strong&gt;可用于稀疏矩阵、稀疏数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;## 标准化处理
## 方法1：使用numpy和pandas
### 离差标准化
dataset['new_col2'] = (dataset['col2'] - dataset['col2'].min()) / (dataset['col2'].max() - dataset['col2'].min())
### 标准差标准化
dataset['new_col2'] = (dataset['col2'] - dataset['col2'].mean()) / dataset['col2'].std()
### 绝对值最大标准化
dataset['new_col2'] = dataset['col2'] / np.abs(dataset['col2']).max()

## 方法2：使用sklearn
from sklearn import preprocessing
### 离差标准化
minmax_scaler = preprocessing.MinMaxScaler()
dataset['new_col2'] = minmax_scaler.fit_transform(dataset['col2'])
### 标准差标准化
zsocre_scaler = preprocessing.StandardScaler()
dataset['new_col2'] = zsocre_scaler.fit_transform(dataset['col2'])
### 绝对值最大标准化
maxabs_scaler = preprocessing.MaxAbsScaler()
dataset['new_col2'] = maxabs_scaler.fit_transform(dataset['col2'])&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;衍生虚拟变量&quot;&gt;3. 衍生虚拟变量&lt;/h2&gt;
&lt;p&gt;在数据建模过程中，很多算法都不能处理非数值型数据，必须首先将这些数据转化为数值型。但是，即使转化为数值型数据，也不能直接应用到算法计算中，为什么？这需要从离散型数据的分类说起。&lt;br/&gt;&lt;strong&gt;离散型数据也就是分类数据，主要分为两类，一类是无序分类，一类是有序分类。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;无序分类&lt;/strong&gt;，是指各个类别之间没有明显的高、低、大、小等包含等级、顺序、优劣、好坏等逻辑的划分，只是用来区分两个或多个具有相同或相当价值的属性。例如性别的男和女，颜色的红、黄、蓝等等。&lt;br/&gt;&lt;strong&gt;有序分类&lt;/strong&gt;，是指各个类别之间有一定的顺序关系。例如用户价值的高、中、低，学历的博士、硕士、学士等。&lt;br/&gt;对于无序分类来说，无论用什么数值来表示都无法表达出价值相等但有区分的属性，比如性别的男和女，如果分别用1和2表示，那么1和2本身就已经带有距离为1的差异，但实际上二者之间是没有这种差异的，同样，不论用任何数据都无法到达这种区分的目的。&lt;br/&gt;而对于有序分类来说，无论用什么有序的数字序列都无法准确表达出有序类别之间的差异性，比如学历的博士、硕士、学士，如果用3-2-1来表示这种顺序关系，那这种差异为什么不能用30-20-10来表示呢？&lt;br/&gt;所以，非数值型的离散型数据要想参与到算法计算中，不能简单的认为转化成用数值就表示就可以，而是必须使用其他的方法，这种方法就是&lt;strong&gt;衍生虚拟变量&lt;/strong&gt;，也叫做&lt;strong&gt;创建虚拟变量（dummy variable）、创建哑变量、创建名义变量、one-hot编码（one-hot encoding）、N取一编码（one-out-of encoding）&lt;/strong&gt;。它是指，将一个离散型变量衍生出多个真值变量（用0和1，或者True和False表示的变量），比如性别这一变量取值有男、女两个，那么将衍生出性别是否男、性别是否女两个变量；然后使用这些衍生出来的真值变量替换原始变量参与后续的计算。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201805/554583-20180511233627044-2082116409.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;## 衍生虚拟变量
## 方法1：自定义函数
def dummyCreate(ser):
    valueSet = ser.unique()
    resDf = pd.DataFrame()
    colName = ser.name
    for value in valueSet:
        colNameNew = colName + '_' + value
        colDataTmp = ser.values
        colData = (colDataTmp == value)
        resDf[colNameNew] = colData
    return resDf
    
dummyCreate(dataset['col3'])

## 方法2：使用sklearn
from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import LabelEncoder
labelEnc = LabelEncoder()   ##标准标签化
ohEnc = OneHotEncoder()     ##one-hot编码
dataset['new_col3'] = labelEnc.fit_transform(dataset['col3'])   ##将类别值用0.1.2……编码
ohEncRes = ohEnc.fit_transform(dataset['new_col3'].reshape(-1,1)).toarray()     ##one-hot编码
newDf = pd.concat((dataset, pd.DataFrame(ohEncRes)), axis=1)    ##合并结果
dataset = newDf.rename(columns={0:'col3_aaa',1:'col3_bbb',2:'col3_ccc'})    ##重命名列名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;创建虚拟变量和虚拟变量编码（dummy encoding）是不同的概念，前者如上所述，如果一个离散变量有N个取值，就会衍生出N个真值变量，而后者——虚拟变量编码，则是衍生出N-1个变量，它认为这个N-1个变量都为0时即表示原始数据取第N个值。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/554583/201805/554583-20180511233649932-1270313646.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;离散化&quot;&gt;4. 离散化&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;离散化就是将一份数据从细粒度转化为粗粒度，实质就是数据的集中化。&lt;/strong&gt;主要包括&lt;strong&gt;两方面&lt;/strong&gt;：将连续型数据转化成离散型数据、将离散型数据进行类别合并，具体又分为以下几点：&lt;/p&gt;
&lt;h3 id=&quot;针对时间数据的离散化&quot;&gt;4.1 针对时间数据的离散化&lt;/h3&gt;
&lt;p&gt;针对时间数据的离散化主要是指对时间数据进行粒度上的上卷（反之是下钻）：&lt;br/&gt;时间戳——&amp;gt;小时——&amp;gt;上午\下午&lt;br/&gt;日期型——&amp;gt;星期——&amp;gt;周数——&amp;gt;季度——&amp;gt;年份&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;## 离散化
### 针对时间数据的离散化
colList = list(dataset.columns)
colList.extend(['weekday_col5','week_col5','year_col5','month_col5','day_col5','hour_col5'])
dataset = dataset.reindex(columns = colList)
for index,value in enumerate(dataset['col5']):
    newValue = pd.to_datetime(value)
    dataset['weekday_col5'][index] = newValue.weekday()
    dataset['week_col5'][index] = newValue.week
    dataset['year_col5'][index] = newValue.year
    dataset['month_col5'][index] = newValue.month
    dataset['day_col5'][index] = newValue.day
    dataset['hour_col5'][index] = newValue.hour&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;针对类别数据的离散化&quot;&gt;4.2 针对类别数据的离散化&lt;/h3&gt;
&lt;p&gt;针对类别数据的离散化主要是指将多个类别进行合并而产生新的类别划分。&lt;br/&gt;比如将年龄区间（小于18，18-35，35-50，50-70，70以上）合并为年龄区间（小于18，18-35，35-50，50以上）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;### 针对类别数据的离散化
mapDf = pd.DataFrame([['0-10','0-20'],['10-20','0-20'],['20-30','20-30'],['30-40','30-50'],['40-50','30-50']],columns=['col6','new_col6'])
dataset = dataset.merge(mapDf, left_on = 'col6', right_on = 'col6', how = 'inner')&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;针对连续数据的离散化&quot;&gt;4.3 针对连续数据的离散化&lt;/h3&gt;
&lt;p&gt;离散化中主要的工作是针对连续数据的离散化，包括&lt;strong&gt;两方面&lt;/strong&gt;：将连续数据分成多个区间、将连续数据划分成特定的类。前者通常被称为分箱。具体有以下几种实现方法：&lt;/p&gt;
&lt;h4 id=&quot;自定义分箱&quot;&gt;（1）自定义分箱&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;自定义分箱&lt;/strong&gt;，是指根据业务经验或者常识等自行设定划分的区间，然后将原始数据归类到各个区间中。&lt;/p&gt;
&lt;h4 id=&quot;等宽分箱&quot;&gt;（2）等宽分箱&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;等宽分箱&lt;/strong&gt;，是指划分的各个区间的宽度（或称为距离）相等。&lt;/p&gt;
&lt;h4 id=&quot;等频分箱&quot;&gt;（3）等频分箱&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;等频分箱&lt;/strong&gt;，是指划分的各个区间包含的数据点的个数相等，也称为&lt;strong&gt;等深分箱&lt;/strong&gt;，或者是&lt;strong&gt;分位数分箱&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;聚类法&quot;&gt;（4）聚类法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;聚类法&lt;/strong&gt;，是指使用聚类算法自动将原始数据分成多个类别。&lt;/p&gt;
&lt;h4 id=&quot;二值化&quot;&gt;（5）二值化&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;二值化&lt;/strong&gt;，是指设置一个阈值，将每个数据点与这个阈值进行比较，大于（或等于）阈值取某一固定值A，小于（或等于）阈值则取另一固定值B，从而将原始数据转换为两个取值的离散数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;### 针对连续数据的离散化
#### (1)自定义分箱
points = [0,800,1500,2000,2500]  #定义边界点
dataset['new_col7'] = pd.cut(dataset['col7'], points)
dataset['new_col7'] = pd.cut(dataset['col7'], points, labels = ['a','b','c','d'])

#### (2)等宽分箱
bins = 4   #箱数
dataset['new_col7'] = pd.cut(dataset['col7'], bins)
dataset['new_col7'] = pd.cut(dataset['col7'], bins, labels = ['a','b','c','d'])

#### (3)等频分箱
bins = 4   #箱数
dataset['new_col7'] = pd.qcut(dataset['col7'], bins)
dataset['new_col7'] = pd.qcut(dataset['col7'], bins, labels = ['a','b','c','d'])

#### (4)聚类法
from sklearn.cluster import KMeans
data = dataset['col7']
new_data = data.reshape((data.shape[0], 1))
kmeans = KMeans(n_clusters=4, random_state=0)  # 使用K-Means聚类
keames_result = kmeans.fit_predict(new_data)
dataset['new_col7'] = keames_result

#### (5)二值法
from sklearn import preprocessing
binarizer_scaler = preprocessing.Binarizer(threshold = dataset['col7'].mean())  #使用均值作为分割阈值
temp = binarizer_scaler.fit_transform(dataset['col7'])
temp.resize(dataset['col7'].shape)
dataset['new_col7'] = temp&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;降维&quot;&gt;5. 降维&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;降维&lt;/strong&gt;是指降低数据集的维度数量，从而降低模型的计算工作量，减少模型的运行时间，减弱噪声变量（无关变量）对模型结果可能产生的影响。&lt;/p&gt;
&lt;h3 id=&quot;基于特征选择的降维&quot;&gt;5.1 基于特征选择的降维&lt;/h3&gt;
&lt;p&gt;基于特征选择的降维，通俗的说，就是特征筛选，或者叫变量筛选。从多个变量中筛选出更有用的较少个变量，从而降低数据集的维度。特征筛选的主要方法包括：基于经验的方法（比如专家法）、基于统计的方法（比如区分度、信息增益）和基于机器学习的方法（比如决策树算法）。&lt;br/&gt;基于特征选择的降维的好处是，既保留了原有维度的特征，同时又完成了降维的目的。&lt;br/&gt;&lt;strong&gt;由于特征筛选是数据准备工作的一个重要环节，因此会单独拿出来进行总结论述，此处不做详细讨论。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;基于维度转换的降维&quot;&gt;5.2 基于维度转换的降维&lt;/h3&gt;
&lt;p&gt;基于维度转换的降维，是指按照一定的数学变换方法，把给定的一组（相关的）变量，通过数学模型从高维空间映射到低维度空间中，然后利用映射后产生的新变量来表示原有变量的总体特征，转换后产生的新特征是多个原始特征的综合。&lt;br/&gt;具体的方法分为线性降维和非线性降维，常用的算法有主成分分析、因子分析、线性判别分析等。&lt;br/&gt;&lt;strong&gt;关于具体的算法原理，后续将在统计学或机器学习系列中进行总结论述，此处不做讨论。&lt;/strong&gt;&lt;br/&gt;基于维度转换的降维将使用转换后产生的新变量参与后续的建模分析，因此直接影响到模型的可解释性和可理解性，在不要求对模型进行解释说明时可以使用，否则，建议使用基于特征选择的降维。&lt;/p&gt;

&lt;h2 id=&quot;参考与感谢&quot;&gt;6. 参考与感谢&lt;/h2&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://book.douban.com/subject/2038599/&quot;&gt;数据挖掘概念与技术&lt;/a&gt;&lt;br/&gt;[2] &lt;a href=&quot;https://book.douban.com/subject/5377669/&quot;&gt;数据挖掘导论&lt;/a&gt;&lt;br/&gt;[3] &lt;a href=&quot;https://book.douban.com/subject/30147778/&quot;&gt;Python机器学习基础教程&lt;/a&gt;&lt;br/&gt;[4] &lt;a href=&quot;https://book.douban.com/subject/27608466/&quot;&gt;Python数据分析与数据化运营&lt;/a&gt;&lt;br/&gt;[5] &lt;a href=&quot;https://book.douban.com/subject/26677686/&quot;&gt;Python数据分析与数据挖掘实战&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 11 May 2018 15:41:00 +0000</pubDate>
<dc:creator>hbsygfz</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hbsygfz/p/9026998.html</dc:identifier>
</item>
<item>
<title>[CQOI2007] 余数求和 - YoungNeal</title>
<link>http://www.cnblogs.com/YoungNeal/p/9027038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YoungNeal/p/9027038.html</guid>
<description>&lt;h2 id=&quot;description&quot;&gt;Description&lt;/h2&gt;
&lt;p&gt;求 &lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=1}^n\;k\;mod\;i\)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;
&lt;p&gt;先化简式子&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=1}^n\;k\;mod\;i=\sum_{i=1}^nk-\lfloor{\frac{k}{i}}\rfloor=k\times n-\sum_{i=1}^n\lfloor{\frac{k}{i}}\rfloor\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用样例打表找规律之后，发现 &lt;span class=&quot;math inline&quot;&gt;\(\lfloor{\frac{k}{i}}\rfloor\)&lt;/span&gt; 分别在一定的区域内相等。&lt;/p&gt;
&lt;p&gt;所以用分块除法来做这题。&lt;/p&gt;
&lt;p&gt;首先定义 &lt;span class=&quot;math inline&quot;&gt;\(t=\lfloor{\frac{k}{i}}\rfloor\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用 &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt; 来代表我们当前除法块的左边界， &lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt; 来代表右边界，我们让一开始的 &lt;span class=&quot;math inline&quot;&gt;\(l=1\)&lt;/span&gt; ，因为第一块除法块的开头永远都是从 &lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt; 开始,然后我们可以通过 &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt; 来求出 &lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt; 。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;t=k/l;
&lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(!t) &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
r=std::min(k/t,n);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为我们的定义是 &lt;span class=&quot;math inline&quot;&gt;\(t=\lfloor{\frac{k}{i}}\rfloor\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以我们可以直接让 &lt;span class=&quot;math inline&quot;&gt;\(t=k/l\)&lt;/span&gt; 来求出他当前除法块的商，因为连续一块除法块的商都是相等的（不相等就绝对不是同一块），这样我们算出了 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; ，然后就通过 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 来找 &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(t=0\)&lt;/span&gt; 时，&lt;span class=&quot;math inline&quot;&gt;\(r=n\)&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(t!=0\)&lt;/span&gt; 时，&lt;span class=&quot;math inline&quot;&gt;\(r=min(\lfloor{\frac{k}{t}}\rfloor,n)\)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解释如下，因为当 &lt;span class=&quot;math inline&quot;&gt;\(t=0\)&lt;/span&gt; 时，后面那一块肯定都是大于 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 的那一段，所以我们直接让 &lt;span class=&quot;math inline&quot;&gt;\(r=n\)&lt;/span&gt; ，算出最后这一大块，当 &lt;span class=&quot;math inline&quot;&gt;\(t!=0\)&lt;/span&gt; 的时候，我们让 &lt;span class=&quot;math inline&quot;&gt;\(r=\lfloor{\frac{k}{t}}\rfloor\)&lt;/span&gt;，这样可以算出有这个整除的商的最大的一个整数是多少，因为 &lt;span class=&quot;math inline&quot;&gt;\(\lfloor{\frac{k}{t}}\rfloor\)&lt;/span&gt; 可能会大于 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; ，所以我们加上一个 &lt;span class=&quot;math inline&quot;&gt;\(min\)&lt;/span&gt; 函数，防止他超过边界。 有了右边界，每一块的和也就好求了&lt;/p&gt;
&lt;p&gt;剩下的就是用 &lt;span class=&quot;math inline&quot;&gt;\(n\times k\)&lt;/span&gt;减去每一块的值就好了&lt;/p&gt;
&lt;h2 id=&quot;code&quot;&gt;Code&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode cpp&quot;&gt;
&lt;code class=&quot;sourceCode cpp&quot;&gt;&lt;span class=&quot;ot&quot;&gt;#include&amp;lt;cstdio&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#include&amp;lt;iostream&amp;gt;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;#define int long long&lt;/span&gt;

&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ans;
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n,k;

&lt;span class=&quot;dt&quot;&gt;signed&lt;/span&gt; main(){
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; r;
    scanf(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%lld%lld&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;k);
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i=&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;i&amp;lt;=n;i=r&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;){
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; t=k/i;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt;(!t) &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
        r=std::min(k/t,n);
        ans+=t*(i+r)*(r-i&lt;span class=&quot;dv&quot;&gt;+1&lt;/span&gt;)/&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;;
        &lt;span class=&quot;co&quot;&gt;//printf(&quot;i=%lld,ans=%lld\n&quot;,i,ans);&lt;/span&gt;
    }
    printf(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%lld\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;,n*k-ans);
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 11 May 2018 15:35:00 +0000</pubDate>
<dc:creator>YoungNeal</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YoungNeal/p/9027038.html</dc:identifier>
</item>
<item>
<title>CentOS6系列系统启动常见故障排查与解决方法 - 疯狂船长</title>
<link>http://www.cnblogs.com/L-dongf/p/9026782.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/L-dongf/p/9026782.html</guid>
<description>&lt;p&gt;/boot/vmlinuz-2.6.32-642.el6.x86_64 内核文件&lt;/p&gt;
&lt;p&gt;1、故障现象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180511205426216-65143435.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、解决方法：挂载光盘，进入rescue（救援）模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180511205752337-1952948353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、选择——English——us——No——Continue——OK——OK。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180511210020905-631158706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、进入shell，重新安装内核&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# mkdir cdrom
# mount -r /dev/sr0 /cdrom
# rpm -ivh --force --root=/mnt/sysimage/ /cdrom/Packages/kernel-2.6.32-642.el6.x86_64.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180511211057233-861764989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、确认新的内核文件已经生成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180511211232387-270269657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、重新启动完成修复&lt;/p&gt;
&lt;p&gt;如果initramfs文件损坏也可以使用这个方法修复。&lt;/p&gt;

&lt;h2&gt;故障现象：&lt;/h2&gt;
&lt;p&gt;grub第1阶段损坏：无法从系统硬盘启动，直接进入下一可引导的启动设备&lt;/p&gt;
&lt;p&gt;grub第1.5阶段损坏：从此硬盘启动黑屏，在第一行有一个光标，但是无法进入系统，也不会去读取下一个可引导设备&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180511214654300-1246442148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;grub第2阶段损坏：grub第2阶段是提供了grub菜单界面，如果损坏了和1.5相似，也是无法看到grub启动界面&lt;/p&gt;
&lt;h2&gt;救援方法：&lt;/h2&gt;
&lt;p&gt;1、解决方法：进入rescue，在光盘引导界面按Esc件，输入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
rescue linux
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180511212126049-1711248975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、使用chroot命令切换根文件系统，然后用grub-install进行修复&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# chroot /mnt/sysimage&lt;br/&gt;# grub-install /dev/sda
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180511212819844-76456627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、重启恢复系统完成&lt;/p&gt;

&lt;p&gt;/boot/grub/grub.conf&lt;/p&gt;
&lt;p&gt;1、故障现象：grub无法读取配置文件，在开机的时候会默认进入grub的命令行界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180511215202387-891661934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、在命令行界面我们只需要手动指定内核和ramdisk文件的路径，如果不知道内核所在分区则可以尝试用find命令来查找&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180511215629073-766817907.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、输入boot启动，成功进入系统后去编辑/boot/grub/grub.conf文件，修复完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180511220229414-1162807936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1、故障现象：内核可以初始化但是无法进入登录界面，出现一个sh的命令行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180511220458523-1296584444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、进入救援模式，安装upstart包，并查看init程序是否重新生成&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# rpm -ivh --force --root=/mnt/sysimage/  /cdrom/Packages/upstart-0.6.5-el6.x86_64.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180511221044368-1861826180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、重启进入系统，成功&lt;/p&gt;

&lt;p&gt;1、故障现象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180511221706130-133674060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、进入救援模式，安装upstart包，并查看init程序是否重新生成&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# rpm -ivh --force --root=/mnt/sysimage/  /cdrom/Packages/bash-4.1.2-40.el6.x86_64.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180511222106345-1762492614.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、重启进入系统，成功&lt;/p&gt;

&lt;p&gt;1、故障现象：因为无法挂载分区，启动故障&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180511225537874-1764286255.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、解决方法：由于fstab文件丢失无法找到根文件系统，所以我们得自己找到根文件系统所在分区挂载到/mnt/sysimage，然后把手动把fstab文件写到/etc下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1331725/201805/1331725-20180511230602193-335079214.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、重启进入系统，然后再把其他的分区找到，然后写入fatab文件，修复成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果根和boot分区是用的lvm管理的，那么在救援模式下不可以直接使用，得需要使用以下命令激活vg，然后操作就和以上步骤一样了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vgchange -ay vgname 激活卷组
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;可喜可贺，可喜可贺！&lt;/h2&gt;

&lt;p&gt;记录于2018.5.11 23:11&lt;/p&gt;
</description>
<pubDate>Fri, 11 May 2018 15:18:00 +0000</pubDate>
<dc:creator>疯狂船长</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/L-dongf/p/9026782.html</dc:identifier>
</item>
<item>
<title>从深圳回武汉的面试感想以及一些面试题 - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/9026994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/9026994.html</guid>
<description>&lt;p&gt;大家好，我是ITDragon龙，今天分享一些面试中常问的题目，和一些面试感受。我是四月二十五号离职，二十六号上午八点从深圳出发，下午三点到武汉。二十七号便开始参加面试。每天上午去面试，中午去小区监工，下午再去面试，中途可能还有几个电话面试。面试算的上颇有经验吧！这几天的面试给我很多感受。&lt;/p&gt;
&lt;p&gt;一、面试的几家公司大部分是北上广深在武汉建立的研发部门。原因很简单，武汉人才性价比高。&lt;/p&gt;
&lt;p&gt;二、面试的几家公司大部分面试官都会很直接告诉你加班强度很大。&lt;/p&gt;
&lt;p&gt;三、无关技术，从深圳回到武汉，工资大概要打七折。原因嘛，五花八门。&lt;/p&gt;
&lt;p&gt;因为房子和交通，我选择公司的范围缩小了很多。因为回来匆忙，对于面试题和公司都没有很好的了解，因此在面试中一直处于劣势。现在把自己的面试经验分享出来，帮大家把部分坑填平。预祝大家都能拿高薪。我这炮灰的作用也算是尽职了。&lt;/p&gt;
&lt;h2 id=&quot;找工作不将就&quot;&gt;找工作不将就&lt;/h2&gt;
&lt;p&gt;找工作不能将就，不能进公司后发现不满意而选择离职，这样对自己和对公司都有损失。所以一开始就要问清楚。以下是我比较在意的四个点，仅供参考。&lt;/p&gt;
&lt;p&gt;一、&lt;strong&gt;加班强度&lt;/strong&gt;：现在程序员加班已成常态，产品发布还要等到夜深人静的时候。我觉得程序员就像一支蜡烛，燃烧自己照亮世界。加班一定要适量。不加，老板不会放过你！多加，医生也不会放过你！所以我希望加班强度不能太大。&lt;/p&gt;
&lt;p&gt;二、&lt;strong&gt;出差频率&lt;/strong&gt;：有的人喜欢出差，有的人不喜欢出差，比如我。&lt;/p&gt;
&lt;p&gt;三、&lt;strong&gt;额外待遇&lt;/strong&gt;：比如每月的绩效奖金，项目现金，一年的年终奖。年终奖一定要问清楚：未满一年的是怎么计算？除了每月固定工资外，一定要有其他额外福利，不然动力从何而来。&lt;/p&gt;
&lt;p&gt;四、&lt;strong&gt;接触领域&lt;/strong&gt;：如果有机会进入贵公司，最好问清楚接触的技术领域，最好是主流的技术。不建议推倒车。&lt;/p&gt;
&lt;p&gt;最后注意点：&lt;strong&gt;你用一个月加班换来的钱，还不够在医院消费一次&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;技术面试题&quot;&gt;技术面试题&lt;/h2&gt;
&lt;p&gt;你需要注意：&lt;strong&gt;回答技术问题的时候，面试官希望听到更多的答案&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;io和nio的区别&quot;&gt;IO和NIO的区别&lt;/h3&gt;
&lt;p&gt;这是一个很常见的问题，如果单纯的只回答IO和NIO的区别，只能算及格。我个人觉得应该从以下几个方面回答：&lt;/p&gt;
&lt;p&gt;1）、IO简介，&lt;/p&gt;
&lt;p&gt;2）、TCP的三次握手，因为这也是两者的区别之一，&lt;/p&gt;
&lt;p&gt;3）、NIO简介，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IO&lt;/strong&gt;：（Block-IO）是一种&lt;strong&gt;阻塞同步&lt;/strong&gt;的通信模式。是一个比较传统的通信方式，&lt;strong&gt;模式简单&lt;/strong&gt;，&lt;strong&gt;使用简单&lt;/strong&gt;。但&lt;strong&gt;并发处理能力低&lt;/strong&gt;（每次连接都会创建新的线程进行链路处理），&lt;strong&gt;通信耗时&lt;/strong&gt;（TCP三次握手），&lt;strong&gt;依赖网速&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP三次握手&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;第一次握手：建立连接，客户端发送syn包到服务器端，等待服务器确认&lt;/p&gt;
&lt;p&gt;第二次握手：服务器收到客户端传来的syn包，给客户端返回ack和syn包，等待客户端确认&lt;/p&gt;
&lt;p&gt;第三次握手：客户端收到服务器传来的ack+ayn包，向服务器发送ack包，连接建立成功&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NIO&lt;/strong&gt;：（New IO / Non-Block IO）是一种&lt;strong&gt;非阻塞同步&lt;/strong&gt;的通信模式。客户端和服务器之间通过Channel通信（避免TCP建立连接使用三次握手带来的开销）。NIO在Channel进行读写操作。这些Channel都会被注册在Selector多路复用器上。Selector通过一个线程不停的轮询这些Channel。找出已经准备就绪的Channel执行IO操作。&lt;/p&gt;
&lt;p&gt;参考文档&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/itdragon/p/8337234.html&quot;&gt;IO,BIO,AIO区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_18425655/article/details/52163228&quot;&gt;TCP三次握手详细介绍&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;java堆和栈的区别&quot;&gt;Java堆和栈的区别&lt;/h3&gt;
&lt;p&gt;1）、堆和栈的共同点，&lt;/p&gt;
&lt;p&gt;2）、堆和栈的区别，&lt;/p&gt;
&lt;p&gt;3）、线程之间数据共享，&lt;/p&gt;
&lt;p&gt;Java内存分两类，一类是堆内存，一类是栈内存&lt;/p&gt;
&lt;p&gt;堆：主要用于存储实例化的对象，数组和方法区。由JVM动态分配内存空间。一个JVM只有一个堆内存，线程是可以共享数据的。&lt;/p&gt;
&lt;p&gt;栈：主要用于存储局部变量和对象的引用变量，每个线程都会有一个独立的栈空间，所以线程之间是不共享数据的。&lt;/p&gt;
&lt;h3 id=&quot;谈谈内存溢出&quot;&gt;谈谈内存溢出&lt;/h3&gt;
&lt;p&gt;1）、先回答什么是内存溢出，&lt;/p&gt;
&lt;p&gt;2）、再谈谈内存溢出的原因，&lt;/p&gt;
&lt;p&gt;3）、最后提出几个内存溢出的解决方案，&lt;/p&gt;
&lt;p&gt;内存溢出：程序运行实际使用的内存大于虚拟机设置的内存&lt;/p&gt;
&lt;p&gt;溢出原因：&lt;/p&gt;
&lt;p&gt;1）、虚拟机配置参数设置不合理&lt;/p&gt;
&lt;p&gt;2）、代码中出现死循环或者产生大量的重复对象实体&lt;/p&gt;
&lt;p&gt;3）、数据流如果没有闭关也容易导致&lt;/p&gt;
&lt;p&gt;4）、内存中一次性加载的数据量过于庞大&lt;/p&gt;
&lt;p&gt;5）、大量的垃圾不能被JVM回收&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;1）、最直接，最不负责的方案就是修改JVM启动参数&lt;/p&gt;
&lt;p&gt;2）、正确流程是通过检查错误日志，查找OutOfMemory错误原因，然后修改bug&lt;/p&gt;
&lt;h3 id=&quot;jvm垃圾回收机制&quot;&gt;JVM垃圾回收机制&lt;/h3&gt;
&lt;p&gt;1）、先回答什么是JVM认为的垃圾，&lt;/p&gt;
&lt;p&gt;2）、都有那些常用的垃圾回收算法，&lt;/p&gt;
&lt;p&gt;3）、都有那些常用的垃圾回收器，&lt;/p&gt;
&lt;p&gt;JVM认为那些不被使用的对象就是垃圾，需要从内存中除掉。&lt;/p&gt;
&lt;p&gt;常用的垃圾回收算法有：引用计算法，标记清除法，标记压缩法，复制算法，分代，分区思想&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引用计算法&lt;/strong&gt;：古老的算法，对象被引用时加一，引用断开时减一，若为零则被当成垃圾回收。频繁加减操作性能低。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标记清除法&lt;/strong&gt;：先把垃圾&quot;标记&quot;（&lt;strong&gt;遍历所有的GC Roots，然后将所有GC Roots可达的对象标记为存活的对象&lt;/strong&gt;），后统一&quot;清理&quot;。清理后的内存空间不连续，性能不高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;标记压缩法&lt;/strong&gt;：在标记清除法的基础上做一个压缩功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复制算法&lt;/strong&gt;：内存被分为两个大小相同的A，B两块，使用A内存时，将把A内存中的活对象复制到B，然后清空内存A中的所有对象。使用B内存也是一样的。缺点是内存变小了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分代思想&lt;/strong&gt;：新生代，老年代（新生代中的对象经过频繁的GC中存活下来的对象）。新生代因为存活率低，需要复制的对象少，建议用复制算法。老年代存活率高，需要清理的对象少，建议用标记压缩法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分区思想&lt;/strong&gt;：将整个内存分为多个独立空间。在每个独立空间进行垃圾回收，提高系统性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;串行垃圾回收器&lt;/strong&gt;：使用单线程进行垃圾回收&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并行垃圾回收器&lt;/strong&gt;：使用多线程进行垃圾回收，对性能要求比较高&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CMS收回器&lt;/strong&gt;：并发回收器，比并行更快，当占用的资源更多，可以尽可能减少系统停顿时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;G1回收器&lt;/strong&gt;：JDK1.7之后提供的新的收集器，是基于标记压缩的算法，特点是针对整个java堆进行&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;JVM系列博客：&lt;a href=&quot;https://blog.csdn.net/column/details/javavirtualmachine.html&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/column/details/javavirtualmachine.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;lock和synchronized区别&quot;&gt;lock和synchronized区别&lt;/h3&gt;
&lt;p&gt;1）、简单介绍两者的区别&lt;/p&gt;
&lt;p&gt;2）、工作中建议使用synchronized的原因&lt;/p&gt;
&lt;p&gt;3）、JDK1.6之后对synchronized的优化&lt;/p&gt;
&lt;p&gt;synchronized：关键字，在jvm层面上，线程正常执行完后会释放锁，若线程发生异常则由jvm释放锁，jdk1.5之前没有锁竞争机制，容易出现线程一直阻塞的情况，只适合少并发量使用。&lt;br/&gt;Lock：类，必须在finally中释放锁，因为添加了锁竞争机制，不会出现线程一直等待的问题，适合高并发量使用。&lt;/p&gt;
&lt;p&gt;工作中建议使用synchronized关键字，原因很简单，jdk1.6之后对synchronized做了大量的优化。为了减少获得锁和释放锁所带来的性能消耗，引入了“轻量级锁”和“偏向锁”来提高性能。&lt;/p&gt;
&lt;p&gt;一、适应性自旋&lt;/p&gt;
&lt;p&gt;降低了线程在等待锁的过程中的开销。因为线程从挂起到恢复是很耗时的，有些线程在挂起后很短的时间内就可以获取锁，通过漫无目的的循环让线程暂不挂起。适应性自旋表现在自选的循环次数是根据实际情况来定。&lt;/p&gt;
&lt;p&gt;二、锁消除&lt;/p&gt;
&lt;p&gt;删除一些没必要的加锁操作。&lt;/p&gt;
&lt;p&gt;三、锁粗化&lt;/p&gt;
&lt;p&gt;虽然减小锁的粒度，可以提高性能。但有些代码明明只需要加一把锁，你非要加多个？？锁粗化可以把多次加锁和解锁合并成一次，用以提高效率。&lt;/p&gt;
&lt;p&gt;四、轻量级锁&lt;/p&gt;
&lt;p&gt;轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。&lt;/p&gt;
&lt;p&gt;五、偏向锁&lt;/p&gt;
&lt;p&gt;引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;lock和synchronized区别：&lt;a href=&quot;https://blog.csdn.net/wangtaomtk/article/details/52264043&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/wangtaomtk/article/details/52264043&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;lock和synchronized区别：&lt;a href=&quot;https://blog.csdn.net/u012403290/article/details/64910926?locationNum=11&amp;amp;fps=1&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/u012403290/article/details/64910926?locationNum=11&amp;amp;fps=1&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;hashmap底层实现&quot;&gt;HashMap底层实现&lt;/h3&gt;
&lt;p&gt;1）、简单谈谈HashMap的底层实现&lt;/p&gt;
&lt;p&gt;2）、HashMap和HashTable的区别&lt;/p&gt;
&lt;p&gt;3）、工作中线程安全的HashMap使用&lt;/p&gt;
&lt;p&gt;HashMap的底层是链表散列的数据结构，即数组和链表的结构。通过计算key的hash值确定数组的位置，若该位置已经有值，则往该元素后面添加，形成一个链表。每个Entity存储hash，key，value，next四个值。在检索中，通过hash找到数组的位置，然后在通过key遍历链表，直到找到为止。在jdk1.8以后，若链表长度超过阙值后，会将该链表转为红黑树，以提高检索效率。红黑树是自平衡查找二叉树，解决了二叉树多次插入新节点导致的不平衡。当红黑树插入新节点时会通过[变色]和[选择]来满足自身规则，详情可以参考文档连接。&lt;/p&gt;
&lt;p&gt;HashMap，HashTable，LinkedHashMap区别&lt;/p&gt;
&lt;p&gt;1）、HashMap不是线程安全的，HashTable是线程安全的，内部通过synchronized修改加锁，其性能较差&lt;/p&gt;
&lt;p&gt;2）、HashMap允许一个key为null，HashTable不允许&lt;/p&gt;
&lt;p&gt;3）、HashMap的初始容量是16，而HashTable的初始容量是11&lt;/p&gt;
&lt;p&gt;4）、工作中HashMap的使用频率较高，若希望值有序则使用LinkedHashMap，若考虑线程安全则使用ConcurrentHashMap，ConcurrentHashMap使用分段式锁性能比HashTable好。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;ArrayList和LinkedList的区别，&lt;a href=&quot;http://www.cnblogs.com/itdragon/p/8400461.html&quot;&gt;Java 常用List集合使用场景分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HashMap的实现原理：&lt;a href=&quot;https://blog.csdn.net/tuke_tuke/article/details/51588156&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/tuke_tuke/article/details/51588156&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;hashMap和hashTable的区别：&lt;a href=&quot;https://www.cnblogs.com/aspirant/p/6856487.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/aspirant/p/6856487.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;什么是红黑树：&lt;a href=&quot;http://www.sohu.com/a/201923614_466939&quot; class=&quot;uri&quot;&gt;http://www.sohu.com/a/201923614_466939&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;java单例模式实现&quot;&gt;Java单例模式实现&lt;/h3&gt;
&lt;p&gt;1）、什么是单例模式&lt;/p&gt;
&lt;p&gt;2）、常见的单例模式有那些&lt;/p&gt;
&lt;p&gt;3）、写出其中的一种&lt;/p&gt;
&lt;p&gt;单例模式：某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。&lt;/p&gt;
&lt;p&gt;常见的单例模式有：懒汉模式，饿汉模式，静态类内部加载&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;// 线程安全的静态类内部加载&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SingletonDemo{
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; SingletonHolder{
        &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; SingletonDemo instance = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;SingletonDemo&lt;/span&gt;();
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; SingletonDemo &lt;span class=&quot;fu&quot;&gt;getInstance&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; SingletonHolder.&lt;span class=&quot;fu&quot;&gt;instance&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/cielosun/p/6582333.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/cielosun/p/6582333.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;谈谈mvc模式&quot;&gt;谈谈MVC模式&lt;/h3&gt;
&lt;p&gt;听到这个问题时，我是窃喜的，多么简单的问题，可是面试的时候，却不知道该怎么回答。&lt;/p&gt;
&lt;p&gt;MVC：model，view，controller。&lt;/p&gt;
&lt;p&gt;Model：模型层，负责实现业务逻辑，操作数据库&lt;/p&gt;
&lt;p&gt;View：视图层，负责页面展示&lt;/p&gt;
&lt;p&gt;Controller：控制层，负责处理请求&lt;/p&gt;
&lt;p&gt;我们通过实际的框架来了解，&lt;/p&gt;
&lt;p&gt;SpringMVC，它实现了mvc设计模式的web框架。用户发送的请求会通过前端控制器（DispatcherServlet），根据URL映射到对应的Handler中。&lt;a href=&quot;mailto:而这个Handler可以是用注解@RequestMapping修饰的方法&quot;&gt;而这个Handler可以是用注解@RequestMapping修饰的方法&lt;/a&gt;，而这个方法所在的类可以用注解Controller修饰表明该类是一个控制层。可以在方法里面调用接口完成业务逻辑的操作和数据修改，将返回的结果放在ModelAndView变量中。DispatcherServlet会通过视图解析器拼接返回页面的路径，并将数据放到作用域中，渲染给用户。实现业务逻辑的接口可以理解为Model层，处理请求的类可以理解为Controller层，页面就是View层。&lt;/p&gt;
&lt;p&gt;谈到SpringMVC，就不会少了Struts2，&lt;/p&gt;
&lt;p&gt;Struts2也是一个基于MVC设计模式的Web应用框架，在web.xml文件中将符合要求的请求交给Servlet处理，这个 Servlet再参考struts-config.xml文件找到对应的action方法，执行完成后关联到对应的页面。SpringMVC比Struts2简单了很多。&lt;/p&gt;
&lt;p&gt;我们再简单谈谈Hibernate，Mybatis，SpringData&lt;/p&gt;
&lt;p&gt;我们还可以再谈谈Spring&lt;/p&gt;
&lt;h2 id=&quot;其他问题&quot;&gt;其他问题&lt;/h2&gt;
&lt;p&gt;还有一些因为时间和精力问题，简单整理的问题。&lt;/p&gt;
&lt;p&gt;一、redis事务是怎么做的？&lt;/p&gt;
&lt;p&gt;redis的事务主要是通过multi（开启事务），exec（提交事务），watch（监控版本号）几个命令完成的。&lt;/p&gt;
&lt;p&gt;二、如何实现抢购防超卖功能？&lt;/p&gt;
&lt;p&gt;抢购，秒杀的场景下既要保证用户体验， 又要防超卖。其实很简单，减少数据库的调用，1000个商品限时抢购，就是1000个数字减一。通过加锁保证线程安全。使用缓存提高效率。&lt;/p&gt;
&lt;p&gt;三、如何设计数据查询接口保证数据的安全和性能？&lt;/p&gt;
&lt;p&gt;安全：服务器接口令牌验证；查询参数长度校验；查询参数格式校验（避免sql注入）；&lt;/p&gt;
&lt;p&gt;性能：索引优化；Ehcache本地缓存；redis缓存预热；&lt;/p&gt;
&lt;p&gt;四、Nginx如何做权限拦截&lt;/p&gt;
&lt;p&gt;Nginx和lua可以实现权限拦截&lt;/p&gt;
&lt;p&gt;五、2*16如何最快计算结果&lt;/p&gt;
&lt;p&gt;向左移动4位&lt;/p&gt;
&lt;p&gt;六、架构如何用一个字段设置10个Boolean型权限&lt;/p&gt;
&lt;p&gt;用0，1表示false和true&lt;/p&gt;
&lt;p&gt;七、你对我们公司的了解么？&lt;/p&gt;
&lt;p&gt;先暂时到这里，喜欢的朋友可以关注我，觉得这篇文章对你有帮助也可以点赞，如有问题，请尽快联系我，会及时修改。&lt;/p&gt;
</description>
<pubDate>Fri, 11 May 2018 15:18:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itdragon/p/9026994.html</dc:identifier>
</item>
<item>
<title>「SQL归纳」树形结构表的存储与查询功能的实现——通过路径方法（非递归） - 青屿</title>
<link>http://www.cnblogs.com/Tjna/p/9026980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tjna/p/9026980.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、树形结构例子分析：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以360问答页面为例：http://wenda.so.com/c/&lt;/p&gt;
&lt;p&gt;我们通过观察URL，可以明确该页面的数据以树形结构存储，下面三块模块分别为：&lt;/p&gt;
&lt;p&gt;①根节点&lt;/p&gt;
&lt;p&gt;②根节点的第一层子节点&lt;/p&gt;
&lt;p&gt;③为左侧所选择节点的下一层子节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1393941/201805/1393941-20180511213117389-269255762.jpg&quot; alt=&quot;&quot; width=&quot;793&quot; height=&quot;377&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图1）&lt;/p&gt;
&lt;p&gt;该例简化的树形结构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1393941/201805/1393941-20180511214514608-1124681311.png&quot; alt=&quot;&quot; width=&quot;481&quot; height=&quot;214&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图2）&lt;/p&gt;
&lt;p&gt;我们不难发现，每当点击图1红框内的类别时，页面主体问题部分会显示该类别节点下所有子节点的问题。因此，需要实现查询出某节点所有子节点的功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、表的存储：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要存储两张表：&lt;/p&gt;
&lt;p&gt;1、类别表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;QType&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;
(
QID &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;&lt;span&gt;,
QPID &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
QPath &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;max&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
QTypeContent &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;max&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1393941/201805/1393941-20180511220048412-2125888098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;






&lt;p&gt;·路径字段的添加方法：找到父节点的Path +“，”+自身的ID 即可。&lt;/p&gt;

&lt;p&gt;2、问题表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; QContent
(
ContentID &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;&lt;span&gt;,
TypeID &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
Content &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;max&lt;/span&gt;) &lt;span&gt;not&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1393941/201805/1393941-20180511230020922-533771754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;·问题表的TypeID即为类别表的QID&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、表的查询&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询出某ID的所有子节点（包含自身）
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; QType &lt;span&gt;where&lt;/span&gt; &lt;span&gt;CHARINDEX&lt;/span&gt;((&lt;span&gt;select&lt;/span&gt; QPath &lt;span&gt;from&lt;/span&gt; QType &lt;span&gt;where&lt;/span&gt; QID&lt;span&gt;=&lt;/span&gt;参数),QPath)&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CHARINDEX函数说明：&lt;strong&gt;CHARINDEX ( expressionToFind , expressionToSearch [ , start_location ] )&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过CHARINDEX如果能够找到对应的字符串，则返回该字符串位置，否则返回0。因此当其&amp;gt;0时表示能在路径中找到相应字符串，即可查询到自身以及子节点。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找出以2为ID节点的所有子节点（包含自身）
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; QType &lt;span&gt;where&lt;/span&gt; &lt;span&gt;CHARINDEX&lt;/span&gt;((&lt;span&gt;select&lt;/span&gt; QPath &lt;span&gt;from&lt;/span&gt; QType &lt;span&gt;where&lt;/span&gt; QID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;),QPath)&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 查询结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1393941/201805/1393941-20180511225240178-1850832696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;





&lt;p&gt;因此，实现以上功能（即点击类别找到相应问题显示），则为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; QContent.Content &lt;span&gt;from&lt;/span&gt; QContent &lt;span&gt;where&lt;/span&gt; QContent.TypeID &lt;span&gt;IN&lt;/span&gt;&lt;span&gt;
(&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; QType.QID &lt;span&gt;from&lt;/span&gt; QType &lt;span&gt;where&lt;/span&gt; &lt;span&gt;CHARINDEX&lt;/span&gt;((&lt;span&gt;select&lt;/span&gt; QType.QPath &lt;span&gt;from&lt;/span&gt; QType &lt;span&gt;where&lt;/span&gt; QID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;参数&lt;/span&gt;),QPath)&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;四、总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过新增一个路径字段的方法，可以无需使用递归，有效提高效率。&lt;/p&gt;
&lt;p&gt;正在学习中，欢迎大家指出问题&amp;amp;相互交流！&lt;/p&gt;

</description>
<pubDate>Fri, 11 May 2018 15:12:00 +0000</pubDate>
<dc:creator>青屿</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tjna/p/9026980.html</dc:identifier>
</item>
</channel>
</rss>