<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>使用Flink的SavePoint功能 - 静若清池</title>
<link>http://www.cnblogs.com/liugh/p/8367671.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liugh/p/8367671.html</guid>
<description>&lt;p&gt;     Flink通过SavePoint功能可以做到程序升级后，继续从升级前的那个点开始执行计算，保证数据不中断。&lt;/p&gt;
&lt;p&gt;     Flink中CheckPoint用于保存状态，是自动执行的，SavePoint是指向CheckPoint的&lt;span&gt;指针&lt;/span&gt;，需要手动执行。&lt;/p&gt;
&lt;p&gt;     据Flink路线图，后面SavePoint会和CheckPoint合并成一个，不像现在这样分成两个，而且一个自动、一个手动了。&lt;/p&gt;
&lt;p&gt;1.flink-conf.yaml中配置SavePoint存储位置&lt;/p&gt;
&lt;p&gt;   不是必须设置，但是设置后，后面创建指定Job的SavePoint时，可以不用在手动命令时指定SavePoint的位置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
state.savepoints.dir: &lt;span&gt;hdfs://t-sha1-flk-01:9000/flink-savepoints&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2.列出当前Job&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[teld@T-SHA1-FLK-&lt;span&gt;01&lt;/span&gt;&lt;span&gt; log]$ flink list
&lt;/span&gt;------------------ Running/Restarting Jobs -------------------&lt;span&gt;
aaaaaaaaaaaa : &lt;/span&gt;&lt;span&gt;8eaee3ed045c14337568c1cf3a272a45 &lt;/span&gt;&lt;span&gt;: MonitorEngine_V1.0_SH.A1_Minute (RUNNING)
bbbbbbbbbbbb : &lt;span&gt;ca1f3ac0081711ee6a0767fe1fd5b31c&lt;/span&gt; : MonitorEngine_V1.0_SH.A1_Second (RUNNING)
&lt;/span&gt;--------------------------------------------------------------&lt;span&gt;
No scheduled jobs.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.停止Job，并将状态写入Savepoint&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[teld@T-SHA1-FLK-&lt;span&gt;01&lt;/span&gt; log]$ flink cancel -&lt;span&gt;s &lt;span&gt;ca1f3ac0081711ee6a0767fe1fd5b31c&lt;/span&gt;
Cancelling job ca1f3ac0081711ee6a0767fe1fd5b31c with savepoint to &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; savepoint directory.
Cancelled job ca1f3ac0081711ee6a0767fe1fd5b31c. Savepoint stored &lt;/span&gt;&lt;span&gt;&lt;span&gt;in&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;hdfs://&lt;/span&gt;&lt;span&gt;&lt;span&gt;t-sha1-flk-01:9000/flink-savepoints/&lt;span&gt;savepoint-ca1f3a-9f86a020ee76&lt;/span&gt;&lt;/span&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4.从指定的SavePoint启动Job&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
[teld@T-SHA1-FLK-&lt;span&gt;01&lt;/span&gt; log]$ flink run -s &lt;span&gt;hdfs://&lt;/span&gt;&lt;span&gt;&lt;span&gt;t-sha1-flk-01:9000/flink-savepoints/&lt;/span&gt;&lt;/span&gt;&lt;span&gt;savepoint-ca1f3a-9f86a020ee76&lt;/span&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;-p 6 -c cn.teld.monitor.MonitorEngine monitorengine_flink_sec-1.0-jar-with-dependencies.jar&lt;/span&gt; &lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5.建议为Flink程序中的每个操作设置uid以及Name&lt;/p&gt;
</description>
<pubDate>Sat, 27 Jan 2018 15:53:00 +0000</pubDate>
<dc:creator>静若清池</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liugh/p/8367671.html</dc:identifier>
</item>
<item>
<title>古中国数学家的计算力真是惊人 - 窗户</title>
<link>http://www.cnblogs.com/Colin-Cai/p/8367610.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Colin-Cai/p/8367610.html</guid>
<description>&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
　　版权申明：本文为博主窗户(Colin Cai)原创，欢迎转帖。如要转贴，必须注明原文网址

　　http://www.cnblogs.com/Colin-Cai/p/8367610.html 

　　作者：窗户

　　QQ：6679072

　　E-mail：6679072@qq.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现代数学是建立在公理化的体系之上，可以认为是形而上学。公理化是数学的本质所在，古代中国人建立过数学的辉煌，但是却似乎并没有去思考数学的本质，而古希腊的《几何原本》是人类有史以来记载的最早数学往公理化方向努力，尽管《几何原本》中存在着公理的不完备，证明过程中依然有”想当然“的成分，比如直线上除某点之外的一点（几何原本中并没有公理支持直线上除了某点之外还可以取一点），但是往公理化运行的这个历史意义巨大。&lt;/p&gt;
&lt;p&gt;　　很长时间，我都不太认为古代数学有哪些惊人，只是还知道勾股定理，杨辉三角，以及祖冲之算圆周率等。&lt;/p&gt;
&lt;p&gt;　　今天老婆问我圆周率怎么算的，我就想了想。虽然圆周率可以有一堆无穷级数或者无穷乘积可以表示，我还是选择了用最简单的方式来回答，于是就直接行动起来吧。&lt;/p&gt;
&lt;p&gt;　　选择一个单位圆，x&lt;sup&gt;2&lt;/sup&gt;+y&lt;sup&gt;2&lt;/sup&gt;=1，它的面积就是pi，于是用微积分逼近的方法来做，分成n等分，然后用上和或者下和逼近。当然要考虑精度问题，所以还是用上bc这个任意精度计算器，这个计算器我一直很喜欢使用，一边跟老婆解释一边写程序，程序很快写完。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
scale = &lt;span&gt;12&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;所有计算精度小数点后12位&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
n &lt;/span&gt;= &lt;span&gt;10&lt;/span&gt;^&lt;span&gt;6&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;单位圆切200万刀，y轴左右各100万刀&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
pi &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;上和累计初始值为0&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;) {
        x &lt;/span&gt;= i/n;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;x坐标&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        y &lt;/span&gt;= sqrt(&lt;span&gt;1&lt;/span&gt;-x^&lt;span&gt;2&lt;/span&gt;);&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;y坐标&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        s &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;*y/n;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;此块上和，4个象限对称4份&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        pi &lt;/span&gt;= pi+s;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;累和进去&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}
print &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pi = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, pi, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;最终打印出累和出来的圆周率&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　用bc运行一下，我的虚拟机24秒后有了结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
# time bc &amp;lt;2
pi = 3.141594151717

real    0m24.015s
user    0m24.006s
sys     0m0.008s
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　结果并不是很理想，计算精度12位其实只是影响了一点点累和时的精度问题，完全不是祖冲之的3.14159265级别的问题。&lt;/p&gt;
&lt;p&gt;　　于是换条路吧，祖冲之的割圆术应该是对周长的，于是我就分它个2&lt;sup&gt;15&lt;/sup&gt;=32768份，成为一个32768边形，边长其实是2*sin(2*pi/32768),我们就来算这个值吧。sin(2x)=2sin(x)*cos(x)，因为是锐角，可算出sin(x)=sqrt((1-sqrt(1-cos(2x)*cos(2x)))/2)。&lt;/p&gt;
&lt;p&gt;　　继续用bc来写，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
n=&lt;span&gt;13&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;从圆的内接正方形开始，开始对切13次&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
scale&lt;/span&gt;=&lt;span&gt;20&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;纪念20位足够&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
s&lt;/span&gt;=sqrt(&lt;span&gt;2&lt;/span&gt;)/&lt;span&gt;2&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;sin(pi/4)&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;) {
        s &lt;/span&gt;= sqrt((&lt;span&gt;1&lt;/span&gt;-sqrt(&lt;span&gt;1&lt;/span&gt;-s^&lt;span&gt;2&lt;/span&gt;))/&lt;span&gt;2&lt;/span&gt;);&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;一个个的推&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}
print &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pi = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;*s*&lt;span&gt;2&lt;/span&gt;^n, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;打印圆周率&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行一下，这次对于计算机就很快了，长度法比面积法靠谱，&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
# time bc &amp;lt;3
p = 3.14159264877598965760

real    0m0.007s
user    0m0.004s
sys     0m0.004s
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可是，精度还差那么一点，看来应该多切一刀，把程序中的n改成14,精度符合要求。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
# time bc &amp;lt;3
p = 3.14159265238350561280

real    0m0.005s
user    0m0.000s
sys     0m0.004s
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这样的开平方运算用手算是很复杂的，参考我的博文&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/Colin-Cai/p/7220506.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;《平方根的C语言实现(二) —— 手算平方根的原理》&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，我无法想像祖冲之如何面对这么复杂的运算的。中国古人虽然可能对于数学的基本原理没有做深层次的考虑（不排除以前考虑过，但资料丢失的可能，毕竟经过了嬴政和刘彻和那么多的朝代），但至少古人的计算能力真的是很让人震撼。&lt;/p&gt;

</description>
<pubDate>Sat, 27 Jan 2018 15:17:00 +0000</pubDate>
<dc:creator>窗户</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Colin-Cai/p/8367610.html</dc:identifier>
</item>
<item>
<title>数据库 MySQL进阶之索引 - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/8353262.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/8353262.html</guid>
<description>&lt;p&gt;&lt;strong&gt;数据库的索引非常重要，基本面试数据库的问题都在索引上，所以这里小编整理出来，一方面为了自己复习，一方面也方便大家。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt; 一，索引前传&lt;/h3&gt;
&lt;p&gt;　　在了解数据库索引之前，首先有必要了解一下数据库索引的数据结构基础，那么什么样的数据结构可以作为索引呢？&lt;/p&gt;
&lt;p&gt;　　B-tree是最常用的用于索引的数据结构。因为它们是时间复杂度低， 查找、删除、插入操作都可以可以在对数时间内完成。另外一个重要原因存储在B-Tree中的数据是有序的。数据库管理系统（RDBMS）通常决定索引应该用哪些数据结构。但是，在某些情况下，你在创建索引时可以指定索引要使用的数据结构。&lt;/p&gt;
&lt;p&gt;       B+是一个树数据结构，通常用于数据库和操作系统的文件系统中，B+树的特点是能够保持数据稳定有序，其插入与修改拥有比较稳定的对数时间复杂度，B+树元素自底向上插入，这个和二叉树刚好相反。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;B＋tree&lt;strong&gt; &lt;/strong&gt;是一个n叉树，每个节点有多个叶子节点，一颗B+树包含根节点，内部节点，叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上叶子节点的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　B＋tree的性质：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。&lt;/p&gt;
&lt;p&gt;　　　　2.所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。&lt;/p&gt;
&lt;p&gt;　　　　3.所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。&lt;/p&gt;
&lt;p&gt;　　      由于B+tree的性质， 它通常被用于数据库和操作系统的文件系统中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为元数据索引，因为B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度（B+ 树元素自底向上插入）。&lt;/p&gt;
&lt;p&gt;B＋tree结构原型图大概如下（引用）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1226410/201801/1226410-20180126233802475-1520182255.png&quot; alt=&quot;&quot; width=&quot;635&quot; height=&quot;375&quot;/&gt;&lt;/p&gt;

&lt;h4 id=&quot;哈希表索引是怎么工作的&quot;&gt;哈希表索引是怎么工作的？&lt;/h4&gt;
&lt;p&gt;　　哈希表是另外一种你可能看到用作索引的数据结构-这些索引通常被称为哈希索引。使用哈希索引的原因是，在寻找值时哈希表效率极高。所以，如果使用哈希索引，对于比较字符串是否相等的查询能够极快的检索出的值。&lt;/p&gt;
&lt;h4 id=&quot;哈希索引的缺点&quot;&gt;哈希索引的缺点是什么呢？&lt;/h4&gt;
&lt;p&gt;　　哈希表是无顺的数据结构，对于很多类型的查询语句哈希索引都无能为力。举例来说，假如你想要找出所有小于40岁的员工。你怎么使用使用哈希索引进行查询？这不可行，因为哈希表只适合查询键值对-也就是说查询相等的查询（例：like “WHERE name = ‘Jesus’）。哈希表的键值映射也暗示其键的存储是无序的。这就是为什么哈希索引通常不是数据库索引的默认数据结构-&lt;strong&gt;因为在作为索引的数据结构时，其不像B-Tree那么灵活&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;还有什么其他类型的索引&quot;&gt;还有什么其他类型的索引？&lt;/h4&gt;
&lt;p&gt;　　使用R-Tree作为数据结构的索引通常用来为空间问题提供帮助。例如，一个查询要求“查询出所有距离我两公里之内的星巴克”，如果数据库表使用R- Tree索引，这类查询的效率将会提高。&lt;br/&gt;　　另一种索引是位图索引（bitmap index）， 这类索引适合放在包含布尔值(true 和 false)的列上，但是这些值（表示true或false的值）的许多实例-基本上都是&lt;a href=&quot;http://www.programmerinterview.com/index.php/database-sql/selectivity-in-sql-databases/&quot; target=&quot;_blank&quot;&gt;选择性（selectivity）&lt;/a&gt;低的列。&lt;/p&gt;
&lt;h3&gt; 二，索引内容&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;2.1、索引&lt;/strong&gt;&lt;br/&gt;　　索引是对数据库表中一列或者多列的值进行排序的一种结构，使用索引可以快速访问数据库表中的特定信息，索引有助于更快的获取信息。索引是表的目录，在查找内容之前可以先在目录中查找索引位置，以此快速定位查询数据。对于索引，会保存在额外的文件中。&lt;/p&gt;
&lt;p&gt;　　索引的一个主要的目的就是加快检索表中数据的方法，也可以协助信息搜寻者能尽快的找到符合限制条件的记录。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.2、索引种类&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;普通索引：仅加速查询&lt;/li&gt;
&lt;li&gt;唯一索引：加速查询 + 列值唯一（可以有null）
&lt;ul&gt;&lt;li&gt;唯一索引是不允许其中任何两行具有相同索引值的索引，当现有数据存在大量的重复的键值的时候，大多数数据库不允许唯一索引与表一起保存，数据库还可能防止添加将表中创建重复键值的新数据。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;主键索引：加速查询 + 列值唯一 +　表中只有一个（不可以有null）
&lt;ul&gt;&lt;li&gt;数据库表经常有一列或者多列组合，其值唯一标识表中的每一行，每一列称为表的主键，在数据库关系图中为表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型，该索引要求主键索引的每个值都唯一。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;组合索引：多列值组成一个索引，&lt;br/&gt;              专门用于组合搜索，其效率大于索引合并&lt;/li&gt;
&lt;li&gt;全文索引：对文本的内容进行分词，进行搜索 &lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;——普通索引&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; -1，创建表 + 索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
create table in1(
    nid int not null auto_increment primary key,
    name varchar(32) not null,
    email varchar(64) not null,
    extra text,
    index ix_name (name)
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; -2，创建表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
create index index_name on table_name(column_name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-3，删除表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
drop index_name on table_name;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-4，查看索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
show index from table_name;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　注意：对于创建索引时如果是BLOB 和 TEXT 类型，必须指定length。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
create index ix_extra on in1(extra(32));
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;——唯一索引&lt;/h4&gt;
&lt;p&gt;-1，创建表 + 唯一索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
create table in1(
    nid int not null auto_increment primary key,
    name varchar(32) not null,
    email varchar(64) not null,
    extra text,
    unique ix_name (name)
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-2，创建唯一索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
create unique index 索引名 on 表名(列名)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-3，删除唯一索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
drop unique index 索引名 on 表名
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;——主键索引&lt;/h4&gt;
&lt;p&gt;-1，创建表+创建主键&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
create table in1(
    nid int not null auto_increment primary key,
    name varchar(32) not null,
    email varchar(64) not null,
    extra text,
    index ix_name (name)
)

OR

create table in1(
    nid int not null auto_increment,
    name varchar(32) not null,
    email varchar(64) not null,
    extra text,
    primary key(ni1),
    index ix_name (name)
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-2，创建主键&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
alter table 表名 add primary key(列名);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-3，删除主键&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
alter table 表名 drop primary key;
alter table 表名  modify  列名 int, drop primary key;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;——组合索引&lt;/h4&gt;
&lt;p&gt;组合索引是将n个列组合成一个索引&lt;/p&gt;
&lt;p&gt;其应用场景为：频繁的同时使用n列来进行查询，如：where n1 = 'alex' and n2 = 666。&lt;/p&gt;
&lt;p&gt;-1，创建表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
create table in3(
    nid int not null auto_increment primary key,
    name varchar(32) not null,
    email varchar(64) not null,
    extra text
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-2，创建组合索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
create index ix_name_email on in3(name,email);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上创建组合索引之后，查询：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;name and email  -- 使用索引&lt;/li&gt;
&lt;li&gt;name                 -- 使用索引&lt;/li&gt;
&lt;li&gt;email                 -- 不使用索引&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：对于同时搜索n个条件时，组合索引的性能好于多个单一索引合并。&lt;/p&gt;
&lt;h4&gt; ——其他&lt;/h4&gt;
&lt;p&gt;-1，条件语句（if条件语句例子）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
delimiter \\
CREATE PROCEDURE proc_if ()
BEGIN
    
    declare i int default 0;
    if i = 1 THEN
        SELECT 1;
    ELSEIF i = 2 THEN
        SELECT 2;
    ELSE
        SELECT 7;
    END IF;

END\\
delimiter ;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-2，while循环语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
delimiter \\
CREATE PROCEDURE proc_while ()
BEGIN

    DECLARE num INT ;
    SET num = 0 ;
    WHILE num &amp;lt; 10 DO
        SELECT
            num ;
        SET num = num + 1 ;
    END WHILE ;

END\\
delimiter ;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-3，repeat循环语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
delimiter \\
CREATE PROCEDURE proc_repeat ()
BEGIN

    DECLARE i INT ;
    SET i = 0 ;
    repeat
        select i;
        set i = i + 1;
        until i &amp;gt;= 5
    end repeat;

END\\
delimiter ;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-4，loop循环语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
BEGIN
    
    declare i int default 0;
    loop_label: loop
        
        set i=i+1;
        if i&amp;lt;8 then
            iterate loop_label;
        end if;
        if i&amp;gt;=10 then
            leave loop_label;
        end if;
        select i;
    end loop loop_label;

END
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;-5，动态执行SQL语句&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
delimiter \\
DROP PROCEDURE IF EXISTS proc_sql \\
CREATE PROCEDURE proc_sql ()
BEGIN
    declare p1 int;
    set p1 = 11;
    set @p1 = p1;

    PREPARE prod FROM 'select * from tb2 where nid &amp;gt; ?';
    EXECUTE prod USING @p1;
    DEALLOCATE prepare prod; 

END\\
delimiter ;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;span&gt;2.3、相关命令&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
查看表结构
    desc 表名
 
- 查看生成表的SQL
    show create table 表名
 
- 查看索引
    show index from  表名
 
- 查看执行时间
    set profiling = 1;
    SQL...
    show profiles;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.4、索引的优缺点（使用索引和不使用索引）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;通过建立索引可以极大地提高在数据库中获取所需信息的速度，同时还能提高服务器处理相关搜索请求的效率，从这个方面来看它具有以下优点：&lt;/p&gt;

&lt;ul class=&quot;custom_dot para-list list-paddingleft-1&quot; readability=&quot;4&quot;&gt;&lt;li class=&quot;list-dot list-dot-paddingleft&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;在设计数据库时，通过创建一个惟一的索引，能够在索引和信息之间形成一对一的映射式的对应关系，增加数据的惟一性特点。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;list-dot list-dot-paddingleft&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;能提高数据的搜索及检索速度，符合数据库建立的初衷。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;list-dot list-dot-paddingleft&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;能够加快表与表之间的连接速度，这对于提高数据的参考完整性方面具有重要作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;list-dot list-dot-paddingleft&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;在信息检索过程中，若使用分组及排序子句进行时，通过建立索引能有效的减少检索过程中所需的分组及排序时间，提高检索效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;list-dot list-dot-paddingleft&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;建立索引之后，在信息查询过程中可以使用优化隐藏器，这对于提高整个信息检索系统的性能具有重要意义。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然索引的建立在提高检索效率方面具有诸多积极的作用，但还是存在下列缺点  ：&lt;/p&gt;
&lt;ul class=&quot;custom_dot para-list list-paddingleft-1&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;list-dot list-dot-paddingleft&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;在数据库建立过程中，需花费较多的时间去建立并维护索引，特别是随着数据总量的增加，所花费的时间将不断递增。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;list-dot list-dot-paddingleft&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;在数据库中创建的索引需要占用一定的物理存储空间，这其中就包括数据表所占的数据空间以及所创建的每一个索引所占用的物理空间，如果有必要建立起聚簇索引，所占用的空间还将进一步的增加&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;list-dot list-dot-paddingleft&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;在对表中的数据进行修改时，例如对其进行增加、删除或者是修改操作时，索引还需要进行动态的维护，这给数据库的维护速度带来了一定的麻烦。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
由于索引是专门用于加速搜索而生，所以加上索引之后，查询效率会快到飞起来。
 
# 有索引
mysql&amp;gt; select * from tb1 where name = 'wupeiqi-888';
+-----+-------------+---------------------+----------------------------------+---------------------+
| nid | name        | email               | radom                            | ctime               |
+-----+-------------+---------------------+----------------------------------+---------------------+
| 255 | tonm        | 12474565666@qq.com  | cdccccce76a16a90b8a8301d5314204b | 2017-08-03 09:33:35 |
+-----+-------------+---------------------+----------------------------------+---------------------+
1 row in set (0.00 sec)
 
# 无索引
mysql&amp;gt; select * from tb1 where email = 'wupeiqi888@live.com';
+-----+-------------+---------------------+----------------------------------+---------------------+
| nid | name        | email               | radom                            | ctime               |
+-----+-------------+---------------------+----------------------------------+---------------------+
| 256 | tonm        | 12474565666@qq.com  | 5312269e76a1clslclscc01d5314204b | 2017-08-03 09:33:35 |
+-----+-------------+---------------------+----------------------------------+---------------------+
1 row in set (1.23 sec)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;25、正确使用索引&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据库表中添加索引后确实会让查询速度起飞，但前提必须是正确的使用索引来查询，如果以错误的方式使用，则即使建立索引也会不奏效。&lt;br/&gt;即使建立索引，索引也不会生效：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
- like '%xx'
    select * from tb1 where name like '%cn';
- 使用函数
    select * from tb1 where reverse(name) = 'wupeiqi';
- or
    select * from tb1 where nid = 1 or email = 'seven@live.com';
    特别的：当or条件中有未建立索引的列才失效，以下会走索引
            select * from tb1 where nid = 1 or name = 'seven';
            select * from tb1 where nid = 1 or email = 'seven@live.com' and name = 'alex'
- 类型不一致
    如果列是字符串类型，传入条件是必须用引号引起来，不然...
    select * from tb1 where name = 999;
- !=
    select * from tb1 where name != 'alex'
    特别的：如果是主键，则还是会走索引
        select * from tb1 where nid != 123
- &amp;gt;
    select * from tb1 where name &amp;gt; 'alex'
    特别的：如果是主键或索引是整数类型，则还是会走索引
        select * from tb1 where nid &amp;gt; 123
        select * from tb1 where num &amp;gt; 123
- order by
    select email from tb1 order by name desc;
    当根据索引排序时候，选择的映射如果不是索引，则不走索引
    特别的：如果对主键排序，则还是走索引：
        select * from tb1 order by nid desc;
 
- 组合索引最左前缀
    如果组合索引为：(name,email)
    name and email       -- 使用索引
    name                 -- 使用索引
    email                -- 不使用索引
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2.6，使用索引注意事项&lt;/h4&gt;
&lt;div class=&quot;para&quot; readability=&quot;8.76&quot;&gt;　　&lt;a href=&quot;https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95&quot; target=&quot;_blank&quot;&gt;索引&lt;/a&gt;是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。一般来说，应该在这些列上创建索引：&lt;/div&gt;
&lt;p&gt;　　在经常需要搜索的列上，可以加快搜索的速度；&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;6.5625&quot;&gt;　　在作为&lt;a href=&quot;https://baike.baidu.com/item/%E4%B8%BB%E9%94%AE&quot; target=&quot;_blank&quot;&gt;主键&lt;/a&gt;的列上，强制该列的唯一性和组织表中数据的排列结构；&lt;/div&gt;
&lt;div class=&quot;para&quot; readability=&quot;9.7333333333333&quot;&gt;　　在经常用在连接的列上，这些列主要是一些&lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%96%E9%94%AE&quot; target=&quot;_blank&quot;&gt;外键&lt;/a&gt;，可以加快连接的速度；在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；&lt;/div&gt;
&lt;p&gt;　　在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;8.4315789473684&quot;&gt;　　在经常使用在WHERE子句中的列上面创建&lt;a href=&quot;https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95&quot; target=&quot;_blank&quot;&gt;索引&lt;/a&gt;，加快条件的判断速度。&lt;/div&gt;
&lt;p&gt;　　同样，对于有些列不应该创建索引。一般来说，不应该创建索引的这些列具有下列特点：&lt;/p&gt;
&lt;p&gt;　　第一，对于那些在查询中很少使用或者参考的列不应该创建索引。这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;12.439655172414&quot;&gt;　　第二，对于那些只有很少数据值的列也不应该增加索引。这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，&lt;a href=&quot;https://baike.baidu.com/item/%E7%BB%93%E6%9E%9C%E9%9B%86&quot; target=&quot;_blank&quot;&gt;结果集&lt;/a&gt;的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加&lt;a href=&quot;https://baike.baidu.com/item/%E7%B4%A2%E5%BC%95&quot; target=&quot;_blank&quot;&gt;索引&lt;/a&gt;，并不能明显加快检索速度。&lt;/div&gt;
&lt;div class=&quot;para&quot; readability=&quot;11.0625&quot;&gt;　　第三，对于那些定义为text, image和&lt;a href=&quot;https://baike.baidu.com/item/bit%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&quot; target=&quot;_blank&quot;&gt;bit数据类型&lt;/a&gt;的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少,不利于使用索引。&lt;/div&gt;
&lt;p&gt;　　第四，当修改性能远远大于检索性能时，不应该创建索引。这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改操作远远多于检索操作时，不应该创建索引。&lt;/p&gt;
&lt;h3&gt; 三，索引后记&lt;/h3&gt;
&lt;h4 id=&quot;把数据库索引类比成什么比较好呢&quot;&gt;3.1把数据库索引类比成什么比较好呢?&lt;/h4&gt;
&lt;p&gt;　　一个非常好的类比是把数据库索引看作是书的索引。如果你有一本关于狗的书，你想要找关于‘黄金猎犬’的那部分。当你可以通过在书背的索引找到哪几页有关于‘黄金猎犬’信息的时候，你为什么要翻完正本书 - 这相当于数据库中的全表扫描。同样的，就像一本书的索引包含页码一样，数据库的索引包含了指针，指向你在SQL中想要查询的值所在的行。&lt;/p&gt;
&lt;h4 id=&quot;使用数据库索引会有什么代价&quot;&gt;3.2使用数据库索引会有什么代价？&lt;/h4&gt;
&lt;p&gt;　　那么，使用数据库索引有什么缺点呢？其一，索引会占用空间 - 你的表越大，索引占用的空间越大。其二，性能损失（主要值更新操作），当你在表中添加、删除或者更新行数据的时候， 在索引中也会有相同的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记住：建立在某列（或多列）索引需要保存该列最新的数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本原则是只如果表中某列在查询过程中使用的非常频繁，那就在该列上创建索引&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.3、limit分页&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无论是否有索引，limit分页是一个值得关注的问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
每页显示10条：
当前 118 120， 125

倒序：
            大      小
   970  7 6  6 5  54  43  32
19 98     
下一页：

    select 
        * 
    from 
        tb1 
    where 
        nid &amp;lt; (select nid from (select nid from tb1 where nid &amp;lt; 当前页最小值 order by nid desc limit 每页数据 *【页码-当前页】) A order by A.nid asc limit 1)  
    order by 
        nid desc 
    limit 10;



    select 
        * 
    from 
        tb1 
    where 
        nid &amp;lt; (select nid from (select nid from tb1 where nid &amp;lt; 970  order by nid desc limit 40) A order by A.nid asc limit 1)  
    order by 
        nid desc 
    limit 10;


上一页：

    select 
        * 
    from 
        tb1 
    where 
        nid &amp;lt; (select nid from (select nid from tb1 where nid &amp;gt; 当前页最大值 order by nid asc limit 每页数据 *【当前页-页码】) A order by A.nid asc limit 1)  
    order by 
        nid desc 
    limit 10;


    select 
        * 
    from 
        tb1 
    where 
        nid &amp;lt; (select nid from (select nid from tb1 where nid &amp;gt; 980 order by nid asc limit 20) A order by A.nid desc limit 1)  
    order by 
        nid desc 
    limit 10;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3.4、执行计划&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;explain + 查询SQL - 用于显示SQL执行信息参数，根据参考信息可以进行SQL优化&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
mysql&amp;gt; explain select * from tb2;
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
|  1 | SIMPLE      | tb2   | ALL  | NULL          | NULL | NULL    | NULL |    2 | NULL  |
+----+-------------+-------+------+---------------+------+---------+------+------+-------+
1 row in set (0.00 sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
id
        查询顺序标识
            如：mysql&amp;gt; explain select * from (select nid,name from tb1 where nid &amp;lt; 10) as B;
            +----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+
            | id | select_type | table      | type  | possible_keys | key     | key_len | ref  | rows | Extra       |
            +----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+
            |  1 | PRIMARY     | &amp;lt;derived2&amp;gt; | ALL   | NULL          | NULL    | NULL    | NULL |    9 | NULL        |
            |  2 | DERIVED     | tb1        | range | PRIMARY       | PRIMARY | 8       | NULL |    9 | Using where |
            +----+-------------+------------+-------+---------------+---------+---------+------+------+-------------+
        特别的：如果使用union连接气值可能为null


    select_type
        查询类型
            SIMPLE          简单查询
            PRIMARY         最外层查询
            SUBQUERY        映射为子查询
            DERIVED         子查询
            UNION           联合
            UNION RESULT    使用联合的结果
            ...
    table
        正在访问的表名


    type
        查询时的访问方式，性能：all &amp;lt; index &amp;lt; range &amp;lt; index_merge &amp;lt; ref_or_null &amp;lt; ref &amp;lt; eq_ref &amp;lt; system/const
            ALL             全表扫描，对于数据表从头到尾找一遍
                            select * from tb1;
                            特别的：如果有limit限制，则找到之后就不在继续向下扫描
                                   select * from tb1 where email = 'seven@live.com'
                                   select * from tb1 where email = 'seven@live.com' limit 1;
                                   虽然上述两个语句都会进行全表扫描，第二句使用了limit，则找到一个后就不再继续扫描。

            INDEX           全索引扫描，对索引从头到尾找一遍
                            select nid from tb1;

            RANGE          对索引列进行范围查找
                            select *  from tb1 where name &amp;lt; 'alex';
                            PS:
                                between and
                                in
                                &amp;gt;   &amp;gt;=  &amp;lt;   &amp;lt;=  操作
                                注意：!= 和 &amp;gt; 符号


            INDEX_MERGE     合并索引，使用多个单列索引搜索
                            select *  from tb1 where name = 'alex' or nid in (11,22,33);

            REF             根据索引查找一个或多个值
                            select *  from tb1 where name = 'seven';

            EQ_REF          连接时使用primary key 或 unique类型
                            select tb2.nid,tb1.name from tb2 left join tb1 on tb2.nid = tb1.nid;



            CONST           常量
                            表最多有一个匹配行,因为仅有一行,在这行的列值可被优化器剩余部分认为是常数,const表很快,因为它们只读取一次。
                            select nid from tb1 where nid = 2 ;

            SYSTEM          系统
                            表仅有一行(=系统表)。这是const联接类型的一个特例。
                            select * from (select nid from tb1 where nid = 1) as A;
    possible_keys
        可能使用的索引

    key
        真实使用的

    key_len
        MySQL中使用索引字节长度

    rows
        mysql估计为了找到所需的行而要读取的行数 ------ 只是预估值

    extra
        该列包含MySQL解决查询的详细信息
        “Using index”
            此值表示mysql将使用覆盖索引，以避免访问表。不要把覆盖索引和index访问类型弄混了。
        “Using where”
            这意味着mysql服务器将在存储引擎检索行后再进行过滤，许多where条件里涉及索引中的列，当（并且如果）它读取索引时，就能被存储引擎检验，因此不是所有带where子句的查询都会显示“Using where”。有时“Using where”的出现就是一个暗示：查询可受益于不同的索引。
        “Using temporary”
            这意味着mysql在对查询结果排序时会使用一个临时表。
        “Using filesort”
            这意味着mysql会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。mysql有两种文件排序算法，这两种排序方式都可以在内存或者磁盘上完成，explain不会告诉你mysql将使用哪一种文件排序，也不会告诉你排序会在内存里还是磁盘上完成。
        “Range checked for each record(index map: N)”
            这个意味着没有好用的索引，新的索引将在联接的每一行上重新估算，N是显示在possible_keys列中索引的位图，并且是冗余的。

详细
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1226410/201801/1226410-20180125212506600-1694538338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1）、id列数字越大越先执行，如果说数字一样大，那么就从上往下依次执行，id列为null的就表是这是一个结果集，不需要使用它来进行查询。&lt;/p&gt;

&lt;p&gt;2）、select_type列常见的有：&lt;/p&gt;
&lt;p&gt;A：simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个&lt;/p&gt;
&lt;p&gt;B：primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个&lt;/p&gt;
&lt;p&gt;C：union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union&lt;/p&gt;
&lt;p&gt;D：dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响&lt;/p&gt;
&lt;p&gt;E：union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null&lt;/p&gt;
&lt;p&gt;F：subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery&lt;/p&gt;
&lt;p&gt;G：dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响&lt;/p&gt;
&lt;p&gt;H：derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select&lt;/p&gt;

&lt;p&gt;3）、table&lt;/p&gt;
&lt;p&gt;显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为null，如果显示为尖括号括起来的&amp;lt;derived N&amp;gt;就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。如果是尖括号括起来的&amp;lt;union M,N&amp;gt;，与&amp;lt;derived N&amp;gt;类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。&lt;/p&gt;

&lt;p&gt;4）、type&lt;/p&gt;
&lt;p&gt;依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引&lt;/p&gt;
&lt;p&gt;A：system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index&lt;/p&gt;
&lt;p&gt;B：const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描&lt;/p&gt;
&lt;p&gt;C：eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref&lt;/p&gt;
&lt;p&gt;D：ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。&lt;/p&gt;
&lt;p&gt;E：fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引&lt;/p&gt;
&lt;p&gt;F：ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。&lt;/p&gt;
&lt;p&gt;G：unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值&lt;/p&gt;
&lt;p&gt;H：index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。&lt;/p&gt;
&lt;p&gt;I：range：索引范围扫描，常见于使用&amp;gt;,&amp;lt;,is null,between ,in ,like等运算符的查询中。&lt;/p&gt;
&lt;p&gt;J：index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range&lt;/p&gt;
&lt;p&gt;K：index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。&lt;/p&gt;
&lt;p&gt;L：all：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。&lt;/p&gt;

&lt;p&gt;5）、possible_keys&lt;/p&gt;
&lt;p&gt;查询可能使用到的索引都会在这里列出来&lt;/p&gt;

&lt;p&gt;6）、key&lt;/p&gt;
&lt;p&gt;查询真正使用到的索引，select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个。&lt;/p&gt;

&lt;p&gt;7）、key_len&lt;/p&gt;
&lt;p&gt;用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进去，没有使用到的列，这里不会计算进去。留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了。要注意，mysql的ICP特性使用到的索引不会计入其中。另外，&lt;span lang=&quot;EN-US&quot;&gt;key_len只计算&lt;span lang=&quot;EN-US&quot;&gt;where条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到&lt;span lang=&quot;EN-US&quot;&gt;key_len中。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;8）、ref&lt;/p&gt;
&lt;p&gt;如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func&lt;/p&gt;

&lt;p&gt;9）、rows&lt;/p&gt;
&lt;p&gt;这里是执行计划中估算的扫描行数，不是精确值&lt;/p&gt;

&lt;p&gt;10）、extra&lt;/p&gt;
&lt;p&gt;这个列可以显示的信息非常多，有几十种，常用的有&lt;/p&gt;
&lt;p&gt;A：distinct：在select部分使用了distinc关键字&lt;/p&gt;
&lt;p&gt;B：no tables used：不带from字句的查询或者From dual查询&lt;/p&gt;
&lt;p&gt;C：使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。&lt;/p&gt;
&lt;p&gt;D：using filesort：排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中&lt;/p&gt;
&lt;p&gt;E：using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。&lt;/p&gt;
&lt;p&gt;F：using join buffer（block nested loop），using join buffer（batched key accss）：5.6.x之后的版本优化关联查询的BNL，BKA特性。主要是减少内表的循环数量以及比较顺序地扫描查询。&lt;/p&gt;
&lt;p&gt;G：using sort_union，using_union，using intersect，using sort_intersection：&lt;/p&gt;
&lt;p&gt;using intersect：表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集&lt;/p&gt;
&lt;p&gt;using union：表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集&lt;/p&gt;
&lt;p&gt;using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。&lt;/p&gt;
&lt;p&gt;H：using temporary：表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。&lt;/p&gt;
&lt;p&gt;I：using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。extra列显示using index condition&lt;/p&gt;
&lt;p&gt;J：firstmatch(tb_name)：5.6.x开始引入的优化子查询的新特性之一，常见于where字句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个&lt;/p&gt;
&lt;p&gt;K：loosescan(m..n)：5.6.x之后引入的优化子查询的新特性之一，在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个&lt;/p&gt;

&lt;p&gt;除了这些之外，还有很多查询数据字典库，执行计划过程中就发现不可能存在结果的一些提示信息&lt;/p&gt;

&lt;p&gt;11）、filtered&lt;/p&gt;
&lt;p&gt;使用explain extended时会出现这个列，5.7之后的版本默认就有这个字段，不需要使用explain extended了。这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.5、慢日志查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a、配置MySQL自动记录慢日志&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;slow_query_log = OFF                            是否开启慢日志记录&lt;br/&gt;long_query_time = 2                              时间限制，超过此时间，则记录&lt;br/&gt;slow_query_log_file = /usr/slow.log        日志文件&lt;br/&gt;log_queries_not_using_indexes = OFF     为使用索引的搜索是否记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;注：查看当前配置信息：&lt;/em&gt;&lt;br/&gt;&lt;em&gt;　　     show variables like '%query%'&lt;/em&gt;&lt;br/&gt;&lt;em&gt;     修改当前配置：&lt;/em&gt;&lt;br/&gt;&lt;em&gt;　　　　set global 变量名 = 值&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b、查看MySQL慢日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mysqldumpslow -s at -a  /usr/local/var/mysql/MacBook-Pro-3-slow.log&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&quot;&quot;&quot;
--verbose    版本
--debug      调试
--help       帮助
 
-v           版本
-d           调试模式
-s ORDER     排序方式
             what to sort by (al, at, ar, c, l, r, t), 'at' is default
              al: average lock time
              ar: average rows sent
              at: average query time
               c: count
               l: lock time
               r: rows sent
               t: query time
-r           反转顺序，默认文件倒序拍。reverse the sort order (largest last instead of first)
-t NUM       显示前N条just show the top n queries
-a           不要将SQL中数字转换成N，字符串转换成S。don't abstract all numbers to N and strings to 'S'
-n NUM       abstract numbers with at least n digits within names
-g PATTERN   正则匹配；grep: only consider stmts that include this string
-h HOSTNAME  mysql机器名或者IP；hostname of db server for *-slow.log filename (can be wildcard),
             default is '*', i.e. match all
-i NAME      name of server instance (if using mysql.server startup script)
-l           总时间中不减去锁定时间；don't subtract lock time from total time
&quot;&quot;&quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 此篇博客主要参考：http://www.cnblogs.com/wupeiqi/articles/5716963.html；http://www.cnblogs.com/xiaoboluo768/p/5400990.html，写在这里主要是为了巩固学习知识，同时希望更多的同学学习。&lt;/p&gt;

</description>
<pubDate>Sat, 27 Jan 2018 14:39:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wj-1314/p/8353262.html</dc:identifier>
</item>
<item>
<title>缓存详解 - 秦至</title>
<link>http://www.cnblogs.com/jztan/p/8367384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jztan/p/8367384.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;总括：&lt;/strong&gt; 缓存从来都是前端的一个痛点，很多前端搞不清楚缓存到底是何物，从而给自己创造了一些麻烦，本文一如既往的用通俗易懂的文字和实例来讲述缓存，希望能让您有所得。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;天青色等烟雨，而我在等你。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说实话，我起始真的不知道怎么去介绍缓存，所以引用了上面相对官方的定义。我想几乎每个开发者都碰到过缓存的问题吧，甚至有很多情况下我们会说&lt;code&gt;这个问题已经修复了,你清理下缓存就好了&lt;/code&gt;。这篇文章我们就细细的来挖掘下缓存的种种轶事。&lt;/p&gt;
&lt;h3 id=&quot;缓存的种类&quot;&gt;🦋缓存的种类&lt;/h3&gt;
&lt;p&gt;很多开发者习惯把cookie、webStorage以及IndexedDB存储的数据也称之为缓存，理由是都是保存在客户端的数据，没有什么区别。其实这是不严谨的，cookie的存在更多的是为了让服务端区别用户，webStorage和IndexedDB则更多用在保存具体的数据和在客户端存储大量结构化数据(文件/blobs)上面。&lt;/p&gt;
&lt;p&gt;实际上所谓的缓存只有一种——它是&lt;strong&gt;请求资源的副本&lt;/strong&gt;。试想一下，如果每一个资源我们客户端都会保存一份副本，这会怎么样？客户端会炸掉，开发者会疯掉！所以我们需要一份协议来处理缓存，可以让开发者控制缓存的建立和删除。谁呢？还能有谁，&lt;code&gt;HTTP&lt;/code&gt;呗。HTTP协议里定义了很多关于缓存的请求和响应字段，这也是接下来我们重点要逼逼叨的对象，研究下究竟是哪些字段怎么影响缓存的。&lt;/p&gt;
&lt;p&gt;纳尼？你问我为什么要缓存？😱&lt;/p&gt;
&lt;p&gt;那就太容易说道了🤣，缓存好处有很多：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;缓解服务器压力(不用每次去请求资源)；&lt;/li&gt;
&lt;li&gt;提升性能(打开本地资源速度当然比请求回来再打开要快得多)；&lt;/li&gt;
&lt;li&gt;减少带宽消耗(我相信你可以理解)；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;🤦‍♀️那么问题又来了，既然缓存这么好，如果我请求的服务器中间有代理也缓存了怎么办？代理服务器缓存了我的资源导致我没法从源服务器拿到最新的资源怎么办？HTTP当然也想到了这块的诉求。接下来我们也会逐层剖析。&lt;/p&gt;
&lt;p&gt;🍉缓存在宏观上可以分成两类：&lt;strong&gt;私有缓存&lt;/strong&gt;和&lt;strong&gt;共享缓存&lt;/strong&gt;。共享缓存就是那些能被各级代理缓存的缓存(咋觉得有点绕)。私有缓存就是用户专享的，各级代理不能缓存的缓存。&lt;/p&gt;
&lt;p&gt;🐜微观上可以分下面三类：&lt;/p&gt;
&lt;h4 id=&quot;浏览器缓存&quot;&gt;1. 浏览器缓存&lt;/h4&gt;
&lt;p&gt;我相信只要你经常使用某个浏览器🌎(Chrome,Firefox,IE等)，肯定知道这些浏览器在设置里面都是有个清除缓存功能，这个功能存在的作用就是删除存储在你本地磁盘上资源副本，也就是清除缓存。&lt;/p&gt;
&lt;p&gt;缓存存在的意义就是当用户点击back按钮或是再次去访问某个页面的时候能够更快的响应。尤其是在多页应用的网站中，如果你在多个页面使用了一张相同的图片，那么缓存这张图片就变得特别的有用。😏&lt;/p&gt;
&lt;h4 id=&quot;代理服务器缓存&quot;&gt;2. 代理服务器缓存&lt;/h4&gt;
&lt;p&gt;代理服务器缓存原理和浏览器端类似，但规模要大得多，因为是为成千上万的用户提供缓存机制，大公司和大型的ISP提供商通常会将它们设立在防火墙上或是作为一个独立的设备来运营。(&lt;strong&gt;下文如果没有特殊说明,所有提到的缓存服务器都是指代理服务器。&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;由于缓存服务器不是客户端或是源服务器的一部分，它们存在于网络中，请求路由必须经过它们才会生效，所以实际上你可以去手动设置浏览器的代理，或是通过一个中间服务器来进行转发，这样用户自然就察觉不到代理服务器的存在了。🤥&lt;/p&gt;
&lt;p&gt;代理服务器缓存就是一个共享缓存，不只为一个用户服务，经常为大量用户使用，因此在减少相应时间和带宽使用方面很有效：因为同一个缓存可能会被重用多次。&lt;/p&gt;
&lt;h4 id=&quot;网关缓存&quot;&gt;3. 网关缓存&lt;/h4&gt;
&lt;p&gt;也被称为&lt;strong&gt;代理缓存或反向代理缓存&lt;/strong&gt;，网关也是一个中间服务器，网关缓存一般是网站管理员自己部署，从让网站拥有更好的性能。🙂&lt;/p&gt;
&lt;p&gt;CDNS(网络内容分发商)分布网关缓存到整个（或部分）互联网上，并出售缓存服务给需要的网站，比如国内的七牛云、又拍云都有这种服务。&lt;/p&gt;
&lt;h4 id=&quot;数据库缓存&quot;&gt;4. 数据库缓存&lt;/h4&gt;
&lt;p&gt;数据库缓存是指当我们的应用极其复杂，表自然也很繁杂，我们必须进行频繁的进行数据库查询，这样可能导致数据库不堪重负，一个好的办法就是将查询后的数据放到内存中，下一次查询直接从内存中取就好了。关于数据库缓存本篇不会展开。🙃&lt;/p&gt;
&lt;h3 id=&quot;浏览器的缓存策略&quot;&gt;🦄浏览器的缓存策略&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;缓存的目标：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个检索请求的成功响应: 对于 GET请求，响应状态码为：200，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应；&lt;/li&gt;
&lt;li&gt;不变的重定向: 响应状态码：301；&lt;/li&gt;
&lt;li&gt;可用缓存响应：响应状态码：304，这个存在疑问，Chrome会缓存304中的缓存设置，Firefox；&lt;/li&gt;
&lt;li&gt;错误响应: 响应状态码：404 的一个页面；&lt;/li&gt;
&lt;li&gt;不完全的响应: 响应状态码 206，只返回局部的信息；&lt;/li&gt;
&lt;li&gt;除了 GET 请求外，如果匹配到作为一个已被定义的cache键名的响应；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上，对于我们可以和应该缓存的目标有个了解。🤗&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢❓响应头！响应头！响应头！重要的事情说三遍。✌️&lt;/p&gt;
&lt;p&gt;我们看🌰：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;Age&lt;/span&gt;:23146
&lt;span class=&quot;kw&quot;&gt;Cache-Control&lt;/span&gt;:max-age=2592000
&lt;span class=&quot;kw&quot;&gt;Date&lt;/span&gt;:Tue, 28 Nov 2017 12:26:41 GMT
&lt;span class=&quot;kw&quot;&gt;ETag&lt;/span&gt;:W/&lt;span class=&quot;st&quot;&gt;&quot;5a1cf09a-63c6&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;Expires&lt;/span&gt;:Thu, 28 Dec 2017 05:27:45 GMT
&lt;span class=&quot;kw&quot;&gt;Last-Modified&lt;/span&gt;:Tue, 28 Nov 2017 05:14:02 GMT
&lt;span class=&quot;kw&quot;&gt;Vary&lt;/span&gt;:Accept-Encoding&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;强缓存阶段&quot;&gt;1. 强缓存阶段&lt;/h4&gt;
&lt;p&gt;以上请求头来自百度首页某个CSS文件的响应头。我去除了一些和缓存无关的字段，只保留了以上部分。我们来分析下，&lt;code&gt;Expires&lt;/code&gt;是HTTP/1.0中的定义缓存的字段，它规定了缓存过期的一个绝对时间。&lt;code&gt;Cache-Control:max-age=2592000&lt;/code&gt;是HTTP/1.1定义的关于缓存的字段，它规定了缓存过期的一个相对时间。优先级上当然是版本高的优先了，&lt;code&gt;max-age &amp;gt; Expires&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这就是&lt;strong&gt;强缓存阶段&lt;/strong&gt;，当浏览器再次试图访问这个CSS文件，发现有这个文件的缓存，那么就判断根据上一次的响应判断是否过期，如果没过期，使用缓存。加载文件，OVER！✌️&lt;/p&gt;
&lt;p&gt;Firefox浏览器表现为一个灰色的200状态码。&lt;/p&gt;
&lt;p&gt;Chrome浏览器状态码表现为:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;200 (from disk cache)或是200 OK (from memory cache)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;多说一点：&lt;/strong&gt;关于缓存是从磁盘中获取还是从内存中获取，查找了很多资料，得出了一个较为可信的结论：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很高会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是from memory cache有时是from disk cache的问题了。&lt;/p&gt;
&lt;p&gt;那么当这个CSS文件过期了怎么办?&lt;code&gt;ETag&lt;/code&gt;和&lt;code&gt;Last-Modified&lt;/code&gt;就该闪亮登场了。&lt;/p&gt;
&lt;p&gt;先说&lt;code&gt;Last-Modified&lt;/code&gt;，这个字段是文件最后一次修改的时间；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ETag&lt;/code&gt;呢？ETag是对文件的一个标记，嗯，可以这么说，具体生成方式HTTP并没有给出一个明确的方式，所以理论上只要不会重复生成方式无所谓，比如对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。&lt;/p&gt;
&lt;h4 id=&quot;协商缓存阶段&quot;&gt;2. 协商缓存阶段&lt;/h4&gt;
&lt;p&gt;利用这两个字段浏览器可以进入&lt;strong&gt;协商缓存阶段&lt;/strong&gt;，当浏览器再次试图访问这个CSS文件，发现缓存过期，于是会在本次请求的请求头里携带&lt;code&gt;If-Moified-Since&lt;/code&gt;和&lt;code&gt;If-None-Match&lt;/code&gt;这两个字段，服务器通过这两个字段来判断资源是否有修改，如果有修改则返回状态码&lt;strong&gt;200和新的内容&lt;/strong&gt;，如果没有修改返回状态码&lt;strong&gt;304&lt;/strong&gt;，浏览器收到200状态码，该咋处理就咋处理(相当于首次访问这个文件了)，发现返回&lt;strong&gt;304&lt;/strong&gt;，于是知道了本地缓存虽然过期但仍然可以用，于是加载本地缓存。然后根据新的返回的响应头来设置缓存。(这一步有所差异，发现不同浏览器的处理是不同的，chrome会为304设置缓存，firefox则不会)😑&lt;/p&gt;
&lt;p&gt;具体两个字段携带的内容如下(分别和上面的&lt;code&gt;Last-Modified&lt;/code&gt;、&lt;code&gt;ETag&lt;/code&gt;携带的值对应)：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;If-Moified-Since&lt;/span&gt;: Tue, 28 Nov 2017 05:14:02 GMT
&lt;span class=&quot;kw&quot;&gt;If-None-Match&lt;/span&gt;: W/&lt;span class=&quot;st&quot;&gt;&quot;5a1cf09a-63c6&quot;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这协商缓存结束。&lt;/p&gt;
&lt;h4 id=&quot;启发式缓存阶段&quot;&gt;3. 启发式缓存阶段&lt;/h4&gt;
&lt;p&gt;我们把上面的响应头改下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;Age&lt;/span&gt;:23146
&lt;span class=&quot;kw&quot;&gt;Cache-Control&lt;/span&gt;: public
&lt;span class=&quot;kw&quot;&gt;Date&lt;/span&gt;:Tue, 28 Nov 2017 12:26:41 GMT
&lt;span class=&quot;kw&quot;&gt;Last-Modified&lt;/span&gt;:Tue, 28 Nov 2017 05:14:02 GMT
&lt;span class=&quot;kw&quot;&gt;Vary&lt;/span&gt;:Accept-Encoding&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发现没？浏览器用来确定缓存过期时间的字段一个都没有！那该怎么办？有人可能会说下次请求直接进入协商缓存阶段，携带&lt;code&gt;If-Moified-Since&lt;/code&gt;呗，不是的，浏览器还有个&lt;strong&gt;启发式缓存阶段&lt;/strong&gt;😎&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这就是启发式缓存阶段。这个阶段很容让人忽视，但实际上每时每刻都在发挥着作用。所以在今后的开发过程中如果遇到那种&lt;code&gt;默认缓存&lt;/code&gt;的坑，不要叫嚣，不要生气，浏览器只是在遵循启发式缓存协议而已。&lt;/p&gt;
&lt;p&gt;我画了下面这张图，来解释浏览器整个缓存策略的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xsssj.com2.z0.glb.qiniucdn.com/%E7%BC%93%E5%AD%98%E8%BF%87%E7%A8%8B.svg&quot; alt=&quot;缓存&quot;/&gt;&lt;/p&gt;
&lt;p&gt;👌对于缓存策略介绍到这，接下来再细细分析不同的HTTP首部字段的内容，以及它们之间的关系。&lt;/p&gt;
&lt;h3 id=&quot;http中和缓存相关的首部字段&quot;&gt;🦀HTTP中和缓存相关的首部字段&lt;/h3&gt;
&lt;p&gt;HTTP报文是什么呢？就是HTTP报文，这是一个概念，主要由以下两部分构成：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;首部(header)&lt;/strong&gt;：包含了很多字段，比如：cookie、缓存、报文大小、报文格式等等）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主体(body)&lt;/strong&gt;：HTTP请求真正要传输的部分，比如：一个HTML文档，一个js文件；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上我们知道浏览器对于缓存的处理过程，也简单的提到了几个相关的字段。🤧接下来我们具体看下这几个字段：&lt;/p&gt;
&lt;h4 id=&quot;通用首部字段&quot;&gt;1. 通用首部字段&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;Cache-Control&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;控制缓存具体的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;Pragma&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;HTTP1.0时的遗留字段，当值为&quot;no-cache&quot;时强制验证缓存&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;Date&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;创建报文的日期时间(启发式缓存阶段会用到这个字段)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;响应首部字段&quot;&gt;2. 响应首部字段&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ETag&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;服务器生成资源的唯一标识&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Vary&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;代理服务器缓存的管理信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Age&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;资源在缓存代理中存贮的时长(取决于max-age和s-maxage的大小)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;请求首部字段&quot;&gt;3. 请求首部字段&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td align=&quot;left&quot;&gt;If-Match&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;If-None-Match&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;和If-Match作用相反，服务器根据这个字段判断文件是否有新的修改&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;If-Modified-Since&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;比较资源前后两次访问最后的修改时间是否一致&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;If-Unmodified-Since&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;比较资源前后两次访问最后的修改时间是否一致&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;实体首部字段&quot;&gt;4. 实体首部字段&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Expires&lt;/td&gt;
&lt;td&gt;告知客户端资源缓存失效的绝对时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Last-Modified&lt;/td&gt;
&lt;td&gt;资源最后一次修改的时间&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;浏览器缓存控制&quot;&gt;🦅浏览器缓存控制&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html&quot;&gt;HTTP/1.1&lt;/a&gt;一共规范了47种首部字段，而和缓存相关的就有以上12个之多。接下来的两个小节会一个一个介绍给大家。🤓&lt;/p&gt;
&lt;h4 id=&quot;cache-control&quot;&gt;1. Cache-Control&lt;/h4&gt;
&lt;p&gt;通过cache-control的指令可以控制告诉客户端或是服务器如何处理缓存。这也是11个字段中指令最多的一个，我们先来看看&lt;strong&gt;请求指令&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;no-cache&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;强制源服务器再次验证&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;no-store&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;不缓存请求或是响应的任何内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;max-age=[秒]&lt;/td&gt;
&lt;td&gt;缓存时长，单位是秒&lt;/td&gt;
&lt;td&gt;缓存的时长，也是响应的最大的Age值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;min-fresh=[秒]&lt;/td&gt;
&lt;td&gt;必需&lt;/td&gt;
&lt;td&gt;期望在指定时间内响应仍然有效&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;no-transform&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;代理不可更改媒体类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;only-if-cached&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;从缓存获取&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;cache-extension&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;新的指令标记(token)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;响应指令&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;public&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;任意一方都能缓存该资源(客户端、代理服务器等)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;private&lt;/td&gt;
&lt;td&gt;可省略&lt;/td&gt;
&lt;td&gt;只能特定用户缓存该资源&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;no-cache&lt;/td&gt;
&lt;td&gt;可省略&lt;/td&gt;
&lt;td&gt;缓存前必须先确认其有效性&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;no-store&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;不缓存请求或响应的任何内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;no-transform&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;代理不可更改媒体类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;must-revalidate&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;可缓存但必须再向源服务器进确认&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;proxy-revalidate&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;要求中间缓存服务器对缓存的响应有效性再进行确认&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;max-age=[秒]&lt;/td&gt;
&lt;td&gt;缓存时长，单位是秒&lt;/td&gt;
&lt;td&gt;缓存的时长，也是响应的最大的Age值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;s-maxage=[秒]&lt;/td&gt;
&lt;td&gt;必需&lt;/td&gt;
&lt;td&gt;公共缓存服务器响应的最大Age值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;cache-extension&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;新指令标记(token&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;请注意no-cache指令很多人误以为是不缓存，这是不准确的，no-cache的意思是可以缓存，但每次用应该去想服务器验证缓存是否可用。no-store才是不缓存内容。另外部分指令也可以组合使用，比如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;Cache-Control&lt;/span&gt;: max-age=100, must-revalidate, public&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面指令的意思是缓存的有效时间为100秒，之后访问需要向源服务器发送请求验证，此缓存可被代理服务器和客户端缓存。&lt;/p&gt;
&lt;h4 id=&quot;pragma&quot;&gt;2. Pragma&lt;/h4&gt;
&lt;p&gt;这是HTTP/1.0里面的一个字段，但&lt;strong&gt;优先级很高&lt;/strong&gt;，测试发现，Chrome和Firefox中Pragma的优先级高于Cache-Control和Expires，为了向下兼容，这个字段依然发挥着它的作用。🤔一般可能我们会这么用：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; http-equiv=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Pragma&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; content=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;no-cache&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Pragma属于通用首部字段，在客户端上使用时，常规要求我们往html上加上上面这段meta元标签（而且可能还得&lt;a href=&quot;https://support.microsoft.com/zh-cn/kb/222064&quot;&gt;做些hack放到body后面去&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;事实上这种禁用缓存的形式用处很有限：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;仅有IE才能识别这段meta标签含义，其它主流浏览器仅能识别&lt;code&gt;Cache-Control: no-store&lt;/code&gt;的meta标签(见&lt;a href=&quot;http://securityevaluators.com/knowledge/case_studies/caching/&quot;&gt;出处&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;在IE中识别到该meta标签含义，并不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求(仅限页面，页面上的资源则不受影响)。——&lt;a href=&quot;http://www.cnblogs.com/vajoy/p/5341664.html&quot;&gt;浅谈浏览器http的缓存机制&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;读者可以自行拷贝后面模拟服务端决策的代码进行测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务端响应添加&lt;code&gt;'Pragma': 'no-cache'&lt;/code&gt;，浏览器表现行为和强制刷新类似。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;expires&quot;&gt;3. Expires&lt;/h4&gt;
&lt;p&gt;这又是一个HTTP/1.0的字段，上面也说过了定义的是缓存到期的绝对时间。&lt;/p&gt;
&lt;p&gt;同样，我们也可以在html文件里直接使用:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; http-equiv=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;expires&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; content=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;Thu, 30 Nov 2017 11:17:26 GMT&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果设置的是已经过去的时间会怎样呢？YES！！！则刷新页面会重新发送请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pragma禁用缓存，如果又给Expires定义一个还未到期的时间，那么Pragma字段的优先级会更高。&lt;/strong&gt;🤖&lt;/p&gt;
&lt;p&gt;🤖Expires有一个很大的弊端，就是它返回的是服务器的时间，但判断的时候用的却是客户端的时间，这就导致Expires很被动，因为用户有可能改变客户端的时间，导致缓存时间判断出错，这也是引入&lt;code&gt;Cache-Control:max-age&lt;/code&gt;指令的原因之一。&lt;/p&gt;
&lt;h4 id=&quot;last-midified&quot;&gt;4. Last-Midified&lt;/h4&gt;
&lt;p&gt;接下来这几个字段都是校验字段，或者说是在协商缓存阶段发挥作用的字段。第一个就是Last-modified，这个字段不光协商缓存起作用，在启发式缓存阶段同样起到至关重要的作用。&lt;/p&gt;
&lt;p&gt;在浏览器第一次请求某一个URL时，服务器端的返回状态码会是200，响应的实体内容是客户端请求的资源，同时有一个&lt;code&gt;Last-Modified&lt;/code&gt;的属性标记此文件在服务器端最后被修改的时间。like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;Last-Modified&lt;/span&gt; : Fri , 12 May 2006 18:53:33 GMT&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&quot;if-modified-since&quot;&gt;If-Modified-Since&lt;/h5&gt;
&lt;p&gt;当浏览器第二次请求这个URL的时候，根据HTTP协议规定，浏览器会把第一次&lt;code&gt;Last-Modified&lt;/code&gt;的值存储在&lt;code&gt;If-Modified-Since&lt;/code&gt;里面发送给服务端来验证资源有没有修改。like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;If-Modified-Since&lt;/span&gt; : Fri , 12 May 2006 18:53:33 GMT&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务端通过&lt;code&gt;If-Modified-Since&lt;/code&gt;字段来判断在这两次访问期间资源有没有被修改过，从而决定是否返回完整的资源。如果有修改正常返回资源，状态码200，如果没有修改只返回响应头，状态码304，告知浏览器资源的本地缓存还可用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用途：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;验证本地缓存是否可用&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;if-unmodified-since&quot;&gt;If-Unmodified-Since&lt;/h5&gt;
&lt;p&gt;这个字段字面意思和&lt;code&gt;If-Modified-Since&lt;/code&gt;相反，但处理方式并不是相反的。如果文件在两次访问期间没有被修改则返回200和资源，如果文件修改了则返回状态码412(预处理错误)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用途：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;与含有 &lt;code&gt;If-Range&lt;/code&gt;消息头的范围请求搭配使用，实现断点续传的功能，即如果资源没修改继续下载，如果资源修改了，续传的意义就没有了。&lt;/li&gt;
&lt;li&gt;POST、PUT请求中，优化并发控制，即当多用户编辑用一份文档的时候，如果服务器的资源已经被修改，那么在对其作出编辑会被拒绝提交。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;😈&lt;code&gt;Last-Modified&lt;/code&gt;有几个缺点：没法准确的判断资源是否真的修改了，比如某个文件在1秒内频繁更改了多次，根据Last-Modified的时间(单位是秒)是判断不出来的，再比如，某个资源只是修改了，但实际内容并没有发生变化，Last-Modified也无法判断出来，因此在HTTP/1.1中还推出了&lt;code&gt;ETag&lt;/code&gt;这个字段👇&lt;/p&gt;
&lt;h4 id=&quot;etag&quot;&gt;5. ETag&lt;/h4&gt;
&lt;p&gt;服务器可以通过某种自定的算法对资源生成一个唯一的标识(比如md5标识)，然后在浏览器第一次请求某一个URL时把这个标识放到响应头传到客户端。服务器端的返回状态会是200。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;ETag&lt;/span&gt;: abc-123456&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ETag的值有可能包含一个 W/ 前缀，来提示应该采用弱比较算法（这个是画蛇添足，因为 If-None-Match 用且仅用这一算法）。🙄&lt;/p&gt;
&lt;h5 id=&quot;if-none-match&quot;&gt;If-None-Match&lt;/h5&gt;
&lt;p&gt;If-None-Match和If-Modified-Since同时存在的时候If-None-Match优先级更高。&lt;/p&gt;
&lt;p&gt;当浏览器第二次请求这个URL的时候，根据HTTP协议规定，浏览器回把第一次ETag的值存储在If-None-Match里面发送给服务端来验证资源有没有修改。like this:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;If-None-Match&lt;/span&gt;: abc-123456&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Get请求中，当且仅当服务器上没有任何资源的ETag属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为&lt;strong&gt;200&lt;/strong&gt;。如果没有资源的ETag值相匹配，那么返回&lt;strong&gt;304&lt;/strong&gt;状态码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;POST、PUT等请求改变文件的请求，如果没有资源的ETag值相匹配，那么返回412状态码。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;if-match&quot;&gt;If-Match&lt;/h5&gt;
&lt;p&gt;在请求方法为 GET) 和 HEAD的情况下，服务器仅在请求的资源满足此首部列出的 &lt;code&gt;ETag&lt;/code&gt;之一时才会返回资源。而对于 PUT或其他非安全方法来说，只有在满足条件的情况下才可以将资源上传。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用途：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;For GET和 HEAD 方法，搭配 Range首部使用，可以用来保证新请求的范围与之前请求的范围是对同一份资源的请求。如果 ETag 无法匹配，那么需要返回 &lt;strong&gt;416&lt;/strong&gt;（范围请求无法满足) 响应。&lt;/li&gt;
&lt;li&gt;对于其他方法来说，尤其是 PUT, &lt;code&gt;If-Match&lt;/code&gt; 首部可以用来避免更新丢失问题。它可以用来检测用户想要上传的不会覆盖获取原始资源之后做出的更新。如果请求的条件不满足，那么需要返回&lt;strong&gt;412&lt;/strong&gt;(预处理错误) 响应。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然和&lt;code&gt;Last-Modified&lt;/code&gt;相比，ETag也有自己的缺点，比如由于需要对资源进行生成标识，性能方面就势必有所牺牲。😕&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于强校验和弱校验：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;W/&quot;1&quot;&lt;/td&gt;
&lt;td&gt;W/&quot;1&quot;&lt;/td&gt;
&lt;td&gt;no match&lt;/td&gt;
&lt;td&gt;match&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;W/&quot;1&quot;&lt;/td&gt;
&lt;td&gt;W/&quot;2&quot;&lt;/td&gt;
&lt;td&gt;no match&lt;/td&gt;
&lt;td&gt;no match&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;W/&quot;1&quot;&lt;/td&gt;
&lt;td&gt;&quot;1&quot;&lt;/td&gt;
&lt;td&gt;no match&lt;/td&gt;
&lt;td&gt;match&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&quot;1&quot;&lt;/td&gt;
&lt;td&gt;&quot;1&quot;&lt;/td&gt;
&lt;td&gt;match&lt;/td&gt;
&lt;td&gt;match&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;服务端缓存控制&quot;&gt;🐝服务端缓存控制&lt;/h3&gt;
&lt;p&gt;当&lt;code&gt;Expires&lt;/code&gt;和&lt;code&gt;Cache-Control:max-age=xxx&lt;/code&gt;同时存在的时候取决于缓存服务器应用的HTTP版本。应用HTTP/1.1版本的服务器会优先处理max-age，忽略Expires，而应用HTTP/1.0版本的缓存服务器则会优先处理Expires而忽略max-age。接下来看下和缓存服务器相关的两个字段。&lt;/p&gt;
&lt;h4 id=&quot;vary&quot;&gt;6. Vary&lt;/h4&gt;
&lt;p&gt;Vary用来做什么的呢？试想这么一个场景：在某个网页中网站提供给移动端的内容是不同的，怎么让缓存服务器区分移动端和PC端呢？不知道你是否注意，浏览器在每次请求都会携带UA字段来表明来源，所以我们可以利用&lt;code&gt;User-Agent&lt;/code&gt;字段来区分不同的客户端，用法如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;Vary&lt;/span&gt;: User-Agent&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再比如，源服务器启用了gzip压缩，但用户使用了比较旧的浏览器，不支持压缩，缓存服务器如何返回？就可以这么设定：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;Vary&lt;/span&gt;: Accept-Encoding&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，也可以这么用：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;Vary&lt;/span&gt;: User-Agent, Accept-Encoding&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这意味着缓存服务器会以&lt;code&gt;User-Agent&lt;/code&gt;和 &lt;code&gt;Accept-Encoding&lt;/code&gt;两个请求首部字段来区分缓存版本。根据请求头里的这两个字段来决定返回给客户端什么内容。&lt;/p&gt;
&lt;h4 id=&quot;age&quot;&gt;7. Age&lt;/h4&gt;
&lt;p&gt;这个字段说的是资源在缓存服务器存在的时长，前面也说了&lt;code&gt;Cache-Control: max-age=[秒]&lt;/code&gt;就是Age的最大值。&lt;/p&gt;
&lt;p&gt;这个字段存在的意义是什么呢？用来区分请求的资源来自源服务器还是缓存服务器的缓存的。&lt;/p&gt;
&lt;p&gt;🤧但得结合另一个字段来进行判断，就是Date，Date是报文创建的时间。&lt;/p&gt;
&lt;h5 id=&quot;date&quot;&gt;Date&lt;/h5&gt;
&lt;p&gt;如果按F5频繁刷新发现响应里的Date没有改变，就说明命中了缓存服务器的缓存以下面的一个响应为🍐：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;Accept-Ranges&lt;/span&gt;: bytes
&lt;span class=&quot;kw&quot;&gt;Age&lt;/span&gt;: 1016859
&lt;span class=&quot;kw&quot;&gt;Cache-Control&lt;/span&gt;: max-age=2592000
&lt;span class=&quot;kw&quot;&gt;Content-Length&lt;/span&gt;: 14119
&lt;span class=&quot;kw&quot;&gt;Content-Type&lt;/span&gt;: image/png
&lt;span class=&quot;kw&quot;&gt;Date&lt;/span&gt;: Fri, 01 Dec 2017 12:27:25 GMT
&lt;span class=&quot;kw&quot;&gt;ETag&lt;/span&gt;: &lt;span class=&quot;st&quot;&gt;&quot;5912bfd0-3727&quot;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;Expires&lt;/span&gt;: Tue, 19 Dec 2017 17:59:46 GMT
&lt;span class=&quot;kw&quot;&gt;Last-Modified&lt;/span&gt;: Wed, 10 May 2017 07:22:56 GMT
&lt;span class=&quot;kw&quot;&gt;Ohc-Response-Time&lt;/span&gt;: 1 0 0 0 0 0
&lt;span class=&quot;kw&quot;&gt;Server&lt;/span&gt;: bfe/1.0.8.13-sslpool-patch&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上图来自百度首页某个图片的响应字段。我们可以看到Age=1016859，说明这个资源已经在缓存服务器存在了1016859秒。如果文件被修改或替换，Age会重新由0开始累计。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Age消息头的值通常接近于0。表示此消息对象刚刚从原始服务器获取不久；其他的值则是表示代理服务器当前的系统时间与此应答消息中的通用消息头 Date的值之差。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面这个结论归结为一个等式就是：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;静态资源&lt;span class=&quot;kw&quot;&gt;Age&lt;/span&gt; + 静态资源Date = 原服务端Date&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;用户操作行为对缓存的影响&quot;&gt;🐲用户操作行为对缓存的影响&lt;/h3&gt;
&lt;p&gt;搜索了很久有没有关于这方面的权威总结，最后竟然在百度百科找到了也是很惊讶，我自己加了一条用户强制刷新操作浏览器的反应。强制刷新，window下是&lt;code&gt;Ctrl+F5&lt;/code&gt;,mac下就是&lt;code&gt;command+shift+R&lt;/code&gt;操作了。😌&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;8&quot;&gt;&lt;td align=&quot;left&quot;&gt;打开新窗口&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;如果指定cache-control的值为private、no-cache、must-revalidate,那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值,那么在此值内的时间里就不会重新访问服务器,例如：Cache-control: max-age=5 表示当访问此网页后的5秒内不会去再次访问服务器.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;8&quot;&gt;&lt;td align=&quot;left&quot;&gt;在地址栏回车&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;如果值为private或must-revalidate,则只有第一次访问时会访问服务器,以后就不再访问。如果值为no-cache,那么每次都会访问。如果值为max-age,则在过期之前不会重复访问。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td align=&quot;left&quot;&gt;按后退按扭&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;如果值为private、must-revalidate、max-age,则不会重访问,而如果为no-cache,则每次都重复访问.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;按刷新按扭&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;无论为何值,都会重复访问.（可能返回状态码：200、304，这个不同浏览器处理是不一样的，FireFox正常，Chrome则会启用缓存(200 from cache)）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;按强制刷新按钮&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;当做首次进入重新请求(返回状态码200)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/Cache-control/1885913?fr=aladdin&quot;&gt;来自百度百科&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;😉如果想在浏览器点击“刷新”按钮的时候不让浏览器去发新的验证请求呢？办法找到一个，知乎上面一个回答，在页面加载完毕后通过脚本动态地添加资源：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;at&quot;&gt;$&lt;/span&gt;(window).&lt;span class=&quot;at&quot;&gt;load&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; bg&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'http://img.infinitynewtab.com/wallpaper/100.jpg'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;at&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;at&quot;&gt;$&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'#bgOut'&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;css&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'background-image'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'url('&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;bg&lt;span class=&quot;op&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;')'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/28725359/answer/41960936&quot;&gt;来自知乎&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;html5的缓存&quot;&gt;🐩HTML5的缓存&lt;/h3&gt;
&lt;p&gt;这部分准备的说应该叫离线存储。现在比较普遍用的是&lt;code&gt;Appcache&lt;/code&gt;，但&lt;code&gt;Appcache&lt;/code&gt;已经从web标准移除了，在可预见的未来里，&lt;code&gt;ServiceWorker&lt;/code&gt;可能会是一个比较适合的解决方案。&lt;/p&gt;
&lt;h4 id=&quot;appcache&quot;&gt;1. Appcache&lt;/h4&gt;
&lt;p&gt;这是HTML5的一个新特性，通过离线存储达到用户在没有网络连接的情况下也能访问页面的功能。离线状态下即使用户点击刷新都能正常加载文档。&lt;/p&gt;
&lt;p&gt;使用方法如下，在HTML文件中引入&lt;code&gt;appcache&lt;/code&gt;文件:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; manifest=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;manifest.appcache&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;***&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;root&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;🤠web 应用中的 &lt;code&gt;manifest&lt;/code&gt; 特性可以指定为缓存清单文件的相对路径或一个绝对 URL(绝对 URL 必须与应用同源)。缓存清单文件可以使用任意扩展名，但传输它的 MIME 类型必须为 &lt;code&gt;text/cache-manifest。&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;在 Apache 服务器上，若要设置适用于清单(.appcache)文件的 MIME 类型，可以向根目录或应用的同级目录下的一个 .htaccess 文件中增加 &lt;code&gt;AddType text/cache-manifest .appcache&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;CACHE&lt;/span&gt; MANIFEST
&lt;span class=&quot;co&quot;&gt;# 注释：需要缓存的文件，无论在线与否，均从缓存里读取&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# v1 2017-11-30&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;# This is another comment&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;/static/logo.png&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 注释：不缓存的文件，始终从网络获取&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;NETWORK&lt;/span&gt;:
&lt;span class=&quot;kw&quot;&gt;example.js&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;# 注释：获取不到资源时的备选路径，如index.html访问失败，则返回404页面&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;FALLBACK&lt;/span&gt;:
&lt;span class=&quot;kw&quot;&gt;index.html&lt;/span&gt; 404.html&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面就是一个完整的缓存清单文件的示例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;主页一定会被缓存起来的，因为AppCache主要是用来做离线应用的，如果主页不缓存就无法离线查看了，因此把index.html添加到NETWORK中是不起效果的。&lt;/p&gt;
&lt;p&gt;实际上这个特性已经web标准中删除，但现在为止还有很多浏览器支持它，所以这里提一下。&lt;/p&gt;
&lt;p&gt;你可以用最新的Firefox(版本 57.0.1)测试下，控制台会有这么一行字👉：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;程序缓存 API（AppCache）已不赞成使用，几天后将被移除。需离线支持请尝试使用 Service Worker。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最新Chrome(版本 62.0.3202.94)倒是没有这个警告。🐻&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AppCache&lt;/code&gt;之所以不受待见我想了下面几个原因：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一旦使用了manifest后，没办法清空这些缓存，只能更新缓存，或者得用户自己去清空浏览器的缓存；&lt;/li&gt;
&lt;li&gt;假如更新的资源中有一个资源更新失败了，那么所有的资源就会全部更新失败，将用回上一版本的缓存；&lt;/li&gt;
&lt;li&gt;主页会被强制缓存(使用了manifest的页面)，并且无法清除；&lt;/li&gt;
&lt;li&gt;appache文件可能会无法被及时更新，因为各大浏览器对于appcache文件的处理方式不同；&lt;/li&gt;
&lt;li&gt;以上几个弊端一旦出问题，会让用户抓狂更会让开发者抓狂！&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;service-worker&quot;&gt;2. Service Worker&lt;/h4&gt;
&lt;p&gt;Service worker还是一个实验性的功能，线上环境不推荐使用。🐒这里大概介绍一下。&lt;/p&gt;
&lt;p&gt;Service worker本质上充当Web应用程序与浏览器之间的代理服务器。&lt;/p&gt;
&lt;p&gt;🙂&lt;strong&gt;首先讲个小故事：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们都知道浏览器的js引擎处理js是单线程的，它就好像一个大Boss高高在上，同一个时间它只做一个事情(就是那么傲娇)，基于这个弊端，&lt;strong&gt;W3C&lt;/strong&gt;(HR)给大Boss招聘了一个秘书(&lt;code&gt;web worker&lt;/code&gt;)，大Boss可以把琐碎的事情交给秘书&lt;code&gt;web worker&lt;/code&gt;去做，做完了发个微信(&lt;code&gt;postMessage&lt;/code&gt;)通知大Boss，大Boss通过&lt;code&gt;onmessage&lt;/code&gt;来获取秘书&lt;code&gt;web worker&lt;/code&gt;做的事情的结果。傍晚时分，下班时间到！大Boss回家哄儿子了，秘书也出去约会去了，没人加班了！这怎么行！&lt;strong&gt;W3C&lt;/strong&gt;(HR)又提出了招个&lt;strong&gt;程序🐵&lt;/strong&gt;的想法的想法，OK，&lt;code&gt;Service Worker&lt;/code&gt;应聘成功！于是，&lt;strong&gt;程序🙈&lt;/strong&gt;就坚持在工作岗位上了，从此开启没完没了的加班之路。总的来说这只猿的工作是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;后台数据同步&lt;/li&gt;
&lt;li&gt;响应来自其它源的资源请求&lt;/li&gt;
&lt;li&gt;集中接收计算成本高的数据更新，比如地理位置和陀螺仪信息，这样多个页面就可以利用同一组数据&lt;/li&gt;
&lt;li&gt;在客户端进行CoffeeScript，LESS，CJS/AMD等模块编译和依赖管理（用于开发目的）&lt;/li&gt;
&lt;li&gt;后台服务钩子&lt;/li&gt;
&lt;li&gt;自定义模板用于特定URL模式&lt;/li&gt;
&lt;li&gt;性能增强，比如预取用户可能需要的资源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;——&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API&quot;&gt;Service Worker API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意：Service workers之所以优于以前同类尝试（如上面提到的AppCache)），是因为它们无法支持当操作出错时终止操作。Service workers可以更细致地控制每一件事情。如何控制的呢？&lt;/p&gt;
&lt;p&gt;Service workers利用了ES6中比较重要的特性Promise，并且在拦截请求的时候使用的是新的fetch API，之所以使用fetch就是因为fetch返回的是Promise对象。可以说Service workers重要组成部分就是三块：事件、Promise和Fetch请求。OK，talk is cheap，show you the code。🤓&lt;/p&gt;
&lt;p&gt;首先我们看下app.js文件：告诉浏览器注册某个JavaScript文件为service worker，检查service worker API是否可用，如果可用就注册service worker：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;//使用 ServiceWorkerContainer.register()方法首次注册service worker。&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;navigator&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;serviceWorker&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;navigator&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;serviceWorker&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;register&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'./sw.js'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;scope&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
        .&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (registration) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(registration)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
        .&lt;span class=&quot;at&quot;&gt;catch&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (e) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;error&lt;/span&gt;(e)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'该浏览器不支持Service Worker'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来看看具体作为service worker的文件sw.js，例子如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; CACHE_VERSION &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'v1'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 缓存文件的版本&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; CACHE_FILES &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [ &lt;span class=&quot;co&quot;&gt;// 需要缓存的文件&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;'./test.js'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;'./app.js'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;'https://code.jquery.com/jquery-3.0.0.min.js'&lt;/span&gt;
]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;addEventListener&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'install'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (event) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 监听worker的install事件&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;waitUntil&lt;/span&gt;( &lt;span class=&quot;co&quot;&gt;// 延迟install事件直到缓存初始化完成&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;caches&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;open&lt;/span&gt;(CACHE_VERSION)
        .&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (cache) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'缓存打开'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;cache&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;addAll&lt;/span&gt;(CACHE_FILES)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
    )&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;addEventListener&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'activate'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(event) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;// 监听worker的activate事件&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;waitUntil&lt;/span&gt;(&lt;span class=&quot;co&quot;&gt;// 延迟activate事件直到&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;caches&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;keys&lt;/span&gt;().&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(keys) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;Promise&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;all&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;keys&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;map&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(key&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; i)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(key &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; CACHE_VERSION)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;caches&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;delete&lt;/span&gt;(keys[i])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 清除旧版本缓存&lt;/span&gt;
                &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;))
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
    )
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;self&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;addEventListener&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'fetch'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(event) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 截取页面的资源请求&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;respondWith&lt;/span&gt;(
        &lt;span class=&quot;va&quot;&gt;caches&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;match&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;request&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(res) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 判断缓存是否命中&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (res) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 返回缓存中的资源&lt;/span&gt;
                &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; res&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;at&quot;&gt;_request&lt;/span&gt;(event)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 执行请求备份操作&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
    )
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;_request&lt;/span&gt;(event) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;clone&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;fetch&lt;/span&gt;(url).&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(res) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;// 使用fetch请求线上资源&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;// 错误判断&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;op&quot;&gt;!&lt;/span&gt;res &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;res&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;status&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;res&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'basic'&lt;/span&gt;) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; res&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; response &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;res&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;clone&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 创建了一个响应对象的克隆,储藏在一个单独的变量中&lt;/span&gt;

        &lt;span class=&quot;va&quot;&gt;caches&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;open&lt;/span&gt;(CACHE_VERSION).&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(cache) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;// 缓存从线上获取的资源&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;cache&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;put&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;event&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; response)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; res&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;清除一个Service Worker也很简单：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;st&quot;&gt;'serviceWorker'&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; navigator) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;va&quot;&gt;navigator&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;serviceWorker&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;register&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/sw.js'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;scope&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'./'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(registration) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// registration worked&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Registration succeeded.'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;registration&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;unregister&lt;/span&gt;().&lt;span class=&quot;at&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(boolean) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;co&quot;&gt;// if boolean = true, unregister is successful&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;catch&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;(error) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// registration failed&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'Registration failed with '&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; error)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相对AppCache来说，Service Worker的API增多了不少，用法也更复杂了些，但看得出Service Worker才是未来，对于web app来说，更是如虎添翼。现在支持Service Worker的浏览器除了Chrome和Firefox，最近新添一个生力军——Safari也支持Service Worker了。期待它在未来大放异彩吧。🤗&lt;/p&gt;
&lt;h3 id=&quot;模拟实现服务端决策&quot;&gt;🦉模拟实现服务端决策&lt;/h3&gt;
&lt;p&gt;如下，使用node原生代码简单的模拟下服务器发送响应的过程，包括对于协商缓存的处理过程：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; http &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'http'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; fs &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'fs'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; url &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'url'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;env&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;TZ&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Europe/London'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; tag &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'123456'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;va&quot;&gt;http&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;createServer&lt;/span&gt;( &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (request&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; response) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;  

   &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; pathname &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;url&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;parse&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;url&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;pathname&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Request for &quot;&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; pathname &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot; received.&quot;&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; fileMap &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;st&quot;&gt;'js'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'application/javascript; charset=utf-8'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;st&quot;&gt;'html'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'text/html'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;st&quot;&gt;'png'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'image/png'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;st&quot;&gt;'jpg'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'image/jpeg'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;st&quot;&gt;'gif'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'image/gif'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;st&quot;&gt;'ico'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'image/*'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;st&quot;&gt;'appcache'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'text/cache-manifest'&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;fs&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;readFile&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;pathname&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; (err&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; data) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;va&quot;&gt;request&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;headers&lt;/span&gt;[&lt;span class=&quot;st&quot;&gt;'if-none-match'&lt;/span&gt;] &lt;span class=&quot;op&quot;&gt;===&lt;/span&gt; tag) &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;response&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;writeHead&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;304&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;'Content-Type'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; fileMap[&lt;span class=&quot;va&quot;&gt;pathname&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;split&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'.'&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;'Expires'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Date&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;Date&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;now&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;30000&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;'Cache-Control'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'max-age=10, public'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;'ETag'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; tag&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;'Last-Modified'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Date&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;Date&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;now&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;30000&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;'Vary'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'User-Agent'&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
       &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;cf&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;             
            &lt;span class=&quot;va&quot;&gt;response&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;writeHead&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;200&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;'Content-Type'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; fileMap[&lt;span class=&quot;va&quot;&gt;pathname&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;split&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'.'&lt;/span&gt;)[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;'Cache-Control'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'max-age=10, public'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;'Expires'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Date&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;Date&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;now&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;30000&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;'ETag'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; tag&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;'Last-Modified'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;Date&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;Date&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;now&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;30000&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;'Vary'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'User-Agent'&lt;/span&gt;
            &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;va&quot;&gt;response&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;write&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;fs&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;readFileSync&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;pathname&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)))&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;        
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;response&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;end&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;   
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;).&lt;span class=&quot;at&quot;&gt;listen&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;8081&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码。如果你没使用过node，拷贝下代码存为file.js，安装node，命令行输入&lt;code&gt;node file.js&lt;/code&gt;，可以在同目录下建立index.html文件，在html文件中引用一些图片，CSS等文件，浏览器输入&lt;code&gt;localhost:8081/index.html&lt;/code&gt;进行模拟。🤓&lt;/p&gt;
&lt;h3 id=&quot;关于缓存的一些问答&quot;&gt;🦆关于缓存的一些问答&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 问题：请求被缓存，导致新代码未生效&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;解决方案:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;服务端响应添加&lt;code&gt;Cache-Control:no-cache,must-revalidate&lt;/code&gt;指令；&lt;/li&gt;
&lt;li&gt;修改请求头&lt;code&gt;If-modified-since:0&lt;/code&gt;或&lt;code&gt;If-none-match&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;修改请求URL，请求URL后加随机数，随机数可以是时间戳，哈希值，比如：&lt;a href=&quot;http://damonare.cn/?a=1234&quot; class=&quot;uri&quot;&gt;http://damonare.cn?a=1234&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2. 问题：服务端缓存导致本地代码未更新&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;合理设置Cache-Control:s-maxage指令；&lt;/li&gt;
&lt;li&gt;设置Cache-Control:private指令，防止代理服务器缓存资源；&lt;/li&gt;
&lt;li&gt;CDN缓存可以使用管理员设置的缓存刷新接口进行刷新；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3. 问题： Cache-Control: max-age=0 和 no-cache有什么不同&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;回答：&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;max-age=0&lt;/code&gt;和&lt;code&gt;no-cache&lt;/code&gt;应该是从语气上不同。&lt;code&gt;max-age=0&lt;/code&gt;是告诉客户端资源的缓存到期&lt;strong&gt;应该&lt;/strong&gt;向服务器验证缓存的有效性。而&lt;code&gt;no-cache&lt;/code&gt;则告诉客户端使用缓存前&lt;strong&gt;必须&lt;/strong&gt;向服务器验证缓存的有效性。&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;参考文档：&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 27 Jan 2018 14:02:00 +0000</pubDate>
<dc:creator>秦至</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jztan/p/8367384.html</dc:identifier>
</item>
<item>
<title>关于首屏时间采集自动化的解决方案 - royalrover</title>
<link>http://www.cnblogs.com/accordion/p/8366692.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/accordion/p/8366692.html</guid>
<description>&lt;h2 id=&quot;关于首屏&quot;&gt;关于首屏&lt;/h2&gt;
&lt;p&gt;首屏时间是指从转向该页面到屏幕中该页面所有内容都可见时的时间。已经有太多的关于首屏时间的计算，在本文中并不重复阐述这些已经被提出或者实现的方案，而旨在探索与讨论更多的首屏自动化采集方案，扩大思考范围，你我思想之间互相碰撞往往可以激起更多的稀奇古怪的解决方案，这也正是我写这篇文章的目的。&lt;/p&gt;
&lt;p&gt;通过浏览器调试工具，我们可以清晰的看出页面资源加载时序图：&lt;/p&gt;
&lt;p&gt;先是html页面加载，token进行词法、语法解析后开始加载静态资源并执行相关脚本，开始构建DOM树、render树和CSSOM数，最后加载图片，用户看到完整的网页。&lt;/p&gt;
&lt;p&gt;虽然浏览器有着各自的优化的解决方案，但是大多数情况下图片往往是最后加载完毕，这不仅仅是由于图片的大小相对较大，而且图片的加载与否与DOM结构有着很大的关系。DOM是否构建完毕，render树中是否渲染以及其他的图片加载策略有关系可能都会影响图片加载时序。因此在首屏时间的计算中，我们是以最终首屏图片的加载时间为节点计算的。&lt;/p&gt;
&lt;h2 id=&quot;首屏计算&quot;&gt;首屏计算&lt;/h2&gt;
&lt;h3 id=&quot;原则1-首屏计算模块不应该耦合业务线&quot;&gt;原则1 首屏计算模块不应该耦合业务线&lt;/h3&gt;
&lt;p&gt;一般而言，首屏计算作为一个抽离出的js脚本单独引用，这个模块尽量不暴露API给开发者使用，所有的采集端任务都由该模块完成。这句话可能听起来像一句废话，但还是有很多情况可能需要业务人员来进行首屏渲染时间的判断的，下面将针对这个情形举一个实际的场景：&lt;/p&gt;
&lt;p&gt;随着MVVM模式的兴起，前端异步渲染逐渐流行起来，前端编码逐渐由面向jQuery编程转向为面向Vue编程。可是使用Vue编写的业务代码在本地打包后仅仅是一个bundle，此时的HTML文件中只是一个&lt;/p&gt;

的占位符而已，那么首屏时间计算模块该如何准确的计算首屏时间呢？&lt;strong&gt;因此首屏时间计算模块必须知道首屏的DOM结构渲染完毕的时间节点，在这个节点时刻进行计算首屏范围内的图片加载时间。&lt;/strong&gt; 可是如何获取首屏DOM结构渲染完毕的时间节点呢？这就需要业务开发人员制定。在更新vue实例的data属性后，通知首屏计算模块此时DOM接口已渲染完毕，开始计算首屏时间。
&lt;p&gt;MVVM开发模式下，首屏时间的计算已经耦合了业务代码，虽然可以在保证首屏时间的准确性，但却给开发者带来了一些可观判断逻辑，而这些判断往往会困扰新入职的同志们，因此我们的目标之一就是解决需要手动打点进行首屏时间计算的现状。&lt;/p&gt;
&lt;h3 id=&quot;原则2-性能与准确性的权衡&quot;&gt;原则2 性能与准确性的权衡&lt;/h3&gt;
&lt;p&gt;业界有个通过canvas截屏并通过轮询对比不同时间点截屏图片之间某几个随机像素点，从而判断首屏是否加载完毕。这种方式虽然科学，但是估计没有几个公司会采用这种方案。通过canvas截屏这个操作对硬件的要求可能就比较高，而且需要进行额外的像素运算，因此性能肯定很差。其实这种场景在工程领域经常出现，工程不同于科学那般严谨，我们只需要找到给定条件的最优解即可，做工程也就是在做trade off。因此这种对比方案我们也必须摒弃。&lt;/p&gt;
&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;再次强调，由开发者打点首屏DOM渲染完毕进行首屏时间计算的方式是相对准确的方式，因此我们后续讨论的自动化计算首屏时间的准确性都是基于此标准进行对比说明，因为自动化计算肯定是没有人工干预准确的，这一点毫无疑问。&lt;/p&gt;
&lt;h3 id=&quot;轮训采集大法&quot;&gt;轮训采集大法&lt;/h3&gt;
&lt;p&gt;仍然是轮训，不同的是在每次轮询中执行一些操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取首屏的所有图片（包括IMG标签与css相关属性）&lt;/li&gt;
&lt;li&gt;绑定首屏图片的onload和onerror事件，每次轮询不会重复绑定已绑定的图片&lt;/li&gt;
&lt;li&gt;相同图片不需重复绑定事件侦听，否则会与 2 中的每次轮询混淆&lt;/li&gt;
&lt;li&gt;图片的事件处理函数执行打点信息并统计图片加载状态，同时比对时间戳得到最迟加载的时间&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体的实现中，需要特别注意首屏出现的相同图片的情况。笔者起初在获取首屏图片中简单计算图片的url数组，存储重复图片的个数，并且与该图片的加载状态绑定在一起。如首屏中出现了3张相同的图片，那么在该图片onload或onerror中对已加载图片的数量做 &lt;strong&gt;加3&lt;/strong&gt; 处理，否则导致最终的 &lt;strong&gt;已加载图片总数 与 首屏图片总数 不相等的情况发生&lt;/strong&gt;。这种实现导致逻辑非常的差，且实现复杂。后通过存储图片所在的DOM对象数组实现更为简单的图片状态判断，更加已读。&lt;/p&gt;
&lt;p&gt;伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// totalCounter为轮询的总时间
// DemandCounter是规定的轮询总时间，为3000ms
// imgsLoadedCount则为首屏已加载的图片数量
// lastImageLoadedStamp为最后加载的图片时间戳
function checkFirstScreenDomReady(){
    if(totalCounter &amp;gt;= DemandCounter){
        // ...
        var stamps = Object.keys(pools),
        len = stamps.length,
        i = 0,
        it; 
        finalImgCount = pools[stamps[len - 1]].imgLen; 
        pollEnd = true;

        for(;i&amp;lt;len;i++){
            it = pools[stamps[i]];
            if(it.imgLen == finalImgCount &amp;amp;&amp;amp; it.imgsLoadedCount &amp;gt;= finalImgCount){
                self.onRecord = true;
                _perfQueue._firstScreenLoadEnd = lastImageLoadedStamp;
                firstScreen.firstScreenLoadEnd = lastImageLoadedStamp;
                firstScreen.duaring = lastImageLoadedStamp - performance.timing.navigationStart;
                
                reportData(firstScreen);
                return;
            }
        }
        return;
    }
    
    var imgEls = getImage();

    imgEls.forEach(function(el) {
        if(!imgLoadedHash.get(el)){
            var img = new Image();
            imgLoadedHash.put(el,{
                loaded: true,
            });
            img.onload = OnLoad;
            img.onerror = OnError;
            img.src = el.__src;
        }
    });
    pools[totalCounter+''] = {
        imgLen: imgEls.length,
        stamp: Date.now(),
        imgsLoadedCount: imgsLoadedCount
    };
    totalCounter += timeout;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;watch-dog采集&quot;&gt;watch dog采集&lt;/h2&gt;
&lt;p&gt;利用Mutation Observer API进行侦听 内容框的DOM事件，判断首屏DOM结构是否完备；如果构建完毕则侦听首屏范围内的图片加载事件，计算首屏时间。&lt;/p&gt;
&lt;p&gt;watch dog需要知晓合适首屏DOM构建完毕。这需要首屏计算模块主动插入一个打点标签&lt;/p&gt;

，将业务代码放置在标签内部（这个步骤最好放在发布阶段，由脚手架操作）。通过mutation 侦听 .j_collector_container 容器的DOM子孙节点变化。如在observe事件处理函数中，计算 .j_collector_container 高度，如果大于屏幕高度则意味着首屏的DOM结构已渲染完毕，开始计算首屏时间。
&lt;p&gt;在计算 .j_collector_container 高度时，最好采用限流策略，防止短时间内计算多次容器的布局信息，这也是无可奈何之举。&lt;/p&gt;
&lt;p&gt;此处的伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 记录首屏DOM元素的位置信息
var firstScreenDomReady = false;
var callback = function(records){
    if(firstScreenDomReady)
        return;

    // 此处需做throttle 处理
    for(var i=0,len=records.length;i&amp;lt;len;i++){
        // 判断首屏DOM渲染完毕的策略：
        // 判断collectWrapper元素高度是否大于首屏
        var cr = collectWrapper.getBoundingClientRect(),
        screenHeight = win.innerHeight;

        if(cr.top + cr.height &amp;gt;= screenHeight){
            firstScreenDomReady = true;
            recordFirstScreenLoad();
            return;
        }
    }
};
    
var mo = new MutationObserver(callback);

var option = {
    'childList': true,
    'subtree': true
};

var collectWrapper = document.querySelector('.j_collector_wrapper');
if(collectWrapper.getBoundingClientRect().height &amp;lt; win.innerHeight){
    mo.observe(collectWrapper, option);
}else{
    setTimeout(function(){
        recordFirstScreenLoad();
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;不管采用哪种方式，计算出来的首屏时间都不是准确的。而且在每种实现中都需要通过JS引擎与渲染引擎的bridge进行通信执行耗时的操作，如getBoundingClientRect和访问offsetTop属性导致relayout。不过这也是没有办法的办法，在浏览器不提供相关首屏API的前提下我们只有这么做。&lt;/p&gt;
&lt;p&gt;另外，对比这三种实现（开发者手动打点、轮训、watch dog采集），针对一个复杂的电商首屏做了性能测试，该页面首屏部分有7个非常复杂的子组件，得到如下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://si.geilicdn.com/hz_img_096600000161370109180a026860_558_994_unadjust.png&quot; alt=&quot;电商首页&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://si.geilicdn.com/hz_img_096700000161370109200a026860_1588_714_unadjust.png&quot; alt=&quot;采集结果&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://si.geilicdn.com/hz_img_125400000161370108ba0a02685e_1008_636_unadjust.png&quot; alt=&quot;采集结果柱状图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果也符合我们的预期。&lt;/p&gt;
</description>
<pubDate>Sat, 27 Jan 2018 09:49:00 +0000</pubDate>
<dc:creator>royalrover</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/accordion/p/8366692.html</dc:identifier>
</item>
<item>
<title>拥抱变化，渴望挑战 - 记我的 2017 - 韩子迟</title>
<link>http://www.cnblogs.com/zichi/p/summary-of-2017.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zichi/p/summary-of-2017.html</guid>
<description>&lt;p&gt;唯一永远不改变，是不停地改变。&lt;/p&gt;
&lt;p&gt;2017，改变了太多太多，也经历了太多太多的第一次，在人生的长河中终究会成为最重要的一年之一。&lt;/p&gt;
&lt;p&gt;翻翻 &lt;a href=&quot;http://www.cnblogs.com/zichi/p/6032582.html&quot;&gt;去年的年终总结&lt;/a&gt;，很惭愧，很多计划并没有实现，但是也做了很多未预料到的事情。&lt;/p&gt;

&lt;p&gt;2017 最重要的事情，无疑是从上海回到了杭州，为什么用回字呢？因为楼主作为浙江人，而且在杭州度过了大学的四年时光。毕业后为了当时的女朋友，义无反顾地跑去了上海，从而顺利错过了杭州房价最低谷，失之东隅收之桑榆，今年女朋友研究生毕业后，顺利扯了证，也在元旦前夕在杭州某一郊区顺利上岸买了房，也算是不坏的结果吧。&lt;/p&gt;
&lt;p&gt;17 年 3 月份离职后，开始在网上投简历，面试还算顺利，但是做了当时看起来最好实则是最坏的选择，入职两周后就离开了。后来机缘巧合，也算是运气不错，入职了目前的公司 SegmentFault。SegmentFault 的前端技术比较传统，用的是 Requirejs+jQuery+BootStrap+Gulp 的技术栈，当时入职时却是一个都没接触过，但是同事都非常 nice，很快便熟悉了手上的业务，并经过思考在新功能 &lt;a href=&quot;https://segmentfault.com/mp&quot;&gt;技术号&lt;/a&gt; 中引入了 Vue.js 进行开发。&lt;/p&gt;
&lt;p&gt;在 SegmentFault 工作是怎样一种体验？非常舒服，弹性工作，朝十晚六，除了钱少了点哈哈。因为人少，大家都很熟，不像在大公司，各种规章制度，各种审批，甚至还有小帮派，勾心斗角。但是因为公司小项目少，机会也非常有限，项目就一个主站，代码已经很熟悉，短时间内架构也无法改变，一颗渴望挑战的心也时常蠢蠢欲动，非常渴望在工作中能够开阔眼界，能了解并用到一些前沿的技术。&lt;/p&gt;
&lt;p&gt;6 月份，女朋友毕业后也来了杭州，她的专业是 7 年前最热门的专业，却不想现在已经物是人非，让人唏嘘，不禁让人感概选择比努力更重要。而且工作机会非常少，很难跳槽，工作后，拿着几千块的月薪，经常加班到凌晨一两点，大多数周末都在加班，她身体又不好，楼主也是很心疼，只能内心暗暗发誓早日努力强大自己。&lt;/p&gt;
&lt;p&gt;10 月份，领了证，日子也仿佛慢慢步入了正轨。&lt;/p&gt;

&lt;p&gt;17 年下半年的关键字无疑是「买房」。楼主从来不是个懂得规划人生的人，所以也自食其果。毕业后直到今年，从来没有想过结婚、买房，这些事仿佛和自己很遥远。在杭州的朋友应该都知道，G20 前后，杭州房价翻了一倍，而直到此时楼主才意识到，已经快在杭州买不起房了，当时虽然还在上海，但是已经计划着来年回杭州，作为浙江人其实还是有点杭州情节的，而且杭州的 IT 公司多，也不难就业。&lt;/p&gt;
&lt;p&gt;7 月份开始去看房，遭到了无数白眼，有幸见证了可能是杭州历史上最牛的卖方市场，截图留念。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/675542/201801/675542-20180127170629303-1142610915.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是更多的还是不甘心，相同的楼盘，朋友 100w 不到买的，不到一年，现在要 200w+ 了，而且很多楼盘还要关系，还要全款，更别提公积金贷款了，但是还是供不应求，趋之若鹜。&lt;/p&gt;
&lt;p&gt;微信公众号的关注也是从之前的技术类，变成了大批房产类的推文。某地又拍了地王，哪个盘又领出了预售证，每条新闻都时刻牵动着购房者的心。杭州的刚需房也从 100w，上升到 200w，直到今年的 300w，半年前还是这样的标题「200w 的刚需房还能买哪里？」，到现在已经变成「300w 的刚需房哪里找？看这里」，实在唏嘘。据说春晚的分会场还有杭州奥体，又可以吹一波了，毕竟是第一个要靠卖地晋升为一线的城市，最后苦的还是普通百姓。兴，百姓苦，亡，百姓苦。&lt;/p&gt;
&lt;p&gt;一切可能都是最好的安排吧，最终在元旦前也算是上车了，虽然这个总价如果放在一年前两年前，都能买到钱江世纪城、奥体的楼盘了，现在却是在一个鸟不拉屎的郊区，甚至连公交都很少经过，但是人生没有如果。&lt;/p&gt;
&lt;p&gt;买完房，接下去要考虑的就是努力工作还债了。这次买房的经历，也让我第一次真正意识到了「钱」的重要性。虽然不是生在大富大贵的家庭，但是之前的人生，感谢我的爸爸妈妈，让我从来没有为钱担忧过，找工作也是，钱从来不是我主要考虑的东西，但是这一次不一样，我认识到，有了钱，我可以有更好的选择，老婆也不用工作地那么辛苦，我爸也不用一把年纪还出去干活，我仿佛理解了「面向工资编程」，多么痛的领悟。&lt;/p&gt;

&lt;p&gt;对于目前的工作内容，我还是比较满意的。由于 SegmentFault 是个程序员垂直论坛，所以在前端兼容方面，只需要考虑流行的浏览器即可，再也特么的不用考虑 IE6 了。在技术选型方面也非常自由，只要实现需求，可以用任何你熟悉的技术，并没有太多的性能要求。&lt;/p&gt;
&lt;p&gt;在工作中，我也有了很多第一次体验。比如第一次在工作中用 CSS/BootStrap/jQuery，第一次用 Git 合作，第一次用 Docker 开发，第一次在线上体验 Vue.js，等等。&lt;/p&gt;
&lt;p&gt;翻了下 &lt;a href=&quot;http://www.cnblogs.com/zichi/p/6032582.html&quot;&gt;去年的计划&lt;/a&gt;，其实大多数也算勉强完成了。&lt;a href=&quot;https://github.com/hanzichi/leetcode&quot;&gt;Leetcode&lt;/a&gt; 勉强达标，切到了 350，2018 应该很少有时间继续了；ES6/Vue/CSS/BootStrap 也算是基本都入门了，唯一遗憾的是 PHP 的学习，基本为 0。&lt;/p&gt;
&lt;p&gt;2018 年，在工作和学习方面，还是有不少想法：&lt;/p&gt;
&lt;p&gt;其实给自己目标定的太多未免是好事，我对自己的要求其实不是很高，学有余力就多看看书吧，买的好多书，基本都没动过。&lt;/p&gt;

&lt;p&gt;最近一年，已经很少写博客了，非常佩服阮老师这样持续输出的技术人。我之前在 &lt;a href=&quot;https://ing.cnblogs.com/&quot;&gt;闪存&lt;/a&gt; 发过一条状态，大概意思是能持续写博客的人，要么就是闲的蛋疼，要么就是真特么的努力，很显然，之前的我是前者，而阮老师则是后者。&lt;/p&gt;
&lt;p&gt;不忘初心，写博客的初衷是什么？帮助别人？没那么高尚，一开始写博客就相当于记个笔记，以便自己日后查找方便，哪怕现在，我也是这么想。可以去 &lt;a href=&quot;http://www.cnblogs.com/zichi/&quot;&gt;首页&lt;/a&gt; 看看我今年记的很多笔记，当然如果能无意间帮助到别人，我也是非常开心的。&lt;/p&gt;
&lt;p&gt;看自己以前写的文章（或者说是做的笔记），很多时候会有删除的冲动，写的是什么狗屁玩意？但是有时又会收到读者表示感谢的留言，终究还是保留下来了，也算是我青春的印记吧。&lt;/p&gt;
&lt;p&gt;既然说到写作很多时候仅仅是作为笔记，其实不少笔记作为 cheatsheet 类的，都不好意思放到博客园，建了个 &lt;a href=&quot;https://github.com/hanzichi/cheat-sheet&quot;&gt;cheat-sheet&lt;/a&gt; 的 repo，为了方便查找，还给它写了个 workflow，用起来也是美滋滋的。&lt;/p&gt;
&lt;p&gt;以前的时候，写完博客，总喜欢看看有没有评论，点赞，粉丝数有没有增加， &lt;a href=&quot;https://github.com/hanzichi&quot;&gt;GitHub&lt;/a&gt; 有没有增加 followers，发到各种网站，头条，甚至还专门研究了下 &lt;a href=&quot;http://www.cnblogs.com/zichi/p/5115754.html&quot;&gt;几点发博客阅读数最多&lt;/a&gt; 。现在的我，再也没有这种心思，写完就发，哪怕今天是周六，哪怕没人看，又如何呢？我的初心只是记录给以后的自己看的。&lt;/p&gt;
&lt;p&gt;话说写这篇总结用了 3 个小时，写文章真的挺累的！毕竟我有强迫症，写完要自己读好几遍，尽量不出现不通顺的语句，不出现错别字。&lt;/p&gt;

&lt;p&gt;这一年，过的是既坎坷，也挺欣慰的。2018，还是得想着怎么提高自己，怎么能努力赚钱，毕竟，太缺钱了！&lt;/p&gt;
&lt;p&gt;最后，给大家拜个早年了！&lt;/p&gt;
</description>
<pubDate>Sat, 27 Jan 2018 09:16:00 +0000</pubDate>
<dc:creator>韩子迟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zichi/p/summary-of-2017.html</dc:identifier>
</item>
<item>
<title>ProtoBuf 与 gRPC - 行者酱油君</title>
<link>http://www.cnblogs.com/makor/p/protobuf-and-grpc.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/makor/p/protobuf-and-grpc.html</guid>
<description>&lt;p&gt;用 Protobuf 很久了，但是一直觉得很简单，所以就没有做一个总结，今天想尝试一下 gRPC，顺带就一起总结一下。ProtoBuf 是个老同志了，应该是 2010 的时候发布的，然后被广泛使用，目前在市面上应该和 Facebook 的 thrift 应该是不相上下，无论是性能上，还是用户的支持度上。&lt;/p&gt;
&lt;h3 id=&quot;toc_0&quot;&gt;What's ProtoBuf&lt;/h3&gt;
&lt;p&gt;ProtoBuf 是一种数据表达方式，根据 G 家自己的描述，应该叫做&lt;strong&gt;数据交换格式&lt;/strong&gt;，注意这里使用的是 &lt;strong&gt;交换&lt;/strong&gt; 字眼，也就是说着重于在数据的传输上，有别于 TOML 和 XML 较常用于配置（当然 WebService 一套也是用于数据交换）。&lt;/p&gt;
&lt;p&gt;在使用 ProtoBuf 之后，很多时候，我都希望能够用它来替换 json 和 XML，因为相比较于这些工具，ProtoBuf 的优势比较明显。例如 json 虽然表达方便，语法清晰，但是，有一个硬伤就是没有 schema，对于 Client-Server 的应用/服务来说，这就意味着双方需要使用其他方式进行沟通 schema，否则将无法正确的交流；相比之下，XML 确实提供了强大的 Schema 支持，但是，可能因为年纪更大的缘故，XML 自身的语法啰嗦，更别说定义它的 Schema 了，一句话概括，那就是非常得不现代。&lt;/p&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;ProtoBuf 结构&lt;/h3&gt;
&lt;p&gt;ProtoBuf 目前有两个版本，分别是 proto2 和 proto3，虽然 proto3 看上去比 proto2 新，但是，在一些处理上其实被很多人所诟病，例如默认值和未定义的字段的处理上，proto3 不如 proto2；但是 proto3 确实也修正了 proto2 的很多问题和做了精简，所以这里我就直接上 proto3 了，不会差别很大，所以喜欢 proto2 的同学也不用纠结。&lt;/p&gt;
&lt;p&gt;proto 的语法有点类似于定义一个类或者说结构体更合适一些，因为它没有方法，只有属性，一个简单的示例为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201801/469840-20180127163538131-1793569818.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第 1 行肯定是需要的，表面一下你用的是哪个版本，这里指明我的语法是 &quot;proto3&quot; 版本的&lt;/li&gt;
&lt;li&gt;第 3 行这里就可以理解成定义了一个结构体，名字叫做：&lt;strong&gt;SearchRequest&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;第 4 - 6 行就是定义了结构体的属性了，&lt;strong&gt;类型 + 名字&lt;/strong&gt;，这里后面的 &quot;=1/2/3&quot; 这个先不用关注，保证它不一样就好了&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样我们就定义了一个简单的 ProtoBuf，也就是这么简单，然后我们应该尝试一下如何用程序语言来使用这个结构。我这里使用的编程语言是 Go 语言，但是其实用什么语言都不是问题，因为步骤基本一致。&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;程序操作 ProtoBuf&lt;/h3&gt;
&lt;p&gt;不同于 json 可以直接被读取解析，ProtoBuf 因为一些元数据，所以在使用之前，我们需要通过工具生成 Model 类，然后再使用，工具安装可以参考官方的文档进行安装，安装完成之后我们直接使用命令生成即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ protoc --go_out=. --python_out=. search.proto
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里从参数中可以看到，我生成了两种语言的 Model，分别是 Python 和 Go 的，类似的，如果你需要其他语言的 Model，可以将语言名字替换试试。&lt;/p&gt;
&lt;p&gt;命令完成之后，我们可以在当前目录看到一些文件了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201801/469840-20180127163538115-422789487.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;然后我们就可以操作使用代码进行操作了，下面继续：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201801/469840-20180127163538506-2122846743.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;我这里就通过这个 Model 新建一个对象，然后将它序列化（Line 7），序列化之后看一下序列化结果的类型，然后再反序列化（Line 15）回来，然后再看看反序列化之后结果是否正常（Line 20 - 22）。如果你的代码写得没问题的话，那么对应的结果应该也是一样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201801/469840-20180127163538147-1247554975.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;ProtoBuf 节省字节&lt;/h3&gt;
&lt;p&gt;从上边的 Demo 里边你可能看不出 ProtoBuf 有什么特别好的优势，除了有 Schema 之外，但是，如果你看一下序列化之后的 data 的大小之后，你会发现它才 22 个 uint8，以为这什么，也就是说刚才的数据结构才占用 22 个字节，如果你用 json 和 XML 的话是多少？就拿 json 来说，key 和 value 两部分，value 的大小就算和 ProtoBuf 的 value 一样，那应该要 20 个字节，加上 key 超过 20 个字节，算下来至少的 40 个字节，可以认为这里至少省下了一半的空间。你会说这点小钱看不上，但是，你觉得在企业服务中，数据就这么几个？在大数据的场景下，每天的数据量随随便便几百个 G 甚至几十 T；在网络中，节省一半流量代价的下降将至少减少 2 倍以上，内存同理。&lt;/p&gt;
&lt;p&gt;既然 ProtoBuf 能这么省字节，那么它是怎么做到的？不知道你还记得不，前面在定义 Message 的时候我让你先忽略掉的数字：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201801/469840-20180127163538131-1793569818.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这个数字可是有大用处的，这里我们是写着连续的，但是事实上他们可以是不连续的，那么它们的用处是啥？根据&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/encoding&quot;&gt;官方文档&lt;/a&gt;的介绍，在序列化 ProtoBuf 的时候，它们也是以 Key-Value 的形式压缩的，但是，它们的 key 不是这里面的字面量，而是后面的数值，也就是说对于 &quot;query&quot; 这个字段，我们保存的不是 &quot;query&quot; 的字符串，而是 1 这个数字，这样就将我们的压缩量降低了一大截。&lt;/p&gt;
&lt;p&gt;除此之外，对于 value 的处理也是有特别处理的，这里有点类似于 UTF 的处理方式，存在一种称为 varint 的类型，如果是 0-127 的数字，那么我们可以直接用 1 个字节（最多用了 7 位）表示，如果不够用了，要表示 128，那么分为两个字节，不同之处在于，低位的字节要取反码保存，就拿 128 来说吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201801/469840-20180127163538115-597330501.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;这里有意思的地方在于 2 和 3 行，在第 2 行，我们可以看到是对低位的字节取反码，然后在第 3 行，是将高低位转化，最终成为了第 4 行中的表示。这里我有个疑惑就是，为啥要这么操作，文档中的说明是这样可以从左到右搜索字节，如果第一位为 1 则表示这个字节后面还有字节，那么如果我对高位进行取反的话也能得到同样的效果啊。&lt;/p&gt;
&lt;p&gt;我认为，这里除了最高位是 1 表示还存在后续字节之外，将高低字节调转在解析的时候会方便不少，因为我们可以看到，字节流从左到右进行解析，最先解析的字节应该是最低位的，也就是说如果我们算 128 的话，最先解析的结果是 127 ，然后是 1，加起来就是 128 了。当然，这对于在程序语言中单类型可以表示完全的好像没什么优势，但是如果并不能表示完全的就有意义了，例如让一种不支持 64 位长整数的程序语言处理 uint64 的数值。&lt;/p&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;gRPC&lt;/h3&gt;
&lt;p&gt;ProtoBuf 除了经常被用于数据保存交换之外，还被用于定义 gRPC 服务，gRPC 也是 G 家公开的高性能 RPC 调用框架，号称高效，支持广（题外话，似乎度娘也开源了一款不错的 RPC 框架）。&lt;/p&gt;
&lt;p&gt;使用 gRPC 的步骤其实还是很简单的，因为我们只需要做简单几步，就将整体的代码结构创建好了，剩下的工作都是填业务了。无论怎样，第一步肯定还是先明确一下接口的详情：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201801/469840-20180127163539022-1111951947.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;要定义一个接口，除了定义函数原型之外，还需要定义参数和返回值，gRPC 也一样，这里定义接口的形式和 Go 语言有点类似，语法为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rpc 函数名 (参数) returns (返回值) {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数 和 返回值 都是我们在前面已经很熟悉的 Message 定义。有了这些定义之后，我们可以很简单得通过刚才的方式生成框架代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ protoc proto/service.proto --go_out=plugins=grpc:service
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;随后我们就可以在 service 目录下发现生成的 Go 语言代码，然后我们看到文件：&lt;code&gt;service/proto/service.pb.go&lt;/code&gt;，会发现已经生成了我们的函数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201801/469840-20180127163539022-2139642019.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;重新根据我们自己的逻辑编辑它即可，但是这仅仅只是一个实现，并不能直接对外提供服务，所以我们还需要编写一段服务器的代码，用来驱动这个 service：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/469840/201801/469840-20180127163538678-2046767238.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;然后运行看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ go run main.go
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是如何搭配 ProtoBuf 和 gRPC 的一个方式。&lt;/p&gt;
&lt;h3 id=&quot;toc_5&quot;&gt;Reference&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/golang/protobuf&quot;&gt;Golang Protobuf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/overview&quot;&gt;ProtoBuf Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://grpc.io/docs/&quot;&gt;gRPC Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 27 Jan 2018 08:36:00 +0000</pubDate>
<dc:creator>行者酱油君</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/makor/p/protobuf-and-grpc.html</dc:identifier>
</item>
<item>
<title>今天不聊技术，聊聊工作中的做事方法 - 喝着啤酒写bug</title>
<link>http://www.cnblogs.com/cq-jiang/p/8365704.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cq-jiang/p/8365704.html</guid>
<description>&lt;p&gt;　　最近因为某些原因，小明在医院玩了几天，遇到几件记忆深刻的事，这些事都是我们在工作中可能会遇到的，这些事和技术没有任何关系，我们平时工作中遇到问题，如何正确解决问题有很大的关系，所以在此分享给大家。&lt;/p&gt;
&lt;p&gt;　　一：孕妇家属和主治医生的攻坚战&lt;/p&gt;
&lt;p&gt;　　某日凌晨1点左右，小明刚刚在病房刚刚睡着，外面突然传来很大的吵闹声，刚睡下整层楼病房的人都被吵醒，原来是医院来了一位快要分娩的孕妇，由于这个孕妇分娩现像特别明显，家属的意思是直接进入待产流程，值班医生认为，他没有这个孕妇的任何信息，需要孕妇去做常规检查，家属急了，认为孕妇马上生了，你还让她做检查，完全不合理，然后双方由意见不一致，从争执到敞开嗓子大吵的过程（主要是家属比较激动，声音较大），以小明的脾气，如果写java程序的笔记本在身边，说不定他会把笔记本撕成两半，给这两个二货每人一半扔过去，提醒他们现在是凌晨，并且在医院，注意大家的休息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1128579/201801/1128579-20180127124055100-1077838798.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其实冷静下来想一想，双方都没有错,家属担心孕妇，不愿意再花时间做检查，医生没有孕妇任何信息，肯定不敢轻易的做诊断，但这两个家伙不顾整层楼其它人的心情，不断的争吵，如果可以，绝对给医院差评，其实我们工作中也会遇到类似的事，几年前，小明团队做短信售后，整个部门在中午休息时，某几个销售都会不断的往技术部打电话，问短信延时方面的问题，如果电话接慢了，或者未接到电话，这群家伙就会和孕妇家属一样，不顾整个技术部同事的感受，直接到这边来，敞开嗓子问，为什么测试短信还收不到？我们顾及整个部门同事的感受，顾及销售的情绪，所以选择一个择中的方法，避免和销售面对面接触(如果和销售面对面，他们可不管你的态度好或差，他们表现都一样的刚烈，所以避免和他们面对面的pk)，加强测试短信通道的管理，如还是收不到，给出一个让销售信服的理由，销售不闹了，技术团队能够正常午休。&lt;/p&gt;
&lt;p&gt;　　如果这个时候，团队成员一根筋， 不顾团队和销售的情绪，认为这是午休，不是上班时间，对问题置之不理，或者不用正确的办法，估计销售和团队成品会上演一场真人pk.&lt;/p&gt;
&lt;p&gt;二：护士长和护士处理问题的思维&lt;/p&gt;
&lt;p&gt;　　小明终于等到和医院说bye,小明去医院办手续，护士长不在，美丽的护士笑呵呵接待，问小明，身份证，户口薄带了吗，小明说带了，护士说，护士长在门诊楼，一会过来，小明本来还有事需要办，没办法只好等了近20分钟，护士长来了，当护士长检查小明准备的资料时发现，只有身份证，户口薄还不够，还需要其它资料，好吧，资料没准备齐，小明没有生气的意思，他决定回去重新准备，本来事情至此结束，没有什么特别之处，此时护士长对护士说了以下一段话：你刚才没有检查小明准备的资料吗，资料没准备齐，你为什么还让他等这么久，这不是浪费别人时间吗？小明其实没有怪谁，护士也一脸无辜。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1128579/201801/1128579-20180127144124412-1640594003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　表面上这是一件很小的事，本来资料没准备齐就是自己的事，换位思考一下，本来小明还有其它事要做，如果小明脾气差，护士长说的话，从小明口中说出，事态会怎样？透过现像看本质，我们可以看到，护士长这段话有安抚小明的意思，就算小明心中有火，一个大男人也不好意思发火，此时我们虚构一个场景，销售到技术部门来提货，提货需要boss签字，boss外出办事，销售给boss电话，知道boss在办事回来的路上，所以销售就在部门等，当boss回来看到销售的提货单，发现货不够，此时销售就发飙，没有货为什么让他等？瞬间办公室成了这两个家伙的战场，如果销售在电话，或者用邮件告诉技术主管，需要多少件货，或者boss主动咨询一下，销售提货的数量及型号，发现货不够时，这场”战争“完全可以避免，虽然此处是虚构，但工作中不排除会遇到，我想说：可惜没有如果。在工作中，不管去办事，或者接洽其它部门同事，做事多细心一点，你做好了，肯定在同事，boss眼中另眼相看，表现好了，下一个涨工资的绝对有你。&lt;/p&gt;
&lt;p&gt;三：遇到问题不要慌，找到正确的处理方法&lt;/p&gt;
&lt;p&gt;　　从医院出来后，小明第一时间去公司交医疗报销资料，到公司发现，差一个资料，之前问过报销需要哪些资料，最后还是少准备了费用个人接算表，然后去找医生，医生原话的意思是，他从来没有听说过有这种表，他问了几个身边的护士，也是同样的答案，现在尴尬了，公司的意思是，没有这个表就报销不了，医生说从来没听说过有这个表.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1128579/201801/1128579-20180127153600240-1118495781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       对于生活在社会底层的人来说，这笔报销可以顶几个月的工资了，此事到目前，好像进入了一个死胡同，此时需要换一种方法来走出这个胡同，通过不断的交流，最终到医院结算中心处理这个事情，其实在工作中，也会遇到类似的事情，比如说：小明以前做短信技术支持的时候，第三方企业的技术，或者销售经常要求我们做到，&lt;span&gt;&lt;strong&gt;短信验证码短信，必须一分钟内收到&lt;/strong&gt;&lt;/span&gt;，好像这也是硬性需求，没有什么好说的，但问题是，公司的短信系统，由于某些原因，只能保存大部分情况下，能及时收到，有些时候是无法及时收到的，验证码短信的重要性可相而知，如果这个时候还用原来的短信发送流程，肯定行不通的。但问题也不是没有解决的办法，比如把验证码短信独立出来，单独找通道发送，或者接入更好的网关通道，当然和第三方技术支持人员的沟通也很重要。&lt;/p&gt;
&lt;p&gt;　　今天写了这么多和技术无关的话，只是因为最近遇到一些记忆比较深刻的事，这些事在工作中我们也会遇到类似的情况，当工作中我们遇到&quot;&lt;strong&gt;&lt;span&gt;奇葩&lt;/span&gt;&lt;/strong&gt;“问题时，希望大家能多想一下，或许换一种方法，事情会有一个更好的结果。　&lt;/p&gt;
</description>
<pubDate>Sat, 27 Jan 2018 08:05:00 +0000</pubDate>
<dc:creator>喝着啤酒写bug</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cq-jiang/p/8365704.html</dc:identifier>
</item>
<item>
<title>Struts2与Ajax数据交互 - 蚊蚊蚊蚊蚊170624</title>
<link>http://www.cnblogs.com/eleven258/p/8361536.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eleven258/p/8361536.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;写在前面：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;ajax请求在项目中常常使用,今天就平时掌握的总结一下，关于使用ajax请求到Struts2中的action时，前台页面与后台action之间的数据传递交互问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里我主要记录下自己所掌握的几种方式。可以根据自己平时项目的需求来进行选择。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   &lt;span&gt;&lt;strong&gt;1.使用stream类型的result&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　此种类型可以直接让Struts2中的action向客户端浏览器生成文本响应。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　jsp页面：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ taglib prefix&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; uri&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/struts-tags&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html;charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ajax提交登录信息&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;导入js插件&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;${PageContext.request.contextPath}/demo/js/jquery-1.4.4.min.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;异步登录&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;s:form &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;loginForm&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;POST&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;s:textfield &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;s:textfield &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;psw&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;loginBtn&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;提交&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;s:form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;show&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;display:none;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#loginBtn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){

        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).hide();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送请求login 以各表单里歌空间作为请求参数&lt;/span&gt;
&lt;span&gt;        $.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,$(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#loginForm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).serializeArray(),
            &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(&lt;span&gt;data&lt;/span&gt;,statusText){

                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).height(&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;)
                    .width(&lt;/span&gt;&lt;span&gt;240&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1px solid black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border-radius&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;15px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;backgroud-color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#efef99&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ff0000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;padding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .empty();
                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;登录结果:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).show(&lt;/span&gt;&lt;span&gt;600&lt;/span&gt;&lt;span&gt;);

        },&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);//指定服务器响应为html
    });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;处理逻辑的action:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Description:eleven.action
 * Author: Eleven
 * Date: 2018/1/26 18:09
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LoginAction &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ActionSupport{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String psw;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出结果的二进制流&lt;/span&gt;
    &lt;span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; InputStream inputStream;

&lt;/span&gt;&lt;/span&gt;&lt;span&gt;    public&lt;/span&gt; String login() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(username.equals(&quot;tom&quot;)&amp;amp;&amp;amp; psw.equals(&quot;123&quot;&lt;span&gt;)){
            inputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ByteArrayInputStream(&quot;恭喜您，登录成功&quot;.getBytes(&quot;UTF-8&quot;&lt;span&gt;));
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            inputStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ByteArrayInputStream(&quot;对不起，登录失败&quot;.getBytes(&quot;UTF-8&quot;&lt;span&gt;));
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供get方法&lt;/span&gt;
   &lt;span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; InputStream getInputStream() {

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inputStream;
    }

&lt;/span&gt;&lt;/span&gt;&lt;span&gt;    public&lt;/span&gt;&lt;span&gt; String getUsername() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPsw() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; psw;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPsw(String psw) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.psw =&lt;span&gt; psw;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;action中除了接收页面传递的用户名、密码外，还有一个InputStream类型的成员变量，并为它提供了对应的get方法。get方法中返回的二进制流将会直接输出给客户端浏览器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　struts.xml配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE struts PUBLIC
    &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;
    &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;struts&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constant &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;struts.enable.DynamicMethodInvocation&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constant &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;struts.devMode&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;default&quot;&lt;/span&gt;&lt;span&gt; namespace&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; extends&lt;/span&gt;&lt;span&gt;=&quot;struts-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;eleven.action.LoginAction&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;stream&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;指定stream流生成响应的数据类型&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;contentType&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;text/html&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;指定action中由哪个方法去输出InputStream类型的变量&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;inputName&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;inputStream&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;struts&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　在浏览器中浏览该页面，并输入相关信息，然后提交，可以看到后台action直接将消息数据返回给页面，而同时页面也不需要进行刷新，而是直接在局部进行显示，这是利用了ajax的异步发送请求。注意，此种方式需要在struts.xml文件中要配置类型为stream的流，并设置inputName属性，并在action中提供InputStream对应的get方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　运行截图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1188460/201801/1188460-20180127094301647-1500533537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;2.使用json类型的result&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;有个jar包struts2-json-plugin-2.3.16.3.jar，可以为Struts2增加JSON插件，即当action中的result的类型设为json时，也可以在客户端js中异步调用action,并且action中返回的数据，可以直接被JSON插件序列化成json格式的字符串，并将该字符串返回给客户端浏览器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　示例:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　jsp页面：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ taglib prefix&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; uri&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/struts-tags&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;@ page contentType&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html;charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; language&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ajax提交登录信息&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;%&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;导入js插件&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;${PageContext.request.contextPath}/demo/js/jquery-1.4.4.min.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;异步登录&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h3&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;s:form &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;loginForm&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;POST&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;s:textfield &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;s:textfield &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;psw&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;loginBtn&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;提交&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;s:form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;show&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;display:none;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;

    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#loginBtn&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).click(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){

        $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).hide();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送请求login 以各表单里歌空间作为请求参数&lt;/span&gt;
&lt;span&gt;        $.get(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,$(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#loginForm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).serializeArray(),
            &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data,statusText){
                &lt;/span&gt;&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时的data中包含username,psw,age&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).height(&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;)
                    .width(&lt;/span&gt;&lt;span&gt;300&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1px solid black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;border-radius&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;15px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;backgroud-color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#efef99&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#ff0000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .css(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;padding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;20px&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    .empty();
               &lt;/span&gt;
&lt;span&gt;                alert(data);
                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).append(data&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).show(&lt;/span&gt;&lt;span&gt;600&lt;/span&gt;&lt;span&gt;);

        },&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    });
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;action代码:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LoginAction &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ActionSupport{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String username;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String psw;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String login() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
        age &lt;/span&gt;= 18&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; SUCCESS;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getUsername() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setUsername(String username) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.username =&lt;span&gt; username;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPsw() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; psw;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPsw(String psw) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.psw =&lt;span&gt; psw;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　struts.xml中配置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE struts PUBLIC
    &quot;-//Apache Software Foundation//DTD Struts Configuration 2.3//EN&quot;
    &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;struts&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constant &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;struts.enable.DynamicMethodInvocation&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;constant &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;struts.devMode&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;default&quot;&lt;/span&gt;&lt;span&gt; namespace&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt; extends&lt;/span&gt;&lt;span&gt;=&quot;struts-default,&lt;span&gt;json-default&lt;/span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;action &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;eleven.action.LoginAction&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;login&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;json&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;noCache&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;contentType&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;text/html&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;struts&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;在浏览器中浏览该页面，并输入相关信息，然后提交，可以看到后台action直接将消息数据返回给页面，而同时页面也不需要进行刷新，而是直接在局部进行显示，这是利用了ajax的异步发送请求。注意，此种方式需要在struts.xml文件中要配置package继承json-default,且配置result类型为json，并在action中提供需要传递数据的对应的get方法。当然了前提是添加了struts2-json-plugin-2.3.16.3.jar，不然struts2是不会自动将数据转为json格式的数据的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　效果截图:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1188460/201801/1188460-20180127102523506-1696228024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　故我们可以总结一下result类型为json的步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;strong&gt;1.导入jar包：struts2-json-plugin-2.3.7.jar&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　　2.配置struts返回的结果集视图 设置type=json&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　　3.设置对应action所在的package继承自json-default&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　　4.将要返回的数据提供get方法&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;　　　　5.在struts.xml中设置返回数据的格式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于第5步设置返回数据的格式,可以根据自己项目的需要，去具体设置，这里只是简单举例，并没有拿复杂的数据，如果是返回一个List集合，那么对于数据的格式可以进行如下设置：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;test&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;json&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 设置数据的来源从某个数据得到 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
       　&amp;lt;!-- 过滤数据从gtmList集合中得到，且只获取集合中对象的name，跟uuid属性 --&amp;gt;　&lt;span&gt;&lt;br/&gt;　　　　　&amp;lt;param name=&quot;root&quot;&amp;gt;gtmList&amp;lt;/param&amp;gt;
        &amp;lt;param name=&quot;includeProperties&quot;&amp;gt;
              \[\d+\]\.name,
              \[\d+\]\.uuid
        &amp;lt;/param&amp;gt; &lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　上面这种方式外，还有下面这种方式&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;result &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;ajaxGetBySm&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;json&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            
          &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 一般使用这种方式 先用来源过滤action默认从整个action中获取所有的（前提是此action中没有getAction()方法）
                但是为了方便  一般不写root:action这个
                然后再用包含设置进行过滤设置
          &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;                
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;action&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
          &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;includeProperties&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
                 gtmList\[\d+\]\.name,
                 gtmList\[\d+\]\.uuid
          &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;result&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;上面两种方式都是设置数据从gtmList集合中获取且，只获取对象的属性为name与uuid的。这里只做简单的举例，具体可自己下去深入研究。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　附上json类型的Result允许指定的常用参数:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/1188460/201801/1188460-20180127152335365-232845018.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　另外，除了以上两种是struts2支持的ajax外，其实如果单纯的只是可以让服务器端可以跟客户端浏览器进行数据交互，可以使用response.getWrite()这种方式。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
PrintWriter printWriter =&lt;span&gt;response.getWriter();
printWriter.print(&lt;/span&gt;&quot;success&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;选择哪种方式?&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于我，如果只是对增删改功能是否成功的一个flag判断的数据，则可优先选择response.getWriter().print(&quot;xxx&quot;)与设置result类型为stream的方式，但是如果是需要返回大量对象数据，在页面接收然后进行数据展示，例如页面通过ajax请求，需要后台action返回一个list集合，则就要选择配置result类型为json的方式了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 27 Jan 2018 07:31:00 +0000</pubDate>
<dc:creator>蚊蚊蚊蚊蚊170624</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eleven258/p/8361536.html</dc:identifier>
</item>
<item>
<title>粗略的物体碰撞预测及检测 - DHUtoBUAA</title>
<link>http://www.cnblogs.com/DHUtoBUAA/p/8366062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DHUtoBUAA/p/8366062.html</guid>
<description>&lt;p&gt;  该博客实时更新于&lt;a href=&quot;https://github.com/wylloong/TinyPrograms/blob/master/TechBlog/%E7%B2%97%E7%95%A5%E7%9A%84%E7%89%A9%E4%BD%93%E7%A2%B0%E6%92%9E%E9%A2%84%E6%B5%8B%E5%8F%8A%E6%A3%80%E6%B5%8B.md&quot;&gt;我的Github&lt;/a&gt;。&lt;br/&gt;  在机器人局部路径规划中，需要实时躲避运动或者静态的障碍物，这个过程涉及到碰撞检测这个问题，本文主要讨论这个问题。&lt;br/&gt;  碰撞检测问题也是游戏开发中经常遇到的问题，一个游戏场景中可能存在很多物体，它们之间大多属于较远位置或者相对无关的状态，那么一个物体的碰撞运算没必要遍历这些物体，我们可以使用一个包围一个或多个物体的多边形来讨论碰撞问题，这样子可以节省重要的计算量和时间。&lt;br/&gt;  在真实的物理系统中，一般需要在运算速度和精确性上做取舍。尽管非常精确的碰撞检测算法可以精确地表示和解决碰撞问题，但是在路径规划初期对碰撞只需要有一个初步的估计，比如是否会发生碰撞，碰撞的大概程度如何，以免把大量的精力浪费在碰撞检测问题上，从而降低了在其他方面的注意力。本文主要利用游戏中用到的碰撞检测方法，来解决碰撞检测的初步估计，或者对碰撞精确度要求不高的场合，将不规则的物体投影成较规则的物体进行碰撞预测及检测。&lt;/p&gt;

&lt;p&gt;  目前，成功的3D游戏普遍采用的碰撞检测是BSP树以及AABB(Axially Aligned Bounding Box)包装盒方式。BSP树是用来控制检测顺序和方向的数据描述。这里不再详细讨论。AABB检测方法采用一个描述用的立方体或者球形体包裹住3D物体对象的整体（或者主要部分），我们可以根据包装盒的距离、位置等信息来计算是否发生碰撞。注意：出于计算量和方便性考虑，AABB中常用的包装盒形状是球体和长方体，但是在其它特殊场合，其他形状也可以作为包装盒。&lt;br/&gt;  坐标轴平行（Axially-aligned）不仅指盒体与世界坐标轴平行，同时也指盒体的每个面都和一条坐标轴垂直，这样一个基本信息就能减少转换盒体时操作的次数。AABB技术在当今的许多游戏中都得到了应用，开发者经常用它们作为模型的检测模型。&lt;br/&gt;  二维场景中的AABB包围盒具备特点(下图中的所有坐标系均采用右手直角坐标系):&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;表现形式为四边形，即用四边形包围物体。&lt;/li&gt;
&lt;li&gt;四边形的每一条边，都会与坐标系的轴垂直。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/44012494.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  三维场景中的AABB包围盒特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;表现形式为六面体。&lt;/li&gt;
&lt;li&gt;六面体中的每条边都平行于一个坐标平。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/31070002.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  其中，为了更明显的展示AABB包围盒的特点，在最右侧展示了一个OBB（Oriented Bounding Box）包围盒，也称作有向包围盒。AABB包围盒与OBB包围盒的最直接的区别就是，AABB包围盒是不可以旋转的，而OBB包围盒是可以旋转的，也就是有向的。&lt;/p&gt;
&lt;p&gt;  三维场景中物体的AABB包围盒是一个六面体，虽然有8个顶点，但是对于规则的AABB立方体，我们仅需要知道两个顶点(x&lt;sub&gt;min&lt;/sub&gt;,y&lt;sub&gt;min&lt;/sub&gt;,z&lt;sub&gt;min&lt;/sub&gt;)和(x&lt;sub&gt;max&lt;/sub&gt;,y&lt;sub&gt;max&lt;/sub&gt;,z&lt;sub&gt;max&lt;/sub&gt;)就可以得到AABB的中心点、边长等属性,具体不再详述。&lt;em&gt;三维物体的AABB包围盒的八个顶点依旧可以用两个顶点来标识&lt;/em&gt;，如下图所示。&lt;br/&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/2161.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  球体是碰撞检测中最简单的数学模型，我们只需要直到两个球体的球心和半径就可以进行检测。&lt;br/&gt;  球体碰撞的优点是非常适用于需要快速检测的游戏，因为它不需要精确的碰撞检测算法,执行速度相对较快，不会给CPU带来过大的计算负担。球体碰撞的另一个劣势是只适用于近似球形物体，如果物体非常窄或者非常宽，该碰撞检测算法将会失效，因为会在物体实际发生碰撞之前，碰撞检测系统就发出碰撞信号。&lt;/p&gt;
&lt;h2 id=&quot;球体树&quot;&gt;球体树&lt;/h2&gt;
&lt;p&gt;  为了解决包容球精确度不高的问题，人们又提出了&lt;strong&gt;球体树&lt;/strong&gt;的方法。如下图所示，球体树实际上是一种表达3D物体的层次结构。对一个形状复杂的3D物体，先用一个大球体包容整个物体，然后对物体的各个主要部分用小一点的球体来表示，然后对更小的细节用更小的包容球体，这些球体和它们之间的层次关系就形成了一个球体树。&lt;br/&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/92221122.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  举例来说，对一个游戏中的人物角色，可以用一个大球来表示整个人，然后用中等大小的球体来表示四肢和躯干，然后用更小的球体来表示手脚等。这样在对两个物体进行碰撞检测时，先比较两个最大的球体。如果有重叠，则沿树结构向下遍历，对小一点的球体进行比较，直到没有任何球体重叠，或者到了最小的球体，这个最小的球体所包含的部分就是碰撞的部分。&lt;/p&gt;
&lt;h2 id=&quot;速度锥&quot;&gt;速度锥&lt;/h2&gt;
&lt;p&gt;  在实际碰撞检测中，我们需要提前预估碰撞的危险程度，通过将运动物体碰撞处理为两个球体，在已知球体的球心、半径、运动矢量后，就可以预估出沿着当前运动趋势的最近距离和对应时间。为方便理解，如下图所示，以二维平面上的两个圆形为例建立相对运动坐标系，讨论碰撞检测问题，可以扩展到3维空间的球体中。&lt;br/&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/66783426.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  在二维平面内，障碍物的碰撞预测如下，其中&lt;strong&gt;DCPA表示最近距离的值，TCPA表示在最近时刻的时间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/12448785.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  碰撞预测C#源代码:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// C# 代码
public static ARPA CPACalculation(double USVGeo_x, double USVGeo_y, double OBSGeo_x, double OBSGeo_y, double USV_Speed, double USV_Azimuth, double OBS_Speed, double OBS_Azimuth)
{
    // 计算距离
    double distance = GeographyBase.GeographyTransfer.CalLength(USVGeo_x,USVGeo_y,OBSGeo_x,OBSGeo_y);
    // 计算方位
    double UAV2OBSAzimuth = GeographyBase.GeographyTransfer.CalAzimuth(USVGeo_x, USVGeo_y, OBSGeo_x, OBSGeo_y);
    double interAngle = USV_Azimuth - OBS_Azimuth; //取值范围在[-180, 180]之间
    if (interAngle &amp;gt; 180)
        interAngle -= 360;
    if (interAngle &amp;lt; -180)
        interAngle += 360;
    // 相对速度
    double RelativSpeed = Math.Sqrt(Math.Pow(USV_Speed, 2) + Math.Pow(OBS_Speed, 2) - 2 * USV_Speed * OBS_Speed * Math.Cos(interAngle / 180.0 * Math.PI));
    // 相对航向
    double angleQ = Math.Acos((Math.Pow(RelativSpeed, 2) + Math.Pow(USV_Speed, 2) - Math.Pow(OBS_Speed, 2)) / (2 * RelativSpeed * USV_Speed)) * 180.0 / Math.PI;
    double RelativeAzimuth = 0;
    if (interAngle &amp;gt; 0)
        RelativeAzimuth = USV_Azimuth + angleQ;
    else
        RelativeAzimuth = USV_Azimuth - angleQ;
    // 相对舷角的计算 
    double bearing = UAV2OBSAzimuth - RelativeAzimuth;
    double DCPA = distance * Math.Sin(bearing * Math.PI / 180.0);
    double TCPA = distance * Math.Cos(bearing * Math.PI / 180.0) / RelativSpeed;
    ARPA arpa = new ARPA();
    arpa.DCPA = DCPA;
    arpa.TCPA = TCPA;
    arpa.SailSpeed = OBS_Speed;
    arpa.SailAngle = OBS_Azimuth;
    arpa.TargetDistance = distance;
    arpa.TargetAzimuth = UAV2OBSAzimuth;
    return arpa;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;  AABB对物体的方向很敏感，同一物体的不同方向，AABB也可能不同（由于球体只有一个自由度，所以检测球对物体方向不敏感）。&lt;br/&gt;  当物体在场景中移动时，它的AABB也需要随之移动，当物体发生旋转时，有两种选择：用变换后的物体来重新计算AABB，或者对AABB做和物体同样的变换。如果物体没有发生扭曲，可以通过“变换后AABB”重新计算，因为该方法要比通过“变换后的物体”计算快得多。可以利用矩阵变化加快新的AABB的计算速度，具体可以参考&lt;a href=&quot;http://www.docin.com/p-538256449.html&quot;&gt;适合新手的3d碰撞检测&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;aabb静态检测&quot;&gt;AABB静态检测&lt;/h3&gt;
&lt;p&gt;  AABB的静态检测比较简单，检测两个静止包装盒是否相交，它是一种布尔测试，测试结果只有相交或者不相交。这里我们还提供了获取相交范围信息的方法，一般来说，这种测试的目的是为了返回一个布尔值。&lt;br/&gt;  在一维坐标轴中，两线段A和B相交的条件是:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;线段A在坐标轴上的最大值A&lt;sub&gt;max&lt;/sub&gt;不小于线段B在坐标轴上的最小值B&lt;sub&gt;min&lt;/sub&gt;;&lt;/li&gt;
&lt;li&gt;线段B坐标轴上的最大值B&lt;sub&gt;max&lt;/sub&gt;不小于线段A在坐标轴上的最小值A&lt;sub&gt;min&lt;/sub&gt;;&lt;br/&gt;即 (A&lt;sub&gt;max&lt;/sub&gt;-B&lt;sub&gt;min&lt;/sub&gt;)*(B&lt;sub&gt;max&lt;/sub&gt;-A&lt;sub&gt;min&lt;/sub&gt;)&amp;gt;0&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  基于上述事实，&lt;strong&gt;二维场景中AABB碰撞检测原理&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/70742987.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  在上图中，分别做物体A与物体B在X,Y轴方向的投影，物体A的Y轴方向最大点坐标为Y1，最小点坐标Y2，X轴方向最小点坐标X1，最大点坐标X2，物体B同理。图中红色区域为物体A与物体B投影的重叠部分。&lt;br/&gt;  &lt;em&gt;二维场景中AABB碰撞检测具有如下规则：物体A与物体B分别沿两个坐标轴做投影，只有在两个坐标轴都发生重叠的情况下，两个物体才意味着发生了碰撞&lt;/em&gt;。&lt;br/&gt;  即，若Y轴方向上(Y1-Y4)*(Y3-Y2)&amp;gt;0，X轴方向上(X4-X1)*(X2-X3)&amp;gt;0,那么证明物体A与物体B发生重合，否则证明物体A和B并未发生重合。&lt;br/&gt;  &lt;strong&gt;三维场景中AABB碰撞检测原理&lt;/strong&gt;:&lt;br/&gt;  三维场景中物体的AABB包围盒是一个六面体，其坐标系对于二维坐标系来讲只是多了一个Z轴，所以实际上在三维场景中物体的AABB碰撞检测依然可以采用四个点信息的判定来实现，即从物体A的八个顶点与物体B的八个顶点分别选出两个最大与最小的顶点进行对比。碰撞的示意如下图：&lt;br/&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/81364644.jpg&quot;/&gt;&lt;br/&gt;  &lt;em&gt;三维场景中AABB碰撞检测具有如下规则：物体A与物体B分别沿三个坐标轴做投影，只有在三个坐标轴都发生重叠的情况下，两个物体才意味着发生了碰撞&lt;/em&gt;。&lt;br/&gt;  实现代码如下，其中min和max数组是另一个AABB的最小点和最大点，最后返回碰撞检测结果和碰撞部分的AABB。&lt;br/&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/68475964.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/3866616.jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/58966858.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;运动多面体&quot;&gt;运动多面体&lt;/h3&gt;
&lt;p&gt;  在使用单步碰撞检测时，存在时间步长较大时会发生两个物体完全穿透而算法却未检测出来的问题，如下图所示。通常的解决方法是产生一个4D空间，在单位时间步长内，在物体运动的开始和结束时间之间产生一个&lt;strong&gt;4D超多面体&lt;/strong&gt;，又称运动多面体，用于穿透测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://p05tunu6e.bkt.clouddn.com/18-1-27/44640621.jpg&quot;/&gt;&lt;br/&gt;  对一个三维物体网格化处理后，需要对三维物体内的子网格做碰撞监测，子网格是规则的立方体。在单位时长内，连接开始和结束时刻物体的最大包络线得到的就是运动多面体。其中，通过求取垂直物体运动方向上的宽度就可以得到包络线的宽度，可以应用旋转的方法。&lt;br/&gt;  AABB碰撞检测算法虽然计算方法简单，速度快，但是仅适用于精度要求不高的场合中。相对于AABB碰撞检测，还有一种更逼近物体并更为精确的一种算法--OBB碰撞检测。&lt;/p&gt;

&lt;p&gt;  未完待续&lt;/p&gt;

&lt;p&gt;[1] Gottschalk, Stefan, Ming C. Lin, and Dinesh Manocha. &quot;OBBTree: A hierarchical structure for rapid interference detection.&quot; Proceedings of the 23rd annual conference on Computer graphics and interactive techniques. ACM, 1996.&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/u012945598/article/details/39524343&quot;&gt;三维物体AABB碰撞检测算法&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.docin.com/p-538256449.html&quot;&gt;适合新手的3d碰撞检测&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://wenku.baidu.com/view/d90ca0c3bb4cf7ec4afed043.html&quot;&gt;船舶碰撞危险度的计算方法比较(非匿名)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 27 Jan 2018 06:51:00 +0000</pubDate>
<dc:creator>DHUtoBUAA</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DHUtoBUAA/p/8366062.html</dc:identifier>
</item>
</channel>
</rss>