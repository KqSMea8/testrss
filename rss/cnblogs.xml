<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Chef 自动化运维：初探 cookbook - geekrainy</title>
<link>http://www.cnblogs.com/geekrainy/p/8125979.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/geekrainy/p/8125979.html</guid>
<description>&lt;h2 id=&quot;cookbook-概述&quot;&gt;cookbook 概述&lt;/h2&gt;
&lt;p&gt;Chef 意为“厨房”，我们要做“菜”，自然需要有“菜谱”。事实上在 Chef 中分发到各服务器节点的不是“菜”，而是“菜谱”，服务器自己“做菜”，自己管理自己。&lt;/p&gt;
&lt;p&gt;Cookbook 规定了在 Chef 中执行的操作顺序，决定了应用的构建步骤。可以从市场中寻找一个 cookbook，市场地址：&lt;a href=&quot;https://supermarket.chef.io/cookbooks/&quot; class=&quot;uri&quot;&gt;https://supermarket.chef.io/cookbooks/&lt;/a&gt; 使用如下命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;knife cookbook site install nginx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它会进行版本控制，在提交历史中留下创建记录。&lt;/p&gt;
&lt;p&gt;如果不适用版本控制，则可以使用如下命令（不推荐）：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;knife cookbook site download nginx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在老的版本中，使用 knife 来与 Chef Server 进行交互，创建一个 cookbook 的命令是这样的：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;knife cookbook create first_cookbook&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而在新版本中，创建的命令变为：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;chef generate app first_cookbook&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 repo 的 cookbook 目录下新建时，输入如下命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;chef generate first_cookbook&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行命令后，可以看到创建的目录：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;.
├── Berksfile
├── chefignore
├── LICENSE
├── metadata.rb
├── README.md
├── recipes
│   └── default.rb
├── spec
│   ├── spec_helper.rb
│   └── unit
│       └── recipes
│           └── default_spec.rb
└── test
    └── smoke
        └── default
            └── default_test.rb&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在新版本 Chef 中，不会自动生成所有目录，一个 cookbook 内可能包含的目录及作用参见文档：&lt;a href=&quot;https://docs.chef.io/cookbooks.html&quot; class=&quot;uri&quot;&gt;https://docs.chef.io/cookbooks.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们创建一个部署 nginx 的 cookbook，在这里以 tengine 为例：&lt;/p&gt;
&lt;h2 id=&quot;第一个-cookbook&quot;&gt;第一个 cookbook&lt;/h2&gt;
&lt;p&gt;首先，修改 recipes 目录下的以 &lt;code&gt;.rb&lt;/code&gt; 结尾的文件，该文件记录了节点自身进行操作的步骤。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;package 'pcre-devel' do
  action :install
end

package 'openssl' do
  action :install
end

package 'openssl-devel' do
  action :install
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述脚本安装了可能缺少的依赖包，这里 Chef 可以帮我们抹除平台差异，例如在 Ubuntu 平台使用 &lt;code&gt;apt&lt;/code&gt; 和在 CentOS 使用 &lt;code&gt;yum&lt;/code&gt; 的差异。&lt;/p&gt;
&lt;p&gt;也可以一步安装多个依赖包：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;package %w(pcre-devel openssl openssl-devel)
  action :install
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可能产生的问题是，在不同的平台包名可能不同，对不同环境下依赖包的版本不同。当然，Chef 会考虑到这一点，这里不详细展开，可以参阅文档：&lt;a href=&quot;https://docs.chef.io/resource_package.html&quot; class=&quot;uri&quot;&gt;https://docs.chef.io/resource_package.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安装完依赖后，就需要下载 tengine 源码，并进行编译操作。这一步用 shell 命令很方便，所以在 recipe 中也是可以定义一组 shell 命令的。在文件后追加如下行：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;script 'install_tengine' do
  interpreter 'bash'
  user 'root'
  cwd '/usr/local/src'
  code &amp;lt;&amp;lt;-EOH
  wget 'http://tengine.taobao.org/download/tengine-2.2.1.tar.gz'
  tar -zxvf tengine-2.2.1.tar.gz -C /usr/local/src/
  cd /usr/local/src/tengine-2.2.1/
  ./configure
  make
  make install
  chkconfig nginx on
  EOH
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;interpreter&lt;/code&gt; 参数指定了要以何种 shell 去运行，&lt;code&gt;user&lt;/code&gt; 定义执行用户，&lt;code&gt;cwd&lt;/code&gt; 定义执行路径。&lt;/p&gt;
&lt;p&gt;随后下载解压，进行编译安装。&lt;/p&gt;
&lt;p&gt;可以看到我们在定义的命令中启用了 nginx 服务：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;chkconfig nginx on&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的问题在于，tengine 编译后并不会生成定义服务的文件，因而需要我们手动添加服务，即：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;创建 nginx 服务文件 -&amp;gt; 给定权限 -&amp;gt; 启用服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以需要添加一个固定的文件，添加到节点中。在 cookbook 内，可以定义文件，文件中的内容一般是固定不变的。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;script 'install_tengine' do&lt;/code&gt; 块之前添加：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;cookbook_file &quot;/etc/init.d/nginx&quot; do
  source &quot;nginx&quot;
  mode '0755'
  owner 'root'
  group 'root'
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以本地文件 nginx 去添加到节点服务器的 /etc/init.d/nginx 内。其它参数顾名思义，cookbook 文件、权限、所有者及组。&lt;/p&gt;
&lt;p&gt;新建一个 files/default 文件夹，在其中建立 nginx 文件，该文件定义了 nginx 服务，会被添加至 &lt;code&gt;/etc/init.d/&lt;/code&gt; 文件夹。nginx 文件的内容可以自己去定义，也可以参考如下定义（来自 &lt;a href=&quot;http://blog.51cto.com/benpaozhe/1760999&quot; class=&quot;uri&quot;&gt;http://blog.51cto.com/benpaozhe/1760999&lt;/a&gt;）：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;#!/bin/bash
#writer:gaolixu
#chkconfig: 345 86 16
start(){
if [ -f /var/lock/subsys/tengine.lock ];then
  echo &quot;Tengine is already running: [ FAILED ]&quot;
else
  if /usr/local/nginx/sbin/nginx ;then
    echo &quot;Starting tengine: [ OK ]&quot; 
    touch /var/lock/subsys/tengine.lock
  else
    echo &quot;Starting tengine: [ FAILED ]&quot;
  fi
fi
}
stop(){
if [ -f /var/lock/subsys/tengine.lock  ];then
 if /usr/local/nginx/sbin/nginx -s quit ;then
   echo &quot;Stopping tengine: [ OK ]&quot;
   rm -rf /var/lock/subsys/tengine.lock
 else
   echo &quot;Stopping tengine: [ FAILED ]&quot;
 fi
else
 echo &quot;Tengine not runing: [ FAILED ]&quot;
fi
}
reload(){
if /usr/local/nginx/sbin/nginx -s reload ;then
  echo &quot;Reload tengine: [ OK ]&quot;
else
  echo &quot;Reload tengine: [ FAILED ]&quot;
fi
}
case $1 in
&quot;start&quot;)
 start
;;
&quot;stop&quot;)
 stop
;;
&quot;restart&quot;)
 stop
 sleep 1
 start
;;
&quot;reload&quot;)
 reload
;;
&quot;status&quot;)
 s=`pidof -s nginx`
 [ &quot;$s&quot; ] &amp;amp;&amp;amp; echo &quot;Tengine(nginx) pid $s running!!&quot; || echo &quot;Tengine（nginx） not runging!&quot;
;;
*)
echo &quot;usage: $0 start|stop|restart|reload|status&quot;
esac
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，目录结构应该是这样的：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;.
├── Berksfile
├── chefignore
├── files
│   └── default
│       └── nginx
├── LICENSE
├── metadata.rb
├── README.md
├── recipes
│   └── default.rb
├── spec
│   ├── spec_helper.rb
│   └── unit
│       └── recipes
│           └── default_spec.rb
└── test
    └── smoke
        └── default
            └── default_test.rb&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当安装完添加服务后，当然希望它启动：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;service 'nginx' do
  supports [:enable, :start, :status, :restart, :reload]

  action :start
end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义了 nginx 服务支持的命令和要执行的操作，对 service 的管理，参见：&lt;a href=&quot;https://docs.chef.io/resource_service.html&quot; class=&quot;uri&quot;&gt;https://docs.chef.io/resource_service.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同样地，使用 Chef 内置的语法来管理 service，可以消除平台差异，并且可以支持更多的逻辑判断操作，对服务的管理更加灵活。&lt;/p&gt;
&lt;p&gt;现在就简单的完成了一个 cookbook，现在来测试一下运行结果，在 chef-repo 文件夹下运行：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;chef-client --local-mode --override-runlist first_cookbook&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到一堆命令输出，若有报错会中止！&lt;/p&gt;
&lt;p&gt;命令结束后，验证：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;service nginx status
Tengine(nginx) pid 23776 running!!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，已经成功使用 cookbook 部署运行了 nginx。&lt;/p&gt;
&lt;h2 id=&quot;不足&quot;&gt;不足&lt;/h2&gt;
&lt;p&gt;我们简单的创建了一个 nginx 的 cookbook，并且在部署后实现了服务的自动启动。但是往往在现实中会有不同的配置，简单的使用默认配置当然不能满足需求。这时，cookbook 中的 &lt;code&gt;template&lt;/code&gt; 和 &lt;code&gt;attributes&lt;/code&gt; 就派上用场了。下篇文章会使用模板变量结合一定的逻辑，来实现多样化的配置管理需求。&lt;/p&gt;
&lt;p&gt;-EOF-&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 07:28:00 +0000</pubDate>
<dc:creator>geekrainy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/geekrainy/p/8125979.html</dc:identifier>
</item>
<item>
<title>为 Azure IoT Edge 设备部署 Azure Stream Analytics 服务 - 施炯</title>
<link>http://www.cnblogs.com/dearsj001/p/AzureIoTEdgeASA.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dearsj001/p/AzureIoTEdgeASA.html</guid>
<description>&lt;p&gt;      在前面的两篇文章《&lt;a href=&quot;http://www.cnblogs.com/dearsj001/p/AzureIoTEdge4WindowsIoTCore.html&quot;&gt;Azure IoT Edge on Windows 10 IoT Core&lt;/a&gt;》和《&lt;a href=&quot;http://www.cnblogs.com/dearsj001/p/AzureIoTEdge4RaspberryPi.html&quot;&gt;Azure IoT Edge on Raspberry Pi 3 with Raspbian&lt;/a&gt;》中，我们学习了如何在Windows 10和Linux系统上进行Docker的部署和Python、Iotedgectl工具的安装，同时，在Azure Portal上完成了IoT Edge Device的创建、Azure IoT Edge Module的部署与运行。而在实际的生产环境中，IoT 设备可以生成大量的数据。 为了减少上传的数据量或降低控制策略的延时，有时必须在设备端对数据进行实时分析或处理。Azure Stream Analytics 服务就是很好的解决方案之一，用户可以从Azure Portal中创建Azure Stream Analytics 服务，然后在 Azure IoTHub 中将其设置为 IoT Edge Module 并部署到Azure IoT Edge设备上。本文将演示如何创建Azure Stream Analytics Job， 并将其部署到 IoT Edge 设备上。&lt;/p&gt;

&lt;p&gt;      首先，在 Azure 门户中，转到“New”，在搜索框输入“Storage”，选择“Storage account - Blob，file, table, queue”。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152501706-1728161093.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152502081-361641761.png&quot; alt=&quot;image&quot; width=&quot;484&quot; height=&quot;468&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      然后，在“Create Storage Account ”中，输入存储帐户的名称，选择存储IoTHub的同一位置(这里为East Asia)，然后选择“Create”。 请记下该名称供稍后使用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152502519-2103930367.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152502847-2118309899.png&quot; alt=&quot;image&quot; width=&quot;484&quot; height=&quot;702&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      接着，转到刚刚创建的存储帐户，选择“Blob Service”。为Azure Stream Analytics 模块创建一个新容器用于存储数据，将访问级别设置为“Container”，选择“确定”。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152503206-1503069009.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152503488-587073204.png&quot; alt=&quot;image&quot; width=&quot;484&quot; height=&quot;503&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;      首先，在 Azure 门户中，转到“Create” &amp;gt; “Internet of Things”，然后选择“Stream Analytics Job”。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152503847-1375588067.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152504050-362479187.png&quot; alt=&quot;image&quot; width=&quot;484&quot; height=&quot;442&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      然后，在“New Stream Analytics Job”中执行以下操作：在“Job name”框中键入作业名称;在”Hosting Environment”下，选择“Edge”；在剩余字段中使用默认值。&lt;/p&gt;
&lt;p&gt;      接着，在所创建作业中的“Job Topology”下，依次选择“Input”-“Add”。在“Input alias”框中，输入 &lt;strong&gt;temperature&lt;/strong&gt;。在“Source Type”框中，选择“Data stream”。在剩余字段中使用默认值。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152504269-1862843306.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152504425-2015397558.png&quot; alt=&quot;image&quot; width=&quot;484&quot; height=&quot;326&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;       接下来，在所创建作业中的“Job Topology”下，依次选择“Output”-“Add”， 在“输出别名”框中，键入 &lt;strong&gt;alert，&lt;/strong&gt;在剩余字段中使用默认值。之后选择“创建” 。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152504597-917042908.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152504753-1384925148.png&quot; alt=&quot;image&quot; width=&quot;484&quot; height=&quot;292&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      最后，在在所创建作业中的“Job Topology”下，依次选择“Query”-“Add”， 加入以下SQL语句并保存&lt;/p&gt;
&lt;p&gt;&lt;em&gt;SELECT &lt;br/&gt;     'reset' AS command&lt;br/&gt;INTO&lt;br/&gt;    alert&lt;br/&gt;FROM&lt;br/&gt;    temperature TIMESTAMP BY timeCreated&lt;br/&gt;GROUP BY TumblingWindow(second,30)&lt;br/&gt;HAVING Avg(machine.temperature) &amp;gt; 70&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;      首先，在 Azure Portal 的 IoTHub页面内，转到“IoT Edge”并打开 IoT Edge 设备的详细信息页。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152504910-2050082330.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152505144-1573107398.png&quot; alt=&quot;image&quot; width=&quot;484&quot; height=&quot;322&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      选择“Set Modules”，并确保已经按照之前文章中的步骤添加了tempSensor模块，因为这里的Azure Stream Analytics模块是针对tempSensor模块产生的数据来进行实时分析的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152505331-1611569582.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152505503-1021979573.png&quot; alt=&quot;image&quot; width=&quot;484&quot; height=&quot;280&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      在“Add Modules”页面，选择“Import Azure Stream Analytics IoT Edge Module”，&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152505675-276751981.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152505847-1021568978.png&quot; alt=&quot;image&quot; width=&quot;484&quot; height=&quot;492&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      在接下来的Edge Deployment页面，选择之前创建好的Stream Analytics - Edge Job，注意，这里要选择之前第一部分已经创建好的存储账户和Container，点击保存，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152506019-559967568.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152506191-1035223436.png&quot; alt=&quot;image&quot; width=&quot;484&quot; height=&quot;470&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      之后，将一下代码复制到Routes，将{&lt;em&gt;moduleName&lt;/em&gt;}替换为复制的模块名称：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;{&lt;br/&gt;     &quot;routes&quot;: {                                                              &lt;br/&gt;       &quot;telemetryToCloud&quot;: &quot;FROM /messages/modules/tempSensor/* INTO $upstream&quot;,&lt;br/&gt;       &quot;alertsToCloud&quot;: &quot;FROM /messages/modules/{moduleName}/* INTO $upstream&quot;,&lt;br/&gt;       &quot;alertsToReset&quot;: &quot;FROM /messages/modules/{moduleName}/* INTO BrokeredEndpoint(\&quot;/modules/tempSensor/inputs/control\&quot;)&quot;,&lt;br/&gt;       &quot;telemetryToAsa&quot;: &quot;FROM /messages/modules/tempSensor/* INTO BrokeredEndpoint(\&quot;/modules/{moduleName}/inputs/temperature\&quot;)&quot;&lt;br/&gt;     }&lt;br/&gt;}&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;      选择下一步，然后Submit。返回到“设备详细信息”页，并选择“刷新”。应会看到新的流分析模块已经在列表中，但是状态还是处于Pending Deployment。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152506331-1199637559.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152506503-759893304.png&quot; alt=&quot;image&quot; width=&quot;484&quot; height=&quot;112&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      一段时间以后，等该Module部署到设备以后，刷新列表，可以发现，EdgeASA已经处于running状态，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152506644-610599947.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152506785-1091627599.png&quot; alt=&quot;image&quot; width=&quot;484&quot; height=&quot;114&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;      回到Putty工具，利用“docker logs -f {moduleName} ”指令（其中，{moduleName} 用刚刚部署的流分析模块的名称代替），就可以查看流分析的日志信息，如下图所示。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;a href=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152506956-540720856.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;http://images2017.cnblogs.com/blog/41072/201712/41072-20171227152507206-1384256078.png&quot; alt=&quot;image&quot; width=&quot;484&quot; height=&quot;348&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;      至此，我们完成了存储账户的创建、Azure Stream Analytics Job的创建和Azure Stream Analytics Job的部署与运行。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;参考链接： &lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;1. &lt;a href=&quot;http://www.cnblogs.com/dearsj001/p/AzureIoTEdge4WindowsIoTCore.html&quot;&gt;Azure IoT Edge on Windows 10 IoT Core&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2. &lt;a href=&quot;http://www.cnblogs.com/dearsj001/p/AzureIoTEdge4RaspberryPi.html&quot;&gt;Azure IoT Edge on Raspberry Pi 3 with Raspbian&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3. &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/iot-edge/tutorial-deploy-stream-analytics&quot;&gt;Deploy Azure Stream Analytics as an IoT Edge module - preview&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 07:25:00 +0000</pubDate>
<dc:creator>施炯</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dearsj001/p/AzureIoTEdgeASA.html</dc:identifier>
</item>
<item>
<title>nodejs实现OAuth2.0授权服务 - 西安-晁州</title>
<link>http://www.cnblogs.com/vipzhou/p/8125924.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vipzhou/p/8125924.html</guid>
<description>&lt;p&gt;OAuth是一种开发授权的网络标准，全拼为&lt;em&gt;open authorization&lt;/em&gt;，即开放式授权，最新的协议版本是2.0。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;p&gt;有一个&quot;云冲印&quot;的网站，可以将用户储存在Google的照片，冲印出来。用户为了使用该服务，必须让&quot;云冲印&quot;读取自己储存在Google上的照片。&lt;/p&gt;
&lt;p&gt;传统方法是，用户将自己的Google用户名和密码，告诉&quot;云冲印&quot;，后者就可以读取用户的照片了。这样的做法有以下几个严重的缺点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&quot;云冲印&quot;为了后续的服务，会保存用户的密码，这样很不安全。&lt;/li&gt;
&lt;li&gt;Google不得不部署密码登录，而我们知道，单纯的密码登录并不安全。&lt;/li&gt;
&lt;li&gt;&quot;云冲印&quot;拥有了获取用户储存在Google所有资料的权力，用户没法限制&quot;云冲印&quot;获得授权的范围和有效期。&lt;/li&gt;
&lt;li&gt;用户只有修改密码，才能收回赋予&quot;云冲印&quot;的权力。但是这样做，会使得其他所有获得用户授权的第三方应用程序全部失效。&lt;/li&gt;
&lt;li&gt;只要有一个第三方应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;所以OAuth就诞生了！&lt;/p&gt;
&lt;h2 id=&quot;名词定义&quot;&gt;名词定义&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Third-party application：第三方应用程序，本文中又称&quot;客户端&quot;（client），即上一节例子中的&quot;云冲印&quot;。&lt;/li&gt;
&lt;li&gt;HTTP service：HTTP服务提供商，本文中简称&quot;服务提供商&quot;，即上一节例子中的Google。&lt;/li&gt;
&lt;li&gt;Resource Owner：资源所有者，本文中又称&quot;用户&quot;（user）。&lt;/li&gt;
&lt;li&gt;User Agent：用户代理，本文中就是指浏览器。&lt;/li&gt;
&lt;li&gt;Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。&lt;/li&gt;
&lt;li&gt;Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;oauth整体思路&quot;&gt;OAuth整体思路&lt;/h2&gt;
&lt;p&gt;登录层提供令牌（token）的生成，其中token包括：有效期、权限范围。客户端拿到token去访问受限资源。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;access_token：请求资源时需要携带的token，即访问token。&lt;/li&gt;
&lt;li&gt;refresh_token：刷新token，如果access_token过期，可以使用该token获取一份新的access_token和新的refresh_token。一般refresh_token时效性较长，比如一年，而access_token时效性较短，比如几分钟。&lt;/li&gt;
&lt;li&gt;权限范围：即指定客户端可以获取的资源权限范围。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;oauth授权模式&quot;&gt;OAuth授权模式&lt;/h2&gt;
&lt;p&gt;OAuth有四种授权模式，分别为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;授权码模式（authorization code）&lt;/li&gt;
&lt;li&gt;简化模式（implicit）&lt;/li&gt;
&lt;li&gt;密码模式（resource owner password credentials）&lt;/li&gt;
&lt;li&gt;客户端模式（client credentials）&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;授权码模式&quot;&gt;1、授权码模式&lt;/h3&gt;
&lt;p&gt;授权码模式是最为严密的授权模式，整体流程为：浏览器携带必要信息至授权页面，正常登录成功后，返回一个code（授权码），客户端拿到code后在后台获取拿code换取token。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.beekka.com/blog/2014/bg2014051204.png&quot; alt=&quot;code grant模式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://on-img.com/chart_image/58d9ffcde4b03e064c8addb6.png&quot; alt=&quot;此处输入图片的描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;密码模式&quot;&gt;2、密码模式&lt;/h3&gt;
&lt;p&gt;密码模式，简单地理解即为使用用户名密码等参数获取access_token，它的步骤如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;用户向客户端提供用户名和密码。&lt;/li&gt;
&lt;li&gt;客户端将用户名和密码发给认证服务器，向后者请求令牌。&lt;/li&gt;
&lt;li&gt;认证服务器确认无误后，向客户端提供访问令牌。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/caiya/imgs/8850b1b9e336d3774cf924cf8611267db95442e2/%E4%BD%BF%E7%94%A8password%E6%A8%A1%E5%BC%8F%E8%8E%B7%E5%8F%96access_token.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;refresh_token的应用&quot;&gt;3、refresh_token的应用&lt;/h3&gt;
&lt;p&gt;refresh_token被用来获取新的access_token和refresh_token，使用方式简单如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/caiya/imgs/8850b1b9e336d3774cf924cf8611267db95442e2/%E4%BD%BF%E7%94%A8refresh_token%E8%AF%B7%E6%B1%82%E6%96%B0%E7%9A%84access_token.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;refresh_token无效：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/caiya/imgs/8850b1b9e336d3774cf924cf8611267db95442e2/%E9%94%99%E8%AF%AF%E7%9A%84refresh_token.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用nodejs实现oauth授权服务&quot;&gt;使用nodejs实现OAuth授权服务&lt;/h2&gt;
&lt;p&gt;技术栈：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;nodejs + eggjs&lt;/li&gt;
&lt;li&gt;eggjs-oAuth-server插件&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;具体可以参考：&lt;br/&gt;&lt;a href=&quot;https://github.com/Azard/egg-oauth2-server&quot; class=&quot;uri&quot;&gt;https://github.com/Azard/egg-oauth2-server&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://cnodejs.org/topic/592b2aedba8670562a40f60b&quot; class=&quot;uri&quot;&gt;https://cnodejs.org/topic/592b2aedba8670562a40f60b&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;code-grant模式测试及单点登录实现&quot;&gt;1、code grant模式测试及单点登录实现&lt;/h3&gt;
&lt;p&gt;这里我们构建两个站点，一个是7001端口（授权服务），一个是7002端口（客户端），授权模式为code grant。&lt;/p&gt;
&lt;p&gt;首先是客户端登录页：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/caiya/imgs/c369910fbff2422fa6a705b4208907bdc1dd2334/%E5%AD%90%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单击按钮后直接登录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/caiya/imgs/c369910fbff2422fa6a705b4208907bdc1dd2334/oAuth%E7%BB%9F%E4%B8%80%E7%99%BB%E5%BD%95%E9%A1%B5.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，浏览器重定向到授权服务地址，并携带了&lt;em&gt;response_type、client_id、redirect_uri&lt;/em&gt;三个参数，登录成功后，浏览器会重定向到&lt;em&gt;redirect_uri&lt;/em&gt;指定的地址，即这里的*&lt;a href=&quot;http://127.0.0.1:7002/auth/redirect*&quot; class=&quot;uri&quot;&gt;http://127.0.0.1:7002/auth/redirect*&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;如下为授权服务的登录页写法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;form&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; action=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;/oauth2/authorize?{{query}}&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;form1&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;f&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;post&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;input_outer&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;span&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;u_user&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;username&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; style=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;color: #FFFFFF !important&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; placeholder=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;请输入账户&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;input_outer&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;span&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;us_uer&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;input&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; style=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;color: #FFFFFF !important; position:absolute; z-index:100;&quot;&lt;/span&gt;&lt;span class=&quot;er&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; type=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; placeholder=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;请输入密码&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;mb2&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;a&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;act-but submit&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; href=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;javascript:;&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; onclick=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;document.getElementById('form1').submit()&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; style=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;color: #FFFFFF&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;登录&lt;span class=&quot;kw&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的&lt;em&gt;${query}&lt;/em&gt;即为客户端登录重定向携带的完整query，然后是&lt;em&gt;/oauth2/authorize&lt;/em&gt;路由的写法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;all&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/oauth2/authorize'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;app&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;oAuth2Server&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;authorize&lt;/span&gt;())&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;co&quot;&gt;// 获取授权码&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里调用&lt;em&gt;app.oAuth2Server.authorize()&lt;/em&gt;时，插件会自动执行重定向操作，首先是重定向到客户端指定地址，客户端拿到code和state后，再去授权层获取token：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode js&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;async &lt;span class=&quot;at&quot;&gt;redirect&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// 服务端重定向过来的&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;query&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;const&lt;/span&gt; result &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; await &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;curl&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'http://127.0.0.1:7001/users/token'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;dataType&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'json'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;co&quot;&gt;// contentType: 'application/x-www-form-urlencoded', // 默认格式&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;method&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'POST'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;dt&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;grant_type&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'authorization_code'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;query&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;query&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;client_id&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; client_id&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;client_secret&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; client_secret&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;redirect_uri&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; redirect_uri&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;ctx&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;result&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取到token后正常返回：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/caiya/imgs/c369910fbff2422fa6a705b4208907bdc1dd2334/oAuth%E7%99%BB%E5%BD%95%E6%88%90%E5%8A%9F%E8%BF%94%E5%9B%9E.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;password-grant模式测试&quot;&gt;2、password grant模式测试&lt;/h2&gt;
&lt;p&gt;首先使用username、password获取access_token：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/caiya/imgs/8850b1b9e336d3774cf924cf8611267db95442e2/%E4%BD%BF%E7%94%A8password%E6%A8%A1%E5%BC%8F%E8%8E%B7%E5%8F%96access_token.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户名或密码错误时返回：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/caiya/imgs/8850b1b9e336d3774cf924cf8611267db95442e2/password%20grant%E4%B8%8B%E9%94%99%E8%AF%AF%E7%9A%84%E5%AF%86%E7%A0%81.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用token获取授权资源正常返回：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/caiya/imgs/8850b1b9e336d3774cf924cf8611267db95442e2/%E8%8E%B7%E5%8F%96%E5%88%B0token%E5%90%8E%EF%BC%8C%E6%B7%BB%E5%8A%A0Bearer%20token%E6%9D%A5%E8%AF%B7%E6%B1%82%E5%90%8E%E7%BB%AD%E6%89%80%E6%9C%89API%E6%8E%A5%E5%8F%A3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上内容完整源码参考：&lt;a href=&quot;https://github.com/caiya/eggjs-oAuth2-server&quot; class=&quot;uri&quot;&gt;https://github.com/caiya/eggjs-oAuth2-server&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;OAuth实际使用时要上https，包括客户端和授权服务端&lt;/li&gt;
&lt;li&gt;授权服务可以使用私钥签名，客户端使用公钥验证，从而保证数据安全性&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
</description>
<pubDate>Wed, 27 Dec 2017 07:20:00 +0000</pubDate>
<dc:creator>西安-晁州</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vipzhou/p/8125924.html</dc:identifier>
</item>
<item>
<title>数据结构(四)--队列 - xiaoyouPrince</title>
<link>http://www.cnblogs.com/xiaoyouPrince/p/8125852.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoyouPrince/p/8125852.html</guid>
<description>&lt;p&gt;本文主要讲解了队列的定义和队列主要功能实现的算法。最后会列举一些队列在程序设计当中常见的应用实例！相信了解了队列对你理解数据结构和程序设计会更加有益处！&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;1. 队列的定义&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;队列 (Queue)&lt;/strong&gt;是一种先进先出(first in first out : &lt;strong&gt;FIFO&lt;/strong&gt;)的线性表。它只允许在表的一端进行插入，在另一端进行删除元素。这和我们平时战队买票很一样。最早进入队列的元素最先离开，在队列中，允许插入的一端叫做&lt;strong&gt;队尾(rear)&lt;/strong&gt;,允许删除的一段则称为&lt;strong&gt;队头(front)&lt;/strong&gt;.示意图如下：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/905487/201712/905487-20171227150616378-1183696704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;2. 队列的分类&lt;/h2&gt;
&lt;p&gt;队列主要分为两类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;链式队列：链式队列即用链表实现的队列&lt;/li&gt;
&lt;li&gt;顺序队列：顺序队列是用数组实现的队列，顺序队列通常必须是循环队列&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文主要以顺序队列（循环队列）为例，通过如下几个问题来分析和介绍顺序队列的相关知识，(链式队列内部以链表实现相对更加简单)&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;顺序队列为什么是循环队列？&lt;/li&gt;
&lt;li&gt;一共需要几个参数，分别是什么含义？&lt;/li&gt;
&lt;li&gt;入队伪算法思路&lt;/li&gt;
&lt;li&gt;出队伪算法思路&lt;/li&gt;
&lt;li&gt;如何判断循环队列是否为空&lt;/li&gt;
&lt;li&gt;如何判断循环队列已满&lt;/li&gt;
&lt;li&gt;什么时候该使用顺序队列？什么时候该使用链式队列&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;toc_3&quot;&gt;2.0 循环队列--队列的顺序表示和实现整体分析&lt;/h3&gt;
&lt;p&gt;顺序队列本身是一种数组表示。在队列的顺序存储结构中，除了用一组连续的存储单元依次存放从队列头到队列尾的元素之外，尚需附设两个指针 front 和 rear 分别指示队列头元素及队列尾元素的位置。为了在C语言中描述方便，通常有如下约定：初始化创建空队列时，令 front = rear = 0，每当插入新的队列尾元素时，“尾指针增 1”；每当删除队列头元素时，“头指针增 1”；因此，在非空队列下，头指针始终指向队列头元素，而尾指针始终指向队列尾元素的下一个位置，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/905487/201712/905487-20171227150708988-923701467.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;假设当前队列分配最大空间为6，则当队列处于上图(d)的状态时，不可再继续插入新的队尾元素，否则会因为数组越界而导致程序代码被破坏。然而此时又不宜进行存储再分配扩大数组空间，因为队列的实际可用空间并未占满。一个巧妙的办法是将顺序队列臆造为一个环状的空间，如图所示，称之为循环队列：&lt;br/&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/905487/201712/905487-20171227150739456-1494552563.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/905487/201712/905487-20171227150748347-2006410658.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图，指针和队列之间的关系不变，上图 (a) 所示循环队列中，队列头元素是 J3 ，队列尾元素是 J5,之后J6,J7和J8相继插入，则队列空间均被占满，如图 (b) 所示，此时 Q.front = Q.rear; 反之，若 J3,J4 和 J5 相继从图 (a) 队列中删除，使队列呈“空”的状态，如图 (c) 所示，此时存在关系为 Q.front = Q.rear, 由此可见只凭等式 Q.front = Q.rear无法判断队列是“空”还是“满”。有两种可处理方式：一种是另外设置一个标志以区别队列是 “空” 还是 “满”；另一种是少用一个元素空间，约定以“队列头指针在队列尾指针的下一位置(指环状的下一位置)”作为队列呈“满”状态的标志。&lt;/p&gt;
&lt;p&gt;从此分析中可见，在C语言中不能用动态分配的一维数组来实现循环队列，如果用户的应用程序中设有循环队列，则必须为它设定一个最大队列长度，若用户无法预估所用队列的最大长度，则宜采用链式队列。&lt;/p&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;2.1 顺序队列为什么是循环队列&lt;/h3&gt;
&lt;p&gt;循环队列是针对顺序队列中最大内存空间有限，当队列处于上图(d)的状态时，不可再继续插入新的队尾元素，否则会因为数组越界而导致程序代码被破坏。然而此时又不宜进行存储再分配扩大数组空间，因为队列的实际可用空间并未占满的问题的一种合理的解决方案。&lt;/p&gt;
&lt;h3 id=&quot;toc_5&quot;&gt;2.2 一共需要几个参数，分别是什么含义&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;front &amp;amp;&amp;amp; rear&lt;/strong&gt;&lt;br/&gt;不同场合下含义不同。&lt;br/&gt;1. 队列初始化 -- front 和 rear 的值都是零&lt;br/&gt;2. 队列非空 -- front 代表队列的第一个元素，rear 代表队列的最后一个有效元素的下一个元素&lt;br/&gt;3. 队列为空 -- front 和 rear 相等，但不一定是零&lt;/p&gt;
&lt;h3 id=&quot;toc_6&quot;&gt;2.3 入队伪算法&lt;/h3&gt;
&lt;p&gt;尾部入队，分两步完成&lt;br/&gt;1. 将值存入r所代表的位置&lt;br/&gt;2. 错误写法 r = r + 1; 正确写法： r = (r + 1) % 数组的长度 【n-1对n取余，结果就是n-1】&lt;/p&gt;
&lt;h3 id=&quot;toc_7&quot;&gt;2.4 出队伪算法&lt;/h3&gt;
&lt;p&gt;头部出队，分两步完成&lt;br/&gt;1. 将f出队的值保存起来（可以根据具体需求确定是否要保存）&lt;br/&gt;2. f 的指针变动正确写法： f = (f + 1) % 数组的长度 【n-1对n取余，结果就是n-1】&lt;/p&gt;
&lt;h3 id=&quot;toc_8&quot;&gt;2.5 如何判断循环队列是否为空&lt;/h3&gt;
&lt;p&gt;如果front == rear ，则该队列一定为空&lt;/p&gt;
&lt;h3 id=&quot;toc_9&quot;&gt;2.6 如何判断循环队列已满&lt;/h3&gt;
&lt;p&gt;预备知识：&lt;br/&gt;front 的值可能比 rear 大&lt;br/&gt;front 的值也可能比 rear 小&lt;br/&gt;当然两者也完全可能相等&lt;/p&gt;
&lt;p&gt;判断已满两种方式：&lt;br/&gt;1. 多增加一个标识参数&lt;br/&gt;2. 少用数组中的一个元素【可以直接用两个参数，通常使用第二种方式】&lt;br/&gt;如果r 和 f 的值紧挨着，则标识队列已满&lt;br/&gt;C语言标识就是：&lt;br/&gt;if ( (r+1)%数组长度 == f)&lt;br/&gt;队列已满&lt;br/&gt;else&lt;br/&gt;队列未满&lt;/p&gt;
&lt;h3 id=&quot;toc_10&quot;&gt;2.7 什么时候该使用顺序队列？什么时候该使用链式队列？&lt;/h3&gt;
&lt;p&gt;如果用户的应用程序中设有循环队列，则必须为它设定一个最大队列长度，若用户无法预估所用队列的最大长度，则宜采用链式队列&lt;/p&gt;
&lt;h2 id=&quot;toc_11&quot;&gt;3. 队列的伪算法和实现&lt;/h2&gt;
&lt;p&gt;此小节实现的是一个最大队列长度为 6 的环形队列，下面是本队列的定义和相关实现。&lt;/p&gt;
&lt;p&gt;队列类型的定义&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#define kQueueMaxLength 6   // 假设最大长度为 6
typedef struct Queue{
    int * pBase;    // 队列中操作的数组
    int front;      // 队头
    int rear;       // 对尾
}QUEUE;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;队列的初始化&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/**
 初始化队列
 @param pQueue 要被初始化队列地址
 */
void init_queue(QUEUE *pQueue){
    pQueue-&amp;gt;pBase = (int *)malloc(sizeof(int) * kQueueMaxLength); // 初始化，pBase指向长度6的 int* 数组
    pQueue-&amp;gt;front = pQueue-&amp;gt;rear = 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;元素入队&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/**
 入队

 @param pQueue 要入队的队列地址
 @param val 入队元素的值
 @return 入队成功/失败
 */
bool en_queue(QUEUE *pQueue , int val){
    
    if (full_queue(pQueue)) { // 队列已满，直接返回入队失败
        return false;
    }else
    {   // 队列未满，执行入队操作
        
        // 1.元素插入数组中
        pQueue-&amp;gt;pBase[pQueue-&amp;gt;rear] = val;
        // 2.队头队尾的表示
        pQueue-&amp;gt;rear = (pQueue-&amp;gt;rear + 1) % kQueueMaxLength;
        
        return true;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;元素出队&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/**
 出队

 @param pQueue 要出队队列地址
 @param val 被出队元素地址
 @return 出队成功/失败
 */
bool de_queue(QUEUE *pQueue , int *val){
    
    if (empty_queue(pQueue)) {  // 如果是空队列，直接出队失败
        return false;
    }else
    {
        // 出队-&amp;gt;保存被出队元素的值
        *val = pQueue-&amp;gt;pBase[pQueue-&amp;gt;front];
        // 修改队头位置
        pQueue-&amp;gt;front = (pQueue-&amp;gt;front + 1) % kQueueMaxLength;
        
    }
    return true;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;遍历队列&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/**
 遍历队列

 @param pQueue 要遍历的队列的地址
 */
void tranverce_queue(QUEUE *pQueue){
    
    int i = pQueue-&amp;gt;front;
    int lenght = 0;
    while (i != pQueue-&amp;gt;rear) {
        lenght ++;
        i = (i + 1) % kQueueMaxLength;
    }
    printf(&quot;队列中共有 %d 个元素\n&quot;,lenght);
    
    i = pQueue-&amp;gt;front;
    while (i != pQueue-&amp;gt;rear) {
        
        printf(&quot;第 %d 个元素为 %d\n&quot;,i + 1,pQueue-&amp;gt;pBase[i]);
        i = (i + 1) % kQueueMaxLength;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主函数中使用队列&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int main() {

    QUEUE q;            // 声明队列q
    init_queue(&amp;amp;q);     // 初始化队列q
    
    en_queue(&amp;amp;q, 2);    // 插入元素
    en_queue(&amp;amp;q, 21);    // 插入元素
    en_queue(&amp;amp;q, 3);    // 插入元素
    en_queue(&amp;amp;q, 4);    // 插入元素
    en_queue(&amp;amp;q, 5);    // 插入元素
    en_queue(&amp;amp;q, 6);    // 插入元素
    en_queue(&amp;amp;q, 7);    // 插入元素
    en_queue(&amp;amp;q, 8);    // 插入元素
    
    tranverce_queue(&amp;amp;q);    //遍历队列
    
    int i;
    bool b;
    b = de_queue(&amp;amp;q, &amp;amp;i);   // 出队
    printf(&quot;出队%s,元素为 %d\n&quot;,b?&quot;成功&quot;:&quot;失败&quot;,i);
    
    b = de_queue(&amp;amp;q, &amp;amp;i);   // 出队
    printf(&quot;出队%s,元素为 %d\n&quot;,b?&quot;成功&quot;:&quot;失败&quot;,i);
    
    b = de_queue(&amp;amp;q, &amp;amp;i);   // 出队
    printf(&quot;出队%s,元素为 %d\n&quot;,b?&quot;成功&quot;:&quot;失败&quot;,i);
    
    tranverce_queue(&amp;amp;q);    //遍历队列
    
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;toc_12&quot;&gt;4. 小结&lt;/h2&gt;
&lt;p&gt;队列主要应用在和时间有关的操作。&lt;/p&gt;
&lt;p&gt;常见的例子如现实生活中排队买票，银行排队处理事情。再如操作系统中执行队列，等待队列。又如我们在编写程序过程中的多线程编程，也需要通过队列来管理线程的访问顺序等。&lt;/p&gt;
&lt;p&gt;文中代码地址：&lt;a href=&quot;https://github.com/xiaoyouPrince/DataStructure&quot;&gt;https://github.com/xiaoyouPrince/DataStructure&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 07:09:00 +0000</pubDate>
<dc:creator>xiaoyouPrince</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoyouPrince/p/8125852.html</dc:identifier>
</item>
<item>
<title>分布式环境下的分片数据导出方法 - 此生重演</title>
<link>http://www.cnblogs.com/cishengchongyan/p/8125127.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cishengchongyan/p/8125127.html</guid>
<description>&lt;p&gt;　　最近提交了一个专利，是基于去年做的一个异步数据导出的项目，抽时间把其中的细节分享出来&lt;/p&gt;
&lt;p&gt;　　数据导出excel的传统方法一般都是先将数据生成到内存中，然后利用excel的一些工具类生成excel文件通过http请求或者ftp返回给用户。但是在数据量很大或者并发量很高的场景中，往往会导致内存飙高或者频繁的FullGC，严重时会导致宕机。如果分批进行导出则导出数据量的大小与用户等待时间成正比，用户体验较差。&lt;/p&gt;
&lt;p&gt;　　我们的初衷就是要解决数据导出造成的内存溢出。本文将介绍一种分布式的分片数据导出方法，解决了系统的内存压力，能支撑大数据量及高并发的数据导出，具有较高的效率及扩展性。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;方案比较&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;方案一：在一台机器中，一个请求使用多个线程进行导出，最终生成excel文件，提高数据导出的效率&lt;/li&gt;
&lt;li&gt;方案二：将用户的查询语句分成多个可执行语句，进行分批导出，同时数据是分批发送给用户&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;　　方案分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　第一种方案中，虽然使用了多线程进行导出，但是数据最终还是需要在内存中转换生成excel文件，这样不能真正解决内存压力问题。&lt;/p&gt;
&lt;p&gt;　　第二种方案中，虽然解决了大数据量的内存问题，但是数据是分批输送给用户的，体验较差，同时不能解决高并发的问题，具有局限性。&lt;/p&gt;
&lt;p&gt;　　同时，现有的方案中，一般都是在一台机器上进行分批导出，本质上都用增加导出时间的方式来缓解内存压力，是一种用时间换空间的方式。用户需要等待较长的时间，体验较差。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;方案细节&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　我们同样也是基于分治的思想，但是采用了分布式的解决方案，将一个大数据的导出分片并分成多个子任务在不同的机器上进行导出，并且数据存储为csv格式文件，可以以追加的方式进行存储&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　希望达到的技术效果：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;解决单点导出的内存压力&lt;/li&gt;
&lt;li&gt;提高导出效率，用户不用等待太久&lt;/li&gt;
&lt;li&gt;具有较高的扩展性，可以不断地提高导出的并发度及数据量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　&lt;strong&gt;方案实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　一方面，数据量很大的情况下，不能将数据全部缓存在内存中，需要分片进行导出；另一方面并发量很大时，一台机器也不能满足需求，需要在分布式环境下分散每台机器的压力，这样就拥有了良好的扩展性。&lt;/p&gt;
&lt;p&gt;　　这种分片及分布式的数据导出方法，用于解决大数据量或高并发场景下数据导出问题，能够减轻系统内存压力，同时具有良好的扩展性。&lt;/p&gt;
&lt;p&gt;　　总体流程如下：&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://images2017.cnblogs.com/blog/1055747/201712/1055747-20171227121928307-1529386975.png&quot; alt=&quot;&quot; width=&quot;718&quot; height=&quot;411&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;p1&quot;&gt; &lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一步：用户向业务系统发出导出http请求；&lt;/li&gt;
&lt;li&gt;第二步：业务系统向导出系统发起一个数据导出的RPC调用；&lt;/li&gt;
&lt;li&gt;第三步：导出系统从各种存储系统（例如数据库、搜索等）中分片获取数据；&lt;/li&gt;
&lt;li&gt;第四步：多台机器分片获取到的数据分别上传到文件存储系统中进行组合；&lt;/li&gt;
&lt;li&gt;第五步：在文件系统中组合成csv文件；&lt;/li&gt;
&lt;li&gt;第六步：用户从文件系统中下载文件；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　&lt;strong&gt;分布式分片导出方法：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2017.cnblogs.com/blog/1055747/201712/1055747-20171227122301479-1569982905.png&quot; alt=&quot;&quot; width=&quot;697&quot; height=&quot;413&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先主任务将数据分片，每个分片是一个子任务；&lt;/li&gt;
&lt;li&gt;将所有子任务分发到不同的机器去并行执行，每台机器可以限制并行的子任务数量，来保证内存压力在可空范围。&lt;/li&gt;
&lt;li&gt;当每台机器的子任务都达到阈值上限之后就会将任务缓存在主任务的阻塞队列中，直到所有任务分发完毕。&lt;/li&gt;
&lt;li&gt;每个子任务拼装当前需要处理的数据，我们并不关心数据从哪里获取，可以从DB、搜索、Hbase等存储获取，同时可以在子任务中处理业务逻辑。然后将处理完的数据上传至文件存储系统中。&lt;/li&gt;
&lt;li&gt;当所有子任务执行完毕之后主任务会向文件存储系统发送请求，将所有的分片合并成csv文件。此时主任务会更新任务状态并获取到文件下载链接。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;　　这种数据导出架构的核心思想有4个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据导出异步化，先用时间换空间&lt;/li&gt;
&lt;li&gt;一个高并发及大数据量场景下的导出可以分而治之，分散内存压力&lt;/li&gt;
&lt;li&gt;子任务（数据分片）分发到不同的机器，一方面分布式环境下均衡内存压力，另一方面用空间换时间&lt;/li&gt;
&lt;li&gt;导出的数据文件可追加，基于流式化的导出&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Wed, 27 Dec 2017 05:40:00 +0000</pubDate>
<dc:creator>此生重演</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cishengchongyan/p/8125127.html</dc:identifier>
</item>
<item>
<title>京东个性化推荐系统实战（上） - 杉枫</title>
<link>http://www.cnblogs.com/freedommovie/p/8125251.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freedommovie/p/8125251.html</guid>
<description>&lt;p&gt;       推荐系统核心任务是排序，从线上服务角度看，就是将数据从给定集合中数据选择出来，选出后根据一定规则策略方法&lt;/p&gt;
&lt;p&gt;进行排序。&lt;/p&gt;
&lt;p&gt;       线上服务要根据一定规则进行架构设计，架构设计是什么？每一次权衡取舍都是设计，设计需要理解需求、深入理解需&lt;/p&gt;
&lt;p&gt;求基础上做权衡取舍。复杂系统架构需要需求方与研发人员反复沟通探讨。这需要技术领导者能理解并鼓励这种行为，才能&lt;/p&gt;
&lt;p&gt;有所谓技术驱动，否则光喊口号不会产生什么所谓的技术驱动。&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://images2017.cnblogs.com/blog/942404/201712/942404-20171227131252198-1047160841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       品类召回配置化，通过对每一个key进行配置管理，配置项包含偏好取得数量以及卡分配置、排序优先级等多个配置项。&lt;/p&gt;
&lt;p&gt;每一个配置生成一个配置对象，配置绑定到一个ABTest算法上。配置管理界面、配置管理服务构成配置管理平台。&lt;/p&gt;

&lt;p&gt;       素材、特征召回配置化，根据分类召回素材，根据用户、分类、素材、设备、季节等多个条件拉取素材。素材与特征全&lt;/p&gt;
&lt;p&gt;部通过配置化进行实现，由人管理配置文件由xml构成、素材、特征召回这两项特点是召回量大，要注意有大量此类偏好数量&lt;/p&gt;
&lt;p&gt;，这种数据获取最好用线程池，设置超时如超时则这次请求有部分数据未请求到，并进行记录。&lt;/p&gt;

&lt;p&gt;       特征上报，为了方便模型组进行模型训练，因为一些数据是比较散的，就是说这种情况下需要对数据进行进行响应处理，&lt;/p&gt;
&lt;p&gt;在进行上报，每一种数据处理方式是不同的，需要对特征进行分类处理。&lt;/p&gt;
&lt;p&gt;      并且为了避免增加新特征或者修改特征就进行上线，这是与模型组探讨，根据需求设计可配置，或者说基于配置文件的&lt;/p&gt;
&lt;p&gt;特征计算。要建立一套与特征归一化相应多种计算规则，以支持多种类型特征配置归一化。&lt;/p&gt;

&lt;p&gt;       分类召回级平台，素材、特征召回级平台，均存在一个配置更新后怎样获取问题。配置更新是一个通用问题，大概存在&lt;/p&gt;
&lt;p&gt;几种方式：一种是配置管理界面更新时更新服务配置信息，一种是定时更新方式，一种是通过通知方式，当有变更时发起更&lt;/p&gt;
&lt;p&gt;新。&lt;/p&gt;
&lt;p&gt;       最简单方式就是，在管理平台修改后进行更新，但现在线上服务多为微服务集群，通过更新管理平台，同时更新多个微&lt;/p&gt;
&lt;p&gt;服务节点不是一种可行方式，在过去单体web系统中是可行的。&lt;/p&gt;
&lt;p&gt;       定时更新方式实现简单，并且能保证比较好一致性，并且就算这次更新集群存在个别节点更新失败，下一次更新也会更&lt;/p&gt;
&lt;p&gt;新成功。但这种方式要注意不要用线上服务定时拉取数据库，因为会导致数据库压力过大，可以采取将数据库节点数据同步&lt;/p&gt;
&lt;p&gt;到redis方式，通过redis来支持定时更新，因redis能支持极大读qps。&lt;/p&gt;
&lt;p&gt;       通知方式最优雅，即观察者模式。观察者订阅事件，事件发生时，各个订阅节点根据事件进行响应操作，当配置更新发&lt;/p&gt;
&lt;p&gt;生时，线上服务节点更新配置到最新，通过Zookeeper可以很容易实现此种配置方式，其实也需要比较懂zookeeper原理与编程。&lt;/p&gt;

&lt;p&gt;      过滤建立职责链进行实现，扩展性强，可读性强。分类过滤，最近购买过分类，分类过滤白名单。过滤包括但不限于用户&lt;/p&gt;
&lt;p&gt;已购买、以曝光。在问答业务上，像我提问我已经回答，构建职责链逻辑清晰易理解。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/942404/201712/942404-20171227131411448-1980277061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       配置化，通过配置文件实现整个逻辑通用化，是小伙伴最初的梦想和模型组构建出来配置化召回素材以及特征架构，很给力。&lt;/p&gt;
&lt;p&gt;通过配置实现对于品类素材特征召回，并且支持分层ABtest,并且配置中包含对特征计算，特征计算主要是上报特征用于模型计算&lt;/p&gt;
&lt;p&gt;，但是有些数据需要进行归一化处理，以方便模型训练使用。并且给人编辑配置文件为xml，通过程序转换成json，并且通过json&lt;/p&gt;
&lt;p&gt;来支持程序使用，能够方便程序进行解析，xml对人友好，json对程序解析友好。&lt;/p&gt;
&lt;p&gt;       特征归一化是特征上报很重要一环，他的特点是情况多，要根据数据分布情况做相应处理，就需要提前归纳总结多种情况，&lt;/p&gt;
&lt;p&gt;因为反射性能差线上服务是接受不了的，就需要提前对数据处理分成几类，提前想好处理逻辑，根据配置项选择相应逻辑进行处理。&lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://images2017.cnblogs.com/blog/942404/201712/942404-20171227131312870-298256458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       上报特征服务、日志白名单服务，上报特征服务将两部分特征进行上报，一部分是简单特征由服务本身进行配置上报，另一部分&lt;/p&gt;
&lt;p&gt;是复杂特征由其他服务计算后调用上报特征服务，两部分合并进行特征上报。&lt;/p&gt;
&lt;p&gt;       日志白名单平台，服务可以配置相应用户信息，并且提供服务支持其他服务上报用户在白名单中进行相应记录，并且提供平台界&lt;/p&gt;
&lt;p&gt;面支持检索。这样可以方便定位线上服务问题，快速解决问题。&lt;/p&gt;
&lt;p&gt;       推荐系统是个复杂系统，由多个模块构成，构建推荐引擎，我们在一步步探索。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/942404/201712/942404-20171227131529708-1787940844.jpg&quot; alt=&quot;扫码关注公众号&quot; width=&quot;150&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;            扫码关注&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 05:18:00 +0000</pubDate>
<dc:creator>杉枫</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freedommovie/p/8125251.html</dc:identifier>
</item>
<item>
<title>在Office Add-in中实现单点登陆（SSO） - 陈希章</title>
<link>http://www.cnblogs.com/chenxizhang/p/8125113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenxizhang/p/8125113.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：陈希章 发表于 2017年12月27日&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这篇文章经过多次修改，终于在今天晚上写完了，演示用的范例代码也终于跑通了。因为这个SSO的功能目前只是Preview的状态，所以本篇文章严格参考了官方的文档，并且对其中的重点环节做了提示，对最终效果做了说明。&lt;/p&gt;
&lt;blockquote readability=&quot;1.4150943396226&quot;&gt;
&lt;p&gt;官方的文档请参考 &lt;a href=&quot;https://docs.microsoft.com/en-us/office/dev/add-ins/develop/sso-in-office-add-ins&quot;&gt;https://docs.microsoft.com/en-us/office/dev/add-ins/develop/sso-in-office-add-ins&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;实现Office Add-in 的单点登录是要解决一个典型问题：已登陆到Office的用户，能否直接利用他自己的身份去访问到Microsoft Graph的资源，而无需再次登录。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;请注意，目前这个功能是Preview的状态。所以要进行测试的话，你必须是某个Office 365 Tenant的全局管理员。如果不具备这个条件，你将无法完成这个实验，但你可以通过这个文章对单点登录流程和效果有一个基本认识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下图是Office Add-in中进行SSO认证的标准流程。这里面涉及到几个部分&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Office 宿主程序。&lt;/li&gt;
&lt;li&gt;Office Add-in&lt;/li&gt;
&lt;li&gt;Office Add-in Service（通常是一个API服务）&lt;/li&gt;
&lt;li&gt;Azure AD V2（请注意，必须是2.0）&lt;/li&gt;
&lt;li&gt;Microsoft Graph&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-27-11-06-55.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-27-11-06-55.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基本流程如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Office Add-in发起一个请求，getAccessTokenAsync。&lt;/li&gt;
&lt;li&gt;Office 宿主程序会向Azure AD 发起一个请求，去获取当前用户的一个所谓的addin token。&lt;/li&gt;
&lt;li&gt;Office Add-in得到这个addin token后，将其发送到Office Add-in Service，并请求Microsoft Graph的资源。请注意，Office Add-in 和 Office Add-in service必须使用同一个域名。&lt;/li&gt;
&lt;li&gt;Office Add-in Service 向Azure AD发起请求，利用addin token交换得到真正的access token。&lt;/li&gt;
&lt;li&gt;Office Add-in Service 利用得到的access token去访问Microsoft Graph，并将结果返回给Office Add-in。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我是完全按照 &lt;a href=&quot;https://docs.microsoft.com/en-us/office/dev/add-ins/develop/create-sso-office-add-ins-aspnet&quot;&gt;这篇文章&lt;/a&gt;进行了实验，并且已经做出来效果。下面我将有关的步骤，尤其是一些要注意的步骤介绍一下。（该文档的部分地方存在一些小问题，我已经提报给作者了）。&lt;/p&gt;
&lt;ol readability=&quot;23.638576779026&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;实验环境。你需要安装最新的Visual Studio 2017和Office 2016（版本1708或者更新）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.32051282051282&quot;&gt;
&lt;p&gt;克隆这个代码库 &lt;a href=&quot;https://github.com/officedev/office-add-in-aspnet-sso&quot;&gt;https://github.com/officedev/office-add-in-aspnet-sso&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在***Completed***目录中找到 &lt;code&gt;Office-Add-in-ASPNET-SSO.sln&lt;/code&gt;，双击打开这个解决方案。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;此时编译解决方案会报错，请运行 &lt;code&gt;Install-Package Microsoft.Identity.Client -IncludePrerelease&lt;/code&gt; 命令安装一个包。再次编译，请确保没有任何错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在 &lt;a href=&quot;https://apps.dev.microsoft.com/&quot;&gt;https://apps.dev.microsoft.com/&lt;/a&gt; 注册一个应用程序，这个步骤比较重要，一定要严格按照说明操作。下面是我注册的信息，请一定要确保保持一致。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-27-11-30-45.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-27-11-30-45.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.83050847457627&quot;&gt;
&lt;p&gt;将上图中的Application ID和Application Secret信息记下来，并且将Application ID的信息替换掉这个地址中的占位符：&lt;a href=&quot;https://login.microsoftonline.com/common/adminconsent?client_id=%7Bapplication_ID%7D&amp;amp;state=12345&quot;&gt;https://login.microsoftonline.com/common/adminconsent?client_id={application_ID}&amp;amp;state=12345&lt;/a&gt; 得到 &lt;a href=&quot;https://login.microsoftonline.com/common/adminconsent?client_id=f7e0154d-1258-42ef-9e89-9857889f4e01&amp;amp;state=12345%E3%80%82&quot;&gt;https://login.microsoftonline.com/common/adminconsent?client_id=f7e0154d-1258-42ef-9e89-9857889f4e01&amp;amp;state=12345。&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;目前来说，要测试这个功能，你必须拥有一个Office 365 Tenant的全局管理员身份。在浏览器中输入上面这个地址，然后提供你的管理员身份，你会收到如下的提示，要你接受授权的请求。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-27-11-39-37.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-27-11-39-37.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;点击“Accept”（有时候可能要两次）后，页面会被重定向到下面的地址。请不要惊慌，因为当前我们的Office Add-in网站没有运行起来，所以确实会报告“无法访问此网站”。在这里，只要将地址栏中的tenant这个查询字符串的信息记下来即可（我的例子是：&lt;code&gt;ca2af238-5e61-4608-8622-797a954c4d65&lt;/code&gt;），后面要用到。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-27-11-42-23.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-27-11-42-23.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;回到Visual Studio 2017里面来，找到 &lt;code&gt;Office-Add-in-ASPNET-SSO-WebAPI&lt;/code&gt; 这个项目中的Web.config文件，在appsettings里面修改几个设置信息。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-27-11-46-04.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-27-11-46-04.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在&lt;code&gt;Office-Add-in-ASPNET-SSO&lt;/code&gt; 这个项目中，找到 &lt;code&gt;Office-Add-in-ASPNET-SSOManifest&lt;/code&gt;这个文件，在最底部，修改WebApplicationInfo这个节的信息如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-27-11-48-46.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-27-11-48-46.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;选择&lt;code&gt;Office-Add-in-ASPNET-SSO&lt;/code&gt; 这个项目，在右键菜单中选择“发布”，然后新建一个配置文件：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-27-11-51-03.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-27-11-51-03.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后点击“打包外接程序”按钮&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-27-11-52-38.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-27-11-52-38.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;输入当前本地调试用的网址后点击“完成”，你将得到一个可以用于部署的清单文件&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-27-11-53-52.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-27-11-53-52.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;利用清单文件加载该Add-in。这个Add-in是用于PowerPoint的，它的详细代码我这里就不展开了，它实现了一个简单的功能用来读取当前用户的OneDrive for Business中的文件列表信息。&lt;/p&gt;
&lt;p&gt;我的实验环境中，当前用户的OneDrive for Business中有如下的文件：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-27-11-58-01.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-27-11-58-01.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请在Visual Studio中将“Office-Add-in-ASPNET-SSO-WebAPI”这个项目运行起来，然后通过PowerPoint Online创建一个演示文档，在菜单中选择“插入”=》“Office 加载项”，然后选择“上载我的加载项”，选择上一步骤中生成的XML文件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-27-12-00-54.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-27-12-00-54.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后你可以在工具栏中看到一个新的按钮，点击之后可以显示一个任务面板&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-27-12-04-19.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-27-12-04-19.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后，激动人心的时刻终于要到了。点击任务面板中的“Get My Files From OneDrive”按钮，你将在任务面板的下方看到OneDrive for Business中的文件列表信息。&lt;/p&gt;
&lt;p&gt;当然，很多时候，我也发现会遇到如下的错误。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chenxizhang/office365dev/blob/master/docs/images/2017-12-27-12-07-21.png&quot;&gt;&lt;img alt=&quot;&quot; src=&quot;https://github.com/chenxizhang/office365dev/raw/master/docs/images/2017-12-27-12-07-21.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文对于最新的Office Add-in中实现单点登录（SSO）的方案进行了讲解，并且将配套的实例进行了测试。由于当前这个功能还是非常早期的阶段，所以可能你在做实验的时候，也会遇到这样那样的问题。如果遇到，可以给我留言。我过一阵子会继续关注一下这个功能的进展，给大家更新。&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 04:13:00 +0000</pubDate>
<dc:creator>陈希章</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenxizhang/p/8125113.html</dc:identifier>
</item>
<item>
<title>开源组件NanUI一周年 - 使用HTML/CSS/JS来构建.Net Winform应用程序界面 - 林选臣</title>
<link>http://www.cnblogs.com/linxuanchen/p/NanUI-Introduction.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linxuanchen/p/NanUI-Introduction.html</guid>
<description>&lt;h2 id=&quot;nanui是什么&quot;&gt;NanUI是什么&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://netdimension.github.io/NanUI/&quot;&gt;NanUI&lt;/a&gt;基于ChromiumFX项目进行开发，它能让你在你的Winform应用程序中使用HTML5/CSS3/Javascript等网页技术来呈现用户界面（类似Electron）。同时NanUI提供了原生窗口和定制化的无标题栏无边框窗口，你能使用全部的网页技术来设计和呈现你的应用程序界面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20171226150643379&quot; alt=&quot;NanUI&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;开源方式&quot;&gt;开源方式&lt;/h2&gt;
&lt;p&gt;NanUI基于MIT协议，所以无论你使用NanUI来开发商业项目或者开源、免费项目都将不受任何限制，只需要遵照&lt;a href=&quot;https://github.com/NetDimension/NanUI/blob/master/LICENSE&quot;&gt;协议文件&lt;/a&gt;中规定的，在你的软件中声明使用了NanUI技术即可。&lt;/p&gt;
&lt;h2 id=&quot;系列文档&quot;&gt;系列文档&lt;/h2&gt;
&lt;h2 id=&quot;源码和包&quot;&gt;源码和包&lt;/h2&gt;
&lt;p&gt;你可以通过GitHub获取NanUI的源码以及示例代码，稳定版的NanUI包通过Nuget进行分发。NanUI支持.NET4.0/4.5/4.6/4.7和更新版本的Windows窗体应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取源码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/NetDimension/NanUI.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Nuget包管理器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常规版本（&lt;em&gt;CEF 3.2987.1601.gf035232 / Chromium 57.0.2987.133&lt;/em&gt;）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;PM&amp;gt;&lt;/span&gt; Install-Package NetDimension.NanUI&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;WindowXP版本（&lt;em&gt;CEF 3.2526.1366.g8617e7c / Chromium 47.0.2526.80&lt;/em&gt;）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode bash&quot;&gt;
&lt;code class=&quot;sourceCode bash&quot;&gt;&lt;span class=&quot;kw&quot;&gt;PM&amp;gt;&lt;/span&gt; Install-Package NetDimension.NanUI.XP&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;推荐使用Nuget包管理器安装NanUI程序集将自动安装对应的CEF依赖项，一键安装方便使用。&lt;/p&gt;
&lt;h2 id=&quot;如何编译源码和示例&quot;&gt;如何编译源码和示例&lt;/h2&gt;
&lt;p&gt;编译当前版本的NanUI需要支持C#7.0语法的编译器，推荐的编译工具有且只有Visual Studio 2017。&lt;/p&gt;
&lt;h2 id=&quot;如何使用&quot;&gt;如何使用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;初始化NanUI&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;namespace TestApplication
{
    using NetDimension.NanUI;
    static class Program
    {
        [STAThread]
        static void Main(string[] args)
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);

            //初始化CEF: 设置CEF的相关Path
            //如果要使用Nuget自动下载的fx文件夹结构，需要手动指定各个文件夹的路径

            var result = Bootstrap.Load(PlatformArch.Auto, System.IO.Path.Combine(Application.StartupPath, &quot;fx&quot;), System.IO.Path.Combine(Application.StartupPath, &quot;fx\\Resources&quot;), System.IO.Path.Combine(Application.StartupPath, &quot;fx\\Resources\\locales&quot;));
            
            if (result)
            {
                // Load embedded html/css resources in assembly.
                Bootstrap.RegisterAssemblyResources(System.Reflection.Assembly.GetExecutingAssembly());

                Application.Run(new Form1());

                Application.Exit();
            }

        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用原生的窗口样式来使用NanUI&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;namespace TestApplication
{
    public partial class Form1 : Formium

    {

        public Form1()
            //Load embedded resource index.html and not set form to no border style by the second parameter.
            : base(&quot;http://res.app.local/index.html&quot;, false)
        {
            InitializeComponent();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用无边框模式来使用NanUI&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;namespace TestApplication
{
    public partial class Form1 : Formium

    {

        public Form1()
            //Load embedded resource index.html and set form to no border style by igrone the second parameter or set it to true.
            : base(&quot;http://res.app.local/index.html&quot;)
        {
            InitializeComponent();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;请注意：&lt;/strong&gt;如果使用Visual Studio 2015或者更低的版本开发和调试NanUI应用程序，需要在项目属性的调试选项卡中关闭“启用VS承载进程”选项，否则调试时将出现&lt;strong&gt;页面不加载&lt;/strong&gt;白屏的情况。如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/352785/201605/352785-20160519162319279-154556205.png&quot; alt=&quot;调试设置&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;社群和帮助&quot;&gt;社群和帮助&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;GitHub&lt;/strong&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/NetDimension/NanUI/&quot; class=&quot;uri&quot;&gt;https://github.com/NetDimension/NanUI/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交流群QQ群&lt;/strong&gt;&lt;br/&gt;521854872&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;赞助作者&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你喜欢我的工作，并且希望NanUI持续的发展，请对NanUI项目进行捐助以此来鼓励和支持我继续NanUI的开发工作。你可以使用&lt;strong&gt;微信&lt;/strong&gt;或者&lt;strong&gt;支付宝&lt;/strong&gt;来扫描下面的二维码进行捐助。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ohtrip.cn/media/beg_with_border.png&quot; alt=&quot;Screen Shot&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 04:01:00 +0000</pubDate>
<dc:creator>林选臣</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linxuanchen/p/NanUI-Introduction.html</dc:identifier>
</item>
<item>
<title>带你深度解析Maven - Hafiz.Zhang</title>
<link>http://www.cnblogs.com/hafiz/p/8119964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hafiz/p/8119964.html</guid>
<description>&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;一、What`s Maven?&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　Maven是基于项目对象模型(POM project object model)，可以通过一小段描述信息（配置）来管理项目的构建，报告和文档的软件项目管理工具，简单的说就是用来管理项目所需要的依赖且管理项目构建的工具。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;二、Maven的优势&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　1. 约定优于配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　2. 简单&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　3. 测试支持&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　4. 构建简单&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　5. CI集成&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　6. 插件丰富&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;三、Maven的安装、配置&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　1. 在官网下载安装包：&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://maven.apache.org/download.cgi&quot;&gt;&lt;span&gt;http://maven.apache.org/download.cgi&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　2. 解压缩压缩包&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　3. 配置环境变量MAVEN_HOME=maven的解压后的目录&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　4. 在变量Path的开头增加&quot;%MAVEN_HOME%\bin;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　5. 在MAVEN_HOME/conf/setting.xml文件中通过&amp;lt;localRepository&amp;gt;&amp;lt;/localRepository&amp;gt;标签配置本地仓库的位置&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;strong&gt;　　注&lt;/strong&gt; ：超级pom.xml的位置：MAVEN_HOME/lib/maven-model-build-3.3.9.jar/org/apache/maven/model/pom-4.0.0.xml&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;四、Maven的使用&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;1. 输出本地安装的maven的相关信息&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
mvn -version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;2. 在IDEA中配置使用本地安装的maven&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;打开： File--&amp;gt;Settings, 然后按照下图操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/894443/201712/894443-20171227094712510-1905476014.png&quot; alt=&quot;&quot; width=&quot;825&quot; height=&quot;499&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;3. 控制台使用maven命令，配置文件加载顺序&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　1) &lt;span class=&quot;md-line md-end-block&quot;&gt;~/.m2/setting.xml&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　2) &lt;span class=&quot;md-line md-end-block&quot;&gt;MAVEN_HOME/conf/setting.xml&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;五、配置Maven镜像加快依赖下载速度&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;mirrors&amp;gt;
  &amp;lt;mirror&amp;gt;
    &amp;lt;id&amp;gt;aliyun_cental&amp;lt;/id&amp;gt;
    &amp;lt;name&amp;gt;aliyun_cental&amp;lt;/name&amp;gt;
    &amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/groups/public/&amp;lt;/url&amp;gt;
    &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;
  &amp;lt;/mirror&amp;gt;
  &amp;lt;mirror&amp;gt;
    &amp;lt;id&amp;gt;uk&amp;lt;/id&amp;gt;
    &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;
    &amp;lt;name&amp;gt;Human Readable Name for this Mirror.&amp;lt;/name&amp;gt;
    &amp;lt;url&amp;gt;http://uk.maven.org/maven2&amp;lt;/url&amp;gt;
  &amp;lt;/mirror&amp;gt;
  &amp;lt;mirror&amp;gt;
    &amp;lt;id&amp;gt;osc&amp;lt;/id&amp;gt;
    &amp;lt;name&amp;gt;Human Readable Name for this Mirror&amp;lt;/name&amp;gt;
    &amp;lt;url&amp;gt;http://maven.oschina.net:/content/groups/public/&amp;lt;/url&amp;gt;
    &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;
  &amp;lt;/mirror&amp;gt;
  &amp;lt;mirror&amp;gt;
    &amp;lt;id&amp;gt;osc_thirdparty&amp;lt;/id&amp;gt;
    &amp;lt;mirrorOf&amp;gt;thirdparty&amp;lt;/mirrorOf&amp;gt;
    &amp;lt;url&amp;gt;http://maven.oschina.net/content/repositories/thirdparty/&amp;lt;/url&amp;gt;
  &amp;lt;/mirror&amp;gt;
&amp;lt;/mirrors&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;具体请移步另一篇博客：&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl06_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/hafiz/p/7566983.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;只用一招,让你Maven依赖下载速度快如闪电&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;六、认识Maven的结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;1. maven项目结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;    &lt;img src=&quot;https://images2018.cnblogs.com/blog/894443/201712/894443-20171226203111338-1292802651.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;    src/main/java : 项目java类文件位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;    src/main/resources : 项目配置资源文件位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;    src/test/java : 项目单元测试java类文件位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;    src/test/resources : 项目单元测试配置资源文件位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;    target : 项目打包后文件所在位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;2. setting.xml元素解读: &lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/yangxia-test/p/4409736.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/yangxia-test/p/4409736.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;3. pom.xml元素解读: &lt;strong&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/hafiz/p/5360195.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;h&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;ttp://www.cnblogs.com/hafiz/p/5360195.html&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;七、Maven的坐标、依赖&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;1. 坐标：maven通过groupId、artifactId、version三个变量来唯一确定一个具体的依赖（俗称GAV）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;2. 依赖：在pom.xml中我们通过dependency来声明坐标信息(GAV)如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-core&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;4.2.6.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;　　这样我们就在项目中依赖了4.2.6.RELEASE版本的spring-core jar包.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;strong&gt;　　注&lt;/strong&gt; ：&lt;strong&gt;pom.xml中packaging用来指定打包方式，默认为：jar&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;3. dependencyManagementy&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　1) &lt;span class=&quot;md-line md-end-block&quot;&gt;只能出现在父pom里&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　2) &lt;/span&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;统一版本号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　3) &lt;/span&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;只是依赖声明，并不直接依赖，需要时在子项目中在声明要使用依赖的GA信息，V信息可以省略.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;4. 依赖scope&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　1) compile：编译依赖范围，在编译，测试，运行时都需要，依赖范围默认值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　2) test：测试依赖范围，测试时需要。编译和运行不需要，如junit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　3) provided：已提供依赖范围，编译和测试时需要。运行时不需要,如servlet-api&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　4) runtime：运行时依赖范围，测试和运行时需要。编译不需要,例如面向接口编程，JDBC驱动实现jar&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　5) system：系统依赖范围。本地依赖，不在maven中央仓库，结合systemPath标签使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;5. 依赖传递时仲裁原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　1) 路径最短原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　2) 路径一样长,加载先后原则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/894443/201712/894443-20171226203806729-895948102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;　　注&lt;/strong&gt;&lt;span class=&quot;md-expand&quot;&gt; ： 第一列表示直接依赖的scope,第一行表示间接依赖的scope&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt; 6. 依赖排除&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;　　使用&lt;span class=&quot;md-tag&quot;&gt;&amp;lt;exclusions&amp;gt;&lt;span&gt;标签下的&lt;span class=&quot;md-tag&quot;&gt;&amp;lt;exclusion&amp;gt;&lt;span&gt;标签指定GA信息来排除，例如：排除xxx.jar传递依赖过来的yyy.jar&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.xxx&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;xxx&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;x.version&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;exclusions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;exclusion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.xxx&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;yyy&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;exclusion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;exclusions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7. 依赖关系查看&lt;/p&gt;
&lt;p&gt;进入工程根目录，在cmd中运行&lt;/p&gt;
&lt;p&gt;　　1) &lt;span class=&quot;md-expand&quot;&gt;&lt;code&gt;mvn dependency:tree&lt;/code&gt; &lt;span class=&quot;md-expand&quot;&gt;命令会列出依赖关系树及各级依赖关系&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　2) &lt;span class=&quot;md-expand&quot;&gt;&lt;code&gt;mvn dependency:analyze&lt;/code&gt; &lt;span class=&quot;md-expand&quot;&gt;分析依赖关系&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;八、版本管理&lt;/h3&gt;
&lt;p&gt;　　尽量使用语义化版本，方便团队协作，后面我们专门写一篇文章来说语义化版本。&lt;/p&gt;
&lt;p&gt;　　Maven中的版本号中带SNAPSHOT和不带的区别以及作用请移步：&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/hafiz/p/8124741.html&quot;&gt;&lt;span&gt;Maven版本号中隐藏的惊天大秘密&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;九、生命周期、插件&lt;/h3&gt;
&lt;p&gt;1. 生命周期&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;　　A build lifecycle is made up of phases.&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;　　A build phases is made up of plugin goals.&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/894443/201712/894443-20171226204414713-1538169023.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;　　1) clean(按顺序分别包括：pre-clean 、clean 、post-clean)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;　　2) &lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;default(compile、package、install、deploy ...)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　3) site(又包括：pre-site、site、post-site、site-deploy)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;2. 插件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　请移步另一篇文章：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;十、自定义手写Maven的项目骨架&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　请移步另外一篇文章：&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl08_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/hafiz/p/5515388.html&quot;&gt;&lt;span&gt;手写Maven的archetype项目脚手架&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;十一、总结&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;md-line md-end-block&quot;&gt;&lt;span&gt;　　通过本文，我们就对maven有了一个直观深入的了解和学习，通过maven我们可以进行自己的定制和开发。这是工程化的第一步，我们继续加油，下一步解析Git和Jenkins.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 03:38:00 +0000</pubDate>
<dc:creator>Hafiz.Zhang</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hafiz/p/8119964.html</dc:identifier>
</item>
<item>
<title>不可思议的混合模式 background-blend-mode - ChokCoco</title>
<link>http://www.cnblogs.com/coco1s/p/8124815.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coco1s/p/8124815.html</guid>
<description>&lt;p&gt;&lt;span&gt;本文接前文：&lt;a href=&quot;https://github.com/chokcoco/iCSS/issues/16&quot;&gt;不可思议的混合模式 mix-blend-mode&lt;/a&gt; 。由于 &lt;code&gt;mix-blend-mode&lt;/code&gt; 这个属性的强大，很多应用场景和动效的制作不断完善和被发掘出来，遂另起一文继续介绍一些使用 &lt;code&gt;mix-blend-mode&lt;/code&gt; 制作的酷炫动画。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CSS3 新增了一个很有意思的属性 -- &lt;code&gt;mix-blend-mode&lt;/code&gt; ，其中 mix 和 blend 的中文意译均为混合，那么这个属性的作用直译过来就是混合混合模式，当然，我们我们通常称之为混合模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;混合模式最常见于 photoshop 中，是 PS 中十分强大的功能之一。当然，瞎用乱用混合模式谁都会，利用混合模式将多个图层混合得到一个新的效果，只是要用到恰到好处，或者说在 CSS 中利用混合模式制作出一些效果则需要对混合模式很深的理解及不断的尝试。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;mix-blend-mode 简介&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;关于 &lt;code&gt;mix-blend-mode&lt;/code&gt; 最基本的用法和描述，可以简单看看上篇文章 &lt;a href=&quot;https://github.com/chokcoco/iCSS/issues/16&quot;&gt;不可思议的混合模式 mix-blend-mode&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;background-blend-mode 简介&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;除了 &lt;code&gt;mix-blend-mode&lt;/code&gt; ，CSS 还提供一个 &lt;code&gt;background-blend-mode&lt;/code&gt; 。也就是背景的混合模式。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;可以是背景图片与背景图片的混合，&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;也可以是背景图片和背景色的之间的混合。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;code&gt;background-blend-mode&lt;/code&gt; 的可用取值与 &lt;code&gt;mix-blend-mode&lt;/code&gt;一样，不重复介绍，下面直接进入应用阶段。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;background-blend-mode 基础应用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;对于 &lt;code&gt;background-blend-mode&lt;/code&gt; ，最简单的应用就是将两个或者多个图片利用混合模式叠加在一起。假设我们存在下述两张图片，可以利用背景混合模式 &lt;code&gt;background-blend-mode&lt;/code&gt; 叠加在一起：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/34369102-3ea353ac-eaf4-11e7-9d27-f7d28c6a66f6.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/34369102-3ea353ac-eaf4-11e7-9d27-f7d28c6a66f6.jpg&quot; alt=&quot;person&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/34369175-c14ae23e-eaf4-11e7-96f1-e146e5e5a96b.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/34369175-c14ae23e-eaf4-11e7-96f1-e146e5e5a96b.jpg&quot; alt=&quot;timg&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过背景混合模式 &lt;code&gt;background-blend-mode:lighten&lt;/code&gt; 处理之后：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/34369251-38f9199a-eaf5-11e7-84a2-613e947129ca.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/34369251-38f9199a-eaf5-11e7-84a2-613e947129ca.png&quot; alt=&quot;image&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://codepen.io/Chokcoco/pen/OzWvNN&quot; rel=&quot;nofollow&quot;&gt;CodePen Demo -- image mix by bg-blend-mode&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然，这里使用的是 &lt;code&gt;background-blend-mode:lighten&lt;/code&gt; 变亮这个混合模式，核心代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;div class=&quot;container&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.container {
    background: url($pic1), url($pic2);
    background-size: cover;
    background-blend-mode: lighten;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们可以尝试其他的组合，也就是改变 &lt;code&gt;background-blend-mode&lt;/code&gt; 的各种取值，将会得到各种不同的感官效果。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;使用 &lt;code&gt;background-blend-mode: difference&lt;/code&gt; 制作黑白反向动画&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;黑色白色这两种颜色，无疑是使用频率最高也是我认为最搭的两个颜色。当这两种颜色结合在一起，总是能碰撞出不一样的火花。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扯远了，借助 &lt;code&gt;difference&lt;/code&gt; 差值混合模式，配合黑白 GIF，能产生奇妙的效果，假设我们拥有这样一张 GIF 图（图片来自网络，侵删）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/34104896-4442e35e-e42d-11e7-80e8-3cf98219f23d.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/34104896-4442e35e-e42d-11e7-80e8-3cf98219f23d.gif&quot; alt=&quot;timg&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;利用 &lt;code&gt;background-blend-mode: difference&lt;/code&gt; ，将它叠加到不同的黑白背景之下（黑白背景由 CSS 画出来）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/34106100-e14b865c-e431-11e7-8419-ed58fa1479e3.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/34106100-e14b865c-e431-11e7-8419-ed58fa1479e3.png&quot; alt=&quot;image&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;产生的效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/34141560-07988702-e4bd-11e7-96bc-e3ae8e931230.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/34141560-07988702-e4bd-11e7-96bc-e3ae8e931230.gif&quot; alt=&quot;bg-gif&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;通过混合渐变背景色，配合 Hover 效果，我们可以给这些图配上一些我们想要的色彩：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/34238979-8f4b598a-e63f-11e7-84e8-10d5ccf2bcba.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/34238979-8f4b598a-e63f-11e7-84e8-10d5ccf2bcba.gif&quot; alt=&quot;bgblendmodehover&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;代码非常简单，示意如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.pic {
    background: url($img),
        linear-gradient(#f00, #00f);
    background-size: cover, 100% 100%;
    background-position: 0 0, -300px 0;
    background-blend-mode: luminosity;
    background-repeat: no-repeat;
    transition: .5s background-position linear;
}

.pic:hover { 
    background-position: 0 0, 0 0; 
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里有几点需要注意的：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;这里使用了背景色渐变动画，&lt;a href=&quot;https://github.com/chokcoco/iCSS/issues/10&quot;&gt;背景色的渐变动画&lt;/a&gt;有几种方式实现（戳这里了解更多方法），这里使用的是位移 &lt;code&gt;background-position&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;实现上述效果使用的 &lt;code&gt;background-blend-mode&lt;/code&gt; 不限制具体某一种混合模式，可以自己多尝试&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;span&gt;使用 mix-blend-mode || background-blend-mode 改变图标的颜色&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果再运用上一篇文章介绍的知识 &lt;a href=&quot;https://github.com/chokcoco/iCSS/issues/32&quot;&gt;两行 CSS 代码实现图片任意颜色赋色技术&lt;/a&gt; ，我们可以实现 ICON 的颜色的动态改变。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设我们有这样一张 ICON 图，注意主色是黑色，底色的白色（底色不是透明色），所以符合要求的 JPG、PNG、GIF 图都可以：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/34350345-4812d23a-ea51-11e7-98eb-461188ce9125.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/34350345-4812d23a-ea51-11e7-98eb-461188ce9125.png&quot; alt=&quot;iconmonstr-cursor-31&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;利用 &lt;code&gt;background-blend-mode: lighten&lt;/code&gt; 可以实现动态改变图标主色的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/34350563-702857ee-ea52-11e7-89fc-5f298ccef692.gif&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/34350563-702857ee-ea52-11e7-89fc-5f298ccef692.gif&quot; alt=&quot;bgblendhover&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而且这里的具体颜色（渐变、纯色皆可），动画方向都可以可以随意控制的。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;这里我们使用 &lt;code&gt;mix-blend-mode&lt;/code&gt; 也能够轻易实现，我们只需要构造出黑色文字，白色底色的文字 div ，叠加上图片，再运用 &lt;code&gt;mix-blend-mode&lt;/code&gt; 即可，简单原理如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://user-images.githubusercontent.com/8554143/34352651-d2081074-ea5e-11e7-901f-90e6dcfe0c3c.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/8554143/34352651-d2081074-ea5e-11e7-901f-90e6dcfe0c3c.png&quot; alt=&quot;image&quot;/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;核心代码如下，可以看看：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-text-html-basic&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
&amp;lt;div class=&quot;container&quot;&amp;gt;
    &amp;lt;div class=&quot;pic&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;text&quot;&amp;gt;IMAGE&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;highlight highlight-source-css&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
.pic {
    position: relative;
    width: 100%;
    height: 100%;
    background: url($img);
    background-repeat: no-repeat;
    background-size: cover;
}

.text {
    position: absolute;
    width:100%;
    height:100%;
    color: #000;
    mix-blend-mode: lighten;
    background-color: #fff;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;好了，本文到此结束，希望对你有帮助 :)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果还有什么疑问或者建议，可以多多交流，原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Dec 2017 03:22:00 +0000</pubDate>
<dc:creator>ChokCoco</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coco1s/p/8124815.html</dc:identifier>
</item>
</channel>
</rss>