<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>NFS PersistentVolume - 每天5分钟玩转 Docker 容器技术（151） - CloudMan</title>
<link>http://www.cnblogs.com/CloudMan6/p/8721078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CloudMan6/p/8721078.html</guid>
<description>&lt;p&gt;&lt;span&gt;上一节我们介绍了 PV 和 PVC，本节通过 NFS 实践。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;作为准备工作，我们已经在 k8s-master 节点上搭建了一个 NFS 服务器，目录为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/nfsdata&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180405070522794-874127244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;下面创建一个 PV &lt;/span&gt;&lt;code&gt;&lt;span&gt;mypv1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，配置文件 &lt;/span&gt;&lt;code&gt;&lt;span&gt;nfs-pv1.yml&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180405070535040-475570166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;① &lt;/span&gt;&lt;code&gt;&lt;span&gt;capacity&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指定 PV 的容量为 1G。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;② &lt;/span&gt;&lt;code&gt;&lt;span&gt;accessModes&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指定访问模式为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ReadWriteOnce&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，支持的访问模式有：&lt;br/&gt;ReadWriteOnce – PV 能以 read-write 模式 mount 到单个节点。&lt;br/&gt;ReadOnlyMany – PV 能以 read-only 模式 mount 到多个节点。&lt;br/&gt;ReadWriteMany – PV 能以 read-write 模式 mount 到多个节点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;③ &lt;/span&gt;&lt;code&gt;&lt;span&gt;persistentVolumeReclaimPolicy&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指定当 PV 的回收策略为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Recycle&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，支持的策略有：&lt;br/&gt;Retain – 需要管理员手工回收。&lt;br/&gt;Recycle – 清除 PV 中的数据，效果相当于执行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;rm -rf /thevolume/*&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;br/&gt;Delete – 删除 Storage Provider 上的对应存储资源，例如 AWS EBS、GCE PD、Azure Disk、OpenStack Cinder Volume 等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;④ &lt;/span&gt;&lt;code&gt;&lt;span&gt;storageClassName&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指定 PV 的 class 为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;nfs&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。相当于为 PV 设置了一个分类，PVC 可以指定 class 申请相应 class 的 PV。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;⑤ 指定 PV 在 NFS 服务器上对应的目录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;创建 &lt;/span&gt;&lt;code&gt;&lt;span&gt;mypv1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180405070547488-1220449836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;&lt;span&gt;STATUS&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Available&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，表示 &lt;/span&gt;&lt;code&gt;&lt;span&gt;mypv1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 就绪，可以被 PVC 申请。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;接下来创建 PVC &lt;/span&gt;&lt;code&gt;&lt;span&gt;mypvc1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，配置文件 &lt;/span&gt;&lt;code&gt;&lt;span&gt;nfs-pvc1.yml&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180405070601362-1456449500.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PVC 就很简单了，只需要指定 PV 的容量，访问模式和 class。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;创建 &lt;/span&gt;&lt;code&gt;&lt;span&gt;mypvc1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180405070611724-960848240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl get pvc&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;kubectl get pv&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的输出可以看到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;mypvc1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 已经 Bound 到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;mypv1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，申请成功。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;接下来就可以在 Pod 中使用存储了，Pod 配置文件 &lt;/span&gt;&lt;code&gt;&lt;span&gt;pod1.yml&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180405070621990-60738088.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;与使用普通 Volume 的格式类似，在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;volumes&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;persistentVolumeClaim&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指定使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;mypvc1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 申请的 Volume。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;创建 &lt;/span&gt;&lt;code&gt;&lt;span&gt;mypod1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180405070638960-758477768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;验证 PV 是否可用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/775365/201804/775365-20180405070651774-1312980319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;可见，在 Pod 中创建的文件 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/mydata/hello&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 确实已经保存到了 NFS 服务器目录 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/nfsdata/pv1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果不再需要使用 PV，可用删除 PVC 回收 PV，下节我们详细讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;书籍：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.《每天5分钟玩转Kubernetes》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/26225745440.html&quot;&gt;https://item.jd.com/26225745440.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.《每天5分钟玩转Docker容器技术》&lt;br/&gt;&lt;a href=&quot;https://item.jd.com/16936307278.html&quot;&gt;https://item.jd.com/16936307278.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.《每天5分钟玩转OpenStack》&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;a href=&quot;https://item.jd.com/12086376.html&quot;&gt;https://item.jd.com/12086376.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img title=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; src=&quot;https://i.imgsafe.org/68/68da21ce15.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Apr 2018 21:25:00 +0000</pubDate>
<dc:creator>CloudMan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CloudMan6/p/8721078.html</dc:identifier>
</item>
<item>
<title>IdentityServer4实战 - 基于角色的权限控制及Claim详解 - 晓晨Master</title>
<link>http://www.cnblogs.com/stulzq/p/8726002.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stulzq/p/8726002.html</guid>
<description>&lt;h2 id=&quot;一.前言&quot;&gt;一.前言&lt;/h2&gt;
&lt;p&gt;大家好，许久没有更新博客了，最近从重庆来到了成都，换了个工作环境，前面都比较忙没有什么时间，这次趁着清明假期有时间，又可以分享一些知识给大家。在QQ群里有许多人都问过IdentityServer4怎么用Role(角色)来控制权限呢？还有关于Claim这个是什么呢？下面我带大家一起来揭开它的神秘面纱！&lt;/p&gt;
&lt;h2 id=&quot;二.claim详解&quot;&gt;二.Claim详解&lt;/h2&gt;
&lt;p&gt;我们用过IdentityServer4或者熟悉ASP.NET Core认证的都应该知道有Claim这个东西，Claim我们通过在线翻译有以下解释：&lt;/p&gt;
&lt;p&gt;（1）百度翻译&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201804/668104-20180406013401403-687068849.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）谷歌翻译&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201804/668104-20180406013414153-1218383096.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我理解为&lt;code&gt;声明&lt;/code&gt;，我们每个用户都有多个Claim，每个Claim声明了用户的某个信息比如：Role=Admin，UserID=1000等等，这里Role，UserID每个都是用户的Claim，都是表示用户信息的&lt;code&gt;单元&lt;/code&gt; ，我们不妨把它称为&lt;code&gt;用户信息单元&lt;/code&gt; 。&lt;/p&gt;
&lt;blockquote readability=&quot;2.4705882352941&quot;&gt;
&lt;p&gt;建议阅读杨总的Claim相关的解析 &lt;a href=&quot;http://www.cnblogs.com/savorboard/p/aspnetcore-identity.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/savorboard/p/aspnetcore-identity.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三.测试环境中添加角色claim&quot;&gt;三.测试环境中添加角色Claim&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里我们使用IdentityServer4的QuickStart中的第二个Demo：&lt;code&gt;ResourceOwnerPassword&lt;/code&gt;来进行演示（代码地址放在文末）,所以项目的创建配置就不在这里演示了。&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201804/668104-20180406013435113-764124936.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里我们需要自定义IdentityServer4(后文简称id4)的验证逻辑，然后在验证完毕之后，将我们自己需要的Claim加入验证结果。便可以向API资源服务进行传递。id4定义了&lt;code&gt;IResourceOwnerPasswordValidator&lt;/code&gt;接口，我们实现这个接口就行了。&lt;/p&gt;
&lt;p&gt;Id4为我们提供了非常方便的In-Memory测试支持，那我们在In-Memory测试中是否可以实现自定义添加角色Claim呢，答案当时是可以的。&lt;/p&gt;
&lt;p&gt;1.首先我们需要在定义&lt;code&gt;TestUser&lt;/code&gt;测试用户时，定义用户Claims属性，意思就是为我们的测试用户添加额外的身份信息单元，这里我们添加角色身份信息单元：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;new TestUser
{
    SubjectId = &quot;1&quot;,
    Username = &quot;alice&quot;,
    Password = &quot;password&quot;,
    Claims = new List&amp;lt;Claim&amp;gt;(){new Claim(JwtClaimTypes.Role,&quot;superadmin&quot;) }
},
new TestUser
{
    SubjectId = &quot;2&quot;,
    Username = &quot;bob&quot;,
    Password = &quot;password&quot;,
    Claims = new List&amp;lt;Claim&amp;gt;(){new Claim(JwtClaimTypes.Role,&quot;admin&quot;) }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;JwtClaimTypes&lt;/code&gt;是一个静态类在IdentityModel程序集下，里面定义了我们的jwt token的一些常用的Claim，JwtClaimTypes.Role是一个常量字符串&lt;code&gt;public const string Role = &quot;role&quot;;&lt;/code&gt;如果&lt;code&gt;JwtClaimTypes&lt;/code&gt;定义的Claim类型没有我们需要的，那我们直接写字符串即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.分别启动 QuickstartIdentityServer、Api、ResourceOwnerClient 查看 运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201804/668104-20180406013518485-515635134.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看见我们定义的API资源通过&lt;code&gt;HttpContext.User.Claims&lt;/code&gt;并没有获取到我们为测试用户添加的Role Claim，那是因为我们为API资源做配置。&lt;/p&gt;
&lt;p&gt;3.配置API资源需要的Claim&lt;/p&gt;
&lt;p&gt;在QuickstartIdentityServer项目下的&lt;code&gt;Config&lt;/code&gt;类的&lt;code&gt;GetApiResources&lt;/code&gt;做出如下修改：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static IEnumerable&amp;lt;ApiResource&amp;gt; GetApiResources()
{
    return new List&amp;lt;ApiResource&amp;gt;
    {
//                new ApiResource(&quot;api1&quot;, &quot;My API&quot;)
        new ApiResource(&quot;api1&quot;, &quot;My API&quot;,new List&amp;lt;string&amp;gt;(){JwtClaimTypes.Role})
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们添加了一个Role Claim，现在再次运行（需要重新QuickstartIdentityServer方可生效）查看结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201804/668104-20180406013537624-747904290.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，我们的API服务已经成功获取到了Role Claim。&lt;/p&gt;
&lt;p&gt;这里有个疑问，为什么需要为APIResource配置Role Claim，我们的API Resource才能获取到呢，我们查看&lt;code&gt;ApiResource&lt;/code&gt;的源码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public ApiResource(string name, string displayName, IEnumerable&amp;lt;string&amp;gt; claimTypes)
{
    if (name.IsMissing()) throw new ArgumentNullException(nameof(name));

    Name = name;
    DisplayName = displayName;

    Scopes.Add(new Scope(name, displayName));

    if (!claimTypes.IsNullOrEmpty())
    {
        foreach (var type in claimTypes)
        {
            UserClaims.Add(type);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的代码可以分析出，我们自定义的Claim添加到了一个名为&lt;code&gt;UserClaims&lt;/code&gt;的属性中，查看这个属性：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// List of accociated user claims that should be included when this resource is requested.
/// &amp;lt;/summary&amp;gt;
public ICollection&amp;lt;string&amp;gt; UserClaims { get; set; } = new HashSet&amp;lt;string&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据注释我们便知道了原因：请求此资源时应包含的相关用户身份单元信息列表。&lt;/p&gt;
&lt;h2 id=&quot;四.通过角色控制api访问权限&quot;&gt;四.通过角色控制API访问权限&lt;/h2&gt;
&lt;p&gt;我们在API项目下的&lt;code&gt;IdentityController&lt;/code&gt;做出如下更改&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;[Route(&quot;[controller]&quot;)]
    
public class IdentityController : ControllerBase
{
    [Authorize(Roles = &quot;superadmin&quot;)]
    [HttpGet]
    public IActionResult Get()
    {
        return new JsonResult(from c in HttpContext.User.Claims select new { c.Type, c.Value });
    }

    [Authorize(Roles = &quot;admin&quot;)]
    [Route(&quot;{id}&quot;)]
    [HttpGet]
    public string Get(int id)
    {
        return id.ToString();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们定义了两个API通过&lt;code&gt;Authorize&lt;/code&gt;特性赋予了不同的权限（我们的测试用户只添加了一个角色，通过访问具有不同角色的API来验证是否能通过角色来控制）&lt;/p&gt;
&lt;p&gt;我们在ResourceOwnerClient项目下，&lt;code&gt;Program&lt;/code&gt;类最后添加如下代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;response = await client.GetAsync(&quot;http://localhost:5001/identity/1&quot;);
if (!response.IsSuccessStatusCode)
{
    Console.WriteLine(response.StatusCode);
    Console.WriteLine(&quot;没有权限访问 http://localhost:5001/identity/1&quot;);
}
else
{
    var content = response.Content.ReadAsStringAsync().Result;
    Console.WriteLine(content);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们请求第二个API的代码，正常情况应该会没有权限访问的（我们使用的用户只具有superadmin角色，而第二个API需要admin角色），运行一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201804/668104-20180406013601995-1063859810.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到提示我们第二个，无权访问，正常。&lt;/p&gt;
&lt;h2 id=&quot;五.如何使用已有用户数据自定义claim&quot;&gt;五.如何使用已有用户数据自定义Claim&lt;/h2&gt;
&lt;p&gt;我们前面的过程都是使用的TestUser来进行测试的，那么我们正式使用时肯定是使用自己定义的用户（从数据库中获取），这里我们可以实现&lt;code&gt;IResourceOwnerPasswordValidator&lt;/code&gt;接口，来定义我们自己的验证逻辑。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 自定义 Resource owner password 验证器
/// &amp;lt;/summary&amp;gt;
public class CustomResourceOwnerPasswordValidator: IResourceOwnerPasswordValidator
{
    /// &amp;lt;summary&amp;gt;
    /// 这里为了演示我们还是使用TestUser作为数据源，
    /// 正常使用此处应当传入一个 用户仓储 等可以从
    /// 数据库或其他介质获取我们用户数据的对象
    /// &amp;lt;/summary&amp;gt;
    private readonly TestUserStore _users;
    private readonly ISystemClock _clock;

    public CustomResourceOwnerPasswordValidator(TestUserStore users, ISystemClock clock)
    {
        _users = users;
        _clock = clock;
    }

    /// &amp;lt;summary&amp;gt;
    /// 验证
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;context&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    public Task ValidateAsync(ResourceOwnerPasswordValidationContext context)
    {
        //此处使用context.UserName, context.Password 用户名和密码来与数据库的数据做校验
        if (_users.ValidateCredentials(context.UserName, context.Password))
        {
            var user = _users.FindByUsername(context.UserName);

            //验证通过返回结果 
            //subjectId 为用户唯一标识 一般为用户id
            //authenticationMethod 描述自定义授权类型的认证方法 
            //authTime 授权时间
            //claims 需要返回的用户身份信息单元 此处应该根据我们从数据库读取到的用户信息 添加Claims 如果是从数据库中读取角色信息，那么我们应该在此处添加 此处只返回必要的Claim
            context.Result = new GrantValidationResult(
                user.SubjectId ?? throw new ArgumentException(&quot;Subject ID not set&quot;, nameof(user.SubjectId)),
                OidcConstants.AuthenticationMethods.Password, _clock.UtcNow.UtcDateTime,
                user.Claims);
        }
        else
        {
            //验证失败
            context.Result = new GrantValidationResult(TokenRequestErrors.InvalidGrant, &quot;invalid custom credential&quot;);
        }
        return Task.CompletedTask;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Startup类里配置一下我们自定义的验证器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201804/668104-20180406013655391-1349952090.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现了&lt;code&gt;IResourceOwnerPasswordValidator&lt;/code&gt;还不够，我们还需要实现&lt;code&gt;IProfileService&lt;/code&gt;接口，他是专门用来装载我们需要的Claim信息的，比如在token创建期间和请求用户信息终结点是会调用它的&lt;code&gt;GetProfileDataAsync&lt;/code&gt;方法来根据请求需要的Claim类型，来为我们装载信息，下面是一个简单实现：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class CustomProfileService: IProfileService
{
/// &amp;lt;summary&amp;gt;
/// The logger
/// &amp;lt;/summary&amp;gt;
protected readonly ILogger Logger;

/// &amp;lt;summary&amp;gt;
/// The users
/// &amp;lt;/summary&amp;gt;
protected readonly TestUserStore Users;

/// &amp;lt;summary&amp;gt;
/// Initializes a new instance of the &amp;lt;see cref=&quot;TestUserProfileService&quot;/&amp;gt; class.
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;users&quot;&amp;gt;The users.&amp;lt;/param&amp;gt;
/// &amp;lt;param name=&quot;logger&quot;&amp;gt;The logger.&amp;lt;/param&amp;gt;
public CustomProfileService(TestUserStore users, ILogger&amp;lt;TestUserProfileService&amp;gt; logger)
{
    Users = users;
    Logger = logger;
}

/// &amp;lt;summary&amp;gt;
/// 只要有关用户的身份信息单元被请求（例如在令牌创建期间或通过用户信息终点），就会调用此方法
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;context&quot;&amp;gt;The context.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public virtual Task GetProfileDataAsync(ProfileDataRequestContext context)
{
    context.LogProfileRequest(Logger);

    //判断是否有请求Claim信息
    if (context.RequestedClaimTypes.Any())
    {
        //根据用户唯一标识查找用户信息
        var user = Users.FindBySubjectId(context.Subject.GetSubjectId());
        if (user != null)
        {
            //调用此方法以后内部会进行过滤，只将用户请求的Claim加入到 context.IssuedClaims 集合中 这样我们的请求方便能正常获取到所需Claim

            context.AddRequestedClaims(user.Claims);
        }
    }

    context.LogIssuedClaims(Logger);

    return Task.CompletedTask;
}

/// &amp;lt;summary&amp;gt;
/// 验证用户是否有效 例如：token创建或者验证
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;context&quot;&amp;gt;The context.&amp;lt;/param&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
public virtual Task IsActiveAsync(IsActiveContext context)
{
    Logger.LogDebug(&quot;IsActive called from: {caller}&quot;, context.Caller);

    var user = Users.FindBySubjectId(context.Subject.GetSubjectId());
    context.IsActive = user?.IsActive == true;

    return Task.CompletedTask;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样在&lt;code&gt;Startup&lt;/code&gt;类里启用我们自定义的&lt;code&gt;ProfileService&lt;/code&gt; ：&lt;code&gt;AddProfileService&amp;lt;CustomProfileService&amp;gt;()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;值得注意的是如果我们直接将用户的所有Claim加入 &lt;code&gt;context.IssuedClaims&lt;/code&gt;集合，那么用户所有的Claim都将会无差别返回给请求方。比如默认情况下请求用户终结点(&lt;a href=&quot;http://Identityserver4%E5%9C%B0%E5%9D%80/connect/userinfo)%E5%8F%AA%E4%BC%9A%E8%BF%94%E5%9B%9Esub%EF%BC%88%E7%94%A8%E6%88%B7%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%EF%BC%89%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E5%9C%A8%E6%AD%A4%E5%A4%84%E7%9B%B4%E6%8E%A5&quot; class=&quot;uri&quot;&gt;http://Identityserver4地址/connect/userinfo)只会返回sub（用户唯一标识）信息，如果我们在此处直接&lt;/a&gt; context.IssuedClaims=User.Claims，那么所有Claim都将被返回，而不会根据请求的Claim来进行筛选，这样做虽然省事，但是损失了我们精确控制的能力，所以不推荐。&lt;/p&gt;
&lt;p&gt;上述说明配图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201804/668104-20180406013714642-317203640.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果直接 &lt;code&gt;context.IssuedClaims=User.Claims&lt;/code&gt;，那么返回结果如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;         /// &amp;lt;summary&amp;gt;
        /// 只要有关用户的身份信息单元被请求（例如在令牌创建期间或通过用户信息终点），就会调用此方法
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;context&quot;&amp;gt;The context.&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public virtual Task GetProfileDataAsync(ProfileDataRequestContext context)
        {
            var user = Users.FindBySubjectId(context.Subject.GetSubjectId());
            if (user != null)
                context.IssuedClaims .AddRange(user.Claims);

            return Task.CompletedTask;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/668104/201804/668104-20180406013727363-72685343.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户的所有Claim都将被返回。这样降低了我们控制的能力，我们可以通过下面的方法来实现同样的效果，但却不会丢失控制的能力。&lt;/p&gt;
&lt;p&gt;(1).自定义身份资源资源&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;身份资源的说明：身份资源也是数据，如用户ID，姓名或用户的电子邮件地址。 身份资源具有唯一的名称，您可以为其分配任意身份信息单元（比如姓名、性别、身份证号和有效期等都是身份证的身份信息单元）类型。 这些身份信息单元将被包含在用户的身份标识（Id Token）中。 客户端将使用scope参数来请求访问身份资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static IEnumerable&amp;lt;IdentityResource&amp;gt; GetIdentityResourceResources()
{
    var customProfile = new IdentityResource(
        name: &quot;custom.profile&quot;,
        displayName: &quot;Custom profile&quot;,
        claimTypes: new[] { &quot;role&quot;});

    return new List&amp;lt;IdentityResource&amp;gt;
    {
        new IdentityResources.OpenId(), 
        new IdentityResources.Profile(),
        customProfile
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2).配置Scope&lt;br/&gt;通过上面的代码，我们自定义了一个名为“customProfile“的身份资源，他包含了&quot;role&quot; Claim(可以包含多个Claim)，然后我们还需要配置Scope，我们才能访问到：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;new Client
{
    ClientId = &quot;ro.client&quot;,
    AllowedGrantTypes = GrantTypes.ResourceOwnerPassword,

    ClientSecrets = 
    {
        new Secret(&quot;secret&quot;.Sha256())
    },
    AllowedScopes = { &quot;api1&quot; ,IdentityServerConstants.StandardScopes.OpenId, 
        IdentityServerConstants.StandardScopes.Profile,&quot;custom.profile&quot;}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在Client对象的AllowedScopes属性里加入了我们刚刚定义的身份资源，下载访问用户信息终结点将会得到和上面一样的结果。&lt;/p&gt;
&lt;h2 id=&quot;六.总结&quot;&gt;六.总结&lt;/h2&gt;
&lt;p&gt;写这篇文章，简单分析了一下相关的源码，如果因为有本文描述不清楚或者不明白的地方建议阅读一下源码，或者加下方QQ群在群内提问。如果我们的根据角色的权限认证没有生效，请检查是否正确获取到了角色的用户信息单元。我们需要接入已有用户体系，只需实现&lt;code&gt;IProfileService&lt;/code&gt;和&lt;code&gt;IResourceOwnerPasswordValidator&lt;/code&gt;接口即可，并且在Startup配置Service时不再需要&lt;code&gt;AddTestUsers&lt;/code&gt;，因为将使用我们自己的用户信息。&lt;/p&gt;
&lt;p&gt;Demo地址：&lt;a href=&quot;https://github.com/stulzq/BlogDemos/tree/master/Id4RoleAndClaim&quot; class=&quot;uri&quot;&gt;https://github.com/stulzq/BlogDemos/tree/master/Id4RoleAndClaim&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Apr 2018 17:46:00 +0000</pubDate>
<dc:creator>晓晨Master</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stulzq/p/8726002.html</dc:identifier>
</item>
<item>
<title>Spring邮件发送1 - Ark~</title>
<link>http://www.cnblogs.com/ark-blog/p/8725959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ark-blog/p/8725959.html</guid>
<description>&lt;p&gt;&lt;em&gt;注意：邮件发送code中，邮件服务器的申请和配置是比较主要的一个环节，博主这里用的是QQ的邮件服务器。有需要的可以谷歌、百度查下如何开通。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;今天看了下Spring的官方文档的邮件发送这一章节。在这里记录一下初次学习成果。详细使用方案如下：&lt;/p&gt;

&lt;p&gt;1.  申请邮箱服务器，用于发送邮件。&lt;/p&gt;

&lt;p&gt;2.  在项目中引入用于支持java邮件发送的jar包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;javax.mail&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mail&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.4.7&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;javax.activation&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;activation&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.1.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.  配置java邮件发送器&lt;/p&gt;
&lt;p&gt;邮件发送器配置： applicationContext-mail.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　 &amp;lt;!-- Define mail sender util bean --&amp;gt;
    &amp;lt;bean id=&quot;mailSender&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.mail.javamail.JavaMailSenderImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;protocol&quot; value=&quot;#{config['mail.protocol']}&quot; /&amp;gt;
        &amp;lt;property name=&quot;host&quot; value=&quot;#{config['mail.host']}&quot; /&amp;gt;
        &amp;lt;property name=&quot;port&quot; value=&quot;#{config['mail.port']}&quot; /&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;#{config['mail.username']}&quot; /&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;#{config['mail.password']}&quot; /&amp;gt;
        &amp;lt;property name=&quot;defaultEncoding&quot; value=&quot;#{config['mail.default.encoding']}&quot; /&amp;gt;
        &amp;lt;property name=&quot;javaMailProperties&quot;&amp;gt;
            &amp;lt;props&amp;gt;
                &amp;lt;prop key=&quot;mail.smtp.auth&quot;&amp;gt;#{config['mail.smtp.auth']}&amp;lt;/prop&amp;gt; 
                &amp;lt;prop key=&quot;mail.smtp.starttls.enable&quot;&amp;gt;#{config['mail.smtp.starttls.enable']}&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;mail.smtp.timeout&quot;&amp;gt;#{config['mail.smtp.timeout']}&amp;lt;/prop&amp;gt;  
            &amp;lt;/props&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;邮件发送器属性文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mail.protocol=&lt;span&gt;smtp
mail.host&lt;/span&gt;=&lt;span&gt;smtp.qq.com
mail.port&lt;/span&gt;=587&lt;span&gt;

mail.username&lt;/span&gt;=&lt;span&gt;发件人邮箱
mail.password&lt;/span&gt;=&lt;span&gt;邮箱授权
mail.&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;.encoding=UTF-8&lt;span&gt;

mail.smtp.auth&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
mail.smtp.starttls.enable&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
mail.smtp.timeout&lt;/span&gt;=25000
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4. 编写邮件发送处理器&lt;/p&gt;
&lt;p&gt;接口： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * send text email
  * 
  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; email     recipients email address 
  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; subject
  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; content
  * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;          send mail result
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; sendText(String email, String subject, String content);
    
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * send email with attachment
  * 
  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; email
  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; subject
  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; content
  * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; attachments
  * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
  &lt;span&gt;*/&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; sendAttachment(String email, String subject, String content, File...attachments);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1). 发送文本邮件　　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
MimeMessage mimeMessage =&lt;span&gt; mailSender.createMimeMessage();
            
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Indicate this is multipart message &amp;amp; indicate encoding&lt;/span&gt;
MimeMessageHelper helper = &lt;span&gt;new&lt;/span&gt; MimeMessageHelper(mimeMessage, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, encoding);
helper.setFrom(form);           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set sender&lt;/span&gt;
helper.setTo(to);               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; set recipients&lt;/span&gt;
&lt;span&gt;helper.setSubject(subject);
helper.setText(content, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Indicate the text included is HTML
            
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Send mail&lt;/span&gt;
mailSender.send(mimeMessage);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2). 发送带附件邮件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
MimeMessage mimeMessage =&lt;span&gt; mailSender.createMimeMessage();
            
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Indicate this is multipart message &amp;amp; indicate encoding&lt;/span&gt;
MimeMessageHelper helper = &lt;span&gt;new&lt;/span&gt; MimeMessageHelper(mimeMessage, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;, encoding);
helper.setFrom(form);           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set sender&lt;/span&gt;
helper.setTo(to);               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; set recipients&lt;/span&gt;
&lt;span&gt;helper.setSubject(subject);
helper.setText(content, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Indicate the text included is HTML
            
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Indicate with attachment&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (File attachment : attachments) {
　　helper.addAttachment(attachment.getName(), attachment);
}
            
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Send mail&lt;/span&gt;
mailSender.send(mimeMessage);
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 05 Apr 2018 17:31:00 +0000</pubDate>
<dc:creator>Ark~</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ark-blog/p/8725959.html</dc:identifier>
</item>
<item>
<title>使用C#开发Android应用之WebApp - 蓝建荣</title>
<link>http://www.cnblogs.com/lanxiaoke/p/8725370.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lanxiaoke/p/8725370.html</guid>
<description>&lt;p&gt;近段时间了解了一下VS2017开发安卓应用的一些技术，特地把C#开发WebApp的一些过程记录下来，&lt;/p&gt;
&lt;p&gt;欢迎大家一起指教、讨论，废话少说，是时候开始表演真正的技术了。。&lt;/p&gt;

&lt;h2&gt;1、&lt;span&gt;新建空白&lt;/span&gt;Android&lt;span&gt;应用&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/254672/201804/254672-20180406001510621-234911147.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2、&lt;span&gt;拖一个&lt;/span&gt;WebView&lt;span&gt;控件进来&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/254672/201804/254672-20180406001537980-1578776813.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://images2018.cnblogs.com/blog/254672/201804/254672-20180406001744561-908725660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3、&lt;span&gt;打开模拟器&lt;/span&gt;Genymotion，选择一个系统版本，启动&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/254672/201804/254672-20180406001603743-475324980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/254672/201804/254672-20180406001614401-310343237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4、加载网页&lt;/h2&gt;
&lt;p&gt;4.1 &lt;span&gt;打开&lt;/span&gt;MainActivity.cs，在OnCreate方法里添加2行代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnCreate(Bundle savedInstanceState)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnCreate(savedInstanceState);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set our view from the &quot;main&quot; layout resource&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            SetContentView(Resource.Layout.Main);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;var web = FindViewById&amp;lt;WebView&amp;gt;(Resource.Id.webView1);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;web.LoadUrl(&quot;http://www.baidu.com&quot;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加载网页就是这样简单，F5调试，就可以看到模拟器有了变化，打开了我们的应用，并如期加载了网页&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/254672/201804/254672-20180406002007367-369859519.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;5、&lt;span&gt;网页端调用手机&lt;/span&gt;APP后台方法&lt;/h2&gt;
&lt;p&gt;5.1 &lt;span&gt;打开&lt;/span&gt;MainActivity.cs，重写OnCreate为如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnCreate(Bundle savedInstanceState)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnCreate(savedInstanceState);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; webView = &lt;span&gt;new&lt;/span&gt; WebView(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            SetContentView(webView);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;             webView.Settings.JavaScriptEnabled = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;webView.AddJavascriptInterface(new CustomJSInterface(this), &quot;CSharp&quot;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;webView.LoadUrl(&quot;http://192.168.0.113:8080/&quot;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;标红的是实现前端调用后台方法的关键，新建CustomJSInterface.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomJSInterface : Java.Lang.Object
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        Context context;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CustomJSInterface(Context context)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.context =&lt;span&gt; context;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        [Export]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        [JavascriptInterface]
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ShowToast(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; message)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            Toast.MakeText(context, message, ToastLength.Short).Show();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而&quot;http://192.168.0.113:8080/&quot;是我们的Web站点，大部分业务逻辑在网站里处理，WebApp只是在外表包了一个壳&lt;/p&gt;
&lt;p&gt;5.2 &lt;span&gt;我们再新建一个本地&lt;/span&gt;Web站点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/254672/201804/254672-20180406002642989-1822099308.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;改动首页&lt;/span&gt;HTML，主要功能是点击按钮，会调用后台ShowToast，这是个提示功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    ViewBag.Title = &quot;Home Page&quot;;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;jumbotron&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; onClick&lt;/span&gt;&lt;span&gt;=&quot;CSharp.ShowToast('hello')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;由前端调用C#后台方法&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器预览&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/254672/201804/254672-20180406002735024-1374743389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;5.3 VS2017按F5&lt;span&gt;部署，可以看的模拟器也正常把本地站点加载进来了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/254672/201804/254672-20180406002823858-660515670.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;点击&quot;获取前端JS返回的数据&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/254672/201804/254672-20180406002913691-1749342146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;6、APP&lt;span&gt;执行前端&lt;/span&gt;&lt;span&gt;JS&lt;/span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;6.1 &lt;/span&gt;重写OnCreate&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必须重写WebView客户端&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;             webView.SetWebViewClient(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomWebViewClient());
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先打开首页&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             webView.LoadUrl(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://192.168.0.113:8080/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; APP主动获取前端数据&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; btn = FindViewById&amp;lt;Button&amp;gt;&lt;span&gt;(Resource.Id.button1);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             btn.Click += &lt;span&gt;delegate&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; callback = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReceiveValueCallback();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 callback.OnReceiveValueCallback += (message) =&amp;gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     Toast.MakeText(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ApplicationContext, message, ToastLength.Short).Show();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                };
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;                 webView.EvaluateJavascript(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GetData()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, callback);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.2 &lt;span&gt;新建&lt;/span&gt;CustomWebViewClient.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomWebViewClient : WebViewClient
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; ShouldOverrideUrlLoading(WebView view, String url)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;            view.LoadUrl(url);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.3 新建ReceiveValueCallback.cs，这个类主要负责处理前端返回的数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReceiveValueCallback : Java.Lang.Object, IValueCallback
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnReceiveValueCallbackHandler(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; message);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; OnReceiveValueCallbackHandler OnReceiveValueCallback;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重写ReceiveValue方法&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnReceiveValue(Java.Lang.Object value)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            OnReceiveValueCallback(value.ToString());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.4 &lt;span&gt;修改&lt;/span&gt;Index.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    ViewBag.Title = &quot;Home Page&quot;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;jumbotron&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;button&quot;&lt;/span&gt;&lt;span&gt; onClick&lt;/span&gt;&lt;span&gt;=&quot;CSharp.ShowToast('hello')&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;由前端调用C#后台方法&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; GetData() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456789&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.5 VS2017按F5部署&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/254672/201804/254672-20180406003354610-205508335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.6 点击按钮&quot;&lt;span&gt;获取前端&lt;/span&gt;JS返回的数据&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/254672/201804/254672-20180406003414163-816085903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 7、WebAPP使用疑问&lt;/h2&gt;
&lt;p&gt; 7.1 &lt;span&gt;细心的人可能注意到：前端代码完全可以自己处理完业务，那还有Web&lt;/span&gt;App&lt;span&gt;什么事情呢？这时的&lt;/span&gt;&lt;span&gt;APP&lt;/span&gt;&lt;span&gt;完全就跟一个浏览器差不多！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;7.2 &lt;span&gt;确实是这样的&lt;/span&gt;WebApp&lt;span&gt;相对与其他安卓&lt;/span&gt;&lt;span&gt;APP&lt;/span&gt;&lt;span&gt;来说，是轻量级的，只是一个壳子，但是他也是有其合适的使用范围；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如：如果前端并没有数据持久化功能（如纯&lt;/span&gt;&lt;span&gt;JS&lt;/span&gt;&lt;span&gt;前端），这时要保存数据只能调用其他的&lt;/span&gt;&lt;span&gt;WebApi&lt;/span&gt;&lt;span&gt;，而由于&lt;/span&gt;&lt;span&gt;JS&lt;/span&gt;&lt;span&gt;的特性可能会引起一些安全问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者根本没有第三方&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;，数据需要保存在手机端，&lt;/span&gt;&lt;span&gt;JS&lt;/span&gt;&lt;span&gt;也没有这种权限。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以既兼顾了像升级&lt;/span&gt;&lt;span&gt;Web&lt;/span&gt;&lt;span&gt;站点那样简便，又有一些手机端的操作权限，&lt;/span&gt;&lt;span&gt;WebApp&lt;/span&gt;&lt;span&gt;应运而生。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 05 Apr 2018 16:40:00 +0000</pubDate>
<dc:creator>蓝建荣</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lanxiaoke/p/8725370.html</dc:identifier>
</item>
<item>
<title>Python基础学习篇章二 - 水滴月</title>
<link>http://www.cnblogs.com/lty-fly/p/8724959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lty-fly/p/8724959.html</guid>
<description>&lt;p&gt;&lt;span&gt;一. Python如何运行程序&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 在交互模式下编写代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　最简单的运行Python程序的方法是在Python交互命令行中输入程序。当然有很多方法可以开始这样的命令行，比如IDE，系统终端。如果你已经在计算机中安装了解释器，并且可以运行，那么你就可以输入Python程序了。也可以使用系统自带的黑窗口命令模式，这是最基本的输入命令的方式，windows中按着win+r输入cmd就可进入命令提示环境。下面给大家看下操作（输出Hello world）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                  &lt;img src=&quot;https://images2018.cnblogs.com/blog/1353593/201804/1353593-20180405175749069-1263226647.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或许是Python版本比较高，在命令行下输入 print 'hello world '  回车是报错的。但是像下面的输出确实正确的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                 &lt;img src=&quot;https://images2018.cnblogs.com/blog/1353593/201804/1353593-20180405180202285-2005438118.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些前提是你要先安装Python到你的个人的计算机中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 在交互提示模式下编写代码有以下技巧&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）只能输入Python命令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2） 在文件中想输出结果，必须使用打印语句&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）在交互提示模式下不需要缩进。当输入Python程序时，无论是在交互模式下还是在一个文本文件中，要确定所有没有嵌套的语句都在第一列，也就是最左边。如果不是这样Python会打印SyntaxError的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）留意提示符的变换和符合语句。在交互模式下输入两行后多行的复合语句时，提示符会发生变化。在shell窗口界面中，交互提示符会在第二行及后面的行由&amp;gt;&amp;gt;&amp;gt;变成··· 。在IDLE界面中，第一行后的行会被自动缩进。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 系统命令行和文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在交互命令行下，Python一旦执行了输入的程序后，它们就会消失。在交互模式下输入的代码不会保存到一个文件中，要想重新运行，必须从头开始输入。想要保存程序，就要把代码写到文件中。运行文件中的代码有很多种方式，可以在系统命令行、通过点击图标、在IDLE用户界面中选择等方式。含有能运行的代码的文件通常称为模块，能直接运行的模块文件称之为脚本。这里应该注意，Python脚本的文件扩展名为.py。&lt;span&gt;另外有个有趣的事就是可以重定向（输入流的重定向）Python的输出至以文件（在系统的shell界面中）。&lt;span&gt;大致的用法如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　python  test.py &amp;gt; saveit.txt        这样的话test.py中的输出结果会保存到saveit.txt文件中！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;尝试了一下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;                &lt;img src=&quot;https://images2018.cnblogs.com/blog/1353593/201804/1353593-20180405224833449-1550820607.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                   &lt;img src=&quot;https://images2018.cnblogs.com/blog/1353593/201804/1353593-20180405224909012-992210989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 05 Apr 2018 16:03:00 +0000</pubDate>
<dc:creator>水滴月</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lty-fly/p/8724959.html</dc:identifier>
</item>
<item>
<title>WPF自学入门（十一）WPF MVVM模式Command命令 - 黄昏前黎明后</title>
<link>http://www.cnblogs.com/fly-bird/p/8724915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fly-bird/p/8724915.html</guid>
<description>&lt;p&gt;        在WPF自学入门（十）WPF MVVM简单介绍中的示例似乎运行起来没有什么问题，也可以进行更新。但是这并不是我们使用MVVM的正确方式。正如上一篇文章中在开始说的，MVVM的目的是为了最大限度地降低了Xaml文件和CS文件的耦合度，分离界面和业务逻辑，所以我们要尽可能的在View后台不写代码。但是这个例子中，我们将更新ViewModel的代码写在了View里，下一个例子中，我们要通过命令(Command)的来将Button的事件分离出来。&lt;/p&gt;
&lt;p&gt;       因为本文中需要使用Command命令，我们先来简单了解Command命令。在WPF中使用命令的步骤很简单&lt;/p&gt;
&lt;p&gt;1.创建命令&lt;/p&gt;
&lt;p&gt;2.绑定命令&lt;/p&gt;
&lt;p&gt;3.设置命令源&lt;/p&gt;
&lt;p&gt;4.设置命令目标&lt;/p&gt;
&lt;p&gt;      WPF中命令的核心是System.Windows.Input.ICommand接口，所有命令对象都实现了此接口。当创建自己的命令时，不能直接实现ICommand接口，而是要使用System.Windows.Input.RouteCommand类，该类已经实现了ICommand接口，所有WPF命令都是RouteCommand类的实例。在程序中处理的大部分命令不是RoutedCommand对象，而是RoutedUICommand类的实例，它继承自RouteCommand类。&lt;/p&gt;
&lt;p&gt;       WPF提供了一个很好的方式来解决事件绑定的问题--ICommand。很多控件都有Command属性，如果没有，我们可以将命令绑定到触发器上。接下来我们来先实现一个ICommand接口。ICommand需要用户定义两个方法bool CanExecute和void Execute。第一个方法可以让我们来判断是否可以执行这个命令，第二个方法就是我们具体的命令。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; 
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Windows.Input;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt;  
&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************作者：黄昏前黎明后**********************************
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;*   作者：黄昏前黎明后
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;*   CLR版本：4.0.30319.42000
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;*   创建时间：2018-04-05 22:57:56
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;*   命名空间：Example3
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;*   唯一标识：b9043d4c-fdd7-4e0f-a324-00f0f09286d0
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;*   机器名称：HLPC
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;*   联系人邮箱：hl@cn-bi.com
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;*   描述说明：
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;*   修改历史：
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;*
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;****************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Example3
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RelayCommand : ICommand
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 字段
&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt;         &lt;span&gt;readonly&lt;/span&gt; Func&amp;lt;Boolean&amp;gt;&lt;span&gt; _canExecute;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;         &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Action _execute;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;  
&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; 构造函数
&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RelayCommand(Action execute)
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt;             : &lt;span&gt;this&lt;/span&gt;(execute, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; RelayCommand(Action execute, Func&amp;lt;Boolean&amp;gt;&lt;span&gt; canExecute)
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (execute == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt;             _execute =&lt;span&gt; execute;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;             _canExecute =&lt;span&gt; canExecute;
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt; 
&lt;span&gt; 87&lt;/span&gt;  
&lt;span&gt; 88&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;#region&lt;/span&gt; ICommand的成员
&lt;span&gt; 90&lt;/span&gt; 
&lt;span&gt; 91&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; EventHandler CanExecuteChanged
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;            add
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; 
&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt;  
&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (_canExecute != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; 
&lt;span&gt;103&lt;/span&gt;                     CommandManager.RequerySuggested +=&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt; &lt;span&gt;            remove
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt;  
&lt;span&gt;112&lt;/span&gt; 
&lt;span&gt;113&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (_canExecute != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; 
&lt;span&gt;115&lt;/span&gt;                     CommandManager.RequerySuggested -=&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; 
&lt;span&gt;119&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; 
&lt;span&gt;121&lt;/span&gt;  
&lt;span&gt;122&lt;/span&gt; 
&lt;span&gt;123&lt;/span&gt; &lt;span&gt;        [DebuggerStepThrough]
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean CanExecute(Object parameter)
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; 
&lt;span&gt;129&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; _canExecute == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;true&lt;/span&gt;&lt;span&gt; : _canExecute();
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; 
&lt;span&gt;133&lt;/span&gt;  
&lt;span&gt;134&lt;/span&gt; 
&lt;span&gt;135&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Execute(Object parameter)
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; 
&lt;span&gt;137&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt; &lt;span&gt;            _execute();
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; 
&lt;span&gt;143&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;span&gt;144&lt;/span&gt; 
&lt;span&gt;145&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; 
&lt;span&gt;147&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; 
&lt;span&gt;149&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们再在我们的NameViewModel中声明一个ICommand字段：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#region&lt;/span&gt; 命令
&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt;&lt;span&gt; UpdateNameExecute()
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.UserName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;黄昏前黎明后&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.CompanyName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中软易通科技&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;  
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CanUpdateNameExecute()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;  
&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; ICommand UpdateName { &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RelayCommand(UpdateNameExecute, CanUpdateNameExecute); } }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;  
&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后，我们再将事件绑定上这个Command：&lt;/p&gt;
&lt;p&gt;&amp;lt;Button Content=&quot;更新&quot; Command=&quot;{Binding UpdateName}&quot; Margin=&quot;20&quot;/&amp;gt;&lt;/p&gt;
&lt;p&gt;运行一下，看结果。我们成功将事件分离了出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/662342/201804/662342-20180405233438222-1110459640.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;     看到上面的结果，似乎目前为止我们已经很好的解决了所有的问题。我们看到运行的数据，事件都是绑定的，实现了界面的完美分离。实际在处理问题是好像需要考虑通用性，这时我们能否把MVVM提取出来作为一个框架，来去更好的解决问题。下一次我们一起来看看怎么进行提取成为通用框架。&lt;/p&gt;

&lt;p&gt;本文的DEMO下载地址:WPFMVVMDemo2.zip&lt;/p&gt;

</description>
<pubDate>Thu, 05 Apr 2018 15:54:00 +0000</pubDate>
<dc:creator>黄昏前黎明后</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fly-bird/p/8724915.html</dc:identifier>
</item>
<item>
<title>网络编程——客户/服务器程序设计范式 - herelsp</title>
<link>http://www.cnblogs.com/herelsp/p/8724705.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/herelsp/p/8724705.html</guid>
<description>&lt;div class=&quot;output_wrapper&quot; id=&quot;output_wrapper_id&quot; readability=&quot;50.5&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4938916-eb452d9a98ebc170.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;网络编程&quot; title=&quot;网络编程&quot;/&gt;网络编程
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;我们在需要开发一个服务器程序时，有较多的的程序设计范式可供选择，不同范式有其自身的特点和实用范围，明了不同范式的特性有助于我们服务器程序的开发。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;客户端程序通常比服务器容易些，当然客户端程序也可以使用这些程序设计范式，因为它们蕴含的道理都是想通的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;本文所设计的服务器主要是指基于TCP的服务器&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h&quot;&gt;&lt;span&gt;迭代服务器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;迭代TCP服务器 &lt;strong&gt;总是在完全处理某个客户的请求之后才开始下一个客户的请求处理&lt;/strong&gt;。&lt;br/&gt;这样的服务器实际中比较少见。&lt;br/&gt;&lt;strong&gt;基于UDP的大多服务器却是这样实现&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;hfork&quot;&gt;&lt;span&gt;并发服务器，每个客户请求fork一个子进程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;传统并发服务器 &lt;strong&gt;调用fork派生一个子进程来处理每个客户，这使得服务器能够同时为多个客户服务，每个进程一个客户&lt;/strong&gt;。&lt;br/&gt;客户数目的唯一限制是操作系统对其能够同时拥有多少子进程的限制。&lt;br/&gt;绝大多数TCP服务器程序都是按这个范式编写。&lt;br/&gt;并发服务器的问题在于为每个客户现场fork一个子进程比较耗费CPU时间。&lt;/p&gt;
&lt;h3 id=&quot;haccept&quot;&gt;&lt;span&gt;预先派生子进程，每个子进程无保护地调用accept&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;不同于传统意义的并发服务器那样为每个客户现场派生一个子进程，而是 &lt;strong&gt;在启动阶段预先派生一定数量的子进程，当有客户连接到达时，这些子进程就能立即为它提供服务&lt;/strong&gt;。&lt;br/&gt;这种技术的有点在于无需引入父进程执行fork的开销就能处理新到来的客户。缺点是父进程必须在服务启动阶段猜测需要预先派生多少子进程。如果某个时刻客户数恰好等于子进程总数，那么新到的客户将被忽略，直到至少有一个子进程完成处理重新可用。&lt;/p&gt;
&lt;h3 id=&quot;haccept-1&quot;&gt;&lt;span&gt;预先派生子进程,使用文件上锁保护accept&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在多个进程中引用同一个监听套接字的描述符上调用accept的做法在某些系统实现是不被支持的，那么解决办法是让应用进程在调用accept前后安装某种形式的锁(lock),这样任意时刻只有一个子进程阻塞在accept调用中，其他子进程则阻塞在获取保护accept的锁上。&lt;br/&gt;这里使用文件锁来保护,文件锁涉及到文件系统的操作，可能比较耗时。&lt;/p&gt;
&lt;h3 id=&quot;haccept-2&quot;&gt;&lt;span&gt;预先派生子进程,使用线程互斥锁上锁保护accept&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;相比于 &lt;strong&gt;预先派生子进程,使用文件上锁保护accept&lt;/strong&gt;，使用线程锁保护accept，这种方法 &lt;strong&gt;不仅适用于同一进程内各个线程间的锁保护，而且能够用于不同进程之间的锁保护&lt;/strong&gt;。&lt;br/&gt;在不同进程间的锁保护需要注意的是&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;互斥锁变量必须存放在由所有进程共享的内存区中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;必须告知线程函数库这个锁是用于不同进程间共享的互斥锁&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;预先派生子进程，父进程向子进程传递套接字描述符&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;只让父进程嗲用accept，然后把所接受的已经连接的套接字 &lt;strong&gt;传递&lt;/strong&gt; 给某个子进程。&lt;br/&gt;这样绕过了为所有子进程的accept调用提供上锁保护的需求，但是需要从父进程到子进程进行某种形式的描述符传递。&lt;br/&gt;这种技术会上代码比较复杂，父进程必须跟踪子进程的闲忙状态，以便于给空闲的子进程传递新的套接字。&lt;/p&gt;
&lt;h3 id=&quot;h-2&quot;&gt;&lt;span&gt;并发服务器，每个客户端请求创建一个线程&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;相比于多进程模型，如果服务器主机提供支持线程，我们可以改用线程以取代进程。线程相比于进程的优势这里不再累述。&lt;/p&gt;
&lt;h3 id=&quot;haccept-3&quot;&gt;&lt;span&gt;预先创建线程服务器，使用互斥锁上锁保护accept&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;相比预先派生一个子进程池快于为每个客户线程fork一个子进程池类似的道理，在有线程支持的系统上，预先创建的线程池取代为每个客户现场创建一个线程的做法有类似的性能提升。&lt;br/&gt;这种模式的基本设计是预先创建一个线程，并让每个线程各自调用accept，取代让每个线程都阻塞在accept调用中的做法，使用互斥锁保证任何时刻只有一个线程在调用accept。&lt;/p&gt;
&lt;h3 id=&quot;haccept-4&quot;&gt;&lt;span&gt;预先创建线程服务器，由主线程调用accept&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;程序启动阶段创建一个线程池后让主线程调用accept；&lt;br/&gt;主线程把每个客户连接传递给池中某个可用的线程，类似于进程版本的做法。&lt;br/&gt;这样的设计问题在于主线程如何将一个已连接套接字传递给线程池中某个可用线程&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我们有很多实现手段，本可用如前面一样使用描述符传递，但是既然所有线程和所有描述符都在同一个进程中，那么也就没有必要把一个描述符从一个线程传递到另一个线程。接收线程只需要知道这个已连接套接字描述符的值（&lt;strong&gt;传递描述符可不只是传递这个值，事实上是需要传递这个套接字的引用，因此也将返回一个不同于原值的描述符，该套接字的引用计数也会增加&lt;/strong&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h-3&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;当 &lt;strong&gt;系统负载较轻时&lt;/strong&gt;，每来一个客户请求现场派生一个子进程为之服务的传统并发服务器程序模型就足够了&lt;/li&gt;
&lt;li&gt;相比传统的每个客户fork一次设计范式，&lt;strong&gt;预先创建一个子进程池或一个线程池的范式能够把进程控制CPU时间降低10倍或以上&lt;/strong&gt;。编写这些范式的程序并不会复杂，不过会有额外的工作，比如监视现在子进程数，随着所服务客户数的动态变化而增加或减少这个数目&lt;/li&gt;
&lt;li&gt;&lt;span&gt;某些实现允许多个子进程或线程阻塞在同一个accept调用中，另外的实现却要求对accept调用需要某种类型的锁加以保（文件锁或者互斥锁等）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;让所有子进程或线程自行调用accept通常比让父进程或主线程独自调用accept并把描述符传递个子进程或线程来的简单和快捷&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;由于潜在select冲突的原因，让所有子进程或线程阻塞在同一accept调用中比让他们阻塞在同一个select调用中更可取。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;使用 &lt;strong&gt;线程通常远快于使用进程&lt;/strong&gt;，不过选择每个客户一个子进程还是每个客户一个线程取决于操作系统提供什么支持(某些系统不提供线程支持)，还可能取决于为服务每个客户需要激活其他什么程序。例如，如果accept客户连接的服务器调用fork和exec，那么fork一个单线程的进程可能快于fork一个多线程的进程，另外还有资源等方面的综合考虑。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 05 Apr 2018 14:53:00 +0000</pubDate>
<dc:creator>herelsp</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/herelsp/p/8724705.html</dc:identifier>
</item>
<item>
<title>Spring+Hibernate+Struts(SSH)框架整合 - 佳先森</title>
<link>http://www.cnblogs.com/cailijia52o/p/8724710.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cailijia52o/p/8724710.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;前言：有人说，现在还是流行主流框架，SSM都出来很久了，更不要说SSH。我不以为然。现在许多公司所用的老项目还是ssh，如果改成主流框架，需要成本。再说比如金融IT这一块，数据库dao层还是推荐使用的是hibernate，因为能够快速开发上手，除非是互联网，因涉及到高并发，dao层用的是mybatis，数据交互效率较快。所以，SSH不容忽略。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;一、什么是SSH&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;SSH是 struts+spring+hibernate的一个集成框架，是目前比较流行的一种Web应用程序开源框架。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;集成SSH框架的系统从职责上分为四层：表示层、业务逻辑层、数据持久层和域模块层，以帮助开发人员在短期内搭建结构清晰、可复用性好、维护方便的Web应用程序。其中使用Struts作为系统的整体基础架构，负责MVC的分离，在Struts框架的模型部分，控制业务跳转，利用Hibernate框架对持久层提供支持，Spring做管理，管理struts和hibernate。具体做法是：用面向对象的分析方法根据需求提出一些模型，将这些模型实现为基本的Java对象，然后编写基本的DAO(Data Access Objects)接口，并给出Hibernate的DAO实现，采用Hibernate架构实现的DAO类来实现Java类与数据库之间的转换和访问，最后由Spring做管理，管理struts和hibernate。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;---------百度百科&lt;/p&gt;
&lt;h2&gt;二、SSH所涉及的部分&lt;/h2&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180405194147732-378649854.png&quot; alt=&quot;&quot; width=&quot;731&quot; height=&quot;542&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180405194247033-1741358821.png&quot; alt=&quot;&quot; width=&quot;728&quot; height=&quot;421&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、快速部署环境&lt;/h2&gt;
&lt;p&gt;这里利用保存客户的小Demo来演示整合SSH&lt;/p&gt;
&lt;h3&gt;　　1.导入所需jar包　&lt;/h3&gt;
&lt;p&gt; 　　1）. Struts2框架&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;         * struts-2.3.24\apps\struts2-blank\WEB-INF\lib\*.jar        -- Struts2需要的所有jar包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;        * struts2-spring-plugin-2.3.24.jar                          ---Struts2整合Spring的插件包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180405195041020-1959264726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;16&quot;&gt;　　2）. Hibernate框架&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * hibernate-release-5.0.7.Final\lib\required\*.jar          -- Hibernate框架需要的jar包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * slf4j-api-1.6.1.jar                                       -- 日志接口&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * slf4j-log4j12-1.7.2.jar                                   -- 日志实现&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * mysql-connector-java-5.1.7-bin.jar                        -- MySQL的驱动包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180405195018418-2002571809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;16&quot;&gt;　　3）. Spring框架&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * IOC核心包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * AOP核心包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * JDBC模板和事务核心包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * Spring整合JUnit测试包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * Spring整合Hibernate核心包&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * Spring整合Struts2核心包&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180405195109578-488510827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　2、在web.xml中配置spring与struts的相关代码&lt;/h3&gt;
&lt;p&gt;　　1）配置struts2核心过滤器&lt;/p&gt;
&lt;p&gt;　　这里定义为拦截所有&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &amp;lt;!-- 配置核心过滤器 --&amp;gt;
    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&amp;lt;/filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;
    &amp;lt;/filter&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）配置spring的监听器&lt;/p&gt;
&lt;p&gt;　　当服务启动时，就会先加载spring的配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &amp;lt;!-- 配置Spring框架整合WEB的监听器 --&amp;gt;
     &amp;lt;listener&amp;gt;
           &amp;lt;listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;
    &amp;lt;/listener&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3）配置默认加载路径&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &amp;lt;!-- 监听器默认加载Web-INF文件下，需要配置参数来加载指定文件 --&amp;gt;
    &amp;lt;context-param&amp;gt;
         &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
         &amp;lt;param-value&amp;gt;classpath:applicationContext.xml&amp;lt;/param-value&amp;gt;
&amp;lt;/context-param&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　总结：web.xml全部代码为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 配置Spring框架整合WEB的监听器 --&amp;gt;
     &amp;lt;listener&amp;gt;
           &amp;lt;listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.context.ContextLoaderListener&amp;lt;/listener-&lt;span&gt;class&lt;/span&gt;&amp;gt;
    &amp;lt;/listener&amp;gt;
    &amp;lt;!-- 监听器默认加载Web-INF文件下，需要配置参数来加载指定文件 --&amp;gt;
    &amp;lt;context-param&amp;gt;
         &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
         &amp;lt;param-value&amp;gt;classpath:applicationContext.xml&amp;lt;/param-value&amp;gt;
    &amp;lt;/context-param&amp;gt;
  &amp;lt;!-- 配置核心过滤器 --&amp;gt;
    &amp;lt;filter&amp;gt;
        &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
        &amp;lt;filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&amp;lt;/filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;
    &amp;lt;/filter&amp;gt;
    &amp;lt;filter-mapping&amp;gt;
        &amp;lt;filter-name&amp;gt;struts2&amp;lt;/filter-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/filter-mapping&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2、src下编写相关配置文件&lt;/h3&gt;
&lt;p&gt;　　1)spring:applicationContext.xml&lt;/p&gt;
&lt;p&gt;　　导入相关约束&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
    xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
    xmlns:tx&lt;/span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans 
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;&lt;/span&gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）hibernate:hibernate.cfg.xml&lt;/p&gt;
&lt;p&gt;　　导入相关约束，并配置数据库&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE hibernate-&lt;span&gt;configuration PUBLIC
    &lt;/span&gt;&quot;-//Hibernate/Hibernate Configuration DTD 3.0//EN&quot;
    &quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;&amp;gt;
&amp;lt;hibernate-configuration&amp;gt;
    
    &amp;lt;session-factory&amp;gt;
        &amp;lt;!-- 必须配置 --&amp;gt;
        &amp;lt;property name=&quot;hibernate.connection.driver_class&quot;&amp;gt;com.mysql.jdbc.Driver&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.connection.url&quot;&amp;gt;jdbc:mysql:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.174.130:3306/SSH&amp;lt;/property&amp;gt;&lt;/span&gt;
        &amp;lt;property name=&quot;hibernate.connection.username&quot;&amp;gt;root&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.connection.password&quot;&amp;gt;root&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.MySQLDialect&amp;lt;/property&amp;gt;
        
        &amp;lt;!-- 可选配置 --&amp;gt;
        &amp;lt;property name=&quot;hibernate.show_sql&quot;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.format_sql&quot;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hibernate.hbm2ddl.auto&quot;&amp;gt;update&amp;lt;/property&amp;gt;
        
        &amp;lt;!-- 配置C3P0的连接池 --&amp;gt;
        &amp;lt;property name=&quot;connection.provider_class&quot;&amp;gt;org.hibernate.connection.C3P0ConnectionProvider&amp;lt;/property&amp;gt;
        
        &amp;lt;!-- 不能配置绑定当前的线程的操作 --&amp;gt;
        &amp;lt;!-- 映射配置文件 --&amp;gt;
        &amp;lt;mapping resource=&quot;com/clj/domain/Customer.hbm.xml&quot;/&amp;gt;
    &amp;lt;/session-factory&amp;gt;
    
&amp;lt;/hibernate-configuration&amp;gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3）配置log4j.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;### direct log messages to stdout ###
log4j.appender.stdout&lt;/span&gt;=&lt;span&gt;org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target&lt;/span&gt;=&lt;span&gt;System.err
log4j.appender.stdout.layout&lt;/span&gt;=&lt;span&gt;org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern&lt;/span&gt;=%d{ABSOLUTE} %5p %c{1}:%L - %m%&lt;span&gt;n

### direct messages to file mylog.log ###
log4j.appender.file&lt;/span&gt;=&lt;span&gt;org.apache.log4j.FileAppender
log4j.appender.file.File&lt;/span&gt;=&lt;span&gt;c\:mylog.log
log4j.appender.file.layout&lt;/span&gt;=&lt;span&gt;org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern&lt;/span&gt;=%d{ABSOLUTE} %5p %c{1}:%L - %m%&lt;span&gt;n

### set log levels &lt;/span&gt;- &lt;span&gt;for&lt;/span&gt; more verbose logging change 'info' to 'debug'&lt;span&gt; ###

log4j.rootLogger&lt;/span&gt;=info, stdout
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4)struts2:struts.xml&lt;/p&gt;
&lt;p&gt;　　导入相关约束&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!&lt;span&gt;DOCTYPE struts PUBLIC
    &lt;/span&gt;&quot;-//Apache Software Foundation//DTD Struts Configuration 2.1//EN&quot;
    &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&amp;gt;
&amp;lt;struts&amp;gt;
&amp;lt;/struts&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　总结：src所需配置文件如图&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180405200824770-1891254572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;　　3、配置dao层&lt;/h3&gt;
&lt;p&gt;　　定义一个接口和其实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; CustomerDao {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerDaoImpl  &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerDao {&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer) {
        &lt;/span&gt;&lt;span&gt;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　4、定义业务层接口和实现类&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; CustomerService {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.annotation.Transactional;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.dao.CustomerDao;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的业务层
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerService{&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来保存客户&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer) {
     &lt;/span&gt;&lt;span&gt;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　5、定义pojo类&lt;/h3&gt;
&lt;p&gt;　　hibernate通过操作pojo类来操作数据库表，做到对象关系映射&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.domain;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Customer {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long cust_id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long cust_user_id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Long cust_create_id;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_source;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_industry;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_level;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_linkman;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_phone;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String cust_mobile;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long getCust_id() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_id(Long cust_id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_id =&lt;span&gt; cust_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_name() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_name(String cust_name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_name =&lt;span&gt; cust_name;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long getCust_user_id() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_user_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_user_id(Long cust_user_id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_user_id =&lt;span&gt; cust_user_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Long getCust_create_id() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_create_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_create_id(Long cust_create_id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_create_id =&lt;span&gt; cust_create_id;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_source() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_source;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_source(String cust_source) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_source =&lt;span&gt; cust_source;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_industry() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_industry;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_industry(String cust_industry) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_industry =&lt;span&gt; cust_industry;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_level() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_level;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_level(String cust_level) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_level =&lt;span&gt; cust_level;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_linkman() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_linkman;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_linkman(String cust_linkman) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_linkman =&lt;span&gt; cust_linkman;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_phone() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_phone;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_phone(String cust_phone) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_phone =&lt;span&gt; cust_phone;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getCust_mobile() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cust_mobile;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCust_mobile(String cust_mobile) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cust_mobile =&lt;span&gt; cust_mobile;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;Customer [cust_id=&quot; + cust_id + &quot;, cust_name=&quot; +&lt;span&gt; cust_name
                &lt;/span&gt;+ &quot;, cust_user_id=&quot; + cust_user_id + &quot;, cust_create_id=&quot;
                + cust_create_id + &quot;, cust_source=&quot; +&lt;span&gt; cust_source
                &lt;/span&gt;+ &quot;, cust_industry=&quot; + cust_industry + &quot;, cust_level=&quot;
                + cust_level + &quot;, cust_linkman=&quot; +&lt;span&gt; cust_linkman
                &lt;/span&gt;+ &quot;, cust_phone=&quot; + cust_phone + &quot;, cust_mobile=&quot; +&lt;span&gt; cust_mobile
                &lt;/span&gt;+ &quot;]&quot;&lt;span&gt;;
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　6、定义Customer.hbm.xml&lt;/h3&gt;
&lt;p&gt;　　此配置文件关乎Customer这个pojo类，此文件需放在Customer pojo类同个包下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE hibernate-&lt;span&gt;mapping PUBLIC 
    &lt;/span&gt;&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;
    &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&amp;gt;
    
&amp;lt;hibernate-mapping&amp;gt;
    
    &amp;lt;&lt;span&gt;class&lt;/span&gt; name=&quot;com.clj.domain.Customer&quot; table=&quot;cst_customer&quot;&amp;gt;
        &amp;lt;id name=&quot;cust_id&quot; column=&quot;cust_id&quot;&amp;gt;
            &amp;lt;generator &lt;span&gt;class&lt;/span&gt;=&quot;native&quot;/&amp;gt;
        &amp;lt;/id&amp;gt;
        
        &amp;lt;property name=&quot;cust_name&quot; column=&quot;cust_name&quot;/&amp;gt;
        &amp;lt;property name=&quot;cust_user_id&quot; column=&quot;cust_user_id&quot;/&amp;gt;
        &amp;lt;property name=&quot;cust_create_id&quot; column=&quot;cust_create_id&quot;/&amp;gt;
        &amp;lt;property name=&quot;cust_source&quot; column=&quot;cust_source&quot;/&amp;gt;
        &amp;lt;property name=&quot;cust_industry&quot; column=&quot;cust_industry&quot;/&amp;gt;
        &amp;lt;property name=&quot;cust_level&quot; column=&quot;cust_level&quot;/&amp;gt;
        &amp;lt;property name=&quot;cust_linkman&quot; column=&quot;cust_linkman&quot;/&amp;gt;
        &amp;lt;property name=&quot;cust_phone&quot; column=&quot;cust_phone&quot;/&amp;gt;
        &amp;lt;property name=&quot;cust_mobile&quot; column=&quot;cust_mobile&quot;/&amp;gt;
        
    &amp;lt;/&lt;span&gt;class&lt;/span&gt;&amp;gt;
    
&amp;lt;/hibernate-mapping&amp;gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　项目构建大致图&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180405202819615-178460725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;四、demo之保存客户初步演示&lt;/h2&gt;
&lt;p&gt;　　这里先初略的定义持久层交给heibernate，业务层交个struts2，创建实例交给spring&lt;/p&gt;
&lt;h3&gt;　　1、定义一个保存客户的界面，利用form表单进行数据的提交&lt;/h3&gt;
&lt;p&gt;　　根据域名可知，这里利用的是struts2的通配符方式进行访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;FORM id=form1 name=&lt;span&gt;form1
        action&lt;/span&gt;=&quot;${pageContext.request.contextPath }/customer_add.action&quot;&lt;span&gt;
        method&lt;/span&gt;=post&amp;gt;
           &amp;lt;!--table部分省略--&amp;gt;
&amp;lt;/FORM&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2、在struts.xml中配置接受请求，根据action名和方法跳转指定的action，执行指定的方法&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;spring整合struts2方式一：action由struts2框架管理&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　 * 因为导入的struts2-spring-plugin-2.3.24.jar 包自带一个配置文件 struts-plugin.xml &lt;span&gt;，该配置文件中有如下代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;        * &amp;lt;constant name=&quot;struts.objectFactory&quot; value=&quot;spring&quot; /&amp;gt;   开启一个常量，如果该常量开启，那么下面的常量就可以使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        * struts.objectFactory.spring.autoWire = name，该常量是可以让Action的类来自动装配Bean对象！&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!&lt;span&gt;DOCTYPE struts PUBLIC
    &lt;/span&gt;&quot;-//Apache Software Foundation//DTD Struts Configuration 2.1//EN&quot;
    &quot;http://struts.apache.org/dtds/struts-2.3.dtd&quot;&amp;gt;
&amp;lt;struts&amp;gt;
    &amp;lt;!-- 配置包结构 --&amp;gt;
        &amp;lt;&lt;span&gt;package&lt;/span&gt; name=&quot;crm&quot; &lt;span&gt;extends&lt;/span&gt;=&quot;struts-default&quot; namespace=&quot;/&quot;&amp;gt;
            &amp;lt;!-- 配置客户的Action --&amp;gt;
            &amp;lt;!--&lt;span&gt;  方式一：aciton由struts2框架管理&lt;/span&gt;--&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　&lt;/span&gt;&amp;lt;action name=&quot;customer_*&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.web.action.CustomerAction&quot; method=&quot;{1}&quot;/&amp;gt; &lt;br/&gt;　　　　&amp;lt;/&lt;span&gt;package&lt;/span&gt;&amp;gt;&lt;br/&gt;&amp;lt;/struts&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3、在spring的applicationContext.xml中配置相对应的bean以及事务&lt;/h3&gt;
&lt;p&gt;　　     这里利用spring中IOC(控制反转)的特性，将创建实例的任务交给spring框架管理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;bean id=&quot;customerService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.service.CustomerServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;customerDao&quot; ref=&quot;customerDao&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;customerDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.dao.CustomerDaoImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;hibernateTemplate&quot; ref=&quot;hibernateTemplate&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;hibernateTemplate&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.HibernateTemplate&quot;&amp;gt;
        &amp;lt;!-- 注入sessionFactory  --&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　4、编写持久层实现类相关代码&lt;/h3&gt;
&lt;p&gt;　　这里利用hibernate提供的模板类，内部封转了session，从而可以调用session中的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 持久层
 * 
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerDaoImpl  &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerDao {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据保存到数据库中(调用模板类(hibernate提供，内部封装了session))&lt;/span&gt;
   &lt;span&gt; private HibernateTemplate hibernateTemplate;
    
    public void setHibernateTemplate(HibernateTemplate hibernateTemplate) {
        this.hibernateTemplate = hibernateTemplate;
    }&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 保存客户
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer) {
        System.out.println(&lt;/span&gt;&quot;持久层：保存客户&quot;&lt;span&gt;);
       &lt;/span&gt; &lt;span&gt;h&lt;/span&gt;iber&lt;span&gt;nateTemplate().save(customer);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　5、编写业务层实现类相关代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.annotation.Transactional;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.dao.CustomerDao;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的业务层
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Transactional
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerService{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerDao customerDao;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCustomerDao(CustomerDao customerDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.customerDao =&lt;span&gt; customerDao;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来保存客户&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer) {
        System.out.println(&lt;/span&gt;&quot;业务层，保存客户&quot;&lt;span&gt;);
        customerDao.save(customer);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　6、编写action相关代码&lt;/h3&gt;
&lt;p&gt;　　这里通过struts2的模板类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.web.action;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.struts2.ServletActionContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.context.WebApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.context.support.WebApplicationContextUtils;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.service.CustomerService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionSupport;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ModelDriven;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的控制层
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerAction &lt;span&gt;extends&lt;/span&gt; ActionSupport &lt;span&gt;implements&lt;/span&gt; ModelDriven&amp;lt;Customer&amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不要忘记手动new&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Customer customer=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Customer getModel() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; customer;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供service成员属性，提供set方法&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerService customerService;
    
    

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCustomerService(CustomerService customerService) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.customerService =&lt;span&gt; customerService;
    }



    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 保存客户
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String add(){
        System.out.println(&lt;/span&gt;&quot;WEB层，保存客户&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方式一：创建web的工厂（action由struts2创建）&lt;/span&gt;
        &lt;span&gt;WebApplicationContext context=WebApplicationContextUtils.getWebApplicationContext(ServletActionContext.getServletContext());
        CustomerService cs=(CustomerService) context.getBean(&quot;customerService&quot;);
        //调用方法
        cs.save(customer);&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NONE;
    }

    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五、项目优化之整合&lt;/h2&gt;
&lt;h3&gt;　　1、 spring整合struts2方式二：action由spring框架管理&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;把具体的&lt;/span&gt;Action类配置文件applicatonContext.xml的配置文件中，但是注意：struts.xml需要做修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;struts&amp;gt;
    &amp;lt;!-- 配置包结构 --&amp;gt;
        &amp;lt;&lt;span&gt;package&lt;/span&gt; name=&quot;crm&quot; &lt;span&gt;extends&lt;/span&gt;=&quot;struts-default&quot; namespace=&quot;/&quot;&amp;gt;
            &amp;lt;!-- 配置客户的Action --&amp;gt;
            &amp;lt;!--&lt;span&gt;  方式一：aciton由struts2框架管理
            &lt;/span&gt;&amp;lt;action name=&quot;customer_*&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.web.action.CustomerAction&quot; method=&quot;{1}&quot;/&amp;gt;--&amp;gt;
            &amp;lt;!-- 方式二：action由spring管理，class标签上只需要编写srping配置bean的ID值既可以--&amp;gt;
             &amp;lt;action name=&quot;customer_*&quot; &lt;span&gt;class&lt;/span&gt;=&quot;customerAction&quot; method=&quot;{1}&quot;&amp;gt;&amp;lt;/action&amp;gt;
        &amp;lt;/&lt;span&gt;package&lt;/span&gt;&amp;gt;
&amp;lt;/struts&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　2、在applicationContext.xml中配置Action类&lt;/h3&gt;
&lt;p&gt;　　　注意：1）Spring框架默认生成CustomerAction是单例的，而Struts2框架是多例的。所以需要配置 scope=&quot;prototype&quot;&lt;/p&gt;
&lt;p&gt;　　　　　　2）此时没有struts2的自动装配，在action需要手动配置customerService属性，并在action类中生成set方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 配置客户模块 --&amp;gt;
    &amp;lt;!-- 强调：配置的Aciton,必须是多列的 --&amp;gt;
    &amp;lt;bean id=&quot;customerAction&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.web.action.CustomerAction&quot; scope=&quot;prototype&quot;&amp;gt;
        &amp;lt;!--注意：struts管理action时，基于其中有个struts-&lt;span&gt;plugin的jar包，其中更改了一个
        常量struts.objectFactory.spring.autoWire &lt;/span&gt;=&lt;span&gt; name将其打开了，可以自动装配，只需要提供set方法
        但是此时action由spring管理，自动装配失效，所以需要手动进行配置注入
        &lt;/span&gt;--&amp;gt;
        &amp;lt;property name=&quot;customerService&quot; ref=&quot;customerService&quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3、.配置事务&lt;/h3&gt;
&lt;p&gt;　　 spring整合hibernate方式一：&lt;strong&gt;&lt;span&gt;（带有&lt;/span&gt;hibernate.cfg.xml的配置文件。强调：不能加绑定当前线程的配置）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　以前玩hibernate时，hibernate.cfg.xml都是由hibernate框架管理，其配置文件能生成sessionFactory,持久层加载此配置文件获取sessionFactory，从而创建工厂生成session，进行数据的增删改成，此时其配置文件应该交给spring管理，充分利用spring的IOC特性&lt;/p&gt;

&lt;p&gt;　　Spring框架提供了一个HibernateDaoSupport的工具类，以后DAO都可以继承该类！！在引入hibernate核心配置文件之前，得让dao层继承一个父类HibernateDaoSupport，此父类内部封装了事务模板&lt;/p&gt;
&lt;p&gt;　　看源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1226944/201804/1226944-20180405214923738-86679128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　1）修改相对应的持久层实现类，让他继承HibernateDaoSupport&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.dao;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.orm.hibernate5.HibernateTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.orm.hibernate5.support.HibernateDaoSupport;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 持久层
 * 继承HibernateDaoSupport，内部封装了HibernateTemplate
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerDaoImpl &lt;span&gt;extends&lt;/span&gt; HibernateDaoSupport &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerDao {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据保存到数据库中(调用模板类(hibernate提供，内部封装了session))&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;private HibernateTemplate hibernateTemplate;
    
    public void setHibernateTemplate(HibernateTemplate hibernateTemplate) {
        this.hibernateTemplate = hibernateTemplate;
    }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 保存客户
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer) {
        System.out.println(&lt;/span&gt;&quot;持久层：保存客户&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHibernateTemplate().save(customer);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）修改业务层让，开启事务注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.annotation.Transactional;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.dao.CustomerDao;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的业务层
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Transactional
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerService{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerDao customerDao;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCustomerDao(CustomerDao customerDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.customerDao =&lt;span&gt; customerDao;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来保存客户&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer) {
        System.out.println(&lt;/span&gt;&quot;业务层，保存客户&quot;&lt;span&gt;);
        customerDao.save(customer);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　3）修改applicationContext.xml文件&lt;/p&gt;
&lt;p&gt;　　先引入hibernate配置文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 编写bean,名称都是固定的，由spring提供，用来加载hibernate.cfg.xml的配置文件--&amp;gt;
    &amp;lt;bean id=&quot;sessionFactory&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&amp;gt;
    &amp;lt;!-- 配置路径：当启动服务器时 ，该对象就会被创建，从而加载hibernate.cfg.xml文件，从而生成sessionFactory对象--&amp;gt;
        &amp;lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　配置平台事务管理：用来管理事务，&lt;span&gt;注意现在使用的是&lt;/span&gt;Hibernate框架，所以需要使用Hibernate框架的事务管理器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 先配置平台事务管理器 --&amp;gt;
    &amp;lt;bean id=&quot;transactionManager&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&amp;gt;
        &amp;lt;!-- 注入事务，session能够管理事务，工厂能够创建session --&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　开启事务注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　&amp;lt;!-- 开启事务的注解 --&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　去除模板类配置，并为持久层配置sessionFactory&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 以后，Dao都需要继承HibernateDaoSupport，注入sessionFactory --&amp;gt;
    &amp;lt;bean id=&quot;customerDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.dao.CustomerDaoImpl&quot;&amp;gt;
        &amp;lt;!--&amp;lt;property name=&quot;hibernateTemplate&quot; ref=&quot;hibernateTemplate&quot;/&amp;gt;--&amp;gt;
        &amp;lt;!-- 这里不注入模板类，而是注入sessionFactory,因为模板需要session(封装了session)--&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　全部代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
    xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
    xmlns:tx&lt;/span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans 
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;&lt;/span&gt;
    &amp;lt;!-- 编写bean,名称都是固定的，有spring提供，用来加载hibernate.cfg.xml的配置文件--&amp;gt;
    &amp;lt;bean id=&quot;sessionFactory&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&amp;gt;
    &amp;lt;!-- 配置路径：当启动服务器时 ，该对象就会被创建，从而加载hibernate.cfg.xml文件，从而生成sessionFactory对象--&amp;gt;
        &amp;lt;property name=&quot;configLocation&quot; value=&quot;classpath:hibernate.cfg.xml&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 先配置平台事务管理器 --&amp;gt;
    &amp;lt;bean id=&quot;transactionManager&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&amp;gt;
        &amp;lt;!-- 注入事务，session能够管理事务，工厂能够创建session --&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 开启事务的注解 --&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&amp;gt;
    
    &amp;lt;!-- 配置客户模块 --&amp;gt;
    &amp;lt;!-- 强调：配置的Aciton,必须是多列的 --&amp;gt;
    &amp;lt;bean id=&quot;customerAction&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.web.action.CustomerAction&quot; scope=&quot;prototype&quot;&amp;gt;
        &amp;lt;!--注意：struts管理action时，基于其中有个struts-&lt;span&gt;plugin的jar包，其中更改了一个
        常量struts.objectFactory.spring.autoWire &lt;/span&gt;=&lt;span&gt; name将其打开了，可以自动装配，只需要提供set方法
        但是此时action由spring管理，自动装配失效，所以需要手动进行配置注入
        &lt;/span&gt;--&amp;gt;
        &amp;lt;property name=&quot;customerService&quot; ref=&quot;customerService&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;customerService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.service.CustomerServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;customerDao&quot; ref=&quot;customerDao&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;customerDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.dao.CustomerDaoImpl&quot;&amp;gt;
        &amp;lt;!--&amp;lt;property name=&quot;hibernateTemplate&quot; ref=&quot;hibernateTemplate&quot;/&amp;gt;--&amp;gt;
        &amp;lt;!-- 这里不注入模板类，而是注入sessionFactory,因为模板需要session(封装了session)--&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 配置模板类(hibernate框架提供的，内部封装了session)，此时交给spring管理,如果持久层继承了HibernateDaoSupport，则无需配置--&amp;gt;
    &amp;lt;!-- &amp;lt;bean id=&quot;hibernateTemplate&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.HibernateTemplate&quot;&amp;gt;&lt;span&gt;
        注入sessionFactory 
        &lt;/span&gt;&amp;lt;property name=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;--&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　4）修改action类&lt;/p&gt;
&lt;p&gt;　　　　因为注入了业务层实现类，所以此时可以直接调用业务层方法，无须加载bean&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.web.action;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.struts2.ServletActionContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.context.WebApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.context.support.WebApplicationContextUtils;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.service.CustomerService;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ActionSupport;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.opensymphony.xwork2.ModelDriven;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的控制层
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerAction &lt;span&gt;extends&lt;/span&gt; ActionSupport &lt;span&gt;implements&lt;/span&gt; ModelDriven&amp;lt;Customer&amp;gt;&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不要忘记手动new&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Customer customer=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Customer getModel() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; customer;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;提供service成员属性，提供set方法&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerService customerService;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCustomerService(CustomerService customerService) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.customerService =&lt;span&gt; customerService;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 保存客户
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String add(){
        System.out.println(&lt;/span&gt;&quot;WEB层，保存客户&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;方式一：创建web的工厂（action由struts2创建）&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;WebApplicationContext context=WebApplicationContextUtils.getWebApplicationContext(ServletActionContext.getServletContext());
        CustomerService cs=(CustomerService) context.getBean(&quot;customerService&quot;);
        //调用方法
        cs.save(customer);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        customerService.save(customer);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NONE;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　spring整合hibernate方式二：&lt;strong&gt;&lt;span&gt;（不带有&lt;/span&gt;hibernate.cfg.xml的配置文件）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;这里准备删除hibernate的核心配置文件，在删除之前，需要将其配置文件中的相关内容配置到spring的applicatioinContext.xml文件中取&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;　　1、查看hibernate.cfg.xml文件中的相关内容&lt;/h3&gt;
&lt;p class=&quot;16&quot;&gt;  　　&lt;span&gt;  * 数据库连接基本参数（4大参数）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;   　　 * Hibernate相关的属性&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;   　　 * 连接池&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;    　　* 映射文件&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;16&quot;&gt;&lt;span&gt;　　2、引入配置&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;16&quot;&gt;&lt;span&gt;　　引入连接池&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 先配置C3p0的连接池 --&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://192.168.174.130:3306/SSH&quot;/&amp;gt;
        &amp;lt;property name=&quot;user&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　修改对应的sessionFactory:&lt;span&gt;因为已经没有了&lt;/span&gt;hibernate.cfg.xml的配置文件，所以需要修改该配置，注入连接池&lt;/p&gt;
&lt;p&gt;　　引入对象映射文件：因为已经没有了hibernate.cfg.xml的配置文件，不会扫描到该配置文件，需要注入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &amp;lt;!-- 编写bean,名称都是固定的，有spring提供，用来加载hibernate.cfg.xml的配置文件--&amp;gt;
    &amp;lt;bean id=&quot;sessionFactory&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&amp;gt;
        &amp;lt;!--先加载连接池 --&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
        &amp;lt;!-- 加载方言，加载可选项 --&amp;gt;
        &amp;lt;property name=&quot;hibernateProperties&quot;&amp;gt;
            &amp;lt;props&amp;gt;
                &amp;lt;prop key=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.MySQLDialect&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.show_sql&quot;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.format_sql&quot;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&amp;gt;update&amp;lt;/prop&amp;gt;
            &amp;lt;/props&amp;gt;
        &amp;lt;/property&amp;gt;
        
        &amp;lt;!-- 引入映射的配置文件 --&amp;gt;
        &amp;lt;property name=&quot;mappingResources&quot;&amp;gt;
            &amp;lt;list&amp;gt;
                &amp;lt;value&amp;gt;com/clj/domain/Customer.hbm.xml&amp;lt;/value&amp;gt;
            &amp;lt;/list&amp;gt;
        
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在：applicationContext.xml全部代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;span&gt;
    xmlns:context&lt;/span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;span&gt;
    xmlns:aop&lt;/span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;span&gt;
    xmlns:tx&lt;/span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;=&quot;http://www.springframework.org/schema/beans 
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/aop/spring-aop.xsd&lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx &lt;/span&gt;
    http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/tx/spring-tx.xsd&quot;&amp;gt;&lt;/span&gt;
    
    &amp;lt;!-- 先配置C3p0的连接池 --&amp;gt;
    &amp;lt;bean id=&quot;dataSource&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
        &amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://192.168.174.130:3306/SSH&quot;/&amp;gt;
        &amp;lt;property name=&quot;user&quot; value=&quot;root&quot;/&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 编写bean,名称都是固定的，有spring提供，用来加载hibernate.cfg.xml的配置文件--&amp;gt;
    &amp;lt;bean id=&quot;sessionFactory&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.LocalSessionFactoryBean&quot;&amp;gt;
        &amp;lt;!--先加载连接池 --&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
        &amp;lt;!-- 加载方言，加载可选项 --&amp;gt;
        &amp;lt;property name=&quot;hibernateProperties&quot;&amp;gt;
            &amp;lt;props&amp;gt;
                &amp;lt;prop key=&quot;hibernate.dialect&quot;&amp;gt;org.hibernate.dialect.MySQLDialect&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.show_sql&quot;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.format_sql&quot;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&amp;gt;update&amp;lt;/prop&amp;gt;
            &amp;lt;/props&amp;gt;
        &amp;lt;/property&amp;gt;
        
        &amp;lt;!-- 引入映射的配置文件 --&amp;gt;
        &amp;lt;property name=&quot;mappingResources&quot;&amp;gt;
            &amp;lt;list&amp;gt;
                &amp;lt;value&amp;gt;com/clj/domain/Customer.hbm.xml&amp;lt;/value&amp;gt;
            &amp;lt;/list&amp;gt;
        
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 先配置平台事务管理器 --&amp;gt;
    &amp;lt;bean id=&quot;transactionManager&quot; &lt;span&gt;class&lt;/span&gt;=&quot;org.springframework.orm.hibernate5.HibernateTransactionManager&quot;&amp;gt;
        &amp;lt;!-- 注入事务，session能够管理事务，工厂能够创建session --&amp;gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;!-- 开启事务的注解 --&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&amp;gt;
    
    &amp;lt;!-- 配置客户模块 --&amp;gt;
    &amp;lt;!-- 强调：配置的Aciton,必须是多列的 --&amp;gt;
    &amp;lt;bean id=&quot;customerAction&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.web.action.CustomerAction&quot; scope=&quot;prototype&quot;&amp;gt;
        &amp;lt;!--注意：struts管理action时，基于其中有个struts-&lt;span&gt;plugin的jar包，其中更改了一个
        常量struts.objectFactory.spring.autoWire &lt;/span&gt;=&lt;span&gt; name将其打开了，可以自动装配，只需要提供set方法
        但是此时action由spring管理，自动装配失效，所以需要手动进行配置注入
        &lt;/span&gt;--&amp;gt;
        &amp;lt;property name=&quot;customerService&quot; ref=&quot;customerService&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;customerService&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.service.CustomerServiceImpl&quot;&amp;gt;
        &amp;lt;property name=&quot;customerDao&quot; ref=&quot;customerDao&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 以后，Dao都需要继承HibernateDaoSupport，注入sessionFactory --&amp;gt;
    &amp;lt;bean id=&quot;customerDao&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.clj.dao.CustomerDaoImpl&quot;&amp;gt;
      &lt;span&gt;  &amp;lt;!--&amp;lt;property name=&quot;hibernateTemplate&quot; ref=&quot;hibernateTemplate&quot;/&amp;gt;--&amp;gt;
        &amp;lt;!-- 这里不注入模板类，而是注入sessionFactory,因为模板需要session(封装了session)--&amp;gt;&lt;/span&gt;
        &amp;lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!-- 配置模板类(hibernate框架提供的，内部封装了session)，此时交给spring管理,如果持久层继承了HibernateDaoSupport，则无需配置--&amp;gt;
    &lt;span&gt;&amp;lt;!-- &amp;lt;bean id=&quot;hibernateTemplate&quot; class=&quot;org.springframework.orm.hibernate5.HibernateTemplate&quot;&amp;gt;
        注入sessionFactory 
        &amp;lt;property name=&quot;sessionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;--&amp;gt;&lt;/span&gt;
&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　此时可以安心的删除hibernate.cfg.xml文件了&lt;/p&gt;
&lt;p&gt;　　这样SSH整合完毕&lt;/p&gt;
&lt;h2&gt;六、Hibernate模板常用方法&lt;/h2&gt;
&lt;p&gt;　　注意：以下代码省略了接口中的演示(偷了个懒，相信初学者不会看不懂)&lt;/p&gt;
&lt;p&gt;　　1）插入：&lt;/p&gt;
&lt;p&gt;　　持久层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.dao;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.criterion.DetachedCriteria;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.orm.hibernate5.HibernateTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.orm.hibernate5.support.HibernateDaoSupport;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 持久层
 * 继承HibernateDaoSupport，内部封装了HibernateTemplate
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerDaoImpl &lt;span&gt;extends&lt;/span&gt; HibernateDaoSupport &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerDao {&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(Customer customer) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHibernateTemplate().update(customer);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　业务层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.annotation.Transactional;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.dao.CustomerDao;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的业务层
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Transactional
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerService{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerDao customerDao;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCustomerDao(CustomerDao customerDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.customerDao =&lt;span&gt; customerDao;
    }
&lt;/span&gt;&lt;span&gt; @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(Customer customer) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;        customerDao.update(customer);
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.service.CustomerService;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 测试Hiberante模板类的简单方法
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RunWith(SpringJUnit4ClassRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ContextConfiguration(&lt;/span&gt;&quot;classpath:applicationContext.xml&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo1 {
    @Resource(name&lt;/span&gt;=&quot;customerService&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerService customerService;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 测试插入
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run1(){
        Customer customer&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
        customer.setCust_id(&lt;/span&gt;1L&lt;span&gt;);
        customer.setCust_name(&lt;/span&gt;&quot;测试&quot;&lt;span&gt;);
        customerService.update(customer);
    }&lt;/span&gt;&lt;span&gt;
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）以下为指定查询、查询所有、离线查询代码&lt;/p&gt;
&lt;p&gt;　　持久层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.dao;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.hibernate.criterion.DetachedCriteria;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.orm.hibernate5.HibernateTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.orm.hibernate5.support.HibernateDaoSupport;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 持久层
 * 继承HibernateDaoSupport，内部封装了HibernateTemplate
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerDaoImpl &lt;span&gt;extends&lt;/span&gt; HibernateDaoSupport &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerDao {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将数据保存到数据库中(调用模板类(hibernate提供，内部封装了session))&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;private HibernateTemplate hibernateTemplate;
    
    public void setHibernateTemplate(HibernateTemplate hibernateTemplate) {
        this.hibernateTemplate = hibernateTemplate;
    }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 保存客户
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer) {
        System.out.println(&lt;/span&gt;&quot;持久层：保存客户&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHibernateTemplate().save(customer);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(Customer customer) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHibernateTemplate().update(customer);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过主键查询
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Customer getById(Long id) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.getHibernateTemplate().get(Customer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, id);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询所有
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Customer&amp;gt;&lt;span&gt; findAll() {
        String sql&lt;/span&gt;=&quot;from Customer&quot;&lt;span&gt;;
        List&lt;/span&gt;&amp;lt;Customer&amp;gt; list=(List&amp;lt;Customer&amp;gt;) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHibernateTemplate().find(sql);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * QBC离线查询
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Customer&amp;gt;&lt;span&gt; findAllByQBC() {
        DetachedCriteria criteria&lt;/span&gt;=DetachedCriteria.forClass(Customer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        List&lt;/span&gt;&amp;lt;Customer&amp;gt; list=(List&amp;lt;Customer&amp;gt;) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getHibernateTemplate().findByCriteria(criteria);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　业务层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.service;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.transaction.annotation.Transactional;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.dao.CustomerDao;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 客户的业务层
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Transactional
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomerServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; CustomerService{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerDao customerDao;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setCustomerDao(CustomerDao customerDao) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.customerDao =&lt;span&gt; customerDao;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来保存客户&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; save(Customer customer) {
        System.out.println(&lt;/span&gt;&quot;业务层，保存客户&quot;&lt;span&gt;);
        customerDao.save(customer);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(Customer customer) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;        customerDao.update(customer);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Customer getById(Long id) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; customerDao.getById(id);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Customer&amp;gt;&lt;span&gt; findAll() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; customerDao.findAll();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Customer&amp;gt;&lt;span&gt; findAllByQBC() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; customerDao.findAllByQBC();
    }&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.clj.test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.annotation.Resource;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.runner.RunWith;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.ContextConfiguration;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.domain.Customer;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.clj.service.CustomerService;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 测试Hiberante模板类的简单方法
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; Administrator
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RunWith(SpringJUnit4ClassRunner.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@ContextConfiguration(&lt;/span&gt;&quot;classpath:applicationContext.xml&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo1 {
    @Resource(name&lt;/span&gt;=&quot;customerService&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerService customerService;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 测试插入
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run1(){
        Customer customer&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
        customer.setCust_id(&lt;/span&gt;1L&lt;span&gt;);
        customer.setCust_name(&lt;/span&gt;&quot;测试&quot;&lt;span&gt;);
        customerService.update(customer);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 测试查询指定的客户
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run2(){
        Customer customer&lt;/span&gt;=customerService.getById(2L&lt;span&gt;);
        System.out.println(customer);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 查询所有的客户
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run3(){
        List&lt;/span&gt;&amp;lt;Customer&amp;gt; list=&lt;span&gt;customerService.findAll();
        System.out.println(list);
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * QBC(离线查询)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run4(){
        List&lt;/span&gt;&amp;lt;Customer&amp;gt; list=&lt;span&gt;customerService.findAllByQBC();
        System.out.println(list);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;七、关于SSH延迟加载问题&lt;/h2&gt;
&lt;h3 class=&quot;16&quot;&gt;　1. 使用延迟加载的时候，再WEB层查询对象的时候程序会抛出异常！&lt;/h3&gt;
&lt;p class=&quot;16&quot;&gt;    * 原因是延迟加载还没有发生SQL语句，在业务层session对象就已经销毁了，所以查询到的JavaBean对象已经变成了托管态对象！&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * 注意：一定要先删除javassist-3.11.0.GA.jar包（jar包冲突了）&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;16&quot;&gt;　2. 解决办法&lt;/h3&gt;
&lt;p class=&quot;16&quot;&gt;　Spring框架提供了一个过滤器，让session对象在WEB层就创建，在WEB层销毁。只需要配置该过滤器即可&lt;/p&gt;
&lt;p class=&quot;16&quot;&gt;    * 但是：要注意需要在struts2的核心过滤器之前进行，spring监听器之后配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 解决延迟加载的问题 --&amp;gt;
         &amp;lt;filter&amp;gt;
            &amp;lt;filter-name&amp;gt;OpenSessionInViewFilter&amp;lt;/filter-name&amp;gt;
            &amp;lt;filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.orm.hibernate5.support.OpenSessionInViewFilter&amp;lt;/filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;
        &amp;lt;/filter&amp;gt;
        &amp;lt;filter-mapping&amp;gt;
            &amp;lt;filter-name&amp;gt;OpenSessionInViewFilter&amp;lt;/filter-name&amp;gt;
            &amp;lt;url-pattern&amp;gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;&amp;lt;/url-pattern&amp;gt;
        &amp;lt;/filter-mapping&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;　　3、演示延迟加载&lt;/h3&gt;
&lt;p&gt;　　持久层：调用load方法，此方法时延迟加载的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 延迟加载
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Customer loadById(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.getHibernateTemplate().load(Customer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, id);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　业务层&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Customer loadById(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; id) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; customerDao.loadById(id);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run5(){
        Customer customer&lt;/span&gt;=customerService.loadById(2L&lt;span&gt;);
        System.out.println(customer);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;











</description>
<pubDate>Thu, 05 Apr 2018 14:53:00 +0000</pubDate>
<dc:creator>佳先森</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cailijia52o/p/8724710.html</dc:identifier>
</item>
<item>
<title>简单介绍 CPU 的工作原理 - 一像素</title>
<link>http://www.cnblogs.com/onepixel/p/8724526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/onepixel/p/8724526.html</guid>
<description>&lt;h3&gt;1、内部架构&lt;/h3&gt;
&lt;p&gt;CPU 的根本任务就是执行指令，对计算机来说最终都是一串由 0 和 1 组成的序列。CPU 从逻辑上可以划分成 3 个模块，分别是控制单元、运算单元和存储单元 。其内部架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/849589/201708/849589-20170822172925277-1871938563.png&quot; alt=&quot;&quot; width=&quot;533&quot; height=&quot;335&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;【1】控制单元&lt;/h4&gt;
&lt;p&gt;控制单元是整个CPU的指挥控制中心，由指令寄存器IR（Instruction Register）、指令译码器ID（Instruction Decoder）和 操作控制器OC（Operation Controller） 等组成，对协调整个电脑有序工作极为重要。它根据用户预先编好的程序，依次从存储器中取出各条指令，放在指令寄存器IR中，通过指令译码（分析）确定应该进行什么操作，然后通过操作控制器OC，按确定的时序，向相应的部件发出微操作控制信号。操作控制器OC中主要包括：节拍脉冲发生器、控制矩阵、时钟脉冲发生器、复位电路和启停电路等控制逻辑。&lt;/p&gt;
&lt;h4&gt;【2】运算单元&lt;/h4&gt;
&lt;p&gt;运算单元是运算器的核心。可以执行算术运算（包括加减乘数等基本运算及其附加运算）和逻辑运算（包括移位、逻辑测试或两个值比较）。相对控制单元而言，运算器接受控制单元的命令而进行动作，即运算单元所进行的全部操作都是由控制单元发出的控制信号来指挥的，所以它是执行部件。&lt;/p&gt;
&lt;h4&gt;【3】存储单元&lt;/h4&gt;
&lt;p&gt;存储单元包括 CPU 片内缓存和寄存器组，是 CPU 中暂时存放数据的地方，里面保存着那些等待处理的数据，或已经处理过的数据，CPU 访问寄存器所用的时间要比访问内存的时间短。采用寄存器，可以减少 CPU 访问内存的次数，从而提高了 CPU 的工作速度。寄存器组可分为专用寄存器和通用寄存器。专用寄存器的作用是固定的，分别寄存相应的数据；而通用寄存器用途广泛并可由程序员规定其用途。&lt;/p&gt;
&lt;h3&gt;2、工作原理&lt;/h3&gt;
&lt;p&gt;总的来说，CPU 从内存中一条一条地取出指令和相应的数据，按指令操作码的规定，对数据进行运算处理，直到程序执行完毕为止。具体过程可分为以下四步：&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;【1】取指令&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;CPU 控制器从内存读取一条指令并放入指令寄存器。指令的格式如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2017.cnblogs.com/blog/849589/201708/849589-20170823213258027-1278154922.png&quot; alt=&quot;&quot; width=&quot;571&quot; height=&quot;56&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; &lt;strong&gt;操作码&lt;/strong&gt;：就是汇编语言里的 mov，add，jmp 等符号码；&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;操作数地址&lt;/strong&gt;：说明该指令需要的操作数所在的地方，是在内存里还是在CPU的内部寄存器里。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;strong&gt;【2】指令译码&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;指令寄存器中的指令经过译码，决定该指令应进行何种操作（就是指令里的操作码）、操作数在哪里（操作数的地址） 。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;【3】 执行指令&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;执行指令分为两个阶段： 取操作数 和 进行运算 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt; 取操作数&lt;/strong&gt;：CPU 通过寻址操作，从内存（数据段）中读取操作数到通用寄存器中，暂存起来。&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;进行运算&lt;/strong&gt;：运算单元通过指令中的操作码，对寄存器中的操作数进行 mov，add，jmp 操作。&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;strong&gt;【4】 指令计数&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;修改指令计数器，决定下一条指令的地址 。CPU 重复上述三步操作，处于内存代码段的指令被逐个的执行，直到程序执行完毕为止。&lt;/p&gt;
&lt;h3&gt;3、CPU 字长&lt;/h3&gt;
&lt;p&gt;CPU在单位时间内(同一时间)能一次处理的二进制数的位数叫字长。所以，能处理字长为 8 位数据的 CPU 通常就叫 8 位的 CPU。同理，32 位CPU 能在单位时间内处理字长为 32 位的二进制数据 。&lt;/p&gt;
&lt;p&gt;常见的 32位 CPU 和 64位 CPU 主要存在以下两个差异：&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;【1】处理能力不同&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;32 位 CPU 的一个指令，最大能处理 32 位二进制数据，即一次能处理 4 个字节数据。&lt;br/&gt;64 位 CPU 的一个指令，最大能处理 64 位二进制数据，即一次能处理 8 个字节数据。&lt;br/&gt;&lt;h4&gt;&lt;strong&gt;【2】寻址空间不同&lt;/strong&gt;&lt;/h4&gt;
&lt;/p&gt;
&lt;p&gt;32 位 CPU 的寻址范围是 32 位的二进制，32位二进制能表示的地址长度为2的32次方，即寻址空间最大为 4GB。&lt;br/&gt;而 64 位CPU的寻址范围是 64 位的二进制。能表示的地址长度更大，其寻址空间也会更大。&lt;/p&gt;





&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;&lt;/p&gt;



</description>
<pubDate>Thu, 05 Apr 2018 14:12:00 +0000</pubDate>
<dc:creator>一像素</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/onepixel/p/8724526.html</dc:identifier>
</item>
<item>
<title>【深度学习】深入理解Batch Normalization批标准化 - 郭耀华</title>
<link>http://www.cnblogs.com/guoyaohua/p/8724433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guoyaohua/p/8724433.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这几天面试经常被问到BN层的原理，虽然回答上来了，但还是感觉答得不是很好，今天仔细研究了一下Batch Normalization的原理，以下为参考网上几篇文章总结得出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　Batch Normalization作为最近一年来DL的重要成果，已经广泛被证明其有效性和重要性。虽然有些细节处理还解释不清其理论原因，但是实践证明好用才是真的好，别忘了DL从Hinton对深层网络做Pre-Train开始就是一个&lt;strong&gt;经验领先于理论分析&lt;/strong&gt;的偏经验的一门学问。本文是对论文《Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift》的导读。&lt;/p&gt;
&lt;p&gt;　　机器学习领域有个很重要的假设：&lt;span&gt;&lt;span&gt;&lt;strong&gt;IID独立同分布假设&lt;/strong&gt;&lt;/span&gt;，就是假设训练数据和测试数据是满足相同分布的，这是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障&lt;/span&gt;。那BatchNorm的作用是什么呢？&lt;strong&gt;BatchNorm就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　接下来一步一步的理解什么是BN。&lt;/p&gt;
&lt;p&gt;　　为什么深度神经网络&lt;strong&gt;随着网络深度加深，训练起来越困难，收敛越来越慢？&lt;/strong&gt;这是个在DL领域很接近本质的好问题。很多论文都是解决这个问题的，比如ReLU激活函数，再比如Residual Network，BN本质上也是解释并从某个不同的角度来解决这个问题的。&lt;/p&gt;
&lt;h2&gt;一、“Internal Covariate Shift”问题&lt;/h2&gt;
&lt;p&gt;　　从论文名字可以看出，BN是用来解决“&lt;span&gt;Internal Covariate Shift&lt;/span&gt;”问题的，那么首先得理解什么是“Internal Covariate Shift”？&lt;/p&gt;
&lt;p&gt;　　论文首先&lt;span&gt;说明Mini-Batch SGD相对于One Example SGD的两个优势：梯度更新方向更准确；并行计算速度快；&lt;/span&gt;（为什么要说这些？因为BatchNorm是基于Mini-Batch SGD的，所以先夸下Mini-Batch SGD，当然也是大实话）；然后吐槽下SGD训练的缺点：超参数调起来很麻烦。（作者隐含意思是用BN就能解决很多SGD的缺点）&lt;/p&gt;
&lt;p&gt;　　接着引入&lt;span&gt;&lt;strong&gt;covariate shift的概念&lt;/strong&gt;&lt;/span&gt;：&lt;span&gt;&lt;strong&gt;如果ML系统实例集合&amp;lt;X,Y&amp;gt;中的输入值X的分布老是变，这不符合IID假设&lt;/strong&gt;&lt;/span&gt;，网络模型很难&lt;strong&gt;稳定的学规律&lt;/strong&gt;，这不得引入迁移学习才能搞定吗，我们的ML系统还得去学习怎么迎合这种分布变化啊。&lt;span&gt;对于深度学习这种包含很多隐层的网络结构，在训练过程中，因为各层参数不停在变化，所以每个隐层都会面临covariate shift的问题，也就是&lt;span&gt;&lt;strong&gt;在训练过程中，隐层的输入分布老是变来变去，这就是所谓的“Internal Covariate Shift”，Internal指的是深层网络的隐层，是发生在网络内部的事情，而不是covariate shift问题只发生在输入层。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　然后提出了BatchNorm的基本思想：能不能&lt;strong&gt;让每个隐层节点的&lt;span&gt;激活输入分布&lt;/span&gt;固定下来呢&lt;/strong&gt;？这样就避免了“Internal Covariate Shift”问题了。&lt;/p&gt;
&lt;p&gt;　　BN不是凭空拍脑袋拍出来的好点子，它是有启发来源的：之前的研究表明如果在图像处理中对输入图像进行白化（Whiten）操作的话——所谓&lt;span&gt;&lt;strong&gt;白化&lt;/strong&gt;&lt;/span&gt;，&lt;span&gt;&lt;strong&gt;就是对输入数据分布变换到0均值，单位方差的正态分布&lt;/strong&gt;&lt;/span&gt;——那么神经网络会较快收敛，那么BN作者就开始推论了：图像是深度神经网络的输入层，做白化能加快收敛，那么其实对于深度网络来说，其中某个隐层的神经元是下一层的输入，意思是其实深度神经网络的每一个隐层都是输入层，不过是相对下一层来说而已，那么能不能对每个隐层都做白化呢？这就是启发BN产生的原初想法，而BN也确实就是这么做的，&lt;strong&gt;可以理解为对深层神经网络每个隐层神经元的激活值做简化版本的白化操作。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;二、&lt;/strong&gt;BatchNorm的本质思想&lt;/h2&gt;
&lt;p&gt;　　BN的基本思想其实相当直观：&lt;span&gt;因为深层神经网络在做非线性变换前的&lt;span&gt;&lt;strong&gt;激活输入值&lt;/strong&gt;&lt;/span&gt;（就是那个x=WU+B，U是输入）&lt;span&gt;&lt;strong&gt;随着网络深度加深或者在训练过程中，其分布逐渐发生偏移或者变动，之所以训练收敛慢，一般是整体分布逐渐往非线性函数的取值区间的上下限两端靠近&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;（对于Sigmoid函数来说，意味着激活输入值WU+B是大的负值或正值），所以这&lt;span&gt;&lt;strong&gt;导致反向传播时低层神经网络的梯度消失&lt;/strong&gt;&lt;/span&gt;，这是训练深层神经网络收敛越来越慢的&lt;strong&gt;本质原因&lt;/strong&gt;，&lt;span&gt;&lt;strong&gt;而BN就是通过一定的规范化手段，把每层神经网络任意神经元这个输入值的分布强行拉回到均值为0方差为1的标准正态分布&lt;/strong&gt;&lt;/span&gt;，其实就是把越来越偏的分布强制拉回比较标准的分布，这样使得激活输入值落在非线性函数对输入比较敏感的区域，这样输入的小变化就会导致损失函数较大的变化，意思是&lt;strong&gt;这样让梯度变大，避免梯度消失问题产生，而且梯度变大意味着学习收敛速度快，能大大加快训练速度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　THAT’S IT。其实一句话就是：&lt;span&gt;&lt;strong&gt;对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间极限饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，以此避免梯度消失问题。&lt;/strong&gt;&lt;/span&gt;因为梯度一直都能保持比较大的状态，所以很明显对神经网络的参数调整效率比较高，就是变动大，就是说向损失函数最优值迈动的步子大，也就是说收敛地快。BN说到底就是这么个机制，方法很简单，道理很深刻。&lt;/p&gt;
&lt;p&gt;　　上面说得还是显得抽象，下面更形象地表达下这种调整到底代表什么含义。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405225246905-37854887.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  图1  几个正态分布&lt;/p&gt;
&lt;p&gt;　　假设某个隐层神经元原先的激活输入x取值符合正态分布，正态分布均值是-2，方差是0.5，对应上图中最左端的浅蓝色曲线，通过BN后转换为均值为0，方差是1的正态分布（对应上图中的深蓝色图形），意味着什么，意味着输入x的取值正态分布整体右移2（均值的变化），图形曲线更平缓了（方差增大的变化）。这个图的意思是，BN其实就是把每个隐层神经元的激活输入分布从偏离均值为0方差为1的正态分布通过平移均值压缩或者扩大曲线尖锐程度，调整为均值为0方差为1的正态分布。&lt;/p&gt;
&lt;p&gt;　　那么把激活输入x调整到这个正态分布有什么用？首先我们看下均值为0，方差为1的标准正态分布代表什么含义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405225314624-527885612.png&quot; alt=&quot;&quot; width=&quot;666&quot; height=&quot;341&quot;/&gt;&lt;/p&gt;

&lt;p&gt;图2  均值为0方差为1的标准正态分布图&lt;/p&gt;

&lt;p&gt;　　这意味着在一个标准差范围内，也就是说64%的概率x其值落在[-1,1]的范围内，在两个标准差范围内，也就是说95%的概率x其值落在了[-2,2]的范围内。那么这又意味着什么？我们知道，激活值x=WU+B,U是真正的输入，x是某个神经元的激活值，假设非线性函数是sigmoid，那么看下sigmoid(x)其图形：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522210808736&quot; alt=&quot;&quot; width=&quot;452&quot; height=&quot;307&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3. Sigmoid(x)&lt;/p&gt;
&lt;p&gt;及sigmoid(x)的导数为：G’=f(x)*(1-f(x))，因为f(x)=sigmoid(x)在0到1之间，所以G’在0到0.25之间，其对应的图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522210831111&quot; alt=&quot;&quot; width=&quot;438&quot; height=&quot;333&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图4  Sigmoid(x)导数图&lt;/p&gt;
&lt;p&gt;　　假设没有经过BN调整前x的原先正态分布均值是-6，方差是1，那么意味着95%的值落在了[-8,-4]之间，那么对应的Sigmoid（x）函数的值明显接近于0，这是典型的梯度饱和区，在这个区域里梯度变化很慢，为什么是梯度饱和区？请看下sigmoid(x)如果取值接近0或者接近于1的时候对应导数函数取值，接近于0，意味着梯度变化很小甚至消失。而假设经过BN后，均值是0，方差是1，那么意味着95%的x值落在了[-2,2]区间内，很明显这一段是sigmoid(x)函数接近于线性变换的区域，意味着x的小变化会导致非线性函数值较大的变化，也即是梯度变化较大，对应导数函数图中明显大于0的区域，就是梯度非饱和区。&lt;/p&gt;
&lt;p&gt;　　从上面几个图应该看出来BN在干什么了吧？其实就是把隐层神经元激活输入x=WU+B从变化不拘一格的正态分布通过BN操作拉回到了均值为0，方差为1的正态分布，即原始正态分布中心左移或者右移到以0为均值，拉伸或者缩减形态形成以1为方差的图形。什么意思？就是说&lt;strong&gt;经过BN后，目前大部分Activation的值落入非线性函数的线性区内，其对应的导数远离导数饱和区，这样来加速训练收敛过程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　但是很明显，看到这里，稍微了解神经网络的读者一般会提出一个疑问：如果都通过BN，那么不就跟把非线性函数替换成线性函数效果相同了？这意味着什么？我们知道，如果是多层的线性函数变换其实这个深层是没有意义的，因为多层线性网络跟一层线性网络是等价的。这意味着网络的&lt;span&gt;&lt;strong&gt;表达能力&lt;/strong&gt;&lt;/span&gt;下降了，这也意味着深度的意义就没有了。&lt;span&gt;&lt;strong&gt;所以BN为了保证非线性的获得，对变换后的满足均值为0方差为1的x又进行了scale加上shift操作(y=scale*x+shift)&lt;/strong&gt;&lt;/span&gt;，每个神经元增加了两个参数scale和shift参数，这两个参数是通过训练学习到的，意思是通过scale和shift把这个值从标准正态分布左移或者右移一点并长胖一点或者变瘦一点，每个实例挪动的程度不一样，这样等价于非线性函数的值从正中心周围的线性区往非线性区动了动。&lt;span&gt;核心思想应该是想找到一个线性和非线性的较好平衡点，既能享受非线性的较强表达能力的好处，又避免太靠非线性区两头使得网络收敛速度太慢。&lt;/span&gt;当然，这是我的理解，论文作者并未明确这样说。但是很明显这里的scale和shift操作是会有争议的，因为按照论文作者论文里写的理想状态，就会又通过scale和shift操作把变换后的x调整回未变换的状态，那不是饶了一圈又绕回去原始的“Internal Covariate Shift”问题里去了吗，感觉论文作者并未能够清楚地解释scale和shift操作的理论原因。&lt;/p&gt;
&lt;h2&gt;三、训练阶段如何做BatchNorm&lt;/h2&gt;
&lt;p&gt;　　上面是对BN的抽象分析和解释，具体在Mini-Batch SGD下做BN怎么做？其实论文里面这块写得很清楚也容易理解。为了保证这篇文章完整性，这里简单说明下。&lt;/p&gt;
&lt;p&gt;　　假设对于一个深层神经网络来说，其中两层结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405213859690-1933561230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  图5  DNN其中两层&lt;/p&gt;

&lt;p&gt;　　要对每个隐层神经元的激活值做BN，可以想象成每个隐层又加上了一层BN操作层，它位于X=WU+B激活值获得之后，非线性函数变换之前，其图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1192699/201804/1192699-20180405213955224-1791925244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  图6. BN操作&lt;/p&gt;
&lt;p&gt;　　对于Mini-Batch SGD来说，一次训练过程里面包含m个训练实例，其具体BN操作就是对于隐层内每个神经元的激活值来说，进行如下变换：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522210954533&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　要注意，&lt;span&gt;这里t层某个神经元的x(k)不是指原始输入，就是说不是t-1层每个神经元的输出，而是t层这个神经元的线性激活x=WU+B，这里的U才是t-1层神经元的输出。&lt;/span&gt;变换的意思是：某个神经元对应的原始的激活x通过减去mini-Batch内m个实例获得的m个激活x求得的均值E(x)并除以求得的方差Var(x)来进行转换。&lt;/p&gt;
&lt;p&gt;　　上文说过经过这个&lt;span&gt;&lt;strong&gt;变换后某个神经元的激活x形成了均值为0，方差为1的正态分布，目的是把值往后续要进行的非线性变换的线性区拉动，增大导数值，增强反向传播信息流动性，加快训练收敛速度。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;但是这样会导致网络表达能力下降，为了防止这一点，每个神经元增加两个调节参数（scale和shift），这两个参数是通过训练来学习到的，用来对变换后的激活反变换，使得网络表达能力增强，即对变换后的激活进行如下的scale和shift操作，这其实是变换的反操作：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522211016799&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　BN其具体操作流程，如论文中描述的一样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522211049877&quot; alt=&quot;&quot; width=&quot;484&quot; height=&quot;344&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　过程非常清楚，就是上述公式的流程化描述，这里不解释了，直接应该能看懂。&lt;/p&gt;
&lt;h2&gt;四、BatchNorm的推理(Inference)过程&lt;/h2&gt;
&lt;p&gt;　　BN在训练的时候可以根据Mini-Batch里的若干训练实例进行激活数值调整，但是在推理（inference）的过程中，很明显输入就只有一个实例，看不到Mini-Batch其它实例，那么这时候怎么对输入做BN呢？因为很明显一个实例是没法算实例集合求出的均值和方差的。这可如何是好？&lt;/p&gt;
&lt;p&gt;　　既然没有从Mini-Batch数据里可以得到的统计量，那就想其它办法来获得这个统计量，就是均值和方差。可以用从所有训练实例中获得的统计量来代替Mini-Batch里面m个训练实例获得的均值和方差统计量，因为本来就打算用全局的统计量，只是因为计算量等太大所以才会用Mini-Batch这种简化方式的，那么在推理的时候直接用全局统计量即可。&lt;/p&gt;
&lt;p&gt;　　决定了获得统计量的数据范围，那么接下来的问题是如何获得均值和方差的问题。很简单，因为每次做Mini-Batch训练时，都会有那个Mini-Batch里m个训练实例获得的均值和方差，现在要全局统计量，只要把每个Mini-Batch的均值和方差统计量记住，然后对这些均值和方差求其对应的数学期望即可得出全局统计量，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522211109253&quot; alt=&quot;&quot; width=&quot;207&quot; height=&quot;75&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　有了均值和方差，每个隐层神经元也已经有对应训练好的Scaling参数和Shift参数，就可以在推导的时候对每个神经元的激活数据计算NB进行变换了，在推理过程中进行NB采取如下方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522211128691&quot; alt=&quot;&quot; width=&quot;332&quot; height=&quot;48&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个公式其实和训练时&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522211144175&quot; alt=&quot;&quot; width=&quot;236&quot; height=&quot;36&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　是等价的，通过简单的合并计算推导就可以得出这个结论。那么为啥要写成这个变换形式呢？我猜作者这么写的意思是：在实际运行的时候，按照这种变体形式可以减少计算量，为啥呢？因为对于每个隐层节点来说：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20160522211201143&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;都是固定值，这样这两个值可以事先算好存起来，在推理的时候直接用就行了，这样比原始的公式每一步骤都现算少了除法的运算过程，乍一看也没少多少计算量，但是如果隐层节点个数多的话节省的计算量就比较多了。&lt;/p&gt;
&lt;h2&gt;五、BatchNorm的好处&lt;/h2&gt;
&lt;p&gt;　　BatchNorm为什么NB呢，关键还是效果好。&lt;span&gt;&lt;strong&gt;①&lt;/strong&gt;&lt;strong&gt;不仅仅极大提升了训练速度，收敛过程大大加快；②还能增加分类效果，一种解释是这是类似于Dropout的一种防止过拟合的正则化表达方式，所以不用Dropout也能达到相当的效果；③另外调参过程也简单多了，对于初始化要求没那么高，而且可以使用大的学习率等。&lt;/strong&gt;&lt;/span&gt;总而言之，经过这么简单的变换，带来的好处多得很，这也是为何现在BN这么快流行起来的原因。&lt;/p&gt;

</description>
<pubDate>Thu, 05 Apr 2018 13:50:00 +0000</pubDate>
<dc:creator>郭耀华</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/guoyaohua/p/8724433.html</dc:identifier>
</item>
</channel>
</rss>