<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>病毒分析第二讲,分析病毒的主要功能 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7898188.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7898188.html</guid>
<description>&lt;p&gt;---恢复内容开始---&lt;/p&gt;

&lt;p&gt;经过昨天病毒分析第一讲,得出一个被注入的DLL&lt;/p&gt;
&lt;p&gt;开始分析DLL主要功能&lt;/p&gt;
&lt;p&gt;PS: IDA中,DLL会有各种初始化的代码,和释放资源,所以不再看,只看重要的API&lt;/p&gt;
&lt;h2&gt;一丶行为分析(创建命名互斥体,防止病毒多开)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126020048859-969856804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入函数去看,从DLLmain入口点分析.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126020134171-2032316317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得出,第一步,病毒为了防止重复注入IE,创建命名互斥体.&lt;/p&gt;
&lt;p&gt;名字是:  &quot;KyUffThOkYwRRtgPP&quot;&lt;/p&gt;

&lt;h3&gt; 二丶拼接字符串,创建文件,写入系统当前时间&lt;/h3&gt;
&lt;p&gt;进入DLLmain第二个函数查看.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126022138703-892492851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS:分析到哪里都已经改名字了,原名字不是Init,这个是根据分析里面的函数调用的出来的.&lt;/p&gt;
&lt;p&gt;点击进入,查看具体怎么做了&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126022448203-1633954423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 根据分析,可以分为四部分去看&lt;/p&gt;
&lt;p&gt;1.初始化各种数据&lt;/p&gt;
&lt;p&gt;2.经过一些列自己写的算法运算&lt;/p&gt;
&lt;p&gt;3.获取磁盘和驱动器的信息,并且处理文件&lt;/p&gt;
&lt;p&gt;4.写入系统时间(需要跟随大里面去看)&lt;/p&gt;
&lt;p&gt;虚拟机动态调试查看.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126025017000-1286719423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一次,通过动态分析,得出会拼接一个字符串,为&lt;/p&gt;
&lt;p&gt;当前的: C:Documents and settings\Administrator\桌面\xxxx\dmiconf.data&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126025913000-62446975.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 第二此分析,得出,在目录下面创建这个文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126030037031-1654538855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126030127796-1555788329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写入的内容是时间&lt;/p&gt;
&lt;p&gt;得出第二次行为:&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;创建文件dmlconf.dat在当前目录,并且写入文件内容为当前时间&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;15&quot;&gt;&lt;span&gt;三丶分析行为三,写入注册表,实现开机自启动&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;继续分析DLLmain下面的API&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;15&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126030424453-538551918.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;点击API进去查看.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126030613796-1913015776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面还有一层,进去查看.没有命名的函数都是无关紧要的,这些都是实现命名过了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126030756625-1413033055.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进去一层则看到&lt;/p&gt;
&lt;p&gt;1.打开注册表&lt;/p&gt;
&lt;p&gt;2.遍历注册表的值&lt;/p&gt;
&lt;p&gt;3.修改注册表的值&lt;/p&gt;
&lt;p&gt;4.关闭注册表&lt;/p&gt;
&lt;p&gt;此时我们需要动态查看是进入是修改的那个注册表了.&lt;/p&gt;
&lt;h3&gt;1.找到线程回调&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126035741578-89190773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.线程回调进入下段点,并设置为新的EIP&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126035948109-390043155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置的快捷键是 Ctrl + * 键&lt;/p&gt;
&lt;h3&gt;3.进入Call查看 &lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126040156546-656773483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 4.查看注册表操作&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126040338015-1983090948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得出了要操作注册表&lt;/p&gt;
&lt;p&gt;HEEY_LOCAL_MACHINE Software\Microsoft\Windows NT\CurrentVersion\Winlogon&lt;/p&gt;
&lt;p&gt;这个正好是开机启动项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126040548218-1780985927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过上面和下面的分析,得出先获取注册表的值,然后申请内存&lt;/p&gt;
&lt;p&gt;写入我们的内容&lt;/p&gt;
&lt;p&gt;时间关系,不一步一不的跟了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201711/1197364-20171126042003968-1717304317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实跟进去看的话她会设置自己的子体到里面,这样就会开机自启动了.&lt;/p&gt;
&lt;h2&gt;四丶网络相关&lt;/h2&gt;
&lt;p&gt; 此病毒还涉及到网络相关,但是现在这个病毒现在也链接不了服务器了.所以网络相关的掠过&lt;/p&gt;
&lt;p&gt;如果想明白原理,建议自己跟一下看下也可以.&lt;/p&gt;
&lt;h2&gt;五丶修改PE文件,修改Html&lt;/h2&gt;
&lt;p&gt;此功能昨天已经快速定位到了.&lt;/p&gt;
&lt;p&gt;鉴于时间关系不一步一步的分析了.此次样本分析完毕.&lt;/p&gt;

&lt;p&gt;得出行为:&lt;/p&gt;
&lt;p&gt;　　1.使用命名互斥体,防止多开&lt;/p&gt;
&lt;p&gt;　　2.创建文件在dmlconf.dat在C盘目录下,并写入时间&lt;/p&gt;
&lt;p&gt;　　3.写入注册表开机自动启动&lt;/p&gt;
&lt;p&gt;　　4.链接服务器,发送和接受数据&lt;/p&gt;
&lt;p&gt;　　5.修改PE,以及html&lt;/p&gt;

</description>
<pubDate>Sat, 25 Nov 2017 20:46:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7898188.html</dc:identifier>
</item>
<item>
<title>[OIDC in Action] 1. 基于OIDC（OpenID Connect）的SSO - Blackheart</title>
<link>http://www.cnblogs.com/linianhui/p/oidc-in-action-sso.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linianhui/p/oidc-in-action-sso.html</guid>
<description>&lt;p&gt;在&lt;a href=&quot;http://www.cnblogs.com/linianhui/category/929878.html&quot; target=&quot;_blank&quot;&gt;[认证授权]&lt;/a&gt;系列博客中，分别对OAuth2和OIDC在理论概念方面进行了解释说明，其间虽然我有写过一个完整的示例（&lt;a href=&quot;https://github.com/linianhui/oidc.example&quot; target=&quot;_blank&quot;&gt;https://github.com/linianhui/oidc.example&lt;/a&gt;），但是却没有在实践方面做出过解释。在这里新开一个系列博客，来解释其各种不同的应用场景。因为OIDC是在OAuth2之上的协议，所以这其中也会包含OAuth2的一些内容。&lt;/p&gt;
&lt;p&gt;OIDC协议本身有很多的开源实现，这里选取的是基于.Net的开源实现基于&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4&quot; target=&quot;_blank&quot;&gt;IdentityServer4&lt;/a&gt;。本系列的源代码位于&lt;a href=&quot;https://github.com/linianhui/oidc.example&quot; target=&quot;_blank&quot;&gt;https://github.com/linianhui/oidc.example&lt;/a&gt;。clone下来后用管理员身份运行build.ps1来部署整个系统，其中可能会弹出UAC警告（脚本会修改host文件，记得允许管理员读写这个文件先）。部署完后的样子如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125200012234-991774929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125200054484-4142294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文中主要是关注一下SSO这部分的内容，主要是&lt;strong&gt;跨一级域&lt;/strong&gt;的&lt;strong&gt;单点登录&lt;/strong&gt;和&lt;strong&gt;统一登出&lt;/strong&gt;功能。其中涉及到的站点有一下4个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;oidc-server.dev：利用oidc实现的统一认证和授权中心，SSO站点。&lt;/li&gt;
&lt;li&gt;oidc-client-hybrid.dev：oidc的一个客户端，采用hybrid模式。&lt;/li&gt;
&lt;li&gt;oidc-client-implicit.dev：odic的另一个客户端，采用implicit模式。&lt;/li&gt;
&lt;li&gt;oidc-client-js.dev：oidc的又一个客户端，采用implicit模式，纯静态网站，只有js和html，无服务端代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通常来讲，SSO包括&lt;strong&gt;统一的登录&lt;/strong&gt;和&lt;strong&gt;统一的登出&lt;/strong&gt;这两部分。基于OIDC实现的SSO主要是利用OIDC服务作为用户认证中心作为统一入口，使得所有的需要登录的地方都交给OIDC服务来做。更直白点说就是把需要进行用户认证的客户端中的用户认证这部分都剥离出来交给OIDC认证中心来做。具体的交互流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125203425109-653379399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中这三个客户端是完全独立的位于不同的域名之下，且没有任何依赖关系，三者均依赖oidc-server.dev这个站点进行认证和授权，通信协议为HTTP，那么下面则通过它们之间的HTTP消息来解释其具体的流程。这个过程中使用fiddler来进行监视其所有的请求。&lt;/p&gt;
&lt;h2&gt;第1步：OIDC-Client- 触发认证请求&lt;/h2&gt;
&lt;p&gt;在浏览器打开&lt;strong&gt;oidc-client-implicit.dev&lt;/strong&gt;这个站点，打开后如下（QQ这个先不管它，后面单独介绍）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125204918421-637260866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击Oidc Login后，会触发一个302的重定向操作。具体的HTTP请求和响应信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125205416140-54770807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Request：Get后面的URL是我们点击Oidc Login的Url，这个URL包含一个参数，代表登录成功后所要回到的页面是哪里。&lt;/p&gt;
&lt;p&gt;Response：服务器返回了一个302重定向。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Location的Url指向了oidc-server.dev这个站点，其中还携带了一大堆参数（参数后面一小节介绍）；&lt;/li&gt;
&lt;li&gt;Set-Cookie设置了一个nonce的cookie，主要目的用于安全方面。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;第2步：OIDC-Client - 认证请求&lt;/h2&gt;
&lt;p&gt;紧接上一步，浏览器在接收到第1步的302响应后，会对Location所指定的URL发起一个Get请求。这个请求携带的参数如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125210334625-999970810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中参数的含义在&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/openid-connect-core.html#auto_id_7&quot; target=&quot;_blank&quot;&gt;OIDC的认证请求&lt;/a&gt;有详细的解释（注：其中采用的认证类型不管是authorization code，或者implict，还是hybrid都无关紧要，它们的区别只是其适用场景的差异，并不影响整个流程）。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;client_id=implicit-client：发起认证请求的客户端的唯一标识，这个客户端事先已经在oidc-server.dev这个站点注册过了。&lt;/li&gt;
&lt;li&gt;reponse_mode=form_post：指示oidc服务器应该使用form表单的形式返回数据给客户端。&lt;/li&gt;
&lt;li&gt;response_type=id_token：区别于oauth2授权请求的一点，必须包含有id_token这一项。&lt;/li&gt;
&lt;li&gt;scope=openid profile：区别于oauth2授权请求的一点，必须包含有openid这一项。&lt;/li&gt;
&lt;li&gt;state：oauth2定义的一个状态字符串，这里的实现是加密保存了一些客户端的状态信息（用于记录客户端的一些状态，在登录成功后会有用处），oidc会在认证完成后原样返回这个参数。&lt;/li&gt;
&lt;li&gt;nonce：上一步中写入cookie的值，这字符串将来会包含在idtoken中原样返回给客户端。&lt;/li&gt;
&lt;li&gt;redirect_uri：认证成功后的回调地址，oidc-server.dev会把认证的信息发送给这个地址。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;第3步：OIDC-Server - 验证请求信息&lt;/h2&gt;
&lt;p&gt;oidc-server.dev站点会验证第2步中传递过来的信息，比如client_id是否有效，redircet_uri是否合法，其他的参数是否合法之类的验证。如果验证通过，则会进行下一步操作。&lt;/p&gt;
&lt;h2&gt;第4步：OIDC-Server - 打开登录页面&lt;/h2&gt;
&lt;p&gt;在oidc-server.dev站点验证完成后，&lt;strong&gt;如果没有从来没有客户端通过oidc-server.dev登陆过，那么第2步的请求会返回一个302重定向重定向到登录页面&lt;/strong&gt;。&lt;strong&gt;如果是已经登录，则会直接返回第5步中生产重定向地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125212816781-808682152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;浏览器会打开响应消息中Location指定的地址（登录页面）。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125214220078-1722927925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;第5步：OIDC-Server - 完成用户登录，同时记录登录状态&lt;/h2&gt;
&lt;p&gt;在第四步输入账户密码点击提交后，会POST如下信息到服务器端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125214231171-1367563199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务器验证用户的账号密码，通过后会使用Set-cookie维持自身的登录状态。然后使用302重定向到下一个页面。&lt;/p&gt;
&lt;h2&gt;第6步：浏览器 - 打开上一步重定向的地址，同时自动发起一个post请求&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125214244468-1820768675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;form的地址是在第2步中设置的回调地址，form表单中包含（根据具体的认证方式authorization code，implict或者hybrid，其包含的信息会有一些差异，这个例子中是采用的implicit方式）如下信息：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;id_token：&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/openid-connect-core.html#auto_id_5&quot; target=&quot;_blank&quot;&gt;id_token&lt;/a&gt;即为认证的信息，OIDC的核心部分，采用&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/oauth2-extensions-protocol-and-json-web-token.html#auto_id_5&quot; target=&quot;_blank&quot;&gt;JWT格式&lt;/a&gt;包装的一个字符串。&lt;/li&gt;
&lt;li&gt;scope：用户允许访问的scope信息。&lt;/li&gt;
&lt;li&gt;state：第1步中发送的state，原样返回。&lt;/li&gt;
&lt;li&gt;session_state：会话状态。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/openid-connect-core.html#auto_id_5&quot; target=&quot;_blank&quot;&gt;id_token&lt;/a&gt;包含的具体的信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125220745625-1675189586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其中包含认证的服务器信息iss，客户端的信息aud，时效信息nbf和exp，用户信息sub和nickname，会话信息sid，以及第1步中设置的nonce。还有其签名的信息alg=RS256，表示idtoken最后的一段信息（上图中浅蓝色的部分）是oidc-server.dev使用RSA256对id_token的header和payload部分所生产的数字签名。客户端需要使用oidc-server.dev提供的公钥来验证这个数字签名&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;第7步：OIDC-Client - 接收第6步POST过来的参数，构建自身的登录状态&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125222039390-1426574351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端验证id_token的有效性，其中验证所需的公钥来自&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/openid-connect-extension.html#auto_id_0&quot; target=&quot;_blank&quot;&gt;OIDC的发现服务&lt;/a&gt;中的jwk_uri，这个验证是必须的，目的时为了保证客户端得到的id_token是oidc-sercer.dev颁发的，并且没有被篡改过，以及id_token的有效时间验证。&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/security-based-toolbox.html#auto_id_16&quot; target=&quot;_blank&quot;&gt;数字签名&lt;/a&gt;的JWT可以保证id_token的不可否认性，认证和完整性，但是并不能保证其机密性，所以id_token中千万不要包含有机密性要求的敏感的数据。如果确实需要包含，则需要对其进行加密处理（比如JWE规范）。其中验证也包含对nonce（包含在id_token中）的验证（第1步设置的名为nonce的cookie）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在验证完成后，客户端就可以取出来其中包含的用户信息来构建自身的登录状态，比如上如中Set-Cookie=lnh.oidc这个cookie。然后清除第1步中设置的名为nonce的cookie。&lt;/p&gt;
&lt;p&gt;最后跳转到客户端指定的地址（这个地址信息被保存在第1步中传递给oidc-server.dev的state参数中，被oidc-server.dev原样返回了这个信息）。然后读取用户信息如下（这里读取的是id_token中的完整信息）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125222146859-1871035934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;其他的客户端登录&lt;/h2&gt;
&lt;p&gt;登录流程是和上面的步骤是一样的，一样会发起认证请求，区别在于已经登录的时候会在第4步直接返回post信息给客户端的地址，而不是打开一个登录页面，这里就不再详细介绍了。大家可以在本地运行一下，通过fiddler观察一下它们的请求流程。贴一下oidc-client-hybrid.dev这个客户端登录后的页面吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125231909609-2081337290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;退出的流程相比登录简单一些。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125233327093-1665849488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中核心部分在于利用浏览器作为中间的媒介，来逐一的通知已经登录的客户端退出登录。&lt;/p&gt;
&lt;h2&gt;第1步：OIDC-Client - 触发登出请求&lt;/h2&gt;
&lt;p&gt;点击Logout链接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125231909609-2081337290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击退出后会触发一个GET请求，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125233853281-1409909241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图这个请求会返回一个302的响应，Location的地址指向oidc-server.dev的一个endsession的接口。同时会通过Set-Cookie来清除自身的cookie。&lt;/p&gt;
&lt;h2&gt;第2步：OIDC-Client - 登出请求&lt;/h2&gt;
&lt;p&gt;浏览器通过GET访问上一步中指定的Location地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125234624656-182330914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接口地址定义在&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/openid-connect-extension.html#auto_id_0&quot; target=&quot;_blank&quot;&gt;OIDC的发现服务&lt;/a&gt;中的end_session_endpoint字段中，参数信息定义在&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/openid-connect-extension.html#auto_id_3&quot; target=&quot;_blank&quot;&gt;OIDC的Front-Channel-Logout规范&lt;/a&gt;中。&lt;/p&gt;
&lt;h2&gt;第3步：OIDC-Server - 验证登出请求&lt;/h2&gt;
&lt;p&gt;验证上图中传递的信息，如果信息无误则再一次重定向到一个地址（这里是IdentityServer4的实现机制，其实可以无需这个再次重定向的）。&lt;/p&gt;
&lt;h2&gt;第4步：OIDC-Server - 登出自身，返回包含IFrame的HTML&lt;/h2&gt;
&lt;p&gt;浏览器打开第3步中重定向的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171125235243593-20753457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;响应中会通过Set-Cookie（idsrv和idsrv.session）清除oidc-server.dev自身的登录状态。然后包含一个HTML表单页面，上图中iframe指向的地址是IdentityServer4内部维持的一个地址。访问这个地址后的信息如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;iframe&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;none&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;iframe &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;='http://oidc-client-implicit.dev/oidc/front-channel-logout-callback?sid=b51ea235574807beb0deff7c6db6a381&amp;amp;iss=http%3A%2F%2Foidc-server.dev'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;iframe&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;iframe &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;='http://oidc-client-hybrid.dev/oidc/front-channel-logout-callback?sid=b51ea235574807beb0deff7c6db6a381&amp;amp;iss=http%3A%2F%2Foidc-server.dev'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;iframe&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码中的iframe是真正的调用已经登录的客户端进行登出的地址（IdentityServer4会记录下来已经登录的客户端，没有登陆过的和没有配置启用Front-Channel-Logout的则不会出现在这里）。其中iframe指向的地址是OIDC客户端在oidc-server.dev中注册的时候配置的地址。参数则是动态附加上去的参数。&lt;/p&gt;
&lt;p&gt;最后页面中包含一个js脚本文件，在页面load完成后，跳转到第2步中指定的post_logout_redirect_uri指向的回调页面。&lt;/p&gt;
&lt;h2&gt;第5步：OIDC-Client - 处理登出回调通知&lt;/h2&gt;
&lt;p&gt;在浏览器访问上面代码中iframe指向的地址的时候，被动登出的OIDC客户端会接收到登出通知。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/168328/201711/168328-20171126000841453-1217915494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;响应中通过Set-Cookie（lnh.oidc）清除了需要被动登出的客户端的Cookie。至此，统一的登出完成。&lt;/p&gt;

&lt;p&gt;本文介绍了基于OIDC实现的SSO的工作原理和流程，但并未涉及到OIDC的具体实现IdentityServer4的是如何使用的（这部分通过读我提供的源码应该是很容易理解的），旨在解释一下如何用OIDC实现SSO，而非如何使用OIDC的某一个实现框架。OIDC是一个协议族，这些具体每一步怎么做都是有标准的规范的，所以侧重在了用HTTP来描述这个过程，这样这个流程也就可以用在java,php,nodejs等等开发平台上。&lt;/p&gt;

&lt;p&gt;本文源代码：&lt;a href=&quot;https://github.com/linianhui/oidc.example&quot; target=&quot;_blank&quot;&gt;https://github.com/linianhui/oidc.example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;认证授权：&lt;a href=&quot;http://www.cnblogs.com/linianhui/category/929878.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/linianhui/category/929878.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Id Token：&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/openid-connect-core.html#auto_id_5&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/linianhui/p/openid-connect-core.html#auto_id_5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JWT：&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/oauth2-extensions-protocol-and-json-web-token.html#auto_id_5&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/linianhui/p/oauth2-extensions-protocol-and-json-web-token.html#auto_id_5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;数字签名：&lt;a href=&quot;http://www.cnblogs.com/linianhui/p/security-based-toolbox.html#auto_id_16&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/linianhui/p/security-based-toolbox.html#auto_id_16&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OIDC：&lt;a href=&quot;http://openid.net/connect/&quot; target=&quot;_blank&quot;&gt;http://openid.net/connect/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IdentityServer4：&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4&quot; target=&quot;_blank&quot;&gt;https://github.com/IdentityServer/IdentityServer4&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Nov 2017 17:09:00 +0000</pubDate>
<dc:creator>Blackheart</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linianhui/p/oidc-in-action-sso.html</dc:identifier>
</item>
<item>
<title>源码剖析Django REST framework的认证方式及自定义认证 - renpingsheng</title>
<link>http://www.cnblogs.com/renpingsheng/p/7897192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renpingsheng/p/7897192.html</guid>
<description>&lt;h2 id=&quot;源码剖析django-rest-framework的认证方式&quot;&gt;源码剖析Django REST framework的认证方式&lt;/h2&gt;
&lt;p&gt;在前面说过,请求到达REST framework的时候,会对request进行二次封装,在封装的过程中会对客户端发送过来的request封装进认证,选择,解析等功能&lt;/p&gt;
&lt;p&gt;request方法封装完成之后,执行initial方法时,又会再次对客户端的请求执行认证操作,确保请求的合法性&lt;/p&gt;
&lt;p&gt;现在来说说&lt;code&gt;REST framework&lt;/code&gt;的认证&lt;/p&gt;
&lt;p&gt;在对request方法进行封装时,通过查看dispatch的源码,可以知道request二次封装是调用了&lt;code&gt;get_authenticators&lt;/code&gt;这个方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def initialize_request(self, request, *args, **kwargs):
    &quot;&quot;&quot;
    Returns the initial request object.
    &quot;&quot;&quot;
    parser_context = self.get_parser_context(request)
            self.authentication_classes
    return Request(
        request,
        parsers=self.get_parsers(),
        authenticators=self.get_authenticators(),
        negotiator=self.get_content_negotiator(),
        parser_context=parser_context
    )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次查看get_authenticators方法的源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def get_authenticators(self):                                  
    &quot;&quot;&quot;                                                        
    Instantiates and returns the list of authenticators that th
    &quot;&quot;&quot;                                                        
    return [auth() for auth in self.authentication_classes]    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出使用了列表生成式,如果&lt;code&gt;self.authentication_classes&lt;/code&gt;是一个列表,且列表中的每一个元素都是一个类,则循环这个列表,并对列表中的元素进行实例化&lt;/p&gt;
&lt;p&gt;所以可以知道,&lt;code&gt;self.get_authenticators()&lt;/code&gt;方法的执行结果是一个对象列表&lt;/p&gt;
&lt;p&gt;还有一个问题,列表生成式中的&lt;code&gt;self.authentication_classes&lt;/code&gt;又是什么呢??&lt;/p&gt;
&lt;p&gt;再查看&lt;code&gt;self.authentication_classes&lt;/code&gt;的源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class APIView(View):

    # The following policies may be set at either globally, or per-view.
    renderer_classes = api_settings.DEFAULT_RENDERER_CLASSES
    parser_classes = api_settings.DEFAULT_PARSER_CLASSES
    authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES
    throttle_classes = api_settings.DEFAULT_THROTTLE_CLASSES
    permission_classes = api_settings.DEFAULT_PERMISSION_CLASSES
    content_negotiation_class = api_settings.DEFAULT_CONTENT_NEGOTIATION_CLASS
    metadata_class = api_settings.DEFAULT_METADATA_CLASS
    versioning_class = api_settings.DEFAULT_VERSIONING_CLASS

    # Allow dependency injection of other settings to make testing easier.
    settings = api_settings
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出,&lt;code&gt;authentication_classes来自api_settings&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看REST framework的views.py文件的导入模块时,可以看到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1133627/201711/1133627-20171126000021234-322686773.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说&lt;code&gt;authentication_classes是来看于REST framework的配置文件&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;新建一个项目test_rest,定义视图函数,打印authentication_classes到底是什么??&lt;/p&gt;
&lt;p&gt;views.py文件内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.shortcuts import render,HttpResponse
from rest_framework.views import APIView

class UsersView(APIView):

    def get(self,request,*args,**kwargs):

        print('authentication_classes:', self.authentication_classes)
        return HttpResponse(&quot;aaaa&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;authentication_classes: [&amp;lt;class 'rest_framework.authentication.SessionAuthentication'&amp;gt;, &amp;lt;class 'rest_framework.authentication.BasicAuthentication'&amp;gt;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可以知道,&lt;code&gt;authentication_classes&lt;/code&gt;默认就是这两个类&lt;/p&gt;
&lt;p&gt;在视图函数中导入这两个类,再查看这两个类的源码,可以知道&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class BasicAuthentication(BaseAuthentication):

    www_authenticate_realm = 'api' 

    def authenticate(self, request):

        ...

    def authenticate_credentials(self, userid, password):

        ...

class SessionAuthentication(BaseAuthentication):

    def authenticate(self, request):

        ...

    def enforce_csrf(self, request):

        ...
        
class TokenAuthentication(BaseAuthentication):
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个文件中,可以发现,这个文件中不仅定义了&lt;code&gt;SessionAuthentication&lt;/code&gt;和&lt;code&gt;BasicAuthentication&lt;/code&gt;这两个类,&lt;/p&gt;
&lt;p&gt;相关的类还有&lt;code&gt;TokenAuthentication&lt;/code&gt;,而且这三个认证相关的类都是继承自&lt;code&gt;BaseAuthentication&lt;/code&gt;类&lt;/p&gt;
&lt;p&gt;从上面的源码可以大概知道,这三个继承自&lt;code&gt;BaseAuthentication&lt;/code&gt;的类是不同的认证方式.&lt;/p&gt;
&lt;p&gt;到现在大致的认证流程也已经清楚了&lt;/p&gt;
&lt;p&gt;&lt;code&gt;get_authenticators&lt;/code&gt;方法获取到&lt;code&gt;SessionAuthentication&lt;/code&gt;类和&lt;code&gt;BasicAuthentication&lt;/code&gt;类,并实例化后返回经&lt;br/&gt;REST framework方法中的&lt;code&gt;initialize_request&lt;/code&gt;方法,把这两个方法的实例化对象封装进行客户端发过来的request中,返回REST framework中看到的Request&lt;/p&gt;
&lt;p&gt;查看REST framework中的Request方法的源码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1133627/201711/1133627-20171126000037015-507383051.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Request方法中,&lt;code&gt;get_authenticators&lt;/code&gt;方法执行完成返回的对象列表被赋值给了&lt;code&gt;authenticators&lt;/code&gt;参数&lt;/p&gt;
&lt;p&gt;所以在REST framework中执行&lt;code&gt;request.authenticators&lt;/code&gt;方法时,就是在调用相关的认证功能对请求进行过滤&lt;/p&gt;
&lt;p&gt;Django REST framework的认证方式的执行流程图解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1133627/201711/1133627-20171126000358984-1632031741.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;request封装完成后执行&lt;code&gt;initial&lt;/code&gt;方法,在这里调用默认的认证功能进行认证,返回认证通过后的用户对象&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def perform_authentication(self, request):

    request.user&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入request.user的执行流程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def _authenticate(self):
    &quot;&quot;&quot;
    Attempt to authenticate the request using each authentication instance
    in turn.
    Returns a three-tuple of (authenticator, user, authtoken).
    &quot;&quot;&quot;
    for authenticator in self.authenticators:
        try:
            user_auth_tuple = authenticator.authenticate(self)
        except exceptions.APIException:
            self._not_authenticated()
            raise

        if user_auth_tuple is not None:
            self._authenticator = authenticator
            self.user, self.auth = user_auth_tuple
            return

    self._not_authenticated()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里&lt;code&gt;self.authenticators&lt;/code&gt;方法的执行结果就是&lt;code&gt;get_authenticators&lt;/code&gt;方法执行完成后返回的对象列表&lt;/p&gt;
&lt;p&gt;循环认证的对象列表,执行每一个认证方法的类中的authenticate方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class ForcedAuthentication(object):
    &quot;&quot;&quot;
    This authentication class is used if the test client or request factory
    forcibly authenticated the request.
    &quot;&quot;&quot;

    def __init__(self, force_user, force_token):
        self.force_user = force_user
        self.force_token = force_token

    def authenticate(self, request):
        return (self.force_user, self.force_token)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;authenticate&lt;/code&gt;方法返回用户认证的元组,这个元组包括通过认证的用户及用户的口令&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;_authenticate&lt;/code&gt;方法中使用了try/except方法来捕获authenticate方法可能出现的异常&lt;/p&gt;
&lt;p&gt;如果出现异常,就调用&lt;code&gt;_not_authenticated&lt;/code&gt;方法来设置返回元组中的用户及口令并终止程序继续运行&lt;/p&gt;
&lt;h2 id=&quot;自定义认证功能&quot;&gt;自定义认证功能&lt;/h2&gt;
&lt;p&gt;在上面我们知道,Request会调用认证相关的类及方法,&lt;code&gt;APIView&lt;/code&gt;会设置认证相关的类及方法&lt;/p&gt;
&lt;p&gt;所以如果想自定义认证功能,只需要重写&lt;code&gt;authenticate&lt;/code&gt;方法及&lt;code&gt;authentication_classes&lt;/code&gt;的对象列表即可&lt;/p&gt;
&lt;p&gt;新建一个项目test_auth,项目中有一个app01的项目&lt;/p&gt;
&lt;p&gt;在项目配置文件的&lt;code&gt;INSTALLED_APPS&lt;/code&gt;中引入rest_framework,&lt;/p&gt;
&lt;p&gt;urls.py文件配置如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.conf.urls import url
from django.contrib import admin
from app01 import views

urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^users/',views.UsersView.as_view())
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的视图函数内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.shortcuts import render,HttpResponse
from rest_framework.views import APIView
from rest_framework.authentication import BaseAuthentication
from rest_framework import exceptions

TOKEN_LIST=[            # 定义token_list
    'aabbcc',
    'ddeeff',
]
class UserAuthView(BaseAuthentication):
    def authenticate(self,request):
        tk=request._request.GET.get(&quot;tk&quot;)   # request._request为原生的request

        if tk in TOKEN_LIST:
            return (tk,None)        # 返回一个元组
        raise exceptions.AuthenticationFailed(&quot;用户认证失败&quot;)

    def authenticate_header(self,request):
        pass

class UsersView(APIView):
    authentication_classes = [UserAuthView,]

    def get(self,request,*args,**kwargs):
        print(request.user)

        return HttpResponse(&quot;.....&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动项目,在浏览器中输入&lt;code&gt;http://127.0.0.1:8000/users/?tk=aabbcc&lt;/code&gt;,然后回车,在服务端后台会打印&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;aabbcc&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把浏览器中的url换为&lt;code&gt;http://127.0.0.1:8000/users/?tk=ddeeff&lt;/code&gt;,后台打印信息则变为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ddeeff&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就实现REST framework的自定义认证功能&lt;/p&gt;
&lt;h2 id=&quot;rest-framework认证的扩展&quot;&gt;REST framework认证的扩展&lt;/h2&gt;
&lt;h3 id=&quot;基于token进行用户认证&quot;&gt;基于Token进行用户认证&lt;/h3&gt;
&lt;p&gt;修改上面的项目，在urls.py文件中添加一条路由记录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.conf.urls import url
from django.contrib import admin
from app01 import views

urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^users/',views.UsersView.as_view()),
    url(r'^auth/',views.AuthView.as_view()),
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改视图函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.shortcuts import render,HttpResponse
from rest_framework.views import APIView
from rest_framework.authentication import BaseAuthentication
from rest_framework import exceptions
from django.http import JsonResponse

def gen_token(username):
    &quot;&quot;&quot;
    利用时间和用户名生成用户token
    :param username: 
    :return: 
    &quot;&quot;&quot;
    import time
    import hashlib
    ctime=str(time.time())
    hash=hashlib.md5(username.encode(&quot;utf-8&quot;))
    hash.update(ctime.encode(&quot;utf-8&quot;))
    return hash.hexdigest()

class AuthView(APIView):
    def post(self, request, *args, **kwargs):
        &quot;&quot;&quot;
        获取用户提交的用户名和密码，如果用户名和密码正确，则生成token，并返回给用户
        :param request:
        :param args:
        :param kwargs:
        :return:
        &quot;&quot;&quot;
        res = {'code': 1000, 'msg': None}
        user = request.data.get(&quot;user&quot;)
        pwd = request.data.get(&quot;pwd&quot;)

        from app01 import models
        user_obj = models.UserInfo.objects.filter(user=user, pwd=pwd).first()

        if user_obj:
            token = gen_token(user) # 生成用户口令

            # 如果数据库中存在口令则更新,如果数据库中不存在口令则创建用户口令
            models.Token.objects.update_or_create(user=user_obj, defaults={'token': token})
            print(&quot;user_token:&quot;, token)
            res['code'] = 1001
            res['token'] = token
        else:
            res['msg'] = &quot;用户名或密码错误&quot;

        return JsonResponse(res)
    
class UserAuthView(BaseAuthentication):
    def authenticate(self,request):
        tk=request.query_params.GET.get(&quot;tk&quot;)   # 获取请求头中的用户token

        from app01 import models

        token_obj=models.Token.objects.filter(token=tk).first()

        if token_obj:   # 用户数据库中已经存在用户口令返回认证元组
            return (token_obj.user,token_obj)

        raise exceptions.AuthenticationFailed(&quot;认证失败&quot;)

    def authenticate_header(self,request):
        pass

class UsersView(APIView):
    authentication_classes = [UserAuthView,]

    def get(self,request,*args,**kwargs):

        return HttpResponse(&quot;.....&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建用户数据库的类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.db import models

class UserInfo(models.Model):
    user=models.CharField(max_length=32)
    pwd=models.CharField(max_length=64)
    email=models.CharField(max_length=64)

class Token(models.Model):
    user=models.OneToOneField(UserInfo)
    token=models.CharField(max_length=64)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建数据库,并添加两条用户记录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1133627/201711/1133627-20171126000140781-1551141195.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再创建一个test_client.py文件,来发送post请求&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import requests

response=requests.post(
    url=&quot;http://127.0.0.1:8000/auth/&quot;,
    data={'user':'user1','pwd':'user123'},
)

print(&quot;response_text:&quot;,response.text)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动Django项目,运行test_client.py文件,则项目的响应信息为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;response_text: {&quot;code&quot;: 1001, &quot;msg&quot;: null, &quot;token&quot;: &quot;3736c293443f52fd0c8224a33e0b5945&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此,就完成了自定义的基于token的用户认证&lt;/p&gt;
&lt;p&gt;如果想在项目中使用自定义的认证方式时,可以在&lt;code&gt;authentication_classes&lt;/code&gt;继承刚才的认证的类即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;authentication_classes = [UserAuthView,APIViiew]&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 25 Nov 2017 16:02:00 +0000</pubDate>
<dc:creator>renpingsheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renpingsheng/p/7897192.html</dc:identifier>
</item>
<item>
<title>学习java的优势 - 茆安国</title>
<link>http://www.cnblogs.com/maoanguo/p/7897146.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/maoanguo/p/7897146.html</guid>
<description>&lt;p&gt;              学习java之后，到企业的岗位&lt;/p&gt;
&lt;p&gt;&lt;span&gt;技术：java软件开发工程师（中初级）：技术一般；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;高级工程师：技术高等；&lt;/p&gt;
&lt;p&gt;技术架构师；技术顶级；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;管理：项目经理；产品经理；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;质询：质询顾问；销售经理；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;学会之后可以根据个人的爱好去从事相关的职位，但是不管是做哪一个都是需要技术的底子。希望能帮到你们。在这里我也提醒大家，去做管理和质询的话是需要一定口才的，当然不管做什么你都需要一个好口才，只有把自己推销出去让别人认可你， 你才能拿到高薪。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 Nov 2017 15:50:00 +0000</pubDate>
<dc:creator>茆安国</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/maoanguo/p/7897146.html</dc:identifier>
</item>
<item>
<title>Redis 快速入门 - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/7897131.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/7897131.html</guid>
<description>&lt;p&gt;谈到Redis，大家应该都不陌生。它是用c语言开发的一个高性能键值数据库，主要用于缓存领域。本章通过Redis的安装，Redis的五大数据类型，Redis的Java客户端，Redis与Spring 的整合 。来让读者对它有一个初步的了解。下一章再通过介绍配置文件来搭建Redis的主从模式和集群模式（配置大于编程，先从简单的编程入手）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果图&lt;/strong&gt;：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/806956/201711/806956-20171125214014703-1073380070.png&quot; alt=&quot;Redis 缓存项目效果图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求&lt;/strong&gt;：对商品类目进行Redis缓存处理&lt;br/&gt;&lt;strong&gt;技术&lt;/strong&gt;：Redis，Spring，SpringMVC，Mybatis，EasyUI&lt;br/&gt;&lt;strong&gt;说明&lt;/strong&gt;：EasyUI的树菜单上一章节有介绍，这里是为了方便展示效果。项目结构图中箭头所指的文件是需要重点学习的。若对EasyUI 树菜单感兴趣的可以访问：（该章节源码中提供商品类名的sql文件）&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/qq_19558705/article/details/78583888&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qq_19558705/article/details/78583888&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;源码&lt;/strong&gt;：见文章底部&lt;br/&gt;&lt;strong&gt;项目结构&lt;/strong&gt;：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/806956/201711/806956-20171125215651906-382867536.png&quot; alt=&quot;项目结构图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;redis-安装&quot;&gt;Redis 安装&lt;/h2&gt;
&lt;p&gt;安装文档:&lt;br/&gt;&lt;a href=&quot;https://github.com/ITDragonBlog/daydayup/blob/master/Redis/Redis%E5%AE%89%E8%A3%85.md&quot;&gt;https://github.com/ITDragonBlog/daydayup/blob/master/Redis/Redis%E5%AE%89%E8%A3%85.md&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;redis-五大数据类型&quot;&gt;Redis 五大数据类型&lt;/h2&gt;
&lt;p&gt;Redis 五大数据类型有String 类型，Hash 类型，List 类型，Set 类型，Zset（Sortedset）类型。其中常用的是前三个。&lt;br/&gt;官方提供的操作手册：&lt;a href=&quot;http://redisdoc.com/&quot; class=&quot;uri&quot;&gt;http://redisdoc.com/&lt;/a&gt;&lt;br/&gt;在redis 自带的客户端中输入命令时，可以使用tab自动补齐，新手建议不要偷懒。&lt;/p&gt;
&lt;h3 id=&quot;string-类型&quot;&gt;String 类型&lt;/h3&gt;
&lt;p&gt;String 是 redis 最基本的类型，一个key对应一个value。&lt;br/&gt;赋值：set key value&lt;br/&gt;取值：get key&lt;br/&gt;批量赋值：mset key value ... keyN valueN&lt;br/&gt;批量取值：mget key ... keyN&lt;br/&gt;取值并赋值：getset key value&lt;br/&gt;删除key：del key ... keyN&lt;br/&gt;数值加一：incr key&lt;br/&gt;数值加N：incrby key n&lt;br/&gt;数值减一：decr key&lt;br/&gt;数值减N：decrby key n&lt;br/&gt;字符串追加：append key value&lt;br/&gt;字符串长度：strlen key&lt;br/&gt;*注 形如&quot;key ... keyN&quot; 表示可以批量操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; set key value
OK
127.0.0.1:6379&amp;gt; get key
&quot;value&quot;
127.0.0.1:6379&amp;gt; mset key1 1 key2 2 key3 3
OK
127.0.0.1:6379&amp;gt; mget key1 key3
1) &quot;1&quot;
2) &quot;3&quot;
127.0.0.1:6379&amp;gt; del key
(integer) 1
127.0.0.1:6379&amp;gt; incr count
(integer) 1
127.0.0.1:6379&amp;gt; incrby count 10
(integer) 11
127.0.0.1:6379&amp;gt; decr count
(integer) 10
127.0.0.1:6379&amp;gt; decrby count 5
(integer) 5
127.0.0.1:6379&amp;gt; set str itdragon
OK
127.0.0.1:6379&amp;gt; append str &quot; blog!&quot;
(integer) 14
127.0.0.1:6379&amp;gt; get str
&quot;itdragon blog!&quot;
127.0.0.1:6379&amp;gt; strlen str
(integer) 14&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hash-散列类型&quot;&gt;Hash 散列类型&lt;/h3&gt;
&lt;p&gt;Redis hash 是一个键值对集合，和Java 的HashMap 类似。&lt;br/&gt;Redis hash 是一个String 类型的 field 和 value 的映射表，hash特别适合用于存储对象（key 可以是对象+id，field 是对象属性，value则是属性值）。&lt;br/&gt;给一个字段赋值：hset key field value&lt;br/&gt;给多个字段赋值：hmset key field value ... fieldN valueN&lt;br/&gt;取一个字段的值：hget key field&lt;br/&gt;取多个字段的值：gmset key field ... fieldN&lt;br/&gt;取所有的字段名和值：hgetall key&lt;br/&gt;删除字段名和值：hdel key field ... fieldN&lt;br/&gt;判断字段是否存在：hexists key field&lt;br/&gt;获取key的所有field：hkeys key&lt;br/&gt;获取key的所有value：hvals key&lt;br/&gt;获取field个数：hlen key&lt;br/&gt;*注：这里的field 就是 字段名，value 就是字段值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; hset user name itdragon
(integer) 1
127.0.0.1:6379&amp;gt; hget user name
&quot;itdragon&quot;
127.0.0.1:6379&amp;gt; hmset user position java study redis
OK
127.0.0.1:6379&amp;gt; hmget user position study
1) &quot;java&quot;
2) &quot;redis&quot;
127.0.0.1:6379&amp;gt; hgetall user
1) &quot;name&quot;
2) &quot;itdragon&quot;
3) &quot;position&quot;
4) &quot;java&quot;
5) &quot;study&quot;
6) &quot;redis&quot;
127.0.0.1:6379&amp;gt; hdel user name 
(integer) 1
127.0.0.1:6379&amp;gt; hdel user position study
(integer) 2
127.0.0.1:6379&amp;gt; hexists user name
(integer) 1
127.0.0.1:6379&amp;gt; hexists user age
(integer) 0
127.0.0.1:6379&amp;gt; hkeys user
1) &quot;name&quot;
2) &quot;position&quot;
3) &quot;study&quot;
127.0.0.1:6379&amp;gt; hvals user
1) &quot;itdragon&quot;
2) &quot;java&quot;
3) &quot;redis&quot;
127.0.0.1:6379&amp;gt; hlen user
(integer) 3&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;list-类型&quot;&gt;List 类型&lt;/h3&gt;
&lt;p&gt;Redis 列表是采用来链表来存储的简单字符串列表，按照插入顺序排序。添加元素一般从链表两端开始。&lt;br/&gt;向列表左侧加元素：lpush key value ... valueN&lt;br/&gt;向列表右侧加元素：rpush key value ... valueN&lt;br/&gt;遍历列表：lrange key startIndex endIndex&lt;br/&gt;获取List长度：llen key&lt;br/&gt;通过下标获取值：lindex key index&lt;br/&gt;通过下标设置值：lset key index value&lt;br/&gt;列表左侧移除第一个元素：lpop key&lt;br/&gt;列表右侧移除第一个元素：rpop key&lt;br/&gt;截取保留剩下的列表：ltrim key startIndex endIndex&lt;br/&gt;在制定元素插入值：linsert key after/before index value&lt;br/&gt;把集合第一个元素移到其他集合中：rpoplpush key otherListKey&lt;/p&gt;
&lt;ul readability=&quot;13&quot;&gt;&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;注：若endIndex=-1 表示最后一位；otherListKey 表示其他集合&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; lpush list 1 2
(integer) 2
127.0.0.1:6379&amp;gt; rpush list 3 4 
(integer) 4
127.0.0.1:6379&amp;gt; lrange list 0 -1
1) &quot;2&quot;
2) &quot;1&quot;
3) &quot;3&quot;
4) &quot;4&quot;
127.0.0.1:6379&amp;gt; lpop list
&quot;2&quot;
127.0.0.1:6379&amp;gt; rpop list
&quot;4&quot;
127.0.0.1:6379&amp;gt; llen list
(integer) 2
127.0.0.1:6379&amp;gt; lindex list 1
&quot;3&quot;
127.0.0.1:6379&amp;gt; linsert list after 1 2
(integer) 3
127.0.0.1:6379&amp;gt; linsert list before 3 4
(integer) 4
127.0.0.1:6379&amp;gt; ltrim list 0 1
OK
127.0.0.1:6379&amp;gt; rpoplpush list newlist
&quot;1&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;set-类型&quot;&gt;Set 类型&lt;/h3&gt;
&lt;p&gt;Redis 的 Set 是String类型的无序集合。它是通过HashTable实现实现的，用法和 List 类型很相似。&lt;br/&gt;新增集合元素：sadd key value ... valueN&lt;br/&gt;删除集合元素：srem key value ... valueN&lt;br/&gt;获取集合所有元素：smembers key&lt;br/&gt;判断集合元素是否存在：sismember key value&lt;br/&gt;集合差集：sdiff key1 key2&lt;br/&gt;集合交集：sinter key1 key2&lt;br/&gt;集合并集：sunion key1 key2&lt;br/&gt;获取集合长度：scard key1&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; sadd set a b c d
(integer) 4
127.0.0.1:6379&amp;gt; srem set a b c
(integer) 3
127.0.0.1:6379&amp;gt; smembers set
1) &quot;d&quot;
127.0.0.1:6379&amp;gt; sismember set a
(integer) 0
127.0.0.1:6379&amp;gt; sismember set d
(integer) 1
127.0.0.1:6379&amp;gt; sadd setA 1 2 3 
(integer) 3
127.0.0.1:6379&amp;gt; sadd setB 2 3 4
(integer) 3
127.0.0.1:6379&amp;gt; sdiff setA setB
1) &quot;1&quot;
127.0.0.1:6379&amp;gt; sdiff setB setA
1) &quot;4&quot;
127.0.0.1:6379&amp;gt; sinter setA setB
1) &quot;2&quot;
2) &quot;3&quot;
127.0.0.1:6379&amp;gt; sunion setA setB
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
127.0.0.1:6379&amp;gt; scard setA
(integer) 3&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;zset-类型&quot;&gt;Zset 类型&lt;/h3&gt;
Redis 的 zset（sorted set）和 set 一样也是string类型元素的集合,且不允许有重复的成员。不同的是 zset 的每个元素都会关联一个double类型的分数。zset正是通过分数来为集合中的成员进行排序。zset的成员是唯一的,但分数(score)却可以重复。&lt;br/&gt;新增集合元素：zadd key score value ... scoreN valueN&lt;br/&gt;获取元素分数：zscore key value&lt;br/&gt;按照分数从小到大排序：zrange key startIndex endIndex&lt;br/&gt;按照分数从大到小排序：zrevrange key startIndex endIndex&lt;br/&gt;遍历时显示分数：withscores&lt;br/&gt;统计分数比value少的个数：zrank key value&lt;br/&gt;统计分数比value高的个数：zrevrank key value&lt;br/&gt;输出分数在制定值内的元素：zrangebyscore key score1 score2&lt;br/&gt;给元素加分：zincrby key score value&lt;br/&gt;获取元素个数：zcard()&lt;br/&gt;统计分数内的个数：zcount key score1 score2&lt;br/&gt;删除制定排名内的元素：zremrangebyrank key no1 no2&lt;br/&gt;删除指定分数内的元素：zremrangebyscore key score1 score2&lt;br/&gt;删除指定元素：zrem key value&lt;/li&gt;
&lt;li readability=&quot;13.5&quot;&gt;
&lt;p&gt;注： zcount 统计分数内的个数，score1 &amp;lt;= keyScore =&amp;lt; score2；zremrangebyrank 的 no1 和 no2 表示排名的第几位。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;127.0.0.1:6379&amp;gt; zadd zset 65 A 67 C 66 B
(integer) 3
127.0.0.1:6379&amp;gt; zscore zset C
&quot;67&quot;
127.0.0.1:6379&amp;gt; zrange zset 0 -1
1) &quot;A&quot;
2) &quot;B&quot;
3) &quot;C&quot;
127.0.0.1:6379&amp;gt; zrevrange zset 0 -1
1) &quot;C&quot;
2) &quot;B&quot;
3) &quot;A&quot;
127.0.0.1:6379&amp;gt; zrevrange zset 0 -1 withscores
1) &quot;C&quot;
2) &quot;67&quot;
3) &quot;B&quot;
4) &quot;66&quot;
5) &quot;A&quot;
6) &quot;65&quot;
127.0.0.1:6379&amp;gt; zrank zset C
(integer) 2
127.0.0.1:6379&amp;gt; zrevrank zset C
(integer) 0
127.0.0.1:6379&amp;gt; zrangebyscore zset 65 66
1) &quot;A&quot;
2) &quot;B&quot;
127.0.0.1:6379&amp;gt; zrangebyscore zset 65 66 limit 1 2
1) &quot;B&quot;
127.0.0.1:6379&amp;gt; zincrby zset 10 A
&quot;75&quot;
127.0.0.1:6379&amp;gt; zcard zset
(integer) 3
127.0.0.1:6379&amp;gt; zcount zset 65 66
(integer) 1
127.0.0.1:6379&amp;gt; zremrangebyrank zset 0 1
(integer) 2
127.0.0.1:6379&amp;gt; zremrangebyscore zset 100 200
(integer) 0
127.0.0.1:6379&amp;gt; zrem zset A
(integer) 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;jedis客户端&quot;&gt;Jedis客户端&lt;/h2&gt;
&lt;p&gt;Jedis 是比较主流的 Redis Java 客户端。&lt;br/&gt;第一步：导入Jedis需要的jar&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;co&quot;&gt;&amp;lt;!-- Redis客户端 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;redis.clients&lt;span class=&quot;kw&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;jedis&lt;span class=&quot;kw&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;jedis.version&amp;gt;&lt;/span&gt;2.7.2&lt;span class=&quot;kw&quot;&gt;&amp;lt;/jedis.version&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二步：单元测试类&lt;br/&gt;Jedis 的语法和 Redis 几乎一样，如果学好了Redis，Jedis也就没问题了，可谓是买一送一。建议使用连接池的方式。&lt;br/&gt;```java&lt;br/&gt;package com.itdragon.redis;&lt;br/&gt;import java.util.HashMap;&lt;br/&gt;import java.util.Map;&lt;br/&gt;import org.apache.commons.pool2.impl.GenericObjectPoolConfig;&lt;br/&gt;import org.junit.Test;&lt;br/&gt;import redis.clients.jedis.Jedis;&lt;br/&gt;import redis.clients.jedis.JedisPool;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;public class TestJedisOperate {&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private final static String HOST = &quot;112.74.83.71&quot;;
private final static int PORT = 6379;

/**
 * jedis 的语法和 redis 的语法几乎一致，比较常用的有Hash，String，List
 */
@Test
public void jedisSignle() {
    Jedis jedis = new Jedis(HOST, PORT);
    jedis.set(&quot;account&quot;, &quot;itdragon&quot;);
    System.out.println(&quot;set , get 操作 : &quot; + jedis.get(&quot;account&quot;));
    jedis.mset(&quot;account:01&quot;, &quot;itdragon01&quot;, &quot;account:02&quot;, &quot;itdragon02&quot;);
    System.out.println(&quot;mset , mget 操作 : &quot; + jedis.mget(&quot;account:01&quot;, &quot;account:02&quot;));
    jedis.hset(&quot;user&quot;, &quot;name&quot;, &quot;ITDragon&quot;);
    System.out.println(&quot;hset , hget 操作 : &quot; + jedis.hget(&quot;user&quot;, &quot;name&quot;));
    Map&amp;lt;String, String&amp;gt; userMap = new HashMap&amp;lt;&amp;gt;();
    userMap.put(&quot;password&quot;, &quot;123456&quot;);
    userMap.put(&quot;position&quot;, &quot;Java&quot;);
    jedis.hmset(&quot;user&quot;, userMap);
    System.out.println(&quot;hmset , hmget 操作 : &quot; + jedis.hmget(&quot;user&quot;, &quot;name&quot;, &quot;password&quot;, &quot;position&quot;));
    if (0 == jedis.llen(&quot;userList&quot;)) {
        jedis.lpush(&quot;userList&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;);
    }
    System.out.println(&quot;List 类型 lpush , lrange 操作 : &quot; + jedis.lrange(&quot;userList&quot;, 0, -1));
    jedis.sadd(&quot;userSet&quot;, &quot;1&quot;, &quot;2&quot;, &quot;2&quot;);
    System.out.println(&quot;Set 类型 sadd , smembers 操作 : &quot; + jedis.smembers(&quot;userSet&quot;));
    Map&amp;lt;String, Double&amp;gt; scoreMembers = new HashMap&amp;lt;&amp;gt;();
    scoreMembers.put(&quot;A&quot;, 65.0);
    scoreMembers.put(&quot;C&quot;, 67.0);
    scoreMembers.put(&quot;B&quot;, 66.0);
    jedis.zadd(&quot;userScore&quot;, scoreMembers);
    System.out.println(&quot;Set 类型 zadd , zrange 操作 : &quot; + jedis.zrange(&quot;userScore&quot;, 0, -1));
    jedis.close();
}

@Test
public void testJedisPool() {
    JedisPool pool = new JedisPool(HOST, PORT);
    Jedis jedis = pool.getResource();
    System.out.println(&quot;通过连接池获取 key 为 account 的值 : &quot; + jedis.get(&quot;account&quot;));
    jedis.close();
    pool.close();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;br/&gt;```&lt;/p&gt;
&lt;h2 id=&quot;spring-整合-redis&quot;&gt;Spring 整合 Redis&lt;/h2&gt;
&lt;p&gt;创建用于整合redis的文件 applicationContext-jedis.xml&lt;br/&gt;建议使用redis 默认配置（默认，让生活更美好）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;kw&quot;&gt;&amp;lt;?xml&lt;/span&gt; version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;span class=&quot;kw&quot;&gt;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;beans&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xmlns:context=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns:p=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/p&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xmlns:aop=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; xmlns:tx=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span class=&quot;ot&quot;&gt;    xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd&lt;/span&gt;
&lt;span class=&quot;st&quot;&gt;    http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 加载配置文件 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;context:property-placeholder&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; location=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;classpath:resource/*.properties&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 连接池配置 (可以用 redis 默认配置，效果可能会更好)--&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jedisPoolConfig&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;redis.clients.jedis.JedisPoolConfig&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 最大连接数 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;maxTotal&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;30&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 最大空闲连接数 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;maxIdle&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;10&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 每次释放连接的最大数目 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;numTestsPerEvictionRun&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1024&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 释放连接的扫描间隔（毫秒） --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;timeBetweenEvictionRunsMillis&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;30000&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 连接最小空闲时间 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;minEvictableIdleTimeMillis&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1800000&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 连接空闲多久后释放, 当空闲时间&amp;gt;该值 且 空闲连接&amp;gt;最大空闲连接数 时直接释放 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;softMinEvictableIdleTimeMillis&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;10000&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;maxWaitMillis&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;1500&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 在获取连接的时候检查有效性, 默认false --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;testOnBorrow&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 在空闲时检查有效性, 默认false --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;testWhileIdle&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;true&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true --&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;property&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;blockWhenExhausted&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;false&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- jedis客户端单机版 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;redisClient&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;redis.clients.jedis.JedisPool&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;constructor-arg&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;host&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${redis.host}&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;&amp;lt;constructor-arg&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; name=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;port&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; value=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;${redis.ip}&quot;&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;co&quot;&gt;&amp;lt;!-- &amp;lt;constructor-arg name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot; /&amp;gt; --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;jedisClient&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.itdragon.common.utils.JedisClientSingle&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单封装了Jedis 常用方法 JedisClientSingle.java&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.itdragon.common.utils;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import redis.clients.jedis.Jedis;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import redis.clients.jedis.JedisPool;&lt;/span&gt;

&lt;span class=&quot;co&quot;&gt;// 单例的Redis 工具类&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; JedisClientSingle {
    
    &lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * connect timed out 问题： &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 1. 检查redis服务是否开启&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 2. 检查是否是因为防火墙的问题&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * 3. 检查网络问题(如果在同一个局域网内几乎不会出现这个问题)&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * Jedis jedis =new Jedis(HOST,PORT,100000);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     * JedisPool pool = new JedisPool(poolConfig, HOST, PORT, 100000);&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;     */&lt;/span&gt;
    
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; JedisPool jedisPool; 
    
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(String key) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        String string = jedis.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(key);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; string;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;set&lt;/span&gt;(String key, String value) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        String string = jedis.&lt;span class=&quot;fu&quot;&gt;set&lt;/span&gt;(key, value);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; string;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;hget&lt;/span&gt;(String hkey, String key) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        String string = jedis.&lt;span class=&quot;fu&quot;&gt;hget&lt;/span&gt;(hkey, key);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; string;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hset&lt;/span&gt;(String hkey, String key, String value) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        Long result = jedis.&lt;span class=&quot;fu&quot;&gt;hset&lt;/span&gt;(hkey, key, value);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;del&lt;/span&gt;(String key) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        Long result = jedis.&lt;span class=&quot;fu&quot;&gt;del&lt;/span&gt;(key);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result;
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;hdel&lt;/span&gt;(String hkey, String key) {
        Jedis jedis = jedisPool.&lt;span class=&quot;fu&quot;&gt;getResource&lt;/span&gt;();
        Long result = jedis.&lt;span class=&quot;fu&quot;&gt;hdel&lt;/span&gt;(hkey, key);
        jedis.&lt;span class=&quot;fu&quot;&gt;close&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; result;
    }

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取商品类名接口实现类 ProductCategoryServiceImpl.java&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package com.itdragon.service.impl;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.ArrayList;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Date;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.List;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.apache.commons.lang3.StringUtils;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.beans.factory.annotation.Value;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.util.CollectionUtils;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.stereotype.Service;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.transaction.annotation.Transactional;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.common.pojo.EUTreeNode;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.common.pojo.ResponseResult;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.common.utils.JedisClientSingle;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.common.utils.JsonUtils;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.mapper.ProductCategoryMapper;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.pojo.ProductCategory;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.pojo.ProductCategoryExample;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.pojo.ProductCategoryExample.Criteria;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import com.itdragon.service.ProductCategoryService;&lt;/span&gt;

&lt;span class=&quot;fu&quot;&gt;@Service&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; ProductCategoryServiceImpl &lt;span class=&quot;kw&quot;&gt;implements&lt;/span&gt; ProductCategoryService {
    
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; ProductCategoryMapper categoryMapper;
    
    &lt;span class=&quot;fu&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; JedisClientSingle jedisClientSingle;
    
    &lt;span class=&quot;fu&quot;&gt;@Value&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;${CATEGROY_ID_CACHE_REDIS_KEY}&quot;&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String CATEGROY_ID_CACHE_REDIS_KEY;

    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; List&amp;lt;EUTreeNode&amp;gt; &lt;span class=&quot;fu&quot;&gt;getCategoryList&lt;/span&gt;(Long parentId) {
        &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; startTime = System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
        List&amp;lt;EUTreeNode&amp;gt; resultList = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();
        &lt;span class=&quot;co&quot;&gt;// 从redis缓存中取内容&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            String cacheDatas = jedisClientSingle.&lt;span class=&quot;fu&quot;&gt;hget&lt;/span&gt;(CATEGROY_ID_CACHE_REDIS_KEY, parentId.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;());
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (StringUtils.&lt;span class=&quot;fu&quot;&gt;isNotBlank&lt;/span&gt;(cacheDatas)) {
                List&amp;lt;ProductCategory&amp;gt; categories = JsonUtils.&lt;span class=&quot;fu&quot;&gt;jsonToList&lt;/span&gt;(cacheDatas, ProductCategory.&lt;span class=&quot;fu&quot;&gt;class&lt;/span&gt;);
                &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (ProductCategory category : categories) {
                    EUTreeNode node = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;EUTreeNode&lt;/span&gt;();
                    node.&lt;span class=&quot;fu&quot;&gt;setId&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;());
                    node.&lt;span class=&quot;fu&quot;&gt;setText&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;());
                    node.&lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getIsParent&lt;/span&gt;()?&lt;span class=&quot;st&quot;&gt;&quot;closed&quot;&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;&quot;open&quot;&lt;/span&gt;);
                    resultList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(node);
                }
                System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;redis cache Time : &quot;&lt;/span&gt; + (System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;() - startTime));
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; resultList;
            }
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        ProductCategoryExample example = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ProductCategoryExample&lt;/span&gt;();
        Criteria criteria = example.&lt;span class=&quot;fu&quot;&gt;createCriteria&lt;/span&gt;();
        criteria.&lt;span class=&quot;fu&quot;&gt;andStatusEqualTo&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;);
        criteria.&lt;span class=&quot;fu&quot;&gt;andParentIdEqualTo&lt;/span&gt;(parentId); &lt;span class=&quot;co&quot;&gt;// 查询父节点下的所有子节点&lt;/span&gt;
        List&amp;lt;ProductCategory&amp;gt; productCategories = categoryMapper.&lt;span class=&quot;fu&quot;&gt;selectByExample&lt;/span&gt;(example);
        
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (ProductCategory category : productCategories) {
            EUTreeNode node = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;EUTreeNode&lt;/span&gt;();
            node.&lt;span class=&quot;fu&quot;&gt;setId&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getId&lt;/span&gt;());
            node.&lt;span class=&quot;fu&quot;&gt;setText&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;());
            node.&lt;span class=&quot;fu&quot;&gt;setState&lt;/span&gt;(category.&lt;span class=&quot;fu&quot;&gt;getIsParent&lt;/span&gt;()?&lt;span class=&quot;st&quot;&gt;&quot;closed&quot;&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;&quot;open&quot;&lt;/span&gt;);
            resultList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(node);
        }
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;No redis cache Time : &quot;&lt;/span&gt; + (System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;() - startTime));
        &lt;span class=&quot;co&quot;&gt;// 向redis缓存中添加内容&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            jedisClientSingle.&lt;span class=&quot;fu&quot;&gt;hset&lt;/span&gt;(CATEGROY_ID_CACHE_REDIS_KEY, parentId.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;(), JsonUtils.&lt;span class=&quot;fu&quot;&gt;objectToJson&lt;/span&gt;(productCategories));
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Exception e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; resultList;
    }

    &lt;span class=&quot;co&quot;&gt;// 后面的内容看源码...&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;源码：&lt;a href=&quot;https://github.com/ITDragonBlog/daydayup/tree/master/Redis&quot; class=&quot;uri&quot;&gt;https://github.com/ITDragonBlog/daydayup/tree/master/Redis&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到这里，Redis 的快速入门就结束了。下一章节介绍Redis 的主从和集群。&lt;/p&gt;
</description>
<pubDate>Sat, 25 Nov 2017 15:42:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itdragon/p/7897131.html</dc:identifier>
</item>
<item>
<title>来手撸一个小小小小小&quot;3D引擎&quot; - assassinx</title>
<link>http://www.cnblogs.com/assassinx/p/7896478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/assassinx/p/7896478.html</guid>
<description>&lt;p&gt;开始的唠叨&lt;/p&gt;
&lt;p&gt;说是3D引擎确实有点过于博眼球了，其实就是实现了一个透视投影，当然也不是那么简单的。 此篇文章是纯粹给小白看的 高手请勿喷 。也称之为小向带你图形学入门基础 。 哇哈哈哈哈 一说到做一个3D画面的东东 一说总是到DirectX  OpenGL 这些玩意儿 我们这些菜鸟总是 想到哇擦擦 哇C++的   哇 计算机图形学好难。这玩意儿难度好大。其实就那么回事儿 ，DirectX OpenGL 只是工具 而已， 只要把原理搞懂了 你看我用low逼的GDI照样给你绘制一个3D物体 可以这样说即使不用GDI 其他任何能划线 画点的东西 ，我在安卓平台上照样给你实现这个效果。不要局限于工具 谁说做3D就只能用DirectX OpenGL了 ，谁说做3D只能用C++了  。&lt;/p&gt;

&lt;p&gt;顶点数据展现&lt;/p&gt;
&lt;p&gt;首先是3D编程中通用的数据展现 那就是顶点组成的网格数据 称之为mesh， 3个点为一组  组成的三角面片数据。三个点顺时针的方向那么 箭头方向为外表面 另一面为内表面 ，在绘制的时候 内表面不可见。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125215040562-1569414831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;好那么我们也以此方式来定义数据 ，我们定义的东西是一个 中心位置在( 0,0，-130)处的立方体。我们的观察点在(0, 0, 0)处 正对着立方体观察。 由于我们想让立方体一个面的颜色相同，所以是两个为一组定义的 ，当然三角形也是以同样的 两个为一组 组成一个正方形面。由此对物体表面空间点的描述数据就做好了。&lt;br/&gt;好 ，定义数据的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;93&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Marsh
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; List&amp;lt;Point3dF&amp;gt;&lt;span&gt; points;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Marsh()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 points = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Point3dF&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;                 Point3dF pointA = &lt;span&gt;new&lt;/span&gt; Point3dF(&lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;160&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 Point3dF pointB = &lt;span&gt;new&lt;/span&gt; Point3dF(-&lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;160&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 Point3dF pointC = &lt;span&gt;new&lt;/span&gt; Point3dF(-&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;160&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 Point3dF pointD = &lt;span&gt;new&lt;/span&gt; Point3dF(&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;160&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 Point3dF pointE = &lt;span&gt;new&lt;/span&gt; Point3dF(&lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                 Point3dF pointF = &lt;span&gt;new&lt;/span&gt; Point3dF(-&lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                 Point3dF pointG = &lt;span&gt;new&lt;/span&gt; Point3dF(-&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                 Point3dF pointH = &lt;span&gt;new&lt;/span&gt; Point3dF(&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;30&lt;/span&gt;, -&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                points.Add(pointA);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;                points.Add(pointB);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                points.Add(pointC);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                points.Add(pointD);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                points.Add(pointE);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                points.Add(pointF);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                points.Add(pointG);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                points.Add(pointH);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;                 
&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;                 path1 = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;() { 
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     &lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                     &lt;span&gt;5&lt;/span&gt; ,&lt;span&gt;2&lt;/span&gt; ,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                     &lt;span&gt;1&lt;/span&gt; ,&lt;span&gt;3&lt;/span&gt; ,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                     &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt; ,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                     &lt;span&gt;0&lt;/span&gt; ,&lt;span&gt;7&lt;/span&gt; ,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                     &lt;span&gt;0&lt;/span&gt; ,&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                    ,
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                     &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                     &lt;span&gt;4&lt;/span&gt; ,&lt;span&gt;0&lt;/span&gt; ,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                     &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; ,&lt;span&gt;7&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                     &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                };
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;                 faceColors = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Brush&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 Random rdm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Random();
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;6&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                     Brush b= &lt;span&gt;new&lt;/span&gt; SolidBrush(Color.FromArgb(rdm.Next(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;), rdm.Next(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;), rdm.Next(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;255&lt;/span&gt;&lt;span&gt;)));
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Brush b = new SolidBrush(Color.FromArgb(266 / 6 * i, 266 / 6 * i, 266 / 6 * i));&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; &lt;span&gt;                    faceColors.Add(b);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;                    faceColors.Add(b);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;                 
&lt;span&gt;64&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; List&amp;lt;Brush&amp;gt;&lt;span&gt; faceColors;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; path1;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于透视投影 和顶点绘制&lt;/p&gt;
&lt;p&gt;我数学底子差 在写这个例子之前参考了很多前辈的 图形学理论基础。最主要是透视投影 和3D旋转矩阵绕任意轴旋转 。甚至没完全搞懂 于是我就抄起代码开搞了。 不得不说这玩意儿真的很有意思。&lt;br/&gt;首先是透视投影：http://blog.csdn.net/popy007/article/details/1797121&lt;br/&gt;作者讲的很详细 其实我只看到一半 ，后面矩阵推导那些太难了 没有继续往下啃 。视线是一个发散的方式从一个点出去 （其实最后发现不用管什么视椎体不视椎体的）。 假设视点前面有一张半透明的纸张 视线上的点是怎么打到纸张上的？关于这个问题  你要粗暴点确实很简单 就是三角形 初中的知识。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125215710437-782610699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就如开始所述 视点在(0,0,0) 处看向 位于(0,0,-130) 的立方体  ，假设有一架摄像机  ，那么上图就是他的从空中看下去的俯视图。设p为(x,z)　　p'为(x' ,z') 。则x'=-N(x/z)  y'=-N(y/z)。为了方便 我们的数据定义也是跟示意图上差不多的。于是我们依葫芦画瓢 把所有的点绘制出来 包装成一个paint函数。&lt;br/&gt;需要注意的是平面坐标系 跟屏幕坐标之间的转换 ，其实不难 你其他计算应用数学公式 数学函数 还是一样该咋算咋算。  完成后我们平面坐标系的0,0  对应屏幕坐标的0,0   。&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125220959171-520820594.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125221017593-296350008.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;看到没 x轴0左边也是负数 不用管  就只是y的符号不一样 变成-y就可以了。然后要让他显示在窗口中间  还要进行偏移 就是x加偏移， y加偏移  就这样就完成啦 。  哈哈哈哈哈。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; paint()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             Graphics gph = Graphics.FromHwnd(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Handle);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            gph.Clear(Color.Lavender);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进行到屏幕坐标的映射(x y z)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p~ =(-n x/z       -n y/z      -n)&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             PointF screenLastPoint=&lt;span&gt; PointF.Empty;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; msh.path1.Count / &lt;span&gt;3&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (i &amp;gt;= 4)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    return;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 PointF screenPointA = &lt;span&gt;new&lt;/span&gt; PointF((&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;]].x / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;]].z)) , (&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;]].y / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;&lt;span&gt;]].z))  );
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 PointF screenPointB = &lt;span&gt;new&lt;/span&gt; PointF((&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;]].x / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;]].z)) , (&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;]].y / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;]].z))  );
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 PointF screenPointC = &lt;span&gt;new&lt;/span&gt; PointF((&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;]].x / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;]].z))  , (&lt;span&gt;float&lt;/span&gt;)((-nearPlan) * (msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;]].y / msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;&lt;span&gt;]].z))  );
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;                 screenPointA.Y = -&lt;span&gt;screenPointA.Y;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 screenPointB.Y = -&lt;span&gt;screenPointB.Y;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 screenPointC.Y = -&lt;span&gt;screenPointC.Y;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;                 screenPointA.Y=screenPointA.Y+&lt;span&gt;offsety;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 screenPointB.Y= screenPointB.Y+&lt;span&gt;offsety;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 screenPointC.Y = screenPointC.Y +&lt;span&gt; offsety;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;                 screenPointA.X = screenPointA.X +&lt;span&gt; offsetx;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 screenPointB.X = screenPointB.X +&lt;span&gt; offsetx;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 screenPointC.X = screenPointC.X +&lt;span&gt; offsetx;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;                 System.Drawing.Drawing2D.GraphicsPath ph = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Drawing.Drawing2D.GraphicsPath(
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PointF[] { screenPointA, screenPointB, screenPointC },
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] { &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; },
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                    System.Drawing.Drawing2D.FillMode.Winding);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;---求法向量及夹角 如果为true 则渲染面&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算当前管线三角面片的法向量 是否朝着镜头 ，最终决定是否可见&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (angelCalc(msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;]], msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;]], msh.points[msh.path1[i * &lt;span&gt;3&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;]]) == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                    gph.FillPath(msh.faceColors[i], ph);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绘制边框&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;             gph.DrawLine(Pens.Red, &lt;span&gt;new&lt;/span&gt; PointF(offsetx - &lt;span&gt;36&lt;/span&gt;, offsety - &lt;span&gt;36&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; PointF(offsetx + &lt;span&gt;36&lt;/span&gt;, offsety - &lt;span&gt;36&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             gph.DrawLine(Pens.Red,  &lt;span&gt;new&lt;/span&gt; PointF(offsetx + &lt;span&gt;36&lt;/span&gt;, offsety - &lt;span&gt;36&lt;/span&gt;),&lt;span&gt;new&lt;/span&gt; PointF(offsetx + &lt;span&gt;36&lt;/span&gt;, offsety + &lt;span&gt;36&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             gph.DrawLine(Pens.Red, &lt;span&gt;new&lt;/span&gt; PointF(offsetx + &lt;span&gt;36&lt;/span&gt;, offsety +&lt;span&gt;36&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; PointF(offsetx - &lt;span&gt;36&lt;/span&gt;, offsety + &lt;span&gt;36&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             gph.DrawLine(Pens.Red, &lt;span&gt;new&lt;/span&gt; PointF(offsetx - &lt;span&gt;36&lt;/span&gt;, offsety + &lt;span&gt;36&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; PointF(offsetx - &lt;span&gt;36&lt;/span&gt;, offsety - &lt;span&gt;36&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;///&lt;/span&gt;&lt;span&gt;/绘制网格线&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;screenLastPoint = PointF.Empty;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;for (int i = 0; i &amp;lt; msh.path1.Count / 3; i++)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (i &amp;gt;= 4)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    return;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    PointF screenPointA = new PointF((float)((-nearPlan) * (msh.points[msh.path1[i * 3]].x / msh.points[msh.path1[i * 3]].z)), (float)((-nearPlan) * (msh.points[msh.path1[i * 3]].y / msh.points[msh.path1[i * 3]].z)));
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    PointF screenPointB = new PointF((float)((-nearPlan) * (msh.points[msh.path1[i * 3 + 1]].x / msh.points[msh.path1[i * 3 + 1]].z)), (float)((-nearPlan) * (msh.points[msh.path1[i * 3 + 1]].y / msh.points[msh.path1[i * 3 + 1]].z)));
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    PointF screenPointC = new PointF((float)((-nearPlan) * (msh.points[msh.path1[i * 3 + 2]].x / msh.points[msh.path1[i * 3 + 2]].z)), (float)((-nearPlan) * (msh.points[msh.path1[i * 3 + 2]].y / msh.points[msh.path1[i * 3 + 2]].z)));
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointA.Y = -screenPointA.Y;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointB.Y = -screenPointB.Y;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointC.Y = -screenPointC.Y;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointA.Y = screenPointA.Y + offsety;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointB.Y = screenPointB.Y + offsety;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointC.Y = screenPointC.Y + offsety;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointA.X = screenPointA.X + offsetx;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointB.X = screenPointB.X + offsetx;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    screenPointC.X = screenPointC.X + offsetx;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    gph.DrawLine(Pens.Red, screenPointA, screenPointB);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    gph.DrawLine(Pens.Red, screenPointB, screenPointC);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    gph.DrawLine(Pens.Red, screenPointC, screenPointA);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt; 
&lt;span&gt;73&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;绕着坐标轴进行旋转  &lt;/p&gt;
&lt;p&gt;最开始我没有绘制面只是绘制的顶点线框而已 。然后我想做的是旋转  让他转起来，总共八个点连成线就是立方体了，哪怕是low逼的线条 只要转起来是不是就有立方体的样子了。  哇哈哈哈哈。最开始我想的很简单啊 立体的旋转也没啥不得了的啊 ，比如饶y轴旋转 我把他当成平面的不就得了么 y不变x和z变。 绕x轴旋转 同理。 我原来也写过平面的点进行旋转的计算。 为了符合图形学上的标准方式 最后我还是使用二维矩阵旋转的方式： &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RotationTest2()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;二维空间旋转矩阵为 ： x是角度
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cos(x)  -sin(x)   (1-cos(x))tx+ty*sin(x))  x
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Sin(x) cos(x)     (1-cos(x))ty-tx*sin(x)) y
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2pi 等于360度
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绕y轴旋转
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;double xita = ((Math.PI * 2d) / 360d) * 2d;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; xita = ((Math.PI * 2d) / 360d) *&lt;span&gt; anglex;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; cosx =&lt;span&gt; Math.Cos(xita);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; sinx =&lt;span&gt; Math.Sin(xita);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; xitay = ((Math.PI * 2d) / &lt;span&gt;360&lt;/span&gt;) *&lt;span&gt; angley;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; cosy =&lt;span&gt; Math.Cos(xitay);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; siny =&lt;span&gt; Math.Sin(xitay);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; msh.points.Count; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Point3dF tmpPoint = new Point3dF(msh.points[i].x, msh.points[i].y, msh.points[i].z);&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                 Point3dF tmpPoint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point3dF(mshSource.points[i].x, mshSource.points[i].y, mshSource.points[i].z);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 msh.points[i].x =
&lt;span&gt;24&lt;/span&gt;                     tmpPoint.x * cosx + ((-sinx) * tmpPoint.z) +
&lt;span&gt;25&lt;/span&gt;                 (((1d - cosx) * 0d) + ((-130d) *&lt;span&gt; sinx));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;                 msh.points[i].z =
&lt;span&gt;28&lt;/span&gt;                     tmpPoint.x * sinx + (cosx * tmpPoint.z) +
&lt;span&gt;29&lt;/span&gt;                     (((1d - cosx) * (-130d)) - ((0d) *&lt;span&gt; sinx));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;                 msh.points[i].y =&lt;span&gt; tmpPoint.y;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;---------------------------------&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;                 tmpPoint = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point3dF(msh.points[i].x, msh.points[i].y, msh.points[i].z);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;                 msh.points[i].y = tmpPoint.y * cosy + ((-siny) * tmpPoint.z) +
&lt;span&gt;37&lt;/span&gt;                 (((1d - cosy) * 0d) + ((-130d) *&lt;span&gt; siny));
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;                 msh.points[i].z = tmpPoint.y * siny + (cosy * tmpPoint.z) +
&lt;span&gt;40&lt;/span&gt;                     (((1d - cosy) * (-130d)) - ((0d) *&lt;span&gt; siny));
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意了 绕着任意轴进行旋转&lt;/p&gt;
&lt;p&gt;现在我想做的是做一个跟踪球效果 。鼠标按下拖动的时候让物体 像烤肉串样绕着一根轴旋转。 网上跟踪球都是旋转相机 我们这里直接旋转物体坐标。绕着任意轴旋转啊绕着任意轴旋转的矩阵 说实话 3D旋转矩阵这个我搞不懂 ，我看不懂推导过程 但是我会看公式 哇哈哈哈哈。&lt;br/&gt;https://www.cnblogs.com/graphics/archive/2012/08/10/2627458.html&lt;br/&gt;其他的博文里贴出来的旋转矩阵也是这样 直接把他的代码抄下来之  ，c++的 我抄成c#的 没啥难的 我已经超过好些c++代码了。总之我们要做的就是 得出一个二维数组作为矩阵回传 让所有坐标根据此矩阵进行运算。注意有两个基本概念：  两个点相减 a-b  得出的是 b到a 的向量 (0,0) -(1,1)  =(-1,-1)  ，然后是向量归一化： 什么叫归一化， 就是 把向量的方向不变 长度变到单位长度 ，也就是1。问向量归一化怎么搞  。好 ，比如一个二维向量，计算原理就是通过距离计算公式&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125223044390-971885070.png&quot; alt=&quot;&quot;/&gt;得出距离。这个距离与1的比值等于 现x与归一化后x的比值：&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125223658468-749414512.png&quot; alt=&quot;&quot;/&gt;求归一化后y的值同理。当然这些都是基础的没什么特别说的。&lt;br/&gt;求旋转矩阵的函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到旋转矩阵&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;double&lt;/span&gt;[,] RotateArbitraryLine(Point3dF v1, Point3dF v2, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; theta)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; a =&lt;span&gt; v1.x;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; b =&lt;span&gt; v1.y;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; c =&lt;span&gt; v1.z;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             Point3dF p = &lt;span&gt;new&lt;/span&gt; Point3dF(v2.x - v1.x, v2.y - v1.y, v2.z -&lt;span&gt; v1.z);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;v2归一化&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; x_p2 = p.x / Math.Sqrt(Math.Pow(p.x, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(p.y, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; y_p2 = p.y / Math.Sqrt(Math.Pow(p.x, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(p.y, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;.IsNaN(x_p2))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 x_p2 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;double&lt;/span&gt;&lt;span&gt;.IsNaN(y_p2))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 y_p2 = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; u =&lt;span&gt; x_p2;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; v =&lt;span&gt; y_p2;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; w = 0d;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -130d;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0d;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; uu = u *&lt;span&gt; u;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; uv = u *&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; uw = u *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; vv = v *&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; vw = v *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; ww = w *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; au = a *&lt;span&gt; u;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; av = a *&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; aw = a *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; bu = b *&lt;span&gt; u;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; bv = b *&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; bw = b *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; cu = c *&lt;span&gt; u;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; cv = c *&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; cw = c *&lt;span&gt; w;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; costheta =&lt;span&gt; Math.Cos(theta);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; sintheta =&lt;span&gt; Math.Sin(theta) ;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt;[,] pOut = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;[&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             pOut[&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;] = uu + (vv + ww) *&lt;span&gt; costheta;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             pOut[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;] = uv * (&lt;span&gt;1&lt;/span&gt; - costheta) + w *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             pOut[&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;] = uw * (&lt;span&gt;1&lt;/span&gt; - costheta) - v *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             pOut[&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                   
&lt;span&gt;46&lt;/span&gt;             pOut[&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;] = uv * (&lt;span&gt;1&lt;/span&gt; - costheta) - w *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             pOut[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;] = vv + (uu + ww) *&lt;span&gt; costheta;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             pOut[&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;] = vw * (&lt;span&gt;1&lt;/span&gt; - costheta) + u *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             pOut[&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                   
&lt;span&gt;51&lt;/span&gt;             pOut[&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;] = uw * (&lt;span&gt;1&lt;/span&gt; - costheta) + v *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             pOut[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;] = vw * (&lt;span&gt;1&lt;/span&gt; - costheta) - u *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             pOut[&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;] = ww + (uu + vv) *&lt;span&gt; costheta;
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             pOut[&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                   
&lt;span&gt;56&lt;/span&gt;             pOut[&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;] = (a * (vv + ww) - u * (bv + cw)) * (&lt;span&gt;1&lt;/span&gt; - costheta) + (bw - cv) *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             pOut[&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;] = (b * (uu + ww) - v * (au + cw)) * (&lt;span&gt;1&lt;/span&gt; - costheta) + (cu - aw) *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;             pOut[&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;] = (c * (uu + vv) - w * (au + bv)) * (&lt;span&gt;1&lt;/span&gt; - costheta) + (av - bu) *&lt;span&gt; sintheta;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             pOut[&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; pOut;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;函数写好了 矩阵也能得出了，还有个问题：函数的那几个参数 ，旋转的度数也好搞 按下的时候记录一个点 拖动的时候计算跟他的距离 距离作为度数 拖动50像素 旋转50度。 旋转的那根儿轴你怎么得出来，开始点容易 立方体的中心是0 0 -130  。按下的时候记录了按下开始点 鼠标的移动就已经是一个向量了 所以我们只需要对这个向量 绕z轴进行90度旋转 ，z也设成-130 就跟中心点平齐了 就是需要的烤肉串儿的旋转轴了。 好 原理讲完了 ，代码走起：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Form1_MouseMove(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, MouseEventArgs e)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须要得出旋转的轴才行&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (pressed)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;中心点 0,0,-130
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过拖动远近决定旋转角度，垂直向量 得到旋转轴
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得出鼠标拖动向量 &lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;                 Point3dF dragJuli = &lt;span&gt;new&lt;/span&gt; Point3dF((e.Location.X - startPoint.X),( e.Location.Y - startPoint.Y),-&lt;span&gt;130d);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;还要旋转90度才是真正的旋转轴
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cos(x)  -sin(x)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Sin(x) cos(x)  &lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;double&lt;/span&gt; cos90=&lt;span&gt;0d;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;double&lt;/span&gt; sin90=&lt;span&gt;1d;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; x = dragJuli.x * 0d + dragJuli.y *&lt;span&gt; 1d;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; y = dragJuli.x * 1d + dragJuli.y *&lt;span&gt; 0d;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;                 Point3dF dragJuli2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point3dF(x, y, dragJuli.z);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Point3dF dragJuli90=
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;x1 x2+y1 y2=0
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;double x2=(-dragJuli.y)/(dragJuli.x);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;垂直的旋转轴向量
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Point3dF roll = new Point3dF(x2, 1, -130);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;拖动距离 拖动距离等于角度&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;                 angelourua= Math.Sqrt(Math.Pow((e.Location.X - startPoint.X), &lt;span&gt;2&lt;/span&gt;) + Math.Pow((e.Location.Y - startPoint.Y), &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 angelourua = angelourua % &lt;span&gt;360&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 angelourua = ((Math.PI * 2d) / 360d) *&lt;span&gt; angelourua;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;double&lt;/span&gt;[,] roatMatarix= RotateArbitraryLine(&lt;span&gt;new&lt;/span&gt; Point3dF(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, -&lt;span&gt;130d), dragJuli2,angelourua);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                RotationTest(roatMatarix);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                paint();
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;好就这样 先进行3d空间的点旋转， 再进行平面坐标映射绘制 用线连起来。是不是就有点3D立体的样子了。哇哈哈哈哈&lt;/p&gt;
&lt;p&gt; 注意了 面绘制&lt;/p&gt;
&lt;p&gt;前面的都是有些挖的别人的，这个功能绝对是自己捣鼓出来的。开始那些不论是两两之间的线条绘制啥的都只能算是 点绘制  ，我们现在要进行面绘制。首先你要清楚的是我的顶点三角面片数据已经给出了， 3d坐标点打在半透明纸张上 的x，y 也已经得出了。 调用gdi的fillpath按ABC 的顺序连起来 就能绘制一个三角面片 是不是很简单。但是先别慌 还有两个问题需要处理，一个就是可见面判别。 就是两个三角面片 的位置 决定了 在透视投影的时候哪个在前哪个在后， 还有面相交的情况呢 ？ 是不是很复杂？其实根本不用管，即使要管 只要你使用z缓冲算法 也不是很复杂 zbuffer 。就是在求出屏幕x y过后把同xy的点z越靠近视点的放在前面 这样就达到目的了。这里我们先 不管这个zbuffer算法  下次有空闲了我们再来写。这里我们使用另外一种方式 通过判别正向面与后向面来达到目的。前面我们不是说了吗 ：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125215040562-1569414831.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;我们通过计算每个三角面片的法向量， 然后我们有一个视点到三角面片的向量 ，通过计算两向量的点积  &lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125225730328-262725811.png&quot; alt=&quot;&quot;/&gt;然后通过反余弦函数就可以得出两向量的夹角 。 如果夹角大于90度代表三角面片正向面朝着视点， 如果小于90度代表正向面背对了视点， 则不对这个三角面片进行渲染。如此一来 你仔细想想 我们的立方体至始至终不会存在一个面把另一个面遮挡的情况。&lt;br/&gt;好了原理讲至此 好下面 根据原理撸代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;平面是否面向摄像机的判别&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; angelCalc( Point3dF A,Point3dF B,Point3dF C)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;https://zhidao.baidu.com/question/810216091258785532.html&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;AB、AC所在平面的法向量即AB×AC=(a,b,c),其中：
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;a=(y2-y1)(z3-z1)-(z2-z1)(y3-y1)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;b=(z2-z1)(x3-x1)-(z3-z1)(x2-x1)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;c=(x2-x1)(y3-y1)-(x3-x1)(y2-y1)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先得出点 对应的向量
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Point3dF AB = new Point3dF(B.x - A.x, B.y - A.y, B.z - A.z);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首先求出法向量&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; a = ((B.y - A.y)*(C.z - A.z) - (B.z - A.z)*(C.y -&lt;span&gt; A.y));
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; b = (B.z - A.z) * (C.x - A.x) - (C.z - A.z) * (B.x -&lt;span&gt; A.x);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; c = (B.x - A.x) * (C.y - A.y) - (C.x - A.x) * (B.y -&lt;span&gt; A.y);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             Point3dF bb = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Point3dF(a, b, c);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;套公式 第二册 下b 39  通过两向量的cos函数 继而通过反余弦得出角度&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; angelPlan =&lt;span&gt;Math.Acos(
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 (A.x * bb.x + A.y * bb.y + A.z * bb.z) /&lt;span&gt; (
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                Math.Sqrt(Math.Pow(A.x, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(A.y, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(A.z, &lt;span&gt;2&lt;/span&gt;)) *
&lt;span&gt;22&lt;/span&gt;                Math.Sqrt(Math.Pow(bb.x, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(bb.y, &lt;span&gt;2&lt;/span&gt;) + Math.Pow(bb.z, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;               )
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;               );
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (angelPlan &amp;gt; (Math.PI / &lt;span&gt;2&lt;/span&gt;))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;法向量与镜头的夹角大于90度 代表三角面片面向摄像机 则可见&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则不可见&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关于光照&lt;/p&gt;
&lt;p&gt;光照这玩意儿还是 用到三角面片的法向量 ，三角面片正对着光 则表面亮度最高 ，垂直则变成黑暗。参照面绘制的原理就可以搞出来 我这里就每个面各用些五颜六色的颜色算了吧 懒得整了。&lt;/p&gt;
&lt;p&gt;其他的&lt;/p&gt;
&lt;p&gt;还有我的摄像机镜头是固定的 ，其实还有很多工作需要做  。 希望各位大大继续完善。看下效果 是不是有模有样：上个gif图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/72285/201711/72285-20171125232626546-2022770934.gif&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;你可以把平面面向摄像机判别函数返回的值反向一下看看什么效果，是不是看到内壁的那一面了 是不是很神奇哇哈哈哈哈&lt;br/&gt;是的你没看错就这么几百行核心部分就实现了  差不多都是数学知识 ，其他的都是添砖加瓦的事，原理都在这了。 好了 以后再看DirectX 啊OpenGL啊 图形学 变换矩阵啊那些的 别被唬住了 没那么难的。&lt;br/&gt;按说的话这些知识总体来说蛮难的 但是毕竟还是学过高中的向量  两向量垂直时点积等于零 这些之类的  ， 靠着摸着石头过河 把这些半懂不懂的知识 拼凑起来 加上各种度娘 和查资料 来实现 没想到竟然成功了。 意外意外  ，当然学习是要靠自己的  你想直接度娘给你出来个你要的效果 那是不可能的。&lt;/p&gt;

</description>
<pubDate>Sat, 25 Nov 2017 15:38:00 +0000</pubDate>
<dc:creator>assassinx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/assassinx/p/7896478.html</dc:identifier>
</item>
<item>
<title>Entity Framework——常见报错总结 - 甜橙很酸</title>
<link>http://www.cnblogs.com/hdwgxz/p/7897031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hdwgxz/p/7897031.html</guid>
<description>&lt;p&gt;1 &lt;strong&gt;&lt;span&gt;实体属性配置为&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;IsRequired()&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;对更新的影响&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;抛出异常类型&lt;/span&gt;DbEntityValidationException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;表结构：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201711/1024858-20171125225446000-1348712507.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;实体：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 账号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Account { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 邮箱
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Email { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 昵称
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Nickname { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 头像
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AvatarId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 记录插入时间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DateTime InsertTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 记录修改时间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DateTime UpdateTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;实体配置：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　　　　　　modelBuilder.Entity&amp;lt;User&amp;gt;().Property(u =&amp;gt;&lt;span&gt; u.Account)
                .IsRequired()
                .IsUnicode(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
                .HasMaxLength(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
            modelBuilder.Entity&lt;/span&gt;&amp;lt;User&amp;gt;().Property(u =&amp;gt;&lt;span&gt; u.Email)
                .IsRequired()
                .IsUnicode(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
                .HasMaxLength(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
            modelBuilder.Entity&lt;/span&gt;&amp;lt;User&amp;gt;().Property(u =&amp;gt;&lt;span&gt; u.Nickname)
                .IsUnicode(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
                .HasMaxLength(&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;);
            modelBuilder.Entity&lt;/span&gt;&amp;lt;User&amp;gt;().Property(u =&amp;gt;&lt;span&gt; u.AvatarId)
                .IsOptional()
                .HasMaxLength(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;CustomDbContext&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;继承自&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;DbContext&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[DbConfigurationType(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(MySqlEFConfiguration))]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomDbContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CustomDbContext()
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name=Master&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Configuration.LazyLoadingEnabled = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;; 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DropCreateDatabaseIfModelChanges
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;new DropCreateDatabaseAlways&amp;lt;CustomDbContext&amp;gt;()&lt;/span&gt;
            Database.SetInitializer&amp;lt;CustomDbContext&amp;gt;(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;User&amp;gt; Users { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(DbModelBuilder modelBuilder)
        {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnModelCreating(modelBuilder);
            EntityConfiguration.Set(modelBuilder);
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;更新操作：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt; (CustomDbContext db = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomDbContext())
{
                    User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User 
                    {
                        Id &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                        Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test@1622.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    };
                    DbEntityEntry&lt;/span&gt;&amp;lt;User&amp;gt; entry = db.Entry&amp;lt;User&amp;gt;&lt;span&gt;(user);
                    entry.State &lt;/span&gt;=&lt;span&gt; EntityState.Unchanged;
                    entry.Property(t &lt;/span&gt;=&amp;gt; t.Email).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num =&lt;span&gt; db.SaveChanges();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;执行操作，报错信息如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201711/1024858-20171125225655281-86711460.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看&lt;/span&gt;EntityValidationErrors&lt;span&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只能看到&lt;/span&gt;{System.Data.Entity.Validation.DbEntityValidationResult}&lt;span&gt;，没有更详细的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果将上述代码用&lt;/span&gt;try..catch&lt;span&gt;包起来，如下写法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行代码&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (DbEntityValidationException ex)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; e =&lt;span&gt; ex.EntityValidationErrors;
}
&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
{
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;一层一层地打开，看到真正导致异常的原因，看到下面的截图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201711/1024858-20171125225840750-867443493.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分析实体配置发现，&lt;/span&gt;Account&lt;span&gt;属性被设置为&lt;/span&gt;IsRequired&lt;span&gt;，那么在更新实体的时候，即使不更新这个字段，也要给这个字段赋值，那么赋值后观察：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更新操作代码变为&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;using&lt;/span&gt; (CustomDbContext db = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomDbContext())
                {
                    User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User 
                    {
                        Id &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                        Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test@1622.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        Account &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    };
                    DbEntityEntry&lt;/span&gt;&amp;lt;User&amp;gt; entry = db.Entry&amp;lt;User&amp;gt;&lt;span&gt;(user);
                    entry.State &lt;/span&gt;=&lt;span&gt; EntityState.Unchanged;
                    entry.Property(t &lt;/span&gt;=&amp;gt; t.Email).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num =&lt;span&gt; db.SaveChanges();
                }        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;经过上述调整后，更新成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么换一个思路，将&lt;/span&gt;Account&lt;span&gt;属性被设置为&lt;/span&gt;IsOptional()&lt;span&gt;是不是也可以呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改&lt;/span&gt;&lt;span&gt;实体配置，将&lt;/span&gt;Account&lt;span&gt;属性设置按如下修改，并注掉上面的&lt;/span&gt;Account = &quot;a&quot;&lt;/p&gt;
&lt;p&gt;modelBuilder.Entity&amp;lt;User&amp;gt;().Property(u =&amp;gt; u.Account)&lt;/p&gt;
&lt;p&gt;                .IsOptional()&lt;/p&gt;
&lt;p&gt;                .IsUnicode(false)&lt;/p&gt;
&lt;p&gt;                .HasMaxLength(50);&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行测试，更改成功。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;得出结论：在实体配置时，指定了为必选的字段，那么更新操作时，构造实例一定要对必选（&lt;/span&gt;IsRequired()&lt;span&gt;）字段赋值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上述测试中还有一个值得考虑的细节，构造&lt;/span&gt;User实例的时候，只对Id,Email进行了赋值，而没有对其他属性进行赋值，那么为什么会成功呢？那么必定是未进行任何设置的实体属性默认是IsOptional()&lt;span&gt;。这跟表结构中的字段类型设置为&lt;/span&gt;Not Null有无关联呢，从测试结果看就本类应用无必然联系。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;a.实体配置中指定了实体属性为IsRequired()&lt;span&gt;，更新操作构造类的实例时必对此属性赋值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;b.不进行配置的实体属性默认为IsOptional()&lt;/p&gt;
&lt;p&gt;c.&lt;span&gt;表结构中字段是否为&lt;/span&gt;Not Null对上述规则无影响。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2 更新报错：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;An object with the same key already exists in the ObjectStateManager. The ObjectStateManager cannot track multiple objects with the same key.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;异常类型：&lt;/span&gt;System.Data.Entity.Infrastructure.DbUpdateConcurrencyException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实体属性配置如上例所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作代码：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;using&lt;/span&gt; (CustomDbContext db = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomDbContext())
                {
                    User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User 
                    {
                        Id &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                        Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test@132.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    };
                    DbEntityEntry&lt;/span&gt;&amp;lt;User&amp;gt; entry = db.Entry&amp;lt;User&amp;gt;&lt;span&gt;(user);
                    entry.State &lt;/span&gt;=&lt;span&gt; EntityState.Unchanged;
                    entry.Property(t &lt;/span&gt;=&amp;gt; t.Email).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                    User user1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User
                    {
                        Id &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                        Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test@132.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    };
                    DbEntityEntry&lt;/span&gt;&amp;lt;User&amp;gt; entry1 = db.Entry&amp;lt;User&amp;gt;&lt;span&gt;(user1);
                    entry1.State &lt;/span&gt;=&lt;span&gt; EntityState.Unchanged;
                    entry1.Property(t &lt;/span&gt;=&amp;gt; t.Email).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num =&lt;span&gt; db.SaveChanges();
                }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;执行操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201711/1024858-20171125230022828-936003490.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;涉及到两次修改操作，两次操作构造了两个实例，但是实例的属性&lt;/span&gt;Id&lt;span&gt;有相同的值。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果两次操作的是同一个实例，而不是不同的实例，那么不会抛出异常，代码如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;using&lt;/span&gt; (CustomDbContext db = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomDbContext())
                {
                    User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User 
                    {
                        Id &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                        Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test@132.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    };
                    DbEntityEntry&lt;/span&gt;&amp;lt;User&amp;gt; entry = db.Entry&amp;lt;User&amp;gt;&lt;span&gt;(user);
                    entry.State &lt;/span&gt;=&lt;span&gt; EntityState.Unchanged;
                    entry.Property(t &lt;/span&gt;=&amp;gt; t.Email).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                    DbEntityEntry&lt;/span&gt;&amp;lt;User&amp;gt; entry1 = db.Entry&amp;lt;User&amp;gt;&lt;span&gt;(user);
                    entry1.State &lt;/span&gt;=&lt;span&gt; EntityState.Unchanged;
                    entry1.Property(t &lt;/span&gt;=&amp;gt; t.Email).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num =&lt;span&gt; db.SaveChanges();
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3 &lt;strong&gt;&lt;span&gt;未给主键赋值或赋给主键一个不存在的值，抛出异常&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;System.Data.Entity.Infrastructure.DbUpdateConcurrencyException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作代码如下，其中&lt;/span&gt;Id=1这条语句被注掉，Id是主键：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;using&lt;/span&gt; (CustomDbContext db = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomDbContext())
                {
                    User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User 
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Id = 1,&lt;/span&gt;
                        Email = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test@132.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    };
                    DbEntityEntry&lt;/span&gt;&amp;lt;User&amp;gt; entry = db.Entry&amp;lt;User&amp;gt;&lt;span&gt;(user);
                    entry.State &lt;/span&gt;=&lt;span&gt; EntityState.Unchanged;
                    entry.Property(t &lt;/span&gt;=&amp;gt; t.Email).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num =&lt;span&gt; db.SaveChanges();
                }    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行上述代码，抛出异常信息如下，注意异常类型居然是&lt;/span&gt;System.Data.Entity.Infrastructure.DbUpdateConcurrencyException，看上去像是并发问题，但实际却不是！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Message:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Store update, insert, or delete statement affected an unexpected number of rows (0). Entities may have been modified or deleted since entities were loaded. Refresh ObjectStateManager entries.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201711/1024858-20171125230131265-1225355712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;赋给主键一个不存在的值，令&lt;/span&gt;Id=4(在数据库表中不存在Id为4的一条记录)抛出的异常与上面的相同。&lt;/p&gt;

&lt;p&gt;4 &lt;strong&gt;&lt;span&gt;字段超长抛出异常：&lt;/span&gt;System.Data.Entity.Validation.DbEntityValidationException&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表中&lt;/span&gt;Nickname &lt;span&gt;字段定义为&lt;/span&gt;50个字符，现在赋值超过50。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作代码如下&lt;/span&gt;:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt; (CustomDbContext db = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomDbContext())
                {
                    User user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User
                    {
                        Id &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,
                        Email &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test@132.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        Nickname &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestUpdateErrorTestUpdateErrorTestUpdateErrorTestUpdateErrorTestUpdateErrorTestUpdateErrorTestUpdateErrorTestUpdateErrorTestUpdateErrorTestUpdateErrorTestUpdateError&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    };
                    DbEntityEntry&lt;/span&gt;&amp;lt;User&amp;gt; entry = db.Entry&amp;lt;User&amp;gt;&lt;span&gt;(user);
                    entry.State &lt;/span&gt;=&lt;span&gt; EntityState.Unchanged;
                    entry.Property(t &lt;/span&gt;=&amp;gt; t.Email).IsModified = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num =&lt;span&gt; db.SaveChanges();
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行程序报错：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201711/1024858-20171125230228984-503881830.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一层一层点开，查看具体原因：&lt;img src=&quot;https://images2018.cnblogs.com/blog/1024858/201711/1024858-20171125230353593-1287100658.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; -----------------------------------------------------------------------------------------&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;global-zeroclipboard-html-bridge&quot; class=&quot;global-zeroclipboard-container&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;转载与引用请注明出处。&lt;/p&gt;
&lt;p&gt;时间仓促，水平有限，如有不当之处，欢迎指正。&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Sat, 25 Nov 2017 15:06:00 +0000</pubDate>
<dc:creator>甜橙很酸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hdwgxz/p/7897031.html</dc:identifier>
</item>
<item>
<title>匿名内部类之白话文版 - 程序猿伊桑</title>
<link>http://www.cnblogs.com/ethan0603/p/7896994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ethan0603/p/7896994.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　匿名内部类对于很多刚入门的新手来说，都是一个很难跨越的坎，不是说这东西有多难，主要是这东西太饶，那么我们如何才能征服这小妖精呢？其实最重要的是搞懂三个明确：&lt;/span&gt;1.&lt;span&gt;匿名内部类是存在在外部内的成员方法内的，换句话说匿名内部类它首先得是一个局部内部类；&lt;/span&gt;&lt;span&gt;2.&lt;/span&gt;&lt;span&gt;匿名内部类必须实现一个接口或继承一个类&lt;/span&gt; &lt;span&gt;3.&lt;/span&gt;&lt;span&gt;第三个明确是在第二个明确基础上的，就是匿名内部类它实质也就是它继承的类或者实现接口的匿名子类对象，注意注意，它本质是一个子类对象！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其实看代码会觉得匿名内部类的格式很复杂，各种花括号小括号分号缠绕在一块，如果用文字表达，看上去就清晰很多了：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　new 父类(或接口){ 子类内容 }。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　根据上面的解释，好像对于匿名内部类有一点点了解了，那么我们就去试一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　要有匿名内部类，我们首先得创建一个接口或类：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AbsClass{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method(){
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         System.out.println(&quot;我是抽象类的method&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　然后我们创建一个外部类，在外部类的成员方法内定义匿名内部类（就是之前提到的三个明确之一，匿名内部类首先得是一个局部内部类）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Outer{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method(){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         System.out.println(&quot;我是外部类的method&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; AbsClass() {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;new出来的这整个代码块，其实就代表匿名内部类，实际上也就是父类或接口的子类对象。所以，我们可以当然可以在new代码块之后用.方法名来调用本类方法&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 System.out.println(&quot;我是内部类的show&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }.show();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当然我们也可以创建一个父类或接口引用指向这个匿名内部类(也就是匿名子类对象),然后用变量名来调用方法，这是比较常用的&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         AbsClass abs1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AbsClass() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 System.out.println(&quot;我是通过变量名调用的内部类的show&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        abs1.show();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;创建测试类对其进行测试：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; 匿名内部类Test01 {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Outer().method();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;　　其实现在要理解起来就会轻松很多，我要使用匿名内部类，其实就是创建某个类或者接口的子类对象而已，只不过这个子类对象稍微特殊一点，它匿名罢了。那么匿名内部类到底会在哪些地方被应用到呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当方法参数是接口或抽象类类型时，可以使用匿名内部类作为实际参数作为传递&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;这也是动态代理的主要操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面用代码来进行分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先定义一个类或接口&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Inter{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show1();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show2();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　然后创建外部类，在外部类的成员方法内创建匿名内部类：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; 匿名内部类Test02 {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show(Inter in){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当一个方法定义时的形参是一个引用类型，那么它实际上是需要这个类或&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;者其子类或实现的对象，这个我们应该很清楚&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        in.show1();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        in.show2();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;          &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 当我们以前看到这个show()方法参数是一个引用类型数据时，都是会去创建他的对象作为实际参数传递
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;         * 如果是接口或者抽象类，我们就创建其子类对象作为实参进行传递，
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;         * 但现在我们知道了匿名内部类的实质，也就是父类或接口的匿名子类对象，我们就可以将匿名内部类作为参数传递了，因为他实际上也是对象啊
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;         * 我们只是需要在传递过程中完成对其父类抽象方法的重写即可
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         show(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Inter() {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show2() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 System.out.println(&quot;我是匿名内部类的show1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show1() {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 System.out.println(&quot;我是匿名内部类的show2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　我们现在都知道匿名内部类有两种调用自己内部方法的形式了，一种是用匿名对象调用，也就是在&lt;/span&gt;new&lt;span&gt;代码块后面直接&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;方法名；另一种则是通过父类引用来调用方法，那么他们到底有什么区别呢？&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; 匿名对象类Demo03 {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Outer03().method();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Inter03{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show1();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show2();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Outer03{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; method(){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Inter03() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show2() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 System.out.println(&quot;show1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show1() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 System.out.println(&quot;show2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show3(){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 System.out.println(&quot;我不是重写父类方法，我是自己的方法show3&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         }.show3();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这样子我是能调用我自己的方法show()3的,此时我又想调用里面的多个方法，所以我就想到了通过父类引用来给这个子类对象赋变量名，于是...&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         Inter03 inter03=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Inter03() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show2() {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 System.out.println(&quot;show1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show1() {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 System.out.println(&quot;show2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show3(){
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 System.out.println(&quot;我不是重写父类方法，我是自己的方法show3&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;inter03.show3();于是，我们很明显看到这里报错了，为什么呢？
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为我们这里用父类引用指向子类对象，也就形成了多态，而多态中成员方法是完全按照父类中的执行的，不能执行子类特有方法，所以就报错了
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;那么为什么上面通过匿名内部类直接调用自己特有方法就可以呢？因为他本质是一个对象，当没有父类引用指向它时，它当然可以调用自己本身的方法&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　其实看过上面的代码，就能明白他们的区别了。用父类引用进行调用的时候，只能调用父类中本来定义过的方法，因为父类引用指向子类对象就是多态！多态！！这里是很多人会跳入陷阱的地方了，对于成员方法而言，不管是编译还是运行，都是从父类中找的，那么如果你通过这个引用调用匿名内部类中特有的方法，自然是不可能实现的啦！！然后我们通过匿名对象&lt;/span&gt;.&lt;span&gt;方法名的方法为什么就可以呢？因为它就是子类对象啊，它就死它自己啊，它并没有向上转型啊，自己当然可以调用自己的方法啊！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说的最简单的，匿名对象类一个前提，两个明确：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前提：必须定义接口或父类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　明确：&lt;/span&gt;1.&lt;span&gt;定义在成员方法内，是局部内部类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　2.&lt;span&gt;匿名内部类的本质是继承的父类或实现的接口的匿名子类对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果能想通这三个东西，对于理解使用匿名内部类也就没什么难度了。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 25 Nov 2017 14:57:00 +0000</pubDate>
<dc:creator>程序猿伊桑</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ethan0603/p/7896994.html</dc:identifier>
</item>
<item>
<title>IIFE（立即执行函数表达式） - liuyongjia</title>
<link>http://www.cnblogs.com/liuyongjia/p/7896923.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuyongjia/p/7896923.html</guid>
<description>&lt;p&gt;我们经常会看到这样的写法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;(&lt;span class=&quot;at&quot;&gt;fuction&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;// do something&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就是一个简单的IIFE（立即执行函数表达式，immediately-invoked function expression）了。&lt;/p&gt;
&lt;p&gt;这样的写法有什么好处呢？来简单分析一下。&lt;/p&gt;
&lt;h2 id=&quot;开头的分号&quot;&gt;1. 开头的分号&lt;/h2&gt;
&lt;p&gt;我们都知道，js是可以加分号或者不加分号的，在某些情况下，不加分号会让解析器解析出错，举个例子：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; 
    a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; b &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
a &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; b &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;
(b &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; a)
&lt;span class=&quot;co&quot;&gt;// Uncaught TypeError: 3 is not a function&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解析代码的时候，a = b + 3和(b = a)这两条语句之间没有明确的分界，回车和空格会自动被忽略。解析器会认为这是一句。所以，此时会认为3是一个函数，b=a是他的参数。&lt;br/&gt;在知乎的&lt;a href=&quot;https://www.zhihu.com/question/20298345&quot;&gt;这个问题&lt;/a&gt;下，尤大做了解释。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;真正会导致上下行解析出问题的 token 有 5 个：括号，方括号，正则开头的斜杠，加号，减号。我还从没见过实际代码中用正则、加号、减号作为行首的情况，所以总结下来就是一句话：一行开头是括号或者方括号的时候加上分号就可以了，其他时候全部不需要。其实即使是这两种情况，在实际代码中也颇为少见。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ok，回到我们的例子，我们的例子就是以括号开头的，如果上一个语句没有加分号，很可能会出现这样问题，这个分号就是为了防止这样的情况发生，称之为防御性分号。&lt;/p&gt;
&lt;h2 id=&quot;function&quot;&gt;2. function(){}&lt;/h2&gt;
&lt;p&gt;函数有两种声明方式：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;foo&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; foo &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两种声明方式的不同之处在于，使用var声明的函数不会自动提升到顶部。也就是说，不能在var声明函数的语句之前调用函数，否则会抛出undefined的错误。&lt;br/&gt;function () {}这种形式被称为匿名函数。匿名函数没有名字，也就是没有指针，是无法在其他地方调用的。&lt;br/&gt;将匿名函数赋值给foo，则可以通过foo来调用。&lt;br/&gt;当然还有办法调用它，就是例子中的两对括号。第一对括号将匿名函数包装成了一个表达式，而第二对括号意思就是立即执行它。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 报错 Uncaught SyntaxError: Unexpected token (&lt;/span&gt;
(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;) &lt;span class=&quot;co&quot;&gt;// 返回函数定义 ƒ () {console.log('a')}，没有log&lt;/span&gt;
(&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; () &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)() &lt;span class=&quot;co&quot;&gt;// a&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;at&quot;&gt;foo&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'a'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;() &lt;span class=&quot;co&quot;&gt;// 报错 Uncaught SyntaxError: Unexpected token )&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行，因为不是合法的声明方式，希望找到函数名的地方是‘(’，所以抛出了该异常。&lt;br/&gt;第二行，（）中的语句被当成了表达式，解析器会认为是var声明的方式。&lt;br/&gt;第三行，自执行。&lt;br/&gt;第四行，function foo() {console.log('a')}是正确的函数声明方式，被正确解析。接下来的一对括号依次解析，括号里需要有表达式，但是没有，所以会抛出这样的异常。&lt;/p&gt;
&lt;h2 id=&quot;好处&quot;&gt;3. 好处&lt;/h2&gt;
&lt;p&gt;IIFE的好处就是不会污染全局变量，就在当前的函数体的作用域下进行操作，保证了父作用域的干净，如果return出一些函数，那这些函数就形成了闭包。&lt;br/&gt;我们常用IIFE来写module。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; counter &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; i&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;( val )&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      i &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; val&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;increment&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;() &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;++&lt;/span&gt;i&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;op&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)()&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F&quot;&gt;维基百科：立即调用函数表达式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/question/20298345&quot;&gt;知乎：JavaScript 语句后应该加分号么？&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 25 Nov 2017 14:36:00 +0000</pubDate>
<dc:creator>liuyongjia</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuyongjia/p/7896923.html</dc:identifier>
</item>
<item>
<title>Android音视频通话过程中最小化成悬浮框的实现（类似Android8.0画中画效果） - CKTim</title>
<link>http://www.cnblogs.com/cxk1995/p/7824375.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxk1995/p/7824375.html</guid>
<description>&lt;p&gt;&lt;span&gt;关于音视频通话过程中最小化成悬浮框这个功能的实现，网络上类似的文章很多，但是好像还没看到解释的较为清晰的，这里因为项目需要实现了这样的一个功能，今天我把它记录下来，一方面为了以后用到便于自己查阅，一方面也给有需要的人提供一个思路，让大家少走弯路。这里我也是参考了些有关Android悬浮框的文章，再结合自己的理解所实现出来的，可能实现的方法不是最好，但是这或许也是一个可行的方案。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、实现效果（gif效果可能录制的不是特别好）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;http://images2017.cnblogs.com/blog/913913/201711/913913-20171112214644700-761711102.gif&quot; alt=&quot;&quot;/&gt;              &lt;img src=&quot;http://images2017.cnblogs.com/blog/913913/201711/913913-20171112215257216-13134648.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、实现思路&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于这个功能的实现其实不难，这里我把实现思路拆分为了两步：1、视频通话Activity的最小化。 2、视频通话悬浮框的开启&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;具体思路是这样的：&lt;span&gt;当&lt;/span&gt;&lt;span&gt;用户点击最小化按钮的时候，最小化我们的视频通话Activity（这时Activity处于后台状态），移除原先在Activity的视频画布（因为我用的是网易云信，这里他们只能允许一个视频画布存在，这里看情况要不要移除），于此同时，延时个几百毫秒，开启悬浮框，新建一个新的视频画布然后动态添加到悬浮框里面去，监听悬浮框的触摸事件，让悬浮框可以拖拽移动；监听悬浮框的点击事件，如果用户点击了悬浮框，则移除悬浮框里面新建的那个视频画布，然后重新调起我们在后台的视频通话Activity，紧接着新建一个新的视频画布重新动态的添加到Activity里面去。关于视频画布的添加移除方法，这里要看一下所接入的第三方SDK，如用的若是网易云信的SDK，他们的方法如下（下面摘自他们的SDK说明文档），也就是说移除画布我只需要传入null就行了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/913913/201711/913913-20171112224008950-761319050.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.Activity是如何实现最小化的？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Activity最小化可能你没有听过，但是只要姿势对的话，其实实现起来非常简单，因为Activity本身就自带了一个moveTaskToBack(boolean nonRoot)，如果我们要实现最小化，只需要调用moveTaskToBack(true)传入一个true值就可以了，但是这里有一个前提，就是需要设置Activity的启动模式为singleInstance模式，两步搞定。（&lt;span&gt;注：这里先记住一个小知识点，就是activity最小化后重新从后台回到前台会回调onRestart()方法&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    public boolean moveTaskToBack(boolean nonRoot) {
        return super.moveTaskToBack(nonRoot);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.悬浮框是如何开启的？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我把悬浮框的实现方法写在一个服务Service里面，将悬浮框的开启关闭与服务Service的绑定解绑所关联起来，开启服务即相当于开启我们的悬浮框，解绑服务则相当于关闭关闭的悬浮框，以此来达到更好的控制效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a. 首先我们声明一个服务类，取名为FloatVideoWindowService：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public class FloatVideoWindowService extends Service {

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return new MyBinder();
    }

    public class MyBinder extends Binder {
        public FloatVideoWindowService getService() {
            return FloatVideoWindowService.this;
        }
    }

    @Override
    public void onCreate() {
        super.onCreate();
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        return super.onStartCommand(intent, flags, startId);
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;b. 为悬浮框建立一个布局文件alert_float_video_layout，这里根据需求去写，如果只是像我上面gif那样，只需要悬浮框显示对方的视频画布，那么布局文件可以如下所示：（其中悬浮框大小我这里固定为长80dp，高110dp，id为small_size_preview的Linearlayout主要是一个容器，可以动态的添加view到里面去，也就是我们的视频画布）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;&amp;gt;

    &amp;lt;FrameLayout
        android:layout_width=&quot;80dp&quot;
        android:layout_height=&quot;110dp&quot;
        android:background=&quot;@color/black_1f2d3d&quot;&amp;gt;

        &amp;lt;LinearLayout
            android:id=&quot;@+id/small_size_preview&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot;
            android:background=&quot;@color/transparent&quot;
            android:orientation=&quot;vertical&quot; /&amp;gt;
    &amp;lt;/FrameLayout&amp;gt;
&amp;lt;/LinearLayout&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;c. 布局定义好后，接下来就要对悬浮框做一些初始化操作了，初始化操作这里我们放在服务的onCreate()生命周期里面执行，因为只需要执行一次就行了。&lt;/span&gt;&lt;span&gt;这里的初始化主要包括对：&lt;span&gt;悬浮框的基本参数（位置，宽高等），悬浮框的点击事件以及悬浮框的触摸事件（即可拖动范围）等的设置&lt;/span&gt;，代码注释已经很清楚，直接看代码，如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public class FloatVideoWindowService extends&lt;/span&gt;&lt;span&gt;&lt;span&gt; Service {
    private&lt;/span&gt;&lt;span&gt;&lt;span&gt; WindowManager mWindowManager;
    private&lt;/span&gt;&lt;span&gt;&lt;span&gt; WindowManager.LayoutParams wmParams;
    private&lt;/span&gt;&lt;span&gt;&lt;span&gt; LayoutInflater inflater;

    //constant
    private boolean&lt;/span&gt;&lt;span&gt;&lt;span&gt; clickflag;

    //view
    private View mFloatingLayout;    //浮动布局
    private&lt;/span&gt;&lt;span&gt;&lt;span&gt; LinearLayout smallSizePreviewLayout; //容器父布局

    @Nullable
    @Override
    public&lt;/span&gt;&lt;span&gt;&lt;span&gt; IBinder onBind(Intent intent) {
        return new&lt;/span&gt;&lt;span&gt;&lt;span&gt; MyBinder();
    }

    public class MyBinder extends&lt;/span&gt;&lt;span&gt;&lt;span&gt; Binder {
        public&lt;/span&gt;&lt;span&gt;&lt;span&gt; FloatVideoWindowService getService() {
            return FloatVideoWindowService.this&lt;/span&gt;&lt;span&gt;&lt;span&gt;;
        }
    }

    @Override
    public void&lt;/span&gt;&lt;span&gt;&lt;span&gt; onCreate() {
        super&lt;/span&gt;&lt;span&gt;&lt;span&gt;.onCreate();
        initWindow();//设置悬浮窗基本参数（位置、宽高等）
        initFloating();//悬浮框点击事件的处理
&lt;/span&gt;&lt;span&gt;&lt;span&gt;    }

    @Override
    public int onStartCommand(Intent intent, int flags, int&lt;/span&gt;&lt;span&gt;&lt;span&gt; startId) {
        return super&lt;/span&gt;&lt;span&gt;&lt;span&gt;.onStartCommand(intent, flags, startId);
    }

  
    @Override
    public void&lt;/span&gt;&lt;span&gt;&lt;span&gt; onDestroy() {
        super&lt;/span&gt;&lt;span&gt;&lt;span&gt;.onDestroy();
    }

    /**
     * 设置悬浮框基本参数（位置、宽高等）
     */
    private void&lt;/span&gt;&lt;span&gt;&lt;span&gt; initWindow() {
        mWindowManager =&lt;/span&gt;&lt;span&gt;&lt;span&gt; (WindowManager) getApplicationContext().getSystemService(Context.WINDOW_SERVICE);
        wmParams = getParams();//设置好悬浮窗的参数
        // 悬浮窗默认显示以左上角为起始坐标
        wmParams.gravity = Gravity.LEFT |&lt;/span&gt;&lt;span&gt;&lt;span&gt; Gravity.TOP;
        //悬浮窗的开始位置，因为设置的是从左上角开始，所以屏幕左上角是x=0;y=0
        wmParams.x = 70&lt;/span&gt;&lt;span&gt;&lt;span&gt;;
        wmParams.y = 210&lt;/span&gt;&lt;span&gt;&lt;span&gt;;
        //得到容器，通过这个inflater来获得悬浮窗控件
        inflater =&lt;/span&gt;&lt;span&gt;&lt;span&gt; LayoutInflater.from(getApplicationContext());
        // 获取浮动窗口视图所在布局
        mFloatingLayout = inflater.inflate(R.layout.alert_float_video_layout, null&lt;/span&gt;&lt;span&gt;&lt;span&gt;);
        // 添加悬浮窗的视图
&lt;/span&gt;&lt;span&gt;&lt;span&gt;        mWindowManager.addView(mFloatingLayout, wmParams);
    }

  
    private&lt;/span&gt;&lt;span&gt;&lt;span&gt; WindowManager.LayoutParams getParams() {
        wmParams = new&lt;/span&gt;&lt;span&gt;&lt;span&gt; WindowManager.LayoutParams();
        //设置window type 下面变量2002是在屏幕区域显示，2003则可以显示在状态栏之上
        wmParams.type =&lt;/span&gt;&lt;span&gt;&lt;span&gt; WindowManager.LayoutParams.TYPE_TOAST;
        //设置可以显示在状态栏上
        wmParams.flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL |&lt;/span&gt;&lt;span&gt;&lt;span&gt;
                WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR |&lt;/span&gt;&lt;span&gt;&lt;span&gt;
                WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH;

        //设置悬浮窗口长宽数据
        wmParams.width =&lt;/span&gt;&lt;span&gt;&lt;span&gt; WindowManager.LayoutParams.WRAP_CONTENT;
        wmParams.height =&lt;/span&gt;&lt;span&gt;&lt;span&gt; WindowManager.LayoutParams.WRAP_CONTENT;
        return&lt;/span&gt;&lt;span&gt;&lt;span&gt; wmParams;
    }
&lt;br/&gt;　　
    private void&lt;/span&gt;&lt;span&gt;&lt;span&gt; initFloating() {
        smallSizePreviewLayout =&lt;/span&gt;&lt;span&gt;&lt;span&gt; mFloatingLayout.findViewById(R.id.small_size_preview);

        //悬浮框点击事件
        smallSizePreviewLayout.setOnClickListener(new&lt;/span&gt;&lt;span&gt;&lt;span&gt; View.OnClickListener() {
            @Override
            public void&lt;/span&gt;&lt;span&gt;&lt;span&gt; onClick(View v) {
              　//在这里实现点击重新回到Activity
            }
        });

        //悬浮框触摸事件，设置悬浮框可拖动
        smallSizePreviewLayout.setOnTouchListener(new&lt;/span&gt;&lt;span&gt;&lt;span&gt; FloatingListener());
    }

    //开始触控的坐标，移动时的坐标（相对于屏幕左上角的坐标）
    private int&lt;/span&gt;&lt;span&gt;&lt;span&gt; mTouchStartX, mTouchStartY, mTouchCurrentX, mTouchCurrentY;
    //开始时的坐标和结束时的坐标（相对于自身控件的坐标）
    private int&lt;/span&gt;&lt;span&gt;&lt;span&gt; mStartX, mStartY, mStopX, mStopY;&lt;br/&gt;　　 //判断悬浮窗口是否移动，这里做个标记，防止移动后松手触发了点击事件
    private boolean isMove;

    private class FloatingListener implements&lt;/span&gt;&lt;span&gt;&lt;span&gt; View.OnTouchListener {

        @Override
        public boolean&lt;/span&gt;&lt;span&gt;&lt;span&gt; onTouch(View v, MotionEvent event) {
            int action =&lt;/span&gt;&lt;span&gt;&lt;span&gt; event.getAction();
            switch&lt;/span&gt;&lt;span&gt;&lt;span&gt; (action) {
                case&lt;/span&gt;&lt;span&gt;&lt;span&gt; MotionEvent.ACTION_DOWN:
                    isMove = false&lt;/span&gt;&lt;span&gt;&lt;span&gt;;
                    mTouchStartX = (int&lt;/span&gt;&lt;span&gt;&lt;span&gt;) event.getRawX();
                    mTouchStartY = (int&lt;/span&gt;&lt;span&gt;&lt;span&gt;) event.getRawY();
                    mStartX = (int&lt;/span&gt;&lt;span&gt;&lt;span&gt;) event.getX();
                    mStartY = (int&lt;/span&gt;&lt;span&gt;&lt;span&gt;) event.getY();
                    break&lt;/span&gt;&lt;span&gt;&lt;span&gt;;
                case&lt;/span&gt;&lt;span&gt;&lt;span&gt; MotionEvent.ACTION_MOVE:
                    mTouchCurrentX = (int&lt;/span&gt;&lt;span&gt;&lt;span&gt;) event.getRawX();
                    mTouchCurrentY = (int&lt;/span&gt;&lt;span&gt;&lt;span&gt;) event.getRawY();
                    wmParams.x += mTouchCurrentX -&lt;/span&gt;&lt;span&gt;&lt;span&gt; mTouchStartX;
                    wmParams.y += mTouchCurrentY -&lt;/span&gt;&lt;span&gt;&lt;span&gt; mTouchStartY;
                    mWindowManager.updateViewLayout(mFloatingLayout, wmParams);

                    mTouchStartX =&lt;/span&gt;&lt;span&gt;&lt;span&gt; mTouchCurrentX;
                    mTouchStartY =&lt;/span&gt;&lt;span&gt;&lt;span&gt; mTouchCurrentY;
                    break&lt;/span&gt;&lt;span&gt;&lt;span&gt;;
                case&lt;/span&gt;&lt;span&gt;&lt;span&gt; MotionEvent.ACTION_UP:
                    mStopX = (int&lt;/span&gt;&lt;span&gt;&lt;span&gt;) event.getX();
                    mStopY = (int&lt;/span&gt;&lt;span&gt;&lt;span&gt;) event.getY();
                    if (Math.abs(mStartX - mStopX) &amp;gt;= 1 || Math.abs(mStartY - mStopY) &amp;gt;= 1&lt;/span&gt;&lt;span&gt;&lt;span&gt;) {
                        isMove = true&lt;/span&gt;&lt;span&gt;&lt;span&gt;;
                    }
                    break&lt;/span&gt;&lt;span&gt;&lt;span&gt;;
            }

            //如果是移动事件不触发OnClick事件，防止移动的时候一放手形成点击事件
            return&lt;/span&gt;&lt;span&gt;&lt;span&gt; isMove;
        }
    }
}       &lt;/span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;d. 在悬浮框成功被初始化以及相关参数被设置后，接下来就需要将对方的视频画布添加到悬浮框里面去了，这样我们才能看到对方的视频画面嘛，同样我们是在&lt;span&gt;Service的oncreate这个生命周期&lt;/span&gt;完成这个操作的，&lt;span&gt;这里视频画布的添加方式使用的网易云信的SDK，具体的添加方式视不同的SDK而定&lt;/span&gt;，代码如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    /**
     * 初始化预览窗口
     */
    private void initSurface() {
        if (smallRender == null) {
            smallRender = new AVChatSurfaceV&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 25 Nov 2017 14:36:00 +0000</pubDate>
<dc:creator>CKTim</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cxk1995/p/7824375.html</dc:identifier>
</item>
</channel>
</rss>