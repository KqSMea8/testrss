<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>淘宝天猫商品抓取 - TTyb</title>
<link>http://www.cnblogs.com/TTyb/p/7816794.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TTyb/p/7816794.html</guid>
<description>&lt;p&gt;&lt;em&gt;知己知彼，百战百胜。意为如果对敌我双方的情况都能了解透彻，打起仗来百战就不会有危险。语出《孙子·谋攻篇》：“知彼知己，百战不殆；不知彼而知己，一胜一负；不知彼，不知己，每战必殆。”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;任何一个电子商务公司想要存活下去，必须要时时掌控市场的动态，包括但不局限于：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;爆款款式&lt;/li&gt;
&lt;li&gt;热卖销量&lt;/li&gt;
&lt;li&gt;加个动态&lt;/li&gt;
&lt;li&gt;竞争对手动态&lt;/li&gt;
&lt;li&gt;买家购买趋势&lt;br/&gt;...&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;等等...&lt;/p&gt;
&lt;p&gt;可以说掌握了市场的动态就相当于掌握了赚钱的渠道，接下来就是强大的运营团队的事情。那么问题来了，如何让运营能够时时把控市场呢？&lt;/p&gt;
&lt;h3 id=&quot;阿里数据产品&quot;&gt;阿里数据产品&lt;/h3&gt;
&lt;p&gt;可以说 &lt;strong&gt;阿里集团&lt;/strong&gt; 为卖家提供了大量的资源，其中包括一项非常重要的资源： &lt;code&gt;数据&lt;/code&gt; 。但是阿里巴巴的产品种类繁多，且价格不凡，一般的电商公司都会选购这些产品：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;生意参谋&lt;/li&gt;
&lt;li&gt;采购排行&lt;/li&gt;
&lt;li&gt;网销宝&lt;/li&gt;
&lt;li&gt;订单大管家&lt;/li&gt;
&lt;li&gt;量子恒道电商分析&lt;br/&gt;...&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;大量的数据产品充实卖家后台，但是这些无非就是一些数据，在大数据时代最值钱的也是数据，阿里的 ** 生意参谋 ** 几乎能满足大部分卖家的后台数据。但是各个运营会发现，** 生意参谋 ** 里面大部分的数据都是卖家自身的数据，对于其他卖家的数据很少，且都通过了变形。什么是变形，就是不展示原始的数据，仅仅提供一个叫做 &lt;code&gt;淘宝指数&lt;/code&gt; 的值，虽然包含一定的价值，但是在这个统计量上做的分析总会有一些偏差，而真实的数据往往是卖家最需要的。&lt;/p&gt;
&lt;p&gt;** 生意参谋 **&lt;/p&gt;
&lt;h3 id=&quot;爬虫教程&quot;&gt;爬虫教程&lt;/h3&gt;
&lt;p&gt;作者是一个 &lt;em&gt;爬虫爱好者&lt;/em&gt; ，对于网站的爬虫有一定的心得，因此写了教程 &lt;a href=&quot;http://www.tybai.com/crawlerfirst/_%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B.html&quot;&gt;python爬虫教程&lt;/a&gt;。用 &lt;code&gt;python&lt;/code&gt; 写一个小型的爬虫不难，仅仅需要几行就可以搞定：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env python
# -*- coding: utf-8 -*-

import urllib.request

url = &quot;http://www.tybai.com&quot;
# url = &quot;http://www.baidu.com&quot;

html_bytes = urllib.request.urlopen(url).read()
html = html_bytes.decode(&quot;UTF-8&quot;)

print(html)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为此很多读者对我提出了 &lt;strong&gt;如何抓取淘宝天猫商品&lt;/strong&gt; 的需求，毕竟不是每一个读者都能很认真的看完我写的 &lt;a href=&quot;http://www.tybai.com/crawlerfirst/_%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B.html&quot;&gt;python爬虫教程&lt;/a&gt;，而且有些读者是不会编程的，所以我写了一份专门抓取 &lt;code&gt;淘宝天猫商品&lt;/code&gt; 的爬虫，解决大佬们的问题。&lt;/p&gt;
&lt;h3 id=&quot;淘宝天猫商品抓取&quot;&gt;淘宝天猫商品抓取&lt;/h3&gt;
&lt;p&gt;鉴于大部分大佬不会编程，所以做了一个极其简单的网页作为展示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/996148/201711/996148-20171110222317122-1995074616.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;页面内容包含商品的如下信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;店铺名字&lt;/li&gt;
&lt;li&gt;商品标题&lt;/li&gt;
&lt;li&gt;商品原价&lt;/li&gt;
&lt;li&gt;商品折后价&lt;/li&gt;
&lt;li&gt;详情页网址&lt;/li&gt;
&lt;li&gt;评论数&lt;/li&gt;
&lt;li&gt;销量&lt;/li&gt;
&lt;li&gt;促销卖点&lt;/li&gt;
&lt;li&gt;优惠政策&lt;/li&gt;
&lt;li&gt;商品略缩图&lt;/li&gt;
&lt;li&gt;商品大图&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;这些信息在页面可以直接复制到 &lt;code&gt;excel&lt;/code&gt; 中进行分析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/996148/201711/996148-20171110222816841-990637859.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据数据可以完成的 &lt;strong&gt;竞品分析&lt;/strong&gt; 、&lt;strong&gt;实时价格监控&lt;/strong&gt; 、&lt;strong&gt;热卖分析&lt;/strong&gt; 、&lt;strong&gt;热词分析&lt;/strong&gt; 、&lt;strong&gt;美图&lt;/strong&gt; 等等，这些运营会比我清楚，所以不想再列举。&lt;/p&gt;
&lt;p&gt;而且页面最重要的还有能自主 &lt;code&gt;搜索&lt;/code&gt; 、 &lt;code&gt;抓取商品&lt;/code&gt; 等功能，在页面的左上方可以看到输入框，只需要输入查询关键词和抓取的页数就能实时展现在页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/996148/201711/996148-20171110223208059-1983368977.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是我想看到以前的商品信息怎么办？保留着信息在本地呢，在页面可以根据 &lt;strong&gt;日期&lt;/strong&gt; 对历史的查询信息进行查询：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/996148/201711/996148-20171110223317247-377951418.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只要是个卖家就能实时使用这套页面，重点是 &lt;strong&gt;免费&lt;/strong&gt; &lt;strong&gt;免费&lt;/strong&gt; &lt;strong&gt;免费&lt;/strong&gt; ，更加重点的是 &lt;strong&gt;开源&lt;/strong&gt; &lt;strong&gt;开源&lt;/strong&gt; &lt;strong&gt;开源&lt;/strong&gt; ，重要的事说三次！&lt;/p&gt;
&lt;p&gt;想要免费下载的可以在如下页面下载 &lt;a href=&quot;https://github.com/TTyb/tbtmGoods&quot;&gt;下载页面&lt;/a&gt; ，使用方法为，先解压得到如下文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/996148/201711/996148-20171110223653934-1102934902.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;双击 &lt;code&gt;run.bat&lt;/code&gt; 会打开如下页面，当出现 &lt;code&gt;127.0.0.1:5000&lt;/code&gt; 时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/996148/201711/996148-20171110223747059-576695230.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以随意在浏览器里面输入网址 &lt;a href=&quot;http://www.cnblogs.com/TTyb/p/7816794.html&quot; class=&quot;uri&quot;&gt;127.0.0.1:5000&lt;/a&gt; 就能进入展示页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/996148/201711/996148-20171110223843466-518885535.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;搜索下载一应俱全！但是如果你是稍微懂一点 &lt;code&gt;python&lt;/code&gt; ，可以在 &lt;a href=&quot;http://www.tybai.com/python/%E6%B7%98%E5%AE%9D%E5%A4%A9%E7%8C%AB%E5%95%86%E5%93%81%E6%8A%93%E5%8F%96.html&quot;&gt;淘宝天猫商品抓取分析&lt;/a&gt; 里面学习抓取的步骤，可以随意自己更改代码，写出更符合自己公司的代码。&lt;/p&gt;
&lt;p&gt;文章欢迎各位转载，但是请注明作者 &lt;a href=&quot;http://tybai.com&quot;&gt;TTyb&lt;/a&gt; ，出自&lt;a href=&quot;http://www.cnblogs.com/TTyb/p/7816794.html&quot;&gt;淘宝天猫商品抓取&lt;/a&gt; ，谢谢观赏！&lt;/p&gt;
</description>
<pubDate>Sat, 11 Nov 2017 07:38:00 +0000</pubDate>
<dc:creator>TTyb</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TTyb/p/7816794.html</dc:identifier>
</item>
<item>
<title>强大又简单的响应式框架——Foundation 网格系统 - 骚楠</title>
<link>http://www.cnblogs.com/lnzixin/p/7816008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lnzixin/p/7816008.html</guid>
<description>&lt;p class=&quot;active brush&quot;&gt;&lt;span&gt;⊙Foundation的网格系统与Bootstrap的栅格系统及其相似都是分为12列根据屏幕或设备的大小&lt;br/&gt;　　——Foundation有三个列&lt;br/&gt;　　　　　　　　.small（手机端）&lt;br/&gt;　　　　　　　　.medium (平板设备)&lt;br/&gt;　　　　　　　　.large (电脑设备)&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;active brush&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;active brush&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;active brush&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;active brush&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;active brush&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1205872/201711/1205872-20171111130659450-439463172.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;active brush&quot;&gt;&lt;span&gt;⊙&lt;/span&gt;&lt;span&gt;他的导航条也与Bootstrap的相似下面给大家先展示一下他的响应式&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;active brush&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1205872/201711/1205872-20171111131827981-650473017.gif&quot; alt=&quot;&quot; width=&quot;1090&quot; height=&quot;143&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;active brush&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &amp;lt;nav &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;top-bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; data-topbar&amp;gt;
  　　&amp;lt;ul &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title-area&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
   　　 &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
      &amp;lt;!-- 如果你不需要标题或图标可以删掉它 --&amp;gt;
      &amp;lt;h1&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;顶部导航响应&amp;lt;/a&amp;gt;&amp;lt;/h1&amp;gt;
    &amp;lt;/li&amp;gt;
      &amp;lt;!-- 小屏幕上折叠按钮: 去掉 .menu-&lt;span&gt;icon 类，可以去除图标。 
      如果需要只显示图片，可以删除 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Menu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 文本 --&amp;gt;
    &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;toggle-topbar menu-icon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;span&amp;gt;Menu&amp;lt;/span&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;

  &amp;lt;section &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;top-bar-section&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;ul &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
      &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;active&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Home&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Page &lt;span&gt;1&lt;/span&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Page &lt;span&gt;2&lt;/span&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
      &amp;lt;li&amp;gt;&amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Page &lt;span&gt;3&lt;/span&gt;&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; 
    &amp;lt;/ul&amp;gt;
  &amp;lt;/section&amp;gt;
&amp;lt;/nav&amp;gt;

&amp;lt;!-- 初始化 Foundation JS --&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
$(document).ready(function() {
    $(document).foundation();
})
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;active brush&quot;&gt;&lt;span&gt;⊙网格系统，首先创建一行&amp;lt;div class = &quot;row&quot;&amp;gt;这是一行水平的垂直列然后添加列的数量说明 &lt;code&gt;small-&lt;em&gt;num&lt;/em&gt;&lt;/code&gt;, &lt;code&gt;medium-&lt;em&gt;num&lt;/em&gt;&lt;/code&gt; 及 &lt;code&gt;large-&lt;em&gt;num&lt;/em&gt;&lt;/code&gt;类。注意：列的数量 &lt;code&gt;&lt;em&gt;num&lt;/em&gt;&lt;/code&gt; 加起来必须等于 12 :&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;row&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
  ...
&lt;/span&gt;&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;active brush&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;⊙Foundation  网格 - 水平叠堆&lt;br/&gt;　　　　&lt;span&gt;解释：大屏幕  pc上的显示为水平平铺的，小型设备，或缩小屏幕 显示为垂直叠堆的。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;active brush&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;row&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
          &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;medium-6 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:chartreuse;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;网格叠堆&amp;lt;/div&amp;gt;
          &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;medium-6 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:orangered;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;网格叠堆&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;active brush&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;⊙Foundation  网格 - 小型设备（手机）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;解释：以下实例设置了两个列，比例为 25% 和 75% (Foundation 是移动优先: 如果没有特别说明，在大型设备上会继承 .small 类的代码)。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;active brush&quot;&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1205872/201711/1205872-20171111135206372-981457468.gif&quot; alt=&quot;&quot; width=&quot;1062&quot; height=&quot;150&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;row&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;small-3 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:darksalmon;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;小型设备 &lt;span&gt;25&lt;/span&gt;%&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;small-9 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:mediumvioletred;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;小型设备75%&amp;lt;/p&amp;gt;  
  &amp;lt;/div&amp;gt;  
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;⊙Foundation  网格 - 中型设备（平板）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;span&gt;解释：以下实例中我们指定了 &lt;code&gt;.medium-6&lt;/code&gt; 类 (不是 &lt;code&gt;.small-*&lt;/code&gt;)。这表明在中型或大型设备上比例为 50%/50%。但在小型设备上会水平堆叠 (100% 宽度):&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;active brush&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;active brush&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1205872/201711/1205872-20171111135933919-1279640255.gif&quot; alt=&quot;&quot; width=&quot;1061&quot; height=&quot;294&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;row&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;small-3 medium-6 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:yellow;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;中型设备&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;small-9 medium-6 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:pink;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;中型设备&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;

    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;small-3 medium-6 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:cadetblue;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;中型设备&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;small-9 medium-6 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:saddlebrown;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;中型设备&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;⊙Foundation  网格 - 大型设备（电脑）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　解释：以下实例中我们指定了 &lt;code&gt;.large-6&lt;/code&gt; 类 (不是 .medium-* 和 &lt;code&gt;.small-*&lt;/code&gt;)。这表明在大型设备上比例为 50%/50%。但在中型或小型设备上会水平堆叠 (100% 宽度)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　解析：&lt;/span&gt;&lt;span&gt;小型设备两个列的比例为 25%/75% (&lt;code&gt;.small-3&lt;/code&gt; 和 &lt;code&gt;.small-9&lt;/code&gt;)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　　　　　中型设备两个列的比例为 50%/50% (&lt;code&gt;.medium-6&lt;/code&gt; 和 &lt;code&gt;.medium-6&lt;/code&gt;)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　　　　　大型设备两个列的比例为 33%/66% (&lt;code&gt;.large-4&lt;/code&gt; 和 &lt;code&gt;.large-8&lt;/code&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　　　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;active brush&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1205872/201711/1205872-20171111140525013-1626726173.gif&quot; alt=&quot;&quot; width=&quot;1068&quot; height=&quot;277&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;row&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;small-3 medium-6 large-4 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:yellow;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;大型设备&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;small-9 medium-6 large-8 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:pink;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;大型设备&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;⊙foundation 块状网格&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　解释：块状网格用来均分页面内容例如一行内要显示几张图片，不管什么屏幕下都需要均分宽度。可以使用 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 元素加上 &lt;code&gt;.small|medium|large-block-grid-&lt;em&gt;num&lt;/em&gt;&lt;/code&gt; 类来创建块状网格。&lt;em&gt;num&lt;/em&gt; 用于指定均分是数量：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1205872/201711/1205872-20171111143844903-1984535135.gif&quot; alt=&quot;&quot; width=&quot;1052&quot; height=&quot;564&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;ul &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;small-block-grid-2 medium-block-grid-3 large-block-grid-4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;float: left;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;    
        &amp;lt;li&amp;gt;&amp;lt;img src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img/img.gif&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width: 200px;height: 100px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;img src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img/img2.gif&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width: 200px;height: 100px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;img src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img/img3.gif&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width: 200px;height: 100px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;img src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img/img5.gif&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width: 200px;height: 100px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;img src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img/img3.gif&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width: 200px;height: 100px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;img src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;img/img2.gif&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width: 200px;height: 100px;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;⊙Foundation 网格实例&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　解释：创建三个均等列 (33.3%/33.3%/33.3%) ，在中型和大型设备上显示三个列，在小型设备上自动堆叠&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　创建三个不均等列 (25%/50%/25%)，在中型和大型设备上显示三个列，在小型设备上自动堆叠&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　创建两个均等列 (50%/50%)，在小型、中型和大型设备上列的比例始终为 50%/50%&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　等等就不给大家一一解释了 可以根据帮助文档进行了解更多&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1205872/201711/1205872-20171111150815528-2102362772.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;style type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
        div{
            border&lt;/span&gt;-&lt;span&gt;bottom: 1px solid white;
        }
    &lt;/span&gt;&amp;lt;/style&amp;gt;
    &amp;lt;body&amp;gt;
        
        &amp;lt;!--三个均等列--&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;row&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;medium-3 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:yellow;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;.medium-&lt;span&gt;3&lt;/span&gt;&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;medium-6 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:pink;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;.medium-&lt;span&gt;6&lt;/span&gt;&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;medium-3 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:yellow;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;.medium-&lt;span&gt;3&lt;/span&gt;&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
        &amp;lt;!-- 三个不均等列--&amp;gt;
&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;row&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;medium-3 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:yellow;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;.medium-&lt;span&gt;3&lt;/span&gt;&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;medium-6 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:pink;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;.medium-&lt;span&gt;6&lt;/span&gt;&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;medium-3 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:yellow;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;.medium-&lt;span&gt;3&lt;/span&gt;&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
    &amp;lt;!--两个均等列--&amp;gt;
&amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;row&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;small-8 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:yellow;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;.small-&lt;span&gt;8&lt;/span&gt;&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;small-4 columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:pink;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;.small-&lt;span&gt;4&lt;/span&gt;&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
    &amp;lt;!--修改列顺序--&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;row&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;small-4 small-8-push columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:yellow;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;.small-&lt;span&gt;4&lt;/span&gt; .small-&lt;span&gt;8&lt;/span&gt;-push&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;small-8 small-4-pull columns&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; style=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;background-color:pink;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;p&amp;gt;.small-&lt;span&gt;8&lt;/span&gt; .small-&lt;span&gt;4&lt;/span&gt;-pull&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

    &amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 11 Nov 2017 07:26:00 +0000</pubDate>
<dc:creator>骚楠</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lnzixin/p/7816008.html</dc:identifier>
</item>
<item>
<title>浅谈web移动端适配问题 - 黄大渣渣</title>
<link>http://www.cnblogs.com/superSmile/p/7818913.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/superSmile/p/7818913.html</guid>
<description>&lt;p&gt;一、布局方案&lt;/p&gt;
&lt;p&gt;目前在解决移动端页面适配问题方案选择上，目前用得比较多是百分比布局，弹性布局flex，rem布局，本文将重点跟大家探讨rem布局。&lt;/p&gt;
&lt;p&gt;二、viewport&lt;/p&gt;
&lt;p&gt;在介绍rem布局之前，首先跟大家介绍一下viewpoint视口。&lt;/p&gt;
&lt;p&gt;通俗的讲，移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。&lt;/p&gt;
&lt;p&gt;三个viewport：layout viewport，visual viewport，ideal viewport&lt;/p&gt;
&lt;p&gt;layout viewport：即为布局视口，dom宽度，浏览器默认情况下把viewport设为一个较宽的值，比如980px。（document.documentElement.clientWidth）&lt;/p&gt;
&lt;p&gt;visual viewport：浏览器可视区域的大小，屏幕宽度。（window. innerWidth）&lt;/p&gt;
&lt;p&gt;ideal viewport： 理想适口：使布局视口就是可见视口；&lt;/p&gt;
&lt;p&gt;在进行移动设备网站的开发时，我们需要的是ideal viewport。那么怎么才能得到ideal viewport呢？这就该轮到meta标签出场了。&lt;/p&gt;
&lt;p&gt;我们在开发移动设备的网站时，最常见的的一个动作就是把下面这个东西复制到我们的head标签中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在苹果的规范中，meta viewport 有6个属性(暂且把content中的那些东西称为一个个属性和值)，如下：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;1&quot;&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;150&quot;&gt;width&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;673&quot;&gt;设置&lt;em&gt;&lt;strong&gt;layout viewport&lt;/strong&gt;&lt;/em&gt;  的宽度，为一个正整数，或字符串&quot;width-device&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;150&quot;&gt;initial-scale&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;673&quot;&gt;设置页面的初始缩放值，为一个数字，可以带小数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;150&quot;&gt;minimum-scale&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;673&quot;&gt;允许用户的最小缩放值，为一个数字，可以带小数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;150&quot;&gt;maximum-scale&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;673&quot;&gt;允许用户的最大缩放值，为一个数字，可以带小数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;150&quot;&gt;height&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;673&quot;&gt;设置&lt;em&gt;&lt;strong&gt;layout viewport&lt;/strong&gt;&lt;/em&gt;  的高度，这个属性对我们并不重要，很少使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;150&quot;&gt;user-scalable&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;673&quot;&gt;是否允许用户进行缩放，值为&quot;no&quot;或&quot;yes&quot;, no 代表不允许，yes代表允许&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;三、js实现rem自动匹配计算font-size&lt;/p&gt;
&lt;p&gt;利用js监听屏幕宽度变化来实现更改HTML 根元素font-size的值，一下是js代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (doc, win) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; docEl =&lt;span&gt; doc.documentElement,
            resizeEvt &lt;/span&gt;= 'orientationchange' &lt;span&gt;in&lt;/span&gt; window ? 'orientationchange' : 'resize'&lt;span&gt;,
            recalc &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; clientWidth =&lt;span&gt; docEl.clientWidth;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!clientWidth) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(clientWidth&amp;gt;=640&lt;span&gt;){
                    docEl.style.fontSize &lt;/span&gt;= '100px'&lt;span&gt;;
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    docEl.style.fontSize &lt;/span&gt;= 100 * (clientWidth / 640) + 'px'&lt;span&gt;;
                }
            };

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!doc.addEventListener) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        win.addEventListener(resizeEvt, recalc, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        doc.addEventListener(&lt;/span&gt;'DOMContentLoaded', recalc, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    })(document, window);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此代码选640px为基准值，为什么选640呢，&lt;/p&gt;
&lt;p&gt;640px的页面宽度是一个安全的最大宽度，保证了移动端页面两边不会留白。注意这里的px是css逻辑像素，与设备的物理像素是有区别的。如iPhone 5使用的是Retina视网膜屏幕，使用2px x 2px的 device pixel 代表 1px x 1px 的 css pixel，所以设备像素数为640 x 1136px，而它的CSS逻辑像素数为320 x 568px。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以当要切移动端的页面的时候，需要把效果图宽度等比例缩放到640px。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;比如当页面中某一div的宽度为60，高度为65的时候，就可以直接这样写样式：&lt;/p&gt;
&lt;div readability=&quot;34.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    width:&lt;/span&gt;0&lt;span&gt;.6rem;
    height:&lt;/span&gt;0&lt;span&gt;.65rem
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四、使用媒体查询进行适配&lt;/p&gt;
&lt;p&gt;一下为sass写法，比如拿到的设计稿是iPhone6，设备宽为375px.设计稿采用的像素是物理像素，二倍屏(retina)750px,所以当计算的时候要除以2.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// REM 适配 &amp;lt;html&amp;gt;
$designWidth:375;
// 375px (iPhone 6)
// 此为基准值, 与视觉设计稿 `宽度/2` 保持一致
html &lt;/span&gt;{&lt;span&gt;
    font-size&lt;/span&gt;:&lt;span&gt;20px&lt;/span&gt;;
}&lt;span&gt;
@media (min-width:320px)&lt;/span&gt;{&lt;span&gt;
  html{
    font-size&lt;/span&gt;:&lt;span&gt; #{20*320PX/$designWidth&lt;/span&gt;}&lt;span&gt; !important;
  }
}
@media (min-width:360px)&lt;/span&gt;{&lt;span&gt;
  html{
    font-size&lt;/span&gt;:&lt;span&gt; #{20*360PX/$designWidth&lt;/span&gt;}&lt;span&gt; !important;
  }
}
@media (min-width:375px)&lt;/span&gt;{&lt;span&gt;
  html{
    font-size&lt;/span&gt;:&lt;span&gt;#{20*375PX/$designWidth&lt;/span&gt;}&lt;span&gt; !important;
  }
}
@media (min-width:412px)&lt;/span&gt;{&lt;span&gt;
  html{
    font-size&lt;/span&gt;:&lt;span&gt; #{20*412PX/$designWidth&lt;/span&gt;}&lt;span&gt; !important;
  }
}
@media (min-width:480px)&lt;/span&gt;{&lt;span&gt;
  html{
    font-size&lt;/span&gt;:&lt;span&gt;#{20*480PX/$designWidth&lt;/span&gt;}&lt;span&gt; !important;
  }
}
@media (min-width:640px)&lt;/span&gt;{&lt;span&gt;
  html{
    font-size&lt;/span&gt;:&lt;span&gt; #{20*640PX/$designWidth&lt;/span&gt;}&lt;span&gt; !important;
  }
}
@media (min-width:720px)&lt;/span&gt;{&lt;span&gt;
  html{
    font-size&lt;/span&gt;:&lt;span&gt;#{20*720PX/$designWidth&lt;/span&gt;}&lt;span&gt; !important;
  }
}
@media (min-width:768px)&lt;/span&gt;{&lt;span&gt;
  html{
    font-size&lt;/span&gt;:&lt;span&gt; #{20*768PX/$designWidth&lt;/span&gt;}&lt;span&gt; !important;
  }
}
@media (min-width:1440px)&lt;/span&gt;{&lt;span&gt;
  html{
    font-size&lt;/span&gt;:&lt;span&gt;#{20*1440PX/$designWidth&lt;/span&gt;}&lt;span&gt; !important;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了减少单位换算的时间，加快编写代码的效率，可以采用函数自动换算：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@function torem($px)&lt;/span&gt;{&lt;span&gt;//$px为需要转换的字号
    @return ($px / 40) * 1rem; //40px为根字体大小
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为根字体为font-size：20px，设计稿采用2倍像素表示，所以除以20*2;（如果设计稿采用设备像素及跟屏幕尺寸一样的比例，则不用除以2）&lt;/p&gt;
&lt;p&gt;比如一个div的在设计稿上的宽度是366px,高度为239px,则直接可以这样写：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div&lt;/span&gt;{&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt;torem(366)&lt;/span&gt;;&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt;torem(239)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四、图片适配问题&lt;/p&gt;
&lt;p&gt;当项目不需要对图片要求很高的话可以直接通过宽度适配，假如需要多不同的分辨率要对图片进行更换的话，通过设备像素比实现图片更换。以下是解决办法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bg-image($url)
  background-image url($url + &quot;@2x.png&quot;)
  @media (-webkit-min-device-pixel-ratio: 3),(min-device-pixel-ratio)
    background-image url($url + &quot;@3x.png&quot;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;五、具体适配实现要看设计稿给出来的模板而定。分享先到这里。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 11 Nov 2017 06:09:00 +0000</pubDate>
<dc:creator>黄大渣渣</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/superSmile/p/7818913.html</dc:identifier>
</item>
<item>
<title>基于python3.x，使用Tornado中的torndb模块操作数据库 - 17VZ</title>
<link>http://www.cnblogs.com/venz-seventeen/p/7818806.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/venz-seventeen/p/7818806.html</guid>
<description>&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
目前Tornado中的torndb模块是不支持python3.x，所以需要修改部分torndb源码即可正常使用
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、开发环境介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作系统：win8（64位），python版本：python3.6（32位），IDE：pycharm&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、安装torndb（这里使用pip进行安装）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
pip install torndb
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、源码修改&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;修改MySQLdb，torndb是依赖于MySQLdb实现的对MySQL数据库操作，但是python3中不支持MySQLdb，而是使用pymysql，所以需要将源码中使用&lt;strong&gt;MySQLdb的地方修改为&lt;/strong&gt;pymysql。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;1）修改导入模块&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import pymysql.connections
import pymysql.converters
import pymysql.cursors
# import MySQLdb.constants
# import MySQLdb.converters
# import MySQLdb.cursors
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 2）修改连接mysql的方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def reconnect(self):
        &quot;&quot;&quot;Closes the existing database connection and re-opens it.&quot;&quot;&quot;
        self.close()
        self._db = pymysql.connect(**self._db_args)# MySQLdb.connect(**self._db_args)
        self._db.autocommit(True)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3）修改连接参数，以及遍历字段类型时所使用的列表增加元素（python3使用append进行元素的添加，而不是使用加号）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# if MySQLdb is not None:
if pymysql is not None:
    # Fix the access conversions to properly recognize unicode/binary
    FIELD_TYPE = pymysql.connections.FIELD_TYPE # MySQLdb.constants.FIELD_TYPE
    FLAG = pymysql.constants.FLAG# MySQLdb.constants.FLAG
    CONVERSIONS = copy.copy (pymysql.converters.conversions)# (MySQLdb.converters.conversions)

    field_types = [FIELD_TYPE.BLOB, FIELD_TYPE.STRING, FIELD_TYPE.VAR_STRING]
    if 'VARCHAR' in vars(FIELD_TYPE):
        field_types.append(FIELD_TYPE.VARCHAR)

    for field_type in field_types:
        &lt;span&gt;# CONVERSIONS[field_type] = [(FLAG.BINARY, str)] + CONVERSIONS[field_type]
        CONVERSIONS[field_type] = [(FLAG.BINARY, str)].append(CONVERSIONS[field_type])&lt;/span&gt;

    # Alias some common MySQL exceptions
    IntegrityError = pymysql.IntegrityError# MySQLdb.IntegrityError
    OperationalError = pymysql.OperationalError# MySQLdb.OperationalError
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li readability=&quot;3.5&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;修改连接超时时间，在torndb初始化方法中设置，需要传递给pymysql&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def __init__(self, host, database, user=None, password=None,
                 max_idle_time=7 * 3600, connect_timeout=10,# 设置连接超时时间，时间是秒
                 time_zone=&quot;+0:00&quot;, charset = &quot;utf8&quot;, sql_mode=&quot;TRADITIONAL&quot;):
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;修改查询方法中的迭代方法（将izip改为zip_longest）&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def query(self, query, *parameters, **kwparameters):
        &quot;&quot;&quot;Returns a row list for the given query and parameters.&quot;&quot;&quot;
        cursor = self._cursor()
        try:
            self._execute(cursor, query, parameters, kwparameters)
            column_names = [d[0] for d in cursor.description]
            return [Row(itertools.&lt;span&gt;zip_longest&lt;/span&gt;(column_names, row)) for row in cursor]
        finally:
            cursor.close()
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、测试使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1003211/201711/1003211-20171111134642981-1445800556.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class IndexHandler(RequestHandler):
    def get(self, *args, **kwargs):
        # get返回的是字典对象
        ret = self.application.db.get('select title from houses where id = 2')
        self.write(ret['title'])

if __name__ == '__main__':
    options.parse_command_line()
    app = Application([
        (r'/', IndexHandler),
    ], debug=True)
    # 建立数据库连接
    app.db = torndb.Connection(
        host='127.0.0.1',
        database='demo',
        user='you_ruser',
        password='your_password'
    )
    http_server = httpserver.HTTPServer(app)
    http_server.listen(options.port)
    ioloop.IOLoop.current().start()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1003211/201711/1003211-20171111135014622-53925492.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;经过测试，增删改查等数据库操作能够正常使用，就不一一展示了&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 11 Nov 2017 05:54:00 +0000</pubDate>
<dc:creator>17VZ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/venz-seventeen/p/7818806.html</dc:identifier>
</item>
<item>
<title>js实现小球的弹性碰撞。 - 我吃小月饼</title>
<link>http://www.cnblogs.com/interesting-me/p/7818632.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/interesting-me/p/7818632.html</guid>
<description>&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  前  言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;MYBG&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　小编最近在做自己的个人网站，其中就用到了一个小球碰撞检测的功能，想自己写，无奈本人能力不足啊（毕竟还是一个菜鸟）！！就想着找个插件用一下也好，可是找了好久也没有找到一个比较好用的。好在天无绝人之路，在不断的搜搜巡巡过程中，还是发现了一个，用原生js实现小球碰撞检测的方法，下面分享给大家。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：本文参考“敲代码不爱找bug的妹子”的一篇博客，详解可参考：http://blog.csdn.net/new_codeer/article/details/52386566&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　参考过后，经过对原文进行了稍微的改动，特别适用于网站的开发。复制过去，稍微改动一下即可。具体的原代码如下：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、HTML代码（body部分）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;只需要做一个大div包裹几个小div即可，你想要几个小球碰撞就在内部做几个div即可，这里我们做了6个小球&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;main&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面body部分这样就算是完成了，下面我们给body中的div做一些小样式。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、CSS小球样式部分&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将body默认的margin和padding部分去掉&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    *&lt;/span&gt;{
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        margin&lt;/span&gt;:&lt;span&gt; 0px&lt;/span&gt;;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        padding&lt;/span&gt;: &lt;span&gt;0px&lt;/span&gt;;
&lt;span&gt; 6&lt;/span&gt;      }
&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;采用定位的方式，让小球运动起来&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     #main&lt;/span&gt;{
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;         margin&lt;/span&gt;:&lt;span&gt; 0px auto&lt;/span&gt;;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;         position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;
&lt;span&gt;11&lt;/span&gt;      }
&lt;span&gt;12&lt;/span&gt;      &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;小球的样式&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;     #main div&lt;/span&gt;{
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;         overflow&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;         position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;         width&lt;/span&gt;:&lt;span&gt; 80px&lt;/span&gt;;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;         height&lt;/span&gt;:&lt;span&gt; 80px&lt;/span&gt;;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;         opacity&lt;/span&gt;:&lt;span&gt; 0.5&lt;/span&gt;;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;         border-radius&lt;/span&gt;:&lt;span&gt; 50%&lt;/span&gt;;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;         background-color&lt;/span&gt;:&lt;span&gt; red&lt;/span&gt;;
&lt;span&gt;21&lt;/span&gt;      }
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　小球是要运动起来的，我们通过给小球和它的父元素添加定位，最后用js改变其top、bottom、left、right值来让小球运动。现在我们小球的样式已经做好了，下面的js代码才是重中之重。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.1 Android 事件基础知识&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
&lt;span&gt;  2&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; main = document.getElementById(&quot;main&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到小球父元素&lt;/span&gt;
&lt;span&gt;  3&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; circles = main.getElementsByTagName(&quot;div&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到小球&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; st = [0,1,2,3,4,5,6,7,8,9&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; json = [],arr = [],color =&lt;span&gt; [];
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; maxW = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; maxH = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; cwidth = circles[0].offsetWidth; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象可见宽度&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; cheight = circles[0].offsetHeight; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象可见高度&lt;/span&gt;
&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据浏览器窗口的大小自动调节小球的运动空间&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;         window.onresize=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;             maxW=window.innerWidth-circles[0].clientWidth;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小球运动的最大宽度&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;             maxH=window.innerHeight-circles[0].clientHeight;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小球运动的最大高度&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;                 main.style.width = window.innerWidth+&quot;px&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;             main.style.height = window.innerHeight+&quot;px&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;        onresize();
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组对象的初始化&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;circles.length;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;             arr=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=0;j&amp;lt;6;j++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;                 color[j] = st[Math.floor(Math.random()*16&lt;span&gt;)];
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;         arr.x = Math.floor(Math.random()*(maxW+1));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始x坐标&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;         arr.y = Math.floor(Math.random()*(maxH+1));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始y坐标&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;         arr.cx = arr.x + circles[0].offsetWidth/2; //圆心x坐标
&lt;span&gt; 28&lt;/span&gt;         arr.cy = arr.y + circles[0].offsetHeight/2; //圆心y坐标
&lt;span&gt; 29&lt;/span&gt;         arr.movex = Math.floor(Math.random()*2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;x轴移动方向&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;         arr.movey = Math.floor(Math.random()*2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;y轴移动方向&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;         arr.speed = 2+Math.floor(Math.random()*5);&lt;span&gt;//随机生成2-6之间的移动速度，&lt;/span&gt;&lt;span&gt;如果在做项目的时候，这种随即生成的速度不想用的话，可以直接给speed赋值，&lt;br/&gt;固定小球的速度即可。如以下代码：&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;arr.speed = 1.5;&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;         arr.timer = &lt;span&gt;null&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计时器&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;         arr.index = i;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引值&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;        json.push(arr);
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         circles[i].style.left = arr.x + &quot;px&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小球位置初始化&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt;         circles[i].style.top = arr.y + &quot;px&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小球位置初始化&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;碰撞函数&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; crash(a){
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; ball1x =&lt;span&gt; json[a].cx;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; ball1y =&lt;span&gt; json[a].cy;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i= 0;i&amp;lt;json.length;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(i!=&lt;span&gt;a){
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; ball2x =&lt;span&gt; json[i].cx;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; ball2y =&lt;span&gt; json[i].cy;
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;圆心距离的平方&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; len = (ball1x-ball2x)*(ball1x-ball2x)+(ball1y-ball2y)*(ball1y-&lt;span&gt;ball2y);
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(len &amp;lt;= cwidth*&lt;span&gt;cwidth){
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;小球位置的判断，发生碰撞反应&lt;/span&gt;
&lt;span&gt; 52&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;(ball1x &amp;gt;&lt;span&gt;ball2x){
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt;(ball1y &amp;gt;&lt;span&gt; ball2y){
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                                 json[a].movex=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;                                 json[a].movey=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                             }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(ball1y &amp;lt;&lt;span&gt; ball2y){
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;                                 json[a].movex=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;                                 json[a].movey=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;                             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                                 json[a].movex=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(ball1x &amp;lt;&lt;span&gt; ball2x){
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt;(ball1y &amp;gt;&lt;span&gt; ball2y){
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                                 json[a].movex=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;                                 json[a].movey=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;                             }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(ball1y &amp;lt;&lt;span&gt; ball2y){
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;                                 json[a].movex=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                                 json[a].movey=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                             }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                                 json[a].movex=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;                         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt;(ball1y &amp;gt;&lt;span&gt; ball2y){
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                                 json[a].movey=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;                             }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(ball1y &amp;lt;&lt;span&gt; ball2y){
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                                 json[a].movey=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; 
&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动函数&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; move(circle){
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;             circle.timer = setInterval(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(circle.movex == 1&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                     circle.x+=&lt;span&gt;circle.speed;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(circle.x+circle.speed &amp;gt;= maxW){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;防止小球出界&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt;                     circle.x =&lt;span&gt; maxW;
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                     circle.movex=0;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小球运动方向发生改变&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;                 }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                     circle.x-=&lt;span&gt;circle.speed;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(circle.x-circle.speed &amp;lt;= 0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                         circle.x = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                         circle.movex=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(circle.movey == 1&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                     circle.y +=&lt;span&gt; circle.speed;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(circle.y+circle.speed &amp;gt;=&lt;span&gt; maxH){
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;                         circle.y =&lt;span&gt; maxH;
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                         circle.movey=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;                 }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;                     circle.y-=&lt;span&gt;circle.speed;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(circle.y-circle.speed &amp;lt;= 0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;                         circle.y = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                         circle.movey=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;                 circle.cx = circle.x + circles[0].offsetWidth/2;//小球每一次运动圆心都会发生改变
&lt;span&gt;114&lt;/span&gt;                 circle.cy = circle.y + circles[0].offsetHeight/2;
&lt;span&gt;115&lt;/span&gt;                 circles[circle.index].style.left = circle.x + &quot;px&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小球位置重定位&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt;                 circles[circle.index].style.top = circle.y + &quot;px&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;                crash(circle.index);
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;             },15&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对每一个小球绑定计时器，让小球动起来&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;circles.length;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;            move(json[i]);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;  &amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　其实，我们通过上面的代码就可以完全实现一个小球碰撞检测的功能了。但是仅仅是上面的代码，还是会存在一定的bug，就是当整个网站存在右侧滚动条时，当小球碰到屏幕右侧的时候，会出现一瞬的横向滚动条，这就是做网站比较忌讳的了，横向滚动条的出现太丑了。所以我们可以通过以下代码来解决。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;滚动条宽度计算函数&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getScrollbarWidth() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; oP = document.createElement(&quot;p&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 styles =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                     width: &quot;100px&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                     height: &quot;100px&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     overflowY: &quot;scroll&quot;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                }, i, scrollbarWidth;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (i &lt;span&gt;in&lt;/span&gt; styles) oP.style[i] =&lt;span&gt; styles[i];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            document.body.appendChild(oP);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             scrollbarWidth = oP.offsetWidth -&lt;span&gt; oP.clientWidth;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            oP.remove();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; scrollbarWidth;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上是一个计算滚动条宽度的函数，此函数可以计算右侧滚动条的宽度，我们只需要在“根据浏览器窗口的大小自动调节小球的运动空间”上面，调用此函数&lt;/p&gt;
&lt;p&gt;var scrollbarWidth = getScrollbarWidth(); 再修改小球的最大运动宽度   maxW=window.innerWidth-circles[0].clientWidth-scrollbarWidth ;这样这个bug就修改好了。&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;h4 class=&quot;135brush&quot;&gt;编者按&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　这个是我在做项目时的亲身经历，觉得这个写得特别好用，就拿过来与大家分享一下。希望对大家有那么一点点儿帮助吧！！最后还要感谢一下“敲代码不爱找bug的妹子”帮我解决了一个大问题。。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 11 Nov 2017 05:34:00 +0000</pubDate>
<dc:creator>我吃小月饼</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/interesting-me/p/7818632.html</dc:identifier>
</item>
<item>
<title>使用SuperSocket打造逾10万长连接的Socket服务 - 搵中求胜</title>
<link>http://www.cnblogs.com/ycbt/p/7818800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ycbt/p/7818800.html</guid>
<description>&lt;p&gt;SuperSocket 是一个轻量级, 跨平台而且可扩展的 .Net/Mono Socket 服务器程序框架。你无须了解如何使用 Socket, 如何维护 Socket 连接和 Socket 如何工作，但是你却可以使用 SuperSocket 很容易的开发出一款 Socket 服务器端软件，例如游戏服务器，GPS 服务器, 工业控制服务和数据采集服务器等等。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PS&lt;/strong&gt;:&lt;span&gt;上面这句话复制官网的，好了，总之告诉大家SuperSocket已经很强大、很稳定、方便。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果你没有Socket基础，首先要了解协议；本人两年都在做智能穿戴，接触大量硬件厂商，发现大部分是“带起止符的协议”（BeginEndMarkReceiveFilter）或者“头部格式固定并且包含内容长度的协议”（FixedHeaderReceiveFilter）&lt;/p&gt;

&lt;p&gt;我简单介绍这两种协议。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/227601/201711/227601-20171111122943606-1885533053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码上我就二选一介绍FixedHeaderReceiveFilter吧&lt;/p&gt;
&lt;p&gt;首先新建项目，在Nuget管理器上搜索“SuperSocket”安装“SuperSocket”和“SuperSocket.Engine”&lt;/p&gt;


&lt;p&gt;接下来你需要实现&lt;/p&gt;
&lt;p&gt;1、 IRequestInfo（请求信息，一次数据包）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyRequestInfo : IRequestInfo
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MyRequestInfo(&lt;span&gt;byte&lt;/span&gt;[] header, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bodyBuffer)
        {
            Key &lt;/span&gt;= ((header[&lt;span&gt;0&lt;/span&gt;] * &lt;span&gt;256&lt;/span&gt;) + header[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]).ToString();
            Data &lt;/span&gt;=&lt;span&gt; bodyBuffer;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 协议号对应自定义命令Name，会触摸自定义命令
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Key { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 正文字节码
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] Data { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 正文文本，大部分协议都不是这么玩的
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; Body
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Encoding.UTF8.GetString(Data);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、 &lt;span class=&quot;Apple-tab-span&quot;&gt;FixedHeaderReceiveFilter&amp;lt;IRequestInfo&amp;gt;（数据包的解析）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyReceiveFilter : FixedHeaderReceiveFilter&amp;lt;MyRequestInfo&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; +-------+---+-------------------------------+
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; |request| l |                               |
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; | name  | e |    request body               |
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; |  (2)  | n |                               |
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; |       |(2)|                               |
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; +-------+---+-------------------------------+&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyReceiveFilter()
        : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;&lt;span&gt;)
        {

        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; GetBodyLengthFromHeader(&lt;span&gt;byte&lt;/span&gt;[] header, &lt;span&gt;int&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;)header[offset + &lt;span&gt;2&lt;/span&gt;] * &lt;span&gt;256&lt;/span&gt; + (&lt;span&gt;int&lt;/span&gt;)header[offset + &lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
        }
        
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; MyRequestInfo ResolveRequestInfo(ArraySegment&amp;lt;&lt;span&gt;byte&lt;/span&gt;&amp;gt; header, &lt;span&gt;byte&lt;/span&gt;[] bodyBuffer, &lt;span&gt;int&lt;/span&gt; offset, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; body =&lt;span&gt; bodyBuffer.Skip(offset).Take(length).ToArray();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyRequestInfo(header.Array, body);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、 &lt;span class=&quot;Apple-tab-span&quot;&gt;AppSession&amp;lt;TAppSession, TRequestInfo&amp;gt;（Session会话，服务端管理客户端的连接、信息）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MySession : AppSession&amp;lt;MySession, MyRequestInfo&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MySession()
        {

        }&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnSessionStarted()
        {

        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnInit()
        {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnInit();
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; HandleUnknownRequest(MyRequestInfo requestInfo)
        {
&lt;/span&gt;&lt;span&gt;
        }
        
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; HandleException(Exception e)
        {
&lt;/span&gt;&lt;span&gt;
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnSessionClosed(CloseReason reason)
        {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnSessionClosed(reason);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、 &lt;span class=&quot;Apple-tab-span&quot;&gt;AppServer&amp;lt;TAppSession, TRequestInfo&amp;gt;（监听服务）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyServer : AppServer&amp;lt;MySession, MyRequestInfo&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 通过配置文件安装服务从这里启动
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyServer()
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; DefaultReceiveFilterFactory&amp;lt;MyReceiveFilter, MyRequestInfo&amp;gt;&lt;span&gt;())
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.NewSessionConnected +=&lt;span&gt; MyServer_NewSessionConnected;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.SessionClosed +=&lt;span&gt; MyServer_SessionClosed;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; winform启动，不使用这里的事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; MyServer(SessionHandler&amp;lt;MySession&amp;gt; NewSessionConnected, SessionHandler&amp;lt;MySession, CloseReason&amp;gt;&lt;span&gt; SessionClosed)
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; DefaultReceiveFilterFactory&amp;lt;MyReceiveFilter, MyRequestInfo&amp;gt;&lt;span&gt;())
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.NewSessionConnected +=&lt;span&gt; NewSessionConnected;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.SessionClosed +=&lt;span&gt; SessionClosed;
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnStarted()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动成功&lt;/span&gt;
            LogHelper.WriteLog(&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Socket启动成功：{0}:{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.Config.Ip, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Config.Port));
        }

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; MyServer_NewSessionConnected(MySession session)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接成功&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; MyServer_SessionClosed(MySession session, CloseReason value)
        {

        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;好了，你可以跑起来&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; config = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SuperSocket.SocketBase.Config.ServerConfig()
            {
                Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SSServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                ServerTypeName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                ClearIdleSession&lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;60秒执行一次清理90秒没数据传送的连接&lt;/span&gt;
                ClearIdleSessionInterval = &lt;span&gt;60&lt;/span&gt;&lt;span&gt;,
                IdleSessionTimeOut &lt;/span&gt;= &lt;span&gt;90&lt;/span&gt;&lt;span&gt;,
                MaxRequestLength &lt;/span&gt;= &lt;span&gt;2048&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大包长度&lt;/span&gt;
                Ip = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Any&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                Port &lt;/span&gt;= &lt;span&gt;18888&lt;/span&gt;&lt;span&gt;,
                MaxConnectionNumber &lt;/span&gt;= &lt;span&gt;100000&lt;/span&gt;&lt;span&gt;,
            };
            app &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyServer(app_NewSessionConnected, app_SessionClosed);
            LogHelper.SetOnLog(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LogHelper.LogEvent((m) =&amp;gt;&lt;span&gt;
            {
                txtAll.Text &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;, m, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                txtAll.Select(txtAll.TextLength, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
                txtAll.ScrollToCaret();
            }));
            app.Setup(config);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;app.Start())
            {
                LogHelper.WriteLog(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Socket {0}:{1}启动失败，请检查权限或端口是否被占用！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, config.Ip, config.Port));
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/227601/201711/227601-20171111125444278-920821918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;有关性能，本人在本地(笔记本i5 4200H/12G)测试10万连接同时在线，没有问题；当然啦，跟业务有关，比如你要做的是IM群聊，数据到服务端需要频繁计算。&lt;/p&gt;

&lt;p&gt;最后我还有一些提示&lt;/p&gt;
&lt;p&gt;1、 尽可能使用&lt;span&gt;安装成windows服务&lt;/span&gt;，这样性能、稳定性更好；如果前期连接数不大也可用winform中启动&lt;/p&gt;
&lt;p&gt;2、 如果终端可选.net，那使用SuperSocket.ClientEngine比自己又重新敲更稳健&lt;/p&gt;
&lt;p&gt;3、 心跳包应在终端向服务端发送，服务端响应即可，&lt;span&gt;切勿在服务端向终端发心跳&lt;/span&gt;（服务端拥有超时机制，若超时终端重连即可）&lt;/p&gt;
&lt;p&gt;4、 如果需要支持&lt;span&gt;WebSocket&lt;/span&gt;，参考SuperWebScoket；有的网友直接在WebSocket直接连接SuperSocket立即断开&lt;/p&gt;
&lt;p&gt;5、 有的人问&lt;span&gt;怎么传JSON&lt;/span&gt;，参照本文图1先把数据转JSON再转byte[]放到正文内容部分&lt;/p&gt;
&lt;p&gt;6、 做Socket开发，可能经常需要在十进制、十六进制、256&lt;span&gt;进制之间转换&lt;/span&gt;（尤其是在省流量的仅支持2G网络的硬件）&lt;/p&gt;
&lt;p&gt;7、如果你在做硬件开发，你所处的电脑又没有外网IP，可使用&lt;span&gt;&lt;strong&gt;ngrok&lt;/strong&gt;&lt;/span&gt;反向代理TCP，让别人代理访问你的电脑&lt;/p&gt;

&lt;p&gt;有关其他协议或介绍请参考官方文档&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.supersocket.net/v1-6/zh-CN&quot; target=&quot;_blank&quot;&gt;http://docs.supersocket.net/v1-6/zh-CN&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;有关客户端或本例子代码（可直接运行），如果你想先运行看看结果，再自己敲一遍&lt;/p&gt;
&lt;p&gt;链接: &lt;a href=&quot;https://pan.baidu.com/s/1hs09vb2&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1hs09vb2&lt;/a&gt; 密码: 4ntg&lt;/p&gt;

</description>
<pubDate>Sat, 11 Nov 2017 05:12:00 +0000</pubDate>
<dc:creator>搵中求胜</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ycbt/p/7818800.html</dc:identifier>
</item>
<item>
<title>Linux网络中接收 &quot;二进制&quot; 流的那些事 --- 就recv的返回值和strlen库函数进行对话 - Psrion</title>
<link>http://www.cnblogs.com/Older-Driver-of-Newer/p/7818781.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Older-Driver-of-Newer/p/7818781.html</guid>
<description>&lt;p&gt;1.    前言&lt;/p&gt;
&lt;p&gt;　　很多朋友在做网络编程开发的时候可能都遇到这样的问题，在进行接收二进制流的数据的时候，使用strlen库函数来得到&lt;/p&gt;
&lt;p&gt;二进制数据长度的时候并不准确。为什么呢？？首先，使用strlen进行统计长度的为字符串，并非二进制流数据，因此在&lt;/p&gt;
&lt;p&gt;获取二进制数据流的定长中并不适合。解决的问题必然使用网络接收函数的返回值来进行判断，如recv和recvfrom等。&lt;/p&gt;
&lt;p&gt;2.    简单的网络服务器&lt;/p&gt;
&lt;p&gt;　　Linux中简单的网络服务器做起来很简单，无非就是以下几个步骤&lt;/p&gt;
&lt;p&gt;　　创建网络套接字(socket) --&amp;gt; 绑定本地套接字到网络中(bind) --&amp;gt; 设置最大监听数目(listen) --&amp;gt; 监听客户端接入(accept)&lt;/p&gt;
&lt;p&gt;3.　具体的例子&lt;/p&gt;
&lt;p&gt;(服务端)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;errno.h&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;sys/types.h&amp;gt;   
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;sys/socket.h&amp;gt;
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;arpa/inet.h&amp;gt;
&lt;span&gt; 7&lt;/span&gt; #include &amp;lt;unistd.h&amp;gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt;  WEB_PORT      8080
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt;  MAX_CLIENT     5
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt;  MAX_RECV      1024
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc,&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 创建网络套接字&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; sock = socket(AF_INET,SOCK_STREAM,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt; &amp;gt;&lt;span&gt; sock)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         fprintf(stderr,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;socket: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,strerror(errno));
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 设置端口立即释放，可以立即使用&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; on = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,&amp;amp;on,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(on));
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3. 绑定本地套接字到网络中&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in localAddr;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     socklen_t localAddrLen = &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(localAddr);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     localAddr.sin_family =&lt;span&gt; AF_INET;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     localAddr.sin_port =&lt;span&gt; htons(WEB_PORT);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     localAddr.sin_addr.s_addr =&lt;span&gt; htonl(INADDR_ANY);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt; &amp;gt; bind(sock,(&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;&lt;span&gt;localAddr,localAddrLen))
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         fprintf(stderr,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bind: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,strerror(errno));
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4. 设置最大监听数目&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt; &amp;gt;&lt;span&gt; listen(sock,MAX_CLIENT))
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         fprintf(stderr,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bind: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,strerror(errno));
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5. 监听客户端接入&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in peerAddr;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     socklen_t peerAddrLen = &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(peerAddr);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; cRecvDataBuf[MAX_RECV] = {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;     ssize_t sRecvRet = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; connfd = accept(sock,(&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;peerAddr,&amp;amp;&lt;span&gt;peerAddrLen);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt; &amp;gt;&lt;span&gt; connfd)
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             fprintf(stderr,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;accept: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,strerror(errno));
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;    
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;         memset(cRecvDataBuf,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(cRecvDataBuf));
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         sRecvRet = recv(connfd,cRecvDataBuf,&lt;span&gt;sizeof&lt;/span&gt;(cRecvDataBuf),&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt; &amp;gt;&lt;span&gt; sRecvRet)
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;             fprintf(stderr,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;recv: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,strerror(errno));
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;    
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n**************************************\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sRecvRet = %ld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,sRecvRet);
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;strlen(cRecvDataBuf) = %lu\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,strlen(cRecvDataBuf));
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;**************************************\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\ncRecvDataBuf :\n%s\n\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,cRecvDataBuf);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; 
&lt;span&gt;78&lt;/span&gt; &lt;span&gt;        close(connfd);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; 
&lt;span&gt;81&lt;/span&gt; &lt;span&gt;    close(sock);
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt; 
&lt;span&gt;83&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(客户端)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;errno.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;sys/types.h&amp;gt;&lt;span&gt;   
#include &lt;/span&gt;&amp;lt;sys/socket.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;arpa/inet.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;unistd.h&amp;gt;

&lt;span&gt;#define&lt;/span&gt;  WEB_PORT      8080

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc,&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 创建网络套接字&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; sock = socket(AF_INET,SOCK_STREAM,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt; &amp;gt;&lt;span&gt; sock)
    {
        fprintf(stderr,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;socket: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,strerror(errno));
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 设置端口立即释放，可以立即使用&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; on = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,&lt;/span&gt;&amp;amp;on,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(on));

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3. 设置服务器的地址和链接发送二进制流数据&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in serverAddr;
    socklen_t serverAddrLen &lt;/span&gt;= &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(serverAddr);
    serverAddr.sin_family &lt;/span&gt;=&lt;span&gt; AF_INET;
    serverAddr.sin_port &lt;/span&gt;=&lt;span&gt; htons(WEB_PORT);
    serverAddr.sin_addr.s_addr &lt;/span&gt;=&lt;span&gt; htonl(INADDR_ANY);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt; == connect(sock,(&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;&lt;span&gt;serverAddr,serverAddrLen))
    {

        FILE &lt;/span&gt;*pFile = fopen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./linux.bin.ub&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(NULL !=&lt;span&gt; pFile)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4. 获取二进制文件的数据大小            &lt;/span&gt;
            fseek(pFile,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,SEEK_END);
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; lFileSize =&lt;span&gt; ftell(pFile);
            rewind(pFile);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5. 读取数据并发送&lt;/span&gt;
            &lt;span&gt;char&lt;/span&gt; *pSendBuf = (&lt;span&gt;char&lt;/span&gt; *)&lt;span&gt;malloc&lt;/span&gt;(lFileSize+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(NULL ==&lt;span&gt; pSendBuf)
            {
                fprintf(stderr,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;malloc: %s\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,strerror(errno));    
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            }

            memset(pSendBuf,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,lFileSize+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            fread(pSendBuf,lFileSize,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,pFile);
            fclose(pFile);

            send(sock,pSendBuf,lFileSize,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(pSendBuf);
            close(sock);
        }

    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(二进制流数据 : 9.27 MB (9,728,804 字节) )&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1091747/201711/1091747-20171111124030794-1591072624.png&quot; alt=&quot;&quot; width=&quot;776&quot; height=&quot;205&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.    比较结果：&lt;/p&gt;
&lt;p&gt;　　首先本人在服务器端只是接受一次的数据，最大长度为1024字节，那么如何收到的二进制数据的程度实际上应该为1024字节(假设网路正常，只接收一次，由于文件的二进制流数据大小为9728804字节，所以收到的数据长度为1024字节)，具体的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1091747/201711/1091747-20171111124631075-935857007.png&quot; alt=&quot;&quot; width=&quot;781&quot; height=&quot;235&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.    结论：&lt;/p&gt;
&lt;p&gt;　　从结果图可以看出，如果使用strlen进行获取数据的话只有12字节，使用返回值来定长度的话，确实1024字节，这个返回值才是正确的。因&lt;/p&gt;
&lt;p&gt;此，在网络编程中，&lt;span&gt;建议大家在发送二进制文件流或者在接收二进制文件流的时候，切记不要使用strlen进行定长，否则容易出错&lt;/span&gt;。但是如果发送的是字符串流的数据的话，这倒不是什么问题，但是为了系统安全和数据的准确性，使用返回值比strlen更加有优&lt;/p&gt;
&lt;p&gt;势。&lt;/p&gt;
</description>
<pubDate>Sat, 11 Nov 2017 04:53:00 +0000</pubDate>
<dc:creator>Psrion</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Older-Driver-of-Newer/p/7818781.html</dc:identifier>
</item>
<item>
<title>C#中结构体定义并转换字节数组 - dafanjoy</title>
<link>http://www.cnblogs.com/dafanjoy/p/7818126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dafanjoy/p/7818126.html</guid>
<description>&lt;p&gt;       最近的项目在做socket通信报文解析的时候，用到了结构体与字节数组的转换；由于客户端采用C++开发，服务端采用C#开发，所以双方必须保证各自定义结构体成员类型和长度一致才能保证报文解析的正确性，这一点非常重要。&lt;/p&gt;
&lt;p&gt;       首先是结构体定义，一些基本的数据类型，C#与C++都是可以匹配的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Head
    {&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ushort&lt;/span&gt; proMagic;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;包起始标记：固定0x7e7e&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ushort&lt;/span&gt; proPackLen;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;包长度：包头 + 数据区 + 包尾长度，注意不要超过最大长度限制&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;   proSrcAddr;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;源地址：不使用，填0&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ushort&lt;/span&gt; proSrcPort;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;源地址端口:不使用，填0&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;   proDstAddr;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;目的地址：不使用，填0&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ushort&lt;/span&gt; proDstPort;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;目的端口：不使用，填0&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ushort&lt;/span&gt; proCmdCode;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;命令码：参见以上命令码定义&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ushort&lt;/span&gt; proVersion;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;版本号：不使用，填1&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;   proSerial;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;报文序号：一条报文实例对应一个序号，不同报文叠加，0-255往复&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ushort&lt;/span&gt; proPackSum;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;总包数：当包长超过最大长度限制时，需要拆包，大包拆小包总数，不拆默认1&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ushort&lt;/span&gt; proPackId;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前包号：对应以上总包数的小包标识，不拆默认0&lt;/span&gt;
&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       一、首先是 [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 1)]，这是C#引用非托管的C/C++的DLL的一种定义定义结构体的方式，主要是为了内存中排序，LayoutKind有两个属性Sequential和Explicit，Sequential表示顺序存储，结构体内数据在内存中都是顺序存放的，CharSet=CharSet.Ansi表示编码方式。这都是为了使用非托管的指针准备的，这两点大家记住就可以。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       需要注意的是 Pack = 1 这个特性&lt;/strong&gt;，它代表了结构体的字节对齐方式，在实际开发中，C++开发环境开始默认是2字节对齐方式 ，拿上面报文包头结构体为例，char类型在虽然在内存中至占用一个字节，但在结构体转为字节数组时，系统会自动补齐两个字节，所以如果C#这面定义为Pack=1,C++默认为2字节对齐的话，双方结构体会出现长度不一致的情况，相互转换时必然会发生错位，所以需要大家都默认1字节对齐的方式，C#定义Pack=1,C++ 添加 #pragma pack 1，保证结构体中字节对齐方式一致。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       二、数组的定义，结构体中每个成员的长度都是需要明确的，因为内存需要根据这个分配空间，而C#结构体中数组是无法进行初始化的，这里我们需要在成员声明时进行定义；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 终端信息查询
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; PackTerminalSearch5001
    {
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst &lt;/span&gt;= &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 终端编号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; stationCode;

        [MarshalAs(UnmanagedType.ByValArray, SizeConst &lt;/span&gt;= &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 回复指令
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Byte[] order;
    }
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 终端信息数据
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;
    [StructLayoutAttribute(LayoutKind.Sequential, CharSet &lt;/span&gt;= CharSet.Ansi, Pack = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; PackTerminalSearch3004
    {
        [MarshalAs(UnmanagedType.ByValTStr, SizeConst &lt;/span&gt;= &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 终端编号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; stationCode;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 终端IP
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; terminalIP;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 终端端口
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ushort&lt;/span&gt;&lt;span&gt; terminalPort;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 中心IP
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; serverIP;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 测站端口
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;ushort&lt;/span&gt;&lt;span&gt; serverPort;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 磁盘信息数组
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        [MarshalAs(UnmanagedType.ByValArray, SizeConst = &lt;span&gt;8&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PackDiskInfo[] diskInfoArray;
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 磁盘信息
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    [StructLayoutAttribute(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; PackDiskInfo
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 盘符
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;&lt;span&gt; drive;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 总空间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; totalSize;
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 可用空间
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; usableSize;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        上面的代码需要注意的是string类型实际为Char[6]长度的数组，实际使用中只能有效的使用前5个字符，因为char[6]最后一位默认\0；&lt;/p&gt;
&lt;p&gt;        三、结构体与字节数组的互转&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63.5&quot;&gt;
&lt;pre&gt;
　　
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;        PackTerminalSearch5001 info;
        info.stationCode = &quot;12345&quot;&lt;span&gt;;
        info.order = new byte[6] { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05&lt;span&gt; };
        Byte[] recv =&lt;span&gt; StructToBytes(info);

        object obj = BytesToStuct(recv, typeof&lt;span&gt;(PackTerminalSearch5001));
        PackTerminalSearch5001 info5001 =&lt;span&gt; (PackTerminalSearch5001)obj;
        byte[] order =  info5001.order;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/ &lt;/span&gt;&lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 结构体转byte数组
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;structObj&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;要转换的结构体&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;转换后的byte数组&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] StructToBytes(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; structObj)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到结构体的大小&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; Marshal.SizeOf(structObj);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建byte数组&lt;/span&gt;
            &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[size];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分配结构体大小的内存空间&lt;/span&gt;
            IntPtr structPtr =&lt;span&gt; Marshal.AllocHGlobal(size);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将结构体拷到分配好的内存空间&lt;/span&gt;
            Marshal.StructureToPtr(structObj, structPtr, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从内存空间拷到byte数组&lt;/span&gt;
            Marshal.Copy(structPtr, bytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, size);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放内存空间&lt;/span&gt;
&lt;span&gt;            Marshal.FreeHGlobal(structPtr);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回byte数组&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; bytes;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; byte数组转结构体
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;bytes&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;byte数组&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;type&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;结构体类型&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;转换后的结构体&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; BytesToStuct(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] bytes, Type type)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到结构体的大小&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; Marshal.SizeOf(type);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;byte数组长度小于结构体的大小&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (size &amp;gt;&lt;span&gt; bytes.Length)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回空&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分配结构体大小的内存空间&lt;/span&gt;
            IntPtr structPtr =&lt;span&gt; Marshal.AllocHGlobal(size);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将byte数组拷到分配好的内存空间&lt;/span&gt;
            Marshal.Copy(bytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, structPtr, size);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将内存空间转换为目标结构体&lt;/span&gt;
            &lt;span&gt;object&lt;/span&gt; obj =&lt;span&gt; Marshal.PtrToStructure(structPtr, type);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放内存空间&lt;/span&gt;
&lt;span&gt;            Marshal.FreeHGlobal(structPtr);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回结构体&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
        }&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;


&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span/&gt;&lt;/em&gt;
&lt;/pre&gt;

</description>
<pubDate>Sat, 11 Nov 2017 04:42:00 +0000</pubDate>
<dc:creator>dafanjoy</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dafanjoy/p/7818126.html</dc:identifier>
</item>
<item>
<title>如何用代理平台解决微服务的一些痛点 - lvyahui</title>
<link>http://www.cnblogs.com/lvyahui/p/7818757.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvyahui/p/7818757.html</guid>
<description>&lt;h3 id=&quot;-&quot;&gt;为什么要做代理平台&lt;/h3&gt;
&lt;p&gt;微服务架构越来越流行，在一个上百号人开发的项目中，使用微服务的方式，大量模块之间通过接口调用，随之也带来了许多问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接口不能及时提供造成阻塞：往往客户端需要等待后台接口进入测试阶段，才能开始进行开发。一些刚入门的客户端开发（如web前端开发），并没有自行伪造接口数据的能力。&lt;/li&gt;
&lt;li&gt;通信数据格式混乱：json、xml、protobuf等各种方式都有，方式相同而数据结构又不统一，主调和被调方都需要自行封装和解析不同格式的数据&lt;/li&gt;
&lt;li&gt;日志未收敛汇集 ： 日志分散在各个模块，未跟请求链路绑定，异常发生时的故障现场不好还原&lt;/li&gt;
&lt;li&gt;各模块重复造轮子：各接口需要自己实现鉴权、限频、验证调用者等通用能力&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为解决上述问题，我们约定一套调用规范，并将所有调用收归一处进行代理中转。因此，需要实现一套高可用的代理平台。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;代理平台特性&lt;/h3&gt;
&lt;p&gt;先说一下几个角色&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第三方（服务） -- 接口提供方，被调方&lt;/li&gt;
&lt;li&gt;调用方（应用） -- 主调方 ，它可以是一个客户端如浏览器、手机APP，也可以是另一个接口提供方（第三方、服务）。&lt;/li&gt;
&lt;li&gt;代理平台 -- 请求转发平台。&lt;/li&gt;
&lt;li&gt;代理管理平台 -- 可视化配置及查询调用方、第三方、请求日志等数据，&lt;/li&gt;
&lt;li&gt;鉴权平台 -- 基于 cookie、token等方式的含登录、权限控制的用户中心&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代理平台主要有以下特性&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;松耦合、消除客户端开发等待。&lt;/h4&gt;
&lt;p&gt;代理平台除可以正常转发请求外，还可以伪装响应，即&lt;strong&gt;代理平台直接按预定规则随机生成响应给调用方，并不请求第三方&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;统一输入输出格式&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;严格控制输入格式、标准化输出结构。第三方可以不按结构响应，但是需要在代理管理平台定义转换规则&lt;/strong&gt;。如果很多事情按照约定来，可以少很多工作。这也是许多框架所倡导的约定优于配置。&lt;/p&gt;
&lt;h4 id=&quot;-cgi-&quot;&gt;规范CGI文档&lt;/h4&gt;
&lt;p&gt;通过统一的页面，统一录入接口说明、参数说明、响应头及字段说明等等。客户端开发甚至不需要跟后台开发沟通，即可完成开发任务。同时也提高接口的复用性。可以提供相应的注解和注释包，开发者在代码中引入注解或者注释，可以自动完成接口数据在平台上的录入、更新等操作。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;输入初步验证&lt;/h4&gt;
&lt;p&gt;在代理平台定义好入参规则，&lt;strong&gt;代理平台在收到请求时，统一对输入参数进行格式验证、必填验证等等&lt;/strong&gt;。对恶意输入请求进行拦截并记录。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;频率控制&lt;/h4&gt;
&lt;p&gt;代理平台对每个接口提供基于分钟频次或者超频验证码的调用频率控制能力&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;接口性能统计&lt;/h4&gt;
&lt;p&gt;统计从平台向第三方发起请求，到平台完全收到第三方的响应的时间，做为第三方接口的性能。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;请求日志&lt;/h4&gt;
&lt;p&gt;目标请求接口，来源ip、请求报文、响应报文、成功状态、耗时、所属的调用树等等整个请求完整的上下文数据，都记录在案。&lt;strong&gt;并且，请求到达接口提供方之后，如果第三方处理出现异常，可以将异常日志反向上报到代理平台，由代理平台来关联这次请求的日志&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;还原调用树（调用链路）&lt;/h4&gt;
&lt;p&gt;一个调用方请求到达第三方后，有可能级联发起更多的请求。如果这些请求全部经过代理平台。那么代理平台可以记录链路数据，后续在代理管理平台上&lt;strong&gt;可视化的还原、呈现整个调用链路，清楚标识每个被调节点的耗时、是否成功等数据&lt;/strong&gt;，有助于排查故障、性能瓶颈等问题&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;统一鉴权&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;登录态检查和接口权限控制可以全部收归代理平台&lt;/strong&gt;。如果请求转发到了第三方接口，说明用户已登录并对此接口有权限，第三方开发者只需要从头部取封装好的userkey，到统一鉴权中心换取用户信息即可.&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;协议头规范化及过滤&lt;/h4&gt;
&lt;p&gt;为防止后台响应一些不规范的头，或者一些危险的头进行过滤。并且平台可以统一处理OPTIONS请求，将预定的协商头响应给客户端，可以灵活配置跨域需求。&lt;/p&gt;
&lt;h4 id=&quot;-ip-&quot;&gt;来源IP过滤&lt;/h4&gt;
&lt;p&gt;对接口可以提供IP白名单或者黑名单的功能，合法来源ip的请求才能被转发到后台&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;多协议支持&lt;/h4&gt;
&lt;p&gt;需要能够支持多种接口协议，如HTTP、FTP、SMTP等等应用层协议，也需要能直接支持TCP长连接、UDP数据报等协议。并能做到部分协议转换，&lt;strong&gt;调用方无感知的使用跟第三方接口不同的协议通信&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;关联测试用例&lt;/h4&gt;
&lt;p&gt;每个接口可以集成测试用例，类似于Advance REST Client或PostMan，&lt;strong&gt;定时以用例对接口进行输入输出调用测试&lt;/strong&gt;。这可能需要接口提供方提供专门的测试接口。&lt;/p&gt;
&lt;h4 id=&quot;-server-&quot;&gt;服务存活检查，多server时提供负载均衡&lt;/h4&gt;
&lt;p&gt;第三方可以提供部署服务的多个server ip，由&lt;strong&gt;代理管理平台来进行存活检查&lt;/strong&gt;，但server不可用时从缓存中踢掉此server，&lt;strong&gt;代理平台对多个server ip实现负载均衡&lt;/strong&gt;。server故障时向真实接口方发出告警。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;对第三方接口压测&lt;/h4&gt;
&lt;p&gt;代理平台本身需要具备较强的并发能力。但更重要的是接口本身支持高吞吐量访问。代理平台可以对第三方接口进行压测，以推进第三方优化接口性能及并发能力。&lt;/p&gt;
&lt;h3 id=&quot;-&quot;&gt;实现方式&lt;/h3&gt;
&lt;h4 id=&quot;nginx-lua-confd-etcd&quot;&gt;nginx+lua+confd + etcd&lt;/h4&gt;
&lt;p&gt;confd + etcd 用来实现实时动态更新nginx配置，当有接口新增或修改时，动态生成server或者location配置。nginx来实现请求转发。lua脚本来实现一些诸如日志上报、鉴权检查、协议头检查等等逻辑。&lt;br/&gt;这种方式在接口量较小时是个不错的选择。但是&lt;strong&gt;当接口数量达到成千上万的级别后，动态生成的nginx配置会非常大，不利于问题排查，且容易生成冲突、错误的nginx配置&lt;/strong&gt;，致使nginx进程异常。并且上面提到的一些复杂的目标，如还原调用链路、输入参数验证、关联测试用例等，此方式也很难实现。&lt;/p&gt;
&lt;h4 id=&quot;camel&quot;&gt;camel&lt;/h4&gt;
&lt;p&gt;apache camel是一个协议转换的框架，可以很方便实现协议转换、请求路由转发。下面是代理平台及代理管理平台的架构及请求处理过程示意。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/635249/201711/635249-20171111123919169-2022735260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;/p&gt;
&lt;p&gt;clinet 即为调用方，使用平台提供的各种语言（js、c、java、php、python等）的sdk，可以对调用方无感知的包装一些验证、标识头部。这也是还原调用链路的基础。如果不使用sdk，同样可以向代理平台发起请求。SDK主要做提供两个功能：1、透传标识头、来源路径头信息等等。2、向代理管理平台上报此次请求处理出现的异常日志。&lt;/p&gt;
&lt;p&gt;cgi_proxy 即是基于camel开发的代理平台。主要实现验证请求合法性（appkey）、登录态验证与权限控制、协议转换、参数验证、请求转发、头部特殊字段处理、格式化响应、请求日志记录等等。日志由异步线程写入到消息队列。转发请求需要的数据从redis中获取，redis中存储了接口提供方真实接口地址、参数规则、合法appkey等信息。&lt;strong&gt;因为在client看来，请求的处理时间是平台处理时间+真实接口处理时间，只有平台处理足够快，才能减少性能损失，所以cgi_proxy 不从任何接口查询数据，也不直接操作db，只从redis查询数据，这样可以很好的减少性能损失&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;log_coll收集消息队列中的请求日志落地存储，并按时对全平台接口调用情况进行统计，生成运营数据。当每日的调用量达到百万、千万级别时，比db分表更好的手段是由此进程定时迁移旧的数据。&lt;/p&gt;
&lt;p&gt;manager 即代理管理平台。定义一套接口模型，将各种后台接口按模型规范并存储至db。将核心的数据缓存到redis。在页面实现可视的接口编辑、日志查询等能力&lt;/p&gt;
</description>
<pubDate>Sat, 11 Nov 2017 04:42:00 +0000</pubDate>
<dc:creator>lvyahui</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvyahui/p/7818757.html</dc:identifier>
</item>
<item>
<title>OpenCASCADE BRepMesh - 2D Delaunay Triangulation - opencascade</title>
<link>http://www.cnblogs.com/opencascade/p/OpenCASCADE_BRepMesh.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/opencascade/p/OpenCASCADE_BRepMesh.html</guid>
<description>&lt;h2&gt;OpenCASCADE BRepMesh - 2D Delaunay Triangulation&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;mailto:eryar@163.com&quot;&gt;eryar@163.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Abstract.&lt;/strong&gt; OpenCASCADE package BRepMesh can compute the Delaunay’s triangulation with the algorithm of Watson. It can be used for 2d plane or on surface by meshing in UV parametric space. The blog focus on the usage of the triangulation tool to triangulate 2d points.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key Words.&lt;/strong&gt; BRepMesh, Delaunay Triangulation, &lt;/p&gt;
&lt;h3&gt;1.Introduction&lt;/h3&gt;
&lt;p&gt;点集的三角剖分Triangulation主要用于几何数据的可视化，在所有的造型内核中都有三角剖分的功能，用来生成模型的网格数据交给图形接口，如OpenGL等来显示。OpenCASCADE中使用类BRepMesh_IncrementalMesh来将TopoDS_Shape进行三角剖分得到显示数据。其原理根据其名字可以这样解释，使用了增量算法，不停的剖分直到结果的三角形满足精度要求。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.opencascade.com/content/brepmeshincremental-mesh-algorithm&quot;&gt;https://www.opencascade.com/content/brepmeshincremental-mesh-algorithm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OpenCASCADE的BRepMesh只能用于二维点集的三角剖分，所以对于任意曲面的三角剖分，可以对其参数空间UV使用增量算法进行剖分，直到最终的三角剖分满足显示精度要求，最后将参数空间UV映射回实际的三维模型空间。所以三角剖分的关键就成了寻找合理的剖分点，在尽量少的剖分点情况下，使剖分满足显示精度要求。&lt;/p&gt;
&lt;p&gt;本文主要介绍如何使用OpenCASCADE中BRepMesh来对二维点集进行三角剖分，最后将剖分结果在Draw Test Harness中进行可视化，便于实时查看剖分结果。&lt;/p&gt;
&lt;h3&gt;2.Code Example&lt;/h3&gt;
&lt;p&gt;使用BRepMesh直接对二维点集进行三角剖分，代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
Copyright(C) 2017 Shing Liu(eryar@163.com)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files(the &quot;Software&quot;), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and / or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions :

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

#include &lt;/span&gt;&amp;lt;math_BullardGenerator.hxx&amp;gt;&lt;span&gt;

#include &lt;/span&gt;&amp;lt;BRepMesh.hxx&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;BRepMesh_Delaun.hxx&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;BRepMesh_DataStructureOfDelaun.hxx&amp;gt;

&lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;TKernel.lib&quot;)
&lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;TKMath.lib&quot;)

&lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;TKG2d.lib&quot;)
&lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;TKG3d.lib&quot;)
&lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;TKGeomBase.lib&quot;)
&lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;TKGeomAlgo.lib&quot;)

&lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;TKBRep.lib&quot;)
&lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;TKTopAlgo.lib&quot;)
&lt;span&gt;#pragma&lt;/span&gt; comment(lib, &quot;TKMesh.lib&quot;)

&lt;span&gt;void&lt;/span&gt;&lt;span&gt; testMesh(Standard_Integer thePointCount)
{
    std::ofstream aTclFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;d:/mesh.tcl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    math_BullardGenerator aRandom;

    BRepMesh::Array1OfVertexOfDelaun aVertices(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, thePointCount);

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Standard_Integer i = aVertices.Lower(); i &amp;lt;= aVertices.Upper(); ++&lt;span&gt;i)
    {
        gp_XY aPoint;
        aPoint.SetX(aRandom.NextReal() &lt;/span&gt;*&lt;span&gt; aVertices.Upper());
        aPoint.SetY(aRandom.NextReal() &lt;/span&gt;*&lt;span&gt; aVertices.Upper());

        BRepMesh_Vertex aVertex(aPoint, i, BRepMesh_Frontier);

        aVertices.SetValue(i, aVertex);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; output point to Draw Test Harness.&lt;/span&gt;
        aTclFile &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vpoint p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aPoint.X() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aPoint.Y() &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; std::endl;
    }

    BRepMesh_Delaun aDelaunay(aVertices);
    Handle(BRepMesh_DataStructureOfDelaun) aMeshStructure &lt;/span&gt;=&lt;span&gt; aDelaunay.Result();

    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; BRepMesh::MapOfInteger&amp;amp; aTriangles = aMeshStructure-&amp;gt;&lt;span&gt;ElementsOfDomain();
    BRepMesh::MapOfInteger::Iterator aTriangleIt(aTriangles);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (aTriangleIt; aTriangleIt.More(); aTriangleIt.Next())
    {
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; Standard_Integer aTriangleId =&lt;span&gt; aTriangleIt.Key();
        &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; BRepMesh_Triangle&amp;amp; aCurrentTriangle = aMeshStructure-&amp;gt;&lt;span&gt;GetElement(aTriangleId);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (aCurrentTriangle.Movability() ==&lt;span&gt; BRepMesh_Deleted)
        {
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }

        Standard_Integer aTriangleVerts[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
        aMeshStructure&lt;/span&gt;-&amp;gt;&lt;span&gt;ElementNodes(aCurrentTriangle, aTriangleVerts);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; output line to Draw Test Harness.&lt;/span&gt;
        aTclFile &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vline l&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aTriangleId &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1 p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aTriangleVerts[&lt;span&gt;0&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aTriangleVerts[&lt;span&gt;1&lt;/span&gt;] &amp;lt;&amp;lt;&lt;span&gt; std::endl;
        aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vline l&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aTriangleId &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2 p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aTriangleVerts[&lt;span&gt;1&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aTriangleVerts[&lt;span&gt;2&lt;/span&gt;] &amp;lt;&amp;lt;&lt;span&gt; std::endl;
        aTclFile &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vline l&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aTriangleId &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3 p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aTriangleVerts[&lt;span&gt;2&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; p&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; aTriangleVerts[&lt;span&gt;0&lt;/span&gt;] &amp;lt;&amp;lt;&lt;span&gt; std::endl;
    }

    aTclFile.close();
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    testMesh(&lt;/span&gt;&lt;span&gt;500&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;程序使用随机数据生成的点集进行三角剖分并将三角剖分结果输出到D盘mesh.tcl文件，在Draw Test Harness中导入mesh.tcl即可看到剖分结果，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/534255/201711/534255-20171111124420700-1849342149.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/534255/201711/534255-20171111124430278-772012208.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.Conclusion&lt;/h3&gt;
&lt;p&gt;BRepMesh可以对二维点集进行三角剖分，使用简单，只需要将点集传入类BRepMesh_Delaun即可。&lt;/p&gt;
&lt;p&gt;将三角剖分结果生成Draw Test Harness脚本的方法，可以用来方便地将剖分结果可视化。自己开发程序的时候也可采用这个方法将造型的模型数据在Draw Test Harness中显示。&lt;/p&gt;
&lt;p&gt;如果三角剖分的点集中有孔需要去除，OpenCASCADE应该也提供了这个功能，有待发掘。&lt;/p&gt;
</description>
<pubDate>Sat, 11 Nov 2017 04:42:00 +0000</pubDate>
<dc:creator>opencascade</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/opencascade/p/OpenCASCADE_BRepMesh.html</dc:identifier>
</item>
</channel>
</rss>