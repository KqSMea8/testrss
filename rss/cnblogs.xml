<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C++反汇编第二讲,不同作用域下的构造和析构的识别 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/7990797.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/7990797.html</guid>
<description>&lt;p&gt;目录大纲:&lt;/p&gt;
&lt;p&gt;　　1.全局(静态)对象的识别,(全局静态全局一样的,都是编译期间检查,所以当做全局对象看即可.)&lt;/p&gt;
&lt;p&gt;　　　　1.1 探究本质,理解构造和析构的生成,以及调用方式(重要,如果不想知道,可以看总结.)&lt;/p&gt;
&lt;p&gt;　　2.对象做函数参数的识别　&lt;/p&gt;
&lt;p&gt;　　3.返回值为对象的识别&lt;/p&gt;
&lt;p&gt;　　4.对象为静态局部的识别&lt;/p&gt;
&lt;p&gt;　　5.堆中对象识别&lt;/p&gt;
&lt;p&gt;　　　　  5.1. malloc和new的区别,free 和delete的区别&lt;/p&gt;
&lt;p&gt;　　6.对象数组&lt;/p&gt;
&lt;p&gt; 　　　　6.1, delete对象和 delete[] 对象数组的区别 &lt;/p&gt;

&lt;p&gt;　　对于全局对象,以及全局变量等等.这些初始化,都是在ininterm中初始化的,和全局变量初始化的位置一样,如果不太懂,请看.以前博客链接:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/iBinary/p/7912427.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/iBinary/p/7912427.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;建立高级代码,查看其调用栈.(最后会总结)&lt;/p&gt;
&lt;p&gt;高级代码:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyTest
{
    MyTest();
    &lt;/span&gt;~&lt;span&gt;MyTest();

};

MyTest::MyTest()
{
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;111\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

MyTest::&lt;/span&gt;~&lt;span&gt;MyTest()
{
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;222\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

}
MyTest test();              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建对象在全局&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看调用栈回朔:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206011832488-1822721957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调用栈的顺序依次是&lt;/p&gt;
&lt;p&gt;　　initterm  -&amp;gt; E4(代理) - &amp;gt; E1(代理)  ,熟悉完探究原理和本质的时候再来讲解E4 和E1代理是干啥用的.&lt;/p&gt;
&lt;h2&gt;1.1探究原理,追求本质.构造和析构的生成,构造的调用和析构的调用&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;1.熟悉 ininterm原理&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们以前讲过 ininterm函数里面的原理和本质(不熟悉看下方图)它会根据函数的起始和结束地址,循环遍历并且调用同一接口的函数进行初始化动作.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206012226066-802705885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么现在E4代理函数就是统一接口的,也就是说, ininterm函数循环的函数指针调用,都是调用E4代理函数&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.熟悉构造函数何时调用,E1代理, E3代理函数.&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;现在我们知道了ininterm函数为了统一接口,所以弄出来了一个&lt;strong&gt;E4代理函数,为了统一接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;E4代理函数内部:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么E4代理里面做了什么事情.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206012638191-1593152050.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出,E4代理里面调用了E1代理和E3代理&lt;/p&gt;
&lt;p&gt;关于E1代理,我们知道,它是为了统一参数而生成的一个代理,其内部调用我们的真正代码,(也就是构造函数)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;E1函数代理内部&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206012819831-1327305859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;E3代理,E3代理稍后讲解,我们要知道E3是干什么用的要先知道一个C库函数的作用.&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.E3代理内部,以及C库函数作用&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　C库函数,&lt;span&gt;atexit &lt;/span&gt; 注册函数回调,main函数结尾的时候进行收尾动作(也就是释放资源的动作)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个C库函数在C语言时代就是释放资源的.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;看下MSDN声明.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206013515363-1437277451.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注册一个C约定的函数回调即可.看下程序例子:&lt;/p&gt;
&lt;p&gt;　　高级代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Abc()
{
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1234\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    atexit(Abc);　　　　　　　　　　//注册 C约定函数指针,当main函数结束的时候操作系统调用这个函数.
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行程序结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206013735363-1092130963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正文:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　atexit可以注册多个回调,而这些会是一个线性表,里面储存了你注册的函数地址.当main函数结束的时候会调用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206013942847-1066156199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而内部&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206014002753-567592695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;do exit函数内部会执行核心代码:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206014039441-168502039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码含义,一开始没有注册的时候, 线性表的头和尾都是一样的位置&lt;/p&gt;
&lt;p&gt;当你注册了那么线性表则会增加4个字节存储你注册的函数回调地址.&lt;/p&gt;
&lt;p&gt;可以看出上面代码逻辑&lt;/p&gt;
&lt;p&gt;　　从后往前调用,执行函数指针, 而这个函数则是你注册的函数回调.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;E3代理含义:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　明白其上面的 atexit函数的原理,那么现在看看其E3内部的实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206014415441-1453865644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;E3内部其实是将E2函数注册进了atexit函数,当结束的时候则会调用E2&lt;/p&gt;
&lt;p&gt;那么现在看看E2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;E2函数内部:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206014531550-432959564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;E2函数内部则会调用析构函数,有人会说,为什么不直接将析构注册为函数回调,这样直接调用atexit不就在释放的时候,从后往前依次调用析构的了吗.&lt;/p&gt;
&lt;p&gt;答:&lt;/p&gt;
&lt;p&gt;　　因为atexit的参数的c约定回调,而析构是thiscall,调用约定,所以内部必须包含一层才可以.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　当为全局对象的时候&lt;/p&gt;
&lt;p&gt;　　1.会在ininterm里面进行初始化动作&lt;/p&gt;
&lt;p&gt;　　2.会产生代理函数,这个代理函数是为了使ininterm函数的代码正常初始化而产生的一个统一接口的函数,暂且称为E4 (名字可能不一样)&lt;/p&gt;
&lt;p&gt;　　3.E4函数代理是为了统一接口,其内部又调用了 构造函数代理 (E1),和析构函数代理(E3)&lt;/p&gt;
&lt;p&gt;　　4.E1代理函数是为了统一参数用的,其内部是调用构造的,如果是有参数构造,则在E1代理函数内部可以看到传参的.&lt;/p&gt;
&lt;p&gt;　　5.E3代理函数是为了注册析构函数的,为了使atexit函数正常运行而注册的(atexit和ininterm类似,一个从前往后,一个从后往前)&lt;/p&gt;
&lt;p&gt;　　6.E2是E3内部给atexit函数注册的回调,这样在析构的时候则调用E2即可.&lt;/p&gt;
&lt;p&gt;　　7.E2函数内部是真正的调用析构的.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用流程图:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206015914144-488578616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实战中反汇编查找全局对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然我们知道了atexit函数会调用析构,那么我们在IDA中搜索atexit函数,看看谁引用了它,则可以把全局对象一网打尽.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206020254738-268480129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206020937113-743525179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 二丶对象作为函数参数的识别&lt;/h2&gt;
&lt;p&gt;高级代码:&lt;/p&gt;
&lt;p&gt;　　PS: 为了节省篇幅,类的定义不在重复截图,重复定义了.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; foo(MyTest test)
{
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;333\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyTest t;                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义对象&lt;/span&gt;
    foo(t);                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对象当做参数传递&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Debug下的汇编:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206021711800-693784911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显的特征&lt;/p&gt;
&lt;p&gt;　　1.函数调用前会调用一次构造&lt;/p&gt;
&lt;p&gt;　　2.调用函数&lt;/p&gt;
&lt;p&gt;　　3.函数结束之前调用析构. (foo函数内部,为了节省篇幅,和Release)&lt;/p&gt;
&lt;p&gt;　　4.函数结束之后继续调用构造&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Release版本汇编:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206022152128-1053676463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面包含了 1 2 4步,其中第三步是在 foo函数内部调用的析构&lt;/p&gt;
&lt;p&gt;foo 函数内部&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206022234659-117952238.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;内部会有个Jmp来调用析构&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结: &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;当函数参数为对象的时候.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1.会先在函数外部进行构造一次&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.调用函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3.函数内部调用一次析构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4.函数结束之后的外面调用一次析构函数.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;PS: 注意,局部对象和传参的区别,局部对象会在函数内部进行调用构造,而传参的时候是在函数外面进行的初始化动作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt; 三丶返回值为对象的识别&lt;/h2&gt;
&lt;p&gt;当返回值为对象的时候,会有两种情况&lt;/p&gt;
&lt;p&gt;1.定义的时候产生拷贝动作&lt;/p&gt;
&lt;p&gt;2.使用的时候产生临时对象&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;p&gt;　　MyTest t = Getobj(); 定义t的同时,接受Getobj返回的对象,则会产生拷贝构造&lt;/p&gt;
&lt;p&gt;　　t = Getobj():　　　　定义完obj然后使用t接受Getobj()则会产生临时对象.不产生拷贝构造&lt;/p&gt;
&lt;p&gt;以上都是C++语言,不熟悉的同学复习一下构造析构以及拷贝构造的内容即可.&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1.拷贝动作的时候其返回对象的识别.&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　高级代码:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MyTest Getobj()
{
    MyTest obj;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyTest t &lt;/span&gt;=&lt;span&gt; Getobj();          //定义同时,接受返回对象         
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Debug下的汇编代码:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206023704300-1431076208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.调用的时候,当做参数传递给Getobj&lt;/p&gt;
&lt;p&gt;3.函数结束之后调用析构&lt;/p&gt;
&lt;p&gt;2.函数内部调用构造和析构&lt;/p&gt;
&lt;p&gt;(其中2在Getobj里面,看Release版本)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Release下的汇编&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206024109159-76687601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是第一步和第三步&lt;/p&gt;
&lt;p&gt;第二步函数内部:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206024159878-2105069645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其内部调用构造和析构&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　1.this指针会当做参数传递给函数, Mytest t = Getobj() t会当做参数传递&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.其函数内部开始的时候会调用构造函数,结束之前调用析构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　3.函数结束之后,外部会调用析构函数.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; PS: 当代吗为引用的时候,其作用域跟着引用走  Mytest &amp;amp;t = Getobj();&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.使用的时候产生临时对象的情况下&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;高级代码:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MyTest Getobj()
{
    MyTest obj;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyTest t ;
    t &lt;/span&gt;= Getobj();      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义完毕之后使用             &lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Debug下的汇编&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206031144784-1470831627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.  T变量进行构造&lt;/p&gt;
&lt;p&gt;2.产生临时对象,调用GetObj, 其中Getobj内部会构造和析构,然后返回临时一般来那个&lt;/p&gt;
&lt;p&gt;3.返回的临时变量给栈变量保存,然后 mov edx,[ecx] 给edx赋值&lt;/p&gt;
&lt;p&gt;4.临时变量拷贝给t&lt;/p&gt;
&lt;p&gt;5.临时变量析构&lt;/p&gt;
&lt;p&gt;6.main结束前局部变量析构&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Release下的汇编&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206031452488-1945311959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Release汇编和Debug一样,减少了变量,进行了优化.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;span&gt;　使用时获得对象则产生临时对象&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　1.局部对象进行构造&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2.调用函数的时候产生临时对象,其内部产生构造和析构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　3.返回的时候返回值给使用的对象赋值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　4.临时对象析构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　5.main结束时局部对象析构.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;MyTest Getobj()
{
    MyTest obj;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    MyTest &lt;/span&gt;*&lt;span&gt;t ;
    t &lt;/span&gt;= &amp;amp;Getobj();      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义完毕之后使用       &lt;/span&gt;
    t-&amp;gt;m_dwNumber = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;




&lt;p&gt;&lt;strong&gt;Debug下反汇编&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206032805331-1864911651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们会发现&lt;/p&gt;
&lt;p&gt;返回的临时对象会给t保存&lt;/p&gt;
&lt;p&gt;但是紧接着析构了,但是此时指针调用了临时对象里面的成员,并且给它赋值了.所以以后写代码要注意,这种错误编译器检测不出来.虽然支持这个语法.但是肯定会出错,而且是莫名其妙的错误&lt;/p&gt;

&lt;h2&gt; 四丶对象为静态局部的识别&lt;/h2&gt;
&lt;p&gt;　　高级代码:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;*&lt;span&gt; argv[])
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt;&lt;span&gt; MyTest t ;
    
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Debug下的汇编&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206034513488-1590019612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;会生成一个检查标志,根据这个标志判断,是否调用构造和析构&lt;/p&gt;
&lt;p&gt;会跳过一个 构造和注册析构的一块区域&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　生成检查标志,跳过构造和注册析构代理.&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;五.堆中对象识别&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;高级代码:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
MyTest *t = &lt;span&gt;new&lt;/span&gt; MyTest ;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Debug下的汇编:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206034949206-1823067351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;new 和malloc是一样的,new是对malloc的一个封装. 只会申请空间,&lt;strong&gt;但是&lt;/strong&gt;会产生额外的代码,中间会判断标志,申请成功的返回值为0或者为1,如果为0则不构造,如果为1则构造&lt;/p&gt;
&lt;p&gt;但是注意:这里的额外代码只是判断是否进行构造,你自己也要进行判断.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Delete语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Delete语法会调用析构,也会生成额外语法.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206035541441-1933346216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 当Delete的时候会传入1, 这个是按位来的, 如果最低位为1,则是代表释放内存,那么就调用析构并且释放,如果为0,则仅仅代表了调用析构.&lt;/p&gt;
&lt;p&gt;为什么会这样:&lt;/p&gt;
&lt;p&gt;　　在早期,硬件资源匮乏,内存想重复利用.&lt;/p&gt;
&lt;p&gt;所以会有人显示的调用构造(vc6.0中可以)然后显示的调用析构进行管理,示例:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206035834925-2090171764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加上类域则可以调用构造了,那么析构我们是显示调用,所以看看汇编代码,会传入0,不会释放内存的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1197364/201712/1197364-20171206035944472-785314979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.new 和malloc 一样,new是对malloc的一个封装,但是会产生额外代码,用来判断是否进行构造&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　2.delete的时候,会传入0 和1来判断是否是 调用析构并释放内存(1) ,或者 只调用析构(0)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;时间关系,明天继续补充. 剩下了对象数组,可以提前看一下.&lt;/p&gt;

</description>
<pubDate>Tue, 05 Dec 2017 20:03:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/7990797.html</dc:identifier>
</item>
<item>
<title>【趣味连载】攻城狮上传视频与普通人上传视频：序 - iOS122</title>
<link>http://www.cnblogs.com/ios122/p/7990307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ios122/p/7990307.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;我想写一个简单的系列文章。主题很简单，就是记录下面对上传视频需求时，攻城狮和普通人(泛指所有非技术人员)的一些区别。当然，从需求分析到最终完整实现，每个步骤都是有干货。我会尽量避免一些偏情绪化的表述。更多的时候，我们应该把注意力集中在各个需求点本身的技术实现上。&lt;/p&gt;
&lt;p&gt;这个系列的主要目的，就是秀一下我们作为攻城狮的优越感；不过，我总觉得我们秀完，他们可能也不知道究竟发生了什么事。另外，更重要的是，这个系列文章展示了从需求分析到技术选项，一直到最终的自动化上传，自动化测试的完整思考核实践的过程。我觉得，对于攻城狮来说，后者可能是我们更需要交流和关注的。&lt;/p&gt;
&lt;p&gt;我会适当替换一些敏感的代码细节。即使如此，我仍然努力会保证，经过适当配置后，所有代码都是可以正常运行的。&lt;/p&gt;
&lt;h2 id=&quot;背景简介&quot;&gt;背景简介&lt;/h2&gt;
&lt;p&gt;大概是上周一左右吧，临时被安排去给一个内部项目新上传大约 100 个新的视频资源。要的还很急，说是周三就要做好。好吧，当时我就知道，那一周肯定会过的很“酸爽”。因为那个项目可以认为是没有管理后台的，数据是要直接上传到数据库。意思就是我要手动编辑视频相关的资料数据。还有就是，我拿到的第一手数据，也不是什么结构化数据，而是一个 word 表格，和一个分散在多个文件夹下的视频资源。&lt;/p&gt;
&lt;p&gt;更“可怕”的是，我同时还被指派成了这个项目的 ”Owner“。“Owner”，就意味着，我绝不能像他们上次那样，继续手动传视频了。成本太高，而且数据容易混乱。上一次，我只是作为一个协作者，写了几行项目相关的代码，帮他们简单设计了一个数据库表，也没想太多，够用就性。毕竟当时时间也非常紧，许多东西也是没办法尽善尽美的。&lt;/p&gt;
&lt;p&gt;原来只有约20个视频，都是交给“普通人”上传的。流程大概就是：视频拷贝给普通人 --&amp;gt; 普通人上传完视频 --&amp;gt; 邮件发出来视频url和视频标题 --&amp;gt; 我手动把数据录进数据库。中间，往返沟通了几次，比如视频尺寸不对了，视频不能播放了，标题和视频不对应了。。。真正的往返沟通，要比多很多，但是视频数量少，总体来看倒也无伤大雅。&lt;/p&gt;
&lt;p&gt;但是这次是大概100个视频。就算是只录入数据，差不多也得1个小时了，如果再手一抖，录错了。。。更可怕的是，我成了项目的 Owner，以后这种事，都得我直接处理。跨部门沟通，真的成本很高，或者说我太懒了吧，懒得一遍遍去别人工位催人家。所以，我就暗暗发誓，这件事必须彻底解决。这次我要把包括视频相关的数据，从生成到上传，到自动化验证，完全自动化，智能化。虽然这100个视频，时间上不会有太多变化，但是以后，再多的视频，最多也就是输入几行命令，敲几下键盘，就可以自动搞定了。如此，这个Owner，才能做的舒心。当然，它是一个很小的内部项目，我也是真的不想再让它以后占用我太多时间了。&lt;/p&gt;
&lt;h2 id=&quot;更新规划&quot;&gt;更新规划&lt;/h2&gt;
&lt;p&gt;如果没有意外的话，本周三到周五晚上，每天一更；周末会适当多写点。&lt;/p&gt;
&lt;h3 id=&quot;一生成结构化数据&quot;&gt;（一）生成结构化数据&lt;/h3&gt;
&lt;p&gt;讲述的是，数据如何从普通的 word 文档数据，变成最终可被程序化处理的过程。是的，你没看错，大部人“普通人”是用 Word 来传递数据的。好处就是人人都能看的懂；但是人人都能看懂的东西，攻城狮反倒没法直接用。&lt;/p&gt;
&lt;h3 id=&quot;二批量验证语义分析功能&quot;&gt;（二）批量验证语义分析功能&lt;/h3&gt;
&lt;p&gt;项目对接了微软拿到 Luis 语义识别系统。原来是手动逐条验证每个问题和答案是否能匹配上。现在，必须写个简单的脚本来自动化验证了。&lt;/p&gt;
&lt;h3 id=&quot;三批量导入数据&quot;&gt;（三）批量导入数据&lt;/h3&gt;
&lt;p&gt;就是如何把数据处理成数据库需要的格式，自动导入数据库。因为是内部项目，项目本身没有提供数据编辑功能，所以我就采用最简单的策略，每次数据有变化时，就全部删除旧数据，重新批量导入新数据。新数据，肯定是从原始数据，自动生成的。手动输入，真的很容易出问题。&lt;/p&gt;
&lt;h3 id=&quot;四批量导入视频&quot;&gt;（四）批量导入视频&lt;/h3&gt;
&lt;p&gt;就是如何把视频批量自动上传到七牛服务器。肯定是一个自动化脚本，可能大家都会写。但是，小技巧往往解决大问题！晚上睡了一觉，第二天起来看到所有视频都上传完了，真的是很开心的事。&lt;/p&gt;
&lt;h3 id=&quot;五批量验证视频上传是否成功&quot;&gt;（五）批量验证视频上传是否成功&lt;/h3&gt;
&lt;p&gt;视频是否上传成功，肯定需要单独验证的。只是上传脚本不能说明一定都上传成功了，需要单独验证下。&lt;/p&gt;
&lt;h3 id=&quot;六验证视频能否真正播放&quot;&gt;（六）验证视频能否真正播放&lt;/h3&gt;
&lt;p&gt;这一步很关键。项目主要在 iPad 上用，所以需要验证每个视频在 iPad 上能否自动播放。iPad 上，用 HTML5 Video 播放视频时，对视频格式有一些要求，所以每个视频都要验证下。原来，就那几个，手动点下就行了。现在，肯定不能再那样了。于是写了一个简答的测试网页，通过捕捉 Video 的一些事件，来实现自动化批量验证视频能否真正播放。&lt;/p&gt;
</description>
<pubDate>Tue, 05 Dec 2017 16:51:00 +0000</pubDate>
<dc:creator>iOS122</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ios122/p/7990307.html</dc:identifier>
</item>
<item>
<title>mysql安装后服务启动不了（总结） - 炭烧小鸡</title>
<link>http://www.cnblogs.com/tanshaoxiaoji/p/mysql_open_services.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tanshaoxiaoji/p/mysql_open_services.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;mysql安装后服务启动不了&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1.1 前言&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;最近真的是倒霉到家，装个mysql都能把所有的问题给问候了一遍······不过这也是一个宝贵的经验，得好好总结下，毕竟也不知道以后会不会再次遇到。如果有网友也能像我这样倒霉，但是能够幸运地看到我这个文章，并且真正解决问题，那我就欣慰了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.2 我的倒霉过程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;公司的新电脑到了，由于个人原因，我想在本机装个mysql，方便自己工作。我知道安装mysql是有两种方式的，一种是msi安装包自动安装，一种是zip包解压后配置相关文件进行安装。刚开始我想都没想就选择了msi自动安装，结果各种报错，直接不能安装成功，各种查找资料还是没有解决，没办法下只能够下载zip包进行解压配置安装，一顿折腾下把mysql安装好了，刚想放下心头，结果发现mysql服务启动不了，然后一顿折腾后，服务启动了，冷不丁又来个连接不上数据库的问题，真是***碎蛋啊！又是各种资料查阅，终于把所有问题都搞定了，数据库访问成功！！！这么奇葩的连环套我都能遇上我也是醉了，因此我得把主要问题的解决过程尽量详细的记录下来，如果写的不好大家别骂，我的水平只能这样了，以后我回过头来也能知道自己以前是有多水，才知道自己进步程度，或者说是成就感。废话不多说，进入正题。&lt;span&gt;（PS：如果安装过程遇到问题，可参考：&lt;a title=&quot;mysql安装&quot; href=&quot;http://www.cnblogs.com/tanshaoxiaoji/p/mysql_install_type.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/tanshaoxiaoji/p/mysql_install_type.html&lt;/a&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.3 进入正题，&lt;/strong&gt;服务启动&lt;/span&gt;解决方案&lt;/p&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li&gt;&lt;span&gt;在mysql的安装目录即根目录下找到配置文件my.ini（如果是my.default.ini则修改为my.ini），然后将my.ini移至bin文件夹的根目录下；&lt;/span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1258453/201712/1258453-20171205234553409-1689227472.png&quot; alt=&quot;&quot; width=&quot;646&quot; height=&quot;213&quot;/&gt; &lt;/li&gt;
&lt;li&gt;&lt;span&gt;Windows+R，输入cmd进入命令行模式，输入命令&lt;span&gt;cd D:\MySQL\mysql-5.7.19-winx64\bin&lt;/span&gt;进入mysql 的 bin根目录；&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;（注意：&lt;span&gt;如果这条命令不能成功执行，那就先执行&lt;/span&gt; D:&lt;span&gt;，成功切换目录后再执行&lt;/span&gt; cd  MySQL\mysql-5.7.19-winx64\bin）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1258453/201712/1258453-20171205235524113-775652457.png&quot; alt=&quot;&quot; width=&quot;652&quot; height=&quot;143&quot;/&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;成功进入bin目录后，执行命令&lt;/span&gt; &lt;span&gt;&lt;span&gt;mysqld --initialize --user=mysql --console&lt;/span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1258453/201712/1258453-20171205235836941-2008420919.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;将上个步骤执行结果生成的随机临时密码一定要保存下来，一定！&lt;span&gt;（如果复制不到，可以这样试试，鼠标右键点击全选，然后在随机临时密码附近点击一下，然后拖动鼠标选上随机临时密码，按&lt;/span&gt;Ctrl+C&lt;span&gt;,不要怀疑自己，试试在txt文本按&lt;/span&gt;Ctrl+V&lt;/span&gt;&lt;span&gt;&lt;span&gt;试试，是不是复制下来了？哈哈）&lt;/span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1258453/201712/1258453-20171206001001347-1506836986.png&quot; alt=&quot;&quot; width=&quot;576&quot; height=&quot;149&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt; &lt;span&gt;然后执行命令 &lt;/span&gt;&lt;span&gt;&lt;span&gt;mysqld --install   &lt;/span&gt;&lt;span&gt;&lt;span&gt;（也是相信自己，执行&lt;span&gt;net start mysql&lt;/span&gt; （或者&lt;span&gt;Windows+R输入services.msc&lt;/span&gt;，找到MYSQL点击启动试试）看看能不能启动），就算启动成功也别急着高兴先，还没结束呢，耐心往下看好吗&lt;/span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1258453/201712/1258453-20171206001739519-923077031.png&quot; alt=&quot;&quot; width=&quot;656&quot; height=&quot;220&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt; 然后输入指令 &lt;/span&gt;&lt;span&gt;&lt;span&gt;mysql -u root -p&lt;/span&gt; &lt;span&gt;&lt;span&gt;并按回车键，输入刚刚复制的临时随机密码 *********，你会感觉心头的石块终于落地了（是吗？）&lt;/span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1258453/201712/1258453-20171206002437488-987483637.png&quot; alt=&quot;&quot; width=&quot;715&quot; height=&quot;233&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt; &lt;span&gt;最后一步就是修改过期密码了，当时查资料是用 &lt;span&gt;mysqladmin -u root -p password 123456&lt;span&gt;，结果报错，然后又教我&lt;span&gt;update mysql.user set password=PASSWORD('我要设置的密码') where User ='root';&lt;/span&gt;，结果还是报错，干！！最后终于找到了（感动！）。就是！！&lt;/span&gt;&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre name=&quot;code&quot; class=&quot;programlisting&quot;&gt;
&lt;span&gt;&lt;span&gt;&lt;strong&gt;       ALTER USER 'root'@'localhost' IDENTIFIED BY '&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;replaceable&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;新密码&lt;/code&gt;' PASSWORD EXPIRE NEVER;-- 密码永不过期,将NEVER去掉则是有过期时间&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.4结束语！！！&lt;/span&gt;&lt;br/&gt;　　&lt;/strong&gt;&lt;span&gt;短短一片文章，竟然从晚上11点写到00点30分，不过还是很快乐的，能够总结问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;replaceable&quot;&gt;希望对大家有所帮助，谢谢！&lt;/span&gt;
&lt;/pre&gt;
&lt;pre name=&quot;code&quot; class=&quot;programlisting&quot;&gt;
&lt;/pre&gt;
&lt;pre name=&quot;code&quot; class=&quot;programlisting&quot;&gt;
&lt;span&gt;&lt;span class=&quot;replaceable&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 05 Dec 2017 16:40:00 +0000</pubDate>
<dc:creator>炭烧小鸡</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tanshaoxiaoji/p/mysql_open_services.html</dc:identifier>
</item>
<item>
<title>写博客的意义是什么，我为什么捡起继续写博客 - Ryan.Miao</title>
<link>http://www.cnblogs.com/woshimrf/p/why-write-blog.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/woshimrf/p/why-write-blog.html</guid>
<description>&lt;h2 id=&quot;入坑&quot;&gt;入坑&lt;/h2&gt;
&lt;p&gt;第一次接触博客还是上高中的时候，那时候第一次上网，那时候第一次发表文章是在百度空间。然后qq空间。学生时代对文学浓厚的兴趣导致内容多是像作文一样的叙事，散文。会写下又不小心领悟了什么哲理，感觉又距离世界近了一步啥的。然后，然后就在大学之后丢弃。&lt;/p&gt;
&lt;p&gt;一直到工作的时候，刚进入的小公司，什么都不会，也没有人带路。只能百度，百度的多了，发现有时候明明百度过一遍了第二天又忘记了，再百度一遍。为了防止这个问题再次发生，我用笔把问题写到笔记本里。然而，这是代码啊，即便是状元笔记也不会这么记录代码啊。于是，想着找找怎么记录，那时候还不知道用有道云笔记，感觉印象笔记笔记不好使。那就纪录到博客吧。&lt;/p&gt;
&lt;p&gt;当时百度的文章主要是csdn和博客园。然后csdn渣渣的页面和广告促使我选择了博客园。好久之后才知道，原来他妈的博客园居然&lt;code&gt;.net&lt;/code&gt;社区。当时就是相当做笔记本，备忘录来着。写第一个的时候，不知道是写文章好还是写随笔好。想文章逼格很高，自己就是随笔吧。后来才发现，大家的博客都是随笔。&lt;/p&gt;
&lt;h2 id=&quot;倒腾&quot;&gt;倒腾&lt;/h2&gt;
&lt;p&gt;渐渐的，见招拆招，遇到的问题多了，解决的多了。大部分问题都没必要记录了。于是放弃了写博客。毕竟花时间。直到看到springboot横空出世，妈的，我又感觉啥都不会了。接着学，也就接着记笔记。写多了，感觉主题不爽，自定义吧。找了推荐博客的前几名的模板，F12给抄了过来。然后，看到人家逼格满满，也学着加了百度统计。直到这时，我才发现，原来我写的博客已经开始产生价值了。虽然水的一逼。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/686418/201712/686418-20171205225439863-1784185351.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据百度统计，工作日访问量的独立ip平均超过1500。按照我看博客意义，我居然每天间接帮助了1500多人。然后，统计地区发现，尼玛，还是北京上海牛。不知道有没有后悔从北京跑到深圳来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/686418/201711/686418-20171121214606274-1101218594.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/686418/201712/686418-20171205235422722-73586590.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，自己搭建github page，搞的挺有意思。&lt;a href=&quot;http://blog.rmiao.top/&quot; class=&quot;uri&quot;&gt;http://blog.rmiao.top/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/686418/201712/686418-20171205225617253-574062733.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然而，还是觉得博客园好用。继续修改主题吧。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;还是要排版&quot;&gt;还是要排版&lt;/h2&gt;
&lt;p&gt;当然，写博客的真正意义并不是改UI。而是记笔记。不用想着人家专栏写的多好，哪有时间搞排版啊，都是小工，花时间排版哪还能工作？还能学习？直到参加了两次hackathon才发现，尼玛，原来把视频做好才能获奖。代码写的再多，demo的时候也就是一分钟。要学会讲故事。所以，排版还是会看一看。&lt;/p&gt;
&lt;p&gt;嗯，自从有了markdown，再也不用担心排版了。大家都这么写。不用费心半天，F12就是为了把人家博客的标题蓝色背景抄过来。&lt;/p&gt;
&lt;h2 id=&quot;写的再多不如一张图一张好图胜过千言&quot;&gt;写的再多不如一张图，一张好图胜过千言&lt;/h2&gt;
&lt;p&gt;不要以为写代码就不用沟通了，团队里要沟通，团队之间要沟通，和boss要沟通。以前不觉的沟通有啥麻烦的，主要是轮不到我沟通，我就是被安排做个啥，不许反抗。后来想要把自己写的东西告诉别人也不是简单事情。有的人脑回路就是不一样(也许是程序员脑回路和其他人不同)，怎么讲都听不懂。听他讲呢，也听不懂说啥。于是，明明是一个问题，说过来说过去。来来去去的说，一会自己说向左，一会变成自己支持向右。尼玛，写下来，画下来，这下你不能来回讲车轱辘话了吧。就用chrome的插件gliffy。画多了就好了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/686418/201712/686418-20171205230702441-2119603498.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;写博客就是整理思路督促学习&quot;&gt;写博客就是整理思路，督促学习&lt;/h2&gt;
&lt;p&gt;写博客的时候，想要记录的东西总是要确认下才写。这不是为了别人好，这是为了自己好，尼玛，下次看的时候还不确定的话，写下来有毛用。终归还是给自己看的。然后就不得不查资料，不得不学习。&lt;/p&gt;
&lt;h2 id=&quot;坚持总会有收获&quot;&gt;坚持总会有收获&lt;/h2&gt;
&lt;p&gt;程序员，不说话。时间久了，舌头都不能打转了。我一个北方人，愣是被同化成各种吐字不清。为了矫正发音，准备朗诵。朗诵怎么校验呢？还是记录下来。一开始使用自己的手机录音软件。后来觉得丢喜马拉雅好了，方便管理。由于读的都是出版产品，一度仔细看了几遍喜马拉雅的霸王条款--都是我们的。我这算不算侵权？算了，不哔哔，我就是练习发音而已。在北京的时候，早上6点半去西土城遗址公园走一圈，边走边读。到深圳，有一段时间也会早上去莲花山跑两圈读半个钟。然后搬家了，然后卸载了喜马拉雅。&lt;/p&gt;
&lt;p&gt;直到最近，感觉自己快成哑巴了。不行，不说英语发不准了，普通话都不行好不好。接着把喜马拉雅下下来。于是看到钱包有2毛钱，什么鬼？广告分成？找到了订阅最多一个录音。尼玛，居然有人订阅。我自己听了一下，完全听不清，更别说听懂了。这也可以。可惜，当时读了一遍发现这本书太难读了，太监。&lt;br/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/686418/201712/686418-20171205231920300-1506979928.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;接下来&quot;&gt;接下来&lt;/h2&gt;
&lt;p&gt;回归一下Java基础。学一下scala/python/go/kotlin/JavaScript。搞通spring cloud技术栈。嗯，继续记笔记。继续练习发音。&lt;/p&gt;
</description>
<pubDate>Tue, 05 Dec 2017 15:58:00 +0000</pubDate>
<dc:creator>Ryan.Miao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/woshimrf/p/why-write-blog.html</dc:identifier>
</item>
<item>
<title>数据结构  重点详解 - Kindear_chen</title>
<link>http://www.cnblogs.com/masterchd/p/7987371.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/masterchd/p/7987371.html</guid>
<description>&lt;hr/&gt;
&lt;h3&gt;线性表-顺序表&lt;/h3&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61&quot;&gt;&lt;img id=&quot;code_img_closed_20086ca5-ade6-46ca-bfc2-2a18a731e864&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_20086ca5-ade6-46ca-bfc2-2a18a731e864&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_20086ca5-ade6-46ca-bfc2-2a18a731e864&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;117&quot;&gt;
&lt;pre&gt;
#include &amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;#define&lt;/span&gt; TRUE   1
&lt;span&gt;#define&lt;/span&gt; FALSE   0
&lt;span&gt;#define&lt;/span&gt; OK    1
&lt;span&gt;#define&lt;/span&gt; ERROR   0
&lt;span&gt;#define&lt;/span&gt; INFEASIBLE -1
&lt;span&gt;#define&lt;/span&gt; OVERFLOW -2
&lt;span&gt;#define&lt;/span&gt; LIST_INIT_SIZE 100 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线性表初始空间分配量&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; LISTINCREMENT   10 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线性表空间分配的增量&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Status;
typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ElemType;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LNode{
    ElemType  &lt;/span&gt;*elem;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储空间的基地址&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;      lenght;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前的长度&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;         listsize;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前分配的存储容量&lt;/span&gt;
&lt;span&gt;}SqList;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化 线性表 空表&lt;/span&gt;
Status initList(SqList &amp;amp;L, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; lenght){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lenght == &lt;span&gt;0&lt;/span&gt;) lenght =&lt;span&gt; LIST_INIT_SIZE;
    L.elem &lt;/span&gt;= (ElemType *)&lt;span&gt;malloc&lt;/span&gt;(lenght * &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(ElemType));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!L.elem) exit(OVERFLOW);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分配存储空间失败&lt;/span&gt;
    L.lenght = &lt;span&gt;0&lt;/span&gt;;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始空表长度为0&lt;/span&gt;
    L.listsize = lenght ;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始存储容量为100&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在 i 位置 插入 e&lt;/span&gt;
Status insertList(SqList &amp;amp;L, ElemType e, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
    ElemType &lt;/span&gt;*p,  *&lt;span&gt;q;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i&amp;lt;&lt;span&gt;0&lt;/span&gt; ||i &amp;gt; L.lenght) &lt;span&gt;return&lt;/span&gt; ERROR;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;i值不合法&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (L.lenght &amp;gt;=&lt;span&gt; L.listsize)
    {
        ElemType &lt;/span&gt;*newbase = (ElemType *)&lt;span&gt;realloc&lt;/span&gt;(L.elem ,(L.listsize +LISTINCREMENT)*&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(ElemType));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!newbase) &lt;span&gt;return&lt;/span&gt; OVERFLOW;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储分配失败&lt;/span&gt;
        L.elem = newbase;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新基值&lt;/span&gt;
        L.listsize += LISTINCREMENT;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加存储容量&lt;/span&gt;
&lt;span&gt;    }
    q &lt;/span&gt;= &amp;amp;L.elem[i];                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;q为插入的位置&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (p = &amp;amp;L.elem[L.lenght]; p&amp;gt;=q; --&lt;span&gt;p) {
        &lt;/span&gt;*p = *(p-&lt;span&gt;1&lt;/span&gt;);                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;i元素之后的元素往后移动&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;*q = e;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入e&lt;/span&gt;
    L.lenght +=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;

}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
void ListInsert(SqList *L,int i,ElemType e) // 插入操作的第二写法
//在线性表L的第i个位置插入新元素e
{
    if(L-&amp;gt;lenght==100)
    {
        printf(&quot;线性表已满\n&quot;);
        return;
    }
    if(i&amp;lt;1||i&amp;gt;L-&amp;gt;lenght+1)
    {
        printf(&quot;插入位置出错\n&quot;);
        return;
    }
    for(int k=L-&amp;gt;lenght;k&amp;gt;=i;k--)
    {
        L-&amp;gt;data[k]=L-&amp;gt;data[k-1];
    }
    L-&amp;gt;data[i-1]=e;
    L-&amp;gt;lenght++;
}
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除元素操作&lt;/span&gt;
Status deleteListElem(SqList &amp;amp;L, &lt;span&gt;int&lt;/span&gt; i, ElemType &amp;amp;&lt;span&gt;e){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *p,  *&lt;span&gt;q;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i&amp;lt;&lt;span&gt;0&lt;/span&gt; ||i &amp;gt; L.lenght) &lt;span&gt;return&lt;/span&gt; ERROR;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;i值不合法&lt;/span&gt;
    q = &amp;amp;L.elem[i];                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;被删除元素的位置为i，L.elem就是数组名,&lt;/span&gt;
    e = *q;                                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;被删除元素的值赋值给e&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (p = q; p&amp;lt; (L.elem + L.lenght); p++){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;元素左移&lt;/span&gt;
        *p = *(p+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;--&lt;span&gt;L.lenght;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;// 第二删除操作
void ListDelete(SqList *L,int i,ElemType *e)
//删除线性表L中的第i个位置元素，并用e返回其值
{
    if(L-&amp;gt;length==0)
    {
        printf(&quot;线性表为空\n&quot;);
        return;
    }
    if(i&amp;lt;1||i&amp;gt;L-&amp;gt;length)
    {
        printf(&quot;位置出错\n&quot;);
        return;
    }
    *e=L-&amp;gt;data[i-1];
    for(int k=i;k&amp;lt;l-&amp;gt;length;k++)
    {
        L-&amp;gt;data[k-1]=L-&amp;gt;data[k];
    }
    L-&amp;gt;length--;
    return;
}
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线性表快速排序&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; partition(SqList &amp;amp;&lt;span&gt;L, ElemType low, ElemType high){
    ElemType pivotkey &lt;/span&gt;= L.elem[low];               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;枢轴记录关键字&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (low &amp;lt; high) {                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从表的两端向中间扫描&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (low &amp;lt; high &amp;amp;&amp;amp;  L.elem[high] &amp;gt;= pivotkey ) --high;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;高端位置扫描&lt;/span&gt;
        L.elem[low] = L.elem[high];        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换数据，小于pivotkey移到低端&lt;/span&gt;
        L.elem[high] =&lt;span&gt; pivotkey;

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (low &amp;lt; high &amp;amp;&amp;amp; L.elem[low] &amp;lt;= pivotkey ) ++low;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;低端扫描&lt;/span&gt;
        L.elem[high] = L.elem[low];                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;交换数据 大于pivotkey移到高端&lt;/span&gt;
        L.elem[low] =&lt;span&gt; pivotkey;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; low;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分治法 ：&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; quickSort(SqList &amp;amp;&lt;span&gt;L, ElemType low, ElemType high){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; pivot;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(low &amp;lt;&lt;span&gt; high) {
        pivot &lt;/span&gt;=&lt;span&gt;  partition(L,  low,  high);
        quickSort(L,  low,  pivot &lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;低端子表排序&lt;/span&gt;
        quickSort(L,  pivot +&lt;span&gt;1&lt;/span&gt;, high);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;高端子表排序&lt;/span&gt;
&lt;span&gt;    }

}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 线性表合并操作&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; mergeList(SqList La, SqList Lb,  SqList &amp;amp;&lt;span&gt;Lc){
    ElemType &lt;/span&gt;*pa, *pb, *&lt;span&gt;pc;
    Lc.listsize &lt;/span&gt;=  La.lenght +&lt;span&gt; Lb.lenght;
    initList(Lc, Lc.listsize);            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化LC\pc = Lc.elem;&lt;/span&gt;
    Lc.lenght =&lt;span&gt; Lc.listsize;
    pc &lt;/span&gt;=&lt;span&gt; Lc.elem;
    pa &lt;/span&gt;=&lt;span&gt; La.elem;
    pb &lt;/span&gt;=&lt;span&gt; Lb.elem;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (pa &amp;lt;= &amp;amp;La.elem[La.lenght -&lt;span&gt;1&lt;/span&gt;] &amp;amp;&amp;amp; pb &amp;lt;= &amp;amp;Lb.elem[Lb.lenght -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (*pa &amp;lt;= *pb) *pc++ = *pa++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; *pc++ = *pb++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(pa &amp;lt;= &amp;amp;La.elem[La.lenght -&lt;span&gt;1&lt;/span&gt;]) *pc++ = *pa++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入La的剩余元素&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(pb &amp;lt;= &amp;amp;Lb.elem[Lb.lenght -&lt;span&gt;1&lt;/span&gt;]) *pc++ = *pb++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入Lb的剩余元素&lt;/span&gt;
&lt;span&gt;
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印操作&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; printList(SqList L){
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前值:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt;0&lt;/span&gt;; i&amp;lt;L.lenght;i++&lt;span&gt;) {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *(L.elem+i)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; L.elem为首地址&lt;/span&gt;
&lt;span&gt;    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    SqList La,Lb,Lc;
    ElemType e;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; init,i;
    init &lt;/span&gt;=&lt;span&gt; initList(La, LIST_INIT_SIZE);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; data[&lt;span&gt;6&lt;/span&gt;] = {&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;&lt;span&gt;6&lt;/span&gt;;i++&lt;span&gt;) {
        insertList(La,  data[i],  i);
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LA:\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    printList(La);
    deleteListElem(La, &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;, e );
    printList(La);
    insertList(La,  e,  &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    printList(La);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;排序&lt;/span&gt;
    quickSort(La,&lt;span&gt;0&lt;/span&gt;, La.lenght-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    printList(La);

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LB:\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    initList(Lb, LIST_INIT_SIZE);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Bdata[&lt;span&gt;5&lt;/span&gt;] = {&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;&lt;span&gt;};
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;&lt;span&gt;5&lt;/span&gt;;i++&lt;span&gt;) {
        insertList(Lb,  Bdata[i],  i);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;排序&lt;/span&gt;
    quickSort(Lb,&lt;span&gt;0&lt;/span&gt;, Lb.lenght-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    printList(Lb);

    mergeList(La, Lb,  Lc);
    printList(Lc);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;线性表—顺序表&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;顺序存储结构： &lt;/p&gt;
&lt;p&gt;原理：使用数组，数组把线性表的数据元素存储在一块连续地址空间的内存单位中&lt;/p&gt;
&lt;p&gt; 特点：线性表中逻辑上相邻的数据元素在物理地址上也相邻。 &lt;/p&gt;
&lt;p&gt;优点：算法简单，存储密度大，空间单位利用效率高&lt;/p&gt;
&lt;p&gt; 缺点：需要预先确定数据元素的最大个数，并且插入和删除操作时需要移动较多的数据元素。（可简化为：插入或删除元素时不方便）&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;在顺序表中实现的基本运算： &lt;/p&gt;
&lt;p&gt;  ·插入：平均移动结点次数为n/2；平均时间复杂度均为O（n）。     &lt;/p&gt;
&lt;p&gt; ·删除：平均移动结点次数为（n-1）/2；平均时间复杂度均为O（n）。 &lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt; 线性表——链表&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;&lt;img id=&quot;code_img_closed_e49f7ab8-a7a1-4d44-b446-99cfcf7e5b2e&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e49f7ab8-a7a1-4d44-b446-99cfcf7e5b2e&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e49f7ab8-a7a1-4d44-b446-99cfcf7e5b2e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;89&quot;&gt;
&lt;pre&gt;
#include &amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; TRUE   1
&lt;span&gt;#define&lt;/span&gt; FALSE   0
&lt;span&gt;#define&lt;/span&gt; OK    1
&lt;span&gt;#define&lt;/span&gt; ERROR   0
&lt;span&gt;#define&lt;/span&gt; INFEASIBLE -1
&lt;span&gt;#define&lt;/span&gt; OVERFLOW -2

&lt;span&gt;#define&lt;/span&gt; LT(a,b)   ((a)&amp;lt;(b))
&lt;span&gt;#define&lt;/span&gt; N = 100&lt;span&gt;

typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Status;
typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ElemType;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
链表的存储特点：
链表的存储方式也于此类似，下面讨论一下链表的特点：
(1)数据元素的逻辑顺序和物理顺序不一定相同。
(2)在查找数据元素时，必须从头指针开始依次查找，表尾的指针域指向NULL。
(3)在特定的数据元素之后插入或删除元素，不需要移动数据元素，因此时间复杂度为 O(1)。
(4) 存储空间不连续，数据元素之间使用指针相连，每个数据元素只能访问周围的一个元素。
(5)长度不固定，可以任意增删。
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LNode{
    ElemType  data;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; LNode   *&lt;span&gt;next;
}LNode, &lt;/span&gt;*&lt;span&gt;LinkList;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
初始化链表
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status initList(LinkList &lt;/span&gt;&amp;amp;&lt;span&gt;L){
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;单链表的初始化&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    L &lt;/span&gt;= (LinkList)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(LNode));    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;申请一个头节点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(!L) exit(OVERFLOW);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;申请空间失败&lt;/span&gt;
    L-&amp;gt;next=NULL;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立一个带都节点的空链表&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    需要改变指针的指针，所以参数必须是引用或者是 *L:
    (*L) = (Lnode *)malloc(sizeof(Lnode));
    (*L)-&amp;gt;next=NULL;
    return 1;
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
创建链表
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; createList(LinkList L, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n){
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;单链表的初始化&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;L) {
        initList(L);
    }
    ElemType data;
    LinkList p,q &lt;/span&gt;=&lt;span&gt; L;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入节点数据的个数%d：\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, n);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i&amp;lt;n; i++&lt;span&gt;) {
        p &lt;/span&gt;= (LinkList) &lt;span&gt;malloc&lt;/span&gt;( &lt;span&gt;sizeof&lt;/span&gt;(LNode)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;申请一个新节点&lt;/span&gt;
        scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;data);
        p&lt;/span&gt;-&amp;gt;data =&lt;span&gt; data;
        p&lt;/span&gt;-&amp;gt;next = q-&amp;gt;&lt;span&gt;next;
        q&lt;/span&gt;-&amp;gt;next =&lt;span&gt; p;
        q &lt;/span&gt;=&lt;span&gt; p;
    }
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 在第i位置插入e
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status insertList(LinkList L, ElemType e, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
    LinkList s, p &lt;/span&gt;=&lt;span&gt; L;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p &amp;amp;&amp;amp; j&amp;lt;i){                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;寻找i节点&lt;/span&gt;
        p = p-&amp;gt;&lt;span&gt;next;
        j&lt;/span&gt;++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!p ||j &amp;gt;i) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    s &lt;/span&gt;= (LinkList) &lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(LNode));        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成新节点&lt;/span&gt;
    s-&amp;gt;data = e; s-&amp;gt;next = p-&amp;gt;next;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入L中&lt;/span&gt;
    p-&amp;gt;next =&lt;span&gt; s;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;

}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 删除第i位置元素，并用e返回其值                                                                     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status deleteListElem(LinkList L, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i, ElemType &amp;amp;&lt;span&gt;e){
    LinkList p, q;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    p &lt;/span&gt;=&lt;span&gt; L;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p &amp;amp;&amp;amp; j&amp;lt;&lt;span&gt;i){
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;++&lt;span&gt;j;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!p-&amp;gt;next || j&amp;gt;i)  &lt;span&gt;return&lt;/span&gt; ERROR;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除的位置不对&lt;/span&gt;
    q  = p-&amp;gt;next; p-&amp;gt;next = q-&amp;gt;&lt;span&gt;next;
    e &lt;/span&gt;= q-&amp;gt;data; &lt;span&gt;free&lt;/span&gt;(q);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放节点&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;  插入排序
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt;&lt;span&gt;  InsertSort(LinkList L)
{
    LinkList  list;                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;为原链表剩下用于直接插入排序的节点头指针&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    LinkList  node;                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;插入节点&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    LinkList  p;
    LinkList  q;

    list &lt;/span&gt;= L-&amp;gt;next;                &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;原链表剩下用于直接插入排序的节点链表&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    L&lt;/span&gt;-&amp;gt;next = NULL;                &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;只含有一个节点的链表的有序链表。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (list != NULL)   {    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;遍历剩下无序的链表&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        node &lt;/span&gt;= list, q =&lt;span&gt; L;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (q &amp;amp;&amp;amp; node-&amp;gt;data &amp;gt; q-&amp;gt;&lt;span&gt;data  ) {
            p &lt;/span&gt;=&lt;span&gt; q;
            q &lt;/span&gt;= q-&amp;gt;&lt;span&gt;next;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (q == L) {  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;插在第一个节点之前&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            L &lt;/span&gt;=&lt;span&gt; node;
        }  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {      &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;p是q的前驱&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            p&lt;/span&gt;-&amp;gt;next =&lt;span&gt; node;
        }
        list &lt;/span&gt;= list-&amp;gt;&lt;span&gt;next;
        node&lt;/span&gt;-&amp;gt;next = q; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;完成插入动作&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

    }
}



&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
合并两个线性表
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;void&lt;/span&gt; mergeList(LinkList  &amp;amp;La, LinkList  &amp;amp;Lb,  LinkList &amp;amp;&lt;span&gt;Lc){
    LinkList pa, pb, pc;
    pa    &lt;/span&gt;= La-&amp;gt;&lt;span&gt;next;
    pb    &lt;/span&gt;= Lb-&amp;gt;&lt;span&gt;next;
    Lc &lt;/span&gt;=  pc =&lt;span&gt; La;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (pa &amp;amp;&amp;amp;&lt;span&gt; pa) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pa-&amp;gt;data &amp;gt; pb-&amp;gt;&lt;span&gt;data) {
            pc&lt;/span&gt;-&amp;gt;next =&lt;span&gt; pb;
            pc &lt;/span&gt;=&lt;span&gt; pb;
            pb &lt;/span&gt;=pb-&amp;gt;&lt;span&gt;next;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            pc&lt;/span&gt;-&amp;gt;next =&lt;span&gt; pa;
            pc &lt;/span&gt;=&lt;span&gt; pa;
            pa &lt;/span&gt;=pa-&amp;gt;&lt;span&gt;next;
        }
    }
    pc&lt;/span&gt;-&amp;gt;next = pa?&lt;span&gt; pa :pb;
    &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(Lb);
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 打印list
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; printList(LinkList  L){
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前值:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    LinkList p;
    p &lt;/span&gt;= L-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(p){
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, p-&amp;gt;&lt;span&gt;data);
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    LinkList  La,Lb,Lc;
    ElemType e;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; init,i;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LA:\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    initList(La);
    createList(La, &lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
    insertList(La, &lt;/span&gt;&lt;span&gt;7&lt;/span&gt;,  &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    printList(La);
    deleteListElem(La, &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;,  e);
    printList(La);
    InsertSort(La);
    printList(La);

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lb:\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    initList(Lb);
    createList(Lb, &lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    InsertSort(Lb);
    printList(Lb);

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Lc:\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    initList(Lc);
    mergeList(La,   Lb,   Lc);
    printList(Lc);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;线性表——链表&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;链式存储结构： &lt;/p&gt;
&lt;p&gt;原理：把存放数据元素的结点用指针域构造成链。 &lt;/p&gt;
&lt;p&gt;         特点：数据元素间的逻辑关系表现在结点的连接关系上 &lt;/p&gt;
&lt;p&gt;         优点：不需要预先确定数据元素的最大个数，插入和删除操作是不需要移动数据元素（可简&lt;/p&gt;
&lt;p&gt;化为：优点：插入或删除元素时很方便，使用灵活。&lt;/p&gt;
&lt;p&gt;           缺点：存储密度小，空间单位利用效率低&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt; 链表三节点区别：&lt;/p&gt;
&lt;p&gt;·头指针：指向链表中第一个结点(或为头结点或为首元结点)的指针。 &lt;/p&gt;
&lt;p&gt;·头结点：链表的首元结点之前附设的一个结点。即头指针所指的不存放数据元素的第一个结点。 &lt;/p&gt;
&lt;p&gt;·首结点：链表中存储线性表中第一个数据元素的结点。  &lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;头结点的作用主要是使插入和删除等操作统一，在第一个元素之前插入元素和删除第一个结点不必另作判断。另外，不论链表是否为空，链表指针不变。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;&lt;span&gt;动态单链表&lt;/span&gt;&lt;/h3&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;span&gt;这种链表在初始时必须分配足够的空间, 也就是空间大小是静态的, 在进行插入和删除时则不需要移动元素, 修改指针域即可,所以仍然具有链表的主要优点，链表结构可以是动态地分配存储的，即在需要时才开辟结点的存储空间，实现动态链接。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;&lt;img id=&quot;code_img_closed_0825934b-d3a5-447d-899c-68b4af495d34&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_0825934b-d3a5-447d-899c-68b4af495d34&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_0825934b-d3a5-447d-899c-68b4af495d34&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;115&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;

&lt;span&gt;#define&lt;/span&gt; TRUE 1
&lt;span&gt;#define&lt;/span&gt; FALSE 0
&lt;span&gt;#define&lt;/span&gt; OK 1
&lt;span&gt;#define&lt;/span&gt; ERROR 0
&lt;span&gt;#define&lt;/span&gt; OVERFLOW -1
&lt;span&gt;#define&lt;/span&gt; INFEASIBLE 0&lt;span&gt;

typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Status;
typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ElemType;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LNode {
    ElemType data;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; LNode *&lt;span&gt;next;
}LNode, &lt;/span&gt;*&lt;span&gt;LinkList;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 操作结果：构造一个空的线性表L
 * @param L
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; InitList(LinkList *&lt;span&gt;L) {
    &lt;/span&gt;*L = (LinkList)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LNode));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!*&lt;span&gt;L) {
        exit(OVERFLOW);
    }
    (&lt;/span&gt;*L)-&amp;gt;next =&lt;span&gt; NULL;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L存在
 * 操作结果：销毁线性表 L
 * @param L
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; DestroyList(LinkList *&lt;span&gt;L) {
    LinkList q;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (*&lt;span&gt;L) {
        q &lt;/span&gt;= (*L)-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;(*&lt;span&gt;L);
        &lt;/span&gt;*L =&lt;span&gt; q;
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在
 * 操作结果：将 L 置为空表
 * @param L
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; ClearList(LinkList L) {
    LinkList p, q;
    p &lt;/span&gt;= L-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (p) {
        q &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(p);
        p &lt;/span&gt;=&lt;span&gt; q;
    }
    L&lt;/span&gt;-&amp;gt;next =&lt;span&gt; NULL;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在
 * 操作结果：若 L 为空表，返回 TRUE，否则返回 FALSE
 * @param L
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status ListEmpty(LinkList L) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; L-&amp;gt;next ==&lt;span&gt; NULL;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在
 * 操作结果：返回 L 中的数据元素个数
 * @param L
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ListLength(LinkList L) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    LinkList p &lt;/span&gt;= L-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (p) {
        i&lt;/span&gt;++&lt;span&gt;;
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在，且 1 &amp;lt;= i &amp;lt;= ListLength(L)
 * 操作结果：用 e 返回 L 中第 i 个元素的值
 * @param L
 * @param i
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status GetElem(LinkList L, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i, ElemType *&lt;span&gt;e) {
    LinkList p &lt;/span&gt;= L-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p &amp;amp;&amp;amp; j &amp;lt;&lt;span&gt; i) {
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;++&lt;span&gt;j;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!p || j &amp;gt;&lt;span&gt; i) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    }
    &lt;/span&gt;*e = p-&amp;gt;&lt;span&gt;data;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在
 * 操作结果：返回 L 中第一个值与元素 e 相同的元素在 L 中的位置。若元素不存在，则返回 0
 * @param L
 * @param e
 * @param compare
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; LocateElem(LinkList L, ElemType e, Status(*&lt;span&gt;compare)(ElemType, ElemType)) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    LinkList p &lt;/span&gt;= L-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (p) {
        i&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compare(p-&amp;gt;&lt;span&gt;data, e)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
        }
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

Status compare(ElemType e1, ElemType e2) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e1 ==&lt;span&gt; e2) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在
 * 操作结果：若 cur_e 是 L 中的元素，且不是第一个，则用 pre_e 返回其前驱，否则失败，pre_e 无定义
 * @param L
 * @param cur_e
 * @param pre_e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status PriorElem(LinkList L, ElemType cur_e, ElemType &lt;/span&gt;*&lt;span&gt;pre_e) {
    LinkList q, p &lt;/span&gt;= L-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p-&amp;gt;&lt;span&gt;next){
        q &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (q-&amp;gt;data ==&lt;span&gt; cur_e) {
            &lt;/span&gt;*pre_e = p-&amp;gt;&lt;span&gt;data;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
        }
        p &lt;/span&gt;=&lt;span&gt; q;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; INFEASIBLE;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在
 * 操作结果：若 cur_e 是 L 中的元素，且不是最后一个，则用 next_e 返回其后驱，否则失败，next_e 无定义
 * @param L
 * @param cur_e
 * @param pre_e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status NextElem(LinkList L, ElemType cur_e, ElemType &lt;/span&gt;*&lt;span&gt;next_e) {
    LinkList q, p &lt;/span&gt;= L-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p-&amp;gt;&lt;span&gt;next) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p-&amp;gt;data ==&lt;span&gt; cur_e) {
            &lt;/span&gt;*next_e = p-&amp;gt;next-&amp;gt;&lt;span&gt;data;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
        }
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; INFEASIBLE;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在，且 1 &amp;lt;= i &amp;lt;= ListLength(L) + 1
 * 操作结果：在 L 中第 i 个元素前插入新的元素 e，L 的长度加 1
 * @param L
 * @param i
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status ListInsert(LinkList L, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, ElemType e) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    LinkList p &lt;/span&gt;=&lt;span&gt; L, s;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p &amp;amp;&amp;amp; j &amp;lt; i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;++&lt;span&gt;j;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!p || j &amp;gt; i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    }
    s &lt;/span&gt;= (LinkList)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LNode));
    s&lt;/span&gt;-&amp;gt;data =&lt;span&gt; e;
    s&lt;/span&gt;-&amp;gt;next = p-&amp;gt;&lt;span&gt;next;
    p&lt;/span&gt;-&amp;gt;next =&lt;span&gt; s;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在且非空，且 1 &amp;lt;= i &amp;lt;= ListLength(L)
 * 操作结果：删除 L 中的第 i 个元素并用 e 返回其值，L 的长度减 1
 * @param S
 * @param i
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status ListDelete(LinkList L, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i, ElemType *&lt;span&gt;e) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    LinkList q, p &lt;/span&gt;=&lt;span&gt; L;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p-&amp;gt;next &amp;amp;&amp;amp; j &amp;lt; i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;++&lt;span&gt;j;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!p || j &amp;gt; i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    }
    &lt;/span&gt;*e = p-&amp;gt;next-&amp;gt;&lt;span&gt;data;
    q &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    p&lt;/span&gt;-&amp;gt;next = q-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(q);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在
 * 操作结果：对线性表进行遍历，在遍历过程中对每个结点访问一次，遍历过程中调用 vi() 操作元素
 * @param L
 * @param vi
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; TraverseList(LinkList L, &lt;span&gt;void&lt;/span&gt;(*&lt;span&gt;vi)(ElemType)) {
    LinkList p &lt;/span&gt;= L-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (p) {
        vi(p&lt;/span&gt;-&amp;gt;&lt;span&gt;data);
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; vi(ElemType e) {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 操纵结果：前插法创建含 n 个元素的单链表
 * @param L
 * @param n
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; CreateList_H(LinkList *L, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
    InitList(L);
    LinkList p;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; ++&lt;span&gt;i) {
        p &lt;/span&gt;= (LinkList)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LNode));
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;p-&amp;gt;&lt;span&gt;data);
        p&lt;/span&gt;-&amp;gt;next = (*L)-&amp;gt;&lt;span&gt;next;
        (&lt;/span&gt;*L)-&amp;gt;next =&lt;span&gt; p;
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 操纵结果：后插法创建含 n 个元素的单链表
 * @param L
 * @param n
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; CreateList_R(LinkList *L, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
    InitList(L);
    LinkList p, r &lt;/span&gt;= *&lt;span&gt;L;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; ++&lt;span&gt;i) {
        p &lt;/span&gt;= (LinkList)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LNode));
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;p-&amp;gt;&lt;span&gt;data);
        p&lt;/span&gt;-&amp;gt;next =&lt;span&gt; NULL;
        r&lt;/span&gt;-&amp;gt;next =&lt;span&gt; p;
        r &lt;/span&gt;=&lt;span&gt; p;
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------主函数------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 测试程序
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; main() {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试程序只测试函数是否有逻辑错误&lt;/span&gt;
&lt;span&gt;    LinkList list;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp;
    ElemType &lt;/span&gt;*&lt;span&gt;e;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    CreateList_H(&amp;amp;list, 3);&lt;/span&gt;
    CreateList_R(&amp;amp;list, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ListEmpty(list));
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ListLength(list));
    TraverseList(list, vi);
    temp &lt;/span&gt;= ListInsert(list, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;99&lt;/span&gt;&lt;span&gt;);
    TraverseList(list, vi);
    temp &lt;/span&gt;= ListInsert(list, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
    TraverseList(list, vi);
    temp &lt;/span&gt;= GetElem(list, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;, e);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *&lt;span&gt;e);
    temp &lt;/span&gt;= PriorElem(list, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;, e);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *&lt;span&gt;e);
    temp &lt;/span&gt;= NextElem(list, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;, e);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *&lt;span&gt;e);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, LocateElem(list, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;, compare));
    temp &lt;/span&gt;= ListDelete(list, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;, e);
    TraverseList(list, vi);
    ClearList(list);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ListLength(list));

    DestroyList(&lt;/span&gt;&amp;amp;&lt;span&gt;list);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;动态单链表&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;---------&amp;gt; 引用自简书&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;basic-info cmn-clearfix&quot;&gt;
&lt;p&gt; 考点在Code里面。&lt;/p&gt;

&lt;hr/&gt;&lt;br/&gt;&lt;h3&gt;双向链表&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_5da6a2f5-ecdd-41f1-a4e3-1df1416c15d5&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5da6a2f5-ecdd-41f1-a4e3-1df1416c15d5&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5da6a2f5-ecdd-41f1-a4e3-1df1416c15d5&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***********************************************************************
*这个结构体里定义的是链表头的信息，我们的链表操作和链表遍历都离不开链表头 
***********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; student
{
    DLinkListNode header;
    DLinkListNode &lt;/span&gt;*slider; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;游标 &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; length;
}TDLinkList;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************************************
*函数名： DLinkList_Create
*参数：void
*返回值：DLinkList*类型，是一个void*类型，然后再由接收函数进行强制类型转换 
*功能：创建链表，并返回链表头 
**********************************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; 
DLinkList&lt;/span&gt;*&lt;span&gt; DLinkList_Create()
{
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
        为链表头获得空间，链表中其他数据节点的空间是在主函数中定义的，也就是插入链表时候由
        结构体进行定义。 
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    TDLinkList&lt;/span&gt;* ret = (TDLinkList*)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt; (TDLinkList));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret !=&lt;span&gt; NULL)
    {
        ret&lt;/span&gt;-&amp;gt;length = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        ret&lt;/span&gt;-&amp;gt;slider =&lt;span&gt; NULL;
        ret&lt;/span&gt;-&amp;gt;header.next =&lt;span&gt; NULL;
        ret&lt;/span&gt;-&amp;gt;header.pre =&lt;span&gt; NULL;
    }
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************************************
*函数名： DLinkList_Destroy
*参数：DLinkList* list 传进来的是链表头 
*返回值：void 
*功能：销毁链表头 
**********************************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;void&lt;/span&gt; DLinkList_Destroy(DLinkList*&lt;span&gt; list)
{
    &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(list);
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************************************
*函数名： DLinkList_Clear
*参数：DLinkList* list 传进来的是链表头 
*返回值：void 
*功能：清空链表，并把链表头信息清空 
**********************************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;void&lt;/span&gt; DLinkList_Clear(DLinkList*&lt;span&gt; list)
{
    TDLinkList &lt;/span&gt;*slist = (TDLinkList*&lt;span&gt;)list;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (slist !=&lt;span&gt; NULL)
    {
        slist&lt;/span&gt;-&amp;gt;length = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        slist&lt;/span&gt;-&amp;gt;header.next =&lt;span&gt; NULL;
        slist&lt;/span&gt;-&amp;gt;header.pre =&lt;span&gt; NULL;
        slist&lt;/span&gt;-&amp;gt;slider =&lt;span&gt; NULL;
    }
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************************************
*函数名： DLinkList_Length
*参数：DLinkList* list 传进来的是链表头 
*返回值：int类型的整数 
*功能：获得链表长度，并将链表的长度返回 
**********************************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;int&lt;/span&gt; DLinkList_Length(DLinkList*&lt;span&gt; list)
{
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;首先给返回值赋初值，如果函数的返回值为-1，则证明链表并不存在&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; 
    &lt;span&gt;int&lt;/span&gt; ret = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    TDLinkList &lt;/span&gt;*slist = (TDLinkList*&lt;span&gt;)list;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (slist !=&lt;span&gt; NULL)
    {
        ret &lt;/span&gt;= slist-&amp;gt;&lt;span&gt;length;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************************************
*函数名： DLinkList_Insert
*参数：DLinkList* list 传进来的是链表头  DLinkListNode* node 要插入的数据节点，其实是我们
*实际要插入的数据节点的指针 int pos 要插入链表中的位置（注意这个是从0开始算起的） 
*返回值：int类型的整数 
*功能：如果插入元素成功返回1，否则返回其他。 
**********************************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;int&lt;/span&gt; DLinkList_Insert(DLinkList* list, DLinkListNode* node, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pos)
{
    TDLinkList &lt;/span&gt;*slist = (TDLinkList*&lt;span&gt;)list;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ret = (slist !=&lt;span&gt; NULL);
    ret &lt;/span&gt;= ret &amp;amp;&amp;amp; (pos &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    ret &lt;/span&gt;= ret &amp;amp;&amp;amp; (node !=&lt;span&gt; NULL);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ret)
    {
        DLinkListNode&lt;/span&gt;*current = (DLinkListNode*&lt;span&gt;)slist;
        DLinkListNode&lt;/span&gt;*next =&lt;span&gt; NULL;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; (i &amp;lt; pos) &amp;amp;&amp;amp; (current-&amp;gt;next != NULL); i++&lt;span&gt;)
        {
            current &lt;/span&gt;= current-&amp;gt;&lt;span&gt;next;
        }
        next &lt;/span&gt;= current-&amp;gt;&lt;span&gt;next;
        
        current&lt;/span&gt;-&amp;gt;next =&lt;span&gt; node;
        
        node&lt;/span&gt;-&amp;gt;next =&lt;span&gt; next;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next !=&lt;span&gt; NULL)
        {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    node-&amp;gt;next = next;&lt;/span&gt;
            next-&amp;gt;pre =&lt;span&gt; node;            
        } 
        
        node&lt;/span&gt;-&amp;gt;pre =&lt;span&gt; current;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (current == (DLinkListNode*&lt;span&gt;)slist)
        {
            node&lt;/span&gt;-&amp;gt;pre =&lt;span&gt; NULL;
        }
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (slist-&amp;gt;length == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            slist&lt;/span&gt;-&amp;gt;slider =&lt;span&gt; node;
        } 
    
        slist&lt;/span&gt;-&amp;gt;length++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************************************
*函数名： DLinkList_Get
*参数：DLinkList* list 传进来的是链表头  int pos 要插入链表中的位置（注意这个是从0开始算起的） 
*返回值：DLinkListNode*类型 也就是返回的是一个链表的节点结构体指针 
*功能：通过传进来的链表指针和位置，可以获得这个位置上的数据节点信息。 
**********************************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
DLinkListNode&lt;/span&gt;* DLinkList_Get(DLinkList* list, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pos)
{
    TDLinkList&lt;/span&gt;* slist = (TDLinkList*&lt;span&gt;)list;
    DLinkListNode&lt;/span&gt;* ret =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((slist != NULL)&amp;amp;&amp;amp; (pos &amp;gt;= &lt;span&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; (pos &amp;lt; slist-&amp;gt;&lt;span&gt;length))
    {
        DLinkListNode&lt;/span&gt;*current = (DLinkListNode*&lt;span&gt;)slist;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DLinkListNode*next = NULL;&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; pos; i++&lt;span&gt;)
        {
            current &lt;/span&gt;= current-&amp;gt;&lt;span&gt;next;    
        }
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;current永远都是我们要找的节点的前一个节点&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt; 
        ret &lt;/span&gt;= current-&amp;gt;&lt;span&gt;next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************************************
*函数名： DLinkList_Delete
*参数：DLinkList* list 传进来的是链表头  int pos 要插入链表中的位置（注意这个是从0开始算起的） 
*返回值：DLinkListNode*类型 也就是返回的是一个链表的节点结构体指针 
*功能：通过传进来的链表指针和位置，可以获取删除指定位置上的元素，并对指定位置上的元素进行删除。 
**********************************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
DLinkListNode&lt;/span&gt;* DLinkList_Delete(DLinkList* list, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; pos)
{
    TDLinkList&lt;/span&gt;* slist = (TDLinkList*&lt;span&gt;)list;
    DLinkListNode &lt;/span&gt;* ret =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((slist != NULL) &amp;amp;&amp;amp; (pos &amp;gt;=&lt;span&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; (pos &amp;lt; slist-&amp;gt;&lt;span&gt;length))    
    {
        DLinkListNode&lt;/span&gt;* current = (DLinkListNode*&lt;span&gt;)(slist);
        DLinkListNode&lt;/span&gt;*next =&lt;span&gt; NULL;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; pos; i++&lt;span&gt;)
        {
            current &lt;/span&gt;= current-&amp;gt;&lt;span&gt;next;
        }
        ret &lt;/span&gt;= current-&amp;gt;&lt;span&gt;next;

        next&lt;/span&gt;-&amp;gt;pre = current;*/&lt;span&gt; 
        next &lt;/span&gt;= ret-&amp;gt;&lt;span&gt;next;
        current&lt;/span&gt;-&amp;gt;next =&lt;span&gt; next;
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (next !=&lt;span&gt; NULL)
        {
            next&lt;/span&gt;-&amp;gt;pre =&lt;span&gt; current;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (current == (DLinkListNode*&lt;span&gt;)slist)
            {
                current&lt;/span&gt;-&amp;gt;next =&lt;span&gt; NULL;
                next&lt;/span&gt;-&amp;gt;pre =&lt;span&gt; NULL;
            }
            
        }
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (slist-&amp;gt;slider ==&lt;span&gt; ret)
        {
            slist&lt;/span&gt;-&amp;gt;slider =&lt;span&gt; next;
        } 
        
        slist&lt;/span&gt;-&amp;gt;length--&lt;span&gt;;
            
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************************************
*函数名： DLinkList_DeleteNode
*参数：DLinkList* list 传进来的是链表头  int pos 要插入链表中的位置（注意这个是从0开始算起的） 
*返回值：DLinkListNode*类型 也就是返回的是一个链表的节点结构体指针 
*功能：通过传进来的链表指针和位置，通过游标指向我们要删除的元素，然后调用DLinkList_Delete函数
进行删除。 
**********************************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
DLinkListNode&lt;/span&gt;* DLinkList_DeleteNode(DLinkList* list, DLinkListNode*&lt;span&gt; node)
{
    TDLinkList&lt;/span&gt;* slist = (TDLinkList*&lt;span&gt;)list;
    DLinkListNode &lt;/span&gt;* ret =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (slist !=&lt;span&gt; NULL)
    {
        DLinkListNode&lt;/span&gt;* current = (DLinkListNode*&lt;span&gt;)(slist);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; slist-&amp;gt;length; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (current-&amp;gt;next ==&lt;span&gt; node)
            {
                ret &lt;/span&gt;= current-&amp;gt;&lt;span&gt;next;
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            current &lt;/span&gt;= current-&amp;gt;&lt;span&gt;next;
        }
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (current !=&lt;span&gt; NULL)
        {
            DLinkList_Delete (list, i);
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************************************
*函数名： DLinkList_Reset
*参数：DLinkList* list 传进来的是链表头   
*返回值：DLinkListNode*类型 也就是返回的是一个链表的节点结构体指针 
*功能：通过传进来的链表指针将游标重新指向头结点所指向的下一个元素的位置，也就是所谓的游标复位。 
进行删除。 
**********************************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
DLinkListNode&lt;/span&gt;* DLinkList_Reset(DLinkList*&lt;span&gt; list)
{
    TDLinkList&lt;/span&gt;* slist = (TDLinkList*&lt;span&gt;)list;
    DLinkListNode&lt;/span&gt;* ret =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (slist !=&lt;span&gt; NULL)
    {
        slist&lt;/span&gt;-&amp;gt;slider = slist-&amp;gt;&lt;span&gt;header.next;
        ret &lt;/span&gt;= slist-&amp;gt;&lt;span&gt;slider; 
    } 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************************************
*函数名： DLinkList_Current
*参数：DLinkList* list 传进来的是链表头   
*返回值：DLinkListNode*类型 也就是返回的是一个链表的节点结构体指针 
*功能：通过传进来的指针，找到游标当前指向的元素，并将这个当前元素返回。 
**********************************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
DLinkListNode&lt;/span&gt;* DLinkList_Current(DLinkList*&lt;span&gt; list)
{
    TDLinkList&lt;/span&gt;* slist = (TDLinkList*&lt;span&gt;)list;
    DLinkListNode&lt;/span&gt;* ret =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (slist !=&lt;span&gt; NULL)
    {
        ret &lt;/span&gt;= slist-&amp;gt;&lt;span&gt;slider;
    } 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************************************
*函数名： DLinkList_Next
*参数：DLinkList* list 传进来的是链表头   
*返回值：DLinkListNode*类型 也就是返回的是一个链表的节点结构体指针 
*功能：通过传进来的指针，找到游标指向前一个元素，并将这个前一个元素返回。 
**********************************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
DLinkListNode&lt;/span&gt;* DLinkList_Next(DLinkList*&lt;span&gt; list)
{
    TDLinkList&lt;/span&gt;* slist = (TDLinkList*&lt;span&gt;)list;
    DLinkListNode&lt;/span&gt;* ret =&lt;span&gt; NULL;
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( (slist != NULL) &amp;amp;&amp;amp; (slist-&amp;gt;slider !=&lt;span&gt; NULL) )
    {
        ret &lt;/span&gt;= slist-&amp;gt;&lt;span&gt;slider;
        slist&lt;/span&gt;-&amp;gt;slider = ret-&amp;gt;&lt;span&gt;next;
    }
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;**********************************************************************************************
*函数名： DLinkList_Pre
*参数：DLinkList* list 传进来的是链表头   
*返回值：DLinkListNode*类型 也就是返回的是一个链表的节点结构体指针 
*功能：通过传进来的指针，找到游标指向前一个元素，并将这个前一个元素返回。 
**********************************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
DLinkListNode&lt;/span&gt;* DLinkList_Pre(DLinkList*&lt;span&gt; list)
{
    TDLinkList&lt;/span&gt;* slist = (TDLinkList*&lt;span&gt;)list;
    DLinkListNode&lt;/span&gt;* ret =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (slist != NULL &amp;amp;&amp;amp; slist-&amp;gt;slider !=&lt;span&gt; NULL)
    {
        slist&lt;/span&gt;-&amp;gt;slider = slist-&amp;gt;slider-&amp;gt;&lt;span&gt;pre; 
        ret &lt;/span&gt;= slist-&amp;gt;&lt;span&gt;slider;
    } 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;双向链表&lt;/span&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;dl class=&quot;basicInfo-block basicInfo-right&quot;/&gt;&lt;/div&gt;
&lt;h3&gt;循环链表 &lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;&lt;img id=&quot;code_img_closed_848cbc4f-5ff0-411a-ada8-5cf3a0b70907&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_848cbc4f-5ff0-411a-ada8-5cf3a0b70907&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_848cbc4f-5ff0-411a-ada8-5cf3a0b70907&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;115&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;

&lt;span&gt;#define&lt;/span&gt; TRUE 1
&lt;span&gt;#define&lt;/span&gt; FALSE 0
&lt;span&gt;#define&lt;/span&gt; OK 1
&lt;span&gt;#define&lt;/span&gt; ERROR 0
&lt;span&gt;#define&lt;/span&gt; OVERFLOW -1
&lt;span&gt;#define&lt;/span&gt; INFEASIBLE 0&lt;span&gt;

typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Status;
typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ElemType;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LNode {
    ElemType data;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; LNode *&lt;span&gt;next;
}LNode, &lt;/span&gt;*&lt;span&gt;LinkList;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 操作结果：构造一个空的线性表L
 * @param L
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; InitList(LinkList *&lt;span&gt;L) {
    &lt;/span&gt;*L = (LinkList)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LNode));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!*&lt;span&gt;L) {
        exit(OVERFLOW);
    }
    (&lt;/span&gt;*L)-&amp;gt;next = *&lt;span&gt;L;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L存在
 * 操作结果：销毁线性表 L
 * @param L
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; DestroyList(LinkList *&lt;span&gt;L) {
    LinkList q, p &lt;/span&gt;= (*L)-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p != *&lt;span&gt;L) {
        q &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(p);
        p &lt;/span&gt;=&lt;span&gt; q;
    }
    &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;(*&lt;span&gt;L);
    &lt;/span&gt;*L =&lt;span&gt; NULL;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在
 * 操作结果：将 L 置为空表
 * @param L
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; ClearList(LinkList *&lt;span&gt;L) {
    LinkList p, q;
    &lt;/span&gt;*L = (*L)-&amp;gt;&lt;span&gt;next;
    p &lt;/span&gt;= (*L)-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p != *&lt;span&gt;L) {
        q &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(p);
        p &lt;/span&gt;=&lt;span&gt; q;
    }
    (&lt;/span&gt;*L)-&amp;gt;next = *&lt;span&gt;L;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在
 * 操作结果：若 L 为空表，返回 TRUE，否则返回 FALSE
 * @param L
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status ListEmpty(LinkList L) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (L-&amp;gt;next ==&lt;span&gt; L) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; TRUE;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; FALSE;
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在
 * 操作结果：返回 L 中的数据元素个数
 * @param L
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ListLength(LinkList L) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    LinkList p &lt;/span&gt;= L-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p !=&lt;span&gt; L) {
        i&lt;/span&gt;++&lt;span&gt;;
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在，且 1 &amp;lt;= i &amp;lt;= ListLength(L)
 * 操作结果：用 e 返回 L 中第 i 个元素的值
 * @param L
 * @param i
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status GetElem(LinkList L, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i, ElemType *&lt;span&gt;e) {
    LinkList p &lt;/span&gt;= L-&amp;gt;next-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;lt; &lt;span&gt;0&lt;/span&gt; || i &amp;gt;&lt;span&gt; ListLength(L)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    }
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (j &amp;lt;&lt;span&gt; i) {
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;++&lt;span&gt;j;
    }
    &lt;/span&gt;*e = p-&amp;gt;&lt;span&gt;data;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在
 * 操作结果：返回 L 中第一个值与元素 e 相同的元素在 L 中的位置。若元素不存在，则返回 0
 * @param L
 * @param e
 * @param compare
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; LocateElem(LinkList L, ElemType e, Status(*&lt;span&gt;compare)(ElemType, ElemType)) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    LinkList p &lt;/span&gt;= L-&amp;gt;next-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p != L-&amp;gt;&lt;span&gt;next) {
        i&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compare(p-&amp;gt;&lt;span&gt;data, e)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
        }
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

Status compare(ElemType e1, ElemType e2) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e1 ==&lt;span&gt; e2) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在
 * 操作结果：若 cur_e 是 L 中的元素，且不是第一个，则用 pre_e 返回其前驱，否则失败，pre_e 无定义
 * @param L
 * @param cur_e
 * @param pre_e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status PriorElem(LinkList L, ElemType cur_e, ElemType &lt;/span&gt;*&lt;span&gt;pre_e) {
    LinkList q, p &lt;/span&gt;= L-&amp;gt;next-&amp;gt;&lt;span&gt;next;
    q &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (q != L-&amp;gt;&lt;span&gt;next) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (q-&amp;gt;data ==&lt;span&gt; cur_e) {
            &lt;/span&gt;*pre_e = p-&amp;gt;&lt;span&gt;data;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
        }
        p &lt;/span&gt;=&lt;span&gt; q;
        q &lt;/span&gt;= q-&amp;gt;&lt;span&gt;next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; INFEASIBLE;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在
 * 操作结果：若 cur_e 是 L 中的元素，且不是最后一个，则用 next_e 返回其后驱，否则失败，next_e 无定义
 * @param L
 * @param cur_e
 * @param pre_e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status NextElem(LinkList L, ElemType cur_e, ElemType &lt;/span&gt;*&lt;span&gt;next_e) {
    LinkList p &lt;/span&gt;= L-&amp;gt;next-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p !=&lt;span&gt; L) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p-&amp;gt;data ==&lt;span&gt; cur_e) {
            &lt;/span&gt;*next_e = p-&amp;gt;next-&amp;gt;&lt;span&gt;data;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
        }
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; INFEASIBLE;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在，且 1 &amp;lt;= i &amp;lt;= ListLength(L) + 1
 * 操作结果：在 L 中第 i 个元素前插入新的元素 e，L 的长度加 1
 * @param L
 * @param i
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status ListInsert(LinkList &lt;/span&gt;*L, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, ElemType e) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    LinkList p &lt;/span&gt;= *&lt;span&gt;L, s;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;lt;= &lt;span&gt;0&lt;/span&gt; || i &amp;gt; ListLength(*L) + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    }
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (j &amp;lt; i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
        j&lt;/span&gt;++&lt;span&gt;;
    }
    s &lt;/span&gt;= (LinkList)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LNode));
    s&lt;/span&gt;-&amp;gt;data =&lt;span&gt; e;
    s&lt;/span&gt;-&amp;gt;next = p-&amp;gt;&lt;span&gt;next;
    p&lt;/span&gt;-&amp;gt;next =&lt;span&gt; s;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在且非空，且 1 &amp;lt;= i &amp;lt;= ListLength(L)
 * 操作结果：删除 L 中的第 i 个元素并用 e 返回其值，L 的长度减 1
 * @param S
 * @param i
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status ListDelete(LinkList &lt;/span&gt;*L, &lt;span&gt;int&lt;/span&gt; i, ElemType *&lt;span&gt;e) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    LinkList q, p &lt;/span&gt;= (*L)-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;lt; &lt;span&gt;0&lt;/span&gt; || i &amp;gt; ListLength(*&lt;span&gt;L)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    }
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (j &amp;lt; i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;++&lt;span&gt;j;
    }
    &lt;/span&gt;*e = p-&amp;gt;next-&amp;gt;&lt;span&gt;data;
    q &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    p&lt;/span&gt;-&amp;gt;next = q-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(q);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：线性表 L 存在
 * 操作结果：对线性表进行遍历，在遍历过程中对每个结点访问一次，遍历过程中调用 vi() 操作元素
 * @param L
 * @param vi
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; TraverseList(LinkList L, &lt;span&gt;void&lt;/span&gt;(*&lt;span&gt;vi)(ElemType)) {
    LinkList p &lt;/span&gt;= L-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p !=&lt;span&gt; L) {
        vi(p&lt;/span&gt;-&amp;gt;&lt;span&gt;data);
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; vi(ElemType e) {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 操纵结果：前插法创建含 n 个元素的单链表
 * @param L
 * @param n
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; CreateList_H(LinkList *L, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
    InitList(L);
    LinkList p;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; ++&lt;span&gt;i) {
        p &lt;/span&gt;= (LinkList)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LNode));
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;p-&amp;gt;&lt;span&gt;data);
        p&lt;/span&gt;-&amp;gt;next = (*L)-&amp;gt;&lt;span&gt;next;
        (&lt;/span&gt;*L)-&amp;gt;next =&lt;span&gt; p;
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 操纵结果：后插法创建含 n 个元素的单链表
 * @param L
 * @param n
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; CreateList_R(LinkList *L, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
    InitList(L);
    LinkList p, r &lt;/span&gt;= (*L)-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; ++&lt;span&gt;i) {
        p &lt;/span&gt;= (LinkList)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; LNode));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;p) {
            exit(OVERFLOW);
        }
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;p-&amp;gt;&lt;span&gt;data);
        p&lt;/span&gt;-&amp;gt;next = *&lt;span&gt;L;
        r&lt;/span&gt;-&amp;gt;next =&lt;span&gt; p;
        r &lt;/span&gt;=&lt;span&gt; p;
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------主函数------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 测试程序
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; main() {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试程序只测试函数是否有逻辑错误&lt;/span&gt;
&lt;span&gt;    LinkList list;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp;
    ElemType &lt;/span&gt;*&lt;span&gt;e;

    CreateList_H(&lt;/span&gt;&amp;amp;list, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    CreateList_R(&amp;amp;list, 3);&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ListEmpty(list));
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ListLength(list));
    TraverseList(list, vi);
    temp &lt;/span&gt;= ListInsert(&amp;amp;list, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;99&lt;/span&gt;&lt;span&gt;);
    TraverseList(list, vi);
    temp &lt;/span&gt;= ListInsert(&amp;amp;list, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
    TraverseList(list, vi);
    temp &lt;/span&gt;= GetElem(list, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;, e);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *&lt;span&gt;e);
    temp &lt;/span&gt;= PriorElem(list, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;, e);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *&lt;span&gt;e);
    temp &lt;/span&gt;= NextElem(list, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;, e);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *&lt;span&gt;e);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, LocateElem(list, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;, compare));
    temp &lt;/span&gt;= ListDelete(&amp;amp;list, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;, e);
    TraverseList(list, vi);
    ClearList(&lt;/span&gt;&amp;amp;&lt;span&gt;list);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ListLength(list));

    DestroyList(&lt;/span&gt;&amp;amp;&lt;span&gt;list);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;循环链表&lt;/span&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;h3&gt;双向循环链表&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60.5&quot;&gt;&lt;img id=&quot;code_img_closed_7908163c-0032-40c4-ac1b-5613eb835797&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7908163c-0032-40c4-ac1b-5613eb835797&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7908163c-0032-40c4-ac1b-5613eb835797&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;116&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;

&lt;span&gt;#define&lt;/span&gt; TRUE 1
&lt;span&gt;#define&lt;/span&gt; FALSE 0
&lt;span&gt;#define&lt;/span&gt; OK 1
&lt;span&gt;#define&lt;/span&gt; ERROR 0
&lt;span&gt;#define&lt;/span&gt; OVERFLOW -1
&lt;span&gt;#define&lt;/span&gt; INFEASIBLE 0&lt;span&gt;

typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Status;
typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ElemType;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; DuLNode {
    ElemType data;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; DuLNode *&lt;span&gt;prior;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; DuLNode *&lt;span&gt;next;
}DuLNode, &lt;/span&gt;*&lt;span&gt;DuLinkList;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 操作结果：构造一个空的双向链表 L
 * @param L
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; InitList(DuLinkList *&lt;span&gt;L) {
    &lt;/span&gt;*L = (DuLinkList)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; DuLNode));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (*&lt;span&gt;L) {
        (&lt;/span&gt;*L)-&amp;gt;next = (*L)-&amp;gt;prior = *&lt;span&gt;L;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        exit(OVERFLOW);
    }

}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：双向链表 L存在
 * 操作结果：销毁双向链表 L
 * @param L
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; DestroyList(DuLinkList *&lt;span&gt;L) {
    DuLinkList q, p &lt;/span&gt;= (*L)-&amp;gt;next; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 指向第一个节点&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (p != *&lt;span&gt;L) {
        q &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(p);
        p &lt;/span&gt;=&lt;span&gt; q;
    }
    &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;(*&lt;span&gt;L);
    &lt;/span&gt;*L =&lt;span&gt; NULL;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：双向链表 L 存在
 * 操作结果：将 L 置空
 * @param L
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; ClearList(DuLinkList L) {
    DuLinkList q, p &lt;/span&gt;= L-&amp;gt;next; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 指向第一个节点&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (p != L) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 没有到表头&lt;/span&gt;
        q = p-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(p);
        p &lt;/span&gt;=&lt;span&gt; q;
    }
    L&lt;/span&gt;-&amp;gt;next = L-&amp;gt;prior = L; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;头节点两个指针均指向本身&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：双向链表 L 存在
 * 操作结果：若 L 为空表，返回 TRUE，否则返回 FALSE
 * @param L
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status ListEmpty(DuLinkList L) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (L-&amp;gt;next == L &amp;amp;&amp;amp; L-&amp;gt;prior ==&lt;span&gt; L) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; TRUE;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; FALSE;
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：双向链表表 L 存在
 * 操作结果：返回 L 中的数据元素个数
 * @param L
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ListLength(DuLinkList L) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    DuLinkList p &lt;/span&gt;= L-&amp;gt;next; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 指向第一个节点&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (p != L) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 没有到表头&lt;/span&gt;
        i++&lt;span&gt;;
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：双向链表表 L 存在，且 1 &amp;lt;= i &amp;lt;= ListLength(L)
 * 操作结果：用 e 返回 L 中第 i 个元素的值
 * @param L
 * @param i
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status GetElem(DuLinkList L, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i, ElemType *&lt;span&gt;e) {
    DuLinkList p &lt;/span&gt;= L-&amp;gt;next; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 指向第一个节点&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计数器&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (p != L &amp;amp;&amp;amp; j &amp;lt; i) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;顺指针向后查询，直到 p 指向第 i 个元素或 p 指向头结点&lt;/span&gt;
        p = p-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;++&lt;span&gt;j;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p == L || j &amp;gt; i) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第 i 个元素不存在&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    }
    &lt;/span&gt;*e = p-&amp;gt;data; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取得第 i 个元素&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：双向链表 L 存在
 * 操作结果：返回 L 中第一个值与元素 e 相同的元素在 L 中的位置。若元素不存在，则返回 0
 * @param L
 * @param e
 * @param compare
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; LocateElem(DuLinkList L, ElemType e, Status(*&lt;span&gt;compare)(ElemType, ElemType)) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    DuLinkList p &lt;/span&gt;= L-&amp;gt;next; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 指向第一个节点&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (p != L) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 没有到表头&lt;/span&gt;
        i++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (compare(p-&amp;gt;data, e)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到该元素&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
        }
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

Status compare(ElemType e1, ElemType e2) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e1 ==&lt;span&gt; e2) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：双向链表 L 存在
 * 操作结果：若 cur_e 是 L 中的元素，且不是第一个，则用 pre_e 返回其前驱，否则失败，pre_e 无定义
 * @param L
 * @param cur_e
 * @param pre_e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status PriorElem(DuLinkList L, ElemType cur_e, ElemType &lt;/span&gt;*&lt;span&gt;pre_e) {
    DuLinkList p &lt;/span&gt;= L-&amp;gt;next-&amp;gt;next; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 指向第二个元素&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (p !=&lt;span&gt; L) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p-&amp;gt;data ==&lt;span&gt; cur_e) {
            &lt;/span&gt;*pre_e = p-&amp;gt;prior-&amp;gt;data; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回前驱&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
        }
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; INFEASIBLE;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：双向链表表 L 存在
 * 操作结果：若 cur_e 是 L 中的元素，且不是最后一个，则用 next_e 返回其后驱，否则失败，next_e 无定义
 * @param L
 * @param cur_e
 * @param pre_e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status NextElem(DuLinkList L, ElemType cur_e, ElemType &lt;/span&gt;*&lt;span&gt;next_e) {
    DuLinkList p &lt;/span&gt;= L-&amp;gt;next-&amp;gt;next; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 指向第二个元素&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (p !=&lt;span&gt; L) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (p-&amp;gt;prior-&amp;gt;data ==&lt;span&gt; cur_e) {
            &lt;/span&gt;*next_e = p-&amp;gt;data; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回后驱&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
        }
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; INFEASIBLE;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 返回 L 中第 i 个元素的地址，若 i = 0 返回头结点，若 i 不存在，返回 NULL
 * @param L
 * @param i
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
DuLinkList GetElemP(DuLinkList L, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
    DuLinkList p &lt;/span&gt;= L; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 指向头结点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (i &amp;lt; &lt;span&gt;0&lt;/span&gt; || i &amp;gt; ListLength(L)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;i 值不合法&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= i; j++&lt;span&gt;) {
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：双向链表 L 存在，且 1 &amp;lt;= i &amp;lt;= ListLength(L) + 1
 * 操作结果：在 L 中第 i 个元素前插入新的元素 e，L 的长度加 1
 * @param L
 * @param i
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status ListInsert(DuLinkList L, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, ElemType e) {
    DuLinkList p, s;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;lt; &lt;span&gt;1&lt;/span&gt; || i &amp;gt; (ListLength(L) + &lt;span&gt;1&lt;/span&gt;)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;i 值不合法&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    }
    p &lt;/span&gt;= GetElemP(L, i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!p) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在 L 中确定第 i 个元素的前驱位置指针 p&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; ERROR; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; p = NULL 时，第 i 个元素不存在&lt;/span&gt;
&lt;span&gt;    }
    s &lt;/span&gt;= (DuLinkList)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; DuLNode));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;s) {
        exit(OVERFLOW);
    }
    s&lt;/span&gt;-&amp;gt;data =&lt;span&gt; e;
    s&lt;/span&gt;-&amp;gt;prior = p; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在 i - 1 个元素后插入&lt;/span&gt;
    s-&amp;gt;next = p-&amp;gt;&lt;span&gt;next;
    p&lt;/span&gt;-&amp;gt;next-&amp;gt;prior =&lt;span&gt; s;
    p&lt;/span&gt;-&amp;gt;next =&lt;span&gt; s;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：双向链表 L 存在且非空，且 1 &amp;lt;= i &amp;lt;= ListLength(L)
 * 操作结果：删除 L 中的第 i 个元素并用 e 返回其值，L 的长度减 1
 * @param S
 * @param i
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status ListDelete(DuLinkList L, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i, ElemType *&lt;span&gt;e) {
    DuLinkList p;
    p &lt;/span&gt;=&lt;span&gt; GetElemP(L, i);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!p) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在 L 中确定第 i 个元素的位置指针 p&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; ERROR; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p = NULL 是，第 i 个元素不存在，也就是 i 值不合法&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;*e = p-&amp;gt;&lt;span&gt;data;
    p&lt;/span&gt;-&amp;gt;prior-&amp;gt;next = p-&amp;gt;next; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改被删除结点的前驱结点的后继指针&lt;/span&gt;
    p-&amp;gt;next-&amp;gt;prior = p-&amp;gt;prior; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改被删除结点的后继结点的前驱指针&lt;/span&gt;
    &lt;span&gt;free&lt;/span&gt;&lt;span&gt;(p);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：双向链表 L 存在
 * 操作结果：由头结点出发，对链表进行遍历，在遍历过程中对每个结点访问一次，遍历过程中调用 vi() 操作元素
 * @param L
 * @param vi
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; TraverseList(DuLinkList L, &lt;span&gt;void&lt;/span&gt;(*&lt;span&gt;vi)(ElemType)) {
    DuLinkList p &lt;/span&gt;= L-&amp;gt;next; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 指向第一个元素&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (p != L) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历&lt;/span&gt;
        vi(p-&amp;gt;&lt;span&gt;data);
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; vi(ElemType e) {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 操纵结果：前插法创建含 n 个元素的双向链表
 * @param L
 * @param n
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; CreateList_H(DuLinkList *L, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
    InitList(L);
    DuLinkList p;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; ++&lt;span&gt;i) {
        p &lt;/span&gt;= (DuLinkList)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; DuLNode));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;p) {
            exit(OVERFLOW);
        }
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;p-&amp;gt;&lt;span&gt;data);
        p&lt;/span&gt;-&amp;gt;prior = *&lt;span&gt;L;
        p&lt;/span&gt;-&amp;gt;next = (*L)-&amp;gt;&lt;span&gt;next;
        (&lt;/span&gt;*L)-&amp;gt;next-&amp;gt;prior =&lt;span&gt; p;
        (&lt;/span&gt;*L)-&amp;gt;next =&lt;span&gt; p;
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 操纵结果：后插法创建含 n 个元素的单链表
 * @param L
 * @param n
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; CreateList_R(DuLinkList *L, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n) {
    InitList(L);
    DuLinkList p, r &lt;/span&gt;= (*L)-&amp;gt;&lt;span&gt;next;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; ++&lt;span&gt;i) {
        p &lt;/span&gt;= (DuLinkList)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; DuLNode));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;p) {
            exit(OVERFLOW);
        }
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;p-&amp;gt;&lt;span&gt;data);
        p&lt;/span&gt;-&amp;gt;prior =&lt;span&gt; r;
        p&lt;/span&gt;-&amp;gt;next = *&lt;span&gt;L;
        r&lt;/span&gt;-&amp;gt;next-&amp;gt;prior =&lt;span&gt; p;
        r&lt;/span&gt;-&amp;gt;next =&lt;span&gt; p;
        r &lt;/span&gt;=&lt;span&gt; p;
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;--------------------主函数------------------------&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 测试程序
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; main() {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试程序只测试函数是否有逻辑错误&lt;/span&gt;
&lt;span&gt;    DuLinkList  list;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; temp;
    ElemType &lt;/span&gt;*&lt;span&gt;e;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    CreateList_H(&amp;amp;list, 3);&lt;/span&gt;
    CreateList_R(&amp;amp;list, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ListEmpty(list));
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ListLength(list));
    TraverseList(list, vi);
    temp &lt;/span&gt;= ListInsert(list, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;99&lt;/span&gt;&lt;span&gt;);
    TraverseList(list, vi);
    temp &lt;/span&gt;= ListInsert(list, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
    TraverseList(list, vi);
    temp &lt;/span&gt;= GetElem(list, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;, e);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *&lt;span&gt;e);
    temp &lt;/span&gt;= PriorElem(list, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;, e);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *&lt;span&gt;e);
    temp &lt;/span&gt;= NextElem(list, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;, e);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, *&lt;span&gt;e);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, LocateElem(list, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;, compare));
    temp &lt;/span&gt;= ListDelete(list, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;, e);
    TraverseList(list, vi);
    ClearList(list);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ListLength(list));

    DestroyList(&lt;/span&gt;&amp;amp;&lt;span&gt;list);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;双向循环链表&lt;/span&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;h3&gt;栈&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_68ef6627-ed95-431c-a7fc-6ff7eb5f03c8&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_68ef6627-ed95-431c-a7fc-6ff7eb5f03c8&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_68ef6627-ed95-431c-a7fc-6ff7eb5f03c8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
#include &amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; Stack_size 10010
&lt;span&gt;#define&lt;/span&gt; Stack_Rise 100&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *&lt;span&gt;base&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *&lt;span&gt;top;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; roomstack;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;栈的容量&lt;/span&gt;
&lt;span&gt;}Stack;
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; InitStack(Stack &amp;amp;&lt;span&gt;S)
{
    S.&lt;/span&gt;&lt;span&gt;base&lt;/span&gt; = (&lt;span&gt;int&lt;/span&gt; *)&lt;span&gt;malloc&lt;/span&gt;(Stack_size*&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(S.&lt;span&gt;base&lt;/span&gt;==NULL)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if(!S.base)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    S.top &lt;/span&gt;= S.&lt;span&gt;base&lt;/span&gt;&lt;span&gt;;
    S.roomstack&lt;/span&gt;+=&lt;span&gt;Stack_size;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; GetTop(Stack &amp;amp;&lt;span&gt;S)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(S.top==S.&lt;span&gt;base&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 栈空 ， 返回 -1&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; *(S.top-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; Push(Stack &amp;amp;S,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; e)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(S.top-S.&lt;span&gt;base&lt;/span&gt;&amp;gt;=S.roomstack) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 空间不足 ， 继续分配&lt;/span&gt;
    S.&lt;span&gt;base&lt;/span&gt; = (&lt;span&gt;int&lt;/span&gt; *)&lt;span&gt;realloc&lt;/span&gt;(S.&lt;span&gt;base&lt;/span&gt;,(S.roomstack+Stack_Rise)*&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!S.&lt;span&gt;base&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    S.top &lt;/span&gt;= S.&lt;span&gt;base&lt;/span&gt;+&lt;span&gt;S.roomstack;
    S.roomstack&lt;/span&gt;+=&lt;span&gt;Stack_Rise;
    &lt;/span&gt;*S.top++ =&lt;span&gt; e;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Pop(Stack &amp;amp;&lt;span&gt;S)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(S.&lt;span&gt;base&lt;/span&gt;==S.top) &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt; *(--&lt;span&gt;S.top);
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    Stack Sta;
    InitStack(Sta);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;n);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; t;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(n--&lt;span&gt;)
    {
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;t);
        Push(Sta,t);
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,GetTop(Sta));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;栈&lt;/span&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;h3&gt;链式栈&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;&lt;img id=&quot;code_img_closed_cfd26588-e211-42ce-b450-b67bd8fc1e8c&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_cfd26588-e211-42ce-b450-b67bd8fc1e8c&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_cfd26588-e211-42ce-b450-b67bd8fc1e8c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;87&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;

&lt;span&gt;#define&lt;/span&gt; TRUE 1
&lt;span&gt;#define&lt;/span&gt; FALSE 0
&lt;span&gt;#define&lt;/span&gt; OK 1
&lt;span&gt;#define&lt;/span&gt; ERROR 0
&lt;span&gt;#define&lt;/span&gt; OVERFLOW -1
&lt;span&gt;#define&lt;/span&gt; INFEASIBLE 0&lt;span&gt;

typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Status;
typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; SElemType;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; StackNode {
    SElemType data;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据域&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; StackNode *next;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指针域&lt;/span&gt;
}StackNode, *&lt;span&gt;LinkStack;

Status InitStack(LinkStack &lt;/span&gt;*&lt;span&gt;S);
Status DestroyStack(LinkStack &lt;/span&gt;*&lt;span&gt;S);
Status ClearStack(LinkStack &lt;/span&gt;*&lt;span&gt;S);
Status StackEmpty(LinkStack S);
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; StackLength(LinkStack S);
Status GetTop(LinkStack S, SElemType &lt;/span&gt;*&lt;span&gt;e);
Status Push(LinkStack &lt;/span&gt;*&lt;span&gt;S, SElemType e);
Status Pop(LinkStack &lt;/span&gt;*S, SElemType *&lt;span&gt;e);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; StackTraverse(LinkStack S, &lt;span&gt;void&lt;/span&gt;(*&lt;span&gt;vi)(SElemType));

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 操作结果：构造一个空栈 S
 * @param L
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status InitStack(LinkStack &lt;/span&gt;*&lt;span&gt;S) {
    S &lt;/span&gt;= NULL;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造一个空栈，栈顶指针置空&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：栈 S 存在
 * 操作结果：栈 S 被销毁
 * @param S
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status DestroyStack(LinkStack &lt;/span&gt;*&lt;span&gt;S) {
    LinkStack p;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (*S) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;未到栈底&lt;/span&gt;
        p = (*S)-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;(*S);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放栈顶空间&lt;/span&gt;
        *S =&lt;span&gt; p;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：栈 S 存在
 * 操作结果：将栈 S 清空
 * @param S
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status ClearStack(LinkStack &lt;/span&gt;*&lt;span&gt;S) {
    LinkStack q, p &lt;/span&gt;= (*S)-&amp;gt;next;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; p 指向栈顶元素&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (p) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;未到栈底&lt;/span&gt;
        q = p-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(p);
        p &lt;/span&gt;=&lt;span&gt; q;
    }
    (&lt;/span&gt;*S) =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：栈 S 存在
 * 操作结果：若 S 是空栈，返回 true，否则返回 false
 * @param S
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status StackEmpty(LinkStack S) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (S ==&lt;span&gt; NULL) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; TRUE;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; FALSE;
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：栈 S 存在
 * 操作结果：返回栈 S 长度
 * @param S
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; StackLength(LinkStack S) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计数器&lt;/span&gt;
    LinkStack p = S;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p指向栈顶元素&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (p) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;未到栈底&lt;/span&gt;
        i++&lt;span&gt;;
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：栈 S 存在且非空
 * 操作结果；用 e 返回栈 S 的栈顶元素，不修改栈顶指针
 * @param S
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status GetTop(LinkStack S, SElemType &lt;/span&gt;*&lt;span&gt;e) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (S) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;S 非空&lt;/span&gt;
        *e = S-&amp;gt;&lt;span&gt;data;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：栈 S 存在
 * 操作结果：插入元素 e 为新的栈顶元素
 * @param L
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status Push(LinkStack &lt;/span&gt;*&lt;span&gt;S, SElemType e) {
    LinkStack p;
    p &lt;/span&gt;= (LinkStack)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt; StackNode));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成新结点&lt;/span&gt;
    p-&amp;gt;data =&lt;span&gt; e;
    p&lt;/span&gt;-&amp;gt;next = *S;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新结点插入栈顶&lt;/span&gt;
    *S = p;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改栈顶指针&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：栈 S 存在且非空
 * 操作结果：删除栈顶元素，并用 e 返回且值
 * @param S
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status Pop(LinkStack &lt;/span&gt;*S, SElemType *&lt;span&gt;e) {
    LinkStack p;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;S) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    }
    &lt;/span&gt;*e = (*S)-&amp;gt;data;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回栈顶元素&lt;/span&gt;
    p = *S;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 临时保存栈顶空间，以备释放&lt;/span&gt;
    *S = (*S)-&amp;gt;next;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改栈顶指针&lt;/span&gt;
    &lt;span&gt;free&lt;/span&gt;(p);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放原栈栈顶空间&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：栈 S 存在且非空
 * 操作结果：从栈底到栈顶依次对 S 中的每个元素进行访问
 * @param S
 * @param vi
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; StackTraverse(LinkStack S, &lt;span&gt;void&lt;/span&gt;(*&lt;span&gt;vi)(SElemType)) {
    LinkStack p &lt;/span&gt;= S;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 指向栈顶&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (p) {
        vi(p&lt;/span&gt;-&amp;gt;&lt;span&gt;data);
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; vi(SElemType e) {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 主函数，测试程序
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
    LinkStack s &lt;/span&gt;=&lt;span&gt; NULL;
    SElemType e;

    InitStack(&lt;/span&gt;&amp;amp;&lt;span&gt;s);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;栈的长度：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, StackLength(s));
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;栈是否为空：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, StackEmpty(s));
    Push(&lt;/span&gt;&amp;amp;s, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    Push(&lt;/span&gt;&amp;amp;s, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    Push(&lt;/span&gt;&amp;amp;s, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
    Push(&lt;/span&gt;&amp;amp;s, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
    StackTraverse(s,vi);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;栈的长度：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, StackLength(s));
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;栈是否为空：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, StackEmpty(s));
    GetTop(s, &lt;/span&gt;&amp;amp;&lt;span&gt;e);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;栈顶元素：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;栈的长度：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, StackLength(s));
    Pop(&lt;/span&gt;&amp;amp;s, &amp;amp;&lt;span&gt;e);
    StackTraverse(s, vi);
    ClearStack(&lt;/span&gt;&amp;amp;&lt;span&gt;s);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;栈的长度：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, StackLength(s));
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;栈是否为空：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, StackEmpty(s));

    DestroyStack(&lt;/span&gt;&amp;amp;&lt;span&gt;s);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;链式栈&lt;/span&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;h3&gt;队列&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44.5&quot;&gt;&lt;img id=&quot;code_img_closed_127be509-1a03-4899-b57e-f7286057f9e2&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_127be509-1a03-4899-b57e-f7286057f9e2&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_127be509-1a03-4899-b57e-f7286057f9e2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;84&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;

&lt;span&gt;#define&lt;/span&gt; MAX_QUEUE_SIZE 100

&lt;span&gt;#define&lt;/span&gt; TRUE 1
&lt;span&gt;#define&lt;/span&gt; FALSE 0
&lt;span&gt;#define&lt;/span&gt; OK 1
&lt;span&gt;#define&lt;/span&gt; ERROR 0
&lt;span&gt;#define&lt;/span&gt; OVERFLOW -1
&lt;span&gt;#define&lt;/span&gt; INFEASIBLE 0&lt;span&gt;

typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Status;
typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; QElemType;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    QElemType &lt;/span&gt;*&lt;span&gt;base&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储空间基地址&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; front;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;头指针&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; rear;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;尾指针&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; QueueSize;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队列容量&lt;/span&gt;
&lt;span&gt;}SqQueue;

Status InitQueue(SqQueue &lt;/span&gt;*&lt;span&gt;);
Status DestroyQueue(SqQueue &lt;/span&gt;*&lt;span&gt;);
Status ClearQueue(SqQueue &lt;/span&gt;*&lt;span&gt;);
Status QueueEmpty(SqQueue );
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; QueueLength(SqQueue);
Status GetHead(SqQueue, QElemType &lt;/span&gt;*&lt;span&gt;);
Status EnQueue(SqQueue &lt;/span&gt;*&lt;span&gt;, QElemType);
Status DeQueue(SqQueue &lt;/span&gt;*, QElemType *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; QueueTraverse(SqQueue , &lt;span&gt;void&lt;/span&gt;(*&lt;span&gt;vi)(QElemType));

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 操作结果：构造一个空队列 Q
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status InitQueue(SqQueue &lt;/span&gt;*&lt;span&gt;Q) {
    Q&lt;/span&gt;-&amp;gt;&lt;span&gt;base&lt;/span&gt; = (QElemType *)&lt;span&gt;malloc&lt;/span&gt;(MAX_QUEUE_SIZE * &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(SqQueue));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!Q-&amp;gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;) {
        exit(OVERFLOW);
    }
    Q&lt;/span&gt;-&amp;gt;front = Q-&amp;gt;rear = &lt;span&gt;0&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;头指针尾指针置为零，队列为空&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：队列 Q 存在
 * 操作结果：队列 Q 被销毁
 * @param Q
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status DestroyQueue(SqQueue &lt;/span&gt;*&lt;span&gt;Q) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Q-&amp;gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;(Q-&amp;gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;);
    }
    Q&lt;/span&gt;-&amp;gt;&lt;span&gt;base&lt;/span&gt; =&lt;span&gt; NULL;
    Q&lt;/span&gt;-&amp;gt;front = Q-&amp;gt;rear = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：队列 Q 存在
 * 操作结果：清空队列 Q
 * @param Q
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status ClearQueue(SqQueue &lt;/span&gt;*&lt;span&gt;Q) {
    Q&lt;/span&gt;-&amp;gt;front = Q-&amp;gt;rear = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：队列 Q 存在
 * 操作结果：若 Q 为空队列，则返回 true，否则返回 false
 * @param Q
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status QueueEmpty(SqQueue Q) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Q.front ==&lt;span&gt; Q.rear) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; TRUE;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; FALSE;
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：队列 Q 存在
 * 操作结果：返回 Q 中元素个数，即队列长度
 * @param Q
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; QueueLength(SqQueue Q) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (Q.rear - Q.front + MAX_QUEUE_SIZE) %&lt;span&gt; MAX_QUEUE_SIZE;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：队列 Q 存在且非空
 * 操作结果：返回 Q 中队头元素
 * @param Q
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status GetHead(SqQueue Q, QElemType &lt;/span&gt;*&lt;span&gt;e) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Q.front ==&lt;span&gt; Q.rear) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    }
    &lt;/span&gt;*e = Q.&lt;span&gt;base&lt;/span&gt;&lt;span&gt;[Q.front];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：队列 Q 存在
 * 操作结果：插入入元素 e 为 Q 的新队尾元素
 * @param Q
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status EnQueue(SqQueue &lt;/span&gt;*&lt;span&gt;Q, QElemType e) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((Q-&amp;gt;rear + &lt;span&gt;1&lt;/span&gt;) % MAX_QUEUE_SIZE == Q-&amp;gt;&lt;span&gt;front) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ERROR;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队尾指针在循环意义上加 1 后等于头指针，表示队满&lt;/span&gt;
&lt;span&gt;    }
    Q&lt;/span&gt;-&amp;gt;&lt;span&gt;base&lt;/span&gt;[Q-&amp;gt;rear] =&lt;span&gt; e;
    Q&lt;/span&gt;-&amp;gt;rear = (Q-&amp;gt;rear + &lt;span&gt;1&lt;/span&gt;) % MAX_QUEUE_SIZE;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队尾指针加 1&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：队列 Q 存在且非空
 * 操作结果：删除 Q 的队头元素，且用 e 返回
 * @param Q
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status DeQueue(SqQueue &lt;/span&gt;*Q, QElemType *&lt;span&gt;e) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Q-&amp;gt;front == Q-&amp;gt;&lt;span&gt;rear) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    }
    &lt;/span&gt;*e = Q-&amp;gt;&lt;span&gt;base&lt;/span&gt;[Q-&amp;gt;&lt;span&gt;front];
    Q&lt;/span&gt;-&amp;gt;front = (Q-&amp;gt;front + &lt;span&gt;1&lt;/span&gt;) % MAX_QUEUE_SIZE;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队头指针加 1&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：队列 Q 存在且非空
 * 操作结果：从队头到队尾，依次对遍历队列中每个元素
 * @param Q
 * @param vi
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; QueueTraverse(SqQueue Q, &lt;span&gt;void&lt;/span&gt;(*&lt;span&gt;vi)(QElemType)) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; Q.front;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i !=&lt;span&gt; Q.rear) {
        vi(Q.&lt;/span&gt;&lt;span&gt;base&lt;/span&gt;[i]);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历&lt;/span&gt;
        i = (i + &lt;span&gt;1&lt;/span&gt;) %&lt;span&gt; MAX_QUEUE_SIZE;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 遍历函数
 * @param e
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; vi(QElemType e) {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,e);
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 主函数，测试程序
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
    SqQueue q;
    QElemType e;

    InitQueue(&lt;/span&gt;&amp;amp;&lt;span&gt;q);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列的长度：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, QueueLength(q));
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列是否为空：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, QueueEmpty(q));
    EnQueue(&lt;/span&gt;&amp;amp;q, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    EnQueue(&lt;/span&gt;&amp;amp;q, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    EnQueue(&lt;/span&gt;&amp;amp;q, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
    EnQueue(&lt;/span&gt;&amp;amp;q, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
    QueueTraverse(q, vi);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列的长度：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, QueueLength(q));
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列是否为空：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, QueueEmpty(q));
    GetHead(q, &lt;/span&gt;&amp;amp;&lt;span&gt;e);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列的头元素：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
    DeQueue(&lt;/span&gt;&amp;amp;q, &amp;amp;&lt;span&gt;e);
    QueueTraverse(q, vi);
    ClearQueue(&lt;/span&gt;&amp;amp;&lt;span&gt;q);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列的长度：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, QueueLength(q));
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列是否为空：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, QueueEmpty(q));

    DestroyQueue(&lt;/span&gt;&amp;amp;&lt;span&gt;q);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;队列&lt;/span&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;h3&gt;链队列&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45.5&quot;&gt;&lt;img id=&quot;code_img_closed_725469eb-429f-4ff6-b415-396be3bfebb4&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_725469eb-429f-4ff6-b415-396be3bfebb4&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_725469eb-429f-4ff6-b415-396be3bfebb4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;86&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;

&lt;span&gt;#define&lt;/span&gt; TRUE 1
&lt;span&gt;#define&lt;/span&gt; FALSE 0
&lt;span&gt;#define&lt;/span&gt; OK 1
&lt;span&gt;#define&lt;/span&gt; ERROR 0
&lt;span&gt;#define&lt;/span&gt; OVERFLOW -1
&lt;span&gt;#define&lt;/span&gt; INFEASIBLE 0&lt;span&gt;

typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; Status;
typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; QElemType;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; QNode {
    QElemType data;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; QNode *&lt;span&gt;next;
}QNode, &lt;/span&gt;*&lt;span&gt;QueuePtr;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    QueuePtr front;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;队头指针&lt;/span&gt;
    QueuePtr rear;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队尾指针&lt;/span&gt;
&lt;span&gt;}LinkQueue;

Status InitQueue(LinkQueue &lt;/span&gt;*&lt;span&gt;);
Status DestroyQueue(LinkQueue &lt;/span&gt;*&lt;span&gt;);
Status ClearQueue(LinkQueue &lt;/span&gt;*&lt;span&gt;);
Status QueueEmpty(LinkQueue );
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; QueueLength(LinkQueue);
Status GetHead(LinkQueue, QElemType &lt;/span&gt;*&lt;span&gt;);
Status EnQueue(LinkQueue &lt;/span&gt;*&lt;span&gt;, QElemType);
Status DeQueue(LinkQueue &lt;/span&gt;*, QElemType *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; QueueTraverse(LinkQueue , &lt;span&gt;void&lt;/span&gt;(*&lt;span&gt;vi)(QElemType));

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 操作结果：构造一个空队列 Q
 * @param Q
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status InitQueue(LinkQueue &lt;/span&gt;*&lt;span&gt;Q) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(Q-&amp;gt;front = Q-&amp;gt;rear = (QueuePtr)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; QNode)))) {
        exit(OVERFLOW);
    }
    Q&lt;/span&gt;-&amp;gt;front-&amp;gt;next =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：队列 Q 存在
 * 操作结果：队列 Q 被销毁
 * @param Q
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status DestroyQueue(LinkQueue &lt;/span&gt;*&lt;span&gt;Q) {
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (Q-&amp;gt;front) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向队尾时结束循环&lt;/span&gt;
        Q-&amp;gt;rear = Q-&amp;gt;front-&amp;gt;next;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 队尾指针指向队头指针的下一个结点&lt;/span&gt;
        &lt;span&gt;free&lt;/span&gt;(Q-&amp;gt;front);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放队头结点&lt;/span&gt;
        Q-&amp;gt;front = Q-&amp;gt;rear;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改队头指针&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：队列 Q 存在
 * 操作结果：清空队列 Q
 * @param Q
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status ClearQueue(LinkQueue &lt;/span&gt;*&lt;span&gt;Q) {
    QueuePtr p, q;
    Q&lt;/span&gt;-&amp;gt;rear = Q-&amp;gt;front;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队尾指针指向头结点&lt;/span&gt;
    p = Q-&amp;gt;front-&amp;gt;next;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 指向队列第一个元素&lt;/span&gt;
    Q-&amp;gt;front-&amp;gt;next = NULL;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队头指针 next 域置空&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (p) {
        q &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(p);
        p &lt;/span&gt;=&lt;span&gt; q;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;

}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：队列 Q 存在
 * 操作结果：若 Q 为空队列，则返回 true，否则返回 false
 * @param Q
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status QueueEmpty(LinkQueue Q) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Q.front-&amp;gt;next ==&lt;span&gt; NULL) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; TRUE;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; FALSE;
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：队列 Q 存在
 * 操作结果：返回 Q 中元素个数，即队列长度
 * @param Q
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; QueueLength(LinkQueue Q) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计数器&lt;/span&gt;
    QueuePtr p = Q.front-&amp;gt;next;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 指向队头元素&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (p) {
        i&lt;/span&gt;++&lt;span&gt;;
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：队列 Q 存在且非空
 * 操作结果：返回 Q 中队头元素
 * @param Q
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status GetHead(LinkQueue Q, QElemType &lt;/span&gt;*&lt;span&gt;e) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Q.front !=&lt;span&gt; Q.rear) {
        &lt;/span&gt;*e = Q.front-&amp;gt;next-&amp;gt;&lt;span&gt;data;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; INFEASIBLE;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：队列 Q 存在
 * 操作结果：插入入元素 e 为 Q 的新队尾元素
 * @param Q
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status EnQueue(LinkQueue &lt;/span&gt;*&lt;span&gt;Q, QElemType e) {
    QueuePtr p;
    p &lt;/span&gt;= (QueuePtr)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt; QNode));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开辟新结点&lt;/span&gt;
    p-&amp;gt;data =&lt;span&gt; e;
    p&lt;/span&gt;-&amp;gt;next =&lt;span&gt; NULL;
    Q&lt;/span&gt;-&amp;gt;rear-&amp;gt;next = p;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将新结点插入到队尾&lt;/span&gt;
    Q-&amp;gt;rear = p;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改队尾指针&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：队列 Q 存在且非空
 * 操作结果：删除 Q 的队头元素，且用 e 返回
 * @param Q
 * @param e
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
Status DeQueue(LinkQueue &lt;/span&gt;*Q, QElemType *&lt;span&gt;e) {
    QueuePtr p;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Q-&amp;gt;front == Q-&amp;gt;rear) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否为空队列&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    }
    p &lt;/span&gt;= Q-&amp;gt;front-&amp;gt;next;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 指向队头元素&lt;/span&gt;
    *e = p-&amp;gt;&lt;span&gt;data;
    Q&lt;/span&gt;-&amp;gt;front-&amp;gt;next = p-&amp;gt;next;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改头指针&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Q-&amp;gt;rear == p) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果删除的是队列最后一个元素&lt;/span&gt;
        Q-&amp;gt;rear = Q-&amp;gt;front;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;队尾指针指向头结点&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(p);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 初始条件：队列 Q 存在且非空
 * 操作结果：从队头到队尾，依次对遍历队列中每个元素
 * @param Q
 * @param vi
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; QueueTraverse(LinkQueue Q, &lt;span&gt;void&lt;/span&gt;(*&lt;span&gt;vi)(QElemType)) {
    QueuePtr p &lt;/span&gt;= Q.front-&amp;gt;next;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p 指向队头元素&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (p) {
        vi(p&lt;/span&gt;-&amp;gt;data);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历&lt;/span&gt;
        p = p-&amp;gt;&lt;span&gt;next;
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 遍历函数
 * @param e
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; vi(QElemType e) {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,e);
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 主函数，测试程序
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
    LinkQueue q;
    QElemType e;

    InitQueue(&lt;/span&gt;&amp;amp;&lt;span&gt;q);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列的长度：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, QueueLength(q));
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列是否为空：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, QueueEmpty(q));
    EnQueue(&lt;/span&gt;&amp;amp;q, &lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    EnQueue(&lt;/span&gt;&amp;amp;q, &lt;span&gt;4&lt;/span&gt;&lt;span&gt;);
    EnQueue(&lt;/span&gt;&amp;amp;q, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
    EnQueue(&lt;/span&gt;&amp;amp;q, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
    QueueTraverse(q, vi);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列的长度：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, QueueLength(q));
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列是否为空：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, QueueEmpty(q));
    GetHead(q, &lt;/span&gt;&amp;amp;&lt;span&gt;e);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列的头元素：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, e);
    DeQueue(&lt;/span&gt;&amp;amp;q, &amp;amp;&lt;span&gt;e);
    QueueTraverse(q, vi);
    ClearQueue(&lt;/span&gt;&amp;amp;&lt;span&gt;q);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列的长度：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, QueueLength(q));
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;队列是否为空：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, QueueEmpty(q));

    DestroyQueue(&lt;/span&gt;&amp;amp;&lt;span&gt;q);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;链队列&lt;/span&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;h3&gt;双向队列&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_191f8ff0-d6e8-4560-9fe4-4280e80f5ff4&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_191f8ff0-d6e8-4560-9fe4-4280e80f5ff4&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_191f8ff0-d6e8-4560-9fe4-4280e80f5ff4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;math.h&amp;gt;
&lt;span&gt;#define&lt;/span&gt; LEN sizeof(struct DQueuelist)
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; DQueuelist    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义结构体结点&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; data;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结构体数据域&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; DQueuelist *prior; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结构体前向指针&lt;/span&gt;
    &lt;span&gt;struct&lt;/span&gt; DQueuelist *next;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结构体后向指针&lt;/span&gt;
}DQueuelist, *&lt;span&gt;DQueueptr;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义双端队列&lt;/span&gt;
&lt;span&gt;{
    DQueueptr front;         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;头指针，指向链队列头结点&lt;/span&gt;
    DQueueptr rear;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;尾指针，指向链队列最后一个结点&lt;/span&gt;
&lt;span&gt;}LinkDQueue;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数声明部分&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; Error(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;s);
LinkDQueue Creat_DQueuelist();              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误处理函数&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; En_DQueuelist(LinkDQueue &amp;amp;q, &lt;span&gt;int&lt;/span&gt; e);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建双端队列函数&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; De_DQueuelist(LinkDQueue &amp;amp;q, &lt;span&gt;int&lt;/span&gt; e);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;入队函数&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; Print_DQueuelist(LinkDQueue &amp;amp;q);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;出队函数&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; Getlength_DQueuelist(LinkDQueue &amp;amp;q);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算双端队列长度函数&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; Gethead_DQueuelist(LinkDQueue &amp;amp;q, &lt;span&gt;int&lt;/span&gt; e); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到双端队列的端口处的元素&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; Destroy_DQueuelist(LinkDQueue &amp;amp;q);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;销毁双端队列函数

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;函数定义定义&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; Error(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;s)
{
    cout &lt;/span&gt;&amp;lt;&amp;lt; s &amp;lt;&amp;lt;&lt;span&gt; endl;
    exit(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
}
LinkDQueue Creat_DQueuelist()  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建双端队列&lt;/span&gt;
&lt;span&gt;{
    DQueuelist &lt;/span&gt;*pnew;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化双端队列&lt;/span&gt;
&lt;span&gt;    LinkDQueue head;
    head.front &lt;/span&gt;= head.rear = (&lt;span&gt;struct&lt;/span&gt; DQueuelist *)&lt;span&gt;malloc&lt;/span&gt;(LEN);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建头结点&lt;/span&gt;
    head.front-&amp;gt;data = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
    head.front&lt;/span&gt;-&amp;gt;next =&lt;span&gt; NULL;
    head.rear&lt;/span&gt;-&amp;gt;next =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; length = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; number = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入双端队列长度：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    cin &lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; length;
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入双端队列数据：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; length; i++) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口2创建双端队列&lt;/span&gt;
&lt;span&gt;    {
        pnew &lt;/span&gt;= (&lt;span&gt;struct&lt;/span&gt; DQueuelist *)&lt;span&gt;malloc&lt;/span&gt;&lt;span&gt;(LEN);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;pnew)
            Error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;内存分配失败！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        cin &lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; number;
        pnew&lt;/span&gt;-&amp;gt;data =&lt;span&gt; number;
        pnew&lt;/span&gt;-&amp;gt;next =&lt;span&gt; NULL;
        head.rear&lt;/span&gt;-&amp;gt;next =&lt;span&gt; pnew;
        pnew&lt;/span&gt;-&amp;gt;prior =&lt;span&gt; head.rear;
        head.rear &lt;/span&gt;=&lt;span&gt; pnew;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; head;
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; En_DQueuelist(LinkDQueue &amp;amp;q, &lt;span&gt;int&lt;/span&gt; e)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;入队函数&lt;/span&gt;
{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1表示在端口1入队，2表示在端口2入队&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; a;
    DQueuelist &lt;/span&gt;*ptr =&lt;span&gt; NULL;
    DQueuelist &lt;/span&gt;*temp =&lt;span&gt; NULL;
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请选择入队端口(默认端口为1和2)：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    cin &lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; a;
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (a)
    {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:
        ptr &lt;/span&gt;= (&lt;span&gt;struct&lt;/span&gt; DQueuelist *)&lt;span&gt;malloc&lt;/span&gt;(LEN);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口1入队只改变队头指针，不改变队尾指针，
                                              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;且将结点插入到头结点之后，使其成为第一个结点&lt;/span&gt;
                                                
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ptr)
            Error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;内存分配失败！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        ptr&lt;/span&gt;-&amp;gt;data =&lt;span&gt; e;
        temp &lt;/span&gt;= q.front-&amp;gt;&lt;span&gt;next;
        q.front&lt;/span&gt;-&amp;gt;next =&lt;span&gt; ptr;
        ptr&lt;/span&gt;-&amp;gt;next =&lt;span&gt; temp;
        temp&lt;/span&gt;-&amp;gt;prior =&lt;span&gt; ptr;
        ptr&lt;/span&gt;-&amp;gt;prior =&lt;span&gt; q.front;
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;:
        ptr &lt;/span&gt;= (&lt;span&gt;struct&lt;/span&gt; DQueuelist *)&lt;span&gt;malloc&lt;/span&gt;(LEN); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口2入队只改变队尾指针，不改变队头指针
                                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将该结点直接插入到最后面即可&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;ptr)
            Error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;内存分配失败！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        ptr&lt;/span&gt;-&amp;gt;data =&lt;span&gt; e;
        ptr&lt;/span&gt;-&amp;gt;next =&lt;span&gt; NULL;
        q.rear&lt;/span&gt;-&amp;gt;next =&lt;span&gt; ptr;
        ptr&lt;/span&gt;-&amp;gt;prior =&lt;span&gt; q.rear;
        q.rear &lt;/span&gt;=&lt;span&gt; ptr;
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; De_DQueuelist(LinkDQueue &amp;amp;q, &lt;span&gt;int&lt;/span&gt; e)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;出队函数&lt;/span&gt;
{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1表示在端口1出队，2表示在端口2出队&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; a;
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入出队端口(默认端口为1和2):&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    cin &lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; a;
    DQueuelist &lt;/span&gt;*ptr =&lt;span&gt; NULL;
    DQueuelist &lt;/span&gt;*temp =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (a)
    {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口1出队，将头结点后的第一个结点删除即可，改变头指针，不改变尾指针&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (q.front-&amp;gt;next ==&lt;span&gt; NULL)
            Error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该队列为空！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        ptr &lt;/span&gt;= q.front-&amp;gt;&lt;span&gt;next;
        e &lt;/span&gt;= ptr-&amp;gt;&lt;span&gt;data;
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;端口1出队的元素是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; e &amp;lt;&amp;lt;&lt;span&gt; endl;
        q.front&lt;/span&gt;-&amp;gt;next = ptr-&amp;gt;&lt;span&gt;next;
        ptr&lt;/span&gt;-&amp;gt;next-&amp;gt;prior =&lt;span&gt; q.front;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (q.rear ==&lt;span&gt; ptr)
            q.rear &lt;/span&gt;=&lt;span&gt; q.front;
        &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; ptr;
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口2出队，直接将最后一个结点删除即可，改变尾指针，不改变头指针&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (q.rear ==&lt;span&gt; NULL)
            Error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该队列为空！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        ptr &lt;/span&gt;= q.rear-&amp;gt;&lt;span&gt;prior;
        temp &lt;/span&gt;=&lt;span&gt; q.rear;
        e &lt;/span&gt;= temp-&amp;gt;&lt;span&gt;data;
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;端口2出队的元素是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; e &amp;lt;&amp;lt;&lt;span&gt; endl;
        ptr&lt;/span&gt;-&amp;gt;next =&lt;span&gt; NULL;
        q.rear &lt;/span&gt;=&lt;span&gt; ptr;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (q.front ==&lt;span&gt; ptr)
            q.front &lt;/span&gt;=&lt;span&gt; q.rear;
        &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; temp;
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Print_DQueuelist(LinkDQueue &amp;amp;q) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出函数&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; e = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入顺序出队端口：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    cin &lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; n;
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (n)
    {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口1顺序输出，正向输出&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (q.front-&amp;gt;next !=&lt;span&gt; NULL)
        {
            DQueuelist &lt;/span&gt;*p =&lt;span&gt; NULL;
            p &lt;/span&gt;= q.front-&amp;gt;&lt;span&gt;next;
            e &lt;/span&gt;= p-&amp;gt;&lt;span&gt;data;
            cout &lt;/span&gt;&amp;lt;&amp;lt; e &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            q.front&lt;/span&gt;-&amp;gt;next = p-&amp;gt;&lt;span&gt;next;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p-&amp;gt;next-&amp;gt;prior = q.rear;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (q.rear ==&lt;span&gt; p)
                q.rear &lt;/span&gt;=&lt;span&gt; q.front;
        }
        cout &lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt; endl;
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;端口2顺序输出，逆向输出&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; ((q.rear != NULL)&amp;amp;&amp;amp;(q.rear-&amp;gt;data!=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;))
        {
            DQueuelist &lt;/span&gt;*p =&lt;span&gt; NULL;
            DQueuelist &lt;/span&gt;*temp =&lt;span&gt; NULL;
            p &lt;/span&gt;= q.rear-&amp;gt;&lt;span&gt;prior;
            temp &lt;/span&gt;=&lt;span&gt; q.rear;
            e &lt;/span&gt;= temp-&amp;gt;&lt;span&gt;data;
            cout &lt;/span&gt;&amp;lt;&amp;lt; e &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            p&lt;/span&gt;-&amp;gt;next =&lt;span&gt; NULL;
            q.rear &lt;/span&gt;=&lt;span&gt; p;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (q.front ==&lt;span&gt; p)
                q.rear &lt;/span&gt;=&lt;span&gt; q.front;
        }
        cout &lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt; endl;
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Getlength_DQueuelist(LinkDQueue &amp;amp;q) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算双端队列长度函数&lt;/span&gt;
&lt;span&gt;{
    DQueuelist &lt;/span&gt;*p =&lt;span&gt; NULL;
    p &lt;/span&gt;=&lt;span&gt; q.front;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; length = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (p-&amp;gt;next !=&lt;span&gt; NULL)
    {
        length&lt;/span&gt;++&lt;span&gt;;
        p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; length;
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Gethead_DQueuelist(LinkDQueue &amp;amp;q, &lt;span&gt;int&lt;/span&gt; e) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到双端队列的端口处的元素，并不修改指针头和尾，只是简单的输出而已&lt;/span&gt;
{&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1表示得到双端队列端口1的元素，2表示得到双端队列断口2的元素&lt;/span&gt;
    cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入出队端口：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    cin &lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; a;
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (a)
    {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (q.front-&amp;gt;next == NULL) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断头结点之后一个节点是否为空&lt;/span&gt;
            Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该队列为空！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        e &lt;/span&gt;= q.front-&amp;gt;next-&amp;gt;&lt;span&gt;data;
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;端口1的第一个元素是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; e &amp;lt;&amp;lt;&lt;span&gt; endl;
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (q.rear == NULL) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断最后一个结点是否为空&lt;/span&gt;
            Error(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该队列为空！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        e &lt;/span&gt;= q.rear-&amp;gt;&lt;span&gt;data;
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;端口2的第一个元素是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; e &amp;lt;&amp;lt;&lt;span&gt; endl;
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Destroy_DQueuelist(LinkDQueue &amp;amp;q)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;销毁函数&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (q.front)
    {
        q.rear &lt;/span&gt;= q.front-&amp;gt;&lt;span&gt;next;
        &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; q.front;
        q.front &lt;/span&gt;=&lt;span&gt; q.rear;
    }
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该链队列销毁成功！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; endl;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    LinkDQueue Q;
    Q &lt;/span&gt;=&lt;span&gt; Creat_DQueuelist();
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该双端队列的长度是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; Getlength_DQueuelist(Q) &amp;lt;&amp;lt;&lt;span&gt; endl;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; m = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;2&lt;/span&gt;; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入要入队的元素：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        cin &lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; n;
        En_DQueuelist(Q, n);
    }
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;入队后双端队列的长度是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; Getlength_DQueuelist(Q) &amp;lt;&amp;lt;&lt;span&gt; endl;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;2&lt;/span&gt;; j++&lt;span&gt;)
    {
        De_DQueuelist(Q, m);
    }
    cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;出队后双端队列的长度是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; Getlength_DQueuelist(Q) &amp;lt;&amp;lt;&lt;span&gt; endl;
    Print_DQueuelist(Q);
    Destroy_DQueuelist(Q);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;双向队列&lt;/span&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;h3&gt;静态查找表&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_e9e3b076-46ff-4e29-a70e-fa3b86f01ae1&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e9e3b076-46ff-4e29-a70e-fa3b86f01ae1&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e9e3b076-46ff-4e29-a70e-fa3b86f01ae1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; KeyType;

typedef  &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    KeyType  key;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;  info;
}ElemType;

typedef  &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    ElemType  &lt;/span&gt;*elem;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据元素存储空间基址，建表时&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;       length;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表的长度&lt;/span&gt;
&lt;span&gt;} SSTable;


&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;  Sq_search(SSTable ST, KeyType key) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在无序表中查找元素key，查找成功时，返回元素在表中的位置 ,否则返回0&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;ST.length;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i&amp;gt;=&lt;span&gt;1&lt;/span&gt;&amp;amp;&amp;amp;ST.elem[i].key!=key) i--&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Init_search(SSTable &amp;amp;ST,&lt;span&gt;int&lt;/span&gt; length)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化表&lt;/span&gt;
&lt;span&gt;{
    ST.length&lt;/span&gt;=&lt;span&gt;length;
    ST.elem &lt;/span&gt;= (ElemType *)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(ElemType)*(length+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Creat_search(SSTable &amp;amp;ST,&lt;span&gt;int&lt;/span&gt; length)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建表&lt;/span&gt;
&lt;span&gt;{
    ElemType &lt;/span&gt;*ptr =&lt;span&gt; ST.elem;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp =&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    ptr&lt;/span&gt;++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们将第一个元素空出来！&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (temp!=-&lt;span&gt;1&lt;/span&gt;&amp;amp;&amp;amp;(i++)&amp;lt;&lt;span&gt;length)
    {
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;temp);
        ptr&lt;/span&gt;++-&amp;gt;key=&lt;span&gt;temp;
    }
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
    SSTable table;
    Init_search(table,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
    Creat_search(table,&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已经找到位置：%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Sq_search(table, &lt;span&gt;13&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;静态查找表&lt;/span&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;h3&gt;Hash查找表 &lt;/h3&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;p&gt;&lt;span&gt;对于&lt;/span&gt;Hash，我们是怎样来处理冲突的。现在就来介绍一些经典的Hash冲突处理的方法。主要包括&lt;/p&gt;
&lt;p&gt;   ( 1）开放地址法&lt;/p&gt;
&lt;p&gt;  （2）拉链法&lt;/p&gt;
&lt;p&gt;  （3）再哈希法&lt;/p&gt;
&lt;p&gt;  （4）建立公共溢出区&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1）开放地址法&lt;/p&gt;
&lt;p&gt;    基本思想：当发生地址冲突时，按照某种方法继续探测Hash表中其它存储单元，直到找到空位置为止。描述如下&lt;/p&gt;
&lt;p&gt;    其中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1141382/201712/1141382-20171205213050284-1629930665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2）拉链法&lt;/p&gt;

&lt;p&gt;    拉链法又叫链地址法，适合处理冲突比较严重的情况。基本思想是把所有关键字为同义词的记录存储在同一个&lt;/p&gt;
&lt;p&gt;    线性链表中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3）再哈希法&lt;/p&gt;

&lt;p&gt;    再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，....，等哈希函数&lt;/p&gt;
&lt;p&gt;    计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4）建立公共溢出区&lt;/p&gt;

&lt;p&gt;    建立公共溢出区的基本思想是：假设哈希函数的值域是[1,m-1]，则设向量HashTable[0...m-1]为基本&lt;/p&gt;
&lt;p&gt;    表，每个分量存放一个记录，另外设向量OverTable[0...v]为溢出表，所有关键字和基本表中关键字为同义&lt;/p&gt;
&lt;p&gt;    词的记录，不管它们由哈希函数得到的哈希地址是什么，一旦发生冲突，都填入溢出表。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_f2c69133-8109-43fa-921b-ac7f759070eb&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f2c69133-8109-43fa-921b-ac7f759070eb&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f2c69133-8109-43fa-921b-ac7f759070eb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;

&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; N = &lt;span&gt;35&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; node
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; key;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关键字&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; len;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个节点引出的链表长度&lt;/span&gt;
    &lt;span&gt;bool&lt;/span&gt; flag;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;有数据的标志&lt;/span&gt;
    node *&lt;span&gt;next;
};

node list[N];

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Init(node list[])
{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;N; i++&lt;span&gt;)
    {
        list[i].len &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        list[i].flag &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        list[i].next &lt;/span&gt;=&lt;span&gt; NULL;
    }
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Insert(node list[], &lt;span&gt;int&lt;/span&gt; val, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; m)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; id = val %&lt;span&gt; m;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;list[id].flag)
    {
        list[id].key &lt;/span&gt;=&lt;span&gt; val;
        list[id].flag &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        node &lt;/span&gt;*p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; node();
        p&lt;/span&gt;-&amp;gt;key =&lt;span&gt; val;
        p&lt;/span&gt;-&amp;gt;next =&lt;span&gt; list[id].next;
        list[id].next &lt;/span&gt;=&lt;span&gt; p;
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出HashTable&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; Print(node list[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; m)
{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;m; i++&lt;span&gt;)
    {
        node &lt;/span&gt;*p =&lt;span&gt; list[i].next;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;list[i].flag)
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The %dth record is NULL!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The %dth record is %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i, list[i].key);
            list[i].len&lt;/span&gt;++&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(p)
            {
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&amp;gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, p-&amp;gt;&lt;span&gt;key);
                p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;next;
                list[i].len&lt;/span&gt;++&lt;span&gt;;
            }
            puts(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算平均查找长度&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt; ASL(node list[], &lt;span&gt;int&lt;/span&gt;&lt;span&gt; m)
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; ans = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;m; i++&lt;span&gt;)
        ans &lt;/span&gt;+= (list[i].len + &lt;span&gt;1&lt;/span&gt;) * list[i].len / &lt;span&gt;2.0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ans /&lt;span&gt; m;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, m;
    Init(list);
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;n, &amp;amp;&lt;span&gt;m);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;n; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; val;
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;val);
        Insert(list, val, m);
    }
    Print(list, m);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The Average Search Length is %.5lf\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ASL(list, m));
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
12 11
47 7 29 11 16 92 22 8 3 37 89 50
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Hash 处理冲突终极版（拉链）&lt;/span&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;h3&gt;数组&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;&lt;img id=&quot;code_img_closed_8fd4b000-8743-48f6-bc1f-f69aa72940a1&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8fd4b000-8743-48f6-bc1f-f69aa72940a1&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8fd4b000-8743-48f6-bc1f-f69aa72940a1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;115&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; EOF(=^Z或F6),NULL &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stdlib.h&amp;gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; atoi() &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;io.h&amp;gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; eof() &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;math.h&amp;gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; floor(),ceil(),abs() &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#include&amp;lt;process.h&amp;gt; /* exit() */&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; 函数结果状态代码 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; TRUE 1
&lt;span&gt;#define&lt;/span&gt; FALSE 0
&lt;span&gt;#define&lt;/span&gt; OK 1
&lt;span&gt;#define&lt;/span&gt; ERROR 0
&lt;span&gt;#define&lt;/span&gt; INFEASIBLE -1
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; #define OVERFLOW -2 因为在math.h中已定义OVERFLOW的值为3,故去掉此行 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Status; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Status是函数的类型,其值是函数结果状态代码，如OK等 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Boolean; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Boolean是布尔类型,其值是TRUE或FALSE &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ElemType;

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; MAX_ARRAY_DIM 8 /* 假设数组维数的最大值为8 */&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt;
{
    ElemType &lt;/span&gt;*&lt;span&gt;base&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 数组元素基址，由InitArray分配 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; dim; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 数组维数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; *bounds; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 数组维界基址，由InitArray分配 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; *constants; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 数组映象函数常量基址，由InitArray分配 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
} Array;

Status InitArray(Array &lt;/span&gt;*A,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; dim,...)
{
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 若维数dim和各维长度合法，则构造相应的数组A，并返回OK &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; elemtotal=&lt;span&gt;1&lt;/span&gt;,i; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; elemtotal是元素总值 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    va_list ap;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(dim&amp;lt;&lt;span&gt;1&lt;/span&gt;||dim&amp;gt;&lt;span&gt;MAX_ARRAY_DIM)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    (&lt;/span&gt;*A).dim=&lt;span&gt;dim;
    (&lt;/span&gt;*A).bounds=(&lt;span&gt;int&lt;/span&gt; *)&lt;span&gt;malloc&lt;/span&gt;(dim*&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!(*&lt;span&gt;A).bounds)
        exit(OVERFLOW);
    va_start(ap,dim);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;dim; ++&lt;span&gt;i)
    {
        (&lt;/span&gt;*A).bounds[i]=va_arg(ap,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((*A).bounds[i]&amp;lt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; UNDERFLOW; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 在math.h中定义为4 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        elemtotal&lt;/span&gt;*=(*&lt;span&gt;A).bounds[i];
    }
    va_end(ap);
    (&lt;/span&gt;*A).&lt;span&gt;base&lt;/span&gt;=(ElemType *)&lt;span&gt;malloc&lt;/span&gt;(elemtotal*&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(ElemType));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!(*A).&lt;span&gt;base&lt;/span&gt;&lt;span&gt;)
        exit(OVERFLOW);
    (&lt;/span&gt;*A).constants=(&lt;span&gt;int&lt;/span&gt; *)&lt;span&gt;malloc&lt;/span&gt;(dim*&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!(*&lt;span&gt;A).constants)
        exit(OVERFLOW);
    (&lt;/span&gt;*A).constants[dim-&lt;span&gt;1&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=dim-&lt;span&gt;2&lt;/span&gt;; i&amp;gt;=&lt;span&gt;0&lt;/span&gt;; --&lt;span&gt;i)
        (&lt;/span&gt;*A).constants[i]=(*A).bounds[i+&lt;span&gt;1&lt;/span&gt;]*(*A).constants[i+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}
Status DestroyArray(Array &lt;/span&gt;*&lt;span&gt;A)
{
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 销毁数组A &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;((*A).&lt;span&gt;base&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;((*A).&lt;span&gt;base&lt;/span&gt;&lt;span&gt;);
        (&lt;/span&gt;*A).&lt;span&gt;base&lt;/span&gt;=&lt;span&gt;NULL;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((*&lt;span&gt;A).bounds)
    {
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;((*&lt;span&gt;A).bounds);
        (&lt;/span&gt;*A).bounds=&lt;span&gt;NULL;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((*&lt;span&gt;A).constants)
    {
        &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;((*&lt;span&gt;A).constants);
        (&lt;/span&gt;*A).constants=&lt;span&gt;NULL;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}
Status Locate(Array A,va_list ap,&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *off) &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Value()、Assign()调用此函数 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 若ap指示的各下标值合法，则求出该元素在A中的相对地址off &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,ind;
    &lt;/span&gt;*off=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;A.dim; i++&lt;span&gt;)
    {
        ind&lt;/span&gt;=va_arg(ap,&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ind&amp;lt;&lt;span&gt;0&lt;/span&gt;||ind&amp;gt;=&lt;span&gt;A.bounds[i])
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OVERFLOW;
        &lt;/span&gt;*off+=A.constants[i]*&lt;span&gt;ind;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}
Status Value(ElemType &lt;/span&gt;*e,Array A,...) &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 在VC++中，...之前的形参不能是引用类型 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ...依次为各维的下标值，若各下标合法，则e被赋值为A的相应的元素值 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    va_list ap;
    Status result;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; off;
    va_start(ap,A);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((result=Locate(A,ap,&amp;amp;off))==OVERFLOW) &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 调用Locate() &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    &lt;/span&gt;*e=*(A.&lt;span&gt;base&lt;/span&gt;+&lt;span&gt;off);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}
Status Assign(Array &lt;/span&gt;*&lt;span&gt;A,ElemType e,...)
{
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ...依次为各维的下标值，若各下标合法，则将e的值赋给A的指定的元素 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    va_list ap;
    Status result;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; off;
    va_start(ap,e);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((result=Locate(*A,ap,&amp;amp;off))==OVERFLOW) &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 调用Locate() &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    &lt;/span&gt;*((*A).&lt;span&gt;base&lt;/span&gt;+off)=&lt;span&gt;e;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    Array A;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i,j,k,*p,dim=&lt;span&gt;3&lt;/span&gt;,bound1=&lt;span&gt;3&lt;/span&gt;,bound2=&lt;span&gt;4&lt;/span&gt;,bound3=&lt;span&gt;2&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; a[3][4][2]数组 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    ElemType e,&lt;/span&gt;*&lt;span&gt;p1;
    InitArray(&lt;/span&gt;&amp;amp;A,dim,bound1,bound2,bound3); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 构造3＊4＊2的3维数组A &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    p&lt;/span&gt;=&lt;span&gt;A.bounds;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A.bounds=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;dim; i++) &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 顺序输出A.bounds &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,*(p+&lt;span&gt;i));
    p&lt;/span&gt;=&lt;span&gt;A.constants;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nA.constants=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;dim; i++) &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 顺序输出A.constants &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,*(p+&lt;span&gt;i));
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n%d页%d行%d列矩阵元素如下:\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,bound1,bound2,bound3);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;bound1; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;; j&amp;lt;bound2; j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(k=&lt;span&gt;0&lt;/span&gt;; k&amp;lt;bound3; k++&lt;span&gt;)
            {
                Assign(&lt;/span&gt;&amp;amp;A,i*&lt;span&gt;100&lt;/span&gt;+j*&lt;span&gt;10&lt;/span&gt;+k,i,j,k); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 将i*100+j*10+k赋值给A[i][j][k] &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                Value(&lt;/span&gt;&amp;amp;e,A,i,j,k); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 将A[i][j][k]的值赋给e &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A[%d][%d][%d]=%2d &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,i,j,k,e); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 输出A[i][j][k] &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            }
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    p1&lt;/span&gt;=A.&lt;span&gt;base&lt;/span&gt;&lt;span&gt;;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A.base=\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;bound1*bound2*bound3; i++) &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 顺序输出A.base &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%4d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,*(p1+&lt;span&gt;i));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i%(bound2*bound3)==bound2*bound3-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    DestroyArray(&lt;/span&gt;&amp;amp;&lt;span&gt;A);
    system(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PAUSE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Array&lt;/span&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;h3&gt;广义表&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;广义表定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;广义表是&lt;/span&gt;n(n≥0)个元素a1，a2，…，ai，…，an的有限序列。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;①ai--或者是原子或者是一个广义表。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;②广义表通常记作：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;Ls=( a1，a2，…，ai，…，an)。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;③Ls是广义表的名字，n为它的长度。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;④若ai是广义表，则称它为Ls的子表。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;①广义表通常用圆括号括起来，用逗号分隔其中的元素。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;②为了区分原子和广义表，书写时用大写字母表示广义表，用小写字母表示原子。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;③若广义表Ls非空(n≥1)，则al是LS的表头，其余元素组成的表(a1，a2，…，an)称为Ls的表尾。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;④广义表是递归定义的&lt;/p&gt;


&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1）广义表常用表示&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;① E=()&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;E是一个空表，其长度为0。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;② L=(a，b)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;L是长度为2的广义表，它的两个元素都是原子，因此它是一个线性表&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;③ A=(x，L)=(x，(a，b))&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;A是长度为2的广义表，第一个元素是原子x，第二个元素是子表L。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;④ B=(A，y)=((x，(a，b))，y)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;B是长度为2的广义表，第一个元素是子表A，第二个元素是原子y。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;⑤ C=(A，B)=((x，(a，b))，((x，(a，b))，y))&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;C的长度为2，两个元素都是子表。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;⑥ D=(a，D)=(a，(a，(a，(…))))&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;D的长度为2，第一个元素是原子，第二个元素是D自身，展开后它是一个无限的广义表。&lt;/p&gt;



&lt;p&gt;&lt;span&gt;【例】表&lt;/span&gt;L、A、B、C的深度为分别为1、2、3、4，表D的深度为∞。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3）带名字的广义表表示&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果规定任何表都是有名字的，为了既表明每个表的名字，又说明它的组成，则可以在每个表的前面冠以该表的名字，于是上例中的各表又可以写成：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;①E()&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;②L(a，b)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;③A(x，L(a，b))&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;④B(A(x，L(a，b))，y)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;⑤C(A(x，l(a，b))，B(A(x，L(a，b))，y))&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;⑥D(a，D(a，D(…)))&lt;/p&gt;


&lt;p&gt;&lt;span&gt;广义表长度是数第一层括号内的逗号数目可以看到&lt;/span&gt;,只有一个元素,&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就是&lt;/span&gt;((a,b,(),c),d),e,((f),g)，所以长度是1，深度是数括号数目,深度是4。&lt;/p&gt;

&lt;p&gt;//21:39:55&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt; 串&lt;/h3&gt;

&lt;p&gt;主要是kmp算法&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如何计算next 数组：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;next数组下标从1开始计算&lt;/p&gt;
&lt;p&gt;next[1] 肯定是 0 &lt;/p&gt;
&lt;p&gt;next[2] 肯定是 1&lt;/p&gt;
&lt;p&gt;next[n] 的情况，将前面n-1个字符，计算从首尾开始组成最大的相同子串的长度，如果找到，那么next值是该长度加1，否则next值是1。&lt;/p&gt;
&lt;p&gt;KMP算法的部分匹配值问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;－　&lt;/span&gt;&quot;a&quot;的前缀和后缀都为空集，共有元素的长度为0；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;－　&lt;/span&gt;&quot;ab&quot;的前缀为[A]，后缀为[B]，共有元素的长度为0；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;－　&lt;/span&gt;&quot;aba&quot;的前缀为[a, ab]，后缀为[ba, a]，共有元素的长度1；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;－　&lt;/span&gt;&quot;abab&quot;的前缀为[a, ab, aba]，后缀为[bab, ab, b]，共有元素的长度为2；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;－　&lt;/span&gt;&quot;ababa&quot;的前缀为[a, ab, aba, abab]，后缀为[baba, aba, ba, a]，共有元素为&quot;aba&quot;，长度为3； &lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_1814f578-51c3-4b37-90a4-2b69e0622048&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1814f578-51c3-4b37-90a4-2b69e0622048&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1814f578-51c3-4b37-90a4-2b69e0622048&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; getnext(&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;s)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;,j=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    next[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;]=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; len=&lt;span&gt;strlen(s);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(i&amp;lt;&lt;span&gt;len)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(s[i]==s[j]||j==-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            i&lt;/span&gt;++&lt;span&gt;;
            j&lt;/span&gt;++&lt;span&gt;;
            next[i]&lt;/span&gt;=&lt;span&gt;j;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            j&lt;/span&gt;=&lt;span&gt;next[j];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;next&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;计算next 的值，同时，也能用于修正next值的数据nextval 求解：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;求&lt;/span&gt;nextval数组值有两种方法，一种是不依赖next数组值直接用观察法求&lt;span&gt;得，一种方法是根据&lt;/span&gt;next数组值进行推理，两种方法均可使用，视更喜欢哪种方法而定。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文主要分析&lt;/span&gt;nextval数组值的第二种方法：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　模式串&lt;/span&gt;  a b a a b c a c&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;next值  0 1 1 2 2 3 1 2&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;nextval值 0 1 0 2 1 3 0 2&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;1.第一位的nextval值必定为0，第二位如果于第一位相同则为0，如果不同则为1。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;2.第三位的next值为1，那么将第三位和第一位进行比较，均为a，相同，则，第三位的nextval值为0。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;3.第四位的next值为2，那么将第四位和第二位进行比较，不同，则第四位的nextval值为其next值，为2。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;4.第五位的next值为2，那么将第五位和第二位进行比较，相同，第二位的next值为1，则继续将第二位与第一位进行比较，不同，则第五位的nextval值为第二位的next值，为1。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;5.第六位的next值为3，那么将第六位和第三位进行比较，不同，则第六位的nextval值为其next值，为3。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;6.第七位的next值为1，那么将第七位和第一位进行比较，相同，则第七位的nextval值为0。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;7.第八位的next值为2，那么将第八位和第二位进行比较，不同，则第八位的nextval值为其next值，为2。&lt;/p&gt;

&lt;p&gt;KMP算法建立在next数组的基础上，计算str 在 s 中出现的次数 合并在main 函数里的getnext &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_9873c9ed-02d6-4355-927d-d170c47720a0&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9873c9ed-02d6-4355-927d-d170c47720a0&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9873c9ed-02d6-4355-927d-d170c47720a0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
#include &amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;KMP 算法&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; N;
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn = &lt;span&gt;10010&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nex[maxn];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
 {
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;N);
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; s,str;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(N--&lt;span&gt;)
    {
        memset(nex,&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(nex));
        cin&lt;/span&gt;&amp;gt;&amp;gt;str&amp;gt;&amp;gt;&lt;span&gt;s;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; _len =&lt;span&gt; str.length();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;  len =&lt;span&gt; s.length();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j=-&lt;span&gt;1&lt;/span&gt;,i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(i&amp;lt;&lt;span&gt;_len)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(j==-&lt;span&gt;1&lt;/span&gt;||str[i]==str[j]) nex[++i]=++&lt;span&gt;j;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; j=&lt;span&gt;nex[j];
        }
        i&lt;/span&gt;=j=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ans =&lt;span&gt;0&lt;/span&gt;&lt;span&gt; ;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(i&amp;lt;&lt;span&gt;len)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(j==-&lt;span&gt;1&lt;/span&gt;||s[i]==str[j]) ++i,++&lt;span&gt;j;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; j=&lt;span&gt;nex[j];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(j ==&lt;span&gt; _len)
                ans&lt;/span&gt;++&lt;span&gt;;
        }
        cout&lt;/span&gt;&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;&lt;span&gt;endl;

    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;KMP CodeA&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 如果想了解更多关于KMP算法的应用&lt;/span&gt;--------------&amp;gt; &lt;a href=&quot;http://note.youdao.com/noteshare?id=09b401b46c6177c657211555c4e8e629&quot; target=&quot;_blank&quot;&gt;Link&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;h3&gt;Manacher 最长回文子串&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_22f2eec1-4151-4e1b-9a1a-9e893009a61a&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_22f2eec1-4151-4e1b-9a1a-9e893009a61a&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_22f2eec1-4151-4e1b-9a1a-9e893009a61a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
#include &amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn = &lt;span&gt;1000010&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; s[maxn];
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; s_new[maxn*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mac[maxn*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Manacher() &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求解最长回文子串&lt;/span&gt;
&lt;span&gt;{
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,s);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; l = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    s_new[l&lt;/span&gt;++] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; 
    s_new[l&lt;/span&gt;++] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;现在匹配串开始填充两个不同的特殊字符&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; strlen(s);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;len;i++) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然后遍历原来的串，隔一个位置，插入一个 ‘#’&lt;/span&gt;
&lt;span&gt;    {
        s_new[l&lt;/span&gt;++] =&lt;span&gt; s[i];
        s_new[l&lt;/span&gt;++] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
    }
    s_new[l] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;匹配串末尾设置为 0 &lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; mx = &lt;span&gt;0&lt;/span&gt;,id=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;l;i++) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; mac 匹配数组&lt;/span&gt;
&lt;span&gt;    {
        mac[i] &lt;/span&gt;= mx&amp;gt;i?min(mac[&lt;span&gt;2&lt;/span&gt;*id-&lt;span&gt;1&lt;/span&gt;],mx-i):&lt;span&gt;1&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 确定比较的位置&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(s_new[i+mac[i]]==s_new[i-&lt;span&gt;mac[i]])
            mac[i]&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i+mac[i]&amp;gt;&lt;span&gt;mx)
        {
            mx &lt;/span&gt;= i +&lt;span&gt; mac[i];
            id &lt;/span&gt;=&lt;span&gt; i;
        }
    }
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ans = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;2&lt;/span&gt;*len+&lt;span&gt;2&lt;/span&gt;;i++) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到 mac里面的最大值，这个值 -1 就是最长回文子串的长度&lt;/span&gt;
        ans = max(ans,mac[i]-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,ans);
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;k);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(k--&lt;span&gt;)
    Manacher();
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
3
abababa
aaaabaa
acacdas
7
5
3

&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;回文子串算法O(n)&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;18:35:17&lt;/p&gt;

&lt;hr/&gt;

&lt;hr/&gt;
&lt;h2&gt;二叉树&lt;/h2&gt;
&lt;hr/&gt;&lt;h3&gt;二叉树&lt;/h3&gt;
&lt;p&gt;顺序存储：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; node{
    datatype data;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; lchild,rchild;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; parent;
}Node;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;链式存储：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; BinNode{
    datatype data;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; BinNode*&lt;span&gt; lchild;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; BinNode*&lt;span&gt; rchild;
}BinNode;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h3&gt;二叉树的建立&lt;/h3&gt;
&lt;p&gt;根据前序遍历生成树（链式存储）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_a2224358-c6ff-4256-afbf-9aaf400e6bd6&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a2224358-c6ff-4256-afbf-9aaf400e6bd6&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a2224358-c6ff-4256-afbf-9aaf400e6bd6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; createtree(bintree *&lt;span&gt;t){      
    datatype c;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;((c=getchar()) == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;*t =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;*t = (bintree)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(BinNode));
        (&lt;/span&gt;*t)-&amp;gt;data =&lt;span&gt; c;
        createtree(&lt;/span&gt;&amp;amp;(*t)-&amp;gt;&lt;span&gt;lchild);
        createtree(&lt;/span&gt;&amp;amp;(*t)-&amp;gt;&lt;span&gt;rchild);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;createtree&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;要用数组生成的话，直接在函数里面加入一个参数引用代替getchar() 就好。&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;二叉树的遍历&lt;/h3&gt;
&lt;p&gt;采取结构链式存储&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;char&lt;/span&gt;&lt;span&gt; datatype;

typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; BinNode{
    datatype data;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; BinNode*&lt;span&gt; lchild;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; BinNode*&lt;span&gt; rchild;
}BinNode;

typedef BinNode&lt;/span&gt;* bintree;  
&lt;/pre&gt;&lt;/div&gt;
&lt;pre data-source-line=&quot;5&quot;&gt;
&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;code&gt;中序遍历&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;code&gt; ：左根右&lt;/code&gt;&lt;/span&gt;&lt;span&gt;&lt;code&gt;
后序遍历&lt;/code&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;code&gt; ：左右根
前序遍历 ：根左右&lt;br/&gt;&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;code&gt;&lt;span&gt;递归型遍历：&lt;/span&gt;&lt;span&gt;前序遍历&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt; 前序遍历 / 其他的只是输出的位置稍有不同&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; preorder(bintree t){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(t){
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,t-&amp;gt;&lt;span&gt;data); //根
        preorder(t&lt;/span&gt;-&amp;gt;&lt;span&gt;lchild);//左
        preorder(t&lt;/span&gt;-&amp;gt;&lt;span&gt;rchild);//右
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;h3&gt; 非递归型遍历&lt;/h3&gt;
&lt;p&gt;需要进行预处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_fcd37312-2240-4d00-a367-67ae7a5d53eb&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fcd37312-2240-4d00-a367-67ae7a5d53eb&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fcd37312-2240-4d00-a367-67ae7a5d53eb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; SIZE 100&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; seqstack{
    bintree data[SIZE];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tag[SIZE];   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为后续遍历准备的&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; top;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;top为数组的下标&lt;/span&gt;
&lt;span&gt;}seqstack;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; push(seqstack *&lt;span&gt;s,bintree t){

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(s-&amp;gt;top ==&lt;span&gt; SIZE){
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the stack is full\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        s&lt;/span&gt;-&amp;gt;top++&lt;span&gt;;
        s&lt;/span&gt;-&amp;gt;data[s-&amp;gt;top]=&lt;span&gt;t;
    }
}

bintree pop(seqstack &lt;/span&gt;*&lt;span&gt;s){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(s-&amp;gt;top == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        s&lt;/span&gt;-&amp;gt;top--&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; s-&amp;gt;data[s-&amp;gt;top+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;预处理&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;前序遍历&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_13e7e76b-0027-4af1-a136-4c305b54a17c&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_13e7e76b-0027-4af1-a136-4c305b54a17c&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_13e7e76b-0027-4af1-a136-4c305b54a17c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; preorder_dev(bintree t){
    seqstack s;
    s.top &lt;/span&gt;= -&lt;span&gt;1&lt;/span&gt;;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为top在这里表示了数组中的位置，所以空为-1&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;t){
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the tree is empty\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(t || s.stop != -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(t){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只要结点不为空就应该入栈保存，与其左右结点无关    &lt;/span&gt;
                  printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,t-&amp;gt;&lt;span&gt;data);
                push(&lt;/span&gt;&amp;amp;&lt;span&gt;s,t);
                t&lt;/span&gt;= t-&amp;gt;&lt;span&gt;lchild;
            }
            t&lt;/span&gt;=pop(&amp;amp;&lt;span&gt;s);
            t&lt;/span&gt;=t-&amp;gt;&lt;span&gt;rchild;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;非递归前序遍历&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;中序遍历&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_46d04588-62d8-4ec1-99b9-610c3fcf57e9&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_46d04588-62d8-4ec1-99b9-610c3fcf57e9&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_46d04588-62d8-4ec1-99b9-610c3fcf57e9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; midorder(bintree t){
    seqstack s;
    s.top &lt;/span&gt;= -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;t){
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the tree is empty!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(t ||s.top != -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(t){
                push(&lt;/span&gt;&amp;amp;&lt;span&gt;s,t);
                t&lt;/span&gt;= t-&amp;gt;&lt;span&gt;lchild;
            }
            t&lt;/span&gt;=pop(&amp;amp;&lt;span&gt;s);
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,t-&amp;gt;&lt;span&gt;data);
            t&lt;/span&gt;=t-&amp;gt;&lt;span&gt;rchild;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;非递归中序遍历&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;后序遍历&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_b5635add-adbf-4ee0-9698-4616bff72342&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b5635add-adbf-4ee0-9698-4616bff72342&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b5635add-adbf-4ee0-9698-4616bff72342&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; postorder_dev(bintree t){
    seqstack s;
    s.top &lt;/span&gt;= -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;t){
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the tree is empty!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(t || s.top != -&lt;span&gt;1&lt;/span&gt;){    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;栈空了的同时t也为空。&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt;&lt;span&gt;(t){
                push(&lt;/span&gt;&amp;amp;&lt;span&gt;s,t);
                s.tag[s.top] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置访问标记，0为第一次访问，1为第二次访问&lt;/span&gt;
                t= t-&amp;gt;&lt;span&gt;lchild;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(s.tag[s.top] == &lt;span&gt;0&lt;/span&gt;){  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次访问时，转向同层右结点&lt;/span&gt;
                t= s.data[s.top];   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左走到底时t是为空的，必须有这步！&lt;/span&gt;
                s.tag[s.top]=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;     
                t&lt;/span&gt;=t-&amp;gt;&lt;span&gt;rchild;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (s.tag[s.top] == &lt;span&gt;1&lt;/span&gt;){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;找到栈中下一个第一次访问的结点，退出循环时并没有pop所以为其左子结点&lt;/span&gt;
                    t = pop(&amp;amp;&lt;span&gt;s);
                    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,t-&amp;gt;&lt;span&gt;data);
                }
                t &lt;/span&gt;= NULL; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须将t置空。跳过向左走，直接向右走&lt;/span&gt;
&lt;span&gt;            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;非递归后序遍历&lt;/span&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;h3&gt;二叉树的查找&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_96e001c1-ea45-4905-acbe-bd13bd289769&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_96e001c1-ea45-4905-acbe-bd13bd289769&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_96e001c1-ea45-4905-acbe-bd13bd289769&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt; InsetBST(BiTree &amp;amp;T,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k)
 {
     BitNode&lt;/span&gt;*&lt;span&gt; p;
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;SearchBST(T,k,NULL,p))
     {   BitNode &lt;/span&gt;* temp=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BitNode;
         temp&lt;/span&gt;-&amp;gt;data=&lt;span&gt;k;
         temp&lt;/span&gt;-&amp;gt;lchild=temp-&amp;gt;rchild=&lt;span&gt;NULL;
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!p)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有树为空时，此时的p才为NULL。看到这里应该明白SearchBST(T,k,pre,p)这些参数的意义了吧&lt;/span&gt;
&lt;span&gt;         {
           T&lt;/span&gt;=&lt;span&gt;temp; 
         }
         &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
         {
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(k&amp;lt;p-&amp;gt;data)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不为空树，加入的key值就和p相比较，小于就是他的左孩子，否子为右孩子&lt;/span&gt;
                 p-&amp;gt;lchild=&lt;span&gt;temp;
             &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
             {
                 p&lt;/span&gt;-&amp;gt;rchild=&lt;span&gt;temp;
             }
         }
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
     }
     &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
     {
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
     }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;查找树元素插入&lt;/span&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_a04a5ac5-2be0-4934-8f68-185d5f5ecba4&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a04a5ac5-2be0-4934-8f68-185d5f5ecba4&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a04a5ac5-2be0-4934-8f68-185d5f5ecba4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bintree search_tree(bintree t,datatype x){  
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;t){  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;  
    }  
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t-&amp;gt;data ==&lt;span&gt; x){  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;  
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{  
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!search_tree(t-&amp;gt;&lt;span&gt;lchild,x)){  
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; search_tree(t-&amp;gt;&lt;span&gt;rchild,x);  
        }  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;  
    }  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;二叉树的查找&lt;/span&gt;&lt;/div&gt;


&lt;hr/&gt;
&lt;h3&gt;二叉树深度&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_1e6fcec7-7a22-41c3-8779-af2aa819a324&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1e6fcec7-7a22-41c3-8779-af2aa819a324&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1e6fcec7-7a22-41c3-8779-af2aa819a324&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hight_tree(bintree t){  
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h,left,right;  
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;t){  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
    }  
    left &lt;/span&gt;= hight_tree(t-&amp;gt;&lt;span&gt;lchild);  
    right &lt;/span&gt;= hight_tree(t-&amp;gt;&lt;span&gt;rchild);  
    h &lt;/span&gt;= (left&amp;gt;right?left:right)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;  
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; h;  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;二叉树深度&lt;/span&gt;&lt;/div&gt;

&lt;hr/&gt;
&lt;h3&gt;二叉树节点个数&lt;/h3&gt;
&lt;p data-source-line=&quot;1&quot;&gt;n0：度为0的结点数，n1:度为1的结点 n2：度为2的结点数。 N是总结点。&lt;/p&gt;
&lt;p data-source-line=&quot;3&quot;&gt;在二叉树中：&lt;/p&gt;
&lt;p data-source-line=&quot;5&quot;&gt;n0=n2+1；&lt;/p&gt;
&lt;p data-source-line=&quot;7&quot;&gt;N=n0+n1+n2&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_67533663-4d27-4b19-8066-8b8b60da20d4&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_67533663-4d27-4b19-8066-8b8b60da20d4&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_67533663-4d27-4b19-8066-8b8b60da20d4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count_tree(bintree t){  
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(t){  
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (count_tree(t-&amp;gt;lchild)+count_tree(t-&amp;gt;rchild)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);  
    }  
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;二叉树节点个数&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_32248898-1a15-4d83-926e-5f58c4cef815&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_32248898-1a15-4d83-926e-5f58c4cef815&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_32248898-1a15-4d83-926e-5f58c4cef815&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; leaf(BiTree root)　　
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; leaf_count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (NULL !=&lt;span&gt; root)
    {
        　　leaf(root&lt;/span&gt;-&amp;gt;&lt;span&gt;lchild);
        　　leaf(root&lt;/span&gt;-&amp;gt;&lt;span&gt;rchild);
        　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (root-&amp;gt;lchild ==&lt;span&gt; NULL
        　　&lt;/span&gt;&amp;amp;&amp;amp; root-&amp;gt;rchild ==&lt;span&gt; NULL)
            　　leaf_count&lt;/span&gt;++&lt;span&gt;;
        　　
    }
    　　&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; leaf_count;　　
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;叶子节点个数&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 优化AVL树：&lt;/p&gt;
&lt;p&gt;//TODO 22:07:35&lt;/p&gt;
&lt;p&gt;.&lt;span&gt;高度为 h 的 AVL 树，节点数 N 最多2^h − 1； 最少N(h)=N(h− 1) +N(h− 2) + 1。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h3&gt;二叉树的种类&lt;/h3&gt;
&lt;p&gt;含有 n 个节点,不相似的二叉树 有 : &lt;span&gt;1/(n+1)*C(n,2n)种；&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; 树&lt;/h2&gt;
&lt;hr/&gt;&lt;h3&gt; 树的知识点&lt;/h3&gt;
&lt;p&gt;树状图是一种数据结构，它是由n（n&amp;gt;=1）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：&lt;/p&gt;
&lt;p&gt;每个节点有零个或多个子节点；没有父节点的节点称为根节点；每一个非根节点有且只有一个父节点；除了根节点外，每个子节点可以分为多个不相交的子树；&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;84.147518189167&quot;&gt;
&lt;ul&gt;&lt;li class=&quot;para&quot;&gt;&lt;span&gt;节点的度：一个节点含有的子树的个数称为该节点的度；&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;&lt;span&gt;叶节点或终端节点：度为0的节点称为叶节点；&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;&lt;span&gt;非终端节点或分支节点：度不为0的节点；&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;&lt;span&gt;双亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;&lt;span&gt;孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点；&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;&lt;span&gt;兄弟节点：具有相同父节点的节点互称为兄弟节点；&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;&lt;span&gt;树的度：一棵树中，最大的节点的度称为树的度；&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;&lt;span&gt;节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;&lt;span&gt;树的高度或深度：树中节点的最大层次；&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;&lt;span&gt;堂兄弟节点：双亲在同一层的节点互为堂兄弟；&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;&lt;span&gt;节点的祖先：从根到该节点所经分支上的所有节点；&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;&lt;span&gt;子孙：以某节点为根的子树中任一节点都称为该节点的子孙。&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;para&quot;&gt;&lt;span&gt;森林：由m（m&amp;gt;=0）棵互不相交的树的集合称为森林；&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;div class=&quot;para-title level-2&quot; readability=&quot;184.20290581162&quot;&gt; 
&lt;p&gt;&lt;strong&gt;&lt;span&gt;树、森林与二叉树的转换&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;、树转换为二叉树&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于二叉树是有序的，为了避免混淆，对于无序树，我们约定树中的每个结点的孩子结点按从左到右的顺序进行编号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将树转换成二叉树的步骤是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）加线。就是在所有兄弟结点之间加一条连线；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）抹线。就是对树中的每个结点，只保留他与第一个孩子结点之间的连线，删除它与其它孩子结点之间的连线；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）旋转。就是以树的根结点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1141382/201712/1141382-20171205220854331-1690483774.png&quot; alt=&quot;&quot; width=&quot;627&quot; height=&quot;456&quot;/&gt;&lt;/p&gt;


&lt;p align=&quot;center&quot;&gt;&lt;span&gt;树转换为二叉树的过程示意图&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;2&lt;span&gt;、森林转换为二叉树&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;森林是由若干棵树组成，可以将森林中的每棵树的根结点看作是兄弟，由于每棵树都可以转换为二叉树，所以森林也可以转换为二叉树。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将森林转换为二叉树的步骤是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）先把每棵树转换为二叉树；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子结点，用线连接起来。当所有的二叉树连接起来后得到的二叉树就是由森林转换得到的二叉树。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1141382/201712/1141382-20171205220936847-521352812.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;span&gt;森林转换为二叉树的转换过程示意图&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;3&lt;span&gt;、二叉树转换为树&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二叉树转换为树是树转换为二叉树的逆过程，其步骤是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）若某结点的左孩子结点存在，将左孩子结点的右孩子结点、右孩子结点的右孩子结点&lt;/span&gt;&lt;span&gt;……&lt;/span&gt;&lt;span&gt;都作为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）删除原二叉树中所有结点与其右孩子结点的连线；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）整理（&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;）和（&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）两步得到的树，使之结构层次分明。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1141382/201712/1141382-20171205220957097-401248555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;二叉树转换为树的过程示意图&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;4&lt;span&gt;、二叉树转换为森林&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二叉树转换为森林比较简单，其步骤如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）先把每个结点与右孩子结点的连线删除，得到分离的二叉树；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）把分离后的每棵二叉树转换为树；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）整理第（&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;）步得到的树，使之规范，这样得到森林。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据树与二叉树的转换关系以及二叉树的遍历定义可以推知，树的先序遍历与其转换的相应的二叉树的先序遍历的结果序列相同；树的后序遍历与其转换的二叉树的中序遍历的结果序列相同；树的层序遍历与其转换的二叉树的后序遍历的结果序列相同。由森林与二叉树的转换关系以及森林与二叉树的遍历定义可知，森林的先序遍历和中序遍历与所转换得到的二叉树的先序遍历和中序遍历的结果序列相同。&lt;/span&gt;&lt;/p&gt;


&lt;hr/&gt;

&lt;hr/&gt;
&lt;h3&gt;图的存储结构&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;设图中&lt;/span&gt; &lt;span&gt;节点数&lt;/span&gt; n ， 边数 m&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果用邻接矩阵存储图：空间复杂度&lt;/span&gt; O(n^2)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;邻接表存储图&lt;/span&gt; &lt;span&gt;：&lt;/span&gt; &lt;span&gt;空间复杂度&lt;/span&gt; O(n+m)&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://note.youdao.com/noteshare?id=8d6a28cba6182fbf8563fac54d8e13e5&amp;amp;sub=9D56E78D10304E8CAF4CBEE6946E75D1&quot; target=&quot;_blank&quot;&gt;邻接表： 详细解释&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_706022b7-434e-4ce6-afa7-1316099b8dc0&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_706022b7-434e-4ce6-afa7-1316099b8dc0&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_706022b7-434e-4ce6-afa7-1316099b8dc0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
#include&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt;int&lt;/span&gt; head[&lt;span&gt;100100&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表头，head[i]代表起点是i的边的编号&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; cnt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;代表边的编号&lt;/span&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; s
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; u;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录边的起点&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; v;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录边的终点&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; w;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录边的权值&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; next;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向上一条边的编号&lt;/span&gt;
}edge[&lt;span&gt;100010&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt; u,&lt;span&gt;int&lt;/span&gt; v,&lt;span&gt;int&lt;/span&gt; w)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向所要连接的表中加入边&lt;/span&gt;
&lt;span&gt;{
    edge[cnt].u&lt;/span&gt;=&lt;span&gt;u;
    edge[cnt].v&lt;/span&gt;=&lt;span&gt;v;
    edge[cnt].w&lt;/span&gt;=&lt;span&gt;w;
    edge[cnt].next&lt;/span&gt;=&lt;span&gt;head[u];
    head[u]&lt;/span&gt;=cnt++&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n)!=&lt;span&gt;EOF)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
        cnt&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        memset(head,&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;(head));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空表头数组&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; u,v,w;
            scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;u,&amp;amp;v,&amp;amp;&lt;span&gt;w);
            add(u,v,w);
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; u,v,w;
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;u);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=head[u];i!=-&lt;span&gt;1&lt;/span&gt;;i=edge[i].next)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出所有与起点为u相连的边的终点和权值&lt;/span&gt;
&lt;span&gt;        {
             v&lt;/span&gt;=&lt;span&gt;edge[i].v;
             w&lt;/span&gt;=&lt;span&gt;edge[i].w;
             printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,v,w);
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;邻接表存储代码&lt;/span&gt;&lt;/div&gt;


&lt;p&gt; 邻接矩阵：二维数组&lt;/p&gt;

&lt;h3&gt;&lt;a href=&quot;http://note.youdao.com/noteshare?id=5b22142fd5b9f13e19c22c9024021fea&amp;amp;sub=wcp1511172454232571&quot; target=&quot;_blank&quot;&gt;矩阵的压缩存储&lt;/a&gt;&lt;/h3&gt;

&lt;hr/&gt;

&lt;h3&gt;拓扑排序&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;由&lt;/span&gt;AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步，直到不存在入度为0的顶点为止。&lt;/p&gt;
&lt;p&gt;(1) 选择一个入度为0的顶点并输出之；&lt;/p&gt;
&lt;p&gt;(2) 从网中删除此顶点及所有出边。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;循环结束后，若输出的顶点数小于网中的顶点数，则输出&lt;/span&gt;“有回路”信息，否则输出的顶点序列就是一种拓扑序列。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_69aac945-c1db-487f-bdac-45916586e8b2&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_69aac945-c1db-487f-bdac-45916586e8b2&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_69aac945-c1db-487f-bdac-45916586e8b2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
#include &amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; maxn 100&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以根据题目条件进行更改&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; edge[maxn][maxn];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; book[maxn];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; point_num;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; edge_num;
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; check_point(&lt;span&gt;int&lt;/span&gt; v)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确定这个点是不是没有入度；&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=point_num;i++&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(edge[i][v]==&lt;span&gt;1&lt;/span&gt;&amp;amp;&amp;amp;(i!=v))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果有入度，返回false,i==v时没有啥实际意义&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; del_edge(&lt;span&gt;int&lt;/span&gt; v)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除以这个点为起始点的所有边&lt;/span&gt;
&lt;span&gt;{
    fill(edge[v],edge[v]&lt;/span&gt;+point_num,&lt;span&gt;0&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;fill灵活用法，用for循环效果一样，时间复杂度相同&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    memset(book,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(book));
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;point_num);
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;edge_num);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;点的个数，边的个数，设为宏观变量，比较好操作&lt;/span&gt;
    memset(edge,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(edge));
     
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=edge_num;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; s_point,e_point;
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;s_point,&amp;amp;&lt;span&gt;e_point);
        edge[s_point][e_point]&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面循环代码肯定是能优化的，不过我一时半会想不起来，欢迎留言，私信我&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(;i&amp;lt;=point_num;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(check_point(i)&amp;amp;&amp;amp;book[i]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        {
            book[i]&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            cout&lt;/span&gt;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            del_edge(i);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除bian&lt;/span&gt;
            i=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=point_num;i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(book[i]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            cout&lt;/span&gt;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&lt;span&gt;endl;
    }&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;扫尾工作，最后可能会留下一个点；输出格式自己搞！&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Topo&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 拓扑排序题目，以及拓扑代码优化----------------------&amp;gt; &lt;a href=&quot;http://note.youdao.com/noteshare?id=9132efb63fe8fa878510b902ecbcdcc9&amp;amp;sub=DB1F3321022D4968AFFFE50AA3DD5C57&quot; target=&quot;_blank&quot;&gt;Link&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据拓扑排序实现关键路径：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://note.youdao.com/noteshare?id=7b36fe793e5c7db6ecb761b0271dea3d&amp;amp;sub=wcp151122605341465&quot; target=&quot;_blank&quot;&gt;AOE网关键路径的算法&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;&lt;img id=&quot;code_img_closed_5fa391fe-0675-478a-bad6-4e218c2d38ff&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5fa391fe-0675-478a-bad6-4e218c2d38ff&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5fa391fe-0675-478a-bad6-4e218c2d38ff&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;83&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; ArcNode  
{  
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; adjvex;                                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该弧指向的顶点位置  &lt;/span&gt;
       &lt;span&gt;struct&lt;/span&gt; ArcNode * nextarc;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向下一个表结点  &lt;/span&gt;
       &lt;span&gt;int&lt;/span&gt; info;                                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;权值信息  &lt;/span&gt;
}ArcNode;                                              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;边结点类型&lt;/span&gt;
Status TopologicalOrder(ALGraph G, Stack &amp;amp;&lt;span&gt;T) 
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有向网G采用邻接表存储结构，求各顶点事件的最早发生时间ve(全局变量)。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; T为拓扑序列定点栈，S为零入度顶点栈。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若G无回路，则用栈T返回G的一个拓扑序列，且函数值为OK，否则为ERROR。&lt;/span&gt;
&lt;span&gt;    Stack S;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,k;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; indegree[&lt;span&gt;40&lt;/span&gt;&lt;span&gt;];
    ArcNode &lt;/span&gt;*&lt;span&gt;p;
    InitStack(S);
    FindInDegree(G, indegree);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对各顶点求入度indegree[0..vernum-1]&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;; j&amp;lt;G.vexnum; ++j)     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 建零入度顶点栈S&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (indegree[j]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;) 
            Push(S, j);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 入度为0者进栈&lt;/span&gt;
    InitStack(T);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建拓扑序列顶点栈T&lt;/span&gt;
    count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;G.vexnum; i++&lt;span&gt;) 
        ve[i] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;StackEmpty(S)) 
    {
        Pop(S, j);  Push(T, j);  &lt;/span&gt;++count;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; j号顶点入T栈并计数&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (p=G.vertices[j].firstarc;  p;  p=p-&amp;gt;&lt;span&gt;nextarc) 
        {
            k &lt;/span&gt;= p-&amp;gt;adjvex;            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对j号顶点的每个邻接点的入度减1&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (--indegree[k] == &lt;span&gt;0&lt;/span&gt;) Push(S, k);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若入度减为0，则入栈&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (ve[j]+p-&amp;gt;info &amp;gt; ve[k])  ve[k] = ve[j]+p-&amp;gt;&lt;span&gt;info;
        }&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;for  *(p-&amp;gt;info)=dut(&amp;lt;j,k&amp;gt;)&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(count&amp;lt;&lt;span&gt;G.vexnum) 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ERROR;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该有向网有回路&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}
Status CriticalPath(ALGraph G) 
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; G为有向网，输出G的各项关键活动。&lt;/span&gt;
&lt;span&gt;    Stack T;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,j,k,el,ee,dut;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; tag;
    ArcNode &lt;/span&gt;*&lt;span&gt;p;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;TopologicalOrder(G, T)) 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(a=&lt;span&gt;0&lt;/span&gt;; a&amp;lt;G.vexnum; a++&lt;span&gt;)
        vl[a] &lt;/span&gt;= ve[G.vexnum-&lt;span&gt;1&lt;/span&gt;];    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化顶点事件的最迟发生时间&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (!StackEmpty(T))       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按拓扑逆序求各顶点的vl值&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (Pop(T, j), p=G.vertices[j].firstarc;  p;  p=p-&amp;gt;&lt;span&gt;nextarc) 
        {
            k&lt;/span&gt;=p-&amp;gt;adjvex;  dut=p-&amp;gt;info;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;dut&amp;lt;j,k&amp;gt;&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (vl[k]-dut &amp;lt;&lt;span&gt; vl[j]) 
                vl[j] &lt;/span&gt;= vl[k]-&lt;span&gt;dut;
        }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (j=&lt;span&gt;0&lt;/span&gt;; j&amp;lt;G.vexnum; ++j)            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 求ee,el和关键活动&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (p=G.vertices[j].firstarc;  p;  p=p-&amp;gt;&lt;span&gt;nextarc) 
        {
            k&lt;/span&gt;=p-&amp;gt;adjvex;dut=p-&amp;gt;&lt;span&gt;info;   
            ee &lt;/span&gt;= ve[j];  el = vl[k]-&lt;span&gt;dut;
            tag &lt;/span&gt;= (ee==el) ? &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; : &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
            printf(j, k, dut, ee, el, tag);   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出关键活动&lt;/span&gt;
&lt;span&gt;        }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; OK;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;关键路径 C（Part）&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48.5&quot;&gt;&lt;img id=&quot;code_img_closed_28c848e6-ffb3-4c3e-86e8-0f0b36750a08&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_28c848e6-ffb3-4c3e-86e8-0f0b36750a08&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_28c848e6-ffb3-4c3e-86e8-0f0b36750a08&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;92&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;&lt;span&gt;  
#include &lt;/span&gt;&amp;lt;stdlib.h&amp;gt;  
&lt;span&gt;#define&lt;/span&gt; MaxVerNum 20  
   
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; visited[MaxVerNum];  
   
typedef &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; VertexType;  
   
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; ArcNode  
{  
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; adjvex;                                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该弧指向的顶点位置  &lt;/span&gt;
       &lt;span&gt;struct&lt;/span&gt; ArcNode * nextarc;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向下一个表结点  &lt;/span&gt;
       &lt;span&gt;int&lt;/span&gt; info;                                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;权值信息  &lt;/span&gt;
}ArcNode;                                              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;边结点类型  &lt;/span&gt;
&lt;span&gt;   
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; VNode  
{  
       VertexType data;  
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; indegree;  
       ArcNode &lt;/span&gt;*&lt;span&gt; firstarc;  
}VNode, Adjlist[MaxVerNum];  
   
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt;  
{  
       Adjlist vertices;            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;邻接表  &lt;/span&gt;
       &lt;span&gt;int&lt;/span&gt; vernum, arcnum;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;顶点数和弧数  &lt;/span&gt;
&lt;span&gt;}ALGraph;  
   
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找符合的数据在数组中的下标  &lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; LocateVer(ALGraph G, &lt;span&gt;char&lt;/span&gt;&lt;span&gt; u)  
{  
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;  
       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; G.vernum; i++&lt;span&gt;)  
       {  
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(u ==&lt;span&gt; G.vertices[i].data)  
                     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; i;  
       }  
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i ==&lt;span&gt; G.vernum)  
       {  
              printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error u!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
              exit(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);  
       }  
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
}  
   
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;常见图的邻接矩阵  &lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; CreateALGraph(ALGraph &amp;amp;&lt;span&gt;G)  
{  
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, j, k, w;  
       &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; v1, v2;  
       ArcNode &lt;/span&gt;*&lt;span&gt; p;  
       printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;输入顶点数和弧数: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
       scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;G.vernum, &amp;amp;&lt;span&gt;G.arcnum);  
       printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入顶点!\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; G.vernum; i++&lt;span&gt;)  
       {  
              printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入第 %d 个顶点: \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, i);  
              fflush(stdin);  
              scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;G.vertices[i].data);  
              G.vertices[i].firstarc &lt;/span&gt;=&lt;span&gt; NULL;  
              G.vertices[i].indegree &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
       }  
   
       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(k = &lt;span&gt;0&lt;/span&gt;; k &amp;lt; G.arcnum; k++&lt;span&gt;)  
       {  
              printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入弧的顶点和相应权值(v1, v2, w): \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空输入缓冲区  &lt;/span&gt;
&lt;span&gt;              fflush(stdin);  
              scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%c %c %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;v1, &amp;amp;v2, &amp;amp;&lt;span&gt;w);  
              i &lt;/span&gt;=&lt;span&gt; LocateVer(G, v1);  
              j &lt;/span&gt;=&lt;span&gt; LocateVer(G, v2);  
              p &lt;/span&gt;= (ArcNode *)&lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(ArcNode));  
              p&lt;/span&gt;-&amp;gt;adjvex =&lt;span&gt; j;  
              p&lt;/span&gt;-&amp;gt;info =&lt;span&gt; w;  
              p&lt;/span&gt;-&amp;gt;nextarc =&lt;span&gt; G.vertices[i].firstarc;  
              G.vertices[i].firstarc &lt;/span&gt;=&lt;span&gt; p;  
              G.vertices[j].indegree&lt;/span&gt;++;                   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;vi-&amp;gt;vj, vj入度加1  &lt;/span&gt;
&lt;span&gt;       }  
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;  
}  
   
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求图的关键路径函数  &lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; CriticalPath(ALGraph G)  
{  
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, k, e, l;  
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; * Ve, *&lt;span&gt; Vl;  
       ArcNode &lt;/span&gt;*&lt;span&gt; p;  
   
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;*****************************************  
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以下是求时间最早发生时间  
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;*****************************************  &lt;/span&gt;
&lt;span&gt;   
       Ve &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; [G.vernum];  
       Vl &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; [G.vernum];  
   
       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; G.vernum; i++)              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;前推  &lt;/span&gt;
              Ve[i] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;  
   
       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; G.vernum; i++&lt;span&gt;)  
       {  
              ArcNode &lt;/span&gt;* p =&lt;span&gt; G.vertices[i].firstarc;  
              &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(p !=&lt;span&gt; NULL)  
              {  
                     k &lt;/span&gt;= p-&amp;gt;&lt;span&gt;adjvex;  
                     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(Ve[i] + p-&amp;gt;info &amp;gt;&lt;span&gt; Ve[k])  
                            Ve[k] &lt;/span&gt;= Ve[i]+p-&amp;gt;&lt;span&gt;info;  
                     p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;nextarc;  
              }  
       }  
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;*****************************************  
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以下是求最迟发生时间  
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;*****************************************  &lt;/span&gt;
       &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; G.vernum; i++&lt;span&gt;)  
              Vl[i] &lt;/span&gt;= Ve[G.vernum-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];  
       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i = G.vernum-&lt;span&gt;2&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--)                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;后推  &lt;/span&gt;
&lt;span&gt;       {  
              p &lt;/span&gt;=&lt;span&gt; G.vertices[i].firstarc;  
              &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(p !=&lt;span&gt; NULL)  
              {  
                     k &lt;/span&gt;= p-&amp;gt;&lt;span&gt;adjvex;  
                     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(Vl[k] - p-&amp;gt;info &amp;lt;&lt;span&gt; Vl[i])  
                            Vl[i] &lt;/span&gt;= Vl[k] - p-&amp;gt;&lt;span&gt;info;  
                     p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;nextarc;  
              }  
       }  
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;******************************************  &lt;/span&gt;
       &lt;span&gt;for&lt;/span&gt;(i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; G.vernum; i++&lt;span&gt;)  
       {  
              p &lt;/span&gt;=&lt;span&gt; G.vertices[i].firstarc;  
              &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(p !=&lt;span&gt; NULL)  
              {  
                     k &lt;/span&gt;= p-&amp;gt;&lt;span&gt;adjvex;  
                     e &lt;/span&gt;= Ve[i];              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最早开始时间为时间vi的最早发生时间  &lt;/span&gt;
                     l = Vl[k] - p-&amp;gt;info;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最迟开始时间  &lt;/span&gt;
                     &lt;span&gt;char&lt;/span&gt; tag = (e == l) ? &lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; : &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关键活动  &lt;/span&gt;
                     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(%c, %c), e = %2d, l = %2d, %c\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, G.vertices[i].data, G.vertices[k].data, e, l, tag);  
                     p &lt;/span&gt;= p-&amp;gt;&lt;span&gt;nextarc;  
              }  
       }  
       &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; [] Ve;  
       &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; [] Vl;  
}  
   
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()  
{  
       ALGraph G;  
       printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;以下是查找图的关键路径的程序。\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);  
       CreateALGraph(G);  
       CriticalPath(G);  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;关键路径Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;&lt;img id=&quot;code_img_closed_57942175-1aee-4247-998c-065d348b4839&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_57942175-1aee-4247-998c-065d348b4839&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_57942175-1aee-4247-998c-065d348b4839&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;85&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstring&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stack&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;queue&amp;gt;
&lt;span&gt;#define&lt;/span&gt; Inf 10000000
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Renwu
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ti;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id;
}renwu[&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; cmp
{
    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;operator&lt;/span&gt;()(&lt;span&gt;struct&lt;/span&gt; Renwu t1,&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Renwu t2)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t1.a&amp;lt;&lt;span&gt;t2.a)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(t1.a==t2.a&amp;amp;&amp;amp;t1.id&amp;gt;&lt;span&gt;t2.id)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
};
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n,m,time[&lt;span&gt;105&lt;/span&gt;][&lt;span&gt;105&lt;/span&gt;],indegree[&lt;span&gt;105&lt;/span&gt;],outdegree[&lt;span&gt;105&lt;/span&gt;&lt;span&gt;];
   scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;&lt;span&gt;m);
   memset(time,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(time));
   memset(indegree,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(indegree));
   &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=m;i++&lt;span&gt;)
   {
       scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;renwu[i].a,&amp;amp;renwu[i].b,&amp;amp;&lt;span&gt;renwu[i].ti);
       time[renwu[i].a][renwu[i].b]&lt;/span&gt;=&lt;span&gt;renwu[i].ti;
       indegree[renwu[i].b]&lt;/span&gt;++&lt;span&gt;;
       outdegree[renwu[i].a]&lt;/span&gt;++&lt;span&gt;;
       renwu[i].id&lt;/span&gt;=&lt;span&gt;i;
   }
   stack&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; s;
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cnt=&lt;span&gt;0&lt;/span&gt;,ve[&lt;span&gt;105&lt;/span&gt;&lt;span&gt;];
   memset(ve,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(ve));
   &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
   {
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(indegree[i]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
       {s.push(i);
       cnt&lt;/span&gt;++&lt;span&gt;;}
   }
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; u;
   &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;s.empty())
   {
       u&lt;/span&gt;=&lt;span&gt;s.top();
       s.pop();
       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
       {
           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(time[u][i]!=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
           {
               ve[i]&lt;/span&gt;=max(ve[i],ve[u]+&lt;span&gt;time[u][i]);
               &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(--indegree[i]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
               {s.push(i);
               cnt&lt;/span&gt;++&lt;span&gt;;}
           }
       }
   }
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(cnt!=&lt;span&gt;n)
   printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
   &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
   {
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ma=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
       {
           ma&lt;/span&gt;=&lt;span&gt;max(ve[i],ma);
       }
       printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,ma);
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; vl[&lt;span&gt;105&lt;/span&gt;&lt;span&gt;];
       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
       {
           vl[i]&lt;/span&gt;=&lt;span&gt;Inf;
       }
       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
       {
           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(outdegree[i]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {vl[i]&lt;/span&gt;=&lt;span&gt;ma;
            s.push(i);}
       }
       &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;s.empty())
       {
           u&lt;/span&gt;=&lt;span&gt;s.top();
           s.pop();
           &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
           {
               &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(time[i][u]!=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
               {
                   vl[i]&lt;/span&gt;=min(vl[i],vl[u]-&lt;span&gt;time[i][u]);
                   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(--outdegree[i]==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                   s.push(i);
               }
           }
       }
      priority_queue&lt;/span&gt;&amp;lt;&lt;span&gt;struct&lt;/span&gt; Renwu,vector&amp;lt;&lt;span&gt;struct&lt;/span&gt; Renwu&amp;gt;,cmp&amp;gt;&lt;span&gt; q;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=m;i++&lt;span&gt;)
      {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ve[renwu[i].a]==vl[renwu[i].a]&amp;amp;&amp;amp;ve[renwu[i].b]==vl[renwu[i].b]&amp;amp;&amp;amp;vl[renwu[i].b]-time[renwu[i].a][renwu[i].b]==&lt;span&gt;ve[renwu[i].a])
          q.push(renwu[i]);
      }
      &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; Renwu t;
      &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;q.empty())
      {
          t&lt;/span&gt;=&lt;span&gt;q.top();
          q.pop();
          printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d-&amp;gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,t.a,t.b);
      }
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;关键路径IM&lt;/span&gt;&lt;/div&gt;
&lt;hr/&gt;

&lt;h3&gt; 图的连通性判断&lt;/h3&gt;
&lt;h4&gt; DFS判断连通性,适用于无向图和有向图&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_365a67b3-b315-499f-8ed4-beb6ba7acd38&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_365a67b3-b315-499f-8ed4-beb6ba7acd38&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_365a67b3-b315-499f-8ed4-beb6ba7acd38&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;vector&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstring&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;algorithm&amp;gt;

&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAXN=&lt;span&gt;1000002&lt;/span&gt;&lt;span&gt;;
vector&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; g[MAXN];
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; vis[MAXN];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m;
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dfs(&lt;span&gt;int&lt;/span&gt; s)              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归深搜&lt;/span&gt;
&lt;span&gt;{
    vis[s]&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;g[s].size(); ++&lt;span&gt;i)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(vis[g[s][i]]) g[s].erase(g[s].begin()+i);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除图中已经遍历过的点，可提高遍历速度&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt; dfs(g[s][i]);
    }
}

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; judge()                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否所有点已被遍历过&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;; i&amp;lt;=n; ++&lt;span&gt;i)
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;vis[i])
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(~scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;&lt;span&gt;m))
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;; i&amp;lt;=n; ++&lt;span&gt;i) g[i].clear();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;m; ++&lt;span&gt;i)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,b;
            scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;&lt;span&gt;b);
            g[a].push_back(b);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无向图转化为有向图，正反两次存入连接表。&lt;/span&gt;
&lt;span&gt;            g[b].push_back(a);
        }
        memset(vis,&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(vis));
        dfs(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(judge())
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;dfs&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt;并查集判断连通，无向图&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_fe3b7b6e-4f22-4d5e-8989-8081cb4665c8&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fe3b7b6e-4f22-4d5e-8989-8081cb4665c8&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fe3b7b6e-4f22-4d5e-8989-8081cb4665c8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstring&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cmath&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;vector&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;map&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;algorithm&amp;gt;
 
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;[&lt;span&gt;1000005&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; find(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x){
   returnx&lt;/span&gt;==&lt;span&gt;set&lt;/span&gt;[x]?x:(&lt;span&gt;set&lt;/span&gt;[x]=find(&lt;span&gt;set&lt;/span&gt;[x]));   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;递归查找集合的代表元素，含路径压缩。&lt;/span&gt;
&lt;span&gt;}
 
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m,i,x,y;
   scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;&lt;span&gt;m);
   &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;&lt;span&gt;1000005&lt;/span&gt;;++i)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化个集合，数组值等于小标的点为根节点。&lt;/span&gt;
       &lt;span&gt;set&lt;/span&gt;[i]=&lt;span&gt;i;
   &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;m;++&lt;span&gt;i){
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,b;
       scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;&lt;span&gt;b);
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; fx=find(a),fy=&lt;span&gt;find(b);
       &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;[fx]=fy;                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并有边相连的各个连通分量&lt;/span&gt;
&lt;span&gt;   }
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cnt=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;++i)          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;统计集合个数，即为连通分量个数，为一时，图联通。&lt;/span&gt;
       &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;set&lt;/span&gt;[i]==&lt;span&gt;i)
           &lt;/span&gt;++&lt;span&gt;cnt;
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(cnt==&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
       printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yes\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
   &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;并查集&lt;/span&gt;&lt;/div&gt;
&lt;h4&gt; BFS判断连通性，无向图&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_97b7cc32-df4d-406f-9521-ed4c0865a2ac&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_97b7cc32-df4d-406f-9521-ed4c0865a2ac&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_97b7cc32-df4d-406f-9521-ed4c0865a2ac&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;vector&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;queue&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;

&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxn = &lt;span&gt;1000&lt;/span&gt; + &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; my_index;

vector&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt; &amp;gt;&lt;span&gt;G[maxn];
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; vis[maxn];

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; bfs(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; u){
  queue&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt; &amp;gt;&lt;span&gt;Q;
  Q.push(u);
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;Q.empty()){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; Q.front();Q.pop();
    vis[s] &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    my_index&lt;/span&gt;++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;;i &amp;lt; G[s].size(); i++&lt;span&gt;){
      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; v =&lt;span&gt; G[s][i];
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;vis[v])Q.push(v);
    }
  }
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main(){
  scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;&lt;span&gt;m);
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;;i &amp;lt;= m; i++&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,b;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;&lt;span&gt;b);
    G[a].push_back(b);
　　　　 G[b].push_back(a);
  }
  bfs(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(my_index == n)printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yes\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;bfs&lt;/span&gt;&lt;/div&gt;

&lt;p&gt; 图的连通性解决的过程中，可以一并结局的问题是回路问题&amp;amp;&lt;a href=&quot;http://note.youdao.com/noteshare?id=b74c9cbc91d53adf58918bfe6e7a282b&amp;amp;sub=7B96806E1D3743B08E91C40A5948AD50&quot; target=&quot;_blank&quot;&gt;图的割集&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43.5&quot;&gt;&lt;img id=&quot;code_img_closed_f924e309-0a41-48d5-9b3b-9b0a2cb2285b&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_f924e309-0a41-48d5-9b3b-9b0a2cb2285b&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_f924e309-0a41-48d5-9b3b-9b0a2cb2285b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;82&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;  
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;  
  
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; L  
{  
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; v;  L *&lt;span&gt;next;  
};  
  
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HEAD  
{  
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:  
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; id; L *&lt;span&gt;next;  
    HEAD(){ id&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;;   next=&lt;span&gt;NULL;}  
};  
  
  
HEAD head[&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;];  &lt;span&gt;int&lt;/span&gt; dfn[&lt;span&gt;1000&lt;/span&gt;],low[&lt;span&gt;1000&lt;/span&gt;],t;     &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;[&lt;span&gt;1000&lt;/span&gt;],C[&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;];  
  
  
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; find(&lt;span&gt;int&lt;/span&gt; father,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v)  
{  
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count=&lt;span&gt;0&lt;/span&gt;;            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;统计v的孩子数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
    dfn[v]&lt;/span&gt;=low[v]=++t;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;将访问时间赋给dfn[v]和low[v]&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  
    &lt;span&gt;lock&lt;/span&gt;[v]=&lt;span&gt;false&lt;/span&gt;;      &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;标记v点已经访问过,不能再被访问&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  
    &lt;span&gt;for&lt;/span&gt;(L *p=head[v].next;p!=NULL;p=p-&amp;gt;&lt;span&gt;next)  
    {  
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;lock&lt;/span&gt;[p-&amp;gt;v])  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;如果v的直接后继节点没有访问过，则对其遍历&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
        {  
            find(v,p&lt;/span&gt;-&amp;gt;v);  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;对v的直接后继遍历&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
            count&lt;/span&gt;++;        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 孩子数+1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  
            &lt;span&gt;if&lt;/span&gt;(low[v]&amp;gt;low[p-&amp;gt;v])  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;如果v的孩子能追溯到更早的祖先,则v也能追溯到&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
                low[v]&lt;/span&gt;=low[p-&amp;gt;&lt;span&gt;v];  
        }  
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(p-&amp;gt;v!=father&amp;amp;&amp;amp;low[p-&amp;gt;v]&amp;lt;low[v])  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;如果v的直接孩子节点已经被访问过&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
            low[v]&lt;/span&gt;=low[p-&amp;gt;&lt;span&gt;v];  
  
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!father&amp;amp;&amp;amp;count&amp;gt;&lt;span&gt;1&lt;/span&gt;)     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;如果当前节点是DFS遍历到的第一个节点,则判断其是否有多个孩子&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
            C[v]&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;  
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(father&amp;amp;&amp;amp;dfn[v]&amp;lt;=low[p-&amp;gt;v])   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;否则判断其后继能否追溯到v的祖先&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
            C[v]&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;  
    }  
}  
  
  
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()  
{  
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,i,a,b;  
    cin&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;n;  
      
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(cin&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;amp;&amp;amp;a&amp;amp;&amp;amp;b)      &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;建立邻接表,输入无向图边每条a b,以0 0结束&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
    {  
        L &lt;/span&gt;*p=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; L;  
        p&lt;/span&gt;-&amp;gt;next=&lt;span&gt;head[b].next;  
        head[b].next&lt;/span&gt;=&lt;span&gt;p;  
        p&lt;/span&gt;-&amp;gt;v=&lt;span&gt;a;  
        p&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; L;  
        p&lt;/span&gt;-&amp;gt;next=&lt;span&gt;head[a].next;  
        head[a].next&lt;/span&gt;=&lt;span&gt;p;  
        p&lt;/span&gt;-&amp;gt;v=&lt;span&gt;b;  
        head[b].id&lt;/span&gt;++&lt;span&gt;;  
        head[a].id&lt;/span&gt;++&lt;span&gt;;  
    }  
    memset(&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;,&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;));  
    memset(dfn,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;)*&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);  
    memset(C,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;(C));  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;C数组用来标记那些点是割点,刚开始全部置为false&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
    t&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;访问时间&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;  
    find(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;);&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;开始对1号点DFS,第一个遍历的前驱节点设为0&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  
    &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++)        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;输入割点&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;  
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(C[i])  
            cout&lt;/span&gt;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;  
        cout&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;  
          
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;图的割集&lt;/span&gt;&lt;/div&gt;


&lt;hr/&gt;
&lt;h3&gt;&lt;a target=&quot;_blank&quot;&gt;欧拉回路 &lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;若图G中存在这样一条路径，使得它恰通过G中每条边一次,则称该路径为欧拉路径。若该路径是一个圈，则称为欧拉(Euler)回路。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具有欧拉回路的图称为欧拉图（简称E图）。具有欧拉路径但不具有欧拉回路的图称为半欧拉图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下判断基于此图的基图连通。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无向图存在欧拉回路的充要条件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个无向图存在欧拉回路，当且仅当该图所有顶点度数都为偶数,且该图是连通图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有向图存在欧拉回路的充要条件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个有向图存在欧拉回路，所有顶点的入度等于出度且该图是连通图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;判断欧拉路是否存在的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有向图：图连通，有一个顶点出度大入度1，有一个顶点入度大出度1，其余都是出度=入度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无向图：图连通，只有两个顶点是奇数度，其余都是偶数度的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;判断欧拉回路是否存在的方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有向图：图连通，所有的顶点出度=入度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;无向图：图连通，所有顶点都是偶数度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;程序实现一般是如下过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.利用并查集判断图是否连通，即判断p[i] &amp;lt; 0的个数，如果大于1，说明不连通。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.根据出度入度个数，判断是否满足要求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.利用dfs输出路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt; 22:45:42&lt;/p&gt;

&lt;h3&gt; 最短路算法&lt;/h3&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h4&gt;最短路算法中，最简单的，就是只有五行的Floyd：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
for(k=1; k&amp;lt;=n; k++)
    for(i=1; i&amp;lt;=n; i++)
        for(j=1; j&amp;lt;=n; j++)
            if(e[i][k]&amp;lt;inf &amp;amp;&amp;amp; e[k][j]&amp;lt;inf &amp;amp;&amp;amp; e[i][j]&amp;gt;e[i][k]+e[k][j])
                e[i][j]=e[i][k]+e[k][j];
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;Dijkstra&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40.5&quot;&gt;&lt;img id=&quot;code_img_closed_eb62c990-f3d2-44ce-9c7a-3f3a3d259ee2&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_eb62c990-f3d2-44ce-9c7a-3f3a3d259ee2&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_eb62c990-f3d2-44ce-9c7a-3f3a3d259ee2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Problem Description 
在每年的校赛里，所有进入决赛的同学都会获得一件很漂亮的t&lt;/span&gt;-&lt;span&gt;shirt。但是每当我们的工作人员把上百件的衣服从商店运回到赛场的时候，却是非常累的！所以现在他们想要寻找最短的从商店到赛场的路线，你可以帮助他们吗？

Input 
输入包括多组数据。每组数据第一行是两个整数N、M（N&lt;/span&gt;&amp;lt;=&lt;span&gt;100&lt;/span&gt;，M&amp;lt;=&lt;span&gt;10000&lt;/span&gt;），N表示成都的大街上有几个路口，标号为1的路口是商店所在地，标号为N的路口是赛场所在地，M则表示在成都有几条路。N=M=0表示输入结束。接下来M行，每行包括3个整数A，B，C（&lt;span&gt;1&lt;/span&gt;&amp;lt;=A,B&amp;lt;=N,&lt;span&gt;1&lt;/span&gt;&amp;lt;=C&amp;lt;=&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;）,表示在路口A与路口B之间有一条路，我们的工作人员需要C分钟的时间走过这条路。 
输入保证至少存在1条商店到赛场的路线。

Output 
对于每组输入，输出一行，表示工作人员从商店走到赛场的最短时间

Sample Input 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; 
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

Sample Output 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;2&lt;/span&gt;
------------------------------------------------&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stdio.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt;#define&lt;/span&gt; INF 0x3f3f3f3f
&lt;span&gt;int&lt;/span&gt; dis[&lt;span&gt;110&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dis[i]表示从起点到i的距离&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; map[&lt;span&gt;110&lt;/span&gt;][&lt;span&gt;110&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;map[i][j]表示从i到j的距离&lt;/span&gt;
&lt;span&gt;bool&lt;/span&gt; used[&lt;span&gt;110&lt;/span&gt;];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记某点是否用过&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m;
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Dijkstra(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pos=&lt;span&gt;x;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
    {
        dis[i]&lt;/span&gt;=&lt;span&gt;map[x][i];
    }
    dis[x]&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;本身到本身为0&lt;/span&gt;
    used[x]=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;=n;i++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;扫剩下的点（作为大循环）&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; min=&lt;span&gt;INF;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=n;j++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;找出当前最距离近的点&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!used[j]&amp;amp;&amp;amp;dis[j]&amp;lt;&lt;span&gt;min)
            {
                min&lt;/span&gt;=&lt;span&gt;dis[j];
                pos&lt;/span&gt;=&lt;span&gt;j;
            }
        }
        used[pos]&lt;/span&gt;=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        dis[pos]&lt;/span&gt;=&lt;span&gt;min;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=n;j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!used[j]&amp;amp;&amp;amp;dis[j]&amp;gt;dis[pos]+map[pos][j])&lt;span&gt;//&lt;/span&gt;&lt;span&gt;画个图就知道了&lt;/span&gt;
&lt;span&gt;            {
                dis[j]&lt;/span&gt;=dis[pos]+&lt;span&gt;map[pos][j];
            }
        }
    }
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;m)!=&lt;span&gt;EOF)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(n==&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;m==&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        memset(dis,INF,&lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(dis));
        memset(used,&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(used));
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=n;j++&lt;span&gt;)
            {
                map[i][j]&lt;/span&gt;=&lt;span&gt;INF;
            }
        }
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(m--&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,b,p;
            scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;b,&amp;amp;&lt;span&gt;p);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(map[a][b]&amp;gt;p)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不知道为啥必须得加这个条件，不加就wa。。&lt;/span&gt;
&lt;span&gt;            {
                map[a][b]&lt;/span&gt;=&lt;span&gt;p;
                map[b][a]&lt;/span&gt;=p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里注意点，双向都赋值&lt;/span&gt;
&lt;span&gt;            }
        }
        Dijkstra(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;起点为1&lt;/span&gt;
        printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,dis[n]);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;终点为n&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Dijkstra 单源最短路（附题目）&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;同时，对于Dj单源最短路，有一个非常简单，但是能减少不少代码量的方法： mini = dis[cur=j];&lt;/p&gt;


&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;collapse:true;;gutter:true;&quot;&gt;
void dijkstra(int s)  
{  
    memset(vis,0,sizeof(vis));         
    int cur=s;                     
    dis[cur]=0;  
    vis[cur]=1;  
    for(int i=0;i&amp;lt;n;i++)  
    {  
        for(int j=0;j&amp;lt;n;j++)                       
            if(!vis[j] &amp;amp;&amp;amp; dis[cur] + map[cur][j] &amp;lt; dis[j])   //未被标记且比已知的短，可更新   
                dis[j]=dis[cur] + map[cur][j] ;  
  
        int mini=INF;  
        for(int j=0;j&amp;lt;n;j++)                    
            if(!vis[j] &amp;amp;&amp;amp; dis[j] &amp;lt; mini)    //选择下一次到已知顶点最短的点。   
                mini=dis[cur=j];  
        vis[cur]=true;  
    }     
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 也可以用优先队列进行优化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;collapse:true;;gutter:true;&quot;&gt;
void dijkstra(int s)  
{  
    priority_queue &amp;lt;node&amp;gt;q;  
    for(int i=0;i&amp;lt;n;i++)  
        d[i]=INF;  
    d[s]=0;  
    q.push_back(node(0,s));  
    while(!q.empty())  
    {  
        node x=q.top();  
        q.pop();  
        int u=x.u;  
        for(int i=0;i&amp;lt;G[u].size();i++)  
        {  
             node e=G[u][i];  
             if(d[e.u]&amp;gt;d[u]+e.d)  
             {  
                 d[e.u]=x.d+e.d;  
                 pi[e.u]=u;  
                 q.push_bacK(node(d[e.u],e.u));  
             }  
        }  
    }  
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 最短路径还能不仅能显示单源到某一点的最短距离，还能计算花费和输出行走路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Dj + 路径输出&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41.5&quot;&gt;&lt;img id=&quot;code_img_closed_ae2317d5-cc64-4e58-9a26-9cd9b7882ecc&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ae2317d5-cc64-4e58-9a26-9cd9b7882ecc&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ae2317d5-cc64-4e58-9a26-9cd9b7882ecc&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
#include &amp;lt;cstdio&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstring&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstdlib&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;algorithm&amp;gt;
&lt;span&gt;#define&lt;/span&gt; N 1005
&lt;span&gt;#define&lt;/span&gt; INF 0x3f3f3f3f
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; m, n;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; map[N][N];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; dis[N],pre[N];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; vis[N];
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; init()
{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= n; j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i == j) map[i][j] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; map[i][j] =&lt;span&gt; INF;
        }
    }
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; creatgraph()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; t1, t2, t3;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; m; i++&lt;span&gt;)
    {
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;t1, &amp;amp;t2, &amp;amp;t3);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个顶点和权值&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (map[t1][t2] &amp;gt; t3)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;防止重复输入相同节点，但是权值不同&lt;/span&gt;
            map[t1][t2] =&lt;span&gt; t3;
    }
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; dijkstra(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; start)
{
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;下边初始化dis,vis数组&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;)
    {
        dis[i] &lt;/span&gt;=&lt;span&gt; map[start][i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dis[i] &amp;gt;= INF) pre[i] = -&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若不直接连通，记为-1&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; pre[i] = start;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;start到i的路径中i的前驱均初始化为start&lt;/span&gt;
&lt;span&gt;    }
    memset(vis, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(vis));
    pre[start] &lt;/span&gt;= -&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;起点的前驱初始化为-1&lt;/span&gt;
    vis[start] = &lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标记第一个点&lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n - &lt;span&gt;1&lt;/span&gt;; i++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环n-1次&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;找出离起点最近的点&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; minn = INF, k = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= n; j++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!vis[j] &amp;amp;&amp;amp; dis[j] &amp;lt;&lt;span&gt; minn)
            {
                minn &lt;/span&gt;=&lt;span&gt; dis[j];
                k &lt;/span&gt;=&lt;span&gt; j;
            }
        }
        vis[k] &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!vis[i] &amp;amp;&amp;amp; map[k][i] &amp;lt;&lt;span&gt; INF)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dis[i] &amp;gt; dis[k] +&lt;span&gt; map[k][i])
                {
                    dis[i] &lt;/span&gt;= dis[k] + map[k][i];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;松弛操作，找到媒介使得出现新的最短路&lt;/span&gt;
                    pre[i] = k;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;k作为i的前驱&lt;/span&gt;
&lt;span&gt;                }
            }
        }
    }
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; printpath(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pre[x] != -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        printpath(pre[x]);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, x);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下边为倒序输出路径&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;int tmp = x;
    while (tmp != 1)
    {
     printf(&quot;%d-&amp;gt;&quot;, tmp);
     tmp = pre[tmp];
    }
    printf(&quot;%d&quot;, 1);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; print()
{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= n; i++&lt;span&gt;)
    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;最短路为：%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, dis[i]);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;最短路径为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        printpath(i);
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;n, &amp;amp;m) != EOF)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;n个顶点，m条边&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; start;
        init();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化地图&lt;/span&gt;
        creatgraph();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建图&lt;/span&gt;
        scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;start);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入起点&lt;/span&gt;
        dijkstra(start);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;核心迪杰斯特拉算法&lt;/span&gt;
        print();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出最短路结果&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Path+Dj&lt;/span&gt;&lt;/div&gt;



&lt;p&gt;Dj + 花费计算&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_89a5f934-0911-4e1c-ae07-8aac24b5567a&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_89a5f934-0911-4e1c-ae07-8aac24b5567a&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_89a5f934-0911-4e1c-ae07-8aac24b5567a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
#include&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;algorithm&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;stack&amp;gt;
&lt;span&gt;#define&lt;/span&gt; maxn 0x7fffffff
&lt;span&gt;int&lt;/span&gt; mat[&lt;span&gt;505&lt;/span&gt;][&lt;span&gt;505&lt;/span&gt;],vis[&lt;span&gt;505&lt;/span&gt;],pay[&lt;span&gt;505&lt;/span&gt;][&lt;span&gt;505&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; dis[&lt;span&gt;505&lt;/span&gt;],cost[&lt;span&gt;505&lt;/span&gt;],n,m,path[&lt;span&gt;505&lt;/span&gt;];  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;最短路 + 路径输出&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; dijkstra(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; s)
{
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,j;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;)
  {
      dis[i]&lt;/span&gt;=&lt;span&gt;mat[s][i];
      cost[i]&lt;/span&gt;=&lt;span&gt;pay[s][i];
      vis[i]&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(dis[i]!=&lt;span&gt;maxn)
          path[i]&lt;/span&gt;=&lt;span&gt;s;
       &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; path[i]=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
  }
  vis[s]&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
  dis[s]&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
  cost[s]&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;)
  {
      &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k=s,u=&lt;span&gt;maxn;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;n;j++&lt;span&gt;)
      {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!vis[j]&amp;amp;&amp;amp;dis[j]&amp;lt;&lt;span&gt;u)
          {
              u&lt;/span&gt;=&lt;span&gt;dis[j];
              k&lt;/span&gt;=&lt;span&gt;j;
          }
      }
      vis[k]&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;n;j++&lt;span&gt;)
      {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!vis[j]&amp;amp;&amp;amp;mat[k][j]!=&lt;span&gt;maxn)
          {
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(dis[j]&amp;gt;dis[k]+&lt;span&gt;mat[k][j])
              {
                  dis[j]&lt;/span&gt;=dis[k]+&lt;span&gt;mat[k][j];
                  cost[j]&lt;/span&gt;=cost[k]+&lt;span&gt;pay[k][j];
                  path[j]&lt;/span&gt;=&lt;span&gt;k;
              }
              &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(dis[j]==dis[k]+&lt;span&gt;mat[k][j])
              {
                  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(cost[j]&amp;gt;cost[k]+&lt;span&gt;pay[k][j])
                  {
                      cost[j]&lt;/span&gt;=cost[k]+&lt;span&gt;pay[k][j];
                      path[j]&lt;/span&gt;=&lt;span&gt;k;
                  }
              }
          }
      }
  }
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; print(&lt;span&gt;int&lt;/span&gt; s,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; t)
{
    stack&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;q;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(t!=&lt;span&gt;s)
    {
        q.push(t);
        t&lt;/span&gt;=&lt;span&gt;path[t];
    }
    q.push(t);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;q.empty())
    {
        cout&lt;/span&gt;&amp;lt;&amp;lt;q.top()&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        q.pop();
    }
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; s,t,a,b,d,w,i,j;
    cin&lt;/span&gt;&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;s&amp;gt;&amp;gt;&lt;span&gt;t;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;)
       &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;n;j++&lt;span&gt;)
          mat[i][j]&lt;/span&gt;=pay[i][j]=maxn; &lt;span&gt;//&lt;/span&gt; 
    &lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;m;i++&lt;span&gt;)
    {
        cin&lt;/span&gt;&amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;d&amp;gt;&amp;gt;&lt;span&gt;w;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(mat[a][b]&amp;gt;&lt;span&gt;d)
        {
            mat[a][b]&lt;/span&gt;=mat[b][a]=&lt;span&gt;d;
            pay[a][b]&lt;/span&gt;=pay[b][a]=&lt;span&gt;w;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(mat[a][b]==&lt;span&gt;d)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(pay[a][b]&amp;gt;&lt;span&gt;w)
               pay[a][b]&lt;/span&gt;=pay[b][a]=&lt;span&gt;w;
        } &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输入进行处理，最短路&lt;/span&gt;
&lt;span&gt;    }
    dijkstra(s); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 寻找从 s 开始 单源最短路&lt;/span&gt;
    print(s,t);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 输出路径， S 到 T 的路径&lt;/span&gt;
    cout&amp;lt;&amp;lt;dis[t]&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;cost[t]&amp;lt;&amp;lt;endl;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; dist 指的是 距离 dis[t] 指的是花费&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Cost + Dj&lt;/span&gt;&lt;/div&gt;



&lt;p&gt; 但是，以上的所有算法，在面对负权回路，就会束手无策了 ，Bellman - Ford 负权回路的领跑者！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_7dfd1558-f56f-489c-a993-bc5b18c6664e&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7dfd1558-f56f-489c-a993-bc5b18c6664e&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7dfd1558-f56f-489c-a993-bc5b18c6664e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstdio&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;

&lt;/span&gt;&lt;span&gt;#define&lt;/span&gt; MAX 0x3f3f3f3f
&lt;span&gt;#define&lt;/span&gt; N 1010
&lt;span&gt;int&lt;/span&gt; nodenum, edgenum, original; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;点，边，起点&lt;/span&gt;
&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; Edge &lt;span&gt;//&lt;/span&gt;&lt;span&gt;边&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; u, v;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cost;
}Edge;

Edge edge[N];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; dis[N], pre[N];

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Bellman_Ford()
{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= nodenum; ++i) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化&lt;/span&gt;
        dis[i] = (i == original ? &lt;span&gt;0&lt;/span&gt;&lt;span&gt; : MAX);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= nodenum - &lt;span&gt;1&lt;/span&gt;; ++&lt;span&gt;i)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= edgenum; ++&lt;span&gt;j)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(dis[edge[j].v] &amp;gt; dis[edge[j].u] + edge[j].cost) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;松弛（顺序一定不能反~）&lt;/span&gt;
&lt;span&gt;            {
                dis[edge[j].v] &lt;/span&gt;= dis[edge[j].u] +&lt;span&gt; edge[j].cost;
                pre[edge[j].v] &lt;/span&gt;=&lt;span&gt; edge[j].u;
            }
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; flag = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否含有负权回路&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= edgenum; ++&lt;span&gt;i)
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(dis[edge[i].v] &amp;gt; dis[edge[i].u] +&lt;span&gt; edge[i].cost)
                {
                    flag &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; flag;
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; print_path(&lt;span&gt;int&lt;/span&gt; root) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印最短路的路径（反向）&lt;/span&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(root != pre[root]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;前驱&lt;/span&gt;
&lt;span&gt;    {
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d--&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, root);
        root &lt;/span&gt;=&lt;span&gt; pre[root];
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(root ==&lt;span&gt; pre[root])
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, root);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;nodenum, &amp;amp;edgenum, &amp;amp;&lt;span&gt;original);
    pre[original] &lt;/span&gt;=&lt;span&gt; original;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= edgenum; ++&lt;span&gt;i)
    {
        scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;edge[i].u, &amp;amp;edge[i].v, &amp;amp;&lt;span&gt;edge[i].cost);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(Bellman_Ford())
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= nodenum; ++i) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个点最短路&lt;/span&gt;
&lt;span&gt;        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, dis[i]);
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Path:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            print_path(i);
        }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;have negative circle\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;BF&lt;/span&gt;&lt;/div&gt;



&lt;p&gt;如果想了解更多---------------------&amp;gt;  &lt;a href=&quot;http://note.youdao.com/noteshare?id=14ce6c772711d7e3527223292c9bf6bc&quot; target=&quot;_blank&quot;&gt; Link&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;最小生成树&lt;/h3&gt;
&lt;p&gt;Prim：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:cpp;collapse:true;;gutter:true;&quot;&gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;fstream&amp;gt;
using  namespace std;
#define INF 0x3f3f3f3f
const int maxn = 117;
int m[maxn][maxn];
int vis[maxn], low[maxn];
int n;
int prim()
{
    vis[1] = 1;
    int sum = 0;
    int pos, minn;
    pos = 1;
    for(int i = 1; i &amp;lt;= n; i++)
    {
        low[i] = m[pos][i];
    }
    for(int i = 1; i &amp;lt; n; i++)
    {
        minn = INF;
        for(int j = 1; j &amp;lt;= n; j++)
        {
            if(!vis[j] &amp;amp;&amp;amp; minn &amp;gt; low[j])
            {
                minn = low[j];
                pos = j;
            }
        }
        sum += minn;
        vis[pos] = 1;
        for(int j = 1; j &amp;lt;= n; j++)
        {
            if(!vis[j] &amp;amp;&amp;amp; low[j] &amp;gt; m[pos][j])
            {
                low[j] = m[pos][j];
            }
        }
    }
    return sum;
}

int main()
{
    scanf(&quot;%d&quot;,&amp;amp;n);
    int ms = n*(n-1)/2;
    int x,y,cost,tes;
    for(int i = 1; i &amp;lt;= n ;i++ )
        for(int j = 1; j &amp;lt;= n; j++)
        m[i][j] = INF;
    for(int i = 1; i &amp;lt;= ms ; i++)
    {
        cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y&amp;gt;&amp;gt;cost&amp;gt;&amp;gt;tes;
        m[x][y] = m[y][x] = tes==1?0:cost;
    }
    cost = prim();
    cout&amp;lt;&amp;lt; cost &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; Kruskal：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:cpp;collapse:true;;gutter:true;&quot;&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int MAX=1000;
int father[MAX];
typedef struct
{
    int u;
    int v;
    int w;
}edge;// u,v,w分别代表点，点，对应的边的长度
edge e[MAX];
int n,m;
int sum=0,counts=0;//路径和计数器
void initial(int n)    //初始化
{
    for(int i=1;i&amp;lt;=n;i++)
        father[i]=i;
}
int find(int x)    //查找
{
    while(father[x]!=x)
        x=father[x];
    return father[x];//  return x==father[x]?father[x]:find(father[x]);
}
int combine(int a,int b)   //合并
{
    int tmpa=find(a);
    int tmpb=find(b);
    if(tmpa!=tmpb)
    {
        father[tmpa]=tmpb;//遵循以右为尊原则，也可以以左为尊
        return 1;
    }//认祖归宗，找不到就另开山头，
    /*
    if(tmpa&amp;lt;tmpb)
        father[tmpb]=tmpa;
    else
        father[tmpa]=tmpb;
    */
    return 0;
}
bool cmp(edge a,edge b)
{
    return a.w&amp;lt;b.w;//快速排序的比较函数
}
int main()
{
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    for(int i=1;i&amp;lt;=m;i++)
        cin&amp;gt;&amp;gt;e[i].u&amp;gt;&amp;gt;e[i].v&amp;gt;&amp;gt;e[i].w;
    sort(e+1,e+m+1,cmp);
    initial(n);
    for(int i=1;i&amp;lt;=m;i++)
    if(combine(e[i].u,e[i].v))//祖宗一样就说明已经联通，不需要在计算，否则就加入并查集中
    {
        counts++;
        sum+=e[i].w;
        if(counts==n-1)//最小生成树，最短路径，边只要有n-1条
            break;
    }
    cout&amp;lt;&amp;lt;sum&amp;lt;&amp;lt;endl;//输出最小花费
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 在这里不得不提到并查集，判断集合个数非常简单的方式：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/horizonice/p/3658176.html&quot; target=&quot;_blank&quot;&gt;Link&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_34c5e015-d83b-4394-92ab-58b49fee9d7d&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_34c5e015-d83b-4394-92ab-58b49fee9d7d&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_34c5e015-d83b-4394-92ab-58b49fee9d7d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; father[&lt;span&gt;105&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; maps[&lt;span&gt;110&lt;/span&gt;][&lt;span&gt;110&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, m , k;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; finds(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x!=father[x]) father[x]=&lt;span&gt;finds(father[x]);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; father[x];
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; combine(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; y,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; t)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(t==&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a=&lt;span&gt;finds(x);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b=&lt;span&gt;finds(y);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a==&lt;span&gt;b)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(a&amp;lt;&lt;span&gt;b)
        father[b]&lt;/span&gt;=&lt;span&gt;a;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        father[a]&lt;/span&gt;=&lt;span&gt;b;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        maps[x][y] &lt;/span&gt;= maps[y][x] = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; init()
{
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
      father[i]&lt;/span&gt;=&lt;span&gt;i;
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
   scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;n,&amp;amp;m,&amp;amp;&lt;span&gt;k);
   init();
   memset(maps,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(maps));
   &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=m;i++&lt;span&gt;)
   {
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x,y,t;
       scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;x,&amp;amp;y,&amp;amp;&lt;span&gt;t);
       combine(x,y,t);
   }
   &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x,y;
   &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;k;i++&lt;span&gt;)
   {
        cin&lt;/span&gt;&amp;gt;&amp;gt;x&amp;gt;&amp;gt;&lt;span&gt;y;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(finds(x)==finds(y)&amp;amp;&amp;amp;maps[x][y]!=-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No problem\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(finds(x)==finds(y)&amp;amp;&amp;amp;maps[x][y]==-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OK but...\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(finds(x)!=finds(y)&amp;amp;&amp;amp;maps[x][y]==-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;No way\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OK\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
   }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;并查集&lt;/span&gt;&lt;/div&gt;



&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;写在最后：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    实在抱歉，暂时只能想起来的基础部分只有这么多了，还有许多详细的内容没有填充上去，如果您有好的建议，希望不吝赐教，请尽管在评论区发表，或者私信给我，附加上您希望添加的内容，希望能在各位斧正下尽快完善了这个文章。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    有许多部分的内容会对于初学者来说会有那么一点不好理解，如果可能的话，希望初学者在查阅并且学习的过程中，能够整理下来自己存在理解障碍的地方或者自己想要完善的部分，尽可能利用百度。谷歌等工具理解这些内容，最后如果有可能的话，能将你们整理的适合添加的内容分享给我一部分，最好能指出希望修改的部分，我的邮箱 &lt;/span&gt;  &lt;a target=&quot;_blank&quot;&gt;hoodychen@qq.com&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;还有，希望大家能给个关注，谢谢各位。 &lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 05 Dec 2017 15:22:00 +0000</pubDate>
<dc:creator>Kindear_chen</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/masterchd/p/7987371.html</dc:identifier>
</item>
<item>
<title>直方图实现快速中值滤波 - 一棹烟波</title>
<link>http://www.cnblogs.com/riddick/p/7989871.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/riddick/p/7989871.html</guid>
<description>&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; #include &amp;lt;opencv2\opencv.hpp&amp;gt;
&lt;span&gt;  2&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt;  3&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;
&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; cv;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算亮度中值和灰度&amp;lt;=中值的像素点个数&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; CalculateImage_MedianGray_PixelCount(&lt;span&gt;const&lt;/span&gt; Mat &amp;amp;histogram, &lt;span&gt;int&lt;/span&gt; pixelCount, &lt;span&gt;int&lt;/span&gt; &amp;amp;medianValue, &lt;span&gt;int&lt;/span&gt; &amp;amp;&lt;span&gt;pixleCountLowerMedian)
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; *data = (&lt;span&gt;float&lt;/span&gt; *)histogram.data;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直方图&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt;= &lt;span&gt;255&lt;/span&gt;; ++&lt;span&gt;i)
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;//
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;         sum +=&lt;span&gt; data[i];
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;2&lt;/span&gt; * sum&amp;gt;&lt;span&gt;pixelCount)
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;             medianValue =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;             pixleCountLowerMedian =&lt;span&gt; sum;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fastMedianBlur(&lt;span&gt;const&lt;/span&gt; Mat &amp;amp;srcImg, Mat &amp;amp;dstImg, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; diameter)
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; radius = (diameter - &lt;span&gt;1&lt;/span&gt;) / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; imgW =&lt;span&gt; srcImg.cols;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; imgH =&lt;span&gt; srcImg.rows;
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; channels =&lt;span&gt; srcImg.channels();
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;     dstImg =&lt;span&gt; Mat::zeros(imgH, imgW, CV_8UC1);
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; windowSize = diameter*&lt;span&gt;diameter;
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     Mat windowImg =&lt;span&gt; Mat::zeros(diameter, diameter, CV_8UC1);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;直方图&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;    Mat histogram;
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; histogramSize = &lt;span&gt;256&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;灰度等级&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; thresholdValue = windowSize / &lt;span&gt;2&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;step1.设置阈值(步骤参考：图像的高效编程要点之四)
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;待处理图像像素&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt;     uchar *pDstData = dstImg.data + imgW*radius +&lt;span&gt; radius;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;整个图像中窗口位置指针&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;     uchar *pSrcData =&lt;span&gt; srcImg.data;
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; 
&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;逐行遍历&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = radius; i &amp;lt;= imgH - &lt;span&gt;1&lt;/span&gt; - radius; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;列指针&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;         uchar *pColDstData =&lt;span&gt; pDstData;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;         uchar *pColSrcData =&lt;span&gt; pSrcData;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;单个窗口指针&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;         uchar *pWindowData =&lt;span&gt; windowImg.data;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;         uchar *pRowSrcData =&lt;span&gt; pColSrcData;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从源图中提取窗口图像&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; winy = &lt;span&gt;0&lt;/span&gt;; winy &amp;lt;= diameter - &lt;span&gt;1&lt;/span&gt;; winy++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; winx = &lt;span&gt;0&lt;/span&gt;; winx &amp;lt;= diameter - &lt;span&gt;1&lt;/span&gt;; winx++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                 pWindowData[winx] =&lt;span&gt; pRowSrcData[winx];
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;             pRowSrcData +=&lt;span&gt; imgW;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;             pWindowData +=&lt;span&gt; diameter;
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;求直方图,确定中值，并记录亮度&amp;lt;=中值的像素点个数&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt;         calcHist(&amp;amp;&lt;span&gt;windowImg,
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;             &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Mat的个数&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;             &lt;span&gt;0&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来计算直方图的通道索引，通道索引依次排开&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;             Mat(),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Mat()返回一个空值，表示不用mask,&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;             histogram, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;直方图&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;直方图的维数，如果计算2个直方图，就为2&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;             &amp;amp;histogramSize, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;直方图的等级数(如灰度等级),也就是每列的行数&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt;             &lt;span&gt;0&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分量的变化范围&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;求亮度中值和&amp;lt;=中值的像素点个数&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; medianValue, pixelCountLowerMedian;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;        CalculateImage_MedianGray_PixelCount(histogram, windowSize, medianValue, pixelCountLowerMedian);
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;         &lt;span&gt;////////////&lt;/span&gt;&lt;span&gt;滑动窗口操作结束&lt;/span&gt;&lt;span&gt;/////////////////////&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;滤波&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;         pColDstData[&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; (uchar)medianValue;
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; 
&lt;span&gt; 86&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理同一行下一个像素&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;         pColDstData++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;         pColSrcData++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = radius + &lt;span&gt;1&lt;/span&gt;; j &amp;lt;= imgW - radius - &lt;span&gt;1&lt;/span&gt;; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;维护滑动窗口直方图
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除左侧&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;             uchar *pWinLeftData = pColSrcData - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;             &lt;span&gt;float&lt;/span&gt; *pHistData = (&lt;span&gt;float&lt;/span&gt;*&lt;span&gt;)histogram.data;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; winy = &lt;span&gt;0&lt;/span&gt;; winy &amp;lt; diameter; winy++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                 uchar grayValue = pWinLeftData[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                 pHistData[grayValue] -= &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (grayValue &amp;lt;=&lt;span&gt; medianValue)
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                     pixelCountLowerMedian--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;                 pWinLeftData +=&lt;span&gt; imgW;
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; 
&lt;span&gt;106&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;增加右侧&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt;             uchar *pWinRightData = pColSrcData + diameter - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; winy = &lt;span&gt;0&lt;/span&gt;; winy &amp;lt; diameter; winy++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                 uchar grayValue = pWinRightData[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                 pHistData[grayValue] += &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (grayValue &amp;lt;=&lt;span&gt; medianValue)
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;                     pixelCountLowerMedian++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt;                 pWinRightData +=&lt;span&gt; imgW;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算新的中值&lt;/span&gt;
&lt;span&gt;119&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (pixelCountLowerMedian &amp;gt;&lt;span&gt; thresholdValue)
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;                     pixelCountLowerMedian -=&lt;span&gt; pHistData[medianValue];
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                     medianValue--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (pixelCountLowerMedian &amp;lt;=&lt;span&gt; thresholdValue)
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;    
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; 
&lt;span&gt;132&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt; (pixelCountLowerMedian &amp;lt;&lt;span&gt; thresholdValue)
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;                     medianValue++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;                     pixelCountLowerMedian +=&lt;span&gt; pHistData[medianValue];
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; 
&lt;span&gt;138&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt;             pColDstData[&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; medianValue;
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下一个像素&lt;/span&gt;
&lt;span&gt;143&lt;/span&gt;             pColDstData++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt;             pColSrcData++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动至下一行&lt;/span&gt;
&lt;span&gt;147&lt;/span&gt;         pDstData +=&lt;span&gt; imgW;
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;         pSrcData +=&lt;span&gt; imgW;
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; 
&lt;span&gt;151&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;边界直接赋原始值，不做滤波处理&lt;/span&gt;
&lt;span&gt;152&lt;/span&gt;     pSrcData =&lt;span&gt; srcImg.data;
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;     pDstData =&lt;span&gt; dstImg.data;
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上下边界&lt;/span&gt;
&lt;span&gt;155&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; imgW; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; radius; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; idxTop = i*imgW +&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;             pDstData[idxTop] =&lt;span&gt; pSrcData[idxTop];
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; idxBot = (imgH - i - &lt;span&gt;1&lt;/span&gt;)*imgW +&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt;             pDstData[idxBot] =&lt;span&gt; pSrcData[idxBot];
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左右边界&lt;/span&gt;
&lt;span&gt;166&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = radius; i &amp;lt; imgH - radius - &lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; radius; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; idxLeft = i*imgW +&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;             pDstData[idxLeft] =&lt;span&gt; pSrcData[idxLeft];
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; idxRight = i*imgW + imgW - j-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;             pDstData[idxRight] =&lt;span&gt; pSrcData[idxRight];
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; 
&lt;span&gt;178&lt;/span&gt; 
&lt;span&gt;179&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;     &lt;span&gt;string&lt;/span&gt; imgPath = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;     Mat srcImg = imread(imgPath + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;moon.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; &lt;span&gt;    Mat dstImg;
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;     &lt;span&gt;double&lt;/span&gt; t0 =&lt;span&gt; cv::getTickCount();
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;     fastMedianBlur(srcImg, dstImg, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;cv::medianBlur(srcImg, dstImg, 5); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;OpenCV&lt;/span&gt;
&lt;span&gt;187&lt;/span&gt;     &lt;span&gt;double&lt;/span&gt; t1 =&lt;span&gt; cv::getTickCount();
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;     cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;time=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; (t1 - t0) / cv::getTickFrequency() &amp;lt;&amp;lt;&lt;span&gt; endl;
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt;     
&lt;span&gt;190&lt;/span&gt;     imwrite(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data/test/srcImg.bmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, srcImg);
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;     imwrite(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;data/test/myFilter.bmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, dstImg);
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt; }
&lt;/pre&gt;</description>
<pubDate>Tue, 05 Dec 2017 14:42:00 +0000</pubDate>
<dc:creator>一棹烟波</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/riddick/p/7989871.html</dc:identifier>
</item>
<item>
<title>Django 2.0 新特性 抢先看！ - 刘江-Python-Django</title>
<link>http://www.cnblogs.com/feixuelove1009/p/7989720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixuelove1009/p/7989720.html</guid>
<description>&lt;p&gt;2017年12月2日，Django官方发布了2.0版本，成为多年来的第一次大版本提升，那么2.0对广大Django使用者有哪些变化和需要注意的地方呢？&lt;/p&gt;
&lt;h2 id=&quot;一python兼容性&quot;&gt;一、Python兼容性&lt;/h2&gt;
&lt;p&gt;Django 2.0支持Python3.4、3.5和3.6。Django官方强烈推荐每个系列的最新版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最重要的是Django 2.0不再支持Python2！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Django 1.11.x是支持Python2.7的最后版本。&lt;/p&gt;
&lt;h2 id=&quot;二2.0新特性&quot;&gt;二、2.0新特性&lt;/h2&gt;
&lt;h3 id=&quot;简化了url路由语法&quot;&gt;1.简化了URL路由语法&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;django.urls.path()&lt;/code&gt;方法的语法更简单了。&lt;/p&gt;
&lt;p&gt;例如以前的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;url(r'^articles/(?P&amp;lt;year&amp;gt;[0-9]{4})/$', views.year_archive),&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以写作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;path('articles/&amp;lt;int:year&amp;gt;/', views.year_archive),&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新语法支持强制定义参数类型。例子中只接收整数型年份参数，不再接收字符串类型，同时“10000”年也是合法的（虽然是5位数字），而不像先前正则里只能接收4位数字。&lt;/p&gt;
&lt;p&gt;以前版本的&lt;code&gt;django.conf.urls.url()&lt;/code&gt;方法变成了&lt;code&gt;django.urls.re_path()&lt;/code&gt;，但为了向后兼容，旧的依然保留，而不是立刻废弃。&lt;code&gt;django.conf.urls.include()&lt;/code&gt;方法现在可以从&lt;code&gt;django.urls&lt;/code&gt;导入，也就是你可以使用&lt;code&gt;from django.urls import include, path, re_path&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;admin后台对移动端更加友好&quot;&gt;2.admin后台对移动端更加友好&lt;/h3&gt;
&lt;p&gt;Django最受大家欢迎的admin后台，具有响应式特性，支持主流的移动设备。&lt;/p&gt;
&lt;h3 id=&quot;window-表达式&quot;&gt;3.Window 表达式&lt;/h3&gt;
&lt;p&gt;新的Window表达式允许为查询集添加一个OVER从句。&lt;/p&gt;
&lt;h3 id=&quot;小特性&quot;&gt;4.小特性&lt;/h3&gt;
&lt;h4 id=&quot;django.contrib.admin后台&quot;&gt;django.contrib.admin后台&lt;/h4&gt;
&lt;p&gt;新的&lt;code&gt;ModelAdmin.autocomplete_fields&lt;/code&gt;属性和&lt;code&gt;ModelAdmin.get_autocomplete_fields()&lt;/code&gt;方法现在可以在外键和多对多字段上使用Select2搜索框。&lt;/p&gt;
&lt;h4 id=&quot;django.contrib.auth用户认证&quot;&gt;django.contrib.auth用户认证&lt;/h4&gt;
&lt;p&gt;PBKDF2密码哈希默认的迭代次数从36000增加到100000。&lt;/p&gt;
&lt;h4 id=&quot;django.contrib.gis地理框架&quot;&gt;django.contrib.gis地理框架&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;为AsGeoJSON、GeoHash和GeoHash方法，isvalid和distance查询增加MySQL支持；&lt;/li&gt;
&lt;li&gt;添加Azimuth和LineLocatePoint方法，支持PostGIS和SpatiaLite；&lt;/li&gt;
&lt;li&gt;所有从GeoJSON导入的GEOSGeometry拥有SRID集合；&lt;/li&gt;
&lt;li&gt;添加&lt;code&gt;OSMWidget.default_zoom&lt;/code&gt;属性，用于自定义地图的默认缩放级别；&lt;/li&gt;
&lt;li&gt;metadata现在是可读可编辑的；&lt;/li&gt;
&lt;li&gt;允许在GDAL的内部虚拟文件系统中创建GDALRaster对象；&lt;/li&gt;
&lt;li&gt;新的&lt;code&gt;GDALBand.color_interp()&lt;/code&gt;方法返回波段的颜色说明。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;django.contrib.postgres数据库&quot;&gt;django.contrib.postgres数据库&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;ArrayAgg新增distinct参数；&lt;/li&gt;
&lt;li&gt;新的RandomUUID函数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;django.contrib.postgres.indexes.GinIndex&lt;/code&gt;现在支持&lt;code&gt;fastupdate&lt;/code&gt;和&lt;code&gt;gin_pending_list_limit&lt;/code&gt;参数；&lt;/li&gt;
&lt;li&gt;新的GistIndex类允许在数据库中创建GiST索引；&lt;/li&gt;
&lt;li&gt;inspectdb现在可以内省JSONField和RangeFields。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;django.contrib.sitemaps站点地图&quot;&gt;django.contrib.sitemaps站点地图&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;为GenericSitemap构造器增加protocol参数；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;cache缓存&quot;&gt;Cache缓存&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;cache.set_many()现在返回一个列表，包含了插入失败的键值；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;file-storage文件存储&quot;&gt;File Storage文件存储&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;File.open()&lt;/code&gt;现在可以用于上下文管理器，例如&lt;code&gt;with file.open() as f:&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;forms表单&quot;&gt;Forms表单&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;SplitDateTimeWidget&lt;/code&gt;和&lt;code&gt;SplitHiddenDateTimeWidget&lt;/code&gt;增加&lt;code&gt;date_attrs&lt;/code&gt;与&lt;code&gt;time_attrs&lt;/code&gt;参数，用于为&lt;code&gt;DateInput&lt;/code&gt;与&lt;code&gt;TimeInput&lt;/code&gt;指定HTML属性；&lt;/li&gt;
&lt;li&gt;新的&lt;code&gt;Form.errors.get_json_data()&lt;/code&gt;方法返回字典类型的表单错误,以适应JSON类型x响应；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;generic-views通用视图&quot;&gt;Generic Views通用视图&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;新的&lt;code&gt;ContextMixin.extra_context&lt;/code&gt;属性允许在&lt;code&gt;View.as_view()&lt;/code&gt;中添加上下文；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;management-commands管理命令&quot;&gt;Management Commands管理命令&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;inspectdb现在将MySQL的无符号整数视作&lt;code&gt;PositiveIntegerField&lt;/code&gt;或者&lt;code&gt;PositiveSmallIntegerField&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;新增&lt;code&gt;makemessages --add-location&lt;/code&gt;选项；&lt;/li&gt;
&lt;li&gt;loaddata现在可以从标准输入读入；&lt;/li&gt;
&lt;li&gt;新增&lt;code&gt;diffsettings --output&lt;/code&gt;选项；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;migrations迁移&quot;&gt;Migrations迁移&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;新增&lt;code&gt;squashmigrations --squashed-name&lt;/code&gt;选项；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;models模型&quot;&gt;Models模型&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;新增StrIndex数据库函数；&lt;/li&gt;
&lt;li&gt;对于Oracle数据库，AutoField和BigAutoField现在会生成identity列；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QuerySet.iterator()&lt;/code&gt;新增&lt;code&gt;chunk_size&lt;/code&gt;参数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QuerySet.earliest()&lt;/code&gt;、&lt;code&gt;QuerySet.latest()&lt;/code&gt;和&lt;code&gt;Meta.get_latest_by&lt;/code&gt;现在可以根据一些字段进行排序；&lt;/li&gt;
&lt;li&gt;增加ExtractQuarter方法，用于DateField和DateTimeField；&lt;/li&gt;
&lt;li&gt;新增TruncQuarter方法用于截取DateField和DateTimeField到季度的第一天；&lt;/li&gt;
&lt;li&gt;为基于类的索引添加&lt;code&gt;db_tablespace&lt;/code&gt;参数；&lt;/li&gt;
&lt;li&gt;为&lt;code&gt;QuerySet.select_for_update()&lt;/code&gt;增加of参数，但只支持PostgreSQL和Oracle数据库；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QuerySet.in_bulk()&lt;/code&gt;新增&lt;code&gt;field_name&lt;/code&gt;参数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CursorWrapper.callproc()&lt;/code&gt;现在接收可选的字典类型关键字参数；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QuerySet.values_list()&lt;/code&gt;新增named参数，用于获取命名的元组结果；&lt;/li&gt;
&lt;li&gt;新的FilteredRelation类允许为查询集增加一个ON从句；&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;增加&lt;code&gt;Paginator.get_page()&lt;/code&gt;，可以处理各种非法页面参数，防止异常;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;requests-and-responses请求和相应&quot;&gt;Requests and Responses请求和相应&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;现在，runserver服务器支持HTTP 1.1；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;templates模版&quot;&gt;Templates模版&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;为了提高&lt;code&gt;Engine.get_default()&lt;/code&gt;在第三方模块的用途，现在它将返回配置在TEMPLATES中的多个DjangoTemplates引擎中的第一个，而不是弹出ImproperlyConfigured错误；&lt;/li&gt;
&lt;li&gt;自定义模版标签现在接收强制关键字参数；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;tests测试&quot;&gt;Tests测试&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;为LiveServerTestCase添加多线程支持；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;validators验证器&quot;&gt;Validators验证器&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;新的ProhibitNullCharactersValidator不允许CharField及其子类的表单输入为空；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三重要的向后不兼容&quot;&gt;三、重要的向后不兼容&lt;/h2&gt;
&lt;h3 id=&quot;某些地方删除对bytestrings的支持&quot;&gt;1. 某些地方删除对bytestrings的支持&lt;/h3&gt;
&lt;p&gt;例如，对于reverse()，现在使用str()代替force_text()。&lt;/p&gt;
&lt;h3 id=&quot;abstractuser.last_name的最大长度增加到150&quot;&gt;2. AbstractUser.last_name的最大长度增加到150&lt;/h3&gt;
&lt;p&gt;如果你有一个自定义的用户模型继承了AbstractUser，你需要生成并应用一个数据库迁移，使得&lt;code&gt;last_name&lt;/code&gt;的最大长度变为150。&lt;/p&gt;
&lt;p&gt;如果你需要为&lt;code&gt;last_name&lt;/code&gt;保持30个字符的限制，可以如下使用自定义表单：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.contrib.auth.forms &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; UserChangeForm

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyUserChangeForm(UserChangeForm):
    last_name &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; forms.CharField(max_length&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;30&lt;/span&gt;, required&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;False&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果你需要在admin中也保持这个约束，那么可以如下使用UserAdmin.form：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.contrib.auth.admin &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; UserAdmin
&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; django.contrib.auth.models &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; User

&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyUserAdmin(UserAdmin):
    form &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; MyUserChangeForm

admin.site.unregister(User)
admin.site.register(User, MyUserAdmin)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;queryset.reverse和last不能用于切片后的查询集&quot;&gt;3. QuerySet.reverse()和last()不能用于切片后的查询集&lt;/h3&gt;
&lt;p&gt;对切片后的查询集使用反转和获取最近对象的操作将弹出异常，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; Model.objects.all()[:2].reverse()
Traceback (most recent call last):
...
TypeError: Cannot reverse a query once a slice has been taken.&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;表单的字段不再接收可选参数作为位置参数&quot;&gt;4. 表单的字段不再接收可选参数作为位置参数&lt;/h3&gt;
&lt;p&gt;为了防止运行时错误，提高可靠性。以前类似下面的参数传递方法，现在是错误的了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;forms.IntegerField(25, 10)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要这么传递：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;forms.IntegerField(max_value=25, min_value=10)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;index不再接收位置参数&quot;&gt;5. Index不再接收位置参数&lt;/h3&gt;
&lt;p&gt;例如下面的用法将导致异常：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;models.Index(['headline', '-pub_date'], 'index_name')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要提供参数关键字，改写为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;models.Index(fields=['headline', '-pub_date'], name='index_name')&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;call_command将验证它接收的选项&quot;&gt;6. call_command()将验证它接收的选项&lt;/h3&gt;
&lt;p&gt;对于使用选项而不是使用&lt;code&gt;parser.add_argument&lt;/code&gt;()进行自定义的管理命令，需要添加一个&lt;code&gt;stealth_options&lt;/code&gt;属性，如下所示：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; MyCommand(BaseCommand):
    stealth_options &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; (&lt;span class=&quot;st&quot;&gt;'option_name'&lt;/span&gt;, ...)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;sqlite现在支持外键约束&quot;&gt;7. SQLite现在支持外键约束&lt;/h3&gt;
&lt;p&gt;另外，Django2.0还废弃和移除了一些方法和属性。&lt;/p&gt;
&lt;h2 id=&quot;总结-好像也没多大变化不是重度使用者基本感受不出变化来该怎么用还是怎么用-&quot;&gt;总结: 好像也没多大变化，不是重度使用者，基本感受不出变化来，该怎么用还是怎么用，^-^!&lt;/h2&gt;
&lt;hr/&gt;&lt;h2 id=&quot;欢迎大家访问我的个人网站刘江的博客和教程www.liujiangblog.com&quot;&gt;欢迎大家访问我的个人网站《刘江的博客和教程》&lt;a href=&quot;http://www.liujiangblog.com&quot;&gt;www.liujiangblog.com&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&quot;主要分享python-及django教程以及相关的博客&quot;&gt;主要分享Python 及Django教程以及相关的博客！&lt;/h2&gt;
&lt;h2 id=&quot;交流qq群514549650&quot;&gt;交流QQ群：514549650&lt;/h2&gt;
</description>
<pubDate>Tue, 05 Dec 2017 14:16:00 +0000</pubDate>
<dc:creator>刘江-Python-Django</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feixuelove1009/p/7989720.html</dc:identifier>
</item>
<item>
<title>C++ 指针和引用 吐血整理 Pointer&amp;Reference - 算法生活</title>
<link>http://www.cnblogs.com/tangxiaobo199181/p/7989464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tangxiaobo199181/p/7989464.html</guid>
<description>&lt;p&gt;说道C++的指针，很多人都很头疼，也很confuse。经常把它和变量名，引用（reference）等混淆，其实这最主要的原因是很多程序员对于基本知识的掌握有问题，从而导致的很多基本概念的混淆。本文就是从最基本的概念讲起，着重分析和比较指针和引用。主要从以下几个方面着重的讲解：&lt;/p&gt;
&lt;p&gt;1. 变量（variable）的表现形式；&lt;/p&gt;
&lt;p&gt;2. 指针的结构和原理；&lt;/p&gt;
&lt;p&gt;3. 引用的结构和原理；&lt;/p&gt;
&lt;p&gt;4. 指针在Array中的应用和注意事项；&lt;/p&gt;
&lt;p&gt;5. 指针不能dereference的几种情况；&lt;/p&gt;
&lt;p&gt;一：变量的形式&lt;/p&gt;
&lt;p&gt;说道变量，很多人都觉得非常简单，每天都在定义变量，应用变量。可是有没有停下脚步细细的品味一下具体什么是变量呢？变量（variable）的定义在计算机科学中到底是如何定义的？然后variable到底是在内存中如何存储值的呢？那么跟着上面的问题，我们来一一的解答，首先最重要的，&lt;span&gt;variable的定义，当你申明一个变量的时候，计算机会将指定的一块内存空间和变量名进行绑定&lt;/span&gt;；这个定义很简单，但其实很抽象，例如：int x = 5; 这是一句最简单的变量赋值语句了， 我们常说“x等于5”，其实这种说法是错误的，x仅仅是变量的一个名字而已，它本身不等于任何值的。这条statement的正确翻译应该是：“&lt;span&gt;将5赋值于名字叫做x的内存空间&lt;/span&gt;”，其本质是将值5赋值到一块内存空间，而这个内存空间名叫做x。切记：x只是简单的一个别名而已，x不等于任何值。其图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1287224/201712/1287224-20171205191709863-1180849088.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 变量在内存中的操作其实是需要经过2个步骤的：&lt;/p&gt;
&lt;p&gt;1）找出与变量名相对应的内存地址。&lt;/p&gt;
&lt;p&gt;2）根据找到的地址，取出该地址对应的内存空间里面的值进行操作。&lt;/p&gt;
&lt;p&gt; 二：指针的结构和原理&lt;/p&gt;
&lt;p&gt;首先介绍到底什么是指针？指针变量和任何变量一样，也有变量名，和这个变量名对应的内存空间，只是指针的特殊之处在于：&lt;span&gt;指针变量相对应的内存空间存储的值恰好是某个内存地址。&lt;span&gt;这也是指针变量区别去其他变量的特征之一。例如某个指针的定义如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; *ptr = &amp;amp;x;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ptr即是一个指正变量名。通过指针获取这个指针指向的内存中的值称为dereference，这个的中文翻译叫啥我也不知道。【惭愧】，哈哈。dereference&lt;/p&gt;

&lt;p&gt;其相对于内存空间的表示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1287224/201712/1287224-20171205192649347-770389909.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;特别提醒：这里千万千万不要钻进变量名x, ptr的牛角尖里面，不要去思考这些变量名存储在哪里，变量名仅仅是一块内存空间的代号名字而已，我们应该关心的是这些变量名相对应的内存地址。&lt;span&gt;根据上面的分析可以看出，指针变量和任何变量在内存中的形式是相同的，仅仅在于其存储的值比较特殊而已。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;三：引用在内存中的结构和原理&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;引用（reference）在C++中也是经常被用到，尤其是在作为函数参数的时候，需要在函数内部修改更新函数外部的值的时候，可以说是引用场景非常丰富。但程序员一般很难或者不注意分析reference和pointer，只是知道怎么应用而已，而不去具体分析这个reference。下面我就来简单的分析一下这个reference。首先我们必须明确的一点就是：&lt;span&gt;reference是一种特殊的pointer。&lt;span&gt;从这可以看出reference在内存中的存储结构应该跟上面的指针是一样的，也是存储的一块内存的地址。例如reference的定义如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; &amp;amp;y = x;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reference 和 pointer主要有以下3中不同点：&lt;/p&gt;
&lt;p&gt;1）reference不需要dereference即可直接获取到指向的内存空间的值。例如上例中，直接y就可以获取reference y所指向的内存空间的值，而不需要*y来获取。&lt;/p&gt;
&lt;p&gt;2）reference的赋值操作也不需要取地址符来赋值，可以直接通过变量名，例如上例中，int &amp;amp;y = x, 而不需要 int &amp;amp;y = &amp;amp;x;&lt;/p&gt;
&lt;p&gt;3) reference 在申明的时候就必须要有初始值，而且reference变量指向的内存地址是不能变化，不像pointer那样可以很灵活的重新指向其他地址。&lt;/p&gt;
&lt;p&gt;reference和pointer在内存中的结构和关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1287224/201712/1287224-20171205204220784-718862175.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;四：指针在Array中的应用和注意事项&lt;/p&gt;
&lt;p&gt;在C++中，一个Array类型的变量arr, 其实本质是一个指向数组第一个元素的指针。字符串string在C++中其实就是一个char类型的array，例如：char arr[] = {'a','b','c','d','e','\0'};这就是表示的一串字符串“abcde”，其中arr[0],arr[1], arr[2]..........之间相差的数值可能并不一定是1byte, 要根据这个数组的类型来判断，compiler会自动判断它们之间的相差值的; 另外在c++中字符串也可以用string literals(求大神翻译)的方式表示，即：char *arr2 = &quot;abcde&quot;; 但是通过string literal方式表示的字符串是read only的，不能修改的， 例如：*（arr2+1）= 'f'; 这句语句会产生error的。其在内存中的表现形式如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1287224/201712/1287224-20171205210211628-1586906130.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;五：指针不能dereference的情况&lt;/p&gt;
&lt;p&gt;但一个指针的值是invalid的时候，那么这个指针是不能dereference的。那么到底哪几种情况是invalid的呢？主要有以下几种情况：&lt;/p&gt;
&lt;p&gt;1）当这个指针的值是NULL的时候，这个指针是不能dereference的。因为指针为NULL，即表示这个指针指向内存地址为0的地址块，内存地址为0的内存空间是没有值的，所以是不能dereference的； 例如：int *ptr = NULL; cout&amp;lt;&amp;lt;*ptr&amp;lt;&amp;lt;endl; 是错误的。&lt;/p&gt;
&lt;p&gt;2）当某个指针被deallocte或者某个指针所在的内存空间被erase了的话，那么这个指针也是不能被dereference的；例如下面的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; *function(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a){
    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; temp = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &amp;amp;&lt;span&gt;temp;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码返回的指针也是不能dereference的，因为temp出了作用域后会被系统回收这一块空间，temp所占的内存空间已经被erase了，所以它返回的指针是一个指向被erase了的内存空间。也是不能dereference的，否则会出错。编译阶段会给出警告，在runtime的时候，如果dereference是会有error的。&lt;/p&gt;
&lt;p&gt;好了C++的指针（pointer）和引用（reference）就先总结到这里了。&lt;/p&gt;

&lt;p&gt;如果有什么问题欢迎大家的留言或者建议。谢谢&lt;/p&gt;

</description>
<pubDate>Tue, 05 Dec 2017 13:20:00 +0000</pubDate>
<dc:creator>算法生活</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tangxiaobo199181/p/7989464.html</dc:identifier>
</item>
<item>
<title>java.util.HashMap和java.util.HashTable (JDK1.8) - snowater</title>
<link>http://www.cnblogs.com/snowater/p/7742287.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowater/p/7742287.html</guid>
<description>&lt;h2&gt;一、java.util.HashMap&lt;/h2&gt;
&lt;h3&gt;1.1 java.util.HashMap 综述&lt;/h3&gt;
&lt;p&gt;java.util.HashMap继承结构如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201710/1244495-20171027142126633-680695965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HashMap是非线程安全的，key和value都支持null&lt;/p&gt;
&lt;p&gt;HashMap的节点是链表，节点的equals比较的是节点的key和value内容是否相等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt;&lt;span&gt; K key;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        V value;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         Node&amp;lt;K,V&amp;gt;&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         Node(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.hash =&lt;span&gt; hash;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; K getKey()        { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; key; }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; V getValue()      { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value; }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String toString() { &lt;span&gt;return&lt;/span&gt; key + &quot;=&quot; +&lt;span&gt; value; }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; Objects.hashCode(key) ^&lt;span&gt; Objects.hashCode(value);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; V setValue(V newValue) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             V oldValue =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             value =&lt;span&gt; newValue;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object o) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Map.Entry) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 Map.Entry&amp;lt;?,?&amp;gt; e = (Map.Entry&amp;lt;?,?&amp;gt;&lt;span&gt;)o;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (Objects.equals(key, e.getKey()) &amp;amp;&amp;amp;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                    Objects.equals(value, e.getValue()))
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.2 HashMap属性&lt;/h3&gt;
&lt;p&gt;HashMap中的成员变量如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] table;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;transient&lt;/span&gt; Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; entrySet;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; modCount;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; threshold;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; loadFactor;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;HashMap就是Node&amp;lt;K, V&amp;gt;数组，同时也是Map.Entry&amp;lt;K, V&amp;gt;集合。 transient修饰表明这些变量是不需要被序列化的。&lt;/p&gt;
&lt;p&gt;size是指当前HashMap中有多少个node；&lt;/p&gt;
&lt;p&gt;threshold表示下一次resize HashMap的值，换言之当size达到这个值的时候就需要扩容了，需要将现有的元素重新散列到扩容的空间；&lt;/p&gt;
&lt;p&gt;loadFactor加载因子，因为HashMap并不会等空间全部使用完在扩容，通常会预留一部分。该值默认为0.75，threshold = loadFactor * capacity （此处有个前提就是loadFactor * capacity &amp;lt; MAXIMUM_CAPACITY ，也即小于 1 &amp;lt;&amp;lt; 30）&lt;/p&gt;
&lt;p&gt;modCount表示HashMap发生结构性修改的次数。&lt;/p&gt;
&lt;h3&gt;1.3 HashMap方法&lt;/h3&gt;
&lt;p&gt;先来看下计算hash的函数 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash(Object key) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt;&lt;span&gt; h;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个hash算法实现的是：获取key的hashCode()，然后高16bit不变，低16bit和高16bit异或结果作为低16bit。&lt;/p&gt;
&lt;p&gt;在put和get方法时计算下标采用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; (n - 1) &amp;amp; hash
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;据代码注释解释，这种计算下标方式是综合考虑效率、作用和质量的结果。通常hash table的计算下标方式为模%，但是模%运算很容易发生碰撞，为什么这么说呢？不妨思考一下，在n - 1为15(0x1111)时，其实散列真正生效的只是低4bit的有效位，当然容易碰撞了。因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高16bit和低16bit异或了一下。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用&lt;code&gt;O(logn)&lt;/code&gt;的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。&lt;/p&gt;
&lt;p&gt;整个过程图示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171129205414229-352699172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Java 8中使用了链表和红黑树来解决hash碰撞问题。链表法get一个key的时间复杂度是O(1) + O(n)，红黑树get一个key的时间复杂度为O(1) + O(logn)。从二者时间复杂度也能看出如果只使用链表解决hash碰撞，当碰撞非常严重的时候，效率并不理想，因此设定了一个链表的长度阈值，当长度超过该阈值（默认为8）则将链表转换为红黑树。&lt;/p&gt;
&lt;p&gt;再来看下put方法，put方法的核心是putVal方法，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; V putVal(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onlyIfAbsent,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, i;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; table还未创建，则新建之&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;             n = (tab =&lt;span&gt; resize()).length;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((p = tab[i = (n - 1) &amp;amp; hash]) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Hash 位置无数据，则直接插入&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             tab[i] = newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             Node&amp;lt;K,V&amp;gt;&lt;span&gt; e; K k;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p.hash == hash &amp;amp;&amp;amp;
&lt;span&gt;13&lt;/span&gt;                 ((k = p.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; hash 位置上已经存在该key，则后续判断是否需要修改value&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 e =&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 红黑树节点，则将待插入节点插入到红黑树
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果插入过程中发现key已经存在于红黑树中，则后续判断是否需要修改value&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                 e = ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, tab, hash, key, value);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 链表，则插入链表末尾
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历链表过程中如果发现key已经存在，则后续判断是否需要修改value&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; binCount = 0; ; ++&lt;span&gt;binCount) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; ((e = p.next) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                         p.next = newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -1 for 1st
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 链表长度超过一定长度（默认为8）则将链表转换为红黑树&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                            treeifyBin(tab, hash);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;
&lt;span&gt;32&lt;/span&gt;                         ((k = e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发现key已经存在于链表中了&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                     p =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; table中已经存在该key了，根据onlyIfAbsent判断是否需要修改value&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; existing mapping for key&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;                 V oldValue =&lt;span&gt; e.value;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!onlyIfAbsent || oldValue == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                     e.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                afterNodeAccess(e);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         ++&lt;span&gt;modCount; 
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否需要resize&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (++size &amp;gt;&lt;span&gt; threshold)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            resize();
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        afterNodeInsertion(evict);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码为JDK 1.8 HashMap put方法的核心部分。当调用putVal方法的时候，先按照hash算法(n - 1) &amp;amp; hash去table中取数据，如果取出来的是null，则新建一个newNode(hash, key, value, null)存入到下标为(n - 1) &amp;amp; hash的位置。&lt;/p&gt;
&lt;p&gt;如果取出来的不是null，则说明table中以(n - 1) &amp;amp; hash为下标的位置上已经有数据了，这个时候有两种情况：有可能是该key已经存在于table中了，或者发生了hash冲突。&lt;/p&gt;
&lt;p&gt;如果确实key已经存在于table中了p.hash == hash &amp;amp;&amp;amp; ((k = p.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k)))），那么则查看onlyIfAbsent参数，如果为true则不修改该key的value，否则就更新value。&lt;/p&gt;
&lt;p&gt;如果发生了hash冲突，此时有两种解决方法，一种是红黑树，一种是链表。&lt;/p&gt;
&lt;p&gt;如果是链表，也很好解决，循环遍历链表，如果找到了某个节点的key等于待存入的key，则根据onlyIfAbsent决定是否需要更新value；找不到则新建一个节点存入到链表的结尾。当然这个链表不能无限制的扩展的，程序中设置链表最长为REEIFY_THRESHOLD - 1，也即为7。长度超过7则需要将链表构建为一颗红黑树。&lt;/p&gt;
&lt;p&gt;如果不是链表，则需要在红黑树中处理，红黑树中同样需要先查看key是否存在，存在则根据onlyIfAbsent决定是否更新value，不存在则new一个放入到红黑树中。&lt;/p&gt;
&lt;p&gt;整个putVal方法流程图如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171129201341370-682595395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每次调用putVal方法，如果key不存在于table中则会增加modCount，table修改次数加1。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] resize() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Node&amp;lt;K,V&amp;gt;[] oldTab =&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; oldCap = (oldTab == &lt;span&gt;null&lt;/span&gt;) ? 0&lt;span&gt; : oldTab.length;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; oldThr =&lt;span&gt; threshold;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; newCap, newThr = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt;=&lt;span&gt; MAXIMUM_CAPACITY) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 threshold =&lt;span&gt; Integer.MAX_VALUE;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldTab;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;
&lt;span&gt;12&lt;/span&gt;                      oldCap &amp;gt;=&lt;span&gt; DEFAULT_INITIAL_CAPACITY)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通常情况下threshold成倍扩展&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 newThr = oldThr &amp;lt;&amp;lt; 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; double threshold&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (oldThr &amp;gt; 0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; initial capacity was placed in threshold&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             newCap =&lt;span&gt; oldThr;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; {               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; zero initial threshold signifies using defaults
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;             newCap =&lt;span&gt; DEFAULT_INITIAL_CAPACITY;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             newThr = (&lt;span&gt;int&lt;/span&gt;)(DEFAULT_LOAD_FACTOR *&lt;span&gt; DEFAULT_INITIAL_CAPACITY);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (newThr == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;float&lt;/span&gt; ft = (&lt;span&gt;float&lt;/span&gt;)newCap *&lt;span&gt; loadFactor;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (&lt;span&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY ?
&lt;span&gt;26&lt;/span&gt;                       (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ft : Integer.MAX_VALUE);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         threshold =&lt;span&gt; newThr;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;             Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node[newCap];
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         table =&lt;span&gt; newTab;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不是初始化的resize，就需要重新hash了。&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (oldTab != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据oldCap遍历整个table&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; oldCap; ++&lt;span&gt;j) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 Node&amp;lt;K,V&amp;gt;&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; ((e = oldTab[j]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     oldTab[j] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (e.next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是单独的一个节点，则重新hash到新table中&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;                         newTab[e.hash &amp;amp; (newCap - 1)] =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是红黑树则分裂红黑树&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;                         ((TreeNode&amp;lt;K,V&amp;gt;)e).split(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, newTab, j, oldCap);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; preserve order 保持原来的顺序，否则多线程同时resize会出现jdk1.7中的死链问题
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对链表节点进行重新Hash，具体Hash算法下面详解&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;                         Node&amp;lt;K,V&amp;gt; loHead = &lt;span&gt;null&lt;/span&gt;, loTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                         Node&amp;lt;K,V&amp;gt; hiHead = &lt;span&gt;null&lt;/span&gt;, hiTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                         Node&amp;lt;K,V&amp;gt;&lt;span&gt; next;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                         &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                             next =&lt;span&gt; e.next;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; ((e.hash &amp;amp; oldCap) == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (loTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                                     loHead =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;                                     loTail.next =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                                 loTail =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                             &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                                 &lt;span&gt;if&lt;/span&gt; (hiTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;                                     hiHead =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;                                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt;                                     hiTail.next =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;                                 hiTail =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                         } &lt;span&gt;while&lt;/span&gt; ((e = next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (loTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                             loTail.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                             newTab[j] =&lt;span&gt; loHead;
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (hiTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;                             hiTail.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;                             newTab[j + oldCap] =&lt;span&gt; hiHead;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; newTab;
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当table的size超过threshold = capacity * loadFactor时，需要对HashMap进行resize操作。capacity表示table的总容量，size表示已经存入了多少node。threshold为阈值，超过该阈值则需要进行resize操作。&lt;/p&gt;
&lt;p&gt;resize的时候，通常情况为capacity &amp;lt;&amp;lt; 1， threshold &amp;lt;&amp;lt; 1，也即扩展为之前的两倍（超过MAXIMUM_CAPACITY情况另当别论）。&lt;/p&gt;
&lt;p&gt;无论是链表还是红黑树，其中节点在resize过后都需要重新重新hash，但是Java8中重新Hash设计的非常巧妙。举例说明，假设table从16扩展为32，具体变化为：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171129211829354-2137149303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;元素在重新计算hash之后，因为n变为2倍(capacity &amp;lt;&amp;lt; 1)，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171129211944479-123467570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171129212053292-514748162.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的table中。牛逼！&lt;/p&gt;
&lt;p&gt; 两个主要的函数理解之后，其它方法就不是很困难了。再来看下get方法，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(Object key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Node&amp;lt;K,V&amp;gt;&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (e = getNode(hash(key), key)) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : e.value;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; getNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash, Object key) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; first, e; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n; K k;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((tab = table) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
&lt;span&gt; 9&lt;/span&gt;             (first = tab[(n - 1) &amp;amp; hash]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (first.hash == hash &amp;amp;&amp;amp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; always check first node&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 ((k = first.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断找到的第一个节点，如果key相等（相等是为了处理key为null的情况）或equal则直接返回第一个&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; first;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ((e = first.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (first &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是红黑树则去红黑树中查找该key&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt; ((TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;)first).getTreeNode(hash, key);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 剩下一种情况就是链表了，直接遍历链表查找&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;
&lt;span&gt;21&lt;/span&gt;                         ((k = e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 } &lt;span&gt;while&lt;/span&gt; ((e = e.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据上面的描述，get方法还是很好理解的。在查找的时候，除了比较hash以外，还会比较key的内容(k = e.key) == key || (key != null &amp;amp;&amp;amp; key.equals(k)))。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; V remove(Object key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Node&amp;lt;K,V&amp;gt;&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; (e = removeNode(hash(key), key, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;)) == &lt;span&gt;null&lt;/span&gt; ?
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : e.value;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; removeNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash, Object key, Object value,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                                &lt;span&gt;boolean&lt;/span&gt; matchValue, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; movable) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         Node&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, index;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先get到对应key的节点，这部分代码跟get方法一样&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((tab = table) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;
&lt;span&gt;12&lt;/span&gt;             (p = tab[index = (n - 1) &amp;amp; hash]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             Node&amp;lt;K,V&amp;gt; node = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, e; K k; V v;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (p.hash == hash &amp;amp;&amp;amp;
&lt;span&gt;15&lt;/span&gt;                 ((k = p.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该下标上存放的第一个节点就是要查找的节点&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 node =&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((e = p.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (p &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从红黑树中查找该节点&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                     node = ((TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;)p).getTreeNode(hash, key);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历链表查找该节点&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;
&lt;span&gt;26&lt;/span&gt;                             ((k = e.key) == key ||
&lt;span&gt;27&lt;/span&gt;                              (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k)))) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                             node =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存节点&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;                         p =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     } &lt;span&gt;while&lt;/span&gt; ((e = e.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             
&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (!matchValue || (v = node.value) == value ||
&lt;span&gt;38&lt;/span&gt;                                  (value != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; value.equals(v)))) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (node &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从红黑树中移除掉该节点&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;                     ((TreeNode&amp;lt;K,V&amp;gt;)node).removeTreeNode(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, tab, movable);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (node ==&lt;span&gt; p)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个节点就是待删除节点，直接将next节点存放到index位置&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;                     tab[index] =&lt;span&gt; node.next;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 链表，p为待删除节点的前一个节点&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;                     p.next =&lt;span&gt; node.next;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 ++&lt;span&gt;modCount;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 --&lt;span&gt;size;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                afterNodeRemoval(node);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;https://tech.meituan.com/java-hashmap.html&lt;/p&gt;
&lt;p&gt;https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/&lt;/p&gt;

&lt;h2&gt;二、java.util.Hashtable&lt;/h2&gt;
&lt;h3&gt;2.1 java.util.Hashtable综述&lt;/h3&gt;
&lt;p&gt;继承结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1244495/201711/1244495-20171130201442586-1353436731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hashtable是线程安全的，key和value都不支持null。&lt;/p&gt;
&lt;h3&gt;2.2 Java.util.Hashtable属性&lt;/h3&gt;
&lt;p&gt;Hashtable属性如下，跟HashMap一样，也是一个数组。count表示当前table中有多少个Entry，threshold、loadFactor和modCount意义同HashMap。Hashtable的初始化capacity为11，loadFactor默认为0.75f。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; Entry&amp;lt;?,?&amp;gt;&lt;span&gt;[] table;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; threshold;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; modCount = 0;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.3 Java.util.Hashtable方法&lt;/h3&gt;
&lt;p&gt;先来看下get方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; V get(Object key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Entry&amp;lt;?,?&amp;gt; tab[] =&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; key.hashCode();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; index = (hash &amp;amp; 0x7FFFFFFF) %&lt;span&gt; tab.length;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;?,?&amp;gt; e = tab[index] ; e != &lt;span&gt;null&lt;/span&gt; ; e =&lt;span&gt; e.next) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ((e.hash == hash) &amp;amp;&amp;amp;&lt;span&gt; e.key.equals(key)) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (V)e.value;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;get方法是synchronized方法，多线程执行的时候给整个hashtable对象加锁，这样一来效率肯定会打折扣，但是线程是安全的。&lt;/p&gt;
&lt;p&gt;在hashtable中，index = (hash &amp;amp; 0x7FFFFFFF) % tab.length，将key.hashCode()除去符号位模上tab.length。目前hashtable仍然只使用了链表去解决hash碰撞问题，因此，如果tab[index]没找到，则遍历链表继续查找即可，算法复杂读O(n)。&lt;/p&gt;
&lt;p&gt;在查找的时候除了比较hash值以外还会要求e.key.equals(key)对内容进行比较，因为key不允许为null，因此e.key也能保证不为null。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addEntry(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         modCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         Entry&amp;lt;?,?&amp;gt; tab[] =&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (count &amp;gt;=&lt;span&gt; threshold) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 超过阈值，需要扩容，重新hash
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Rehash the table if the threshold is exceeded&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            rehash();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;             tab =&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             hash =&lt;span&gt; key.hashCode();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             index = (hash &amp;amp; 0x7FFFFFFF) %&lt;span&gt; tab.length;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Creates the new entry.&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存下当前链表头部节点&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         Entry&amp;lt;K,V&amp;gt; e = (Entry&amp;lt;K,V&amp;gt;&lt;span&gt;) tab[index];
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入到链表头部&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         tab[index] = &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;&amp;gt;&lt;span&gt;(hash, key, value, e);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Make sure the value is not null&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (value == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Makes sure the key is not already in the hashtable.&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         Entry&amp;lt;?,?&amp;gt; tab[] =&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; key.hashCode();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; index = (hash &amp;amp; 0x7FFFFFFF) %&lt;span&gt; tab.length;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         Entry&amp;lt;K,V&amp;gt; entry = (Entry&amp;lt;K,V&amp;gt;&lt;span&gt;)tab[index];
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(; entry != &lt;span&gt;null&lt;/span&gt; ; entry =&lt;span&gt; entry.next) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ((entry.hash == hash) &amp;amp;&amp;amp;&lt;span&gt; entry.key.equals(key)) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果key已经存在于hashtable，则直接替换旧的value&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;                 V old =&lt;span&gt; entry.value;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 entry.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; old;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新建Entry，放在index位置上链表的头部    &lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        addEntry(hash, key, value, index);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面为put方法，put方法还是比较简单的，已经存在就更新value值，冲突了就添加到链表头部。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; V remove(Object key) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         Entry&amp;lt;?,?&amp;gt; tab[] =&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; key.hashCode();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定位下标&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; index = (hash &amp;amp; 0x7FFFFFFF) %&lt;span&gt; tab.length;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         Entry&amp;lt;K,V&amp;gt; e = (Entry&amp;lt;K,V&amp;gt;&lt;span&gt;)tab[index];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历链表，prev保存前一个节点&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(Entry&amp;lt;K,V&amp;gt; prev = &lt;span&gt;null&lt;/span&gt; ; e != &lt;span&gt;null&lt;/span&gt; ; prev = e, e =&lt;span&gt; e.next) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ((e.hash == hash) &amp;amp;&amp;amp;&lt;span&gt; e.key.equals(key)) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 modCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 链表删除节点&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (prev != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     prev.next =&lt;span&gt; e.next;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     tab[index] =&lt;span&gt; e.next;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 count--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 V oldValue =&lt;span&gt; e.value;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 e.value = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;remove节点也比较简单。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rehash() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; oldCapacity =&lt;span&gt; table.length;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Entry&amp;lt;?,?&amp;gt;[] oldMap =&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; overflow-conscious code
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扩容为oldCapacity两倍+1&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; newCapacity = (oldCapacity &amp;lt;&amp;lt; 1) + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (oldCapacity ==&lt;span&gt; MAX_ARRAY_SIZE)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Keep running with MAX_ARRAY_SIZE buckets&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             newCapacity =&lt;span&gt; MAX_ARRAY_SIZE;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         Entry&amp;lt;?,?&amp;gt;[] newMap = &lt;span&gt;new&lt;/span&gt; Entry&amp;lt;?,?&amp;gt;&lt;span&gt;[newCapacity];
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         modCount++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         threshold = (&lt;span&gt;int&lt;/span&gt;)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         table =&lt;span&gt; newMap;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扩容后需要对原有数据进行重新hash分配位置&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = oldCapacity ; i-- &amp;gt; 0&lt;span&gt; ;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (Entry&amp;lt;K,V&amp;gt; old = (Entry&amp;lt;K,V&amp;gt;)oldMap[i] ; old != &lt;span&gt;null&lt;/span&gt;&lt;span&gt; ; ) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 Entry&amp;lt;K,V&amp;gt; e =&lt;span&gt; old;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历链表&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                 old =&lt;span&gt; old.next;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重新确定位置&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; index = (e.hash &amp;amp; 0x7FFFFFFF) %&lt;span&gt; newCapacity;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新到来的节点插到链表开头位置&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;                 e.next = (Entry&amp;lt;K,V&amp;gt;&lt;span&gt;)newMap[index];
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 newMap[index] =&lt;span&gt; e;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;rehash扩容方法也还是比较简单，如果遇到链表遍历一下重新hash每个链表上的节点即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; V putIfAbsent(K key, V value) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        Objects.requireNonNull(value);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Makes sure the key is not already in the hashtable.&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         Entry&amp;lt;?,?&amp;gt; tab[] =&lt;span&gt; table;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; hash =&lt;span&gt; key.hashCode();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; index = (hash &amp;amp; 0x7FFFFFFF) %&lt;span&gt; tab.length;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         Entry&amp;lt;K,V&amp;gt; entry = (Entry&amp;lt;K,V&amp;gt;&lt;span&gt;)tab[index];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先查找是否存在&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (; entry != &lt;span&gt;null&lt;/span&gt;; entry =&lt;span&gt; entry.next) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; ((entry.hash == hash) &amp;amp;&amp;amp;&lt;span&gt; entry.key.equals(key)) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 V old =&lt;span&gt; entry.value;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (old == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     entry.value =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; old;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不存在，则创建新节点插到链表开头&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        addEntry(hash, key, value, index);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在putIfAbsent方法中需要先查找，找不到key或者key存在但是value为null，则插入。但是put方法中能确保插入的节点value都不为null，所以value为null的场景应该是不存在的。&lt;/p&gt;
</description>
<pubDate>Tue, 05 Dec 2017 12:36:00 +0000</pubDate>
<dc:creator>snowater</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snowater/p/7742287.html</dc:identifier>
</item>
<item>
<title>理解defineProperty以及getter、setter - 吕大豹</title>
<link>http://www.cnblogs.com/lvdabao/p/7989238.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvdabao/p/7989238.html</guid>
<description>&lt;p&gt;我们常听说vue是用getter与setter实现数据监控的，那么getter与setter到底是什么东西，它与defineProperty是什么关系，平时有哪些用处呢？本文将为大家一一道来。&lt;/p&gt;
&lt;h2 id=&quot;对象的属性&quot;&gt;对象的属性&lt;/h2&gt;
&lt;p&gt;按照一贯的“由浅到深”行文原则，我们先温习一下对象的属性。我们知道对象有自身的属性以及原型上的属性，它们都可以通过obj.key这样的方式访问到。&lt;/p&gt;
&lt;p&gt;要设置/修改对象的属性也是很简单的，只需obj.key='value'即可。要注意的是，如果key位于原型上，那么此时会在对象自身设置该值，而不是修改原型上的。&lt;/p&gt;
&lt;p&gt;另外需要注意的是，原型上的属性有时候会被for in给“不小心”遍历出来，例如下面的代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; arr &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; [&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;arr&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;__proto__&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(i &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; arr)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(arr[i])&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//输出：1234&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以我们一般在用for in的时候都要加上hasOwnProperty判断，或者是抛弃for in，用forEach.&lt;/p&gt;
&lt;h2 id=&quot;认识defineproperty&quot;&gt;认识defineProperty&lt;/h2&gt;
&lt;p&gt;defineProperty是挂载在Object上的一个方法，作用是：为对象定义一个属性，或是修改已有属性的值，并设置该属性的描述符。该方法返回修改后的对象。&lt;/p&gt;
&lt;p&gt;如果没有后半句作用的话，那它与obj.key = 'value'这种赋值语句没什么两样。他的完整语法是这样：&lt;code&gt;Object.defineProperty(obj, prop, descriptor)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;obj: 目标对象&lt;br/&gt;prop: 属性名称&lt;br/&gt;descriptor: 属性描述符&lt;/p&gt;
&lt;p&gt;前两个就不必讲了，需要重点理解的是第三参数。属性描述符用于定义该属性的一些特性。具体来讲分了两类：数据描述符（data descriptor）、访问描述符（accessor descriptor）.&lt;/p&gt;
&lt;p&gt;这两类描述符有两个必选项：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;configurable&lt;br/&gt;从字面意思看它表示“可配置”，含义是：当它为true时，该属性的描述符可被修改，并且该属性可被delete删除。同理，当它为false时，我们无法再次调用defineProperty去修改描述符，也不可通过delete删除。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;enumerable&lt;br/&gt;从字面意思看它表示“可枚举”，含义是：当它为true时，该属性可被迭代器枚举出来。比如使用for in或者是Object.keys。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来就是数据描述符（data descriptor）了，有两个：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;value&lt;br/&gt;这个就是该属性的值啦，即通过obj.key访问时返回。任何js数据类型都可以使用（number,string,object,function等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;writable&lt;br/&gt;这个也很好理解，表示改属性是否可写。当它为false时，属性不可被任何赋值语句重写。想要通过调用defineProperty修改value的方式也是不行的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;剩下的就是访问描述符啦，先卖个关子讲两个注意事项。&lt;/p&gt;
&lt;h2 id=&quot;描述符的原型与默认值&quot;&gt;描述符的原型与默认值&lt;/h2&gt;
&lt;p&gt;一般情况，我们会创建一个descriptor对象，然后传给defineProperty方法。如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;kw&quot;&gt;var&lt;/span&gt; descriptor &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;writable&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;defineProperty&lt;/span&gt;(obj&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'key'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; descriptor)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种情况是有风险的，如果descriptor的原型上面有相关特性，也会通过原型链被访问到，算入在对key的定义中。比如：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;descriptor&lt;/span&gt;.&lt;span class=&quot;va&quot;&gt;__proto__&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;enumerable&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;defineProperty&lt;/span&gt;(obj&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'key'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; descriptor)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getOwnPropertyDescriptor&lt;/span&gt;(obj&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'key'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//返回的enumerable为true&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了避免发生这样的意外情况，官方建议使用Object.freeze冻结对象，或者是使用Object.create(null)创建一个纯净的对象（不含原型）来使用。&lt;/p&gt;
&lt;p&gt;接下来的注意点是默认值，首先我们会想普通的赋值语句会生成怎样的描述符，如&lt;code&gt;obj.key=&quot;value&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以使用Object.getOwnPropertyDescriptor来返回一个属性的描述符:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;obj &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{};&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;obj&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getOwnPropertyDescriptor&lt;/span&gt;(obj&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'key'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;/*输出&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    configurable:true,&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    enumerable:true,&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    value:&quot;value&quot;,&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;    writable:true,&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;*/&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这也是复合我们预期的，通过赋值语句添加的属性，相关描述符都为true，可写可配置可枚举。但是使用defineProperty定义的属性，默认值就不是这样了，其规则是这样的：&lt;br/&gt;configurable: false&lt;br/&gt;enumerable: false&lt;br/&gt;writable: false&lt;br/&gt;value: undefined&lt;/p&gt;
&lt;p&gt;所以这里还是要注意下的，使用的时候把描述符写全，免得默认都成false了。&lt;/p&gt;
&lt;h2 id=&quot;getter与setter&quot;&gt;getter与setter&lt;/h2&gt;
&lt;p&gt;所谓getter与setter其实是两个概念，并没有这样的属性。与之对应的是两个访问描述符（access descriptor）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;get&lt;br/&gt;它是一个函数，访问该属性时会自动调用，函数的返回值即为该属性的value。默认为undefined。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;你可能会想，既有value又有get函数，那么属性的值是什么呢？那你就想多了，这种情况在定义的时候就直接报错了，本身逻辑就矛盾嘛。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;set&lt;br/&gt;它是一个函数，为该属性赋值时会自动调用，并且新值会被当做参数传入。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;看到这里你可能就眼前一亮了，为属性赋值的时候会自动执行一个函数，那岂不是就能监控到数据的变化，从而实现mvvm的双向绑定？其实vue的数据监控用到的核心原理也就是这个啦。如果你用过knockout可能感受会更深，knockout能做到在IE6都支持双向绑定，就是强制让属性值为函数类型，必须手动执行函数才能拿到值。&lt;/p&gt;
&lt;p&gt;还好现在有了浏览器的默认支持，ES5开始就支持gettter、setter了，现在移动端基本完全可用，pc端需要IE9+。&lt;/p&gt;
&lt;h2 id=&quot;实际应用&quot;&gt;实际应用&lt;/h2&gt;
&lt;p&gt;这么好用的方法，我们平时好像也不怎么用呀？写业务代码可能用到的确实少，但是当你要写一个公共模块乃至写一个框架时，就可能用到啦。&lt;/p&gt;
&lt;p&gt;比如你写一个公共模块，会往window上挂一些全局属性，并且你不希望别人在其他地方不小心覆盖这个属性，那就可以用defineProperty让该属性不可写、不可配置。贴一个我们项目中的代码：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;co&quot;&gt;//向全局挂载通用方法&lt;/span&gt;
&lt;span class=&quot;cf&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;let&lt;/span&gt; key &lt;span class=&quot;kw&quot;&gt;in&lt;/span&gt; methods)&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;methods&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;hasOwnProperty&lt;/span&gt;(key))&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;defineProperty&lt;/span&gt;(WIN&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; key&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;dt&quot;&gt;value        &lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; methods[key]
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外一个用途呢，就是你自己想干坏事。覆盖别人写的代码，比如写chrome插件刷页面。或者说是想篡改浏览器的一些信息。&lt;/p&gt;
&lt;p&gt;比如你想把浏览器的userAgent给改了，直接写&lt;code&gt;navigator.userAgent = 'iPhoneX'&lt;/code&gt;.你再输出一下userAgent，发现并没有修改。这是为什么呢？我们用这行代码看一下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;getOwnPropertyDescriptor&lt;/span&gt;(window&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'navigator'&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;//输出&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;configurable&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;enumerable&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;ƒ ()&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;dt&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;undefined&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原因就找到了，navigator是有setter的，每次取值总会执行这个set函数来做返回。但是好消息是什么呢？configurable为true，那就意味这我们可以通过defineProperty来修改这个属性，代码就相当简单了：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;va&quot;&gt;Object&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;defineProperty&lt;/span&gt;(navigator&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'userAgent'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;dt&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;function&lt;/span&gt;()&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'iphoneX'&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;}}&lt;/span&gt;)
&lt;span class=&quot;va&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;va&quot;&gt;navigator&lt;/span&gt;.&lt;span class=&quot;at&quot;&gt;userAgent&lt;/span&gt;)&lt;span class=&quot;op&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//输出iphoneX&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;喏，篡改浏览器userAgent的方法我教给你了。&lt;/p&gt;
</description>
<pubDate>Tue, 05 Dec 2017 12:35:00 +0000</pubDate>
<dc:creator>吕大豹</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvdabao/p/7989238.html</dc:identifier>
</item>
</channel>
</rss>