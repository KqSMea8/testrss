<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Unity 点乘&amp;叉乘 应用实例 - 不敲代码了去打网球了</title>
<link>http://www.cnblogs.com/u3ddjw/p/8587767.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/u3ddjw/p/8587767.html</guid>
<description>&lt;h2&gt;一 前言&lt;/h2&gt;
&lt;h3&gt;1.可以解决的问题&lt;/h3&gt;
&lt;p&gt;　　　&lt;span&gt;　&lt;strong&gt;I.如何计算角度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　II.如何判断前后&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　III.如何判断逆时针还是顺时针。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　IV.如何判断其他物体在目标物体左右。&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　V.如何计算平行四边形面积&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;2.概述&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　主要概述了点乘，叉乘的实用例子，没有讲述什么原理性的，偏向应用层。点乘叉乘数学原理性的东西比较“难记”，网上很多。实用举例，网上算是比较少吧。故，来总结一番。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;二 理论知识&lt;/h2&gt;
&lt;h3&gt;1.点乘性质&lt;/h3&gt;
&lt;p&gt; 　　　　　&lt;span&gt;　 a · b = |a|*|b| cosθ   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　  a ·b = b·a&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　  结果是float类型&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.叉乘性质&lt;/h3&gt;
&lt;p&gt;　　　　　　 &lt;span&gt;  aXb = c,c⊥a，c⊥b。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　   |aXb| = |a| |b| sinθ,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　a X b = -b X a&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　叉乘的结果还是向量，且其模就是那两个向量为边的平行四边形面积&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.性质总结&lt;/h3&gt;
&lt;p&gt;　　　　&lt;span&gt;　　根据点乘，叉乘的公式得知，用到cos函数和sin函数，所以理解cos函数和sin函数很重要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;复习一下，我推荐使用根据函数图像理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　点乘，cos函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1134928/201810/1134928-20181029111525464-161721215.jpg&quot; alt=&quot;&quot; width=&quot;287&quot; height=&quot;113&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;叉乘，sin函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1134928/201810/1134928-20181029111628361-1449430711.jpg&quot; alt=&quot;&quot; width=&quot;289&quot; height=&quot;106&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三.分析&amp;amp;理解&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　    当然，这边计算角度，直接可以用Vector.Angle(p1,p2) 就可以解决，但是返回角度范围为（0,180）。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　我们根据上述点乘叉乘，可以得出，点乘，叉乘都可以算出角度。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;1.点乘 计算角度&lt;/h3&gt;
&lt;p&gt;　　       &lt;span&gt;  首先我们根据公式   a · b = |a|*|b| cosθ，θ∈（0,180）　 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　I.在知道a,b均为单位向量的情况，则 cosθ = Mathf.Dot(a,b)&lt;/span&gt;&lt;span&gt;这里的θ角度跟Vector.Angle的返回的结果是一致的(0,180)，则cosθ最终返回的也只是 （-1,1）之间.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　II.继续得出 θ =arcCos(Mathf.Dot(a,b)) ---------注意这个θ是弧度值，弧度制就类似π/2, 90度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　III.我们的目的是得出角度，则 angle = θ * Mathf.Rad2Deg     ----------注意：Mathf.Rad2Deg即为 180/π，与之相乘则弧度转角度；  注意区分Mathf.Deg2Rad 为π/180,角度转弧度，Deg即Degree，角度的意思。　&lt;/span&gt;　　　　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
  　　　 &lt;span&gt;float&lt;/span&gt; cosAngle =&lt;span&gt; Vector3.Dot(p1.normalized, p2.normalized);
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; angleDot = Mathf.Acos(cosAngle)*&lt;span&gt;Mathf.Rad2Deg;
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; angleVector =&lt;span&gt; Vector3.Angle(p1, p2);

        Debug.Log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;angleDot:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; angleDot);
        Debug.Log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;angleVector:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + angleVector);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 &lt;span&gt;   由上述对比，完全与Vector.Angle一致，结果都是0,180范围。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.点乘计算背向还是面向　　　&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;span&gt;　根据上述1中结果，可以使用其判断是面向还是背向，点乘结果&amp;gt;0, θ∈0，,90）则面向；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点乘结果&amp;gt;0,θ∈90,180，则背向。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3.叉乘计算角度&lt;/h3&gt;
&lt;p&gt;　　　&lt;span&gt;　我们根据公式 |aXb| = |a|*|b|*sin&amp;lt;θ&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　I.当然，我们只需要计算角度，还是需要转为单位向量计算最为方便，得出|aXb| = sin&amp;lt;θ&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　II.则得出，θ = ARCSin（|aXb|）, (Mathf.Magnitude，这是求向量长度）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　III.因为上述得出的是弧度制，依然 则 angle = Mathf.arcSin(|aXb|) *Mathf.Rad2Deg　　　&lt;/span&gt;&lt;span&gt;　　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 　    Vector3 corssResult =&lt;span&gt; Vector3.Cross(p1.normalized, p2.normalized);
　　　　&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; angleCross = Mathf.Asin(Vector3.Magnitude(corssResult)) *&lt;span&gt; Mathf.Rad2Deg;
　　　　Debug.Log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;angleCross:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; angleCross);
　　　　Debug.Log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;angleVector:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + angleVector);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;由上述对比得出angleCross 范围在（0,90）,即两个向量间的延伸交叉最小的夹角，这个真的有点出乎意料，需要自己注意一下&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个应用啥呐，应用“两个向量不考虑方向的情况之间谁更紧密”吧。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;4.如何判断逆时针还是顺时针&lt;/h3&gt;
&lt;p&gt;　　&lt;span&gt;（因为根据1 点乘中得出的角度，范围都只是0,180，并还不能清楚知道两个向量的具体方位，所以还缺个顺时针还是逆时针。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;span&gt;我们可以根据叉乘的性质 a X b  = - b X a ，可以根据叉乘的正负值，来判断a,b的相对位置，即b是出于a的顺时针还是逆时针。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里需要注意“叉乘的正负值”：&lt;span&gt;注意顺时针，逆时针的概念，是在2d空间中判断，所以需要指定两个维度，一般在x，y屏幕上，则判断z轴&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;上的正负，即为“叉乘的正负值”。　　&lt;/span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        Vector3 resultCross =&lt;span&gt; Vector3.Cross(p1, p2);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在指定x，y平面则判断z轴正负,为正，则p2在p1顺时针，为负，则p2在p1逆时针。&lt;/span&gt;
        Debug.Log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p1:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+p1+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; p2:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+p2 +&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;resultCross.z:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + resultCross.z);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5.如何判断物体在左边还是右边&lt;/h3&gt;
&lt;p&gt;　　其实判断在左边还是在右边，理论与4相似，只是需要稍微加工一下。假设p1为目标点，p2判断是在p1的左边还是右边。&lt;/p&gt;
&lt;p&gt;见图:&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1134928/201810/1134928-20181030140007197-793660675.jpg&quot; alt=&quot;&quot; width=&quot;332&quot; height=&quot;170&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为我们是在xy平面上,所以判断z轴&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; crossResult = Vector3.Cross(Vector3.up,p2-&lt;span&gt;p1).z;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Vector3.Cross(trans1.up, trans2.position - trans1.position).z; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;transform的写法&lt;/span&gt;
        Debug.Log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;crossResult:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + crossResult);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;crossResult 为正则在其左边，为负则在其右边。也4中顺时针，逆时针一个道理，只不过对比的是物体的正前方的向量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意如果为0，则是物体正前方，或者正后方；判断正后方还是正前方参考2中用法。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;6.如何计算出两向量组成的平行四边形面积&lt;/h3&gt;
&lt;p&gt;　　　&lt;span&gt;　根据平行四边形公式  S=a*h，h为高，a为底。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　a = |p1|&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　又因为h = |p2|*sinθ，则 a* h = |p1|*|p2|*sinθ&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　即 |p1Xp2| = S&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　   float s = Vector3.Magnitude(resultCross);&lt;/span&gt;　　　&lt;/p&gt;
&lt;h2&gt; 四 总结&lt;/h2&gt;
&lt;p&gt;　　　&lt;span&gt;　上述基本涵盖了游戏中的点乘叉乘的所有用法，都是自己敲一遍论证后的结果，当然，还需要你自己敲一遍,如有讲述错误，欢迎指正。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;哎，这是2018年唯一一篇比较原创花心思的博客，不能这样啦，博客要坚持写，代码要亲自敲啊。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 30 Oct 2018 07:11:00 +0000</pubDate>
<dc:creator>不敲代码了去打网球了</dc:creator>
<og:description>一 前言 1.可以解决的问题 I.如何计算角度 II.如何判断前后 III.如何判断逆时针还是顺时针。 IV.如何判断其他物体在目标物体左右。 V.如何计算平行四边形面积 2.概述 主要概述了点乘，叉</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/u3ddjw/p/8587767.html</dc:identifier>
</item>
<item>
<title>TCP 建立连接为什么要握 3 次手？ - YJK923</title>
<link>http://www.cnblogs.com/YJK923/p/9876942.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YJK923/p/9876942.html</guid>
<description>&lt;p&gt;上次已经说过，没有协议，不成方圆，计算机之间的通信更是依赖于协议。今天就重点分析一下 TCP 协议。&lt;/p&gt;

&lt;p&gt;传输控制协议 TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络 OSI 模型中，它完成第四层传输层所指定的功能，用户数据包协议（UDP）是同一层内另一个重要的传输协议。&lt;/p&gt;

&lt;p&gt;先来复习一下 OSI 的七层模型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1453063/201810/1453063-20181030150729434-1420032332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;TCP 工作在 OSI 中的第四层——Transport 层，IP 在第三层——Network 层，ARP 在第二层——Data Link 层；在第二层上的数据，我们把它叫 Frame，在第三层上的数据叫 Packet，第四层的数据叫 Segment。 同时，我们需要知道，数据从应用层发下来，会在每一层都会加上头部信息，进行封装，然后再发送到数据接收端。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1453063/201810/1453063-20181030150800633-34673057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;TCP 协议所涉及到的知识太多，没有办法兼顾，我主要想谈谈 3 次握手和 4 次挥手。TCP 的运行可以分为三个阶段，建立连接、传送数据、关闭连接。3 次握手 4 次挥手就对应着建立连接和关闭连接。&lt;/p&gt;

&lt;p&gt;操作系统将 TCP 连接抽象为套接字表示的本地端点，作为编程接口给程序使用。在 TCP 连接的生命期内，本地端点要经历一系列的状态改变。我们经常会听到面向 Socket 编程，这是后话了。&lt;/p&gt;

&lt;p&gt;要想知道握手是怎样进行了，我们先来看看 TCP 的报文结构。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1453063/201810/1453063-20181030150841943-452558303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;有以下几点需要说明&lt;/p&gt;

&lt;p&gt;TCP 报文中没有 IP 地址，有源端口和目的端口，IP 地址在网络层中的 Packet 中。&lt;/p&gt;

&lt;p&gt;Sequence Number（序号），用来标识从 TCP 发送端向 TCP 接收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节在数据流中的序号；通信双方要知道对方的初始化序号，这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP 会用这个序号来拼接数据）。&lt;/p&gt;

&lt;p&gt;Acknowledgment Number（确认号）32 位确认序列号包含发送确认的一端所期望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加 1。不过，只有当标志位中的 ACK 标志（下面介绍）为 1 时该确认序列号的字段才有效。主要用来解决不丢包的问题。&lt;/p&gt;

&lt;p&gt;SYN，表示同步序号，用来建立连接。SYN 标志位和 ACK 标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1。&lt;/p&gt;

&lt;p&gt;这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有 SYN 的数据包，如果对方主机响应了一个数据包回来 ，就表明这台主机存在这个端口；但是由于这种扫描方式只是进行 TCP 三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行 TCP 的三次握手。&lt;/p&gt;

&lt;p&gt;ACK，TCP 协议规定，只有 ACK=1 时有效，也规定连接建立后所有发送的报文的 ACK 必须为 1 。&lt;/p&gt;

&lt;p&gt;FIN，表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送 FIN 标志位的 TCP 数据包后，连接将被断开。这个标志的数据包也经常被用于进行端口扫描。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1453063/201810/1453063-20181030150918796-1854147170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;三次握手的过程，即建立一个 TCP 连接的过程，在 Socket 编程中，这一过程由客户端执行 connect 来触发，整个流程如上图所示。&lt;/p&gt;

&lt;p&gt;第一次握手：Client 将标志位 SYN 置为1，随机产生一个值 seq=x，并将该数据包发送给 Server，Client 进入 SYN_SENT 状态，等待 Server 确认。&lt;/p&gt;

&lt;p&gt;第二次握手：Server 收到数据包后由标志位 SYN=1 知道 Client 请求建立连接，Server 将标志位 SYN 和 ACK 都置为1，ack=x+1，随机产生一个值 seq=y，并将该数据包发送给 Client 以确认连接请求，Server 进入 SYN_RCVD 状态。&lt;/p&gt;

&lt;p&gt;第三次握手：Client 收到确认后，检查 ack 是否为 x+1，ACK 是否为1，如果正确则将标志位 ACK 置为1，ack=y+1，并将该数据包发送给 Server，Server 检查 ack 是否为 y+1，ACK 是否为1，如果正确则连接建立成功，Client 和 Server 进入 ESTABLISHED 状态，完成三次握手，随后 Client 与 Server 之间可以开始传输数据了。&lt;/p&gt;

&lt;p&gt;注意，不要搞混了 SYN、ACK 只是标志位，seq 是序号，防止乱序，ack 是确认号，主要用来解决不丢包的问题。&lt;/p&gt;

&lt;p&gt;四次挥手，即终止 TCP 连接，就是指断开一个 TCP 连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在 Socket 编程中，这一过程由客户端或服务端任一方执行 close 来触发。&lt;/p&gt;

&lt;p&gt;由于 TCP 连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 FIN 来终止这一方向的连接，收到一个 FIN 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个 TCP 连接上仍然能够发送数据，直到对方也发送了 FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。&lt;/p&gt;

&lt;p&gt;第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number 和 Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；&lt;/p&gt;

&lt;p&gt;第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；&lt;/p&gt;

&lt;p&gt;第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；&lt;/p&gt;

&lt;p&gt;第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明 Server 端已正常关闭，那好，主机1也可以关闭连接了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为什么建立连接需要 3 次握手 ？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为，TCP 协议要保证两端数据的可靠传输，最少就要采取 3 次交互。三次是保证双方互相明确对方能收能发的最低值。下面有个生活中的例子可以感受一下。&lt;/p&gt;

&lt;p&gt;TCP之所以使用三次握手，完全是一种为了解决“两军问题”所采用的折衷的设计。所谓“两军问题”，就是红军想告诉蓝军明天下午一起对敌开火，那么红军会派信使 1 号跑过去告诉蓝军，蓝军收到消息再派信使 2 号告诉红军收到，注意，这时蓝军并不知道红军是否收到蓝军的回复。因此需要红军收到回复再派信使 3 号告诉蓝军收到回复，而此时红军也不知道蓝军是否收到回复，因此蓝军收到信使 3 号的消息再派信使 4 号…&lt;/p&gt;

&lt;p&gt;还有一个秒懂例子，看到这个真的笑死我了。但是这个例子不严谨哦，权当一乐就好。&lt;/p&gt;

&lt;p&gt;三次握手：&lt;br/&gt;“喂，你听得到吗？”&lt;br/&gt;“我听得到呀，你听得到我吗？”&lt;br/&gt;“我能听到你，今天balabala……”&lt;/p&gt;

&lt;p&gt;两次握手：&lt;br/&gt;“喂，你听得到吗？”&lt;br/&gt;“我听得到呀”&lt;br/&gt;“喂喂，你听得到吗？”&lt;br/&gt;“草，我听得到呀！！！！”&lt;br/&gt;“你TM能不能听到我讲话啊！！喂！”&lt;br/&gt;“……”&lt;/p&gt;

&lt;p&gt;四次握手：&lt;br/&gt;“喂，你听得到吗？”&lt;br/&gt;“我听得到呀，你听得到我吗？”&lt;br/&gt;“我能听到你，你能听到我吗？”&lt;br/&gt;“……不想跟傻逼说话”&lt;/p&gt;

&lt;p&gt;所以说，握手次数要保持刚刚好，2 次不够，4 次多了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SYN 攻击&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 SYN 包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，正常的 SYN 请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。&lt;/p&gt;

&lt;p&gt;检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。&lt;/p&gt;

&lt;p&gt;如何防御 SYN 攻击 ？&lt;/p&gt;
&lt;p&gt;SYN 攻击不能完全被阻止，除非将 TCP 协议重新设计。我们所做的是尽可能的减轻 SYN 攻击的危害，常见的防御 SYN 攻击的方法有如下几种：&lt;/p&gt;

&lt;p&gt;缩短超时（SYN Timeout）时间&lt;/p&gt;
&lt;p&gt;增加最大半连接数&lt;/p&gt;
&lt;p&gt;过滤网关防护&lt;/p&gt;
&lt;p&gt;SYN cookies 技术&lt;/p&gt;
</description>
<pubDate>Tue, 30 Oct 2018 07:10:00 +0000</pubDate>
<dc:creator>YJK923</dc:creator>
<og:description>上次已经说过，没有协议，不成方圆，计算机之间的通信更是依赖于协议。今天就重点分析一下 TCP 协议。 传输控制协议 TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YJK923/p/9876942.html</dc:identifier>
</item>
<item>
<title>【福州活动】| &quot;福州首届.NET开源社区线下技术交流会&quot;(2018.11.10) - KAnts</title>
<link>http://www.cnblogs.com/ants/p/fz-one-community-activity.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ants/p/fz-one-community-activity.html</guid>
<description>&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　微软爱开源，已是尽人皆知的事实。自从收购全球最大的开源社区 GitHub 之后，微软依旧使 GitHub 保持独立运营，并且通过此项举措，微软本身已经成为最大的社区服务者。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;　　.NET Core&lt;/strong&gt;开源后取得了更加快速的发展，目前越活跃用户高达400万人，每月新增开发者45万，在 GitHub 上的月度增长达到15%。目前有来自超过3,700家企业的1.9万开发者在为 .NET Core 做贡献。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　基于微软对.NET开源社区的支持，因此在福州举办首届.NET开源社区线下技术交流会。此次交流会邀请到了三位资深专家作为分享嘉宾，将从Azure云服务、DDD、微服务与大家交流：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;《Azure介绍及应用》&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;《我在网龙的DDD实践之路》&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;《Hello Microservice》&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;活动须知&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;1、此次线下交流会纯公益，免费，感兴趣的同学抓紧时间报名吧。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;2、为了保证活动的质量，使话题能够深入展开，我们将限定参会人数，请您务必提前报名。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;报名网址：&lt;a href=&quot;http://dwr23tij34gntad1.mikecrm.com/XO5VomQ&quot; target=&quot;_blank&quot;&gt;http://dwr23tij34gntad1.mikecrm.com/XO5VomQ&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;报名二维码：报名成功后请加入社区微信群。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/384997/201810/384997-20181030141152810-1461964457.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;时间：&lt;/strong&gt;2018年11月10日 周六下午 13:30 -- 17:00&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;活动地点：&lt;/strong&gt;蒲公英创新工场(&lt;/span&gt;&lt;span&gt;泊寓万象城店&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;具体地址：&lt;/strong&gt;福州市台江区西二环路荷泽小区荷泽巷32号&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/384997/201810/384997-20181030141604653-848165142.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;300&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot;&gt;&lt;span&gt;13:30 – 13:55 签到&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;14:00 – 14:15 郭联钰 开场 《首届福州.NET开源社区启动及介绍》&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;14:15 – 14:55 谢鸿凯 《Azure介绍及应用》&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;15:00 – 15:40 林靖 《我在网龙的DDD实践之路》&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;15:45 – 16:25 马坚 《Hello Microservice》&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;16:25 – 16:40 会后总结及合影留念&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;16:40 – 17:00 自由讨论&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/384997/201810/384997-20181030142039938-1016617383.png&quot; alt=&quot;&quot; width=&quot;150&quot; height=&quot;200&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;开场《&lt;/strong&gt;&lt;strong&gt;首届福州.NET开源社区启动及介绍》&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;主持人：郭联钰，&lt;/strong&gt;网龙高级软件工程师,福州.NET开源社区发起者,擅长.NET Core微服务架构及容器运用，具有多年的软件研发经验。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/384997/201810/384997-20181030142400299-1183751718.png&quot; alt=&quot;&quot; width=&quot;248&quot; height=&quot;200&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;话题一《Azure介绍及应用》&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;分享人：谢鸿凯，&lt;/strong&gt;福建知鱼科技，云部门客户成功经理，云服务与企业服务领域专家，拥有多年的云服务应用和项目管理经验。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/384997/201810/384997-20181030141922789-1816519987.png&quot; alt=&quot;&quot; width=&quot;200&quot; height=&quot;200&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;话题二《我在网龙的DDD实践之路》&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;分享人：林靖，&lt;/strong&gt;网龙高级架构师，资深.NET、Kubernetes和容器化解决方案专家，超过10年的软件研发和项目管理经验。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/384997/201810/384997-20181030141938366-392344278.png&quot; alt=&quot;&quot; width=&quot;150&quot; height=&quot;200&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;话题三《Hello Microservice》&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;&lt;strong&gt;分享人：马坚，&lt;/strong&gt;健康之路高级架构师，微软最有价值专家Microsoft MVP，.NET开源社区贡献者以及福州.NET开源社区发起者，具有多年软件研发项目管理经验。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/384997/201810/384997-20181030142505139-692508522.png&quot; alt=&quot;&quot; width=&quot;325&quot; height=&quot;100&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/384997/201810/384997-20181030142512373-216532703.png&quot; alt=&quot;&quot; width=&quot;247&quot; height=&quot;100&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/384997/201810/384997-20181030142521386-1954520842.png&quot; alt=&quot;&quot; width=&quot;161&quot; height=&quot;100&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/384997/201810/384997-20181030142530733-919688329.png&quot; alt=&quot;&quot; width=&quot;334&quot; height=&quot;100&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/384997/201810/384997-20181030142535886-2138468823.png&quot; alt=&quot;&quot; width=&quot;116&quot; height=&quot;100&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p1&quot;&gt;泊寓万象城店&lt;span&gt;主打活动、社交、资源共享，这里聚集了一群有趣的灵魂，给在城市漂泊的青年一个家。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;泊寓万象城店招租热线15659125561，现在签约立减500。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 30 Oct 2018 06:34:00 +0000</pubDate>
<dc:creator>KAnts</dc:creator>
<og:description>活动介绍 微软爱开源，已是尽人皆知的事实。自从收购全球最大的开源社区 GitHub 之后，微软依旧使 GitHub 保持独立运营，并且通过此项举措，微软本身已经成为最大的社区服务者。 .NET Cor</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ants/p/fz-one-community-activity.html</dc:identifier>
</item>
<item>
<title>(2)shiro角色资源权限 - nfcm</title>
<link>http://www.cnblogs.com/nfcm/p/9875657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nfcm/p/9875657.html</guid>
<description>&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;一般在web系统权限设计中，一般分为三个维度，用户，角色，资源，一个用户可以拥有多个角色，比如说可以是老师，也可以是班主任，一个角色也可以拥有多个资源。&lt;/p&gt;
&lt;p&gt;比如老师同时拥有查看班级学生和批改作业的资源，如果一个用户有老师这个角色，那么就代表他拥有了查看班级学生和批改作业的两个资源权限。&lt;/p&gt;
&lt;p&gt;因为只判断角色颗粒度太粗，而根据资源权限则比较细。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;校验权限代码&lt;/h2&gt;
&lt;p&gt;在classpath下新建shiro-role.ini文件，内容如下：&lt;/p&gt;
&lt;p&gt;代表有一个zhang的用户，拥有role1角色（如果有多个角色，后面用逗号继续隔开role1,role2）&lt;/p&gt;
&lt;p&gt;role1这个角色有两个资源，分别是user:create和user:update。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[users]
zhang=123456,role1
[roles]
role1=user:create,user:update&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        Factory&amp;lt;SecurityManager&amp;gt; factory =&lt;span&gt;new&lt;/span&gt; IniSecurityManagerFactory(&quot;classpath:shiro-role.ini&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到安全管理器&lt;/span&gt;
        SecurityManager securityManager =&lt;span&gt; factory.getInstance();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将securityManager托管给SecurityUtils&lt;/span&gt;
&lt;span&gt;        SecurityUtils.setSecurityManager(securityManager);

        Subject subject &lt;/span&gt;=&lt;span&gt; SecurityUtils.getSubject();

        UsernamePasswordToken token &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; UsernamePasswordToken(&quot;zhang&quot;, &quot;123456&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            subject.login(token);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (AuthenticationException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否已经认证&lt;/span&gt;
&lt;span&gt;        System.out.println(subject.isAuthenticated());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验是否有对应的权限和资源，如果没有则抛出对应的异常UnauthorizedException&lt;/span&gt;
        subject.checkRole(&quot;role1&quot;&lt;span&gt;);
        subject.checkPermission(&lt;/span&gt;&quot;user:create&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;退出&lt;/span&gt;
        subject.logout();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;过程没有遇到任何错误，执行到了最后，但是如果你check一个zhang不存在的role或者permission，则会报UnauthorizedException。&lt;/p&gt;

&lt;h2&gt;身份和凭证&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在登陆中，用户需要提供principals(身份)和credentials（证明/凭证）提供给shiro来进行认证和授权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;principals可以有多个身份，但是只能有一个Primary principals，一般是登录账号，比如手机号。&lt;/p&gt;
&lt;p&gt;credentials一般是密码。&lt;/p&gt;
&lt;p&gt;在UsernamePasswordToken的账户密码就对应着身份和凭证。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100855/201810/1100855-20181030140515946-461935455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;subject.login()原理&lt;/h2&gt;
&lt;p&gt;当执行subject.login的时候，实际调用的是securityManager所属的Authenticator（默认是ModularRealmAuthenticator）的doAuthenticate方法进行验证。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100855/201810/1100855-20181030153035165-702233837.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt; 他会根据当前设置了几个realm走不同的方法（后面介绍多个realms）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100855/201810/1100855-20181030153155746-1020983215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 最终走的realm对应的getAuthenticationInfo方法，判断用户账号密码是否正确，如果错误则抛出对应的异常。正确则返回一个AuthenticationInfo对象。（这里是SimpleAuthenticationInfo）&lt;/p&gt;
&lt;p&gt; &lt;span&gt;所以后面我们自定义realms的时候就覆盖getAuthenticationInfo这个方法即可。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;subject.checkRole原理&lt;/h2&gt;
&lt;p&gt;当用户调用subject.checkRole(&quot;role1&quot;)判断用户是否有对应的角色的时候，底层还是走的SecurityManager所属的Authorizer的checkRole方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100855/201810/1100855-20181030135019761-699582805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;hasRole然后又走了下面的方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100855/201810/1100855-20181030141532163-1352570323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后获取到了所有的realms，上篇文章说了java环境下使用了IniRealm，并且注入到了Authenticator（认证器）和Authorizer（授权器）的一个成员变量中。&lt;/p&gt;
&lt;p&gt;所以getRealms就可以直接获取到所有的realms&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100855/201810/1100855-20181030141931771-686158506.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为IniRealms继承了AuthorizingRealm，而IniRealm没有实现hasRole方法，所以会走他的继承类AuthorizingRealm里面的hasRole来判断是否有权限。下面就是对应的方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100855/201810/1100855-20181030142246869-1941313997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在初始化IniRealm的时候会读取所有用户所属的role和permission并封装到变量中，getAuthorizationInfo方法创建了一个AuthorizationInfo对象里面获取了zhang所属role和permission。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100855/201810/1100855-20181030142603092-931179141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后进行checkRole就很容易看懂了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1100855/201810/1100855-20181030142913505-397472387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果返回false，则Authorizer会抛出UnauthorizedException授权失败异常。&lt;/p&gt;

&lt;h2&gt;github地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cmniefei/shiroparent&quot; target=&quot;_blank&quot;&gt;https://github.com/cmniefei/shiroparent&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 30 Oct 2018 06:33:00 +0000</pubDate>
<dc:creator>nfcm</dc:creator>
<og:description>一般在web系统权限设计中，一般分为三个维度，用户，角色，资源，一个用户可以拥有多个角色，比如说可以是老师，也可以是班主任，一个角色也可以拥有多个资源。 比如老师同时拥有查看班级学生和批改作业的资源，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nfcm/p/9875657.html</dc:identifier>
</item>
<item>
<title>[翻译] 初看 ASP.NET Core 3.0 即将到来的变化 - Rwing</title>
<link>http://www.cnblogs.com/Rwing/p/a-first-look-at-changes-coming-in-asp-net-core-3-0.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rwing/p/a-first-look-at-changes-coming-in-asp-net-core-3-0.html</guid>
<description>&lt;p&gt;原文: &lt;a href=&quot;https://blogs.msdn.microsoft.com/webdev/2018/10/29/a-first-look-at-changes-coming-in-asp-net-core-3-0/&quot;&gt;A first look at changes coming in ASP.NET Core 3.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在我们努力&lt;a href=&quot;https://blogs.msdn.microsoft.com/webdev/2018/10/17/asp-net-core-2-2-0-preview3-now-available/&quot;&gt;完成下一个 minor 版本的 ASP.NET Core&lt;/a&gt; 的同时，我们也在对下一个 major 版本进行更新，其中包括如何使用框架组合项目、更紧密的 .NET Core 集成以及第三方开源集成，所有这些事的目标都是为了让您更容易、更快速地开发。有关 .NET Core 3.0 的更多内容，我们建议您查看我们&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2018/10/04/update-on-net-core-3-0-and-net-framework-4-8/&quot;&gt;之前&lt;/a&gt;关于在 Windows 上添加对 .NET Core 3.0 的 WinForms 和 WPF 支持的公告。我们将在不久的将来发布有关 ASP.NET Core 3.0 中新功能的更多详细信息。&lt;/p&gt;
&lt;h2 id=&quot;包-vs-框架&quot;&gt;包 vs 框架&lt;/h2&gt;
&lt;p&gt;历史的原因，经过不同的版本和年代，ASP.NET Core 的项目引用和运行方式已经发生了变化。在 1.0 中，ASP.NET Core 本身就只是一个包，像引用其他 Nuget 包一样的出现在项目。这有利有弊，&lt;br/&gt;随着时间的推移，我们已经改进了这个模型，试图平衡模块化引用与更大且必备框架之间的优劣势。在 2.1 中，ASP.NET Core 最终发展成为一个 .NET Core “共享框架”（就像 .NET Core 本身的基础框架 Microsoft.NETCore.App 一样）。ASP.NET Core 团队成员 Nate McMaster 撰写的&lt;a href=&quot;https://natemcmaster.com/blog/2018/08/29/netcore-primitives-2/&quot;&gt;这篇博客文章&lt;/a&gt;很好地解释了共享框架的工作原理，同时也了指出当前方法的一些问题。我们在 3.0 中引入的更新旨在为所有用户减少这些问题。&lt;/p&gt;
&lt;p&gt;作为本次更新的一部分，&lt;a href=&quot;https://github.com/aspnet/Announcements/issues/325&quot;&gt;将从 ASP.NET Core 3.0 共享框架中删除一些值得注意的子组件&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Json.NET (Newtonsoft.Json)&lt;/li&gt;
&lt;li&gt;Entity Framework Core (Microsoft.EntityFrameworkCore.*)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有关在 .NET Core 中添加 JSON API 的更多详细信息，请参阅此&lt;a href=&quot;https://github.com/dotnet/announcements/issues/90&quot;&gt;公告&lt;/a&gt;。对于现在仍然依赖于 Json.NET 的地方（例如 MVC 中的 JSON 格式化），我们将继续提供该集成的软件包，但默认将改为使用即将推出的内置 JSON API。&lt;/p&gt;
&lt;p&gt;Entity Framework Core 将作为 3.0 中的 “纯” NuGet 包发布。这使得其发布模式与 .NET 上的其他数据访问库相同，用最简单的方式保持持续更新，提供各种 .NET 平台的支持。注意，Entity Framework Core 移出共享框架对其作为 Microsoft 旗下开发、支持和维护的库的状态没有影响，并且它将继续被 &lt;a href=&quot;https://www.microsoft.com/net/platform/support-policy&quot;&gt;.NET Core 支持策略&lt;/a&gt;所覆盖。&lt;/p&gt;
&lt;h2 id=&quot;充分利用-.net-core&quot;&gt;充分利用 .NET Core&lt;/h2&gt;
&lt;p&gt;正如&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2018/10/04/update-on-net-core-3-0-and-net-framework-4-8/&quot;&gt;本月早些时候在 .NET 博客上所宣布&lt;/a&gt;的那样，由于 .NET Framework 的更新策略以及可能对现有应用程序带来破坏，.NET Framework 将只会获得很少的 .NET Core 的新平台新语言特性。为了确保 ASP.NET Core 能够充分利用 .NET Core 未来的发展改进，&lt;a href=&quot;https://github.com/aspnet/Announcements/issues/324&quot;&gt;ASP.NET Core 将从 3.0 开始仅支持在 .NET Core 上运行&lt;/a&gt;。展望未来，您可以简单地将 ASP.NET Core 视为 .NET Core 的一部分。&lt;/p&gt;
&lt;p&gt;今天在 .NET Framework 上使用 ASP.NET Core 的客户可以继续使用完全支持的 2.1 LTS 版本。2.1 的支持和服务将持续到2021年8月21日。&lt;/p&gt;
&lt;p&gt;有关从 .NET Framework 移植到 .NET Core 的更多信息，请参阅此&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/porting/&quot;&gt;文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;通过专注的第三方开源集成提供更多价值&quot;&gt;通过专注的第三方开源集成提供更多价值&lt;/h2&gt;
&lt;p&gt;与此同时，我们对 3.0 中“平台”的构成做了更明确的区分，从该层中删除了第三方组件，我们认识到, 许多更高层次的方案都是由已建立、有能力且支持良好的开源组件提供最佳支持的, 我们可以帮助支持这些组件更好的集成到 ASP.NET Core 应用程序中。&lt;/p&gt;
&lt;p&gt;这种支持将采取不同的形式, 包括我们团队构建的一流集成 API 和包、我们的工程师对现有库的贡献、使用这些库的默认体验中的项目模板、官方 ASP.NET Core上文档站点、以及处理关键问题和 bug 修复 (包括安全性) 的过程。&lt;/p&gt;
&lt;p&gt;我们已经在 2.2 版本中开始了这一过程，为流行的 IdentityServer 库开发了&lt;a href=&quot;https://github.com/aspnet/Identity/issues/2033&quot;&gt;新的集成&lt;/a&gt;，这将帮助我们在构建 ASP.NET Core 应用程序中的 API 授权时非常简单和实用，同时允许客户在需要时充分利用 IdentityServer 其功能。&lt;/p&gt;
&lt;p&gt;我们还致力于简化构建 HTTP API 的体验，新的 &lt;a href=&quot;https://blogs.msdn.microsoft.com/webdev/2018/08/23/asp-net-core-2-20-preview1-open-api-analyzers-conventions/&quot;&gt;API 约定和分析器&lt;/a&gt;可以更轻松地使用流行的 Open API库（如 Swashbuckle 和 NSwag），以及一个新的 &lt;a href=&quot;https://github.com/aspnet/Mvc/issues/7947&quot;&gt;API 客户端生成系统&lt;/a&gt;，可以非常简单与代码生成器集成，例如 AutoRest 和 NSwag。&lt;/p&gt;
&lt;p&gt;如果你对我们新的&lt;a href=&quot;https://blogs.msdn.microsoft.com/webdev/2018/08/22/asp-net-core-2-2-0-preview1-healthcheck/&quot;&gt;健康检查功能&lt;/a&gt;感兴趣，&lt;a href=&quot;https://github.com/Xabaril/AspNetCore.Diagnostics.HealthChecks&quot;&gt;BeatPulse 库&lt;/a&gt;的作者正在努力移植他们的库。&lt;/p&gt;
&lt;p&gt;我们打算将这些经验汇集到一个新的项目模板中，以便在 2.2 发布之后提供。&lt;/p&gt;
&lt;h2 id=&quot;尾声&quot;&gt;尾声&lt;/h2&gt;
&lt;p&gt;请持续关注，我们会继续发布 ASP.NET Core 在 .NET Core 3.0 中的变化，包括我们在此版本中将要启用的新功能的简介。我们会定期在公告中发布变更详情和其他信息，我们鼓励您订阅。&lt;/p&gt;
</description>
<pubDate>Tue, 30 Oct 2018 06:00:00 +0000</pubDate>
<dc:creator>Rwing</dc:creator>
<og:description>在我们努力[完成下一个 minor 版本的 ASP.NET Core](https://blogs.msdn.microsoft.com/webdev/2018/10/17/asp-net-core-</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Rwing/p/a-first-look-at-changes-coming-in-asp-net-core-3-0.html</dc:identifier>
</item>
<item>
<title>从壹开始微服务 [ DDD ] 之四 ║让你明白DDD的小故事 &amp; EFCore初探 - 老张的哲学</title>
<link>http://www.cnblogs.com/laozhang-is-phi/p/9872450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laozhang-is-phi/p/9872450.html</guid>
<description>&lt;p&gt;哈喽大家好哟，今天又到了老张的周二四放送时间了，当然中间还有不定期的更新（因为个人看papi酱看多了），这个主要是针对小伙伴提出的问题和优秀解决方案而写的，经过上周两篇DDD领域驱动设计的试水，我发现一个问题，这个DDD的水是真的深啊~或者来说就是这个思想的转变是不舒服的，好多小伙伴就说有点儿转不过来，当然我也是，一直站在原地追着影子跑，当然这个系列我会一直坚持下去的，大家如果感觉我写的没有误人子弟或者感觉看着还有点儿意思，请不要着急，多多评论，我虽然没有更新，但是也一直在线，提出来的问题可以一起讨论，周末的时候，我又和“李大爷”一起从非专业的角度，从领域专家的角度思考了下DDD领域驱动设计的思想，感觉还有点儿领悟的，这里给大家分享下，如果你现在还对为什么使用DDD，或者还有DDD就像是一个三层架构或者MVC架构的想法的话，看完这一篇应该就能稍微的明白了。&lt;/p&gt;
&lt;p&gt;很开森的是上周的问题大家评论很好，也上了24小时评论榜单，希望大家都可以多评论评论😀，真的很精彩，大家可以再去看看《&lt;a id=&quot;post_title_link_9832684&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9832684.html&quot;&gt;二 ║ DDD入门 &amp;amp; 项目结构粗搭建&lt;/a&gt;》，评论席的内容的含金量，甚至都超过了我的正文内容，而且也能满足老张小小的虚荣感，今天呢，我就先在本文的上半篇重点说一下大家最最最热心的两个问题，然后再继续推进咱们的项目代码，就主要从以下三个大块铺开来说：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;1、DDD的意义到底在哪里？为什么很难理解？&lt;/p&gt;
&lt;p&gt;2、为什么要使用仓储，EFCore不就是一个仓储么？&lt;/p&gt;
&lt;p&gt;3、限界上下文如何定义呢？包含了平时遇到的哪些东西？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;悄悄说：经过周末的讨论，我发现上次咱们新建的那个关于 Customer 领域对象不好举例子，问答程序说起来也不是很顺口，所以我已经修改成了 Student 模型，然后我也想到了一个领域——教务系统，这个大家一定是熟悉的不能再熟悉了，每个小伙伴都是经过上学的噩梦里过来的（哈哈学霸就另说了），以后咱们就用这个教务领域来展开说明，大家也能都在一条思路上，而且也不会花心思去考虑问答系统这个不熟悉的领域。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201810/1468246-20181029184017896-1775027041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;关于DDD的使用，网上已经有很多的栗子了，无论是各种粘贴复制的教科书，还是自我的一些心得，基本已经说完了，不过我每次读的时候，心里都是有点儿抗拒，一直都没办法看懂，今天我就决定用另一个办法，来和大家好好说一下这个DDD领域驱动设计的意义到底在哪里。这个时候请你自己先想一想，如果使用DDD会有哪些好处，如果说看完了我写的，感觉有共鸣，那很不错，要是感觉我写的认为不对，欢迎评论席留下你的意见哟，开源嘛，不能让我自己发表看法的，也让我的博客可以多在大家的面前展现下哈哈。&lt;/p&gt;
&lt;p&gt;故事就从这里开始：咱们有一个学校，就叫从壹大学（我瞎起的名字哈哈），我们从壹大学要开发一套教务系统，这个系统涵盖了学校的方方面面，从德智体美劳都有，其中就有一个管理后台，任何人都可以登陆进去，学习查看自己的信息和成绩等，老师可以选择课程或者修改自己班级的学生的个人信息的，现在就说其中的一个小栗子 —— 班主任更改学生的手机号。我们就用普通的写法，就是我们平时在写或者现在在用的流程来设计这个小方法。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;请注意&lt;/span&gt;：当前系统就是一个 &lt;strong&gt;领域&lt;/strong&gt;，里边会有很多 &lt;strong&gt;子领域&lt;/strong&gt;，这个大家应该都能动。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;1、后台管理，修改学生的手机号&lt;/h3&gt;
&lt;p&gt;这个方法逻辑很简单，就是把学生的手机号更新一下就行，平时咱们一定是咣咣把数据库建好，然后新建实体类，然后就开始写这样的一批方法了，话不多说，直接看看怎么写（这是伪代码）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 后台修改学生手机号方法
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;NewPhoNumber&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;StudentId&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;TeacherId&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; UpdateStudentPhone(&lt;span&gt;string&lt;/span&gt; NewPhoNumber,&lt;span&gt;int&lt;/span&gt; StudentId,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; TeacherId)
{
 
    &lt;/span&gt;&lt;strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;核心1：连数据，获取学生信息，然后做修改，再保存数据库。&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;
  

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个方法特别正确，而且是核心算法，简单来看，已经满足我们的需求了，但是却不是完整的，为什么呢，因为只要是管理系统涉及到的一定是有权限问题，然后我们就很开始和DBA讨论增加权限功能。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;请注意&lt;/span&gt;：这里说到的修改手机号的方法，就是我们之后要说到的&lt;strong&gt;领域事件&lt;/strong&gt;，学生就是我们的&lt;strong&gt;领域模型&lt;/strong&gt;，当然这里边还有&lt;strong&gt;聚合根，值对象&lt;/strong&gt;等等，都从这些概念中提炼出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;2、为我们的系统增加一个刚需&lt;/h3&gt;
&lt;p&gt;刚需就是指必须使用到的一些功能，是仅此于核心功能的下一等级，如果按照我们之前的方法，我们就很自然的修改了下我们的方法。&lt;/p&gt;
&lt;p&gt;故事：领导说，上边的方法好是好，但是必须增加一个功能强大的权限系统，不仅能学生自己登陆修改，还可以老师，教务处等等多方修改，还不能冲突，嗯。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 后台修改学生手机号方法
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;NewPhoNumber&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;StudentId&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;TeacherId&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; UpdateStudentPhone(&lt;span&gt;string&lt;/span&gt; NewPhoNumber,&lt;span&gt;int&lt;/span&gt; StudentId,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; TeacherId)
{
    &lt;/span&gt;&lt;strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重要2：首先要判断当然 Teacher 是否有权限（比如只有班主任可以修改本班）
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意这个时候已经把 Teacher 这个对象，给悄悄的引进来了。

    &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------------------------------------------

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;核心：连数据，获取学生信息，然后做修改，再保存数据库。&lt;/span&gt;
&lt;span&gt;
  


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候你一定会说我们可以使用JWT这种呀，当然你说的对，是因为咱们上一个系列里说到这个了，这个也有设计思想在里边，今天咱们就暂时先用平时咱们用到的上边这个方法，集成到一起来说明，只不过这个时候我们发现我们的的领域里，不仅仅多了 Teacher 这个其他模型，而且还多了与主方法无关，或者说不是核心的事件。&lt;/p&gt;
&lt;p&gt;这个时候，我们在某些特定的方法里，已经完成权限，我们很开心，然后交给学校验收，发现很好，然后就上线了，故事的第一篇就这么结束了，你会想，难道还有第二篇么，没错！事务总是源源不断的的进来的，请耐心往下看。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;请注意：这个权限问题就是 &lt;strong&gt;切面AOP &lt;/strong&gt;编程问题，以前已经说到了，这个时候你能想到JWT，说明很不错了，当然还可以用Id4等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;3、给系统增加一个事件痕迹存储&lt;/h3&gt;
&lt;p&gt;这个不知道你是否能明白，这个说白了就是操作日志，当然你可以和错误日志呀，接口访问日志一起联想，我感觉也是可以的，不过我更喜欢把它放在事件上，而不是日志这种数据上。&lt;/p&gt;
&lt;p&gt;故事：经过一年的使用，系统安静平稳，没有bug，一起正常，但是有一天，学生小李自己换了一个手机号，然后就去系统修改，竟然发现自己的个人信息已经被修改了（是班主任改的），小李很神奇这件事，然后就去查，当然是没有记录的，这个时候反馈给技术部门，领导结合着其他同学的意见，决定增加一个痕迹历史记录页，将痕迹跟踪提上了日程。我们就这么开发了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 后台修改学生手机号方法
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;NewPhoNumber&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;StudentId&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;TeacherId&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; UpdateStudentPhone(&lt;span&gt;string&lt;/span&gt; NewPhoNumber,&lt;span&gt;int&lt;/span&gt; StudentId,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; TeacherId)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重要：首先要判断当然 Teacher 是否有权限（比如只有班主任可以修改本班）
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意这个时候已经把 Teacher 这个对象，给悄悄的引进来了。

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------------------------------------------

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;核心：连数据，或者学生信息，然后做修改，再保存数据库。

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------------------------------------------

    &lt;/span&gt;&lt;strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;协同3：痕迹跟踪（你可以叫操作日志），获取当然用户信息，和老师信息，连同更新前后的信息，一起保存到数据库，甚至是不同的数据库地址。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意，这个是一个突发的，项目上线后的需求&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;br/&gt;这个时候你可能会说，这个项目太假了，不会发生这样的事情，这些问题都应该在项目开发的时候讨论出来，并解决掉，真的是这样的么，这样的事情多么常见呀，我们平时开发的时候，就算是一个特别成熟的领域，也会在项目上线后，增加删除很多东西，这个只是一个个例，大家联想下平时的工作即可。&lt;/p&gt;
&lt;p&gt;这个时候如果我们还采用这个方法，你会发现要修改很多地方，如果说我们只有几十个方法还行，我们就粘贴复制十分钟就行，但是我们项目有十几个用户故事，每一个故事又有十几个到几十个不等的用例流，你想想，如果我们继续保持这个架构，我们到底应该怎么开发，可能你会想到，还有权限管理的那个AOP思想，写一个切面，可是真的可行么，我们现在不仅仅要获取数据前和数据后两块，还有用户等信息，切面我感觉是很有困难的，当然你也好好思考思考。&lt;/p&gt;
&lt;p&gt;这个时候你会发现，咱们平时开发的普通的框架已经支撑不住了，或者是已经很困难了，一套系统改起来已经过去很久了，而且不一定都会修改正确，如果一个地方出错，当前方法就受影响，一致性更别说了，试想下，如果我们开发一个在线答题系统，就因为记录下日志或者什么的，导致结果没有保存好，学生是会疯的。第二篇就这么结束了，也许你的耐心已经消磨一半了，也许我们以为一起安静的时候，第三个故事又开始了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;请注意：这个事件痕迹记录就涉及到了 &lt;strong&gt;事件驱动 &lt;/strong&gt;和 &lt;strong&gt;事件源 &lt;/strong&gt;相关问题，以后会说到。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;4、再增加一个站内通知业务&lt;/h3&gt;
&lt;p&gt; 故事：我们从壹大学新换了一个PM，嗯，在数据安全性，原子性的同时，更注重大家信息的一致性 —— 任何人修改都需要给当前操作人，被操作人，管理员或者教务处发站内消息通知，这个时候你会崩溃到哭的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 后台修改学生手机号方法
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;NewPhoNumber&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;StudentId&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;TeacherId&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; UpdateStudentPhone(&lt;span&gt;string&lt;/span&gt; NewPhoNumber,&lt;span&gt;int&lt;/span&gt; StudentId,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; TeacherId)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重要：首先要判断当然 Teacher 是否有权限（比如只有班主任可以修改本班）
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意这个时候已经把 Teacher 这个对象，给悄悄的引进来了。

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------------------------------------------

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;核心：连数据，或者学生信息，然后做修改，再保存数据库。

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------------------------------------------

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;协同：痕迹跟踪（你可以叫操作日志），获取当然用户信息，和老师信息，连同更新前后的信息，一起保存到数据库，甚至是不同的数据库地址。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意，这个是一个突发的，项目上线后的需求

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;------------------------------------------------------------

    &lt;/span&gt;&lt;strong&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;协同4：消息通知，把消息同时发给指定的所有人。&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候我就不具体说了，相信都已经离职了吧，可是这种情况就是每天都在发生。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;请注意：上边咱们这个伪代码所写的，就是DDD的 &lt;strong&gt;通用领域语言&lt;/strong&gt;，也可以叫 &lt;strong&gt;战略设计&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;5、DDD领域驱动设计就能很好的解决&lt;/h3&gt;
&lt;p&gt;上边的这个问题不知道是否能让你了解下软件开发中的痛点在哪里，二十年前 Eric Evans 就发现了，并提出了领域驱动设计的思想，就是通过将一个领域进行划分成不同的子领域，各个子领域之间通过限界上下文进行分隔，在每一个限界上下文中，有领域模型，领域事件，聚合，值对象等等，各个上下文互不冲突，互有联系，保证内部的一致性，这些以后会说到。&lt;/p&gt;
&lt;p&gt;如果你对上下文不是很明白，你可以暂时把它理解成子领域，领域的概念是从战略设计来说的，上下文这些是从战术设计上来说的。&lt;/p&gt;
&lt;p&gt;具体的请参考我的上一篇文章《&lt;a id=&quot;post_title_link_9845573&quot; href=&quot;https://www.cnblogs.com/laozhang-is-phi/p/9845573.html&quot;&gt;三 ║ 简单说说：领域、子域、限界上下文&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;你也许会问，那我们如何通过DDD领域驱动设计来写上边的修改手机号这个方法呢，这里简单画一下，只是说一个大概意思，切分领域以后，每一个领域之间互不联系，有效的避免了牵一发而动全身的问题，而且我们可以很方便进行扩展，自定义扩展上下文，当然如果你想在教学子领域下新增一个年级表，那就不用新建上下文了，直接在改学习上下文中操作即可，具体的代码如何实现，咱们以后会慢慢说到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201810/1468246-20181029230311668-1158179792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;总结：这个时候你通过上边的这个栗子，不知道你是否明白了，我们为什么要在大型的项目中，使用DDD领域设计，并配合这CQRS和事件驱动架构来搭建项目了，它所解决的就是我们在上边的小故事中提到的随着业务的发展，困难值呈现指数增长的趋势了。&lt;/p&gt;


&lt;p&gt;这里就简单的说两句为什么一直要使用仓储，而不直接接通到 EFCore 上：&lt;/p&gt;
&lt;p&gt;1、我们驱动设计的核心是什么，就是最大化的解决项目中出现的痛点，上边的小故事就是一个栗子，随着技术的更新，面向接口开发同时也变的特别重要，无论是方便重构，还是方便IoC，依赖注入等等，都需要一个仓储接口来实现这个目的。&lt;/p&gt;
&lt;p&gt;2、仓储还有一个重要的特征就是分为仓储定义部分和仓储实现部分，在领域模型中我们定义仓储的接口，而在基础设施层实现具体的仓储。&lt;/p&gt;
&lt;p&gt;这样做的原因是：由于仓储背后的实现都是在和数据库打交道，但是我们又不希望客户（如应用层）把重点放在如何从数据库获取数据的问题上，因为这样做会导致客户（应用层）代码很混乱，很可能会因此而忽略了领域模型的存在。所以我们需要提供一个简单明了的接口，供客户使用，确保客户能以最简单的方式获取领域对象，从而可以让它专心的不会被什么数据访问代码打扰的情况下协调领域对象完成业务逻辑。这种通过接口来隔离封装变化的做法其实很常见，我们需要什么数据直接拿就行了，而不去管具体的操作逻辑。&lt;/p&gt;
&lt;p&gt;3、由于客户面对的是抽象的接口并不是具体的实现，所以我们可以随时替换仓储的真实实现，这很有助于我们做单元测试。&lt;/p&gt;

&lt;p&gt;总结：现在随着开发，越来越发现接口的好处，不仅仅是一个持久化层需要一层接口，小到一个缓存类，或者日志类，我们都需要一个接口的实现，就比如现在我就很喜欢用依赖注入的方式来开发，这样可以极大的减少依赖，还有增大代码的可读性。&lt;/p&gt;


&lt;p&gt;限界上下文已经说的很明白了，是从战术技术上来解释说明战略中的领域概念，你想一下，我们如何在代码中直接体现领域的概念？当然没办法，领域是一个通过语言，领域专家和技术人员都能看懂的一套逻辑，而代码中的上下文才是实实在在的通过技术来实现。&lt;/p&gt;
&lt;p&gt;大家可以在回头看看上边的那个故事栗子，下边都一个“请注意”三个字，里边就是我们上下文中所包含的部分内容，其实限界上下文并没有想象中的那么复杂，我们只需要理解成是一个虚拟的边界，把不属于这个子领域的内容踢出去，对外解耦，但是内部通过聚合的。&lt;/p&gt;
&lt;h3&gt;0、在基础设施层下新建一个 appsetting.json 配置文件&lt;/h3&gt;
&lt;p&gt;用于我们的特定的数据库连接，当然我们可以公用 api 层的配置文件，这里单独拿出来，用于配合着下边的EFCore，进行注册。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionStrings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DefaultConnection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server=.;uid=sa;pwd=123;database=EDU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IncludeScopes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Information&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Information&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;1、新建系统核心上下文&lt;/h3&gt;
&lt;p&gt;在Christ3D.Infrastruct.Data 基础设施数据层新建 Context 文件夹，以后在基础设施层的上下文都在这里新建，比如事件存储上下文（上文中存储事件痕迹的子领域），&lt;/p&gt;
&lt;p&gt;然后新建教务领域中的核心子领域——学习领域上下文，StudyContext.cs，这个时候你就不用问我，为啥在教务系统领域中，学习领域是核心子领域了吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 定义核心子领域——学习上下文
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudyContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Student&amp;gt; Students { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重写自定义Map配置
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;modelBuilder&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(ModelBuilder modelBuilder)
        {
            modelBuilder.ApplyConfiguration(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StudentMap());
                        
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnModelCreating(modelBuilder);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重写连接数据库
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;optionsBuilder&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从 appsetting.json 中获取配置信息&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; config = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder()
                .SetBasePath(Directory.GetCurrentDirectory())
                .AddJsonFile(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .Build();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义要使用的数据库&lt;/span&gt;
            optionsBuilder.UseSqlServer(config.GetConnectionString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DefaultConnection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个上下文中，有领域模型 Student ，还有以后说到的聚合，领域事件（上文中的修改手机号）等。&lt;/p&gt;

&lt;h3&gt;2、引入我们的ORM框架 —— EFCore&lt;/h3&gt;
&lt;p&gt;这里边有三个 Nuget 包，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Microsoft.EntityFrameworkCore&lt;span&gt;//&lt;/span&gt;&lt;span&gt;EFCore核心包&lt;/span&gt;
Microsoft.EntityFrameworkCore.SqlServer&lt;span&gt;//&lt;/span&gt;&lt;span&gt;EFCore的SqlServer辅助包&lt;/span&gt;
Microsoft.Extensions.Configuration.FileExtensions&lt;span&gt;//&lt;/span&gt;&lt;span&gt;appsetting文件扩展包&lt;/span&gt;
Microsoft.Extensions.Configuration.Json&lt;span&gt;//&lt;/span&gt;&lt;span&gt;appsetting 数据json读取包&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里给大家说下，如果你不想通过nuget管理器来引入，因为比较麻烦，你可以直接对项目工程文件 Christ3D.Infrastruct.Data.csproj 进行编辑 ，保存好后，项目就直接引用了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;Project Sdk=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.NET.Sdk&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

  &amp;lt;PropertyGroup&amp;gt;
    &amp;lt;TargetFramework&amp;gt;netcoreapp2.&lt;span&gt;1&lt;/span&gt;&amp;lt;/TargetFramework&amp;gt;
  &amp;lt;/PropertyGroup&amp;gt;

  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;ProjectReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;..\Christ3D.Domain\Christ3D.Domain.csproj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;

  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;就是下边这一块&lt;/span&gt;
  &amp;lt;ItemGroup&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.EntityFrameworkCore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.2.0-preview3-35497&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.EntityFrameworkCore.SqlServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.2.0-preview3-35497&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.Extensions.Configuration.FileExtensions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.2.0-preview3-35497&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;PackageReference Include=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft.Extensions.Configuration.Json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; Version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2.2.0-preview3-35497&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/ItemGroup&amp;gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;就是上边这些&lt;/span&gt;
  
&amp;lt;/Project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201810/1468246-20181029233543756-2072115895.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;3、添加我们的实体Map&lt;/h3&gt;
&lt;p&gt; Christ3D.Infrastruct.Data 基础设施数据层新建 Mappings 文件夹，以后在基础设施层的map文件都在这里建立，&lt;/p&gt;
&lt;p&gt;然后新建学生实体map，StudentMap.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 学生map类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; StudentMap : IEntityTypeConfiguration&amp;lt;Student&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 实体属性配置
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;builder&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(EntityTypeBuilder&amp;lt;Student&amp;gt;&lt;span&gt; builder)
        {
            builder.Property(c &lt;/span&gt;=&amp;gt;&lt;span&gt; c.Id)
                .HasColumnName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            builder.Property(c &lt;/span&gt;=&amp;gt;&lt;span&gt; c.Name)
                .HasColumnType(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;varchar(100)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .HasMaxLength(&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;)
                .IsRequired();

            builder.Property(c &lt;/span&gt;=&amp;gt;&lt;span&gt; c.Email)
                .HasColumnType(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;varchar(100)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .HasMaxLength(&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;)
                .IsRequired();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;4、用EFCore来完成基类仓储实现类&lt;/h3&gt;
&lt;p&gt; 将我们刚刚创建好的上下文注入到基类仓储中&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 泛型仓储，实现泛型仓储接口
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;TEntity&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Repository&amp;lt;TEntity&amp;gt; : IRepository&amp;lt;TEntity&amp;gt; &lt;span&gt;where&lt;/span&gt; TEntity : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; StudyContext Db;
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; DbSet&amp;lt;TEntity&amp;gt;&lt;span&gt; DbSet;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Repository(StudyContext context)
        {
            Db &lt;/span&gt;=&lt;span&gt; context;
            DbSet &lt;/span&gt;= Db.Set&amp;lt;TEntity&amp;gt;&lt;span&gt;();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add(TEntity obj)
        {
            DbSet.Add(obj);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; TEntity GetById(Guid id)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; DbSet.Find(id);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; IQueryable&amp;lt;TEntity&amp;gt;&lt;span&gt; GetAll()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; DbSet;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update(TEntity obj)
        {
            DbSet.Update(obj);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Remove(Guid id)
        {
            DbSet.Remove(DbSet.Find(id));
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; SaveChanges()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Db.SaveChanges();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
        {
            Db.Dispose();
            GC.SuppressFinalize(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201810/1468246-20181030125419287-1970279507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;5、完善实现应用层Service方法&lt;/h3&gt;
&lt;p&gt;这个时候我们知道，因为我们的应用层的模型的视图模型 StudentViewModel ，但是我们的仓储接口使用的是 Student 业务领域模型，这个时候该怎么办呢，聪明的你一定会想到咱们在上一个系列中所说到的两个知识点，1、DTO的Automapper，然后就是2、引用仓储接口的 IoC 依赖注入，咱们今天就先简单配置下 DTO。这两个内容如果不是很清楚，可以翻翻咱们之前的系列教程内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201810/1468246-20181030120006166-1882576113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1、在应用层，新建 AutoMapper 文件夹，我们以后的配置文件都放到这里，新建DomainToViewModelMappingProfile.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 配置构造函数，用来创建关系映射
 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
 &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DomainToViewModelMappingProfile()
 {
     CreateMap&lt;/span&gt;&amp;lt;Student, StudentViewModel&amp;gt;&lt;span&gt;();
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这些代码你一定很熟悉的，这里就不多说了，如果一头雾水请看我的第一个系列文章吧。&lt;/p&gt;
&lt;p&gt;2、完成 StudentAppService.cs 的设计&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Christ3D.Application.Services
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; StudentAppService 服务接口实现类,继承 服务接口
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 通过 DTO 实现视图模型和领域模型的关系处理
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 作为调度者，协调领域层和基础层，
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 这里只是做一个面向用户用例的服务接口,不包含业务规则或者知识
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentAppService : IStudentAppService
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意这里是要IoC依赖注入的，还没有实现&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IStudentRepository _StudentRepository;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来进行DTO&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IMapper _mapper;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StudentAppService(
            IStudentRepository StudentRepository,
            IMapper mapper
            )
        {
            _StudentRepository &lt;/span&gt;=&lt;span&gt; StudentRepository;
            _mapper &lt;/span&gt;=&lt;span&gt; mapper;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;StudentViewModel&amp;gt;&lt;span&gt; GetAll()
        {

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (_StudentRepository.GetAll()).ProjectTo&amp;lt;StudentViewModel&amp;gt;&lt;span&gt;();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StudentViewModel GetById(Guid id)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _mapper.Map&amp;lt;StudentViewModel&amp;gt;&lt;span&gt;(_StudentRepository.GetById(id));
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Register(StudentViewModel StudentViewModel)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否为空等等 还没有实现&lt;/span&gt;
&lt;span&gt;
            _StudentRepository.Add(_mapper.Map&lt;/span&gt;&amp;lt;Student&amp;gt;&lt;span&gt;(StudentViewModel));
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Update(StudentViewModel StudentViewModel)
        {
            _StudentRepository.Update(_mapper.Map&lt;/span&gt;&amp;lt;Student&amp;gt;&lt;span&gt;(StudentViewModel));

        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Remove(Guid id)
        {
            _StudentRepository.Remove(id);

        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
        {
            GC.SuppressFinalize(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201810/1468246-20181030130710081-958711825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;6、思考：这样就是DDD领域驱动设计了么&lt;/h3&gt;
&lt;p&gt;好啦，其实这个时候，我们的接口已经可以使用了，可能还有些注入呀，没有实现，但是基本的逻辑就这么施行了，你一定看着很熟悉，无论是DTO还是IOC，无论是EFCore还是仓储，一切都那么熟悉，但是这就是DDD领域驱动设计么，你一定要带着这个问题好好想想。答案当然是否定的。 &lt;/p&gt;
&lt;p&gt;到这里，我们的核心学习子领域的上下文的创建已经完成，请注意，这是上下文的定义创建完成，里边的核心内容还没有说到。&lt;/p&gt;
&lt;p&gt;当然，我们在完成应用层的调用后，直接就可以用了，这个时候的你可能会发现，到目前为止，咱们还是一个普通的写法，和我们上个系列是一样的，没有体现出哪里使用了领域驱动设计的思想，无非就是引用了EFCore和定义了一个上下文。&lt;/p&gt;
&lt;p&gt;没错，你说的是对的，目前为止还没有实现领域设计的核心，但是至少我们已经把领域给划分出来了，而且你如何看明白了上边的我说的内容，也应该有一定的想法了，明天咱们就重点说说&lt;strong&gt;领域事件&lt;/strong&gt;和&lt;strong&gt;聚合&lt;/strong&gt;的相关概念。 &lt;/p&gt;


&lt;p&gt; 今天重点重申了下DDD的意义，简单说明了下仓储的设计思想，然后也将我们的项目引入EFCore，并实现了接口等。这里我要说明三点，看看大家读完这篇文章的心情属于哪一种：&lt;/p&gt;
&lt;p&gt;1、入门：如果你看到我上边的小故事，还对为什么使用DDD而疑惑，那就请再仔细看看，好好想想。不要往下看，就看第一部分。&lt;/p&gt;
&lt;p&gt;2、了解：如果你看懂了我说的第一部分的意思，并了解了使用领域驱动设计的意义，但是看下边第三部分的代码结构又好像和平时的多层设计很像，而又去和多层对比，那麻烦请结合我的Git代码看看。&lt;/p&gt;
&lt;p&gt;3、优秀：如果你明白了DDD的意义，并且很想了解我的架构到底是如何进行领域驱动的，恭喜你，已经成功了，剩下的时间我就会带你去深入了解 &lt;strong&gt;中介者模式下的事件驱动——CQRS&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt; 核心内容要来了，你准备好了么 【机智表情】&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://github.com/anjoy8/ChristDDD&quot; target=&quot;_blank&quot;&gt;https://github.com/anjoy8/ChristDDD&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/laozhangIsPhi/ChristDDD&quot; target=&quot;_blank&quot;&gt;https://gitee.com/laozhangIsPhi/ChristDDD&lt;/a&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 30 Oct 2018 05:24:00 +0000</pubDate>
<dc:creator>老张的哲学</dc:creator>
<og:description>缘起 哈喽大家好哟，今天又到了老张的周二四放送时间了，当然中间还有不定期的更新（因为个人看papi酱看多了），这个主要是针对小伙伴提出的问题和优秀解决方案而写的，经过上周两篇DDD领域驱动设计的试水，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laozhang-is-phi/p/9872450.html</dc:identifier>
</item>
<item>
<title>Go基础系列：函数(1) - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/9876203.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/9876203.html</guid>
<description>&lt;h2 id=&quot;go中函数特性简介&quot;&gt;Go中函数特性简介&lt;/h2&gt;
&lt;p&gt;对Go中的函数特性做一个总结。懂则看，不懂则算。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Go中有3种函数：普通函数、匿名函数(没有名称的函数)、方法(定义在struct上的函数)。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Go编译时不在乎函数的定义位置，但建议init()定义在最前面(如果有的话)，main函数定义在init()之后，然后再根据函数名的字母顺序或者根据调用顺序放置各函数的位置。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;函数的参数、返回值以及它们的类型，结合起来成为函数的签名(signature)。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;函数调用的时候，如果有参数传递给函数，则先拷贝参数的副本，再将副本传递给函数。
&lt;ul&gt;&lt;li&gt;由于引用类型(slice、map、interface、channel)自身就是指针，所以这些类型的值拷贝给函数参数，函数内部的参数仍然指向它们的底层数据结构。&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;函数参数可以没有名称，例如&lt;code&gt;func myfunc(int,int)&lt;/code&gt;。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Go中的函数可以作为一种type类型，例如&lt;code&gt;type myfunc func(int,int) int&lt;/code&gt;。
&lt;ul&gt;&lt;li&gt;实际上，在Go中，函数本身就是一种类型，它的signature就是所谓的type，例如&lt;code&gt;func(int,int) int&lt;/code&gt;。所以，当函数ab()赋值给一个变量&lt;code&gt;ref_ab&lt;/code&gt;时&lt;code&gt;ref_ab := ab&lt;/code&gt;，不能再将其它函数类型的函数cd()赋值给变量&lt;code&gt;ref_ab&lt;/code&gt;。&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Go中作用域是词法作用域，意味着函数的定义位置决定了它能看见的变量。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Go中不允许函数重载(overload)，也就是说不允许函数同名。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Go中的函数不能嵌套函数，但可以嵌套匿名函数。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Go实现了一级函数(first-class functions)，Go中的函数是高阶函数(high-order functions)。这意味着：
&lt;ul&gt;&lt;li&gt;函数是一个值，可以将函数赋值给变量，使得这个变量也成为函数&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;函数可以作为参数传递给另一个函数&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;函数的返回值可以是一个函数&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;这些特性使得函数变得无比的灵活，例如回调函数、闭包等等功能都依赖于这些特性。&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Go中的函数不支持泛型(目前不支持)，但如果需要泛型的情况，大多数时候都可以通过接口、type switch、reflection的方式来解决。但使用这些技术使得代码变得更复杂，性能更低。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;参数和返回值&quot;&gt;参数和返回值&lt;/h2&gt;
&lt;p&gt;函数可以有0或多个参数，0或多个返回值，参数和返回值都需要指定数据类型，返回值通过return关键字来指定。&lt;/p&gt;
&lt;p&gt;return可以有参数，也可以没有参数，这些返回值可以有名称，也可以没有名称。Go中的函数可以有多个返回值。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1).当返回值有多个时，这些返回值必须使用括号包围，逗号分隔&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(2).return关键字中指定了参数时，返回值可以不用名称。如果return省略参数，则返回值部分必须带名称&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(3).当返回值有名称时，必须使用括号包围，逗号分隔，即使只有一个返回值&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(4).但即使返回值命名了，return中也可以强制指定其它返回值的名称，也就是说return的优先级更高&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(5).命名的返回值是预先声明好的，在函数内部可以直接使用，无需再次声明。命名返回值的名称不能和函数参数名称相同，否则报错提示变量重复定义&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;(6).return中可以有表达式，但不能出现赋值表达式，这和其它语言可能有所不同。例如&lt;code&gt;return a+b&lt;/code&gt;是正确的，但&lt;code&gt;return c=a+b&lt;/code&gt;是错误的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 单个返回值
func func_a() int{
    return a
}

// 只要命名了返回值，必须括号包围
func func_b() (a int){
    // 变量a int已存在，无需再次声明
    a = 10
    return
    // 等价于：return a
}

// 多个返回值，且在return中指定返回的内容
func func_c() (int,int){
    return a,b
}

// 多个返回值
func func_d() (a,b int){
    return
    // 等价于：return a,b
}

// return覆盖命名返回值
func func_e() (a,b int){
    return x,y
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Go中经常会使用其中一个返回值作为函数是否执行成功、是否有错误信息的判断条件。例如&lt;code&gt;return value,exists&lt;/code&gt;、&lt;code&gt;return value,ok&lt;/code&gt;、&lt;code&gt;return value,err&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;当函数的返回值过多时，例如有4个以上的返回值，应该将这些返回值收集到容器中，然后以返回容器的方式去返回。例如，同类型的返回值可以放进slice中，不同类型的返回值可以放进map中。&lt;/p&gt;
&lt;p&gt;但函数有多个返回值时，如果其中某个或某几个返回值不想使用，可以通过下划线&lt;code&gt;_&lt;/code&gt;这个blank identifier来丢弃这些返回值。例如下面的&lt;code&gt;func_a&lt;/code&gt;函数两个返回值，调用该函数时，丢弃了第二个返回值b，只保留了第一个返回值a赋值给了变量&lt;code&gt;a&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func func_a() (a,b int){
    return
}

func main() {
    a,_ := func_a()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;按值传参&quot;&gt;按值传参&lt;/h2&gt;
&lt;p&gt;Go中是通过传值的方式传参的，意味着传递给函数的是拷贝后的副本，所以函数内部访问、修改的也是这个副本。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a,b := 10,20
min(a,b)
func min(x,y int) int{}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面调用min()时，是将a和b的值拷贝一份，然后将拷贝的副本赋值给变量x,y的，所以min()函数内部，访问、修改的一直是a、b的副本，和原始的数据对象a、b没有任何关系。&lt;/p&gt;
&lt;p&gt;如果想要修改外部数据(即上面的a、b)，需要传递指针。&lt;/p&gt;
&lt;p&gt;例如，下面两个函数，&lt;code&gt;func_value()&lt;/code&gt;是传值函数，&lt;code&gt;func_ptr()&lt;/code&gt;是传指针函数，它们都修改同一个变量的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    a := 10
    func_value(a)
    fmt.Println(a)    // 输出的值仍然是10
    
    b := &amp;amp;a
    func_ptr(b)
    fmt.Println(*b)   // 输出修改后的值：11
}

func func_value(x int) int{
    x = x + 1
    return x
}

func func_ptr(x *int) int{
    *x = *x + 1
    return *x
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;map、slice、interface、channel这些数据类型本身就是指针类型的，所以就算是拷贝传值也是拷贝的指针，拷贝后的参数仍然指向底层数据结构，所以修改它们&lt;strong&gt;可能&lt;/strong&gt;会影响外部数据结构的值。&lt;/p&gt;
&lt;p&gt;另外注意，赋值操作&lt;code&gt;b = a+1&lt;/code&gt;这种类型的赋值也是拷贝赋值。换句话说，现在底层已经有两个数据对象，一个是a，一个是b。但&lt;code&gt;a = a+1&lt;/code&gt;这种类型的赋值虽然本质上是拷贝赋值，但因为a的指针指向特性，使得结果上看是原地修改数据对象而非生成新数据对象。&lt;/p&gt;
&lt;h2 id=&quot;变长参数...variadic&quot;&gt;变长参数&quot;...&quot;(variadic)&lt;/h2&gt;
&lt;p&gt;有时候参数过多，或者想要让函数处理任意多个的参数，可以在函数定义语句的参数部分使用&lt;code&gt;ARGS...TYPE&lt;/code&gt;的方式。这时会将&lt;code&gt;...&lt;/code&gt;代表的参数全部保存到一个名为ARGS的slice中，注意这些参数的数据类型都是TYPE。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;...&lt;/code&gt;在Go中称为variadic，在使用&lt;code&gt;...&lt;/code&gt;的时候(如传递、赋值)，可以将它看作是一个slice，下面的几个例子可以说明它的用法。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;func myfunc(a,b int,args...int) int {}&lt;/code&gt;。除了前两个参数a和b外，其它的参数全都保存到&lt;strong&gt;名为args的slice中&lt;/strong&gt;，且这些参数全都是int类型。所以，在函数内部就已经有了一个&lt;code&gt;args = []int{....}&lt;/code&gt;的数据结构。&lt;/p&gt;
&lt;p&gt;例如，下面的例子中，min()函数要从所有参数中找出最小的值。为了实验效果，特地将前两个参数a和b独立到slice的外面。min()函数内部同时会输出保存到args中的参数值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    a,b,c,d,e,f := 10,20,30,40,50,60
    fmt.Println(min(a,b,c,d,e,f))
}

func min(a,b int,args...int) int{
    // 输出args中保存的参数
    // 等价于 args := []int{30,40,50,60}
    for index,value := range args {
        fmt.Printf(&quot;%s%d%s %d\n&quot;,&quot;args[&quot;,index,&quot;]:&quot;,value)
    }

    // 取出a、b中较小者
    min_value := a
    if a&amp;gt;b {
        min_value = b
    }
    // 取出所有参数中最小值
    for _,value := range args{
        if min_value &amp;gt; value {
            min_value = value
        }
    }
    return min_value
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但上面代码中调用函数时传递参数的方式显然比较笨重。如果要传递的参数过多(要比较的值很多)，可以先将这些参数保存到一个slice中，再传递slice给min()函数。传递slice给函数的时候，使用&lt;code&gt;SLICE...&lt;/code&gt;的方式即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    s1 := []int{30,40,50,60,70}
    fmt.Println(min(10,20,s1...))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的赋值方式已经能说明能使用slice来理解&lt;code&gt;...&lt;/code&gt;的行为。另外，下面的例子也能很好的解释：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func f1(s...string){
    f2(s...)
    f3(s)
}

func f2(s...string){}
func f3(s []string){}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果各参数的类型不同，又想定义成变长参数，该如何？第一种方式，可以使用struct，第二种方式可以使用接口。接口暂且不说，如果使用struct，大概如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type args struct {
    arg1 string
    arg2 int
    arg3 type3
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后可以将args传递给函数：&lt;code&gt;f(a,b int,args{})&lt;/code&gt;，如果args结构中需要初始化，则&lt;code&gt;f(a,b int,args{arg1:&quot;hello&quot;,arg2:22})&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;defer关键字&quot;&gt;defer关键字&lt;/h2&gt;
&lt;p&gt;defer关键字可以让&lt;strong&gt;函数或语句&lt;/strong&gt;延迟到函数语句块的最结尾时，即即将退出函数时执行，即便函数中途报错结束、即便已经panic()、即便函数已经return了，也都会执行defer所推迟的对象。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    a()
}

func a() {
    println(&quot;in a&quot;)
    defer b()
    println(&quot;leaving a&quot;)
    //到了这里才会执行b()
}

func b() {
    println(&quot;in b&quot;)
    println(&quot;leaving b&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面将输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;in a
leaving a
in b
leaving b&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即便是函数已经报错，或函数已经return返回，defer的对象也会在函数退出前的最后一刻执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func a() TYPE{
    ...CODE...
    
    defer b()
    
    ...CODE...
    
    // 函数执行出了错误
    
    return args
    // 函数b()都会在这里执行
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但注意，由于Go的作用域采用的是词法作用域，defer的定义位置决定了它推迟对象能看见的变量值，而不是推迟对象被调用时所能看见的值。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

var x = 10
func main() {
    a()
}

func a() {
    println(&quot;start a:&quot;,x)   // 输出10
    x = 20
    defer b(x)
    x = 30
    println(&quot;leaving a:&quot;,x)  // 输出30
    // 调用defer延迟的对象b()，输出20
}

func b(x int) {
    println(&quot;start b:&quot;,x)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果语句块内有多个defer，则defer的对象以LIFO(last in first out)的方式执行，也就是说，先定义的defer后执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    println(&quot;start...&quot;)
    defer println(&quot;1&quot;)
    defer println(&quot;2&quot;)
    defer println(&quot;3&quot;)
    defer println(&quot;4&quot;)
    println(&quot;end...&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;start...
end...
4
3
2
1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;defer有什么用呢？一般用来做善后操作，例如清理垃圾、释放资源，无论是否报错都执行defer对象。另一方面，defer可以让这些善后操作的语句和开始语句放在一起，无论在可读性上还是安全性上都很有改善，毕竟写完开始语句就可以直接写defer语句，永远也不会忘记关闭、善后等操作。&lt;/p&gt;
&lt;p&gt;例如，打开文件，关闭文件的操作写在一起：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;open()
defer file.Close()
... 操作文件 ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是defer的一些常用场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打开关闭文件&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;锁定、释放锁&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;建立连接、释放连接&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;作为结尾输出结尾信息&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;清理垃圾(如临时文件)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;panic和recover&quot;&gt;panic()和recover()&lt;/h2&gt;
&lt;p&gt;panic()用于产生错误信息并终止&lt;strong&gt;当前的goroutine&lt;/strong&gt;，一般将其看作是退出panic()所在函数以及退出调用panic()所在函数的函数。例如，G()中调用F()，F()中调用panic()，则F()退出，G()也退出。&lt;/p&gt;
&lt;p&gt;注意，defer关键字推迟的对象是函数最后调用的，即使出现了panic也会调用defer推迟的对象。&lt;/p&gt;
&lt;p&gt;例如，下面的代码中，main()中输出一个&lt;code&gt;start main&lt;/code&gt;之后调用a()，它会输出&lt;code&gt;start a&lt;/code&gt;，然后就panic了，panic()会输出&lt;code&gt;panic: panic in a&lt;/code&gt;，然后报错，终止程序。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    println(&quot;start main&quot;)
    a()
    println(&quot;end main&quot;)
}

func a() {
    println(&quot;start a&quot;)
    panic(&quot;panic in a&quot;)
    println(&quot;end a&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;start main
start a
panic: panic in a

goroutine 1 [running]:
main.a()
        E:/learning/err.go:14 +0x63
main.main()
        E:/learning/err.go:8 +0x4c
exit status 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意上面的&lt;code&gt;end a&lt;/code&gt;和&lt;code&gt;end main&lt;/code&gt;都没有被输出。&lt;/p&gt;
&lt;p&gt;可以使用recover()去捕获panic()并恢复执行。recover()用于捕捉panic()错误，并返回这个错误信息。但注意，即使recover()捕获到了panic()，但调用含有panic()函数的函数(即上面的G()函数)也会退出，所以如果recover()定义在G()中，则G()中调用F()函数之后的代码都不会执行(见下面的通用格式)。&lt;/p&gt;
&lt;p&gt;以下是比较通用的panic()和recover()的格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    G()
    // 下面的代码会执行
    ...CODE IN MAIN...
}
func G(){
    defer func (){
        if str := recover(); str != nil {
            fmt.Println(str)
        }
    }()
    ...CODE IN G()...
    
    // F()的调用必须在defer关键字之后
    F()
    // 该函数内下面的代码不会执行
    ...CODE IN G()...
}
func F() {
    ...CODE1...
    panic(&quot;error found&quot;)
    // 下面的代码不会执行
    ...CODE IN F()...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用recover()去捕获panic()并恢复执行。但以下代码是错误的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    println(&quot;start main&quot;)
    a()
    println(&quot;end main&quot;)
}

func a() {
    println(&quot;start a&quot;)
    panic(&quot;panic in a&quot;)

    // 直接放在panic后是错误的
    panic_str := recover()
    println(panic_str)

    println(&quot;end a&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之所以错误，是因为panic()一出现就直接退出函数a()和main()了。要想recover()真正捕获panic()，需要将recover()放在defer的推迟对象中，且defer的定义必须在panic()发生之前。&lt;/p&gt;
&lt;p&gt;例如，下面是通用格式的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    println(&quot;start main&quot;)
    b()
    println(&quot;end main&quot;)
}

func a() {
    println(&quot;start a&quot;)
    panic(&quot;panic in a&quot;)
    println(&quot;end a&quot;)
}

func b() {
    println(&quot;start b&quot;)
    defer func() {
        if str := recover(); str != nil {
            fmt.Println(str)
        }
    }()
    a()
    println(&quot;end b&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;start main
start b
start a
panic in a
end main&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意上面的&lt;code&gt;end b&lt;/code&gt;、&lt;code&gt;end a&lt;/code&gt;都没有被输出，但是&lt;code&gt;end main&lt;/code&gt;输出了。&lt;/p&gt;
&lt;p&gt;panic()是内置的函数(在包builtin中)，在&lt;code&gt;log&lt;/code&gt;包中也有一个Panic()函数，它调用Print()输出信息后，再调用panic()。&lt;code&gt;go doc log Panic&lt;/code&gt;一看便知：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ go doc log Panic
func Panic(v ...interface{})
    Panic is equivalent to Print() followed by a call to panic().&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;内置函数&quot;&gt;内置函数&lt;/h2&gt;
&lt;p&gt;在builtin包中有一些内置函数，这些内置函数额外的导入包就能使用。&lt;/p&gt;
&lt;p&gt;有以下内置函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ go doc builtin | grep func
func close(c chan&amp;lt;- Type)
func delete(m map[Type]Type1, key Type)
func panic(v interface{})
func print(args ...Type)
func println(args ...Type)
func recover() interface{}
    func complex(r, i FloatType) ComplexType
    func imag(c ComplexType) FloatType
    func real(c ComplexType) FloatType
    func append(slice []Type, elems ...Type) []Type
    func make(t Type, size ...IntegerType) Type
    func new(Type) *Type
    func cap(v Type) int
    func copy(dst, src []Type) int
    func len(v Type) int&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;close&lt;/code&gt;用于关闭channel&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delete&lt;/code&gt;用于删除map中的元素&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copy&lt;/code&gt;用于拷贝slice&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;append&lt;/code&gt;用于追加slice&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cap&lt;/code&gt;用于获取slice的容量&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;len&lt;/code&gt;用于获取
&lt;ul&gt;&lt;li&gt;slice的长度&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;map的元素个数&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;array的元素个数&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;指向array的指针时，获取array的长度&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;string的字节数&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;channel的channel buffer中的未读队列长度&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;print&lt;/code&gt;和&lt;code&gt;println&lt;/code&gt;：底层的输出函数，用来调试用。在实际程序中，应该使用fmt中的print类函数&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;complex&lt;/code&gt;、&lt;code&gt;imag&lt;/code&gt;、&lt;code&gt;real&lt;/code&gt;：操作复数(虚数)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;panic&lt;/code&gt;和&lt;code&gt;recover&lt;/code&gt;：处理错误&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;make&lt;/code&gt;：分配内存并初始化
&lt;ul&gt;&lt;li&gt;new适用于为值类(value type)的数据类型(如array,int等)和struct类型的对象分配内存并初始化，并返回它们的&lt;strong&gt;地址&lt;/strong&gt;给变量。如&lt;code&gt;v := new(int)&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;make适用于为内置的引用类的类型(如slice、map、channel等)分配内存并初始化底层数据结构，并返回它们的&lt;strong&gt;指针&lt;/strong&gt;给变量，同时可能会做一些额外的操作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意，地址和指针是不同的。地址就是数据对象在内存中的地址，指针则是占用一个机器字长(32位机器是4字节，64位机器是8字节)的数据，这个数据中存储的是它所指向数据对象的地址。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a -&amp;gt; AAAA
b -&amp;gt; Pointer -&amp;gt; BBBB&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;递归函数&quot;&gt;递归函数&lt;/h2&gt;
&lt;p&gt;函数内部调用函数自身的函数称为递归函数。&lt;/p&gt;
&lt;p&gt;使用递归函数最重要的三点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;必须先定义函数的退出条件，退出条件基本上都使用退出点来定义，退出点常常也称为递归的基点，是递归函数的最后一次递归点，或者说没有东西可递归时就是退出点。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;递归函数很可能会产生一大堆的goroutine(其它编程语言则是出现一大堆的线程、进程)，也很可能会出现栈空间内存溢出问题。在其它编程语言可能只能设置最大递归深度或改写递归函数来解决这个问题，在Go中可以使用channel+goroutine设计的&quot;lazy evaluation&quot;来解决。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;递归函数通常可以使用level级数的方式进行改写，使其不再是递归函数，这样就不会有第2点的问题。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;例如，递归最常见的示例，求一个给定整数的阶乘。因为阶乘的公式为&lt;code&gt;n*(n-1)*...*3*2*1&lt;/code&gt;，它在参数为1的时候退出函数，也就是说它的递归基点是1，所以对是否为基点进行判断，然后再写递归表达式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    fmt.Println(a(5))
}

func a(n int) int{
    // 判断退出点
    if n == 1 {
        return 1
    }
    // 递归表达式
    return n * a(n-1)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的调用过程大概是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201810/733013-20181030002344419-991111285.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再比如斐波那契数列，它的计算公式为&lt;code&gt;f(n)=f(n-1)+f(n-2)&lt;/code&gt;且&lt;code&gt;f(2)=f(1)=1&lt;/code&gt;。它在参数为1和2的时候退出函数，所以它的退出点为1和2。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    fmt.Println(f(3))
}

func f(n int) int{
    // 退出点判断
    if n == 1 || n == 2 {
        return 1
    }
    // 递归表达式
    return f(n-1)+f(n-2)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如何递归一个目录？它的递归基点是文件，只要是文件就返回，只要是目录就进入。所以，伪代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func recur(dir FILE) FILE{
    // 退出点判断
    if (dir is a file){
        return dir
    }

    // 当前目录的文件列表
    file_slice := filelist()
    
    // 遍历所有文件
    for _,file := range file_slice {
        return recur(file)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;匿名函数&quot;&gt;匿名函数&lt;/h2&gt;
&lt;p&gt;匿名函数是没有名称的函数。一般匿名函数嵌套在函数内部，或者赋值给一个变量，或者作为一个表达式。&lt;/p&gt;
&lt;p&gt;定义的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 声明匿名函数
func(args){
    ...CODE...
}

// 声明匿名函数并直接执行
func(args){
    ...CODE...
}(parameters)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面的示例中，先定义了匿名函数，将其赋值给了一个变量，然后在需要的地方再去调用执行它。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    // 匿名函数赋值给变量
    a := func() {
        fmt.Println(&quot;hello world&quot;)
    }
    // 调用匿名函数
    a()
    fmt.Printf(&quot;%T\n&quot;, a) // a的type类型：func()
    fmt.Println(a)        // 函数的地址
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果给匿名函数的定义语句后面加上&lt;code&gt;()&lt;/code&gt;，表示声明这个匿名函数的同时并执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    msg := &quot;Hello World&quot;
    func(m string) {
        fmt.Println(m)
    }(msg)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;func(c string)&lt;/code&gt;表示匿名函数的参数，&lt;code&gt;func(m string){}(msg)&lt;/code&gt;的&lt;code&gt;msg&lt;/code&gt;表示传递msg变量给匿名函数，并执行。&lt;/p&gt;
&lt;h2 id=&quot;func-type&quot;&gt;func type&lt;/h2&gt;
&lt;p&gt;可以将func作为一种type，以后可以直接使用这个type来定义函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

type add func(a,b int) int

func main() {
    var a add = func(a,b int) int{
        return a+b
    }
    s := a(3,5)
    fmt.Println(s)
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 30 Oct 2018 04:50:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>Go中函数特性简介 对Go中的函数特性做一个总结。懂则看，不懂则算。 1. Go中有3种函数：普通函数、匿名函数(没有名称的函数)、方法(定义在struct上的函数)。 2. Go编译时不在乎函数的定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/9876203.html</dc:identifier>
</item>
<item>
<title>spring事务详解（四）测试验证 - 只会一点java</title>
<link>http://www.cnblogs.com/dennyzhangdd/p/9602670.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dennyzhangdd/p/9602670.html</guid>
<description>&lt;h2&gt;系列目录&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dennyzhangdd/p/9549535.html&quot; target=&quot;_blank&quot;&gt;spring事务详解（一）初探事务&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dennyzhangdd/p/9708499.html&quot; target=&quot;_blank&quot;&gt;spring事务详解（二）简单样例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dennyzhangdd/p/9602673.html&quot; target=&quot;_blank&quot;&gt;spring事务详解（三）源码详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dennyzhangdd/p/9602670.html&quot; target=&quot;_blank&quot;&gt;spring事务详解（四）测试验证&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;spring事务详解（五）总结提高&lt;/p&gt;
&lt;h2&gt;一、引子&lt;/h2&gt;
&lt;p&gt;在第一节中我们知道spring为了支持数据库事务的ACID四大特性，在底层源码中对事务定义了6个属性：&lt;span&gt;&lt;strong&gt;事务名称&lt;/strong&gt;、&lt;strong&gt;隔离级别&lt;/strong&gt;、&lt;strong&gt;超时时间&lt;/strong&gt;、&lt;strong&gt;是否只读&lt;/strong&gt;、&lt;strong&gt;传播机制&lt;/strong&gt;、&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;回滚机制。&lt;/strong&gt;其中&lt;span&gt;隔离级别&lt;/span&gt;和&lt;span&gt;传播机制&lt;/span&gt;光看第一节的描述还是不够的，需要实际测试一下方能放心且记忆深刻。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二、环境&lt;/h2&gt;
&lt;h3&gt;2.1 业务模拟&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;模拟用户去银行转账，用户A转账给用户B，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要保证用户A扣款，用户B加款同时成功或失败回滚。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.2 环境准备&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;测试环境&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;mysql8+mac，测试时使用的mysql8（和mysql5.6的设置事务变量的语句不同，不用太在意）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试准备&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;创建一个数据库test,创建一张表&lt;span&gt;user_balance用户余额表。id主键，name姓名，balance账户余额。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 mysql&lt;span&gt;&amp;gt; &lt;span&gt;create &lt;span&gt;database&lt;span&gt; test;
&lt;span&gt; 2 Query OK, &lt;span&gt;1 row affected (&lt;span&gt;0.05&lt;span&gt; sec)
&lt;span&gt; 3 
&lt;span&gt; 4 mysql&lt;span&gt;&amp;gt; &lt;span&gt;use&lt;span&gt; test;
&lt;span&gt; 5 &lt;span&gt;Database&lt;span&gt; changed
&lt;span&gt; 6 mysql&lt;span&gt;&amp;gt; &lt;span&gt;CREATE &lt;span&gt;TABLE&lt;span&gt; `user_balance` (
&lt;span&gt; 7     &lt;span&gt;-&amp;gt;   `id` &lt;span&gt;int(&lt;span&gt;11) &lt;span&gt;NOT &lt;span&gt;NULL AUTO_INCREMENT COMMENT &lt;span&gt;'&lt;span&gt;ID主键&lt;span&gt;'&lt;span&gt;,
&lt;span&gt; 8     &lt;span&gt;-&amp;gt;   `name` &lt;span&gt;varchar(&lt;span&gt;20) &lt;span&gt;DEFAULT &lt;span&gt;NULL COMMENT &lt;span&gt;'&lt;span&gt;姓名&lt;span&gt;'&lt;span&gt;,
&lt;span&gt; 9     &lt;span&gt;-&amp;gt;   `balance` &lt;span&gt;decimal(&lt;span&gt;10,&lt;span&gt;0) &lt;span&gt;DEFAULT &lt;span&gt;NULL COMMENT &lt;span&gt;'&lt;span&gt;账户余额&lt;span&gt;'&lt;span&gt;,
&lt;span&gt;10     &lt;span&gt;-&amp;gt;   &lt;span&gt;PRIMARY &lt;span&gt;KEY&lt;span&gt; (`id`)
&lt;span&gt;11     &lt;span&gt;-&amp;gt; ) ENGINE&lt;span&gt;=InnoDB AUTO_INCREMENT&lt;span&gt;=&lt;span&gt;24 &lt;span&gt;DEFAULT CHARSET&lt;span&gt;=&lt;span&gt;utf8;
&lt;span&gt;12 Query OK, &lt;span&gt;0 rows affected, &lt;span&gt;1 warning (&lt;span&gt;0.15 sec)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始化数据，2个账户都是1000元：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt; &lt;span&gt;INSERT &lt;span&gt;INTO `user_balance` &lt;span&gt;VALUES (&lt;span&gt;'&lt;span&gt;1&lt;span&gt;', &lt;span&gt;'&lt;span&gt;张三&lt;span&gt;', &lt;span&gt;'&lt;span&gt;1000&lt;span&gt;'), (&lt;span&gt;'&lt;span&gt;2&lt;span&gt;', &lt;span&gt;'&lt;span&gt;李四&lt;span&gt;', &lt;span&gt;'&lt;span&gt;1000&lt;span&gt;'&lt;span&gt;);
Query OK, &lt;span&gt;2 rows affected (&lt;span&gt;0.06&lt;span&gt; sec)
Records: &lt;span&gt;2  Duplicates: &lt;span&gt;0  Warnings: &lt;span&gt;0&lt;span&gt;

mysql&lt;span&gt;&amp;gt; &lt;span&gt;select &lt;span&gt;* &lt;span&gt;from user_balance;                                              &lt;br/&gt;&lt;span&gt;+&lt;span&gt;--&lt;span&gt;--+--------+---------+
&lt;span&gt;| id &lt;span&gt;| name   &lt;span&gt;| balance &lt;span&gt;|
&lt;span&gt;+&lt;span&gt;--&lt;span&gt;--+--------+---------+
&lt;span&gt;|  &lt;span&gt;1 &lt;span&gt;| 张三   &lt;span&gt;|    &lt;span&gt;1000 &lt;span&gt;|
&lt;span&gt;|  &lt;span&gt;2 &lt;span&gt;| 李四   &lt;span&gt;|    &lt;span&gt;1000 &lt;span&gt;|
&lt;span&gt;+&lt;span&gt;--&lt;span&gt;--+--------+---------+
&lt;span&gt;2 rows &lt;span&gt;in &lt;span&gt;set (&lt;span&gt;0.00 sec)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、隔离级别实测&lt;/h2&gt;
&lt;h3&gt;3.2 隔离级别实测&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;通用语句&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1.开启/提交事务：开启：begin/start transaction都行，提交：commit;&lt;/p&gt;
&lt;p&gt;2.查询事务级别：select @@transaction_isolation;&lt;/p&gt;
&lt;p&gt;3.修改事务级别：set global transaction_isolation='read-uncommitted';&lt;/p&gt;
&lt;p&gt;注意：修改完了后要exit退出再重新连接mysql(mysql -uroot)才能生效(这里是模拟MySQL5.6，MySQL8有直接生效的语句)。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以下4种测试都是先设置好事务隔离级别，再做的测试，下面的测试就不再展示出来了。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;3.2.1 Read Uncommitted（读未提交）&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;测试步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.开启2个会话连接mysql，会话1开始事务A，会话2开始事务B。&lt;/p&gt;
&lt;p&gt;2.事务A中执行update把张三的余额1000-100=900，事务A查询结果为900。&lt;/p&gt;
&lt;p&gt;3.此时事务A并没有提交，事务B查询结果也是900，即：读取了未提交的内容（MVCC快照读的最新版本号数据）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如下图（左边的是会话1-事务A，右边的是会话2-事务B）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/584866/201810/584866-20181026104739940-1618027359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：&lt;span&gt;明显不行，因为事务A内部的处理数据不一定是最后的数据，很可能事务A后续再加上1000，那么事务B读取的数据明显就错了，即脏读！&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;3.2.2 Read Committed（读提交）&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;测试步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.开启2个会话连接mysql，会话1开始事务A，会话2开始事务B。&lt;/p&gt;
&lt;p&gt;2.事务A中执行update把张三的余额1000-100=900，事务A查询结果为900。只要事务A未提交，事务B查询数据都没有变化还是1000.&lt;/p&gt;
&lt;p&gt;3.事务A提交，事务B查询立即变成900了，即：读已提交。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如下图（&lt;/strong&gt;左边的是会话1-事务A，右边的是会话2-事务B）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/584866/201810/584866-20181026110127626-1663806704.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：&lt;span&gt;解决了脏读问题，但此时事务B还没提交，即出现了在一个事务中多次查询同一sql数据不一致的情况，即不可重复读！&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;3.2.3 Repeatable Read（可重读）&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;测试步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.开启2个会话连接mysql，会话1开始事务A，会话2开始事务B。&lt;/p&gt;
&lt;p&gt;2.事务A中执行update把张三的余额1000-100=900，事务A查询结果为900。&lt;span&gt;事务A提交，事务B查询数据还是1000&lt;span&gt;不变.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3.会话1再开始一个&lt;span&gt;事务C插入一条“王五”数据，&lt;span&gt;并提交，&lt;span&gt;事务B查询还是2条数据，且数据&lt;span&gt;和第一次查询一致，即：读已提交+可重复读。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4.会话2中的&lt;span&gt;事务B也插入一条相同ID的数据，&lt;span&gt;报错：已经存在相同ID=3的数据插入失败！，即出现了幻读。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如下图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/584866/201810/584866-20181026163905339-1485580843.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;mysql支持的解决方案&lt;/strong&gt;&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;要防止幻读，可以事务A中for update加上范围，最终会生成间隙锁，阻塞其它事务插入数据，并且当事务A提交后，事务B立即可以插入成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/584866/201808/584866-20180831115925503-1371231721.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;3.2.4 Serializable（可串行化）&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;测试步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.开启2个会话连接mysql，会话1开始事务A，会话2开始事务B。&lt;/p&gt;
&lt;p&gt;2.事务A，查询id=2的记录，事务B更新id=2的记录，update操作被阻塞一直到超时（事务A提交后，事务B update可以立即执行）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如下图&lt;/strong&gt;（&lt;strong&gt;左边的是会话1-事务A，右边的是会话2-事务B）&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/584866/201810/584866-20181026173446239-66859077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结论：Serializable级别下，读也加锁！如果是行锁（查询一行），那么后续对这一行的修改操作会直接阻塞等待第一个事务完毕。如果是表锁（查询整张表），那么后续对这张表的所有修改操作都阻塞等待。可见仅仅一个查询就锁住了相应的查询数据，性能实在是不敢恭维。&lt;/p&gt;
&lt;h2&gt;四、传播机制实测&lt;/h2&gt;
&lt;h4&gt;3.3.1 测试准备&lt;/h4&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;p&gt;spring4+mybatis+mysql+slf4j+logback,注意：日志logback要配置：日志打印为debug级别，这样才能看见事务过程。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1 &lt;span&gt;&amp;lt;&lt;span&gt;root &lt;span&gt;level&lt;span&gt;=&quot;DEBUG&quot;&lt;span&gt;&amp;gt;
&lt;span&gt;2    &lt;span&gt;&amp;lt;&lt;span&gt;appender-ref &lt;span&gt;ref&lt;span&gt;=&quot;STDOUT&quot;&lt;span&gt;/&amp;gt;
&lt;span&gt;3 &lt;span&gt;&amp;lt;/&lt;span&gt;root&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;
测试基类：BaseTest
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 &lt;span&gt;import&lt;span&gt; lombok.extern.slf4j.Slf4j;
&lt;span&gt; 2 &lt;span&gt;import&lt;span&gt; org.junit.runner.RunWith;
&lt;span&gt; 3 &lt;span&gt;import&lt;span&gt; org.springframework.boot.test.context.SpringBootTest;
&lt;span&gt; 4 &lt;span&gt;import&lt;span&gt; org.springframework.test.context.junit4.SpringRunner;
&lt;span&gt; 5 &lt;span&gt;import&lt;span&gt; study.StudyDemoApplication;
&lt;span&gt; 6 
&lt;span&gt; 7 &lt;span&gt;@Slf4j
&lt;span&gt; 8 @RunWith(SpringRunner.&lt;span&gt;class&lt;span&gt;)
&lt;span&gt; 9 @SpringBootTest(classes = StudyDemoApplication.&lt;span&gt;class&lt;span&gt;)
&lt;span&gt;10 &lt;span&gt;public &lt;span&gt;class&lt;span&gt; BaseTest {
&lt;span&gt;11 
&lt;span&gt;12 
&lt;span&gt;13 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试子类：UserBalanceTest&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 &lt;span&gt;import&lt;span&gt; org.junit.Test;
&lt;span&gt; 2 &lt;span&gt;import&lt;span&gt; study.service.UserBalanceService;
&lt;span&gt; 3 
&lt;span&gt; 4 &lt;span&gt;import&lt;span&gt; javax.annotation.Resource;
&lt;span&gt; 5 &lt;span&gt;import&lt;span&gt; java.math.BigDecimal;
&lt;span&gt; 6 
&lt;span&gt; 7 &lt;span&gt;/**
&lt;span&gt; 8 &lt;span&gt; * @Description 用户余额测试类（事务）
&lt;span&gt; 9 &lt;span&gt; * &lt;span&gt;@author&lt;span&gt; denny
&lt;span&gt;10 &lt;span&gt; * @date 2018/9/4 上午11:38
&lt;span&gt;11  &lt;span&gt;*/ 
&lt;span&gt;12 &lt;span&gt;public &lt;span&gt;class UserBalanceTest &lt;span&gt;extends&lt;span&gt; BaseTest{
&lt;span&gt;13 
&lt;span&gt;14 &lt;span&gt;    @Resource
&lt;span&gt;15     &lt;span&gt;private&lt;span&gt; UserBalanceService userBalanceService;
&lt;span&gt;16 
&lt;span&gt;17 &lt;span&gt;    @Test
&lt;span&gt;18     &lt;span&gt;public &lt;span&gt;void&lt;span&gt; testAddUserBalanceAndUser(){
&lt;span&gt;19         userBalanceService.&lt;span&gt;addUserBalanceAndUser(&quot;赵六&quot;,&lt;span&gt;new BigDecimal(1000&lt;span&gt;));
&lt;span&gt;20 &lt;span&gt;    }
&lt;span&gt;21     
&lt;span&gt;22     &lt;span&gt;public &lt;span&gt;static &lt;span&gt;void&lt;span&gt; main(String[] args) {
&lt;span&gt;23         
&lt;span&gt;24 &lt;span&gt;    }
&lt;span&gt;25     
&lt;span&gt;26 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
UserBalanceImpl：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 &lt;span&gt;package&lt;span&gt; study.service.impl;
&lt;span&gt; 2 
&lt;span&gt; 3 &lt;span&gt;import&lt;span&gt; lombok.extern.slf4j.Slf4j;
&lt;span&gt; 4 &lt;span&gt;import&lt;span&gt; org.springframework.stereotype.Service;
&lt;span&gt; 5 &lt;span&gt;import&lt;span&gt; org.springframework.transaction.annotation.Propagation;
&lt;span&gt; 6 &lt;span&gt;import&lt;span&gt; org.springframework.transaction.annotation.Transactional;
&lt;span&gt; 7 &lt;span&gt;import&lt;span&gt; study.domain.UserBalance;
&lt;span&gt; 8 &lt;span&gt;import&lt;span&gt; study.repository.UserBalanceRepository;
&lt;span&gt; 9 &lt;span&gt;import&lt;span&gt; study.service.UserBalanceService;
&lt;span&gt;10 &lt;span&gt;import&lt;span&gt; study.service.UserService;
&lt;span&gt;11 
&lt;span&gt;12 &lt;span&gt;import&lt;span&gt; javax.annotation.Resource;
&lt;span&gt;13 &lt;span&gt;import&lt;span&gt; java.math.BigDecimal;
&lt;span&gt;14 
&lt;span&gt;15 &lt;span&gt;/**
&lt;span&gt;16 &lt;span&gt; * @Description 
&lt;span&gt;17 &lt;span&gt; * &lt;span&gt;@author&lt;span&gt; denny
&lt;span&gt;18 &lt;span&gt; * @date 2018/8/31 下午6:30
&lt;span&gt;19  &lt;span&gt;*/
&lt;span&gt;20 &lt;span&gt;@Slf4j
&lt;span&gt;21 &lt;span&gt;@Service
&lt;span&gt;22 &lt;span&gt;public &lt;span&gt;class UserBalanceImpl &lt;span&gt;implements&lt;span&gt; UserBalanceService {
&lt;span&gt;23 
&lt;span&gt;24 &lt;span&gt;    @Resource
&lt;span&gt;25     &lt;span&gt;private&lt;span&gt; UserService userService;
&lt;span&gt;26 &lt;span&gt;    @Resource
&lt;span&gt;27     &lt;span&gt;private&lt;span&gt; UserBalanceRepository userBalanceRepository;
&lt;span&gt;28 
&lt;span&gt;29     &lt;span&gt;/**
&lt;span&gt;30 &lt;span&gt;     * 创建用户
&lt;span&gt;31 &lt;span&gt;     *
&lt;span&gt;32 &lt;span&gt;     * &lt;span&gt;@param&lt;span&gt; userBalance
&lt;span&gt;33 &lt;span&gt;     * &lt;span&gt;@return
&lt;span&gt;34      &lt;span&gt;*/
&lt;span&gt;35 &lt;span&gt;    @Override
&lt;span&gt;36     &lt;span&gt;public &lt;span&gt;void&lt;span&gt; addUserBalance(UserBalance userBalance) {
&lt;span&gt;37         &lt;span&gt;this&lt;span&gt;.userBalanceRepository.insert(userBalance);
&lt;span&gt;38 &lt;span&gt;    }
&lt;span&gt;39 
&lt;span&gt;40     &lt;span&gt;/**
&lt;span&gt;41 &lt;span&gt;     * 创建用户并创建账户余额
&lt;span&gt;42 &lt;span&gt;     *
&lt;span&gt;43 &lt;span&gt;     * &lt;span&gt;@param&lt;span&gt; name
&lt;span&gt;44 &lt;span&gt;     * &lt;span&gt;@param&lt;span&gt; balance
&lt;span&gt;45 &lt;span&gt;     * &lt;span&gt;@return
&lt;span&gt;46      &lt;span&gt;*/
&lt;span&gt;47     @&lt;span&gt;Transactional(propagation= Propagation.REQUIRED, rollbackFor = Exception.&lt;span&gt;class&lt;span&gt;)
&lt;span&gt;48 &lt;span&gt;    @Override
&lt;span&gt;49     &lt;span&gt;public &lt;span&gt;void&lt;span&gt;&lt;span&gt; addUserBalanceAndUser(String name, BigDecimal balance) {
&lt;span&gt;50         log.info(&quot;[addUserBalanceAndUser] begin!!!&quot;&lt;span&gt;);
&lt;span&gt;51         &lt;span&gt;//&lt;span&gt;1.新增用户
&lt;span&gt;52 &lt;span&gt;        userService.&lt;span&gt;addUser(name);
&lt;span&gt;53         &lt;span&gt;//&lt;span&gt;2.新增用户余额
&lt;span&gt;54         UserBalance userBalance = &lt;span&gt;new&lt;span&gt; UserBalance();
&lt;span&gt;55 &lt;span&gt;        userBalance.setName(name);
&lt;span&gt;56         userBalance.setBalance(&lt;span&gt;new BigDecimal(1000&lt;span&gt;));
&lt;span&gt;57         &lt;span&gt;this&lt;span&gt;.addUserBalance(userBalance);
&lt;span&gt;58         log.info(&quot;[addUserBalanceAndUser] end!!!&quot;&lt;span&gt;);
&lt;span&gt;59 &lt;span&gt;    }
&lt;span&gt;60 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
如上图所示：
&lt;/pre&gt;
&lt;p&gt;addUserBalanceAndUser(){&lt;/p&gt;
&lt;p&gt;　　addUser(name);//添加用户&lt;/p&gt;
&lt;p&gt;　　addUserBalance(userBalance);//添加用户余额&lt;br/&gt;}&lt;/p&gt;
&lt;p&gt;addUserBalanceAndUser开启一个事务，内部方法addUser也申明事务，如下：&lt;/p&gt;
&lt;p&gt;UserServiceImpl：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1 &lt;span&gt;package&lt;span&gt; study.service.impl;
&lt;span&gt; 2 
&lt;span&gt; 3 &lt;span&gt;import&lt;span&gt; lombok.extern.slf4j.Slf4j;
&lt;span&gt; 4 &lt;span&gt;import&lt;span&gt; org.springframework.stereotype.Service;
&lt;span&gt; 5 &lt;span&gt;import&lt;span&gt; org.springframework.transaction.annotation.Propagation;
&lt;span&gt; 6 &lt;span&gt;import&lt;span&gt; org.springframework.transaction.annotation.Transactional;
&lt;span&gt; 7 &lt;span&gt;import&lt;span&gt; study.domain.User;
&lt;span&gt; 8 &lt;span&gt;import&lt;span&gt; study.repository.UserRepository;
&lt;span&gt; 9 &lt;span&gt;import&lt;span&gt; study.service.UserService;
&lt;span&gt;10 
&lt;span&gt;11 &lt;span&gt;import&lt;span&gt; javax.annotation.Resource;
&lt;span&gt;12 
&lt;span&gt;13 &lt;span&gt;/**
&lt;span&gt;14 &lt;span&gt; * @Description 
&lt;span&gt;15 &lt;span&gt; * &lt;span&gt;@author&lt;span&gt; denny
&lt;span&gt;16 &lt;span&gt; * @date 2018/8/27 下午5:31
&lt;span&gt;17  &lt;span&gt;*/
&lt;span&gt;18 &lt;span&gt;@Slf4j
&lt;span&gt;19 &lt;span&gt;@Service
&lt;span&gt;20 &lt;span&gt;public &lt;span&gt;class UserServiceImpl &lt;span&gt;implements&lt;span&gt; UserService{
&lt;span&gt;21 &lt;span&gt;    @Resource
&lt;span&gt;22     &lt;span&gt;private&lt;span&gt; UserRepository userRepository;
&lt;span&gt;23 
&lt;span&gt;24     @&lt;span&gt;Transactional(propagation= Propagation.REQUIRED, rollbackFor = Exception.&lt;span&gt;class&lt;span&gt;)
&lt;span&gt;25 &lt;span&gt;    @Override
&lt;span&gt;26     &lt;span&gt;public &lt;span&gt;void&lt;span&gt;&lt;span&gt; addUser(String name) {
&lt;span&gt;27         log.info(&quot;[addUser] begin!!!&quot;&lt;span&gt;);
&lt;span&gt;28         User user = &lt;span&gt;new&lt;span&gt; User();
&lt;span&gt;29 &lt;span&gt;        user.setName(name);
&lt;span&gt;30 &lt;span&gt;        userRepository.insert(user);
&lt;span&gt;31         log.info(&quot;[addUser] end!!!&quot;&lt;span&gt;);
&lt;span&gt;32 &lt;span&gt;    }
&lt;span&gt;33 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;3.3.2 实测&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1.REQUIRED&lt;/strong&gt;：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;外部方法，内部方法都是&lt;strong&gt;REQUIRED：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/584866/201809/584866-20180904113643031-194863440.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 如上图所示：外部方法开启事务，由于不存在事务，Registering注册一个新事务；内部方法Fetched获取已经存在的事务并使用，符合预期。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.SUPPORTS&lt;/strong&gt;：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;外部方法required，内部&lt;span&gt;SUPPORTS。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/584866/201810/584866-20181026180719043-1067728182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，外部方法创建一个事务，传播机制是required，内部方法Participating in existing transaction即加入已存在的外部事务，并最终一起提交事务，符合预期。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.MANDATORY&lt;/strong&gt;：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常&lt;/p&gt;
&lt;p&gt;外部没有事务,内部&lt;strong&gt;MANDATORY：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/584866/201810/584866-20181026183027185-423455249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，外部没有事务，内部&lt;strong&gt;MANDATORY&lt;/strong&gt;，报错，符合预期。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.REQUIRES_NEW&lt;/strong&gt;：创建新事务，如果存在当前事务，则挂起当前事务。新事务执行完毕后，再继续执行老事务。&lt;/p&gt;
&lt;p&gt;外部方法&lt;span&gt;REQUIRED&lt;/span&gt;,内部方法&lt;span&gt;REQUIRES_NEW：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/584866/201810/584866-20181029151551506-1977025383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，外部方法REQUIRED创建新事务,内部方法REQUIRES_NEW挂起老事务，创建新事务，新事务完毕后，唤醒老事务继续执行。符合预期。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5.NOT_SUPPORTED&lt;/strong&gt;：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。&lt;/p&gt;
&lt;p&gt;外部方法&lt;span&gt;REQUIRED,&lt;/span&gt;内部方法&lt;span&gt;&lt;span&gt;&lt;strong&gt;NOT_SUPPORTED&lt;/strong&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/584866/201810/584866-20181029153814938-1742813948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，外部方法创建事务A，内部方法不支持事务，挂起事务A，内部方法执行完毕，唤醒事务A继续执行。符合预期。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6.NEVER&lt;/strong&gt;：以非事务方式执行，如果当前存在事务，则抛出异常。&lt;/p&gt;
&lt;p&gt;外部方法&lt;span&gt;REQUIRED,&lt;/span&gt;内部方法&lt;span&gt;NEVER：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/584866/201810/584866-20181029155416250-65903163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，外部方法&lt;span&gt;REQUIRED&lt;/span&gt;创建事务，内部方法&lt;span&gt;NEVER如果当前存在事务报错，符合预期。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7.NESTED&lt;/strong&gt;：如果当前存在事务，则在&lt;span&gt;&lt;strong&gt;嵌套事务&lt;/strong&gt;&lt;/span&gt;内执行。如果当前没有事务，则执行与REQUIRED类似的操作。&lt;/p&gt;
&lt;p&gt;外部方法&lt;span&gt;REQUIRED,内部方法&lt;span&gt;NEVER：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/584866/201810/584866-20181029162446913-770631645.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如上图，外部方法REQUIRED创建事务,内部方法&lt;strong&gt;NESTED&lt;/strong&gt;构造一个内嵌事务并创建保存点，内部事务运行完毕释放保存点，继续执行外部事务。最终和外部事务一起commit.上图只有一个sqlSession对象，commit时也是一个。符合预期。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：NESTED和REQUIRES_NEW区别？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.回滚：&lt;span&gt;&lt;span&gt;&lt;strong&gt;NESTED在创建内层事务之前创建一个保存点，内层事务回滚只回滚到保存点，不会影响外层事务（真的可以自动实现吗？❎具体见下面“强烈注意”！）。外层事务回滚则会连着内层事务一起回滚；&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;REQUIRES_NEW&lt;/strong&gt;构造一个新事务，和外层事务是两个独立的事务，互不影响。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;2.提交：&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;NESTED&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是嵌套事务，是外层事务的子事务。外层事务commit则内部事务一起提交，只有一次commit；&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;REQUIRES_NEW是新事务，完全独立的事务，独立进行2次commit。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;强烈注意：&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;NESTED嵌套事务能够自己回滚到保存点，但是嵌套事务方法中的上抛的异常，外部方法也能捕获，那么外部事务也就回滚了，所以如果期望实现内部嵌套异常回滚不影响外部事务，那么需要捕获嵌套事务的异常。如下：&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @Transactional(propagation= Propagation.&lt;span&gt;REQUIRED&lt;/span&gt;, rollbackFor = Exception.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addUserBalanceAndUser(String name, BigDecimal balance) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         log.info(&quot;[addUserBalanceAndUser] begin!!!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.新增用户余额--》最终会插入成功，不受嵌套回滚异常影响&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         UserBalance userBalance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserBalance();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        userBalance.setName(name);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         userBalance.setBalance(&lt;span&gt;new&lt;/span&gt; BigDecimal(1000&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.addUserBalance(userBalance);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.新增用户，&lt;span&gt;这里捕获嵌套事务的异常，不让外部事务获取到，不然外部事务肯定会回滚！&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 嵌套事务@Transactional(propagation= Propagation.&lt;span&gt;&lt;span&gt;NESTED&lt;/span&gt;, rollbackFor = Exception.class)&lt;/span&gt;--》异常会回滚到保存点&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            userService.addUser(name);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里可根据实际情况添加自己的业务！&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             log.error(&quot;嵌套事务【addUser】异常！&quot;&lt;span&gt;,e);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         log.info(&quot;[addUserBalanceAndUser] end!!!&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 30 Oct 2018 04:33:00 +0000</pubDate>
<dc:creator>只会一点java</dc:creator>
<og:description>系列目录 spring事务详解（一）初探事务 spring事务详解（二）简单样例 spring事务详解（三）源码详解 spring事务详解（四）测试验证 spring事务详解（五）总结提高 一、引子</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dennyzhangdd/p/9602670.html</dc:identifier>
</item>
<item>
<title>美团技术分享：美团深度学习系统的工程实践 - 码友</title>
<link>http://www.cnblogs.com/mayou18/p/9876155.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mayou18/p/9876155.html</guid>
<description>&lt;blockquote&gt;
&lt;h3&gt;&lt;span&gt;更多美团技术分享收藏：&lt;a title=&quot;美团技术分享&quot; href=&quot;https://www.mayou18.com/special/3ErC518F.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;MAYOU18-美团技术专栏&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;p&gt;深度学习作为AI时代的核心技术，已经被应用于多个场景。在系统设计层面，由于其具有计算密集型的特性，所以与传统的机器学习算法在工程实践过程中存在诸多的不同。本文将介绍美团平台在应用深度学习技术的过程中，相关系统设计的一些经验。&lt;/p&gt;
&lt;p&gt;本文将首先列举部分深度学习算法所需的计算量，然后再介绍为满足这些计算量，目前业界比较常见的一些解决方案。最后，我们将介绍美团平台在NLU和语音识别两个领域中，设计相关系统的经验。&lt;/p&gt;

&lt;div class=&quot;table-container&quot;&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Model&lt;/th&gt;
&lt;th&gt;Input Size&lt;/th&gt;
&lt;th&gt;Param Size&lt;/th&gt;
&lt;th&gt;Flops&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;AlexNet&lt;/td&gt;
&lt;td&gt;227 x 227&lt;/td&gt;
&lt;td&gt;233 MB&lt;/td&gt;
&lt;td&gt;727 MFLOPs&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CaffeNet&lt;/td&gt;
&lt;td&gt;224 x 224&lt;/td&gt;
&lt;td&gt;233 MB&lt;/td&gt;
&lt;td&gt;724 MFLOPs&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;VGG-VD-16&lt;/td&gt;
&lt;td&gt;224 x 224&lt;/td&gt;
&lt;td&gt;528 MB&lt;/td&gt;
&lt;td&gt;16 GFLOPs&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;VGG-VD-19&lt;/td&gt;
&lt;td&gt;224 x 224&lt;/td&gt;
&lt;td&gt;548 MB&lt;/td&gt;
&lt;td&gt;20 GFLOPs&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;GoogleNet&lt;/td&gt;
&lt;td&gt;224 x 224&lt;/td&gt;
&lt;td&gt;51 MB&lt;/td&gt;
&lt;td&gt;2 GFLOPs&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ResNet-34&lt;/td&gt;
&lt;td&gt;224 x 224&lt;/td&gt;
&lt;td&gt;83 MB&lt;/td&gt;
&lt;td&gt;4 GFLOPs&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ResNet-152&lt;/td&gt;
&lt;td&gt;224 x 224&lt;/td&gt;
&lt;td&gt;230 MB&lt;/td&gt;
&lt;td&gt;11 GFLOPs&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SENet&lt;/td&gt;
&lt;td&gt;224 x 224&lt;/td&gt;
&lt;td&gt;440 MB&lt;/td&gt;
&lt;td&gt;21 GFLOPs&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;5.5167785234899&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.mayou18.com/special/3ErC518F.html#&quot;&gt;数据来源&lt;/a&gt;&lt;br/&gt;上表列举了，ImageNet图像识别中常见算法的模型大小以及单张图片一次训练（One Pass）所需要的计算量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自2012年，Hinton的学生Alex Krizhevsky提出AlexNet，一举摘下ILSVRC 2012的桂冠后，ILSVRC比赛冠军的准确率越来越高。与此同时，其中使用到的深度学习算法也越来越复杂，所需要的计算量也越来越大。SENet与AlexNet相比，计算量多了近30倍。我们知道，ImageNet大概有120万张图片，以SENet为例，如果要完成100个epoch的完整训练，将需要2.52 * 10^18的计算量。如此庞大的计算量，已经远远超出传统的机器学习算法的范畴。更别说，Google在论文&lt;a href=&quot;https://www.mayou18.com/special/3ErC518F.html#&quot;&gt;《Revisiting Unreasonable Effectiveness of Data in Deep Learning Era》&lt;/a&gt;中提及的、比ImageNet大300倍的数据集。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;物理计算性能&lt;/h2&gt;
&lt;p&gt;面对如此庞大的计算量，那么，我们业界当前常用的计算单元的计算力是多少呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CPU 物理核：一般浮点运算能力在10^10 FLOPS量级。一台16 Cores的服务器，大致上有200 GFLOPS的运算能力。实际运行，CPU 大概能用到80%的性能，那就160 GFLOPS的运算能力。完成上述SENet运行，需要182天。&lt;/li&gt;
&lt;li&gt;NVIDIA GPGPU： 目前的V100，单精度浮点运算的峰值大概为14 TFLOPS， 实际运行中，我们假设能用到50%的峰值性能，那就是7 TFLOPS，需要4天。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据以上数据结果可以看出：在深度学习领域，GPU训练数据集所需要耗费的时间，远远少于CPU，这也是当前深度学习训练都是采用GPU的重要原因。&lt;/p&gt;

&lt;p&gt;从前面的计算可知，即使使用GPU来计算，训练一次ImageNet 也需要4天的时间。但对于算法工程师做实验、调参而言，这种耗时数天的等待是难以忍受的。为此，目前业界针对深度学习训练的加速，提出了各种各样的解决方案。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;异构计算的并行方案&lt;/h2&gt;
&lt;h3 id=&quot;-data-parallelism-&quot;&gt;数据并行（Data Parallelism）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mayou18.com/mayou/20181027/1540637894615331.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;br/&gt;数据并行，即每个计算单元都保留一份完整的模型拷贝，分别训练不同的数据，经过一个Iteration或若干个Iteration后，把各个计算单元的模型做一次同步。这是最常见的深度学习训练方式，好处在于逻辑简单、代码实现方便。&lt;/p&gt;
&lt;h3 id=&quot;-model-parallelism-&quot;&gt;模型并行（Model Parallelism）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mayou18.com/mayou/20181027/1540637895657102.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;br/&gt;模型并行，即各个计算单元存储同一层模型数据的不同部分，训练相同的数据。相对于数据并行，因为各个运算单元每训练完一层神经网络，就必须要同步一次，频繁的同步通信导致系统不能充分地利用硬件的运算能力，所以更为少见。但是在一些业务场景下，Softmax层需要分类的类别可能会有很多，导致Softmax层太大，单个计算单元无法存储，这个时候，需要把模型切割成若干部分，存储在不同的运算单元。模型并行常见于NLU、推荐、金融等领域。&lt;/p&gt;
&lt;h3 id=&quot;-stream-parallelism-&quot;&gt;流式并行（Stream Parallelism）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mayou18.com/mayou/20181027/1540637896506834.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;br/&gt;流式并行，即每个计算单元都存储不同层的模型数据，训练相同的数据。如上图所示，GPU1只负责第一层神经网络的计算，GPU2只负责2~5层神经网络的计算，GPU3只负责第6层的计算。流式并行的好处在于每个运算单元之间的通信和计算重叠（overlap），如果配置得当，可以非常充分地利用硬件资源。缺点在于，根据不同的模型，需要平衡好各个计算单元的计算量，如果配置不好，很容易形成“堰塞湖”。如上图所示，很有可能出现GPU1 负责的运算量太少，而GPU2 负责的运算量太多，导致GPU1 和GPU2 之间堵塞住大量的Mini-batch，更常见于线上环境。&lt;/p&gt;
&lt;h3 id=&quot;-hybrid-parallelism-&quot;&gt;混合并行（Hybrid Parallelism）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mayou18.com/mayou/20181027/1540637897671423.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;br/&gt;混合并行，即上面提到的并行方式的混合。如对于一些图像识别任务来说，可能前几层使用数据并行，最后的Softmax层，使用模型并行。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;异构计算的硬件解决方案&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;单机单卡：一个主机内安装上一块GPU运算卡。常见于个人计算机。&lt;/li&gt;
&lt;li&gt;单机多卡：一个主机内安装上多块GPU运算卡。常见的有：1机4卡，1机8卡，甚至有1机10卡。一般公司都采取这种硬件方案。&lt;/li&gt;
&lt;li&gt;多机多卡：多台主机内安装多块GPU运算卡。常见于公司内部的计算集群，一般多机之间采取Infiniband 来实现网络的快速通信。&lt;/li&gt;
&lt;li&gt;定制化：即类似于Google的TPU解决方案。常见于“巨无霸”公司内部。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;-&quot;&gt;异构计算的通信解决方案&lt;/h2&gt;
&lt;p&gt;根据上面的硬件解决方案，我们以ResNet为例：模型的大小为230M，单张图片运算量为11 GFLPOS，Mini-batch假设为128。可以计算出各个硬件模块在深度学习训练中的耗时比较：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GPU：对于V100，假设有6 TFLOPS，一次Mini-batch 理论耗时：0.23s。&lt;/li&gt;
&lt;li&gt;PCI-E：常见PCI-E 3.0 * 16，速度为10 GB/s，传输一个模型的理论耗时为：0.023s。&lt;/li&gt;
&lt;li&gt;网络：假设为10 GB/s的高速网络，传输一个模型的理论耗时：0.023s。&lt;/li&gt;
&lt;li&gt;Disk：普通的磁盘，我们假设200M/s的读取速度，读取一次Mini-batch所需要的图片耗时：0.094s。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据上面的数据结果，我们似乎可以得出一个结论：PCI-E和网络的传输耗时，相对于GPU来说，整整少了一个数量级，所以网络通信同步的时间可以忽略不计。然而问题并没有那么简单，上面例子中的耗时只是单个模型的耗时，但是对于8卡的集群来说，如果使用数据并行，每次同步就需要传输8份模型，这就导致数据传输的时间和GPU的计算时间“旗鼓相当”。这样的话，GPU就得每训练完一个Mini-batch，都得等候很久的一段时间（采取同步更新），这会浪费很多计算资源。因此，网络通信也需要制定对应的解决方案。下面我们以Nvidia NCCL中单机多卡的通信解决方案为例介绍，而多机多卡的通信解决方案其实是类似的。&lt;br/&gt;&lt;img src=&quot;https://www.mayou18.com/mayou/20181027/1540637898304920.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;br/&gt;上图是单机4卡机器，在硬件上，两种不同的通信体系。左边为普通的PCI-E通信，即4个GPU之间组成一个环状。右边为NVLink通信，即两两之间相互连接。&lt;br/&gt;常见的通信类型如下图所示：&lt;br/&gt;&lt;img src=&quot;https://www.mayou18.com/mayou/20181027/1540637898982746.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;br/&gt;对于深度学习训练而言，关键的两种通信类型为：Broadcast和Reduce。Broadcast用于Master分发最新的模型给各个GPU。Reduce 用于各个GPU计算完Mini-batch后，把模型更新值汇总到Master上。以Broadcast为例，最简单的通信方式是Master往各个GPU上发送数据，这样的耗时就是4次模型传输的时间，通信时间就会太长，一种简单的优化方法如下图所示：&lt;br/&gt;&lt;img src=&quot;https://www.mayou18.com/mayou/20181027/1540637899905218.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;br/&gt;即把所需要传输的数据分成若干块，然后通过接力的方式逐个传递，每个GPU都把自己最新的一块数据发送到下一个GPU卡上。这种传输方式能充分利用硬件层面的通信结构，使得需要的耗时大幅缩减。与此类似的，Reduce的通信优化也可以采取相同的方式进行提速。&lt;/p&gt;

&lt;p&gt;尽管目前在业界已经推出了很多著名的深度学习训练平台，通用的训练平台如TensorFlow、MxNet等等，还有领域专用的训练平台，如语音识别中的Kaldi，但是我们经过调研后，决定内部自主开发一套深度学习系统，理由如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通用的训练平台，缺乏了领域特色的功能。如语音识别中的特征提取模块和算法。&lt;/li&gt;
&lt;li&gt;通用的训练平台，通常是基于Data-flow Graph，来对计算图中的每个operator进行建模，所以颗粒度很小，需要调度的单元多，导任务调度复杂。&lt;/li&gt;
&lt;li&gt;领域特色的训练平台，如Kaldi，在神经网络训练的时候，性能不足。&lt;/li&gt;
&lt;li&gt;线上业务存在很多特殊性，如果使用TensorFlow之类作为训练平台，不太适合线上业务的情景。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;nlu-&quot;&gt;NLU线上系统&lt;/h2&gt;
&lt;h3 id=&quot;-&quot;&gt;线上系统的业务特点&lt;/h3&gt;
&lt;p&gt;我们在设计NLU线上系统时，考虑了NLU业务的一些特性。发现其具备如下的一些特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;随着业务和技术的变化，算法流程也经常发生变化。&lt;/li&gt;
&lt;li&gt;算法流程是多个算法串联组成的，不单纯的只有深度学习算法。如分词等算法就不是DL算法。&lt;/li&gt;
&lt;li&gt;为了能够快速响应一些紧急问题，需要经常对模型进行热更新。&lt;/li&gt;
&lt;li&gt;更重要的是，我们希望构建一个能以“数据驱动”的自动迭代闭环。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;-&quot;&gt;业务多变&lt;/h4&gt;
&lt;p&gt;NLU任务的算法流程是多层级的，并且业务经常发生变化。如下图所示：&lt;br/&gt;&lt;img src=&quot;https://www.mayou18.com/mayou/20181027/1540637900597567.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;br/&gt;即随着业务要求的变化，NLU系统一开始的算法流程，只需要把一个Query分为两个类，但是到后面，极有可能会变成需要分为三个类别。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;热更新&lt;/h4&gt;
&lt;p&gt;根据业务需求，或者为了紧急处理一些特殊问题，NLU线上系统经常需要做出快速响应，热更新算法模型。如最近的热点词“skr”，几乎是一夜之间，突然火爆起来。如下图所示的微博，如果不能正确理解“skr”的正确语义，可能就不能准确理解这条微博想要表达的意思。&lt;br/&gt;&lt;img src=&quot;https://www.mayou18.com/mayou/20181027/1540637901332998.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;br/&gt;为了避免影响用户体验，我们可能会对NLU系统，马上进行热更新，把新模型紧急进行上线。&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;数据驱动的自动迭代闭环&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mayou18.com/mayou/20181027/1540637902037287.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;br/&gt;对于线上系统而言，构建如上图所示的自动迭代闭环，能更好地利用业务数据来提升服务质量。&lt;/p&gt;
&lt;h3 id=&quot;nlu-&quot;&gt;NLU线上系统的核心设计&lt;/h3&gt;
&lt;h4 id=&quot;-&quot;&gt;算法流程的抽象&lt;/h4&gt;
&lt;p&gt;为了适应线上系统串联、多变的算法流程，我们把线上系统的算法进行抽象，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://www.mayou18.com/mayou/20181027/1540637902876395.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;br/&gt;即每一个算法，都依赖于若干个槽位（Slot）和资源（Resource），一旦槽位和资源就位，就会触发对应的算法执行。算法的执行先通过算法适配器，来适配槽位和资源中的数据，转换成算子的输入格式。然后算子执行算法本身，执行完算子后，再经过算法解析器。算法解析器主要用于解析算法执行的结果，触发对应的槽位。如根据算法的结果，触发Top 3的结果。&lt;br/&gt;多个算法串联起来，就构建成如下结果：&lt;br/&gt;&lt;img src=&quot;https://www.mayou18.com/mayou/20181027/1540637903381977.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;-&quot;&gt;热更新流程的设计&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mayou18.com/mayou/20181027/1540637903891286.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;br/&gt;如上图所示，我们把算法的热更新流程设计如上。初试状态为左上角，即多个Query使用同一份模型数据。当遇到模型更新的请求后，系统将会block住新的query（右上角状态）。然后更新模型完后，新的query使用新的模型，旧query依然使用旧模型（右下角状态）。最后，当使用旧模型的query结束后，把旧的模型从内存中删除（左下角），然后系统恢复到初始状态。&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;声学模型训练系统&lt;/h2&gt;
&lt;p&gt;因为TensorFlow等通用深度学习训练平台，缺乏了特征提取等业务相关的领域功能，而Kaldi的声学模型训练过程又太慢。所以美团开发了一个声学模型训练系统——Mimir，其具备如下特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用比TensorFlow更粗颗粒度的建模单元，使得任务调度、优化更简单方便易行。&lt;/li&gt;
&lt;li&gt;使用数据并行的并行方案，单机多卡可达到近线性加速。（采取同步更新策略下，4卡加速比达到3.8）&lt;/li&gt;
&lt;li&gt;移植了Kaldi的一些特有的训练算法。&lt;/li&gt;
&lt;li&gt;速度上为Kaldi的6~7倍。（800个小时的训练数据，单机单卡的条件下，Kaldi需要6~7天， Mimir只需20个小时）&lt;/li&gt;
&lt;li&gt;业务上，移植了Kaldi的特征提取等领域的相关模块。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;剑鹏，美团点评算法专家。2017年加入美团，目前作为语音识别团队的声学模型负责人，负责声学模型相关的算法和系统设计与开发。&lt;/p&gt;
</description>
<pubDate>Tue, 30 Oct 2018 04:32:00 +0000</pubDate>
<dc:creator>码友</dc:creator>
<og:description>更多美团技术分享收藏：MAYOU18-美团技术专栏 背景 深度学习作为AI时代的核心技术，已经被应用于多个场景。在系统设计层面，由于其具有计算密集型的特性，所以与传统的机器学习算法在工程实践过程中存在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mayou18/p/9876155.html</dc:identifier>
</item>
<item>
<title>解耦关联对象——观察者模式详解 - takumiCX</title>
<link>http://www.cnblogs.com/takumicx/p/9872290.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/takumicx/p/9872290.html</guid>
<description>&lt;h2 id=&quot;观察者模式简介&quot;&gt;1. 观察者模式简介&lt;/h2&gt;
&lt;p&gt;在软件开发中,观察者模式是使用频率最高的设计模式之一,如果你做过web开发,对它应该更不会陌生,因为典型的MVC架构就是对观察者模式的一种延伸。在软件开发中经常会碰到这种困境:系统由若干个相互协作的类构成,类之间常有一对多的依赖关系,当被依赖对象的状态变化时,其他所有依赖对象都要发生改变。以MVC为例,模型(Model)对象封装了数据,视图(View)对象对数据进行渲染和进行图形表示。当模型中的数据改变时,视图应该马上得到反馈从而改变其显示的内容。我们需要维护这种具有依赖关系的对象之间的一致性,又不希望为了维护这种一致性导致类之间紧密耦合。而观察者模式正式对这一困境的回答。观察者模式的的最大好处是可以实现具有关联关系的对象之间的解耦,使得双方可以独立的进行扩展和变化,使得系统具有更好的弹性。&lt;/p&gt;
&lt;h2 id=&quot;观察者模式详解&quot;&gt;2. 观察者模式详解&lt;/h2&gt;
&lt;h3 id=&quot;观察者模式定义&quot;&gt;2.1 观察者模式定义&lt;/h3&gt;
&lt;p&gt;观察者模式定义了对象之间的一对多依赖关系,每当对象改变状态,所有依赖于它的对象都会得到通知并被自动更新。&lt;/p&gt;
&lt;h3 id=&quot;观察者模式的结构&quot;&gt;2.2观察者模式的结构&lt;/h3&gt;
&lt;p&gt;观察者模式的结构相对简单,可以用&lt;code&gt;&amp;lt;Head First设计模式&amp;gt;&lt;/code&gt;中的一张图来描述&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201810/1422237-20181029181146543-1310417657.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;观察者模式的主要角色:&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Subject(主题)/Observable(被观察者)&lt;br/&gt;通常以抽象类或者接口的形式存在,定义了被观察者即主题必须实现的职责:1.必须能动态的注册和移除观察者 2.在主题状态改变时能通知观察者进行更新。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Observer(观察者)&lt;br/&gt;定义了观察者的主要职责:在主题状态改变时需要进行更新,具体的更新逻辑由具体观察者自行实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;ConcreteSubject(具体的主题)/ConcreteObservable(具体的被观察者)&lt;br/&gt;根据业务实际实现抽象主题中定义的接口,并对特定的观察者进行通知。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;ConcreteObserver(具体的观察者)&lt;br/&gt;根据业务实际实现自己的更新逻辑,在主题状态改变时进行更新。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;观察者模式的简单实现&quot;&gt;2.3 观察者模式的简单实现&lt;/h3&gt;
&lt;p&gt;观察者模式又被称为发布订阅模式,以客户订阅报纸为例,客户相当于观察者,而报社则是被观察者。客户可以向报社订阅报纸,也可以取消订阅。当报社有新报纸出版时,就会将报纸发送给订阅的客户。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主题抽象&lt;br/&gt;使用抽象类定义并实现了主题具有的基本职责:添加/移除观察者,在主题状态变化时通知所有注册的观察者。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * @author: takumiCX
 * @create: 2018-10-29
 **/
public abstract class Subject {

    //观察者集合
    private CopyOnWriteArrayList&amp;lt;Observer&amp;gt; observers=new CopyOnWriteArrayList&amp;lt;&amp;gt;();


    //注册观察者
    protected  void registerObserver(Observer observer){
        observers.add(observer);
    }

    //移除观察者
    protected boolean removeObserver(Observer observer){
        return observers.remove(observer);
    }


    /**
     * 通知观察者
     * @param msg 发送给观察者的消息
     */
    protected void notifyObservers(String msg){

        for(Observer observer:observers){
            observer.update(msg);
        }
    }

    /**
     * 通知观察者
     */
    protected void notifyObservers(){

        for(Observer observer:observers){
            observer.update();
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该抽象类内部维护了一个线程安全的CopyOnWriteArrayList来存储观察者集合,并没有使用Vector或者SynchronizedList等常见同步容器,在需要频繁增删观察者的情况下可以一定程度提升性能。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;具体的主题实现——报社&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * @author: takumiCX
 * @create: 2018-10-29
 **/
public class NewsPaperSubject extends Subject {

    //报纸的期号
    private String date;

    public String getDate() {
        return date;
    }

    public void setDate(String date) {
        this.date = date;
    }

    /**
     * 通知订阅的客户接收新一期的报纸
     */
    public void postNewPublication(){

        notifyObservers(date);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的主题实现类继承了主题抽象类,并添加了一个状态变量,表示报纸的期号,在通知订阅的客户时需要将该信息也一起传过去。&lt;code&gt;postNewPublication()&lt;/code&gt;方法当有新一期的报纸发行时,会通过调用该方法对订阅的客户进行通知。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;观察者抽象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * @author: takumiCX
 * @create: 2018-10-29
 **/
public interface Observer {

    void update(String msg);

    void update();

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;具体的观察者实现——客户&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * @author: takumiCX
 * @create: 2018-10-29
 **/
public class CustomerObserver implements Observer {

    //客户姓名
    private String name;

    public CustomerObserver(String name) {
        this.name = name;
    }

    @Override
    public void update(String msg) {
        System.out.println(name+&quot; 您好!&quot;+msg+&quot; 期的报纸已发送,请注意接收!&quot;);
    }

    @Override
    public void update() {

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;uml类结构&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201810/1422237-20181029213309343-956149259.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;测试代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * @author: takumiCX
 * @create: 2018-10-29
 **/
public class Test {

    public static void main(String[] args) {

        //报社(主题)
        NewsPaperSubject newsPaperSubject = new NewsPaperSubject();

        //客户1(观察者)
        CustomerObserver observer1 = new CustomerObserver(&quot;赵云&quot;);

        //客户2(观察者)
        CustomerObserver observer2 = new CustomerObserver(&quot;马超&quot;);

        CustomerObserver observer3 = new CustomerObserver(&quot;张飞&quot;);
        //向主题注册观察者
        newsPaperSubject.registerObserver(observer1);
        newsPaperSubject.registerObserver(observer2);
        newsPaperSubject.registerObserver(observer3);

        //报纸的期号
        String date=&quot;2018-10-29&quot;;
        newsPaperSubject.setDate(date);
        //通知所有订阅的客户接收报纸
        newsPaperSubject.postNewPublication();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试结果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201810/1422237-20181029181158449-441599991.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;使用jdk内置的观察者实现&quot;&gt;2.4 使用JDK内置的观察者实现&lt;/h3&gt;
&lt;p&gt;JDK内置了对观察者模式的支持,只要继承或者实现相应的抽象类或接口&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主题实现类&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * @author: takumiCX
 * @create: 2018-10-29
 **/
public class JDKNewsPaperObservable extends Observable {


    //报纸的期号
    private String date;

    public String getDate() {
        return date;
    }

    public void setDate(String date) {
        this.date = date;
    }


    public void postNewPublication(){

        //将状态改变的标志位置位true
        setChanged();
        //通知所有观察者
        notifyObservers(date);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JKD中对主题通过抽象类Observable进行了抽象,实现自定义主题只要继承该抽象类即可。注意该抽象类内部有一个标注主题状态是否改变的标志位,默认为false&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private boolean changed = false;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在通知观察者前必须先通过调用setChanged()方法将该标志位置为true。在通知观察者进行更新的方法被调用后,该标志位会被重新置为false。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;具体的观察者对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * @author: takumiCX
 * @create: 2018-10-29
 **/
public class JDKCustomerObserver implements Observer {

    //客户姓名
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public JDKCustomerObserver(String name) {
        this.name = name;
    }

    @Override
    public void update(Observable o, Object arg) {

        System.out.println(name+&quot; 您好!&quot;+arg+&quot; 期的报纸已发送,请注意接收!&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;uml类结构&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201810/1422237-20181029213333791-378677455.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;测试代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * @author: takumiCX
 * @create: 2018-10-29
 **/
public class Test2 {

    public static void main(String[] args) {
        //报社(主题)
        JDKNewsPaperObservable jdkNewsPaperObservable = new JDKNewsPaperObservable();

        //客户1(观察者)
        JDKCustomerObserver observer1 = new JDKCustomerObserver(&quot;赵云&quot;);

        //客户2(观察者)
        JDKCustomerObserver observer2 = new JDKCustomerObserver(&quot;马超&quot;);

        JDKCustomerObserver observer3 = new JDKCustomerObserver(&quot;张飞&quot;);
        //向主题注册观察者
        jdkNewsPaperObservable.addObserver(observer1);
        jdkNewsPaperObservable.addObserver(observer2);
        jdkNewsPaperObservable.addObserver(observer3);

        //报纸的期号
        String date=&quot;2018-10-29&quot;;
        jdkNewsPaperObservable.setDate(date);
        //通知所有订阅的客户接收报纸
        jdkNewsPaperObservable.postNewPublication();

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;运行结果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1422237/201810/1422237-20181029181204796-1113125907.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;使用观察者模式需要注意的地方&quot;&gt;3 使用观察者模式需要注意的地方&lt;/h2&gt;
&lt;p&gt;1.多个观察者默认是被顺序调用而执行的,当一个观察者的业务逻辑执行卡顿,或者执行时间过长,会导致后续观察者的业务逻辑执行被延迟,也会影响整体的执行效率。&lt;br/&gt;解决办法:采用异步的方式进行处理,比如将观察者的业务逻辑放到线程池中去执行。&lt;/p&gt;
&lt;p&gt;2.当多个对象既是观察者又是被观察者将导致系统难以调试和维护。&lt;br/&gt;解决办法:不允许观察者模式中存在既是观察者又是被观察者的对象。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;4. 总结&lt;/h2&gt;
&lt;p&gt;当存在相互关联的对象,即某些对象状态的改变会导致其他对象产生相应的变化。使用观察者模式可以方便的维护关联对象间行为的一致性,同时使其保持松耦合状态,这样双方就可以相对独立的进行扩展和变化,使得系统更具弹性。&lt;/p&gt;
</description>
<pubDate>Tue, 30 Oct 2018 03:51:00 +0000</pubDate>
<dc:creator>takumiCX</dc:creator>
<og:description>1. 观察者模式简介 在软件开发中,观察者模式是使用频率最高的设计模式之一,如果你做过web开发,对它应该更不会陌生,因为典型的MVC架构就是对观察者模式的一种延伸。在软件开发中经常会碰到这种困境:系</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/takumicx/p/9872290.html</dc:identifier>
</item>
</channel>
</rss>