<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>记一次webpack打包优化 - hi_shepherd</title>
<link>http://www.cnblogs.com/hi-shepherd/p/9030833.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hi-shepherd/p/9030833.html</guid>
<description>&lt;p&gt;未进行打包优化的痛点：&lt;/p&gt;
&lt;p&gt;　　随着项目的不断扩大，引入的第三方库会越来越多，我们每次build的时候会对所有的文件进行打包，耗时必定很长，不利于日常开发。&lt;/p&gt;
&lt;p&gt;解决思路：&lt;/p&gt;
&lt;p&gt;　　第三方库我们只是引入到项目里来，一般不会经常性的去修改源码，一般都是在src目录下编写业务代码，因此可以把第三方依赖和src分开打包。&lt;/p&gt;
&lt;p&gt;　　每次build的时候我们只需要把之前build好的第三方依赖文件引入到项目中即可，避免了我们每次build的时候都会build第三方依赖。&lt;/p&gt;
&lt;p&gt;　　当第三方依赖发生改变的时候我们只需要把第三方依赖再build一次就行。&lt;/p&gt;
&lt;p&gt;步骤一：构建项目 引入第三方依赖&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;

&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
vue init webpack webpack-&lt;span&gt;test
cd dll&lt;/span&gt;-test
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install vuex vue-router axios lodash element-ui  vue-bus iview  --save
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;img src=&quot;https://images2018.cnblogs.com/blog/1032087/201805/1032087-20180513011007306-633845265.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;　　main.js中引入第三方资源&lt;/div&gt;

&lt;div readability=&quot;9.5&quot;&gt;　　
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import Vue from 'vue'&lt;span&gt;
import App from &lt;/span&gt;'./App'&lt;span&gt;
import router from &lt;/span&gt;'./router'&lt;span&gt;
import iView from &lt;/span&gt;'iview'&lt;span&gt;
import VueBus from &lt;/span&gt;'vue-bus'&lt;span&gt;
import lodash from &lt;/span&gt;'lodash'&lt;span&gt;
import vuex from &lt;/span&gt;'vuex'&lt;span&gt;
import ElementUI from &lt;/span&gt;'element-ui'&lt;span&gt;
import axios from &lt;/span&gt;'axios'&lt;span&gt;
import vueRouter from &lt;/span&gt;'vue-router'&lt;span&gt;

Vue.config.productionTip &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;

Vue.use(iView)
Vue.use(ElementUI)
Vue.use(VueBus)
Vue.use(lodash)
Vue.use(vuex)
Vue.use(axios)
Vue.use(vueRouter)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;看下未优化前的打包时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1032087/201805/1032087-20180513014803779-2109197471.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;22930ms差不多23s，后面项目变大，可达数分钟。　&lt;/p&gt;
&lt;p&gt;步骤二：使用DllPlugin插件把第三方依赖抽离出来&lt;/p&gt;
&lt;p&gt;　　在build文件夹下(根目录，config目录下都可以)创建webpack.dll.conf.js&lt;/p&gt;
&lt;p&gt;　　内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; path = require(&quot;path&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; webpack = require(&quot;webpack&quot;&lt;span&gt;);

module.exports &lt;/span&gt;=&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 你想要打包的模块&lt;/span&gt;
&lt;span&gt;  entry: {
    vendor: [
    &lt;/span&gt;'axios'&lt;span&gt;,
    &lt;/span&gt;'iview'&lt;span&gt;,
    &lt;/span&gt;'vue/dist/vue.esm.js'&lt;span&gt;,
    &lt;/span&gt;'lodash'&lt;span&gt;,
    &lt;/span&gt;'vue-bus'&lt;span&gt;,
    &lt;/span&gt;'element-ui'&lt;span&gt;,
    &lt;/span&gt;'vue-router'&lt;span&gt;,
    &lt;/span&gt;'vuex'&lt;span&gt;,
    ]
  },
  output: {
    path: path.join(__dirname, &lt;/span&gt;'../static/js'), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打包后文件输出的位置&lt;/span&gt;
    filename: '[name].dll.js'&lt;span&gt;,
    library: &lt;/span&gt;'[name]_library'&lt;span&gt; 
  },
  plugins: [
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.DllPlugin({
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成上文说到清单文件，此处放在当前build文件下面，你也可以放其他地方&lt;/span&gt;
      path: path.join(__dirname, '.', '[name]-manifest.json'&lt;span&gt;), 
      name: &lt;/span&gt;'[name]_library'&lt;span&gt;
    }),
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;压缩 只是为了包更小一点 &lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.optimize.UglifyJsPlugin({
      compress: {
        warnings: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
        drop_console:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        drop_debugger:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
      },
      output:{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 去掉注释内容&lt;/span&gt;
        comments: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
      },
      sourceMap: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    })
  ]
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将第三方包抽离出来打包的脚本已经写好了，需要编写一条命令来执行该脚本。&lt;/p&gt;
&lt;p&gt;package.json中scripts下加入该命令&quot;dll&quot;: &quot;webpack --config build/webpack.dll.conf.js&quot;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
  &quot;scripts&quot;: {
    &quot;dev&quot;: &quot;webpack-dev-server --inline --progress --config build/webpack.dev.conf.js&quot;,
    &quot;start&quot;: &quot;npm run dev&quot;,
    &quot;lint&quot;: &quot;eslint --ext .js,.vue src&quot;,
    &quot;build&quot;: &quot;node build/build.js&quot;,
    &quot;dll&quot;: &quot;webpack --config build/webpack.dll.conf.js&quot;
  },
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行下npm run dll 命令将第三方依赖进行打包&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1032087/201805/1032087-20180513012759719-169946986.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到在项目中生成了vendor-manifest.json 和 vendor.dll.js这两个文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1032087/201805/1032087-20180513013042271-1103295610.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;vendor-manifest.json是dllPlugin生成的资源，内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1032087/201805/1032087-20180513013442497-1606712384.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;div readability=&quot;19&quot;&gt;
&lt;p&gt;可以看到，每一个公共库中的js文件，都会有一个对应的资源ID。&lt;/p&gt;
&lt;p&gt;同时生成一个打包文件vendor.dll.js，一般是依赖库， 这个文件会暴露给全局一个类似require功能的函数，这个全局函数的名字是可以配置的, 比如，可以为 vendorRequire();&lt;/p&gt;

&lt;p&gt;步骤三：引入DllReferencePlugin 插件，让在打包业务组件的时候自动引入第三方依赖打包好的资源，根据vendor-manifest.json中对应的资源id。&lt;/p&gt;
&lt;p&gt;DllReferencePlugin 是在打包过程中使用的，在打包业务代码时，每遇到一个在manifest.json中出现的文件，就可以利用上述 vendor.dll.js 暴露的全局函数进行相应处理，而不会把这个文件打包进来。&lt;/p&gt;
&lt;/div&gt;
安装add-asset-html-webpack-plugin插件（将打包好的endor.dll.js加入到生成的html中）&lt;/div&gt;
&lt;div readability=&quot;30.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm add-asset-html-webpack-plugin --save
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在webpack.prod.conf.js中加入以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将生成的css js添加到HTML文件&lt;/span&gt;
const AddAssetHtmlPlugin = require('add-asset-html-webpack-plugin')
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在plugins中加入如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打包优化  &lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; webpack.DllReferencePlugin({
      context: path.resolve(__dirname, &lt;/span&gt;'..'&lt;span&gt;), 
      manifest: require(&lt;/span&gt;'./vendor-manifest.json'&lt;span&gt;)
    }),
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个主要是将生成的vendor.dll.js文件加上hash值插入到页面中。&lt;/span&gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AddAssetHtmlPlugin([{
      filepath: path.resolve(__dirname,&lt;/span&gt;'../static/js/vendor.dll.js'&lt;span&gt;),
      outputPath: utils.assetsPath(&lt;/span&gt;'js'&lt;span&gt;),
      publicPath: path.posix.join(config.build.assetsPublicPath, &lt;/span&gt;'static/js'&lt;span&gt;),
      includeSourcemap: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
      hash: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    }]),&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此第三方依赖的抽离已完成，我们打包下看看优化后的速度。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
npm run build
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1032087/201805/1032087-20180513015208379-110079153.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3187ms  才3s，是不是比未优化的22930ms快多了，在项目越来越大的时候效果更明显。&lt;/p&gt;
&lt;p&gt;可以使用npm run build -report 来查看打包的直观图。&lt;/p&gt;
&lt;p&gt;这只是一种优化的方式，还有其他可优化的部分，后续继续添加。&lt;/p&gt;
&lt;p&gt;赶紧去解决打包时间过长的烦恼吧。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 12 May 2018 18:01:00 +0000</pubDate>
<dc:creator>hi_shepherd</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hi-shepherd/p/9030833.html</dc:identifier>
</item>
<item>
<title>在python中单线程，多线程，多进程对CPU的利用率实测以及GIL原理分析 - 汪凡</title>
<link>http://www.cnblogs.com/wf-skylark/p/9030690.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wf-skylark/p/9030690.html</guid>
<description>&lt;h2&gt;&lt;span&gt;首先关于在python中单线程，多线程，多进程对&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;的利用率实测如下：&lt;/span&gt;&lt;/h2&gt;

&lt;h3&gt;单线程，多线程，多进程测试代码使用死循环。&lt;/h3&gt;

&lt;h3&gt;1）单线程：&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180512232126889-326708104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180512232149980-1841831410.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2）多线程：&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180512232159734-1687400170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180512232205488-716353692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3）多进程：&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180512232253143-883243746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180512232258916-279900635.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;查看&lt;/span&gt;cpu&lt;span&gt;使用效率：&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180512232304932-738747330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180512232311598-1135672966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;开始观察分别执行时候&lt;/span&gt;cpu&lt;span&gt;的使用效率：&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;1）单线程执行的时候：&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180512232320063-704376389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2）多线程执行的时候：&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180512232326906-2127536038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3）多进程执行的时候：&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180512232335104-143308973.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;总结：&lt;/h4&gt;
&lt;h4&gt;1）单进程单线程时，对于双核CPU的利用率只能利用一个核，没有充分利用两个核。&lt;/h4&gt;
&lt;h4&gt;2）单进程多线程时，对于双核CPU的来说，虽然两个核都用到的，不过很明显没有充分利用两个核，这里要说一个GIL（全局解释器锁）的概念：&lt;/h4&gt;
&lt;h4&gt;GIL不同于线程之间的互斥锁，GIL并不是Python的特性，而是Cpython引入的一个概念。（Jpython，PYPY）&lt;/h4&gt;
&lt;h4 class=&quot;p&quot;&gt;Python&lt;span&gt;的代码由&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;的解释器执行（&lt;/span&gt;&lt;span&gt;CPython&lt;/span&gt;&lt;span&gt;）。那么我们的代码什么时候被&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;解释器执行，由我们的&lt;/span&gt;&lt;span&gt;GIL&lt;/span&gt;&lt;span&gt;也就是全局解释器锁进行控制。&lt;/span&gt;&lt;/h4&gt;
&lt;h4 class=&quot;p&quot;&gt;&lt;span&gt;当我们有一个线程开始访问解释器的时候，&lt;/span&gt;GIL&lt;span&gt;会将这把锁上锁，也就是说，其他线程无法再访问解释器，也就意味着，其他的线程无法再被执行。&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;h4&gt;GIL执行流程：&lt;/h4&gt;
&lt;h4 class=&quot;p&quot;&gt; &lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;
&lt;h4&gt;加锁GIL&lt;span&gt;。&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;&lt;span&gt;切换到一个线程去执行。&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;&lt;span&gt;运行。&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h4&gt;&lt;span&gt;解锁&lt;/span&gt;GIL&lt;span&gt;。&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;&lt;span&gt;再次重复以上步骤。&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;对于下列代码GIL的执行流程：&lt;/span&gt;&lt;/h4&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import threading
import time
# 写两个函数，分别让两个线程去执行
# 这个两个函数，都要访问我的全局变量
number = 0

def test1(count):
    global number
    for i in range(count):
        number += 1
    print(number)

def test2(count):
    global number
    for i in range(count):
        number += 1
    print(number)


def main():
    th1 = threading.Thread(target=test1,args= (1000000,))
    th2 = threading.Thread(target=test2, args=(1000000,))
    th1.start()
    th2.start()

    time.sleep(5)
    print(number)

if __name__ == '__main__':
    main()
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;运行结果（这里充分的说明了多线程资源抢占问题）：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180512235517495-1130687261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;流程图如下：&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1396321/201805/1396321-20180512235006400-1757623006.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;线程1在执行到对全局变量加一操作的时候全局解释器锁被收回，线程2申请并得到了全局解释器锁开始运行，在线程2执行完加一操作以后对全局变量进行了修改并释放了全局解释器锁。&lt;/h4&gt;
&lt;h4&gt;这时线程1再次得到了全局解释器锁，从上次释放全局解释器锁的地方开始继续执行对全局变量加一的操作，记住，这里线程1中的全局变量还是开始的0，虽然线程2已经对其进行了加一的操作，但是线程1并不知道，线程1还是会接着上一次的位置开始执行，所以线程1在执行完加一操作的时候同样把1再次赋值给了全局变量num，也就是说，线程2执行完加一操作之后赋值过去的1又被线程1赋值过去的1所覆盖，加了两次等于加了一次！类似于协程，只是做了一个执行代码来回切换的操作！&lt;/h4&gt;
&lt;h4 class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;所以在&lt;/span&gt;Python&lt;span&gt;中，同一时刻，只能有一个线程被执行。所以&lt;/span&gt;Python&lt;span&gt;中的多线程是假的&lt;/span&gt;。&lt;/strong&gt;&lt;/h4&gt;
&lt;h4 class=&quot;p&quot;&gt;既然这样我们为什么还要用多线程呢？&lt;/h4&gt;
&lt;h4 class=&quot;p&quot;&gt;其实多线程也有它的好处，例如我们在进行IO操作的时候，有效的组织了程序的阻塞，不至于一直无限的等待。&lt;/h4&gt;
&lt;h4&gt;3）多进程时，对于双核CPU来说，每个进程的优先级都是同等的，所分配的资源也是相等的，两个进程的时候完全可以充分的利用双核CPU，而且由于计算密集型的任务完全是依靠于cpu的核数，所以需要尽量的完全利用cpu，这时候多进程的好处就能够完美的体现出来。&lt;/h4&gt;

&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sat, 12 May 2018 16:17:00 +0000</pubDate>
<dc:creator>汪凡</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wf-skylark/p/9030690.html</dc:identifier>
</item>
<item>
<title>IAAS-libvirt介绍。 - angie_hawk7</title>
<link>http://www.cnblogs.com/hrbeu05/p/9030677.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hrbeu05/p/9030677.html</guid>
<description>&lt;h2&gt;Libvirt介绍&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/532603/201805/532603-20180513002233268-693365384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/532603/201805/532603-20180513001031360-804857251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Libvirt&lt;span&gt;与&lt;/span&gt;&lt;span&gt;hypervisor&lt;/span&gt;&lt;span&gt;无关，其提供与多种操作系统虚拟化能力进行交互的&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;与工具库。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Libvirt&lt;span&gt;提供了一个通用稳定的抽象层，可以安全的操作物理机上的虚拟机，同时为了可以远程交互，&lt;/span&gt;&lt;span&gt;Libvirt&lt;/span&gt;&lt;span&gt;在&lt;/span&gt;&lt;span&gt;hypervisor&lt;/span&gt;&lt;span&gt;支持的范围内提供了创建，修改，监控，迁移，停止&lt;/span&gt; &lt;span&gt;domain&lt;/span&gt;&lt;span&gt;的一系列&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;，虽然可以使用&lt;/span&gt;&lt;span&gt;Libvirt&lt;/span&gt;&lt;span&gt;同时访问多个物理机，但是&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;层做了限制，只允许访问单个物理机。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Libvirt&lt;span&gt;被设计为可以支持多种虚拟化环境，这意味着大部分通用的能力在&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;上是被支持的，也因为此，在于通用型之间为了平衡，一些特殊的能力是不被支持的，譬如不支持虚拟化的告警策略或者多节点管理，不过&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;的稳定性确保这些特性可以在&lt;/span&gt;&lt;span&gt;Libvirt&lt;/span&gt;&lt;span&gt;实现。为了保持这种稳定性，&lt;/span&gt;&lt;span&gt;Libvirt&lt;/span&gt;&lt;span&gt;视图隔离这些虚拟化框架中频繁变更的应用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Libvirt&lt;span&gt;意在作为单虚拟化节点上的高级管理工具和应用，唯一例外的是虚拟机在多个物理机的迁移能力。提供了一系列&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;用来定义，监控，和使用管理节点的资源，这些资源包括&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;memory&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;storage&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;network&lt;/span&gt;&lt;span&gt;以及&lt;/span&gt;&lt;span&gt;NUMA&lt;/span&gt;&lt;span&gt;分区，虽然一个单独的物理机可以被管理程序分配一个管理节点，但是这应该确保使用安全的协议来操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;术语定义：&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;137&quot;&gt;
&lt;p&gt;术语&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;431&quot;&gt;
&lt;p&gt;定义&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;137&quot;&gt;
&lt;p&gt;Domain&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;431&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;运行在被&lt;span&gt;hypervisor&lt;/span&gt;&lt;span&gt;支持的虚拟机的上，表示一个操作系统的实例，对于容器虚拟化来说，表示的是操作系统的子系统。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;137&quot;&gt;
&lt;p&gt;Hypervisor&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;431&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;相对于物理机来说，有自己特殊配置的可以支持虚拟化的软件层&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;137&quot;&gt;
&lt;p&gt;Node&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;431&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;物理机，可以是不同的类型，譬如存储类型，数据库类型等&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;137&quot;&gt;
&lt;p&gt;Storage Pool&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;431&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;存储池，一个存储介质的集合，例如物理硬盘驱动器，一个存储池被切分为多个卷，这些卷可以分配给一个或者多个虚拟机&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;137&quot;&gt;
&lt;p&gt;Volume&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;431&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;卷，存储池上分配的存储空间，卷可以指定给虚拟机使用，一般更多的是在虚拟机领域内被作为虚拟硬盘驱动器使用&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;on&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;对象模型&lt;/h2&gt;
&lt;p&gt;Libvirt&lt;span&gt;中的对象使用&lt;/span&gt;&lt;span&gt;xml&lt;/span&gt;&lt;span&gt;进行配置（也就是应用程序与&lt;/span&gt;&lt;span&gt;libvirt&lt;/span&gt;&lt;span&gt;交互的时候，通过&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;传输的数据承载体是&lt;/span&gt;&lt;span&gt;xml&lt;/span&gt;&lt;span&gt;格式）。关于每种对象的&lt;/span&gt;&lt;span&gt;xml&lt;/span&gt;&lt;span&gt;定义详细参见：&lt;/span&gt;&lt;a href=&quot;https://libvirt.org/format.html&quot;&gt;&lt;span&gt;https://libvirt.org/format.html&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Hypervisor connections&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;无论作为一个&lt;/span&gt;Libvirt&lt;span&gt;的客户端应用运行在本地节点还是通过网络访问远端的节点，都需要建立一个连接&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;连接是通过&lt;strong&gt;virConnectPtr&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;对象管理，并通过&lt;/span&gt;URI标记。URI的schema和path决定了连接哪钟hypervisor，而URI的host部分决定是那个hypervisor节点。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;允许应用同时建立多个连接，包括一个机器的不同&lt;/span&gt;hypervisor。例如一台主机同时支持KVM和LXC虚拟化。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一个连接对象可以被多个线程复用，一旦一个连接被建立，就可能获取其它管理对象的句柄或者创建一个新的管理对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;表示一个正在运行的虚拟机或者一个可以启动虚拟机的配置。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个&lt;/span&gt;Guest domain&lt;span&gt;使用具有唯一标识的一个&lt;/span&gt;&lt;strong&gt;virDomainPtr&lt;/strong&gt;&lt;strong&gt;对象表示&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;唯一标识对象具有&lt;/span&gt;ID，名称，UID三个属性：&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;strong&gt;Guest domains&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ID:&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;正整数，单个主机上运行状态的虚拟机是唯一的，非运行状态没有&lt;/span&gt;ID&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Name：&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;字符串，一个主机上的所有虚拟机之间名称唯一，字符串只允许包含：字母数字（&lt;/span&gt;A—Z，0—9），连字符（-）和下划线（^）字符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UUID:&lt;/strong&gt;&lt;strong&gt;16字节，任意主机的所有虚拟机之间唯一，RFC4122定义了UUID的格式和提供算法保证唯一性。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;提供创建&lt;/span&gt;geust domains，管理已经存在的guest dmains的一系列API&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Geust domain分为零时的和永久的，零时的guest domain只有在其运行状态才可以被管理，一旦关机，其所有痕迹都会消失，永久的guest domain 的配置数据被存储在hypervisor主机的数据存储上，因此，即使断电，依然可以被管理。一个临时的guest 可以在其运行的状态下通过定义配置属性转换为永久的guest&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;strong&gt;Virtual networks&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Virtual networks&lt;span&gt;提供一种在一台主机内，可以连接一个或者多个虚拟机的网络设备的方法。可以支持：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;与宿主机的隔离型&lt;/li&gt;
&lt;li&gt;Allow routing of traffic off-node via the active network interfaces of the host OS. This includes the option to apply NAT to IPv4 traffic.&lt;/li&gt;
&lt;li&gt;一个虚拟网络由&lt;strong&gt;具有两个唯一标识&lt;/strong&gt;&lt;strong&gt;virNetworkPtr&lt;/strong&gt;&lt;strong&gt;对象表示&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Name：字符串，只允许包含：&lt;/strong&gt;&lt;strong&gt;a-Z,0-9,-,_&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;字符，在一台主机的所有虚拟网络之间&lt;/span&gt;Name唯一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UUID:16字节，&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;任意主机的所有虚拟网络之间唯一，&lt;/span&gt;RFC4122定义了UUID的格式和提供算法保证唯一性。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;虚拟网络也分为零时的和永久的，同&lt;/span&gt;Geust domains描述相同。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;在&lt;/span&gt;Libvirt被安装后，每个host将获得一个名为default的虚拟网络，其提供DHCP服务为geust，并且允许NAT IP连接到主机的网口，这对于使用间歇性网络的大部分主机很有用，譬如使用无线网络的笔记本。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;strong&gt;Storage pools&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;存储吃对象提供了一种管理一台主机上所有类型存储的机制，例如本地磁盘，逻辑卷组，&lt;/span&gt;iSCSI&lt;span&gt;目标，光线&lt;/span&gt;&lt;span&gt;HBA&lt;/span&gt;&lt;span&gt;，以及本地&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;网络文件系统。一个池由表示的是可以被分配为多个独立的卷所组成的数据存储。其使用一对唯一身份的&lt;/span&gt;&lt;strong&gt;virStoragePoolPtr&lt;/strong&gt;&lt;strong&gt;对象表示。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Name：字符串，只包含&lt;/strong&gt;&lt;strong&gt;a-Z,0-9,-,_&lt;/strong&gt; &lt;strong&gt;。&lt;/strong&gt;&lt;strong&gt;一台主机上唯一。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UUID:同上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;存储池也分为零时的和永久的，同上述定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Storage volumes&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;存储卷对象提供在一个存储池内的存储块的分配管理。可以是磁盘分区，逻辑卷，SCSI/iSCSI LUN，&lt;span&gt;或者本地&lt;/span&gt;/网络文件系统中的文件。一旦被分配，一个卷给一个或者多个虚拟机提供磁盘。&lt;/p&gt;
&lt;p&gt;一个卷通过具有三个标识属性的&lt;strong&gt;virStorageVolPtr&lt;/strong&gt; &lt;strong&gt;对象表示。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Name：字符串，只允许包含&lt;/strong&gt;&lt;strong&gt;a-Z,0-9,-,_&lt;/strong&gt; &lt;strong&gt; &lt;span&gt;一个存储池呢唯一。具有稳定不可变形&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Key：一个存储池内唯一，任意字符串，具有稳定不可变性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Path：表示卷的文件系统路径，具有稳定不可变性，即使重新启动后也保持不变&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Host devices&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;主机设备提供了主机上可用的硬件设备的视图，包含物理的&lt;/span&gt;USB,PCI&lt;span&gt;设备，与提供例如网卡，磁盘，磁盘控制器，声卡等的逻辑设备。设备被排列为可以识别的关系树结构来识别。主机设备使用&lt;/span&gt;&lt;strong&gt;virNodeDevPtr&lt;/strong&gt; &lt;strong&gt;对象来标识，有一个通用属性，不过特殊的设备类型可以有自己的唯一标识符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Name：字符串，主机上所有设备中唯一，命名由主机的操作系统决定。名称不能保证在重新启动后保持不变。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;物理设备可以从主机&lt;/span&gt;OS的驱动程序（可以从geust domain隐式删除所有关联的逻辑设备）解除绑定，物理设备的信息在使用存储和网络API来确定可配置的资源的时候是很有用的&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;驱动模型&lt;/h2&gt;
&lt;p&gt;1&lt;span&gt;：屏蔽不同虚拟化技术的差异，稳定，公开的&lt;/span&gt;&lt;span&gt;API&amp;amp;ABI&lt;/span&gt;&lt;span&gt;集合。不同虚拟化技术有不同的&lt;/span&gt;&lt;span&gt;Driver ABI&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;：应用程序可以通过指定&lt;/span&gt;&lt;span&gt;URI&lt;/span&gt;&lt;span&gt;来决定使用哪种虚拟化技术的&lt;/span&gt;&lt;span&gt;ABI&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;：&lt;/span&gt;&lt;span&gt;Libvirt&lt;/span&gt;&lt;span&gt;对应用程序提供了查询主机支持的&lt;/span&gt;&lt;span&gt;hypervisor&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;ABI&lt;/span&gt;&lt;span&gt;类型额&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/532603/201805/532603-20180513001109025-683140108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Hypervisor Driver&lt;/strong&gt;&lt;/h3&gt;
&lt;table&gt;&lt;tbody readability=&quot;24.702642185401&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;90&quot;&gt;
&lt;p&gt;Hypervisor&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;78&quot;&gt;
&lt;p&gt;URI&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot;&gt;
&lt;p&gt;详细介绍&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.2083333333333&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;90&quot;&gt;
&lt;p&gt;&lt;strong&gt;Xen&lt;/strong&gt;:&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;78&quot;&gt;
&lt;p&gt;&lt;strong&gt;xen:///&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;The open source Xen hypervisor providing paravirtualized and&lt;em&gt; fully virtualized machines&lt;/em&gt;.A single system driver runs in the Dom0 host talking directly to a combination of the hypervisor,xenstored and xend&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot; readability=&quot;0.44117647058824&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://libvirt.org/drvxen.html&quot;&gt;https://libvirt.org/drvxen.html&lt;/a&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.7153284671533&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;90&quot;&gt;
&lt;p&gt;&lt;strong&gt;QEMU&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;78&quot;&gt;
&lt;p&gt;&lt;strong&gt;qemu:///system&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;Any open source QEMU based virtualization technology, including KVM. A single privileged system driver runs in the host managing QEMU processes. Each unprivileged user account also&lt;/p&gt;
&lt;p&gt;has a private instance of the driver&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot; readability=&quot;0.42857142857143&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://libvirt.org/drvqemu.html&quot;&gt;https://libvirt.org/drvqemu.html&lt;/a&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.285447761194&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;90&quot;&gt;
&lt;p&gt;&lt;strong&gt;UML&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;78&quot;&gt;
&lt;p&gt;&lt;strong&gt;uml:///system&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;The User Mode Linux kernel, a pure paravirtualization technology. A single privileged system driver runs in the host managing UML processes. Each unprivileged user account also has a private instance of the driver&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot; readability=&quot;0.44117647058824&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://libvirt.org/drvuml.html&quot;&gt;https://libvirt.org/drvuml.html&lt;/a&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.095652173913&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;90&quot;&gt;
&lt;p&gt;&lt;strong&gt;OpenVZ&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;78&quot;&gt;
&lt;p&gt;&lt;strong&gt;openvz:///system&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;The OpenVZ container based virtualization technology, using a modified Linux host kernel.&lt;/p&gt;
&lt;p&gt;A single privileged system driver runs in the host talking to the OpenVZ tools&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot; readability=&quot;0.40540540540541&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://libvirt.org/drvopenvz.html&quot;&gt;https://libvirt.org/drvopenvz.html&lt;/a&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.1911111111111&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;90&quot;&gt;
&lt;p&gt;&lt;strong&gt;LXC&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;78&quot;&gt;
&lt;p&gt;&lt;strong&gt;lxc:///&lt;/strong&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;The native Linux container based virtualization technology, available with Linux kernels since&lt;/p&gt;
&lt;p&gt;2.6.25. A single privileged system driver runs in the host talking to the kernel&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot; readability=&quot;0.44117647058824&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://libvirt.org/drvlxc.html&quot;&gt;https://libvirt.org/drvlxc.html&lt;/a&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;20&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;90&quot;&gt;
&lt;p&gt;&lt;strong&gt;Remote&lt;/strong&gt;:&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;78&quot; readability=&quot;7&quot;&gt;
&lt;p&gt; Example URI to talk to Xen over a TLS channel&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;xen+tls://somehostname/&lt;/strong&gt;. Example URI to talk to QEMU over a SASL channel &lt;strong&gt;qemu+tcp:///&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;somehost/system&lt;/strong&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot; readability=&quot;15&quot;&gt;
&lt;p&gt;Generic secure RPC service talking to a &lt;strong&gt;libvirtd&lt;/strong&gt; daemon. Encryption and&lt;/p&gt;
&lt;p&gt;authentication using a choice of TLS, x509 certificates, SASL (GSSAPI/Kerberos) and SSH&lt;/p&gt;
&lt;p&gt;tunneling. URIs follow the scheme of the desired driver, but with a hostname filled in, and a data&lt;/p&gt;
&lt;p&gt;transport name appended to the URI scheme&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15.866666666667&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;90&quot;&gt;
&lt;p&gt;VMware ESX&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;78&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;vpx://example-vcenter.com/dc1/srv1     (VPX over HTTPS, select ESX server 'srv1' in datacenter 'dc1')&lt;/p&gt;
&lt;p&gt;esx://example-esx.com                  (ESX over HTTPS)&lt;/p&gt;
&lt;p&gt;gsx://example-gsx.com                  (GSX over HTTPS)&lt;/p&gt;
&lt;p&gt;esx://example-esx.com/?transport=http  (ESX over HTTP)&lt;/p&gt;
&lt;p&gt;esx://example-esx.com/?no_verify=1     (ESX over HTTPS, but doesn't verify the server's SSL certificate)&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot; readability=&quot;0.44117647058824&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://libvirt.org/drvesx.html&quot;&gt;https://libvirt.org/drvesx.html&lt;/a&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;90&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;78&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;199&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;&lt;strong&gt;Storage Driver&lt;/strong&gt;&lt;/h3&gt;
&lt;table&gt;&lt;tbody readability=&quot;3.3333333333333&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;后端存储类型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;详细说明&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;0.88732394366197&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Directory backend&lt;/p&gt;
&lt;/td&gt;
&lt;td rowspan=&quot;10&quot; valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;0.28301886792453&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://libvirt.org/storage.html#StorageBackendDir&quot;&gt;https://libvirt.org/storage.html#StorageBackendDir&lt;/a&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Local filesystem backend&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Network filesystem backend&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Logical Volume Manager (LVM) backend&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Disk backend&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;iSCSI backend&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;SCSI backend&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Multipath backend&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;RBD (RADOS Block Device) backend&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;Sheepdog backend&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;&lt;strong&gt;NodeDevice Driver&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;LIVirt&lt;span&gt;提供了物理和虚拟主机设备的管理，如&lt;/span&gt;&lt;span&gt;USB&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;PCI&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;SCSI&lt;/span&gt;&lt;span&gt;和网络设备。包括上述设备提供的各种虚拟化能力，例如&lt;/span&gt;&lt;span&gt;SR-IOV&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;NPIV&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;MDEV&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;DRM&lt;/span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生成主机设备的&lt;/span&gt;xml&lt;span&gt;定义属性如下：&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;14.497126436782&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;139&quot;&gt;
&lt;p&gt;属性&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;139&quot;&gt;
&lt;p&gt;Name&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;The device's name will be generated by libvirt using the subsystem, like pci and the device's sysfs basename.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;139&quot;&gt;
&lt;p&gt;Path&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;正确的指向设备的系统文件路径&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;139&quot;&gt;
&lt;p&gt;Parent&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;此元素标识设备层次结构中的父节点。如果设备没有任何父级，则该元素的值将对应于设备父级的名称元素或计算机。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;139&quot;&gt;
&lt;p&gt;Driver&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;此元素报告在该设备中使用的驱动程序。此元素在输出&lt;span&gt;XML&lt;/span&gt;&lt;span&gt;中的存在取决于底层设备管理器（最有可能的&lt;/span&gt;&lt;span&gt;UDEV&lt;/span&gt;&lt;span&gt;）是否公开了有关驱动程序的信息。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;26.04780876494&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;139&quot;&gt;
&lt;p&gt;Capability&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot; readability=&quot;21.360488798371&quot;&gt;
&lt;p&gt;描述设备的支持特性，有一个决定设备的类型的必须属性。当前支持的属性为： &lt;span&gt;system, pci, usb, usb_device, net, scsi, scsi_host (Since 0.4.7), fc_host, vports, scsi_target (Since 0.7.3), storage (Since 1.0.4), scsi_generic (Since 1.0.7), drm (Since 3.1.0), and mdev (Since 3.4.0).&lt;/span&gt; &lt;span&gt;这些元素可以嵌套，此时可以更进一步指定设备的具体能力。具体支持的设备&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;的详细使用模型和介绍参见：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://libvirt.org/drvnodedev.html&quot;&gt;https://libvirt.org/drvnodedev.html&lt;/a&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;139&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;429&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;远程管理&lt;/h2&gt;
&lt;p&gt;Libvirt&lt;span&gt;内部对&lt;/span&gt;&lt;span&gt;driver&lt;/span&gt;&lt;span&gt;提供了可以远程管理&lt;/span&gt;&lt;span&gt;Libvirt&lt;/span&gt;&lt;span&gt;管理程序的能力，但是并不直接在&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;上暴漏给应用程序。此外&lt;/span&gt;&lt;span&gt;Libvirt&lt;/span&gt;&lt;span&gt;内部包含了本地&lt;/span&gt;&lt;span&gt;RPC&lt;/span&gt;&lt;span&gt;服务。&lt;/span&gt;&lt;span&gt;Libvirt-qpid&lt;/span&gt;&lt;span&gt;项目提供了&lt;/span&gt;&lt;span&gt;QPID&lt;/span&gt;&lt;span&gt;消息服务的&lt;/span&gt;&lt;span&gt;agent&lt;/span&gt;&lt;span&gt;，将所有&lt;/span&gt;&lt;span&gt;LIVIVT&lt;/span&gt;&lt;span&gt;托管对象和操作暴漏到了消息总线上，暴漏的能力与&lt;/span&gt;&lt;span&gt;Libvirt&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;C-API&lt;/span&gt;&lt;span&gt;几乎一致&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;RPC&lt;span&gt;服务的&lt;/span&gt;&lt;span&gt;Server&lt;/span&gt;&lt;span&gt;端由&lt;/span&gt;&lt;span&gt;Libvirtd&lt;/span&gt;&lt;span&gt;守护进程提供，守护进程必须运行在被管理的主机上。默认部署中，守护进程只监听本地&lt;/span&gt;&lt;span&gt;UNIX socket&lt;/span&gt;&lt;span&gt;连接。只允许&lt;/span&gt;&lt;span&gt;Libvirt&lt;/span&gt;&lt;span&gt;客户端使用&lt;/span&gt;&lt;span&gt;SSH&lt;/span&gt;&lt;span&gt;隧道传输数据，使用&lt;/span&gt;&lt;span&gt;X509&lt;/span&gt;&lt;span&gt;证书或&lt;/span&gt;&lt;span&gt;SASL&lt;/span&gt;&lt;span&gt;凭据。&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;16.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;146&quot;&gt;
&lt;p&gt;Transport&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;422&quot;&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;18.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;146&quot;&gt;
&lt;p&gt;Tls&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;422&quot; readability=&quot;24&quot;&gt;
&lt;p&gt;A TCP socket running the TLS protocol on the&lt;/p&gt;
&lt;p&gt;wire. &lt;strong&gt;This is the default data transport if none is&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;explicitly requested&lt;/strong&gt;, and uses a TCP connection&lt;/p&gt;
&lt;p&gt;on port &lt;strong&gt;16514&lt;/strong&gt;. &lt;strong&gt;At minimum it is necessary to&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;configure the server with a x509 certificate&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;authority and issue it a server certificate&lt;/strong&gt;. The&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;libvirtd&lt;/strong&gt; server can, optionally, be configured&lt;/p&gt;
&lt;p&gt;to require clients to present x509 certificates as a&lt;/p&gt;
&lt;p&gt;means of authentication.&lt;/p&gt;
&lt;p&gt;1：这是Libvirt默认的传输通道&lt;/p&gt;
&lt;p&gt;2：TCP端口16514&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;146&quot;&gt;
&lt;p&gt;Tcp&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;422&quot; readability=&quot;19&quot;&gt;
&lt;p&gt;A TCP socket without the TLS protocol on&lt;/p&gt;
&lt;p&gt;the wire. This data transport should not be&lt;/p&gt;
&lt;p&gt;used on untrusted networks, unless the SASL&lt;/p&gt;
&lt;p&gt;authentication service has been enabled&lt;/p&gt;
&lt;p&gt;and configured with a plug-in that provides&lt;/p&gt;
&lt;p&gt;encryption. The TCP connection is made on port&lt;/p&gt;
&lt;p&gt;16509.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1：TCP端口16509&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2：没有采用TLS安全协议传输，不应该使用在非信任网络内（如DMZ区），除非启用了SASL身份认证服务并使用提供加密能力的插件配&lt;/strong&gt;置&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;17&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;146&quot;&gt;
&lt;p&gt;Unix&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;422&quot; readability=&quot;23&quot;&gt;
&lt;p&gt;A local only data transport, allowing users to&lt;/p&gt;
&lt;p&gt;connect to a &lt;strong&gt;libvirtd&lt;/strong&gt; daemon running as a&lt;/p&gt;
&lt;p&gt;different user account. As it is only accessible&lt;/p&gt;
&lt;p&gt;on the local machine, it is unencrypted. The&lt;/p&gt;
&lt;p&gt;standard socket names are &lt;strong&gt;/var/run/&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;libvirt/libvirt-sock&lt;/strong&gt; for full management&lt;/p&gt;
&lt;p&gt;capabilities and &lt;strong&gt;/var/run/libvirt/&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;libvirt-sock-ro&lt;/strong&gt; for a socket restricted to&lt;/p&gt;
&lt;p&gt;read only operations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1：本地数据传输。&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;21.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;146&quot;&gt;
&lt;p&gt;Ssh&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;422&quot; readability=&quot;34&quot;&gt;
&lt;p&gt;The RPC data is tunneled over an SSH&lt;/p&gt;
&lt;p&gt;connection to the remote machine. It requires&lt;/p&gt;
&lt;p&gt;Netcat (nc) is installed on the remote machine&lt;/p&gt;
&lt;p&gt;and that libvirtd is running with the UNIX domain&lt;/p&gt;
&lt;p&gt;socket enabled. It is recommended that SSH&lt;/p&gt;
&lt;p&gt;be configured to not require password prompts&lt;/p&gt;
&lt;p&gt;to the client application. For example, if using&lt;/p&gt;
&lt;p&gt;SSH public key authentication it is recommended&lt;/p&gt;
&lt;p&gt;an ssh-agent by run to cache key credentials.&lt;/p&gt;
&lt;p&gt;GSSAPI is another useful authentication mode&lt;/p&gt;
&lt;p&gt;for the SSH transport allowing use of a preinitialized&lt;/p&gt;
&lt;p&gt;Keberos credential cache.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1：远端机器必须安装netcat程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2：Libvirtd守护进程必须打开UNIX socket开关&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3：建议ssh配置为不需要对客户端进行密码提示的模式&lt;/strong&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;146&quot;&gt;
&lt;p&gt;Ext&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;422&quot; readability=&quot;18&quot;&gt;
&lt;p&gt;Any external program that can make a&lt;/p&gt;
&lt;p&gt;connection to the remote machine by means&lt;/p&gt;
&lt;p&gt;that are outside the scope of libvirt. If none of&lt;/p&gt;
&lt;p&gt;the built-in data transports are satisfactory, this&lt;/p&gt;
&lt;p&gt;allows an application to provide a helper program&lt;/p&gt;
&lt;p&gt;to proxy RPC data over a custom channel.&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;应用可以自定义数据传输通道&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;146&quot;&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;422&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;efinition&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;API&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;支持的客户端语言有：&lt;/span&gt; c#, go, java, ocaml, perl, python, php, ruby&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://libvirt.org/docs/libvirt-appdev-guide/en-US/pdf/libvirt-0.9-Application_Development_Guide-en-US.pdf&quot;&gt;&lt;span&gt;https://libvirt.org/docs/libvirt-appdev-guide/en-US/pdf/libvirt-0.9-Application_Development_Guide-en-US.pdf&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;API&lt;span&gt;涉及的对象有列下，监控统计，配置管理都涉及，对于配置管理基本都是&lt;/span&gt;&lt;span&gt;XML&lt;/span&gt;&lt;span&gt;数据内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/532603/201805/532603-20180513001317981-293521750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如上信息主要参考&lt;/span&gt;libvirt&lt;span&gt;官网文档，以及&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;手册。通过此篇应该了解如下信息：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;：&lt;/span&gt;&lt;span&gt;libvirt&lt;/span&gt;&lt;span&gt;支持多种&lt;/span&gt;&lt;span&gt;hypervisor&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;storage&lt;/span&gt;&lt;span&gt;，并且应用程序可以基于其规范扩展&lt;/span&gt;&lt;span&gt;dirver&lt;/span&gt;&lt;span&gt;插件以满足产品使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;：&lt;/span&gt;&lt;span&gt;libvirt&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;有哪些（可以配置管理哪些对象，可以获取哪些对象的哪些指标），如何使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;扩展延伸：&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;：既然&lt;/span&gt;&lt;span&gt;libvirt&lt;/span&gt;&lt;span&gt;层面支持了&lt;/span&gt;&lt;span&gt;lxc&lt;/span&gt;&lt;span&gt;，为什么还会额外出现&lt;/span&gt;&lt;span&gt;libcontainer&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt;&lt;span&gt;针对&lt;/span&gt;&lt;span&gt;lxc&lt;/span&gt;&lt;span&gt;容器的抽象层&lt;/span&gt;&lt;span&gt;api&lt;/span&gt;&lt;span&gt;），&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;：为什么额外会出现&lt;/span&gt;&lt;span&gt;lxd&lt;/span&gt;&lt;span&gt;（直接操作内核态&lt;/span&gt;&lt;span&gt;lxc&lt;/span&gt;&lt;span&gt;，提供&lt;/span&gt;&lt;span&gt;restAPI&lt;/span&gt;&lt;span&gt;，命令行&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;，守护进程），为什么在&lt;/span&gt;&lt;span&gt;openstack&lt;/span&gt;&lt;span&gt;生态圈中会出现&lt;/span&gt;&lt;span&gt;nova-compute&lt;/span&gt;&lt;span&gt;直接到&lt;/span&gt;&lt;span&gt;lxd&lt;/span&gt;&lt;span&gt;的模式？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;：&lt;/span&gt;&lt;span&gt;GPU,FPGA&lt;/span&gt;&lt;span&gt;等异构专属设备如何通过&lt;/span&gt;&lt;span&gt;libvirt&lt;/span&gt;&lt;span&gt;操作的详细实践步骤。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 12 May 2018 16:12:00 +0000</pubDate>
<dc:creator>angie_hawk7</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hrbeu05/p/9030677.html</dc:identifier>
</item>
<item>
<title>JS的事件绑定、事件流模型 - 小白坤</title>
<link>http://www.cnblogs.com/gcywj/p/9030668.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gcywj/p/9030668.html</guid>
<description>&lt;h2&gt;&lt;span&gt;（一）JS事件分类&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.鼠标事件：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;click/dbclick/mouseover/mouseout&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.HTML事件：&lt;/span&gt;&lt;br/&gt;&lt;span&gt; onload/onunload/onsubmit/onresize/onchange/onfoucs/onscroll&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.键盘事件：&lt;/span&gt;&lt;br/&gt;&lt;span&gt; keydown：键盘按下时触发&lt;/span&gt;&lt;br/&gt;&lt;span&gt; keypress：键盘按下并抬起的瞬间触发。&lt;/span&gt;&lt;br/&gt;&lt;span&gt; keyup：键盘抬起触发&lt;/span&gt;&lt;br/&gt;&lt;span&gt;[注意事项]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;①执行顺序：keydown keypress keyup&lt;/span&gt;&lt;br/&gt;&lt;span&gt;②keypress只能捕获数字，字母，符号键，而不能捕获功能键。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;③长按时循环执行keydown--keypress&lt;/span&gt;&lt;br/&gt;&lt;span&gt;④有keydown，并不一定有keyup，当长按时焦点失去，将不再触发keyup&lt;/span&gt;&lt;br/&gt;&lt;span&gt;⑤keypress区分大小写，keydown，kewup不区分。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4.事件因子：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当触发一个事件时，该事件将向事件所调用的函数中，默认传入一个参数，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这个参数就是一个事件因子，包含了该事件的各种详细信息。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 document.onkeydown=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
 console.log(e);
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
document.onkeydown=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
console.log(window.event);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;兼容浏览器的写法：&lt;/span&gt;
document.onkeydown=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
e&lt;/span&gt;==e||&lt;span&gt;Window.event;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Code=e.keyCode||e.which||&lt;span&gt;e.charCode;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(code==13&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;回车&lt;/span&gt;
&lt;span&gt;}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;5.如何确定键盘按键？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;①再出发的函数中，接收事件因子e。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;②可以使用e.key直接去到按下的按键字符（不推荐使用）。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;③一次可以使用keyCode/which/charCode取到按键的ASCII码值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(兼容各种浏览器的写法)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; Code=e.keyCode||e.which||e.charCode;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断组合键&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; isAlt=0,isEnt=0&lt;span&gt;;
document.onkeyup&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(e.keyCode==18&lt;span&gt;){
isAlt&lt;/span&gt;=1&lt;span&gt;;
}            
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(e.keyCode==13&lt;span&gt;){
isEnt&lt;/span&gt;=1&lt;span&gt;;
}        
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(isAlt==1&amp;amp;&amp;amp;isEnt==1&lt;span&gt;){
alert(&lt;/span&gt;&quot;同时按下Alt和Enter键&quot;&lt;span&gt;);
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
document.onkeyup=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
console.log(&lt;/span&gt;&quot;keyup&quot;&lt;span&gt;);
}
document.onkeypress&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
console.log(&lt;/span&gt;&quot;keypress&quot;&lt;span&gt;);
}
document.onkeydown&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
console.log(&lt;/span&gt;&quot;keydown&quot;&lt;span&gt;);
}
document.onkeypress&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
console.log(window.event);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否按下了回车键&lt;/span&gt;
document.onkeydown=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; code=&lt;span&gt;e.keyCode;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(code==13&lt;span&gt;){
alert(&lt;/span&gt;&quot;你输入的是回车键&quot;&lt;span&gt;);
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;（一）DOM0事件模型&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;绑定注意事项：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①使用window.onload加载完成后进行绑定。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
window.onload =&lt;span&gt;function&lt;/span&gt;(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;事件}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;②放在body后面进行绑定。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;body内容&lt;/span&gt;
&amp;lt;body&amp;gt;
    &amp;lt;button onclick=&quot;func()&quot;&amp;gt;内联模型绑定&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;btn1&quot;&amp;gt;哈哈哈哈&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;btn2&quot;&amp;gt;DOM2模型绑定&amp;lt;/button&amp;gt;
    &amp;lt;button id=&quot;btn3&quot;&amp;gt;取消DOM2&amp;lt;/button&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;1.内联模型（行内绑定）：将函数名直接作为html标签中属性的属性值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;button onclick=&quot;func()&quot;&amp;gt;内联模型绑定&amp;lt;/button&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 缺点：不符合w3c中关于内容与 行为分离的基本规范。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.脚本模型（动态绑定）：通过在JS中选中某个节点，然后给节点添加onclick属性。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
document.getElementById(&quot;btn1&quot;)=&lt;span&gt;function&lt;/span&gt;(){}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 优点：符合w3c中关于内容与行为分离的基本规范，实现html与js的分离。&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 缺点：同一个节点只能添加一次同类型事件，如果添加多次，最后一个生效。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
document.getElementById(&quot;btn1&quot;).onclick=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    alert(&lt;/span&gt;1234&lt;span&gt;);    
}
document.getElementById(&lt;/span&gt;&quot;btn1&quot;).onclick=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    alert(&lt;/span&gt;234&lt;span&gt;);    
}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重复的只能出现最近的一次&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3.DOM0共有缺点：通过DOM0绑定的事件，一旦绑定将无法取消。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
document.getElementById(&quot;btn3&quot;).onclick=&lt;span&gt;function&lt;/span&gt;(){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不能取消匿名函数&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(btn.detachEvent){
        btn.detachEvent(&lt;/span&gt;&quot;onclick&quot;&lt;span&gt;,func1);
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        btn.removeEventListener(&lt;/span&gt;&quot;click&quot;&lt;span&gt;,func1);
    }
        alert(&lt;/span&gt;&quot;取消DOM2&quot;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;（二）DOM2事件模型&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.添加DOM2事件绑定：&lt;/span&gt;&lt;br/&gt;&lt;span&gt; ①IE8之前，使用.attachEvent(&quot;onclick&quot;,函数);&lt;/span&gt;&lt;br/&gt;&lt;span&gt; ②IE8之后，使用.addEventListener(&quot;click&quot;,函数，true/false);&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 参数三：false（默认）表示事件冒泡，传入true表示事件捕获。&lt;/span&gt;&lt;br/&gt;&lt;span&gt; ③兼容所有浏览器的处理方式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; btn=document.getElementById(&quot;btn1&quot;&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(btn.attachEvent){
 btn.attachEvent(&lt;/span&gt;&quot;onclick&quot;,func1);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;事件，事件需要执行的函数IE8可以&lt;/span&gt;
 }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
  btn.attachEventListener(&lt;/span&gt;&quot;click&quot;&lt;span&gt;,func1);
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2.DOM2绑定的优点：&lt;/span&gt;&lt;br/&gt;&lt;span&gt; ①同一个节点，可以使用DOM2绑定多个同类型事件。&lt;/span&gt;&lt;br/&gt;&lt;span&gt; ②使用DOM2绑定的事件，可以有专门的函数进行取消。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3.取消事件绑定：&lt;/span&gt;&lt;br/&gt;&lt;span&gt; ①使用attachEvent绑定，要用detachevent取消。&lt;/span&gt;&lt;br/&gt;&lt;span&gt; ②使用attachEventListener绑定，要用removeEventListenter取消。&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 注意：如果DOM2绑定的事件，需要取消，则绑定事件时，回调函数必须是函数名，&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 而不能是匿名函数，因为取消事件时，取消传入函数名进行取消。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;（一）JS中的事件流模型&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1. 事件冒泡(fasle/不写)：当触发一个节点的事件是，会从当前节点开始，依次触发其祖先节点的同类型事件，直到DOM根节点。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2. 事件捕获(true)：当初发一个节点的事件时，会从DOM根节点开始，依次触发其祖先节点的同类型事件，直到当前节点自身。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3. 什么时候事件冒泡？什么时候事件捕获？&lt;/span&gt;&lt;br/&gt;&lt;span&gt; ① 当使用addEventListener绑定事件，第三个参数传为true时表示事件捕获；&lt;/span&gt;&lt;br/&gt;&lt;span&gt; ② 除此之外的所有事件绑定均为事件冒泡。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4. 阻止事件冒泡：&lt;/span&gt;&lt;br/&gt;&lt;span&gt; ① IE10之前，e.cancelBubble = true;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; ② IE10之后，e.stopPropagation();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5. 阻止默认事件：&lt;/span&gt;&lt;br/&gt;&lt;span&gt; ① IE10之前：e.returnValue = false;&lt;/span&gt;&lt;br/&gt;&lt;span&gt; ② IE10之后：e.preventDefault();&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;css&lt;/span&gt;
&lt;span&gt;#div1{
    width: 300px;;
    height: 300px;
    background&lt;/span&gt;-&lt;span&gt;color: powderblue;
}
#div2{
    width: 200px;
    height: 200px;
    background&lt;/span&gt;-&lt;span&gt;color: deeppink;
}
#div3{
    width: 100px;
    height: 100px;
    background&lt;/span&gt;-&lt;span&gt;color:#A9A9A9;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;
&amp;lt;div id=&quot;div1&quot;&amp;gt;
    &amp;lt;div id=&quot;div2&quot;&amp;gt;
        &amp;lt;div id=&quot;div3&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;a href=&quot;01-事件笔记.html&quot; onclick=&quot;func()&quot;&amp;gt;超链接&amp;lt;/a&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
div1.addEventListener(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;div1 click&quot;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
div2.addEventListener(&lt;/span&gt;&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;div2 click&quot;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
div3.addEventListener(&lt;/span&gt;&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;(){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;原来的顺序是：3--&amp;gt;2--&amp;gt;1。&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;    myParagraphEventHandler(); //截获事件流后，只触发3.但是从2开始依然会冒泡；&lt;/span&gt;
    console.log(&quot;div3 click&quot;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结果（事件冒泡）（由小到大div3-》div2-》div1）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1360028/201805/1360028-20180512235309218-1738610529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
div1.addEventListener(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;div1 click&quot;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
div2.addEventListener(&lt;/span&gt;&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;div2 click&quot;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
div3.addEventListener(&lt;/span&gt;&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){ 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    myParagraphEventHandler(); //截获事件流后，只触发3.但是从2开始依然会冒泡；&lt;/span&gt;
    console.log(&quot;div3 click&quot;&lt;span&gt;);
},&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结果(事件捕获)（由小到大div3-》div2-》div1）：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1360028/201805/1360028-20180512235554906-1371715930.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;依然遵循事件冒泡&lt;/span&gt;
document.onclick=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;&quot;document click&quot;&lt;span&gt;)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;截获事件流阻止事件冒泡&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; myParagraphEventHandler(e) {
     e &lt;/span&gt;= e ||&lt;span&gt; window.event;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (e.stopPropagation) {
         e.stopPropagation(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IE10以后 &lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
         e.cancelBubble &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IE10之前&lt;/span&gt;
&lt;span&gt;     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;截获事件流阻止事件冒泡&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; myParagraphEventHandler(e) {
     e &lt;/span&gt;= e ||&lt;span&gt; window.event;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (e.stopPropagation) {
         e.stopPropagation(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IE10以后 &lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
         e.cancelBubble &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IE10之前&lt;/span&gt;
&lt;span&gt;     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻止默认事件&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; eventHandler(e) {
    e &lt;/span&gt;= e ||&lt;span&gt; window.event;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 防止默认行为 &lt;/span&gt;
     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (e.preventDefault) {
         e.preventDefault(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;IE10之后&lt;/span&gt;
    } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
         e.returnValue &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IE10之前    &lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 12 May 2018 16:04:00 +0000</pubDate>
<dc:creator>小白坤</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gcywj/p/9030668.html</dc:identifier>
</item>
<item>
<title>OpenApi开放平台架构实践 - 戎&quot;码&quot;一生</title>
<link>http://www.cnblogs.com/lucky_hu/p/9030667.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lucky_hu/p/9030667.html</guid>
<description>&lt;p&gt;随着业务的发展,越来越多不同系统之间需要数据往来,我们和外部系统之间产生了数据接口的对接。当然,有我们提供给外部系统(工具)的,也&lt;span&gt;有我们调用第三方的。而这里重点讲一下我们对外的接口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;   &lt;span&gt;目前,我们运营和维护着诸多的对外接口,很多现有的接口服务寄宿在各个不同的项目,哪些应用在使用api也没有管理起来。并且以前的调用模式也是比较复杂,排错困难。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目前已经对外提供服务的有短信平台,审核中心,ETCP,官网系列(充值,登陆,注册),服务中心,AuterCenter,HomeAPI(即将上线)。同时内部还有工单系统,安全中心,基础服务,GEMC等。其他的还有一些内部工具服务。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从目前的需求上看,我们对外提供接口的需求很大。当然,能够持续对外提供服务是好事。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是,对接标准不统一,服务寄宿不合理, 无文档,无测试报告,无demo,无接口变更记录都将导致api的可持续和可维护变得越来越难。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们将更多的考虑对外服务的安全性,高可靠性,可维护性,尤其是离产品和用户最近的那些API。 同时,尽量做到所有api及其调用关系都有数据可查。因此,对于新接入的API,提供专业、规范的设计标准和文档规范势在必行。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让所有支撑服务化,所有服务标准化。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OPenAPI将作为支撑的中间件,与其他系统服务一起为运维、安全、产品和运营的各种需求提供强有力支撑。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 12 May 2018 16:03:00 +0000</pubDate>
<dc:creator>戎&amp;quot;码&amp;quot;一生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lucky_hu/p/9030667.html</dc:identifier>
</item>
<item>
<title>JavaScript定时器 - 岁影如风</title>
<link>http://www.cnblogs.com/nie5135257/p/9030652.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nie5135257/p/9030652.html</guid>
<description>&lt;div id=&quot;cnblogs_title&quot; readability=&quot;26.666666666667&quot;&gt;      JavaScript定时器&lt;span&gt;&lt;a&gt;恢复&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;div id=&quot;cnblogs_message&quot; readability=&quot;89.5&quot;&gt;
&lt;p&gt;      Windows对象包含了4个定时器方法，说明如下表所示：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;caption&gt;Windows对象定时器方法列表&lt;/caption&gt;
&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;方法&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;setTimeout()&lt;/td&gt;
&lt;td&gt;在指定的毫秒数后调用函数或计算表达式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;setInterval()&lt;/td&gt;
&lt;td&gt;按照在指定的周期（以毫秒计）来调用函数或计算表达式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;clearTimeout()&lt;/td&gt;
&lt;td&gt;取消setTimeout()方法生成的定时器对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;clearInterval()&lt;/td&gt;
&lt;td&gt;取消setInterval()方法生成的定时器对象&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;      &lt;strong&gt;1. setTimeout()方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;           setTimeout()方法在指定的时间段后执行的代码。其中拥有两个参数值，分别是code和delay，其中参数code表示要延迟执行的代码，可以包含多个语句，语句之间要用分号进行分隔，delay表示要延迟的时间，以毫秒为单位计时。&lt;/p&gt;
&lt;p&gt;          &lt;strong&gt;示例&lt;/strong&gt;：当鼠标经过段落文本时时显示 “段落文本”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
          &lt;span&gt;var&lt;/span&gt; p=document.getElementsByTagName(&quot;p&quot;)[0&lt;span&gt;];
          p.onmouseover&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
              setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                  alert(“段落文本”);
              },&lt;/span&gt;1000&lt;span&gt;);
          }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;        也可将JavaScript代码封装在函数体内，然后引用函数作为参数传递给setTimeout()方法，这样就可以避免了传递代码众多而造成不必要的麻烦。&lt;/p&gt;
&lt;p&gt;        &lt;strong&gt;示例&lt;/strong&gt;：如何为集合中每一个元素绑定延迟事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
         &lt;span&gt;var&lt;/span&gt; o=document.getElementsByTagName(&quot;body&quot;)[0].childNodes;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取body元素下所用子元素&lt;/span&gt;
         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;o.length;i++&lt;span&gt;){
             o[i].onmouseover&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i){
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                     f(o[i]);   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将js代码封装在一个函数体中作为参数传给setTimeout&lt;/span&gt;
&lt;span&gt;                 }
             }(i);
         }
         &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f(o){
             &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; out=setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                 alert(o.tagName)
             },&lt;/span&gt;500&lt;span&gt;);
         }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;                这样就可以当鼠标经过body元素下的子元素时，延迟半秒后弹出该元素的名称。&lt;/p&gt;

&lt;p&gt;     &lt;strong&gt;  2. clearTimeout()方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;               clearTimeout()方法表示在特定的情况下清除要延迟的代码，这样就可以避免了函数之间的互相干扰。&lt;/p&gt;
&lt;p&gt;               列如：当鼠标停留在某个元素时，半秒后才会弹出提示信息，一旦鼠标提前离开该元素，就立即清除前面定义的延迟处理事件函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
         &lt;span&gt;var&lt;/span&gt; o=document.getElementsByTagName(&quot;body&quot;)[0&lt;span&gt;].childNodes;
         &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;o.length;i++&lt;span&gt;){
             o[i].onmouseover&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i){
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                     f(o[i]);   
                 }
             }(i);
             o[i].onmouseout&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(i){
                 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                     clearTimeout(o[i].out);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清除延迟处理的函数&lt;/span&gt;
&lt;span&gt;                 }
             }(i);
         }
         &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f(o){
             o.out&lt;/span&gt;=setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                 alert(o.tagName)
             },&lt;/span&gt;500&lt;span&gt;);
         }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;                 也可以这这样使用clearTimeout()方法：&lt;/p&gt;
&lt;p&gt;                 &lt;strong&gt;示例&lt;/strong&gt;：在文本框中按秒针速度显示递增的数字，当循环10次后调用clearTimeout()方法清除对延迟代码的执行，并弹出提示信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
         &amp;lt;body&amp;gt;
         &amp;lt;input type=&quot;text&quot; /&amp;gt;
         &amp;lt;/body&amp;gt;
         &amp;lt;script&amp;gt;    
         &lt;span&gt;var&lt;/span&gt; t=document.getElementsByTagName(&quot;input&quot;)[0&lt;span&gt;];
         &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; i=1&lt;span&gt;;
         &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f(){
             &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; out=&lt;span&gt;setTimeout(
                 &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
                     t.value&lt;/span&gt;=i++&lt;span&gt;;
                     f();
                 },&lt;/span&gt;1000&lt;span&gt;);
                 &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i&amp;gt;10&lt;span&gt;){
                     clearTimeout(out);
                     alert(&lt;/span&gt;&quot;时间到&quot;&lt;span&gt;);
                 }
         }   
         f();
         &lt;/span&gt;&amp;lt;/script&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;           &lt;strong&gt;3. setInterval()方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;              setInterval()方法的用法和setTimeout()方法的用法基本相同，其中参数为code和interval，只是参数code表示要周期性执行的代码，参数interva表示周期的时间间隔，也是以毫秒为单位。&lt;/p&gt;
&lt;p&gt;              如上的示例：在文本框中按秒针速度显示递增的数字，当循环10次后调用clearTimeout()方法清除对延迟代码的执行，并弹出提示信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;setInterval()用法和setTimeout()用法相同，只是code改为了周期性，即每个多久执行一次代码&lt;/span&gt;
         &lt;span&gt;var&lt;/span&gt; t=document.getElementsByTagName(&quot;input&quot;)[0&lt;span&gt;];
         &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; i=1&lt;span&gt;;
         &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; out=setInterval(f,1000)；&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义周期性执行的函数&lt;/span&gt;
         &lt;span&gt;function&lt;/span&gt;&lt;span&gt; f(){
             t.value&lt;/span&gt;=i++&lt;span&gt;;
         　　　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i&amp;gt;10&lt;span&gt;){
             　　clearTimeout(out);
             　　alert(&lt;/span&gt;&quot;时间到&quot;&lt;span&gt;);
             }
         }   &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;            我的第一篇博客，还望大神们多多指教。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 12 May 2018 15:59:00 +0000</pubDate>
<dc:creator>岁影如风</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nie5135257/p/9030652.html</dc:identifier>
</item>
<item>
<title>如何利用Python网络爬虫爬取微信朋友圈动态--附代码（下） - dcpeng</title>
<link>http://www.cnblogs.com/dcpeng/p/9030622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dcpeng/p/9030622.html</guid>
<description>


&lt;p&gt;前天给大家分享了&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.toutiao.com/i6553461873956618766/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;如何利用Python网络爬虫爬取微信朋友圈数据的上篇（理论篇）&lt;/a&gt;，今天给大家分享一下代码实现（实战篇），接着上篇往下继续深入。&lt;/p&gt;
&lt;p&gt;一、代码实现&lt;/p&gt;
&lt;p&gt;1、修改Scrapy项目中的items.py文件。我们需要获取的数据是朋友圈和发布日期，因此在这里定义好日期和动态两个属性，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-157f53a60f11ae3e0f7689daf564369a_hd.jpg&quot; alt=&quot;&quot; width=&quot;554&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;286&quot; data-original=&quot;https://pic3.zhimg.com/v2-157f53a60f11ae3e0f7689daf564369a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-157f53a60f11ae3e0f7689daf564369a_b.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、修改实现爬虫逻辑的主文件moment.py，首先要导入模块，尤其是要主要将items.py中的WeixinMomentItem类导入进来，这点要特别小心别被遗漏了。之后修改start_requests方法，具体的代码实现如下图。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-11ce628ff19429416cce6c5c846452d0_hd.jpg&quot; alt=&quot;&quot; width=&quot;554&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;330&quot; data-original=&quot;https://pic2.zhimg.com/v2-11ce628ff19429416cce6c5c846452d0_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-11ce628ff19429416cce6c5c846452d0_b.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、修改parse方法，对导航数据包进行解析，代码实现稍微复杂一些，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-f1b5d3ce12f7980e939f0ff61b173433_hd.jpg&quot; alt=&quot;&quot; width=&quot;554&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;372&quot; data-original=&quot;https://pic4.zhimg.com/v2-f1b5d3ce12f7980e939f0ff61b173433_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-f1b5d3ce12f7980e939f0ff61b173433_b.jpg&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;l需要注意的是从网页中获取的response是bytes类型，需要显示的转为str类型才可以进行解析，否则会报错。&lt;/li&gt;
&lt;li&gt;l在POST请求的限定下，需要构造参数，需要特别注意的是参数中的年、月和索引都需要是字符串类型的，否则服务器会返回400状态码，表示请求参数错误，导致程序运行的时候报错。&lt;/li&gt;
&lt;li&gt;l在请求参数还需要加入请求头，尤其是Referer（反盗链）务必要加上，否则在重定向的时候找不到网页入口，导致报错。&lt;/li&gt;
&lt;li&gt;l上述的代码构造方式并不是唯一的写法，也可以是其他的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4、定义parse_moment函数，来抽取朋友圈数据，返回的数据以JSON加载的，用JSON去提取数据，具体的代码实现如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-1965271922c882037b6d16baad443a32_hd.jpg&quot; alt=&quot;&quot; width=&quot;554&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;256&quot; data-original=&quot;https://pic3.zhimg.com/v2-1965271922c882037b6d16baad443a32_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1965271922c882037b6d16baad443a32_b.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;5、在setting.py文件中将ITEM_PIPELINES取消注释，表示数据通过该管道进行处理。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-0b160d6492df67fc1de7134f98b040ac_hd.jpg&quot; alt=&quot;&quot; width=&quot;554&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;226&quot; data-original=&quot;https://pic3.zhimg.com/v2-0b160d6492df67fc1de7134f98b040ac_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0b160d6492df67fc1de7134f98b040ac_b.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;6、之后就可以在命令行中进行程序运行了，在命令行中输入scrapy crawl moment -o moment.json，之后可以得到朋友圈的数据，在控制台上输出的信息如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-c06e1a151b78263e02514273d22fbc42_hd.jpg&quot; alt=&quot;&quot; width=&quot;554&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;337&quot; data-original=&quot;https://pic3.zhimg.com/v2-c06e1a151b78263e02514273d22fbc42_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-c06e1a151b78263e02514273d22fbc42_b.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;7、尔后我们得到一个moment.json文件，里面存储的是我们朋友圈数据，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic3.zhimg.com/80/v2-618a3a82ab7566a2ba75deae950cb8b1_hd.jpg&quot; alt=&quot;&quot; width=&quot;554&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;135&quot; data-original=&quot;https://pic3.zhimg.com/v2-618a3a82ab7566a2ba75deae950cb8b1_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-618a3a82ab7566a2ba75deae950cb8b1_b.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;8、嗯，你确实没有看错，里边得到的数据确实让人看不懂，但是这个并不是乱码，而是编码的问题。解决这个问题的方式是将原来的moment.json文件删除，之后重新在命令行中输入下面的命令：scrapy crawl moment -o moment.json -s FEED_EXPORT_ENCODING=utf-8，此时可以看到编码问题已经解决了，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic4.zhimg.com/80/v2-83367d5ad769883c764a367d25635183_hd.jpg&quot; alt=&quot;&quot; width=&quot;554&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;554&quot; data-rawheight=&quot;151&quot; data-original=&quot;https://pic4.zhimg.com/v2-83367d5ad769883c764a367d25635183_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-83367d5ad769883c764a367d25635183_b.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下一篇文章，小编带大家将抓取到的朋友圈数据进行可视化展示，敬请关注~~&lt;/p&gt;
</description>
<pubDate>Sat, 12 May 2018 15:44:00 +0000</pubDate>
<dc:creator>dcpeng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dcpeng/p/9030622.html</dc:identifier>
</item>
<item>
<title>虚拟机配置Openstack常见问题汇总 - Skylar_Zhan</title>
<link>http://www.cnblogs.com/skylarzhan/p/9030600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skylarzhan/p/9030600.html</guid>
<description>&lt;p&gt;&lt;span&gt;之前配置了openstack，遇到一些问题，现在将问题全部汇总记录在这里。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）问题：主机名字修改不了；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因：没有进入root状态；或者没有正确打开文件，要打开的是/etc/hostname，结果忘记一个斜杠，直接/etc/hostname&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方案：1、进入root状态 ，使用命令行sudo su 后面输入密码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     　　　  2、检查输入文件名字是否正确&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）问题：输入信息不进去&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因：可能是linux的操作键盘个windows不一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方法：将光标移动到要输入的位置，然后按键盘 i ，然后进行输入，删除直接用delete键，&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;（3）问题：修改文件保存不了&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因：没有进入root状态，所以没有权限保存；未使用英文字符，导致保存命令无效&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方案：1、进入root状态 ，使用命令行sudo su 后面输入密码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、在vi 打开的情况下，使用esc+:wq!保存；如果使用gedit 打开文件，可以直接ctrl+x保存，但是要建立在管理员权限在才有效（gedit 命令适用于desktop版本）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;（4）问题：配置主机网络环境错误：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因：没有查看本身自带的ifconfig，直接参照视频教程做&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方案：1、ifconfig ，然后查看到address IP地址，然后修改最后一个为基准，对IP地址进行修改，比如我的是192.168.17.129开始，逐渐递增130，131，132，133。网关要查看一下，使用nm-tool。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、如果参照视频教程，相应的也要把虚拟机的网络配置器修改为你所配置的网络IP Address&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;（5）问题：openstack no command&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    原因：没有openstack 这个命令&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方案：下载安装openstackclient ,也就是openstack的包，同时要记得加载source-openrc.sh&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;（6）问题：ping 不通虚拟机&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因1、检查物理链路是否正常，网线，交换机是否正常 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、网卡的状态是否为UP  (ip addr)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、查看配置是否IP地址是否正确&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、检查虚拟机是否重启，IP地址是否更改为设置的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方案：1、物理链路问题的话就要去虚拟机的网络编辑器设值好相应的IP地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、网卡状态显示为down ，即没有开启网卡，尝试开启；显示为unknown即为在配置主机网络环境时网络不稳定，由于网络自动分配，导致后期找不到，这种情况可能就要重装。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、ifconfig，核对好自己本机的IP地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、配置好网络环境后要重启一下reboot，可能就成功了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;（7）问题：创建云硬盘失败 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因：Ntp问题，各个节点时间不同步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方案：下载安装NTP或者chrony&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;(8)问题：出现错误但是找不到出错地方&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因：可能遗漏某步骤或者在配置过程中不小心删除重要文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方案：每完成一个点尽量拍摄一个快照，这样子一旦出现配置错误，可以直接返回原先稳定状态。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;(9)问题：消息队列启动失败&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因：1、/etc/hosts中IP是否正确，检查installrc和lib/hosts中IP是否正确 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方案：1、检查/etc/hosts中IP是否正确 ，采用脚本安装还需检查installrc和lib/hosts中IP是否正确 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;(10)问题：数据库启动失败 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原因：监听IP是否正确，如果采用脚本安装还需检查installrc和lib/hosts中IP是否正确 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;解决方案： 如都没问题，手动卸载数据库，并删除库文件rm -rf /var/lib/mysql/再次安装 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;(11)问题：执行source admin-openrc.sh后执行命令报错 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   原因：环境中有代理，或者其他环境变量干扰。此问题也和开发人员编程习    惯有关，在写代码是从不喜欢写绝对路径，环境中执行了该程序导致。出现问题是无从查起。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决解决方案： 重启物理机、或者将admin-openrc.sh内容拷贝出来在命令行中执行一遍&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;（12）错误内容：Therequest you have made requires authentication. (HTTP 401)&lt;/strong&gt; (Request-ID:req-70bb9d8c-a1ba-47e3-8dc4-ef2e63e269f4)&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;原因：401是未授权导致。密码或账号错误。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;解决方案：填写创建用户时的密码。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;（13）错误内容：数据库同步错误，&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;原因：一般原因是connection参数不对，或者密码错误，格式不对等。数据库未关闭时，往往会造成错误。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;解决方案：重启数据库。检查connection的参数 &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;（14）错误内容：云主机 &quot;two&quot; 执行所请求操作失败，云主机处于错误状态。&lt;/strong&gt;: 请稍后再试 [错误: No valid host was found. Thereare not enough hosts available.].&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;原因：多半是计算节点down，或者是计算节点上的资源不够用了&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;解决方案：查看计算节点资源，查看计算节点是否启动：openstack compute service list novaservice-list&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;（15）错误内容：Fail toconnect vnc&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;原因：VNC配置错误，连接实例的ip地址不对（一般是因为控制节点两块网卡，而写入的IP地址不可用于通信）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;解决方案：重启实例，修改VNC配置，换控制节点另一块网卡的IP地&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;（16）错误内容：路由删除不掉&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;原因：多半是还有浮动IP在用的原因&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;解决方案：删掉浮动IP&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;（17）错误内容：Dashboard登陆不上去，报错Unauthorization&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;原因一： 在/etc/keystone/keystone-paste.ini 中的 [pipeline:public_api], [pipeline:admin_api], and [pipeline:api_v3] 三个选项中未移除 admin_token_auth。这是临时授权，未移除会被警告。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;原因二：Dashboard配置文件 /etc/openstack-dashboard/local_settings.py。其中注意几点：时区可能未配置好，API版本不对&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;解决方案：1、在/etc/keystone/keystone-paste.ini 中，移除admin_token_auth；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;2、时区如果不知道最好不要选；  OPENSTACK_KEYSTONE_URL = &quot;http://%s:5000/v3&quot; %OPENSTACK_HOST 中的V3 一定要改成V3&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;（18）错误内容：’module’ object has no attribute ‘SSL_ST_INIT’&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;原因：模块对象没有属性的ssl_st_init”&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;解决方案：pip uninstall pyopenssl&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;　　　　   pip install pyopenssL&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;配置Openstack的话，可以直接参照官网上的内容直接配置。一开始写着是需要三台虚拟机，但是后期实际在配置过程中，基本是compute节点跟controller节点上配置就可以了。配置openstack的话要求运行内存，存储容量都要足够，这样子才能保证后期都能完整进行。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;在前文提到过配置openstack有server版跟destop版；如果用server版要用secureCRT才能复制粘贴，这样子可以提高效率。用desktop版可以gedit打开文本编辑器，还可以查找，更快捷。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Sat, 12 May 2018 15:34:00 +0000</pubDate>
<dc:creator>Skylar_Zhan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skylarzhan/p/9030600.html</dc:identifier>
</item>
<item>
<title>[备忘] 数学小定理相关 - YoungNeal</title>
<link>http://www.cnblogs.com/YoungNeal/p/9030575.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YoungNeal/p/9030575.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;由于上一篇&lt;a href=&quot;http://www.cnblogs.com/YoungNeal/p/8908187.html&quot;&gt;数学相关&lt;/a&gt;分版块记录定理及证明，对于小定理等略有繁琐，故新开一篇博客记录一些数学小芝士，以此备忘。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;关于质因子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(1-2\times 10^9\)&lt;/span&gt; 中任何数的不同质因子都不会超过 &lt;span class=&quot;math inline&quot;&gt;\(10\)&lt;/span&gt; 个，且所有质因子的指数总和不超过 &lt;span class=&quot;math inline&quot;&gt;\(30\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;证明：因为最小的 &lt;span class=&quot;math inline&quot;&gt;\(11\)&lt;/span&gt; &lt;span class=&quot;math inline&quot;&gt;\(2\times 3\times 5\times 7\times 11\times 13\times 17\times 19\times 23\times 29\times 31&amp;gt;2\times 10^9\)&lt;/span&gt;，所以 &lt;span class=&quot;math inline&quot;&gt;\(N\leq 2\times 10^9\)&lt;/span&gt; 不可能有多于 &lt;span class=&quot;math inline&quot;&gt;\(10\)&lt;/span&gt; 个不同质因子。&lt;br/&gt;因为即使只包含最小的质数，仍然有 &lt;span class=&quot;math inline&quot;&gt;\(2^{31}&amp;gt;2\times 10^9\)&lt;/span&gt; ，所以 &lt;span class=&quot;math inline&quot;&gt;\(N\leq 2\times 10^9\)&lt;/span&gt; 的质因子质数总和不会超过 &lt;span class=&quot;math inline&quot;&gt;\(30\)&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;欧拉函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\sum _{d\mid n}\phi(d)=n\]&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;欧拉定理可推&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[gcd(a,n)=1\Rightarrow a^{\phi(n)}\equiv 1\quad (mod\;n)\Rightarrow a^b\equiv a^{b\;mod\;\phi(n)}\quad (mod\;n)\]&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;小引理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(gcd(a,n)=1\)&lt;/span&gt;，则满足 &lt;span class=&quot;math inline&quot;&gt;\(a^x\equiv 1\quad (mod\;n)\)&lt;/span&gt; 的最小正整数 &lt;span class=&quot;math inline&quot;&gt;\(x_0\)&lt;/span&gt; 是 &lt;span class=&quot;math inline&quot;&gt;\(\phi(n)\)&lt;/span&gt; 的约数。&lt;/p&gt;
</description>
<pubDate>Sat, 12 May 2018 15:25:00 +0000</pubDate>
<dc:creator>YoungNeal</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YoungNeal/p/9030575.html</dc:identifier>
</item>
<item>
<title>非正则表达式检验邮箱格式是否合法（Java代码实现） - 三号小学生</title>
<link>http://www.cnblogs.com/zjf1665119803/p/9030537.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjf1665119803/p/9030537.html</guid>
<description>&lt;h2&gt;一、邮箱格式需满足以下要求&lt;/h2&gt;
&lt;p&gt;                        1. 有且只有一个@&lt;br/&gt;                        2. @不能放在开头，也不能放在结尾&lt;br/&gt;                        3. @之后必须有.&lt;br/&gt;                        4. @之前或之后不能紧跟.&lt;br/&gt;                        5. @之前要有6个字符&lt;br/&gt;                        6. 以com、org、cn、net结尾&lt;/p&gt;
&lt;h2&gt;二、代码实现&lt;/h2&gt;
&lt;h3&gt;1. 实现代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; homework3;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;邮箱检验是否合格&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CheckEmail {

     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmail(String email) {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否为空邮箱&lt;/span&gt;
         &lt;span&gt;int&lt;/span&gt; k = 0&lt;span&gt;;
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(email == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
             &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
         }
         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
          * 单引号引的数据 是char类型的 
                                    双引号引的数据 是String类型的 
                                    单引号只能引一个字符 
                                    而双引号可以引0个及其以上*
          &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否有仅有一个@且不能在开头或结尾&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt;(email.indexOf(&quot;@&quot;) &amp;gt; 0 &amp;amp;&amp;amp; email.indexOf('@') == email.lastIndexOf('@') &amp;amp;&amp;amp; email.indexOf('@') &amp;lt; email.length()-1&lt;span&gt;) {
             k&lt;/span&gt;++&lt;span&gt;;
         }
         
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断&quot;@&quot;之后必须有&quot;.&quot;且不能紧跟&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt;(email.indexOf('.',email.indexOf('@')) &amp;gt; email.indexOf('@')+1&lt;span&gt; ) {
             k&lt;/span&gt;++&lt;span&gt;;
         }
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断&quot;@&quot;之前或之后不能紧跟&quot;.&quot;&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt;(email.indexOf('.') &amp;lt; email.indexOf('@')-1 || email.indexOf('.') &amp;gt; email.indexOf('@')+1&lt;span&gt; ) {
             k&lt;/span&gt;++&lt;span&gt;;
         }
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;@之前要有6个字符&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt;(email.indexOf('@') &amp;gt; 5&lt;span&gt; ) {
             k&lt;/span&gt;++&lt;span&gt;;
         }
         
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(email.endsWith(&quot;com&quot;) || email.endsWith(&quot;org&quot;) || email.endsWith(&quot;cn&quot;) ||email.endsWith(&quot;net&quot;&lt;span&gt;)) {
             k&lt;/span&gt;++&lt;span&gt;;
         }
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(k == 5&lt;span&gt;) {
             &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
         }
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
         
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2. 测试代码&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; homework3;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Scanner;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EmailTest {
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
        { Scanner sc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);   
         System.out.println(&lt;/span&gt;&quot;请输入你的邮箱:&quot;&lt;span&gt;);   
         String str &lt;/span&gt;= sc.nextLine();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取字符串型输入   &lt;/span&gt;
         CheckEmail email = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CheckEmail();
         &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; result =&lt;span&gt; email.isEmail(str);
         &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(result) {
             System.out.println(&lt;/span&gt;&quot;邮箱地址合法&quot;&lt;span&gt;);
         }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
             System.out.println(&lt;/span&gt;&quot;邮箱地址不合法&quot;&lt;span&gt;);
         }
         System.out.println(&lt;/span&gt;&quot;  &quot;&lt;span&gt;);
    }
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3. 测试结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1381587/201805/1381587-20180512231620862-4272911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;三、总结&lt;/h2&gt;
&lt;p&gt;        这是我在博客园上的第一篇文章，没有啥技术含量，但是却见证着我的学习与成长。&lt;br/&gt;        本人Java小白一枚，正在努力追赶，希望有志同道合的小伙伴可以共勉，一起努力学习，一起进步。&lt;/p&gt;
</description>
<pubDate>Sat, 12 May 2018 15:18:00 +0000</pubDate>
<dc:creator>三号小学生</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjf1665119803/p/9030537.html</dc:identifier>
</item>
</channel>
</rss>