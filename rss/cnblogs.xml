<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>第25天面向对象编程详解之继承 - 沉沦的罚</title>
<link>http://www.cnblogs.com/huwentao/p/9836359.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huwentao/p/9836359.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;面向对象补充知识&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;面向对象概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;面向对象核心二字在与对象，对象就是特征和技能的结合体，基于该思想编程就好比在创建一个世界，世界上的任何事物都是对象，你就好比是这个世界的上帝，这是一种基于上帝式的思维方式。
优点：扩展性强
缺点：编程的复杂度要远远高于面向过程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;问题一：&lt;/span&gt;&lt;/strong&gt;既然面向对象这么好，我们之后的编程是不是都要用面向对象呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　不是的，衡量一个软件的标准除了扩展性之外，其实还有很多的方面，如性能，可维护性，可移植性等等，但是面向对象编程设计之初就是为了解决扩展性的，所以在其他的一些软件质量的考核上面并没有想象中的那么好，因此，如果我们的软件从一写出来&lt;br/&gt;很长时间都不会再去改动的话，用面向对象编程就不太合适了。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;类的概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
对象是特征和技能的结合体，类就是一系列对象相同特征和技能的结合体。&lt;br/&gt;现实生活中&lt;br/&gt;　　先有对象，随着人类文明的发展总结出了类。&lt;br/&gt;代码世界中&lt;br/&gt;　　我们需要先定义类，然后才能通过类去创建对象。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;类的创建过程:&lt;/span&gt;&lt;/strong&gt; 创建一个老男孩选课系统&lt;/p&gt;
&lt;p&gt;现实世界的分析：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;步骤一：&lt;/strong&gt;&lt;/span&gt;要从需求中分析出对象的特征和技能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;分析对象的特征与技能是要根据特定的环境下进行分析的，因为我们分析的特征与技能是希望之后可以使用的，而不是说只是用来看看而已的。

例如：下面分析的一个对象特征也没错，但是就是没有结合特定的环境下分析的特征与技能，在选课系统中，对于特征，我们需要的是一个人的信息，便于之后查询，如名字，年龄，性别等等，但是对于外貌的特征我们是不需要的。对与技能，我们需要的是对象是如何选课的，而不是它是怎么吃饭和怎么喝水的。因此在分析需求的时候一定要根据特定的环境来分析对象的特征和技能。

老男孩选课系统分析
对象1：
    特征
        两个耳朵
        一个眼睛
    技能
        吃
        喝&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_321ac934-aa56-47ca-b040-2e262f6dcecf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_321ac934-aa56-47ca-b040-2e262f6dcecf&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_321ac934-aa56-47ca-b040-2e262f6dcecf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;老男孩选课系统分析
学生类
对象1：
    特征
        学校 school &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Oldboy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        姓名 name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;张铁蛋&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        性别 gender &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        年龄 age &lt;/span&gt;= 12&lt;span&gt;
    技能
        选课
对象2：
    特征
        学校 school &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Oldboy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        姓名 name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;王铁锤&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        性别 gender &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        年龄 age &lt;/span&gt;= 10&lt;span&gt;
    技能
        选课
教师类
对象3：
    特征
        学校 school &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Oldboy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        姓名 name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        性别 gender &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        年龄 age &lt;/span&gt;= 18&lt;span&gt;
        级别 level &lt;/span&gt;= 10&lt;span&gt;
        薪资 salary &lt;/span&gt;= 100000&lt;span&gt;
    技能
        修改分数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;属性的分析&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;步骤二：&lt;/strong&gt;&lt;/span&gt;寻找相似的特征和技能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;学生类：
相似的特征
    学校 school &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Oldboy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
相似的技能
    选课&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码世界的分析：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;步骤三：&lt;/strong&gt;&lt;/span&gt;根据相似的特征和技能定义类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
当我们寻找出相似的特征与技能之后我们就可以根据现实世界中的类别来通过class关键字创建自己的类
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据我们现实世界中分析出来的伪代码来定义我们的类&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;学生类：&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyStudent:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相似的特征&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 学校  school = 'Oldboy'&lt;/span&gt;
    school = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Oldboy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相似的技能&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选课&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; choose_course(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;choose_course&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;步骤四：&lt;/strong&gt;&lt;/span&gt;根据类创建对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个学生对象&lt;/span&gt;
stu1 = OldBoyStudent()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;虽然还有很多的细节没有实现，当对象创建完成之后就代表着我们已经成功的把现实中的内容迁移到了我们代码世界中。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;类的用途&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;用途一：
    类本质上就是一个命名空间，我们可以对该名称空间进行增删改查
用途二：
    调用类产生对象，执行了两个步骤
    &lt;/span&gt;1&lt;span&gt;. 产生一个空对象obj
    &lt;/span&gt;2. 触发类中__init__方法，OldBoyStudent.&lt;span&gt;__init__&lt;/span&gt;(obj)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;用途一：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;名称空间就是名字和空间地址的一一映射关系，在python中我们可以使用自动触发函数__dict__去查看当前对象的命名空间中都有哪些名字，说到这里，可能你就会意识到，既然名称空间的存储是一个字典，那么对于这个字典的增删改查是不是就是对名称空间的增删改查呢，没错，就是这样的。
&lt;br/&gt;例如对于上面的例子,我们要查看类中的名称空间
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;学生类：&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyStudent:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相似的特征&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 学校  school = 'Oldboy'&lt;/span&gt;
    school = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Oldboy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相似的技能&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选课&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; choose_course(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;choose_course&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个学生对象&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 查看的两种方法&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(OldBoyStudent.&lt;span&gt;__dict__&lt;/span&gt;[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;school&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(OldBoyStudent.school)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 增加就是在__dict__中添加一对键值对&lt;/span&gt;
OldBoyStudent.name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; OldBoyStudent.__dict__['name']  = 'egon'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;用途二&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对象的创建&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
在我们上面的例子中发现，类中只有一个属性school和一个方法choose_course，那么对于一个对象而言它的名字，年龄，和性别就需要我们每次创建完成之后重新去定义它的属性。
&lt;/pre&gt;
&lt;pre readability=&quot;7&quot;&gt;
# 创建学生对象，并且添加属性&lt;br/&gt;stu1 = OldBoyStudent()&lt;br/&gt;stu1.name = 'egon'&lt;br/&gt;stu1.age = 18&lt;br/&gt;stu1.gender = 'male'&lt;p&gt;当我需要再创建一个对象的时候，还需要重新去定义这个属性，这太麻烦了，因此，python帮我们封装了一个函数__init__函数，我们可以在创建的时候直接通过传递属性参数进行赋值就可以了
&lt;/p&gt;&lt;/pre&gt;
&lt;pre readability=&quot;9&quot;&gt;
class OldBoyStudent:&lt;br/&gt;school = 'Oldboy'&lt;br/&gt;def __init__(self, name, age, gender):&lt;br/&gt;self.name=name&lt;br/&gt;self.age=age&lt;br/&gt;self.gender=gender &lt;p&gt;def choose_course(self):&lt;br/&gt;print('choose_course')&lt;/p&gt;&lt;p&gt;# 创建学生对象，并且添加属性&lt;br/&gt;stu1 = OldBoyStudent('egon', 11, 'male')
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;理解：面向对象是更高程度的一种封装&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题一：&lt;/strong&gt;&lt;/span&gt;当我们有很多此调用这个函数的时候，我们都需要去传递这样的一组数据，很麻烦&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; exec1(address, port, db, charset, sql):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(address, port, db, charset, sql)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当我们有很多此调用这个函数的时候，我们都需要去传递这样的一组数据，很麻烦&lt;/span&gt;
exec1(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3306, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
exec1(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3306, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
exec1(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3306, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
exec1(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3306, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决方法一：&lt;/strong&gt;&lt;/span&gt;将函数exec1的参数设置成默认参数，这样的话虽然解决了上面存在的问题，但是如果一旦出现另一组数据的话一样是这样的情况，并没有太大的进步。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; exec1(address=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, port=3306, db=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, charset=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, sql=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(address, port, db, charset, sql)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 虽然说对于第一种的调用我们简化了很多，但是一旦出现另一组数据和之前一样比较麻烦&lt;/span&gt;
&lt;span&gt;exec1()
exec1()
exec1()
exec1()
exec1(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3307, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
exec1(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3307, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
exec1(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3307, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
exec1(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3307, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决方法二&lt;/strong&gt;&lt;/span&gt;：将数据定义成变量，通过变量进行传递参数，虽然说稍微简单了一点点，但是当出现两组或者几组数据的时候将会变的非常混乱，不仅如此，数据的耦合性非常强。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; exec1(address, port, db, charset, sql):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(address, port, db, charset, sql)

HOST&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
PORT&lt;/span&gt;=3306&lt;span&gt;
DB&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
CHARSET&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
SQL&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这样比之前直接传入数据会稍微简单一点，但是对于定义的一些变量，我们并不需要它可以被其他的程序所使用&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 因此，我们需要把变量和函数绑定起来&lt;/span&gt;
&lt;span&gt;exec1(HOST, PORT, DB, CHARSET, SQL)
exec1(HOST, PORT, DB, CHARSET, SQL)
exec1(HOST, PORT, DB, CHARSET, SQL)
exec1(HOST, PORT, DB, CHARSET, SQL)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决方法三：&lt;/strong&gt;&lt;/span&gt;通过函数将数据和方法进行绑定，这也是一种面向对象编程的一种思想，但是我们一般并不会这样去写。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过函数的方式把变量和函数绑定到一块，其他的函数自然就使用不到此函数内的变量和方法&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 并且通过字典的形式将之前的变量包括到一块，可以简化我们函数传递的参数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func():
    obj_dict &lt;/span&gt;=&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HOST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PORT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 3306&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DB&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CHARSET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;select * from db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    }
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; exec1(obj_dict):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(obj_dict[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;HOST&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], obj_dict[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;PORT&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], obj_dict[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DB&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], obj_dict[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CHARSET&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;], obj_dict[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

    exec1(obj_dict)
func()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决方法四：&lt;/strong&gt;&lt;/span&gt;通过类的形式来将变量和方法进行绑定&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 并且通过字典的形式将之前的变量包括到一块，可以简化我们函数传递的参数&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Mysql:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, host, port, db, charset, sql):
        self.host&lt;/span&gt;=&lt;span&gt;host
        self.port&lt;/span&gt;=&lt;span&gt;port
        self.db&lt;/span&gt;=&lt;span&gt;db
        self.charset&lt;/span&gt;=&lt;span&gt;charset
        self.sql&lt;/span&gt;=&lt;span&gt;sql

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; exec1(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.host, self.port, self.db, self.charset, self.sql)


mysql_obj &lt;/span&gt;= Mysql(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3306, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;db1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
mysql_obj.exec1()
mysql_obj.exec1()
mysql_obj.exec1()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_be09ceec-ddd5-4718-a72f-1adf72a9daff&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_be09ceec-ddd5-4718-a72f-1adf72a9daff&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_be09ceec-ddd5-4718-a72f-1adf72a9daff&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; python3中统一了类与类型的概念&lt;/span&gt;
l = list([1, 2, 3&lt;span&gt;])
l.append(&lt;/span&gt;4&lt;span&gt;)
list.append(l, &lt;/span&gt;5&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(l)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 结果&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; [1, 2, 3, 4, 5]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;类与类型的概念&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;面向对象是一种更高程度的封装
    在之前没有面向对象的时候，我们会发现如果需要传递参数的时候，我们无非有两种方式，一种是传递数据，一种就是传递功能，但是没有说我可以通过传递一个变量，这个变量既有数据又有功能的。也就是说一旦我们需要的参数较多，而且调用的次数较为频繁的时候，我们难免就会产生大量的重复操作，因为我们没有一个变量可以将其进行封装。
    而对象呢就是高度封装了一系列的方法和属性的变量，我们可以通过传递一个对象，就可以获得它所有的方法和属性，简化了我们传递参数时的操作。
面向对象的精髓虽在：
　　&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 掌握了一种方法，能够把专门的数据和专门的方法整合到一块，&lt;/span&gt;
　　&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当我们拿到一个对象的时候不仅仅能够拿到对应的数据，也能拿到相应的配套方法。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;继承&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;人生三问&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span readability=&quot;4&quot;&gt;什么是继承&lt;br/&gt;　　继承是一种遗传关系，子类可以重用父类中的属性。&lt;br/&gt;　　在程序中继承是一种新建子类的方式，新创建的类称为子类或者派生类，被继承的类称为父类\基类\超类。&lt;br/&gt;为什么要用继承
　　减少类与类之间的代码冗余的问题&lt;br/&gt;怎么使用继承&lt;br/&gt;　　先抽象再继承&lt;p&gt;只有在python2中才会分新式类和经典类，python3都是新式类&lt;br/&gt;新式类：但凡继承了object类的子类，以及该子类的子子类，...都称为新式类。&lt;br/&gt;经典类：但凡没有继承object类的子类，以及该子类的子子类，....都称为经典类。&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;继承概览：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在python3中默认是继承object类的&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 在python2中默认是没有继承的，如果想要继承要把object传进去&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Parent1:
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Parent2:
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sub1(Parent1):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Sub2(Parent1, Parent2):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;(Sub1.&lt;span&gt;__bases__&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; __bases__显示的是当前子类继承的父类&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(Sub2.&lt;span&gt;__bases__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(Parent2.&lt;span&gt;__bases__&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在python3中默认是继承object类的&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(Parent1.&lt;span&gt;__bases__&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 结果：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (&amp;lt;class '__main__.Parent1'&amp;gt;,)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (&amp;lt;class '__main__.Parent1'&amp;gt;, &amp;lt;class '__main__.Parent2'&amp;gt;)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (&amp;lt;class 'object'&amp;gt;,)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (&amp;lt;class 'object'&amp;gt;,)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;属性的查找顺序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;情况一：&lt;/strong&gt;单继承问题查找顺序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181163/201810/1181163-20181023183959265-315676427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;情况二：&lt;/strong&gt;非菱形多继承问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181163/201810/1181163-20181023184752022-1256503363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;情况三：&lt;/strong&gt;菱形多继承问题&lt;/p&gt;
&lt;p&gt;python2中是深度优先查找（经典类）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181163/201810/1181163-20181023184333891-2142926923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;python3中是广度优先查找（新式类）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1181163/201810/1181163-20181023184609499-1631011750.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结：只有在python2中的菱形问题才会出现深度查找。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;案例：&lt;/strong&gt;&lt;/span&gt;继承是如何解决代码冗余问题的&lt;/p&gt;
&lt;p&gt;首先创建了一个学生类和一个教师类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_77935d18-6657-436f-87f5-83760ad749da&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_77935d18-6657-436f-87f5-83760ad749da&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_77935d18-6657-436f-87f5-83760ad749da&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据之前写的Oldboy选课系统来说&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyStudent:
    school &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;OldBoy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age, gender):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age
        self.gender&lt;/span&gt;=&lt;span&gt;gender

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; choose_course(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;choose_course&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyTeacher:
    school &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;OldBoy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age, gender, level, salary):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age
        self.gender&lt;/span&gt;=&lt;span&gt;gender
        self.level&lt;/span&gt;=&lt;span&gt;level
        self.salary&lt;/span&gt;=&lt;span&gt;salary

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; change_score(self, stu, score):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;change score&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;学生类和教师类&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题一：&lt;/strong&gt;&lt;/span&gt;我们发现这两个类中有些重复的代码，如他们的共有属性school = 'OldBoy'，为了简化代码，我们需要抽象一个父类，将共有属性放进去，然后通过继承让两个类可以获得相应的属性值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 创建一个类然后让学生类和教师类继承&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;27&quot;&gt;
class OldBoyPerson:&lt;br/&gt;school = 'OldBoy'&lt;p&gt;# 根据之前写的Oldboy选课系统来说&lt;br/&gt;class OldBoyStudent(OldBoyPerson):&lt;br/&gt;# school = 'OldBoy'  因为父类中有属性，所以这里就不需要了&lt;/p&gt;&lt;p&gt;def __init__(self, name, age, gender):&lt;br/&gt;self.name=name&lt;br/&gt;self.age=age&lt;br/&gt;self.gender=gender&lt;/p&gt;&lt;p&gt;def choose_course(self):&lt;br/&gt;print('choose_course')&lt;/p&gt;&lt;p&gt;class OldBoyTeacher(OldBoyPerson):&lt;br/&gt;# school = 'OldBoy'&lt;/p&gt;&lt;p&gt;def __init__(self, name, age, gender, level, salary):&lt;br/&gt;self.name=name&lt;br/&gt;self.age=age&lt;br/&gt;self.gender=gender&lt;br/&gt;self.level=level&lt;br/&gt;self.salary=salary&lt;/p&gt;&lt;p&gt;def change_score(self, stu, score):&lt;br/&gt;print('change score')
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;问题二：&lt;/strong&gt;&lt;/span&gt;这样确实是减少了子类中的公共属性，但是我们发现在__init__方法中也有一部分是重复的，对于这样的重复的选项我们应该怎么去减少呢&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;步骤一：先将学生类和教师类中相同的参数的name， age， gender提取出来放在父类中的__init方法中

步骤二: 通过不同的方法让子类中的init方法中接受到传递过来的额外的参数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;方法一：&lt;/strong&gt;&lt;/span&gt;指名道姓的通过类去找到相应的方法实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_476d48b6-2245-4c4c-a1ec-8b8719abddef&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_476d48b6-2245-4c4c-a1ec-8b8719abddef&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_476d48b6-2245-4c4c-a1ec-8b8719abddef&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyPerson:
    school &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;OldBoy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age, gender):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age
        self.gender&lt;/span&gt;=&lt;span&gt;gender


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据之前写的Oldboy选课系统来说&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyStudent(OldBoyPerson):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; choose_course(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;choose_course&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyTeacher(OldBoyPerson):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age, gender, level, salary):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此处就是指名道姓的要调用父类中的__init__方法&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此时父类中的__init__方法就是一个普通的方法，我们需要把四个参数全部传进去&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这样就达到了继承的效果了&lt;/span&gt;
        OldBoyPerson.&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age, gender) 
        self.level&lt;/span&gt;=&lt;span&gt;level
        self.salary&lt;/span&gt;=&lt;span&gt;salary

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; change_score(self, stu, score):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;change score&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;方法一与继承无关，只是可以达到继承的目的而已&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;方法二&lt;/strong&gt;&lt;/span&gt;：严格依照继承的方法去继承用到函数super&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_90ca0cda-9cb5-46da-aaa3-b25f86226704&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_90ca0cda-9cb5-46da-aaa3-b25f86226704&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_90ca0cda-9cb5-46da-aaa3-b25f86226704&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyPerson:
    school &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;OldBoy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age, gender):
        self.name&lt;/span&gt;=&lt;span&gt;name
        self.age&lt;/span&gt;=&lt;span&gt;age
        self.gender&lt;/span&gt;=&lt;span&gt;gender


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据之前写的Oldboy选课系统来说&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyStudent(OldBoyPerson):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; choose_course(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;choose_course&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldBoyTeacher(OldBoyPerson):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, name, age, gender, level, salary):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 参数一是当前类，参数二当前对象&lt;/span&gt;
        super(OldBoyTeacher, self).&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(name, age, gender)
        self.level&lt;/span&gt;=&lt;span&gt;level
        self.salary&lt;/span&gt;=&lt;span&gt;salary

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; change_score(self, stu, score):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;change score&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;super函数严格按照继承关系&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;难点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; super(OldBoyTeacher, self)在python3中不需要传递参数，它会创建一个特殊的对象&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 该对象是强调: super()函数会严格按照类的mro列表的顺序依次查找属性&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例题：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;A没有继承B,&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A.test&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 首先打印&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当执行到super函数的时候，会安好mro列表的顺序去查找&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当前mro列表已经执行到A，所以下一个查找地方是B因此会执行B类的test方法&lt;/span&gt;
&lt;span&gt;        super().test()   
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;from B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 所以打印了&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; C(A,B):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;

c&lt;/span&gt;=C()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 首先创建对象&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 1. 对象中没有此方法&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 2. 去C类中查找，没有找到&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 3. 去父类A中查找，有test，开始执行test函数&lt;/span&gt;
&lt;span&gt;c.test()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(C.mro())
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 23 Oct 2018 15:43:00 +0000</pubDate>
<dc:creator>沉沦的罚</dc:creator>
<og:description>面向对象补充知识 面向对象概念 问题一：既然面向对象这么好，我们之后的编程是不是都要用面向对象呢？ 类的概念 类的创建过程: 创建一个老男孩选课系统 现实世界的分析： 步骤一：要从需求中分析出对象的特</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huwentao/p/9836359.html</dc:identifier>
</item>
<item>
<title>差分约束讲解 - Yang1208</title>
<link>http://www.cnblogs.com/yangsongyi/p/9840389.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangsongyi/p/9840389.html</guid>
<description>&lt;p align=&quot;right&quot;&gt;——by ysy&lt;/p&gt;
&lt;h4 id=&quot;前置知识&quot;&gt;1.前置知识&lt;/h4&gt;
&lt;p&gt;        因为差分约束是基于&lt;span class=&quot;math inline&quot;&gt;\(spfa\)&lt;/span&gt;的一种解不等式，或等式组的技巧，所以差分约束的前置知识就是&lt;span class=&quot;math inline&quot;&gt;\(spfa\)&lt;/span&gt;和对不等式的简单小变换。&lt;/p&gt;
&lt;h4 id=&quot;讲解&quot;&gt;2.讲解&lt;/h4&gt;
&lt;p&gt;​        因为差分约束只是一个技巧，所以在这里我先讲解技巧，之后再讲解例题。&lt;/p&gt;
&lt;h6 id=&quot;建图技巧&quot;&gt;建图技巧&lt;/h6&gt;
&lt;p&gt;​        我们将不等式组分为两种：&lt;span class=&quot;math inline&quot;&gt;\(A \le B+val\)&lt;/span&gt;以及&lt;span class=&quot;math inline&quot;&gt;\(A\ge B+val\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;​        现在讨论第一种&lt;span class=&quot;math inline&quot;&gt;\(A\le B+val\)&lt;/span&gt;，我们在建图时&lt;span class=&quot;math inline&quot;&gt;\(B \rightarrow A\)&lt;/span&gt;建边，边权为&lt;span class=&quot;math inline&quot;&gt;\(val\)&lt;/span&gt;，所有的不等式都像这样建边的话，我们可以在建出的图上跑最短路。&lt;/p&gt;
&lt;p&gt;        现在为第二种&lt;span class=&quot;math inline&quot;&gt;\(A\ge B+val\)&lt;/span&gt;，我们在建图时&lt;span class=&quot;math inline&quot;&gt;\(B \rightarrow A\)&lt;/span&gt;建边，边权为&lt;span class=&quot;math inline&quot;&gt;\(val\)&lt;/span&gt;，所有的不等式都像这样建边的话，我们可以在建出的图上跑最长路。&lt;/p&gt;
&lt;p&gt;​        如果我所有的式子给出的时候不是都为第一种或者第二种呢？如果不将式子的形式统一的话，就没法在建出来的图上单纯的跑最短路或者最长路。所以我们就需要将所有的式子的形式进行统一。&lt;/p&gt;
&lt;p&gt;​        讨论完不等式了，就剩下等式。&lt;span class=&quot;math inline&quot;&gt;\(A=B\)&lt;/span&gt;我们就以这个为例。等式可以化成不等式组&lt;span class=&quot;math inline&quot;&gt;\(A\le B\&amp;amp;\&amp;amp; A \ge B\)&lt;/span&gt;。我们将这个不等式组转化成为图就是$B \rightarrow A $，边权为&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;，同时加另一条边&lt;span class=&quot;math inline&quot;&gt;\(A \rightarrow B\)&lt;/span&gt;，边权为&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;。这样一个等式就化为不等式的形式了。&lt;/p&gt;
&lt;p&gt;        我在上面写的都是大于等于或者小于等于的情况，如果是大于或者小于的情况怎么办？我在这里以大于为例：&lt;span class=&quot;math inline&quot;&gt;\(A\gt B \rightarrow A \ge B +1\)&lt;/span&gt;。我们只需要将式子化成为带等于的形式就可以了。&lt;/p&gt;
&lt;h4 id=&quot;例题&quot;&gt;3.例题&lt;/h4&gt;
&lt;h6 id=&quot;题目链接httpswww.lydsy.comjudgeonlineproblem.phpid3436&quot;&gt;1）[题目链接][&lt;a href=&quot;https://www.lydsy.com/JudgeOnline/problem.php?id=3436&quot; class=&quot;uri&quot;&gt;https://www.lydsy.com/JudgeOnline/problem.php?id=3436&lt;/a&gt;]&lt;/h6&gt;
&lt;p&gt;​        我们看这道题目，会发现题目之中有三个限制&lt;span class=&quot;math inline&quot;&gt;\(X_a \ge X_b+c\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(X_a \le X_b+c\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(X_a=X_b\)&lt;/span&gt;。我们们根据这三个性质能建出来一个图。第一个条件就是$a \rightarrow b &lt;span class=&quot;math inline&quot;&gt;\(，边权为\)&lt;/span&gt;-c&lt;span class=&quot;math inline&quot;&gt;\(。第二个条件就是\)&lt;/span&gt;b \rightarrow a&lt;span class=&quot;math inline&quot;&gt;\(，边权为\)&lt;/span&gt;c&lt;span class=&quot;math inline&quot;&gt;\(。第三个条件就是\)&lt;/span&gt;a\rightarrow b &lt;span class=&quot;math inline&quot;&gt;\(和\)&lt;/span&gt;b\rightarrow a$边权都为&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;​        因为我们要判断能否成立，所以我们只需要在我们建出的图上跑最短路，并且判断是否有负环，如果有则输出&lt;span class=&quot;math inline&quot;&gt;\(No\)&lt;/span&gt;，否则输出&lt;span class=&quot;math inline&quot;&gt;\(Yes\)&lt;/span&gt;。因为要判断负环，所以我们很容易想到&lt;span class=&quot;math inline&quot;&gt;\(spfa\)&lt;/span&gt;。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
#define N 10010
#define M 10010
#define inf1 1000000000
#define inf2 900000000
int n,m;
int head[N],nxt[M&amp;lt;&amp;lt;2],to[M&amp;lt;&amp;lt;2],val[M&amp;lt;&amp;lt;2];
int dis[N],idx;bool vis[N],is;
void add(int a,int b,int c)
{nxt[++idx]=head[a],to[idx]=b,val[idx]=c,head[a]=idx;}
void spfa(int p)
{
    vis[p]=true;
    for(int i=head[p];i;i=nxt[i])
    {
        if(dis[to[i]]&amp;lt;=dis[p]+val[i]) continue;
        dis[to[i]]=dis[p]+val[i];
        if(vis[to[i]]||is) {is=true;return;}
        spfa(to[i]);
    }vis[p]=false;
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m);
    for(int i=1;i&amp;lt;=m;i++)
    {
        int kind,a,b,c;
        scanf(&quot;%d&quot;,&amp;amp;kind);
        if(kind==1) scanf(&quot;%d%d%d&quot;,&amp;amp;a,&amp;amp;b,&amp;amp;c),c=-c;
        else if(kind==2) scanf(&quot;%d%d%d&quot;,&amp;amp;a,&amp;amp;b,&amp;amp;c),swap(a,b);
        else scanf(&quot;%d%d&quot;,&amp;amp;a,&amp;amp;b),c=0,add(b,a,c);
        add(a,b,c);
    }
    for(int i=1;i&amp;lt;=n;i++) dis[i]=inf1;
    for(int i=1;i&amp;lt;=n;i++) dis[i]=0,spfa(i);
    if(is) printf(&quot;No\n&quot;);
    else printf(&quot;Yes&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我有时间的话，例题会持续更下去。这是本人的见解。有问题可以评论问我。&lt;/p&gt;
</description>
<pubDate>Tue, 23 Oct 2018 15:16:00 +0000</pubDate>
<dc:creator>Yang1208</dc:creator>
<og:description>差分约束讲解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangsongyi/p/9840389.html</dc:identifier>
</item>
<item>
<title>mybatis百科-结果集映射类ResultMap - 阿进的写字台</title>
<link>http://www.cnblogs.com/homejim/p/9840373.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/homejim/p/9840373.html</guid>
<description>&lt;p&gt;&lt;code&gt;ResultMap&lt;/code&gt; 对应的是结果集 &amp;lt;resultMap&amp;gt;中的一个结果集。 其基本组成部分中， 含有 &lt;code&gt;ResultMapping&lt;/code&gt; 对象。&lt;/p&gt;
&lt;p&gt;其组成大致如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181023231155176?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzEzOTE5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;结果集映射类&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文， 主要讲解一下该类的组成。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;  // resultMap 节点的 id
  private String id;
  // resultMap 节点的 type
  private Class&amp;lt;?&amp;gt; type;
  // 用于记录 &amp;lt;discriminayor&amp;gt; 节点之外的其他映射关系
  private List&amp;lt;ResultMapping&amp;gt; resultMappings;
  // 记录映射关系中带有 ID 标记的映射关系。 如 id， constructor 等节点
  private List&amp;lt;ResultMapping&amp;gt; idResultMappings;
  // 记录映射关系中有 Constructor 标记的映射关系
  private List&amp;lt;ResultMapping&amp;gt; constructorResultMappings;
  // 记录映射关系中没有 Constructor 标记的映射关系
  private List&amp;lt;ResultMapping&amp;gt; propertyResultMappings;
  // 记录所有映射关系中涉及 column 属性的集合
  private Set&amp;lt;String&amp;gt; mappedColumns;
  private Set&amp;lt;String&amp;gt; mappedProperties;
  // 鉴别器， 对应 &amp;lt;discriminayor&amp;gt; 节点
  private Discriminator discriminator;
  // 是否含有嵌套的结果映射， 如果某个映射关系中有 resultMap， 没有 resultSet ， 则为true
  private boolean hasNestedResultMaps;
  // 是否存在嵌套查询
  private boolean hasNestedQueries;
  // 是否开启自动映射
  private Boolean autoMapping;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;只有默认构造函数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  private ResultMap() {
  }
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;setter-和-getter-函数&quot;&gt;3.1 setter 和 getter 函数&lt;/h2&gt;
&lt;p&gt;对象创建使用的是建造者模式， 因此，只有部分成员变量含有 setter 函数。而除了 Configuration 对象， 其他都含有 getter 函数。&lt;/p&gt;

&lt;h2 id=&quot;成员变量-1&quot;&gt;4.1 成员变量&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;  private ResultMap resultMap = new ResultMap();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是要建造的对象。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;public Builder(Configuration configuration, String id, Class&amp;lt;?&amp;gt; type, List&amp;lt;ResultMapping&amp;gt; resultMappings) {
    this(configuration, id, type, resultMappings, null);
}

public Builder(Configuration configuration, String id, Class&amp;lt;?&amp;gt; type, List&amp;lt;ResultMapping&amp;gt; resultMappings, Boolean autoMapping) {
    resultMap.configuration = configuration;
    resultMap.id = id;
    resultMap.type = type;
    resultMap.resultMappings = resultMappings;
    resultMap.autoMapping = autoMapping;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没有默认构造函数， 必须要给&lt;code&gt;ResultMap&lt;/code&gt;对象的一些成员变量赋值。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;    public Builder discriminator(Discriminator discriminator) {
      resultMap.discriminator = discriminator;
      return this;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;discriminator， 赋值后返回对象本身。&lt;/p&gt;
&lt;p&gt;负责建造对象一些逻辑的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public ResultMap build() {
    if (resultMap.id == null) {
      throw new IllegalArgumentException(&quot;ResultMaps must have an id&quot;);
    }
    resultMap.mappedColumns = new HashSet&amp;lt;&amp;gt;();
    resultMap.mappedProperties = new HashSet&amp;lt;&amp;gt;();
    resultMap.idResultMappings = new ArrayList&amp;lt;&amp;gt;();
    resultMap.constructorResultMappings = new ArrayList&amp;lt;&amp;gt;();
    resultMap.propertyResultMappings = new ArrayList&amp;lt;&amp;gt;();
    final List&amp;lt;String&amp;gt; constructorArgNames = new ArrayList&amp;lt;&amp;gt;();
    
    // 遍历 resultMappings
    for (ResultMapping resultMapping : resultMap.resultMappings) {
      // 是否存在嵌套查询
      resultMap.hasNestedQueries = resultMap.hasNestedQueries || resultMapping.getNestedQueryId() != null;
      // 是否存在嵌套的结果
      resultMap.hasNestedResultMaps = resultMap.hasNestedResultMaps || (resultMapping.getNestedResultMapId() != null &amp;amp;&amp;amp; resultMapping.getResultSet() == null);
      // 获取列名
      final String column = resultMapping.getColumn();
      if (column != null) {
        // 列名转大写添加到 mappedColumns 结果集中
        resultMap.mappedColumns.add(column.toUpperCase(Locale.ENGLISH));
      } else if (resultMapping.isCompositeResult()) {
        for (ResultMapping compositeResultMapping :   resultMapping.getComposites()) {
          final String compositeColumn = compositeResultMapping.getColumn();
          if (compositeColumn != null) {
            resultMap.mappedColumns.add(compositeColumn.toUpperCase(Locale.ENGLISH));
          }
        }
      }
      // 获取列映射对应的属性
      final String property = resultMapping.getProperty();
      if(property != null) {
        resultMap.mappedProperties.add(property);
      }
      if (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) {
        resultMap.constructorResultMappings.add(resultMapping);
        if (resultMapping.getProperty() != null) {
          constructorArgNames.add(resultMapping.getProperty());
        }
      } else {
        resultMap.propertyResultMappings.add(resultMapping);
      }
      if (resultMapping.getFlags().contains(ResultFlag.ID)) {
        resultMap.idResultMappings.add(resultMapping);
      }
    }
    if (resultMap.idResultMappings.isEmpty()) {
      resultMap.idResultMappings.addAll(resultMap.resultMappings);
    }
    if (!constructorArgNames.isEmpty()) {
      final List&amp;lt;String&amp;gt; actualArgNames = argNamesOfMatchingConstructor(constructorArgNames);
      if (actualArgNames == null) {
        throw new BuilderException(&quot;Error in result map '&quot; +   resultMap.id
            + &quot;'. Failed to find a constructor in '&quot;
            + resultMap.getType().getName() + &quot;' by arg names &quot; + constructorArgNames
            + &quot;. There might be more info in debug log.&quot;);
      }
      Collections.sort(resultMap.constructorResultMappings, (o1, o2) -&amp;gt; {
        int paramIdx1 = actualArgNames.indexOf(o1.getProperty());
        int paramIdx2 = actualArgNames.indexOf(o2.getProperty());
        return paramIdx1 - paramIdx2;
      });
    }
    // lock down collections
    resultMap.resultMappings = Collections.unmodifiableList(resultMap.resultMappings);
    resultMap.idResultMappings = Collections.unmodifiableList(resultMap.idResultMappings);
    resultMap.constructorResultMappings = Collections.unmodifiableList(resultMap.constructorResultMappings);
    resultMap.propertyResultMappings = Collections.unmodifiableList(resultMap.propertyResultMappings);
    resultMap.mappedColumns = Collections.unmodifiableSet(resultMap.mappedColumns);
    return resultMap;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;获取配置的构造方法参数列表&quot;&gt;4.4 获取配置的构造方法参数列表&lt;/h2&gt;
&lt;p&gt;主函数是&lt;code&gt;argNamesOfMatchingConstructor&lt;/code&gt;。 其功能主要是获取参数名。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private List&amp;lt;String&amp;gt; argNamesOfMatchingConstructor(List&amp;lt;String&amp;gt; constructorArgNames) {
  // 获取声明的构造方法
  Constructor&amp;lt;?&amp;gt;[] constructors = resultMap.type.getDeclaredConstructors();
  // 遍历每个构造方法
  for (Constructor&amp;lt;?&amp;gt; constructor : constructors) {
    // 获取构造方法的参数类型
    Class&amp;lt;?&amp;gt;[] paramTypes = constructor.getParameterTypes();
    // 参数长度和获取到参数类型数量一致
    if (constructorArgNames.size() == paramTypes.length) {
      // 获取构造函数的参数名称
      List&amp;lt;String&amp;gt; paramNames = getArgNames(constructor);
      if (constructorArgNames.containsAll(paramNames)
          &amp;amp;&amp;amp; argTypesMatch(constructorArgNames, paramTypes, paramNames)) {
        return paramNames;
      }
    }
  }
  return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;getArgNames&lt;/code&gt;获取构造函数的参数名&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private List&amp;lt;String&amp;gt; getArgNames(Constructor&amp;lt;?&amp;gt; constructor) {
  List&amp;lt;String&amp;gt; paramNames = new ArrayList&amp;lt;&amp;gt;();
  List&amp;lt;String&amp;gt; actualParamNames = null;
  // 获取参数的注解
  final Annotation[][] paramAnnotations = constructor.getParameterAnnotations();
  int paramCount = paramAnnotations.length;
  for (int paramIndex = 0; paramIndex &amp;lt; paramCount; paramIndex++) {
    String name = null;
    for (Annotation annotation : paramAnnotations[paramIndex]) {
      if (annotation instanceof Param) {
        name = ((Param) annotation).value();
        break;
      }
    }
    if (name == null &amp;amp;&amp;amp; resultMap.configuration.isUseActualParamName()) {
      if (actualParamNames == null) {
        actualParamNames = ParamNameUtil.getParamNames(constructor);
      }
      if (actualParamNames.size() &amp;gt; paramIndex) {
        name = actualParamNames.get(paramIndex);
      }
    }
    paramNames.add(name != null ? name : &quot;arg&quot; + paramIndex);
  }
  return paramNames;
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;argTypesMatch&lt;/code&gt;方法用来检查构造方法参数是否匹配&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    private boolean argTypesMatch(final List&amp;lt;String&amp;gt; constructorArgNames,
        Class&amp;lt;?&amp;gt;[] paramTypes, List&amp;lt;String&amp;gt; paramNames) {
      for (int i = 0; i &amp;lt; constructorArgNames.size(); i++) {
        Class&amp;lt;?&amp;gt; actualType = paramTypes[paramNames.indexOf(constructorArgNames.get(i))];
        Class&amp;lt;?&amp;gt; specifiedType = resultMap.constructorResultMappings.get(i).getJavaType();
        if (!actualType.equals(specifiedType)) {
          if (log.isDebugEnabled()) {
            log.debug(&quot;While building result map '&quot; + resultMap.id
                + &quot;', found a constructor with arg names &quot; + constructorArgNames
                + &quot;, but the type of '&quot; + constructorArgNames.get(i)
                + &quot;' did not match. Specified: [&quot; + specifiedType.getName() + &quot;] Declared: [&quot;
                + actualType.getName() + &quot;]&quot;);
          }
          return false;
        }
      }
      return true;
    }&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 23 Oct 2018 15:13:00 +0000</pubDate>
<dc:creator>阿进的写字台</dc:creator>
<og:description>ResultMap 对应的是结果集 &lt;resultMap&gt;中的一个结果集。 其基本组成部分中， 含有 ResultMapping 对象。 其组成大致如下： 本文， 主要讲解一下该类的组成。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/homejim/p/9840373.html</dc:identifier>
</item>
<item>
<title>关于编程语言的一些趣史 - kid551</title>
<link>http://www.cnblogs.com/kid551/p/9840321.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kid551/p/9840321.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/672506/201810/672506-20181023230059968-2119226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;回顾历史做仔细的分析与研究，总能给人意想不到的发现和惊叹。从认知的难易程度上来看，编程语言的范式可以按照如下的方式排序：最容易理解的是structured programming，一根线从上往下；再来会稍微费点功夫理解的是object-oriented（OO）programming；更困难的是functional programming，相当抽象，整个就是一数学的抽象思维。&lt;/p&gt;
&lt;p&gt;自然地，历史的发展都是由简单到复杂，我们会下意识地认为编程语言在历史上的出现顺序也应该是：structured programming、OO、functional programming。&lt;/p&gt;
&lt;p&gt;但翻阅历史，却会惊讶地发现它们的出现顺序竟然是反过来的！&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;structured programming是在1968年出现，其标志是Dijkstra（对，那个最短路径算法里出现的名字）发表他的seminal paper 'Cooperating sequential processes’。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;再来是更早的1966年，Dahl和Nygaard发现function call stack frame可以被放到heap去做，这标志着OO的出现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;而似乎最难以理解的functional programming，则几乎可以追溯到1936年计算机被发明的时期。其标志是Alonzo Church推出lambda calculus。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另一件值得探讨的事情是：为什么Dijkstra要引入structured programming？虽然从现在来看structured programming是如此的直观，以至于你会问，为什么会过了那么久才引入structured programming？&lt;/p&gt;
&lt;p&gt;在Dijkstra的时代，主流编程语言都不是structured的，到处充斥着goto所带来的跳转。为什么会遍地的goto呢？因为在计算机语言的莽荒时期，一切都是向机器看齐的。对于机器语言、汇编来讲，指令集的各种jump操作是再平常不过的事情了。既然它们都有之灵跳转，对应的编程语言怎么好意思说不支持goto呢？&lt;/p&gt;
&lt;p&gt;所以，structured programming反而在当时是一种极端的非主流，因为它为programming给予了相当大的限制。&lt;/p&gt;
&lt;p&gt;Dijkstra之所以要引入structured programming源自于他要把“计算机”这门学科变为科学的尝试：将数学的公理化体系引入computer science（CS）。但经过大量尝试后，他发现要为代码构建牢固的数学公理体系着实不是一件容易的事情。而其中最大的问题障碍，就是goto带来的不确定性。&lt;/p&gt;
&lt;p&gt;于是，Dijkstra采用了数学家常用的研究方法：当需要推出一个漂亮的理论却发现前提条件不够时，就反过来先引入这个结论需要的前提假设。&lt;/p&gt;
&lt;p&gt;于是，Dijkstra就直接把goto（至少是被滥用的goto）废除掉。没有了goto，虽然引入数学的严格证明会变得相当简单，但这样会不会限制语言的表达？又或者说，有些代码是不是没有了goto就无法写出来呢？&lt;/p&gt;
&lt;p&gt;说来也是历史机缘，恰好在这个时候，Bohm and Jacopini在理论上证明了：所有的程序都可以被以下三种句式所替代： sequence, selection(if/then/else), iteration(for/while)。而这正好是Dijkstra所需要的，因为实现这三种语句完全用不到goto。于是，Dijkstra的为CS引入严格数学公理体系的壮举也就水到渠成：所有的由sequence、selection（if/then/else）语句构成的程序，可以由数学枚举法证明。而由iteration（for/while）语句构成的程序，则可以由数学归纳法完成。而structured programming这种被做了更多限制的编程范式也就应运而生。（很有意思的事情是，三种编程范式structured programming、OO、functional programming的引入，都是通过“限制功能”而非增加功能做出的，也即是，为了更强你需要更弱一点。更多讨论可以参考我以前的一篇文章《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247483774&amp;amp;idx=1&amp;amp;sn=74906052c65df36baa63cbbf5800c656&amp;amp;chksm=ec20e6c2db576fd4c230ea140e0cfd5cb910500b5ff219f66b1e7038d3f9fd844e2cb29c6ccf&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;为了快一点为什么却要慢一点&lt;/a&gt;》。）&lt;/p&gt;
&lt;p&gt;如果按照这样的思维框架去思考算法，比如LeetCode中的算法题目，又会有一些惊人发现。我的一个想转行做程序员的朋友曾跟我聊过这样一段刷题感受：似乎算法题目都或多或少地在使用数学归纳法。这确实是很强的洞见。回顾起来，无论是divide-and-conquere还是dynamic programmming，这两种作为算法基石的工具都运用到了数学归纳法的思维方式。前者（递归）是天然的数学归纳法处理方式，而后者则是做了空间复杂度优化的递归，同样按照数学归纳法的方式做处理。&lt;/p&gt;
&lt;p&gt;进一步，我们可以考察一些工作中遇到的问题。刚毕业工作的小白程序员常常会疑惑这样一个事情，明明自己在学校中算法的造诣颇高，按道理说算法好不就是编程的功底好么，但为什么到了工作岗位中还是各种碰壁？&lt;/p&gt;
&lt;p&gt;按照我们上面构建的思维框架，我们其实可以给出一种解释：因为算法部分的修炼，仅仅保证了你在structured programming这个语言范式下做事具备了很好的能力。可工作中所涉及到的软件设计，则是在OO范式和functional programming范式下进行的。领域不同，自然是新手，碰壁也是自然之事。&lt;/p&gt;
&lt;p&gt;再回到我们最开始的那个问题，为什么编程范式会是以相反的认知方向来发展？因为这是按照“构建计算机领域”的难易程度在走，也即是背后的数学发展在展开，而不是编程语言使用的难易程度在发展。这是一门新兴学科初期的发展特点——先考虑的是生产的便利性，再来是消费者的便利性。&lt;/p&gt;
&lt;p&gt;========&lt;/p&gt;
&lt;p&gt;Comments for 《Clean Architecture》&lt;/p&gt;




&lt;p&gt;&lt;strong&gt;近期回顾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484593&amp;amp;idx=1&amp;amp;sn=26c4e29b584a98e244d7334c6a75b63c&amp;amp;chksm=ec20e30ddb576a1b548420615abfe3545acff718db4585d33190e0e5b03df0425f5ef55eb99d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;他人皆蠢，吗？&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484588&amp;amp;idx=1&amp;amp;sn=5d047d123e90b6165916f91a49b37c98&amp;amp;chksm=ec20e310db576a06facd210f3bf06351c7a2b372fdc88bb2ae22c2b856b3cc7d2090c501c0a5&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;从Facebook面试看互联网行业&lt;/a&gt;》&lt;br/&gt;《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzI5MDMyMTEwNw==&amp;amp;mid=2247484582&amp;amp;idx=1&amp;amp;sn=3b7a671c9bffc89f7c7182624ce05164&amp;amp;chksm=ec20e31adb576a0c48f81147ed4ffabfaad6766995e6085256a0ba9ebbeb40f8ab3c6136a148&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;GeekArtT两周年&lt;/a&gt;》&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;如果你喜欢我的文章或分享，请长按下面的二维码关注我的微信公众号，谢谢！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/672506/201810/672506-20181023230137555-2124868900.jpg&quot; alt=&quot;&quot; width=&quot;628&quot; height=&quot;314&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;h3&gt;   &lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;更多信息交流和观点分享，可加入知识星球：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/672506/201810/672506-20181023230213124-1621146937.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Oct 2018 15:03:00 +0000</pubDate>
<dc:creator>kid551</dc:creator>
<og:description>回顾历史做仔细的分析与研究，总能给人意想不到的发现和惊叹。从认知的难易程度上来看，编程语言的范式可以按照如下的方式排序：最容易理解的是structured programming，一根线从上往下；再来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kid551/p/9840321.html</dc:identifier>
</item>
<item>
<title>一种精准monkey测试的方法 - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/9840315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/9840315.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;WeTest 导读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;相信大家都知道移动端应用的monkey测试吧，不知你们有没有为monkey测试的太过于随机性的特性有过困扰，至少在我们这种界面控件较少且控件位置较偏的app的使用上其测试有效性大打折扣。因此本文主要针对这个问题，提供了一种解决方案。&lt;/p&gt;

&lt;hr/&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;1. 问题背景&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Monkey测试：是Android自动化测试的一种手段，简单的说是像猴子一样乱点，它向系统发送伪随机的用户事件流(如按键输入、触摸屏输入、手势输入等)，是一种随机性测试，为了测试软件的健壮性和稳定性，通常用于安卓应用的压力测试。&lt;/p&gt;

&lt;p&gt;因此，我们的产品也用了这种传统的monkey手段进行app稳定性测试，在使用一段时间后，并未发现实际性问题。通过观察一段时间的执行过程，发现由于我们app几个页面控件布局是比较偏上和偏下边缘，中间只有一个大按钮，这样中间大按钮命中率比较高经常会进入同一个页面，那么其他页面和按钮的功能几乎没有被点击到。这种传统monkey测试控件命中率太低！&lt;/p&gt;

&lt;p&gt;市面上有很多类似布局的app，相信在采用传统monkey测试时也存在此类问题。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2. 解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;我们知道，对于app页面布局的控件位置、属性等信息是可以用android sdk 工具包中的uiautomatorviewer.bat查看的，如果在monkey测试时能获得这些控件的位置信息，那么就可以实现控件的精准点击。android sdk提供了这个命令“adb shell uiautomator dump”，可以实现将当前activity布局文件dump到xml文件中，这样问题就得到了解决。&lt;/p&gt;

&lt;p&gt;dump 布局文件：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201810/992994-20181023225823747-2097395912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;得到的window_dump.xml内容：&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version='1.0' encoding='UTF-8' standalone='yes' ?&amp;gt;&lt;br/&gt;&amp;lt;hierarchy rotation=&quot;0&quot;&amp;gt;&lt;br/&gt;&amp;lt;node index=&quot;0&quot; text=&quot;&quot; resource-id=&quot;&quot; class=&quot;android.widget.FrameLayout&quot; package=&quot;com.bass.cleaner.security&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;false&quot; enabled=&quot;true&quot; focusable=&quot;false&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[0,0][1080,1776]&quot;&amp;gt;&lt;br/&gt;&amp;lt;node index=&quot;0&quot; text=&quot;&quot; resource-id=&quot;&quot; class=&quot;android.widget.LinearLayout&quot; package=&quot;com.bass.cleaner.security&quot; content-desc=&quot;&quot; checkable=&quot;false&quot; checked=&quot;false&quot; clickable=&quot;false&quot; enabled=&quot;true&quot; focusable=&quot;false&quot; focused=&quot;false&quot; scrollable=&quot;false&quot; long-clickable=&quot;false&quot; password=&quot;false&quot; selected=&quot;false&quot; bounds=&quot;[0,0][1080,1776]&quot;&amp;gt;&lt;br/&gt;...&lt;br/&gt;&amp;lt;/hierarchy&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;uiautomatorviewer.bat查看控件属性：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201810/992994-20181023225915522-474274684.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;但是，又一问题，xml中的控件非常多，并非每个控件都可以点击，如果挨个尝试点击那么执行效率也是非常慢的，不符合预期。幸好，控件有个clickable属性，当其等于true时，表示该控件可点，反之不可点。那么，我们将控件信息xml文件中“clickable=true”的控件过滤出来，再去计算这些控件的位置进行点击，就可以实现精准点击。到此，问题得到完美解决。&lt;/p&gt;

&lt;p&gt;举例，执行流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201810/992994-20181023225925959-1880331920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当然，在实际中，还存在控件的点击顺序问题，如果点击顺序不合适，也会存在有些控件被频繁点击、有些控件可能点击不到的情况。这就需要根据实际的测试目标来指定执行策略，例如，在当前页可点击的控件列表中，随机点击、顺序点击，或存储各页面控件的目录树，进行深度遍历点击等等。&lt;/p&gt;

&lt;p&gt;随机测试完后，有时还需要还原执行过程，定位发现的问题，所以在执行过程中，我还加入了一些截图操作，在每次点击控件前进行点击坐标的标记、截图，这样，测试完后就能根据这些截图很完美的还原出了整个随机测试的过程，大大简化的问题的定位。举例，下图是执行过程中的几张连续截图： &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201810/992994-20181023225946648-1511251522.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201810/992994-20181023225954854-1965273642.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201810/992994-20181023230010317-1037714923.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;图中，红点位置就是点击位置，很直观的展示了执行过程。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;本文所述的方案很好的解决了monkey测试在控件布局不均衡的app上执行有效性低的问题。同时，实现了一种自适应的随机测试手段，也就是无需针对不同app编写不同的随机测试脚本，实现了一套测试代码用于所有app的随机性测试。&lt;/h3&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;“自动化兼容测试” 服务将提供云端自动化兼容服务，提交云端百台真机，并行测试。快速发现游戏/应用兼容性和性能问题，覆盖安卓主流机型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点击：&lt;a href=&quot;https://wetest.qq.com/product/auto-compatibility-testing?from=content_cnblogs&quot; target=&quot;_blank&quot;&gt;https://wetest.qq.com/product/auto-compatibility-testing&lt;/a&gt; 了解更多详情。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果使用当中有任何疑问，欢迎联系腾讯WeTest企业QQ：2852350015&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Oct 2018 15:02:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<og:description>WeTest 导读 相信大家都知道移动端应用的monkey测试吧，不知你们有没有为monkey测试的太过于随机性的特性有过困扰，至少在我们这种界面控件较少且控件位置较偏的app的使用上其测试有效性大打</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/9840315.html</dc:identifier>
</item>
<item>
<title>Composite模式（组合设计模式） - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/9840291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/9840291.html</guid>
<description>&lt;h4 id=&quot;composite-设计模式&quot;&gt;Composite 设计模式？&lt;/h4&gt;
&lt;p&gt;在计算机的文件系统中，有“文件夹”的概念（在有些操作系统（Linux操作系统）中，也称为“目录”）。文件夹里面既可以放入文件，也可以放入其他文件夹（子文件夹）。在子文件夹中，一样地既可以放入文件，也可以放入子文件夹。可以说，文件夹是形成了一种容器结构、递归结构。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;结构模式：能够使容器与内容具有一致性，创造出递归结构的模式就是Composite模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;关注点：使用Composite模式可以使容器与内容具有一致性，也可以称其为多个和单个的一致性，即将多个对象结合在一起，当作一个对象进行处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;理清职责&quot;&gt;理清职责&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;到处存在的递归结构：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;在视窗系统中，一个窗口可以含有一个子窗口，&lt;br/&gt;2.在文章的列表中，各列表之间可以相互嵌套，这也是一种递归结构。&lt;br/&gt;3.将多条计算机命令合并为一条宏命令时，如果使用递归结构实现宏命。&lt;br/&gt;4.树结构的数据结构都适用Composite模式。&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;实现：演示文件夹 文件子项之间的层次关系&lt;br/&gt;名字===================&amp;gt;&amp;gt;&amp;gt;说明&lt;br/&gt;Entry || 抽象类，用来实现File类和Directory类的一致性&lt;br/&gt;File || 表示文件的类&lt;br/&gt;Directory || 表示文件夹的类&lt;br/&gt;FileTreatementException || 表示向文件中增加Entry时发生的异常的类&lt;br/&gt;Main || 测试程序行为的类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Add（）方法的存在位置:&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;存在Entry 抛出异常。&lt;/li&gt;
&lt;li&gt;存在Entry 中什么也不做。&lt;/li&gt;
&lt;li&gt;声明在Entry中为抽象方法 不去实现。&lt;/li&gt;
&lt;li&gt;直接定义在Directory类中，但是需要关注类型之间的转换。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;uml&quot;&gt;UML&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181023225719892-288395746.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181023225727918-403187019.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;code&quot;&gt;Code&lt;/h4&gt;
&lt;p&gt;···&lt;/p&gt;
&lt;p&gt;public abstract class Entry {&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 1. 文件名
 * 2. 文件大小
 * @return
 */
public abstract String getName();
public abstract int getSize();

/**
 * Directory  增加条目
 * File 不能增加条目
 */
public Entry add(Entry entry)throws FileTreatementException{
    throw new FileTreatementException();
}

public void printList(){
    printList(&quot;&quot;);
}

protected abstract void printList(String prefix);

@Override
public String toString() {
    return getName()+&quot;(&quot;+getSize()+&quot;)&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;···&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class File extends Entry {

    private String name;

    private int size;

    public File(String name, int size) {
        this.name = name;
        this.size = size;
    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public int getSize() {
        return size;
    }

    @Override
    protected void printList(String prefix) {
        System.out.println(prefix+&quot;/&quot;+this);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;
public class Directory extends Entry {

    private String name;

    private List&amp;lt;Entry&amp;gt; directory=new ArrayList&amp;lt;&amp;gt;();

    public Directory(String name) {
        this.name = name;
    }

    @Override
    public Entry add(Entry entry) throws FileTreatementException {
        directory.add(entry);
        return this;
    }

    @Override
    public String getName() {
        return name;
    }

    /**
     * getSize() | printList(String prefix)
     *
     * 都会递归去遍历下面可能存在的 目录或者文件的子项
     */

    @Override
    public int getSize() {
        int size=0;
        Iterator&amp;lt;Entry&amp;gt; it = directory.iterator();
        while (it.hasNext()){
            // 这里的Entry 可能是目录 也可能是文件
            Entry next = it.next();
            size+=next.getSize();
        }

        return size;
    }

    @Override
    protected void printList(String prefix) {
        // 这里的 prefix是一个引用 this将会调用tostring()方法 又会继续调用getName() getSize()方法
        System.out.println(prefix+&quot;/&quot;+this);
        Iterator&amp;lt;Entry&amp;gt; it = directory.iterator();
        while(it.hasNext()){
            // 这里的Entry 可能是目录 也可能是文件
            Entry next = it.next();
            next.printList(prefix+&quot;/&quot;+this);
        }
    }
}


&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;FileTreatementException&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
public class FileTreatementException extends Exception {

    public FileTreatementException() {
    }

    public FileTreatementException(String message) {
        super(message);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;定义的目的结构：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;start +++++++++++
/root(16000)
/root(16000)/bin(16000)
/root(16000)/bin(16000)/vi(1000)
/root(16000)/bin(16000)/notepaid(15000)
/root(16000)/temp(0)
/root(16000)/user(0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class MainT {

    public static void main(String[] args) throws FileTreatementException{

        System.out.println(&quot;start +++++++++++&quot;);

        Directory rootdir=new Directory(&quot;root&quot;);

        Directory bindir = new Directory(&quot;bin&quot;);
        Directory tempdir = new Directory(&quot;temp&quot;);
        Directory userdir = new Directory(&quot;user&quot;);

        rootdir.add(bindir);
        rootdir.add(tempdir);
        rootdir.add(userdir);

        bindir.add(new File(&quot;vi&quot;,1000));
        bindir.add(new File(&quot;notepaid&quot;,15000));

        rootdir.printList();
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 23 Oct 2018 14:58:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<og:description>Composite 设计模式？ 在计算机的文件系统中，有“文件夹”的概念（在有些操作系统（Linux操作系统）中，也称为“目录”）。文件夹里面既可以放入文件，也可以放入其他文件夹（子文件夹）。在子文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/9840291.html</dc:identifier>
</item>
<item>
<title>Spring 学习01 - pony1223</title>
<link>http://www.cnblogs.com/pony1223/p/9840268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pony1223/p/9840268.html</guid>
<description>&lt;p&gt;1 spring是开源的轻量级框架&lt;/p&gt;
&lt;p&gt;2 spring核心主要两部分：&lt;/p&gt;
&lt;p&gt;（1）aop：面向切面编程，扩展功能不是修改源代码实现&lt;/p&gt;
&lt;p&gt;（2）ioc：控制反转，&lt;/p&gt;
&lt;p&gt;- 比如有一个类，在类里面有方法（不是静态的方法），调用类里面的方法，创建类的对象，使用对象调用方法，创建类对象的过程，需要new出来对象&lt;/p&gt;
&lt;p&gt;- 把对象的创建不是通过new方式实现，而是交给spring配置创建类对象&lt;/p&gt;
&lt;p&gt;3 spring是一站式框架&lt;/p&gt;
&lt;p&gt;（1）spring在javaee三层结构中，每一层都提供不同的解决技术&lt;/p&gt;
&lt;p&gt;- web层：springMVC&lt;/p&gt;
&lt;p&gt;- service层：spring的ioc&lt;/p&gt;
&lt;p&gt;- dao层：spring的jdbcTemplate&lt;/p&gt;
&lt;p&gt;4 spring版本&lt;/p&gt;
&lt;p&gt;（1）hibernate5.x&lt;/p&gt;
&lt;p&gt;（2）spring4.x&lt;/p&gt;

&lt;p&gt;1 把对象的创建交给spring进行管理&lt;/p&gt;
&lt;p&gt;2 ioc操作两部分：&lt;/p&gt;
&lt;p&gt;（1）ioc的配置文件方式&lt;/p&gt;
&lt;p&gt;（2）ioc的注解方式&lt;/p&gt;

&lt;p&gt;1 ioc底层原理使用技术&lt;/p&gt;
&lt;p&gt;（1）xml配置文件&lt;/p&gt;
&lt;p&gt;（2）dom4j解决xml&lt;/p&gt;
&lt;p&gt;（3）工厂设计模式&lt;/p&gt;
&lt;p&gt;（4）反射&lt;/p&gt;
&lt;p&gt;2 画图分析ioc实现原理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223437933-1481605296.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第一步 导入jar包&lt;/p&gt;
&lt;p&gt;（1）解压资料zip文件&lt;/p&gt;
&lt;p&gt;Jar特点：都有三个jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223531660-1517566117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223538381-1916802095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）做spring最基本功能时候，导入四个核心的jar包就可以了&lt;/p&gt;
&lt;p&gt;（3）导入支持日志输出的jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223552589-187325623.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步 创建类，在类里面创建方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223615673-402888542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三步 创建spring配置文件，配置创建类&lt;/p&gt;
&lt;p&gt;（1）spring核心配置文件名称和位置不是固定的&lt;/p&gt;
&lt;p&gt;- 建议放到src下面，官方建议applicationContext.xml&lt;/p&gt;
&lt;p&gt;（2）引入schema约束&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223635881-1391547452.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223641255-945994850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）配置对象创建&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223651719-1715751927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第四步 写代码测试对象创建&lt;/p&gt;
&lt;p&gt;（1）这段代码在测试中使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223706991-1471186601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1 spring引入schema约束，把约束文件引入到eclipse中&lt;/p&gt;
&lt;p&gt;（1）复制约束路径&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223743602-44259373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223751810-1288888922.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;1.Bean实例化的方式&lt;/h2&gt;
&lt;p&gt;1 在spring里面通过配置文件创建对象&lt;/p&gt;
&lt;p&gt;2 bean实例化三种方式实现&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一种 使用类的无参数构造创建（重点）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223937495-1351680771.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;类里面没有无参数的构造，出现异常&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023223949081-16554937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二种 使用静态工厂创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）创建静态的方法，返回类对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224006390-681547141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224016338-2118945765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三种 使用实例工厂创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）创建不是静态的方法，返回类对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224053678-1163742822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224101323-1028454901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.Bean标签常用属性&lt;/h2&gt;
&lt;p&gt;（1）id属性：起名称，id属性值名称任意命名&lt;/p&gt;
&lt;p&gt;- id属性值，不能包含特殊符号&lt;/p&gt;
&lt;p&gt;- 根据id值得到配置对象&lt;/p&gt;
&lt;p&gt;（2）class属性：创建对象所在类的全路径&lt;/p&gt;
&lt;p&gt;（3）name属性：功能和id属性一样的，id属性值不能包含特殊符号，但是在name属性值里面可以包含特殊符号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（4）scope属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;- singleton：默认值，单例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224246991-1920738706.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224253271-918904367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; prototype：多例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224307053-1353064249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;- request：创建对象把对象放到request域里面&lt;/p&gt;
&lt;p&gt;- session：创建对象把对象放到session域里面&lt;/p&gt;
&lt;p&gt;- globalSession：创建对象把对象放到globalSession里面&lt;/p&gt;

&lt;p&gt;1 创建对象时候，向类里面属性里面设置值&lt;/p&gt;
&lt;p&gt;2 属性注入的方式介绍（三种方式）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）使用set方法注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）使用有参数构造注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）使用接口注入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224500278-503250059.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3 在spring框架里面，支持前两种方式&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;（1）set方法注入（重点）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）有参数构造注入&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;使用有参数构造注入属性&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224554802-269351005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224608037-274084728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;使用set方法注入属性（重点）&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224626277-399144596.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224633278-1699850367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1 创建service类和dao类&lt;/p&gt;
&lt;p&gt;（1）在service得到dao对象&lt;/p&gt;
&lt;p&gt;2 具体实现过程&lt;/p&gt;
&lt;p&gt;（1）在service里面把dao作为类型属性&lt;/p&gt;
&lt;p&gt;（2）生成dao类型属性的set方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224740487-574933007.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）配置文件中注入关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224754448-74685792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224856503-1633688160.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023224903636-386827805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;1 数组&lt;/p&gt;
&lt;p&gt;2 list集合&lt;/p&gt;
&lt;p&gt;3 map集合&lt;/p&gt;
&lt;p&gt;4 properties类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注入复杂类型属性值 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;person&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.itcast.property.Person&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 数组 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;arrs&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小王&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小马&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小宋&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; list &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;list&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小奥&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小金&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小普&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;            
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; map &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;map&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;aa&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;lucy&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;bb&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;mary&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;entry &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;cc&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;tom&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;entry&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; properties &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;properties&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;driverclass&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.mysql.jdbc.Driver&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;prop &lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;root&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;prop&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;props&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（1）IOC: 控制反转，把对象创建交给spring进行配置&lt;/p&gt;
&lt;p&gt;（2）DI: 依赖注入，向类里面的属性中设置值&lt;/p&gt;
&lt;p&gt;（3）关系：依赖注入不能单独存在，需要在ioc基础之上完成操作&lt;/p&gt;

&lt;p&gt;1 加载spring核心配置文件，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/401339/201810/401339-20181023225154082-852321699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（1）new对象，功能可以实现，效率很低&lt;/p&gt;
&lt;p&gt;2 实现思想：把加载配置文件和创建对象过程，在服务器启动时候完成&lt;/p&gt;

&lt;p&gt;3 实现原理&lt;/p&gt;
&lt;p&gt;（1）ServletContext对象&lt;/p&gt;
&lt;p&gt;（2）监听器&lt;/p&gt;
&lt;p&gt;（3）具体使用：&lt;/p&gt;
&lt;p&gt;- 在服务器启动时候，为每个项目创建一个ServletContext对象&lt;/p&gt;
&lt;p&gt;- 在ServletContext对象创建时候，使用监听器可以具体到ServletContext对象在什么时候创建&lt;/p&gt;
&lt;p&gt;- 使用监听器监听到ServletContext对象创建时候，&lt;/p&gt;
&lt;p&gt;-- 加载spring配置文件，把配置文件配置对象创建&lt;/p&gt;
&lt;p&gt;-- 把创建出来的对象放到ServletContext域对象里面（setAttribute方法）&lt;/p&gt;
&lt;p&gt;- 获取对象时候，到ServletContext域得到 （getAttribute方法）&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;《黑马程序员》&lt;/p&gt;
</description>
<pubDate>Tue, 23 Oct 2018 14:55:00 +0000</pubDate>
<dc:creator>pony1223</dc:creator>
<og:description>一、Spring概念 1 spring是开源的轻量级框架 2 spring核心主要两部分： （1）aop：面向切面编程，扩展功能不是修改源代码实现 （2）ioc：控制反转， - 比如有一个类，在类里面</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pony1223/p/9840268.html</dc:identifier>
</item>
<item>
<title>【论文阅读】Deep Adversarial Subspace Clustering - 我若成风者</title>
<link>http://www.cnblogs.com/EstherLjy/p/9840016.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/EstherLjy/p/9840016.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;导读：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本文为CVPR2018论文《Deep Adversarial Subspace Clustering》的阅读总结。目的是做聚类，方法是DASC=DSC（Deep Subspace Clustering）+GAN（Generative Adversarial Networks）。本文从以下四个方面来对论文做个简要整理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;背景：&lt;/strong&gt;简要介绍与本文密切相关的基础原理，DSC，GAN。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;方法：&lt;/strong&gt;介绍论文使用的方法和细节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;实验&lt;/strong&gt;：实验结果和简要分析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;总结：&lt;/strong&gt;论文主要特色和个人体会。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;一、背景&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　论文方法DASC（深度对抗聚类）是基于DSC（深度子空间聚类）和GAN（生成对抗网络）的，所以，在介绍论文方法之前，对DSC和GAN做个简要介绍。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;1.DSC&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;1）原理（LRR）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　首先要明确的是，整个论文的大方向是做聚类。做聚类以往已经有非常多的方法，最近几年比较流行也即DSC所采用的理论基石是低秩表示（LRR）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　LRR理论基本思想是，对于一个数据（如图像或图像特征等）可以表示为干净数据部分和噪声部分，其中干净数据部分又可以采用字典和系数表示的形式，此时要求干净数据的系数表示部分是低秩的，噪声部分是稀疏的。此时，如果用数据本身作为字典，那么其系数部分就可以描述原始数据间的相似度。用数学公式表示如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023200724867-2042546461.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　其中，X=[x&lt;sub&gt;1&lt;/sub&gt;,x&lt;sub&gt;2&lt;/sub&gt;,...x&lt;sub&gt;n&lt;/sub&gt;]∈R&lt;sup&gt;d*n&lt;/sup&gt;表示原始输入数据（一般是图像的特征），Z∈R&lt;sup&gt;n*n&lt;/sup&gt;表示系数部分，E∈R&lt;sup&gt;d*n&lt;/sup&gt;表示噪声。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那么这个式子与聚类有什么关系呢？&lt;span&gt;关系是，假设待聚类的数据分布于多个线性子空间，那么通过求解上述式子的最小化问题，我们可以得到数据X间的相似度矩阵Z，有了相似度矩阵我们就可以对输入数据X=[x&lt;sub&gt;1&lt;/sub&gt;,x&lt;sub&gt;2&lt;/sub&gt;,...x&lt;sub&gt;n&lt;/sub&gt;]进行聚类。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　因此，实现对多个d维数据x&lt;sub&gt;i&lt;/sub&gt;的聚类，LRR方法采用的方法是，将x&lt;sub&gt;i&lt;/sub&gt;按列组合成X，然后通过优化上述式子，得到Z，最后将Z输入到谱聚类算法中，就可以得到最终的聚类结果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;2）方法（网络）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　一般来说，对于图像做聚类，我们采用的方法是，对图像提取特征，然后得到特征表示，组成X，然后采用LRR原理进行聚类。但是这种先提取特征再进行聚类的缺点是一个两阶段的过程，两者不能互相促进。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　因此DSC将特征提取和相似度矩阵的学习融入到一个网络中进行统一学习。重新定义符号表示，用X表示输入数据，Z表示特征，θ表示待学习的参数相似度矩阵，那么DSC的学习是最优化下面的式子：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　min ||Z-Zθ||F+λ||θ||F，以求得参数Z和θ。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　网络整体结构如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023205848051-317685050.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;上图所示，输入图像X，经过两层编码器进行编码（即特征转换），得到特征表示Z，然后将Z reshape成一个列向量，然后与后面变量Zθ进行全连接，再将Zθ重新reshape成与前面相对应的大小，再经过两个解码层，得到恢复出的图像。即，原图-&amp;gt;编码得特征-&amp;gt;解码得原图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;　　3）设计&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　DSC重点主要是Loss的设计，Loss由重建损失、参数正则损失、自表示损失几部分组成：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023211250895-929355003.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;2.GAN&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　&lt;strong&gt;　1）原理&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023211519259-2027577176.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　GAN由一个生成器和一个判别器组成。其中，生成器负责生成数据，从真实的数据中生成假的数据，期望假的数据越逼真越好。判别器负责判断接收到的数据是真实的还是产生的，即一个二分类器，期望效果比较好，也就是说真实的数据判别为真的概率更大，假的数据判别为真的概率更小。所以，在生成器期望生成的数据逼真到能够欺骗判别器而判别器期望判别能力强的情况下，通过两者的博弈，来达到生成数据能够模拟真实数据的效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;2）设计&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　实现GAN主要是通过Loss的设计，D的输出为数据被判定为真实数据的概率，整体Loss如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023212325668-1809181585.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　优化D：&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023212427639-1118700760.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　优化G：&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023212505566-941055626.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于上述Loss的解释是，优化判别器D时，希望D判别能力强，那么就希望真实数据被判定为真的概率大，所以&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023212757947-1061554669.jpg&quot; alt=&quot;&quot; width=&quot;232&quot; height=&quot;41&quot;/&gt;应该比较大，&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023212822370-141020961.jpg&quot; alt=&quot;&quot; width=&quot;286&quot; height=&quot;34&quot;/&gt;应该比较小，所以是最大化V（D，G）。优化产生器时，期望伪造数据比较真，那么就希望Z为伪造品时，D（G（Z））比较大，也即&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023213033795-1935425564.jpg&quot; alt=&quot;&quot;/&gt;比较小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　更多关于GAN的解释可见其他博客，这里不做更详细的解释。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;3）作用&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　使得伪造的数据足够逼真，比如从噪声数据，逐步学习，得到人脸数据等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;3.DASC&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　上面介绍完了DAC和GAN，我们知道DSC已经可以做聚类了，而且聚类算比较好的了，那么还能不能再提高呢？答案是可以。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　我们知道，DSC是一步一步训练得到Z来做聚类，其中有个问题是，我们并不确定迭代到多少次效果比较好，也不能确定下次迭代就比上次得到的Z好，那么有没有什么方法能够指导无监督网络DSC的学习，让网络的训练每次都朝着效果更好的方向训练呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　这就是DASC所做的工作了，基础思想是，用GAN来指导DSC的学习，使其每次都朝着效果更好的方向发展。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、方法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本章介绍DASC的方法，从原理、生成器、判别器、训练这四个部分分别进行探讨。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;1）原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　用GAN指导DSC的学习，就需要明确下面两个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　一是，把处于同一子空间的数据，进行线性组合得到新的数据，那么新的数据依然处于该子空间。反之，处于不同子空间的数据，进行线性组合得到的数据跟原始数据处在不同子空间。（可以从下图看出）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023214939474-389380133.png&quot; alt=&quot;&quot; width=&quot;460&quot; height=&quot;241&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　二是，处在同一子空间的数据，判别器（即分类器）分辨不出是真实数据还是伪造的数据，即输出概率为0.5。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　通过一二知，聚类效果比较好-&amp;gt;新数据依然处于该子空间-&amp;gt;判别器无法判别真假。即，判别器越无法判断真假数据，说明聚类效果越好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以，我们要做的任务就是，通过生成器得到正（真实数据）次（线性组合得到的伪造数据）品，输入到判别器中，经过对抗学习，得到更好的相似度矩阵θ和特征表达Z，从而来得到最终的聚类结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023215418280-42416868.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　其中，生成器G包括DSC和正次品采样层。下面的DSC得到中间聚类结果后，将Z输入给采样层，采样层得到正次品输入给判别器D。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;2）生成器&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　生成器的操作步骤是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　11）聚类得到C&lt;sub&gt;i&lt;/sub&gt;和特征表示z&lt;sub&gt;i&lt;/sub&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　22）计算类C&lt;sub&gt;i&lt;/sub&gt;中z&lt;sub&gt;i&lt;/sub&gt;到相对应的子空间S&lt;sub&gt;i&lt;/sub&gt;的投影残差L&lt;sub&gt;r&lt;/sub&gt;。其中S&lt;sub&gt;i&lt;/sub&gt;是由投影矩阵U&lt;sub&gt;i&lt;/sub&gt;来表示的，U&lt;sub&gt;i&lt;/sub&gt;（或者说S&lt;sub&gt;i&lt;/sub&gt;）是判别器学习得到的，与生成器的学习无关。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023220118217-1514083914.png&quot; alt=&quot;&quot; width=&quot;255&quot; height=&quot;32&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　33）选择投影残差L&lt;sub&gt;r&lt;/sub&gt;最小的80%~90%的Ci中的数据作为正品。（因为经过DSC大部分的数据已经是正确的。这里还可以起到去噪的作用）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　44）随机线性组合计算得到与正品同样数量的次品。其中α来于[0-1]中的随机数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023220633993-381547809.png&quot; alt=&quot;&quot; width=&quot;335&quot; height=&quot;40&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　55）将正次品输给判别器D。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023215832615-242570166.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;3）判别器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　11）学习的参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　学习的参数为子投影矩阵U&lt;sub&gt;i&lt;/sub&gt;(代表子空间S&lt;sub&gt;i&lt;/sub&gt;),用子空间来判别是正品还是次品。原则是，投影残差L&lt;sub&gt;r&lt;/sub&gt;越小，说明是正品（文章中说能量越小）的概率越大，对判别器来说Loss的输出也应该越小。反之Loss就越大。所以投影残差L&lt;sub&gt;r&lt;/sub&gt;即与Loss成反比。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023221032840-373200963.png&quot; alt=&quot;&quot; width=&quot;295&quot; height=&quot;38&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　22）优化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　经过上述分析，直接给出Loss优化如下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023221555468-1806092355.png&quot; alt=&quot;&quot; width=&quot;348&quot; height=&quot;96&quot;/&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023221605883-628787633.png&quot; alt=&quot;&quot; width=&quot;287&quot; height=&quot;69&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023221647698-430491565.png&quot; alt=&quot;&quot; width=&quot;242&quot; height=&quot;40&quot;/&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023221654565-477086462.png&quot; alt=&quot;&quot; width=&quot;295&quot; height=&quot;35&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023221723376-888628272.png&quot; alt=&quot;&quot; width=&quot;229&quot; height=&quot;56&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　33）细节&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　投影矩阵U&lt;sub&gt;i&lt;/sub&gt;和类簇C&lt;sub&gt;i&lt;/sub&gt;并不是一一对应的关系，因为每次更新都需要找一下是否子空间投影矩阵是否有变化，所以需要C&lt;sub&gt;i&lt;/sub&gt;进行竞争U&lt;sub&gt;i&lt;/sub&gt;。竞争的方式是，对每个类簇计算平均投影残差，然后选择具有最小平均残差的U&lt;sub&gt;i&lt;/sub&gt;作为自己的投影矩阵。如果该U&lt;sub&gt;i&lt;/sub&gt;具有更小平均投影残差的类簇，那么原类簇则采用对Z进行QR分解来得到自己的U&lt;sub&gt;i&lt;/sub&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　判别器采用两层全连接感知机。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;4）训练&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　11）DSC预训练初始化DASC网络。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　22）用Z&lt;sub&gt;i&lt;/sub&gt;的QR分解初始化U&lt;sub&gt;i&lt;/sub&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　33）联合交替更新DASC中的D和G，其中D更新五次，G更新一次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、实验&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　直接贴结果吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023222605755-778692214.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023222555136-224902851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023222618293-2016192363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/902717/201810/902717-20181023222628436-1071589468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1.该文章采用了DSC+GAN的方式，是GAN在无监督聚类上的首次成功运用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2.文章对无监督的聚类进行了定性的评估：线性组合在同一子空间（不能被判别器正确识别）说明聚类效果好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.文章对无监督聚类进行了定量的评估：据子空间的投影残差越小说明属于真实数据的概率越大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.在写作方面，文章采用比较新颖刁钻的方式。比如，把投影距离称为能量大小，把线性组合称为新子空间采样。换汤不换药，还显得很好喝，就比较骚了。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Oct 2018 14:33:00 +0000</pubDate>
<dc:creator>我若成风者</dc:creator>
<og:description>导读： 本文为CVPR2018论文《Deep Adversarial Subspace Clustering》的阅读总结。目的是做聚类，方法是DASC=DSC（Deep Subspace Cluste</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/EstherLjy/p/9840016.html</dc:identifier>
</item>
<item>
<title>CAS单点登录原理简单介绍 - javahih</title>
<link>http://www.cnblogs.com/mzq123/p/9839862.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/9839862.html</guid>
<description>&lt;h2 id=&quot;sso简介&quot;&gt;1. SSO简介&lt;/h2&gt;
&lt;h3 id=&quot;单点登录定义&quot;&gt;1.1 单点登录定义&lt;/h3&gt;
&lt;p&gt;单点登录(Single sign on)，英文名称缩写SSO，SSO的意思就是在多系统的环境中，登录单方系统，就可以在不用再次登录的情况下访问相关受信任的系统。也就是说只要登录一次单体系统就可以。计划在项目中加入单点登录，开发中，&lt;a href=&quot;https://github.com/u014427391/taoshop&quot;&gt;taoshop&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;单点登录角色&quot;&gt;1.2 单点登录角色&lt;/h3&gt;
&lt;p&gt;单点登录一般包括下面三种角色：&lt;/p&gt;
&lt;p&gt;①用户(多个)；&lt;/p&gt;
&lt;p&gt;②认证中心(一个)；&lt;/p&gt;
&lt;p&gt;③Web应用(多个)。&lt;/p&gt;
&lt;p&gt;PS：这里所说的web应用可以理解为SSO Client，认证中心可以说是SSO Server。&lt;/p&gt;
&lt;h3 id=&quot;section&quot;/&gt;
&lt;h2 id=&quot;cas简介&quot;&gt;2. CAS简介&lt;/h2&gt;
&lt;h3 id=&quot;cas简单定义&quot;&gt;2.1 CAS简单定义&lt;/h3&gt;
&lt;p&gt;CAS(Center Authentication Service)是耶鲁大学研究的一款开源的单点登录项目，主要为web项目提供单点登录实现，&lt;strong&gt;属于Web SSO&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;cas体系结构&quot;&gt;2.2 CAS体系结构&lt;/h3&gt;
&lt;p&gt;CAS体系结构分为CAS Server和CAS Client。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180902172712501?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MjczOTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;PS：图来自官网&lt;/p&gt;
&lt;h3 id=&quot;cas原理&quot;&gt;2.3 CAS原理&lt;/h3&gt;
&lt;p&gt;下面给出一张来自CAS官方的图片&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180826231806797?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MjczOTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;br/&gt;CAS登录等系统分为CAS Server和CAS Client，下面，我根据我的理解稍微解释一下：&lt;/p&gt;
&lt;p&gt;1、用户访问CAS Client请求资源&lt;/p&gt;
&lt;p&gt;2、客户端程序做了重定向，重定向到CAS Server&lt;/p&gt;
&lt;p&gt;3、CAS Server会对请求做认证&lt;/p&gt;
&lt;p&gt;4、认证通过后会生成一个Ticket返回Cas Client&lt;/p&gt;
&lt;p&gt;5、然后Cas Client就带着Ticket再次访问Cas Server，CAS Server进行Ticket验证&lt;/p&gt;
&lt;p&gt;6、CAS Server对Ticket进行再次验证，然后通过就返回用户信息，用户拿到信息后就可以登录&lt;/p&gt;
&lt;p&gt;看到这个过程，我们大概就能理解CAS是怎么实现的，看起来过程挺多的，不过这些过程都是CAS在后台做的&lt;/p&gt;
&lt;h3 id=&quot;cas单点登录&quot;&gt;CAS单点登录&lt;/h3&gt;
&lt;p&gt;现在博客简单介绍一下，CAS Server简单部署实现，CAS是一款开源框架，目前应用比较广泛。下面简单介绍一下：&lt;br/&gt;cas开源到github上，不过只有几个版本有cas release服务端，其它大部分版本都只有source源码而已，所以其它版本都需要自己编译，不想自己编译的可以下载V4.0.0版本的。&lt;br/&gt;&lt;a href=&quot;https://github.com/apereo/cas/releases/tag/v4.0.0&quot; class=&quot;uri&quot;&gt;https://github.com/apereo/cas/releases/tag/v4.0.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载cas server之后，我们就可以简单部署一下，中间件可以用Tomcat&lt;br/&gt;cas的安全机制是依靠SSL实现的，所以一般的http非安全链接不支持的，虽然是这么说，不过学习练习的话，也可以去掉https要求，下面介绍说一下：&lt;/p&gt;
&lt;p&gt;可以先将cas-server-4.0.0-release.zip解压到Tomcat的webapp目录下面，然后需要修改一个配置文件&lt;br/&gt;(1)、先修改一下cas-server-4.0.0-release的WEB-INF下面的deployerConfigContext.xml&lt;br/&gt;修改前：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- Required for proxy ticket mechanism. --&amp;gt;
    &amp;lt;bean id=&quot;proxyAuthenticationHandler&quot;
          class=&quot;org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler&quot;
          p:httpClient-ref=&quot;httpClient&quot;  /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改后，PS：加上p:requireSecure=&quot;false&quot;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;proxyAuthenticationHandler&quot;  
          class=&quot;org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler&quot;  
          p:httpClient-ref=&quot;httpClient&quot; p:requireSecure=&quot;false&quot;/&amp;gt;&amp;lt;/code&amp;gt;  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2)、修改WEB-INF下面的spring-configuration文件夹下面的ticketGrantingTicketCookieGenerator.xml&lt;br/&gt;修改前：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;ticketGrantingTicketCookieGenerator&quot; class=&quot;org.jasig.cas.web.support.CookieRetrievingCookieGenerator&quot;
        p:cookieSecure=&quot;true&quot;
        p:cookieMaxAge=&quot;-1&quot;
        p:cookieName=&quot;CASTGC&quot;
        p:cookiePath=&quot;/cas&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改后，PS：改为p:cookieSecure=&quot;false&quot;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;ticketGrantingTicketCookieGenerator&quot; class=&quot;org.jasig.cas.web.support.CookieRetrievingCookieGenerator&quot;
        p:cookieSecure=&quot;false&quot;
        p:cookieMaxAge=&quot;-1&quot;
        p:cookieName=&quot;CASTGC&quot;
        p:cookiePath=&quot;/cas&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3)、修改WEB-INF下面的spring-configuration文件夹下面的warnCookieGenerator.xml&lt;br/&gt;修改前：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;warnCookieGenerator&quot; class=&quot;org.jasig.cas.web.support.CookieRetrievingCookieGenerator&quot;
        p:cookieSecure=&quot;true&quot;
        p:cookieMaxAge=&quot;-1&quot;
        p:cookieName=&quot;CASPRIVACY&quot;
        p:cookiePath=&quot;/cas&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改后，PS：改为p:cookieSecure=&quot;false&quot;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;bean id=&quot;warnCookieGenerator&quot; class=&quot;org.jasig.cas.web.support.CookieRetrievingCookieGenerator&quot;
        p:cookieSecure=&quot;false&quot;
        p:cookieMaxAge=&quot;-1&quot;
        p:cookieName=&quot;CASPRIVACY&quot;
        p:cookiePath=&quot;/cas&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(4)、修改CAS默认登录jsp页面&lt;br/&gt;可以注释WEB-INF\view\jsp\default\ui\casLoginView.jsp页面如下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;c:if test=&quot;${not pageContext.request.secure}&quot;&amp;gt;
  &amp;lt;div id=&quot;msg&quot; class=&quot;errors&quot;&amp;gt;
    &amp;lt;h2&amp;gt;Non-secure Connection&amp;lt;/h2&amp;gt;
    &amp;lt;p&amp;gt;You are currently accessing CAS over a non-secure connection.  Single Sign On WILL NOT WORK.  In order to have single sign on work, you MUST log in over HTTPS.&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/c:if&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;去掉Https支持要求后，就可以通过http的链接登录cas server了，用户名是casuser，密码是Mellon&lt;br/&gt;PS：可以在deployerConfigContext.xml里看到配置，正规项目是实现jdbc支持&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;bean id=&quot;primaryAuthenticationHandler&quot;
          class=&quot;org.jasig.cas.authentication.AcceptUsersAuthenticationHandler&quot;&amp;gt;
        &amp;lt;property name=&quot;users&quot;&amp;gt;
            &amp;lt;map&amp;gt;
                &amp;lt;entry key=&quot;casuser&quot; value=&quot;Mellon&quot;/&amp;gt;
            &amp;lt;/map&amp;gt;
        &amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;登录成功&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180902172346954?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0MjczOTE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;待续...，PS：找时间继续写...&lt;/p&gt;
&lt;h3 id=&quot;附录&quot;&gt;附录&lt;/h3&gt;
&lt;p&gt;PS：参考学习教程&lt;/p&gt;
&lt;p&gt;单点登录实现方式：&lt;br/&gt;&lt;a href=&quot;https://cnodejs.org/topic/55f6e69904556da7553d20dd&quot;&gt;单点登录的三种实现方式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SpringBoot集成Cas&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/cl_andywin/article/details/53998986&quot;&gt;SpringBoot集成CAS&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/catoop/article/details/50534006&quot;&gt;Spring Boot 集成Shiro和CAS&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://my.oschina.net/marvelcode/blog/1576104&quot;&gt;基于Spring Boot的单点登录&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaojf/p/6619060.html&quot;&gt;springboot + shiro + cas4.2.7 实战&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CAS单点登录教程：&lt;br/&gt;&lt;a href=&quot;http://www.coin163.com/java/cas/index.html&quot;&gt;Cas专题文章列表&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.csdn.net/zzq900503/article/details/54693267&quot;&gt;测试认证方式搭建CAS&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zhoubang521/p/5200407.html&quot;&gt;SSO之单点登录详细搭建教程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/gzseehope/article/details/72914188&quot;&gt;CAS实现SSO单点登录原理&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/opensource/os-cn-cas/index.html&quot;&gt;使用 CAS 在 Tomcat 中实现单点登录&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Oct 2018 14:25:00 +0000</pubDate>
<dc:creator>javahih</dc:creator>
<og:description>1. SSO简介 1.1 单点登录定义 单点登录(Single sign on)，英文名称缩写SSO，SSO的意思就是在多系统的环境中，登录单方系统，就可以在不用再次登录的情况下访问相关受信任的系统。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mzq123/p/9839862.html</dc:identifier>
</item>
<item>
<title>Ocelot简易教程（六）之重写配置文件存储方式并优化响应数据 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/9839863.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/9839863.html</guid>
<description>&lt;p&gt;本来这篇文章在昨天晚上就能发布的，悲剧的是写了两三千字的文章居然没保存，结果我懵逼了。今天重新来写这篇文章。今天我们就一起来探讨下如何重写Ocelot配置文件的存储方式以及获取方式。&lt;/p&gt;
&lt;blockquote readability=&quot;8.9939393939394&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9807125.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/9807125.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很多人都说配置文件的配置很繁琐，如果存储在数据库就方便很多，可以通过自定义UI界面在后台进行路由的配置，然后通过调用Administration API让修改后的路由规则立即生效。当然这都是后话了。今天就教你手把手的来把配置文件放到数据库中，然后在数据库中进行路由的配置。当然，我会在Github上开放源代码供大家参考。至于Nuget包的话，今天还没来得及弄，等明天晚上弄好，再发布Nuget包吧，今天先引用下源代码来使用吧。大家委屈一下吧。本文还是沿用之前的系列文章里面的Demo。所以可以先下载之前系列文章里面的Demo源码。&lt;a href=&quot;https://github.com/yilezhu/OcelotDemo&quot; class=&quot;uri&quot;&gt;https://github.com/yilezhu/OcelotDemo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;实例教程集成步骤&quot;&gt;实例教程集成步骤&lt;/h2&gt;
&lt;ol readability=&quot;-0.75454545454545&quot;&gt;&lt;li readability=&quot;0.75454545454545&quot;&gt;
&lt;p&gt;Github上下载重写的配置文件的源代码，地址：&lt;a href=&quot;https://github.com/yilezhu/Ocelot.ConfigAuthLimitCache&quot; class=&quot;uri&quot;&gt;https://github.com/yilezhu/Ocelot.ConfigAuthLimitCache&lt;/a&gt; 然后把项目文件拷贝到。系列文章的源代码下面，并添加项目引用。如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201810/1377250-20181023222341045-611883175.png&quot; alt=&quot;1540302626763&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;项目添加进来后的结构如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201810/1377250-20181023222340531-2035653599.png&quot; alt=&quot;1540302716406&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;13.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;OcelotDemo网关项目作如下修改，Programs.cs文件移除对Ocelot.json文件的引用，因为配置文件的获取方式已经改成了从数据库中获取，所以，你需要新建一个数据库，然后执行数据库脚本创建数据库表，这里只给出Mssql的数据库脚本，在项目源代码下面，大家自行下载。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.5&quot;&gt;
&lt;p&gt;ConfigureServices服务中Ocelot的注入的同时需要注入我们的扩展方法，如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.AddOcelot()//注入Ocelot服务
                    .AddAuthLimitCache(option=&amp;gt; {
                        option.DbConnectionStrings = &quot;Server=.;Database=Ocelot;User ID=sa;Password=1;&quot;;
                    })
                    .AddConsul();&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：这里需要传入SqlServer的数据库连接字符串，由于博主扩展使用的Dapper+MSSQL所以这里需要传入步骤2中创建的数据库的链接字符串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;我们在数据库中配置一个路由吧，如下所示：字段名称基本都是跟Ocelot原生配置名称一样，只是扩展了一些字段方便后期做限流的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201810/1377250-20181023222340182-1837600611.png&quot; alt=&quot;1540303270834&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家看到没有，这条路由的意思是接受/ss1/{通配符} 的路由，然后转到到下面就是/api/{通配符} 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;路由配置好了，那就让我们启动一下项目看下效果吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201810/1377250-20181023222339859-844164595.png&quot; alt=&quot;1540303513128&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;上面是正常的访问结果，当我们访问一个错误的路由的时候，再看看吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201810/1377250-20181023222339374-1584876328.png&quot; alt=&quot;1540304187258&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到没有，返回了404的状态码，感觉不够友好，所以，我们也进行了改造。直接看结果吧&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;为了看到效果，你需要在Configure中少做下修改&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; app.UseAhphOcelot().Wait();&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;然后我们重新启动下Ocelot网关项目，重新访问下6中的Url吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201810/1377250-20181023222338410-161695171.png&quot; alt=&quot;1540304235799&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到没有，返回的数据更友好，而且是200的状态。当然大家也可以忽略这个功能哈。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;源码地址&quot;&gt;源码地址：&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Demo地址:&lt;a href=&quot;https://github.com/yilezhu/OcelotDemo&quot; class=&quot;uri&quot;&gt;https://github.com/yilezhu/OcelotDemo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;扩展插件地址：&lt;a href=&quot;https://github.com/yilezhu/Ocelot.ConfigAuthLimitCache&quot; class=&quot;uri&quot;&gt;https://github.com/yilezhu/Ocelot.ConfigAuthLimitCache&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文主要通过实例讲述如何集成，将配置文件存储到数据库的插件。源码已经开源，今天暂时没有发布Nuget包，明天再发布吧。当然你可以自行扩展代码。实现你自己的业务。我把配置文件存储到数据库的目的就是方便后面做UI管理方便，还有就是可以基于这些路由在数据库中对每个客户端进行单独的限流。最后感谢大家的阅读。&lt;/p&gt;
&lt;h2 id=&quot;ocelot简易教程目录&quot;&gt;Ocelot简易教程目录&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9557375.html&quot;&gt;Ocelot简易教程（一）之Ocelot是什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9563188.html&quot;&gt;Ocelot简易教程（二）之快速开始1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9638417.html&quot;&gt;Ocelot简易教程（二）之快速开始2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9664977.html&quot;&gt;Ocelot简易教程（三）之主要特性及路由详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9695639.html&quot;&gt;Ocelot简易教程（四）之请求聚合以及服务发现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9807125.html&quot;&gt;Ocelot简易教程（五）之集成IdentityServer认证以及授权&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/9839863.html&quot;&gt;Ocelot简易教程（六）之重写配置文件存储方式并优化响应数据&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 23 Oct 2018 14:25:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>本来这篇文章在昨天晚上就能发布的，悲剧的是写了两三千字的文章居然没保存，结果我懵逼了。今天重新来写这篇文章。今天我们就一起来探讨下如何重写Ocelot配置文件的存储方式以及获取方式。 作者：依乐祝 原</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/9839863.html</dc:identifier>
</item>
</channel>
</rss>