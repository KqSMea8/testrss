<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Web桌面应用框架3：Web桌面应用开发的N种Style - windfic</title>
<link>http://www.cnblogs.com/windfic/p/7811464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/windfic/p/7811464.html</guid>
<description>&lt;p&gt;研究Web桌面应用开发有一段时间了，总结了Web桌面应用开发的一些主流方式。&lt;/p&gt;

&lt;p&gt;一、前端Style&lt;/p&gt;
&lt;p&gt;这种方式的就是直接实现一个Web程序，再封装一个浏览器展示，相当粗暴和有效。著名的框架就是Electron和NW.js了。&lt;/p&gt;
&lt;p&gt;代表应用程序是atom。&lt;/p&gt;
&lt;p&gt;一般是基于node.js。也有其它语言的。&lt;/p&gt;
&lt;p&gt;各种前端框架的拥趸是这种Style的狂热粉丝。这里就不放Demo了。贴段代码就可以感受到它的霸气侧漏。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
app.on('ready', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建浏览器窗口。&lt;/span&gt;
  mainWindow = &lt;span&gt;new&lt;/span&gt; BrowserWindow({width: 800, height: 600&lt;span&gt;});

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载应用的 index.html&lt;/span&gt;
  mainWindow.loadURL('file://' + __dirname + '/index.html'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当 window 被关闭，这个事件会被发出&lt;/span&gt;
  mainWindow.on('closed', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;    mainWindow = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;二、炫酷Style&lt;/p&gt;
&lt;p&gt;这种方式就是在应用界面上嵌入多个Web页面，一般都是效果炫酷的Flash或动画。&lt;/p&gt;
&lt;p&gt;代表应用程序就是QQ了。&lt;/p&gt;
&lt;p&gt;各种DirectUI或换肤框架的用户都是这种模式的真爱粉。&lt;/p&gt;
&lt;p&gt;所谓尺有所短，寸有所长。把脏活累活甩锅给Web页面真是英明。各种不明觉厉的玩意儿能上的都给上了。&lt;/p&gt;
&lt;p&gt;这里我用WxPython和tornado实现了一个小小的代码编辑器的Demo。颜值担当：zTree.js和codemirror.js。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyHtmlFrame(wx.Frame): 
   
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, parent, title):
        wx.Frame.&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;(self, parent, -1, title, size = (800,600&lt;span&gt;))
        self.create_menu()
        self.Bind(wx.EVT_CLOSE, self.OnClose)

        self.statusbar &lt;/span&gt;= self.CreateStatusBar(2&lt;span&gt;)
        self.statusbar.SetStatusText(u&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;status&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, 0)
        self.statusbar.SetStatusText(u&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 1&lt;span&gt;)

        self.splitter &lt;/span&gt;= wx.SplitterWindow(self, style=&lt;span&gt;wx.SP_LIVE_UPDATE)
        self.tree &lt;/span&gt;=&lt;span&gt; wx.html2.WebView.New(self.splitter)
&lt;/span&gt;&lt;span&gt;
        self.html &lt;/span&gt;=&lt;span&gt; wx.html2.WebView.New(self.splitter)

        self.splitter.SetMinimumPaneSize(&lt;/span&gt;200&lt;span&gt;)
        self.splitter.SplitVertically(self.tree, self.html, &lt;/span&gt;300&lt;span&gt;)

        self.tree.LoadURL(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://localhost:8888/tree?v=%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;time.time())
        self.html.LoadURL(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://localhost:8888?v=%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;time.time())
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/569097/201711/569097-20171109212329559-1030756177.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;三、嵌入Style&lt;/p&gt;
&lt;p&gt;有人说所有Web项目都是开源的：（。Web的特性决定了，它的安全性（对于程序本身）很差。同时体验上也有一些限制性。&lt;/p&gt;
&lt;p&gt;所以，嵌入Style放弃了纯粹的Web程序，采取了宿主语言与JavaScript双向绑定的方式，直接操作Web页面，来换取安全性和体验上的提升。&lt;/p&gt;
&lt;p&gt;这种Style带来的开发难度的提升，使得它的狂热爱好者不多，暂时没有发现纯粹的代表应用程序 。大多是框架在做的事情。&lt;/p&gt;
&lt;p&gt;下面是我用cef-python实现的一个Demo。颜值担当：GooFlow.js。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
    check_versions()
    sys.excepthook &lt;/span&gt;= cef.ExceptHook  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; To shutdown all CEF processes on error&lt;/span&gt;
&lt;span&gt;
    settings &lt;/span&gt;=&lt;span&gt; {
         &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;product_version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyProduct/10.00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
         &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user_agent&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyAgent/20.00 MyProduct/10.00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    }
    cef.Initialize(settings&lt;/span&gt;=&lt;span&gt;settings)

    browser &lt;/span&gt;= cef.CreateBrowserSync(url=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file:///html/flow.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                    window_title&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tutorial&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    set_javascript_bindings(browser)

    cef.MessageLoop()
    cef.Shutdown()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/569097/201711/569097-20171110195509341-1701246545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;四、组件Style&lt;/p&gt;
&lt;p&gt;WEB组件，是一种由来已久的技术。最出名的就是.net平台WebForm技术，还有Java平台JSF、Tapestry等。&lt;/p&gt;
&lt;p&gt;组件式开发的优点是简单直观，开发迅速。缺点是封装严重，界面呆板。一个字：丑。相对来说，是一种被认为相当落后和有缺陷的技术。&lt;/p&gt;
&lt;p&gt;但是有意思的地方来了，&lt;/p&gt;
&lt;p&gt;如果使用Web组件开发Web桌面应用，先忽略中间过程，只看组件…桌面应用，这却是一个相当正常和悠久的技术体系了。&lt;/p&gt;
&lt;p&gt;负负得正，螺旋式上升，组件Style一下子变得高大上起来。&lt;/p&gt;
&lt;p&gt;相对于传统组件式应用，新的组件style的优势在于跨平台GUI开发成本大大降低。相当于把浏览器当成GUI Render。&lt;/p&gt;
&lt;p&gt;而且相比其它Style，安全性，炫酷度，体验度都大大增强。开发难度也不太大。&lt;/p&gt;
&lt;p&gt;但这种Style还没有发现有人公开使用。&lt;/p&gt;
&lt;p&gt;不过我发现了一款相当有潜力的Golang框架：github.com/zserge/webview&lt;/p&gt;
&lt;p&gt;可以做一些组件Style的尝试。。。&lt;/p&gt;

&lt;p&gt;五、终极Style&lt;/p&gt;
&lt;p&gt;终极Style并非一种开发方式，而是评分标准，每项五颗星，总分共十五颗星。&lt;/p&gt;
&lt;p&gt;终极的Web应用框架必须完美解决界面、成本、限制这三个方面的问题。大家可以自己来评评看。&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;界面&lt;/td&gt;
&lt;td&gt;成本&lt;/td&gt;
&lt;td&gt;限制&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt; 标准 高级 定制 皮肤 动画&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/569097/201711/569097-20171110205644591-820511038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt; 学习 流行 开发 继承 前途&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/569097/201711/569097-20171110205644591-820511038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt; 平台 体积 流畅 安全 开源&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/569097/201711/569097-20171110205644591-820511038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt; 图例&lt;/p&gt;
&lt;p&gt; 满意 符合 不符&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/569097/201711/569097-20171110210352450-732991934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;源码：&lt;a href=&quot;https://files.cnblogs.com/files/windfic/cool_style.zip&quot; target=&quot;_blank&quot;&gt;cool style&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（完）&lt;/p&gt;

</description>
<pubDate>Fri, 10 Nov 2017 14:00:00 +0000</pubDate>
<dc:creator>windfic</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/windfic/p/7811464.html</dc:identifier>
</item>
<item>
<title>Tinyhttpd精读解析 - nengm</title>
<link>http://www.cnblogs.com/nengm1988/p/7816618.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nengm1988/p/7816618.html</guid>
<description>&lt;p&gt;       首先，本人刚刚开始开源代码精读，写的不对的地方，大家轻拍，一起进步。本文是对Tinyhttpd的一次精读，大家每天都在用着http服务，很多人也一直活跃在上层，使用IIS、Apache等，大家是否想看看http服务器大概是怎么运作的，通过一个500多行的源码加上完整的注释，和大家逛一逛http服务器。Tinyhttpd真的非常适合阅读尤其是刚入门的，清晰的代码，简单的makefile...其实有很多分析tinyghttpd的，这边抱着人家写的是人家，自己写的才是自己的态度，写的尽量详细，尽量简单，很多都写在代码注释里面，也把学习中的一些坑翻出来和大家一起读读，吸取将近20年前的大神通过500行代码带给我们的财富。不管你是写c的，或者C#，js亦或java，只要用到http的都欢迎读读。&lt;br/&gt;大家看后如果觉得我有写的不对的地方，欢迎指出~~&lt;/p&gt;&lt;p&gt;1.首先是一张图 全解了Tinyhttp是如何运作的，我觉得图说明比我用文字描述的要清晰，语言功底不太给力。&lt;/p&gt;&lt;p&gt; 2. 主要函数简略说明，代码中进行了详细注释。&lt;/p&gt;&lt;p&gt;main   　　　　　　 主函数&lt;br/&gt;startup 　　　 　　  绑定监听套接字&lt;br/&gt;accept_request 　   每次收到请求，创建一个线程来处理接受到的请求&lt;br/&gt;serve_file 　　　　 接读取文件返回给请求的http客户端&lt;br/&gt;execute_cgi 　　　 执行cgi文件&lt;/p&gt;&lt;p&gt;index.html必须没有执行权限，否则看不到内容，并且会产生Program received signal SIGPIPE, Broken pipe，因为程序中如果有可执行权限会当cgi脚本处理。所以假如html有执行权限先把它去除了，chmod 600 index.html&lt;/p&gt;&lt;p&gt;color.cgi是用perl写的，相信大家很少接触了。所以可以引用网上一个简单的例子，换成一个shell写的cgi测试&lt;/p&gt;&lt;p&gt;#!/bin/bash&lt;br/&gt;echo &quot;Content-Type: text/html&quot;&lt;br/&gt;echo&lt;br/&gt;echo &quot;&amp;lt;HTML&amp;gt;&amp;lt;BODY&amp;gt;&quot;&lt;br/&gt;echo &quot;&amp;lt;CENTER&amp;gt;Today is:&amp;lt;/CENTER&amp;gt;&quot;&lt;br/&gt;echo &quot;&amp;lt;CENTER&amp;gt;&amp;lt;B&amp;gt;&quot;&lt;br/&gt;date&lt;br/&gt;echo &quot;&amp;lt;/B&amp;gt;&amp;lt;/CENTER&amp;gt;&quot;&lt;br/&gt;echo &quot;&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;&quot;&lt;/p&gt;&lt;div readability=&quot;307&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; J. David's webserver &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; This is a simple webserver.
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt; * Created November 1999 by J. David Blackstone.
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt; * CSE 4344 (Network concepts), Prof. Zeigler
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt; * University of Texas at Arlington
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; This program compiles for Sparc Solaris 2.6.
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt; * To compile for Linux:
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt; *  1) Comment out the #include &amp;lt;pthread.h&amp;gt; line.
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt; *  2) Comment out the line that defines the variable newthread.
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt; *  3) Comment out the two lines that run pthread_create().
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt; *  4) Uncomment the line that runs accept_request().
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt; *  5) Remove -lsocket from the Makefile.
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; #include &amp;lt;stdio.h&amp;gt;
&lt;span&gt; 16&lt;/span&gt; #include &amp;lt;sys/socket.h&amp;gt;
&lt;span&gt; 17&lt;/span&gt; #include &amp;lt;sys/types.h&amp;gt;
&lt;span&gt; 18&lt;/span&gt; #include &amp;lt;netinet/&lt;span&gt;in&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 19&lt;/span&gt; #include &amp;lt;arpa/inet.h&amp;gt;
&lt;span&gt; 20&lt;/span&gt; #include &amp;lt;unistd.h&amp;gt;
&lt;span&gt; 21&lt;/span&gt; #include &amp;lt;ctype.h&amp;gt;
&lt;span&gt; 22&lt;/span&gt; #include &amp;lt;strings.h&amp;gt;
&lt;span&gt; 23&lt;/span&gt; #include &amp;lt;&lt;span&gt;string&lt;/span&gt;.h&amp;gt;
&lt;span&gt; 24&lt;/span&gt; #include &amp;lt;sys/stat.h&amp;gt;
&lt;span&gt; 25&lt;/span&gt; #include &amp;lt;pthread.h&amp;gt;
&lt;span&gt; 26&lt;/span&gt; #include &amp;lt;sys/wait.h&amp;gt;
&lt;span&gt; 27&lt;/span&gt; #include &amp;lt;stdlib.h&amp;gt;
&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;宏定义，是否是空格&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; ISspace(x) isspace((int)(x))
&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; SERVER_STRING &quot;Server: jdbhttpd/0.1.0\r\n&quot;
&lt;span&gt; 33&lt;/span&gt; 
&lt;span&gt; 34&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次收到请求，创建一个线程来处理接受到的请求
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把client_sock转成地址作为参数传入pthread_create&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; accept_request(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;arg);
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误请求&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bad_request(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取文件&lt;/span&gt;
&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; cat(&lt;span&gt;int&lt;/span&gt;, FILE *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;无法执行&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; cannot_execute(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误输出&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; error_die(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; 
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行cig脚本&lt;/span&gt;
&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; execute_cgi(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; 
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到一行数据,只要发现c为\n,就认为是一行结束，如果读到\r,再用MSG_PEEK的方式读入一个字符，如果是\n，从socket用读出
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是下个字符则不处理，将c置为\n，结束。如果读到的数据为0中断，或者小于0，也视为结束，c置为\n&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; get_line(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;char&lt;/span&gt; *, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回http头&lt;/span&gt;
&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; headers(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; 
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有发现文件&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; not_found(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是CGI文件，直接读取文件返回给请求的http客户端&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; serve_file(&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启tcp连接，绑定端口等操作&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; startup(u_short *&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是Get或者Post，就报方法没有实现&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; unimplemented(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Http请求，后续主要是处理这个头
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET / HTTP/1.1
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Host: 192.168.0.23:47310
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Connection: keep-alive
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Upgrade-Insecure-Requests: 1
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*; q = 0.8
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Accept - Encoding: gzip, deflate, sdch
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Accept - Language : zh - CN, zh; q = 0.8
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cookie: __guid = 179317988.1576506943281708800.1510107225903.8862; monitor_count = 5
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; POST / color1.cgi HTTP / 1.1
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Host: 192.168.0.23 : 47310
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Connection : keep - alive
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Content - Length : 10
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cache - Control : max - age = 0
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Origin : http :&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.0.23:40786
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Upgrade - Insecure - Requests : 1
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; User - Agent : Mozilla / 5.0 (Windows NT 6.1; WOW64) AppleWebKit / 537.36 (KHTML, like Gecko) Chrome / 55.0.2883.87 Safari / 537.36
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Content - Type : application / x - www - form - urlencoded
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Accept : text / html, application / xhtml + xml, application / xml; q = 0.9, image / webp, */*;q=0.8
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Referer: &lt;/span&gt;&lt;span&gt;http://192.168.0.23&lt;/span&gt;&lt;span&gt;:47310/
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Accept-Encoding: gzip, deflate
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Accept-Language: zh-CN,zh;q=0.8
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cookie: __guid=179317988.1576506943281708800.1510107225903.8862; monitor_count=281
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Form Data
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; color=gray&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; A request has caused a call to accept() on the server port to
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt; * return.  Process the request appropriately.
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt; * Parameters: the socket connected to the client &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;106&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; accept_request(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;arg)
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;socket&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; client =&lt;span&gt; (intptr_t)arg;
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; numchars;
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; method[&lt;span&gt;255&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; url[&lt;span&gt;255&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; path[&lt;span&gt;512&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt; size_t i, j;
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;  &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; stat st;
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; cgi = &lt;span&gt;0&lt;/span&gt;;      &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; becomes true if server decides this is a CGI
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;                    * program &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; *query_string =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据上面的Get请求，可以看到这边就是取第一行
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这边都是在处理第一条http信息
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;&quot;GET / HTTP/1.1\n&quot;&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt;  numchars = get_line(client, buf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf));
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;  i = &lt;span&gt;0&lt;/span&gt;; j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一行字符串提取Get&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt;  &lt;span&gt;while&lt;/span&gt; (!ISspace(buf[j]) &amp;amp;&amp;amp; (i &amp;lt; &lt;span&gt;sizeof&lt;/span&gt;(method) - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;   method[i] =&lt;span&gt; buf[j];
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;   i++; j++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;  method[i] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是Get还是Post&lt;/span&gt;
&lt;span&gt;137&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (strcasecmp(method, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &amp;amp;&amp;amp; strcasecmp(method, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;  unimplemented(client);
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt; 
&lt;span&gt;143&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是POST，cgi置为1&lt;/span&gt;
&lt;span&gt;144&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (strcasecmp(method, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;   cgi = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; 
&lt;span&gt;147&lt;/span&gt;  i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;跳过空格&lt;/span&gt;
&lt;span&gt;149&lt;/span&gt;  &lt;span&gt;while&lt;/span&gt; (ISspace(buf[j]) &amp;amp;&amp;amp; (j &amp;lt; &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf)))
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;   j++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; 
&lt;span&gt;152&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到 &quot;/&quot;   注意：如果你的http的网址为http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;192.168.0.23:47310/index.html
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;               那么你得到的第一条http信息为GET /index.html HTTP/1.1，那么
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;               解析得到的就是/index.html&lt;/span&gt;
&lt;span&gt;155&lt;/span&gt;  &lt;span&gt;while&lt;/span&gt; (!ISspace(buf[j]) &amp;amp;&amp;amp; (i &amp;lt; &lt;span&gt;sizeof&lt;/span&gt;(url) - &lt;span&gt;1&lt;/span&gt;) &amp;amp;&amp;amp; (j &amp;lt; &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf)))
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;   url[i] =&lt;span&gt; buf[j];
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;   i++; j++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;  url[i] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; 
&lt;span&gt;162&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断Get请求&lt;/span&gt;
&lt;span&gt;163&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (strcasecmp(method, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;165&lt;/span&gt;   query_string =&lt;span&gt; url;
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;   &lt;span&gt;while&lt;/span&gt; ((*query_string != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &amp;amp;&amp;amp; (*query_string != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;    query_string++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (*query_string == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;    cgi = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;    *query_string = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;    query_string++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; 
&lt;span&gt;176&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;路径&lt;/span&gt;
&lt;span&gt;177&lt;/span&gt;  sprintf(path, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;htdocs%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, url);
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; 
&lt;span&gt;179&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认地址，解析到的路径如果为/，则自动加上index.html&lt;/span&gt;
&lt;span&gt;180&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (path[strlen(path) - &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt;   strcat(path, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; 
&lt;span&gt;183&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获得文件信息&lt;/span&gt;
&lt;span&gt;184&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (stat(path, &amp;amp;st) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把所有http信息读出然后丢弃&lt;/span&gt;
&lt;span&gt;186&lt;/span&gt;   &lt;span&gt;while&lt;/span&gt; ((numchars &amp;gt; &lt;span&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; strcmp(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, buf))  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; read &amp;amp; discard headers &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;187&lt;/span&gt;    numchars = get_line(client, buf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf));
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; 
&lt;span&gt;189&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有找到&lt;/span&gt;
&lt;span&gt;190&lt;/span&gt; &lt;span&gt;  not_found(client);
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt;  &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;193&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; ((st.st_mode &amp;amp; S_IFMT) ==&lt;span&gt; S_IFDIR)
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;    strcat(path, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/index.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果你的文件默认是有执行权限的，自动解析成cgi程序，如果有执行权限但是不能执行，会接受到报错信号&lt;/span&gt;
&lt;span&gt;197&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; ((st.st_mode &amp;amp; S_IXUSR) ||
&lt;span&gt;198&lt;/span&gt;       (st.st_mode &amp;amp; S_IXGRP) ||
&lt;span&gt;199&lt;/span&gt;       (st.st_mode &amp;amp;&lt;span&gt; S_IXOTH)    )
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;    cgi = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cgi)
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接读取文件返回给请求的http客户端&lt;/span&gt;
&lt;span&gt;203&lt;/span&gt; &lt;span&gt;   serve_file(client, path);
&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;205&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行cgi文件&lt;/span&gt;
&lt;span&gt;206&lt;/span&gt; &lt;span&gt;   execute_cgi(client, path, method, query_string);
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行完毕关闭socket&lt;/span&gt;
&lt;span&gt;209&lt;/span&gt; &lt;span&gt; close(client);
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; 
&lt;span&gt;212&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;213&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Inform the client that a request it has made has a problem.
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt; &lt;span&gt; * Parameters: client socket &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;215&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;216&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bad_request(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; client)
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; 
&lt;span&gt;220&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTTP/1.0 400 BAD REQUEST\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;  send(client, buf, &lt;span&gt;sizeof&lt;/span&gt;(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-type: text/html\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;  send(client, buf, &lt;span&gt;sizeof&lt;/span&gt;(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt;  send(client, buf, &lt;span&gt;sizeof&lt;/span&gt;(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;P&amp;gt;Your browser sent a bad request, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt;  send(client, buf, &lt;span&gt;sizeof&lt;/span&gt;(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;such as a POST without a Content-Length.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt;  send(client, buf, &lt;span&gt;sizeof&lt;/span&gt;(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt; 
&lt;span&gt;232&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;233&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Put the entire contents of a file out on a socket.  This function
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt; &lt;span&gt; * is named after the UNIX &quot;cat&quot; command, because it might have been
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt; &lt;span&gt; * easier just to do something like pipe, fork, and exec(&quot;cat&quot;).
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt; &lt;span&gt; * Parameters: the client socket descriptor
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt; &lt;span&gt; *             FILE pointer for the file to cat &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;238&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;239&lt;/span&gt; 
&lt;span&gt;240&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到文件内容，发送&lt;/span&gt;
&lt;span&gt;241&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; cat(&lt;span&gt;int&lt;/span&gt; client, FILE *&lt;span&gt;resource)
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; 
&lt;span&gt;245&lt;/span&gt;  fgets(buf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf), resource);
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环读&lt;/span&gt;
&lt;span&gt;247&lt;/span&gt;  &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;feof(resource))
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;   send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;   fgets(buf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf), resource);
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt; 
&lt;span&gt;254&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;255&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Inform the client that a CGI script could not be executed.
&lt;/span&gt;&lt;span&gt;256&lt;/span&gt; &lt;span&gt; * Parameter: the client socket descriptor. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;257&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;258&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; cannot_execute(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; client)
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;261&lt;/span&gt; 
&lt;span&gt;262&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTTP/1.0 500 Internal Server Error\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-type: text/html\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;P&amp;gt;Error prohibited CGI execution.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;269&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;271&lt;/span&gt; 
&lt;span&gt;272&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;273&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Print out an error message with perror() (for system errors; based
&lt;/span&gt;&lt;span&gt;274&lt;/span&gt; &lt;span&gt; * on value of errno, which indicates system call errors) and exit the
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt; &lt;span&gt; * program indicating an error. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;276&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;277&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; error_die(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;sc)
&lt;/span&gt;&lt;span&gt;278&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;279&lt;/span&gt; &lt;span&gt; perror(sc);
&lt;/span&gt;&lt;span&gt;280&lt;/span&gt;  exit(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;281&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;282&lt;/span&gt; 
&lt;span&gt;283&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;284&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Execute a CGI script.  Will need to set environment variables as
&lt;/span&gt;&lt;span&gt;285&lt;/span&gt; &lt;span&gt; * appropriate.
&lt;/span&gt;&lt;span&gt;286&lt;/span&gt; &lt;span&gt; * Parameters: client socket descriptor
&lt;/span&gt;&lt;span&gt;287&lt;/span&gt; &lt;span&gt; *             path to the CGI script &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;288&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;289&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; execute_cgi(&lt;span&gt;int&lt;/span&gt; client, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;path,
&lt;/span&gt;&lt;span&gt;290&lt;/span&gt;                  &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *method, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;query_string)
&lt;/span&gt;&lt;span&gt;291&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;292&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓冲区&lt;/span&gt;
&lt;span&gt;293&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;294&lt;/span&gt; 
&lt;span&gt;295&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2根管道&lt;/span&gt;
&lt;span&gt;296&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; cgi_output[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; cgi_input[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;298&lt;/span&gt; 
&lt;span&gt;299&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进程pid和状态&lt;/span&gt;
&lt;span&gt;300&lt;/span&gt; &lt;span&gt; pid_t pid;
&lt;/span&gt;&lt;span&gt;301&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; status;
&lt;/span&gt;&lt;span&gt;302&lt;/span&gt; 
&lt;span&gt;303&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;304&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt;&lt;span&gt; c;
&lt;/span&gt;&lt;span&gt;305&lt;/span&gt;  
&lt;span&gt;306&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取的字符数&lt;/span&gt;
&lt;span&gt;307&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; numchars = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;308&lt;/span&gt; 
&lt;span&gt;309&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;http的content_length&lt;/span&gt;
&lt;span&gt;310&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; content_length = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;311&lt;/span&gt; 
&lt;span&gt;312&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认字符&lt;/span&gt;
&lt;span&gt;313&lt;/span&gt;  buf[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; buf[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;314&lt;/span&gt; 
&lt;span&gt;315&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;忽略大小写比较字符串&lt;/span&gt;
&lt;span&gt;316&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (strcasecmp(method, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;317&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取数据，把整个header都读掉，以为Get写死了直接读取index.html，没有必要分析余下的http信息了&lt;/span&gt;
&lt;span&gt;318&lt;/span&gt;   &lt;span&gt;while&lt;/span&gt; ((numchars &amp;gt; &lt;span&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; strcmp(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, buf))  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; read &amp;amp; discard headers &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;319&lt;/span&gt;    numchars = get_line(client, buf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf));
&lt;/span&gt;&lt;span&gt;320&lt;/span&gt;  &lt;span&gt;else&lt;/span&gt;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; POST &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;321&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;322&lt;/span&gt;   numchars = get_line(client, buf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf));
&lt;/span&gt;&lt;span&gt;323&lt;/span&gt;   &lt;span&gt;while&lt;/span&gt; ((numchars &amp;gt; &lt;span&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; strcmp(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, buf))
&lt;/span&gt;&lt;span&gt;324&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;325&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是POST请求，就需要得到Content-Length，Content-Length：这个字符串一共长为15位，所以
&lt;/span&gt;&lt;span&gt;326&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取出头部一句后，将第16位设置结束符，进行比较
&lt;/span&gt;&lt;span&gt;327&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第16位置为结束&lt;/span&gt;
&lt;span&gt;328&lt;/span&gt;    buf[&lt;span&gt;15&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;329&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (strcasecmp(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Length:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;330&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;内存从第17位开始就是长度，将17位开始的所有字符串转成整数就是content_length&lt;/span&gt;
&lt;span&gt;331&lt;/span&gt;     content_length = atoi(&amp;amp;(buf[&lt;span&gt;16&lt;/span&gt;&lt;span&gt;]));
&lt;/span&gt;&lt;span&gt;332&lt;/span&gt;    numchars = get_line(client, buf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf));
&lt;/span&gt;&lt;span&gt;333&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;334&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (content_length == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;335&lt;/span&gt; &lt;span&gt;   bad_request(client);
&lt;/span&gt;&lt;span&gt;336&lt;/span&gt;    &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;337&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;338&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;339&lt;/span&gt; 
&lt;span&gt;340&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTTP/1.0 200 OK\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;341&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;342&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立output管道&lt;/span&gt;
&lt;span&gt;343&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (pipe(cgi_output) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;344&lt;/span&gt; &lt;span&gt;  cannot_execute(client);
&lt;/span&gt;&lt;span&gt;345&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;346&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;347&lt;/span&gt; 
&lt;span&gt;348&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立input管道&lt;/span&gt;
&lt;span&gt;349&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (pipe(cgi_input) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;350&lt;/span&gt; &lt;span&gt;  cannot_execute(client);
&lt;/span&gt;&lt;span&gt;351&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;352&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;353&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       fork后管道都复制了一份，都是一样的
&lt;/span&gt;&lt;span&gt;354&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       子进程关闭2个无用的端口，避免浪费             
&lt;/span&gt;&lt;span&gt;355&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       ×&amp;lt;-------------------------&amp;gt;1    output
&lt;/span&gt;&lt;span&gt;356&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       0&amp;lt;--------------------------&amp;gt;×   input 
&lt;/span&gt;&lt;span&gt;357&lt;/span&gt; 
&lt;span&gt;358&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       父进程关闭2个无用的端口，避免浪费             
&lt;/span&gt;&lt;span&gt;359&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       0&amp;lt;--------------------------&amp;gt;×   output
&lt;/span&gt;&lt;span&gt;360&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       ×&amp;lt;-------------------------&amp;gt;1    input
&lt;/span&gt;&lt;span&gt;361&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       此时父子进程已经可以通信
&lt;/span&gt;&lt;span&gt;362&lt;/span&gt; 
&lt;span&gt;363&lt;/span&gt; 
&lt;span&gt;364&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;fork进程，子进程用于执行CGI
&lt;/span&gt;&lt;span&gt;365&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;父进程用于收数据以及发送子进程处理的回复数据&lt;/span&gt;
&lt;span&gt;366&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; ( (pid = fork()) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt; ) {
&lt;/span&gt;&lt;span&gt;367&lt;/span&gt; &lt;span&gt;  cannot_execute(client);
&lt;/span&gt;&lt;span&gt;368&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;369&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;370&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (pid == &lt;span&gt;0&lt;/span&gt;)  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; child: CGI script &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;371&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;372&lt;/span&gt;   &lt;span&gt;char&lt;/span&gt; meth_env[&lt;span&gt;255&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;373&lt;/span&gt;   &lt;span&gt;char&lt;/span&gt; query_env[&lt;span&gt;255&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;374&lt;/span&gt;   &lt;span&gt;char&lt;/span&gt; length_env[&lt;span&gt;255&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;375&lt;/span&gt; 
&lt;span&gt;376&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;子进程输出重定向到output管道的1端&lt;/span&gt;
&lt;span&gt;377&lt;/span&gt;   dup2(cgi_output[&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;378&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;子进程输入重定向到input管道的0端&lt;/span&gt;
&lt;span&gt;379&lt;/span&gt;   dup2(cgi_input[&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;380&lt;/span&gt; 
&lt;span&gt;381&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭无用管道口&lt;/span&gt;
&lt;span&gt;382&lt;/span&gt;   close(cgi_output[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;383&lt;/span&gt;   close(cgi_input[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;384&lt;/span&gt; 
&lt;span&gt;385&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;CGI环境变量&lt;/span&gt;
&lt;span&gt;386&lt;/span&gt;   sprintf(meth_env, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;REQUEST_METHOD=%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, method);
&lt;/span&gt;&lt;span&gt;387&lt;/span&gt; &lt;span&gt;  putenv(meth_env);
&lt;/span&gt;&lt;span&gt;388&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (strcasecmp(method, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;389&lt;/span&gt;    sprintf(query_env, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;QUERY_STRING=%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, query_string);
&lt;/span&gt;&lt;span&gt;390&lt;/span&gt; &lt;span&gt;   putenv(query_env);
&lt;/span&gt;&lt;span&gt;391&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;392&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt; {   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; POST &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;393&lt;/span&gt;    sprintf(length_env, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CONTENT_LENGTH=%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, content_length);
&lt;/span&gt;&lt;span&gt;394&lt;/span&gt; &lt;span&gt;   putenv(length_env);
&lt;/span&gt;&lt;span&gt;395&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;396&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;替换执行path&lt;/span&gt;
&lt;span&gt;397&lt;/span&gt; &lt;span&gt;  execl(path, path, NULL);
&lt;/span&gt;&lt;span&gt;398&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;int m = execl(path, path, NULL);
&lt;/span&gt;&lt;span&gt;399&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果path有问题，例如将html网页改成可执行的，但是执行后m为-1
&lt;/span&gt;&lt;span&gt;400&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;退出子进程，管道被破坏，但是父进程还在往里面写东西，触发Program received signal SIGPIPE, Broken pipe.&lt;/span&gt;
&lt;span&gt;401&lt;/span&gt;   exit(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;402&lt;/span&gt;  } &lt;span&gt;else&lt;/span&gt; {    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; parent &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;403&lt;/span&gt; 
&lt;span&gt;404&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭无用管道口&lt;/span&gt;
&lt;span&gt;405&lt;/span&gt;   close(cgi_output[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;406&lt;/span&gt;   close(cgi_input[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;407&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (strcasecmp(method, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;POST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;408&lt;/span&gt;    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; content_length; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;409&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到post请求数据，写到input管道中，供子进程使用&lt;/span&gt;
&lt;span&gt;410&lt;/span&gt;     recv(client, &amp;amp;c, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;411&lt;/span&gt;     write(cgi_input[&lt;span&gt;1&lt;/span&gt;], &amp;amp;c, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;412&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;413&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从output管道读到子进程处理后的信息，然后send出去&lt;/span&gt;
&lt;span&gt;414&lt;/span&gt;   &lt;span&gt;while&lt;/span&gt; (read(cgi_output[&lt;span&gt;0&lt;/span&gt;], &amp;amp;c, &lt;span&gt;1&lt;/span&gt;) &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;415&lt;/span&gt;    send(client, &amp;amp;c, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;416&lt;/span&gt; 
&lt;span&gt;417&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成操作后关闭管道&lt;/span&gt;
&lt;span&gt;418&lt;/span&gt;   close(cgi_output[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;419&lt;/span&gt;   close(cgi_input[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;420&lt;/span&gt; 
&lt;span&gt;421&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待子进程返回&lt;/span&gt;
&lt;span&gt;422&lt;/span&gt;   waitpid(pid, &amp;amp;status, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;423&lt;/span&gt; 
&lt;span&gt;424&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;425&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;426&lt;/span&gt; 
&lt;span&gt;427&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;428&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Get a line from a socket, whether the line ends in a newline,
&lt;/span&gt;&lt;span&gt;429&lt;/span&gt; &lt;span&gt; * carriage return, or a CRLF combination.  Terminates the string read
&lt;/span&gt;&lt;span&gt;430&lt;/span&gt; &lt;span&gt; * with a null character.  If no newline indicator is found before the
&lt;/span&gt;&lt;span&gt;431&lt;/span&gt; &lt;span&gt; * end of the buffer, the string is terminated with a null.  If any of
&lt;/span&gt;&lt;span&gt;432&lt;/span&gt; &lt;span&gt; * the above three line terminators is read, the last character of the
&lt;/span&gt;&lt;span&gt;433&lt;/span&gt; &lt;span&gt; * string will be a linefeed and the string will be terminated with a
&lt;/span&gt;&lt;span&gt;434&lt;/span&gt; &lt;span&gt; * null character.
&lt;/span&gt;&lt;span&gt;435&lt;/span&gt; &lt;span&gt; * Parameters: the socket descriptor
&lt;/span&gt;&lt;span&gt;436&lt;/span&gt; &lt;span&gt; *             the buffer to save the data in
&lt;/span&gt;&lt;span&gt;437&lt;/span&gt; &lt;span&gt; *             the size of the buffer
&lt;/span&gt;&lt;span&gt;438&lt;/span&gt; &lt;span&gt; * Returns: the number of bytes stored (excluding null) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;439&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;440&lt;/span&gt; 
&lt;span&gt;441&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到一行数据,只要发现c为\n,就认为是一行结束，如果读到\r,再用MSG_PEEK的方式读入一个字符，如果是\n，从socket用读出
&lt;/span&gt;&lt;span&gt;442&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是下个字符则不处理，将c置为\n，结束。如果读到的数据为0中断，或者小于0，也视为结束，c置为\n&lt;/span&gt;
&lt;span&gt;443&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; get_line(&lt;span&gt;int&lt;/span&gt; sock, &lt;span&gt;char&lt;/span&gt; *buf, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size)
&lt;/span&gt;&lt;span&gt;444&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;445&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;446&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; c = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;447&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;448&lt;/span&gt; 
&lt;span&gt;449&lt;/span&gt;  &lt;span&gt;while&lt;/span&gt; ((i &amp;lt; size - &lt;span&gt;1&lt;/span&gt;) &amp;amp;&amp;amp; (c != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;450&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;451&lt;/span&gt;   n = recv(sock, &amp;amp;c, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;452&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; DEBUG printf(&quot;%02X\n&quot;, c); &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;453&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (n &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;454&lt;/span&gt; &lt;span&gt;  {
&lt;/span&gt;&lt;span&gt;455&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;456&lt;/span&gt; &lt;span&gt;   {
&lt;/span&gt;&lt;span&gt;457&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;偷窥一个字节，如果是\n就读走&lt;/span&gt;
&lt;span&gt;458&lt;/span&gt;     n = recv(sock, &amp;amp;c, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, MSG_PEEK);
&lt;/span&gt;&lt;span&gt;459&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; DEBUG printf(&quot;%02X\n&quot;, c); &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;460&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((n &amp;gt; &lt;span&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; (c == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;461&lt;/span&gt;      recv(sock, &amp;amp;c, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;462&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;463&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不是\n（读到第一行的字符）或者没读到，置c为\n 跳出循环,完成一行读取&lt;/span&gt;
&lt;span&gt;464&lt;/span&gt;      c = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;465&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;466&lt;/span&gt;    buf[i] =&lt;span&gt; c;
&lt;/span&gt;&lt;span&gt;467&lt;/span&gt;    i++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;468&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;469&lt;/span&gt;   &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;470&lt;/span&gt;    c = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;471&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;472&lt;/span&gt;  buf[i] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;473&lt;/span&gt;  
&lt;span&gt;474&lt;/span&gt;  &lt;span&gt;return&lt;/span&gt;&lt;span&gt;(i);
&lt;/span&gt;&lt;span&gt;475&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;476&lt;/span&gt; 
&lt;span&gt;477&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;478&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Return the informational HTTP headers about a file. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;479&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Parameters: the socket to print the headers on
&lt;/span&gt;&lt;span&gt;480&lt;/span&gt; &lt;span&gt; *             the name of the file &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;481&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;482&lt;/span&gt; 
&lt;span&gt;483&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加入http的headers&lt;/span&gt;
&lt;span&gt;484&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; headers(&lt;span&gt;int&lt;/span&gt; client, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;filename)
&lt;/span&gt;&lt;span&gt;485&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;486&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;487&lt;/span&gt;  (&lt;span&gt;void&lt;/span&gt;)filename;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; could use filename to determine file type &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;488&lt;/span&gt; 
&lt;span&gt;489&lt;/span&gt;  strcpy(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTTP/1.0 200 OK\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;490&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;491&lt;/span&gt; &lt;span&gt; strcpy(buf, SERVER_STRING);
&lt;/span&gt;&lt;span&gt;492&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;493&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type: text/html\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;494&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;495&lt;/span&gt;  strcpy(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;496&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;497&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;498&lt;/span&gt; 
&lt;span&gt;499&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;500&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Give a client a 404 not found status message. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;501&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;502&lt;/span&gt; 
&lt;span&gt;503&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果资源没有找到得返回给客户端下面的信息&lt;/span&gt;
&lt;span&gt;504&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; not_found(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; client)
&lt;/span&gt;&lt;span&gt;505&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;506&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;507&lt;/span&gt; 
&lt;span&gt;508&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTTP/1.0 404 NOT FOUND\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;509&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;510&lt;/span&gt; &lt;span&gt; sprintf(buf, SERVER_STRING);
&lt;/span&gt;&lt;span&gt;511&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;512&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type: text/html\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;513&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;514&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;515&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;516&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;HTML&amp;gt;&amp;lt;TITLE&amp;gt;Not Found&amp;lt;/TITLE&amp;gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;517&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;518&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;BODY&amp;gt;&amp;lt;P&amp;gt;The server could not fulfill\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;519&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;520&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;your request because the resource specified\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;521&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;522&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;is unavailable or nonexistent.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;523&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;524&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;525&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;526&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;527&lt;/span&gt; 
&lt;span&gt;528&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;529&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Send a regular file to the client.  Use headers, and report
&lt;/span&gt;&lt;span&gt;530&lt;/span&gt; &lt;span&gt; * errors to client if they occur.
&lt;/span&gt;&lt;span&gt;531&lt;/span&gt; &lt;span&gt; * Parameters: a pointer to a file structure produced from the socket
&lt;/span&gt;&lt;span&gt;532&lt;/span&gt; &lt;span&gt; *              file descriptor
&lt;/span&gt;&lt;span&gt;533&lt;/span&gt; &lt;span&gt; *             the name of the file to serve &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;534&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;535&lt;/span&gt; 
&lt;span&gt;536&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是CGI文件，直接读取文件返回给请求的http客户端&lt;/span&gt;
&lt;span&gt;537&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; serve_file(&lt;span&gt;int&lt;/span&gt; client, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;filename)
&lt;/span&gt;&lt;span&gt;538&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;539&lt;/span&gt;  FILE *resource =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;540&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; numchars = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;541&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;542&lt;/span&gt; 
&lt;span&gt;543&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认字符&lt;/span&gt;
&lt;span&gt;544&lt;/span&gt;  buf[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;; buf[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;545&lt;/span&gt;  &lt;span&gt;while&lt;/span&gt; ((numchars &amp;gt; &lt;span&gt;0&lt;/span&gt;) &amp;amp;&amp;amp; strcmp(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, buf))  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; read &amp;amp; discard headers &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;546&lt;/span&gt;   numchars = get_line(client, buf, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(buf));
&lt;/span&gt;&lt;span&gt;547&lt;/span&gt; 
&lt;span&gt;548&lt;/span&gt;  resource = fopen(filename, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;549&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (resource ==&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt;550&lt;/span&gt; &lt;span&gt;  not_found(client);
&lt;/span&gt;&lt;span&gt;551&lt;/span&gt;  &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;552&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;553&lt;/span&gt; &lt;span&gt;  headers(client, filename);
&lt;/span&gt;&lt;span&gt;554&lt;/span&gt; &lt;span&gt;  cat(client, resource);
&lt;/span&gt;&lt;span&gt;555&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;556&lt;/span&gt; &lt;span&gt; fclose(resource);
&lt;/span&gt;&lt;span&gt;557&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;558&lt;/span&gt; 
&lt;span&gt;559&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;560&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; This function starts the process of listening for web connections
&lt;/span&gt;&lt;span&gt;561&lt;/span&gt; &lt;span&gt; * on a specified port.  If the port is 0, then dynamically allocate a
&lt;/span&gt;&lt;span&gt;562&lt;/span&gt; &lt;span&gt; * port and modify the original port variable to reflect the actual
&lt;/span&gt;&lt;span&gt;563&lt;/span&gt; &lt;span&gt; * port.
&lt;/span&gt;&lt;span&gt;564&lt;/span&gt; &lt;span&gt; * Parameters: pointer to variable containing the port to connect on
&lt;/span&gt;&lt;span&gt;565&lt;/span&gt; &lt;span&gt; * Returns: the socket &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;566&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;567&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; startup(u_short *&lt;span&gt;port)
&lt;/span&gt;&lt;span&gt;568&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;569&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; httpd = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;570&lt;/span&gt;  &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in name;
&lt;/span&gt;&lt;span&gt;571&lt;/span&gt; 
&lt;span&gt;572&lt;/span&gt;  httpd = socket(PF_INET, SOCK_STREAM, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;573&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (httpd == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;574&lt;/span&gt;   error_die(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;socket&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;575&lt;/span&gt;  memset(&amp;amp;name, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(name));
&lt;/span&gt;&lt;span&gt;576&lt;/span&gt;  name.sin_family =&lt;span&gt; AF_INET;
&lt;/span&gt;&lt;span&gt;577&lt;/span&gt;  name.sin_port = htons(*&lt;span&gt;port);
&lt;/span&gt;&lt;span&gt;578&lt;/span&gt;  name.sin_addr.s_addr =&lt;span&gt; htonl(INADDR_ANY);
&lt;/span&gt;&lt;span&gt;579&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定socket&lt;/span&gt;
&lt;span&gt;580&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (bind(httpd, (&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;name, &lt;span&gt;sizeof&lt;/span&gt;(name)) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;581&lt;/span&gt;   error_die(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;582&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果端口没有设置，提供个随机端口&lt;/span&gt;
&lt;span&gt;583&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (*port == &lt;span&gt;0&lt;/span&gt;)  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; if dynamically allocating a port &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;584&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;585&lt;/span&gt;   socklen_t  namelen = &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(name);
&lt;/span&gt;&lt;span&gt;586&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (getsockname(httpd, (&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;name, &amp;amp;namelen) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;587&lt;/span&gt;    error_die(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;getsockname&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;588&lt;/span&gt;   *port =&lt;span&gt; ntohs(name.sin_port);
&lt;/span&gt;&lt;span&gt;589&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;590&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;监听&lt;/span&gt;
&lt;span&gt;591&lt;/span&gt;  &lt;span&gt;if&lt;/span&gt; (listen(httpd, &lt;span&gt;5&lt;/span&gt;) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;592&lt;/span&gt;   error_die(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;listen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;593&lt;/span&gt;  &lt;span&gt;return&lt;/span&gt;&lt;span&gt;(httpd);
&lt;/span&gt;&lt;span&gt;594&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;595&lt;/span&gt; 
&lt;span&gt;596&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;597&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Inform the client that the requested web method has not been
&lt;/span&gt;&lt;span&gt;598&lt;/span&gt; &lt;span&gt; * implemented.
&lt;/span&gt;&lt;span&gt;599&lt;/span&gt; &lt;span&gt; * Parameter: the client socket &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;600&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;601&lt;/span&gt; 
&lt;span&gt;602&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果方法没有实现，就返回此信息&lt;/span&gt;
&lt;span&gt;603&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; unimplemented(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; client)
&lt;/span&gt;&lt;span&gt;604&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;605&lt;/span&gt;  &lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;606&lt;/span&gt; 
&lt;span&gt;607&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HTTP/1.0 501 Method Not Implemented\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;608&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;609&lt;/span&gt; &lt;span&gt; sprintf(buf, SERVER_STRING);
&lt;/span&gt;&lt;span&gt;610&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;611&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type: text/html\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;612&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;613&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;614&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;615&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;HTML&amp;gt;&amp;lt;HEAD&amp;gt;&amp;lt;TITLE&amp;gt;Method Not Implemented\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;616&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;617&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/TITLE&amp;gt;&amp;lt;/HEAD&amp;gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;618&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;619&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;BODY&amp;gt;&amp;lt;P&amp;gt;HTTP request method not supported.\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;620&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;621&lt;/span&gt;  sprintf(buf, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;622&lt;/span&gt;  send(client, buf, strlen(buf), &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;623&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;624&lt;/span&gt; 
&lt;span&gt;625&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;********************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;626&lt;/span&gt; 
&lt;span&gt;627&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;628&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;629&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; server_sock = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;630&lt;/span&gt;  u_short port = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;631&lt;/span&gt;  &lt;span&gt;int&lt;/span&gt; client_sock = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;632&lt;/span&gt;  &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sockaddr_in client_name;
&lt;/span&gt;&lt;span&gt;633&lt;/span&gt; 
&lt;span&gt;634&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这边要为socklen_t类型&lt;/span&gt;
&lt;span&gt;635&lt;/span&gt;  socklen_t client_name_len = &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(client_name);
&lt;/span&gt;&lt;span&gt;636&lt;/span&gt; &lt;span&gt; pthread_t newthread;
&lt;/span&gt;&lt;span&gt;637&lt;/span&gt; 
&lt;span&gt;638&lt;/span&gt;  server_sock = startup(&amp;amp;&lt;span&gt;port);
&lt;/span&gt;&lt;span&gt;639&lt;/span&gt;  printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;httpd running on port %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, port);
&lt;/span&gt;&lt;span&gt;640&lt;/span&gt; 
&lt;span&gt;641&lt;/span&gt;  &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;642&lt;/span&gt; &lt;span&gt; {
&lt;/span&gt;&lt;span&gt;643&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接受请求，函数原型
&lt;/span&gt;&lt;span&gt;644&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;#include &amp;lt;sys/types.h&amp;gt;
&lt;/span&gt;&lt;span&gt;645&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;#include &amp;lt;sys/socket.h&amp;gt;  
&lt;/span&gt;&lt;span&gt;646&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);&lt;/span&gt;
&lt;span&gt;647&lt;/span&gt;   client_sock =&lt;span&gt; accept(server_sock,
&lt;/span&gt;&lt;span&gt;648&lt;/span&gt;                        (&lt;span&gt;struct&lt;/span&gt; sockaddr *)&amp;amp;&lt;span&gt;client_name,
&lt;/span&gt;&lt;span&gt;649&lt;/span&gt;                        &amp;amp;&lt;span&gt;client_name_len);
&lt;/span&gt;&lt;span&gt;650&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (client_sock == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;651&lt;/span&gt;       error_die(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;accept&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;652&lt;/span&gt;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; accept_request(client_sock); &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;653&lt;/span&gt; 
&lt;span&gt;654&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次收到请求，创建一个线程来处理接受到的请求
&lt;/span&gt;&lt;span&gt;655&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把client_sock转成地址作为参数传入pthread_create&lt;/span&gt;
&lt;span&gt;656&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (pthread_create(&amp;amp;newthread, NULL, (&lt;span&gt;void&lt;/span&gt; *)accept_request, (&lt;span&gt;void&lt;/span&gt; *)(intptr_t)client_sock) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;657&lt;/span&gt;       perror(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pthread_create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;658&lt;/span&gt; &lt;span&gt; }
&lt;/span&gt;&lt;span&gt;659&lt;/span&gt; 
&lt;span&gt;660&lt;/span&gt; &lt;span&gt; close(server_sock);
&lt;/span&gt;&lt;span&gt;661&lt;/span&gt; 
&lt;span&gt;662&lt;/span&gt;  &lt;span&gt;return&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;663&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Fri, 10 Nov 2017 13:38:00 +0000</pubDate>
<dc:creator>nengm</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nengm1988/p/7816618.html</dc:identifier>
</item>
<item>
<title>图解常用算法 - Amedeo</title>
<link>http://www.cnblogs.com/Amedeo/p/7816215.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Amedeo/p/7816215.html</guid>
<description>&lt;p&gt;我们经常会用到一些算法，而大部分算法过于抽象，记忆起来比较困难，而使用图解可以帮助我们更好地理解和记忆这些算法。&lt;/p&gt;
&lt;h2&gt;一、深度优先搜索算法（DFS）&lt;/h2&gt;
&lt;p&gt;深度优先搜索算法（Depth-First-Search），是搜索算法的一种。它是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现 DFS 算法。DFS 属于盲目搜索。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深度优先遍历图算法步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 访问顶点 v；&lt;/p&gt;
&lt;p&gt;2. 依次从 v 的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和 v 有路径相通的顶点都被访问；&lt;/p&gt;
&lt;p&gt;3. 若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。&lt;/p&gt;
&lt;p&gt;上述描述可能比较抽象，举个实例：&lt;/p&gt;
&lt;p&gt;DFS 在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点 w1；再从 w1 出发，访问与 w1 邻接但还没有访问过的顶点 w2；然后再从 w2 出发，进行类似的访问，…如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止。&lt;/p&gt;
&lt;p&gt;接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点。如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问；如果没有，就再退回一步进行搜索。重复上述过程，直到连通图中所有顶点都被访问过为止。&lt;/p&gt;

&lt;h2&gt;二、广度优先搜索算法（BFS）&lt;/h2&gt;
&lt;p&gt;广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法。简单的说，BFS 是从根节点开始，沿着树 (图) 的宽度遍历树 (图) 的节点。如果所有节点均被访问，则算法中止。BFS 同样属于盲目搜索。一般用队列数据结构来辅助实现 BFS 算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 首先将根节点放入队列中。&lt;/p&gt;
&lt;p&gt;2. 从队列中取出第一个节点，并检验它是否为目标。&lt;/p&gt;
&lt;p&gt;如果找到目标，则结束搜寻并回传结果。&lt;/p&gt;
&lt;p&gt;否则将它所有尚未检验过的直接子节点加入队列中。&lt;/p&gt;
&lt;p&gt;3. 若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传「找不到目标」。&lt;/p&gt;
&lt;p&gt;4. 重复步骤 2。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img1.tuicool.com/rEZbMnj.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、归并排序算法&lt;/h2&gt;
&lt;p&gt;归并排序（Mergesort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（DivideandConquer）的一个非常典型的应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列&lt;/p&gt;
&lt;p&gt;2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置&lt;/p&gt;
&lt;p&gt;3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置&lt;/p&gt;
&lt;p&gt;4. 重复步骤 3 直到某一指针达到序列尾&lt;/p&gt;
&lt;p&gt;5. 将另一序列剩下的所有元素直接复制到合并序列尾&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/KfLGF0ibu6cKjBVIUxr7VmibY5YwUMxXicHRzyjT6hk4MfZsGrINyPuaialyK14ib6atVfmCkiaibqjT3zjoZNkgrHicpw/0?wx_fmt=gif&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;&quot; width=&quot;auto&quot; data-ratio=&quot;0.8464285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/KfLGF0ibu6cKjBVIUxr7VmibY5YwUMxXicHRzyjT6hk4MfZsGrINyPuaialyK14ib6atVfmCkiaibqjT3zjoZNkgrHicpw/0?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;280&quot; data-order=&quot;3&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;四、Dijkstra算法&lt;/h2&gt;
&lt;p&gt;戴克斯特拉算法（Dijkstra算法）是由荷兰计算机科学家艾兹赫尔·戴克斯特拉提出。迪科斯彻算法使用了广度优先搜索解决非负权有向图的单源最短路径问题，算法最终得到一个最短路径树。该算法常用于路由算法或者作为其他图算法的一个子模块。&lt;/p&gt;
&lt;p&gt;该算法的输入包含了一个有权重的有向图 G，以及 G 中的一个来源顶点 S。我们以 V 表示 G 中所有顶点的集合。每一个图中的边，都是两个顶点所形成的有序元素对。(u,v) 表示从顶点 u 到 v 有路径相连。我们以 E 表示 G 中所有边的集合，而边的权重则由权重函数 w:E→[0,∞] 定义。因此，w(u,v) 就是从顶点 u 到顶点 v 的非负权重（weight）。边的权重可以想像成两个顶点之间的距离。任两点间路径的权重，就是该路径上所有边的权重总和。已知有 V 中有顶点 s 及 t，Dijkstra 算法可以找到 s 到 t 的最低权重路径 (例如，最短路径)。这个算法也可以在一个图中，找到从一个顶点 s 到任何其他顶点的最短路径。对于不含负权的有向图，Dijkstra 算法是目前已知的最快的单源最短路径算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 初始时令 S={V0},T={其余顶点}，T 中顶点对应的距离值&lt;/p&gt;
&lt;p&gt;若存在，d(V0,Vi) 为弧上的权值&lt;/p&gt;
&lt;p&gt;若不存在，d(V0,Vi) 为∞&lt;/p&gt;
&lt;p&gt;2. 从 T 中选取一个其距离值为最小的顶点 W 且不在 S 中，加入 S&lt;/p&gt;
&lt;p&gt;3. 对其余 T 中顶点的距离值进行修改：若加进 W 作中间顶点，从 V0 到 Vi 的距离值缩短，则修改此距离值&lt;/p&gt;
&lt;p&gt;重复上述步骤 2、3，直到 S 中包含所有顶点，即 W=Vi 为止&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/KfLGF0ibu6cKjBVIUxr7VmibY5YwUMxXicHM8Jz7498EXKGRU7U8Ekribmau1vwgjG6XYJwJ2p6lt3wXeEIC40yuuQ/0?wx_fmt=gif&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;retryload=1&quot; alt=&quot;&quot; width=&quot;auto&quot; data-ratio=&quot;0.784452296819788&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/KfLGF0ibu6cKjBVIUxr7VmibY5YwUMxXicHM8Jz7498EXKGRU7U8Ekribmau1vwgjG6XYJwJ2p6lt3wXeEIC40yuuQ/0?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;283&quot; data-order=&quot;5&quot; data-fail=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;五、Bellman-Ford算法&lt;/h2&gt;
&lt;p&gt;Bellman-Ford算法能在更普遍的情况下（存在负权边）解决单源点最短路径问题。对于给定的带权（有向或无向）图 G=(V , E)，其源点为 s，加权函数 w 是边集 E 的映射。对图 G 运行Bellman-Ford算法的结果是一个布尔值，表明图中是否存在着一个从源点 s 可达的负权回路。若不存在这样的回路，算法将给出从源点 s 到图 G 的任意顶点 v 的最短路径d[v]。Bellman-Ford算法是在带权图中计算从单一源点出发到其他节点的最短路径的算法。&lt;span&gt;尽管算法复杂度大于 Dijkstra 算法，但是它适用于包含了负值边的图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img2.tuicool.com/jEfMnqZ.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;六、Prim算法&lt;/h2&gt;
&lt;p&gt;普里姆算法（Prim算法），图论中一种重要的算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。Prim算法是用于在带权无向图中计算最小生成树的贪婪算法。换言之，它能够在图中抽取出连接所有节点的边的最小代价子集。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img1.tuicool.com/nMnu2mi.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;七、Kruskal算法&lt;/h2&gt;
&lt;p&gt;克鲁斯卡尔算法（ruskal算法）同样是计算图的最小生成树的算法，&lt;span&gt;跟 Prim 算法的区别在于Kruskal算法不需要图是连通的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;alignCenter&quot; src=&quot;https://img1.tuicool.com/aMj2qqJ.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;作者：耑新新，发布于  &lt;a title=&quot;博客园&quot; href=&quot;https://home.cnblogs.com/u/Amedeo/&quot; target=&quot;_blank&quot;&gt;博客园&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转载请注明出处，欢迎邮件交流：&lt;a title=&quot;给我写信&quot; href=&quot;http://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;amp;email=VC48ITU6LD06LD06FDI7LDk1PTh6Nzs5&quot; target=&quot;_blank&quot;&gt;zhuanxinxin@foxmail.com&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 10 Nov 2017 12:49:00 +0000</pubDate>
<dc:creator>Amedeo</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Amedeo/p/7816215.html</dc:identifier>
</item>
<item>
<title>28.Linux-IIC驱动(详解) - LifeYx</title>
<link>http://www.cnblogs.com/lifexy/p/7816324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lifexy/p/7816324.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;上一节&lt;/span&gt; 我们学习了:  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;IIC接口下的24C02 驱动分析:&lt;/span&gt; &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/lifexy/p/7793686.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/lifexy/p/7793686.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来本节, 学习Linux下如何利用linux下I2C驱动体系结构来操作24C02&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. I2C体系结构分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.1首先进入linux内核的driver/i2c目录下,如下图所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194402075-2024973640.png&quot; alt=&quot;&quot; width=&quot;476&quot; height=&quot;138&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中重要的文件介绍如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1)&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;algos文件夹&lt;/span&gt;(algorithms)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;里面保存I2C的通信方面的算法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2)&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;busses文件夹&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;里面保存I2C总线驱动相关的文件,比如i2c-omap.c、 i2c-versatile.c、 i2c-s3c2410.c等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;3)&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;chips文件夹&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;里面保存I2C设备驱动相关的文件,如下图所示,比如m41t00,就是RTC实时钟&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194416216-654621318.png&quot; alt=&quot;&quot; width=&quot;369&quot; height=&quot;174&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;4)&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;i2c-core.c&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这个文件实现了I2C核心的功能(I2C总线的初始化、注册和适配器添加和注销等相关工作)以及/proc/bus/i2c*接口。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;5)&lt;/strong&gt;&lt;/span&gt; &lt;span&gt;i2c-dev.c&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;提供了通用的read（ ） 、 write（ ） 和ioctl（ ） 等接口，实现了I2C适配器设备文件的功能，其中I2C设备的主设备号都为89， 次设备号为0~255。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;应用层可以借用这些接口访问挂接在适配器上的I2C设备的存储空间或寄存器， 并控制I2C设备的工作方&lt;/span&gt;&lt;span&gt;式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然,它和前几次驱动类似， I2C也分为总线驱动和设备驱动,总线就是协议相关的，它知道如何收发数据，但不知道数据含义，设备驱动却知道数据含义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.2 I2C驱动架构,如下图所示:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194431294-567878229.png&quot; alt=&quot;&quot; width=&quot;274&quot; height=&quot;494&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图所示,每一条I2C对应一个adapter适配器,在kernel中, adapter适配器是通过struct adapter结构体定义,主要是通过i2c core层将i2c设备与i2c adapter关联起来.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在kernel中提供了&lt;span&gt;两个adapter注册接口&lt;/span&gt;,分别为i2c_add_adapter()和i2c_add_numbered_adapter().由于在系统中可能存在多个adapter,因为将每一条I2C总线对应一个编号,下文中称为I2C总线号.这个总线号的PCI中的总线号不同.它和硬件无关,只是软件上便于区分而已.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于i2c_add_adapter()而言,它使用的是动态总线号,即由系统给其分析一个总线号,而i2c_add_numbered_adapter()则是自己指定总线号,如果这个总线号非法或者是被占用,就会注册失败.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.接下来便来分析I2C总线驱动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考 drivers/i2c/busses/i2c-s3c2410.c&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先进入init入口函数,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194447059-1799759547.png&quot; alt=&quot;&quot; width=&quot;435&quot; height=&quot;304&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在init函数中,注册了一个 &lt;span&gt;“s3c2440-i2c”&lt;/span&gt;的platform_driver平台驱动,我们来看看probe函数做了些什么&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.进入s3c24xx_i2c_probe函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; i2c_adapter  adap;

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; s3c24xx_i2c_probe(&lt;span&gt;struct&lt;/span&gt; platform_device *&lt;span&gt;pdev)
{
　　　　&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; s3c24xx_i2c *i2c = &amp;amp;&lt;span&gt;s3c24xx_i2c;
       ... ...

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;获取,使能I2C时钟&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       i2c&lt;/span&gt;-&amp;gt;clk = clk_get(&amp;amp;pdev-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;i2c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取i2c时钟&lt;/span&gt;&lt;span&gt;
       clk_enable(i2c&lt;/span&gt;-&amp;gt;clk);                                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使能i2c时钟&lt;/span&gt;
&lt;span&gt;
       ... ....
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;获取资源&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       res &lt;/span&gt;= platform_get_resource(pdev, IORESOURCE_MEM, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
       i2c&lt;/span&gt;-&amp;gt;regs = ioremap(res-&amp;gt;start, (res-&amp;gt;end-res-&amp;gt;start)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

       ... ....

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置i2c_adapter适配器结构体, 将i2c结构体设为adap的私有数据成员&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
　　　　i2c&lt;/span&gt;-&amp;gt;adap.algo_data = i2c;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;i2c_adapter适配器指向s3c24xx_i2c;&lt;/span&gt;&lt;span&gt;
       i2c&lt;/span&gt;-&amp;gt;adap.dev.parent = &amp;amp;pdev-&amp;gt;&lt;span&gt;dev;

 
　　　　&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; initialise the i2c controller &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;初始化2440的I2C相关的寄存器&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       ret &lt;/span&gt;=&lt;span&gt; s3c24xx_i2c_init(i2c);
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ret != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
              &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; err_iomap;

       ... ...
       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;注册中断服务函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       ret &lt;/span&gt;= request_irq(res-&amp;gt;start, s3c24xx_i2c_irq, IRQF_DISABLED,pdev-&amp;gt;&lt;span&gt;name, i2c);
       ... ...

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;注册i2c_adapter适配器结构体&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       ret &lt;/span&gt;= i2c_add_adapter(&amp;amp;i2c-&amp;gt;&lt;span&gt;adap);
       ... ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中i2c_adapter结构体是放在s3c24xx_i2c-&amp;gt;adap下,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194502481-835272550.png&quot; alt=&quot;&quot; width=&quot;317&quot; height=&quot;300&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.接下来我们进入i2c_add_adapter()函数看看,到底如何注册的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; i2c_add_adapter(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *&lt;span&gt;adapter)
{
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;   id, res = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

retry:
       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (idr_pre_get(&amp;amp;i2c_adapter_idr, GFP_KERNEL) == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用idr_pre_get()为i2c_adapter预留内存空间&lt;/span&gt;
              &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;ENOMEM;

       mutex_lock(&lt;/span&gt;&amp;amp;&lt;span&gt;core_lists);

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; &quot;above&quot; here means &quot;above or equal to&quot;, sigh &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
       res &lt;/span&gt;= idr_get_new_above(&amp;amp;i2c_adapter_idr, adapter,__i2c_first_dynamic_bus_num, &amp;amp;&lt;span&gt;id);
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用idr_get_new_above()将结构插入i2c_adapter_idr中,并将插入的位置赋给id,以后可以通过id在i2c_adapter_idr中找到相应的i2c_adapter结构体&lt;/span&gt;
&lt;span&gt;
       mutex_unlock(&lt;/span&gt;&amp;amp;&lt;span&gt;core_lists);

       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (res &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (res == -&lt;span&gt;EAGAIN)
                    &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; retry;
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
       }
       adapter&lt;/span&gt;-&amp;gt;nr =&lt;span&gt; id;
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; i2c_register_adapter(adapter);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用i2c_register_adapter()函数进一步来注册.&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中i2c_register_adapter()函数代码如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i2c_register_adapter(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *&lt;span&gt;adap)
{
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; list_head  *item;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表头,用来存放i2c_driver结构体的表头&lt;/span&gt;
       &lt;span&gt;struct&lt;/span&gt; i2c_driver *driver;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;i2c_driver,用来描述一个IIC设备驱动&lt;/span&gt;&lt;span&gt;
        list_add_tail(&lt;/span&gt;&amp;amp;adap-&amp;gt;list, &amp;amp;adapters);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加到内核的adapter链表中&lt;/span&gt;&lt;span&gt;
        ... ...
       list_for_each(item,&lt;/span&gt;&amp;amp;drivers) {        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;for循环,从drivers链表里找到i2c_driver结构体的表头&lt;/span&gt;&lt;span&gt;
              driver &lt;/span&gt;= list_entry(item, &lt;span&gt;struct&lt;/span&gt; i2c_driver, list); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过list_head表头,找到i2c_driver结构体&lt;/span&gt;
              &lt;span&gt;if&lt;/span&gt; (driver-&amp;gt;&lt;span&gt;attach_adapter)  
                     &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; We ignore the return code; if it fails, too bad &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                     driver&lt;/span&gt;-&amp;gt;&lt;span&gt;attach_adapter(adap);    &lt;br/&gt;　　　　　　　　　　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用i2c_driver的attach_adapter函数来看看,这个新注册的设配器是否支持i2c_driver&lt;/span&gt;&lt;span&gt; }&lt;br/&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在i2c_register_adapter()函数里主要执行以下几步:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;①&lt;/strong&gt;&lt;/span&gt;将adapter放入i2c_bus_type的&lt;span&gt;adapter链表&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;②&lt;/span&gt;&lt;/strong&gt;将所有的i2c设备调出来,执行i2c_driver设备的attach_adapter函数来匹配&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中, i2c_driver结构体会在后面讲述到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;而i2c_adapter适配器结构体的成员结构,如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; i2c_adapter {  

 &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; module *owner;　　　　　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;所属模块  &lt;/span&gt;&lt;span&gt;
 unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; id;　　　　　　　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;algorithm的类型，定义于i2c-id.h,  &lt;/span&gt;&lt;span&gt;
 unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt;;      
 &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; i2c_algorithm *algo; 　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;总线通信方法结构体指针  &lt;/span&gt;
 &lt;span&gt;void&lt;/span&gt; *algo_data;   　　　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;algorithm数据  &lt;/span&gt;
 &lt;span&gt;struct&lt;/span&gt; rt_mutex bus_lock;　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;控制并发访问的自旋锁  &lt;/span&gt;
 &lt;span&gt;int&lt;/span&gt;&lt;span&gt; timeout;     
 &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; retries;　　　　　　　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重试次数  &lt;/span&gt;
 &lt;span&gt;struct&lt;/span&gt; device dev; 　　　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;适配器设备   &lt;/span&gt;
 &lt;span&gt;int&lt;/span&gt; nr;                  　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放在i2c_adapter_idr里的位置号&lt;/span&gt;
 &lt;span&gt;char&lt;/span&gt; name[&lt;span&gt;48&lt;/span&gt;];　　　　　　　　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;适配器名称  &lt;/span&gt;
 &lt;span&gt;struct&lt;/span&gt; completion dev_released;　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于同步  &lt;/span&gt;
 &lt;span&gt;struct&lt;/span&gt; list_head userspace_clients;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;client链表头  &lt;/span&gt;
&lt;span&gt;
};  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;i2c_adapter表示物理上的一个i2C设备(适配器), 在i2c-s3c2410.c中,是存放在s3c24xx_i2c结构体下的(struct  i2c_adapter  adap)成员中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.其中s3c24xx_i2c的结构体成员如下所示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; i2c_algorithm s3c24xx_i2c_algorithm =&lt;span&gt; {            
       .master_xfer          &lt;/span&gt;= s3c24xx_i2c_xfer,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;主机传输&lt;/span&gt;&lt;span&gt;
       .functionality          &lt;/span&gt;=&lt;span&gt; s3c24xx_i2c_func,                    
};

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; s3c24xx_i2c s3c24xx_i2c =&lt;span&gt; {
       .&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt;              = __SPIN_LOCK_UNLOCKED(s3c24xx_i2c.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;),
       .wait              &lt;/span&gt;=&lt;span&gt; __WAIT_QUEUE_HEAD_INITIALIZER(s3c24xx_i2c.wait),
       .tx_setup &lt;/span&gt;= &lt;span&gt;50&lt;/span&gt;,                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来延时,等待SCL被释放&lt;/span&gt;&lt;span&gt;
       .adap             &lt;/span&gt;= {                                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; i2c_adapter适配器结构体&lt;/span&gt;&lt;span&gt;
              .name                   &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;s3c2410-i2c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
              .owner                  &lt;/span&gt;=&lt;span&gt; THIS_MODULE,
              .algo                     &lt;/span&gt;= &amp;amp;s3c24xx_i2c_algorithm,           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放i2c_algorithm算法结构体&lt;/span&gt;&lt;span&gt;
              .retries           &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;,                                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重试次数&lt;/span&gt;&lt;span&gt;
              .&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;                    =&lt;span&gt; I2C_CLASS_HWMON,
       },
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;显然这里是直接设置了i2c_adapter结构体,所以在s3c24xx_i2c_probe ()函数中没有分配i2c_adapter适配器结构体,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中, i2c_adapter结构体的名称等于&quot;s3c2410-i2c&quot;,它的通信方式等于s3c24xx_i2c_algorithm,重试次数等于2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;PS:如果缺少i2c_algorithm的i2c_adapter什么也做不了，就只是个I2C设备,而没有通信方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;s3c24xx_i2c_algorithm中的关键函数master_xfer()就是用于产生i2c访问周期需要的&lt;span&gt;start stop ack&lt;/span&gt;等信号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如,在s3c24xx_i2c_algorithm中的关键函数master_xfer()里,调用了:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;s3c24xx_i2c_xfer -&amp;gt; s3c24xx_i2c_doxfer()-&amp;gt;s3c24xx_i2c_message_start()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;来启动传输message信息, 其中&lt;span&gt;s3c24xx_i2c_message_start()&lt;/span&gt;函数代码如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; s3c24xx_i2c_message_start(&lt;span&gt;struct&lt;/span&gt; s3c24xx_i2c *i2c, &lt;span&gt;struct&lt;/span&gt; i2c_msg *&lt;span&gt;msg)
{

 unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; addr = (msg-&amp;gt;addr &amp;amp; &lt;span&gt;0x7f&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IIC从设备地址的最低位为读写标志位&lt;/span&gt;&lt;span&gt;
       ... ...

       stat &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
       stat &lt;/span&gt;|=  S3C2410_IICSTAT_TXRXEN;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置标志位启动IIC收发使能&lt;/span&gt;

       &lt;span&gt;if&lt;/span&gt; (msg-&amp;gt;flags &amp;amp; I2C_M_RD) {                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是读,还是写&lt;/span&gt;&lt;span&gt;
              stat &lt;/span&gt;|=&lt;span&gt; S3C2410_IICSTAT_MASTER_RX;       
              addr &lt;/span&gt;|= &lt;span&gt;1&lt;/span&gt;;                                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置从IIC设备地址为读标志&lt;/span&gt;&lt;span&gt;
       } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
              stat &lt;/span&gt;|=&lt;span&gt; S3C2410_IICSTAT_MASTER_TX;

       s3c24xx_i2c_enable_ack(i2c);                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使能ACK信号&lt;/span&gt;
&lt;span&gt;
　　　　iiccon &lt;/span&gt;= readl(i2c-&amp;gt;regs + S3C2410_IICCON);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读出IICCON寄存器&lt;/span&gt;
&lt;span&gt;
       writel(stat, i2c&lt;/span&gt;-&amp;gt;regs + S3C2410_IICSTAT);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入IICSTAT寄存器,使能IIC的读或写标志&lt;/span&gt;
&lt;span&gt;
       dev_dbg(i2c&lt;/span&gt;-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;START: %08lx to IICSTAT, %02x to DS\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, stat, addr);

       writeb(addr, i2c&lt;/span&gt;-&amp;gt;regs + S3C2410_IICDS);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将IIC从设备地址写入IICDS寄存器&lt;/span&gt;

       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; delay here to ensure the data byte has gotten onto the bus
        * before the transaction is started &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;

       ndelay(i2c&lt;/span&gt;-&amp;gt;tx_setup);         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;延时,等待SCL被释放,下面便可以发送起始信号+IIC设备地址值&lt;/span&gt;
&lt;span&gt;

       dev_dbg(i2c&lt;/span&gt;-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;iiccon, %08lx\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, iiccon);
       writel(iiccon, i2c&lt;/span&gt;-&amp;gt;regs +&lt;span&gt; S3C2410_IICCON);            

       stat &lt;/span&gt;|=&lt;span&gt;  S3C2410_IICSTAT_START;              
       writel(stat, i2c&lt;/span&gt;-&amp;gt;regs +&lt;span&gt; S3C2410_IICSTAT); 
　　　　　　　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置IICSTAT寄存器的bit5=1,开始发送起始信号+IIC从设备地址值,并回应ACK&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过上面的代码和注释,发现主要是写入IIC从设备地址,然后发送起始信号+IIC从设备地址值,并回应ACK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然IIC总线驱动i2c-s3c2410.c,主要设置适配器adapter,里面帮我们做好了IIC通信的架构,就是不知道发什么内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;我们进入driver/i2c/chips中,看看eeprom设备驱动是如何写的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考: driver/i2c/chips/eeprom.c&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.还是首先来看它的init入口函数:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194519716-1730511691.png&quot; alt=&quot;&quot; width=&quot;504&quot; height=&quot;147&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中struct  i2c_driver  eeprom_driver的成员如下:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; i2c_driver eeprom_driver =&lt;span&gt; {
       .driver &lt;/span&gt;=&lt;span&gt; {
              .name     &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eeprom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;
        },
       .id           &lt;/span&gt;= I2C_DRIVERID_EEPROM,           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IIC设备标识ID&lt;/span&gt;&lt;span&gt;
       .attach_adapter     &lt;/span&gt;=&lt;span&gt; eeprom_attach_adapter,  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来与总线驱动的适配器匹配,匹配成功添加到适配器adapter中&lt;/span&gt;&lt;span&gt;
       .detach_client &lt;/span&gt;= eeprom_detach_client,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;与总线驱动的适配器解绑,分离这个IIC从设备&lt;/span&gt;&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如下图所示, eeprom_driver结构体的ID成员在i2c-id.h中,里面还定义了大部分常用I2C设备驱动的设备ID&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194533466-969534257.png&quot; alt=&quot;&quot; width=&quot;287&quot; height=&quot;298&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;显然,在init函数中通过i2c_add_driver()注册i2c_driver结构体,然后通过i2c_driver -&amp;gt;attach_adapter来匹配内核中的各个总线驱动的适配器, 发送这个设备地址,若有ACK响应,表示匹配成功&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7.接下来,我们进入i2c_add_driver()来看看是不是这样的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; i2c_add_driver(&lt;span&gt;struct&lt;/span&gt; module *owner, &lt;span&gt;struct&lt;/span&gt; i2c_driver *&lt;span&gt;driver)
{
       driver&lt;/span&gt;-&amp;gt;driver.owner =&lt;span&gt; owner;
       driver&lt;/span&gt;-&amp;gt;driver.bus = &amp;amp;i2c_bus_type;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将i2c_driver放在i2c_bus_type链表中&lt;/span&gt;&lt;span&gt;   

       res &lt;/span&gt;= driver_register(&amp;amp;driver-&amp;gt;driver); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册一个i2c_driver&lt;/span&gt;&lt;span&gt;
       ... ...

       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (driver-&amp;gt;&lt;span&gt;attach_adapter) {
              &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; i2c_adapter *adapter;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个i2c_adapter适配器&lt;/span&gt;&lt;span&gt;
          list_for_each_entry(adapter, &lt;/span&gt;&amp;amp;&lt;span&gt;adapters, list)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;for循环提取出adapters链表中所有的i2c_adapter适配器,放入到adapter结构体中&lt;/span&gt;&lt;span&gt;
 　　　　　{
          driver&lt;/span&gt;-&amp;gt;attach_adapter(adapter); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;来匹配取出来的i2c_adapter适配器&lt;/span&gt;&lt;span&gt;
          }
  }
      ... ...
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在i2c_add_driver ()函数里主要执行以下几步:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;①&lt;/strong&gt;&lt;/span&gt;放入到&lt;span&gt;i2c_bus_type链表&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;②&lt;/strong&gt;&lt;/span&gt;取出&lt;span&gt;adapters链表&lt;/span&gt;中所有的i2c_adapter,然后执行&lt;span&gt;i2c_driver-&amp;gt;attach_adapter()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;所以i2c_adapter适配器和i2c_driver设备驱动注册框架如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194549372-635602878.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这里调用了i2c_driver -&amp;gt;attach_adapter(adapter),我们看看里面是不是通过发送IIC设备地址，等待ACK响应来匹配的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.以struct i2c_driver eeprom_driver 为例,进入i2c_driver -&amp;gt;eeprom_attach_adapter()函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194557138-2076450775.png&quot; alt=&quot;&quot; width=&quot;446&quot; height=&quot;154&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示,里面调用了i2c_probe(adapter, &amp;amp;addr_data, eeprom_detect)函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194605794-2061351036.png&quot; alt=&quot;&quot; width=&quot;551&quot; height=&quot;75&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图的&lt;span&gt;第1个参数&lt;/span&gt;就是i2c_adapter适配器,&lt;span&gt;第2个参数&lt;/span&gt;addr_data变量,里面存放了IIC设备地址的信息,&lt;span&gt;第3个参数&lt;/span&gt;eeprom_detect就是具体的设备探测回调函数&lt;/span&gt;&lt;span&gt;i2c_probe()函数,会通过adapter适配器发送IIC设备地址addr_data,如果收到ACK信号,就调用eeprom_detect()回调函数来注册i2c_client结构体,该结构体对应真实的物理从设备,而i2c_driver对应的是设备驱动,也就是说,只有当适配器支持这个设备驱动,才会注册i2c_client从设备,后面会讲这个回调函数如何注册i2c_client&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而在i2c_driver -&amp;gt;detach_client()中,则注销i2c_client结构体&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中addr_data变量是&lt;span&gt;struct i2c_client_address_data&lt;/span&gt;&lt;strong&gt;结构体&lt;/strong&gt;,它的成员如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; i2c_client_address_data {
       unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *normal_i2c;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放正常的设备高7位地址数据&lt;/span&gt;&lt;span&gt;
       unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *probe;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放不受*ignore影响的高7位设备地址数据&lt;/span&gt;&lt;span&gt;
       unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; *ignore;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放*ignore的高7位设备地址数据&lt;/span&gt;&lt;span&gt;
       unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; **forces;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;forces表示适配器匹配不了该设备,也要将其放入适配器中&lt;/span&gt;
&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当上面结构体的数组成员以I2C_CLIENT_END结尾,则表示地址已结束,&lt;span&gt;比如at24c02设备为例&lt;/span&gt;,看这个结构体如何定义的:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt;  AT24C02_ADDR           (0xA0&amp;gt;&amp;gt;1)           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;AT24C02地址&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;short&lt;/span&gt;  ignore[] =&lt;span&gt; { I2C_CLIENT_END };
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;short&lt;/span&gt;  normal_addr[] =&lt;span&gt; { AT24C02_ADDR, I2C_CLIENT_END };
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;short&lt;/span&gt;   force_addr[] =&lt;span&gt; {ANY_I2C_BUS, AT24C02_ADDR ,2C_CLIENT_END};
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;short&lt;/span&gt;   * forces[] =&lt;span&gt; {force_addr, NULL};&lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　　　　//&lt;/span&gt;&lt;span&gt;ANY_I2C_BUS:表示支持所有适配器总线,若填指定的适配器总线ID,则表示该设备只支持指定的那个适配器&lt;/span&gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; i2c_client_address_data  addr_data =&lt;span&gt; {
       .normal_i2c     &lt;/span&gt;= normal_addr,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放at24c02地址&lt;/span&gt;&lt;span&gt;
       .probe           &lt;/span&gt;= ignore,        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示无地址&lt;/span&gt;&lt;span&gt;
       .ignore           &lt;/span&gt;= ignore,        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示无地址&lt;/span&gt;&lt;span&gt;
       . forces          &lt;/span&gt;= forces,        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放强制的at24c02地址,表示强制支持&lt;/span&gt;
&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一般而言,都不会设置.forces成员,这里只是打个比方&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;8.1接下来继续进入i2c_probe()函数继续分析,如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; i2c_probe(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *&lt;span&gt;adapter,&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; i2c_client_address_data *&lt;span&gt;address_data,&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; (*found_proc) (&lt;span&gt;struct&lt;/span&gt; i2c_adapter *, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;))
{
       ... ...
       err &lt;/span&gt;=&lt;span&gt; i2c_probe_address(adapter,forces[kind][i &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;&lt;span&gt;],kind, found_proc);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;里面调用了i2c_probe_address()函数,从名称上来看,显然它就是用来发送起始信号+设备地址,来探测IIC设备地址用的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.2进入i2c_probe_address()函数:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; i2c_probe_address(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *adapter, &lt;span&gt;int&lt;/span&gt; addr, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; kind,&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; (*found_proc) (&lt;span&gt;struct&lt;/span&gt; i2c_adapter *, &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;&lt;span&gt;))
{

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;判断设备地址是否有效,addr里存放的是设备地址前7位,比如AT24C02=0xA0,那么addr=0x50&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;if&lt;/span&gt; (addr &amp;lt; &lt;span&gt;0x03&lt;/span&gt; || addr &amp;gt; &lt;span&gt;0x77&lt;/span&gt;&lt;span&gt;) {
              dev_warn(&lt;/span&gt;&amp;amp;adapter-&amp;gt;dev, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invalid probe address 0x%02x\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,addr);    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印地址无效,并退出&lt;/span&gt;
              &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;EINVAL;
       }

       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;查找链表中其它IIC设备的设备地址,若这个设备地址已经被使用,则return&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
       &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (i2c_check_addr(adapter, addr))
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;; 

       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (kind &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
              &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i2c_smbus_xfer(adapter, addr, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,I2C_SMBUS_QUICK, NULL) &lt;/span&gt;&amp;lt; &lt;span&gt;0&lt;/span&gt;)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进入I2C传输函数&lt;/span&gt;
　　　　　　　　 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
       ... ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.3 其中i2c_smbus_xfer()传输函数如下:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
s32 i2c_smbus_xfer(&lt;span&gt;struct&lt;/span&gt; i2c_adapter * adapter, u16 addr, unsigned &lt;span&gt;short&lt;/span&gt;&lt;span&gt; flags,&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; read_write, u8 command, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size,union i2c_smbus_data &lt;/span&gt;*&lt;span&gt; data)
{
       s32 res;

       flags &lt;/span&gt;&amp;amp;= I2C_M_TEN |&lt;span&gt; I2C_CLIENT_PEC;

       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (adapter-&amp;gt;algo-&amp;gt;smbus_xfer) {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果adapter适配器有smbus_xfer这个函数&lt;/span&gt;&lt;span&gt;
              mutex_lock(&lt;/span&gt;&amp;amp;adapter-&amp;gt;bus_lock);                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加互斥锁&lt;/span&gt;&lt;span&gt;
              res &lt;/span&gt;= adapter-&amp;gt;algo-&amp;gt;&lt;span&gt;smbus_xfer(adapter,addr,flags,read_write,command,size,data);  &lt;br/&gt;&lt;/span&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　//&lt;/span&gt;&lt;span&gt;调用adapter适配器里的传输函数&lt;/span&gt;&lt;span&gt;
              mutex_unlock(&lt;/span&gt;&amp;amp;adapter-&amp;gt;bus_lock);                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解互斥锁&lt;/span&gt;&lt;span&gt;
       } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则使用默认函数传输设备地址&lt;/span&gt;&lt;span&gt;
              res &lt;/span&gt;=&lt;span&gt; i2c_smbus_xfer_emulated(adapter,addr,flags,read_write,command,size,data);
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;看了上面代码后,显然我们的s3c2410-i2c适配器没有algo-&amp;gt;smbus_xfer函数,而是使用&lt;span&gt;i2c_smbus_xfer_emulated()&lt;/span&gt;函数,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194624247-1622232895.png&quot; alt=&quot;&quot; width=&quot;438&quot; height=&quot;221&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;PS:通常适配器都是不支持的,使用默认的i2c_smbus_xfer_emulated()函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.4 接下来看i2c_smbus_xfer_emulated()函数如何传输的:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; s32 i2c_smbus_xfer_emulated(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *&lt;span&gt; adapter, u16 addr,unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt;&lt;span&gt; flags,&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; read_write, u8 command, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size, union i2c_smbus_data &lt;/span&gt;*&lt;span&gt; data)
{
       unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; msgbuf0[I2C_SMBUS_BLOCK_MAX+&lt;span&gt;3&lt;/span&gt;];              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;属于 msg[0]的buf成员&lt;/span&gt;&lt;span&gt;
       unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; msgbuf1[I2C_SMBUS_BLOCK_MAX+&lt;span&gt;2&lt;/span&gt;];              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;属于 msg[1]的buf成员&lt;/span&gt;
       &lt;span&gt;int&lt;/span&gt; num = read_write == I2C_SMBUS_READ?&lt;span&gt;2&lt;/span&gt;:&lt;span&gt;1&lt;/span&gt;;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果为读命令,就等于2,表示要执行两次数据传输&lt;/span&gt;
       &lt;span&gt;struct&lt;/span&gt; i2c_msg msg[&lt;span&gt;2&lt;/span&gt;] = { { addr, flags, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;, msgbuf0 },
　　　　　　　　　　　　　　　　　　　　{ addr, flags &lt;/span&gt;| I2C_M_RD, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, msgbuf1 }};           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义两个i2c_msg结构体,&lt;/span&gt;
&lt;span&gt;

       msgbuf0[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = command;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;IIC设备地址最低位为读写命令&lt;/span&gt;&lt;span&gt;
       ... ...&lt;br/&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i2c_transfer(adapter, msg, num) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
              &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

              &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置i2c_msg结构体成员&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
              &lt;span&gt;if&lt;/span&gt; (read_write ==&lt;span&gt; I2C_SMBUS_READ)
              &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(size) {
              ... ...
              &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; I2C_SMBUS_BYTE_DATA:              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是读字节&lt;/span&gt;
              &lt;span&gt;if&lt;/span&gt; (read_write ==&lt;span&gt; I2C_SMBUS_READ)
                     msg[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;].len = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
              &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                     msg[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].len = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
                     msgbuf0[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = data-&amp;gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;;
              }
              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
              ... ...
              }
       ... ...

       &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i2c_transfer(adapter, msg, num) &amp;lt; &lt;span&gt;0&lt;/span&gt;)             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将 i2c_msg结构体的内容发送给I2C设备&lt;/span&gt;
              &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
       ... ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中i2c_msg结构体的结构,如下所示:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; i2c_msg {
       __u16 addr;    　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;I2C从机的设备地址&lt;/span&gt;&lt;span&gt;
       __u16 flags;     　　    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当flags=0表示写, flags= I2C_M_RD表示读&lt;/span&gt;&lt;span&gt;
       __u16 len;              &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传输的数据长度,等于buf数组里的字节数&lt;/span&gt;&lt;span&gt;
       __u8 &lt;/span&gt;*buf;              &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存放数据的数组&lt;/span&gt;&lt;span&gt;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;上面代码中之所以&lt;span&gt;读操作&lt;/span&gt;需要两个i2c_msg,&lt;span&gt;写操作&lt;/span&gt;需要一个i2c_msg,是因为读IIC设备是两个流程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上一节&lt;/span&gt;&lt;span&gt;&lt;span&gt;IIC接口下的24C02 驱动分析:&lt;/span&gt; &lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/lifexy/p/7793686.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.cnblogs.com/lifexy/p/7793686.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;里就已经分析到了,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;只要发送一个S起始信号则就是一个i2c_msg,如下两个读写操作图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194638622-994179422.png&quot; alt=&quot;&quot; width=&quot;450&quot; height=&quot;153&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194645528-2046926273.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;141&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而在i2c_transfer()函数中,最终又是调用了之前分析的i2c_adapter-&amp;gt;algo-&amp;gt;master_xfer()发送函数,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194708669-885477807.png&quot; alt=&quot;&quot; width=&quot;528&quot; height=&quot;250&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中&lt;span&gt;i2c_transfer()&lt;/span&gt;的参数*adap表示通过哪个适配器传输出去,msgs表示I2C消息,num表示msgs的数目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内核每发送一个Msg都会先发出S开始信号和设备地址.直到所有Msg传输完毕，最后发出P停止信号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当&lt;span&gt;i2c_transfer()&lt;/span&gt;返回值为正数,表示已经传输正数个数据,当返回负数,说明I2C传输出错&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8.5 所以在i2c_driver -&amp;gt;attach_adapter(adapter)函数里主要执行以下几步:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1)&lt;/span&gt;&lt;/strong&gt; 调用 &lt;span&gt;i2c_probe(&lt;/span&gt;adap, &lt;span&gt;i2c_client_address_data&lt;/span&gt;&lt;strong&gt;设备地址结构体&lt;/strong&gt;, 回调函数&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2)&lt;/span&gt;&lt;/strong&gt; 将要发的&lt;span&gt;设备地址结构体&lt;/span&gt;打包成&lt;span&gt;i2c_msg&lt;/span&gt;,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3)&lt;/span&gt;&lt;/strong&gt; 然后执行&lt;span&gt;i2c_transfer()&lt;/span&gt;来调用i2c_adapter-&amp;gt;algo-&amp;gt;master_xfer()将i2c_msg发出去&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4)&lt;/span&gt;&lt;/strong&gt;若收到ACK回应,便进入回调函数,&lt;span&gt;注册i2c_client&lt;/span&gt;从设备,使该设备与适配器联系在一起&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;所以适配器和iic设备驱动最终注册框架图如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194722247-1723647250.png&quot; alt=&quot;&quot; width=&quot;659&quot; height=&quot;411&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;9.接下来便来分析回调函数如何注册i2c_client从设备的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先来看看i2c_client结构体:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; i2c_client {  

 unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; flags；&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标志    &lt;/span&gt;
&lt;span&gt;
 unsigned &lt;/span&gt;&lt;span&gt;short&lt;/span&gt; addr; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该i2c从设备的设备地址,存放地址高7位  &lt;/span&gt;

 &lt;span&gt;char&lt;/span&gt; name[I2C_NAME_SIZE];   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备名字&lt;/span&gt;

 &lt;span&gt;struct&lt;/span&gt; i2c_adapter *adapter;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;依附的i2c_adapter,表示该IIC设备支持哪个适配器  &lt;/span&gt;

 &lt;span&gt;struct&lt;/span&gt; i2c_driver *driver;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;依附的i2c_driver ,表示该IIC从设备的驱动是哪个&lt;/span&gt;

 &lt;span&gt;struct&lt;/span&gt; device dev;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备结构体    &lt;/span&gt;

 &lt;span&gt;int&lt;/span&gt; irq;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设备所使用的结构体    &lt;/span&gt;

 &lt;span&gt;struct&lt;/span&gt; list_head detected;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;链表头  &lt;/span&gt;
&lt;span&gt;
 };  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;还是以driver/i2c/chips/eeprom.c为例,如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194741044-298465589.png&quot; alt=&quot;&quot; width=&quot;489&quot; height=&quot;77&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;9.1这里的回调函数是eeprom_detect()函数,代码如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; eeprom_detect(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *adapter, &lt;span&gt;int&lt;/span&gt; address, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; kind)
{
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; i2c_client *new_client;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个i2c_client结构体局部变量&lt;/span&gt;
&lt;span&gt;
new_client &lt;/span&gt;=kzalloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt; i2c_client), GFP_KERNEL);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;分配i2c_client结构体为全局变量&lt;/span&gt;


&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置i2c_client结构体&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
new_client&lt;/span&gt;-&amp;gt;addr = address;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置设备地址&lt;/span&gt;&lt;span&gt;
new_client&lt;/span&gt;-&amp;gt;adapter = adapter;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置依附的i2c_adapter&lt;/span&gt;&lt;span&gt;
new_client&lt;/span&gt;-&amp;gt;driver = &amp;amp;eeprom_driver;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置依附的i2c_driver&lt;/span&gt;&lt;span&gt;
new_client&lt;/span&gt;-&amp;gt;flags = &lt;span&gt;0&lt;/span&gt;;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置标志位为初始值&lt;/span&gt;&lt;span&gt;
strlcpy(new_client&lt;/span&gt;-&amp;gt;name, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eeprom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, I2C_NAME_SIZE);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置名字&lt;/span&gt;


 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;注册i2c_client&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
 &lt;span&gt;if&lt;/span&gt; ((err =&lt;span&gt; i2c_attach_client(new_client)))
        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt; exit_kfree;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册失败,便释放i2c_client这个全局变量&lt;/span&gt;&lt;span&gt;
 ... ...&lt;br/&gt;exit_kfree:
       kfree(new_client);
exit:
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; err;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当注册了i2c_client从设备后,便可以使用&lt;span&gt;i2c_transfer()&lt;/span&gt;来实现与设备传输数据了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;10.接下来,我们便参考driver/i2c/chips/eeprom.c驱动,来写出24C02驱动以及测试程序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;驱动代码步骤如下:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;定义&lt;span&gt;file_operations&lt;/span&gt;结构体 ,设置字符设备的读写函数(实现对24C02的读写操作)&lt;br/&gt;&lt;span&gt;//构造i2c_msg结构体, 使用i2c_transfer()来实现与设备传输数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;定义&lt;span&gt;i2c_client_address_data&lt;/span&gt;结构体,里面保存24C02的设备地址&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; 定义一个&lt;span&gt;i2c_driver&lt;/span&gt;驱动结构体&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;   3.1&lt;/strong&gt;&lt;/span&gt; 设置i2c_driver-&amp;gt; attach_adapter&lt;br/&gt;　　　　 &lt;span&gt;// 里面直接调用 i2c_probe(adap, i2c_client_address_data结构体, 回调函数);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　 &lt;span&gt;&lt;strong&gt;  3.2&lt;/strong&gt;&lt;/span&gt; 设置i2c_driver-&amp;gt; detach_client&lt;br/&gt;　   &lt;span&gt;        //里面卸载i2c_client, 字符设备&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.&lt;/strong&gt;&lt;/span&gt;写&lt;span&gt;回调函数&lt;/span&gt;,里面注册i2c_client,字符设备( 字符设备用来实现读写24C02里的数据)&lt;br/&gt;      &lt;strong&gt;&lt;span&gt;4.1&lt;/span&gt;&lt;/strong&gt; 分配并设置i2c_client&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;&lt;span&gt;4.2&lt;/span&gt;&lt;/strong&gt; 使用i2c_attach_client()将i2c_client与适配器进行连接&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;&lt;span&gt;4.3&lt;/span&gt;&lt;/strong&gt; 注册字符设备&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.&lt;/span&gt;&lt;/strong&gt; 写init入口函数,exit出口函数&lt;br/&gt;init: 使用i2c_add_driver()注册i2c_driver&lt;br/&gt;exit: 使用i2c_del_driver ()卸载i2c_driver&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;具体驱动代码如下所示:&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;90&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 *  I2C-24C02
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/kernel.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/init.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/module.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/slab.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/jiffies.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/i2c.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/mutex.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;linux/fs.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;asm/uaccess.h&amp;gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; i2c_client *at24c02_client;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从设备结构体&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; *at24c02_class;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;类结构体&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; at24c02_major;                 

&lt;/span&gt;&lt;span&gt; /*&lt;/span&gt;&lt;span&gt;1.定义file_operations结构体 ,
  *  设置字符设备的读写函数(实现对24C02的读写操作)
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; ssize_t at24c02_read(&lt;span&gt;struct&lt;/span&gt; file *file, &lt;span&gt;char&lt;/span&gt; __user *buf, size_t size, loff_t *&lt;span&gt; offset)
{
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; i2c_msg msg[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
       u8 addr;
       u8 data;
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ret;
       
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(size!=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;EINVAL;

       copy_from_user(&lt;/span&gt;&amp;amp;addr,buf,&lt;span&gt;1&lt;/span&gt;);                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取读地址&lt;/span&gt;
&lt;span&gt;
        msg[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].addr=at24c02_client-&amp;gt;&lt;span&gt;addr;
        msg[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].flags=&lt;span&gt;0&lt;/span&gt;;                                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写标志&lt;/span&gt;
        msg[&lt;span&gt;0&lt;/span&gt;].len  =&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        msg[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].buf  =&amp;amp;addr;                                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入要读的地址&lt;/span&gt;
&lt;span&gt;
        msg[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;].addr=at24c02_client-&amp;gt;&lt;span&gt;addr;
        msg[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;].flags=I2C_M_RD;                               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读标志&lt;/span&gt;
        msg[&lt;span&gt;1&lt;/span&gt;].len  =&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        msg[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;].buf  =&amp;amp;data;                                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读出数据 &lt;/span&gt;
&lt;span&gt;
        ret&lt;/span&gt;=i2c_transfer(at24c02_client-&amp;gt;adapter, msg, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);     
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ret==&lt;span&gt;2&lt;/span&gt;)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示2个msg传输成功&lt;/span&gt;
&lt;span&gt;        {
             copy_to_user(buf,&lt;/span&gt;&amp;amp;data,&lt;span&gt;1&lt;/span&gt;);                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传数据       &lt;/span&gt;
             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;EAGAIN;
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; ssize_t at24c02_write(&lt;span&gt;struct&lt;/span&gt; file *file, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; __user *buf, size_t size, loff_t *&lt;span&gt;offset)
{
       &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; i2c_msg msg[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
       u8 val[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];      
       &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; ret;
       
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(size!=&lt;span&gt;2&lt;/span&gt;)         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;地址   数据&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;EINVAL;

        copy_from_user(val,buf,&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;);                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取 地址   数据&lt;/span&gt;&lt;br/&gt;&lt;span&gt;
        msg[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].addr=at24c02_client-&amp;gt;&lt;span&gt;addr;
        msg[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].flags=&lt;span&gt;0&lt;/span&gt;;                                       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写标志&lt;/span&gt;
        msg[&lt;span&gt;0&lt;/span&gt;].len  =&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
        msg[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;].buf  =val;                                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;写入要写的地址   数据&lt;/span&gt;
&lt;span&gt;
        ret&lt;/span&gt;=i2c_transfer(at24c02_client-&amp;gt;adapter, msg, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);     
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ret==&lt;span&gt;1&lt;/span&gt;)      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示1个msg传输成功&lt;/span&gt;
&lt;span&gt;        {           
             &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;EAGAIN;
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;  file_operations at24c02_fops=&lt;span&gt;{
        .owner &lt;/span&gt;=&lt;span&gt; THIS_MODULE,
    .read  &lt;/span&gt;=&lt;span&gt; at24c02_read,
    .write &lt;/span&gt;=&lt;span&gt; at24c02_write,
};


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;2.定义i2c_client_address_data结构体,保存24C02的设备地址&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;short&lt;/span&gt; ignore[] =&lt;span&gt; { I2C_CLIENT_END };
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;short&lt;/span&gt; normal_addr[] = {&lt;span&gt;0X50&lt;/span&gt;&lt;span&gt;,  I2C_CLIENT_END };
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;short&lt;/span&gt;   force_addr[] = {ANY_I2C_BUS, &lt;span&gt;0x60&lt;/span&gt;&lt;span&gt;, I2C_CLIENT_END};
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; unsigned &lt;span&gt;short&lt;/span&gt;   * forces[] =&lt;span&gt;     {force_addr, NULL};    &lt;br/&gt;&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; i2c_client_address_data   at24c02_addr=&lt;span&gt;{
            .normal_i2c&lt;/span&gt;=&lt;span&gt;normal_addr,
            .probe&lt;/span&gt;=&lt;span&gt;ignore,
            .ignore&lt;/span&gt;=&lt;span&gt;ignore,
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  .forces=forces,                  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 强制地址&lt;/span&gt;
&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;3. 定义一个i2c_driver驱动结构体&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;   at24c02_attach_adapter(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *&lt;span&gt;adapter);
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;   at24c02_detach_client(&lt;span&gt;struct&lt;/span&gt; i2c_client *&lt;span&gt;client);
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; at24c02_detect(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *adap, &lt;span&gt;int&lt;/span&gt; addr, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; kind);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; This is the driver that will be inserted &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; i2c_driver at24c02_driver =&lt;span&gt; {
    .driver &lt;/span&gt;=&lt;span&gt; {
        .name    &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;at24c02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    },
    
    .attach_adapter    &lt;/span&gt;= at24c02_attach_adapter,       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定回调函数&lt;/span&gt;
    .detach_client    = at24c02_detach_client,                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;解绑回调函数&lt;/span&gt;
&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;3.1 设置i2c_driver-&amp;gt; attach_adapter&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;   at24c02_attach_adapter(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *&lt;span&gt;adapter)
{
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; i2c_probe(adapter,&amp;amp;&lt;span&gt;at24c02_addr, at24c02_detect);
}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;3.2 设置i2c_driver-&amp;gt; detach_client&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;   at24c02_detach_client(&lt;span&gt;struct&lt;/span&gt; i2c_client *&lt;span&gt;client)
{
    printk(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;at24c02_detach_client\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    i2c_detach_client(at24c02_client) ;   
    kfree(at24c02_client);&lt;br/&gt;class_device_destroy(at24c02_class,MKDEV(at24c02_major, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
    class_destroy(at24c02_class);
    
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;4.写回调函数,里面注册i2c_client,字符设备&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt; 
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; at24c02_detect(&lt;span&gt;struct&lt;/span&gt; i2c_adapter *adap, &lt;span&gt;int&lt;/span&gt; addr, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; kind)
{
   printk(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;at24c02_detect\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 4.1 分配并设置i2c_client &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    at24c02_client&lt;/span&gt;= kzalloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; i2c_client), GFP_KERNEL);
   
    at24c02_client&lt;/span&gt;-&amp;gt;addr =&lt;span&gt; addr;
    at24c02_client&lt;/span&gt;-&amp;gt;adapter =&lt;span&gt; adap;
    at24c02_client&lt;/span&gt;-&amp;gt;driver = &amp;amp;&lt;span&gt;at24c02_driver;
    at24c02_client&lt;/span&gt;-&amp;gt;flags = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    strlcpy(at24c02_client&lt;/span&gt;-&amp;gt;name, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;at24c02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, I2C_NAME_SIZE);

   &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;4.2 使用i2c_attach_client()将i2c_client与适配器进行连接&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    i2c_attach_client(at24c02_client) ;
    
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;4.3 注册字符设备&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    at24c02_major&lt;/span&gt;= register_chrdev(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;at24c02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;at24c02_fops);  
    at24c02_class&lt;/span&gt;=class_create(THIS_MODULE, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;at24c02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);   
    class_device_create(at24c02_class,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, MKDEV(at24c02_major, &lt;span&gt;0&lt;/span&gt;),&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;at24c02&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;5. 写init入口函数,exit出口函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; at24c02_init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    i2c_add_driver(&lt;/span&gt;&amp;amp;&lt;span&gt;at24c02_driver);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; at24c02_exit(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    i2c_del_driver(&lt;/span&gt;&amp;amp;&lt;span&gt;at24c02_driver);
}&lt;br/&gt;module_init(at24c02_init);
module_exit(at24c02_exit);
MODULE_LICENSE(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GPL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;11.测试运行&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1182576/201711/1182576-20171110194801809-125890547.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 10 Nov 2017 12:33:00 +0000</pubDate>
<dc:creator>LifeYx</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lifexy/p/7816324.html</dc:identifier>
</item>
<item>
<title>机器学习数学|微积分梯度jensen不等式 - cloud&amp;ken</title>
<link>http://www.cnblogs.com/cloud-ken/p/7816129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloud-ken/p/7816129.html</guid>
<description>&lt;h3 id=&quot;觉得有用的话欢迎一起讨论相互学习follow-me&quot;&gt;觉得有用的话,欢迎一起讨论相互学习~&lt;a href=&quot;https://github.com/Asurada2015&quot;&gt;Follow Me&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;原创文章,如需转载请保留出处&lt;br/&gt;本博客为七月在线邹博老师机器学习数学课程学习笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;索引&quot;&gt;索引&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;微积分,梯度和Jensen不等式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Taylor展开及其应用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常见概率分布和推导&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;指数族分布&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共轭分布&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;统计量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;矩估计和最大似然估计&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;区间估计&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Jacobi矩阵&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;矩阵乘法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;矩阵分解RQ和SVD&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对称矩阵&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;凸优化&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;常数e的计算过程&lt;/li&gt;
&lt;li&gt;常见函数的导数&lt;/li&gt;
&lt;li&gt;分部积分法及其应用&lt;/li&gt;
&lt;li&gt;梯度&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;上升/下降最快方向&lt;/li&gt;
&lt;li&gt;凸函数&lt;/li&gt;
&lt;li&gt;Jensen不等式&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;自然常数e&quot;&gt;&lt;span&gt;自然常数e&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;引入&quot;&gt;&lt;span&gt;引入&lt;/span&gt;&lt;/h4&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;我们知道对于公式&lt;span class=&quot;math inline&quot;&gt;\(y=log_{a}x\)&lt;/span&gt;,x=1时,y=0.&lt;mark&gt;则我们是否能找一点a值,使得y函数在(1,0)点的导数为1呢?&lt;/mark&gt;&lt;/p&gt;
&lt;h4 id=&quot;利用导数公式对ylog_ax求导&quot;&gt;&lt;span&gt;利用导数公式对&lt;span class=&quot;math inline&quot;&gt;\(y=log_{a}x\)&lt;/span&gt;求导&lt;/span&gt;&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a05462597cc2.png&quot; alt=&quot;2017-11-10_141323&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;定理一极限存在定理&quot;&gt;定理一:极限存在定理&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;单调有界函数必有极限&lt;/li&gt;
&lt;li&gt;单调数列有上线,必有其极限&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;构造数列xn证明其单调有上界&quot;&gt;&lt;span&gt;构造数列Xn证明其单调有上界&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a054a689914a.png&quot; alt=&quot;2017-11-10_143058&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;又因为其有(1+1)项,则其必比2要大然而又比3要小,则&lt;mark&gt;&lt;span class=&quot;math inline&quot;&gt;\(2&amp;lt;X_n&amp;lt;3\)&lt;/span&gt;&lt;/mark&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;定理二两边夹定理&quot;&gt;定理二:两边夹定理&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a05349d2f788.png&quot; alt=&quot;2017-11-10_115840.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;自然常数e的推导&quot;&gt;&lt;span&gt;自然常数e的推导&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a054b914f52a.png&quot; alt=&quot;2017-11-10_144733&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span class=&quot;math display&quot;&gt;\[自然常数e可以看做e=1+\frac{1}{1!}+\frac{1}{2!}+\frac{1}{3!}+\frac{1}{4!}+...+\frac{1}{n!}\]&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;微分与积分&quot;&gt;&lt;span&gt;&lt;span&gt;微分与积分&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;常用函数的导数公式&quot;&gt;&lt;span&gt;常用函数的导数公式&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/11/10/5a054d74797e3.png&quot; alt=&quot;2017-11-10_145545&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;分部积分法&quot;&gt;&lt;span&gt;分部积分法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a054e9e4437f.png&quot; alt=&quot;2017-11-10_145853&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;方向导数与梯度&quot;&gt;&lt;span&gt;方向导数与梯度&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a055131df111.png&quot; alt=&quot;2017-11-10_151133&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对于方向导数我们也可以视为&lt;span class=&quot;math display&quot;&gt;\[(\frac{\partial f}{\partial x},\frac{\partial f}{\partial y}).(cos\varphi.sin\varphi)^{T}\]&lt;/span&gt;方向导数顾名思义既是复合函数在某一方向上的导数，表示函数在某一方向上的变化趋势。&lt;strong&gt;当在某一方向上的方向导数最大时，即是梯度&lt;/strong&gt; 当 &lt;span class=&quot;math display&quot;&gt;\[cos\varphi =\frac{\partial f}{\partial x}\\sin\varphi = \frac{\partial f}{\partial y}\]&lt;/span&gt; 时,这是方向导数取最大值,即是梯度&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;mark&gt;对于梯度我们有&lt;/mark&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;方向导数是各个方向上的导数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;偏导数连续才有梯度存在&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;梯度的方向是方向导数中取到最大值的方向，梯度的值是方向导数的最大值&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a055929ddf84.png&quot; alt=&quot;2017-11-10_154534&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;凸函数与jsnsen不等式&quot;&gt;&lt;span&gt;&lt;span&gt;凸函数与Jsnsen不等式&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;简而言之,即是&lt;span&gt;函数的割线永远位于函数图像的上方&lt;/span&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a055e71d9c21.png&quot; alt=&quot;2017-11-10_160805&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;一阶可微&quot;&gt;&lt;span&gt;一阶可微&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;简而言之,即是&lt;span&gt;函数如果是一个凸函数,且一阶可微,则过函数任意一点做函数的切线,函数的切线永远在函数的下方&lt;/span&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/11/10/5a055f745187f.png&quot; alt=&quot;2017-11-10_161216&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;二阶可微&quot;&gt;&lt;span&gt;二阶可微&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a05615240126.png&quot; alt=&quot;2017-11-10_162000&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;凸函数举例&quot;&gt;&lt;span&gt;凸函数举例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a056197af9f1.png&quot; alt=&quot;2017-11-10_162139&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;jensen不等式&quot;&gt;&lt;span&gt;Jensen不等式&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Jensen不等式相当于把凸函数的概念反过来说,即是如果f是一个凸函数,任意取一个在f定义域上的(x,y)点,&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;属于[0,1].&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当只有x,y两个参数,即是使用 &lt;strong&gt;基本Jensen不等式&lt;/strong&gt; ,然而当推广到k个参数时, &lt;strong&gt;即是表示参数的线性加权的函数值总要小于函数值的线性加权&lt;/strong&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;可以将其推广到概率密度分布上,假设&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;表示是事件的概率密度K点分布即所加和为1,则函数值的期望大于期望的函数值&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a056ce0691ec.png&quot; alt=&quot;2017-11-10_162630&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://i.loli.net/2017/11/10/5a056f123599a.jpg&quot; alt=&quot;IMG_20171110_171715&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;PS:这都是在f是凸函数的状况下!&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;Jensen不等式是所有不等式的基础,所有不等式都能看做是Jensen不等式利用不同的凸函数推导出来的.&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://ooo.0o0.ooo/2017/11/10/5a05881205891.jpg&quot; alt=&quot;IMG_20171110_190429&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;http://www.julyedu.com/video/play/38&quot;&gt;课程传送门&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 10 Nov 2017 11:25:00 +0000</pubDate>
<dc:creator>cloud&amp;amp;ken</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cloud-ken/p/7816129.html</dc:identifier>
</item>
<item>
<title>一款特好用的JavaScript框架——JQuery - 榆木疙瘩ii</title>
<link>http://www.cnblogs.com/wuhao752718372/p/7816080.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhao752718372/p/7816080.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  了解了解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;                &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   &lt;span&gt;jQuery是一个快速，小巧，功能丰富的JavaScript库。&lt;/span&gt;&lt;span&gt;它使诸如HTML文档遍历和操纵，事件处理，动画和Ajax等事情变得简单得多，而且易于使用的API可以在多种浏览器中使用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、 什么是JQuery？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;jQuery是一个JavaScript函数库。&lt;/p&gt;
&lt;p&gt;jQuery是一个轻量级的&quot;写的少，做的多&quot;的JavaScript库。　　&lt;/p&gt;
&lt;p&gt;jQuery 的功能概括&lt;/p&gt;
&lt;p&gt;　　1、html 的元素选取&lt;/p&gt;
&lt;p&gt;　　2、html的元素操作&lt;/p&gt;
&lt;p&gt;　　3、html dom遍历和修改&lt;/p&gt;
&lt;p&gt;　　4、js特效和动画效果&lt;/p&gt;
&lt;p&gt;　　5、css操作&lt;/p&gt;
&lt;p&gt;　　6、html事件操作&lt;/p&gt;
&lt;p&gt;　　7、ajax异步请求方式&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、 JQuery基础中的基础&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2-1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;JQuery基本语法&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;span&gt;jQuery 语法是通过选取 HTML 元素，并对选取的元素执行某些操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，在使用JQuery之前要先导入JQuery文件。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&quot;js/jquery-3.1.1.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;JQuery中的选择器&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$(&quot;选择器&quot;).函数();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;　　① $是JQuery的缩写，即可以使用JQuery(&quot;选择器&quot;).函数()；&lt;/p&gt;
&lt;p&gt;　　② 选择器，可以是任何的CSS支持的选择符；&lt;/p&gt;
&lt;p&gt;小实例：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;$(this).hide() - 隐藏当前元素&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;$(&quot;p&quot;).hide() - 隐藏所有 &amp;lt;p&amp;gt; 元素&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;$(&quot;p.test&quot;).hide() - 隐藏所有 class=&quot;test&quot; 的 &amp;lt;p&amp;gt; 元素&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;$(&quot;#test&quot;).hide() - 隐藏所有 id=&quot;test&quot; 的元素&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2-2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;文档就绪函数&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;文档就绪函数就是指防止在文档未完全加载完成之前，运行JQuery代码；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
 
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; JQuery 代码...&lt;/span&gt;
&lt;span&gt; 
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它的简写形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
 
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; JQuery 代码...&lt;/span&gt;
&lt;span&gt; 
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div readability=&quot;14&quot;&gt;
&lt;h3&gt;文档就绪函数和window.onload的区别[还是比较重要的！！]&lt;/h3&gt;
&lt;p&gt;① window.onload必须等到网页中的所有内容加载完成之后，才会执行代码(包括图片、视频等资源)；&lt;/p&gt;
&lt;p&gt;　 文档就绪函数，只需要在网页DOM结构加载完成之后，就可以执行代码；&lt;/p&gt;
&lt;p&gt;② window.onload只能写一个，写多个只会执行最后一个；&lt;/p&gt;
&lt;p&gt;　 文档就绪函数，可以写多个，并且不会被覆盖；&lt;/p&gt;
&lt;/div&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、 JQuery中的常用函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;JQuery中的函数实在是太多，在这就不一一解释了，我在下面列举了一些常用的，后面都跟着一个小例子，非常简单，各位博友们一看就懂~~~&lt;/h4&gt;
&lt;h3&gt;内部插入&lt;/h3&gt;
&lt;p&gt;append：将创建好的节点，插入到指定位置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).append(&quot;&amp;lt;p&amp;gt;这是被插入的p标签&amp;lt;/p&amp;gt;&quot;);　　　　//在#div1内部的最后，直接插入一个节点。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;appendTo：&lt;/span&gt;把所有匹配的元素追加到另一个指定的元素元素集合中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;&amp;lt;p&amp;gt;这是被插入的p标签&amp;lt;/p&amp;gt;&quot;).appendTo(&quot;#div1&quot;);　　　　//把新节点插入到#div1中
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; prepend：把每个匹配的元素插入到指定元素的开头&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).prepend(&quot;&amp;lt;p&amp;gt;这是被插入的p标签&amp;lt;/p&amp;gt;&quot;);　　　　//在#div1内部的开头，直接插入一个节点。
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;外部插入&lt;/h3&gt;
&lt;p&gt;after：在每个匹配的元素之后插入内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).after(&quot;&amp;lt;p&amp;gt;这是被插入的p标签&amp;lt;/p&amp;gt;&quot;);　　　　//在div1后面插入一个新节点
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;insertBefore：把所有匹配的元素插入到另一个、指定的元素元素集合的前面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$(&quot;&amp;lt;p&amp;gt;这是被插入的p标签&amp;lt;/p&amp;gt;&quot;).insertBefore(&quot;#div1&quot;);　　　　//把p标签插入到div1前面
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;包裹&lt;/h3&gt;
&lt;p&gt;wrap：把所有匹配的元素用其他元素的结构化标记包裹起来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;p&quot;).wrap(&quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&quot;);　　　　//把每个p标签外面，都包裹一层div
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;wrapAll：将所有匹配的元素用单个元素包裹起来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;p&quot;).wrapAll(&quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&quot;);　　　　//把所有的p标签，包裹在同一个div中
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;wrapInner：将每一个匹配的元素的子内容(包括文本节点)用一个HTML结构包裹起来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).wrapInner(&quot;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&quot;);　　　　//把#div1里面的所有子元素，用&amp;lt;div&amp;gt;包裹起来
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;替换&lt;/h3&gt;
&lt;p&gt;replaceWith：将所有匹配的元素替换成指定的HTML或DOM元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$(&quot;p&quot;).replaceWith(&quot;&amp;lt;span&amp;gt;111&amp;lt;/span&amp;gt;&quot;);　　　　//将所有匹配的p标签，全部换为span标签
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;replaceAll：用匹配的元素替换掉所有 selector匹配到的元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;&amp;lt;span&amp;gt;111&amp;lt;/span&amp;gt;&quot;).replaceAll(&quot;p&quot;);　　　　//用span元素，替换掉所有p标签
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;删除&lt;/h3&gt;
&lt;p&gt;empty：删除匹配的元素集合中所有的子节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).empty();　　　　//删除#div1中的所有子元素。 但是#div1依然保留空标签
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;remove：从DOM中删除所有匹配的元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).remove();　　　　//直接从DOM中，删除#div1以及所有子元素
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;detach：从DOM中删除所有匹配的元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).detach();　　　　//直接从DOM中，删除#div1以及所有子元素
&lt;/pre&gt;&lt;/div&gt;

&lt;div readability=&quot;16&quot;&gt;
&lt;h2&gt;&lt;span&gt;remove和detach的异同点&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1、相同点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　① 都会把当前标签，以及当前标签的所有子节点，全部删除；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　② 都可以在删除时，把当前节点返回。并可以使用变量接受返回的节点，以便后期恢复；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、不同点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用接受的节点，恢复原节点时&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　remove只能恢复节点的内容，但是事件绑定，不能再恢复；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　detach不但恢复节点的内容，还能再恢复 事件的绑定；&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h3&gt;复制（克隆）&lt;/h3&gt;
&lt;p&gt;clone：克隆匹配的DOM元素并且选中这些克隆的副本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).clone(&lt;span&gt;true&lt;/span&gt;).empty().insertBefore(&quot;button:eq(0)&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;div readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;span&gt;JS中.cloneNode() 和 JQ中 .clone()的区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　两者都接受传入true/false的参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　.cloneNode() 不传参数或传入参数false，表示只克隆当前节点，而不克隆子节点。 传入true表示可隆全部子节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　.clone() 无论传入哪个参数，都会克隆所有子节点。但是，不传参数或者传入false，表示只克隆节点，不克隆节点绑定的事件。 传入true表示同时克隆及诶单绑定的事件。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;四、JQuery中的事件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;4-1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;绑定事件的方式&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt; 1、事件绑定的快捷方式&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;button&quot;).eq(0).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){&lt;br/&gt;　　　　alert(&lt;/span&gt;1&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 2、使用on()绑定事件&lt;/h3&gt;
&lt;p&gt;　　&lt;strong&gt;① 使用on进行单事件绑定&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$(&quot;button:eq(0)&quot;).on(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
　　　　alert(&lt;/span&gt;1&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　&lt;strong&gt;② 使用on，一次性给同一节点添加多个事件执行同一函数，多个事件之间空格分隔&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
$(&quot;button:eq(0)&quot;).on(&quot;click mouseover dblclick&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
　　　　console.log(&lt;/span&gt;&quot;触发了事件&quot;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　&lt;strong&gt;③ 一次性给同一节点添加多个事件，分别执行不同函数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
$(&quot;button:eq(0)&quot;&lt;span&gt;).on({
　　　　&lt;/span&gt;&quot;click&quot;:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
　　　　　　　　console.log(&lt;/span&gt;&quot;执行了click事件&quot;&lt;span&gt;);
　　　　},
　　　　&lt;/span&gt;&quot;mouseover&quot;:&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
　　　　　　　　console.log(&lt;/span&gt;&quot;执行了mouseover事件&quot;&lt;span&gt;);
　　　　}
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　&lt;strong&gt;④ 调用函数时，同时给函数传入指定参数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
$(&quot;button:eq(0)&quot;).on(&quot;click&quot;,{&quot;name&quot;:&quot;jredu&quot;,&quot;age&quot;:14},&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(evn){
　　　　console.log(evn);
　　　　console.log(evn.data.name);
　　　　console.log(evn.data.age);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　&lt;strong&gt;⑤使用 on 进行事件委派（非常非常非常非常的重要！）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将原本需要绑定在本元素上的事件，改为绑定到祖先节点乃至根节点上，然后委派给当前节点生效&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
$(&quot;p&quot;).on(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){});　　&lt;br/&gt;//委派如下↓
$(document).on(&lt;/span&gt;&quot;click&quot;,&quot;p&quot;,&lt;span&gt;function&lt;/span&gt;(){});
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;　　使用事件委派的作用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　不使用事件委派的绑定方式，只能绑定到页面初始化时的标签上，当页面新增同类型标签，这些新增的标签，不能绑定上事件；但如果使用事件委派，当页面新增同类型标签时，这些新增的标签也能够绑定已有的事件。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;五、 JQuery中的动画&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt; JQuerey中的动画也是非常多的，在这就给大家列举几个，大家如果觉得不详细的话，可以去菜鸟教程或是查看JQuery的帮助文档！！！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、.show()  让隐藏的元素显示&lt;/p&gt;
&lt;p&gt;　　效果为：同事修改元素的宽度、高度、opacity属性&lt;/p&gt;
&lt;p&gt;　　①不传参：直接显示，不进行动画&lt;/p&gt;
&lt;p&gt;　　②传参时间毫秒数，表示多少毫米内完成函数&lt;/p&gt;
&lt;p&gt;　　③传入(时间，函数)表示动画完成之后，执行回调函数&lt;/p&gt;
&lt;p&gt;2、.hide()  让显示的元素隐藏，与show相反。&lt;/p&gt;
&lt;p&gt;3、.slideDown()  让隐藏的元素显示，效果为从上往下，增加高度&lt;/p&gt;
&lt;p&gt;　  .slideUp()   让显示的元素隐藏，效果为从下往上，减小高度&lt;/p&gt;
&lt;p&gt;　  .slideToggle()   让现实的元素隐藏，让隐藏的元素显示&lt;/p&gt;
&lt;p&gt;4、.fadeIn()   让隐藏的元素淡入显示&lt;/p&gt;
&lt;p&gt;　  .fadeOut()  让显示的元素淡出隐藏&lt;/p&gt;
&lt;p&gt;　  .fadeTogle()  让显示的元素隐藏，让隐藏的元素显示&lt;/p&gt;
&lt;p&gt;　  .fadeTo(时间，最终透明度，函数)  同fadeToggle，接受第二个参数，表示最终达到的透明度&lt;/p&gt;
&lt;p&gt;5、.animate({最终的样式属性，键值对对象}，动画时间，动画效果(&quot;linear&quot;或&quot;swing&quot;),动画执行完后的回调函数)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;给大家举个小例子吧&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js&quot;&amp;gt;
&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt; 
$(document).ready(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
  $(&lt;/span&gt;&quot;button&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    $(&lt;/span&gt;&quot;div&quot;&lt;span&gt;).animate({
      left:&lt;/span&gt;'250px'&lt;span&gt;,
      opacity:&lt;/span&gt;'0.5'&lt;span&gt;,
      height:&lt;/span&gt;'150px'&lt;span&gt;,
      width:&lt;/span&gt;'150px'&lt;span&gt;
    });
  });
});
&lt;/span&gt;&amp;lt;/script&amp;gt; 
&amp;lt;/head&amp;gt;
 
&amp;lt;body&amp;gt;
&amp;lt;button&amp;gt;开始动画&amp;lt;/button&amp;gt;
&amp;lt;p&amp;gt;&lt;span&gt;默认情况下，所有的 HTML 元素有一个静态的位置，且是不可移动的。 
如果需要改变为，我们需要将元素的 position 属性设置为 relative, fixed, 或 absolute&lt;/span&gt;!&amp;lt;/p&amp;gt;
&amp;lt;div style=&quot;background:#98bf21;height:100px;width:100px;position:absolute;&quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;他的运行结果： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1207274/201711/1207274-20171110183740888-1351410051.gif&quot; alt=&quot;&quot; width=&quot;737&quot; height=&quot;140&quot;/&gt;&lt;/p&gt;

&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;六、JQuery中的AJAX&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;AJAX = 异步 JavaScript 和 XML（Asynchronous JavaScript and XML）。&lt;/p&gt;
&lt;p&gt;简短地说，在不重载整个网页的情况下，AJAX 通过后台加载数据，并在网页上进行显示。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;6-1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;JQuery  load()方法&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;jQuery load() 方法是简单但强大的 AJAX 方法。&lt;/p&gt;
&lt;p&gt;load() 方法从服务器加载数据，并把返回的数据放入被选元素中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加载远程的HTML文件代码，并插入到指定的DOM节点中。可以只传入一个参数，表示加载一个静态的HTML代码片段。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;#div1&quot;).load(&quot;load.html&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;6-2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;$.ajax()&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; $.ajax():是JQuery最底层的ajax函数，参数接收一个大对象。对象里面的属性和方法，表示ajax请求的相关设置：&lt;/p&gt;
&lt;p&gt;　　① url : 请求远程文件的路径&lt;/p&gt;
&lt;p&gt;　　② type： Ajax请求的类型，可选值 get/post&lt;/p&gt;
&lt;p&gt;　　③ data: 对象格式。向后台发送一个对象，表示传递的数据。&lt;/p&gt;
&lt;p&gt;　　　　　   常用与type为&quot;post&quot;的请求方式；&lt;/p&gt;
&lt;p&gt;　　　　　   如果type为&quot;get&quot;，可以直接使用？追加在URL的后面。&lt;/p&gt;
&lt;p&gt;　　④ dataType ：预期后台返回什么类型的数据。 &quot;text&quot;-字符串   &quot;json&quot;-JSON对象&lt;/p&gt;
&lt;p&gt;　　⑤ success: 请求成功的回调函数。参数接受一个data，表示后台返回的数据。&lt;/p&gt;
&lt;p&gt;　　⑥ error : 请求失败的时候的回调函数&lt;/p&gt;
&lt;p&gt;　　⑦ statusCode ： 接受一个对象，对象的键值对是status状态码和对应的回调函数，表示当请求状态码是对应数字时，执行具体的操作函数。&lt;/p&gt;
&lt;p&gt;　　　　200-正常请求成功     404-页面没有找到    500-服务器内部错误。具体的状态码见下图&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/1207274/201711/1207274-20171110184510216-2120939750.png&quot; alt=&quot;&quot; width=&quot;451&quot; height=&quot;1430&quot;/&gt;&lt;/p&gt;
&lt;p&gt;$.get();  $.post(); 这两个函数，是在$.ajax()的基础上进行封装而来。可以直接默认发送get请求或post请求；&lt;/p&gt;
&lt;p&gt;接受四个参数：&lt;/p&gt;
&lt;p&gt;　　① 请求的URL路径。 相当于$.ajax()里面的url；&lt;/p&gt;
&lt;p&gt;　　② 向后台传递的数据。 相当于$.ajax()里面的data；&lt;/p&gt;
&lt;p&gt;　　③ 请求成功的回调函数。 相当于$.ajax()里面的success；&lt;/p&gt;
&lt;p&gt;　　④ 预期返回的数据类型。 相当于$.ajax()里面的dataType；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
$.post(&quot;http://localhost/json.php&quot;,{data:&quot;aaa&quot;},&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data){
　　　　console.log(data);
},&lt;/span&gt;&quot;json&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt; 给大家举上两个栗子&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('c89956df-3418-4f46-a03e-e2d68102915b')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_c89956df-3418-4f46-a03e-e2d68102915b&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c89956df-3418-4f46-a03e-e2d68102915b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('c89956df-3418-4f46-a03e-e2d68102915b',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c89956df-3418-4f46-a03e-e2d68102915b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;小栗子&amp;lt;/title&amp;gt;
&amp;lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js&quot;&amp;gt;
&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
$(document).ready(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    $(&lt;/span&gt;&quot;button&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        $.post(&lt;/span&gt;&quot;/try/ajax/demo_test_post.php&quot;&lt;span&gt;,{
            name:&lt;/span&gt;&quot;小栗子&quot;&lt;span&gt;,
            url:&lt;/span&gt;&quot;http://www.baidu.com&quot;&lt;span&gt;
        },
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data,status){
            alert(&lt;/span&gt;&quot;数据: \n&quot; + data + &quot;\n状态: &quot; +&lt;span&gt; status);
        });
    });
});
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;button&amp;gt;点击发送一个POST请求&amp;lt;/button&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;POST&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1207274/201711/1207274-20171110185235075-2115189974.png&quot; alt=&quot;&quot; width=&quot;312&quot; height=&quot;129&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('330443a7-5d0a-47e7-82d5-0d321c026b3a')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_330443a7-5d0a-47e7-82d5-0d321c026b3a&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_330443a7-5d0a-47e7-82d5-0d321c026b3a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('330443a7-5d0a-47e7-82d5-0d321c026b3a',event)&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_330443a7-5d0a-47e7-82d5-0d321c026b3a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;小栗子&amp;lt;/title&amp;gt;
&amp;lt;script src=&quot;http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js&quot;&amp;gt;
&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
$(document).ready(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    $(&lt;/span&gt;&quot;button&quot;).click(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        $.get(&lt;/span&gt;&quot;/try/ajax/demo_test.php&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data,status){
            alert(&lt;/span&gt;&quot;数据: &quot; + data + &quot;\n状态: &quot; +&lt;span&gt; status);
        });
    });
});
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;

&amp;lt;button&amp;gt;点击发送GET请求&amp;lt;/button&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;GET&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1207274/201711/1207274-20171110185338888-1040910979.png&quot; alt=&quot;&quot; width=&quot;306&quot; height=&quot;105&quot;/&gt;&lt;/p&gt;


&lt;p&gt;
&lt;h5 class=&quot;135brush&quot;&gt;&lt;span&gt;好了，今天就给大家分享到这儿吧，大家如果觉得我漏了点什么，可以去菜鸟教程或查看JQuery帮助文档，如果觉得哪个地方需要改进的，请大家给我留言，谢谢大家了！！！！&lt;/span&gt;&lt;/h5&gt;
&lt;/p&gt;
</description>
<pubDate>Fri, 10 Nov 2017 11:07:00 +0000</pubDate>
<dc:creator>榆木疙瘩ii</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhao752718372/p/7816080.html</dc:identifier>
</item>
<item>
<title>【持续更新】JavaScript常见面试题整理 - 卡尔西法calcifer</title>
<link>http://www.cnblogs.com/wq1994/p/7816020.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wq1994/p/7816020.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;&lt;span&gt;【重点提前说&lt;span&gt;】这篇博客里的问题涉及到了JS中常见的的基础知识点，也是面试中常见的一些问题，建议初入职场的园友Mark收藏，本文会持续更新~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110185707044-723103091.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;1、 &lt;span&gt;引入&lt;span&gt;JS&lt;span&gt;的三种方式&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1、在HTML标签中直接使用，直接内嵌JS（但是不提倡使用）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;不符合W3C关于内容和行为分离的要求；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、在HTML页面中使用&amp;lt;scrip&amp;gt; &amp;lt;/script&amp;gt;标签包裹JS代码；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt;script标签可以放到页面的各种位置；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、引入外部的JS文件使用&amp;lt;script&amp;gt; &amp;lt;/script&amp;gt;标签；&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;2、 &lt;span&gt;JS&lt;span&gt;中的变量声明&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181117825-442842401.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;3、 &lt;span&gt;JS&lt;span&gt;中变量的数据类型&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181144466-689623326.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;4、 &lt;span&gt;常用的数值函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div readability=&quot;8&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181213044-867342328.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;parseInt()只能转字符串，转其他的类型都是NAN；而Number（）能转所有的数据类型；&lt;/p&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;5、 &lt;span&gt;运算符注意事项&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181247122-1828925804.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;6、 &lt;span&gt;判断水仙花数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181329669-548886598.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;7、 I&lt;span&gt;f&lt;span&gt;结构，循环结构，支持的判断结果：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181401075-227665399.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;8、 &lt;span&gt;循环控制语句：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181424872-1877408493.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;9、 &lt;span&gt;斐波那契数列&lt;span&gt;:1,1,2,3,5,8,13,21&lt;span&gt;……&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181451356-1246058895.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;10、 &lt;span&gt;JS&lt;span&gt;中函数的调用方式/事件的绑定方式&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181513731-48145763.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;11、 &lt;span&gt;window&lt;span&gt;对象的常用方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181533794-1399602152.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181920309-636385506.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181947903-1666312487.png&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;328&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;12、 DOM&lt;span&gt;操作的相关方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110181614559-619921419.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;13、 &lt;span&gt;键盘事件&lt;span&gt;&amp;amp;&lt;span&gt;确定键盘按键&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182043559-116687543.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;14、 DOM2 &lt;span&gt;兼容写法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182115294-584653886.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;15、 &lt;span&gt;事件冒泡&lt;span&gt;&amp;amp;&lt;span&gt;事件捕获&lt;span&gt;&amp;amp;&lt;span&gt;阻止默认事件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182141497-1621523934.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;16、 &lt;span&gt;数组常用方法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182206372-137276246.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;17、 &lt;span&gt;引用数据类型&lt;span&gt;&amp;amp;&lt;span&gt;基本数据类型：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182230216-2025554138.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;18、 &lt;span&gt;Number&lt;span&gt;类常用方法：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182256856-1282631291.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;19、 &lt;span&gt;String&lt;span&gt;类常用方法：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182324888-1207515199.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;20、 &lt;span&gt;Date&lt;span&gt;类：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182352528-61077849.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;21、 &lt;span&gt;杨辉三角：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182433794-2058005383.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;22、 &lt;span&gt;正则表达式声明：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182458700-476495782.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;23、 &lt;span&gt;正则表达式常用规则：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182533122-941116292.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;24、 &lt;span&gt;正则中的&lt;span&gt;test&lt;span&gt;与&lt;span&gt;exec&lt;span&gt;方法：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182618075-1319868680.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;25、 foreach与each的区别？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;forEach是js中的方法&lt;span&gt;（针对数组），而&lt;span&gt;each是jquery中的方法&lt;span&gt;（针对jquery对象，即$( )；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.forEach方法：如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182653466-2144947337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182719231-342986209.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;span&gt;2.each方法：如下图所示&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182747325-368877856.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110182810559-1048920153.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;26、document load 和document ready的区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Document.onload &lt;span&gt;是在结构和样式加载完才执行&lt;span&gt;js&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;window.onload&lt;span&gt;：不仅仅要在结构和样式加载完，还要执行完所有的样式、图片这些资源文件，全部加载完才会触发&lt;span&gt;window.onload&lt;span&gt;事件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Document.ready原生种没有这个方法，jquery中有 $().ready(function)&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;27、什么是CSS Hack？怎么表示？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;CSS hack由于不同厂商的&lt;span&gt;浏览器，比如Internet Explorer,Safari,&lt;span&gt;Mozilla Firefox,Chrome等，或者是同一厂商的浏览器的不同版本，如IE6和IE7，对CSS的解析认识不完全一样，因此会导致生成的页面效果不一样，得不到我们所需要的页面效果。 这个时候我们就需要针对不同的浏览器去写不同的CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中也能得到我们想要的页面效果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;简单的说，CSS hack的目的就是使你的CSS代码兼容不同的浏览器。当然，我们也可以反过来利用CSS hack为不同版本的浏览器定制编写不同的CSS效果。&lt;/p&gt;
&lt;p&gt;方式一 条件注释法 方法二 类内属性前缀法 方式三：选择器前缀法&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;28、Javascript中callee和caller的作用？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;arguments.callee&lt;span&gt;：获得当前函数的引用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;caller是返回一个对函数的引用，该函数调用了当前函数；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;callee是返回正在被执行的function函数，也就是所指定的function对象的正文。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;29、简述创建函数的几种方式&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;第一种（函数声明）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; sum1(num1,num2){
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1+&lt;span&gt;num2;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第二种（函数表达式）：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; sum2 = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(num1,num2){
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num1+&lt;span&gt;num2;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;匿名函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;function(){}:&lt;span&gt;只能自己执行自己&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;第三种（函数对象方式）：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; sum3 = &lt;span&gt;new&lt;/span&gt; Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;30、把 &lt;span&gt;Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;如果说放在&lt;span&gt;body&lt;span&gt;的封闭之前，将会阻塞其他资源的加载&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果放在&lt;span&gt;body&lt;span&gt;封闭之后，不会影响&lt;span&gt;body&lt;span&gt;内元素的加载&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;31、iframe的优缺点？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 解决加载缓慢的第三方内容如图标和广告等的加载问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. Security sandbox安全沙盒&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 并行加载脚本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. iframe会阻塞主页面的Onload事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 即使内容为空，加载也需要时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 没有语意&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;32、请你谈谈&lt;span&gt;Cookie的弊端？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.`Cookie`数量和长度的限制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.安全性问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.有些状态不可能保存在客户端。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;33、js延迟加载的方式有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1. defer和async&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 按需异步载入js&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;34、documen.write和 innerHTML 的区别？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;document.write 只能重绘整个页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;innerHTML 可以重绘页面的一部分&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;35、哪些操作会造成内存泄漏？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 &lt;span&gt;0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 闭包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 控制台日志&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;36、JS是一门什么类型的语言?&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;JS可以模拟实现继承和封装，但是不能模拟实现多态，故js是基于事件的，基于对象的轻量级脚本语言。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;37、语言有哪几种类型？各有什么特点？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、语言的分类：&lt;/p&gt;
&lt;p&gt;①、面向机器：汇编语言。&lt;/p&gt;
&lt;p&gt;②、面向过程：C语言&lt;/p&gt;
&lt;p&gt;③、面向对象：Java、C++、PHP等。&lt;/p&gt;
&lt;p&gt;2、面向过程与面向对象：&lt;/p&gt;
&lt;p&gt;①、面向过程：专注于如何去解决一个问题的过程步骤，编程的特点是由一个个的函数去实现每一步的过程步骤，没有类和对象的概念。&lt;/p&gt;
&lt;p&gt;②、面向对象：专注于由哪一个对象来解决这个问题，编程特点是出现了一个个的类，从类中拿到对象&lt;/p&gt;
&lt;p&gt;【面向对象的三大特征】 继承、封装、多态&lt;/p&gt;
&lt;p&gt;【区别】&lt;/p&gt;
&lt;p&gt;对于调用者来说，面向过程需要调用者自己去实现各种函数，&lt;/p&gt;
&lt;p&gt;而面向对象，只需要告诉调用者对象中具体方法的功能，不需要调用者去了解方法中的实现细节。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;38、JavaScript中类和对象的关系：&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;类是抽象的，对象是具体的&lt;/p&gt;
&lt;p&gt;类是对象的抽象化，对象是类的具体化；&lt;/p&gt;
&lt;p&gt;★类是一个抽象的概念，只能说类有属性和方法，但是不能给属性和方法赋具体的值。&lt;/p&gt;
&lt;p&gt;例如:人类有身高，但是不能说出具体数值&lt;/p&gt;
&lt;p&gt;★对象是一个具体的个例，是将类中的属性进行具体赋值而来的个体；&lt;/p&gt;
&lt;p&gt;例如：张三是人类中的一个个体，身高180cm。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;39、实现继承的三种方式？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、使用call bind apply来实现继承。&lt;/p&gt;
&lt;p&gt;2、通过扩展object来实现继承。&lt;/p&gt;
&lt;p&gt;3、使用原型实现继承。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;40、 什么叫封装？有什么方法和特点？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;① 方法的封装： 将类内部的函数进行私有化处理，不对外提供调用接口，无法在类外部使用的方法，称为私有方法，即方法的封装。&lt;/p&gt;
&lt;p&gt;② 属性的封装： 将类中的属性进行私有化处理，对外不能直接使用对象名访问(私有属性)。 同时，需要提供专门用于设置和读取私有属性的set/get方法，让外部使用我们提供的方法，对属性进行操作。 这就叫属性的封装。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;封装不是拒绝访问，而是限制访问。 要求调用者，必须使用我们提供的set/get方法进行属性的操作，而不是直接拒绝操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因此，单纯的属性私有化，不能称为封装！必须要私有化之后，提供对应的set/get方法。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;41、 原生JS对象与JQuery对象之间的相互转化方式有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;① 使用$(&quot;&quot;)选中的是JQuery对象，只能调用JQuery函数，而不能使用元素的JS事件与函数；&lt;/p&gt;
&lt;p&gt;② 原生的JS对象转为 JQuery对象&lt;/p&gt;
&lt;p&gt;可以使用$() 包裹即可以转为JQuery对象&lt;/p&gt;
&lt;p&gt;var p = document.getElementsByTagName(&quot;p&quot;);&lt;/p&gt;
&lt;p&gt;$(&quot;p&quot;).click(); √ 原生的JS对象已经转为 JQuery对象；&lt;/p&gt;
&lt;p&gt;③ JQuery转为原生JS对象：&lt;/p&gt;
&lt;p&gt;使用get(index)或者[index]&lt;/p&gt;
&lt;p&gt;$(&quot;#p&quot;).get(0).onclick() = function () {}; √&lt;/p&gt;
&lt;p&gt;$(&quot;#p&quot;).[0].onclick() = function () {}; √&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;42、JS常用的内置对象有哪些？它们各自的一些方法有哪些？：&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、Boolean类、Number类:、String类、Date日期类、&lt;/p&gt;
&lt;p&gt;2、常用方法：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Number类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;.toString() 将数值类型转换成字符串类型；&lt;/p&gt;
&lt;p&gt;.toLocaleString()将数值按照本地格式顺序转换成字符串，一般从右开始，三个一组加都好分隔开；&lt;/p&gt;
&lt;p&gt;.toFixed(n)；将数字保留n位小数，并将其转换为字符串格式；&lt;/p&gt;
&lt;p&gt;.toPrecision(n):将数字格式化为指定长度。n表示不含小数点的位数长度。如果n&amp;lt;原数字长度，则用科学计数法表示。&lt;/p&gt;
&lt;p&gt;.valueOf() 返回Number对象的基本数字值；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;String类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;str.length 返回字符串的长度，即为字符数；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;str.toLowerCase()将字符串所有的字符转成小写；&lt;/p&gt;
&lt;p&gt;str.UpLowerCase()将字符串所有的字符转成大写；&lt;/p&gt;
&lt;p&gt;str.charAt(N)截取数组的第N个字符，相当于str[N]；&lt;/p&gt;
&lt;p&gt;str.indexOf(&quot;srt&quot;,index)查找子串在字符串中出现的位置，如果没有找到返回-1，其他同数组的indexOf方法；&lt;/p&gt;
&lt;p&gt;str.lastIndexOf()同数组。&lt;/p&gt;
&lt;p&gt;str.subString (begin,end) 截取数组中的某一部分并返回截取的字符串&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;传入一个参数，表示是开始的区间，默认将截取到字符串末尾；&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;传入两个参数，表示开始和结束的下标，是一个左闭右开区间；&lt;/p&gt;
&lt;p&gt;str.split(分隔符)将字符串以指定分隔符分隔存入数组中，&lt;/p&gt;
&lt;p&gt;str.replace(old，new)将字符串中的字符进行替换；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Date日期类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、new Date();返回当前最新时间；&lt;/p&gt;
&lt;p&gt;new Date(&quot;2017,08,29,12:33:29&quot;) 返回指定时间；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;43、什么是Jquery中的文档就绪函数&lt;span&gt;？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;文档就绪函数防止文档在未完全加载之前，运行JQuery代码；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;$(document).ready(function() {&lt;/p&gt;
&lt;p&gt;//JQuery代码&lt;/p&gt;
&lt;p&gt;})；&lt;/p&gt;
&lt;p&gt;简写形式如下：&lt;/p&gt;
&lt;p&gt;$(function(){});&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[文档就绪函数&amp;amp;window.onload的区别]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① window.onload必须等到网页中的所有内容(包括图片视频)加载完成后才能执行代码；&lt;/p&gt;
&lt;p&gt;文档就绪函数只需要在 网页DOM结构加载完成之后，就可以执行代码；&lt;/p&gt;
&lt;p&gt;② window.onload只能写一个，写多个之后只会执行最后一个；&lt;/p&gt;
&lt;p&gt;文档就绪函数可以写多个，而且不会覆盖。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;44、常用的CSS的预处理器有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;less&lt;/p&gt;
&lt;p&gt;sass 常用的编译方式&lt;/p&gt;
&lt;p&gt;它们之间的区别：&lt;/p&gt;
&lt;p&gt;SCSS中的嵌套：选择器嵌套 属性嵌套 伪类嵌套&lt;/p&gt;
&lt;p&gt;&lt;span&gt;混合宏、继承、占位符：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① 混合宏:使用@mixin声明混合宏，在其他选择器中使用@include调用混合宏&lt;/p&gt;
&lt;p&gt;② 继承 ：声明一个普通的class，在其他的选择器中使用extend 继承这个class；&lt;/p&gt;
&lt;p&gt;③ 占位符 ：使用%声明%占位符，在其他选择器中使用@extend 继承占位符；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;45、简述下JS中的事件分类&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、鼠标事件： click/dblclick/onmouseon/onmouseover.....&lt;/p&gt;
&lt;p&gt;2、HTML事件： onload/onscroll/onsubmit/onchange/onfocus....&lt;/p&gt;
&lt;p&gt;3、键盘事件：&lt;/p&gt;
&lt;p&gt;keydown:键盘按下时触发&lt;/p&gt;
&lt;p&gt;keypress:键盘按住时触发&lt;/p&gt;
&lt;p&gt;keyup:键盘抬起时触发&lt;/p&gt;
&lt;p&gt;【确定触发的按键】&lt;/p&gt;
&lt;p&gt;① 在触发的函数中传入一个参数e，表示键盘事件；&lt;/p&gt;
&lt;p&gt;② 使用e.keyCode，取到按键的Ascii码值，进而确定触发按键；&lt;/p&gt;
&lt;p&gt;③ 所有浏览器的兼容写法(一般并不需要)&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110184731013-1817762299.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;46、浅谈JavaScript的优点和缺点：&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;性能：由于JavaScript运行在客户端，节省了web服务器的请求时间和带宽&lt;/li&gt;
&lt;li&gt;轻量级的脚本语言，比较容易学习&lt;/li&gt;
&lt;li&gt;运行在用户机器上，运行结果和处理相对比较快。&lt;/li&gt;
&lt;li&gt;可以使用第三方附加组件来检查代码片段。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安全问题：由于JavaScript在客户端运行，可能被用于黑客目的。&lt;/li&gt;
&lt;li&gt;渲染问题：在不同浏览器中的处理结果可能不同。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;47、浅谈jQuery的优点和缺点：&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;使用jQuery最大的好处是少量的代码做更多的事情。&lt;/p&gt;
&lt;p&gt;Write Less Do More&lt;/p&gt;
&lt;p&gt;看个简单例子，获取元素的值，使用JavaScript：&lt;/p&gt;
&lt;p&gt;Javascript代码&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;document.getElementById(‘elementid').value&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用jQuery：&lt;/p&gt;
&lt;p&gt;Jquery代码&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;$(‘#elementid').val();&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;与JavaScript相比，jQuery的语法更加简单。&lt;span&gt;通过jQuery，可以很容易地浏览文档、选择元素、处理事件以及添加效果等，同时还允许开发者定制插件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;jQuery消除了JavaScript跨平台兼容问题。&lt;/li&gt;
&lt;li&gt;相比其他JavaScript和JavaScript库，jQuery更容易使用。&lt;/li&gt;
&lt;li&gt;jQuery有一个庞大的库/函数。&lt;/li&gt;
&lt;li&gt;jQuery有良好的文档和帮助手册。&lt;/li&gt;
&lt;li&gt;jQuery支持AJAX。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于不是原生JavaScript语言，理解起来可能会受到限制。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;项目中需要包含jQuery库文件。如果包含多个版本的jQuery库，可能会发生冲突。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;48、浅谈angular优缺点&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;简介：angularjs是一个javascript框架。通过script脚本引入，他是一个用Javascript编写的库。&lt;span&gt;angularjs通过指令扩展了HTML，通过表达式绑定数据到HTML中。&lt;span&gt;AngularJS主要考虑的是构建CRUD（增删改查）应用。幸运的是，至少90%的WEB应用都是CRUD应用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. 改变操作dom的方式&lt;/p&gt;
&lt;p&gt;将传统的JQuery的先选择元素，在操作的方式改变成了直接对于元素本身的操作。&lt;/p&gt;
&lt;p&gt;这依赖于强大的Html Parser的能力和directive灵活。&lt;/p&gt;
&lt;p&gt;2. 后端MVC前端化&lt;/p&gt;
&lt;p&gt;3. 数据操作&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、框架略笨重&lt;/p&gt;
&lt;p&gt;2、不适合页面复杂的网站类型开发：&lt;/p&gt;
&lt;div readability=&quot;6.0769230769231&quot;&gt;内容网站，需要SEO的。(SEO目前也有了prerender解决方案) https//&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//prerender.io/&quot;&gt;&lt;span&gt;prerender.io&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;p&gt;交互频繁的，如游戏之类交互体验网站。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;49、什么叫做事件委派？有什么作用？（优点）&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;Jq中的事件委派on&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;将原本需要绑定到子元素上的事件，绑定到其祖先节点乃至根节点上面，再委派给子元素节点，生效！&lt;/p&gt;
&lt;p&gt;eg: $(&quot;p&quot;).on(&quot;click&quot;,function(){});&lt;/p&gt;
&lt;p&gt;事件委派 如下：&lt;/p&gt;
&lt;p&gt;$(document).on(&quot;click&quot;,&quot;p&quot;,function(){});&lt;/p&gt;

&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;作用：&lt;/p&gt;
&lt;p&gt;不使用事件委派的绑定方式，只能将事件绑定到初始化时的子元素标签上，&lt;/p&gt;
&lt;p&gt;当页面新增同类型标签时，这些新增的标签上，没有之前绑定的事件。&lt;/p&gt;
&lt;p&gt;而使用 事件委派时 ，当页面新增更同类型标签时,这些新增的事件也具有之同类型前标签所绑定的事件！&lt;/p&gt;
&lt;p&gt;off()取消事件绑定&lt;/p&gt;
&lt;p&gt;$(&quot;p&quot;).off(&quot;click&quot;):取消单事件绑定&lt;/p&gt;
&lt;p&gt;$(&quot;p&quot;).off(&quot;click mouseover dbclick&quot;):取消多事件绑定&lt;/p&gt;
&lt;p&gt;$(document).off(&quot;click&quot;，&quot;p&quot;):取消委派事件绑定&lt;/p&gt;
&lt;p&gt;$(&quot;p&quot;).off()取消所有的事件绑定&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;50、详细介绍下 CSS的动画&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1、 css的transition transition抓住了所设置变化属性的起始态和完成态，通过设定的速度曲线来完成动画。可以涉及到各种变化的css属性，默认为all，则所有变化的属性都会在出发时，以动画的形式展现出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;tips：transform是一种变化属性，该属性允许我们对元素进行旋转、缩放、移动或倾斜。可以作为transition中需要变化的属性。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.css3的animation属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用animation属性制作动画可以更加灵活的设置动画帧，通过不同keyframe（动画帧）的设置，实现很多优雅的效果，keyframe中的百分数是动画完成总时间的比例。&lt;/p&gt;
&lt;p&gt;animation是设置总的动画效果，而keyframe中设置上相应的动画名字，然后在keyframe中设置具体的动画效果。&lt;/p&gt;
&lt;p&gt;JS中的动画&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.原生js动画&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;原生js动画利用js代码，将动画一步以函数的方式写出来，可以实现多种动画样式，而且可以自己做兼容性处理，自己设立每一步的动画效果，并且能够完成比较复杂的效果，但是代码量很大。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;51、&lt;span&gt;Jquery与jQuery UI 有啥区别？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;*jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;*jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;52、jquery 中如何将数组转化为json字符串，然后再转化回来？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
   $.fn.stringifyArray = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(array) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; JSON.stringify(array)
    }
    $.fn.parseArray &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(array) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; JSON.parse(array)
    }
    然后调用：
    $(&lt;/span&gt;&quot;&quot;).stringifyArray(array)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;53、函数实现&lt;span&gt;阻止冒泡函数的功能？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td data-cell-id=&quot;2439-1508681416627-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;2439-1508681416627-cell-0-1&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;span&gt;function stopPropagation(e) {  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;e = e || window.event;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;if(e.stopPropagation) { //W3C阻止冒泡方法  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;e.stopPropagation();  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;} else {  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;e.cancelBubble = true; //IE阻止冒泡方法  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;}  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;document.getElementById('need_hide').onclick = function(e) {  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;stopPropagation(e);  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;54、什么是闭包？ &lt;span&gt;&lt;span&gt;写一个简单的闭包？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;  &lt;span&gt;我的理解是，闭包就是能够读取其他函数内部变量的函数。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JS中提供了一种闭包的概念：在函数中，定义一个子函数，子函数可以访问父函数的私有变量，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以在子函数中进行操作，最后将子函数通过return返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包的作用:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① 可以在函数外部访问函数的私有变量；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② 让函数内部的变量，可以始终存在于内存中，不会在函数调用完成之后立即释放！&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td data-cell-id=&quot;8058-1508682327164-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;8058-1508682327164-cell-0-1&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;function outer(){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;var num = 1;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;function inner(){&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;var n = 2;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;alert(n + num);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;return inner;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;outer()();&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;55、call和apply的区别是什么？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;    参数形式不同，call(obj, pra, pra)后面是单个参数。apply(obj, [args])后面是数组。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;56、为什么不能定义&lt;span&gt;1px左右的div容器？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;   &lt;span&gt;IE6下这个问题是因为默认的行高造成的，解决的方法也有很多，例如：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;overflow:hidden | zoom:0.08 | line-height:1px&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;57、bind(), live(), delegate()的区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;    bind： 绑定事件，对新添加的事件不起作用，方法用于将一个处理程序附加到每个匹配元素的事件上并返回jQuery对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    live： 方法将一个事件处理程序附加到与当前选择器匹配的所有元素（包含现有的或将来添加的）的指定事件上并返回jQuery对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;delegate： 方法基于一组特定的根元素将处理程序附加到匹配选择器的所有元素（现有的或将来的）的一个或多个事件上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;58、简述&lt;span&gt;link和import的区别？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;区别&lt;span&gt;1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;区别&lt;span&gt;2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;区别&lt;span&gt;3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;区别&lt;span&gt;4：link支持使用Javascript控制DOM去改变样式；而@import不支持。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;59、你如何优化自己的代码？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1、代码重用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、避免全局变量（命名空间，封闭空间，模块化&lt;span&gt;mvc..）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、拆分函数避免函数过于臃肿：&lt;span&gt;单一职责&lt;span&gt;原则&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、适当的注释，尤其是一些复杂的业务逻辑或者是计算逻辑，都应该写出这个业务逻辑的具体过程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内存管理，尤其是闭包中的变量释放&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;60、使用&lt;span&gt;js实现这样的效果：在文本域里输入文字时，当按下enter键时不换行，而是替换成“{{enter}}”,(只需要考虑在行尾按下enter键的情况)&lt;span&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;textarea.&lt;span&gt;onkeydown=function(e){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  e.preventDefault();//&lt;span&gt;为了阻止&lt;span&gt;enter&lt;span&gt;键的默认换行效果&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  if(e.keycode==”enter&lt;span&gt;键码”){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    testarea.value+&lt;span&gt;=”{&lt;span&gt;{enter}}”;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;61、请简要描述&lt;span&gt;web&lt;span&gt;前端性能需要考虑哪方面，你的优化思路是什么？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;参见雅虎&lt;span&gt;14web&lt;span&gt;优化规则&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;减少&lt;span&gt;http&lt;span&gt;请求：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1&lt;span&gt;、小图弄成大图，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2&lt;span&gt;、合理的设置缓存&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;、资源合并、压缩&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将外部的&lt;span&gt;js&lt;span&gt;文件置底&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;62、简述readyonly与disabled的区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;readonly&lt;span&gt;只针对&lt;span&gt;input(text / password)&lt;span&gt;和&lt;span&gt;textarea&lt;span&gt;有效，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而disabled&lt;span&gt;对于所有的表单元素都有效，当表单元素在使用了disabled&lt;span&gt;后，当我们将表单以&lt;span&gt;POST&lt;span&gt;或&lt;span&gt;GET&lt;span&gt;的方式提交的话，这个元素的值不会被传递出去，而&lt;span&gt;readonly&lt;span&gt;会将该值传递出去&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;63、请尽可能详尽的解释ajax的工作原理&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;思路：&lt;span&gt;先解释异步，再解释&lt;span&gt;ajax&lt;span&gt;如何使用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ajax&lt;span&gt;的&lt;span&gt;原理简单来说通过&lt;span&gt;XmlHttpRequest&lt;span&gt;对象来向服务器发异步请求，从服务器获得数据，然后用&lt;span&gt;javascript&lt;span&gt;来操作&lt;span&gt;DOM&lt;span&gt;而更新页面。&lt;span&gt;这其中最关键的一步就是&lt;span&gt;从服务器获得请求数据&lt;span&gt;。要清楚这个过程和原理，我们必须对&lt;span&gt; XMLHttpRequest&lt;span&gt;有所了解。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;XMLHttpRequest&lt;span&gt;是&lt;span&gt;ajax&lt;span&gt;的核心机制，它是在&lt;span&gt;IE5&lt;span&gt;中首先引入的，是一种支持异步请求的技术。简单的说&lt;span&gt;，也就是&lt;span&gt;javascript&lt;span&gt;可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;64、为什么扩展javascript内置对象不是好的做法？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;因为扩展内置对象会影响整个程序中所使用到的该内置对象的原型属性&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;65、浏览器标准模式和怪异模式之间的区别是什么？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;标准模式是指，浏览器按&lt;span&gt;W3C&lt;span&gt;标准解析执行代码；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怪异模式则是使用浏览器自己的方式解析执行代码，因为不同浏览器解析执行的方式不一样，所以我们称之为怪异模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;浏览器解析时到底使用标准模式还是怪异模式，与你网页中的&lt;span&gt;DTD&lt;span&gt;声明&lt;span&gt;直接相关，&lt;span&gt;DTD&lt;span&gt;声明定义了标准文档的类型（标准模式解析）文档类型，会使浏览器使用相应的方式加载网页并显示，忽略&lt;span&gt;DTD&lt;span&gt;声明&lt;span&gt;,&lt;span&gt;将使网页进入怪异模式。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;66、如果设计中使用了非标准的字体，你该如何去实现？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;先通过&lt;span&gt;font-face&lt;span&gt;定义字体，再引用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@font-face&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;font-family: myFirstFont;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;src: url('Sansation_Light.ttf'),&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     url('Sansation_Light.eot'); &lt;span&gt;/* IE9+ */&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;67、简述.trigger与.triggerHandler的区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;.trigger()自动 触发某元素事件；&lt;/p&gt;
&lt;p&gt;第一个参数：是需要触发的事件类型；&lt;/p&gt;
&lt;p&gt;第二个参数：(可选)数组格式，表示传递给事件函数的参数；&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt;传递进来的参数，可以在事件函数中，定义形参进行获取&lt;/p&gt;
&lt;p&gt;(形参第一个必须是event事件，所以从第二个开始为所传递的参数！)&lt;/p&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; 也可以直接在函数中，使用arguements对象数组，读取参数;&lt;/p&gt;
&lt;p&gt; .triggerHandler()：功能同上，区别如下：&lt;/p&gt;
&lt;p&gt;① .triggerHandler()不能触发浏览器默认的HTML事件，如submit等；&lt;/p&gt;
&lt;p&gt;② .trigger()可以触发页面中所有匹配元素的事件；&lt;/p&gt;
&lt;p&gt;而.triggerHandler()只能触发第一个匹配元素的事件；&lt;/p&gt;
&lt;p&gt;③ .trigger()的返回值，返回的是调用当前函数的对象，符合JQuery的可链式语法；&lt;/p&gt;
&lt;p&gt;.triggerHandler()返回的是事件函数的返回值，如果事件函数没有返回值，则返回的是Undefined；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;69、call bind apply 这三个函数有什么共同的作用？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;通过函数名调用这三个函数，可以强行将函数中的this指定为某一个对象&lt;/p&gt;
&lt;p&gt;三个函数的唯一区别，在于接受func的&lt;span&gt;参数列表的形式不同，除此之外，功能上没有差别！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;三个函数的写法(区别)&lt;/p&gt;
&lt;p&gt;① call写法：func.call(func的this指向的obj,func参数1,func参2,....);&lt;/p&gt;
&lt;p&gt;② apply写法：func.apply(func的this指向的obj,[func参数1,func参2,....]);&lt;/p&gt;
&lt;p&gt;③ bind写法：func.bind(func的this指向的obj),(func参数1,func参2,....);&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;70、扩展Object实现继承&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;① 声明一个父类函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;function Parent (){}&lt;/p&gt;
&lt;p&gt;声明一个子类函数&lt;/p&gt;
&lt;p&gt;function Son (){}&lt;/p&gt;

&lt;p&gt;&lt;span&gt;② 通过prototype给Object类添加一个扩展方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Object.prototype.extend = function (parent) {&lt;/p&gt;
&lt;p&gt;for(var i in parent){&lt;/p&gt;
&lt;p&gt;this[i] = parent[i];&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③ 分别拿到父类对象和子类对象: 实例化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;var p = new Parent();&lt;/p&gt;
&lt;p&gt;var s = Son();&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④ 用子类对象调用扩展方法，实现从继承操作：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;s.extend(p)&lt;/p&gt;
&lt;p&gt;实现继承的原理：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过循环将父类对象的所有属性和方法，全部赋给子类对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;关键点在于for-in循环，即使不扩展Object，也能通过简单的循环实现操作；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;71、详细解释下JS中的this指向问题&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;谁最终调用函数，this就指向谁！&lt;/p&gt;
&lt;p&gt;this指向的规律 ：(跟函数的调用方式息息相关！)&lt;/p&gt;
&lt;p&gt;① 通过 【 函数名() 】 调用的，this永远指向window；&lt;/p&gt;
&lt;p&gt;② 通过 【 对象.方法 】调用的，this永远指向对象。obj.func();&lt;/p&gt;
&lt;p&gt;③ 函数作为数组中的 一个元素，通过数组下标调用的 【 arr[i]() 】，this指向数组arr。&lt;/p&gt;
&lt;p&gt;④ 函数作为window内置函数的回调函数使用，this指向widow；&lt;/p&gt;
&lt;p&gt;setTimeout() setInterval()等&lt;/p&gt;
&lt;p&gt;⑤ 函数作为构造函数，使用new关键字调用，this指向新new出的对象。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;72、BootStrap的优点和缺点:&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;流媒体网格布局&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;响应式设计&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自定义表单元素&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;页面排版&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JavaScript交互性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;跨浏览器兼容性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;BT栅格系统的本质就是通过CSS3的媒体查询实现的&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BootStrap的缺点:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;兼容性可能不太好&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;73、什么是渐进增强（progressive enhancement）、优雅降级（graceful degradation）呢？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;渐进增强（progressive enhancement）：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。（&lt;span&gt;从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能，向页面添加无害于基础浏览器的额外样式和功能。当浏览器支持时，它们会自动地呈现出来并发挥作用。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;优雅降级（graceful degradation）：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。（&lt;span&gt;Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了，为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的、能够起作用的版本开始，并不断扩充，以适应未来环境的需要。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;74、常见的浏览器状态码&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;200--请求成功！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;500--内部服务器错误！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;404--请求失败！&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;75、详述jQuery中Ajax的写法以及get和post的区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;$.ajax() 通过 HTTP 请求加载远程数据。jQuery 最底层 AJAX 实现函数。&lt;/p&gt;
&lt;p&gt;接受一个大的对象。对象里面的属性和方法，表示ajax请求的相关设置：&lt;/p&gt;
&lt;p&gt;① url:被请求的远程文件的路径。&lt;/p&gt;
&lt;p&gt;② Ajax请求的类型，可选值get/post.&lt;/p&gt;
&lt;p&gt;回调函数：&lt;/p&gt;
&lt;p&gt;•success： 请求成功的回调函数。接受一个参数data，表示后台返回的数据。&lt;/p&gt;
&lt;p&gt;•dataType：预期服务器返回的数据类型。&lt;/p&gt;
&lt;p&gt;&quot;json&quot;: 返回 JSON 数据 。&lt;/p&gt;
&lt;p&gt;&quot;text&quot;: 返回纯文本字符串&lt;/p&gt;
&lt;p&gt;•data：对象格式。向后台发送一个对象，表示传递的数据。&lt;/p&gt;
&lt;p&gt;常用于type为post的请求方式。&lt;/p&gt;
&lt;p&gt;如果type为get,可以使用？直接追加载URL后面。&lt;/p&gt;
&lt;p&gt;•error:请求失败时的回调函数&lt;/p&gt;
&lt;p&gt;•statusCode:接受一个对象，对象的键值对是status状态码和对应的回调函数，&lt;/p&gt;
&lt;p&gt;表示当请求状态码是对应数字时，执行具体的操作函数.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$.get(); $.post(); 这两个函数，是在$.ajax()的基础上进行封装而来。可以直接默认发送get请求或post请求；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;*&lt;/p&gt;
&lt;p&gt;* 接受四个参数：&lt;/p&gt;
&lt;p&gt;* ① 请求的URL路径。 相当于$.ajax()里面的url；&lt;/p&gt;
&lt;p&gt;* ② 向后台传递的数据。 相当于$.ajax()里面的data；&lt;/p&gt;
&lt;p&gt;* ③ 请求成功的回调函数。 相当于$.ajax()里面的success；&lt;/p&gt;
&lt;p&gt;* ① 预期返回的数据类型。 相当于$.ajax()里面的dataType；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;76、IE和DOM事件流的区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;IE9以前&lt;span&gt;：&lt;span&gt;attachEvent(“onclick”)、detachEvent&lt;span&gt;(“onclick”)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IE9开始&lt;span&gt;跟&lt;span&gt;DOM事件流是一样的，都是addEventListener&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;77、IE跟DOM事件流有什么区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;① 阐述事件绑定方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IE9以前&lt;span&gt;：&lt;span&gt;attachEvent(“onclick”)、detachEvent&lt;span&gt;(“onclick”)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IE9开始:&lt;span&gt;跟&lt;span&gt;DOM事件流是一样的，都是addEventListener&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② 这两种绑定方式的区别&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;span&gt;写法上的区别：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;attachEvent&lt;span&gt;两个参数、事件带&lt;span&gt;on&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;addEventListener &lt;span&gt;三个参数、事件不带&lt;span&gt;on、true/false表示&lt;span&gt;捕获&lt;span&gt;/冒泡&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;功能上的区别：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;attachEvent绑定的事件全部冒泡&lt;span&gt;、&lt;span&gt;addEventListener根据第三个参数是true还是false决定冒泡还是捕获。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③ &lt;span&gt;事件冒泡和事件捕获。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;冒泡： &lt;span&gt;&lt;span&gt;当触发一个事件时，会从当前节点开始，依次触发其祖先节点的同类型事件。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;span&gt;捕获： &lt;span&gt;&lt;span&gt;从根节点开始，依次触发其祖先节点同类型事件，直到节点自身。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;78、IE和标准下有哪些兼容性的写法？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1、获取事件对象&lt;span&gt;(&lt;span&gt;事件因子&lt;span&gt;)&lt;span&gt;：  ev = e || window.event;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、DOM2&lt;span&gt;添加事件： &lt;span&gt;if(dom.attachEvent&lt;span&gt;){&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Dom. attachEvent(“onclick”,function);&lt;/p&gt;
&lt;p&gt;}else{&lt;/p&gt;
&lt;p&gt;Dom.&lt;span&gt; addEventListener(“click”,function);&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、取消事件冒泡： &lt;span&gt;if (e.stopPropagation) {&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         e.stopPropagation(); //IE&lt;span&gt;以外&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    } else {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        e.cancelBubble = true; //IE8&lt;span&gt;之前&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、取消默认事件：if (e.preventDefault) {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     e.preventDefault(); //IE&lt;span&gt;以外&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  } else {&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;  e.returnValue = false; //IE&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  }&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;79、API是什么？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;API&lt;span&gt;（&lt;span&gt;Application Programming Interface,&lt;span&gt;应用程序编程接口&lt;span&gt;）是一&lt;span&gt;些预先定义的函数，&lt;span&gt;目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而&lt;span&gt;又无需访问源码&lt;span&gt;，或理解内部工作机制的细节。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在编程语言中，API&lt;span&gt;通常指语言中内置的函数、接口、类等系统工具。我们编程人员无需关心这些函数的实现细节，只需要按照API&lt;span&gt;文档的要求，给函数传入指定参数接受返回值即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;在前后台传递数据，API&lt;span&gt;也是后台提供给前台的接口，前台只需要按照要求请求接口并发送指定参数，结课接受JSON&lt;span&gt;字符串。例如：&lt;a href=&quot;https://api.douban.com/v2/book/1220562&quot;&gt;&lt;span&gt;https://api.douban.com/v2/book/1220562&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;80、Javascript事件处理器在线程空闲之前不会运行是什么意思？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;JS&lt;span&gt;是一个&lt;span&gt;单线程应用，&lt;span&gt;也就是说，当某一段代码正在执行的时候，其他代码如果需要执行也必须等到这个线程结束后，才能执行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td data-cell-id=&quot;8790-1508838851156-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;8790-1508838851156-cell-0-1&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;for(var i=1;i&amp;lt;=3;i++){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  setTimeout(function(){&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      console.log(i);   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  },0); &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;};&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;代码执行到for&lt;span&gt;循环时，当for&lt;span&gt;循环执行第一次，遇到第一个&lt;span&gt;setTimeout时并不会立即触发&lt;span&gt;，因为&lt;span&gt;for循环还有结束&lt;span&gt;，现在的线程被&lt;span&gt;for循环阻塞&lt;span&gt;。&lt;span&gt;setTimeout必须等到for循环的线程结束以后&lt;span&gt;，也就是线程空闲之后，才能执行，而这时候&lt;span&gt;i已经变成了4.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;所以最终打印三个&lt;span&gt;4.  解决的办法可以将var改成let，或者for循环中嵌套自执行函数。 原理。。。。。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;81、js中callee和caller的作用&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;写法不同：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;callee&lt;span&gt;是&lt;span&gt;Arguments&lt;span&gt;的一个属性，在函数中使用&lt;span&gt;Arguments.callee&lt;span&gt;调用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;C&lt;span&gt;aller&lt;span&gt;在函数中，直接使用函数名调用。  F&lt;span&gt;unc.&lt;span&gt; C&lt;span&gt;aller&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;功能不同：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Arguments.callee &lt;span&gt;返回的是，&lt;span&gt;当前函数自身的引用！！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;F&lt;span&gt;unc.&lt;span&gt; C&lt;span&gt;aller &lt;span&gt;返回的是&lt;span&gt;，当前函数在哪个函数中调用。 &lt;span&gt;&lt;span&gt;如果函数时顶层调用，则返回&lt;span&gt;null&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;function func(){&lt;/p&gt;
&lt;p&gt;console.log(func.caller);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;func(); // null&lt;/p&gt;
&lt;p&gt;function func1(){&lt;/p&gt;
&lt;p&gt;func();&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;func1(); // &lt;span&gt;返回&lt;span&gt;func1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;82、js中的保留字是什么？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;程序中&lt;span&gt;预定义的关键字&lt;span&gt;(&lt;span&gt;函数名、类名、属性名、方法名等标识符&lt;span&gt;)&lt;span&gt;都是&lt;span&gt;js&lt;span&gt;中的保留字。 这些保留字，不允许用户再次声明为变量、方法、函数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;保留字在编译器中会变色。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;83、工厂方式创建js对象是啥方式 （JS中创建对象的多种方式）&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt; ① 字面量模式： &lt;span&gt;var obj = {}&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110183259466-1894034820.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110183325903-1969404552.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110183349169-1324536019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;混合模式就是我们所说的将属性添加到成员属性&lt;span&gt;(&lt;span&gt;构造函数模式&lt;span&gt;)&lt;span&gt;，将方法添加到原型方法（原型模式）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110183411216-1590117069.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;84、js延迟加载的方式有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;+&lt;span&gt;将&lt;span&gt;JS&lt;span&gt;代码放在文档最后也是延迟加载的方式之一。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;85、documen.write和 innerHTML 的区别？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;documen.write &lt;span&gt;是直接在整个文档中，写入代码。会覆盖掉其他已有代码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;innerHTML &lt;span&gt;是选中一个节点后，修改节点里面的代码，只影响当前节点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;86、解释jsonp的原理，以及为什么不是真正的ajax&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;后续讲解&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;87、javascript 中的垃圾回收机制？闭包中的内存释放？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Js&lt;span&gt;中的垃圾回收机制，函数中的变量，会在函数执行完成后，被回收处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，如果函数中使用了闭包，那么函数中的变量将始终被内部的函数持有，而不会在函数执行完成后释放。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;闭包的两个重要作用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① 可以让函数外部，能够访问函数内部的变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② 让函数内部的变量在函数执行完成后，不会被释放，而始终保持在内存中&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;88、哪些操作会造成内存泄漏&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;大量使用全局变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大量使用闭包&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;清除DOM&lt;span&gt;节点时，只清除节点，而没有删除事件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;



&lt;hr/&gt;&lt;p&gt;&lt;span&gt;89、js中的精度问题&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;JS&lt;span&gt;中在浮点数运算或者大整数运算的时候，可能导致不准确的结果出现。 &lt;span&gt;&lt;span&gt;例如&lt;span&gt;0.7+0.1=0.7999999999999 &lt;span&gt;解决办法可以将数字&lt;span&gt;*10&lt;span&gt;相加，然后再除以&lt;span&gt;10&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;90、简述defer和async的区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1&lt;span&gt;.&lt;span&gt;默认引用 &lt;span&gt;script:&lt;span&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;x.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当浏览器遇到 &lt;span&gt;script &lt;span&gt;标签时，&lt;span&gt;文档的解析将停止，并立即下载并执行脚本&lt;span&gt;，脚本执行完毕后将继续解析文档。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2&lt;span&gt;.async&lt;span&gt;模式&lt;span&gt; &amp;lt;script &lt;span&gt;type=&quot;text/javascript&quot; src=&quot;x.min.js&quot; async=&quot;async&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当浏览器遇到 &lt;span&gt;script &lt;span&gt;标签时，文档的&lt;span&gt;解析不会停止&lt;span&gt;，&lt;span&gt;其他线程将下载脚本，脚本下载完成后开始执行脚本&lt;span&gt;，脚本执行的过程中文档将停止解析，直到脚本执行完毕。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3&lt;span&gt;.defer&lt;span&gt;模式&lt;span&gt; &amp;lt;script &lt;span&gt;type=&quot;text/javascript&quot; src=&quot;x.min.js&quot; defer=&quot;defer&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当浏览器遇到 &lt;span&gt;script &lt;span&gt;标签时，文档的解析不会停止，其他线程将下载脚本，&lt;span&gt;待到文档解析完成，脚本才会执行&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110183507981-1079945671.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;91、业界常用的优化WEB页面加载速度的方法（可以分别从页面元素展现，请求连接，css,js,服务器等方面介绍）&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;92、解释什么是sql注入，xss漏洞？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;93、解释下这个css选择器发生什么？   [role=nav]&amp;gt;ul a:not([href^=mailto]){}&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;[role=nav] &lt;span&gt;选中页面中&lt;span&gt; role&lt;span&gt;属性等于&lt;span&gt;nav&lt;span&gt;的元素&lt;span&gt;. &lt;span&gt;也就是导航栏&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[role=nav]&amp;gt;ul &lt;span&gt;导航栏中的子节点&lt;span&gt; ul&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;[role=nav]&amp;gt;ul a  UL&lt;span&gt;里面的&lt;span&gt;a&lt;span&gt;标签&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a:not([href^=mailto]) &lt;span&gt;选中a&lt;span&gt;标签，除了href&lt;span&gt;属性使用&lt;span&gt;mailto&lt;span&gt;开头的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选中导航栏中的&lt;span&gt;ul&lt;span&gt;里面的不是&lt;span&gt;mailto&lt;span&gt;的&lt;span&gt;a&lt;span&gt;标签。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;94、有这样一个URL：http://item.taobao.com/item.htm?a=1&amp;amp;b=2&amp;amp;c= e &amp;amp;d=xxx，请写一段JS程序提取URL中的各个GET参数(参数名和参数个数不确定)，将其按key-value形式返回到一个json结构中，如{a:’1′,?b:’2′,?c:”,?d:’xxx’,?e:undefined}。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110183621794-706138375.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;95、以下哪个单词不属于javascript保留字   B&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;A.with&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;B.parent&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;C.class&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;D.void&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;96、 动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;97、 按需异步载入js&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;99、简单的介绍下JS面向对象中的__proto__与prototype&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、prototype:函数的原型对象&lt;/p&gt;
&lt;p&gt;① 只有函数才有prototype，而且所有的函数必然有prototype!&lt;/p&gt;
&lt;p&gt;② prototype本身也是一个对象！&lt;/p&gt;
&lt;p&gt;③ prototype指向了当前函数所在的引用地址！&lt;/p&gt;
&lt;p&gt;2、__proto__：对象的原型&lt;/p&gt;
&lt;p&gt;① 只有对象才有__proto__，而且所有的对象必有__proto__；&lt;/p&gt;
&lt;p&gt;② __proto__也是一个对象，所以也有自己的__proto__，顺着这条线向上找的顺序，就是原型链。&lt;/p&gt;
&lt;p&gt;③ 数组都是对象，也都有自己的__proto__；&lt;/p&gt;
&lt;p&gt;3、实例化一个类，拿到对象的原理：&lt;/p&gt;
&lt;p&gt;实例化一个类的时候，实际上是将新对象的__proto__，指向构造函数所在的prototype；&lt;/p&gt;
&lt;p&gt;也就是说：zhangsan.__proto__ ==Person.prototype √&lt;/p&gt;
&lt;p&gt;4、所有对象的__proto__沿着原型链向上查找都将指向Object的prototype;&lt;/p&gt;
&lt;p&gt;Object的prototype的原型，指向null；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;100、简述下什么是CSShack以及其表现形式有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;CSS hack由于不同厂商的&lt;span&gt;浏览器，比如Internet Explorer,Safari,&lt;span&gt;Mozilla Firefox,Chrome等，或者是同一厂商的浏览器的不同版本，如IE6和IE7，对CSS的解析认识不完全一样，因此会导致生成的页面效果不一样，得不到我们所需要的页面效果。 这个时候我们就需要针对不同的浏览器去写不同的CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中也能得到我们想要的页面效果。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;简单的来说：&lt;/p&gt;
&lt;p&gt;CSS hack的目的就是使你的CSS代码兼容不同的浏览器。&lt;/p&gt;
&lt;p&gt;表现形式：&lt;/p&gt;
&lt;p&gt;（1）方式一 条件注释法&lt;/p&gt;
&lt;p&gt;（2）方式二 类内属性前缀法&lt;/p&gt;
&lt;p&gt;（3）CSS hack方式三：选择器前缀法&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;101、Require.js有什么作用？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、实现了文件的异步加载，避免网页失去响应。&lt;/p&gt;
&lt;p&gt;2、管理模块之间的依赖性，便于代码的编写和维护。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;102、怎么检测一个对象是不是一个类的实例？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;instanceof：A instanceof B 检测一个对象(A)是不是一个类(B)的一个实例；&lt;/p&gt;
&lt;p&gt;louver instanceof Person;√ louver是函数Person的实例化；&lt;/p&gt;
&lt;p&gt;louver instanceof Object;√ 所有对象都是Object的一个实例；&lt;/p&gt;
&lt;p&gt;Person instanceof Object;√ 函数本身也是一个对象；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;constructor：返回当前对象的构造函数；&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;103、zepto和jQuery的不同之处有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1、zepto不支持IE浏览器；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、zepto增加了一些基本的触摸事件：如tap，swip事件’&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、DOM操作的区别：添加ID时jQuery不会生效，而zepto会生效！&lt;/p&gt;
&lt;p&gt;4、使用zepto时，load事件的处理函数会执行，使用jQuery时，load事件的处理函数不会执行。&lt;/p&gt;
&lt;p&gt;5、事件委派的不同：&lt;/p&gt;
&lt;p&gt;在zepto中，当a被点击之后，一次性弹出内容为a事件和b事件，但是在jQuery中只会触发委托弹出a事件，再点击一次才会触发b事件！&lt;/p&gt;
&lt;p&gt;6、offse:zepto：返回left top width heigth&lt;/p&gt;
&lt;p&gt;jQuery:只会返回left top&lt;/p&gt;

&lt;p&gt;&lt;span&gt;7、zepto无法隐藏元素的宽高，jQuery可以；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8、zepto不支持的选择器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① 基本伪类：first last eq(index)&lt;/p&gt;
&lt;p&gt;② 内容伪类：contains(text) :empty :has(selector)&lt;/p&gt;
&lt;p&gt;③ 可见性伪类：hidden visible&lt;/p&gt;
&lt;p&gt;④ 属性选择器：[attribute = value]&lt;/p&gt;
&lt;p&gt;⑤ 表单伪类：input :text :password :submit&lt;/p&gt;
&lt;p&gt;⑥ 表单对象属性：selected&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;104、使用JS跳转页面的方法：&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Window.location=&quot;http://www.baidu.com&quot;;&lt;/p&gt;
&lt;p&gt;细分几种使用location跳转页面的类型：&lt;/p&gt;
&lt;p&gt;location.replace(&quot;http://www.baidu.com&quot;); 使用新的文档替换当前文档，替换以后，不能退回。&lt;/p&gt;
&lt;p&gt;location.assign(&quot;http://www.baidu.com&quot;);加载新的文档，加载之后，可以退回。&lt;/p&gt;
&lt;p&gt;location.repload();重新加载当前页面，即刷新页面；&lt;/p&gt;
&lt;p&gt;①、 location.repload(true) 强制刷新页面，从服务器端重新加载页面----Ctrl+f5;&lt;/p&gt;
&lt;p&gt;②、 location.repload() 在本地刷新当前页面---f5&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;105、一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;图片懒加载&lt;span&gt;，在页面上的未可视区域可以添加一个滚动条事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果图片为&lt;span&gt;css图片，可以使用&lt;span&gt;CSSsprite&lt;span&gt;，&lt;span&gt;SVGsprite&lt;span&gt;，&lt;span&gt;Iconfont&lt;span&gt;、&lt;span&gt;Base64&lt;span&gt;等技术。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更换最新的图片格式&lt;span&gt; &lt;span&gt;谷歌的&lt;span&gt;webp腾讯的tpg&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;合成雪碧图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大图分割加载&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;106、CSS3新增伪类有那些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt; p:first-of-type 选择属于其父元素的首个 &amp;lt;p&amp;gt; 元素的每个 &amp;lt;p&amp;gt; 元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    p:last-of-type  选择属于其父元素的最后 &amp;lt;p&amp;gt; 元素的每个 &amp;lt;p&amp;gt; 元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    p:only-of-type  选择属于其父元素唯一的 &amp;lt;p&amp;gt; 元素的每个 &amp;lt;p&amp;gt; 元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    p:only-child    选择属于其父元素的唯一子元素的每个 &amp;lt;p&amp;gt; 元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &amp;lt;p&amp;gt; 元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    :enabled、:disabled 控制表单控件的禁用状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;:checked，单选框或复选框被选中。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;107、如何在 HTML5 页面中嵌入音频、视频?&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;HTML 5 包含嵌入音频文件的标准方式，支持的格式包括 MP3、Wav 和 Ogg：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;audio controls&amp;gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &amp;lt;source src=&quot;jamshed.mp3&quot; type=&quot;audio/mpeg&quot;&amp;gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   Your browser does'nt support audio embedding feature. &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;/audio&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和音频一样，&lt;span&gt;HTML5 定义了嵌入视频的标准方法，支持的格式包括：MP4、WebM 和 Ogg：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;video width=&quot;500px&quot; height=&quot;500px&quot; autoplay=&quot;autoplay&quot; loop=&quot;loop&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;source src=&quot;binzhiliang1.mp4&quot; type=&quot;video/mp4&quot; &amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Your browser does'nt support video embedding feature. &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;/source&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;/video&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;108、怎么取到一个网址并转化为字符串格式存储？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;console.log(location.href);//返回当前完整路径；&lt;/p&gt;
&lt;p&gt;/*将js中的对象、数组，转化*/&lt;/p&gt;
&lt;p&gt;var str1 = JSON.stringify(jsonObj);&lt;/p&gt;
&lt;p&gt;console.log(str1);&lt;/p&gt;
&lt;p&gt;var obj = JSON.parse(str1);&lt;/p&gt;
&lt;p&gt;console.log(obj);&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;109、如何优化网页加载速度？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;   1.减少css，js文件数量及大小(减少重复性代码，代码重复利用)，压缩CSS和Js代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   2.图片的大小&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   3.把css样式表放置顶部，把js放置页面底部&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   4.减少http请求数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   5.使用外部 Js 和 CSS&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;110、知道css有个content属性吗？有什么作用？有什么应用？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;知道。&lt;span&gt;css的content属性专门应用在 before/after 伪元素上，用来插入生成内容。最常见的应用是利用伪类清除浮动。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;//一种常见利用伪类清除浮动的代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.clearfix:after {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    content:&quot;.&quot;; //这里利用到了content属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    display:block;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    height:0;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    visibility:hidden;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    clear:both; }&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.clearfix {&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    *zoom:1;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;after伪元素通过 content 在元素的后面生成了内容为一个点的块级素，再利用clear:both清除浮动。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;111、简述下web storage和cookie的区别&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、&lt;span&gt;Web Storage&lt;span&gt;相对于&lt;span&gt;cookie&lt;span&gt;来说，拥有更大的容量储存。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、Cookie&lt;span&gt;的大小是受限的，并且每次你请求一个新的页面的时候&lt;span&gt;Cookie&lt;span&gt;都会被发送过去，这样无形 中浪费了带宽。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、&lt;span&gt;cookie&lt;span&gt;还需要指定作用域，不可以跨域调用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、&lt;span&gt;Web Storage&lt;span&gt;拥有&lt;span&gt;setItem,getItem,removeItem,clear&lt;span&gt;等方法，不像&lt;span&gt;cookie&lt;span&gt;需要前端开发者自己封装&lt;span&gt;setCookie&lt;span&gt;，&lt;span&gt;getCookie&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、但是&lt;span&gt;Cookie&lt;span&gt;也是不可以或缺的：&lt;span&gt;Cookie&lt;span&gt;的作用是与服务器进行交互，作为&lt;span&gt;HTTP&lt;span&gt;规范的一部分而存在&lt;span&gt; ，而Web Storage&lt;span&gt;仅仅是为了在本地&lt;span&gt;“&lt;span&gt;存储&lt;span&gt;”&lt;span&gt;数据而生。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;112、为什么利用多个域名来存储网站资源会更有效？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;CDN&lt;span&gt;缓存更方便&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;突破浏览器并发限制&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;节约&lt;span&gt;cookie带宽 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;节约主域名的连接数，优化页面响应速度&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;防止不必要的安全问题&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;113、HTML5 Canvas 元素有什么用？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;答：&lt;span&gt;Canvas 元素用于在网页上绘制图形，该元素标签强大之处在于可以直接在 HTML 上进行图形操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;115、请用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; iArray =&lt;span&gt; [];
funtion getRandom(istart, iend){
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; iChoice = istart - iend +1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Math.floor(Math.random() * iChoice +&lt;span&gt; istart;
}
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0; i&amp;lt;10; i++&lt;span&gt;){
iArray.push(getRandom(&lt;/span&gt;10,100&lt;span&gt;));
}
iArray.sort();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;116、如何消除一个数组里面重复的元素？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;方法一：
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr=[1,2,3,3,4,4,5,5,6,1,9,3,25,4&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; deRepeat(){
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newArr=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt;{};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; index=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; l=&lt;span&gt;arr.length;
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;l;i++&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(obj[arr[i]]==&lt;span&gt;undefined){
obj[arr[i]]&lt;/span&gt;=1&lt;span&gt;;
newArr[index&lt;/span&gt;++]=&lt;span&gt;arr[i];
}&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(obj[arr[i]]==1&lt;span&gt;)
}
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newArr;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newArr2=&lt;span&gt;deRepeat(arr);
alert(newArr2); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出1,2,3,4,5,6,9,25&lt;/span&gt;
&lt;span&gt;方法二：
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr = [1,2,2,3,3,3,4,5,6&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; func (arr){
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; newArr = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array;
newArr.push(arr[&lt;/span&gt;0&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;=arr.length;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newArr.indexOf(arr[i])==-1&lt;span&gt;) {
newArr.push(arr[i]);
}
}
document.write(newArr);
}
func(arr);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;117、闭包：下面这个ul，如何点击每一列的时候alert其index？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;ul id=&quot;test&quot;&amp;gt;
&amp;lt;li&amp;gt;这是第一条&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;这是第二条&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;这是第三条&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;span&gt;非闭包实现
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; lis=document.querySelectorAll('li'&lt;span&gt;);
document.querySelector(&lt;/span&gt;'#test').onclick=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; lis.length; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; li =&lt;span&gt; lis[i];
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(li==&lt;span&gt;e.target){
            alert(i);
        }
    }
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;闭包实现&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; lis=document.querySelectorAll('li'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; lis.length; i++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; li =&lt;span&gt; lis[i];
    li.onclick&lt;/span&gt;=(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(index){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(e){
            alert(index);
        };
    })(i);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;118、JavaScript数组元素添加、删除、排序等方法有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;Array.concat( ) &lt;span&gt;连接数组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.join( ) &lt;span&gt;将数组元素连接起来以构建一个字符串&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.length &lt;span&gt;数组的大小&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.pop( ) &lt;span&gt;删除并返回数组的最后一个元素&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.push( ) &lt;span&gt;给数组添加元素&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.reverse( ) &lt;span&gt;颠倒数组中元素的顺序&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.shift( ) &lt;span&gt;将元素移出数组&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.slice( ) &lt;span&gt;返回数组的一部分&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.sort( ) &lt;span&gt;对数组元素进行排序&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.splice( ) &lt;span&gt;插入、删除或替换数组的元素&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.toLocaleString( ) &lt;span&gt;把数组转换成局部字符串&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Array.toString( ) &lt;span&gt;将数组转换成一个字符串&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;119、简述remove和detach异同&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;* 1、相同点：&lt;/p&gt;
&lt;p&gt;* ① 都会把当前标签，以及当前标签的所有子节点，全部删除；&lt;/p&gt;
&lt;p&gt;* ② 都可以在删除时，把当前节点返回。并可以使用变量接受返回的节点，以便后期恢复；&lt;/p&gt;
&lt;p&gt;* 2、 不同点：&lt;/p&gt;
&lt;p&gt;* 使用接受的节点，恢复原节点时。&lt;/p&gt;
&lt;p&gt;* remove只能恢复节点的内容，但是事件绑定，不能再恢复；&lt;/p&gt;
&lt;p&gt;* detach不但恢复节点的内容，还能再恢复 事件的绑定；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;120、Ajax 是什么? 如何创建一个Ajax？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;Ajax并不算是一种新的技术，全称是asynchronous javascript and xml，可以说是已有技术的组合，主要用来&lt;span&gt;实现客户端与服务器端的异步通信效果，实现页面的局部刷新&lt;span&gt;，&lt;span&gt;带来更好的用户体验；按需获取数据，节约带宽资源；&lt;span&gt;早期的浏览器并不能原生支持ajax，可以使用隐藏帧（iframe）方式变相实现异步效果，后来的浏览器提供了对ajax的原生支持&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用&lt;span&gt;ajax原生方式发送请求主要通过XMLHttpRequest(标准浏览器)、ActiveXObject(IE浏览器)对象实现异步通信效果&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;121、举例简述同步和异步的区别?&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;同步：阻塞的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-张三叫李四去吃饭，李四一直忙得不停，张三一直等着，直到李四忙完两个人一块去吃饭&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;=浏览器向服务器请求数据，服务器比较忙，浏览器一直等着（页面白屏），直到服务器返回数据，浏览器才能显示页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;异步：非阻塞的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;-张三叫李四去吃饭，李四在忙，张三说了一声然后自己就去吃饭了，李四忙完后自己去吃&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;=浏览器向服务器请求数据，服务器比较忙，浏览器可以自如的干原来的事情（显示页面），服务器返回数据的时候通知浏览器一声，浏览器把返回的数据再渲染到页面，局部更新&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;122、如何解决跨域问题?&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;理解跨域的概念：&lt;span&gt;协议&lt;span&gt;、&lt;span&gt;域名&lt;span&gt;、&lt;span&gt;端口&lt;span&gt;都相同才同域，否则都是跨域&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出于安全考虑，服务器不允许&lt;span&gt;ajax跨域获取数据，但是可以跨域获取文件内容，所以基于这一点，可以动态创建script标签，使用标签的src属性访问js文件的形式获取js脚本，并且这个js脚本中的内容是&lt;span&gt;函数调用&lt;span&gt;，该函数调用的参数是服务器返回的数据，为了获取这里的参数数据，需要事先在页面中定义回调函数，在回调函数中处理服务器返回的数据，这就是解决跨域问题的主流解决方案&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;123、页面编码和被请求的资源编码如果不一致如何处理？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;对于&lt;span&gt;ajax请求传递的参数，如果是get请求方式，参数如果传递中文，在有些浏览器会乱码，不同的浏览器对参数编码的处理方式不同，所以对于get请求的参数需要使用 &lt;span&gt;encodeURIComponent&lt;span&gt;函数对参数进行编码处理，后台开发语言都有相应的解码&lt;span&gt;api。对于post请求不需要进行编码&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;124、简述ajax 的过程。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1. 创建XMLHttpRequest对象,也就是创建一个异步调用对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 设置响应HTTP请求状态变化的函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 发送HTTP请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5. 获取异步调用返回的数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6. 使用JavaScript和DOM实现局部刷新&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;$.ajax() 通过 HTTP 请求加载远程数据。jQuery 最底层 AJAX 实现函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接受一个大的对象。对象里面的属性和方法，表示ajax请求的相关设置：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;① url:被请求的远程文件的路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② Ajax请求的类型，可选值get/post.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回调函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•success： 请求成功的回调函数。接受一个参数data，表示后台返回的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•dataType：预期服务器返回的数据类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;json&quot;: 返回 JSON 数据 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;text&quot;: 返回纯文本字符串&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•data：对象格式。向后台发送一个对象，表示传递的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常用于type为post的请求方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果type为get,可以使用？直接追加载URL后面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•error:请求失败时的回调函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•statusCode:接受一个对象，对象的键值对是status状态码和对应的回调函数，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表示当请求状态码是对应数字时，执行具体的操作函数.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;404 - 页面没有找到！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;403 - 服务器收到请求，但是拒绝提供服务！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;200 - 请求成功！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;500 - 内部服务器错误！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;503 - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;301 - 资源（网页等）被永久转移到其它URL！&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;125、阐述一下异步加载。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1. 异步加载的方案： 动态插入 script 标签&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 通过 ajax 去获取 js 代码，然后通过 eval 执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. script 标签上添加 defer 或者 async 属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 创建并插入 iframe，让它异步执行 js&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;126、请解释一下 JavaScript 的同源策略。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;所谓同源指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在前后台进行数据交互时，两个文件必须处于同一域名同一端口号同一协议名之下，否则跨域请求&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;127、ajax的缺点&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt; 1、ajax不支持浏览器back按钮。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2、安全问题 AJAX暴露了与服务器交互的细节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3、对搜索引擎的支持比较弱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 4、破坏了程序的异常机制。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;128、解释jsonp的原理，以及为什么不是真正的ajax&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;　　&lt;span&gt;Jsonp并不是一种数据格式，而json是一种数据格式，&lt;span&gt;jsonp是用来解决跨域获取数据的一种解决方案&lt;span&gt;，具体是通过&lt;span&gt;动态创建&lt;span&gt;script标签，&lt;span&gt;然后通过标签的&lt;span&gt;src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好&lt;span&gt;回调函数，本质上使用的并不是&lt;span&gt;ajax技术&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;129、什么是Ajax和JSON，它们的优缺点。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;Ajax是全称是asynchronous JavaScript andXML，即异步JavaScript和xml，&lt;span&gt;用于在Web页面中实现异步数据交互，实现页面局部刷新。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优点：可以使得页面不重载全部内容的情况下加载局部内容，降低数据传输量，避免用户不断刷新或者跳转页面，提高用户体验&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：对搜索引擎不友好；要实现&lt;span&gt;ajax下的前后退功能成本较大；可能造成请求数据的增加跨域问题限制；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JSON是一种轻量级的数据交换格式&lt;span&gt;，ECMA的一个子集&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;优点：轻量级、易于人的阅读和编写，便于机器（&lt;span&gt;JavaScript）解析，支持复合数据类型（数组、对象、字符串、数字）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;130、分别介绍下javascript的本地对象，内置对象和宿主对象&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;本地对象为独立于宿主环境的&lt;span&gt;ECMAScript提供的对象，包括Array Object RegExp等&lt;span&gt;可以new实例化&lt;span&gt;的对象&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内置对象为&lt;span&gt;Gload&lt;span&gt;，&lt;span&gt;Math 等&lt;span&gt;不可以实例化&lt;span&gt;的(他们也是本地对象，内置对象是本地对象的一个子集)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;宿主对象为所有的非本地对象，所有的&lt;span&gt;BOM和DOM对象都是宿主对象，如&lt;span&gt;浏览器自带的&lt;span&gt;document,window 等&lt;span&gt;对象。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图解：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110183900513-278896728.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;131、为什么利用多个域名来存储网站资源会更有效？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1、速度保证：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;确保用户在不同地区能用最快的速度打开网站。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、安全保障：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中某个域名崩溃用户也能通过其他域名问网站，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、服务端：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;并且不同的资源放到不同的服务器上有利于减轻单台服务器的压力。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;132、请说出三种减低页面加载时间的方法&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1、压缩css、js文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、合并js、css文件，减少http请求&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、外部js、css文件放在最底下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、减少dom操作，尽可能用变量替代不必要的dom操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、优化图片加载的方式。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;133、 知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么?&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;Webkit是浏览器引擎，包括html渲染和js解析功能，手机浏览器的主流内核，与之相对应的引擎有Gecko（Mozilla Firefox 等使用）和Trident（也称MSHTML，IE 使用）。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于浏览器的调试工具要熟练使用，主要是页面结构分析，后台请求信息查看，&lt;span&gt;js调试工具使用，熟练使用这些工具可以快速提高解决问题的效率.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1209629/201711/1209629-20171110183934247-249314736.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;1、Elements 功能标签页：用来查看，修改页面上的元素，包括DOM标签，以及css样式的查看，修改，还有相关盒模型的图形信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、Console控制台：用于打印和输出相关的命令信息，常用于JS错误调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、Sources js资源页面：这个页面内我们可以找到当然浏览器页面中的js 源文件，方便我们查看和调试(打断点调试)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、.Network 网络请求标签页：可以看到所有的资源请求，包括网络请求，图片资源，html,css，js文件等请求，可以根据需求筛选请求项，一般多用于网络请求的查看和分析，分析后端接口是否正确传输，获取的数据是否准确，请求头，请求参数的查看&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、.Timeline标签页可以显示JS执行时间、页面元素渲染时间，不做过多介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6、.Profiles标签页可以查看CPU执行时间与内存占用，不做过多介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7、.Resources标签页会列出所有的资源，以及HTML5的Database和LocalStore等，你可以对存储的内容编辑和删除 不做过多介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;8、.Security标签页 可以告诉你这个网站的安全性，查看有效的证书等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;9、.Audits标签页 可以帮你分析页面性能，有助于优化前端页面，分析后得到的报告&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;134、简述一下 Handlebars 的基本用法？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Handlebars 是 JavaScript 一个语义模板库，通过对view和data的分离来快速构建Web模板。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;135、详解在AngualrJS中使用$http进行数据请求的方法？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$http({
method: &lt;/span&gt;'GET', &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;请求的方法&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
url: &lt;/span&gt;'h51701.json' &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;请求的地址&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj){
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;请求成功的回调函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
alert(&lt;/span&gt;&quot;请求成功！&quot;&lt;span&gt;);
$scope.data &lt;/span&gt;=&lt;span&gt; obj.data;
},&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;请求失败的回调函数&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
alert(&lt;/span&gt;&quot;请求失败！&quot;&lt;span&gt;);
});
[简写方式]
可以直接简写为get或者post方式：
$http.get(&lt;/span&gt;'/someUrl'&lt;span&gt;).then(successCallback, errorCallback);
$http.post(&lt;/span&gt;'/someUrl', data).then(successCallback, errorCallback);
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;136、如何让一个标签块级显示？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、给该元素添加浮动属性&lt;/p&gt;
&lt;p&gt;2、给该元素添加绝对定位属性&lt;/p&gt;
&lt;p&gt;3、 给父元素添加display:flex属性设置为弹性盒子（弹性盒子内部全是块级标签）&lt;/p&gt;
&lt;p&gt;4、给其本身添加display:block/ inlineblock属性&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;137、利用原生JS实现Ajax请求后台数据的步骤？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一步： 获得XMLHttpRequest对象&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; ajax = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二步： 设置状态监听函数&lt;/span&gt;
ajax.onreadystatechange = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
console.log(ajax.readyState);
console.log(ajax.status);
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第五步：在监听函数中，判断readyState=4 &amp;amp;&amp;amp; status=200表示请求成功&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;(ajax.readyState==4 &amp;amp;&amp;amp; ajax.status==200&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第六步： 使用responseText、responseXML接受响应数据，并使用原生JS操作DOM进行显示&lt;/span&gt;
&lt;span&gt;console.log(ajax.responseText);
console.log(ajax.responseXML);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回不是XML，显示null&lt;/span&gt;
&lt;span&gt;console.log(JSON.parse(ajax.responseText));
console.log(eval(&lt;/span&gt;&quot;(&quot;+ajax.responseText+&quot;)&quot;&lt;span&gt;));
}
}
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第三步： open一个链接&lt;/span&gt;
ajax.open(&quot;GET&quot;,&quot;h51701.json&quot;,&lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;true异步请求，false同步&lt;/span&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第四步： send一个请求。 可以发送对象和字符串，不需要传递数据发送null&lt;/span&gt;
ajax.send(&lt;span&gt;null&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;138、实现Ajax的跨域请求有哪些方法？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;【跨域请求处理】&lt;/p&gt;
&lt;p&gt;由于JS中存在同源策略，当请求不同协议名，不同端口号，不同主机名下面的文件时，将会违背同源策略，无法请求成功！需要进行跨域处理！&lt;/p&gt;
&lt;p&gt;1、后台PHP进行设置，在后台请求的PHP文件中，写入一条header:&lt;/p&gt;
&lt;p&gt;header( &quot;Access-Control-Allow-Origin:*&quot;);&lt;/p&gt;
&lt;p&gt;表示允许哪些域名请求这个PHP文件，*表示所有的域名都允许。&lt;/p&gt;
&lt;p&gt;2、使用src属性+JSONP实现跨域&lt;/p&gt;
&lt;p&gt;① 拥有src属性的标签自带跨域功能，所以可以使用&amp;lt;script&amp;gt;标签的src属性请求后台属性。&lt;/p&gt;
&lt;p&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://127.0.0.1/json.php&quot;&amp;gt; &amp;lt;/ script&amp;gt;&lt;/p&gt;
&lt;p&gt;② 由于src在加载数据成功之后，会直接将加载内容放入到script标签中，&lt;/p&gt;
&lt;p&gt;所以后台直接返回JSON字符串将不能在script标签中解析。&lt;/p&gt;
&lt;p&gt;因此，后台应该返回给前台一个回调函数名，并将JSON字符串作为参数传入，&lt;/p&gt;
&lt;p&gt;后台PHP文件中返回 ： echo &quot;callBack($str)&quot;;&lt;/p&gt;
&lt;p&gt;③ 前台接收到返回的回调函数，将直接在script标签中调用。因此需要声明这样的一个回调函数，作为请求成功的回调函数。&lt;/p&gt;
&lt;p&gt;* function callBack(data) {&lt;/p&gt;
&lt;p&gt;alert(&quot;请求成功！&quot;);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;3、jQuery的Ajax实现JSONP&lt;/p&gt;
&lt;p&gt;① 在Ajax请求时设置dataType:&quot;jsonp&quot;&lt;/p&gt;
&lt;p&gt;② 后台返回时，依然需要返回回调函数，但是，在ajax发送请求时，会默认使用get请求将回调函数名发给后台，&lt;/p&gt;
&lt;p&gt;后台可以使用$_GET['callback']取出回到函数名。&lt;/p&gt;
&lt;p&gt;echo &quot;{$_GET['callback']}({$str})&quot;;&lt;/p&gt;
&lt;p&gt;③ 后台返回之后，Ajax依然可以使用succes作为成功的回调函数：&lt;/p&gt;
&lt;p&gt;success:function(data){&lt;/p&gt;
&lt;p&gt;console.log(data);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;当然后台也可以随便返回一个回调函数名： echo &quot;callBack($json)&quot;;&lt;/p&gt;
&lt;p&gt;前台只要请求成功就会自动调用这个函数。类似于上面的第2条的② ③ 步；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;139、js中捕获异常是啥？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;Js中的异常捕获用&lt;span&gt;try{}catch(){} &lt;span&gt;结构进行捕获&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将程序中可能出现异常错误的代码，用&lt;span&gt;try块包裹&lt;span&gt;，当代码真正出现异常时，程序流将进入&lt;span&gt;carch块捕获异常&lt;span&gt;，&lt;span&gt;try块中从异常语句开始下面的代码将不再执行&lt;span&gt;，转而执行&lt;span&gt;catch&lt;span&gt;块中的代码！！！！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JS&lt;span&gt;中常见的异常类型： &lt;span&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
EvalError: raised when an error occurs executing code &lt;span&gt;in&lt;/span&gt;&lt;span&gt; eval()
RangeError: raised when a numeric variable or parameter is outside of its valid range
ReferenceError: raised when de&lt;/span&gt;-&lt;span&gt;referencing an invalid reference
SyntaxError: raised when a syntax error occurs &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; parsing code &lt;span&gt;in&lt;/span&gt;&lt;span&gt; eval()
TypeError: raised when a variable or parameter is not a valid type
URIError: raised when encodeURI() or decodeURI() are passed invalid parameters   &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  &lt;span&gt;所有异常都继承自Error&lt;span&gt;类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户可以自定义异常： &lt;span&gt;throw new Error() ;  &lt;span&gt; throw new TypeError(&lt;span&gt;“错误信息”&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Catch&lt;span&gt;块的小括号中可以接受异常对象&lt;span&gt;e, e.name&lt;span&gt;表示错误名，e.message&lt;span&gt;表示错误信息。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;140、事件委派的原理是啥？事件冒泡吗？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;事件委派的原理就是事件冒泡！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当你点击一个元素时，这个点击事件是会冒泡的，事件依次从该元素向父级元素依次触发，事件委托就是在&lt;span&gt;父级元素上统一监听和处理事件，&lt;span&gt;而不是在具体的元素上，然后通过判断事件源来确定是哪个元素触发的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样做的好处是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们不需要为每个元素添加事件，更节省资源；并且后来新增的元素直接可以同样获得事件，不需要再为其添加监听。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;141、前端代码优化的方法？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;








&lt;hr/&gt;&lt;p&gt;&lt;span&gt;142、详细解释一下关于伪数组与数组？（在Javascript中什么是伪数组？如何将伪数组转化为标准数组？）&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;伪数组：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具有&lt;span&gt;length属性；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;按索引方式存储数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不具有数组的&lt;span&gt;push()、pop()等方法；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;var fakeArray01 = {0:'a',1:'b',length:2};//这是一个标准的伪数组对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;var arr01 = Array.prototype.slice.call(fakeArray01);&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;143、Javascript作用域链?&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;函数作用域的嵌套就组成了所谓的函数作用域链&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;144、什么是JSOPN？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;jsonp：JSON with padding，是JSON的 一种“&lt;span&gt;使用模式”，可用于解决主流浏览器的跨域数据访问的问题。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;145、如何利用Ajxa实现跨域请求？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;由于JS中存在同源策略，当请求不同协议名，不同端口号，不同主机名下面的文件时，将会违背同源策略，无法请求成功！需要进行跨域处理！&lt;/p&gt;
&lt;p&gt;1、后台PHP进行设置，在后台请求的PHP文件中，写入一条header:&lt;/p&gt;
&lt;p&gt;header( &quot;Access-Control-Allow-Origin:*&quot;);&lt;/p&gt;
&lt;p&gt;表示允许哪些域名请求这个PHP文件，*表示所有的域名都允许。&lt;/p&gt;
&lt;p&gt;2、使用src属性+JSONP实现跨域&lt;/p&gt;
&lt;p&gt;① 拥有src属性的标签自带跨域功能，所以可以使用&amp;lt;script&amp;gt;标签的src属性请求后台属性。&lt;/p&gt;
&lt;p&gt;* &amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://127.0.0.1/json.php&quot;&amp;gt; &amp;lt;/ script&amp;gt;&lt;/p&gt;
&lt;p&gt;② 由于src在加载数据成功之后，会直接将加载内容放入到script标签中，&lt;/p&gt;
&lt;p&gt;* 所以后台直接返回JSON字符串将不能在script标签中解析。&lt;/p&gt;
&lt;p&gt;* 因此，后台应该返回给前台一个回调函数名，并将JSON字符串作为参数传入，&lt;/p&gt;
&lt;p&gt;后台PHP文件中返回 ： echo &quot;callBack($str)&quot;;&lt;/p&gt;
&lt;p&gt;③ 前台接收到返回的回调函数，将直接在script标签中调用。因此需要声明这样的一个回调函数，作为请求成功的回调函数。&lt;/p&gt;
&lt;p&gt;* function callBack(data) {&lt;/p&gt;
&lt;p&gt;alert(&quot;请求成功！&quot;);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;3、利用jQuery的Ajax实现JSONP&lt;/p&gt;
&lt;p&gt;① 在Ajax请求时设置dataType:&quot;jsonp&quot;&lt;/p&gt;
&lt;p&gt;② 后台返回时，依然需要返回回调函数，但是，在ajax发送请求时，会默认使用get请求将回调函数名发给后台，&lt;/p&gt;
&lt;p&gt;后台可以使用$_GET['callback']取出回到函数名。&lt;/p&gt;
&lt;p&gt;echo &quot;{$_GET['callback']}({$str})&quot;;&lt;/p&gt;
&lt;p&gt;③ 后台返回之后，Ajax依然可以使用succes作为成功的回调函数：&lt;/p&gt;
&lt;p&gt;success:function(data){&lt;/p&gt;
&lt;p&gt;console.log(data);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;当然后台也可以随便返回一个回调函数名： echo &quot;callBack($json)&quot;;&lt;/p&gt;
&lt;p&gt;前台只要请求成功就会自动调用这个函数。类似于上面的第2条的② ③ 步；&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;span&gt;146、 JavaScript window.onload 事件和 jQuery ready 函数有何不同？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;1.执行时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;    window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。&lt;/p&gt;
&lt;p&gt;    $(document).ready()是DOM结构绘制完毕后就执行，不必等到加载完毕。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.编写个数不同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     window.onload不能同时编写多个，如果有多个window.onload方法，只会执行一个&lt;/p&gt;
&lt;p&gt;     $(document).ready()可以同时编写多个，并且都可以得到执行&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.简化写法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;     window.onload没有简化写法&lt;/p&gt;
&lt;p&gt;     $(document).ready(function(){})可以简写成$(function(){});&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;147、$(this) 和 this 关键字在 jQuery 中有何不同?&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、this表示javascript的&lt;span&gt;dom对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、$(this)表示把&lt;span&gt;dom对象转换为jquery对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3、jquery包的方法只能由jquery对象调用，不能用javascript的&lt;span&gt;Dom对象使用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;$(&quot;input&quot;).click(function(){&lt;/p&gt;
&lt;p&gt;//这里的this表示被点击的输入框对象,可以使用javascript对该对象进行操作&lt;/p&gt;
&lt;p&gt;var value=this.value;&lt;/p&gt;
&lt;p&gt;//jquery对象与&lt;span&gt;dom对象取值方法不一样，要用jquery方法必须使用$(dom对象)转换&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;var val=$(this).val();&lt;/p&gt;
&lt;p&gt;）}&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;148、简单介绍下JavaScript中的作用域与变量声明提升？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1、一个变量的作用域表示这个变量存在的上下文。一个变量的作用域表示这个变量存在的上下文。javascript有拥有函数级别的作用域，也就是说，在一个函数内定义的变量只能在函数内部访问或者这个函数内部的函数访问（闭包除外）每一个在函数外部声明或者定义的变量都是一个全局对象，所以这个变量可以在任何地方被使用。&lt;/p&gt;
&lt;p&gt;2、变量声明提升就是在函数内部不用var 声明的一个变量，想要访问的时候，会在当前函数中寻找，发现当前函数中没有，继续往上层函数找，一直到全局作用下还没有找到，就会将这个变量在全局范围内进行声明。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;149、jquery.extend 与 jquery.fn.extend的区别？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;jQuery为开发插件提拱了两个方法，分别是：&lt;/p&gt;
&lt;p&gt;jQuery.fn.extend();&lt;/p&gt;
&lt;p&gt;jQuery.extend();&lt;/p&gt;
&lt;p&gt;&lt;span&gt;jquery.extend&lt;span&gt;：用于声明全局插件&lt;span&gt;/方法。&lt;span&gt;声明插件&lt;span&gt;/方法使用$.func();直接调用&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;query.fn.extend&lt;span&gt;：用于声明局部插件&lt;span&gt;/方法。&lt;span&gt;声明插件&lt;span&gt;/方法使用$(“选择器”).func();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;150、常见的浏览器内核有哪些？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;1，使用Trident的是internet explorer，国产的绝大部分浏览器。Trident是就是&lt;span&gt;ie内核&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2，使用Gecko的是Mozilla Firefox，使用 Gecko 内核的浏览器也有不少，如 Netscape MozillaSuite/SeaMonkey 等&lt;/p&gt;
&lt;p&gt;3，使用Presto的是opera，这是目前公认网页浏览速度最快的&lt;span&gt;浏览器内核&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4，使用WebKit的有&lt;span&gt;苹果的safari，&lt;span&gt;谷歌的chrome，还有国产的大部分双核浏览器其中一核就是WebKit&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;151、margin和padding分别适合什么场景使用？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。 margin用于布局分开元素使元素与元素互不相干； padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;152、::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）&lt;/p&gt;
&lt;p&gt;双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，&lt;/p&gt;
&lt;p&gt;比如:first-line、:first-letter、:before、:after等，&lt;/p&gt;
&lt;p&gt;而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。 想让插入的内容出现在其它内容前，使用::before，否者，使用::after；&lt;/p&gt;
&lt;p&gt;在代码顺序上，::after生成的内容也比::before生成的内容靠后。&lt;/p&gt;
&lt;p&gt;如果按堆栈视角，::after生成的内容会在::before生成的内容之上&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;153、 li与li之间（display:inline-block）有看不见的空白间隔是什么原因引起的？有什么解决办法？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;浏览器的默认行为是把inline元素间的空白字符（空格换行tab）渲染成一个空格，&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;154、解释一下JavaScript中的this指针、闭包、作用域？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;This指向&lt;span&gt;：&lt;span&gt;JS函数中的this&lt;span&gt;，永远指向&lt;span&gt;函数调用语句所在的对象&lt;span&gt;(谁调用函数，this指向谁)。&lt;span&gt;(2分)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闭包： &lt;span&gt;&lt;span&gt;在函数中，写一个子函数。内层函数可以访问外层函数中的变量。&lt;span&gt;(2分)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作用域： &lt;span&gt;&lt;span&gt;变量生效的范围称为作用域。&lt;span&gt;JS中只有全局作用域和函数作用域。&lt;span&gt;(2分)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;155、使用jQuery操作元素的属性attr()方法和val()有什么区别?&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;Attr():用于读取或者设置元素的属性&lt;span&gt;；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Val(): 用于读取或者设置表单元素的value；&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;156、JavaScript怎样创建节点、删除节点、替换节点、复制节点？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;创建节点： &lt;span&gt;.creatElement();&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;删除节点： &lt;span&gt;.removeChild();&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;替换节点： &lt;span&gt;.replaceChild();&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;复制节点： &lt;span&gt;.cloneNode(true/false);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;157、CSS中的link和@import有什么区别？常用哪种？&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;① link属于标准的HTML标签，而@import不是标准标签；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;② link可以兼容所有低版本浏览器，而@import只在CSS2之后能用；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③ link是将两个文件链接起来，起桥梁作用； 而@import相当于将CSS文件复制到HTML文件中；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④ link会在HTML文件边加载的过程中，边链接CSS文件；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;@import会在HTML文件全部加载完以后，再导入CSS文件；&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 10 Nov 2017 10:51:00 +0000</pubDate>
<dc:creator>卡尔西法calcifer</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wq1994/p/7816020.html</dc:identifier>
</item>
<item>
<title>服务器 : Apache Tomcat - 理解架构层次 - Rudolph_Browne</title>
<link>http://www.cnblogs.com/CARPE-DIEM-wu/p/7709545.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CARPE-DIEM-wu/p/7709545.html</guid>
<description>&lt;h3&gt; 文章概览&lt;/h3&gt;
&lt;p&gt;　　相信很多接触java的人都对Tom猫有着多少的熟悉,就个人而言,本来只知道Tom简单的操作与配置,就像裹上一层纱,迷迷糊糊的.&lt;/p&gt;
&lt;p&gt;　　Tomcat的书籍本来就不多,高分的还是很久之前的版本,直到最近看到下面这本书,解答了我的很多疑问,同时这篇文章将总结读书收获.&lt;/p&gt;
&lt;p&gt;　　如果觉得文章写的内容是你感兴趣的或者我的猫使你感兴趣,建议你读读这本书.&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171101110431716-405618801.png&quot; alt=&quot;&quot; width=&quot;229&quot; height=&quot;307&quot;/&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171101112642779-536230757.png&quot; alt=&quot;&quot; width=&quot;403&quot; height=&quot;303&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　该文会介绍Tom的架构,服务器如何从一层层抽象设计到完整的架构&lt;/p&gt;
&lt;h3&gt;Tomcat介绍&lt;/h3&gt;
&lt;p&gt;　　Tom是一款全世界著名的轻量级应用服务器,基于java,服务于java.主要作为应用服务器来处理客户端发来的动态资源响应. &lt;/p&gt;
&lt;p&gt;　　目前版本是9.x,很多人都在使用6.x,但新版其实提供了很多新的功能,比如WebSocket的支持,点击了解&lt;a href=&quot;WebSocket%20%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5%EF%BC%9F%20-%20Ovear%E7%9A%84%E5%9B%9E%E7%AD%94%20-%20%E7%9F%A5%E4%B9%8E%20https://www.zhihu.com/question/20215561/answer/40316953&quot; target=&quot;_blank&quot;&gt;WebSocket&lt;/a&gt;. &lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171101114455138-1819646546.png&quot; alt=&quot;&quot; width=&quot;470&quot; height=&quot;263&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Tomcat启动参数&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　windows修改$CATALINA_HOME/bin/catalina.bat文件&lt;/p&gt;
&lt;p&gt;　　　　Set JAVA_OPTS=-server -Xms1024m -Xmx2048m -XX:PermSize=256m -XX:MaxPermSize=512m&lt;/p&gt;
&lt;p&gt;　　　　linux修改$CATALINA_HOME/bin/catalina.sh文件&lt;/p&gt;
&lt;p&gt;　　　　JAVA_OPTS=&quot;-server -Xms1024m -Xmx2048m -XX:PermSize=256m -XX:MaxPermSize=512m&quot;&lt;/p&gt;
&lt;p&gt;　　　　-server　　Server端启动Tomcat,Client启动Tomcat两者的初始化参数会有所不同&lt;/p&gt;
&lt;p&gt;　　　　-Xms1024m 初始化堆内存大小&lt;/p&gt;
&lt;p&gt;　　　　-Xmx2048m 允许的最大堆内存大小&lt;/p&gt;
&lt;p&gt;　　　　-XX:PermSize=256m 初始化非堆内存大小&lt;/p&gt;
&lt;p&gt;　　　　-XX:MaxPermSize=512m 允许的最大非堆内存大小&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;Debug方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　依赖于JDK提供的JPDA(Java Platform Debugger Architecture,Java平台调试体系)&lt;/p&gt;
&lt;p&gt;　　　　catalina jpda start&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;目录结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171101181818201-17793876.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;86&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　该文使用的版本是apache-tomcat-9.0.1,目录大致都很容易理解.&lt;/p&gt;
&lt;p&gt;　　　　conf放置的Tomcat的核心配置文件,下文会介绍.&lt;/p&gt;
&lt;p&gt;　　　　webapps是默认的web app的应用目录,只要把项目目录放置进去就可以运行&lt;/p&gt;
&lt;p&gt;　　　　work是Tomcat运行时产生的jsp编译文件所存放的位置&lt;/p&gt;
&lt;h3&gt; 总体架构&lt;/h3&gt;
&lt;p&gt;　　Tomcat是一款应用服务器,我们从最根本的类一层一层演变,直至Tomcat当前版本.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;/span&gt;应用服务器是&lt;span&gt;接收&lt;/span&gt;其他计算机(客户端)发来的&lt;span&gt;请求&lt;/span&gt;数据并对其解析,完成相关业务处理,然后把&lt;span&gt;处理&lt;/span&gt;结果作为&lt;span&gt;响应返回&lt;/span&gt;给计算机.&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171102143006279-1167260582.png&quot; alt=&quot;&quot; width=&quot;590&quot; height=&quot;232&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;/span&gt;一个问题摆在眼前,前面Server请求监听和请求处理放在一起,应用服务器通常会与web服务器进行集群部署和负载均衡,但是这两者的协议并不是HTTP.&lt;/p&gt;
&lt;p&gt;也就是说,&lt;span&gt;服务器连接的另一端需要适配不同的协议来对请求作出不同的处理.&lt;/span&gt;前面的模型扩展性太差,应该分离请求监听和请求处理.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Connector模块管理请求监听,Container模块负责请求处理,&lt;span&gt;两个组件都拥有start()和stop()来加载和释放自己维护的资源&lt;/span&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样子,Server下可以有多个Connector来传送请求至不同的Container中.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171102145759873-1935955560.png&quot; alt=&quot;&quot; width=&quot;555&quot; height=&quot;310&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;/span&gt;上面的设计有个缺陷,既然server可以有多个Connector和Container,那么如何知道哪个Connector将请求发至哪个Container呢?&lt;/p&gt;
&lt;p&gt;考虑一下下面这个设计图,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171102152908466-869114614.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.&lt;/strong&gt;&lt;/span&gt;我们接触过的Tomcat应该是放置web app的容器,在哪放置web app?这将决定哪个app来处理Engine所获取的请求信息.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171102153825216-1105101662.png&quot; alt=&quot;&quot; width=&quot;290&quot; height=&quot;138&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  再想一下,我们浏览器是个app,对吧?然后服务器其实也是app对吧?网络就是两者的通信.我们来看一下网络是怎么进行通信的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171102160952513-1131433490.png&quot; alt=&quot;&quot; width=&quot;633&quot; height=&quot;369&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没错,web app需要端点信息(IP地址,端口号),我们需要提供这一层的抽象.&lt;span&gt;一个Host下可以对应有多个app(Context).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171102161432623-2096080189.png&quot; alt=&quot;&quot; width=&quot;552&quot; height=&quot;369&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.&lt;/strong&gt;&lt;/span&gt;现在设计已经可以满足两个应用的连接了,现在设想一下,应用该怎么进行表示?毕竟Tomcat作为一款Servlet容器而存在.首先Apache组织按照Servlet官方的标准,加入了Servlet的包装类Wrapper.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171102162139716-791879221.png&quot; alt=&quot;&quot; width=&quot;331&quot; height=&quot;95&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6.&lt;/span&gt;&lt;/strong&gt;就目前为止,我们使用&quot;&lt;span&gt;容器&lt;/span&gt;&quot;这一概念来形容&lt;span&gt;处理接收客户端的请求并且返回响应数据的组件&lt;/span&gt;,依此,使用一个类Container来统一表示这一想法,让Engine,Host,Context,Wrapper这类组件来继承Container.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171103093246591-2080032771.png&quot; alt=&quot;&quot; width=&quot;591&quot; height=&quot;492&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Container类能够添加子组件addChild方法,有时需要执行一些异步处理,所以加入backgroundProcess方法.&lt;/p&gt;
&lt;p&gt;由于Engine,Host,Context,Wrapper这类的引用变成了父类Container,所以之前的&lt;span&gt;强组合关系变成了弱组合关系&lt;/span&gt;.强弱关系指的是两个类直接关联或者是间接关联.&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;7.&lt;/span&gt;&lt;/strong&gt;为了从抽象和复用层面上再审视一下当前设计,使概念更加清晰,提供通用性定义.&lt;span&gt;由于所有容器都有着自身的生命周期管理方法,那么我们可以将其进行抽象成一个接口Lifecycle,在方法定义上加入初始化方法init,销毁方法destroy,事件监听方法addLifecycleListener和removeLifecycleListener.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171103100339763-129008876.png&quot; alt=&quot;&quot; width=&quot;609&quot; height=&quot;660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;8.&lt;/span&gt;&lt;/strong&gt;上面这个设计Container部分具有伸缩性和扩展性,这很棒.接下来Tomcat的开发人员为了提高每个组件的灵活性,使其更易扩展,加入了Pipeline和Valve这两个接口.这两个接口的设计运用了职责链模式.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171103103421998-373302533.png&quot; alt=&quot;&quot; width=&quot;455&quot; height=&quot;246&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单介绍以下职责链模式,关于设计模式可以查看博客里的文章&lt;a href=&quot;http://www.cnblogs.com/CARPE-DIEM-wu/p/7624014.html&quot; target=&quot;_blank&quot;&gt;《软件设计 : 聚焦设计模式》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;职责链模式使用一个抽象类来统一定义处理器,然后将处理器构造成一条链,当Client端发来请求时,第一个Handler判断是否处理,不处理则往下个Handler传递,直至被处理或则处理链结束.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171103104007232-315998161.png&quot; alt=&quot;&quot; width=&quot;629&quot; height=&quot;140&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171103104213373-317953730.png&quot; alt=&quot;&quot; width=&quot;655&quot; height=&quot;317&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回头看Tomcat怎么运用这个设计模式,&lt;span&gt;Pipeline接口用于构建职责链,Valve接口代表职责链上的每个处理器.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Pipeline中维护一个基础的Valve,它始终位于Pipeline执行链的末端,封装了具体的请求处理和输出响应过程.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171103110236888-1279941456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就可以构造一条职责链,可是为什么要这么做?记得之前Container不就是可以自包含的容器吗?为什么要弄出多两个接口?&lt;/p&gt;
&lt;p&gt;的确,Container可以自包含,但是它是作为容器抽象类而存在,&lt;strong&gt;&lt;span&gt;而阀(Valve)作为接口而存在,我们可以在实现这个接口的类中添加属于我们自己的Valve实现类,&lt;/span&gt;&lt;/strong&gt;你想做什么都行.&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;就像水管一样,你如果是超级马里奥,你可以随时给它加个阀,做任何事.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171103105439888-1361808673.png&quot; alt=&quot;&quot; width=&quot;585&quot; height=&quot;271&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171103111331795-331548186.png&quot; alt=&quot;&quot; width=&quot;624&quot; height=&quot;443&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;9.&lt;/strong&gt;&lt;/span&gt;前面的设计基本落在Container部分,来看看Connector的设计方案,Connector必须完成下面的功能项.&lt;/p&gt;
&lt;p&gt;　　①监听服务器端口,读取客户端的请求&lt;/p&gt;
&lt;p&gt;　　②将请求数据按指定协议进行解析&lt;/p&gt;
&lt;p&gt;　　③根据请求地址匹配正确的容器进行处理&lt;/p&gt;
&lt;p&gt;　　④将请求返回客户端&lt;/p&gt;
&lt;p&gt;Tomcat支持多协议(HTTP/AJP)和多种IO方式(BIO,NIO,NIO2,APR,HTTP/2)&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171105122629951-857004236.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ProtocolHandler表示协议处理器,针对不同的协议和IO方式,提供不同的实现,ProtocolHandler包含一个Endpoint用来启动socket监听,该接口按照IO方式进行分类实现,还包含一个Process用于按照指定协议读取数据,并交由容器处理.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;处理逻辑如下:&lt;/p&gt;
&lt;p&gt;1.在Connector启动时,Endpoint会启动线程来监听服务器端口,并在接收到请求后调用Process进行数据读取.&lt;/p&gt;
&lt;p&gt;2.当Process读取客户端请求之后,需要按照地址映射到具体的容器进行处理,即请求映射.&lt;/p&gt;
&lt;p&gt;3.由于Tomcat各个组件采用通用的生命周期进行管理,而且通过管理工具进行状态变更,因此请求映射除了考虑映射规则的实现外,还要考虑容器组件的注册和销毁.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171105143835295-669692606.png&quot; alt=&quot;&quot; width=&quot;659&quot; height=&quot;421&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Tomcat采用Mapper来维护容器映射信息,按照映射规则(Servlet规范定义)查找容器;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MapperListener实现LifecycleListener和ContainerListener,用于在容器组件状态变更时,注册或者取消对应的容器映射信息;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;MapperListener实现了Lifecycle接口,当Service启动时,会自动作为监听器注册到各个容器组件之上,同时将已创建的容器注册到Mapper;&lt;/p&gt;
&lt;p&gt;Tomcat通过适配器模式实现了Connector与Mapper,Container的解耦,默认实现为CoyotoAdapter;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;10.&lt;/strong&gt;&lt;/span&gt;到这里,服务器可以正常接入请求和完成响应,可是我们还没考虑到一个关键的问题——并发&lt;/p&gt;
&lt;p&gt;Tomcat使用组件式的设计理念,那么也会有并发组件.&lt;/p&gt;
&lt;p&gt;Tomcat组织为此&lt;span&gt;提供了一个Executor接口表示一个可以在组件间共享的线程池&lt;/span&gt;,该接口同样继承自Lifecycle接口,按照通用组件进行管理.&lt;/p&gt;
&lt;p&gt;Executor由Service进行维护,因此同一个Service中的组件共享一个线程池.值得注意的是如果没有定义线程池,相关组件会自动创建线程池,此时线程池不再共享.&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;在Tomcat中,Endpoint会启动一组线程来监听Socket端口,当接收到客户请求会创建请求处理对象,并交由线程池处理,由此支持并发处理客户端请求.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171105151228638-1423040040.png&quot; alt=&quot;&quot; width=&quot;684&quot; height=&quot;438&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;11.&lt;/strong&gt;&lt;/span&gt;现在Tomcat基础的核心组件已经完整了,但是架构其实还有很多组件没有显示出来.Tomcat开发人员为了让使用者很好地使用Tomcat,提供了&lt;span&gt;一套配置环境来支持系统的可配置性——Catalina&lt;/span&gt;.&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;Catalina代表了整个Servlet容器架构,包含了上面所有组件,还有还没谈及的安全,会话,集群,部署,管理等Servlet容器组件.它通过松耦合的方式集成了Coyoto,以完成按照请求协议进行数据读写.同时,还包括启动入口、Shell程序等.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bootstrap是Catalina的启动入口.&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;为什么Tomcat不通过Catalina启动,而又提供了Bootstrap?&lt;/p&gt;
&lt;p&gt;查看一下Tomcat发布包目录,Bootstrap并不存放于Catalina的lib目录下,而是置于bin目录中.&lt;span&gt;&lt;strong&gt;Bootstrap通过反射调用Catalina实例,与Tomcat服务器完全松耦合,它可以直接依赖JRE运行并为Tomcat应用服务器创建共享类加载器,用于构建Catalina实例以及整个Tomcat服务器.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171105154154560-1040028761.png&quot; alt=&quot;&quot; width=&quot;701&quot; height=&quot;451&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此,Tomcat的基础核心组件介绍结束,我们回顾一下组件的概念&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/span&gt;　　 表示整个Servlet容器,一个Tomcat运行环境只存在一个Server,可存在多个Service.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Service&lt;/span&gt;&lt;/strong&gt;　   表示链接器和处理器的集合,同一个Service下的链接器将请求传至该Service下的处理器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Connector&lt;/span&gt;&lt;/strong&gt; 表示链接器,用于监听并转化Socket请求,支持不同协议与IO方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Container&lt;/span&gt;&lt;/strong&gt;  表示容器组件,能执行客户端请求并返回响应的组件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Engine&lt;/span&gt;&lt;/strong&gt;　   表示顶级容器,是获取目标容器的入口&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Host&lt;/span&gt;&lt;/strong&gt;　　　表示Servlet引擎中的虚拟机,提供Host之类的域名信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Context&lt;/span&gt;&lt;/strong&gt;　 表示一个web app应用上下文环境&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Wrapper&lt;/span&gt;&lt;/strong&gt;　具体的Servlet包装类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Executor   &lt;/span&gt;&lt;/strong&gt;组件间共享的线程池&lt;/p&gt;
&lt;h3&gt;Tomcat启动与请求响应&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171105160049857-1157037456.png&quot; alt=&quot;&quot; width=&quot;681&quot; height=&quot;375&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171105160218748-498514621.png&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;476&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;Tomcat类加载器&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;应用服务器通常会自行创建类加载器以实现更加灵活的控制,这是对规范的实现(Servlet规范要求每个Web应用都有独立的类加载器实例),也是架构层面的考虑.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;书中p46对类加载器进行了详细说明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JVM默认提供了三个类加载器来进行类加载,Tomcat在加载器上进行扩展,用来加载应用自身的类.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/818555/201711/818555-20171110173234200-1514864636.png&quot; alt=&quot;&quot; width=&quot;559&quot; height=&quot;362&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Bootstrap&lt;/span&gt;&lt;/strong&gt;　　JVM提供,加载JVM运行的基础运行类,即位于%JAVA_HOME%/jre/lib目录下的核心类库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Extension&lt;/span&gt;&lt;/strong&gt;　   JVM提供,加载%JAVA_HOME%/jre/lib/ext目录下的扩展类库&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;System　&lt;/span&gt;&lt;/strong&gt;　    JVM提供,加载CLASSPATH指定目录下或者-classpath运行参数指定的jar包&lt;/p&gt;
&lt;p&gt;　　　　　　   Tomcat的Bootstrap类即由这个加载器载入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Common&lt;/span&gt;&lt;/strong&gt;　　 以System为父类加载器,是Tomcat应用服务器顶层的公用类加载器,&lt;/p&gt;
&lt;p&gt;　　　　　　   其路径common.loader,默认指向$Catalina_Home/lib目录.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Catalina&lt;/span&gt;&lt;/strong&gt;　　   用于加载Tomcat应用服务器的类加载器,路径为server.loader,&lt;/p&gt;
&lt;p&gt;　　　　　  　 默认为空,此时Tomcat使用Common类加载器加载应用服务器.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Shared&lt;/span&gt;&lt;/strong&gt;　　 　所有Web应用的类加载器,路径为shared.loader,默认为空.&lt;/p&gt;
&lt;p&gt;　　　　　  　 此时使用Common类加载器作为Web应用的父加载器.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Web App&lt;/span&gt;&lt;/strong&gt;　 　加载WEB-INF/classes目录下未压缩的Class和资源文件以及/WEB-INF/lib目录下的jar包.&lt;/p&gt;
&lt;p&gt;　　　　　　  该类加载器对当前web应用可见,对其他web应用不可见. &lt;/p&gt;





</description>
<pubDate>Fri, 10 Nov 2017 10:29:00 +0000</pubDate>
<dc:creator>Rudolph_Browne</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CARPE-DIEM-wu/p/7709545.html</dc:identifier>
</item>
<item>
<title>一款超好用轻量级JS框架——Zepto.js(下) - Realsdg</title>
<link>http://www.cnblogs.com/realsdg/p/7815922.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/realsdg/p/7815922.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   前   言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;絮叨絮叨&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　前面和大家分享了Zepto的原型方法，相信大家也对这个框架有了一定的了解，那么今天再和大家分享一下它的对象方法吧！&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;1&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;add()&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 支持一到二个参数,第一个为选择器,与$()的差不多,甚至是,第一个参数传进去一个function,它也会正确执行(但是出现什么bug的话，后果自负哟~~),所以说,正确的使用方式是传入选择器,dom对象,或者一段html,这都是可以的,如果有多个的话,那就用用数组括起来,&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
var temp = $([&quot;li&quot;,&quot;span&quot;,&quot;div&quot;]).add([&quot;p&quot;, &quot;p&quot;]).size(); // --&amp;gt; size为4,因为会对返回的集合进行去重处理
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 第二个参数是匹配的上下文,默认不传就按着document来：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1207874/201711/1207874-20171110170255169-870803409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1207874/201711/1207874-20171110170638013-136451387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;add函数本身无任何亮点- -,将两个参数原封不动的传入$()然后返回一个Zepto对象,执行concat函数,该函数会将所有参数添加至调用函数对象的末尾,&lt;/p&gt;
&lt;p&gt;toArray方法会调用get方法,当get方法执行时而没有传入参数,会将该对象所有的匹配元素以数组的形式返回;&lt;/p&gt;
&lt;p&gt;uniq方法是一个数组去重的方法,返回的还是一个数组,然后回到add方法再次通过$()构造一个zepto对象并返回;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;2&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;addClass()&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 该方法接收一个参数,可以直接传入一个字符串作为类名,如有多个,使用空格分开.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;p&quot;).addClass(&quot;content title&quot;); // --&amp;gt; content title
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 还有一种调用方式是传入一个函数,函数可以接收到两个参数,第一个是当前循环到的下标,第二个是当前对象之前的className.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$('p1', 'p2', 'p3').addClass(function (index, oldClass) {
    return 'dynamic' + index;
});
// p1 --&amp;gt; dynamic0
// p2 --&amp;gt; dynamic1
// p3 --&amp;gt; dynamic2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数必须返回一个字符串,否则会运行异常&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1207874/201711/1207874-20171110172358669-1264954746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过each方法循环遍历对象,each方法会返回一个zepto对象.首先会判断元素是否存在className属性,&lt;/p&gt;
&lt;p&gt;通过className方法获取到当前元素的所有className信息的字符串;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;3&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;removeClass()&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; removeClass函数只有一个可选的参数,可以为一个字符串(要移除的className),或者是一个function,用法同addClass,函数也必须要返回一个字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
$('&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;test test2 test3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;').removeClass(&quot;test test3&quot;);
// --&amp;gt; &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;test2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
/*
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;list item 1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;list item 2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;list item 3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
*/
$('li').addClass(&quot;test&quot;);
$('li').removeClass(function (index, oldClass) {
    return index % 2 === 0 ? &quot;test&quot; : &quot;&quot;;
})
// --&amp;gt; [li, li.test, li]
//或者可以不填参数,直接调用,直接调用会清除对象的所有className
$('&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;test test2 test3&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;').removeClass();
// --&amp;gt; &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;removeClass相对于addClass简单点;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1207874/201711/1207874-20171110172740825-127428847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大体相同,唯有在forEach循环中,addClass是给集合push值,而removeClass是从一个字符串中replace掉值;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;4&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;toggleClass()&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 方法使用与前两个类似,只不过多了第二个参数,第二个参数为true时,执行addClass,第二个参数为false时,执行removeClass&lt;/p&gt;
&lt;p&gt;这个用处好像不是太大、、、&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1207874/201711/1207874-20171110173422153-1430275486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接上代码吧，第二个参数没有传的话，就是有了删，没了填,如果第二个参数有值,则不执行hasClass方法,直接通过when变量的值来决定使用什么方法.&lt;/p&gt;

&lt;p&gt;↓↓↓↓↓下面再来说一些Zepto的DOM操作方法↓↓↓↓↓&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;5&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;prepend()&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 将参数插入对象内部的头部;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;div1&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;width: 200px; height: 200px; background-color: red;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这是div1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;.div1&quot;).prepend(&quot;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这是被插入的p标签&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1207874/201711/1207874-20171110174624903-1037317137.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;6&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;append()和appendTo()&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 将参数插入对象内部的尾部;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;div1&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;width: 200px; height: 200px; background-color: red;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这是div1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;.div1&quot;).append(&quot;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这是插入的p标签&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1207874/201711/1207874-20171110175151841-989475700.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
$(&quot;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;&quot;, { text:&quot;Hello&quot;, id:&quot;greeting&quot;, css:{color:'darkblue'} }).appendTo(&quot;.div1&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1207874/201711/1207874-20171110175229200-1293292548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;7&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;after和before&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 将对象插入到元素的后边或前边&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;div1&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;width: 200px; height: 200px; background-color: red;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这是div1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;.div1&quot;).after(&quot;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这是被插入的p标签&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1207874/201711/1207874-20171110175609794-522589381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这是被插入的p标签&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&quot;).insertBefore(&quot;.div1&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1207874/201711/1207874-20171110175750513-697524705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;autonum&quot; title=&quot;&quot; data-original-title=&quot;&quot;&gt;8&lt;/span&gt;&lt;span&gt;&lt;strong class=&quot;135brush&quot; data-brushtype=&quot;text&quot;&gt;wrap和wrapAll&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; 在元素外面包裹一层div&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这是一个p标签1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这是一个p标签2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;这是一个p标签3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;p&quot;).wrap(&quot;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;='width: &lt;/span&gt;&lt;span&gt;100px; height: 100px; background-color: blue;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;img src=&quot;http://images2017.cnblogs.com/blog/1207874/201711/1207874-20171110180147466-262857953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$(&quot;p&quot;).wrapAll(&quot;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;='width: &lt;/span&gt;&lt;span&gt;300px; height: 300px; background-color: blue;'&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1207874/201711/1207874-20171110180229153-443270775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;再叨叨点其他的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 前面我们就说了Zepto和JQuery其实差不多，所以就只是粗略的分享一下，更加深入的东西就不在分享了，如果大家会JQuery的话，那么Zepto真的就是拿来就会用的东西。&lt;/p&gt;
&lt;p&gt;所以Zepto的相关使用操作就到这儿啦啦啦啦啦啦啦~~~~~~&lt;/p&gt;

</description>
<pubDate>Fri, 10 Nov 2017 10:18:00 +0000</pubDate>
<dc:creator>Realsdg</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/realsdg/p/7815922.html</dc:identifier>
</item>
<item>
<title>Golang源码探索(二) 协程的实现原理 - q303248153</title>
<link>http://www.cnblogs.com/zkweb/p/7815600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zkweb/p/7815600.html</guid>
<description>&lt;p&gt;Golang最大的特色可以说是协程(goroutine)了, 协程让本来很复杂的异步编程变得简单, 让程序员不再需要面对回调地狱,&lt;br/&gt;虽然现在引入了协程的语言越来越多, 但go中的协程仍然是实现的是最彻底的.&lt;br/&gt;这篇文章将通过分析golang的源代码来讲解协程的实现原理.&lt;/p&gt;
&lt;p&gt;这个系列分析的golang源代码是Google官方的实现的1.9.2版本, 不适用于其他版本和gccgo等其他实现,&lt;br/&gt;运行环境是Ubuntu 16.04 LTS 64bit.&lt;/p&gt;

&lt;p&gt;要理解协程的实现, 首先需要了解go中的三个非常重要的概念, 它们分别是&lt;strong&gt;G&lt;/strong&gt;, &lt;strong&gt;M&lt;/strong&gt;和&lt;strong&gt;P&lt;/strong&gt;,&lt;br/&gt;没有看过golang源代码的可能会对它们感到陌生, 这三项是协程最主要的组成部分, 它们在golang的源代码中无处不在.&lt;/p&gt;
&lt;h3 id=&quot;g-goroutine&quot;&gt;G (goroutine)&lt;/h3&gt;
&lt;p&gt;G是goroutine的头文字, goroutine可以解释为受管理的轻量线程, goroutine使用&lt;code&gt;go&lt;/code&gt;关键词创建.&lt;/p&gt;
&lt;p&gt;举例来说, &lt;code&gt;func main() { go other() }&lt;/code&gt;, 这段代码创建了两个goroutine,&lt;br/&gt;一个是main, 另一个是other, 注意main本身也是一个goroutine.&lt;/p&gt;
&lt;p&gt;goroutine的新建, 休眠, 恢复, 停止都受到go运行时的管理.&lt;br/&gt;goroutine执行异步操作时会进入休眠状态, 待操作完成后再恢复, 无需占用系统线程,&lt;br/&gt;goroutine新建或恢复时会添加到运行队列, 等待M取出并运行.&lt;/p&gt;
&lt;h3 id=&quot;m-machine&quot;&gt;M (machine)&lt;/h3&gt;
&lt;p&gt;M是machine的头文字, 在当前版本的golang中&lt;strong&gt;等同于系统线程&lt;/strong&gt;.&lt;br/&gt;M可以运行两种代码:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;go代码, 即goroutine, M运行go代码需要一个P&lt;/li&gt;
&lt;li&gt;原生代码, 例如阻塞的syscall, M运行原生代码不需要P&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;M会从运行队列中取出G, 然后运行G, 如果G运行完毕或者进入休眠状态, 则从运行队列中取出下一个G运行, 周而复始.&lt;br/&gt;有时候G需要调用一些无法避免阻塞的原生代码, 这时M会释放持有的P并进入阻塞状态, 其他M会取得这个P并继续运行队列中的G.&lt;br/&gt;go需要保证有足够的M可以运行G, 不让CPU闲着, 也需要保证M的数量不能过多.&lt;/p&gt;
&lt;h3 id=&quot;p-process&quot;&gt;P (process)&lt;/h3&gt;
&lt;p&gt;P是process的头文字, 代表M运行G所需要的资源.&lt;br/&gt;一些讲解协程的文章把P理解为cpu核心, 其实这是错误的.&lt;br/&gt;虽然P的数量默认等于cpu核心数, 但可以通过环境变量&lt;code&gt;GOMAXPROC&lt;/code&gt;修改, 在实际运行时P跟cpu核心并无任何关联.&lt;/p&gt;
&lt;p&gt;P也可以理解为控制go代码的并行度的机制,&lt;br/&gt;如果P的数量等于1, 代表当前最多只能有一个线程(M)执行go代码,&lt;br/&gt;如果P的数量等于2, 代表当前最多只能有两个线程(M)执行go代码.&lt;br/&gt;执行原生代码的线程数量不受P控制.&lt;/p&gt;
&lt;p&gt;因为同一时间只有一个线程(M)可以拥有P, P中的数据都是锁自由(lock free)的, 读写这些数据的效率会非常的高.&lt;/p&gt;

&lt;p&gt;在讲解协程的工作流程之前, 还需要理解一些内部的数据结构.&lt;/p&gt;
&lt;h3 id=&quot;g的状态&quot;&gt;G的状态&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;空闲中(_Gidle): 表示G刚刚新建, 仍未初始化&lt;/li&gt;
&lt;li&gt;待运行(_Grunnable): 表示G在运行队列中, 等待M取出并运行&lt;/li&gt;
&lt;li&gt;运行中(_Grunning): 表示M正在运行这个G, 这时候M会拥有一个P&lt;/li&gt;
&lt;li&gt;系统调用中(_Gsyscall): 表示M正在运行这个G发起的系统调用, 这时候M并不拥有P&lt;/li&gt;
&lt;li&gt;等待中(_Gwaiting): 表示G在等待某些条件完成, 这时候G不在运行也不在运行队列中(可能在channel的等待队列中)&lt;/li&gt;
&lt;li&gt;已中止(_Gdead): 表示G未被使用, 可能已执行完毕(并在freelist中等待下次复用)&lt;/li&gt;
&lt;li&gt;栈复制中(_Gcopystack): 表示G正在获取一个新的栈空间并把原来的内容复制过去(用于防止GC扫描)&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;m的状态&quot;&gt;M的状态&lt;/h3&gt;
&lt;p&gt;M并没有像G和P一样的状态标记, 但可以认为一个M有以下的状态:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自旋中(spinning): M正在从运行队列获取G, 这时候M会拥有一个P&lt;/li&gt;
&lt;li&gt;执行go代码中: M正在执行go代码, 这时候M会拥有一个P&lt;/li&gt;
&lt;li&gt;执行原生代码中: M正在执行原生代码或者阻塞的syscall, 这时M并不拥有P&lt;/li&gt;
&lt;li&gt;休眠中: M发现无待运行的G时会进入休眠, 并添加到空闲M链表中, 这时M并不拥有P&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;自旋中(spinning)这个状态非常重要, 是否需要唤醒或者创建新的M取决于当前自旋中的M的数量.&lt;/p&gt;
&lt;h3 id=&quot;p的状态&quot;&gt;P的状态&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;空闲中(_Pidle): 当M发现无待运行的G时会进入休眠, 这时M拥有的P会变为空闲并加到空闲P链表中&lt;/li&gt;
&lt;li&gt;运行中(_Prunning): 当M拥有了一个P后, 这个P的状态就会变为运行中, M运行G会使用这个P中的资源&lt;/li&gt;
&lt;li&gt;系统调用中(_Psyscall): 当go调用原生代码, 原生代码又反过来调用go代码时, 使用的P会变为此状态&lt;/li&gt;
&lt;li&gt;GC停止中(_Pgcstop): 当gc停止了整个世界(STW)时, P会变为此状态&lt;/li&gt;
&lt;li&gt;已中止(_Pdead): 当P的数量在运行时改变, 且数量减少时多余的P会变为此状态&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;本地运行队列&quot;&gt;本地运行队列&lt;/h3&gt;
&lt;p&gt;在go中有多个运行队列可以保存待运行(_Grunnable)的G, 它们分别是各个P中的本地运行队列和全局运行队列.&lt;br/&gt;入队待运行的G时会优先加到当前P的本地运行队列, M获取待运行的G时也会优先从拥有的P的本地运行队列获取,&lt;br/&gt;本地运行队列入队和出队不需要使用线程锁.&lt;/p&gt;
&lt;p&gt;本地运行队列有数量限制, 当数量达到256个时会入队到全局运行队列.&lt;br/&gt;本地运行队列的数据结构是&lt;a href=&quot;https://en.wikipedia.org/wiki/Circular_buffer&quot;&gt;环形队列&lt;/a&gt;, 由一个256长度的数组和两个序号(head, tail)组成.&lt;/p&gt;
&lt;p&gt;当M从P的本地运行队列获取G时, 如果发现本地队列为空会尝试从其他P盗取一半的G过来,&lt;br/&gt;这个机制叫做&lt;a href=&quot;http://supertech.csail.mit.edu/papers/steal.pdf&quot;&gt;Work Stealing&lt;/a&gt;, 详见后面的代码分析.&lt;/p&gt;
&lt;h3 id=&quot;全局运行队列&quot;&gt;全局运行队列&lt;/h3&gt;
&lt;p&gt;全局运行队列保存在全局变量&lt;code&gt;sched&lt;/code&gt;中, 全局运行队列入队和出队需要使用线程锁.&lt;br/&gt;全局运行队列的数据结构是链表, 由两个指针(head, tail)组成.&lt;/p&gt;
&lt;h3 id=&quot;空闲m链表&quot;&gt;空闲M链表&lt;/h3&gt;
&lt;p&gt;当M发现无待运行的G时会进入休眠, 并添加到空闲M链表中, 空闲M链表保存在全局变量&lt;code&gt;sched&lt;/code&gt;.&lt;br/&gt;进入休眠的M会等待一个信号量(m.park), 唤醒休眠的M会使用这个信号量.&lt;/p&gt;
&lt;p&gt;go需要保证有足够的M可以运行G, 是通过这样的机制实现的:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;入队待运行的G后, 如果当前无自旋的M但是有空闲的P, 就唤醒或者新建一个M&lt;/li&gt;
&lt;li&gt;当M离开自旋状态并准备运行出队的G时, 如果当前无自旋的M但是有空闲的P, 就唤醒或者新建一个M&lt;/li&gt;
&lt;li&gt;当M离开自旋状态并准备休眠时, 会在离开自旋状态后再次检查所有运行队列, 如果有待运行的G则重新进入自旋状态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为&quot;入队待运行的G&quot;和&quot;M离开自旋状态&quot;会同时进行, go会使用这样的检查顺序:&lt;/p&gt;
&lt;p&gt;入队待运行的G =&amp;gt; 内存屏障 =&amp;gt; 检查当前自旋的M数量 =&amp;gt; 唤醒或者新建一个M&lt;br/&gt;减少当前自旋的M数量 =&amp;gt; 内存屏障 =&amp;gt; 检查所有运行队列是否有待运行的G =&amp;gt; 休眠&lt;/p&gt;
&lt;p&gt;这样可以保证不会出现待运行的G入队了, 也有空闲的资源P, 但无M去执行的情况.&lt;/p&gt;
&lt;h3 id=&quot;空闲p链表&quot;&gt;空闲P链表&lt;/h3&gt;
&lt;p&gt;当P的本地运行队列中的所有G都运行完毕, 又不能从其他地方拿到G时,&lt;br/&gt;拥有P的M会释放P并进入休眠状态, 释放的P会变为空闲状态并加到空闲P链表中, 空闲P链表保存在全局变量&lt;code&gt;sched&lt;/code&gt;&lt;br/&gt;下次待运行的G入队时如果发现有空闲的P, 但是又没有自旋中的M时会唤醒或者新建一个M, M会拥有这个P, P会重新变为运行中的状态.&lt;/p&gt;

&lt;p&gt;下图是协程可能出现的工作状态, 图中有4个P, 其中M1~M3正在运行G并且运行后会从拥有的P的运行队列继续获取G:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/881857/201711/881857-20171110171241372-2120016927.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只看这张图可能有点难以想象实际的工作流程, 这里我根据实际的代码再讲解一遍:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
    &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;time&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; printNumber(from, to &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, c &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;) {
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; x := from; x &amp;lt;= to; x++ {
        fmt.Printf(&lt;span class=&quot;st&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, x)
        time.Sleep(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; * time.Millisecond)
    }
    c &amp;lt;- &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
    c := &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; printNumber(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, c)
    &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; printNumber(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, c)
    _ = &amp;lt;- c
    _ = &amp;lt;- c
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;程序启动时会先创建一个G, 指向的是main(实际是runtime.main而不是main.main, 后面解释):&lt;br/&gt;图中的虚线指的是G待运行或者开始运行的地址, 不是当前运行的地址.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/881857/201711/881857-20171110171251091-1325784333.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;M会取得这个G并运行:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/881857/201711/881857-20171110171257559-269808777.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时main会创建一个新的channel, 并启动两个新的G:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/881857/201711/881857-20171110171304919-1329887936.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来&lt;code&gt;G: main&lt;/code&gt;会从channel获取数据, 因为获取不到, G会&lt;strong&gt;保存状态&lt;/strong&gt;并变为等待中(_Gwaiting)并添加到channel的队列:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/881857/201711/881857-20171110171312638-525155603.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为&lt;code&gt;G: main&lt;/code&gt;保存了运行状态, 下次运行时将会从&lt;code&gt;_ = &amp;lt;- c&lt;/code&gt;继续运行.&lt;br/&gt;接下来M会从运行队列获取到&lt;code&gt;G: printNumber&lt;/code&gt;并运行:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/881857/201711/881857-20171110171319888-1466945199.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;printNumber会打印数字, 完成后向channel写数据,&lt;br/&gt;写数据时发现channel中有正在等待的G, 会把数据交给这个G, 把G变为待运行(_Grunnable)并重新放入运行队列:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/881857/201711/881857-20171110171328216-1977430311.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来M会运行下一个&lt;code&gt;G: printNumber&lt;/code&gt;, 因为创建channel时指定了大小为3的缓冲区, 可以直接把数据写入缓冲区而无需等待:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/881857/201711/881857-20171110171335450-1117872609.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后printNumber运行完毕, 运行队列中就只剩下&lt;code&gt;G: main&lt;/code&gt;了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/881857/201711/881857-20171110171343934-830758071.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后M把&lt;code&gt;G: main&lt;/code&gt;取出来运行, 会从上次中断的位置&lt;code&gt;_ &amp;lt;- c&lt;/code&gt;继续运行:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/881857/201711/881857-20171110171354653-922259524.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个&lt;code&gt;_ &amp;lt;- c&lt;/code&gt;的结果已经在前面设置过了, 这条语句会执行成功.&lt;br/&gt;第二个&lt;code&gt;_ &amp;lt;- c&lt;/code&gt;在获取时会发现channel中有已缓冲的0, 于是结果就是这个0, 不需要等待.&lt;br/&gt;最后main执行完毕, 程序结束.&lt;/p&gt;
&lt;p&gt;有人可能会好奇如果最后再加一个&lt;code&gt;_ &amp;lt;- c&lt;/code&gt;会变成什么结果, 这时因为所有G都进入等待状态, go会检测出来并报告死锁:&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;fatal error: all goroutines are asleep - deadlock!&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;关于概念的讲解到此结束, 从这里开始会分析go中的实现代码, 我们需要先了解一些基础的内容.&lt;/p&gt;
&lt;h3 id=&quot;汇编代码&quot;&gt;汇编代码&lt;/h3&gt;
&lt;p&gt;从以下的go代码:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;19&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
    &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;time&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; printNumber(from, to &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, c &lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;) {
    &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; x := from; x &amp;lt;= to; x++ {
        fmt.Printf(&lt;span class=&quot;st&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, x)
        time.Sleep(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt; * time.Millisecond)
    }
    c &amp;lt;- &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
    c := &lt;span class=&quot;fu&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;)
    &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; printNumber(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;, c)
    &lt;span class=&quot;kw&quot;&gt;go&lt;/span&gt; printNumber(&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;, c)
    _, _ = &amp;lt;- c, &amp;lt;- c
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以生成以下的汇编代码(平台是linux x64, 使用的是默认选项, 即启用优化和内联):&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;(lldb) di -n main.main
hello`main.main:
hello[0x401190] &amp;lt;+0&amp;gt;:   movq   %fs:-0x8, %rcx
hello[0x401199] &amp;lt;+9&amp;gt;:   cmpq   0x10(%rcx), %rsp
hello[0x40119d] &amp;lt;+13&amp;gt;:  jbe    0x401291                  ; &amp;lt;+257&amp;gt; at hello.go:16
hello[0x4011a3] &amp;lt;+19&amp;gt;:  subq   $0x40, %rsp
hello[0x4011a7] &amp;lt;+23&amp;gt;:  leaq   0xb3632(%rip), %rbx       ; runtime.rodata + 38880
hello[0x4011ae] &amp;lt;+30&amp;gt;:  movq   %rbx, (%rsp)
hello[0x4011b2] &amp;lt;+34&amp;gt;:  movq   $0x3, 0x8(%rsp)
hello[0x4011bb] &amp;lt;+43&amp;gt;:  callq  0x4035a0                  ; runtime.makechan at chan.go:49
hello[0x4011c0] &amp;lt;+48&amp;gt;:  movq   0x10(%rsp), %rax
hello[0x4011c5] &amp;lt;+53&amp;gt;:  movq   $0x1, 0x10(%rsp)
hello[0x4011ce] &amp;lt;+62&amp;gt;:  movq   $0x3, 0x18(%rsp)
hello[0x4011d7] &amp;lt;+71&amp;gt;:  movq   %rax, 0x38(%rsp)
hello[0x4011dc] &amp;lt;+76&amp;gt;:  movq   %rax, 0x20(%rsp)
hello[0x4011e1] &amp;lt;+81&amp;gt;:  movl   $0x18, (%rsp)
hello[0x4011e8] &amp;lt;+88&amp;gt;:  leaq   0x129c29(%rip), %rax      ; main.printNumber.f
hello[0x4011ef] &amp;lt;+95&amp;gt;:  movq   %rax, 0x8(%rsp)
hello[0x4011f4] &amp;lt;+100&amp;gt;: callq  0x430cd0                  ; runtime.newproc at proc.go:2657
hello[0x4011f9] &amp;lt;+105&amp;gt;: movq   $0x4, 0x10(%rsp)
hello[0x401202] &amp;lt;+114&amp;gt;: movq   $0x6, 0x18(%rsp)
hello[0x40120b] &amp;lt;+123&amp;gt;: movq   0x38(%rsp), %rbx
hello[0x401210] &amp;lt;+128&amp;gt;: movq   %rbx, 0x20(%rsp)
hello[0x401215] &amp;lt;+133&amp;gt;: movl   $0x18, (%rsp)
hello[0x40121c] &amp;lt;+140&amp;gt;: leaq   0x129bf5(%rip), %rax      ; main.printNumber.f
hello[0x401223] &amp;lt;+147&amp;gt;: movq   %rax, 0x8(%rsp)
hello[0x401228] &amp;lt;+152&amp;gt;: callq  0x430cd0                  ; runtime.newproc at proc.go:2657
hello[0x40122d] &amp;lt;+157&amp;gt;: movq   $0x0, 0x30(%rsp)
hello[0x401236] &amp;lt;+166&amp;gt;: leaq   0xb35a3(%rip), %rbx       ; runtime.rodata + 38880
hello[0x40123d] &amp;lt;+173&amp;gt;: movq   %rbx, (%rsp)
hello[0x401241] &amp;lt;+177&amp;gt;: movq   0x38(%rsp), %rbx
hello[0x401246] &amp;lt;+182&amp;gt;: movq   %rbx, 0x8(%rsp)
hello[0x40124b] &amp;lt;+187&amp;gt;: leaq   0x30(%rsp), %rbx
hello[0x401250] &amp;lt;+192&amp;gt;: movq   %rbx, 0x10(%rsp)
hello[0x401255] &amp;lt;+197&amp;gt;: callq  0x4043c0                  ; runtime.chanrecv1 at chan.go:354
hello[0x40125a] &amp;lt;+202&amp;gt;: movq   $0x0, 0x28(%rsp)
hello[0x401263] &amp;lt;+211&amp;gt;: leaq   0xb3576(%rip), %rbx       ; runtime.rodata + 38880
hello[0x40126a] &amp;lt;+218&amp;gt;: movq   %rbx, (%rsp)
hello[0x40126e] &amp;lt;+222&amp;gt;: movq   0x38(%rsp), %rbx
hello[0x401273] &amp;lt;+227&amp;gt;: movq   %rbx, 0x8(%rsp)
hello[0x401278] &amp;lt;+232&amp;gt;: leaq   0x28(%rsp), %rbx
hello[0x40127d] &amp;lt;+237&amp;gt;: movq   %rbx, 0x10(%rsp)
hello[0x401282] &amp;lt;+242&amp;gt;: callq  0x4043c0                  ; runtime.chanrecv1 at chan.go:354
hello[0x401287] &amp;lt;+247&amp;gt;: movq   0x28(%rsp), %rbx
hello[0x40128c] &amp;lt;+252&amp;gt;: addq   $0x40, %rsp
hello[0x401290] &amp;lt;+256&amp;gt;: retq   
hello[0x401291] &amp;lt;+257&amp;gt;: callq  0x4538d0                  ; runtime.morestack_noctxt at asm_amd64.s:365
hello[0x401296] &amp;lt;+262&amp;gt;: jmp    0x401190                  ; &amp;lt;+0&amp;gt; at hello.go:16
hello[0x40129b] &amp;lt;+267&amp;gt;: int3   
hello[0x40129c] &amp;lt;+268&amp;gt;: int3   
hello[0x40129d] &amp;lt;+269&amp;gt;: int3   
hello[0x40129e] &amp;lt;+270&amp;gt;: int3   
hello[0x40129f] &amp;lt;+271&amp;gt;: int3   

(lldb) di -n main.printNumber
hello`main.printNumber:
hello[0x401000] &amp;lt;+0&amp;gt;:   movq   %fs:-0x8, %rcx
hello[0x401009] &amp;lt;+9&amp;gt;:   leaq   -0x8(%rsp), %rax
hello[0x40100e] &amp;lt;+14&amp;gt;:  cmpq   0x10(%rcx), %rax
hello[0x401012] &amp;lt;+18&amp;gt;:  jbe    0x401185                  ; &amp;lt;+389&amp;gt; at hello.go:8
hello[0x401018] &amp;lt;+24&amp;gt;:  subq   $0x88, %rsp
hello[0x40101f] &amp;lt;+31&amp;gt;:  xorps  %xmm0, %xmm0
hello[0x401022] &amp;lt;+34&amp;gt;:  movups %xmm0, 0x60(%rsp)
hello[0x401027] &amp;lt;+39&amp;gt;:  movq   0x90(%rsp), %rax
hello[0x40102f] &amp;lt;+47&amp;gt;:  movq   0x98(%rsp), %rbp
hello[0x401037] &amp;lt;+55&amp;gt;:  cmpq   %rbp, %rax
hello[0x40103a] &amp;lt;+58&amp;gt;:  jg     0x40112f                  ; &amp;lt;+303&amp;gt; at hello.go:13
hello[0x401040] &amp;lt;+64&amp;gt;:  movq   %rax, 0x40(%rsp)
hello[0x401045] &amp;lt;+69&amp;gt;:  movq   %rax, 0x48(%rsp)
hello[0x40104a] &amp;lt;+74&amp;gt;:  xorl   %ebx, %ebx
hello[0x40104c] &amp;lt;+76&amp;gt;:  movq   %rbx, 0x60(%rsp)
hello[0x401051] &amp;lt;+81&amp;gt;:  movq   %rbx, 0x68(%rsp)
hello[0x401056] &amp;lt;+86&amp;gt;:  leaq   0x60(%rsp), %rbx
hello[0x40105b] &amp;lt;+91&amp;gt;:  cmpq   $0x0, %rbx
hello[0x40105f] &amp;lt;+95&amp;gt;:  je     0x40117e                  ; &amp;lt;+382&amp;gt; at hello.go:10
hello[0x401065] &amp;lt;+101&amp;gt;: movq   $0x1, 0x78(%rsp)
hello[0x40106e] &amp;lt;+110&amp;gt;: movq   $0x1, 0x80(%rsp)
hello[0x40107a] &amp;lt;+122&amp;gt;: movq   %rbx, 0x70(%rsp)
hello[0x40107f] &amp;lt;+127&amp;gt;: leaq   0xb73fa(%rip), %rbx       ; runtime.rodata + 54400
hello[0x401086] &amp;lt;+134&amp;gt;: movq   %rbx, (%rsp)
hello[0x40108a] &amp;lt;+138&amp;gt;: leaq   0x48(%rsp), %rbx
hello[0x40108f] &amp;lt;+143&amp;gt;: movq   %rbx, 0x8(%rsp)
hello[0x401094] &amp;lt;+148&amp;gt;: movq   $0x0, 0x10(%rsp)
hello[0x40109d] &amp;lt;+157&amp;gt;: callq  0x40bb90                  ; runtime.convT2E at iface.go:128
hello[0x4010a2] &amp;lt;+162&amp;gt;: movq   0x18(%rsp), %rcx
hello[0x4010a7] &amp;lt;+167&amp;gt;: movq   0x20(%rsp), %rax
hello[0x4010ac] &amp;lt;+172&amp;gt;: movq   0x70(%rsp), %rbx
hello[0x4010b1] &amp;lt;+177&amp;gt;: movq   %rcx, 0x50(%rsp)
hello[0x4010b6] &amp;lt;+182&amp;gt;: movq   %rcx, (%rbx)
hello[0x4010b9] &amp;lt;+185&amp;gt;: movq   %rax, 0x58(%rsp)
hello[0x4010be] &amp;lt;+190&amp;gt;: cmpb   $0x0, 0x19ea1b(%rip)      ; time.initdone.
hello[0x4010c5] &amp;lt;+197&amp;gt;: jne    0x401167                  ; &amp;lt;+359&amp;gt; at hello.go:10
hello[0x4010cb] &amp;lt;+203&amp;gt;: movq   %rax, 0x8(%rbx)
hello[0x4010cf] &amp;lt;+207&amp;gt;: leaq   0xfb152(%rip), %rbx       ; go.string.* + 560
hello[0x4010d6] &amp;lt;+214&amp;gt;: movq   %rbx, (%rsp)
hello[0x4010da] &amp;lt;+218&amp;gt;: movq   $0x3, 0x8(%rsp)
hello[0x4010e3] &amp;lt;+227&amp;gt;: movq   0x70(%rsp), %rbx
hello[0x4010e8] &amp;lt;+232&amp;gt;: movq   %rbx, 0x10(%rsp)
hello[0x4010ed] &amp;lt;+237&amp;gt;: movq   0x78(%rsp), %rbx
hello[0x4010f2] &amp;lt;+242&amp;gt;: movq   %rbx, 0x18(%rsp)
hello[0x4010f7] &amp;lt;+247&amp;gt;: movq   0x80(%rsp), %rbx
hello[0x4010ff] &amp;lt;+255&amp;gt;: movq   %rbx, 0x20(%rsp)
hello[0x401104] &amp;lt;+260&amp;gt;: callq  0x45ad70                  ; fmt.Printf at print.go:196
hello[0x401109] &amp;lt;+265&amp;gt;: movq   $0xf4240, (%rsp)          ; imm = 0xF4240 
hello[0x401111] &amp;lt;+273&amp;gt;: callq  0x442a50                  ; time.Sleep at time.go:48
hello[0x401116] &amp;lt;+278&amp;gt;: movq   0x40(%rsp), %rax
hello[0x40111b] &amp;lt;+283&amp;gt;: incq   %rax
hello[0x40111e] &amp;lt;+286&amp;gt;: movq   0x98(%rsp), %rbp
hello[0x401126] &amp;lt;+294&amp;gt;: cmpq   %rbp, %rax
hello[0x401129] &amp;lt;+297&amp;gt;: jle    0x401040                  ; &amp;lt;+64&amp;gt; at hello.go:10
hello[0x40112f] &amp;lt;+303&amp;gt;: movq   $0x0, 0x48(%rsp)
hello[0x401138] &amp;lt;+312&amp;gt;: leaq   0xb36a1(%rip), %rbx       ; runtime.rodata + 38880
hello[0x40113f] &amp;lt;+319&amp;gt;: movq   %rbx, (%rsp)
hello[0x401143] &amp;lt;+323&amp;gt;: movq   0xa0(%rsp), %rbx
hello[0x40114b] &amp;lt;+331&amp;gt;: movq   %rbx, 0x8(%rsp)
hello[0x401150] &amp;lt;+336&amp;gt;: leaq   0x48(%rsp), %rbx
hello[0x401155] &amp;lt;+341&amp;gt;: movq   %rbx, 0x10(%rsp)
hello[0x40115a] &amp;lt;+346&amp;gt;: callq  0x403870                  ; runtime.chansend1 at chan.go:99
hello[0x40115f] &amp;lt;+351&amp;gt;: addq   $0x88, %rsp
hello[0x401166] &amp;lt;+358&amp;gt;: retq   
hello[0x401167] &amp;lt;+359&amp;gt;: leaq   0x8(%rbx), %r8
hello[0x40116b] &amp;lt;+363&amp;gt;: movq   %r8, (%rsp)
hello[0x40116f] &amp;lt;+367&amp;gt;: movq   %rax, 0x8(%rsp)
hello[0x401174] &amp;lt;+372&amp;gt;: callq  0x40f090                  ; runtime.writebarrierptr at mbarrier.go:129
hello[0x401179] &amp;lt;+377&amp;gt;: jmp    0x4010cf                  ; &amp;lt;+207&amp;gt; at hello.go:10
hello[0x40117e] &amp;lt;+382&amp;gt;: movl   %eax, (%rbx)
hello[0x401180] &amp;lt;+384&amp;gt;: jmp    0x401065                  ; &amp;lt;+101&amp;gt; at hello.go:10
hello[0x401185] &amp;lt;+389&amp;gt;: callq  0x4538d0                  ; runtime.morestack_noctxt at asm_amd64.s:365
hello[0x40118a] &amp;lt;+394&amp;gt;: jmp    0x401000                  ; &amp;lt;+0&amp;gt; at hello.go:8
hello[0x40118f] &amp;lt;+399&amp;gt;: int3   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些汇编代码现在看不懂也没关系, 下面会从这里取出一部分来解释.&lt;/p&gt;
&lt;h3 id=&quot;调用规范&quot;&gt;调用规范&lt;/h3&gt;
&lt;p&gt;不同平台对于函数有不同的调用规范.&lt;br/&gt;例如32位通过栈传递参数, 通过eax寄存器传递返回值.&lt;br/&gt;64位windows通过rcx, rdx, r8, r9传递前4个参数, 通过栈传递第5个开始的参数, 通过eax寄存器传递返回值.&lt;br/&gt;64位linux, unix通过rdi, rsi, rdx, rcx, r8, r9传递前6个参数, 通过栈传递第7个开始的参数, 通过eax寄存器传递返回值.&lt;br/&gt;go并不使用这些调用规范(除非涉及到与原生代码交互), go有一套独自的调用规范.&lt;/p&gt;
&lt;p&gt;go的调用规范非常的简单, 所有参数都通过栈传递, 返回值也通过栈传递,&lt;br/&gt;例如这样的函数:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;type&lt;/span&gt; MyStruct &lt;span class=&quot;kw&quot;&gt;struct&lt;/span&gt; { X &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;; P *&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; }
&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; someFunc(x &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, s MyStruct) (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;, MyStruct) { ... }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用函数时的栈的内容如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/881857/201711/881857-20171110171401966-739107068.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看得出参数和返回值都从低位到高位排列, go函数可以有多个返回值的原因也在于此. 因为返回值都通过栈传递了.&lt;br/&gt;需要注意的这里的&quot;返回地址&quot;是x86和x64上的, arm的返回地址会通过LR寄存器保存, 内容会和这里的稍微不一样.&lt;br/&gt;另外注意的是和c不一样, 传递构造体时整个构造体的内容都会复制到栈上, 如果构造体很大将会影响性能.&lt;/p&gt;
&lt;h3 id=&quot;tls&quot;&gt;TLS&lt;/h3&gt;
&lt;p&gt;TLS的全称是&lt;a href=&quot;https://en.wikipedia.org/wiki/Thread-local_storage&quot;&gt;Thread-local storage&lt;/a&gt;, 代表每个线程的中的本地数据.&lt;br/&gt;例如标准c中的errno就是一个典型的TLS变量, 每个线程都有一个独自的errno, 写入它不会干扰到其他线程中的值.&lt;br/&gt;go在实现协程时非常依赖TLS机制, 会用于获取系统线程中当前的G和G所属的M的实例.&lt;/p&gt;
&lt;p&gt;因为go并不使用glibc, 操作TLS会使用系统原生的接口, 以linux x64为例,&lt;br/&gt;go在新建M时会调用&lt;a href=&quot;http://man7.org/linux/man-pages/man2/arch_prctl.2.html&quot;&gt;arch_prctl&lt;/a&gt;这个syscall设置FS寄存器的值为M.tls的地址,&lt;br/&gt;运行中每个M的FS寄存器都会指向它们对应的M实例的tls, linux内核调度线程时FS寄存器会跟着线程一起切换,&lt;br/&gt;这样go代码只需要访问FS寄存器就可以存取线程本地的数据.&lt;/p&gt;
&lt;p&gt;上面的汇编代码中的&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;hello[0x401000] &amp;lt;+0&amp;gt;:   movq   %fs:-0x8, %rcx&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会把指向当前的G的指针从TLS移动到rcx寄存器中.&lt;/p&gt;
&lt;h3 id=&quot;栈扩张&quot;&gt;栈扩张&lt;/h3&gt;
&lt;p&gt;因为go中的协程是&lt;a href=&quot;https://stackoverflow.com/questions/28977302/how-do-stackless-coroutines-differ-from-stackful-coroutines&quot;&gt;stackful coroutine&lt;/a&gt;, 每一个goroutine都需要有自己的栈空间,&lt;br/&gt;栈空间的内容在goroutine休眠时需要保留, 待休眠完成后恢复(这时整个调用树都是完整的).&lt;br/&gt;这样就引出了一个问题, goroutine可能会同时存在很多个, 如果每一个goroutine都预先分配一个足够的栈空间那么go就会使用过多的内存.&lt;/p&gt;
&lt;p&gt;为了避免这个问题, go在一开始只为goroutine分配一个很小的栈空间, 它的大小在当前版本是2K.&lt;br/&gt;当函数发现栈空间不足时, 会申请一块新的栈空间并把原来的栈内容复制过去.&lt;/p&gt;
&lt;p&gt;上面的汇编代码中的&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;hello[0x401000] &amp;lt;+0&amp;gt;:   movq   %fs:-0x8, %rcx
hello[0x401009] &amp;lt;+9&amp;gt;:   leaq   -0x8(%rsp), %rax
hello[0x40100e] &amp;lt;+14&amp;gt;:  cmpq   0x10(%rcx), %rax
hello[0x401012] &amp;lt;+18&amp;gt;:  jbe    0x401185                  ; &amp;lt;+389&amp;gt; at hello.go:8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会检查比较rsp减去一定值以后是否比g.stackguard0小, 如果小于等于则需要调到下面调用morestack_noctxt函数.&lt;br/&gt;细心的可能会发现比较的值跟实际减去的值不一致, 这是因为stackguard0下面会预留一小部分空间, 编译时确定不超过预留的空间可以省略比对.&lt;/p&gt;
&lt;h3 id=&quot;写屏障write-barrier&quot;&gt;写屏障(Write Barrier)&lt;/h3&gt;
&lt;p&gt;因为go支持并行GC, GC的扫描和go代码可以同时运行, 这样带来的问题是GC扫描的过程中go代码有可能改变了对象的依赖树,&lt;br/&gt;例如开始扫描时发现根对象A和B, B拥有C的指针, GC先扫描A, 然后B把C的指针交给A, GC再扫描B, 这时C就不会被扫描到.&lt;br/&gt;为了避免这个问题, go在GC的标记阶段会启用写屏障(Write Barrier).&lt;/p&gt;
&lt;p&gt;启用了写屏障(Write Barrier)后, 当B把C的指针交给A时, GC会认为在这一轮的扫描中C的指针是存活的,&lt;br/&gt;即使A可能会在稍后丢掉C, 那么C就在下一轮回收.&lt;br/&gt;写屏障只针对指针启用, 而且只在GC的标记阶段启用, 平时会直接把值写入到目标地址:&lt;/p&gt;
&lt;p&gt;关于写屏障的详细将在下一篇(GC篇)分析.&lt;br/&gt;值得一提的是CoreCLR的GC也有写屏障的机制, 作用跟这里说明的一样.&lt;/p&gt;
&lt;h3 id=&quot;闭包closure&quot;&gt;闭包(Closure)&lt;/h3&gt;
&lt;p&gt;闭包这个概念本身应该不需要解释, 我们实际看一看go是如何实现闭包的:&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode go&quot;&gt;
&lt;code class=&quot;sourceCode go&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;kw&quot;&gt;import&lt;/span&gt; (
    &lt;span class=&quot;st&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
)

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; executeFn(fn &lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt;() &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;) &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; {
    &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; fn();
}

&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt; main() {
    a := &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;
    b := &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;
    c := executeFn(&lt;span class=&quot;kw&quot;&gt;func&lt;/span&gt;() &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; {
        a += b
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; a
    })
    fmt.Printf(&lt;span class=&quot;st&quot;&gt;&quot;%d %d %d&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, a, b, c)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码的输出结果是&lt;code&gt;3 2 3&lt;/code&gt;, 熟悉go的应该不会感到意外.&lt;br/&gt;main函数执行executeFn函数的汇编代码如下:&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;hello[0x4a096f] &amp;lt;+47&amp;gt;:  movq   $0x1, 0x40(%rsp)          ; 变量a等于1
hello[0x4a0978] &amp;lt;+56&amp;gt;:  leaq   0x151(%rip), %rax         ; 寄存器rax等于匿名函数main.main.func1的地址
hello[0x4a097f] &amp;lt;+63&amp;gt;:  movq   %rax, 0x60(%rsp)          ; 变量rsp+0x60等于匿名函数的地址
hello[0x4a0984] &amp;lt;+68&amp;gt;:  leaq   0x40(%rsp), %rax          ; 寄存器rax等于变量a的地址
hello[0x4a0989] &amp;lt;+73&amp;gt;:  movq   %rax, 0x68(%rsp)          ; 变量rsp+0x68等于变量a的地址
hello[0x4a098e] &amp;lt;+78&amp;gt;:  movq   $0x2, 0x70(%rsp)          ; 变量rsp+0x70等于2(变量b的值)
hello[0x4a0997] &amp;lt;+87&amp;gt;:  leaq   0x60(%rsp), %rax          ; 寄存器rax等于地址rsp+0x60
hello[0x4a099c] &amp;lt;+92&amp;gt;:  movq   %rax, (%rsp)              ; 第一个参数等于地址rsp+0x60
hello[0x4a09a0] &amp;lt;+96&amp;gt;:  callq  0x4a08f0                  ; 执行main.executeFn
hello[0x4a09a5] &amp;lt;+101&amp;gt;: movq   0x8(%rsp), %rax           ; 寄存器rax等于返回值&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到传给executeFn的是一个指针, 指针指向的内容是&lt;code&gt;[匿名函数的地址, 变量a的地址, 变量b的值]&lt;/code&gt;.&lt;br/&gt;变量a传地址的原因是匿名函数中对a进行了修改, 需要反映到原来的a上.&lt;br/&gt;executeFn函数执行闭包的汇编代码如下:&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;hello[0x4a08ff] &amp;lt;+15&amp;gt;: subq   $0x10, %rsp                ; 在栈上分配0x10的空间
hello[0x4a0903] &amp;lt;+19&amp;gt;: movq   %rbp, 0x8(%rsp)            ; 把原来的寄存器rbp移到变量rsp+0x8
hello[0x4a0908] &amp;lt;+24&amp;gt;: leaq   0x8(%rsp), %rbp            ; 把变量rsp+0x8的地址移到寄存器rbp
hello[0x4a090d] &amp;lt;+29&amp;gt;: movq   0x18(%rsp), %rdx           ; 把第一个参数(闭包)的指针移到寄存器rdx
hello[0x4a0912] &amp;lt;+34&amp;gt;: movq   (%rdx), %rax               ; 把闭包中函数的指针移到寄存器rax
hello[0x4a0915] &amp;lt;+37&amp;gt;: callq  *%rax                      ; 调用闭包中的函数
hello[0x4a0917] &amp;lt;+39&amp;gt;: movq   (%rsp), %rax               ; 把返回值移到寄存器rax
hello[0x4a091b] &amp;lt;+43&amp;gt;: movq   %rax, 0x20(%rsp)           ; 把寄存器rax移到返回值中(参数后面)
hello[0x4a0920] &amp;lt;+48&amp;gt;: movq   0x8(%rsp), %rbp            ; 把变量rsp+0x8的值恢复寄存器rbp(恢复原rbp)
hello[0x4a0925] &amp;lt;+53&amp;gt;: addq   $0x10, %rsp                ; 释放栈空间
hello[0x4a0929] &amp;lt;+57&amp;gt;: retq                              ; 从函数返回&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到调用闭包时参数并不通过栈传递, 而是通过寄存器rdx传递, 闭包的汇编代码如下:&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;hello[0x455660] &amp;lt;+0&amp;gt;:  movq   0x8(%rdx), %rax            ; 第一个参数移到寄存器rax(变量a的指针)
hello[0x455664] &amp;lt;+4&amp;gt;:  movq   (%rax), %rcx               ; 把寄存器rax指向的值移到寄存器rcx(变量a的值)
hello[0x455667] &amp;lt;+7&amp;gt;:  addq   0x10(%rdx), %rcx           ; 添加第二个参数到寄存器rcx(变量a的值+变量b的值)
hello[0x45566b] &amp;lt;+11&amp;gt;: movq   %rcx, (%rax)               ; 把寄存器rcx移到寄存器rax指向的值(相加的结果保存回变量a)
hello[0x45566e] &amp;lt;+14&amp;gt;: movq   %rcx, 0x8(%rsp)            ; 把寄存器rcx移到返回结果
hello[0x455673] &amp;lt;+19&amp;gt;: retq                              ; 从函数返回&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;闭包的传递可以总结如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;闭包的内容是[匿名函数的地址, 传给匿名函数的参数(不定长)...]&lt;/li&gt;
&lt;li&gt;传递闭包给其他函数时会传递指向&quot;闭包的内容&quot;的指针&lt;/li&gt;
&lt;li&gt;调用闭包时会把指向&quot;闭包的内容&quot;的指针放到寄存器rdx(在go内部这个指针称为&quot;上下文&quot;)&lt;/li&gt;
&lt;li&gt;闭包会从寄存器rdx取出参数&lt;/li&gt;
&lt;li&gt;如果闭包修改了变量, 闭包中的参数会是指针而不是值, 修改时会修改到原来的位置上&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;闭包goroutine&quot;&gt;闭包+goroutine&lt;/h3&gt;
&lt;p&gt;细心的可能会发现在上面的例子中, 闭包的内容在栈上, 如果不是直接调用executeFn而是go executeFn呢?&lt;br/&gt;把上面的代码改为&lt;code&gt;go executeFn(func() ...)&lt;/code&gt;可以生成以下的汇编代码:&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;hello[0x455611] &amp;lt;+33&amp;gt;:  leaq   0xb4a8(%rip), %rax        ; 寄存器rax等于类型信息
hello[0x455618] &amp;lt;+40&amp;gt;:  movq   %rax, (%rsp)              ; 第一个参数等于类型信息
hello[0x45561c] &amp;lt;+44&amp;gt;:  callq  0x40d910                  ; 调用runtime.newobject
hello[0x455621] &amp;lt;+49&amp;gt;:  movq   0x8(%rsp), %rax           ; 寄存器rax等于返回值(这里称为新对象a)
hello[0x455626] &amp;lt;+54&amp;gt;:  movq   %rax, 0x28(%rsp)          ; 变量rsp+0x28等于新对象a
hello[0x45562b] &amp;lt;+59&amp;gt;:  movq   $0x1, (%rax)              ; 新对象a的值等于1
hello[0x455632] &amp;lt;+66&amp;gt;:  leaq   0x136e7(%rip), %rcx       ; 寄存器rcx等于类型信息
hello[0x455639] &amp;lt;+73&amp;gt;:  movq   %rcx, (%rsp)              ; 第一个参数等于类型信息
hello[0x45563d] &amp;lt;+77&amp;gt;:  callq  0x40d910                  ; 调用runtime.newobject
hello[0x455642] &amp;lt;+82&amp;gt;:  movq   0x8(%rsp), %rax           ; 寄存器rax等于返回值(这里称为新对象fn)
hello[0x455647] &amp;lt;+87&amp;gt;:  leaq   0x82(%rip), %rcx          ; 寄存器rcx等于匿名函数main.main.func1的地址
hello[0x45564e] &amp;lt;+94&amp;gt;:  movq   %rcx, (%rax)              ; 新对象fn+0的值等于main.main.func1的地址
hello[0x455651] &amp;lt;+97&amp;gt;:  testb  (%rax), %al               ; 确保新对象fn不等于nil
hello[0x455653] &amp;lt;+99&amp;gt;:  movl   0x78397(%rip), %ecx       ; 寄存器ecx等于当前是否启用写屏障
hello[0x455659] &amp;lt;+105&amp;gt;: leaq   0x8(%rax), %rdx           ; 寄存器rdx等于新对象fn+0x8的地址
hello[0x45565d] &amp;lt;+109&amp;gt;: testl  %ecx, %ecx                ; 判断当前是否启用写屏障
hello[0x45565f] &amp;lt;+111&amp;gt;: jne    0x455699                  ; 启用写屏障时调用后面的逻辑
hello[0x455661] &amp;lt;+113&amp;gt;: movq   0x28(%rsp), %rcx          ; 寄存器rcx等于新对象a
hello[0x455666] &amp;lt;+118&amp;gt;: movq   %rcx, 0x8(%rax)           ; 设置新对象fn+0x8的值等于新对象a
hello[0x45566a] &amp;lt;+122&amp;gt;: movq   $0x2, 0x10(%rax)          ; 设置新对象fn+0x10的值等于2(变量b的值)
hello[0x455672] &amp;lt;+130&amp;gt;: movq   %rax, 0x10(%rsp)          ; 第三个参数等于新对象fn(额外参数)
hello[0x455677] &amp;lt;+135&amp;gt;: movl   $0x10, (%rsp)             ; 第一个参数等于0x10(函数+参数的大小)
hello[0x45567e] &amp;lt;+142&amp;gt;: leaq   0x22fb3(%rip), %rax       ; 第二个参数等于一个常量构造体的地址
hello[0x455685] &amp;lt;+149&amp;gt;: movq   %rax, 0x8(%rsp)           ; 这个构造体的类型是funcval, 值是executeFn的地址
hello[0x45568a] &amp;lt;+154&amp;gt;: callq  0x42e690                  ; 调用runtime.newproc创建新的goroutine&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到goroutine+闭包的情况更复杂, 首先go会通过逃逸分析算出变量a和闭包会逃逸到外面,&lt;br/&gt;这时go会在heap上分配变量a和闭包, 上面调用的两次newobject就是分别对变量a和闭包的分配.&lt;br/&gt;在创建goroutine时, 首先会传入函数+参数的大小(上面是8+8=16), 然后传入函数+参数, 上面的参数即闭包的地址.&lt;/p&gt;
&lt;h3 id=&quot;m0和g0&quot;&gt;m0和g0&lt;/h3&gt;
&lt;p&gt;go中还有特殊的M和G, 它们是m0和g0.&lt;/p&gt;
&lt;p&gt;m0是启动程序后的主线程, 这个m对应的实例会在全局变量m0中, 不需要在heap上分配,&lt;br/&gt;m0负责执行初始化操作和启动第一个g, 在之后m0就和其他的m一样了.&lt;/p&gt;
&lt;p&gt;g0是仅用于负责调度的G, g0不指向任何可执行的函数, 每个m都会有一个自己的g0,&lt;br/&gt;在调度或系统调用时会使用g0的栈空间, 全局变量的g0是m0的g0.&lt;/p&gt;
&lt;p&gt;如果上面的内容都了解, 就可以开始看golang的源代码了.&lt;/p&gt;

&lt;p&gt;go程序的入口点是&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/asm_amd64.s&quot;&gt;runtime.rt0_go&lt;/a&gt;, 流程是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分配栈空间, 需要2个本地变量+2个函数参数, 然后向8对齐&lt;/li&gt;
&lt;li&gt;把传入的argc和argv保存到栈上&lt;/li&gt;
&lt;li&gt;更新g0中的stackguard的值, stackguard用于检测栈空间是否不足, 需要分配新的栈空间&lt;/li&gt;
&lt;li&gt;获取当前cpu的信息并保存到各个全局变量&lt;/li&gt;
&lt;li&gt;调用_cgo_init如果函数存在&lt;/li&gt;
&lt;li&gt;初始化当前线程的TLS, 设置FS寄存器为m0.tls+8(获取时会-8)&lt;/li&gt;
&lt;li&gt;测试TLS是否工作&lt;/li&gt;
&lt;li&gt;设置g0到TLS中, 表示当前的g是g0&lt;/li&gt;
&lt;li&gt;设置m0.g0 = g0&lt;/li&gt;
&lt;li&gt;设置g0.m = m0&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/runtime1.go#L140&quot;&gt;runtime.check&lt;/a&gt;做一些检查&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/runtime1.go#L60&quot;&gt;runtime.args&lt;/a&gt;保存传入的argc和argv到全局变量&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/os_linux.go#L269&quot;&gt;runtime.osinit&lt;/a&gt;根据系统执行不同的初始化
&lt;ul&gt;&lt;li&gt;这里(linux x64)设置了全局变量ncpu等于cpu核心数量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L468&quot;&gt;runtime.schedinit&lt;/a&gt;执行共同的初始化
&lt;ul&gt;&lt;li&gt;这里的处理比较多, 会初始化栈空间分配器, GC, 按cpu核心数量或GOMAXPROCS的值生成P等&lt;/li&gt;
&lt;li&gt;生成P的处理在&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L3517&quot;&gt;procresize&lt;/a&gt;中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L2929&quot;&gt;runtime.newproc&lt;/a&gt;创建一个新的goroutine, 指向的是&lt;code&gt;runtime.main&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;runtime.newproc这个函数在创建普通的goroutine时也会使用, 在下面的&quot;go的实现&quot;中会详细讲解&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L1135&quot;&gt;runtime·mstart&lt;/a&gt;启动m0
&lt;ul&gt;&lt;li&gt;启动后m0会不断从运行队列获取G并运行, runtime.mstart调用后不会返回&lt;/li&gt;
&lt;li&gt;runtime.mstart这个函数是m的入口点(不仅仅是m0), 在下面的&quot;调度器的实现&quot;中会详细讲解&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一个被调度的G会运行&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L109&quot;&gt;runtime.main&lt;/a&gt;, 流程是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标记主函数已调用, 设置mainStarted = true&lt;/li&gt;
&lt;li&gt;启动一个新的M执行sysmon函数, 这个函数会监控全局的状态并对运行时间过长的G进行抢占&lt;/li&gt;
&lt;li&gt;要求G必须在当前M(系统主线程)上执行&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L233&quot;&gt;runtime_init&lt;/a&gt;函数&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/mgc.go#L214&quot;&gt;gcenable&lt;/a&gt;函数&lt;/li&gt;
&lt;li&gt;调用main.init函数, 如果函数存在&lt;/li&gt;
&lt;li&gt;不再要求G必须在当前M上运行&lt;/li&gt;
&lt;li&gt;如果程序是作为c的类库编译的, 在这里返回&lt;/li&gt;
&lt;li&gt;调用main.main函数&lt;/li&gt;
&lt;li&gt;如果当前发生了panic, 则等待panic处理&lt;/li&gt;
&lt;li&gt;调用exit(0)退出程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;G的定义&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/runtime2.go#L320&quot;&gt;在这里&lt;/a&gt;.&lt;br/&gt;M的定义&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/runtime2.go#L383&quot;&gt;在这里&lt;/a&gt;.&lt;br/&gt;P的定义&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/runtime2.go#L450&quot;&gt;在这里&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;G里面比较重要的成员如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;stack: 当前g使用的栈空间, 有lo和hi两个成员&lt;/li&gt;
&lt;li&gt;stackguard0: 检查栈空间是否足够的值, 低于这个值会扩张栈, 0是go代码使用的&lt;/li&gt;
&lt;li&gt;stackguard1: 检查栈空间是否足够的值, 低于这个值会扩张栈, 1是原生代码使用的&lt;/li&gt;
&lt;li&gt;m: 当前g对应的m&lt;/li&gt;
&lt;li&gt;sched: g的调度数据, 当g中断时会保存当前的pc和rsp等值到这里, 恢复运行时会使用这里的值&lt;/li&gt;
&lt;li&gt;atomicstatus: g的当前状态&lt;/li&gt;
&lt;li&gt;schedlink: 下一个g, 当g在链表结构中会使用&lt;/li&gt;
&lt;li&gt;preempt: g是否被抢占中&lt;/li&gt;
&lt;li&gt;lockedm: g是否要求要回到这个M执行, 有的时候g中断了恢复会要求使用原来的M执行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;M里面比较重要的成员如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;g0: 用于调度的特殊g, 调度和执行系统调用时会切换到这个g&lt;/li&gt;
&lt;li&gt;curg: 当前运行的g&lt;/li&gt;
&lt;li&gt;p: 当前拥有的P&lt;/li&gt;
&lt;li&gt;nextp: 唤醒M时, M会拥有这个P&lt;/li&gt;
&lt;li&gt;park: M休眠时使用的信号量, 唤醒M时会通过它唤醒&lt;/li&gt;
&lt;li&gt;schedlink: 下一个m, 当m在链表结构中会使用&lt;/li&gt;
&lt;li&gt;mcache: 分配内存时使用的本地分配器, 和p.mcache一样(拥有P时会复制过来)&lt;/li&gt;
&lt;li&gt;lockedg: lockedm的对应值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;P里面比较重要的成员如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;status: p的当前状态&lt;/li&gt;
&lt;li&gt;link: 下一个p, 当p在链表结构中会使用&lt;/li&gt;
&lt;li&gt;m: 拥有这个P的M&lt;/li&gt;
&lt;li&gt;mcache: 分配内存时使用的本地分配器&lt;/li&gt;
&lt;li&gt;runqhead: 本地运行队列的出队序号&lt;/li&gt;
&lt;li&gt;runqtail: 本地运行队列的入队序号&lt;/li&gt;
&lt;li&gt;runq: 本地运行队列的数组, 可以保存256个G&lt;/li&gt;
&lt;li&gt;gfree: G的自由列表, 保存变为_Gdead后可以复用的G实例&lt;/li&gt;
&lt;li&gt;gcBgMarkWorker: 后台GC的worker函数, 如果它存在M会优先执行它&lt;/li&gt;
&lt;li&gt;gcw: GC的本地工作队列, 详细将在下一篇(GC篇)分析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用go命令创建goroutine时, go会把go命令编译为对runtime.newproc的调用, 堆栈的结构如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/881857/201711/881857-20171110171409294-925311779.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一个参数是funcval + 额外参数的长度, 第二个参数是funcval, 后面的都是传递给goroutine中执行的函数的额外参数.&lt;br/&gt;funcval的定义&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/runtime2.go#L138&quot;&gt;在这里&lt;/a&gt;, fn是指向函数机器代码的指针.&lt;br/&gt;&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L2929&quot;&gt;runtime.newproc&lt;/a&gt;的处理如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;计算额外参数的地址argp&lt;/li&gt;
&lt;li&gt;获取调用端的地址(返回地址)pc&lt;/li&gt;
&lt;li&gt;使用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/asm_amd64.s#L301&quot;&gt;systemstack&lt;/a&gt;调用newproc1&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/asm_amd64.s#L301&quot;&gt;systemstack&lt;/a&gt;会切换当前的g到g0, 并且使用g0的栈空间, 然后调用传入的函数, 再切换回原来的g和原来的栈空间.&lt;br/&gt;切换到g0后会假装返回地址是mstart, 这样traceback的时候可以在mstart停止.&lt;br/&gt;这里传给systemstack的是一个闭包, 调用时会把闭包的地址放到寄存器rdx, 具体可以参考上面对闭包的分析.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L2941&quot;&gt;runtime.newproc1&lt;/a&gt;的处理如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用getg获取当前的g, 会编译为读取FS寄存器(TLS), 这里会获取到g0&lt;/li&gt;
&lt;li&gt;设置g对应的m的locks++, 禁止抢占&lt;/li&gt;
&lt;li&gt;获取m拥有的p&lt;/li&gt;
&lt;li&gt;新建一个g
&lt;ul&gt;&lt;li&gt;首先调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L3088&quot;&gt;gfget&lt;/a&gt;从p.gfree获取g, 如果之前有g被回收在这里就可以复用&lt;/li&gt;
&lt;li&gt;获取不到时调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L2909&quot;&gt;malg&lt;/a&gt;分配一个g, 初始的栈空间大小是2K&lt;/li&gt;
&lt;li&gt;需要先设置g的状态为已中止(_Gdead), 这样gc不会去扫描这个g的未初始化的栈&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;把参数复制到g的栈上&lt;/li&gt;
&lt;li&gt;把返回地址复制到g的栈上, 这里的返回地址是goexit, 表示调用完目标函数后会调用goexit&lt;/li&gt;
&lt;li&gt;设置g的调度数据(sched)
&lt;ul&gt;&lt;li&gt;设置sched.sp等于参数+返回地址后的rsp地址&lt;/li&gt;
&lt;li&gt;设置sched.pc等于目标函数的地址, 查看&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/stack.go#L1074&quot;&gt;gostartcallfn&lt;/a&gt;和&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/sys_x86.go#L16&quot;&gt;gostartcall&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;设置sched.g等于g&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;设置g的状态为待运行(_Grunnable)&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L4299&quot;&gt;runqput&lt;/a&gt;把g放到运行队列
&lt;ul&gt;&lt;li&gt;首先随机把g放到p.runnext, 如果放到runnext则入队原来在runnext的g&lt;/li&gt;
&lt;li&gt;然后尝试把g放到P的&quot;本地运行队列&quot;&lt;/li&gt;
&lt;li&gt;如果本地运行队列满了则调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L4334&quot;&gt;runqputslow&lt;/a&gt;把g放到&quot;全局运行队列&quot;
&lt;ul&gt;&lt;li&gt;runqputslow会把本地运行队列中一半的g放到全局运行队列, 这样下次就可以继续用快速的本地运行队列了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果当前有空闲的P, 但是无自旋的M(nmspinning等于0), 并且主函数已执行则唤醒或新建一个M&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;这一步非常重要, 用于保证当前有足够的M运行G, 具体请查看上面的&quot;空闲M链表&quot;&lt;/li&gt;
&lt;li&gt;唤醒或新建一个M会通过&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L1804&quot;&gt;wakep&lt;/a&gt;函数
&lt;ul&gt;&lt;li&gt;首先交换nmspinning到1, 成功再继续, 多个线程同时执行wakep只有一个会继续&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L1704&quot;&gt;startm&lt;/a&gt;函数
&lt;ul&gt;&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L4257&quot;&gt;pidleget&lt;/a&gt;从&quot;空闲P链表&quot;获取一个空闲的P&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L4156&quot;&gt;mget&lt;/a&gt;从&quot;空闲M链表&quot;获取一个空闲的M&lt;/li&gt;
&lt;li&gt;如果没有空闲的M, 则调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L1636&quot;&gt;newm&lt;/a&gt;新建一个M
&lt;ul&gt;&lt;li&gt;newm会新建一个m的实例, m的实例包含一个g0, 然后调用&lt;a href=&quot;http://www.cnblogs.com/zkweb/p/7815600.html&quot;&gt;newosproc&lt;/a&gt;动一个系统线程&lt;/li&gt;
&lt;li&gt;newosproc会调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/sys_linux_amd64.s#L443&quot;&gt;syscall clone&lt;/a&gt;创建一个新的线程&lt;/li&gt;
&lt;li&gt;线程创建后会设置TLS, 设置TLS中当前的g为g0, 然后执行mstart&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;调用notewakeup(&amp;amp;mp.park)唤醒线程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;创建goroutine的流程就这么多了, 接下来看看M是如何调度的.&lt;/p&gt;

&lt;p&gt;M启动时会调用mstart函数, m0在初始化后调用, 其他的的m在线程启动后调用.&lt;br/&gt;&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L1135&quot;&gt;mstart&lt;/a&gt;函数的处理如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用getg获取当前的g, 这里会获取到g0&lt;/li&gt;
&lt;li&gt;如果g未分配栈则从当前的栈空间(系统栈空间)上分配, 也就是说g0会使用系统栈空间&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L1155&quot;&gt;mstart1&lt;/a&gt;函数
&lt;ul&gt;&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/asm_amd64.s#L565&quot;&gt;gosave&lt;/a&gt;函数保存当前的状态到g0的调度数据中, 以后每次调度都会从这个栈地址开始&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/asm_amd64.s#L198&quot;&gt;asminit&lt;/a&gt;函数, 不做任何事情&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/os_linux.go#L311&quot;&gt;minit&lt;/a&gt;函数, 设置当前线程可以接收的信号(signal)&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L2205&quot;&gt;schedule&lt;/a&gt;函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;调用schedule函数后就进入了调度循环, 整个流程可以简单总结为:&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;schedule函数获取g =&amp;gt; [必要时休眠] =&amp;gt; [唤醒后继续获取] =&amp;gt; execute函数执行g =&amp;gt; 执行后返回到goexit =&amp;gt; 重新执行schedule函数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L2205&quot;&gt;schedule&lt;/a&gt;函数的处理如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果当前GC需要停止整个世界（STW), 则调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L1663&quot;&gt;stopm&lt;/a&gt;休眠当前的M&lt;/li&gt;
&lt;li&gt;如果M拥有的P中指定了需要在安全点运行的函数(P.runSafePointFn), 则运行它&lt;/li&gt;
&lt;li&gt;快速获取待运行的G, 以下处理如果有一个获取成功后面就不会继续获取
&lt;ul&gt;&lt;li&gt;如果当前GC正在标记阶段, 则查找有没有待运行的GC Worker, GC Worker也是一个G&lt;/li&gt;
&lt;li&gt;为了公平起见, 每61次调度从全局运行队列获取一次G, (一直从本地获取可能导致全局运行队列中的G不被运行)&lt;/li&gt;
&lt;li&gt;从P的本地运行队列中获取G, 调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L4374&quot;&gt;runqget&lt;/a&gt;函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;快速获取失败时, 调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L1929&quot;&gt;findrunnable&lt;/a&gt;函数获取待运行的G, 会阻塞到获取成功为止
&lt;ul&gt;&lt;li&gt;如果当前GC需要停止整个世界（STW), 则调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L1663&quot;&gt;stopm&lt;/a&gt;休眠当前的M&lt;/li&gt;
&lt;li&gt;如果M拥有的P中指定了需要在安全点运行的函数(P.runSafePointFn), 则运行它&lt;/li&gt;
&lt;li&gt;如果有析构器待运行则使用&quot;运行析构器的G&quot;&lt;/li&gt;
&lt;li&gt;从P的本地运行队列中获取G, 调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L4374&quot;&gt;runqget&lt;/a&gt;函数&lt;/li&gt;
&lt;li&gt;从全局运行队列获取G, 调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L4208&quot;&gt;globrunqget&lt;/a&gt;函数, 需要上锁&lt;/li&gt;
&lt;li&gt;从网络事件反应器获取G, 函数netpoll会获取哪些fd可读可写或已关闭, 然后返回等待fd相关事件的G&lt;/li&gt;
&lt;li&gt;如果获取不到G, 则执行&lt;a href=&quot;http://supertech.csail.mit.edu/papers/steal.pdf&quot;&gt;Work Stealing&lt;/a&gt;
&lt;ul&gt;&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L4455&quot;&gt;runqsteal&lt;/a&gt;尝试从其他P的本地运行队列盗取一半的G&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果还是获取不到G, 就需要休眠M了, 接下来是休眠的步骤
&lt;ul&gt;&lt;li&gt;再次检查当前GC是否在标记阶段, 在则查找有没有待运行的GC Worker, GC Worker也是一个G&lt;/li&gt;
&lt;li&gt;再次检查如果当前GC需要停止整个世界, 或者P指定了需要再安全点运行的函数, 则跳到findrunnable的顶部重试&lt;/li&gt;
&lt;li&gt;再次检查全局运行队列中是否有G, 有则获取并返回&lt;/li&gt;
&lt;li&gt;释放M拥有的P, P会变为空闲(_Pidle)状态&lt;/li&gt;
&lt;li&gt;把P添加到&quot;空闲P链表&quot;中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;让M离开自旋状态&lt;/strong&gt;, 这里的处理非常重要, 参考上面的&quot;空闲M链表&quot;&lt;/li&gt;
&lt;li&gt;首先减少表示当前自旋中的M的数量的全局变量nmspinning&lt;/li&gt;
&lt;li&gt;再次检查所有P的本地运行队列, 如果不为空则让M重新进入自旋状态, 并跳到findrunnable的顶部重试&lt;/li&gt;
&lt;li&gt;再次检查有没有待运行的GC Worker, 有则让M重新进入自旋状态, 并跳到findrunnable的顶部重试&lt;/li&gt;
&lt;li&gt;再次检查网络事件反应器是否有待运行的G, 这里对netpoll的调用会阻塞, 直到某个fd收到了事件&lt;/li&gt;
&lt;li&gt;如果最终还是获取不到G, 调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L1663&quot;&gt;stopm&lt;/a&gt;休眠当前的M&lt;/li&gt;
&lt;li&gt;唤醒后跳到findrunnable的顶部重试&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;成功获取到一个待运行的G&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;让M离开自旋状态&lt;/strong&gt;, 调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L2160&quot;&gt;resetspinning&lt;/a&gt;, 这里的处理和上面的不一样
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;如果当前有空闲的P, 但是无自旋的M(nmspinning等于0), 则唤醒或新建一个M&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;上面离开自旋状态是为了休眠M, 所以会再次检查所有队列然后休眠&lt;/li&gt;
&lt;li&gt;这里离开自选状态是为了执行G, 所以会检查是否有空闲的P, 有则表示可以再开新的M执行G&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果G要求回到指定的M(例如上面的runtime.main)
&lt;ul&gt;&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L1842&quot;&gt;startlockedm&lt;/a&gt;函数把G和P交给该M, 自己进入休眠&lt;/li&gt;
&lt;li&gt;从休眠唤醒后跳到schedule的顶部重试&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L2169&quot;&gt;execute&lt;/a&gt;函数执行G&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L2169&quot;&gt;execute&lt;/a&gt;函数的处理如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用getg获取当前的g&lt;/li&gt;
&lt;li&gt;把G的状态由待运行(_Grunnable)改为运行中(_Grunning)&lt;/li&gt;
&lt;li&gt;设置G的stackguard, 栈空间不足时可以扩张&lt;/li&gt;
&lt;li&gt;增加P中记录的调度次数(对应上面的每61次优先获取一次全局运行队列)&lt;/li&gt;
&lt;li&gt;设置g.m.curg = g&lt;/li&gt;
&lt;li&gt;设置g.m = m&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/asm_amd64.s#L228&quot;&gt;gogo&lt;/a&gt;函数
&lt;ul&gt;&lt;li&gt;这个函数会根据g.sched中保存的状态恢复各个寄存器的值并继续运行g&lt;/li&gt;
&lt;li&gt;首先针对g.sched.ctxt调用写屏障(GC标记指针存活), ctxt中一般会保存指向[函数+参数]的指针&lt;/li&gt;
&lt;li&gt;设置TLS中的g为g.sched.g, 也就是g自身&lt;/li&gt;
&lt;li&gt;设置rsp寄存器为g.sched.rsp&lt;/li&gt;
&lt;li&gt;设置rax寄存器为g.sched.ret&lt;/li&gt;
&lt;li&gt;设置rdx寄存器为g.sched.ctxt (上下文)&lt;/li&gt;
&lt;li&gt;设置rbp寄存器为g.sched.rbp&lt;/li&gt;
&lt;li&gt;清空sched中保存的信息&lt;/li&gt;
&lt;li&gt;跳转到g.sched.pc&lt;/li&gt;
&lt;li&gt;因为前面创建goroutine的newproc1函数把返回地址设为了goexit, 函数运行完毕返回时将会调用goexit函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;g.sched.pc在G首次运行时会指向目标函数的第一条机器指令,&lt;br/&gt;如果G被抢占或者等待资源而进入休眠, 在休眠前会保存状态到g.sched,&lt;br/&gt;g.sched.pc会变为唤醒后需要继续执行的地址, &quot;保存状态&quot;的实现将在下面讲解.&lt;/p&gt;
&lt;p&gt;目标函数执行完毕后会调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/asm_amd64.s#L2336&quot;&gt;goexit&lt;/a&gt;函数, goexit函数会调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L2643&quot;&gt;goexit1&lt;/a&gt;函数, goexit1函数会通过&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/asm_amd64.s#L261&quot;&gt;mcall&lt;/a&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L2654&quot;&gt;goexit0&lt;/a&gt;函数.&lt;br/&gt;&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/asm_amd64.s#L261&quot;&gt;mcall&lt;/a&gt;这个函数就是用于实现&quot;保存状态&quot;的, 处理如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置g.sched.pc等于当前的返回地址&lt;/li&gt;
&lt;li&gt;设置g.sched.sp等于寄存器rsp的值&lt;/li&gt;
&lt;li&gt;设置g.sched.g等于当前的g&lt;/li&gt;
&lt;li&gt;设置g.sched.bp等于寄存器rbp的值&lt;/li&gt;
&lt;li&gt;切换TLS中当前的g等于m.g0&lt;/li&gt;
&lt;li&gt;设置寄存器rsp等于g0.sched.sp, 使用g0的栈空间&lt;/li&gt;
&lt;li&gt;设置第一个参数为原来的g&lt;/li&gt;
&lt;li&gt;设置rdx寄存器为指向函数地址的指针(上下文)&lt;/li&gt;
&lt;li&gt;调用指定的函数, 不会返回&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;mcall这个函数保存当前的运行状态到g.sched, 然后切换到g0和g0的栈空间, 再调用指定的函数.&lt;br/&gt;回到g0的栈空间这个步骤非常重要, 因为这个时候g已经中断, 继续使用g的栈空间且其他M唤醒了这个g将会产生灾难性的后果.&lt;br/&gt;G在中断或者结束后都会通过mcall回到g0的栈空间继续调度, 从goexit调用的mcall的保存状态其实是多余的, 因为G已经结束了.&lt;/p&gt;
&lt;p&gt;goexit1函数会通过mcall调用goexit0函数, &lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L2654&quot;&gt;goexit0&lt;/a&gt;函数调用时已经回到了g0的栈空间, 处理如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把G的状态由运行中(_Grunning)改为已中止(_Gdead)&lt;/li&gt;
&lt;li&gt;清空G的成员&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L2560&quot;&gt;dropg&lt;/a&gt;函数解除M和G之间的关联&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L3346&quot;&gt;gfput&lt;/a&gt;函数把G放到P的自由列表中, 下次创建G时可以复用&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L2205&quot;&gt;schedule&lt;/a&gt;函数继续调度&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;G结束后回到schedule函数, 这样就结束了一个调度循环.&lt;br/&gt;不仅只有G结束会重新开始调度, G被抢占或者等待资源也会重新进行调度, 下面继续来看这两种情况.&lt;/p&gt;

&lt;p&gt;上面我提到了runtime.main会创建一个额外的M运行&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L4178&quot;&gt;sysmon&lt;/a&gt;函数, 抢占就是在sysmon中实现的.&lt;br/&gt;sysmon会进入一个无限循环, 第一轮回休眠20us, 之后每次休眠时间倍增, 最终每一轮都会休眠10ms.&lt;br/&gt;sysmon中有netpool(获取fd事件), retake(抢占), forcegc(按时间强制执行gc), scavenge heap(释放自由列表中多余的项减少内存占用)等处理.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L4306&quot;&gt;retake&lt;/a&gt;函数负责处理抢占, 流程是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;枚举所有的P
&lt;ul&gt;&lt;li&gt;如果P在系统调用中(_Psyscall), 且经过了一次sysmon循环(20us~10ms), 则抢占这个P
&lt;ul&gt;&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L2022&quot;&gt;handoffp&lt;/a&gt;解除M和P之间的关联&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果P在运行中(_Prunning), 且经过了一次sysmon循环并且G运行时间超过forcePreemptNS(10ms), 则抢占这个P
&lt;ul&gt;&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L4401&quot;&gt;preemptone&lt;/a&gt;函数
&lt;ul&gt;&lt;li&gt;设置g.preempt = true&lt;/li&gt;
&lt;li&gt;设置g.stackguard0 = stackPreempt&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么设置了stackguard就可以实现抢占?&lt;br/&gt;因为这个值用于检查当前栈空间是否足够, go函数的开头会比对这个值判断是否需要扩张栈.&lt;br/&gt;stackPreempt是一个特殊的常量, 它的值会比任何的栈地址都要大, 检查时一定会触发栈扩张.&lt;/p&gt;
&lt;p&gt;栈扩张调用的是&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/asm_amd64.s#L421&quot;&gt;morestack_noctxt&lt;/a&gt;函数, morestack_noctxt函数清空rdx寄存器并调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/asm_amd64.s#L373&quot;&gt;morestack&lt;/a&gt;函数.&lt;br/&gt;morestack函数会保存G的状态到g.sched, 切换到g0和g0的栈空间, 然后调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/stack.go#L922&quot;&gt;newstack&lt;/a&gt;函数.&lt;br/&gt;newstack函数判断g.stackguard0等于stackPreempt, 就知道这是抢占触发的, 这时会再检查一遍是否要抢占:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果M被锁定(函数的本地变量中有P), 则跳过这一次的抢占并调用gogo函数继续运行G&lt;/li&gt;
&lt;li&gt;如果M正在分配内存, 则跳过这一次的抢占并调用gogo函数继续运行G&lt;/li&gt;
&lt;li&gt;如果M设置了当前不能抢占, 则跳过这一次的抢占并调用gogo函数继续运行G&lt;/li&gt;
&lt;li&gt;如果M的状态不是运行中, 则跳过这一次的抢占并调用gogo函数继续运行G&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;即使这一次抢占失败, 因为g.preempt等于true, runtime中的一些代码会重新设置stackPreempt以重试下一次的抢占.&lt;br/&gt;如果判断可以抢占, 则继续判断是否GC引起的, 如果是则对G的栈空间执行标记处理(扫描根对象)然后继续运行,&lt;br/&gt;如果不是GC引起的则调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L2635&quot;&gt;gopreempt_m&lt;/a&gt;函数完成抢占.&lt;/p&gt;
&lt;p&gt;gopreempt_m函数会调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L2599&quot;&gt;goschedImpl&lt;/a&gt;函数, goschedImpl函数的流程是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把G的状态由运行中(_Grunnable)改为待运行(_Grunnable)&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L2560&quot;&gt;dropg&lt;/a&gt;函数解除M和G之间的关联&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L4532&quot;&gt;globrunqput&lt;/a&gt;把G放到全局运行队列&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L2205&quot;&gt;schedule&lt;/a&gt;函数继续调度&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为全局运行队列的优先度比较低, 各个M会经过一段时间再去重新获取这个G执行,&lt;br/&gt;抢占机制保证了不会有一个G长时间的运行导致其他G无法运行的情况发生.&lt;/p&gt;

&lt;p&gt;在goroutine运行的过程中, 有时候需要对资源进行等待, channel就是最典型的资源.&lt;br/&gt;channel的数据定义&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/chan.go#L31&quot;&gt;在这里&lt;/a&gt;, 其中关键的成员如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;qcount: 当前队列中的元素数量&lt;/li&gt;
&lt;li&gt;dataqsiz: 队列可以容纳的元素数量, 如果为0表示这个channel无缓冲区&lt;/li&gt;
&lt;li&gt;buf: 队列的缓冲区, 结构是环形队列&lt;/li&gt;
&lt;li&gt;elemsize: 元素的大小&lt;/li&gt;
&lt;li&gt;closed: 是否已关闭&lt;/li&gt;
&lt;li&gt;elemtype: 元素的类型, 判断是否调用写屏障时使用&lt;/li&gt;
&lt;li&gt;sendx: 发送元素的序号&lt;/li&gt;
&lt;li&gt;recvx: 接收元素的序号&lt;/li&gt;
&lt;li&gt;recvq: 当前等待从channel接收数据的G的链表(实际类型是sudog的链表)&lt;/li&gt;
&lt;li&gt;sendq: 当前等待发送数据到channel的G的链表(实际类型是sudog的链表)&lt;/li&gt;
&lt;li&gt;lock: 操作channel时使用的线程锁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;发送数据到channel实际调用的是&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/chan.go#L112&quot;&gt;runtime.chansend1&lt;/a&gt;函数, chansend1函数调用了&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/chan.go#L128&quot;&gt;chansend&lt;/a&gt;函数, 流程是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查channel.recvq是否有等待中的接收者的G
&lt;ul&gt;&lt;li&gt;如果有, 表示channel无缓冲区或者缓冲区为空&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/chan.go#L250&quot;&gt;send&lt;/a&gt;函数
&lt;ul&gt;&lt;li&gt;如果sudog.elem不等于nil, 调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/chan.go#L293&quot;&gt;sendDirect&lt;/a&gt;函数从发送者直接复制元素&lt;/li&gt;
&lt;li&gt;等待接收的sudog.elem是指向接收目标的内存的指针, 如果是接收目标是&lt;code&gt;_&lt;/code&gt;则elem是nil, 可以省略复制&lt;/li&gt;
&lt;li&gt;等待发送的sudog.elem是指向来源目标的内存的指针&lt;/li&gt;
&lt;li&gt;复制后调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L300&quot;&gt;goready&lt;/a&gt;恢复发送者的G
&lt;ul&gt;&lt;li&gt;切换到g0调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L584&quot;&gt;ready&lt;/a&gt;函数, 调用完切换回来
&lt;ul&gt;&lt;li&gt;把G的状态由等待中(_Gwaiting)改为待运行(_Grunnable)&lt;/li&gt;
&lt;li&gt;把G放到P的本地运行队列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果当前有空闲的P, 但是无自旋的M(nmspinning等于0), 则唤醒或新建一个M&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;从发送者拿到数据并唤醒了G后, 就可以从chansend返回了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;判断是否可以把元素放到缓冲区中
&lt;ul&gt;&lt;li&gt;如果缓冲区有空余的空间, 则把元素放到缓冲区并从chansend返回&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;无缓冲区或缓冲区已经写满, 发送者的G需要等待
&lt;ul&gt;&lt;li&gt;获取当前的g&lt;/li&gt;
&lt;li&gt;新建一个sudog&lt;/li&gt;
&lt;li&gt;设置sudog.elem = 指向发送内存的指针&lt;/li&gt;
&lt;li&gt;设置sudog.g = g&lt;/li&gt;
&lt;li&gt;设置sudog.c = channel&lt;/li&gt;
&lt;li&gt;设置g.waiting = sudog&lt;/li&gt;
&lt;li&gt;把sudog放入channel.sendq&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L296&quot;&gt;goparkunlock&lt;/a&gt;函数
&lt;ul&gt;&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L277&quot;&gt;gopark&lt;/a&gt;函数
&lt;ul&gt;&lt;li&gt;通过&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/asm_amd64.s#L261&quot;&gt;mcall&lt;/a&gt;函数调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L2573&quot;&gt;park_m&lt;/a&gt;函数
&lt;ul&gt;&lt;li&gt;mcall函数和上面说明的一样, 会把当前的状态保存到g.sched, 然后切换到g0和g0的栈空间并执行指定的函数&lt;/li&gt;
&lt;li&gt;park_m函数首先把G的状态从运行中(_Grunning)改为等待中(_Gwaiting)&lt;/li&gt;
&lt;li&gt;然后调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L2560&quot;&gt;dropg&lt;/a&gt;函数解除M和G之间的关联&lt;/li&gt;
&lt;li&gt;再调用传入的解锁函数, 这里的解锁函数会对解除channel.lock的锁定&lt;/li&gt;
&lt;li&gt;最后调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/proc.go#L2205&quot;&gt;schedule&lt;/a&gt;函数继续调度&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;从这里恢复表示已经成功发送或者channel已关闭
&lt;ul&gt;&lt;li&gt;检查sudog.param是否为nil, 如果为nil表示channel已关闭, 抛出panic&lt;/li&gt;
&lt;li&gt;否则释放sudog然后返回&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从channel接收数据实际调用的是&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/chan.go#L387&quot;&gt;runtime.chanrecv1&lt;/a&gt;函数, chanrecv1函数调用了&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/chan.go#L403&quot;&gt;chanrecv&lt;/a&gt;函数, 流程是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查channel.sendq中是否有等待中的发送者的G
&lt;ul&gt;&lt;li&gt;如果有, 表示channel无缓冲区或者缓冲区已满, 这两种情况需要分别处理(为了保证入出队顺序一致)&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/chan.go#L536&quot;&gt;recv&lt;/a&gt;函数
&lt;ul&gt;&lt;li&gt;如果无缓冲区, 调用&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/chan.go#L304&quot;&gt;recvDirect&lt;/a&gt;函数把元素直接复制给接收者&lt;/li&gt;
&lt;li&gt;如果有缓冲区代表缓冲区已满
&lt;ul&gt;&lt;li&gt;把队列中下一个要出队的元素直接复制给接收者&lt;/li&gt;
&lt;li&gt;把发送的元素复制到队列中刚才出队的位置&lt;/li&gt;
&lt;li&gt;这时候缓冲区仍然是满的, 但是发送序号和接收序号都会增加1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;复制后调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L300&quot;&gt;goready&lt;/a&gt;恢复接收者的G, 处理同上&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;把数据交给接收者并唤醒了G后, 就可以从chanrecv返回了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;判断是否可以从缓冲区获取元素
&lt;ul&gt;&lt;li&gt;如果缓冲区有元素, 则直接取出该元素并从chanrecv返回&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;无缓冲区或缓冲区无元素, 接收者的G需要等待
&lt;ul&gt;&lt;li&gt;获取当前的g&lt;/li&gt;
&lt;li&gt;新建一个sudog&lt;/li&gt;
&lt;li&gt;设置sudog.elem = 指向接收内存的指针&lt;/li&gt;
&lt;li&gt;设置sudog.g = g&lt;/li&gt;
&lt;li&gt;设置sudog.c = channel&lt;/li&gt;
&lt;li&gt;设置g.waiting = sudog&lt;/li&gt;
&lt;li&gt;把sudog放入channel.recvq&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L296&quot;&gt;goparkunlock&lt;/a&gt;函数, 处理同上&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;从这里恢复表示已经成功接收或者channel已关闭
&lt;ul&gt;&lt;li&gt;检查sudog.param是否为nil, 如果为nil表示channel已关闭&lt;/li&gt;
&lt;li&gt;和发送不一样的是接收不会抛panic, 会通过返回值通知channel已关闭&lt;/li&gt;
&lt;li&gt;释放sudog然后返回&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关闭channel实际调用的是&lt;a href=&quot;https://github.com/golang/go/blob/go1.9.2/src/runtime/chan.go#L313&quot;&gt;closechan&lt;/a&gt;函数, 流程是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设置channel.closed = 1&lt;/li&gt;
&lt;li&gt;枚举channel.recvq, 清零它们sudog.elem, 设置sudog.param = nil&lt;/li&gt;
&lt;li&gt;枚举channel.sendq, 设置sudog.elem = nil, 设置sudog.param = nil&lt;/li&gt;
&lt;li&gt;调用&lt;a href=&quot;https://github.com/golang/go/blob/master/src/runtime/proc.go#L300&quot;&gt;goready&lt;/a&gt;函数恢复所有接收者和发送者的G&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以看到如果G需要等待资源时,&lt;br/&gt;会记录G的运行状态到g.sched, 然后把状态改为等待中(_Gwaiting), 再让当前的M继续运行其他G.&lt;br/&gt;等待中的G保存在哪里, 什么时候恢复是等待的资源决定的, 上面对channel的等待会让G放到channel中的链表.&lt;/p&gt;
&lt;p&gt;对网络资源的等待可以看netpoll相关的处理, netpoll在不同系统中的处理都不一样, 有兴趣的可以自己看看.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go&quot; class=&quot;uri&quot;&gt;https://github.com/golang/go&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://golang.org/s/go11sched&quot; class=&quot;uri&quot;&gt;https://golang.org/s/go11sched&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://supertech.csail.mit.edu/papers/steal.pdf&quot; class=&quot;uri&quot;&gt;http://supertech.csail.mit.edu/papers/steal.pdf&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit#heading=h.x4kziklnb8fr&quot; class=&quot;uri&quot;&gt;https://docs.google.com/document/d/1ETuA2IOmnaQ4j81AtTGT40Y4_Jr6_IDASEKg0t0dBR8/edit#heading=h.x4kziklnb8fr&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.altoros.com/golang-part-1-main-concepts-and-project-structure.html&quot; class=&quot;uri&quot;&gt;https://blog.altoros.com/golang-part-1-main-concepts-and-project-structure.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.altoros.com/golang-internals-part-2-diving-into-the-go-compiler.html&quot; class=&quot;uri&quot;&gt;https://blog.altoros.com/golang-internals-part-2-diving-into-the-go-compiler.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.altoros.com/golang-internals-part-3-the-linker-and-object-files.html&quot; class=&quot;uri&quot;&gt;https://blog.altoros.com/golang-internals-part-3-the-linker-and-object-files.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.altoros.com/golang-part-4-object-files-and-function-metadata.html&quot; class=&quot;uri&quot;&gt;https://blog.altoros.com/golang-part-4-object-files-and-function-metadata.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.altoros.com/golang-internals-part-5-runtime-bootstrap-process.html&quot; class=&quot;uri&quot;&gt;https://blog.altoros.com/golang-internals-part-5-runtime-bootstrap-process.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.altoros.com/golang-internals-part-6-bootstrapping-and-memory-allocator-initialization.html&quot; class=&quot;uri&quot;&gt;https://blog.altoros.com/golang-internals-part-6-bootstrapping-and-memory-allocator-initialization.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64&quot; class=&quot;uri&quot;&gt;http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://legendtkl.com/categories/golang&quot; class=&quot;uri&quot;&gt;http://legendtkl.com/categories/golang&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/diegodu/p/5803202.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/diegodu/p/5803202.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.douban.com/note/300631999/&quot; class=&quot;uri&quot;&gt;https://www.douban.com/note/300631999/&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://morsmachine.dk/go-scheduler&quot; class=&quot;uri&quot;&gt;http://morsmachine.dk/go-scheduler&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;legendtkl很早就已经开始写golang内部实现相关的文章了, 他的文章很有参考价值, 建议同时阅读他写的内容.&lt;br/&gt;morsmachine写的针对协程的分析也建议参考.&lt;br/&gt;golang中的协程实现非常的清晰, 在这里要再次佩服google工程师的功力, 可以写出这样简单易懂的代码不容易.&lt;/p&gt;
</description>
<pubDate>Fri, 10 Nov 2017 09:23:00 +0000</pubDate>
<dc:creator>q303248153</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zkweb/p/7815600.html</dc:identifier>
</item>
</channel>
</rss>