<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>排序算法杂谈（五） —— 关于快速排序的优化策略分析 - Gerrard_Feng</title>
<link>http://www.cnblogs.com/jing-an-feng-shao/p/9865644.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jing-an-feng-shao/p/9865644.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;1. 前提&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jing-an-feng-shao/p/9038915.html&quot; target=&quot;_blank&quot;&gt;排序算法（六） —— 归并排序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jing-an-feng-shao/p/9069091.html&quot; target=&quot;_blank&quot;&gt;排序算法（七） —— 快速排序&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jing-an-feng-shao/p/9118376.html&quot; target=&quot;_blank&quot;&gt;排序算法杂谈（四） —— 快速排序的非递归实现&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;2. 优化策略1：主元（Pivot）的选取&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;归并排序（Merge Sort）有一个很大的优势，就是每一次的递归都能够将数组平均二分，从而大大减少了总递归的次数。&lt;/p&gt;
&lt;p&gt;而快速排序（Quick Sort）在这一点上就做的很不好。&lt;/p&gt;
&lt;p&gt;快速排序是通过选择一个主元，将整个数组划分（Partition）成两个部分，小于等于主元 and 大于等于主元。&lt;/p&gt;
&lt;p&gt;这个过程对于数组的划分完全就是随机的，俗称看脸吃饭。&lt;/p&gt;
&lt;p&gt;这个划分是越接近平均二分，那么这个划分就越是优秀；而若果不巧取到了数组的最大值或是最小值，那这次划分其实和没做没有什么区别。&lt;/p&gt;

&lt;p&gt;因此，主元的选取，直接决定了一个快速排序的效率。&lt;/p&gt;
&lt;p&gt;通过之前快速排序的学习，我们知道了基本上有两种主流的划分方式，我将其称之为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;挖坑取数&lt;/li&gt;
&lt;li&gt;快慢指针&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前者将最左侧的数作为主元，后者将最右侧的数作为主元，这种行为完全就是随机取数。&lt;/p&gt;

&lt;p&gt;最简单的的方法，就是在范围内取一个随机数，但是这种方法从概率的角度上来说，和之前的没有区别。&lt;/p&gt;
&lt;p&gt;进一步的思考，可以从范围内随机取出三个数字，找到三个数字的中位数，然后和原主元的位置进行交换。&lt;/p&gt;
&lt;p&gt;将中位数作为主元，相比于随机取出的另外两个数字，对于划分的影响还是很明显的。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gerrard.sort.compare.quick.partition.pivot;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.gerrard.util.RandomHelper;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MediumPivot &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Pivot {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getPivotIndex(&lt;span&gt;int&lt;/span&gt;[] array, &lt;span&gt;int&lt;/span&gt; left, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; right) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; index1 =&lt;span&gt; RandomHelper.randomBetween(left, right);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; index2 =&lt;span&gt; RandomHelper.randomBetween(left, right);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; index3 =&lt;span&gt; RandomHelper.randomBetween(left, right);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (array[index1] &amp;gt;&lt;span&gt; array[index2]) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (array[index2] &amp;gt;&lt;span&gt; array[index3]) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; index2;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; array[index1] &amp;gt; array[index3] ?&lt;span&gt; index3 : index1;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (array[index1] &amp;gt;&lt;span&gt; array[index3]) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; index3;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; array[index2] &amp;gt; array[index3] ?&lt;span&gt; index3 : index2;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;3. 优化策略2：阈值的选取&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同样是参考归并排序的优化策略，归并排序可以通过判断数组的长度，设定一个阈值。&lt;/p&gt;
&lt;p&gt;数组长度大于阈值的，使用归并排序策略。&lt;/p&gt;
&lt;p&gt;数组长度小于阈值的，使用直接插入排序。&lt;/p&gt;
&lt;p&gt;通过这种方式，归并排序避免了针对小数组时候的递归（递归层次增加最多的场景，就是大量的小数组），从而减轻了JVM的负担。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; OptimizedQuickSort &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Sort {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; ThreeWayPartition partitionSolution = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreeWayPartition();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; threshold = 2 &amp;lt;&amp;lt; 4&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPartitionSolution(ThreeWayPartition partitionSolution) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.partitionSolution =&lt;span&gt; partitionSolution;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setThreshold(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; threshold) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.threshold =&lt;span&gt; threshold;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sort(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         sort(array, 0, array.length - 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; sort(&lt;span&gt;int&lt;/span&gt;[] array, &lt;span&gt;int&lt;/span&gt; left, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; right) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (right - left &amp;lt;&lt;span&gt; threshold) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            insertionSort(array, left, right);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (left &amp;lt;&lt;span&gt; right) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;[] partitions =&lt;span&gt; partitionSolution.partition(array, left, right);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             sort(array, left, partitions[0] - 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             sort(array, partitions[1] + 1&lt;span&gt;, right);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insertionSort(&lt;span&gt;int&lt;/span&gt;[] array, &lt;span&gt;int&lt;/span&gt; startIndex, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; endIndex) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = startIndex + 1; i &amp;lt;= endIndex; ++&lt;span&gt;i) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; cur =&lt;span&gt; array[i];
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = i - 1; j &amp;gt; -1; --&lt;span&gt;j) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (cur &amp;lt;&lt;span&gt; array[j]) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                     array[j + 1] =&lt;span&gt; array[j];
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                     array[j + 1] =&lt;span&gt; cur;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     flag = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;flag) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 array[0] =&lt;span&gt; cur;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;4. 优化策略3：三路划分&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从上面的代码中，我们可以看到一个 ThreeWayPartition，这就是现在要讲的三路划分。&lt;/p&gt;
&lt;p&gt;回顾之前的快速排序划分的描述：&lt;/p&gt;
&lt;p&gt;快速排序是通过选择一个主元，将整个数组划分成两个部分，小于等于主元 and 大于等于主元。&lt;/p&gt;

&lt;p&gt;不难发现，一次划分之后，我们将原数组划分成了三个部分，小于等于主元 and 主元 and 大于等于主元，划分结束之后，再将主元两侧进行递归。&lt;/p&gt;
&lt;p&gt;由此可见，等于主元的部分被划分到了三个部分，那么我们就有了这样的思考：&lt;/p&gt;
&lt;p&gt;能不能将数组明确地划分成三个部分：小于主元 and 主元和等于主元 and 大于主元。&lt;/p&gt;
&lt;p&gt;这样一来，等于主元的部分就直接从下一次的递归中去除了。&lt;/p&gt;

&lt;p&gt;回看一下 “挖坑取数” 的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; partition(&lt;span&gt;int&lt;/span&gt;[] array, &lt;span&gt;int&lt;/span&gt; left, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; right) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; pivot =&lt;span&gt; array[left];
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; left;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; j = right + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; forward = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (i &amp;lt;&lt;span&gt; j) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (forward &amp;amp;&amp;amp; array[++i] &amp;lt;= pivot &amp;amp;&amp;amp; i &amp;lt;&lt;span&gt; j) ;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (!forward &amp;amp;&amp;amp; array[--j] &amp;gt;= pivot &amp;amp;&amp;amp; i &amp;lt;&lt;span&gt; j) ;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            ArrayHelper.swap(array, i, j);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             forward ^= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在内循环中，我们的判断条件是： array[++i] &amp;lt;= pivot。&lt;/p&gt;
&lt;p&gt;在这个基础上，再做一次判断，针对等于 pivot 的情况，将等于 pivot 的值，与一个已经遍历过的位置交换：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从左往右找大于 pivot 的值时，与数组开头部分交换。&lt;/li&gt;
&lt;li&gt;从右往左找小于 pivot 的值时，与数组结束部分交换。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么，在整个划分结束之后，我们会得到这么一个数据模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/941490/201810/941490-20181028143957704-39931165.png&quot; alt=&quot;&quot; width=&quot;861&quot; height=&quot;111&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;等于 pivot：[left,p) &amp;amp; i &amp;amp; (q,right]&lt;/li&gt;
&lt;li&gt;小于 pivot：[p,i)&lt;/li&gt;
&lt;li&gt;大于 pivot：(j,q]&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后将 left-&amp;gt;p 的数据依次交换到 i 的左侧，同理，将q-&amp;gt;right 的数据依次交换到 j 的右侧。&lt;/p&gt;
&lt;p&gt;这样我们就能得到整个数组关于 pivot 的严格大小关系：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;等于 pivot：[p',q']&lt;/li&gt;
&lt;li&gt;小于 pivot：[left,p')&lt;/li&gt;
&lt;li&gt;大于 pivot：(q',right]&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;71&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gerrard.sort.compare.quick.partition;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.gerrard.sort.compare.quick.partition.pivot.Pivot;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.gerrard.util.ArrayHelper;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt; * Three-Way-partition is an optimized solution for partition, also with complexity O(n).
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt; * It directly separate the original array into three parts: smaller than pivot, equal to pivot, larger than pivot.
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt; * It extends {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; SandwichPartition} solution.
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt; * Step1: Select the left one as pivot.
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt; * Step2: Besides i and j, define two more index p and q as two sides index.
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt; * Step3: Work as SandwichPartition, from sides-&amp;gt;middle, the only difference is:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt; *        when meeting equal to pivot scenario, swap i and p or j and q.
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt; * Step4: After iterator ends, the array should look like:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt; *        left                   i=j                     right
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt; *        ---------------------------------------------------
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt; *        |     |           |     |     |               |   |
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt; *        ---------------------------------------------------
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt; *              p           p'          q'              q
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt; *        The distance between left-&amp;gt;p and p'-&amp;gt;i should be same.
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt; *        The distance between j-&amp;gt;q' and q-&amp;gt;right should also be same.
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt; *        [left,p) and (q,right] is equal to pivot, [p,i) is smaller than pivot, (j,q] is larger than pivot.
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt; * Step5: Exchange [left,p) and [p',i), exchange (q,right] and (j,q'].
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt; * Step6: Returns two number p'-1 and q'+1.
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThreeWayPartition {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] partition(&lt;span&gt;int&lt;/span&gt;[] array, &lt;span&gt;int&lt;/span&gt; left, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; right) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (pivotSolution != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; newPivot =&lt;span&gt; pivotSolution.getPivotIndex(array, left, right);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            ArrayHelper.swap(array, left, newPivot);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; pivot =&lt;span&gt; array[left];
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt; left;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; j = right + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; p =&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; q = j - 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; forward = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (i &amp;lt;&lt;span&gt; j) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (forward &amp;amp;&amp;amp; array[++i] &amp;lt;= pivot &amp;amp;&amp;amp; i &amp;lt;&lt;span&gt; j) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (array[i] ==&lt;span&gt; pivot) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                     ArrayHelper.swap(array, i, p++&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; (!forward &amp;amp;&amp;amp; array[--j] &amp;gt;= pivot &amp;amp;&amp;amp; i &amp;lt;&lt;span&gt; j) {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (array[j] ==&lt;span&gt; pivot) {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                     ArrayHelper.swap(array, j, q--&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;            ArrayHelper.swap(array, i, j);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             forward ^= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (p &amp;gt;&lt;span&gt; left) {
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             ArrayHelper.swap(array, --p, --&lt;span&gt;i);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (q &amp;lt;&lt;span&gt; right) {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;             ArrayHelper.swap(array, ++q, ++&lt;span&gt;j);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[]{i, j};
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;span&gt;5. 优化测试&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最后，针对各种快速排序的算法，我做了一系列的性能测试：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.gerrard.helper;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.gerrard.sort.Sort;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ComparableTestHelper {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ComparableTestHelper() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; printCompareResult(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array, Sort... sorts) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Sort sort : sorts) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt;[] copyArray =&lt;span&gt; ArrayTestHelper.copyArray(array);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; t1 =&lt;span&gt; System.nanoTime();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            sort.sort(copyArray);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;long&lt;/span&gt; t2 =&lt;span&gt; System.nanoTime();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;double&lt;/span&gt; timeInSeconds = (t2 - t1) / Math.pow(10, 9&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             System.out.println(&quot;Algorithm &quot; + sort + &quot;, using &quot; + timeInSeconds + &quot; seconds&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/941490/201810/941490-20181028144928684-1407887910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 从测试结果中，我们可以发现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;取原来的主元，和用随机数做主元，对于性能的影响完全是随机的。&lt;/li&gt;
&lt;li&gt;取中位数做主元，对于性能有着比较明显的提高。&lt;/li&gt;
&lt;li&gt;增加阈值，对于性能也有提高，但是阈值选取的数值，还有待深一步的研究。&lt;/li&gt;
&lt;li&gt;三路快排，在数组区间较小的情况，对于性能的影响是显著的，但是数组区间较大时，对于性能有一定的影响。&lt;/li&gt;
&lt;li&gt;递归转迭代的方式，能规避StackOverFlow的情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是还有几个比较奇怪的现象：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;快速排序，对于数组内部有很多数字相等的情况，处理情况不佳。&lt;/li&gt;
&lt;li&gt;快慢指针的方式，对于数字相等的情况，效率降低明显。&lt;/li&gt;
&lt;li&gt;挖坑填数的方式，比快慢指针的方式，更容易出现StackOverFlow的情况，而快慢指针似乎通过了某种时间为代价的方式，规避了这种情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;希望有读者能够解惑这些现象。&lt;/p&gt;

</description>
<pubDate>Sun, 28 Oct 2018 07:01:00 +0000</pubDate>
<dc:creator>Gerrard_Feng</dc:creator>
<og:description>1. 前提 排序算法（六） —— 归并排序 排序算法（七） —— 快速排序 排序算法杂谈（四） —— 快速排序的非递归实现 2. 优化策略1：主元（Pivot）的选取 归并排序（Merge Sort）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jing-an-feng-shao/p/9865644.html</dc:identifier>
</item>
<item>
<title>sql server  错误日志errorlog - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/9862799.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/9862799.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一 .概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　SQL Server 将某些系统事件和用户定义事件记录到 SQL Server 错误日志和 Microsoft Windows 应用程序日志中。 这两种日志都会自动给所有记录事件加上时间戳。 使用 SQL Server 错误日志中的信息可以解决SQL Server的相关问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　查看 SQL Server 错误日志可以确保进程（例如，备份和还原操作、批处理命令或其他脚本和进程）成功完成。 此功能可用于帮助检测任何当前或潜在的问题领域，包括自动恢复消息（尤其是在 SQL Server 实例已停止并重新启动时）、内核消息或其他服务器级错误消息。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　&lt;span&gt;使用 SQL Server 或任何文本编辑器可以查看 SQL Server Management Studio 错误日志。默认情况下，错误日志位于 &lt;code&gt;Program Files\Microsoft SQL Server\MSSQL.&lt;/code&gt;&lt;em&gt;n&lt;/em&gt;&lt;code&gt;\MSSQL\LOG\ERRORLOG&lt;/code&gt; 和 &lt;code&gt;ERRORLOG.&lt;/code&gt;&lt;em&gt;n&lt;/em&gt; 文件中。例如: 我电脑win7上将sql server 2008 r2数据库安装在D:\Program Files目录下,错误日志路径为 D:\Program Files\Microsoft SQL Server\MSSQL10_50.MSSQLSERVER\MSSQL\Log&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;每当启动 SQL Server 实例时，将创建新的错误日志信息，sqlserver系统自动调用 exec sp_cycle_errorlog 系统存储过程，该存储过程会关闭当前的错误日志文件，并循环错误日志扩展编号来循环使用错误日志文件，而不必重新启动 SQL Server实例 (区别mysql下 有四种日志文件，文件会一直增长，需要管理员去清除，避免影响磁盘空间) 。通常， SQL Server 保留前六个日志的备份, 按照时间顺序，依次用文件扩展名.1 .2…  .6表示。每重启一次服务，文件扩展名都会加一, 最早那份会被删除。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二. Errorlog日志内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;2.1  日志自动记录的信息大概有如下：&lt;/p&gt;
&lt;p&gt;   (1) SQL SERVER 的启动参数，以及认证模式，内存分配模式。&lt;/p&gt;
&lt;p&gt;   (2) 每个数据库是否能够被正常打开。如果不能，原因是什么?&lt;/p&gt;
&lt;p&gt;   (3) 数据库损坏相关的错误&lt;/p&gt;
&lt;p&gt;   (4) 数据库备份与恢复动作记录&lt;/p&gt;
&lt;p&gt;   (5) DBCC CHECKDB记录&lt;/p&gt;
&lt;p&gt;   (6) 内存相关的错误和警告&lt;/p&gt;
&lt;p&gt;   (7) SQL调度出现异常时的警告。一般SERVER Hang 服务器死机会伴随着有这些警告&lt;/p&gt;
&lt;p&gt;   (8) SQL I/O操作遇到长时间延迟的警告&lt;/p&gt;
&lt;p&gt;   (9) SQL在运行过程中遇到的其他级别比较高的错误&lt;/p&gt;
&lt;p&gt;   (10) SQL内部的访问越界错误（Access Violation）&lt;/p&gt;
&lt;p&gt;   (11) SQL服务关闭时间&lt;/p&gt;
&lt;p&gt;   (12) SQL SERVER版本，以及windows和processor基本信息。&lt;/p&gt;
&lt;p&gt;　　2.2  日志开启跟踪能看到的信息&lt;/p&gt;
&lt;p&gt;   (1) 所有用户成功或失败的登入&lt;/p&gt;
&lt;p&gt;   (2) 死锁及其参与者的信息。跟踪标志1222 或1204&lt;/p&gt;
&lt;p&gt;　　2.3 日志不能记录的问题&lt;/p&gt;
&lt;p&gt;   (1) 阻塞问题。只要阻塞还没有严重到影响线程调度，日志里是不会体现的。&lt;/p&gt;
&lt;p&gt;   (2) 普通性能问题,超时问题。&lt;/p&gt;
&lt;p&gt;   (3) windows层面异常。&lt;/p&gt;
&lt;p&gt; 　　所以在检查&lt;span lang=&quot;EN-US&quot;&gt;sqlserver 相关问题的时候，总是从&lt;span lang=&quot;EN-US&quot;&gt;error log着手，如果&lt;span lang=&quot;EN-US&quot;&gt;error log里有一些错误或警告，就要确认排查，如果记录问题的时间与软件系统出问题时间对得上，就需要着重分析。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三 &lt;span lang=&quot;EN-US&quot;&gt;.跟踪标志&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　&lt;/span&gt;&lt;/strong&gt;使用DBCC TRACEON来指定要打开的跟踪标记的编号，跟踪标记用于通过控制 SQL Server 的运行方式来自定义某些特征。 启用的跟踪标记将在服务器中一直保持启用状态，直到执行 DBCC TRACEOFF 语句将其禁用为止。在 SQL Server 中，有两种跟踪标志：会话和全局。 会话跟踪标志对某个连接是有效的，只对该连接可见。 全局跟踪标志在服务器级别上进行设置，对服务器上的每一个连接都可见。 若要确定跟踪标记的状态，请使用 DBCC TRACESTATUS。 若要禁用跟踪标记，请使用 DBCC TRACEOFF。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 下面示例是记录死锁，跟踪标志1222 或1204, 脚本如下所示：&lt;/span&gt;
 &lt;span&gt;--&lt;/span&gt;&lt;span&gt;指定打开当前会话的跟踪标志1222 或1204&lt;/span&gt;
&lt;span&gt;DBCC&lt;/span&gt; TRACEON (&lt;span&gt;1222&lt;/span&gt;,&lt;span&gt;1204&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;以全局方式打开跟踪标志1222 或1204&lt;/span&gt;
&lt;span&gt;DBCC&lt;/span&gt; TRACEON (&lt;span&gt;1222&lt;/span&gt;,&lt;span&gt;1204&lt;/span&gt;, &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 查看跟踪标志状态,如下图所示&lt;/span&gt;
&lt;span&gt;DBCC&lt;/span&gt; TRACESTATUS
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201810/151560-20181027191859705-357559694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 以全局方式关闭跟踪标志状态&lt;/span&gt;
 &lt;span&gt;DBCC&lt;/span&gt; TRACEOFF(&lt;span&gt;1222&lt;/span&gt;,&lt;span&gt;1204&lt;/span&gt;, &lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其它跟踪标志号可参考官方文档：&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://docs.microsoft.com/zh-cn/sql/t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql?view=sql-server-2017&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/sql/t-sql/database-console-commands/dbcc-traceon-trace-flags-transact-sql?view=sql-server-2017&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;四&lt;span lang=&quot;EN-US&quot;&gt;. 配置&lt;span lang=&quot;EN-US&quot;&gt;errorlog&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;在对象资源管理器中，展开 SQL Server 的实例，展开“管理”，右键单击“SQL Server 日志”，再单击“配置” 如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201810/151560-20181027192038810-130461839.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　4.1 限制错误日志文件在回收之前的数目&lt;br/&gt;　　　　若选中此选项，将限制在错误日志回收前可以创建的错误日志数。 每次启动 SQL Server 实例时都将创建新的错误日志。 SQL Server 将保留前六个日志的备份，除非选中此选项并在下面指定一个不同的最大错误日志文件数。&lt;/p&gt;
&lt;p&gt;　　4.2  最大错误日志文件数&lt;/p&gt;
&lt;p&gt;　　　　指定错误日志文件回收前创建的最大错误日志文件数。&lt;span lang=&quot;EN-US&quot;&gt; 默认值为 &lt;span lang=&quot;EN-US&quot;&gt;6，即&lt;span lang=&quot;EN-US&quot;&gt; SQL Server 在回收备份日志前保留的以前备份日志的数量。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五&lt;span lang=&quot;EN-US&quot;&gt;. SQL Server 代理错误日志&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201810/151560-20181027192142496-1814938183.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　SQL Server 默认情况下，代理创建错误日志来记录警告和错误。 SQL Server 最多可以维护九个 SQL Server 代理错误日志。 每个存档日志都有一个扩展名，指示该日志的相对存在时间。 例如上图，当前表示最新的存档错误日志，而编号1 表示最旧的存档错误日志。&lt;/p&gt;
&lt;p&gt;　　默认情况下，执行跟踪消息不写入 SQL Server 代理日志错误，因为它们会将日志填满。 如果错误日志已满，会降低选择和分析更严重的错误的能力。 因为日志会增加服务器的处理负荷，所以请务必仔细考虑是否值得将执行跟踪消息捕获到错误日志中。 &lt;strong&gt;通常，最好仅在调试某个特定问题时捕获所有消息&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;六.查看errorlog&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Errorlog 文件以文本方式记录，用任何文件编辑器都能打开。下面介绍二个存储过程来过滤查看日志文件。&lt;/p&gt;
&lt;p&gt;　　6.1  xp_enumerrorlogs&lt;/p&gt;
&lt;p&gt;　　　　通过xp_enumerrorlogs可以查看错误日志文件的存档和占用空间大小， 默认参数是1, 表示查看sql server日志。 参数2 表示查看sql server 代理错误日志列表。脚本如下所示:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;--&lt;/span&gt;&lt;span&gt;  查看sql server日志列表&lt;/span&gt;
&lt;span&gt;EXEC&lt;/span&gt; xp_enumerrorlogs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201810/151560-20181028140942198-1345135092.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 查看代理错误日志&lt;/span&gt;
   &lt;span&gt;EXEC&lt;/span&gt; xp_enumerrorlogs &lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201810/151560-20181028141005392-858216693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　6.2 xp_readerrorlog&lt;/p&gt;
&lt;p&gt;通过系统存储过程：xp_readerrorlog,能条件过滤日志内容查看，它一共有7个参数，分别是：&lt;br/&gt;(1). 存档编号（0~99）&lt;/p&gt;
&lt;p&gt;(2). 日志类型（1为SQL Server日志，2为SQL Server Agent日志）&lt;/p&gt;
&lt;p&gt;(3). 查询包含的字符串&lt;/p&gt;
&lt;p&gt;(4). 查询包含的字符串&lt;/p&gt;
&lt;p&gt;(5). LogDate开始时间&lt;/p&gt;
&lt;p&gt;(6). LogDate结束时间&lt;/p&gt;
&lt;p&gt;(7). 结果排序，按LogDate排序（Desc、Asc）&lt;/p&gt;
&lt;p&gt;　　　　例1 ：查看当前sql server错误日志文件内容。存档编号默认值是0，日志类型默认是1，如果要查看当前sql server错误日志文件内容有三种写法,脚本如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;EXEC&lt;/span&gt;&lt;span&gt; xp_readerrorlog
&lt;/span&gt;&lt;span&gt;EXEC&lt;/span&gt; xp_readerrorlog &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;EXEC&lt;/span&gt; xp_readerrorlog &lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　例 2：查看SQL Server日志历史存档为编号1的文件中，发生的时间为2018-10-27 19:00点 至2018-10-27 20:00之间的错误，排序方式为时间的倒排序，为了满足上面的要求,脚本如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;EXEC&lt;/span&gt; xp_readerrorlog &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-10-27 19:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018-10-27 20:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DESC&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　例3： 查看当前SQL Server日志文件中，错误内容里面包含字符串：“Login failed for user 'sa'”  的错误,脚本如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;EXEC&lt;/span&gt; xp_readerrorlog &lt;span&gt;0&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Login failed for user &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;sa&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 28 Oct 2018 06:28:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一 .概述 SQL Server 将某些系统事件和用户定义事件记录到 SQL Server 错误日志和 Microsoft Windows 应用程序日</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/9862799.html</dc:identifier>
</item>
<item>
<title>Spring Boot + Spring Cloud 构建微服务系统（十）：配置中心（Spring Cloud Bus） - 朝雨忆轻尘</title>
<link>http://www.cnblogs.com/xifengxiaoma/p/9857110.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xifengxiaoma/p/9857110.html</guid>
<description>&lt;h2&gt;技术背景&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们在上一篇讲到，Spring Boot程序只在启动的时候加载配置文件信息，这样在GIT仓库配置修改之后，虽然配置中心服务器能够读取最新的提交信息，但是配置中心客户端却不会重新读取，以至于不能及时的读取更新后的配置信息。这个时候就需要一种通知刷新机制来支持了。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;refresh&quot;&gt;Refresh机制&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;refresh机制是Spring Cloud Config提供的一种刷新机制，它允许客户端通过POST方法触发各自的/refresh，只要依赖spring-boot-starter-actuator包就拥有了/refresh的功能，下面我们为我们的客户端加上刷新功能，以支持更新配置的读取。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;添加依赖&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;修改 spring-cloud-conifg-client，添加监控依赖，监控依赖包里携带了 /refresh 的功能。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;开启更新机制&quot;&gt;开启更新机制&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在使用配置属性的类型加上 @RefreshScope 注解，这样在客户端执行 /refresh 的时候就会刷新此类下面的配置属性了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.louis.spring.cloud.config.client.controller;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.cloud.context.config.annotation.RefreshScope;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RefreshScope
@RestController
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController {
    
    @Value(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${spring.config.hello}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String hello;

    @RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;from&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.hello;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;修改配置&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;修改配置文件添加以下内容，开放refresh的相关接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;bootstrap.yml&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;management:
  endpoints:
    web:
      exposure:
        include: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这样，以后以post请求的方式访问 http://localhost:8552/actuator/refresh 时，就会更新修改后的配置文件了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;特别注意：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里存在着版本大坑，1.x跟2.x的配置不太一样，我们用的是2.0+版本，务必注意。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.安全配置变更&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新版本&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
management.endpoints.web.exposure.include=&lt;span&gt;&quot;*&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;老版本&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
management.security.enabled=&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2.访问地址变更&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新版本&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8552/actuator/refresh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;老版本&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8552/refresh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里还是解释一下上面这个配置起到了什么具体作用，其实actuator是一个健康检查包，它提供了一些健康检查数据接口，refresh功能也是其中的一个接口，但是为了安全起见，它默认只开放了health和info接口（启动信息会包含如下图所示信息），而上面的配置就是设置要开放哪些接口， 我们设置成 “*”，是开放所有接口。你也可以指定开发几个，比如： health，info，refresh，而这里因为我们需要用的refresh功能，所以需要把refresh接口开放出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181028113507862-1946187483.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;设置成 “*” 后，启动信息会包含以下信息，而这个叫refresh的post方法，就是我们需要的，上面说的接口地址变更从这里也可以看得出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181028114025629-1165766924.png&quot; alt=&quot;&quot; width=&quot;684&quot; height=&quot;370&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;测试效果&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;访问 &lt;a href=&quot;http://localhost:8552/hello&quot; target=&quot;_blank&quot;&gt;http://localhost:8552/hello&lt;/a&gt;，返回结果如下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181027165108049-1751944263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;修改仓库配置内容，把数字2改成5，如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181028114411291-60322543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再次访问 &lt;a href=&quot;http://localhost:8552/hello&quot; target=&quot;_blank&quot;&gt;http://localhost:8552/hello&lt;/a&gt;，如我们所料，结果并没有更新，因为我们还没有调refresh方法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;通过工具或自写代码发送post请求 &lt;a href=&quot;http://localhost:8552/refresh&quot; target=&quot;_blank&quot;&gt;http://localhost:8552/actuator/refresh&lt;/a&gt;，刷新配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里通过在线测试网站发送，地址：&lt;a href=&quot;https://getman.cn/Mo2FX&quot; target=&quot;_blank&quot;&gt;https://getman.cn/Mo2FX&lt;/a&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：先让你的Chrome支持跨域。设置方法：在快捷方式的target后加上 --disable-web-security --user-data-dir，重启即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181028114951627-1473952103.png&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;429&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;刷新之后，再次访问 &lt;a href=&quot;http://localhost:8552/hello&quot; target=&quot;_blank&quot;&gt;http://localhost:8552/hello&lt;/a&gt;，返回结果如下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181028114634493-342365670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看返回结果，刷新之后已经可以获取最新提交的配置内容，但是每次都需要手动刷新客户端还是很麻烦，如果客户端数量一多就简直难以忍受了，有没有什么比较好的办法来解决这个问题呢，那是当然的，答案就是：Spring Cloud Bus。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Spring Cloud Bus&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Spring Cloud Bus，被大家称为消息总线，它通过轻量级的消息代理来连接各个分布的节点，可以利用像消息队列的广播机制在分布式系统中进行消息传播，通过消息总线可以实现很多业务功能，其中对于配置中心客户端刷新，就是一个非常典型的使用场景。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面这张图可以很好的解释消息总线的作用流程（图片描述来源：&lt;a href=&quot;https://www.cnblogs.com/ityouknow/p/6931958.html&quot; target=&quot;_blank&quot;&gt;纯洁的微笑：配置中心博文&lt;/a&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181028121039610-404477534.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Spring Cloud Bus 进行配置更新步骤如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  1、提交代码触发post请求给/actuator/bus-refresh&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  2、server端接收到请求并发送给Spring Cloud Bus&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  3、Spring Cloud bus接到消息并通知给其它客户端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  4、其它客户端接收到通知，请求Server端获取最新配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  5、全部客户端均获取到最新的配置&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;安装RabbitMQ&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;因为我们需要用到消息队列，我们这里选择RabbitMQ，使用Docker进行安装。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;拉取镜像&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;执行以下命令，拉取镜像。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker pull rabbitmq:management
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;完成之后执行以下命令查看下载镜像。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker images
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181027161936288-82152045.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;创建容器&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;执行以下命令，创建docker容器。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker run -d --name rabbitmq -p &lt;span&gt;5671&lt;/span&gt;:&lt;span&gt;5671&lt;/span&gt; -p &lt;span&gt;5672&lt;/span&gt;:&lt;span&gt;5672&lt;/span&gt; -p &lt;span&gt;4369&lt;/span&gt;:&lt;span&gt;4369&lt;/span&gt; -p &lt;span&gt;25672&lt;/span&gt;:&lt;span&gt;25672&lt;/span&gt; -p &lt;span&gt;15671&lt;/span&gt;:&lt;span&gt;15671&lt;/span&gt; -p &lt;span&gt;15672&lt;/span&gt;:&lt;span&gt;15672&lt;/span&gt; rabbitmq:management
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;启动成功之后，可以执行以下命令查看启动容器。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181027162215753-847377744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;登录界面&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;容器启动之后就可以访问web管理界面了，访问 http://宿主机IP:15672。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;系统提供了默认账号。 用户名：guest  密码： guest&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181027162556649-1287121962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;管理界面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181027162707404-1981490935.png&quot; alt=&quot;&quot; width=&quot;759&quot; height=&quot;369&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;客户端实现&lt;/h3&gt;
&lt;h4&gt;添加依赖&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;打开客户端 spring-cloud-conifg-client，添加相关依赖。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pom.xml&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-amqp&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;配置文件&quot;&gt;修改配置&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;修改配置，添加RebbitMq的相关配置，这样客户端代码就改造完成了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;bootstrap.yml&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  application:
    name: spring&lt;/span&gt;-cloud-config-&lt;span&gt;client
  cloud:
    consul:
      host: localhost
      port: &lt;/span&gt;&lt;span&gt;8500&lt;/span&gt;&lt;span&gt;
      discovery:
        serviceName: ${spring.application.name}    # 注册到consul的服务名称
    config:
      discovery:
        enabled: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        serviceId: spring&lt;/span&gt;-cloud-config-&lt;span&gt;server # 配置中心服务名称
      name: spring&lt;/span&gt;-&lt;span&gt;config  # 对应{application}部分
      profile: dev  # 对应{profile}部分
      label: master  # 对应git的分支，如果配置中心使用的是本地存储，则该参数无用
  rabbitmq:
    host: localhost
    port: &lt;/span&gt;&lt;span&gt;5672&lt;/span&gt;&lt;span&gt;
    username: guest
    password: guest
management:
  endpoints:
    web:
      exposure:
        include: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;服务端实现&lt;/h3&gt;
&lt;h4&gt;添加依赖&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;修改 spring-cloud-conifg-server，添加相关依赖。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pom.xml&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-amqp&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;修改配置，添加RebbitMq的和接口开放相关配置，这样服务端代码也改造完成了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;application.yml&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;&lt;span&gt;8551&lt;/span&gt;&lt;span&gt;
spring:
  application:
    name: spring&lt;/span&gt;-cloud-config-&lt;span&gt;server
  cloud:
    consul:
      host: localhost
      port: &lt;/span&gt;&lt;span&gt;8500&lt;/span&gt;&lt;span&gt;
      discovery:
        serviceName: ${spring.application.name}    # 注册到consul的服务名称
    config:
      server:
        git:
          uri: https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;gitee.com/liuge1988/spring-cloud-demo/     # 配置git仓库的地址&lt;/span&gt;
          search-paths: config-&lt;span&gt;repository                             # git仓库地址下的相对地址，可以配置多个，用,分割。
          username: username                                             # git仓库的账号
          password: password                                             # git仓库的密码
  rabbitmq:
    host: localhost
    port: &lt;/span&gt;&lt;span&gt;5672&lt;/span&gt;&lt;span&gt;
    username: guest
    password: guest
management:
  endpoints:
    web:
      exposure:
        include: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;测试效果&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1.启动服务端，成功集成消息总线后，启动信息中可以看到如下图中的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181028122804336-2088449230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 2.启动客户端，发现居然报错了，网上也找不到相关资料，也没见其他人提过相关问题。猜测是网上教程多是使用Euraka，而这里用的时Consul，瞎鼓捣了好久，反正是不想换回Euraka，2.0停止开发消息出来以后，将来还不定什么情况，只能硬着头皮解决了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named &lt;span&gt;'&lt;/span&gt;&lt;span&gt;configServerRetryInterceptor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; available
    at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:&lt;/span&gt;&lt;span&gt;685&lt;/span&gt;) ~[spring-beans-&lt;span&gt;5.0&lt;/span&gt;.&lt;span&gt;8&lt;/span&gt;.RELEASE.jar:&lt;span&gt;5.0&lt;/span&gt;.&lt;span&gt;8&lt;/span&gt;&lt;span&gt;.RELEASE]
    at org.springframework.beans.factory.support.AbstractBeanFactory.getMergedLocalBeanDefinition(AbstractBeanFactory.java:&lt;/span&gt;&lt;span&gt;1210&lt;/span&gt;) ~[spring-beans-&lt;span&gt;5.0&lt;/span&gt;.&lt;span&gt;8&lt;/span&gt;.RELEASE.jar:&lt;span&gt;5.0&lt;/span&gt;.&lt;span&gt;8&lt;/span&gt;&lt;span&gt;.RELEASE]
    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:&lt;/span&gt;&lt;span&gt;291&lt;/span&gt;) ~[spring-beans-&lt;span&gt;5.0&lt;/span&gt;.&lt;span&gt;8&lt;/span&gt;.RELEASE.jar:&lt;span&gt;5.0&lt;/span&gt;.&lt;span&gt;8&lt;/span&gt;&lt;span&gt;.RELEASE]
    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;) ~[spring-beans-&lt;span&gt;5.0&lt;/span&gt;.&lt;span&gt;8&lt;/span&gt;.RELEASE.jar:&lt;span&gt;5.0&lt;/span&gt;.&lt;span&gt;8&lt;/span&gt;&lt;span&gt;.RELEASE]
    at org.springframework.retry.annotation.AnnotationAwareRetryOperationsInterceptor.getDelegate(AnnotationAwareRetryOperationsInterceptor.java:&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;) ~[spring-retry-&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.RELEASE.jar:na]
    at org.springframework.retry.annotation.AnnotationAwareRetryOperationsInterceptor.invoke(AnnotationAwareRetryOperationsInterceptor.java:&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;) ~[spring-retry-&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.RELEASE.jar:na]
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;) ~[spring-aop-&lt;span&gt;5.0&lt;/span&gt;.&lt;span&gt;8&lt;/span&gt;.RELEASE.jar:&lt;span&gt;5.0&lt;/span&gt;.&lt;span&gt;8&lt;/span&gt;&lt;span&gt;.RELEASE]
    at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:&lt;/span&gt;&lt;span&gt;688&lt;/span&gt;) ~[spring-aop-&lt;span&gt;5.0&lt;/span&gt;.&lt;span&gt;8&lt;/span&gt;.RELEASE.jar:&lt;span&gt;5.0&lt;/span&gt;.&lt;span&gt;8&lt;/span&gt;&lt;span&gt;.RELEASE]
    at org.springframework.cloud.config.client.ConfigServerInstanceProvider$$EnhancerBySpringCGLIB$$dd44720b.getConfigServerInstances(&lt;/span&gt;&amp;lt;generated&amp;gt;) ~[spring-cloud-config-client-&lt;span&gt;2.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.RELEASE.jar:&lt;span&gt;2.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.RELEASE]
    at org.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration.refresh(DiscoveryClientConfigServiceBootstrapConfiguration.java:&lt;/span&gt;&lt;span&gt;84&lt;/span&gt;) [spring-cloud-config-client-&lt;span&gt;2.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.RELEASE.jar:&lt;span&gt;2.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.RELEASE]
    at org.springframework.cloud.config.client.DiscoveryClientConfigServiceBootstrapConfiguration.startup(DiscoveryClientConfigServiceBootstrapConfiguration.java:&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;) [spring-cloud-config-client-&lt;span&gt;2.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.RELEASE.jar:&lt;span&gt;2.0&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;.RELEASE]
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) &lt;/span&gt;~[na:&lt;span&gt;1.8&lt;/span&gt;&lt;span&gt;.0_131]
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;) ~[na:&lt;span&gt;1.8&lt;/span&gt;&lt;span&gt;.0_131]
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;) ~[na:&lt;span&gt;1.8&lt;/span&gt;&lt;span&gt;.0_131]
    at java.lang.reflect.Method.invoke(Method.java:&lt;/span&gt;&lt;span&gt;498&lt;/span&gt;) ~[na:&lt;span&gt;1.8&lt;/span&gt;.0_131]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后就跟踪代码，发现是在下图中的位置找不到相应的Bean，那么答案就比较明显了，要么是程序有BUG，不过可能性不大，那应该是就是缺包了，在缺失的包里有这个Bean。但是这个Bean是在哪个包？排查了半天也没找到，网上也没有想过资料，对比了一下网上消息总线的配置，依赖也没有少加什么。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181028132111237-416816378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;没有办法，最后只能自己上手了，不就是在刷新的时候缺少一个拦截器吗，自己给他弄一个试试呗。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用就加了一个配置类，并在resources下新建了META-INF目录和一个spring。factories文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181028125152613-706488644.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;RetryConfiguration.java&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.louis.spring.cloud.config.client;

import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.Bean;
import org.springframework.retry.interceptor.RetryInterceptorBuilder;
import org.springframework.retry.interceptor.RetryOperationsInterceptor;


&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RetryConfiguration {

    @Bean
    @ConditionalOnMissingBean(name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;configServerRetryInterceptor&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RetryOperationsInterceptor configServerRetryInterceptor() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; RetryInterceptorBuilder.stateless().backOffOptions(&lt;span&gt;1000&lt;/span&gt;, &lt;span&gt;1.2&lt;/span&gt;, &lt;span&gt;5000&lt;/span&gt;).maxAttempts(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;).build();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;spring.factories&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
org.springframework.cloud.bootstrap.BootstrapConfiguration=com.louis.spring.cloud.config.client.RetryConfiguration
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在这里指定新建的拦截器，这样系统初始化时会加载这个Bean。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后重启启动，果然没有报错了，还是先别高兴，看看能不能用先。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.先访问一下 &lt;a href=&quot;http://localhost:8552/hello&quot; target=&quot;_blank&quot;&gt;http://localhost:8552/hello&lt;/a&gt;，效果如下图所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181028123446794-1658530974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.修改仓库配置文件，把数字5改成15，修改完成提交。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181028125846384-2079907231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再次访问发现还是旧信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.再用工具发送post请求 &lt;a href=&quot;http://localhost:8551/actuator/bus-refresh&quot; target=&quot;_blank&quot;&gt;http://localhost:8551/actuator/bus-refresh&lt;/a&gt; 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意这次是向注册中心服务端发送请求，发送成功之后服务端会通过消息总线通知所有的客户端进行刷新。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外开启消息总线后的请求地址是 /actuator/bus-refresh，不再是refresh了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181028130143010-1523393596.png&quot; alt=&quot;&quot; width=&quot;628&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 7.给服务端发送刷新请求之后，再次访问 &lt;a href=&quot;http://localhost:8552/hello&quot; target=&quot;_blank&quot;&gt;http://localhost:8552/hello&lt;/a&gt;，结果如下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/616891/201810/616891-20181028130606916-259705156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们愉快的发现客户端已经能够通过消息总线获取最新配置了，真是可喜可贺。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;源码下载&lt;/h2&gt;
&lt;p&gt;码云：&lt;a href=&quot;https://gitee.com/liuge1988/spring-cloud-demo.git&quot; target=&quot;_blank&quot;&gt;https://gitee.com/liuge1988/spring-cloud-demo.git&lt;/a&gt;&lt;a href=&quot;https://gitee.com/liuge1988/kitty&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;作者：&lt;a href=&quot;https://www.cnblogs.com/xifengxiaoma/&quot; target=&quot;_blank&quot;&gt;朝雨忆轻尘&lt;/a&gt;&lt;br/&gt;出处：&lt;a href=&quot;https://www.cnblogs.com/xifengxiaoma/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/xifengxiaoma/ &lt;/a&gt;&lt;br/&gt;版权所有，欢迎转载，转载请注明原文作者及出处。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 05:25:00 +0000</pubDate>
<dc:creator>朝雨忆轻尘</dc:creator>
<og:description>技术背景 我们在上一篇讲到，Spring Boot程序只在启动的时候加载配置文件信息，这样在GIT仓库配置修改之后，虽然配置中心服务器能够读取最新的提交信息，但是配置中心客户端却不会重新读取，以至于不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xifengxiaoma/p/9857110.html</dc:identifier>
</item>
<item>
<title>zookeeper 集群搭建 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/9860529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/9860529.html</guid>
<description>&lt;p&gt;　　通过 VMware ，我们安装了三台虚拟机，用来搭建 zookeeper 集群，虚拟机网络地址如下：&lt;/p&gt;
&lt;p&gt;　hostname                      ipaddress        　　       subnet mask                          geteway　　　　&lt;/p&gt;
&lt;p&gt;1、 master　　　　　192.168.146.200　　　　255.255.255.0　　　　　　192.168.146.2&lt;/p&gt;
&lt;p&gt;2、 slave1　　　　　 192.168.146.201　　　　255.255.255.0　　　　　　192.168.146.2&lt;/p&gt;
&lt;p&gt;3、 slave2　　　　　 192.168.146.202　　　　255.255.255.0　　　　　　192.168.146.2&lt;/p&gt;
&lt;p&gt;　　在搭建 zookeeper 集群之前，我们首先要明白为什么要选择三台机器搭建，2台不可以吗？4台不可以吗？&lt;/p&gt;
&lt;p&gt;　　zookeeper 集群通常是用来对用户的分布式应用程序提供协调服务的，为了保证数据的一致性，对 zookeeper 集群进行了这样三种角色划分：leader、follower、observer分别对应着总统、议员和观察者。&lt;/p&gt;
&lt;p&gt;　　总统（leader）：负责进行投票的发起和决议，更新系统状态。&lt;/p&gt;
&lt;p&gt;　　议员（follower）：用于接收客户端请求并向客户端返回结果以及在选举过程中参与投票。&lt;/p&gt;
&lt;p&gt;　　观察者（observer）：也可以接收客户端连接，将写请求转发给leader节点，但是不参与投票过程，只同步leader的状态。通常对查询操作做负载。&lt;/p&gt;
&lt;h3&gt;1、为什么zookeeper节点是奇数？&lt;/h3&gt;
&lt;p&gt;　　我们知道，在每台机器数据保持一致的情况下，zookeeper集群可以保证，客户端发起的每次查询操作，集群节点都能返回同样的结果。&lt;/p&gt;
&lt;p&gt;　　但是对于客户端发起的修改、删除等能改变数据的操作呢？集群中那么多台机器，你修改你的，我修改我的，最后返回集群中哪台机器的数据呢？&lt;/p&gt;
&lt;p&gt;　　这就是一盘散沙，需要一个领导，于是在zookeeper集群中，leader的作用就体现出来了，只有leader节点才有权利发起修改数据的操作，而follower节点即使接收到了客户端发起的修改操作，也要将其转交给leader来处理，leader接收到修改数据的请求后，会向所有follower广播一条消息，让他们执行某项操作，follower 执行完后，便会向 leader 回复执行完毕。当 leader 收到半数以上的 follower 的确认消息，便会判定该操作执行完毕，然后向所有 follower 广播该操作已经生效。&lt;/p&gt;
&lt;p&gt;　　所以zookeeper集群中leader是不可缺少的，但是 leader 节点是怎么产生的呢？其实就是由所有follower 节点选举产生的，讲究民主嘛，而且leader节点只能有一个，毕竟一个国家不能有多个总统。&lt;/p&gt;
&lt;p&gt;　　这个时候回到我们的小标题，为什么 zookeeper 节点数是奇数，我们下面来一一来说明：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①、容错率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　首先从容错率来说明：（需要保证集群能够有半数进行投票）&lt;/p&gt;
&lt;p&gt;　　2台服务器，至少2台正常运行才行（2的半数为1，半数以上最少为2），正常运行1台服务器都不允许挂掉，但是相对于 单节点服务器，2台服务器还有两个单点故障，所以直接排除了。&lt;/p&gt;
&lt;p&gt;　　3台服务器，至少2台正常运行才行（3的半数为1.5，半数以上最少为2），正常运行可以允许1台服务器挂掉&lt;/p&gt;
&lt;p&gt;　　4台服务器，至少3台正常运行才行（4的半数为2，半数以上最少为3），正常运行可以允许1台服务器挂掉&lt;/p&gt;
&lt;p&gt;　　5台服务器，至少3台正常运行才行（5的半数为2.5，半数以上最少为3），正常运行可以允许2台服务器挂掉&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、防脑裂&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　脑裂集群的脑裂通常是发生在节点之间通信不可达的情况下，集群会分裂成不同的小集群，小集群各自选出自己的leader节点，导致原有的集群出现多个leader节点的情况，这就是脑裂。&lt;/p&gt;
&lt;p&gt;　　3台服务器，投票选举半数为1.5，一台服务裂开，和另外两台服务器无法通行，这时候2台服务器的集群（2票大于半数1.5票），所以可以选举出leader，而 1 台服务器的集群无法选举。&lt;/p&gt;
&lt;p&gt;　　4台服务器，投票选举半数为2，可以分成 1,3两个集群或者2,2两个集群，对于 1,3集群，3集群可以选举；对于2,2集群，则不能选择，造成没有leader节点。&lt;/p&gt;
&lt;p&gt;　　5台服务器，投票选举半数为2.5，可以分成1,4两个集群，或者2,3两集群，这两个集群分别都只能选举一个集群，满足zookeeper集群搭建数目。&lt;/p&gt;
&lt;p&gt;　　以上分析，我们从容错率以及防止脑裂两方面说明了3台服务器是搭建集群的最少数目，4台发生脑裂时会造成没有leader节点的错误。&lt;/p&gt;
&lt;h3&gt;2、下载 zookeeper&lt;/h3&gt;
&lt;p&gt;　　官网下载地址：&lt;a href=&quot;http://mirror.bit.edu.cn/apache/zookeeper/&quot; target=&quot;_blank&quot;&gt;http://mirror.bit.edu.cn/apache/zookeeper/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3、安装JDK&lt;/h3&gt;
&lt;p&gt;　　由于zookeeper集群的运行需要Java运行环境，所以需要首先安装 JDK，关于安装步骤，我在前面博客介绍过：&lt;a href=&quot;https://www.cnblogs.com/ysocean/p/6952166.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/ysocean/p/6952166.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;4、解压 zookeeper&lt;/h3&gt;
&lt;p&gt;　　在 /usr/local 目录下新建 software 目录，然后将 zookeeper 压缩文件上传到该目录中，然后通过如下命令解压。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tar -zxvf zookeeper-3.3.6.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;6、修改配置文件 zoo.cfg&lt;/h3&gt;
&lt;p&gt;　　将zookeeper压缩文件解压后，我们进入到 conf 目录：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201810/1120165-20181027123401602-1805280487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将 zoo_sample.cfg 文件复制并重命名为 zoo.cfg 文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cp zoo_sample.cfg zoo.cfg
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后通过 vim zoo.cfg 命令对该文件进行修改：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201810/1120165-20181027123636869-436165376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面红色框住的内容即是我们修改的内容：&lt;/p&gt;
&lt;p&gt;　　①、tickTime：基本事件单元，这个时间是作为Zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔，每隔tickTime时间就会发送一个心跳；最小 的session过期时间为2倍tickTime&lt;/p&gt;
&lt;p&gt;　　②、dataDir：存储内存中数据库快照的位置，除非另有说明，否则指向数据库更新的事务日志。注意：应该谨慎的选择日志存放的位置，使用专用的日志存储设备能够大大提高系统的性能，如果将日志存储在比较繁忙的存储设备上，那么将会很大程度上影像系统性能。&lt;/p&gt;
&lt;p&gt;　　③、client：监听客户端连接的端口。&lt;/p&gt;
&lt;p&gt;　　④、initLimit：允许follower连接并同步到Leader的初始化连接时间，以tickTime为单位。当初始化连接时间超过该值，则表示连接失败。&lt;/p&gt;
&lt;p&gt;　　⑤、syncLimit：表示Leader与Follower之间发送消息时，请求和应答时间长度。如果follower在设置时间内不能与leader通信，那么此follower将会被丢弃。&lt;/p&gt;
&lt;p&gt;　　⑥、server.A=B:C:D&lt;/p&gt;
&lt;p&gt;　　　　A：其中 A 是一个数字，表示这个是服务器的编号；&lt;/p&gt;
&lt;p&gt;　　　　B：是这个服务器的 ip 地址；&lt;/p&gt;
&lt;p&gt;　　　　C：Leader选举的端口；&lt;/p&gt;
&lt;p&gt;　　　　D：Zookeeper服务器之间的通信端口。&lt;/p&gt;
&lt;p&gt;　　我们需要修改的第一个是 dataDir ,在指定的位置处创建好目录。&lt;/p&gt;
&lt;p&gt;　　第二个需要新增的是 server.A=B:C:D 配置，其中 A 对应下面我们即将介绍的myid 文件。B是集群的各个IP地址，C:D 是端口配置。&lt;/p&gt;
&lt;h3&gt;7、创建 myid 文件&lt;/h3&gt;
&lt;p&gt;　　在 上一步 dataDir 指定的目录下，创建 myid 文件。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201810/1120165-20181027124711410-1015969668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后在该文件添加上一步 server 配置的对应 A 数字。&lt;/p&gt;
&lt;p&gt;　　比如我们上面的配置：&lt;/p&gt;
&lt;p&gt;　　dataDir=/usr/local/software/zookeeper-3.3.6/data&lt;/p&gt;
&lt;p&gt;　　然后下面配置是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
server.0=192.168.146.200:2888:3888&lt;span&gt;
server.&lt;/span&gt;1=192.168.146.201:2888:3888&lt;span&gt;
server.&lt;/span&gt;2=192.168.146.202:2888:3888
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那么就必须在 192.168.146.200 机器的的 /usr/local/software/zookeeper-3.3.6/data 目录下创建 myid 文件，然后在该文件中写上 0 即可。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201810/1120165-20181027125037143-461521014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　后面的机器依次在相应目录创建myid文件，写上相应配置数字即可。&lt;/p&gt;
&lt;h3&gt;8、配置环境变量&lt;/h3&gt;
&lt;p&gt;　　为了能够在任意目录启动zookeeper集群，我们需要配置环境变量。&lt;/p&gt;
&lt;p&gt;　　ps:你也可以不配，这不是搭建集群的必要操作，只不过如果你不配置环境变量，那么每次启动zookeeper需要到安装文件的 bin 目录下去启动。&lt;/p&gt;
&lt;p&gt;　　首先进入到 /etc/profile 目录，添加相应的配置信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#set zookeeper environment
export ZK_HOME&lt;/span&gt;=/usr/local/software/zookeeper-3.3.6&lt;span&gt;
export PATH&lt;/span&gt;=$PATH:$ZK_HOME/bin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后通过如下命令使得环境变量生效：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
source /etc/profle
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;9、启动zookeeper服务&lt;/h3&gt;
&lt;p&gt;　　启动命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
zkServer.sh start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　停止命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
zkServer.sh stop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　重启命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
zkServer.sh restart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看集群节点状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
zkServer.sh status
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们分别对集群三台机器执行启动命令。执行完毕后，分别查看集群节点状态：&lt;/p&gt;
&lt;p&gt;　　出现如下即是集群搭建成功：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201810/1120165-20181027125808915-966913713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　三台机器，slave1 成功的通过了选举称为了leader,而剩下的两台成为了 follower。这时候，如果你将slave1关掉，会发现剩下两台又会有一台变成了 leader节点。&lt;/p&gt;
&lt;h3&gt;10、搭建问题&lt;/h3&gt;
&lt;p&gt;　　如果没有出现上面的状态，说明搭建过程出了问题，那么解决问题的首先就是查看日志文件：&lt;/p&gt;
&lt;p&gt;　　zookeeper 日志文件目录在：&lt;/p&gt;
&lt;p&gt;　　dataDir 配置的目录下，文件名称为：&lt;strong&gt;zookeeper.out&lt;/strong&gt;。通过查看日志来解决相应的问题。下面是两种常见的问题：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①、防火墙为关闭&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　查看防火墙状态：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service iptables status
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　关闭防火墙：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
chkconfig iptables off
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;②、dataDir 配置的目录没有创建&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在 zoo.cfg 文件中，会有对 dataDir 的一项配置，需要创建该目录，并且注意要在该目录下创建 myid 文件，里面的配置和 zoo.cfg 的server.x 配置保持一致。&lt;/p&gt;

</description>
<pubDate>Sun, 28 Oct 2018 05:14:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<og:description>zookeeper 集群搭建</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ysocean/p/9860529.html</dc:identifier>
</item>
<item>
<title>浅析mpvue的事件代理系统 - nobody-junior</title>
<link>http://www.cnblogs.com/imgss/p/mpvue-handleProxy.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imgss/p/mpvue-handleProxy.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;说来惭愧，用 mpvue 大半年，小程序快一年了，居然还试图用 &lt;code&gt;event.stopPropagation&lt;/code&gt; 方法阻止事件冒泡，也是有点蠢。痛定思痛，写篇博文来认真捋一捋小程序的事件系统和 mpvue 的事件代理&lt;/p&gt;
&lt;h3 id=&quot;小程序事件系统mpvue-事件系统和-dom-事件系统的差别&quot;&gt;小程序事件系统，mpvue 事件系统和 DOM 事件系统的差别&lt;/h3&gt;
&lt;p&gt;从文档得知，小程序的 event 对象和 DOM 的 event 对象是不同的，我们还可以通过把两个对象的属性打印出来进行比较：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 小程序 event 对象属性（8 个）

[&quot;type&quot;, &quot;timeStamp&quot;, &quot;target&quot;, &quot;currentTarget&quot;, &quot;detail&quot;, &quot;touches&quot;, &quot;changedTouches&quot;, &quot;_requireActive&quot;]


// DOM event 对象属性 / 方法（54 个）

[&quot;isTrusted&quot;, &quot;screenX&quot;, &quot;screenY&quot;, &quot;clientX&quot;, &quot;clientY&quot;, &quot;ctrlKey&quot;, &quot;shiftKey&quot;, &quot;altKey&quot;, &quot;metaKey&quot;, &quot;button&quot;, &quot;buttons&quot;, &quot;relatedTarget&quot;, &quot;pageX&quot;, &quot;pageY&quot;, &quot;x&quot;, &quot;y&quot;, &quot;offsetX&quot;, &quot;offsetY&quot;, ..., &quot;cancelable&quot;, &quot;timeStamp&quot;, &quot;srcElement&quot;, &quot;returnValue&quot;, &quot;cancelBubble&quot;, &quot;path&quot;, &quot;composedPath&quot;, &quot;stopPropagation&quot;, &quot;stopImmediatePropagation&quot;, &quot;preventDefault&quot;, &quot;initEvent&quot;]

// mpvue event 对象属性 / 方法（9 个）

[&quot;mp&quot;, &quot;type&quot;, &quot;timeStamp&quot;, &quot;x&quot;, &quot;y&quot;, &quot;target&quot;, &quot;currentTarget&quot;, &quot;stopPropagation&quot;, &quot;preventDefault&quot;]

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们关注一下 &lt;code&gt;stopPropagation&lt;/code&gt; 和 &lt;code&gt;preventDefault&lt;/code&gt; 这两个在网页中常用的方法。从打印得到的属性来看，在小程序中的 event 对象中没有这两个方法，取而代之的是借助 &lt;code&gt;catchtap&lt;/code&gt; 这样的语法来阻止事件冒泡。另外，小程序中没有什么方式来阻止默认事件。&lt;/p&gt;
&lt;p&gt;但是在 mpvue 中，event 对象又被挂载了这两个方法。至于这两个方法是否可以真的有用，这就需要我们了解一下 mpvue 的事件代理机制。&lt;/p&gt;
&lt;h3 id=&quot;mpvue-的事件代理&quot;&gt;mpvue 的事件代理&lt;/h3&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;cover-view class=&quot;_cover-view&quot; id=&quot;zanIcon&quot; catchtap=&quot;handleProxy&quot; data-eventid=&quot;{{'4'}}&quot; data-comkey=&quot;{{$k}}&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是mpvue生成的wxml文件片段，如果你看过 mpvue 的生成文件，可能会发现，在 mpvue 生成的 wxml 文件中，所有的事件都被一个叫 handleProxy 的函数接管，在 handleProxy 进行处理后再去调用我们写的真正的事件处理函数。这个方法在initMp时，作为小程序Page构造函数的一个选项，从而可以在wxml中被正确调用。函数的定义如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// https://github.com/Meituan-Dianping/mpvue/blob/63700b2d4e4e678bc4297c71e3acd1f36647907a/src/platforms/mp/runtime/lifecycle.js#L286-L288

handleProxy (e) {
   return rootVueVM.$handleProxyWithVue(e) 
}

// https://github.com/Meituan-Dianping/mpvue/blob/63700b2d4e4e678bc4297c71e3acd1f36647907a/src/platforms/mp/runtime/index.js#L53-L54

import { handleProxyWithVue } from './events'

Vue.prototype.$handleProxyWithVue = handleProxyWithVue // handleProxyWithVue实现在 events.js 中&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的代码可以看出，handleProxy只是将小程序的event对象传给handleProxyWithVue函数进行进一步处理。接下来我们看看handleProxyWithVue都做了什么工作：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// https://github.com/Meituan-Dianping/mpvue/blob/63700b2d4e4e678bc4297c71e3acd1f36647907a/src/platforms/mp/runtime/events.js#L84-L108

export function handleProxyWithVue (e) {
  const rootVueVM = this.$root
  const { type, target = {}, currentTarget } = e
  const { dataset = {}} = currentTarget || target
  const { comkey = '', eventid } = dataset
  const vm = getVM(rootVueVM, comkey.split(','))// 根据comkey找到页面对应的mpvue实例（vm）


  if (!vm) {
    return
  }


  const webEventTypes = eventTypeMap[type] || [type]
  const handles = getHandle(vm._vnode, eventid, webEventTypes) //找到真正的事件处理函数

  if (handles.length) {
    const event = getWebEventByMP(e) // 包装为mpvue的event对象
    if (handles.length === 1) {
      const result = handles[0](event)
      return result
    }
    handles.forEach(h =&amp;gt; h(event))// 调用真实的事件处理函数
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;handleProxyWithVue做了以下几件事情：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从根实例开始，根据comkey找出事件处理函数所在的mpvue实例(getVm)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通过遍历找到的vm的vnode，结合eventid找到小程序事件对应的真实的事件处理函数(getHandle)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;将小程序的event对象包装为mpvue的event对象(getWebEventByMP),并添加了preventDefault和stopPropagation方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将包装后的event对象传给真实的处理函数进行调用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这就解释了生成的wxml中绑定事件的节点都有&lt;code&gt;event-comkey&lt;/code&gt;和&lt;code&gt;event-eventid&lt;/code&gt;属性，在一个事件触发时，它们是被用来寻找事件对应的vm实例和对应的事件处理函数的。&lt;/p&gt;
&lt;p&gt;最后我们来看看getWebEventByMP函数：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// https://github.com/Meituan-Dianping/mpvue/blob/63700b2d4e4e678bc4297c71e3acd1f36647907a/src/platforms/mp/runtime/events.js#L62-L82

function getWebEventByMP (e) {
  const { type, timeStamp, touches, detail = {}, target = {}, currentTarget = {}} = e
  const { x, y } = detail
  const event = {
    mp: e,
    type,
    timeStamp,
    x,
    y,
    target: Object.assign({}, target, detail),
    currentTarget,
    stopPropagation: noop,
    preventDefault: noop
  }


  if (touches &amp;amp;&amp;amp; touches.length) {
    Object.assign(event, touches[0])
    event.touches = touches
  }
  return event
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面代码可以看出，stopPropagation和preventDefault都对应到一个叫noop的函数，而这个函数是一个空函数，也就是说在mpvue中，尽管可以调用&lt;code&gt;event.stopPropagation()&lt;/code&gt;，但是并没有什么用，还是要借助&lt;code&gt;.stop&lt;/code&gt;修饰符通过compiler编译成&lt;code&gt;catchEvent&lt;/code&gt;来阻止冒泡。（完）&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 04:56:00 +0000</pubDate>
<dc:creator>nobody-junior</dc:creator>
<og:description>mpvue的事件代理机制</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imgss/p/mpvue-handleProxy.html</dc:identifier>
</item>
<item>
<title>Java并发编程(4)--生产者与消费者模式介绍 - 玉树临枫</title>
<link>http://www.cnblogs.com/yuanfy008/p/9574509.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanfy008/p/9574509.html</guid>
<description>&lt;p&gt;　　这种模式在生活是最常见的，那么它的场景是什么样的呢？ 下面是我假象的，假设有一个仓库，仓库有一个生产者和一个消费者，消费者过来消费的时候会检测仓库中是否有库存，如果没有了则等待生产，如果有就先消费直至消费完成；而生产者每天的工作就是先检测仓库是否有库存，如果没有就开始生产，满仓了就停止生产等待消费，直至工作结束。下图是根据假象画的流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201810/690169-20181028120432195-1648527025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么在程序中怎么才能达到这样的效果呢？下面介绍三种方式实现。&lt;/p&gt;

&lt;p&gt;　　相信大家这两个方法都不陌生，它是Object类中的两个方法，具体请看源码中的解释。提醒一点就是&lt;span&gt;&lt;strong&gt;使用notify()和wait()方法时必须拥有对象锁&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　根据上面假象我这定义一下明确场景：仓库库存有个最大值，如果仓库库存已经达到最大值那么就停止生产，小于就需要生产； 如果库存等于0则需要等待生产停止消费。另外生产者有个生产目标，当它生产了目标数后就结束生产；消费者也是，当消费一定的数据后就结束消费，否则等待消费。&lt;/p&gt;
&lt;p&gt;　　见下面代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.yuanfy.jmm.threads;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.yuanfy.util.SleepUtils;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.TimeUnit;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Factory {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前库存大小&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 库存容量（最大库存值）&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Factory(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.capacity =&lt;span&gt; capacity;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; produce(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;+++++生产者【&quot; +&lt;span&gt; Thread.currentThread().getName()
                    &lt;/span&gt;+ &quot;】, 他的任务是生产&quot; + num + &quot;件产品.&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当生产完成就停止&lt;/span&gt;
           &lt;span&gt; while (num &amp;gt; 0) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前库存大小大于或等于库存容量值了，则停止生产等待消费。&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (size &amp;gt;=&lt;span&gt; capacity) {
                    System.out.println(&lt;/span&gt;&quot;+++++&quot; + Thread.currentThread().getName() +
                            &quot;检测库存已满，停止生产等待消费...&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;// 等待消费
&lt;/span&gt;&lt;span&gt;&lt;span&gt;                    wait();&lt;/span&gt;
                    System.out.println(&lt;/span&gt;&quot;+++++&quot; + Thread.currentThread().getName() + &quot;开始生产...&quot;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则继续生产&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; inc = (num + size) &amp;gt; capacity ? (capacity -&lt;span&gt; size) : num;
                num &lt;/span&gt;-=&lt;span&gt; inc;
                size &lt;/span&gt;+=&lt;span&gt; inc;
                SleepUtils.second(&lt;/span&gt;1&lt;span&gt;);
                System.out.println(&lt;/span&gt;&quot;+++++&quot; + Thread.currentThread().getName() + &quot; 生产了&quot; + inc + &quot;件，当前库存有&quot; + size + &quot;件.&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;// 生产后唤醒消费者
&lt;/span&gt;&lt;span&gt;&lt;span&gt;                notify();&lt;/span&gt;
            }
            System.out.println(&lt;/span&gt;&quot;+++++生产者【&quot; +&lt;span&gt; Thread.currentThread().getName()
                    &lt;/span&gt;+ &quot;】 生产结束.&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; consume(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;-----消费者【&quot; +&lt;span&gt; Thread.currentThread().getName()
                    &lt;/span&gt;+ &quot;】, 他需要消费&quot; + num + &quot;件产品.&quot;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;// 当消费完成则停止
            while (num &amp;gt; 0) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前库存大小小于等于0，则停止消费等待生产。&lt;/span&gt;
               &lt;span&gt; if (size &amp;lt;= 0&lt;/span&gt;&lt;span&gt;&lt;span&gt;) {&lt;/span&gt;
                    System.out.println(&lt;/span&gt;&quot;-----&quot; + Thread.currentThread().getName() + &quot; 检测库存已空，停止消费等待生产...&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等待生产&lt;/span&gt;
&lt;span&gt;&lt;span&gt;                    wait();&lt;/span&gt;
                    System.out.println(&lt;/span&gt;&quot;-----&quot; + Thread.currentThread().getName() + &quot; 开始消费...&quot;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则继续消费&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; dec = (size - num) &amp;gt; 0 ?&lt;span&gt; num : size;
                num &lt;/span&gt;-=&lt;span&gt; dec;
                size &lt;/span&gt;-=&lt;span&gt; dec;
                SleepUtils.second(&lt;/span&gt;1&lt;span&gt;);
                System.out.println(&lt;/span&gt;&quot;-----&quot; + Thread.currentThread().getName() + &quot; 消费了&quot; + dec + &quot;件，当前有&quot; + size + &quot;件.&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;// 消费后唤醒生产者继续生产
&lt;/span&gt;&lt;span&gt;&lt;span&gt;                notify();&lt;/span&gt;
            }
            System.out.println(&lt;/span&gt;&quot;-----消费者【&quot; +&lt;span&gt; Thread.currentThread().getName()
                    &lt;/span&gt;+ &quot;】 消费结束.&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面是工厂（仓库）类，主要包含两个任务一个是生产一个是消费，接下来创建两个线程去调用它，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.yuanfy.jmm.threads;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 生产线程
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Produce {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Factory factory;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Produce(Factory factory) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.factory =&lt;span&gt; factory;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; produce(String name, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; num) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                factory.produce(num);
            }
        }, name).start();
    }
}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 消费线程
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Consume {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Factory factory;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Consume(Factory factory) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.factory =&lt;span&gt; factory;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; consume(String name, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; num) {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                factory.consume(num);
            }
        }, name).start();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProduceConsumeDemo {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
       &lt;span&gt; Factory f &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= new Factory(500&lt;/span&gt;&lt;span&gt;&lt;span&gt;);
&lt;/span&gt;
        Consume consume &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Consume(f);
        consume.consume(&lt;/span&gt;&quot;消费线程&quot;,600&lt;span&gt;);

        Produce produce &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Produce(f);
        produce.produce(&lt;/span&gt;&quot;生产线程&quot;,800&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意上方，消费线程和生产线程都是拥有同一个工厂对象，然后进行生产和消费模式。那么我们直接运行，结果如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/690169/201810/690169-20181028122018004-2064776164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这种方式估计用的比较少，因为使用Condition必须先使用锁Lock。这里我只介绍怎么用Condition对象进行控制实现生产者与消费者模式的实现。&lt;/p&gt;
&lt;p&gt;　　其实它跟上面那种方法有点类似，Condition对象中await()方法表示等待，signal()方法表示唤醒（看了AQS源码的应该都知道有这个对象且了解过这两个方法）。下面看下具体怎么实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Factory {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前大小&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 总容量&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Lock lock;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已满的条件&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Condition fullCondition;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已空的条件&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Condition emptyCondition;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Factory(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.capacity =&lt;span&gt; capacity;
        lock &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
        fullCondition &lt;/span&gt;=&lt;span&gt; lock.newCondition();
        emptyCondition &lt;/span&gt;=&lt;span&gt; lock.newCondition();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; produce(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; no) {
        lock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (no &amp;gt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (size &amp;gt;=&lt;span&gt; capacity) {
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; 报告仓库已满，等待快递员取件...&quot;&lt;span&gt;);
                   &lt;span&gt; fullCondition.await();&lt;/span&gt;
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; 报告开始进货...&quot;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; inc = (no + size) &amp;gt; capacity ? (capacity -&lt;span&gt; size) : no;
                no &lt;/span&gt;-=&lt;span&gt; inc;
                size &lt;/span&gt;+=&lt;span&gt; inc;
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+
                        &quot; 报告进货了： &quot; + inc + &quot;件, 当前库存数： &quot; +&lt;span&gt; size);
               &lt;span&gt; emptyCondition.signal();&lt;/span&gt;
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            lock.unlock();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; consume(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; no) {
        lock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (no &amp;gt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (size &amp;lt;= 0&lt;span&gt;) {
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; 报告仓库已空，等待仓库管理员进货&quot;&lt;span&gt;);
                   &lt;span&gt; emptyCondition.await();&lt;/span&gt;
                    System.out.println(Thread.currentThread().getName() &lt;/span&gt;+ &quot; 报告开始取件...&quot;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; dec = (size - no) &amp;gt; 0 ?&lt;span&gt; no : size;
                no &lt;/span&gt;-=&lt;span&gt; dec;
                size &lt;/span&gt;-=&lt;span&gt; dec;
                System.out.println(Thread.currentThread().getName() &lt;/span&gt;+
                        &quot; 报告取件： &quot; + dec + &quot;, 当前库存数： &quot; +&lt;span&gt; size);
               &lt;span&gt; fullCondition.signal();&lt;/span&gt;
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            lock.unlock();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　看了上面工厂类的代码后是不是跟使用Object中wait()和notify()方法类似呢。 主要区别就是拥有对象的方式不一样，这里使用的lock进行且需要手动释放，而第一种是需要Synchronized进行控制。&lt;/p&gt;

&lt;p&gt;　　这个就很简单了，它已经封装好等待和唤醒的操作，所以不进行案例分享了。其中涉及到两个重要方法put() 和 take&lt;/p&gt;


</description>
<pubDate>Sun, 28 Oct 2018 04:45:00 +0000</pubDate>
<dc:creator>玉树临枫</dc:creator>
<og:description>一、前言 这种模式在生活是最常见的，那么它的场景是什么样的呢？ 下面是我假象的，假设有一个仓库，仓库有一个生产者和一个消费者，消费者过来消费的时候会检测仓库中是否有库存，如果没有了则等待生产，如果有就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanfy008/p/9574509.html</dc:identifier>
</item>
<item>
<title>你所不知道的限流 - 程序诗人</title>
<link>http://www.cnblogs.com/scy251147/p/9865099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/scy251147/p/9865099.html</guid>
<description>&lt;p&gt;在系统架构设计当中，限流是一个不得不说的话题，因为他太不起眼，但是也太重要了。这点有些像古代镇守边陲的将士，据守隘口，抵挡住外族的千军万马，一旦隘口失守，各种饕餮涌入城内，势必将我们苦心经营的朝堂庙店洗劫一空，之前的所有努力都付之一炬。所以今天我们点了这个话题，一方面是要对限流做下总结，另一方面，抛砖引玉，看看大家各自的系统中，限流是怎么做的。&lt;/p&gt;
&lt;p&gt;提到限流，映入脑海的肯定是限制流量四个字，其重点在于如何限。而且这个限，还分为单机限和分布式限，单机限流，顾名思义，就是对部署了应用的docker机或者物理机，进行流量控制，以使得流量的涌入呈现可控的态势，防止过大过快的流量涌入造成应用的性能问题，甚至于失去响应。分布式限流，则是对集群的流量限制，一般这类应用的流量限制集中在一个地方来进行，比如redis，zk或者其他的能够支持分布式限流的组件中。这样当流量过大过快的时候，不至于因为集群中的一台机器被压垮而带来雪崩效应，造成集群应用整体坍塌。&lt;/p&gt;
&lt;p&gt;下面我们来细数一下各种限流操作。&lt;/p&gt;

&lt;p class=&quot;mytitless&quot;&gt;1. 基于计数器的单机限流&lt;/p&gt;
&lt;p&gt;此类限流，一般是通过应用中的计数器来进行流量限制操作。计数器可以用Integer类型的变量，也可以用Java自带的AtomicLong来实现。原理就是设置一个计数器的阈值，每当有流量进入的时候，将计数器递增，当达到阈值的时候，后续的请求将会直接被抛弃。代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;csharpcode&quot;&gt;
    &lt;span class=&quot;rem&quot;&gt;//限流计数器&lt;/span&gt;
    &lt;span class=&quot;kwrd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; AtomicLong counter = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; AtomicLong();
    &lt;span class=&quot;rem&quot;&gt;//限流阈值&lt;/span&gt;
    &lt;span class=&quot;kwrd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; final &lt;span class=&quot;kwrd&quot;&gt;long&lt;/span&gt; counterMax = 500;
    &lt;span class=&quot;rem&quot;&gt;//业务处理方法&lt;/span&gt;
    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; invoke(Request request) {
        &lt;span class=&quot;kwrd&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;rem&quot;&gt;//请求过滤&lt;/span&gt;
            &lt;span class=&quot;kwrd&quot;&gt;if&lt;/span&gt; (counter.incrementAndGet() &amp;gt; counterMax) {
                &lt;span class=&quot;kwrd&quot;&gt;return&lt;/span&gt;;
            }
            &lt;span class=&quot;rem&quot;&gt;//业务逻辑&lt;/span&gt;
            doBusiness(request);
        } &lt;span class=&quot;kwrd&quot;&gt;catch&lt;/span&gt; (Exception e) {
            &lt;span class=&quot;rem&quot;&gt;//错误处理&lt;/span&gt;
            doException(request,e);
        } &lt;span class=&quot;kwrd&quot;&gt;finally&lt;/span&gt; {
            counter.decrementAndGet();
        }
    }
&lt;/pre&gt;
&lt;p&gt;上面的代码就是一个简单的基于计数器实现的单机限流。代码简单易行，操作方便，而且可以带来不错的效果。但是缺点也很明显，那就是先来的流量一般都能打进来，后来的流量基本上都会被拒绝。由于每个请求被执行的概率其实不一样，所以就没有公平性可言。&lt;/p&gt;
&lt;p&gt;所以总结一下此种限流优缺点：&lt;/p&gt;
&lt;p&gt;优点：代码简洁，操作方便&lt;/p&gt;
&lt;p&gt;缺点：先到先得，先到的请求可执行概率为100%，后到的请求可执行概率小一些，每个请求获得执行的机会是不平等的。&lt;/p&gt;
&lt;p&gt;那么，如果想让每个请求获得执行的机会是平等的话，该怎么做呢？&lt;/p&gt;

&lt;p class=&quot;mytitless&quot;&gt;2. 基于随机数的单机限流&lt;/p&gt;
&lt;p&gt;此种限流算法，使得请求可被执行的概率是一致的，所以相对于基于计数器实现的限流说来，对用户更加的友好一些。代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharpcode&quot;&gt;
    &lt;span class=&quot;rem&quot;&gt;//获取随机数&lt;/span&gt;
    &lt;span class=&quot;kwrd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; ThreadLocalRandom ptgGenerator = ThreadLocalRandom.current();
    &lt;span class=&quot;rem&quot;&gt;//限流百分比，允许多少流量通过此业务，这里限定为10%&lt;/span&gt;
    &lt;span class=&quot;kwrd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; final &lt;span class=&quot;kwrd&quot;&gt;long&lt;/span&gt; ptgGuarder = 10;
    &lt;span class=&quot;rem&quot;&gt;//业务处理方法&lt;/span&gt;
    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; invoke(Request request) {
        &lt;span class=&quot;kwrd&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;rem&quot;&gt;//请求进入，获取百分比&lt;/span&gt;
            &lt;span class=&quot;kwrd&quot;&gt;int&lt;/span&gt; currentPercentage = ptgGenerator.nextInt(1, 100);
            &lt;span class=&quot;kwrd&quot;&gt;if&lt;/span&gt; (currentPercentage &amp;lt;= ptgGuarder) {
                &lt;span class=&quot;rem&quot;&gt;//业务处理&lt;/span&gt;
                doBusiness(request);
            } &lt;span class=&quot;kwrd&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;kwrd&quot;&gt;return&lt;/span&gt;;
            }
        } &lt;span class=&quot;kwrd&quot;&gt;catch&lt;/span&gt; (Exception e) {
            &lt;span class=&quot;rem&quot;&gt;//错误处理&lt;/span&gt;
            doException(request, e);
        }
    }
&lt;/pre&gt;
&lt;p&gt;从上面代码可以看出来，针对每个请求，都会先获取一个随机的1~100的执行率，然后和当前限流阈值（比如当前接口只允许10%的流量通过）相比，如果小于此限流阈值，则放行；如果大于此限流阈值，则直接返回，不做任何处理。和之前的计数器限流比起来，每个请求获得执行的概率是一致的。当然，在真正的业务场景中，用户可以通过动态配置化阈值参数，来控制每分钟通过的流量百分比，或者是每小时通过的流量百分比。但是如果对于突增的高流量，此种方法则有点问题，因为高并发下，每个请求之间进入的时间很短暂，导致nextInt生成的值，大概率是重复的，所以这里需要做的一个优化点，就是为其寻找合适的seed，用于优化nextInt生成的值。&lt;/p&gt;
&lt;p&gt;优点：代码简洁，操作简便，每个请求可执行的机会是平等的。&lt;/p&gt;
&lt;p&gt;缺点：不适合应用突增的流量。&lt;/p&gt;

&lt;p class=&quot;mytitless&quot;&gt;3. 基于时间段的单机限流&lt;/p&gt;
&lt;p&gt;有时候，我们的应用只想在单位时间内放固定的流量进来，比如一秒钟内只允许放进来100个请求，其他的请求抛弃。那么这里的做法有很多，可以基于计数器限流实现，然后判断时间，但是此种做法稍显复杂，可控性不是特别好。&lt;/p&gt;
&lt;p&gt;那么这里我们就要用到缓存组件来实现了。原理是这样的，首先请求进来，在guava中设置一个key，此key就是当前的秒数，秒数的值就是放进来的请求累加数，如果此累加数到100了，则拒绝后续请求即可。代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharpcode&quot;&gt;
   &lt;span class=&quot;rem&quot;&gt;//获取guava实例&lt;/span&gt;
    &lt;span class=&quot;kwrd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; LoadingCache&amp;lt;Long, AtomicLong&amp;gt; guava = CacheBuilder.newBuilder()
            .expireAfterWrite(5, TimeUnit.SECONDS)
            .build(&lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; CacheLoader&amp;lt;Long, AtomicLong&amp;gt;() {
                        @Override
                        &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; AtomicLong load(Long seconds) throws Exception {
                            &lt;span class=&quot;kwrd&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;null&lt;/span&gt;;
                        }
                    });
    &lt;span class=&quot;rem&quot;&gt;//每秒允许通过的请求数&lt;/span&gt;
    &lt;span class=&quot;kwrd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; final &lt;span class=&quot;kwrd&quot;&gt;long&lt;/span&gt; requestsPerSecond = 100;
    &lt;span class=&quot;rem&quot;&gt;//业务处理方法&lt;/span&gt;
    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; invoke(Request request) {
        &lt;span class=&quot;kwrd&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;rem&quot;&gt;//guava key&lt;/span&gt;
            &lt;span class=&quot;kwrd&quot;&gt;long&lt;/span&gt; guavaKey = System.currentTimeMillis() / 1000;
            &lt;span class=&quot;rem&quot;&gt;//请求累加数&lt;/span&gt;
            &lt;span class=&quot;kwrd&quot;&gt;long&lt;/span&gt; guavaVal = guava.get(guavaKey).incrementAndGet();
            &lt;span class=&quot;kwrd&quot;&gt;if&lt;/span&gt; (guavaVal &amp;lt;= requestsPerSecond) {
                &lt;span class=&quot;rem&quot;&gt;//业务处理&lt;/span&gt;
                doBusiness(request);
            } &lt;span class=&quot;kwrd&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;kwrd&quot;&gt;return&lt;/span&gt;;
            }
        } &lt;span class=&quot;kwrd&quot;&gt;catch&lt;/span&gt; (Exception e) {
            &lt;span class=&quot;rem&quot;&gt;//错误处理&lt;/span&gt;
            doException(request, e);
        }
    }
&lt;/pre&gt;
&lt;p&gt;从上面的代码中可以看到，我们巧妙的利用了缓存组件的特性来实现。每当有请求进来，缓存组件中的key值累加，到达阈值则拒绝后续请求，这样很方便的实现了时间段限流的效果。虽然例子中给的是按照秒来限流的实现，我们可以在此基础上更改为按照分钟或者按照小时来实现的方案。&lt;/p&gt;
&lt;p&gt;优点：操作简单，可靠性强&lt;/p&gt;
&lt;p&gt;缺点：突增的流量，会导致每个请求都会访问guava，由于guava是堆内内存实现，势必会对性能有一点点影响。其实如果怕限流影响到其他内存计算，我们可以将此限流操作用堆外内存组件来实现，比如利用OHC或者mapdb等。也是比较好的备选方案。&lt;/p&gt;

&lt;p class=&quot;mytitless&quot;&gt;4. 基于漏桶算法的单机限流&lt;/p&gt;
&lt;p&gt;所谓漏桶(&lt;a href=&quot;https://en.wikipedia.org/wiki/Leaky_bucket&quot;&gt;Leaky bucket&lt;/a&gt;)，则是指，有一个盛水的池子，然后有一个进水口，有一个出水口，进水口的水流可大可小，但是出水口的水流是恒定的。下图图示可以显示的更加清晰：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/47012/201810/47012-20181028123426599-1960089450.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/47012/201810/47012-20181028123427216-1167519830.png&quot; alt=&quot;image&quot; width=&quot;480&quot; height=&quot;323&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从图中我们可以看到，水龙头相当于各端的流量，进入到漏桶中，当流量很小的时候，漏桶可以承载这种流量，出水口按照恒定的速度出水，水不会溢出来。当流量开始增大的时候，漏桶中的出水速度赶不上进水速度，那么漏桶中的水位一直在上涨。当流量再大，则漏桶中的水过满则溢。&lt;/p&gt;
&lt;p&gt;由于目前很多MQ，比如rabbitmq等，都属于漏桶算法原理的具体实现，请求过来先入queue队列，队列满了抛弃多余请求，之后consumer端匀速消费队列里面的数据。所以这里不再贴多余的代码。&lt;/p&gt;
&lt;p&gt;优点：流量控制效果不错&lt;/p&gt;
&lt;p&gt;缺点：不能够很好的应付突增的流量。适合保护性能较弱的系统，但是不适合性能较强的系统。如果性能较强的系统能够应对这种突增的流量的话，那么漏桶算法是不合适的。&lt;/p&gt;

&lt;p class=&quot;mytitless&quot;&gt;5. 基于令牌桶算法的单机限流&lt;/p&gt;
&lt;p&gt;所谓令牌桶(&lt;a href=&quot;https://en.wikipedia.org/wiki/Token_bucket&quot;&gt;Token Bucket&lt;/a&gt;)，则是指，请求过来的时候，先去令牌桶里面申请令牌，申请到令牌之后，才能去进行业务处理。如果没有申请到令牌，则操作终止。具体说明如下图：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/47012/201810/47012-20181028123427682-1967746705.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/47012/201810/47012-20181028123428469-1514270438.png&quot; alt=&quot;image&quot; width=&quot;469&quot; height=&quot;273&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于生成令牌的流量是恒定的，面对突增流量的时候，桶里有足够令牌的情况下，突增流量可以快速的获取到令牌，然后进行处理。从这里可以看出令牌桶对于突增流量的处理是容许的。&lt;/p&gt;
&lt;p&gt;由于目前guava组件中已经有了对令牌桶的具体实现类：RateLimiter， 所以我们可以借助此类来实现我们的令牌桶限流。代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharpcode&quot;&gt;
    &lt;span class=&quot;rem&quot;&gt;//指定每秒放1个令牌&lt;/span&gt;
    &lt;span class=&quot;kwrd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; RateLimiter limiter = RateLimiter.create(1);
    &lt;span class=&quot;rem&quot;&gt;//令牌获取超时时间&lt;/span&gt;
    &lt;span class=&quot;kwrd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; final &lt;span class=&quot;kwrd&quot;&gt;long&lt;/span&gt; acquireTimeout = 1000;
    &lt;span class=&quot;rem&quot;&gt;//业务处理方法&lt;/span&gt;
    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; invoke(Request request) {
        &lt;span class=&quot;kwrd&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;rem&quot;&gt;//拿到令牌则进行业务处理&lt;/span&gt;
            &lt;span class=&quot;kwrd&quot;&gt;if&lt;/span&gt; (limiter.tryAcquire(acquireTimeout, TimeUnit.MILLISECONDS)) {
                &lt;span class=&quot;rem&quot;&gt;//业务处理&lt;/span&gt;
                doBusiness(request);
            }
            &lt;span class=&quot;rem&quot;&gt;//拿不到令牌则退出&lt;/span&gt;
            &lt;span class=&quot;kwrd&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;kwrd&quot;&gt;return&lt;/span&gt;;
            }
        } &lt;span class=&quot;kwrd&quot;&gt;catch&lt;/span&gt; (Exception e) {
            &lt;span class=&quot;rem&quot;&gt;//错误处理&lt;/span&gt;
            doException(request, e);
        }
    }
&lt;/pre&gt;
&lt;p&gt;从上面代码我们可以看到，一秒生成一个令牌，那么我们的接口限定为一秒处理一个请求，如果感觉接口性能可以达到1000tps单机，那么我们可以适当的放大令牌桶中的令牌数量，比如800，那么当突增流量过来，会直接拿到令牌然后进行业务处理。但是当令牌桶中的令牌消费完毕之后，那么请求就会被阻塞，直到下一秒另一批800个令牌生成出来，请求才开始继续进行处理。&lt;/p&gt;
&lt;p&gt;所以利用令牌桶的优缺点就很明显了：&lt;/p&gt;
&lt;p&gt;有点：使用简单，有成熟组件&lt;/p&gt;
&lt;p&gt;缺点：适合单机限流，不适合分布式限流。&lt;/p&gt;

&lt;p class=&quot;mytitless&quot;&gt;6. 基于redis lua的分布式限流&lt;/p&gt;
&lt;p&gt;由于上面5中限流方式都是单机限流，但是在实际应用中，很多时候我们不仅要做单机限流，还要做分布式限流操作。由于目前做分布式限流的方法非常多，我就不再一一赘述了。我们今天用到的分布式限流方法，是redis+lua来实现的。&lt;/p&gt;
&lt;p&gt;为什么用redis+lua来实现呢？原因有两个：&lt;/p&gt;
&lt;p&gt;其一：redis的性能很好，处理能力强，且容灾能力也不错。&lt;/p&gt;
&lt;p&gt;其二：一个lua脚本在redis中就是一个原子性操作，可以保证数据的正确性。&lt;/p&gt;
&lt;p&gt;由于要做限流，那么肯定有key来记录限流的累加数，此key可以随着时间进行任意变动。而且key需要设置过期参数，防止无效数据过多而导致redis性能问题。&lt;/p&gt;
&lt;p&gt;来看看lua代码：&lt;/p&gt;
&lt;pre class=&quot;csharpcode&quot;&gt;
            --限流的key
            local key = &lt;span class=&quot;str&quot;&gt;'limitkey'&lt;/span&gt;..KEYS[1]

            --累加请求数
            local val = tonumber(redis.call(&lt;span class=&quot;str&quot;&gt;'get'&lt;/span&gt;, key) or 0)

            --限流阈值
            local threshold = tonumber(ARGV[1])

            &lt;span class=&quot;kwrd&quot;&gt;if&lt;/span&gt;  val&amp;gt;threshold then
                --请求被限
                &lt;span class=&quot;kwrd&quot;&gt;return&lt;/span&gt; 0
            &lt;span class=&quot;kwrd&quot;&gt;else&lt;/span&gt;
                --递增请求数
                redis.call(&lt;span class=&quot;str&quot;&gt;'INCRBY'&lt;/span&gt;, key, &lt;span class=&quot;str&quot;&gt;&quot;1&quot;&lt;/span&gt;)
                --5秒后过期
                redis.call(&lt;span class=&quot;str&quot;&gt;'expire'&lt;/span&gt;, key, 5)
                --请求通过
                &lt;span class=&quot;kwrd&quot;&gt;return&lt;/span&gt; 1
            end
&lt;/pre&gt;
&lt;p&gt;之后就是直接调用使用，然后根据返回内容为0还是1来判定业务逻辑能不能走下去就行了。这样可以通过此代码段来控制整个集群的流量，从而避免出现雪崩效应。当然此方案的解决方式也可以利用zk来进行，由于zk的强一致性保证，不失为另一种好的解决方案，但是由于zk的性能没有redis好，所以如果在意性能的话，还是用redis吧。&lt;/p&gt;
&lt;p&gt;优点：集群整体流量控制，防止雪崩效应&lt;/p&gt;
&lt;p&gt;缺点：需要引入额外的redis组件，且要求redis支持lua脚本。&lt;/p&gt;

&lt;p class=&quot;mytitless&quot;&gt;总结&lt;/p&gt;
&lt;p&gt;通过以上6种限流方式的讲解，主要是想起到抛砖引玉的作用，期待大家更好更优的解决方法。&lt;/p&gt;
&lt;p&gt;以上代码都是伪代码，使用的时候请进行线上验证，否则带来了副作用的话，就得不偿失了。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 04:34:00 +0000</pubDate>
<dc:creator>程序诗人</dc:creator>
<og:description>在系统架构设计当中，限流是一个不得不说的话题，因为他太不起眼，但是也太重要了。这点有些像古代镇守边陲的将士，据守隘口，抵挡住外族的千军万马，一旦隘口失守，各种饕餮涌入城内，势必将我们苦心经营的朝堂庙店</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/scy251147/p/9865099.html</dc:identifier>
</item>
<item>
<title>【AutoFac】依赖注入和控制反转的使用 - YanBigFeg</title>
<link>http://www.cnblogs.com/yanbigfeg/p/9855960.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanbigfeg/p/9855960.html</guid>
<description>&lt;p&gt;在开始之前首先解释一下我认为的依赖注入和控制反转的意思。（新手理解，哪里说得不正确还请指正和见谅）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制反转：&lt;/strong&gt;我们向IOC容器发出获取一个对象实例的一个请求，IOC容器便把这个对象实例“注入”到我们的手中，在这个时候我们不是一个创建者，我们是以一个请求者的身份去请求容器给我们这个对象实例。我们所有的对象依赖于容器提供给你的资源，控制权落到了容器身上。在这里的身份转化或许就是控制反转的核心吧。　&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;依赖注入：&lt;/strong&gt;我们向容器发出请求以后，获得这个对象实例的过程就叫依赖注入。也就是我们在使用对向前我们都需要先注入也就是这个意思吧。&lt;/p&gt;
&lt;p&gt; 今天学习了下AutoFac依赖注入这个插件，然后还有以前用过的Unity这个插件简单做个笔记整理。首先我分两个部分记录，第一部分一点有点的记录今天学习的AutoFac这个插件，最后一部分直接补上以前使用Unity插件的代码封装不做详细解释。&lt;/p&gt;
&lt;h2&gt;AutoFac入门&lt;/h2&gt;
&lt;p&gt;还是放上官网给出的整合流程吧;&lt;/p&gt;
&lt;ul class=&quot;simple&quot;&gt;&lt;li&gt;按照&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;em&gt;控制反转&lt;/em&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; (IoC) 的思想构建你的应用.&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;添加Autofac引用.&lt;/li&gt;
&lt;li&gt;在应用的 startup 处...&lt;/li&gt;
&lt;li&gt;创建&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;cite&gt;ContainerBuilder&lt;/cite&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;注册组件.&lt;/li&gt;
&lt;li&gt;创建容器,将其保存以备后续使用.&lt;/li&gt;
&lt;li&gt;应用执行阶段...&lt;/li&gt;
&lt;li&gt;从容器中创建一个生命周期.&lt;/li&gt;
&lt;li&gt;在此生命周期作用域内解析组件实例.&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;创建简单的例子&lt;/h3&gt;
&lt;p&gt;通过一个控制台简单清晰的介绍了如何使用AutoFac这个插件。&lt;/p&gt;
&lt;h3&gt;创建项目&lt;/h3&gt;
&lt;p&gt;    创建一个控制台程序叫AutoFacDome。&lt;/p&gt;
&lt;p&gt;    这里就不做过多解释了，大家都会创建哈哈。&lt;/p&gt;
&lt;h3&gt;引用&lt;span class=&quot;Apple-converted-space&quot;&gt;Autofac&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;使用我vs强大的nuget来进行添加引用：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;直接在搜索栏输入Autofac直接就可以查找出来：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/809005/201810/809005-20181026141413785-665908443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; Nuget命令行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
Install-Package Autofac -Version 4.8.1
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; 创建一个依赖关系类：&lt;/h3&gt;
&lt;p&gt;首先我们定义一个服务接口=&amp;gt;IService&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 服务接口
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 描述：为了方法的继承和扩展更好的演示下面的例子
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IService
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个输出方法&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PrintWord();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们在创建一个服务类去实现接口(IService)=&amp;gt;Service&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 服务类具体实现
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Service : IService
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出方法的实现&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PrintWord()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是service打印的Hello word&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了现在我们有了一个服务接口和一个服务类 ，并且类下面实现了输出会打印：我是service打印的Hello word。常规我们想调用这个方法我们都是在mian函数中示例化该类进行调用，类似于这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            IService service = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Service();
            service.PrintWord();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;
            Service service2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Service();
            service2.PrintWord();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是今天我们说的不是这些我们说的另外的方式。那我们看看 autofac是怎么调用的。&lt;/p&gt;
&lt;h3&gt;注册容器&lt;/h3&gt;
&lt;p&gt;其实万变不离其宗，不管是autofac，unity，spring.net等，其实都是这么一个套路就是先注册容器然后才能从容器取出，其实这个也非常好理解容器本身是没有东西的，你想用东西就要提前放进去，只有容器有了你请求才会给你。不同的插件只不过是各自的封装方法或者形式存在着差异。autofac的注册方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
           &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建容器&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContainerBuilder();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册对象&lt;/span&gt;
            builder.RegisterType&amp;lt;Service&amp;gt;().As&amp;lt;IService&amp;gt;&lt;span&gt;();
            Container &lt;/span&gt;= builder.Build();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候我们就相当于把service类放入了容器，这样在后面你才可以取出来使用。&lt;/p&gt;
&lt;h3&gt;使用容器&lt;/h3&gt;
&lt;p&gt;这里我写了两个使用的方法根据不同情况使用把：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用方法一&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ioc =&lt;span&gt; Container.BeginLifetimeScope())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; service = ioc.Resolve&amp;lt;IService&amp;gt;&lt;span&gt;();
                service.PrintWord();
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用方法二
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;var service = Container.Resolve&amp;lt;IService&amp;gt;();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;service.PrintWord();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;运行&lt;/h3&gt;
&lt;p&gt;我们可以任意注释一个方法来检测一下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/809005/201810/809005-20181026144544272-546363675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们就完成了autofac的简单运用。&lt;/p&gt;
&lt;h2&gt;AutoFac新手村&lt;/h2&gt;
&lt;p&gt;通过上面的例子我们已经知道autofac的基本运用。基本运用还不行我们还要知道一些知识。&lt;/p&gt;
&lt;h3&gt;多构造函数&lt;/h3&gt;
&lt;p&gt;第一种：就是单纯的有多个构造&lt;/p&gt;
&lt;p&gt;如果我们同一个类存在多个构造函数会给我们一个什么结果哪这个在有时候是非常重要的。&lt;/p&gt;
&lt;p&gt;所以我们修改我们的service类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 服务类具体实现
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Service : IService
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认构造&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Service() {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是service的默认构造&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个参数的构造&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Service(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是service的一个参数构造&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个参数的构造&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Service(&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是service的两个参数构造&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出方法的实现&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PrintWord()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是service打印的Hello word&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他都不变运行代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/809005/201810/809005-20181026150221391-1830519167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里就是执行了默认构造，所有在一个类有多个构造情况下默认的形式是返回给我们默认构造函数的类实例。&lt;/p&gt;
&lt;p&gt;第二种：多构造参数类型并且参数类型也注册容器&lt;/p&gt;
&lt;p&gt;这个什么意思哪就是说有两个类，其中一个类的构造函数参数是另一个类。并且参数类型也进行注册容器&lt;/p&gt;
&lt;p&gt;我们增加一个ServiceTwo类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ServiceTwo :IService
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出方法的实现&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PrintWord()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是serviceTwo打印的Hello word&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改service类中的一个参数构造为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个参数的构造&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Service(ServiceTwo two)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是service的一个参数构造&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;main函数增加注册：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册对象&lt;/span&gt;
            builder.RegisterType&amp;lt;Service&amp;gt;().As&amp;lt;IService&amp;gt;&lt;span&gt;();
            builder.RegisterType&lt;/span&gt;&amp;lt;ServiceTwo&amp;gt;&lt;span&gt;();
            Container &lt;/span&gt;= builder.Build();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后运行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/809005/201810/809005-20181026150713968-66759375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里就和上面的结果不一样了，所有在使用时需要注意，autofac官方解释为：当使用基于反射的组件时,&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;strong&gt;Autofac 自动为你的类从容器中寻找匹配拥有最多参数的构造方法。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;说白了就是如果使用注册类并且注册类多构造函数，并且其构造参数为其他注册类时候，查找的构造函数包含注册类最多的构造函数返回。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 指定构造函数&lt;/h3&gt;
&lt;p&gt;由容器掌握我们的构造函数总是不好的，所有我们要自己指定想创建谁创建谁=&amp;gt;&lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;UsingConstructor（参数类型）可以多个&lt;/span&gt;&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pre&quot;&gt;在这里需要注意我们既然指定了构造函数就要为构造函数传参不然会抱错，参数可以是注册时候传也可以解析时候传，我写了一个解析时候传的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建容器&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContainerBuilder();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册对象&lt;/span&gt;
            builder.RegisterType&amp;lt;Service&amp;gt;().As&amp;lt;IService&amp;gt;().UsingConstructor(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;), &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;));
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; builder.RegisterType&amp;lt;ServiceTwo&amp;gt;();&lt;/span&gt;
            Container =&lt;span&gt; builder.Build();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用方法一&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ioc=&lt;span&gt; Container.BeginLifetimeScope())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; service = ioc.Resolve&amp;lt;IService&amp;gt;(&lt;span&gt;new&lt;/span&gt; NamedParameter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; NamedParameter(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
                service.PrintWord();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/809005/201810/809005-20181026153142256-1080760388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; 类的覆盖&lt;/h3&gt;
&lt;p&gt;如果我两个类或者多个类同时实现一个接口并且注册的时候都与接口做了关联。&lt;/p&gt;
&lt;p&gt;那么会存在覆盖现象。&lt;/p&gt;
&lt;p&gt;下面我们把main函数改造让serviceTwo也注册与IService关联&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建容器&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContainerBuilder();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册对象&lt;/span&gt;
            builder.RegisterType&amp;lt;Service&amp;gt;().As&amp;lt;IService&amp;gt;&lt;span&gt;();
            builder.RegisterType&lt;/span&gt;&amp;lt;ServiceTwo&amp;gt;().As&amp;lt;IService&amp;gt;&lt;span&gt;();
            Container &lt;/span&gt;=&lt;span&gt; builder.Build();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用方法一&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ioc =&lt;span&gt; Container.BeginLifetimeScope())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; service = ioc.Resolve&amp;lt;IService&amp;gt;&lt;span&gt;();
                service.PrintWord();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/809005/201810/809005-20181026154207619-1204191375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候我们得到的是serviceTwo类的示例。如果改变Service和ServiceTwo的位置就会返回service实例。&lt;/p&gt;
&lt;h3&gt; 属性注入&lt;/h3&gt;
&lt;p&gt;WithProperty：绑定一个属性和他的值&lt;/p&gt;
&lt;p&gt;我们给ServiceTwo类添加name属性并扩展一个打印方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PrintName()
        {
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name属性：{name}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后main函数改为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            builder.RegisterType&amp;lt;Service&amp;gt;().As&amp;lt;IService&amp;gt;&lt;span&gt;();
            builder.RegisterType&lt;/span&gt;&amp;lt;ServiceTwo&amp;gt;().WithProperty(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Container &lt;/span&gt;=&lt;span&gt; builder.Build();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用方法一&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; ioc =&lt;span&gt; Container.BeginLifetimeScope())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; service = ioc.Resolve&amp;lt;ServiceTwo&amp;gt;&lt;span&gt;();
                service.PrintName();
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/809005/201810/809005-20181026155125960-525416738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;方法注入&lt;/h3&gt;
&lt;p&gt;OnActivating：方法注入&lt;/p&gt;
&lt;p&gt;我们在ServiceTwo类添加设置名称方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName()
        {
            name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后main函数改为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
builder.RegisterType&amp;lt;ServiceTwo&amp;gt;().OnActivating(e=&amp;gt;&lt;span&gt; {
                e.Instance.setName();
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/809005/201810/809005-20181026155926525-225475567.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;AutoFac集成-MVC&lt;/h2&gt;
&lt;p&gt;首先创建mvc项目就不过多解释了。&lt;/p&gt;
&lt;h3&gt;引用dll：&lt;/h3&gt;
&lt;p&gt;这里需要引用两个dll文件：&lt;span class=&quot;Apple-converted-space&quot;&gt; Autofac.Mvc5和 Autofac。注意这里我的是mvc5所以我安装的Autofac.Mvc5 这个要根据mvc版本做对应不然会报错。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/809005/201810/809005-20181026175058480-121002604.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;通过nuget安装就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;相关类&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;还是我们的Service类和IService类来做示例演示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 服务接口
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 描述：为了方法的继承和扩展更好的演示下面的例子
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IService
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个输出方法&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PrintWord();
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 服务类具体实现
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Service : IService
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认构造&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Service()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是service的默认构造&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出方法的实现&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; PrintWord()
        {
            System.Diagnostics.Debug.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调起了service中的方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;配置文件&lt;/h3&gt;
&lt;p&gt;配置Global文件，来注入控制器。下面我只做构造函数注入和属性注入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Application_Start()
        {

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContainerBuilder();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过程序集注册所有控制器和属性注入
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;builder.RegisterControllers(typeof(MvcApplication).Assembly);&lt;/span&gt;
&lt;span&gt;            builder.RegisterControllers(Assembly.GetExecutingAssembly()).PropertiesAutowired();



            builder.RegisterType&lt;/span&gt;&amp;lt;Service&amp;gt;().As&amp;lt;IService&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将依赖性分解器设置为AutoFac。&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; container =&lt;span&gt; builder.Build();
            DependencyResolver.SetResolver(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AutofacDependencyResolver(container));


            AreaRegistration.RegisterAllAreas();
            FilterConfig.RegisterGlobalFilters(GlobalFilters.Filters);
            RouteConfig.RegisterRoutes(RouteTable.Routes);
            BundleConfig.RegisterBundles(BundleTable.Bundles);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;控制器如何使用：&lt;/h3&gt;
&lt;p&gt;打开home控制器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : Controller
    {

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 构造函数注入
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;serviceClient&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; HomeController(IService serviceClient)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Service =&lt;span&gt; serviceClient;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IService Service;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 属性注入
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; public IService Service2 { get;  set; }&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Index()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用方法一&lt;/span&gt;
&lt;span&gt;            Service.PrintWord();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Service2.PrintWord();&lt;/span&gt;

            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行看效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/809005/201810/809005-20181026175550022-1805162712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 28 Oct 2018 04:16:00 +0000</pubDate>
<dc:creator>YanBigFeg</dc:creator>
<og:description>在开始之前首先解释一下我认为的依赖注入和控制反转的意思。（新手理解，哪里说得不正确还请指正和见谅） 控制反转：我们向IOC容器发出获取一个对象实例的一个请求，IOC容器便把这个对象实例“注入”到我们的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yanbigfeg/p/9855960.html</dc:identifier>
</item>
<item>
<title>毕业这五年【中】 - 帅帅的鱼</title>
<link>http://www.cnblogs.com/appleyk/p/9864955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/appleyk/p/9864955.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　大学的生活其实没有什么好讲的，值得回忆的地方很多，但是如果硬要说能讲出剧情的，就只有我们寝室了，年级和系里的事情，不是我不愿去写，而是真的没有什么东西可写；老师不会管你学习好坏，只要挂科人数不要太多就好；辅导员也不会管你生活起居，只要你不出事就行；宿管阿姨才不会管你什么时候出去什么时候回来的，只要你进出有校园卡就行【blablabla...】；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　偌大的校园，主要的回忆还是发生在了一个只有20平方米的211寝室里了，九台电脑，九台不同的人生【容我再插几句】：上一篇说了，博主所在的专业是.net方向，全称是：计算机科学与技术-软件开发.Net，当时C#那时候叫一个火啊【那时候我还是小白，只知道诺基亚手机上的程序是用Java写的，其他不知道，那时候觉得微软技术真的的很酷，后来的后来，我就不这样想了&lt;/span&gt;&lt;span&gt;】，感觉做出来的winform程序老牛逼了，还有asp.net，上课的时候老是听不懂老师在讲什么，乌拉乌拉的，他一个人是讲舒服了，下面睡觉和玩手机的一片，整个课件差不多都是代码代码，后来才知道，听代码不如敲代码【代码这东西，你听会了和会了是两码事】，随后在寝室索性自己捣鼓，有点头绪后又觉得做出来的动态网页是真特么帅啊【说真的，那时候是真白啊，一张白纸，遗憾的是，后来博主没有将大学所学的学科发扬光大】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　现在想想，那时候支撑我学下去的动力是什么呢？是喜欢学习吗？还是觉得自己认真学习的样子很帅？还是觉得游戏不够好玩？不，都不是。是兴趣！既然谈到兴趣，我就不得不说下，虽然我们寝室九个人，同样的专业，但是毕业后的人生方向简直不带重样的，我不排序，你们也不要对号入座哈，我说一下九个人目前的工作性质:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　( 1 ) 产品设计经理、（2）项目架构师、（3）前端工程师、（4）自己单干，算是创业，接项目的、（5）某软件销售员、（6）人民律师、（7）某保险业某区域总经理、（8）后端研发工程师、（9）高速路口收费站职员&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可谓是九个人，九个完全不同的行业，相同点只有一个：大学四年学的什么.net方向啊，一个也没有从业者，至少我们还有四个目前是从事IT这个行业的，算是码农了，但是多数拥抱的却是Java这一大生态圈【没办法，需求决定了市场，市场决定了经济，经济决定了我们从业者的择业方向】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不知不觉又写了这么多，大学的事就此打住，下面我来写写校园外的事情，那也是相当的精彩啊.......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　大四实习的时候，要选实习的单位和去处【说白了，对于计算机专业的学生来说，实习单位多数指那些需要交钱的培训机构】，这时候寝室九个人分成了三派，一派是自学派，留在学校考研或者自学的；一派是进入社会体验生活的，当然是有工资可拿的；最后一派就是以我为首的培训派，总过四个人，别看那时候专业是.net，但是我们培训派的哥四个还是分出了两拨，一拨是我、小茗加宿舍长的C++派【我们仨经常在一起玩游戏，对游戏开发比较感兴趣，我和小茗在敲代码上面比较有天赋，寝室长是被我俩怂恿过去的】，另一拨不用说，就一个人，他是谁呢，就是睡在博主下铺的小迪同学【我俩是老乡，一个地方的，他比我大好几岁，小迪叫起来很亲切，于是乎现在还这样称呼他，哈哈】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们培训派四个选了一个地方，具体哪个培训机构这里我就不说了，我只想说，是真贵啊！现在想想，当初选什么培训机构啊，有那钱不如租个好点的房子，找个对口的工作，哪怕实习期三个月我不要钱，你让我先进去再说，我能学，我想学！然后找个大神稍微带一下，也比一屋子几十号人听着讲师一个人在那边讲边敲代码要好，不是我埋汰有些培训机构啊，是培训机构交出来的东西真的很基础很基础，不是说基础不重要，基础也很重要，但是基础知识真的不值那么多钱，OK？说到底，还是我们这些选择了培训机构的人太懒，放着学校那么好的教育资源和时间不充分利用，反而是快毕业了想速成一下，结果钱也进去了，效果倒是达到了，但是离世面上公司的要求却是相差一大截。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们四个每天就是两点一线【当时培训机构提供住宿的地方，不是免费的那种，收费的，相对来说比较便宜，所以说，能入社会的就趁早，不要觉得培训机构很高大上，很信任何依赖他们】，几个月下来，我映像最深就是早晨的煎饺【南方煎饺，油很多，但很好吃】和晚上路边小摊上炒的河粉【配上啤酒，那叫一个舒服】，其他的没什么映像，至于课上讲师讲了什么做了什么，记不清了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　培训期间还发生了一个小插曲，这个插曲直接决定了明年我要结婚的对象，说来真是太神奇了，太有缘分了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　实习是发生在12年，那时候微信刚出来没多久，还没达到现在这么的普及，那时候移动有个叫飞信的业务，发短信也不要钱，也是基于通信基站流量的，当时博主手机是诺基亚5230，还没有装飞信，有一天，小迪给我推荐这款软件，说是不错，让我试一试，结果我就装了，后来研究了几天，发现它有一个功能挺好玩的，这个功能就是&quot;小字条&quot;，类似于现在微信的摇一摇捡瓶子【这让我那无处安放的寂寞的小心心啊总算有了着落】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　起初玩这个就是为了打发时间，写一些文字扔出去，管他有没有人收着呢，反正那时候就是稀罕，万一收着回我一句呢；没事的时候【夜深人静】，喜欢捡一些字条，一天好像不能超过十次，而且那个时候，经常有一些奇怪的人发一些奇怪的文字和图片，文字略带挑逗，你说我一涉世未深的小伙子，你发一些这，让我怎么想【哈哈】；更可怕的是，图片还很骚气，这我就受不了，我跟你说，是艺术请别打码，是色情请别传播，好家伙，&lt;/span&gt;&lt;span&gt; 你这不是污染网络环境吗；于是，每次见到这些小字条我都要回复一下：&quot;有什么请冲我来！&quot;，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434157/201810/1434157-20181028143032317-1019105807.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　博主有个毛病，就是喜欢记流水账，一件事情又想讲得细，又想讲的精，结果就是把一件事情讲的很混乱，如果你看过我在CSDN上的博客，你就会觉得我这个人还是挺有耐心的，哈哈，挺好的，还不错。　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　有一天呢，我收到了一个不一样的字条，字条就一张图片，一张青涩稚嫩的少女照，一看就是本人了；我心一想，这可不行啊，这么纯净的一张脸，出现在这乌七八糟的网络环境里，总感觉会有坏人企图；我当时觉得自己就是一个救世主，于是，我主动回了过去：这是你本人吗？【明知故问】，没想太多，回不回我都无所谓，习惯了；可是，电视剧中的套路剧情就是这么开始的，女主回复我了，于是乎我们就有了第一次的对话、第二次的对话、第三...后来互加了企鹅，再后来，我俩都卸载了飞信；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当时得知，女主还是一个初中生【初三】，我的天啊，什么概念，我都快大学毕业了好吧；本来以为可以发生点什么，比如网络一线牵啊，红颜知己什么的，一想到网络对面的她还是一个未成年的小姑娘时，我打消了自己美好的念想，开始做起了女主的思想和人生导师【后来成了她的大叔，再后来成了她的男朋友，再后来，就是今天，刚定了我们的婚戒】；&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434157/201810/1434157-20181028153110632-992403063.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　当时一边上着培训课，一边和女主聊着QQ，我这个人还是很会聊天的，但是分人，不同的人聊天的内容不一样，对于女主这种的，我就聊学习和聊生活的态度，那时候真的没有任何邪念，而且我们也不是天天都聊，那时候她称呼我为师傅，你知道别人叫你一声师傅意味着什么嘛，意味着责任！后来只要她在学习和生活上有什么困惑，只要我在，我都第一时间开导她，女孩子，思想很重要，不像男孩子，叛逆了学坏了还可以打可以骂，女孩子一旦学坏了，就堕落了，很可怕的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那时候我和女主还没有恋情上的苗头，偶尔联系，关系很清楚，只是后来，缘分实在是看不下去了，才促使我们从朋友转变成了恋人，再从恋人发展到异地恋再到如今的，我是她亲爱的鱼，她是我最爱的宝【博主15年从部队复员回来后，过了一个月，就和女主奔现了，后面会说到】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　实习结束后，小迪选择留在了杭州找工作继续实习，我和寝室长还有小茗我们仨回到了学校，回来就是玩，唉，年少不知钱难赚啊；当时博主也没有紧接着去找一份和C++有关的工作，那时候马上要过年了，再加上天变冷了【当初是11月份了】，我又是一个恋家的人，于是乎，就选择回家了，回家干了一件大事，就是考驾照，哈哈【13年】；当时在驾校也认识了一大帮人，基本都是在校学生，有女生也有男生，博主人缘还不错【面善，声音富有磁性】，在这一帮人中很是深得女生的青睐，没办法，别人觉得你有魅力，你就是有魅力，我也不知道为什么；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;span&gt;　考驾照还算顺利，两个月左右就拿到了【当时博主科二考试的时候，第一遍没过，好在倒库有两次机会，我抓住了】，拿到驾照已经是五月份了【博主回家后从11月份玩到了过年，过完年3月份去报的驾校】，这时候学校开始毕业答辩了，就回学校了；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　六月，毕业季，一切都很顺利，寝室哥九个人顺利完成答辩、顺利拿到毕业证和学士学位证，一起吃了散伙饭，拍了毕业照，然后就收拾东西，该回家的回家，该踏入社会的踏入社会，该留校的留校....&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1434157/201810/1434157-20181028154220722-1698833837.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　出了校门后，我就开始投简历，由于没什么工作经验，就把在学校的表现和培训机构学的一些基础知识和做过的项目放在了简历上，那时候对工作和薪资没什么要求，一是因为刚出来，清楚自己几斤几两，第二个就是因为当初生活压力不是太大，自己少赚点，家里多补贴点，自己多赚点，家里就少补贴点【中国有的的孩子真是太幸福了，成人了，还要依赖父母，那时候博主还不知道挣钱难，体会不了做父母的辛苦】；面了好几家公司，最后有一家做汽车检测线设备的公司要了我；我当初一心想找一个游戏开发的公司实习，但现实是，当时我所在的城市要么做游戏的不是搞C++的，要么搞C++看不上我的，我能怎么办？ 　　&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这家公司是做硬件设备的，开发的程序大多是和设备有关的接口程序，公司的规模也比较小，实施工程师3个，人事一个，管财务的是老板娘，C++开发的三个人，我来了后打了两周的酱油，负责开发的项目经理给我模块，让我看代码，&lt;/span&gt;&lt;/p&gt;




&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 28 Oct 2018 03:39:00 +0000</pubDate>
<dc:creator>帅帅的鱼</dc:creator>
<og:description>大学的生活其实没有什么好讲的，值得回忆的地方很多，但是如果硬要说能讲出剧情的，就只有我们寝室了，年级和系里的事情，不是我不愿去写，而是真的没有什么东西可写；老师不会管你学习好坏，只要挂科人数不要太多就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/appleyk/p/9864955.html</dc:identifier>
</item>
<item>
<title>使用PHP结合Ffmpeg快速搭建流媒体服务实践 - idaxia</title>
<link>http://www.cnblogs.com/tangqingsong/p/9864905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tangqingsong/p/9864905.html</guid>
<description>&lt;h2 id=&quot;一背景&quot;&gt;一、背景&lt;/h2&gt;
&lt;p&gt;笔者想将自己收藏的一些电影放到网站上可以用来随时播放，不过遇到了一个问题，便是如果直接将MP4文件放放到网站目录当中，手机端必须下载整个视频才可以播放，而如果跨外网传输，这实在是不太现实。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，便想着搭建一套流媒体服务，这样手机就可以边看边下载，查询了一些资料了了解到需要先将视频分成一小片来传输，比如将MP4转码为M3U8格式，查询了相关转码方法，比较主流的方式是使用ffmpeg这个开源工具&lt;/p&gt;
&lt;h2 id=&quot;二操作概要&quot;&gt;二、操作概要&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;1. 安装Ffmpeg
2. 服务搭建
3. 功能测试&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三搭建ffmpeg&quot;&gt;三、搭建ffmpeg&lt;/h2&gt;
&lt;p&gt;视频转码的工具可能有很多，但开源且使用人数最多的还是莫过于ffmpeg这个工具，具体功能笔者不在这里详细讲解；安装此工具的方式有很多，比如apt安装、源码安装、docker安装等等，不过docker是跨平台的，因此笔者这里将以docker方式安装为例&lt;/p&gt;
&lt;h3 id=&quot;镜像下载&quot;&gt;3.1 镜像下载&lt;/h3&gt;
&lt;p&gt;首先笔者需要下载对应的docker镜像，参考命令如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker pull jrottenberg/ffmpeg&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令执行过程中将会从远处下载镜像，这个时间由当前的网络带宽所决定，当下载完成之后，可以看到如下参考信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Using default tag: latest
latest: Pulling from jrottenberg/ffmpeg
b234f539f7a1: Pull complete
55172d420b43: Pull complete
5ba5bbeb6b91: Pull complete
43ae2841ad7a: Pull complete
f6c9c6de4190: Pull complete
2a0ef76bfa54: Pull complete
40ddf796a4bb: Pull complete
32ba137d2764: Pull complete
Digest: sha256:bcf65375f593518de7e450fd6b775d16a047d3ded00957c2e794e2fe8f7e1590
Status: Downloaded newer image for jrottenberg/ffmpeg:latest&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;容器运行&quot;&gt;3.2 容器运行&lt;/h3&gt;
&lt;p&gt;当容器下载完毕之后，可以用一些命令进行验证是否能够正常运行，如下参考命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run jrottenberg/ffmpeg&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令执行完毕之后，会返回如下结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
Hyper fast Audio and Video encoder
usage: ffmpeg [options] [[infile options] -i infile]... {[outfile options] outfile}...

Getting help:

..... 省略

Audio options:
-aframes number     set the number of audio frames to output
-aq quality         set audio quality (codec-specific)
-ar rate            set audio sampling rate (in Hz)
-ac channels        set number of audio channels
-an                 disable audio
-acodec codec       force audio codec ('copy' to copy stream)
-vol volume         change audio volume (256=normal)
-af filter_graph    set audio filters

Subtitle options:
-s size             set frame size (WxH or abbreviation)
-sn                 disable subtitle
-scodec codec       force subtitle codec ('copy' to copy stream)
-stag fourcc/tag    force subtitle tag/fourcc
-fix_sub_duration   fix subtitles duration
-canvas_size size   set canvas size (WxH or abbreviation)
-spre preset        set the subtitle options to the indicated preset&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查看支持协议&quot;&gt;3.3 查看支持协议&lt;/h3&gt;
&lt;p&gt;FFmpeg所支持的输入输出协议非常多，比如可以选择file协议作为来源，使用hls协议作为输出结果，具体所支持的协议可以通过如下命令查看&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run jrottenberg/ffmpeg   -protocols&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行命令之后，参考结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ffmpeg version 3.4.2 Copyright (c) 2000-2018 the FFmpeg developers
  built with gcc 5.4.0 (Ubuntu 5.4.0-6ubuntu1~16.04.9) 20160609
  configuration: --disable-debug --disable-doc --disable-ffplay --enable-shared --enable-avresample --enable-libopencore-amrnb --enable-libopencore-amrwb --enable-gpl --enable-libass --enable-libfreetype --enable-libvidstab --enable-libmp3lame --enable-libopenjpeg --enable-libopus --enable-libtheora --enable-libvorbis
  ..... 省略
  Supported file protocols:
Input:
  async
  cache
  concat
  crypto
  data
  ..... 省略
Output:
  crypto
  file
  ..... 省略
  tls
  udp&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;转换测试&quot;&gt;3.4 转换测试&lt;/h3&gt;
&lt;p&gt;现在笔者使用FFmpeg对视频进行转码测试，命令非常简单，首先需要通过&lt;code&gt;-v&lt;/code&gt;将视频所在的目录挂载到容器中，然后使用&lt;code&gt;-i&lt;/code&gt;选项找到容器中对应的视频文件;&lt;/p&gt;
&lt;p&gt;接着就可以对编码进行一些选项，比如&lt;code&gt;-hls_time 10&lt;/code&gt;便是将文件没10秒输出一个TS文件，&lt;code&gt;-hls_list_size 0&lt;/code&gt; 则是在m3u8文件中记录所以&lt;code&gt;ts&lt;/code&gt;文件(默认是记录最后五个TS文件)，参数最后则填写文件输出路径，具体参考命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -v /Users/song/video:/root/download  jrottenberg/ffmpeg:latest -i /root/download/1.mp4  -hls_time 10 -hls_list_size 0 -f hls /root/download/index.m3u8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令执行过程中会展示转换进度，参考如下返回所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  Metadata:
    major_brand     : mp42
    minor_version   : 0
    compatible_brands: mp42mp41
    encoder         : Lavf57.83.100
    Stream #0:0(eng): Video: h264 (libx264), yuv420p(progressive), 1920x1080, q=-1--1, 30 fps, 90k tbn, 30 tbc (default)
    Metadata:
      creation_time   : 2018-08-21T15:09:24.000000Z
      handler_name    : Alias Data Handler
      encoder         : Lavc57.107.100 libx264
    Side data:
      cpb: bitrate max/min/avg: 0/0/0 buffer size: 0 vbv_delay: -1
    Stream #0:1(eng): Audio: aac, 48000 Hz, stereo, fltp, 128 kb/s (default)
    Metadata:
      creation_time   : 2018-08-21T15:09:24.000000Z
      handler_name    : Alias Data Handler
      encoder         : Lavc57.107.100 aac
frame=   82 fps= 12 q=29.0 size=N/A time=00:00:02.62 bitrate=N/A speed=0.381x&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时便可以在刚才的挂载点查看TS文件，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.songboy.net/ffmpeg/1.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在笔者将刚才的TS文件都删除，在下面将使用自动化完成。&lt;/p&gt;
&lt;h2 id=&quot;四服务搭建&quot;&gt;四、服务搭建&lt;/h2&gt;
&lt;p&gt;在上一步中笔者已经成功通过终端使用FFmpeg将视频进行转码，下面笔者将结合PHP代码将这些操作完全自动化实现，这样便可以达到通过手机访问网站，服务端自动完成转码播放的需求，这个过程包括创建虚拟主机、编写展示视频列表、视频自动解码三个部分&lt;/p&gt;
&lt;h3 id=&quot;创建虚拟主机&quot;&gt;4.1 创建虚拟主机&lt;/h3&gt;
&lt;p&gt;首先笔者需要借助nginx搭建一个web服务，这时便需要修改配置文件，但并不记得nginx配置文件存放位置，此时可以借助如下命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo nginx -t&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到结果如下，在结果中可以便可以看到nginx的配置文件存放位置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nginx: the configuration file /usr/local/etc/nginx/nginx.conf syntax is ok
nginx: configuration file /usr/local/etc/nginx/nginx.conf test is successful&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用vim编辑器直接编辑nginx配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /usr/local/etc/nginx/nginx.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在配置文件中加入如下参考配置信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    server {
        listen       8089;
        server_name  localhost;
        root  /Users/song/mycode/work/test/video;
        location / {
            index index.html index.htm index.php; 
        }

        location ~ \.php$ {
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi_params;
        }

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取视频列表&quot;&gt;4.2 获取视频列表&lt;/h3&gt;
&lt;p&gt;nginx配置完成之后，便需要编写PHP代码，通过PHP可以获取到目录的视频列表，然后将其输出到网页当中，参考代码如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
    $list = scandir('/Users/song/video/');

    foreach ($list as $key =&amp;gt; $val) {
        if (!in_array(pathinfo($val, PATHINFO_EXTENSION), ['mp4', 'rmvb', 'wmv'])) {
            continue;
        }

        ?&amp;gt;

        &amp;lt;a class=&quot;btn btn-default btn-video btn-lg&quot; href=&quot;./encode.php?name=&amp;lt;?= $val ?&amp;gt;&quot; role=&quot;button&quot;&amp;gt;
            &amp;lt;h2&amp;gt;&amp;lt;?= $val ?&amp;gt;&amp;lt;/h2&amp;gt;&amp;lt;/a&amp;gt;

    &amp;lt;?php }
} ?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在代码中，首先通过&lt;code&gt;scandir&lt;/code&gt;读取文件夹下所有文件，然后进行foreach循环，通过后缀名来判断是否为视频文件，如果是视频文件，则输出一个链接地址方便用户选择。&lt;/p&gt;
&lt;h3 id=&quot;进行视频转码&quot;&gt;4.3 进行视频转码&lt;/h3&gt;
&lt;p&gt;上面的代码在列出视频列表之后，当用户点击链接后就需要使用FFmpeg进行转码，参考代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php

//接收必要参数
$name = $_GET['name'] ?? '1.mp4';
$forced = $_GET['forced'] ?? 0;
$fileName = getFileName($name);

$outPath = '/Users/song/video';
$inPath = '/root/download';
$dir = __DIR__;

//判断之前是否已经转码,如果不强制转码便先返回
if (is_dir(&quot;$outPath/$fileName&quot;) &amp;amp;&amp;amp; empty($forced)) {
    header(&quot;location:./static/{$fileName}/index.m3u8&quot;);
    die;
}

//将目标映射过来
system(&quot;ln -s {$outPath}  {$dir}/static&quot;);

//先创建文件夹
system(&quot;mkdir -p {$outPath}/{$fileName}&quot;);

//进行转码
$ffmpeg = &quot;docker run -v $outPath:/root/download  jrottenberg/ffmpeg:latest&quot;;
$cmd = &quot;nohup $ffmpeg -i {$inPath}/{$name}  -hls_time 10 -hls_list_size 0 -f hls -r 25 {$inPath}/{$fileName}/index.m3u8 &amp;gt;&amp;gt; ./code.log &amp;amp;&quot;;
system($cmd);


//延时执行跳转
returnUrl($fileName);

function getFileName($filename)
{
    $houzhui = substr(strrchr($filename, '.'), 1);
    $result = basename($filename, &quot;.&quot; . $houzhui);

    return $result;

}

function returnUrl($fileName)
{
    echo &quot;&amp;lt;a class='btn  btn-video btn-lg' href='./static/{$fileName}/index.m3u8'&amp;gt;&amp;lt;h1&amp;gt;正在处理中...点击进行跳转&amp;lt;/h1&amp;gt;&amp;lt;/a&amp;gt;&quot;;
    die;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面代码当中，考虑文件是否已经被转码，如果已经转码过了直接返回播放地址，否则创建一个存放TS文件的文件夹，然后进行转码，转码的时候使用nohup命令可以让FFmpeg异步执行，然后PHP返回播放地址。&lt;/p&gt;
&lt;h2 id=&quot;五检验与测试&quot;&gt;五、检验与测试&lt;/h2&gt;
&lt;p&gt;通过前面的步骤，笔者已经完整的搭建了一套流媒体服务器，下面将检验这些服务是否能否正常运行，包括视频列表展示、视频转码是否正常、已经转码的视频能否播放&lt;/p&gt;
&lt;h3 id=&quot;视频列表&quot;&gt;5.1 视频列表&lt;/h3&gt;
&lt;p&gt;首先通过浏览器打开URL地址如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:8089/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加载完成之后可以看到如下的视频列表&lt;br/&gt;&lt;img src=&quot;http://tuchuang.songboy.net/ffmpeg/2.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;读者如果将上方的代码运行界面有稍有差异，因为笔者为了节省文章篇幅，并没有将样式代码放到文章当中，如需界面好看可以自行编写样式代码。&lt;/p&gt;
&lt;h3 id=&quot;视频转码&quot;&gt;5.2 视频转码&lt;/h3&gt;
&lt;p&gt;在视频列表点击一个链接之后，后台PHP程序将会执行转码任务，然后返回一个链接地址，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.songboy.net/ffmpeg/3.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时便代表FFmpeg已经在后台运行，可以通过如下命令进行查看FFmpeg这个容器的运行状态，参考命令如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker ps&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回的参考结果如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS              PORTS               NAMES
ac3e7233eb9f        jrottenberg/ffmpeg:latest   &quot;ffmpeg -i /root/dow…&quot;   1 hours ago        Up 1 hours                             keen_feynman&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的返回结果当中可以看出当前正有一个任务处于运行状态，此时打开视频输出目录，会看到有多个ts格式的视频文件，这些文件是刚在通过PHP自动执行所产生的，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.songboy.net/ffmpeg/4.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当看到如上图的转码视频文件时，便可以通过浏览器进行访问&lt;/p&gt;
&lt;h3 id=&quot;视频播放&quot;&gt;5.3 视频播放&lt;/h3&gt;
&lt;p&gt;这里需要记住，&lt;strong&gt;HLS协议是苹果公司所开发的，因此除了苹果的浏览器外，其他浏览器默认都是不支持m3u8的解析的，如果需要使用其他浏览器播放，需要安装插件；苹果的默认就支持则不需要&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;笔者重新通过Safari浏览器打开页面，然后再次选择&lt;code&gt;1.mp4&lt;/code&gt;视频，则直接跳转到了播放页面，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.songboy.net/ffmpeg/5.png?a=1&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这里，搭建流媒体就基本已经完成了，如果需要将更多视频播放，只需要将视频文件存放到指定的视频目录，网页中便会自动读取出来，页面可能太简化，读者可以根据自己的需要将html页面美化一下。&lt;/p&gt;
&lt;h2 id=&quot;六新书推荐&quot;&gt;六、新书推荐&lt;/h2&gt;
&lt;p&gt;如果对笔者的实战文章较为感兴趣，可以关注笔者新书《PHP Web安全开发实战》，现已在各大平台上架销售，封面如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://tuchuang.songboy.net/xss2/19.png?1&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：汤青松&lt;/p&gt;
&lt;p&gt;微信：songboy8888&lt;/p&gt;
&lt;p&gt;日期：2018-10-28&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 03:27:00 +0000</pubDate>
<dc:creator>idaxia</dc:creator>
<og:description>一、背景 笔者想将自己收藏的一些电影放到网站上可以用来随时播放，不过遇到了一个问题，便是如果直接将MP4文件放放到网站目录当中，手机端必须下载整个视频才可以播放，而如果跨外网传输，这实在是不太现实。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tangqingsong/p/9864905.html</dc:identifier>
</item>
</channel>
</rss>