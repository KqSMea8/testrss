<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>ElasticSearch 学习记录之ES几种常见的聚合操作 - 王守昌</title>
<link>http://www.cnblogs.com/wangshouchang/p/8040587.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangshouchang/p/8040587.html</guid>
<description>&lt;h5 id=&quot;es几种常见的聚合操作&quot;&gt;ES几种常见的聚合操作&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;普通聚合&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;POST /product/_search
{
  &quot;size&quot;: 0, 
  &quot;aggs&quot;: {
    &quot;agg_city&quot;: {
      &quot;terms&quot;: {
        &quot;field&quot;: &quot;departureCitys&quot; //字段
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;父子结构的索引的聚合&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;POST product/_search
{
  &quot;size&quot;: 0, 
  &quot;aggs&quot;: {
    &quot;months&quot;: {
      &quot;children&quot;: {
        &quot;type&quot;: &quot;price&quot;//子类型
      },
      &quot;aggs&quot;: {
        &quot;month&quot;: {
          &quot;terms&quot;: {
            &quot;field&quot;: &quot;months&quot;
          }
        }
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;双层嵌套结构索引的聚合查询&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;POST /product/_search
{
  &quot;size&quot;: 0, 
  &quot;aggs&quot;: {
    &quot;theme&quot;: {
      &quot;nested&quot;: {
        &quot;path&quot;: &quot;themes&quot;//嵌套对象
      },
      &quot;aggs&quot;: {
        &quot;agg_category&quot;: {
          &quot;terms&quot;: {
            &quot;field&quot;: &quot;themes.category&quot;//聚合对象
          },
          &quot;aggs&quot;: {
            &quot;agg_name&quot;: {
              &quot;nested&quot;: {
                &quot;path&quot;: &quot;themes.items&quot;//嵌套对象的嵌套对象
              },
              &quot;aggs&quot;: {
                &quot;agg_name&quot;: {
                  &quot;terms&quot;: {
                    &quot;field&quot;: &quot;themes.items.name&quot;,//聚合的对象的路径
                    &quot;size&quot;: 10
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;嵌套结构索引的聚合查询&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;POST /product/_search
{
  &quot;size&quot;: 0, 
  &quot;aggs&quot;: {
    &quot;theme&quot;: {
      &quot;nested&quot;: {
        &quot;path&quot;: &quot;themes&quot;//嵌套对象
      },
      &quot;aggs&quot;: {
        &quot;agg_category&quot;: {
          &quot;terms&quot;: {
            &quot;field&quot;: &quot;themes.category&quot;//聚合对象
          } 
        }
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 14 Dec 2017 15:33:00 +0000</pubDate>
<dc:creator>王守昌</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangshouchang/p/8040587.html</dc:identifier>
</item>
<item>
<title>深入理解java虚拟机-----&gt;垃圾收集器与内存分配策略（下） - Mairr</title>
<link>http://www.cnblogs.com/Mairr/p/8037366.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mairr/p/8037366.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.  前言&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;内存分配与回收策略
&lt;ul&gt;&lt;li&gt;JVM堆的结构分析（新生代、老年代、永久代）&lt;/li&gt;
&lt;li&gt;对象优先在Eden分配&lt;/li&gt;
&lt;li&gt;大对象直接进入老年代&lt;/li&gt;
&lt;li&gt;长期存活的对象将进入老年代&lt;/li&gt;
&lt;li&gt;动态对象年龄判定&lt;/li&gt;
&lt;li&gt;空间分配担保&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 2.  垃圾收集器与内存分配策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;给对象分配内存;&lt;/li&gt;
&lt;li&gt;回收分配给对象的内存。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　对象的内存分配，往大方向上讲就是在堆上的分配，对象主要分配在新生代的Eden区上。少数也可能分配在老年代，取决于哪一种垃圾收集器组合，还有虚拟机中的相关内存的参数设置。下面先介绍一下JVM中的年代划分：新生代、老年代、永久代（JDK1.8后称为元空间）。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 JVM堆的结构分析（新生代、老年代、永久代）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from（S1）和to（S2）），具体可参下面的JVM内存体系图。Eden和Survival的默认分配比例为8：1。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理，后面会说到),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。&lt;/p&gt;
&lt;p&gt; 　　因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在&lt;strong&gt;&lt;em&gt;&lt;span&gt;年轻代的垃圾回收算法使用的是复制算法&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。&lt;/p&gt;
&lt;p&gt;　　在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，&lt;span&gt;&lt;em&gt;&lt;strong&gt;都会保证名为To的Survivor区域是空的&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1194681/201712/1194681-20171214154620623-940541310.png&quot; alt=&quot;&quot; width=&quot;414&quot; height=&quot;256&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。&lt;br/&gt;　　永久代主要用于存放静态文件，Java类、方法等。永久代对垃圾回收没有显著影响，但是有些应 用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持永久代空间来存放这些运行过程中新增的类。永久代大小通过-XX: MaxPermSize = &amp;lt;N&amp;gt; 进行设置。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;2.2 对象在Eden上分配&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　大多数新生代对象都在Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。&lt;/p&gt;
&lt;p&gt;　　下面做一个测试程序demo，详细说明，新生代对象在Eden区的内存分配情况。尝试分配3个2MB大小和一个4MB大小的对象，在运行时候通过VM参数设置（看代码注释），限制java堆大小为20MB，不可扩展，其中10M分配给新生代，10M分给老年代，需要注意的是Eden区与一个Survivor区的空间比例是8：1，从输出结果也可以看出&quot;eden space 8192K,from space 1024K,to space 1024K&quot;的信息，新生代的总空间为9216KB（endn区+1个survivor区的总容量）。测试代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Minor_GC {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _1MB = 1024 * 1024&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * VM 参数配置： -Xms20M
     *             -Xmx20M
     *             -Xmn10M
     *             -XX:+PrintGCDetails
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]){
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] allocation1,allocation2,allocation3,allocation4;

        allocation1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[2 *&lt;span&gt; _1MB];
        allocation2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[2 *&lt;span&gt; _1MB];
        allocation3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[2 *&lt;span&gt; _1MB];
        allocation4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[4 * _1MB];   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 出现一次GC回收&lt;/span&gt;
&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　输出GC日志如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1194681/201712/1194681-20171214192628607-1941477390.png&quot; alt=&quot;&quot; width=&quot;758&quot; height=&quot;188&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　上述参数可以看出： 执行main函数中，分配给allocation4对象时候发生了一次Minor GC（新生代回收），这次GC的结果是新生代内存7684k----&amp;gt;365k,然而堆上总内存的占用几乎没有改变，因为allocation1、allocation2、allocation3都存活，本次回收基本上没有找到可回收的对象。分析如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新生代一共被分配10M，其中Enden：8M，survivor：2M（From：1M，To:1M）;&lt;/li&gt;
&lt;li&gt;给allocation4分配内存时，Eden已经被占用6M（allocation1、2、3共6M，所以剩下2M）,所以内存已经不够用了----&amp;gt;发生GC;&lt;/li&gt;
&lt;li&gt;然而，6M放不进Survivor的From（只有1M），所以只能通过分配担保机制提前转移到老年代&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　这次GC结束后，Eden中有4M的allocation4对象（一共8M，被占用50%左右），survivor为空闲，老年代为6M（被allocation1、2、3占用），日志中显示为6146k，其中老年代采用Mark-sweep(标志清除)回收的方法。&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;[注意]&lt;/strong&gt;：&lt;strong&gt;区别新生代（Minor GC）和老年代（Full GC）：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多数都具备朝生夕灭的特性，所以Minor GC非常的频繁，一般回收速度也比较快;&lt;/li&gt;
&lt;li&gt;老年代GC（Major GC/Full GC）：指发生在老年代的垃圾回收动作，出现Major GC，经常会有至少一次的MinorGC（因为对象大多数都是先在Eden分配空间的，但是并非绝对）。Major GC回收的速度会比Minor GC慢十倍以上（因为Minor GC回收一般都是大面积的回收采用复制算法;而Major GC没有额外空间为他担保，只能采用标记-清理方法），这两者的回收思路是相反的，是一个空间换时间和时间换空间的关系。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2 大对象直接进入老年代&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　大对象是指需要大量内存空间的Java对象，最典型的大对象就是那种&lt;strong&gt;&lt;span&gt;&lt;em&gt;很长的字符串和数组&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;（byte[ ]就是典型的大对象）。出现达对象很容易导致内存还有不少空间就提前触发垃圾收集以获取足够的连续空间来“安置”它们。&lt;/p&gt;
&lt;p&gt;　　虚拟机提供了一个-XX：pretenureSize Threshold（）参数，令大于这个设置直的对象直接在老年代分配。这样做的目的是避免Eden和Survivor区之间发生大量的内存复制（新生带采用复制的方法完成GC）。下面做个测试demo说明问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Major_GC {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _1MB = 1024 * 1024&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * VM 参数配置： -Xms20M
     *             -Xmx20M
     *             -Xmn10M
     *             -XX:+PrintGCDetails
     *             -XX:PretenureSizeThreshold=3145728（等于3M）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]){
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] allocation;
            allocation &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[4 * _1MB];   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接会分配到老年代&lt;/span&gt;
&lt;span&gt;        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行后可以看到，内存会直接在老年代分配。&lt;strong&gt;[说明]&lt;/strong&gt;：这里不给出运行结果，以免产生误导，因为在&lt;span&gt;&lt;em&gt;&lt;strong&gt;Parallel Scavenge收集器是不支持&lt;span&gt;PretenureSizeThreshold这个参数的，得不到这样的结论。&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;&lt;strong&gt;2.3 长期存活对象将进入老年代&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　&lt;/strong&gt;&lt;/span&gt;　&lt;em&gt;&lt;span&gt;&lt;strong&gt;Java虚拟机采用分代收集的思想来管理虚拟机内存&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;。虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并且经过第一次Minor GC后仍然存活，并且能被Survivor的话，将被移动到Survivor空间中，并且对象年龄增加到一定程度（默认15岁），就会被晋升到老年代。对晋升到老年代的对象的阈值可以通过-XX:MaxTenuringThreshold设置。&lt;/p&gt;
&lt;p&gt; 　　下面给出测试demo：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LongTimeExistObj {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _1MB = 1024 * 1024&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * VM 参数配置： -Xms20M
     *              -Xmx20M
     *              -Xmn10M
     *              -XX:+PrintGCDetails
     *              -XX:MaxTenuringThreshold=1
     *              -XX:+PrintTenuringDistribution
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]){
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] allocation1,allocation2,allocation3;
            allocation1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1MB/4&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 什么时候进入老年代取决于-XX:MaxTenuringThreshold的设置&lt;/span&gt;
            allocation2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[4 *&lt;span&gt; _1MB];
            allocation3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[4 *&lt;span&gt; _1MB];
            allocation3 &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            allocation3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[4 *&lt;span&gt; _1MB];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;测试结果如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1194681/201712/1194681-20171214220323263-851662996.png&quot; alt=&quot;&quot; width=&quot;748&quot; height=&quot;325&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.4 动态对象年龄判定&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;em&gt;虚拟并不是永远都要求对象年龄必须达到&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;em&gt;MaxTenuringThreshold才能晋升为老年代的，如果在Survivor的空间相同年龄的所有对象大小总和大于Survivor空间的一半时，年龄大于或者等于该年龄的对象直接静如老年代&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;，无需要等到MaxTenuringThreshold中要求的年龄。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面做一个动态年龄测试demo：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LongTimeExistObj {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _1MB = 1024 * 1024&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * VM 参数配置： -Xms20M
     *              -Xmx20M
     *              -Xmn10M
     *              -XX:+PrintGCDetails
     *              -XX:MaxTenuringThreshold=15
     *              -XX:+PrintTenuringDistribution
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        @SuppressWarnings(&lt;/span&gt;&quot;unused&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]){
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] allocation1,allocation2,allocation3,allocation4;
            allocation1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1MB/4&lt;span&gt;];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使得allocation1 + allocation2 &amp;gt; survivor空间的一半（0.5M）&lt;/span&gt;
            allocation2 = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[_1MB/4&lt;span&gt;];

            allocation3 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[4 *&lt;span&gt; _1MB];
            allocation4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[4 *&lt;span&gt; _1MB];
            allocation4 &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            allocation4 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[4 *&lt;span&gt; _1MB];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1194681/201712/1194681-20171214223623982-1534869113.png&quot; alt=&quot;&quot; width=&quot;756&quot; height=&quot;307&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　执行代码结果中，可以看出：Survivor区占用空间仍然为0（from = 0，to = 0）;而老年代的内存使用为5M，而其他对象都为4M，可以知道，alloccation1和allocation2都在没有达到15岁的时候就提前进入了老年代。验证了我们的结论----&amp;gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;em&gt;在Survivor的空间相同年龄的所有对象大小总和大于Survivor空间的一半时，年龄大于或者等于该年龄的对象直接静如老年代&lt;/em&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.5 空间分配担保&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;在发生Minor GC之前，虚拟机会先检查老年代可用的连续空间是否大于所有新生代的总空间，如果大于的话，那么这个GC就可以保证安全，如果不成立的，那么可能会造成晋升老年代的时候内存不足。在这样的情况下，虚拟机会先检查HandlePromotionFailure设置值是否允许担保失败，如果是允许的，那么说明虚拟机允许这样的风险存在并坚持运行，然后检查老年代的最大连续可用空间是否大于历次晋升老年代对象的平均大小，如果大于的话，就执行Minor GC,如果小于，或者HandlePromotionFailure设置不允许冒险，那么就会先进行一次Full GC将老年代的内存清理出来，然后再判断。&lt;/p&gt;
&lt;p&gt;　　上面提到的风险，是由于新生代因为存活对象采用复制算法，但为了内存利用率，只使用其中的一个Survivor空间，将存活的对象备份到Survivor空间上，一旦出现大量对象在一次Minor GC以后依然存活（最坏的计划就是没有发现有对象死亡需要清理），那么就需要老年代来分担一部分内存，把在Survivor上分配不下的对象直接进入老年代，因为我们不知道实际上具体需要多大内存，我们只能估算一个合理值，这个值采用的方法就是计算出每次晋升老年代的平均内存大小作为参考，如果需要的话，那就提前进行一次Full GC.&lt;/p&gt;
&lt;p&gt;　　取平均值在大多数情况下是可行的，但是因为内存分配的不确定性太多，保不定哪次运行突然出现某些大对象或者Minor GC以后多数对象依然存活，导致内存远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。这样的情况下，担保失败是要付出代价的，大部分情况下都还是会将HandlePromotionFailure开关打开，毕竟失败的几率比较小，这样的担保可以避免Full GC过于频繁，垃圾收集器频繁的启动肯定是不好的。&lt;/p&gt;
&lt;p&gt; 　　&lt;strong&gt;上面很繁琐（详细），实在看不下去就看图吧：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1194681/201712/1194681-20171214232415951-1809145257.png&quot; alt=&quot;&quot; width=&quot;766&quot; height=&quot;347&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;




&lt;p&gt;文中关于新生代、老年代的概念部分内容参考了博文：https://www.cnblogs.com/E-star/p/5556188.html&lt;/p&gt;
&lt;p&gt; 本文参考书籍：《深入理解java虚拟机》&lt;/p&gt;
</description>
<pubDate>Thu, 14 Dec 2017 15:30:00 +0000</pubDate>
<dc:creator>Mairr</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Mairr/p/8037366.html</dc:identifier>
</item>
<item>
<title>沟通技巧系列 - 如何轻松获取和给予反馈 - 奶爸码农</title>
<link>http://www.cnblogs.com/wdsunny/p/8040510.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wdsunny/p/8040510.html</guid>
<description>&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;1400&quot; data-height=&quot;700&quot;&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/7755754-f0947015aef38f2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/7755754-f0947015aef38f2c.png&quot; data-original-width=&quot;1400&quot; data-original-height=&quot;700&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;1205050&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image.png&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;反馈对于个人发展至关重要，但是并不是每个人都善于去获取反馈，尤其是有时反馈往往会有负面的消息。这篇文章会介绍两个有用工具来帮助大家更好的获得和给予他人的反馈。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;SKS（停止 - 继续 - 开始）流程是你获取他人反馈时可以使用的一组简短问题的方式。 问题很简单：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我应该停止做什么？&lt;/li&gt;
&lt;li&gt;我应该继续做什么？&lt;/li&gt;
&lt;li&gt;我应该开始做什么？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;杨百翰大学心理学教授菲尔·丹尼尔斯（Phil Daniels）设计了这个获取反馈的过程。 这有几个原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，这是非常积极的：这些问题促使他人思考你做得很好的具体事情，并鼓励他们说出你可以做得更好的事情。&lt;/li&gt;
&lt;li&gt;这个过程是以行动为中心的：所做的评论让你对你的行为对他人的影响有一个实际的认识，并且准确地解释你需要做的改进。&lt;/li&gt;
&lt;li&gt;最后，问题很容易回答。 在很多情况下，他们只需几分钟就可以提供高质量的反馈。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;1.我该停止做什么？&lt;/h2&gt;
&lt;p&gt;仔细看看你被建议停止的行为。&lt;/p&gt;
&lt;p&gt;你了解反馈意见吗？为什么对于那个人来说这很重要？如果没有，请澄清。&lt;br/&gt;这种行为是否与你的性格密切相关（例如，如果你是一个内向的人，是鼓励你更加外向的人）？如果是这样的话，你可能需要极力改变，因为新的行为起初可能会感觉不舒服。&lt;/p&gt;
&lt;p&gt;考虑进行个性测试，以更好地了解您的个性，并考虑如何影响您与他人合作的方式。您也可能想要建立长期的反馈机会，以确保您继续取得进展。&lt;/p&gt;
&lt;p&gt;改变你的行为会产生什么样的机会，这种改变将如何改善你的工作生活？思考变革可能带来的积极影响往往是非常激励的。&lt;/p&gt;
&lt;p&gt;得知你正在做一些你的老板或你的同事希望你停下来的事情，这可能会让你感到不安。但是，请记住，他们希望从商业的角度看待这个问题，而不是个人的批评。试着去管理自己的感受，把注意力放在他们所说的价值上。&lt;/p&gt;
&lt;h2&gt;2.我应该继续做什么？&lt;/h2&gt;
&lt;p&gt;这些是你的同事所欣赏的行为和行为。 要了解如何将这些任务更充分地纳入您的角色，请考虑以下问题：&lt;/p&gt;
&lt;p&gt;这些建议有没有让你感到惊讶？ 如果是这样，为什么？&lt;br/&gt;这些行为中的任何一种都会在情感上与你产生共鸣吗？ 例如，当你从事这些事情时，你是否经历了一种流动的状态？ 记下这些活动对您的吸引力，并使用MPS流程在您的工作中增加更多。&lt;br/&gt;作为这些行动的结果，你正在开发哪些特定的技能？ 你是否在利用自己没有意识到的优势？ 如果是这样，你怎么能把这些优势应用到其他项目？&lt;/p&gt;
&lt;h2&gt;3.我应该开始做什么？&lt;/h2&gt;
&lt;p&gt;你收到的最后一个问题的反馈意见指出了当前绩效方面的差距。这些建议可以帮助你查看你可能尚未解决的问题。&lt;/p&gt;
&lt;p&gt;仔细看看你的同事认为你应该开始做的事情。他们会给你和他人提供什么好处？&lt;br/&gt;这些任务，项目或行为是否使你感到焦虑或害怕？如果是这样，你是否因为害怕失败或其他盲点而避免这些事情？&lt;/p&gt;
&lt;p&gt;仔细想想为什么你以前没有提到这些事情，以及你能做些什么来克服你不愿意开始的事情。（如果你刚刚“放弃”，学习如何克服拖延，做到更多。）&lt;/p&gt;
&lt;p&gt;这些新活动是否需要你没有的技能或信息？如果是这样，请制定一个获得成功所需技能的计划。&lt;br/&gt;如果经过反思，你仍然不明白为什么开始一件新事物是重要的，那么请向给你反馈的人澄清一下。你也可以从这个问题上得到一些指导。&lt;/p&gt;
&lt;h2&gt;要点&lt;/h2&gt;
&lt;p&gt;停止 - 继续 - 开始是一个简单的方法来收集指导和反馈使用三个简单的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我应该停止做什么？&lt;/li&gt;
&lt;li&gt;我应该继续做什么？&lt;/li&gt;
&lt;li&gt;我应该开始做什么？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;您可以使用此工具来征求关于您自己的工作的反馈。 同时，在向别人反馈意见，或者提高指导或指导关系时，这也很有用。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;想象一下，你最近给了你的团队成员一些反馈。 你告诉他，他的会议议程看起来不错，但他需要提高他的演讲技巧。&lt;/p&gt;
&lt;p&gt;你几个星期后再跟进，看看他为什么没有做任何改变。 你发现他不明白他能做些什么来改善 - 你的反馈只是提出了更多的问题。 他留下了一个想法：“我可以转移到其他文件的议程有什么好处？” 和“我的演讲技巧有什么问题？&lt;/p&gt;
&lt;p&gt;情景 - 行为 - 影响（SBI）反馈工具可帮助您提供更有效的反馈。 它将您的意见集中在特定的情况和行为上，然后概述这些行为对他人的影响。&lt;/p&gt;
&lt;h2&gt;情景 - 行为 - 影响&lt;/h2&gt;
&lt;p&gt;由创意领导力中心开发的SBI反馈工具概述了一个可以用来提供反馈的简单结构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;情景。&lt;/li&gt;
&lt;li&gt;行为。&lt;/li&gt;
&lt;li&gt;影响。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当你用这种方式来组织反馈的时候，你的员工就会明白你在评论什么，为什么。 当你勾画出他们的行为对他人的影响时，你就给他们机会思考他们的行为，并思考他们需要改变什么。&lt;/p&gt;
&lt;p&gt;该工具还可以帮助您避免做出可能使对方不安的假设，并损害您与他们的关系。&lt;/p&gt;
&lt;h2&gt;1.情景&lt;/h2&gt;
&lt;p&gt;当你给出反馈意见时，首先定义你所指的情景的位置和时间。这将反馈置于上下文中，并给予对方特定的设置作为参考。&lt;/p&gt;
&lt;p&gt;例如：&lt;br/&gt;“在昨天上午的团队会议上，当你给你的介绍...”&lt;br/&gt;“周一下午在客户会议上......”&lt;/p&gt;
&lt;h2&gt;2.行为&lt;/h2&gt;
&lt;p&gt;下一步是描述你想要解决的具体行为。这是该过程中最具挑战性的部分，因为您只需要交流您直接观察到的行为。&lt;/p&gt;
&lt;p&gt;您不得对这些行为做出假设或主观判断。这可能是错误的，这会破坏你的反馈。&lt;/p&gt;
&lt;p&gt;例如，如果你观察到一位同事在演讲中犯了错误，你不应该认为他们没有做好充分的准备。你应该简单地评论你的同事犯了错误，理想的情况下，你应该注意错误是什么。&lt;/p&gt;
&lt;p&gt;不要依赖传闻，因为这可能包含他人的主观判断。再次，这可能会破坏你的反馈，危害你的关系。&lt;/p&gt;
&lt;p&gt;下面的例子包括行为的描述：&lt;/p&gt;
&lt;p&gt;“在昨天上午的团队会议上，当你发表演讲时，你不确定两张幻灯片，而你的销售计算是不正确的。&lt;br/&gt;“在周一下午的客户会议上，您确保会议按时开始，并且每个人都提前发放，您的所有研究都是正确的，并且客户的每个问题都得到了答复。&lt;/p&gt;
&lt;h2&gt;3.影响&lt;/h2&gt;
&lt;p&gt;最后一步是用“我”语句来描述他人的行为如何影响你或他人。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;“在昨天上午的团队会议上，当你发表演讲的时候，你不确定两张幻灯片，你的销售计算是不正确的，我感到尴尬，因为整个董事会在那里，我担心这会影响我们的团队声誉。”&lt;br/&gt;“在周一下午的客户会议上，您确保会议按时开始，并且每个人都提前发放，您的所有研究都是正确的，每个客户的问题都得到了答复，我为您做了这样的一个出色的工作和良好的组织情况感到自豪，我相信我们会得到您的支持，感谢您的辛勤工作。“&lt;/p&gt;
&lt;h2&gt;下一步&lt;/h2&gt;
&lt;p&gt;一旦你提交了你的反馈意见，鼓励其他人考虑这种情况，并了解他或她的行为的影响。（感性职位技术可以帮助他们探索其他人的想法。）让其他人花时间吸收你所说的话，然后重新做一些有助于他改善的具体行动。&lt;/p&gt;
&lt;p&gt;而且，如果有人做得很好，就帮助他们考虑如何在这方面做出贡献。&lt;/p&gt;
</description>
<pubDate>Thu, 14 Dec 2017 15:11:00 +0000</pubDate>
<dc:creator>奶爸码农</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wdsunny/p/8040510.html</dc:identifier>
</item>
<item>
<title>程序员如何提高工作效率 - Tiny熊</title>
<link>http://www.cnblogs.com/tinyxiong/p/8040503.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tinyxiong/p/8040503.html</guid>
<description>&lt;p&gt;很多人问我，你怎么效率那么高，工作很忙，又要带娃，还写博客，还有时间运动。今天就写写这个话题：程序员如何提高工作效率&lt;/p&gt;
&lt;p&gt;保持高工作效率，我觉得主要有一下4个方面，希望能对大家有帮助。&lt;/p&gt;
&lt;h2 id=&quot;集中目标&quot;&gt;集中目标&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;工作列表&lt;/strong&gt;&lt;br/&gt;不论是开发还是设计，还是其他职业，工作列表都很重要，工作目标很明确。工作的时候才能格外专注，才不会走神。&lt;br/&gt;用自己最熟悉的工具（我用Evernote），把待办工作列表（今天要做什么）记录下来，很重要的一点是记录分解后的小目标（分解任务也是一个很重要的能力）。同时也保持工作中产生的新的问题（任务），经常性地调整当前工作任务列表，根据重要性对这些任务进行划分，经常想着那些最重要的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;专注目标&lt;/strong&gt;&lt;br/&gt;专注目标不是那么容易做到的，需要学会&lt;strong&gt;分离与当前无关的任务/问题&lt;/strong&gt;，工作中经常会碰到的问题可以首先寻找简单可用可靠的方案，并将心中的疑虑记录下来，集中成一个列表，工作之外翻翻书，系统思考和学习，而不会因为这个问题而叉开思路对相关的内容研究一番。总之，专注当前的任务，把新问题记录下来，回头再专心攻克。&lt;br/&gt;学会避繁就简，在基本功的增强后，会发现很多问题可以简单阅读或查找文档，或浏览问题相关的库的源码解决；&lt;/p&gt;
&lt;h2 id=&quot;学会简化问题&quot;&gt;学会简化问题&lt;/h2&gt;
&lt;p&gt;无论是在广义的工作方法/工作态度上，还是在针对具体问题上，很重要的一个个人能力就是化繁为简了。化繁为简是所有工作方法/软件设计的核心。将那些可以砍掉的工作砍掉，做到尽可能地简单。&lt;/p&gt;
&lt;p&gt;从工作方法和态度上来讲，真正需要去做的工作才值得去做，大力砍掉那些不应该在当前工作中处理的事情。例如不必要的优化，不必要的扩展性，不必要的性能，不必要的功能，可以不要的技术，不必要的流程，不必要的文档，统统砍掉，一切可以没有的全都不能有。&lt;/p&gt;
&lt;p&gt;工作中也可能遇到非关键的难题，通常绕过它们，使用更简单的方案就是了。纠缠于这些不重要的难题，最容易浪费时间。&lt;/p&gt;
&lt;p&gt;从设计/实现来讲，最好的方案就是最简单直接、一眼就能看懂的方案。而且通常最简单直接的方式，通常性能也最好。&lt;/p&gt;
&lt;h2 id=&quot;基本功&quot;&gt;基本功&lt;/h2&gt;
&lt;p&gt;基本功的内容十分复杂。&lt;br/&gt;第一项基本功是对&lt;strong&gt;整个计算机体系的理解&lt;/strong&gt;，对操作系统/虚拟机/数据库本质的理解，对语言基础类和库的理解，这些是核心基本功。&lt;br/&gt;第二项基本功是&lt;strong&gt;学习能力&lt;/strong&gt;。 通过快速阅读核心文档理解核心思想，然后其他的东西总是能从文档中查到就行。细枝末节的东西，即学即用，学过就忘可也。&lt;br/&gt;第三项基本功是&lt;strong&gt;文档、代码、资料的搜索和收集&lt;/strong&gt;，技术问题建议大家用Google搜索，有意识的整理出自己的代码库。&lt;/p&gt;
&lt;h2 id=&quot;工具&quot;&gt;工具&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;选择工具&lt;/strong&gt;核心标准，就是简单朴素可信赖，如果一个工具出几次诡异现象，那就干脆丢掉它。&lt;br/&gt;&lt;strong&gt;熟悉工具&lt;/strong&gt;，实际上我们工作中，就是和各种各样工具打交道，各种IDE，编辑器，版本管理工具，命令行终端，TODO工具等等。要想在工作中如行云流水，一定要熟悉工具，包括工具快捷键，命令，原理等等。&lt;br/&gt;&lt;strong&gt;写自己工具&lt;/strong&gt;，很多时候，我们需要重复的做一件事情，当你做第2遍，第3遍的时候，就应该想一想，能不能自动化，很多简单的几句shell就可以搞定，麻烦的一点的，可以先记录下来。比如，我就写了非常多的脚本：一个命令反编译APK并查看源码、提取当前版本号打git tag并提交等等。很多时候几分钟到几十分钟的事情可以压缩到几秒钟完成，也避免了对工作的打断。&lt;/p&gt;
&lt;p&gt;前3点靠大家各自的修行，第4点工具部分，我会在&lt;a href=&quot;http://tinyxiong.com/&quot;&gt;博客&lt;/a&gt;中进一步分享。&lt;/p&gt;
&lt;p&gt;关于作者：Tiny熊：&lt;a href=&quot;https://learnblockchain.cn/&quot;&gt;深入浅出区块链&lt;/a&gt;博主&lt;/p&gt;
</description>
<pubDate>Thu, 14 Dec 2017 15:10:00 +0000</pubDate>
<dc:creator>Tiny熊</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tinyxiong/p/8040503.html</dc:identifier>
</item>
<item>
<title>关于hue安装后出现KeyError: &quot;Couldn't get user id for user hue&quot;的解决方法 - 南孤雁</title>
<link>http://www.cnblogs.com/nanguyan/p/8040482.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nanguyan/p/8040482.html</guid>
<description>&lt;p&gt;首先说明出现此问题的原因是因为你使用的root用户安装了hue,然后在root用户下使用的build/env/bin/supervisor，如下图所示那样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140727/201712/1140727-20171214224524467-2114983779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;知道了原因，就容易解决问题了。首先要创建个普通用户，并给添加密码。如果密码给的过于简单，会给出提示，忽略就行，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140727/201712/1140727-20171214225344295-551642343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，我们要给刚才解压的hue文件改变拥有者属性，通过 chown -R 用户名 文件地址。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140727/201712/1140727-20171214225714404-1336104540.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，我们使用 su 命令切换用户，到hue文件夹下执行运行hue的命令就可以了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1140727/201712/1140727-20171214230227263-209942948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 14 Dec 2017 15:04:00 +0000</pubDate>
<dc:creator>南孤雁</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nanguyan/p/8040482.html</dc:identifier>
</item>
<item>
<title>英语发音规律 - Crysta1</title>
<link>http://www.cnblogs.com/shybuku/p/8040456.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shybuku/p/8040456.html</guid>
<description>&lt;p&gt;单元音： [i:]、[i]、[?:]、[?]、[u:]、[u]、[?:]、[?]、[ɑ:]、[?]、[e]、[?]&lt;br/&gt;双元音：[ei]、[ai]、[?i]、[i?]、[??]、[u?]、[au]、[?u]&lt;br/&gt;辅音：[θ]、[e]、[?]、[?]&lt;br/&gt;连读音变： [t]和[j] ==[t?]       meet you&lt;br/&gt;       [d]和[j] ==[d?]    would you&lt;br/&gt;       [s]和[j] ==[?]    miss you&lt;/p&gt;&lt;p&gt;元音和元音： 前面单词以[?u][au][u:][u]结尾，后面单词以原因开头，加上[w]音，但音很轻 too often,going.&lt;br/&gt;         前面单词结尾音节[ei][ai][?i][i?][i]，后面单词以元音开头，加上[j]音， I am， say it&lt;br/&gt;辅音和元音：[r]+元音 your eyes，your answer中间读到一起，&lt;br/&gt;        [l]+元音 double of，&lt;br/&gt;        [t]+元音 get in，get it out of ，[t]的音变成偏向[d]的音&lt;br/&gt;辅音和辅音：失去爆破 [b][p][d][t][g][k]+与其不相同的辅音 发音是只阻塞气流而没有声音只有口型。breakfast，sit down&lt;br/&gt;        击穿  前一个单词以辅音音节结尾，后一个单词以字母h的发音开头，字母h不发音 I like her，in his car，ask him&lt;br/&gt;       &lt;/p&gt;
</description>
<pubDate>Thu, 14 Dec 2017 14:55:00 +0000</pubDate>
<dc:creator>Crysta1</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shybuku/p/8040456.html</dc:identifier>
</item>
<item>
<title>常在池边游，却不曾到池子里一探究竟？ - Jachin01</title>
<link>http://www.cnblogs.com/jachin01/p/8035473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jachin01/p/8035473.html</guid>
<description>&lt;h2&gt;浅谈Java线程池&lt;/h2&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;线程池，简单来说，就是一个池子嘛，里面养着一群线程，ABCD........，然后你要用的时候，从里面拿一个去用，用完放回去。&lt;/p&gt;
&lt;p&gt;一群人要用的时候，每个人都从池子里面拿一个线程，当池子的线程已经被拿完的时候，但是有人没有拿到线程，如果没有超过池子的最大承受量，池子就创造一些线程给未拿到线程的人用，否则这群人就在队伍里乖乖排队等着，等别人用完线程放回池子里，再去拿。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过重用池子中的线程，可以在处理多个请求时分摊在线程创建和销毁过程中产生的巨大开销，在池子线程数足够时，也不会由于在等待创建线程过程中而延迟任务的执行。&lt;/p&gt;
&lt;p&gt;当然，池子有很多种，放的线程的特点也不一样，常用的有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;newFixedThreadPool( )  &lt;/li&gt;
&lt;li&gt;newSingleThreadExecutor( )&lt;/li&gt;
&lt;li&gt;newCachedThreadpoll( )&lt;/li&gt;
&lt;li&gt;newSingleThreadScheduledExecutor( )&lt;/li&gt;
&lt;li&gt;newScheduledThreadPool( )&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;小试牛刀：&lt;/h2&gt;
&lt;p&gt;现假设有10个任务并发操作，来操作Java自带的几种线程池：&lt;/p&gt;
&lt;p&gt;先创建一个Test类，做好准备工作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Test &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Runnable{
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
        System.out.println(System.currentTimeMillis()&lt;/span&gt;+&quot;:Thread ID:&quot;+&lt;span&gt;Thread.currentThread().getId());
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
        }
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sub(ExecutorService es)
        {//对10个任务进行并发操作
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 10; i++&lt;span&gt;){
                es.submit(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            }

        }}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;newFixedThreadPool( )  ：返回&lt;strong&gt;一个固定数量线程&lt;/strong&gt;的线程池，池子里面的线程数量不会变。池子中若有空闲线程，则立即执行任务，没有则在队列中等待有空闲的线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            Test test =&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Test();
            ExecutorService es1&lt;/span&gt;=Executors.newFixedThreadPool(5);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过Executors来创建newFixedThreadPool，并线程池里有指定数量的线程（5）&lt;/span&gt;
&lt;span&gt;            test.sub(es1);
            es1.shutdown();    
&lt;/span&gt;&lt;span&gt;         /*输出结果：&lt;/span&gt;&lt;span&gt;
             *  1513172016629:Thread ID:10
                1513172016630:Thread ID:11
                1513172016630:Thread ID:12
                1513172016630:Thread ID:13
                1513172016630:Thread ID:14

                1513172017630:Thread ID:10
                1513172017631:Thread ID:11
                1513172017631:Thread ID:12
                1513172017632:Thread ID:13
                1513172017632:Thread ID:14
&lt;strong&gt;             * 可以看到10个任务执行结果，是前5个后5个各一组（ID从10到14）的执行的，分成两个批。因为池子里只有5个线程，前5个占用了并执行花了1s，后5个任务就得等待多1s。
&lt;/strong&gt;             * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;newSingleThreadExecutor( )：返回只有&lt;strong&gt;一个线程&lt;/strong&gt;的线程池。大于一个任务的时候，其他任务就在对列中等待。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            ExecutorService es2=Executors.newSingleThreadExecutor();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;整个池子中只有一个线程可用&lt;/span&gt;
&lt;span&gt;            test.sub(es2);
            es2.shutdown();
            &lt;/span&gt;&lt;span&gt;/*输出结果：&lt;/span&gt;&lt;span&gt;
             *  1513172019633:Thread ID:15
                1513172020634:Thread ID:15
                1513172021634:Thread ID:15
                1513172022634:Thread ID:15
                1513172023634:Thread ID:15
&lt;strong&gt;             * 只有一个线程，每次只有一个任务执行并花费1s时间，执行完后放回池子，等待下一个任务执行。线程是同一个，所以是同一个ID。
&lt;/strong&gt;             * 
             * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;newCachedThreadpool( )：返回一个可根据&lt;strong&gt;实际情况调整线程数量&lt;/strong&gt;的线程池。里面的线程数量不确定，若有空闲线程可复用，则不着急创建新线程，否则创建新的线程处理任务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
            ExecutorService es3=Executors.newCachedThreadPool();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当线程池中线程不够用的时候，会创建新的线程。&lt;/span&gt;
&lt;span&gt;            test.sub(es3);
            es3.shutdown();
        &lt;/span&gt;&lt;span&gt;/*输出结果&lt;/span&gt;&lt;span&gt;
         *  1513172129987:Thread ID:10
            1513172129987:Thread ID:11
            1513172129988:Thread ID:12
            1513172129988:Thread ID:13
            1513172129988:Thread ID:14
            1513172129988:Thread ID:15
            1513172129989:Thread ID:16
            1513172129989:Thread ID:17
            1513172129990:Thread ID:18
            1513172129990:Thread ID:19
         * 当下时刻（1s内），线程都在工作中，所以没有空闲的线程来给其他任务用，所以池子会不断创建新的线程用于执行任务。
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;newScheduledThreadPool( )：返回一个可指定线程数量的ScheduledExecutorService对象，可在某个固定延时之后执行或者周期性执行某个任务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;ScheduledExecutorService对象的几个主要方法，其中 delay：开始指定的延时时间，initialDelay：初始化延时（以后每一个任务的间隔延时），period：周期
    &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;public&lt;/span&gt; ScheduledFuture&amp;lt;?&amp;gt;&lt;span&gt; schedule(Runnable command,
                                       &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; delay, TimeUnit unit);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ScheduledFuture&amp;lt;?&amp;gt;&lt;span&gt; scheduleAtFixedRate(Runnable command,
                                                  &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; initialDelay,
                                                  &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; period,
                                                  TimeUnit unit);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ScheduledFuture&amp;lt;?&amp;gt;&lt;span&gt; scheduleWithFixedDelay(Runnable command,
                                                     &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; initialDelay,
                                                     &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; delay,
                                                     TimeUnit unit);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对几个方法写一个eg，来看看他们的功能（这里主要看输出结果的&lt;strong&gt;时间差&lt;/strong&gt;）：&lt;/p&gt;
&lt;p&gt;schedule方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     ScheduledExecutorService ses=Executors.newScheduledThreadPool(10&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     System.out.println(&quot;线程开始时间：&quot;+System.currentTimeMillis()/1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     ses.&lt;strong&gt;schedule&lt;/strong&gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             System.out.println(System.currentTimeMillis()/1000+&quot;:Thread ID:&quot;+&lt;span&gt;Thread.currentThread().getId());
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }, 2&lt;span&gt;, TimeUnit.SECONDS);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     
&lt;span&gt;16&lt;/span&gt;     
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; schedule会在给定时间，只对任务进行一次调度，这里设定两秒后执行
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;     * 输出结果：
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;     * 线程开始时间：1513174768
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;     * 1513174770:Thread ID:10 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;scheduleAtFixedRate方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     ses.scheduleAtFixedRate(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             System.out.println(System.currentTimeMillis()/1000+&quot;:Thread ID:&quot;+&lt;span&gt;Thread.currentThread().getId());
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }, 3, 2&lt;span&gt;, TimeUnit.SECONDS);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; scheduleAtFixedRate会在给定延时initialDlay后（这里3秒），执行完一个任务（1秒），如果执行任务的时间大于周期period的时间，则执行完任务后直接到下一个任务；否则在周期内，任务执行完后，等待周期内剩余的时间。
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * 输出结果：
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * 线程开始时间：1513174386
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        1513174389:Thread ID:10
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        1513174391:Thread ID:10
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        1513174393:Thread ID:12
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        1513174395:Thread ID:10
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        1513174397:Thread ID:13
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        1513174399:Thread ID:12
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;scheduleWithFixedDelay方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; ses.scheduleWithFixedDelay(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             System.out.println(System.currentTimeMillis()/1000+&quot;:Thread ID:&quot;+&lt;span&gt;Thread.currentThread().getId());
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 Thread.sleep(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                e.printStackTrace();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     }, 3, 2&lt;span&gt;, TimeUnit.SECONDS);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;scheduleWithFixedDelay会在给定延时initialDelay后（这里3秒），然后执行完一个任务（1秒），再间隔一个delay（2秒）后，再去执行别的任务
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;     * 输出结果：
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * 线程开始时间：1513174575
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        1513174578:Thread ID:10
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        1513174581:Thread ID:10
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        1513174584:Thread ID:12
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        1513174587:Thread ID:10
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        1513174590:Thread ID:13
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;可以看图帮助更好的理解这3个方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1200992/201712/1200992-20171214223356732-1025217450.jpg&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;305&quot;/&gt;&lt;/p&gt;

&lt;p&gt;针对这几个线程池做了一个测试，大概了解了他们的运作方式，接下来我们来看看他们的内部实现原理。&lt;/p&gt;

&lt;h2&gt;一探究竟——内部实现：&lt;/h2&gt;
&lt;p&gt;这里给出3个简单的线程池的内部实现原理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExecutorService &lt;strong&gt;newFixedThreadPool&lt;/strong&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; nThreads) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor(nThreads, nThreads,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                                       0L&lt;span&gt;, TimeUnit.MILLISECONDS,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                                       &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;());
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService &lt;strong&gt;newSingleThreadExecutor&lt;/strong&gt;() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FinalizableDelegatedExecutorService
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             (&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(1, 1&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                                     0L&lt;span&gt;, TimeUnit.MILLISECONDS,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                                     &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;()));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ExecutorService &lt;strong&gt;newCachedThreadPool&lt;/strong&gt;() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(0&lt;span&gt;, Integer.MAX_VALUE,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                                       60L&lt;span&gt;, TimeUnit.SECONDS,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                                       &lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;());
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;他们都返回一个ThreadPoolExecutor对象，只不过他们的参数不同罢了，来了解一下ThreadPoolExecutor具体的参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; corePoolSize,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                               &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maximumPoolSize,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                               &lt;span&gt;long&lt;/span&gt;&lt;span&gt; keepAliveTime,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                              TimeUnit unit,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                               BlockingQueue&amp;lt;Runnable&amp;gt;&lt;span&gt; workQueue,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                              ThreadFactory threadFactory,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                              RejectedExecutionHandler handler) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (corePoolSize &amp;lt; 0 ||
&lt;span&gt; 9&lt;/span&gt;             maximumPoolSize &amp;lt;= 0 ||
&lt;span&gt;10&lt;/span&gt;             maximumPoolSize &amp;lt; corePoolSize ||
&lt;span&gt;11&lt;/span&gt;             keepAliveTime &amp;lt; 0&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这些参数强制不能小于0，否则抛异常&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (workQueue == &lt;span&gt;null&lt;/span&gt; || threadFactory == &lt;span&gt;null&lt;/span&gt; || handler == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这些参数强制不能为空，否则抛异常&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.corePoolSize =&lt;span&gt; corePoolSize;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.maximumPoolSize =&lt;span&gt; maximumPoolSize;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.workQueue =&lt;span&gt; workQueue;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.keepAliveTime =&lt;span&gt; unit.toNanos(keepAliveTime);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.threadFactory =&lt;span&gt; threadFactory;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.handler =&lt;span&gt; handler;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;br/&gt;我们来看下方法里面的参数：&lt;/span&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;int corePoolSize, 核心线程数，就是制定了池子中的线程数量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;int maximumPoolSize,线程池中线程最大容量数&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;long &lt;span&gt;keepAliveTime,当线程数超过corePoolSize时，超过的那部分线程的剩余存活时间。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;TimeUnit unit,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;keepAliveTime的单位&lt;/li&gt;
&lt;li&gt;BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,任务队列，下面详细介绍&lt;/li&gt;
&lt;li&gt;ThreadFactory threadFactory,线程工厂，用于创建线程，下面介绍&lt;/li&gt;
&lt;li&gt;RejectedExecutionHandler handler，拒绝策略，下面详细介绍&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;关于任务队列：&lt;/h2&gt;
&lt;p&gt; workQueue，就是在那些没有在池子拿到线程的，还在排队的任务所在的队列。这些队列都是一个BlockingQueue接口的对象，主要有以下几种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;直接提交队列：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;SynchronousQueue实现，没有具体的容量大小，每一个插入操作都对应等待一个删除操作，每一个删除操作都对应等待一个插入操作，队列不会真实的保存任务，而是直接转交给线程去执行。&lt;/p&gt;
&lt;p&gt;工作流程如下：将新任务提交给线程执行，如果池子中的线程被用完了，就尝试让池子创建线程，如果池子已经达到最大容量，不可再创建了，就执行拒绝策略（如果池子最大容量太小，则会很容易执行拒绝策略）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1200992/201712/1200992-20171214162724404-1921867561.jpg&quot; alt=&quot;&quot; width=&quot;616&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;p&gt;newCachedThreadPool()就是用这种方式的，核心线程设置为0，maximumPoolSize设置为无穷大，这样当没有任务时，则池子里没有线程；当有任务时，若有空闲线程则使用，若无则加入SynchronousQueue队列，而这直接提交队列会迫使线程池增加新的线程去执行任务，如果任务很多又执行的很慢。。。。那就GG了，这样下去会耗尽内存。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;有界任务队列：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;ArrayBlockingQueue（int capacity）实现，参数capacity是队列的最大容量。&lt;/p&gt;
&lt;p&gt;工作流程如下：将新任务提交给线程执行，如果池子里的线程数小于核心线程数，则会创建线程；否则将任务加入队列中；若队列已经满了，则就创建新的线程，直到maximumPoolSize为止；若超过了maximumPoolSize，就会执行拒绝策略了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1200992/201712/1200992-20171214152458295-751352107.png&quot; alt=&quot;&quot; width=&quot;672&quot; height=&quot;236&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;无界任务队列：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;LinkedBlockingQueue实现，与有界队列相比，除非系统资源耗尽，否则此队列不存在入队失败。&lt;/p&gt;
&lt;p&gt;工作流程如下：将新任务提交给线程执行，如果池子线程数小于核心线程数，池子会新生成线程去执行任务；当线程数到达核心线程数的时候，池子里的线程不再增加，若无空闲线程，则把任务放到任务队列里，队列一直增长，直到内存耗尽。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/1200992/201712/1200992-20171214155105951-1330514468.jpg&quot; alt=&quot;&quot; width=&quot;294&quot; height=&quot;197&quot;/&gt;&lt;/p&gt;
&lt;p&gt;newFixedThreadPool()就是用这种方式的任务队列。因为对于固定大小的线程池而言，不存在线程的动态变化（corePoolSize==maximumPoolSize）。&lt;/p&gt;
&lt;p&gt;newSingleThreadPool()同理。&lt;/p&gt;
&lt;/blockquote&gt;


&lt;p&gt;&lt;strong&gt;优先任务队列：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;PriorityBlockingQueue实现，可以控制任务的执行先后顺序。&lt;/p&gt;
&lt;p&gt;这优先队列是一个&lt;strong&gt;无界队列&lt;/strong&gt;，根据任务的优先级顺序先后执行，优先级高的先执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;关于ThreadFactory ：&lt;/h2&gt;
&lt;p&gt;ThreadFactory是只有一个方法的接口，实现它可以创建出线程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ThreadFactory {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    Thread newThread(Runnable r);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们可以在自定义线程池的时候，也自定义线程的名称、组以及优先级等信息。&lt;/p&gt;
&lt;p&gt;在ThreadPoolExecutor方法的ThreadFactory threadFactory这个参数，可以这样自定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactory(){
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread newThread(Runnable r){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里自定义啦，想做啥做啥，比如创建一个新的线程，然后命名之类的？&lt;/span&gt;
&lt;span&gt;                }
                
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;关于拒绝策略：&lt;/h2&gt;
&lt;p&gt; 当池子中的线程已经用完了，并且对列中也已经排满，再也装不下了，此时，就需要拒绝策略来拒绝新的任务来拿线程。&lt;/p&gt;
&lt;p&gt;JDK内置的拒绝策略均实现了RejectedExecutionHandler接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; RejectedExecutionHandler {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 下面我们拿出源码来分析，来看看JDK自带的4种拒绝策略是如何工作的。&lt;/p&gt;
&lt;p&gt;AbortPolicy策略：直接抛出异常，阻止系统正常工作&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbortPolicy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RejectedExecutionHandler {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AbortPolicy() { }
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;         * Always throws RejectedExecutionException.//总是抛出异常
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rejectedExecution(Runnable r, ThreadPoolExecutor e) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RejectedExecutionException(&quot;Task &quot; + r.toString() +
&lt;span&gt; 8&lt;/span&gt;                                                  &quot; rejected from &quot; +
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                                                 e.toString());
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;CallerRunsPolicy策略：只要池子没有关闭，它会拿起被丢弃的任务继续执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CallerRunsPolicy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RejectedExecutionHandler {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; CallerRunsPolicy() { }
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;         * Executes task r in the caller's thread, unless the executor
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;         * has been shut down, in which case the task is discarded.
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;         * 就是说如果线程池没有关闭，直接在调用者的线程中，运行当前被拒绝的任务
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rejectedExecution(Runnable r, ThreadPoolExecutor e) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;e.isShutdown()) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果线程池没有关闭&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                r.run();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行当前被拒绝的任务&lt;/span&gt;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;DiscardOledestPolicy策略：丢弃最老的请求（就是即将被执行的那个），并尝试再次提交当前任务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DiscardOldestPolicy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RejectedExecutionHandler {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DiscardOldestPolicy() { }
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;         * Obtains and ignores the next task that the executor
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;         * would otherwise execute, if one is immediately available,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;         * and then retries execution of task r, unless the executor
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;         * is shut down, in which case task r is instead discarded.
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;         * 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rejectedExecution(Runnable r, ThreadPoolExecutor e) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!e.isShutdown()) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果线程池没有关闭&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 e.getQueue().poll();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;丢弃队列中最老的那个线程&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;                 e.execute(r);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;尝试去执行当前提交的任务&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;DiscardPolicy策略：啥也不做，默默丢弃无法处理的任务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DiscardPolicy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; RejectedExecutionHandler {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DiscardPolicy() { }
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;         * Does nothing, which has the effect of discarding task r.
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;         *啥也不做
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; rejectedExecution(Runnable r, ThreadPoolExecutor e) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;拒绝策略可以说是当多线程请求执行任务的数量超过实际承载能力时最有力的工具，是系统超负荷运作时的补救措施。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然，JDK内部的拒绝策略都是实现RejectedExecutionHandler接口的，我们也可以照着葫芦画瓢，自定义一个拒绝策略，具体怎么写，大概就是在自定义创建线程池的时候，自定义handler就可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ExecutorService es=&lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(10,10,0L,TimeUnit.MILLISECONDS,&lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(20&lt;span&gt;),Executors.defaultThreadFactory(),
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt;&lt;strong&gt; RejectedExecutionHandlers&lt;/strong&gt;(){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;                    @Override
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;                    rejectedExecution(Runnable r,ThreadPoolExecutor executor){
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里自定义啦，想做啥做啥&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;                     }});
&lt;/pre&gt;&lt;/div&gt;

&lt;hr/&gt;&lt;p&gt;说完ThreadPoolExecutor的参数，接下来说说它里面的核心的方法&lt;/p&gt;
&lt;p&gt;要说最核心的方法，那必定是执行的方法execute，其中The main pool control state, ctl, is an atomic integer packing（clt是主线程池控制状态的标志，是一个integer原子类型）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; execute(Runnable command) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (command == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException();
        &lt;/span&gt;&lt;span&gt;/*源码的注释翻译：&lt;/span&gt;&lt;span&gt;
          *分三步进行：
          * 1.如果当钱线程的线程总数少于corePoolSize，则尝试开始一个新的线程任务。调用addWorker会自动检查runState和workerCount，防止将线程错误的添加。
          * 2.如果任务进入等待队列，需再次检查是否添加一个线程（因为从上次检测到现在，线程池中可能有的线程已经销毁）或者检测线程池是否关闭了。&lt;br/&gt;*  检查是有必要回滚这个入队操作，还是去开始一个新的线程。
          * 3.如果入队失败，则尝试添加一个新的线程。 如果以上操作失败，则拒绝任务。
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; c =&lt;span&gt; ctl.get();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (workerCountOf(c) &amp;lt;&lt;span&gt; corePoolSize) {&lt;span&gt;//当前线程池的线程总数小于核心线程数时，通过addWorker调度，分配线程执行
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (addWorker(command, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            c &lt;/span&gt;=&lt;span&gt; ctl.get();
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isRunning(c) &amp;amp;&amp;amp;&lt;span&gt; workQueue.offer(command)) {&lt;span&gt;//进入等待队列
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; recheck =&lt;span&gt; ctl.get();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (! isRunning(recheck) &amp;amp;&amp;amp;&lt;span&gt; remove(command))
                reject(command);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (workerCountOf(recheck) == 0&lt;span&gt;)
                addWorker(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!addWorker(command, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;))&lt;span&gt;//进入等待队列失败的时候（有界队列到达上限，或者使用了SynchronousQueue）,addworker将任务直接提交给线程池&lt;/span&gt;
            reject(command);&lt;span&gt;//如果提交给线程池失败，则执行拒绝策略（当前线程数达到maximumPoolSize）&lt;/span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当然，ThreadPoolExecutor还有好多有趣的方法，如beforeExecute()、afterExecute()、terminated()等，可以对对其进行扩展来实现对线程池运行状态的跟踪，这里就不多说了，感兴趣的自行探索。&lt;/p&gt;
&lt;p&gt;感谢阅读。&lt;/p&gt;

</description>
<pubDate>Thu, 14 Dec 2017 14:37:00 +0000</pubDate>
<dc:creator>Jachin01</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jachin01/p/8035473.html</dc:identifier>
</item>
<item>
<title>Scala入门系列（九）：函数式编程 - 小丑进场</title>
<link>http://www.cnblogs.com/LiCheng-/p/8040348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LiCheng-/p/8040348.html</guid>
<description>&lt;div id=&quot;wmd-preview-section-17450&quot; readability=&quot;14&quot;&gt;
&lt;h2&gt;引言&lt;/h2&gt;
&lt;p&gt;Scala是一门既面向对象，又面向过程的语言，Scala的函数式编程，就是Scala面向过程最好的佐证。也真是因此让Scala具备了Java所不具备的更强大的功能和特性。&lt;/p&gt;
&lt;p&gt;而之所以Scala一直没有替代Java，一是因为Java诞生早，基于Java开发了大量知名的工程，并且最重要的是Java现在不只是一门编程语言，而是一个庞大的技术生态圈，所以&lt;strong&gt;未来十年内Scala也不会完全替代Java，但是Scala会在自己特有的领域大发光彩&lt;/strong&gt;。&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17451&quot; readability=&quot;10&quot;&gt;
&lt;h2&gt;将函数赋值给变量&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Scala中函数是一等公民，可以独立定义，独立存在，而且可以直接将函数作为值赋值给变量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Scala语法规定：&lt;strong&gt;将函数赋值给变量时，必须在函数后加上空格和下划线&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17452&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scala&amp;gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;/span&gt;(name: &lt;span&gt;String&lt;/span&gt;) = println(&lt;span&gt;&quot;hello, &quot;&lt;/span&gt; + name)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;sayHello: (name: &lt;span&gt;String&lt;/span&gt;)&lt;span&gt;Unit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 必须在函数后加上空格和下划线&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; sayHelloFunc = sayHello _&lt;/p&gt;
&lt;p&gt;sayHelloFunc: &lt;span&gt;String&lt;/span&gt; =&amp;gt; &lt;span&gt;Unit&lt;/span&gt; = &amp;lt;function1&amp;gt;&lt;/p&gt;

&lt;p&gt;scala&amp;gt; sayHelloFunc(&lt;span&gt;&quot;sparks&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;hello, sparks&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17453&quot; readability=&quot;12&quot;&gt;
&lt;h2&gt;匿名函数&lt;/h2&gt;
&lt;p&gt;可以直接定义匿名函数并赋值给某个变量；也可以将匿名函数传入其他函数之中。&lt;/p&gt;
&lt;p&gt;Scala定义匿名函数的语法规则是，&lt;code&gt;（参数名: 参数类型） =&amp;gt; {函数体}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;匿名函数在Spark源码中有大量使用。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17454&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; sayHelloFunc = (name: &lt;span&gt;String&lt;/span&gt;) =&amp;gt; {println(&lt;span&gt;&quot;hello, &quot;&lt;/span&gt;+name)}&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;sayHelloFunc: &lt;span&gt;String&lt;/span&gt; =&amp;gt; &lt;span&gt;Unit&lt;/span&gt; = &amp;lt;function1&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;scala&amp;gt; sayHelloFunc(&lt;span&gt;&quot;sparks&quot;&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;hello, sparks&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt; &lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17455&quot; readability=&quot;11&quot;&gt;
&lt;h2&gt;&lt;code&gt;高阶函数&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;在Scala中，由于函数时一等公民，因此可以直接将某个函数传入其他函数，作为参数。这个功能是极其强大的，也是Java这种面向对象的编程语言所不具备的。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;strong&gt;&lt;code&gt;接收其他函数作为参数的函数，也被称为高阶函数（higher-order function)&lt;/code&gt;&lt;/strong&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17456&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; sayHelloFunc = (name: &lt;span&gt;String&lt;/span&gt;) =&amp;gt; println(&lt;span&gt;&quot;hello, &quot;&lt;/span&gt;+name)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&lt;span&gt;// 接收函数作为参数&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scala&amp;gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;greeting&lt;/span&gt;&lt;/span&gt;(func: (&lt;span&gt;String&lt;/span&gt;)=&amp;gt; &lt;span&gt;Unit&lt;/span&gt;, name: &lt;span&gt;String&lt;/span&gt;){func(name)}&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;&lt;span&gt;// 将匿名函数当做参数传入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; greeting(sayHelloFunc, &lt;span&gt;&quot;leo&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;hello, leo&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// Array的map函数也是高阶函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;).map((num: &lt;span&gt;Int&lt;/span&gt;) =&amp;gt; num*num)&lt;/p&gt;
&lt;p&gt;res5: &lt;span&gt;Array&lt;/span&gt;[&lt;span&gt;Int&lt;/span&gt;] = &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;25&lt;/span&gt;)&lt;/p&gt;

&lt;p&gt;&lt;span&gt;// 高阶函数的另外一个功能是将函数作为返回值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;getGreetingFunc&lt;/span&gt;&lt;/span&gt;(msg: &lt;span&gt;String&lt;/span&gt;) = (name: &lt;span&gt;String&lt;/span&gt;) =&amp;gt; println(msg + &lt;span&gt;&quot; &quot;&lt;/span&gt; + name)&lt;/p&gt;

&lt;p&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; greetingFunc = getGreetingFunc(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;)&lt;/p&gt;

&lt;p&gt;scala&amp;gt; greetingFunc(&lt;span&gt;&quot;sparks&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;hello sparks&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17457&quot; readability=&quot;10&quot;&gt;
&lt;h2&gt;高阶函数-类型推断（更易阅读）&lt;/h2&gt;
&lt;p&gt;在高阶函数中，经常将只需要执行一次的函数定义为匿名函数作为参数传递给高阶函数，就好像map()、filter()等高阶函数中经常能看到使用了匿名函数作为参数。匿名函数在这里有一个特性能够帮助我们写出更容易阅读的函数——参数推断。 &lt;br/&gt;正常情况下，我们使用匿名函数的方式如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17458&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;object&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt;&lt;/span&gt; {&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;(args: &lt;span&gt;Array&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;]) {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;val&lt;/span&gt; arr = &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;1.23&lt;/span&gt;, &lt;span&gt;34.1&lt;/span&gt;, &lt;span&gt;21.32&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;val&lt;/span&gt; result = arr.map((a: &lt;span&gt;Double&lt;/span&gt;) =&amp;gt; a * &lt;span&gt;3&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;println(result.mkString(&lt;span&gt;&quot; &quot;&lt;/span&gt;))&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;即在map函数中定义匿名函数(a: Double) =&amp;gt; a * 3，但是由于map函数知道你传入的是一个类型为(Double)=&amp;gt; Double类型的函数，故可以简化为&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17459&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;object&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt;&lt;/span&gt; {&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;(args: &lt;span&gt;Array&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;]) {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;val&lt;/span&gt; arr = &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;1.23&lt;/span&gt;, &lt;span&gt;34.1&lt;/span&gt;, &lt;span&gt;21.32&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;val&lt;/span&gt; result = arr.map((a) =&amp;gt; a * &lt;span&gt;3&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;println(result.mkString(&lt;span&gt;&quot; &quot;&lt;/span&gt;))&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;并且如果匿名函数只有一个参数，则可以省略()，继续简化：&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17460&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;object&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt;&lt;/span&gt; {&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;(args: &lt;span&gt;Array&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;]) {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;val&lt;/span&gt; arr = &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;1.23&lt;/span&gt;, &lt;span&gt;34.1&lt;/span&gt;, &lt;span&gt;21.32&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;val&lt;/span&gt; result = arr.map(a =&amp;gt; a * &lt;span&gt;3&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;println(result.mkString(&lt;span&gt;&quot; &quot;&lt;/span&gt;))&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;在此基础上，如果参数在=&amp;gt;右边只出现了一次，则可以用_替换它（Spark中大量使用了这种语法）：&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17461&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;object&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt;&lt;/span&gt; {&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;/span&gt;(args: &lt;span&gt;Array&lt;/span&gt;[&lt;span&gt;String&lt;/span&gt;]) {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;val&lt;/span&gt; arr = &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;1.23&lt;/span&gt;, &lt;span&gt;34.1&lt;/span&gt;, &lt;span&gt;21.32&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;val&lt;/span&gt; result = arr.map(_ * &lt;span&gt;3&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;println(result.mkString(&lt;span&gt;&quot; &quot;&lt;/span&gt;))&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;  &lt;br/&gt;类似的示例：&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17462&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// 定义该函数参数接收Int参数，返回Int值&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scala&amp;gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;triplt&lt;/span&gt;&lt;/span&gt;(func: (&lt;span&gt;Int&lt;/span&gt;) =&amp;gt; &lt;span&gt;Int&lt;/span&gt;) = {func(&lt;span&gt;3&lt;/span&gt;)}&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;// 3作为该匿名参数的唯一参数与6做了相乘，然后返回&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 相当于triplt((a: Int) =&amp;gt; a * 6)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; triplt(_ * &lt;span&gt;6&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;res17: &lt;span&gt;Int&lt;/span&gt; = &lt;span&gt;18&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;scala&amp;gt; triplt(_ + &lt;span&gt;6&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;res18: &lt;span&gt;Int&lt;/span&gt; = &lt;span&gt;9&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17463&quot;&gt;
&lt;h2&gt;常见的高阶函数&lt;/h2&gt;
&lt;ol start=&quot;1&quot;&gt;&lt;li rel=&quot;1&quot;&gt;map：对传入集合的每个元素进行映射，返回每个元素处理后的集合。&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17494&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scala&amp;gt; &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;).map(&lt;span&gt;2&lt;/span&gt; * _)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;res23: &lt;span&gt;Array&lt;/span&gt;[&lt;span&gt;Int&lt;/span&gt;] = &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;6&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li rel=&quot;2&quot;&gt;&lt;code&gt;foreach：对传入的每个元素都进行处理，但是没有返回值。&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17465&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scala&amp;gt; (&lt;span&gt;1&lt;/span&gt; to &lt;span&gt;9&lt;/span&gt;).map(&lt;span&gt;&quot;*&quot;&lt;/span&gt; * _).foreach(println _)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;*&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;**&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;***&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;****&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;*****&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;******&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;*******&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;********&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;*********&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li rel=&quot;3&quot;&gt;&lt;code&gt;filter：对传入的每个元素都进行条件判断，保留True元素。&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17466&quot; readability=&quot;18&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scala&amp;gt; (&lt;span&gt;1&lt;/span&gt; to &lt;span&gt;20&lt;/span&gt;).filter(_ % &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;res20: scala.collection.immutable.&lt;span&gt;IndexedSeq&lt;/span&gt;[&lt;span&gt;Int&lt;/span&gt;] = &lt;span&gt;Vector&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;, &lt;span&gt;14&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;, &lt;span&gt;18&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li rel=&quot;4&quot;&gt;&lt;code&gt;reduceLeft：从左侧开始，即先对参数0和参数1进行处理，然后将结果与元素2处理，再将结果与元素3处理，一次类推，即为reduce；（Spark编程的重点！）&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17467&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// 相当于1 * 2 * 3 *……* 9&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scala&amp;gt; (&lt;span&gt;1&lt;/span&gt; to &lt;span&gt;9&lt;/span&gt;).reduceLeft(_ * _)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;res21: &lt;span&gt;Int&lt;/span&gt; = &lt;span&gt;362880&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li rel=&quot;5&quot;&gt;&lt;code&gt;对元素进行两两比较，排序&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17468&quot; readability=&quot;17&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scala&amp;gt; &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;).sortWith(_ &amp;lt; _)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;res22: &lt;span&gt;Array&lt;/span&gt;[&lt;span&gt;Int&lt;/span&gt;] = &lt;span&gt;Array&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt; &lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17529&quot; readability=&quot;7&quot;&gt;
&lt;h2&gt;&lt;code&gt;闭包&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&lt;strong&gt;&lt;code&gt;函数在变量不处于其有效作用域时，还能够对变量进行访问，即为闭包&lt;/code&gt;&lt;/strong&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17590&quot; readability=&quot;21&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scala&amp;gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;getGreetingFunc&lt;/span&gt;&lt;/span&gt;(msg: &lt;span&gt;String&lt;/span&gt;) = (name: &lt;span&gt;String&lt;/span&gt;) =&amp;gt; println(msg + &lt;span&gt;&quot;, &quot;&lt;/span&gt; + name)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;

&lt;p&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; greetingFuncHello = getGreetingFunc(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;)&lt;/p&gt;

&lt;p&gt;scala&amp;gt; &lt;span&gt;val&lt;/span&gt; greetingFuncHi = getGreetingFunc(&lt;span&gt;&quot;hi&quot;&lt;/span&gt;)&lt;/p&gt;

&lt;p&gt;scala&amp;gt; greetingFuncHello(&lt;span&gt;&quot;sparks&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;hello, sparks&lt;/p&gt;

&lt;p&gt;scala&amp;gt; greetingFuncHi(&lt;span&gt;&quot;sparks&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;hi, sparks&lt;/p&gt;
&lt;p&gt;在上面的getGreetingFunc函数中，msg只是一个局部变量，却在getGreetingFunc执行完后，还可以继续存在创建的函数之中。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;greetingFuncHello(“sparks”)运行时，还值为hello的msg被保留在了函数体内部，可以反复使用。 &lt;br/&gt;这种变量超出了其作用域，还能够对变量进行访问，即为闭包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17471&quot; readability=&quot;8&quot;&gt;
&lt;h3&gt;原理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Scala通过为每个函数创建对象来时间闭包，实际上对于greetingFunc函数创建的函数，msg是作为函数对象的变量存在的，因此每个函数才可以拥有不同msg。&lt;/strong&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17622&quot; readability=&quot;13&quot;&gt;
&lt;h2&gt;SAM转换&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;在Java中，不支持直接将函数当做参数传入方法，唯一的办法就是定义一个实现了某个接口的类的实例对象，该对象只有一个方法；而这些接口都只有单个的抽象方法，也就是single abstract method， 简称为SAM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于Scala是可以调用Java代码的，因为当我们调用Java的某个方法时，可能就不得不创建SAM传递给方法，非常麻烦；但是Scala又是支持直接传递函数的，此时就可以使用Scala提供的隐式转换特性将SAM转化为Scala函数。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17473&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; javax.swing._&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.awt.event._&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;// 标准的JAVA SAM写法&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;val&lt;/span&gt; button = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;JButton&lt;/span&gt;(&lt;span&gt;&quot;Click&quot;&lt;/span&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;button.addActionListener(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;ActionListener&lt;/span&gt; {&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;override&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;actionPerformed&lt;/span&gt;&lt;/span&gt;(event: &lt;span&gt;ActionEvent&lt;/span&gt;){&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;println(&lt;span&gt;&quot;Click me&quot;&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;})&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 直接传入函数参数报错，类型不匹配&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; button.addActionListener{(event: &lt;span&gt;ActionEvent&lt;/span&gt;) =&amp;gt; println(&lt;span&gt;&quot;click me&quot;&lt;/span&gt;)}&lt;/p&gt;
&lt;p&gt;&amp;lt;console&amp;gt;:&lt;span&gt;15&lt;/span&gt;: error: &lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;mismatch&lt;/span&gt;&lt;/span&gt;;&lt;/p&gt;
&lt;p&gt;found : java.awt.event.&lt;span&gt;ActionEvent&lt;/span&gt; =&amp;gt; &lt;span&gt;Unit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;required: java.awt.event.&lt;span&gt;ActionListener&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;button.addActionListener{(event: &lt;span&gt;ActionEvent&lt;/span&gt;) =&amp;gt; println(&lt;span&gt;&quot;click me&quot;&lt;/span&gt;)}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 隐式转换&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;implicit&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;getActionListener&lt;/span&gt;&lt;/span&gt;(actionProcessFunc: (&lt;span&gt;ActionEvent&lt;/span&gt;) =&amp;gt; &lt;span&gt;Unit&lt;/span&gt;) = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ActionListener&lt;/span&gt;{&lt;/p&gt;
&lt;p&gt;&lt;span&gt;override&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;actionPerformed&lt;/span&gt;&lt;/span&gt;(event: &lt;span&gt;ActionEvent&lt;/span&gt;){&lt;/p&gt;
&lt;p&gt;actionProcessFunc(event)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// 隐式转换后再传函数参数就ok了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; button.addActionListener{(event: &lt;span&gt;ActionEvent&lt;/span&gt;) =&amp;gt; println(&lt;span&gt;&quot;click me&quot;&lt;/span&gt;)}&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17474&quot; readability=&quot;10&quot;&gt;
&lt;h2&gt;Currying函数&lt;/h2&gt;
&lt;p&gt;定义：将原来接收两个参数的一个函数，转换为两个函数。 &lt;br/&gt;第一个函数接收原先的第一个参数，然后返回接收原先第二个参数的第二个函数。 &lt;br/&gt;在函数调用的过程中，就变成了两个函数连续调用的形式。 &lt;br/&gt;在Spark的源码中也使用了此特性。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17475&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;scala&amp;gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;&lt;/span&gt;(a: &lt;span&gt;Int&lt;/span&gt;, b: &lt;span&gt;Int&lt;/span&gt;) = a + b&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;scala&amp;gt; sum(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;res30: &lt;span&gt;Int&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// Currying函数原理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;sum2&lt;/span&gt;&lt;/span&gt;(a: &lt;span&gt;Int&lt;/span&gt;) = (b: &lt;span&gt;Int&lt;/span&gt;) =&amp;gt; a + b&lt;/p&gt;
&lt;p&gt;scala&amp;gt; sum2(&lt;span&gt;1&lt;/span&gt;)(&lt;span&gt;1&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;res31: &lt;span&gt;Int&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;// Scala提供的更加简洁的语法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;scala&amp;gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;sum3&lt;/span&gt;&lt;/span&gt;(a: &lt;span&gt;Int&lt;/span&gt;)(b: &lt;span&gt;Int&lt;/span&gt;) = a + b&lt;/p&gt;
&lt;p&gt;scala&amp;gt; sum3(&lt;span&gt;1&lt;/span&gt;)(&lt;span&gt;1&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;res32: &lt;span&gt;Int&lt;/span&gt; = &lt;span&gt;2&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17476&quot; readability=&quot;8&quot;&gt;
&lt;h2&gt;return&lt;/h2&gt;
&lt;p&gt;在Scala中，不需要使用return来返回函数值，但是如果要使用的话，该函数必须要给出返回类型，否则无法通过编译。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;wmd-preview-section-17477&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;functionName&lt;/span&gt;&lt;/span&gt; ([参数列表]) : [&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;type&lt;/span&gt;]&lt;/span&gt; = {&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt;function body&lt;/p&gt;
&lt;p&gt;&lt;span&gt;return&lt;/span&gt; [expr]&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;object&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;/span&gt;{&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;addInt&lt;/span&gt;&lt;/span&gt;( a:&lt;span&gt;Int&lt;/span&gt;, b:&lt;span&gt;Int&lt;/span&gt; ) : &lt;span&gt;Int&lt;/span&gt; = {&lt;/p&gt;
&lt;p&gt;&lt;span&gt;var&lt;/span&gt; sum:&lt;span&gt;Int&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;sum = a + b&lt;/p&gt;

&lt;p&gt;&lt;span&gt;return&lt;/span&gt; sum&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Thu, 14 Dec 2017 14:28:00 +0000</pubDate>
<dc:creator>小丑进场</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LiCheng-/p/8040348.html</dc:identifier>
</item>
<item>
<title>keepalived结合nginx实现nginx高可用 - 无涯Ⅱ</title>
<link>http://www.cnblogs.com/wlandwl/p/keepalived.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wlandwl/p/keepalived.html</guid>
<description>&lt;div class=&quot;para&quot; readability=&quot;68.606257378985&quot;&gt;
&lt;p&gt; Keepalived 是一个基于VRRP协议来实现的LVS服务高可用方案，可以利用其来避免单点故障。一个LVS服务会有2台服务器运行Keepalived，一台为主服务器（MASTER），一台为备份服务器（BACKUP），但是对外表现为一个虚拟IP，主服务器会发送特定的消息给备份服务器，当备份服务器收不到这个消息的时候，即主服务器宕机的时候， 备份服务器就会接管虚拟IP，继续提供服务，从而保证了高可用性。Keepalived是VRRP的完美实现，因此在介绍keepalived之前，先介绍一下VRRP的原理。&lt;/p&gt;
&lt;p&gt;1.VRRP 协议简介&lt;/p&gt;
&lt;p&gt;在现实的网络环境中，两台需要通信的主机大多数情况下并没有直接的物理连接。对于这样的情况，它们之间路由怎样选择？主机如何选定到达目的主机的下一跳路由，这个问题通常的解决方法有二种：&lt;/p&gt;
&lt;p&gt;很明显，在主机上配置动态路由是非常不切实际的，因为管理、维护成本以及是否支持等诸多问题。配置静态路由就变得十分流行，但路由器(或者说默认网关default gateway)却经常成为单点故障。VRRP的目的就是为了解决静态路由单点故障问题，VRRP通过一竞选(election)协议来动态的将路由任务交给LAN中虚拟路由器中的某台VRRP路由器。&lt;/p&gt;
&lt;p&gt;2.VRRP 工作机制&lt;/p&gt;
&lt;p&gt;       在一个VRRP虚拟路由器中，有多台物理的VRRP路由器，但是这多台的物理的机器并不能同时工作，而是由一台称为MASTER的负责路由工作，其它的都是BACKUP，MASTER并非一成不变，VRRP让每个VRRP路由器参与竞选，最终获胜的就是MASTER。MASTER拥有一些特权，比如，拥有虚拟路由器的IP地址，我们的主机就是用这个IP地址作为静态路由的。拥有特权的MASTER要负责转发发送给网关地址的包和响应ARP请求。&lt;/p&gt;
&lt;p&gt;       VRRP通过竞选协议来实现虚拟路由器的功能，所有的协议报文都是通过IP多播(multicast)包(多播地址224.0.0.18)形式发送的。虚拟路由器由VRID(范围0-255)和一组IP地址组成，对外表现为一个周知的MAC地址。所以，在一个虚拟路由 器中，不管谁是MASTER，对外都是相同的MAC和IP(称之为VIP)。客户端主机并不需要因为MASTER的改变而修改自己的路由配置，对客户端来说，这种主从的切换是透明的。&lt;/p&gt;
&lt;p&gt;       在一个虚拟路由器中，只有作为MASTER的VRRP路由器会一直发送VRRP通告信息(VRRPAdvertisement message)，BACKUP不会抢占MASTER，除非它的优先级(priority)更高。当MASTER不可用时(BACKUP收不到通告信息)， 多台BACKUP中优先级最高的这台会被抢占为MASTER。这种抢占是非常快速的(&amp;lt;1s)，以保证服务的连续性。由于安全性考虑，VRRP包使用了加密协议进行加密。&lt;/p&gt;
&lt;p&gt;3.VRRP 工作流程&lt;/p&gt;
&lt;p&gt;(1).初始化：    &lt;br/&gt;路由器启动时，如果路由器的优先级是255(最高优先级，路由器拥有路由器地址)，要发送VRRP通告信息，并发送广播ARP信息通告路由器IP地址对应的MAC地址为路由虚拟MAC，设置通告信息定时器准备定时发送VRRP通告信息，转为MASTER状态；否则进入BACKUP状态，设置定时器检查定时检查是否收到MASTER的通告信息。&lt;/p&gt;
&lt;p&gt;(2).Master&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;6&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;设置定时通告定时器；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用VRRP虚拟MAC地址响应路由器IP地址的ARP请求；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;转发目的MAC是VRRP虚拟MAC的数据包；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果是虚拟路由器IP的拥有者，将接受目的地址是虚拟路由器IP的数据包，否则丢弃；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当收到shutdown的事件时删除定时通告定时器，发送优先权级为0的通告包，转初始化状态；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果定时通告定时器超时时，发送VRRP通告信息；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;收到VRRP通告信息时，如果优先权为0，发送VRRP通告信息；否则判断数据的优先级是否高于本机，或相等而且实际IP地址大于本地实际IP，设置定时通告定时器，复位主机超时定时器，转BACKUP状态；否则的话，丢弃该通告包；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;(3).Backup&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;设置主机超时定时器；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不能响应针对虚拟路由器IP的ARP请求信息；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;丢弃所有目的MAC地址是虚拟路由器MAC地址的数据包；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不接受目的是虚拟路由器IP的所有数据包；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当收到shutdown的事件时删除主机超时定时器，转初始化状态；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;主机超时定时器超时的时候，发送VRRP通告信息，广播ARP地址信息，转MASTER状态；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;收到VRRP通告信息时，如果优先权为0，表示进入MASTER选举；否则判断数据的优先级是否高于本机，如果高的话承认MASTER有效，复位主机超时定时器；否则的话，丢弃该通告包；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4.ARP查询处理&lt;/p&gt;
&lt;p&gt;       当内部主机通过ARP查询虚拟路由器IP地址对应的MAC地址时，MASTER路由器回复的MAC地址为虚拟的VRRP的MAC地址，而不是实际网卡的 MAC地址，这样在路由器切换时让内网机器觉察不到；而在路由器重新启动时，不能主动发送本机网卡的实际MAC地址。如果虚拟路由器开启的ARP代理 (proxy_arp)功能，代理的ARP回应也回应VRRP虚拟MAC地址。&lt;/p&gt;
&lt;h3&gt;2.搭建环境&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;服务器1：10.63.0.154  安装keeplived并设置priority 优先值为100&lt;/li&gt;
&lt;li&gt;服务器2：10.63.0.155  安装keeplived并设置priority 优先值为98&lt;/li&gt;
&lt;li&gt;设置两台服务器对应的虚拟ip为：10.63.0.158&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;3.安装keepalived主节点&lt;/h3&gt;
&lt;p&gt;在服务器上安装nginx，安装方法可参考文章：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/wlandwl/p/fastdfs.html&quot; target=&quot;_blank&quot;&gt;FastDFS教程Ⅰ-文件服务器安装与Nginx配置&lt;/a&gt;。本次安装keepalived采用yum的模式，在服务器1上安装，主要操作步骤如下：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;安装ipvsadm，指令：yum install ipvsadm，安装完成后，可通过指令ipvsadm –v查看版本号。&lt;/li&gt;
&lt;li&gt;安装keepalived，指令：yum install keepalived，安装完成后，可通过指令Keepalived –v查看版本号。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;创建/usr/local/nginx/nginx_check.sh脚本。脚本内容如下：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_3e08c7c6-56f4-4465-b8ee-d7226c9a0753&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3e08c7c6-56f4-4465-b8ee-d7226c9a0753&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3e08c7c6-56f4-4465-b8ee-d7226c9a0753&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#!/bin/bash
#判断nginx服务是否启动，如果不存在，调用nginx启用命令，并停止2秒，若#启动失败，杀掉keepalived
A=`ps -C nginx --no-header |wc -l`
if [ $A -eq 0 ];then 
    /usr/sbin/nginx
    sleep 2
    if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then
        killall keepalived
    fi
fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 设置nginx_check.sh权限，设置命令为：&lt;strong&gt;chmod  777   /usr/local/nginx/nginx_check.sh&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;配置keepalived节点信息，默认配置文件为&lt;strong&gt;/etc/keepalived/keepalived.conf。&lt;/strong&gt;keepalived.conf配置文件如下：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_853435f2-cf7c-497f-819a-dfe84094fad6&quot; class=&quot;code_img_closed&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_853435f2-cf7c-497f-819a-dfe84094fad6&quot; class=&quot;code_img_opened&quot; src=&quot;http://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_853435f2-cf7c-497f-819a-dfe84094fad6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;! Configuration File for keepalived

global_defs {
   router_id nginx_master154
}

vrrp_script chk_nginx {
   script &quot;/usr/local/nginx/nginx_check.sh&quot;
    interval 2
    weight 20
}
vrrp_instance VI_1 {
    state  MASTER
    interface  eth0
    virtual_router_id 154
   mcast_src_ip 10.63.0.154
    priority 100
    nopreempt
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }
  track_script {
        chk_nginx
    }
    virtual_ipaddress {
        10.63.0.158
    }
}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 配置文件关键参数说明：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt; router_id   //定义节点名称&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;vrrp_script chk_nginx {    script &quot;/etc/keepalived/nginx_check.sh&quot;     interval 2     weight -20  }    //每隔2秒中去执行/etc/keepalived/nginx_check.sh脚本一次，这项检查从开始便一直进行，interval表示间隔时间，weight -20的意思是，脚本执行当判断异常时，把10.63.0.154这个节点的优先级降低20。&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;state MASTER   //表示该节点角色定义为MASTER&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;virtual_router_id 154  //定义虚拟的节点标识&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;interface eth0   //定义网卡名称 查看服务器网卡名称可通过指令：ifconfig或者ip  a，如图：&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;&lt;img src=&quot;http://images2017.cnblogs.com/blog/626790/201712/626790-20171214214442951-1433777587.png&quot; alt=&quot;&quot;/&gt; &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    以上配置文件完成后，启动nginx,启动keepalived，可测试nginx是否可被虚拟ip地址访问。启动keepalived指令：&lt;strong&gt;systemctl start keepalived.service&lt;/strong&gt;，启动后可通过指令 &lt;strong&gt;systemctl status keepalived.service&lt;/strong&gt;查看状态。利用虚拟ip访问nginx主界面截图如下：&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;http://images2017.cnblogs.com/blog/626790/201712/626790-20171214220355701-318701355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.安装keepalived备用节点&lt;/h3&gt;
&lt;p&gt; 在服务器2上面安装keepalived的方法和服务器1完全一样，在keepalived.conf配置文件中只需修改三个地方：&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;alt&quot;&gt;interface eth0   //定义网卡名称 查看服务器2的网卡 如网卡名称为 eno24 ,则定义为：interface eno24&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;priority  //优先值设置为98&lt;/li&gt;
&lt;li class=&quot;alt&quot;&gt;mcast_src_ip 10.63.0.155&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两台服务器上面的keepalived安装成功后，通过虚拟ip10.63.0.158调用测试，发现始终是主节点的页面，不会调用备用节点的页面。设置把服务器1上面的keepalived关闭后，再次调用，会出现备用节点的主界面，如下图：&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;http://images2017.cnblogs.com/blog/626790/201712/626790-20171214221042420-2035957864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.Linux服务管理工具systemctl&lt;/h3&gt;
&lt;p&gt;Linux中，有service和chkconfig两个命令管理服务。systemctl 是管理服务的主要工具， 它整合了chkconfig 与 service功能于一体。(可以通过该命令管理yum安装软件,同时设置是否开机启动)&lt;/p&gt;
&lt;div readability=&quot;10.950561797753&quot;&gt;
&lt;ul&gt;&lt;li&gt;systemctl is-enabled servicename.service #查询服务是否开机启动&lt;/li&gt;
&lt;li&gt;systemctl enable *.service #开机运行服务&lt;/li&gt;
&lt;li&gt;systemctl disable *.service #取消开机运行&lt;/li&gt;
&lt;li&gt;systemctl start *.service #启动服务&lt;/li&gt;
&lt;li&gt;systemctl stop *.service #停止服务&lt;/li&gt;
&lt;li&gt;systemctl restart *.service #重启服务&lt;/li&gt;
&lt;li&gt;systemctl reload *.service #重新加载服务配置文件&lt;/li&gt;
&lt;li&gt;systemctl status *.service #查询服务运行状态&lt;/li&gt;
&lt;li&gt;systemctl --failed #显示启动失败的服务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       注：*代表某个服务的名字，如http的服务名为httpd&lt;/p&gt;
&lt;p&gt;例如在&lt;a title=&quot;CentOS&quot; href=&quot;http://www.linuxidc.com/topicnews.aspx?tid=14&quot; target=&quot;http://www.linuxidc.com/Linux/2014-11/_blank&quot;&gt;CentOS&lt;/a&gt; 7 上安装http&lt;/p&gt;
&lt;p&gt;      [root@CentOS7 ~]# yum -y install httpd&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 14 Dec 2017 14:25:00 +0000</pubDate>
<dc:creator>无涯Ⅱ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wlandwl/p/keepalived.html</dc:identifier>
</item>
<item>
<title>Golang学习--包管理工具glide - 疯狂的原始人</title>
<link>http://www.cnblogs.com/CraryPrimitiveMan/p/7828357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CraryPrimitiveMan/p/7828357.html</guid>
<description>&lt;p&gt;上一篇文章中我们已经成功的运行了go的代码，这是我们迈出的最基础的一步。&lt;/p&gt;
&lt;p&gt;一个项目通常会依赖很多外部的库，当依赖的库比较多的时候，手工管理就会比较麻烦，这个时候就需要包管理工具出场了，帮你管理好所有依赖的库。&lt;/p&gt;
&lt;p&gt;php项目中使用composer，javascript项目中使用npm，那么在go项目中，我们需要使用什么？&lt;/p&gt;
&lt;h3 id=&quot;包依赖工具的选择&quot;&gt;包依赖工具的选择&lt;/h3&gt;
&lt;p&gt;当前go的包管理工具有&lt;a href=&quot;https://github.com/Masterminds/glide&quot;&gt;glide&lt;/a&gt;、&lt;a href=&quot;https://github.com/tools/godep&quot;&gt;godep&lt;/a&gt;、&lt;a href=&quot;https://github.com/kardianos/govendor&quot;&gt;govendor&lt;/a&gt;和&lt;a href=&quot;https://github.com/FiloSottile/gvt&quot;&gt;gvt&lt;/a&gt;等，相关对比的文章可以查看&lt;a href=&quot;https://studygolang.com/articles/10523&quot;&gt;《go依赖包管理工具对比》&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;功能对比可以参考如下内容（虽然跟上面文章比较的工具有些不同），内容来自&lt;a href=&quot;https://github.com/Masterminds/glide/wiki/Go-Package-Manager-Comparison&quot;&gt;《Go Package Manager Comparison》&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Semantic Versions&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Semantic Version Ranges&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Resolves dependency trees including versions&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Uses common range syntax (similar to PHP, JavaScript, etc)&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Tries to import from other package managers&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Copies from the GOPATH&lt;/td&gt;
&lt;td&gt;✕*&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Works with the go toolchain&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Locks for reproducible builds&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Allows package/version checked into VCS or installed on demand&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;Aliased repos (e.g., using forks)&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Plugin extensibility model&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Supports deleting unused repos for cleanup (opt-in)&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;td&gt;✕&lt;/td&gt;
&lt;td&gt;✓&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;根据我们的需求和了解，选择了使用glide，当然大家也可以选择其他包管理工具。&lt;/p&gt;
&lt;h3 id=&quot;glide命令&quot;&gt;glide命令&lt;/h3&gt;
&lt;p&gt;我们来熟悉一下glide的命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 初始化glide配置
glide create
glide init

# 添加新的包
glide get [package name]

# 根据glide.yaml更新包
glide update
glide up

# 根据glide.yaml安装包
glide install

# 返回当前项目的名称
glide name

# 列出当前项目已安装的包
glide list

# 替换包的镜像
glide mirror set [original] [replacement]
glide mirror set [original] [replacement] --vcs [type]

# 移除包的镜像
glide mirror remove [original]

# 获取包的镜像列表
glide mirror list&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;glide mirror特别适用于不能访问一些站点，导致很Golang的依赖包不能通过go get下载的情况。可以通过配置将墙了的版本库 URL 映射到没被墙的 URL，甚至也可以映射到本地版本库。&lt;/p&gt;
&lt;p&gt;掌握上面的命令就可以使用glide了，是不是很简单？&lt;/p&gt;
&lt;h3 id=&quot;glide.yaml解析&quot;&gt;glide.yaml解析&lt;/h3&gt;
&lt;p&gt;我们再来看一一个完整的glide.yaml的内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package: github.com/Masterminds/glide
homepage: https://masterminds.github.io/glide
license: MIT
owners:
- name: Matt Butcher
  email: technosophos@gmail.com
  homepage: http://technosophos.com
- name: Matt Farina
  email: matt@mattfarina.com
  homepage: https://www.mattfarina.com
ignore:
- appengine
excludeDirs:
- node_modules
import:
- package: gopkg.in/yaml.v2
- package: github.com/Masterminds/vcs
  version: ^1.2.0
  repo:    git@github.com:Masterminds/vcs
  vcs:     git
- package: github.com/codegangsta/cli
  version: f89effe81c1ece9c5b0fda359ebd9cf65f169a51
- package: github.com/Masterminds/semver
  version: ^1.0.0
# 测试导入包
testImport:
- package: github.com/arschles/assert&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;glide.yaml中的这些元素的解释如下：&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;package&lt;/code&gt;：顶部的 package 是它所在GOPATH的位置，glide 将从该位置下开始导包。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;homepage&lt;/code&gt;：该项目的详情页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;license&lt;/code&gt;：许可证标识，可以是SPDX license字符串或文件路径。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;owners&lt;/code&gt;：项目的所有者信息，便于接受漏洞信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;ignore&lt;/code&gt;：忽略导入的包，注意是包而不是目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;excludeDirs&lt;/code&gt;：排除扫描依赖的目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;import&lt;/code&gt;：import 的包列表：&lt;/p&gt;
&lt;ul readability=&quot;13&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;package&lt;/code&gt;：导入包的名称，必填。软件包名称遵循go工具所用的相同模式。这意味着：1、映射到VCS远程位置的软件包名称以.git，.bzr，.hg或.svn结尾。 例如，example.com/foo/pkg.git/subpkg。2、GitHub, BitBucket, Launchpad, IBM Bluemix Services, and Go on Google Source是特殊情况，不需要 VCS 扩展。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;version&lt;/code&gt;：可以为semantic version, semantic version range, branch, tag 或者 commit id。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;repo&lt;/code&gt;：如果包名称不是repo位置或这是一个私人存储库，它可以去这里。 该软件包将从repo签出并放在软件包名称指定的位置。 这允许使用fork。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;vcs&lt;/code&gt;：要使用的VCS，如git，hg，bzr或svn。仅当无法从名称中检测到类型时才需要。例如，以.git或GitHub结尾的仓库可以被检测为Git。 对于Bitbucket的repo，我们可以联系API来发现类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;subpackages&lt;/code&gt;：在存储库中使用的包的记录。这不包括存储库中的所有包，而是包括正在使用的包。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;os&lt;/code&gt;：用于过滤的操作系统的列表。如果设置它将比较当前运行时操作系统与指定的操作系统，并且只有获取匹配的依赖。如果未设置过滤，则跳过。这些名称与构建标志和GOOS环境变量中使用的名称相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;arch&lt;/code&gt;：用于过滤的体系结构列表。如果设置它将比较当前运行时架构与指定的架构，并且只有在匹配时获取依赖关系。如果未设置过滤，则跳过。名称与构建标志和GOARCH环境变量中使用的名称相同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;testImport&lt;/code&gt;：在导入中未列出的测试中使用的软件包列表。每个包具有与导入下列出的相同的详细信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;glide版本号指定规则如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;=: equal (aliased to no operator)
!=: not equal
&amp;gt;: greater than
&amp;lt;: less than
&amp;gt;=: greater than or equal to
&amp;lt;=: less than or equal to

1.2 - 1.4.5 which is equivalent to &amp;gt;= 1.2, &amp;lt;= 1.4.5
2.3.4 - 4.5 which is equivalent to &amp;gt;= 2.3.4, &amp;lt;= 4.5
1.2.x is equivalent to &amp;gt;= 1.2.0, &amp;lt; 1.3.0

&amp;gt;= 1.2.x is equivalent to &amp;gt;= 1.2.0
&amp;lt;= 2.x is equivalent to &amp;lt; 3
* is equivalent to &amp;gt;= 0.0.0

~1.2.3 is equivalent to &amp;gt;= 1.2.3, &amp;lt; 1.3.0
~1 is equivalent to &amp;gt;= 1, &amp;lt; 2
~2.3 is equivalent to &amp;gt;= 2.3, &amp;lt; 2.4
~1.2.x is equivalent to &amp;gt;= 1.2.0, &amp;lt; 1.3.0
~1.x is equivalent to &amp;gt;= 1, &amp;lt; 2

^1.2.3 is equivalent to &amp;gt;= 1.2.3, &amp;lt; 2.0.0
^1.2.x is equivalent to &amp;gt;= 1.2.0, &amp;lt; 2.0.0
^2.3 is equivalent to &amp;gt;= 2.3, &amp;lt; 3
^2.x is equivalent to &amp;gt;= 2.0.0, &amp;lt; 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要注意的是安装完成之后，会生成glide.lock文件，锁定安装包的版本。&lt;/p&gt;
&lt;h3 id=&quot;参考摘录文章&quot;&gt;参考摘录文章&lt;/h3&gt;
</description>
<pubDate>Thu, 14 Dec 2017 14:24:00 +0000</pubDate>
<dc:creator>疯狂的原始人</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CraryPrimitiveMan/p/7828357.html</dc:identifier>
</item>
</channel>
</rss>