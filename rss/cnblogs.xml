<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>3.Hadoop测试Yarn和MapReduce - 零度微笑</title>
<link>http://www.cnblogs.com/TimerHotel/p/hadoop03.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TimerHotel/p/hadoop03.html</guid>
<description>&lt;h2 id=&quot;配置yarn&quot;&gt;1.配置Yarn&lt;/h2&gt;
&lt;h3 id=&quot;配置resourcemanager&quot;&gt;（1）配置ResourceManager&lt;/h3&gt;
&lt;p&gt;生产环境中，一般是重开一台机器作为ResourceManager，这里我们以Master机器代替。&lt;/p&gt;
&lt;p&gt;修改yarn-site.xml：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;!--
  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License. See accompanying LICENSE file.
--&amp;gt;
&amp;lt;configuration&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;yarn.resourcemanager.hostname&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;master&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
 
&amp;lt;property&amp;gt;  
    &amp;lt;name&amp;gt;yarn.nodemanager.aux-services&amp;lt;/name&amp;gt;  
    &amp;lt;value&amp;gt;mapreduce_shuffle&amp;lt;/value&amp;gt;  
&amp;lt;/property&amp;gt;  
 
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;yarn.nodemanager.auxservices.mapreduce.shuffle.class&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;org.apache.hadoop.mapred.ShuffleHandler&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;!-- Site specific YARN configuration properties --&amp;gt;

&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置nodemanager&quot;&gt;（2）配置NodeManager&lt;/h3&gt;
&lt;p&gt;NodeManager作为DataNode所在机器的资源管理程序，一般情况下直接放在DataNode所在节点。&lt;br/&gt;修改yarn-site.xml：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;!--
  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License. See accompanying LICENSE file.
--&amp;gt;
&amp;lt;configuration&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;yarn.resourcemanager.hostname&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;master&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
 
&amp;lt;property&amp;gt;  
    &amp;lt;name&amp;gt;yarn.nodemanager.aux-services&amp;lt;/name&amp;gt;  
    &amp;lt;value&amp;gt;mapreduce_shuffle&amp;lt;/value&amp;gt;  
&amp;lt;/property&amp;gt;  
 
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;yarn.nodemanager.auxservices.mapreduce.shuffle.class&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;org.apache.hadoop.mapred.ShuffleHandler&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;!-- Site specific YARN configuration properties --&amp;gt;

&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动yarn&quot;&gt;（3）启动yarn&lt;/h3&gt;
&lt;p&gt;在ResourceManager所在机器上：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;start-yarn.sh&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;配置mapreduce&quot;&gt;2.配置MapReduce&lt;/h2&gt;
&lt;p&gt;copy一份maper-site.xml.template作为maper-site.xml：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&amp;gt;
&amp;lt;!--
  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License. See accompanying LICENSE file.
--&amp;gt;

&amp;lt;!-- Put site-specific property overrides in this file. --&amp;gt;

&amp;lt;configuration&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;mapreduce.framework.name&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;yarn&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试wordcount实例&quot;&gt;3.测试WordCount实例&lt;/h2&gt;
&lt;h3 id=&quot;上传计算使用文件hello.txt&quot;&gt;（1）上传计算使用文件hello.txt&lt;/h3&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;hello xm
hello sir
java c
python vb
java c++
go php
erlang java&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;输入测试命令&quot;&gt;（2）输入测试命令&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;hadoop jar hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.3.jar wordcount /input/hello.txt /output&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;查看测试结果&quot;&gt;（3）查看测试结果&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;hadoop fs -ls /output&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Found 2 items
-rw-r--r--   3 root supergroup          0 2018-10-18 15:19 /output/_SUCCESS
-rw-r--r--   3 root supergroup         70 2018-10-18 15:19 /output/part-r-00000
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;hadoop fs -text /output/part-r-00000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;c   1
c++ 1
erlang  1
go  1
hello   2
java    3
php 1
python  1
sir 1
vb  1
xm  1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;web查看测试结果&quot;&gt;4.web查看测试结果&lt;/h2&gt;
&lt;h3 id=&quot;hdfsmaster50070&quot;&gt;（1）HDFS：master:50070&lt;/h3&gt;
&lt;h3 id=&quot;yarnmaster8088&quot;&gt;（2）Yarn：master:8088&lt;/h3&gt;
</description>
<pubDate>Thu, 18 Oct 2018 07:34:00 +0000</pubDate>
<dc:creator>零度微笑</dc:creator>
<og:description>Hadoop测试Yarn和MapReduce 1.配置Yarn （1）配置ResourceManager 生产环境中，一般是重开一台机器作为ResourceManager，这里我们以Master机器代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TimerHotel/p/hadoop03.html</dc:identifier>
</item>
<item>
<title>Android开发 - 更&quot;聪明&quot;的申请权限方式 - ExampleCode</title>
<link>http://www.cnblogs.com/lloyd-zh/p/9810769.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lloyd-zh/p/9810769.html</guid>
<description>&lt;p&gt;在Android6.0以后，很多权限需要动态申请，只有在用户点同意后，我们才能使用对应API，因此，正确申请权限就显得很重要。&lt;/p&gt;
&lt;h2 id=&quot;常用方式&quot;&gt;常用方式&lt;/h2&gt;
&lt;p&gt;通常我们使用这种方式来判断权限状态：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static boolean isGranted(final String permission) {
    return Build.VERSION.SDK_INT &amp;lt; Build.VERSION_CODES.M
            || PackageManager.PERMISSION_GRANTED
            == ContextCompat.checkSelfPermission(Utils.getApp(), permission);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是用这种方式我们会碰到一个比较棘手的情况，当用户同意了某个权限后，然后用户又在手机的系统设置的应用权限中关闭了这个权限，此时我们并不能正确获取到正确的权限状态。&lt;/p&gt;
&lt;h2 id=&quot;解决办法&quot;&gt;解决办法&lt;/h2&gt;
&lt;p&gt;有可能Android团队意识到中这个问题，所以他们发布了一个新的权限检查类：android.support.v4.content.PermissionChecker;&lt;/p&gt;
&lt;p&gt;用这个类进行权限的检查就会正确返回，所以我们把权限校验的方法修改如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import android.support.v4.content.PermissionChecker;

private static boolean isGranted(final String permission) {
    return Build.VERSION.SDK_INT &amp;lt; Build.VERSION_CODES.M
            || PackageManager.PERMISSION_GRANTED
            == PermissionChecker.checkCallingOrSelfPermission(Utils.getApp(), permission);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就会解决手机设置与用户授权不一致的问题。&lt;/p&gt;
&lt;p&gt;如有更多疑问，请参考我的其它Android相关博客：&lt;a href=&quot;http://examplecode.cn/categories/Android%E5%BC%80%E5%8F%91/&quot;&gt;我的博客地址&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Oct 2018 07:27:00 +0000</pubDate>
<dc:creator>ExampleCode</dc:creator>
<og:description>在Android6.0以后，很多权限需要动态申请，只有在用户点同意后，我们才能使用对应API，因此，正确申请权限就显得很重要。 常用方式 通常我们使用这种方式来判断权限状态： java private</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lloyd-zh/p/9810769.html</dc:identifier>
</item>
<item>
<title>使用cocoscreator + node.js + websocket实现简单的聊天服务 - 随风的博客</title>
<link>http://www.cnblogs.com/skyxu123/p/9810741.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyxu123/p/9810741.html</guid>
<description>&lt;p&gt;先上个效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651062/201810/651062-20181018150627919-807137556.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用cocoscreator 1.9.1 + node.js + websocket实现，没有使用socket.io, 全部自己封装，长连接进行封装后可以和短连接使用方法一样，使用简单，方便以后开发网络游戏。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、客户端：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　主要就是聊天内容的显示，自动换行和背景扩展，代码大概如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
cc.Class({
    extends: cc.Component,

    properties: {
        msgLabel: cc.Label,
        uidLabel: cc.Label,
        msgLayout: cc.Layout,
        msgBg: cc.Node,
        maxLen: 500,
    },

    // LIFE-CYCLE CALLBACKS:

    // onLoad () {},

    start () {
        this.node.runAction(cc.fadeTo(0.5, 255))
    },

    initMsg(msg, uid){
        this.msgLabel.string = msg;
        this.uidLabel.string = uid;

        this.msgLabel.overflow = cc.Label.Overflow.NONE;
        // this.msgBg.width = this.msgLabel.node.width + 10;
        // this.msgBg.height = this.msgLabel.node.height + 10;
        // this.node.height = this.msgBg.height + 40;

        this.scheduleOnce((dt)=&amp;gt;{
            if ( this.msgLabel.node.width &amp;gt;= this.maxLen){
                this.msgLabel.overflow = cc.Label.Overflow.RESIZE_HEIGHT;
                this.msgLabel.node.width = this.maxLen;
            }

            this.msgBg.width = this.msgLabel.node.width + 10;
            this.msgBg.height = this.msgLabel.node.height + 10;
            this.node.height = this.msgBg.height + 40;

        }, 0);

        this.node.opacity = 0;
    }

    // update (dt) {},
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　网络部分分成了四层：&lt;/p&gt;
&lt;p&gt;　　　　1、socket 封装基础的websocket, 这里是最底层，也是真正链接的开始&lt;/p&gt;
&lt;p&gt;　　　　2、network 控制socket链接层，实现各回调接口&lt;/p&gt;
&lt;p&gt;　　　　3、netproxy 封装各服务功能，把长连接变成短连接的请求方式&lt;/p&gt;
&lt;p&gt;　　　　4、netprotocols 和服务器协商，确定每个请求的请求体格式和回复格式&lt;/p&gt;
&lt;p&gt;　　各部分代码如下：&lt;/p&gt;
&lt;p&gt;　　GameWebSocket.js:　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * @enum {number}
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; GameWebSocketState =&lt;span&gt; cc.Enum({
    CONNECTING: &lt;/span&gt;1&lt;span&gt;,
    OPEN: &lt;/span&gt;2&lt;span&gt;,
    CLOSING: &lt;/span&gt;3&lt;span&gt;,
    CLOSED: &lt;/span&gt;4&lt;span&gt;
});

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * @interface
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; GameWebSocketDelegate =&lt;span&gt; cc.Class({

    onSocketOpen: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {

    },

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 收到了消息
     * @param {string|Uint8Array} data
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    onSocketMessage: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {

    },

    onSocketError: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {

    },

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 连接关闭
     * @param {string} reason
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    onSocketClosed: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (reason) {

    }
});

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * @interface
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; GameWebSocketInterface =&lt;span&gt; cc.Class({

    connect: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {

    },

    send: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {

    },

    close: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {

    },

    getState: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {

    }
});

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; GameWebSocket =&lt;span&gt; cc.Class({
    extends: GameWebSocketInterface,

    properties: {

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * @type {String} 服务器地址
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        _address: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * @type {GameWebSocketDelegate}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        _delegate: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * @type {WebSocket}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        _webSocket: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
    },

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * @param {string} address 服务器地址
     * @param {GameWebSocketDelegate} delegate 回调接口
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    init: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(address, delegate){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._address =&lt;span&gt; address;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._delegate =&lt;span&gt; delegate;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._webSocket = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    },

    connect: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        cc.log(&lt;/span&gt;'connect to '+ &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._address);

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ws = &lt;span&gt;this&lt;/span&gt;._webSocket = &lt;span&gt;new&lt;/span&gt; WebSocket(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._address);
        ws.onopen &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;._delegate.onSocketOpen.bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._delegate);
        ws.onmessage &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (param) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._delegate.onSocketMessage(param.data);
        }.bind(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        ws.onerror &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;._delegate.onSocketError.bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._delegate);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; function({code: Number, reason: String, wasClean: Boolean})}&lt;/span&gt;
        ws.onclose = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (param) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._delegate.onSocketClosed(param.reason);
        }.bind(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    },

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 发送数据
     * @param {string|Uint8Array} stringOrBinary
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    send: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (stringOrBinary) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._webSocket.send(stringOrBinary);
    },

    close: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._webSocket) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._webSocket.close();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (err) {
            cc.log(&lt;/span&gt;'error while closing webSocket'&lt;span&gt;, err.toString());
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._webSocket = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    },

    getState: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._webSocket) {
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._webSocket.readyState){
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; WebSocket.OPEN:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; GameWebSocketState.OPEN;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; WebSocket.CONNECTING:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; GameWebSocketState.CONNECTING;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; WebSocket.CLOSING:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; GameWebSocketState.CLOSING;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; WebSocket.CLOSED:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; GameWebSocketState.CLOSED;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; GameWebSocketState.CLOSED;
    }
});

module.exports &lt;/span&gt;=&lt;span&gt; {
    GameWebSocketState: GameWebSocketState,
    GameWebSocketDelegate: GameWebSocketDelegate,
    GameWebSocketInterface: GameWebSocketInterface,
    GameWebSocket: GameWebSocket
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　GameNetwork.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by skyxu on 2018/10/9.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&quot;use strict&quot;&lt;span&gt;;

let GameWebSocket &lt;/span&gt;= require(&quot;./GameWebSocket&quot;&lt;span&gt;);
let GameProtocols &lt;/span&gt;= require(&quot;./GameProtocols&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 服务器回复消息状态，判断回复消息的各种问题
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; response_state =&lt;span&gt; {
    ERROR_OK : &lt;/span&gt;'0'&lt;span&gt;
};

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 请求回调对象，收到服务器回调后的回调方法
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; NetworkCallback =&lt;span&gt; cc.Class({

    properties: {

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * @type {BaseRequest} request
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        request: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 请求回调对方法
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        callback: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;
    },

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * @param {BaseRequest} request
     * @param {function(BaseResponse): boolean} callback
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    init: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (request, callback) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.request =&lt;span&gt; request;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.callback =&lt;span&gt; callback;
    }
});


let GameNetwork &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: GameWebSocket.GameWebSocketDelegate,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._socket = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._delegate = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 每次发送请求，都需要有一个唯一的编号
         * @type {number}
         * @private
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;._requestSequenceId = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 接受服务器主动下发的response回调
         * key 表示BaseResponse.act
         * @type {Object.&amp;lt;string, function(object.&amp;lt;string, *&amp;gt;)&amp;gt;}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.pushResponseCallback =&lt;span&gt; {};

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 根据seq保存Request和其callback，以便在收到服务器的响应后回调
         * @type {Object.&amp;lt;int, NetworkCallback&amp;gt;}
         * @private
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;._networkCallbacks =&lt;span&gt; {};
    },

    setDelegate: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (delegate) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._delegate =&lt;span&gt; delegate;
    },

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 注册服务器主动推送的response 回调
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    registerPushResponseCallback : &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(act, callback){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.pushResponseCallback[act] =&lt;span&gt; callback;
    },

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 判断socket已连接成功，可以通信
     * @returns {boolean}
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    isSocketOpened: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;._socket &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;._socket.getState() ==&lt;span&gt; GameWebSocket.GameWebSocketState.OPEN);
    },

    isSocketClosed: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;._socket == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    },

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 启动连接
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    connect: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (url) {
        cc.log(&lt;/span&gt;&quot;webSocketUrls=&quot; +&lt;span&gt; url);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._requestSequenceId = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._socket = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; GameWebSocket.GameWebSocket();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._socket.init(url, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._socket.connect();
    },

    closeConnect: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._socket){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._socket.close();
        }
    },

    onSocketOpen: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        cc.log(&lt;/span&gt;'Socket:onOpen'&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;._delegate &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._delegate.onNetworkOpen){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._delegate.onNetworkOpen();
        }
    },

    onSocketError: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        cc.log(&lt;/span&gt;'Socket:onError'&lt;span&gt;);
    },

    onSocketClosed: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (reason) {
        cc.log(&lt;/span&gt;'Socket:onClose'&lt;span&gt;, reason);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._socket) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._socket.close();
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._socket = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;._delegate &amp;amp;&amp;amp; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._delegate.onNetworkClose){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._delegate.onNetworkClose();
        }
    },

    onSocketMessage: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (msg) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._onResponse(msg);
    },

    _onResponse: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(responseData){
        cc.log(&lt;/span&gt;'response-&amp;gt;resp:'&lt;span&gt;, responseData);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; responseJson =&lt;span&gt; JSON.parse(responseData);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; responseClass =&lt;span&gt; GameProtocols.response_classes[responseJson.act];
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * @type {object.&amp;lt;BaseResponse&amp;gt;}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; response = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; responseClass();
        response.loadData(responseJson.data);
        response.act &lt;/span&gt;=&lt;span&gt; responseJson.act;
        response.seq &lt;/span&gt;=&lt;span&gt; responseJson.seq;
        response.err &lt;/span&gt;=&lt;span&gt; responseJson.err;
        response.ts &lt;/span&gt;=&lt;span&gt; responseJson.ts;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果指定了回调函数，先回调&lt;/span&gt;
        &lt;span&gt;var&lt;/span&gt; ignoreError = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(response.seq != -1&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理服务器推送消息&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; pushCallback = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.pushResponseCallback[response.act];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(pushCallback){
                pushCallback(response);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; request回调&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; callbackObj = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._networkCallbacks[response.seq];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(callbackObj){
                ignoreError &lt;/span&gt;=&lt;span&gt; callbackObj.callback(response);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; try {&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     ignoreError = callbackObj.callback(response);&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; } catch (err) {&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     cc.log(err + &quot; error in response callback of &quot; + response.act);&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; } finally {&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     delete this._networkCallbacks[response.seq];&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; }&lt;/span&gt;
&lt;span&gt;            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有错，且不忽略，则统一处理错误&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(response.err &amp;amp;&amp;amp; response.err != response_state.ERROR_OK &amp;amp;&amp;amp; !&lt;span&gt;ignoreError){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (response.is_async) {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 异步请求，如果出错了，应该需要重新登录&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; todo 重新登录？或者重新同步数据？&lt;/span&gt;
            } &lt;span&gt;else&lt;/span&gt; {  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同步请求，如果出错了，需要显示错误信息&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; todo 显示错误&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; msg =&lt;span&gt; responseJson.msg;
                cc.log(&lt;/span&gt;'server err ' +&lt;span&gt; msg);
            }
        }
    },

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 向服务器发送请求。
     *
     * 如果提供了callback，在收到response后会被回调。如果response是一个错误(status!=ERR_OK)，则需要决定由谁来负责处理错误。
     * 如果callback中已经对错误进行了处理，应该返回true，这样会忽略该错误。否则应该返回false，则负责处理该错误。
     *
     * 特别注意：如果这是一个异步(is_async)请求，且出错，一般来讲应该重新登录/同步。但是如果callback返回了true，不会进行
     * 任何处理，也就是不会重新登录/同步。请小心确定返回值。
     *
     * @param {object.&amp;lt;BaseRequest&amp;gt;}
     * @param {function(BaseResponse): boolean=} opt_callback 回调函数。出错的情况下，如果返回true，则不会再次处理错误。
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    sendRequest: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (request, opt_callback) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每个请求的seq应该唯一，且递增&lt;/span&gt;
        request.seq = ++&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._requestSequenceId;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成NetworkCallback对象，绑定请求seq和回调方法&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(opt_callback){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._networkCallbacks[request.seq] = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NetworkCallback();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._networkCallbacks[request.seq].init(request, opt_callback);
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._sendSocketRequest(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, request);
    },

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * sendRequest的不发送data字段
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    sendRequestNoData: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (request, opt_callback) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每个请求的seq应该唯一，且递增&lt;/span&gt;
        request.seq = ++&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._requestSequenceId;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成NetworkCallback对象，绑定请求seq和回调方法&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(opt_callback){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._networkCallbacks[request.seq] = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NetworkCallback();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._networkCallbacks[request.seq].init(request, opt_callback);
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._sendSocketRequest(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, request);
    },

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * @param {Boolean} isNoData
     * @param {object.&amp;lt;BaseRequest&amp;gt;} req
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    _sendSocketRequest: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (isNoData, req) {
        cc.assert(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._socket);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isSocketOpened()){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过json的方法生成请求字符串&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; msg = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(isNoData){
                msg &lt;/span&gt;=&lt;span&gt; JSON.stringify({seq:req.seq, act:req.act});
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                msg &lt;/span&gt;=&lt;span&gt; JSON.stringify({seq:req.seq, act:req.act, data:req});
            }
            cc.log(&lt;/span&gt;&quot;WebSocketDelegate::send-&amp;gt;&quot; +&lt;span&gt; msg);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._socket.send(msg);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; todo&lt;/span&gt;
&lt;span&gt;        }
    }
});

module.exports &lt;/span&gt;= GameNetwork;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　GameProtocols.js&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;98&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by skyxu on 2018/10/9.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&quot;use strict&quot;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 消息基类对象，请求消息BaseRequest， 回调消息BaseResponse都继承BaseProtocol
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
let BaseProtocol &lt;/span&gt;=&lt;span&gt; cc.Class({
    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 请求动作类型
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.act = ''&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 每个请求的sequence_id应该唯一
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.seq = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 错误代码，0为正常
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.err = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 是否需要等待服务器回调
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.is_async = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
});

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 请求消息基类，客户端的请求都继承这个类
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
let BaseRequest &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseProtocol
});

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 服务器返回的消息对应的对象，包含返回数据，一般和BaseRequest成对使用
 * @class BaseResponse
 * @extends BaseProtocol
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
let BaseResponse &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseProtocol,

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 读取返回数据，设置BaseResponse对象
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    loadData: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; key;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; data) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.hasOwnProperty(key)){
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(data[key] !== undefined &amp;amp;&amp;amp; data[key] !== &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;[key] =&lt;span&gt; data[key];
            }
        }
    }
});

let HeartRequest &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseRequest,
    ctor(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'heart'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.t = -1;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送时间&lt;/span&gt;
&lt;span&gt;    }
});

let HeartResponse &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseResponse,

    ctor(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'heart'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.t = -1&lt;span&gt;;
    }
});

let ChatRequest &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseRequest,
    ctor(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'chat'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.msg = ''&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.uid = ''&lt;span&gt;;
    }
});

let ChatResponse &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseResponse,
    ctor(){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'chat'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.msg = ''&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.uid = ''&lt;span&gt;;
    }
});

let LoginRequest &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseRequest,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'login'&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * facebook用户的accessToken，或游客的UUID
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.token = ''&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * token来源，默认0:游客，1:facebook
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.origin = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 平台: 必须为以下几种之一：android/ios/winphone/pc
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.os = ''&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 平台系统版本
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.osVersion = ''&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 设备产品型号, 示例 iPhone8,2, SM-G 9280
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.deviceModel = ''&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 渠道ID
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.channelId = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * Ios设备广告标示符
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.idfa = ''&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 安卓设备id
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.androidId = ''&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * Google广告平台账号，安装了google play的设备可取到
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.googleAid = ''&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 应用版本号
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.appVersion = ''&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 取package name或者bundle id
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.packName = ''&lt;span&gt;;


        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 设备语言
         * @type {string}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.language = ''&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.locale = &quot;&quot;&lt;span&gt;;

    }
});

let LoginResponse &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseResponse,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'login'&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 游客第一次登录时返回的token，需要客户端保存
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.token = ''&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 离体力下次恢复点的剩余时间秒数
         * @type {number}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.spStepLeftTime = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 体力恢复周期
         * @type {Number}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.spInterval = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 农场每天产出量，产出未解锁时为-1
         * @type {number}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.farmDailyOut = -1&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 农场已产出量
         * @type {number}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.farmCoins = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 农场产出间隔
         * @type {number}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.farmInterval = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 用json object表示的一个player对象，字段说明参见player json对象
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.me =&lt;span&gt; {};

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 建筑数据数组
         * @type {Array}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.buildings =&lt;span&gt; [];

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 农民数据数组
         * @type {Array}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.farms =&lt;span&gt; [];

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 富豪数据
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.cashking =&lt;span&gt; {};

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 行星配置
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.planetConf =&lt;span&gt; {};

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 农民配置
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.farmConfList =&lt;span&gt; [];

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 其他配置
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.settingConf =&lt;span&gt; {};

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 好友数据
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.friends =&lt;span&gt; [];

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 好友通缉的目标列表
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.helpWantList =&lt;span&gt; [];

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 邮件消息列表
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.newsList =&lt;span&gt; [];

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 复仇列表
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.revengeList =&lt;span&gt; [];

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 商品信息
         * @type {Array}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.rechargeConfs =&lt;span&gt; [];

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 总岛数
         * @type {Number}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.planetConfListSize = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 他人行星信息对象,仅在转到fire断线重新登录时有效
         * @type {Object}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.fireTarget = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 他人行星信息对象列表,仅在转到steal断线重新登录时有效
         * @type {Array}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.stealTarget = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
});

let LogoutRequest &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseRequest,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'logout'&lt;span&gt;;
    }
});

let LogoutResponse &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseResponse,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'logout'&lt;span&gt;;
    }
});

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 绑定fb账号
 * @extends BaseRequest
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
let BindFacebookRequest &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseRequest,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'bindFb'&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * facebook用户的accessToken，或游客的UUID
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.token = ''&lt;span&gt;;
    }
});
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 绑定fb账号
 * @extends BaseResponse
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
let BindFacebookResponse &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseResponse,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'bindFb'&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * fb数据
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.me = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * fb好友
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.friends = 0&lt;span&gt;;
    }
});

let SpinRequest &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseRequest,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'spin'&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 倍数
         * @type {Number}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.x = 1&lt;span&gt;;
    }
});

let SpinResponse &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseResponse,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'spin'&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 摇中的转盘ID
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.hit = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 转到护盾，但护盾已满时，存在
         * @type {number}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.shieldfull = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 玩家数据对象
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.me =&lt;span&gt; {};

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 他人行星信息对象,仅在转到fire时有效
         * @type {*}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.fireTarget =&lt;span&gt; {};

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 偷取对象数据
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.stealTarget =&lt;span&gt; [];

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 离体力下次恢复点的剩余时间秒数
         * @type {number}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.spStepLeftTime = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 体力恢复周期
         * @type {Number}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.spInterval = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 倍数
         * @type {Number}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.x = 1&lt;span&gt;;
    }
});

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 获取排名
 * @extends BaseRequest
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
let RankRequest &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseRequest,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'rankboard'&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 请求动作类型{ 0全部，1本地，2好友 }
         * @type {int}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.type = 0&lt;span&gt;;
    }
});
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 获取排名
 * @extends BaseResponse
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
let RankResponse &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseResponse,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'rankboard'&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         *  我的排名
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.myRank = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 排名玩家数据
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.men =&lt;span&gt; [];
    }
});


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;push------------------------------------------------------------------------------&lt;/span&gt;

&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 推送消息 被攻击
 * @extends BaseResponse
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; PushAttackedResponse =&lt;span&gt; cc.Class({
    extends: BaseResponse,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'attacked'&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 玩家更新数据
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.me = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 建筑数据
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.building = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 敌人
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.hatredman = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 消息
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.news = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
});


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 推送消息 推送消息好友已赠送体力
 * @extends BaseResponse
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; PushSendSpResponse =&lt;span&gt; cc.Class({
    extends: BaseResponse,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'sendSpNotify'&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 好友对象
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.friend = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
});

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 推送消息 推送消息好友已领取赠送的体力
 * @extends BaseResponse
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; PushTakeSpResponse =&lt;span&gt; cc.Class({
    extends: BaseResponse,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'takeSpNotify'&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 好友对象
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.friend = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
});

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 推送消息 同步好友信息
 * @extends BaseResponse
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; PushSyncFriendInfo =&lt;span&gt; cc.Class({
    extends: BaseResponse,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'friendInfoSync'&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 好友
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.friend = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
});

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 推送消息 新增好友
 * @extends BaseResponse
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; PushAddNewFriend =&lt;span&gt; cc.Class({
    extends: BaseResponse,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = 'newFriend'&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 好友
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.friend = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 消息
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.news = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
});

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * debug回调
 * @extends BaseRequest
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
let DebugChangeMeRequest &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseRequest,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = &quot;cmdTest&quot;;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求动作类型&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.cmd = &quot;&quot;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  &quot;player coins add 100&quot;, cmd格式：player field value 或者 player field add value&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Building field [add] value where playerId value type value&lt;/span&gt;
&lt;span&gt;    }

});
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * debug回调
 * @extends BaseResponse
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
let DebugChangeMeResponse &lt;/span&gt;=&lt;span&gt; cc.Class({
    extends: BaseResponse,

    ctor: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.act = &quot;cmdTest&quot;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 玩家数据
         * @type {Object}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.me =&lt;span&gt; {};

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 体力恢复周期
         * @type {Number}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.spInterval = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 体力恢复剩余时间
         * @type {Number}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.spStepLeftTime = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 存钱罐速度
         * @type {Number}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.farmDailyOut = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 存钱罐可回收金币
         * @type {Number}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.farmCoins = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 存钱罐回收周期
         * @type {Number}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.farmInterval = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
         * 岛屿建筑数据
         * @type {Array}
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.buildings = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
});

let response_classes &lt;/span&gt;=&lt;span&gt; {
    login: LoginResponse,
    logout: LogoutResponse,
    spin: SpinResponse,
    bindFb: BindFacebookResponse,
    rankboard: RankResponse,
    heart: HeartResponse,
    chat: ChatResponse,

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;push&lt;/span&gt;
&lt;span&gt;    attacked: PushAttackedResponse,
    sendSpNotify: PushSendSpResponse,
    takeSpNotify: PushTakeSpResponse,
    newFriend: PushAddNewFriend,
    friendInfoSync: PushSyncFriendInfo,

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; debug&lt;/span&gt;
&lt;span&gt;    cmdTest: DebugChangeMeResponse,
};

module.exports &lt;/span&gt;=&lt;span&gt; {
    LoginRequest: LoginRequest,
    LoginResponse: LoginResponse,
    LogoutRequest: LogoutRequest,
    LogoutResponse: LogoutResponse,
    SpinRequest: SpinRequest,
    SpinResponse: SpinResponse,
    BindFacebookRequest: BindFacebookRequest,
    BindFacebookResponse: BindFacebookResponse,
    RankRequest: RankRequest,
    RankResponse: RankResponse,
    HeartRequest: HeartRequest,
    HeartResponse: HeartResponse,
    ChatRequest: ChatRequest,
    ChatResponse: ChatResponse,

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; debug&lt;/span&gt;
&lt;span&gt;    DebugChangeMeRequest: DebugChangeMeRequest,
    DebugChangeMeResponse: DebugChangeMeResponse,

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;push消息&lt;/span&gt;
&lt;span&gt;    PushAttackedResponse: PushAttackedResponse,
    PushSendSpResponse: PushSendSpResponse,
    PushTakeSpResponse: PushTakeSpResponse,
    PushAddNewFriend: PushAddNewFriend,
    PushSyncFriendInfo: PushSyncFriendInfo,

    response_classes: response_classes
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　NetProxy.js&lt;/p&gt;
&lt;pre readability=&quot;166&quot;&gt;
/**&lt;br/&gt;* Created by skyxu on 2018/10/9.&lt;br/&gt;*/&lt;p&gt;&quot;use strict&quot;;&lt;/p&gt;&lt;p&gt;let GameNetwork = require(&quot;./GameNetwork&quot;);&lt;br/&gt;let GameProtocols = require(&quot;./GameProtocols&quot;);&lt;/p&gt;&lt;p&gt;let GAME_SERVER_URL = 'ws://127.0.0.1:3000';&lt;br/&gt;// GAME_SERVER_URL = 'wss://echo.websocket.org';&lt;/p&gt;&lt;p&gt;let NetProxy = cc.Class({&lt;br/&gt;ctor: function () {&lt;br/&gt;this.network = null;&lt;br/&gt;this._cachePushCallback = [];&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;init: function () {&lt;br/&gt;this.network = new GameNetwork();&lt;br/&gt;this.network.setDelegate(this);&lt;br/&gt;this.initPushCallback();&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;connect: function () {&lt;br/&gt;this.network.connect(GAME_SERVER_URL);&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;closeConnect: function () {&lt;br/&gt;this.network.closeConnect();&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;isNetworkOpened: function () {&lt;br/&gt;return this.network.isSocketOpened();&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;isNetworkClosed: function () {&lt;br/&gt;return this.network.isSocketClosed();&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;onNetworkOpen: function () {&lt;br/&gt;Global.eventMgr.emit(Global.config.EVENT_NETWORK_OPENED);&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;onNetworkClose: function () {&lt;br/&gt;Global.eventMgr.emit(Global.config.EVENT_NETWORK_CLOSED);&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 注册push回调接口&lt;br/&gt;*/&lt;br/&gt;initPushCallback: function () {&lt;br/&gt;let self = this;&lt;br/&gt;let pushCallback = function (resp) {&lt;br/&gt;self.pushCallback(resp);&lt;br/&gt;};&lt;/p&gt;&lt;p&gt;this.network.registerPushResponseCallback('chat', pushCallback);&lt;/p&gt;&lt;p&gt;// let pushCallback = function(response){&lt;br/&gt;//     if(Util.DNN(farm.game) &amp;amp;&amp;amp; farm.game.loginSuccess){&lt;br/&gt;//         this.dealCachePush();&lt;br/&gt;//         this.pushCallback(response);&lt;br/&gt;//     }else{&lt;br/&gt;//         this._cachePushCallback.push(response);&lt;br/&gt;//     }&lt;br/&gt;// }.bind(this);&lt;/p&gt;&lt;p&gt;// this.network.registerPushResponseCallback('attacked', pushCallback);&lt;br/&gt;// this.network.registerPushResponseCallback('acceptWantHelp', pushCallback);&lt;br/&gt;// this.network.registerPushResponseCallback('sendSpNotify', pushCallback);&lt;br/&gt;// this.network.registerPushResponseCallback('takeSpNotify', pushCallback);&lt;br/&gt;// this.network.registerPushResponseCallback('wanted', pushCallback);&lt;br/&gt;// this.network.registerPushResponseCallback('incomplete', pushCallback);&lt;br/&gt;// this.network.registerPushResponseCallback('newFriend', pushCallback);&lt;br/&gt;// this.network.registerPushResponseCallback('news', pushCallback);&lt;br/&gt;// this.network.registerPushResponseCallback('hatredInfoSync', pushCallback);&lt;br/&gt;// this.network.registerPushResponseCallback('friendInfoSync', pushCallback);&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 处理缓存push&lt;br/&gt;*/&lt;br/&gt;dealCachePush: function () {&lt;br/&gt;// if(this._cachePushCallback.length &amp;gt; 0){&lt;br/&gt;//     for(var i = 0; i &amp;lt; this._cachePushCallback.length; i++){&lt;br/&gt;//         this.pushCallback(this._cachePushCallback[i]);&lt;br/&gt;//     }&lt;br/&gt;// }&lt;br/&gt;// this._cachePushCallback = [];&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;beatHeart: function (callback) {&lt;br/&gt;let req = new GameProtocols.HeartRequest();&lt;br/&gt;req.t = Date.now();&lt;br/&gt;this.network.sendRequest(req, callback);&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;chat: function (msg) {&lt;br/&gt;let req = new GameProtocols.ChatRequest();&lt;br/&gt;let uid = cc.sys.localStorage.getItem(&quot;chat_uid&quot;);&lt;br/&gt;req.uid = uid;&lt;br/&gt;req.msg = msg;&lt;br/&gt;this.network.sendRequest(req);&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* Facebook或者游客登录接口&lt;br/&gt;* @param {Object.&amp;lt;LoginOriginType&amp;gt;} origin&lt;br/&gt;* @param token&lt;br/&gt;*/&lt;br/&gt;login: function (origin, token) {&lt;br/&gt;// let req = new GameProtocols.LoginRequest();&lt;br/&gt;// if(token) req.token = token;&lt;br/&gt;// req.origin = origin;&lt;br/&gt;// req.os = cc.sys.os;&lt;br/&gt;// req.osVersion = cc.sys.osVersion;&lt;br/&gt;// // req.language = cc.sys.language;//farm.FarmPlatformHelper.jsToOc(farm.FarmPlatformHelper.JSB_EVENT_JTO_GetCurrentLanguage);&lt;br/&gt;// /*&lt;br/&gt;//  req.deviceModel = '';&lt;br/&gt;//  req.channelId = 0;&lt;br/&gt;//  req.idfa = '';&lt;br/&gt;//  req.androidId = '';&lt;br/&gt;//  req.googleAid = '';&lt;br/&gt;//  req.appVersion = '';&lt;br/&gt;//  req.packName = '';&lt;br/&gt;//  */&lt;br/&gt;// let callback =  function (resp) {&lt;br/&gt;//     if(resp.err != 0){&lt;br/&gt;//         Global.eventMgr.emit(farm.game.gmConst.SP_EVENT_LOGIN_FAILED, resp);&lt;br/&gt;//         return;&lt;br/&gt;//     }&lt;br/&gt;//     if(resp.token &amp;amp;&amp;amp; resp.token.length &amp;gt; 0){&lt;br/&gt;//         farm.localStorage.setItem(farm.game.gmConst.GLS_KEY_GUEST_TOKEN, resp.token);&lt;br/&gt;//     }&lt;br/&gt;//     farm.localStorage.removeItem(farm.game.gmConst.GLS_KEY_IS_LOGOUT);&lt;br/&gt;//&lt;br/&gt;//     //&lt;br/&gt;//     farm.game.initConfig(resp);&lt;br/&gt;//     farm.game.initData(resp);&lt;br/&gt;//     farm.game.loginSuccess = true;&lt;br/&gt;//&lt;br/&gt;//     // js 调取其他平台的sdk，传过去玩家id&lt;br/&gt;//     farm.FarmPlatformHelper.jsToOc(farm.FarmPlatformHelper.JSB_EVENT_JTO_setSessionWithUid, farm.game.player.id.toString());&lt;br/&gt;//     //&lt;br/&gt;//&lt;br/&gt;//     //登录&lt;br/&gt;//     farm.eventManager.emit(farm.game.gmConst.SP_EVENT_LOGIN_SUCCESS);&lt;br/&gt;// };&lt;br/&gt;// this.network.sendRequest(req, callback);&lt;/p&gt;&lt;p&gt;},&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* Facebook或者游客登出&lt;br/&gt;*/&lt;br/&gt;logout: function () {&lt;br/&gt;// let req = new GameProtocols.LogoutRequest();&lt;br/&gt;// this.network.sendRequest(req, function (resp) {&lt;br/&gt;//     if(resp.err != 0){&lt;br/&gt;//         cc.log(&quot;网络请求---LogoutRequest 失败&quot;);&lt;br/&gt;//         farm.eventManager.emit(farm.game.gmConst.SP_EVENT_LOGOUT_FAILED);&lt;br/&gt;//         return;&lt;br/&gt;//     }&lt;br/&gt;//     cc.log(&quot;网络请求---LogoutRequest 成功&quot;);&lt;br/&gt;//     Global.eventMgr.emit(farm.game.gmConst.SP_EVENT_LOGOUT_SUCCESS);&lt;br/&gt;// });&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 绑定fb账号&lt;br/&gt;* @param {String} token&lt;br/&gt;*/&lt;br/&gt;bindFacebook: function (token) {&lt;br/&gt;// let req = new GameProtocols.BindFacebookRequest();&lt;br/&gt;// req.token = token;&lt;br/&gt;// let callback =  function (resp) {&lt;br/&gt;//     //绑定过得逻辑&lt;br/&gt;//     if(resp.err == farm.game.gmConst.ERROR_USER_HAS_REGISTERED){&lt;br/&gt;//         cc.log(&quot;网络请求---BindFacebookRequest 已绑定&quot;);&lt;br/&gt;//         farm.eventManager.emit(farm.game.gmConst.SP_EVENT_HAS_BIND_FACEBOOK);&lt;br/&gt;//         return;&lt;br/&gt;//     }&lt;br/&gt;//     //绑定失败&lt;br/&gt;//     if(resp.err != 0){&lt;br/&gt;//         cc.log(&quot;网络请求---BindFacebookRequest 失败&quot;);&lt;br/&gt;//         farm.eventManager.emit(farm.game.gmConst.SP_EVENT_BIND_FACEBOOK_FAILED);&lt;br/&gt;//         return;&lt;br/&gt;//     }&lt;br/&gt;//     //绑定成功&lt;br/&gt;//     cc.log(&quot;网络请求---BindFacebookRequest 成功&quot;);&lt;br/&gt;//     if(resp.me){&lt;br/&gt;//         farm.game.player.parse(resp.me);&lt;br/&gt;//     }&lt;br/&gt;//     if(resp.friends){&lt;br/&gt;//         farm.game.initFriends(resp.friends);&lt;br/&gt;//     }&lt;br/&gt;//     //绑定成功后删除本地token&lt;br/&gt;//     farm.localStorage.removeItem(farm.game.gmConst.GLS_KEY_GUEST_TOKEN);&lt;br/&gt;//     farm.eventManager.emit(farm.game.gmConst.SP_EVENT_BIND_FACEBOOK_SUCCESS);&lt;br/&gt;// };&lt;br/&gt;// this.network.sendRequest(req, callback);&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 启动转盘&lt;br/&gt;*/&lt;br/&gt;spin: function (x) {&lt;br/&gt;// let req = new GameProtocols.SpinRequest();&lt;br/&gt;// if(farm.util.isNumber(x)){&lt;br/&gt;//     req.x = x;&lt;br/&gt;// }&lt;br/&gt;// var callback =  function (resp) {&lt;br/&gt;//     if(resp.err != 0){&lt;br/&gt;//         cc.log(&quot;网络请求---spin 失败&quot;);&lt;br/&gt;//         farm.eventManager.emit(farm.game.gmConst.SP_EVENT_SPIN_FAILED, resp);&lt;br/&gt;//         return;&lt;br/&gt;//     }&lt;br/&gt;//     cc.log(&quot;网络请求---spin 成功&quot;);&lt;br/&gt;//     farm.game.player.parse(resp.me);&lt;br/&gt;//     farm.game.spTimer.updateSpTime(resp.spStepLeftTime, resp.spInterval);&lt;br/&gt;//     farm.eventManager.emit(farm.game.gmConst.SP_EVENT_SPIN_SUCCESS, resp);&lt;br/&gt;// };&lt;br/&gt;// this.network.sendRequest(req, callback);&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 获取排名&lt;br/&gt;* @param {Number} rankType 0全部，1本地，2好友&lt;br/&gt;*/&lt;br/&gt;getRank: function (rankType) {&lt;br/&gt;// let req = new GameProtocols.RankRequest();&lt;br/&gt;// req.type = rankType;&lt;br/&gt;// let callback =  function (resp) {&lt;br/&gt;//     if(resp.err != 0){&lt;br/&gt;//         cc.log(&quot;网络请求---getRank 失败&quot;);&lt;br/&gt;//         Global.eventMgr.emit(farm.game.gmConst.SP_EVENT_GET_RANK_FAILED, resp);&lt;br/&gt;//         return;&lt;br/&gt;//     }&lt;br/&gt;//     cc.log(&quot;网络请求---getRank 成功&quot;);&lt;br/&gt;//     // todo 暂定排名类型&lt;br/&gt;//     resp._rankType = rankType;&lt;br/&gt;//     //farm.game.initLeaderBoardArray(rankType, resp.myRank, resp.men);&lt;br/&gt;//     if(rankType == 2 &amp;amp;&amp;amp; resp.men){&lt;br/&gt;//         farm.game.updateFriends(resp.men);&lt;br/&gt;//         resp.men = farm.game.sortFriendsByStar();&lt;br/&gt;//     }&lt;br/&gt;//     Global.eventMgr.emit(farm.game.gmConst.SP_EVENT_GET_RANK_SUCCESS, resp);&lt;br/&gt;// };&lt;br/&gt;// this.network.sendRequest(req, callback);&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;//push回调------------------------------------------------------------------------------&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 推送回调&lt;br/&gt;*/&lt;br/&gt;pushCallback: function (response) {&lt;br/&gt;switch (response.act){&lt;br/&gt;case &quot;sendSpNotify&quot;:&lt;br/&gt;case &quot;takeSpNotify&quot;:&lt;br/&gt;case &quot;friendInfoSync&quot;:&lt;br/&gt;this.pushFriendSendTakeSp(response);&lt;br/&gt;break;&lt;br/&gt;case &quot;stole&quot;:&lt;br/&gt;this.pushStole(response);&lt;br/&gt;break;&lt;br/&gt;case &quot;attacked&quot;:&lt;br/&gt;this.pushAttacked(response);&lt;br/&gt;break;&lt;br/&gt;case &quot;newFriend&quot;:&lt;br/&gt;this.pushAddNewFriend(response);&lt;br/&gt;break;&lt;br/&gt;case &quot;chat&quot;:&lt;br/&gt;this.pushChat(response);&lt;br/&gt;break;&lt;br/&gt;}&lt;br/&gt;},&lt;br/&gt;/**&lt;br/&gt;* 好友间互赠体力推送&lt;br/&gt;* @param {PushSendSpResponse|PushTakeSpResponse} resp&lt;br/&gt;*/&lt;br/&gt;pushFriendSendTakeSp: function (resp) {&lt;br/&gt;// cc.log(&quot;网络请求---push--- pushFriendSendTakeSp 成功&quot;);&lt;br/&gt;// if(resp.friend) farm.game.updateFriends(resp.friend);&lt;br/&gt;// farm.eventManager.emit(farm.game.gmConst.SP_PUSH_EVENT_UPDATE_FRIEND);&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 被偷&lt;br/&gt;* @param {PushStolenResponse} resp&lt;br/&gt;*/&lt;br/&gt;pushStole: function (resp) {&lt;br/&gt;// cc.log(&quot;网络请求---push--- pushStole 成功&quot;);&lt;br/&gt;// if(resp.me) farm.game.player.parse(resp.me);&lt;br/&gt;// //if(resp.building) farm.game.buildings[resp.building.type].parse(resp.building);&lt;br/&gt;// if(resp.hatredman &amp;amp;&amp;amp; !farm.game.getHelpWant(resp.hatredman.id)){&lt;br/&gt;//     farm.game.addEnemy(resp.hatredman);&lt;br/&gt;// }&lt;br/&gt;// if(resp.news){&lt;br/&gt;//     resp.news = farm.game.addNews(resp.news);&lt;br/&gt;// }&lt;br/&gt;// farm.eventManager.emit(farm.game.gmConst.SP_PUSH_EVENT_BE_STOLE_SUCCESS, resp);&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 被攻击&lt;br/&gt;* @param {PushAttackedResponse} resp&lt;br/&gt;*/&lt;br/&gt;pushAttacked: function (resp) {&lt;br/&gt;// cc.log(&quot;网络请求---push--- pushAttacked 成功&quot;);&lt;br/&gt;// if(resp.me) {&lt;br/&gt;//     farm.game.player.parse(resp.me);&lt;br/&gt;//     farm.game.dataUpdater.updateStar();&lt;br/&gt;// }&lt;br/&gt;// if(resp.building) farm.game.buildings[resp.building.type].parse(resp.building);&lt;br/&gt;// if(resp.hatredman){&lt;br/&gt;//     farm.game.addBadass(resp.hatredman);&lt;br/&gt;//     if(!farm.game.getHelpWant(resp.hatredman.id)){&lt;br/&gt;//         farm.game.addEnemy(resp.hatredman);&lt;br/&gt;//     }&lt;br/&gt;// }&lt;br/&gt;// if(resp.news){&lt;br/&gt;//     resp.news = farm.game.addNews(resp.news);&lt;br/&gt;// }&lt;br/&gt;// farm.eventManager.emit(farm.game.gmConst.SP_PUSH_EVENT_BE_ATTACK_SUCCESS, resp);&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* 新增好友&lt;br/&gt;* @param {PushAddNewFriend} resp&lt;br/&gt;*/&lt;br/&gt;pushAddNewFriend: function (resp) {&lt;br/&gt;// cc.log(&quot;网络请求---push--- pushAddNewFriend 成功&quot;);&lt;br/&gt;// if(resp.friend){&lt;br/&gt;//     resp.friend = farm.game.addFriend(resp.friend);&lt;br/&gt;// }&lt;br/&gt;// if(resp.news){&lt;br/&gt;//     resp.news = farm.game.addNews(resp.news);&lt;br/&gt;// }&lt;br/&gt;// farm.eventManager.emit(farm.game.gmConst.SP_PUSH_EVENT_ADD_FRIEND_SUCCESS, resp);&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;pushChat: function (resp) {&lt;br/&gt;Global.eventMgr.emit(Global.config.EVENT_CHAT, resp);&lt;br/&gt;},&lt;/p&gt;&lt;p&gt;/**&lt;br/&gt;* debug调试请求&lt;br/&gt;* @param {String} name&lt;br/&gt;*/&lt;br/&gt;debug_addCoins: function (name) {&lt;br/&gt;var req = new GameProtocols.DebugChangeMeRequest();&lt;br/&gt;if (name === &quot;btnAddCoins&quot;) {&lt;br/&gt;req.cmd = &quot;player coins add 100000000&quot;;&lt;br/&gt;} else if (name === &quot;btnClearCoins&quot;) {&lt;br/&gt;req.cmd = &quot;player coins 0&quot;;&lt;br/&gt;} else if (name === &quot;btnAddEnergy&quot;) {&lt;br/&gt;req.cmd = &quot;player sp add 10&quot;;&lt;br/&gt;} else if (name === &quot;btnClearEnergy&quot;) {&lt;br/&gt;req.cmd = &quot;player sp 0&quot;;&lt;br/&gt;} else if (name == &quot;btnAddWp&quot;) {&lt;br/&gt;req.cmd = &quot;player wp add 10&quot;;&lt;br/&gt;} else if (name == &quot;btnClearWp&quot;) {&lt;br/&gt;req.cmd = &quot;player wp 0&quot;;&lt;br/&gt;} else if (name == &quot;btnUnwrap&quot;){&lt;br/&gt;req.cmd = &quot;player fbuid null&quot;;&lt;br/&gt;} else if (name == &quot;btnWizard1&quot;){&lt;br/&gt;req.cmd = &quot;player wizard1 0&quot;;&lt;br/&gt;} else if (name == &quot;btnWizard2&quot;){&lt;br/&gt;req.cmd = &quot;player wizard2 0&quot;;&lt;br/&gt;} else if (name == &quot;btnClearShield&quot;){&lt;br/&gt;req.cmd = &quot;player shield 0&quot;;&lt;br/&gt;} else if (name == &quot;btnSpEc&quot;){&lt;br/&gt;req.cmd = &quot;SpEc stepInterval 60000&quot;;&lt;br/&gt;} else if (name == &quot;btnFarmEc&quot;){&lt;br/&gt;req.cmd = &quot;FarmEc stepInterval 60000&quot;;&lt;br/&gt;} else if (name == &quot;btnSpEcBack&quot;){&lt;br/&gt;req.cmd = &quot;SpEc stepInterval 3600000&quot;;&lt;br/&gt;} else if (name == &quot;btnFarmBack&quot;){&lt;br/&gt;req.cmd = &quot;FarmEc stepInterval 86400000&quot;;&lt;br/&gt;} else if (name == &quot;btnUpdateBuild&quot;){&lt;br/&gt;req.cmd = &quot;Building lv 5&quot;;&lt;br/&gt;} else {&lt;br/&gt;req.cmd = name;&lt;br/&gt;}&lt;br/&gt;// var callback = function (resp) {&lt;br/&gt;//     if (resp.err != 0) {&lt;br/&gt;//         return;&lt;br/&gt;//     }&lt;br/&gt;//     farm.game.player.parse(resp.me);&lt;br/&gt;//     farm.game.spTimer.updateSpTime(resp.spStepLeftTime, resp.spInterval);&lt;br/&gt;//     farm.game.dataUpdater.updateCoin();&lt;br/&gt;//     farm.game.dataUpdater.updateSp();&lt;br/&gt;//     farm.game.dataUpdater.updateShield();&lt;br/&gt;//     farm.game.dataUpdater.updateStar();&lt;br/&gt;//     //&lt;br/&gt;//     if((req.cmd == &quot;FarmEc stepInterval 60000&quot; || req.cmd == &quot;FarmEc stepInterval 86400000&quot;)&lt;br/&gt;//         &amp;amp;&amp;amp; farm.util.isNumber(resp.farmDailyOut)&lt;br/&gt;//         &amp;amp;&amp;amp; farm.util.isNumber(resp.farmCoins)){&lt;br/&gt;//         farm.game.piggyBankTimer.init(resp.farmDailyOut, resp.farmCoins, resp.farmInterval);&lt;br/&gt;//     }&lt;br/&gt;//     if(req.cmd == &quot;SpEc stepInterval 60000&quot; || req.cmd == &quot;SpEc stepInterval 3600000&quot;){&lt;br/&gt;//         farm.game.spTimer.updateSpTime(resp.spStepLeftTime, resp.spInterval);&lt;br/&gt;//     }&lt;br/&gt;//     if(resp.buildings){&lt;br/&gt;//         for(var i = 0; i &amp;lt; resp.buildings.length; ++i){&lt;br/&gt;//             farm.game.buildings[i].parse(resp.buildings[i]);&lt;br/&gt;//         }&lt;br/&gt;//         farm.eventManager.emit(farm.game.gmConst.SP_EVENT_UPGRADE_BUILDING_SUCCESS, resp);&lt;br/&gt;//         farm.eventManager.emit(farm.game.gmConst.SP_DEBUG_EVENT_BUILD_TO_24_SUCCESS, resp);&lt;br/&gt;//     }&lt;br/&gt;// };&lt;br/&gt;// this.network.sendRequest(req, callback);&lt;br/&gt;},&lt;br/&gt;});&lt;/p&gt;&lt;p&gt;module.exports = NetProxy;
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、服务端&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　使用express + express-ws组件，调用WSRouter的init初始化连接即可，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
let expressWS = require('express-ws'&lt;span&gt;);
let work &lt;/span&gt;= require('./work'&lt;span&gt;);

let wsRouter &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; WSRouter(app, server){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.app =&lt;span&gt; app;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.server =&lt;span&gt; server;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.clients =&lt;span&gt; [];
    expressWS(app, server);

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listenClientConnection = ()=&amp;gt;&lt;span&gt;{
        app.ws(&lt;/span&gt;'/', (socket, req)=&amp;gt;&lt;span&gt;{
            console.log(&lt;/span&gt;'client connect to server successful.'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clients.push(socket);
            console.log(&lt;/span&gt;'clients: ' + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clients.length);
            socket.on(&lt;/span&gt;'message', (msg)=&amp;gt;&lt;span&gt;{
                console.log(&lt;/span&gt;'on message: ' +&lt;span&gt; msg);
                work(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, socket, msg);
            });

            socket.on(&lt;/span&gt;'close', (msg)=&amp;gt;&lt;span&gt;{
                console.log(&lt;/span&gt;'on close: ' +&lt;span&gt; msg);
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let index=0; index&amp;lt;&lt;span&gt;this&lt;/span&gt;.clients.length; index++&lt;span&gt;){
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.clients[index] ==&lt;span&gt; socket){
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.clients.splice(index,1&lt;span&gt;);
                    }
                }
                console.log(&lt;/span&gt;'clients: ' + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.clients.length);
            });

            socket.on(&lt;/span&gt;'error', (err)=&amp;gt;&lt;span&gt;{
                console.log(&lt;/span&gt;'on error: ' +&lt;span&gt; error);
            });
        })
    }
}


module.exports &lt;/span&gt;=&lt;span&gt; {
    init: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(app, server){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (wsRouter == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            wsRouter &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WSRouter(app, server);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wsRouter;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
module.exports = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(wsRouter, ws, msg){
    let msgObj &lt;/span&gt;=&lt;span&gt; JSON.parse(msg);
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (msgObj.act){
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'heart'&lt;span&gt;:{
            msgObj.data.t &lt;/span&gt;=&lt;span&gt; Date.now();
            ws.send(JSON.stringify(msgObj));
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'chat'&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let w of wsRouter.clients){
                w.send(msg);
            }
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 18 Oct 2018 07:25:00 +0000</pubDate>
<dc:creator>随风的博客</dc:creator>
<og:description>先上个效果图： 使用cocoscreator 1.9.1 + node.js + websocket实现，没有使用socket.io, 全部自己封装，长连接进行封装后可以和短连接使用方法一样，使用简单</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyxu123/p/9810741.html</dc:identifier>
</item>
<item>
<title>适配器模式 - mingmingcome</title>
<link>http://www.cnblogs.com/mingmingcome/p/9810731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mingmingcome/p/9810731.html</guid>
<description>&lt;p&gt;&lt;code&gt;2018年10月17日08:50:11&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;适配器模式adapter-pattern&quot;&gt;适配器模式（adapter pattern）&lt;/h2&gt;
&lt;h4 id=&quot;定义&quot;&gt;定义&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我喜欢的样子你都有&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;你喜欢的样子我有没有&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;没有的话，我送你个适配器，好吗&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能在一起工作的那些类可以一起工作。——《设计模式：可复用面向对象软件的基础》&lt;/p&gt;
&lt;p&gt;适配器模式是一种对象结构型模式。&lt;/p&gt;
&lt;h4 id=&quot;使用场景&quot;&gt;使用场景&lt;/h4&gt;
&lt;p&gt;客户端需要一个target（目标）接口，但是不能直接重用已经存在的adaptee（适配者）类，因为它的接口和target接口不一致，所以需要adapter（适配器）将adaptee转换为target接口。前提是target接口和已存在的适配者adaptee类所做的事情是相同或相似，只是接口不同且都不易修改。如果在设计之初，最好不要考虑这种设计模式。凡事都有例外，就是设计新系统的时候考虑使用第三方组件，因为我们就没必要为了迎合它修改自己的设计风格，可以尝试使用适配器模式。&lt;/p&gt;
&lt;h4 id=&quot;角色&quot;&gt;角色&lt;/h4&gt;
&lt;p&gt;目标角色（target）：这是客户锁期待的接口。目标可以是具体的或抽象的类，也可以是接口&lt;/p&gt;
&lt;p&gt;适配者角色（adaptee）：已有接口，但是和客户器期待的接口不兼容。&lt;/p&gt;
&lt;p&gt;适配器角色（adapter）：将已有接口转换成目标接口。&lt;/p&gt;
&lt;h4 id=&quot;分类&quot;&gt;分类&lt;/h4&gt;
&lt;p&gt;适配器模式有分三类：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1、类适配器模式（class adapter pattern）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;2、对象适配器模式（object adapter pattern）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;3、缺省适配器模式（default adapter pattern），也叫默认适配器模式、接口适配器模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;类适配器模式class-adapter-pattern&quot;&gt;类适配器模式（class adapter pattern）&lt;/h3&gt;
&lt;p&gt;类适配器模式在编译时实现target（目标）接口。这种适配器模式使用了多个实现了期待的接口或者已经存在的接口的多态接口。比较典型的就是：target接口被创建为一个纯粹的接口，如Java不支持多继承的语言。&lt;/p&gt;
&lt;h4 id=&quot;图示&quot;&gt;图示&lt;/h4&gt;
&lt;p&gt;类适配器模式（adapter pattern）结构图：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/adapter-class-adapter.jpg&quot; alt=&quot;类适配器模式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，因为java没有类多继承，所以只能实现Target接口，而且Target只能是接口。Adapter实现了Target接口，继承了Adaptee类，Target.operation()实现为Adaptee.specificOperation()。&lt;/p&gt;
&lt;p&gt;客户端调用类适配器：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/adapter-class-adapter.png&quot; alt=&quot;客户端调用类适配器&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个图是Adapter适配器多继承的情况，引用维基百科，可以看到客户端调用适配器Adapter的methodA时候，实际上调用的是Adapter继承过来的method1到methodN。&lt;/p&gt;
&lt;h4 id=&quot;代码示例&quot;&gt;代码示例&lt;/h4&gt;
&lt;p&gt;一张图说明需求：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/adapter-power-adapter.jpg&quot; alt=&quot;电源适配器&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嗯，就是电源适配器了。上面有这样两行：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;输入：100-240V ~ 0.5A 50-60HZ&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;输出：5.2V ==== 2.4A&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们的需求就是将电源输入220V（适配者）转换为5V输出（目标）。&lt;/p&gt;
&lt;p&gt;目标角色（PowerTarget.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface PowerTarget {
    public int output5V();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;电源目标。&lt;/p&gt;
&lt;p&gt;适配者角色（PowerAdaptee.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class PowerAdaptee {
    private int output =  220;
    public int output220V() {
        System.out.println(&quot;电源输出电压：&quot; + output);
        return output;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;电源适配者。&lt;/p&gt;
&lt;p&gt;适配器角色（PowerAdapter.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class PowerAdapter extends PowerAdaptee implements PowerTarget{
    
    @Override
    public int output5V() {
        int output = output220V();
        System.out.println(&quot;电源适配器开始工作，此时输出电压是：&quot; + output);
        output = output/44;
        System.out.println(&quot;电源适配器工作完成，此时输出电压是：&quot; + output);
        return output;
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;电源适配器类实现了电源目标，继承了适配者。其实如果没有我打印的那些提示或者说日志，output5V方法可以直接写成：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public int output5V() {
        return output220V()/44;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就适配了。&lt;/p&gt;
&lt;p&gt;类适配器模式测试类（ClassAdapterPatternTest.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ClassAdapterPatternTest {
    
    public static void main(String[] args) {
        PowerTarget target = new PowerAdapter();
        target.output5V();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/adapter-instance-result.jpg&quot; alt=&quot;适配器模式示例测试结果&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;对象适配器模式object-adapter-pattern&quot;&gt;对象适配器模式（object adapter pattern）&lt;/h3&gt;
&lt;p&gt;对象适配器模式在运行时实现target（目标）接口。在这种适配器模式中，适配器包装了一个类实例。在这种情况下，适配器调用包装对象实例的方法。&lt;/p&gt;
&lt;h4 id=&quot;图示-1&quot;&gt;图示&lt;/h4&gt;
&lt;p&gt;对象适配器模式（object adapter pattern）结构图：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/adapter-object-adapter.jpg&quot; alt=&quot;对象适配器模式结构图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，与类适配器模式不同的是，Adapter只实现了Target的接口，没有继承Adaptee，而是使用组合的方式引用adaptee。&lt;/p&gt;
&lt;p&gt;客户端调用对象适配器：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/adapter-object-adapter.png&quot; alt=&quot;客户端调用对象适配器&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户端调用对象适配器方法methodA的时候，实际上调用的是创建对象传进来的适配者实例的方法methodB。&lt;/p&gt;
&lt;h4 id=&quot;代码示例-1&quot;&gt;代码示例&lt;/h4&gt;
&lt;p&gt;代码示例和类适配器模式只有Adapter类有不同，其他完成一样，连测试结果都是一样。下面只贴上Adapter类。&lt;/p&gt;
&lt;p&gt;适配器角色（Adapter.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class PowerAdapter implements PowerTarget{
    private PowerAdaptee powerAdaptee;

    public PowerAdapter(PowerAdaptee powerAdaptee) {
        super();
        this.powerAdaptee = powerAdaptee;
    }

    @Override
    public int output5V() {
        int output = powerAdaptee.output220V();
        System.out.println(&quot;电源适配器开始工作，此时输出电压是：&quot; + output);
        output = output/44;
        System.out.println(&quot;电源适配器工作完成，此时输出电压是：&quot; + output);
        return output;
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现了PowerTarget（目标角色），在创建对象时引入PowerAdaptee（适配者角色）。&lt;/p&gt;
&lt;h4 id=&quot;类适配器模式和对象适配器模式的对比&quot;&gt;类适配器模式和对象适配器模式的对比&lt;/h4&gt;
&lt;h5 id=&quot;优点&quot;&gt;优点&lt;/h5&gt;
&lt;p&gt;类适配器模式（class adapter pattern）：&lt;/p&gt;
&lt;p&gt;由于适配器adapter类是适配者adaptee类的子类，因此可以在适配器类中置换一些适配者的方法，即Override（重写），使得适配器的灵活性更强。&lt;/p&gt;
&lt;p&gt;对象适配器模式（object adapter pattern）：&lt;/p&gt;
&lt;p&gt;一个对象适配器可以把多个不同的适配者adaptee适配到一个目标，也就是说，同一个适配器可以将适配者类和它的子类都适配到目标接口。&lt;/p&gt;
&lt;h5 id=&quot;缺点&quot;&gt;缺点&lt;/h5&gt;
&lt;p&gt;类适配器模式：&lt;/p&gt;
&lt;p&gt;java8之前：接口没有default方法，就是没有实现了具体逻辑的方法，而且不支持类多继承，所以&lt;strong&gt;适配者类只能有一个&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;java8之后：接口有了default方法，接口中的方法有了实现，因为接口是多继承的，所以适配者可以是多个带有default方法的接口，但是接口是不可以实例化的，实际上没有什么意义。有个解决方法就是，接口里都是default方法，实现接口的类什么也没做，就是提供一个可以实例化的类。这样的化，类适配器模式中适配者adapter类就可以适配多个适配者adaptee类了。这个解决方法只是我理论上论证一下，实际上可行与否，请自行判断验证。&lt;/p&gt;
&lt;p&gt;对象适配器模式：&lt;/p&gt;
&lt;p&gt;类适配器模式的优点就是对象适配器模式的缺点，不能置换适配者类的方法。如果想修改适配者类的一个或多个方法，就只好先创建一个继承与适配者类的子类，把适配者类的方法置换掉，然后把适配者的子类当做真正的适配者进行适配，实现过程较为复杂。&lt;/p&gt;
&lt;h3 id=&quot;缺省适配器模式default-adapter-pattern&quot;&gt;缺省适配器模式（default adapter pattern）&lt;/h3&gt;
&lt;p&gt;当不需要全部实现接口提供的方法时，可以设计一个适配器抽象类实现接口，并为接口中的每个方法提供默认方法，抽象类的子类就可以有选择的覆盖父类的某些方法实现需求，它适用于一个接口不想使用所有的方法的情况。在java8后，接口中可以有default方法，就不需要这种缺省适配器模式了。接口中方法都设置为default，实现为空，这样同样同样可以达到缺省适配器模式同样的效果。&lt;/p&gt;
&lt;h4 id=&quot;图示-2&quot;&gt;图示&lt;/h4&gt;
&lt;p&gt;缺省适配器模式结构图：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/adapter-default-adapter.jpg&quot; alt=&quot;缺省适配器模式结构图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;适配器Adapter类实现Target接口，方法默认为空。&lt;/p&gt;
&lt;h4 id=&quot;代码示例-2&quot;&gt;代码示例&lt;/h4&gt;
&lt;p&gt;目标角色（SampleOperation.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface SampleOperation {
    public abstract void operation1();
    public abstract void operation2();
    public abstract void operation3();
    public abstract void operation4();
    public abstract void operation5();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;包含了很多操作。&lt;/p&gt;
&lt;p&gt;适配器角色（DefaultAdapter.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class DefaultAdapter implements SampleOperation{

    @Override
    public void operation1() {
    }

    @Override
    public void operation2() {
    }

    @Override
    public void operation3() {
    }

    @Override
    public void operation4() {
    }

    @Override
    public void operation5() {
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认实现了所有操作&lt;/p&gt;
&lt;p&gt;这个是测试缺省适配器模式需要用到的类（Operator.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Operator {
    private SampleOperation sampleOperation;
    
    public void addOperation(SampleOperation sampleOperation) {
        this.sampleOperation = sampleOperation;
    }

    public void operation1() {
        sampleOperation.operation1();
    }

    public void operation2() {
        sampleOperation.operation2();
    }

    public void operation3() {
        sampleOperation.operation3();
    }

    public void operation4() {
        sampleOperation.operation4();
    }

    public void operation5() {
        sampleOperation.operation5();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;缺省适配器模式测试类（DefaultAdapterTest.java）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DefaultAdapterTest {

    public static void main(String[] args) {
        
        // 1、原来要实现所有操作类的操作
        Operator operator1 = new Operator();
        operator1.addOperation(new SampleOperation() {

            @Override
            public void operation1() {}

            @Override
            public void operation2() {
                System.out.println(&quot;操作2&quot;);
            }

            @Override
            public void operation3() {}

            @Override
            public void operation4() {}

            @Override
            public void operation5() {}
            
        });
        operator1.operation2();
        
        // 2、使用缺省适配器只需要实现需要用到的接口方法
        Operator operator2 = new Operator();
        operator2.addOperation(new DefaultAdapter() {
            
            @Override
            public void operation2() {
                System.out.println(&quot;操作2&quot;);
            }
        });
        operator2.operation2();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试类需要执行操作2，operator1添加SampleOperation时要实现接口里所有方法，operator2添加SampleOperation时只需要通过DefaultAdapter适配器添加自己需要的操作即可。毫无疑问，测试结果是一样的。&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Mingmingcome/cnblogs/master/images/adapter-default-adapter-result.jpg&quot; alt=&quot;缺省适配器模式测试结果&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;优点-1&quot;&gt;优点&lt;/h4&gt;
&lt;p&gt;1、复用性：系统需要使用已经存在的类，功能符合系统要求，但这个类的接口不符合系统的需求，通过适配器模式解决不兼容的问题，使这些功能类得到复用。&lt;/p&gt;
&lt;p&gt;2、扩展性：适配器使得系统多了一个方式扩展系统的功能&lt;/p&gt;
&lt;p&gt;3、耦合性：一定程度上的解耦&lt;/p&gt;
&lt;h4 id=&quot;缺点-1&quot;&gt;缺点&lt;/h4&gt;
&lt;p&gt;过多地使用适配器，增加系统理解难度。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;本文主要介绍了三种适配器模式，本质上是现有的不兼容的接口转换为需要的接口。&lt;/p&gt;
&lt;p&gt;类适配器模式，以继承现有类的方式转换。&lt;/p&gt;
&lt;p&gt;对象适配器模式，以组合对象实例的方式转换。&lt;/p&gt;
&lt;p&gt;接口适配器模式，以实现接口的方式转换。&lt;/p&gt;
&lt;p&gt;适配器模式是在现有的类和系统都不易修改的情况下使用，在系统设计之初慎用适配器模式。&lt;/p&gt;
&lt;h4 id=&quot;完&quot;&gt;完&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;2018年10月18日14:53:33&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Oct 2018 07:24:00 +0000</pubDate>
<dc:creator>mingmingcome</dc:creator>
<og:description>`2018年10月17日08:50:11` 适配器模式（adapter pattern） 定义 我喜欢的样子你都有 你喜欢的样子我有没有 没有的话，我送你个适配器，好吗 将一个类的接口转换成客户希望的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mingmingcome/p/9810731.html</dc:identifier>
</item>
<item>
<title>Android 的 so 文件加载机制 - 请叫我大苏</title>
<link>http://www.cnblogs.com/dasusu/p/9810673.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dasusu/p/9810673.html</guid>
<description>&lt;p&gt;最近碰到一些 so 文件问题，顺便将相关知识点梳理一下。&lt;/p&gt;

&lt;p&gt;本文的结论是跟着 &lt;code&gt;System.loadlibrary()&lt;/code&gt; 一层层源码走进去，个人对其的理解所整理的，那么开始看源码之前，先来提几个问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q1：你知道 so 文件的加载流程吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q2：设备存放 so 的路径有 system/lib，vendor/lib，system/lib64，vendor/lib64，知道在哪里规定了这些路径吗？清楚哪些场景下系统会去哪个目录下寻找 so 文件吗？还是说，所有的目录都会去寻找？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q3：Zygote 进程是分 32 位和 64 位的，那么，系统是如何决定某个应用应该运行在 32 位上，还是 64 位上？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Q4：如果程序跑在 64 位的 Zygote 进程上时，可以使用 32 位的 so 文件么，即应用的 primaryCpuAbi 为 arm64-v8a，那么是否可使用 armeabi-v7a 的 so 文件，兼容的吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Q2，Q3，Q4，这几个问题都是基于设备支持 64 位的前提下，在旧系统版本中，只支持 32 位，也就没这么多疑问需要处理了。&lt;/p&gt;

&lt;h3 id=&quot;准备工作&quot;&gt;准备工作&lt;/h3&gt;
&lt;p&gt;由于这次的源码会涉及很多 framework 层的代码，包括 java 和 c++，直接在 AndroidStudio 跟进 SDK 的源码已不足够查看到相关的代码了。所以，此次是借助 Source Insight 软件，而源码来源如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://android.googlesource.com/platform/&quot; class=&quot;uri&quot;&gt;https://android.googlesource.com/platform/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我并没有将所有目录下载下来，只下载了如下目录的源码：&lt;/p&gt;
&lt;p&gt;我没有下载最新版本的代码，而是选择了 Tags 下的 More 按钮，然后选择 tag 为： &lt;strong&gt;android-5.1.1 r24&lt;/strong&gt; 的代码下载。所以，此次分析的源码是基于这个版本，其余不同版本的代码可能会有所不一样，但大体流程应该都是一致的。&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;
&lt;p&gt;源码分析的过程很长很长，不想看过程的话，你也可以直接跳到末尾看结论，但就会错失很多细节的分析了。&lt;/p&gt;
&lt;p&gt;那么下面就开始来过下源码吧，分析的入口就是跟着 &lt;code&gt;System.loadlibrary()&lt;/code&gt; 走 ：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//System#loadlibrary()
public static void loadLibrary(String libName) {
    Runtime.getRuntime().loadLibrary(libName, VMStack.getCallingClassLoader());
}

//Runtime#loadLibrary()
void loadLibrary(String libraryName, ClassLoader loader) {
    //1. 程序中通过 System.loadlibrary() 方式，这个 loader 就不会为空，流程走这边
    if (loader != null) {
        //2. loader.findLibrary() 这是个重点，这个方法用于寻找 so 文件是否存在
        String filename = loader.findLibrary(libraryName);
        if (filename == null) {
             throw new UnsatisfiedLinkError(loader + &quot; couldn't find \&quot;&quot; + System.mapLibraryName(libraryName) + &quot;\&quot;&quot;);
        }
        //3. 如果 so 文件找到，那么加载它
        String error = doLoad(filename, loader);
        if (error != null) {
            //4. 如果加载失败，那么抛异常
            throw new UnsatisfiedLinkError(error);
        }
        return;
    }
    
    //1.1 以下代码的运行场景我不清楚，但有几个方法可以蛮看一下
    //mapLibraryName 用于拼接 so 文件名的前缀:lib，和后缀.so
    String filename = System.mapLibraryName(libraryName);
    //...省略
    //1.2 mLibPaths 存储着设备存放 so 文件的目录地址
    for (String directory: mLibPaths) {
        String candidate = directory + filename;
        candidates.add(candidate);
        if (IoUtils.canOpenReadOnly(candidate)) 
            // 1.3 调用 native 层方法加载 so 库
            String error = doLoad(candidate, loader);
            if (error == null) {
                return; // We successfully loaded the library. Job done.
            }
            lastError = error;
        }
    }
    //...省略
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，其实 System 的 &lt;code&gt;loadlibrary()&lt;/code&gt; 是调用的 Runtime 的 &lt;code&gt;loadLibrary()&lt;/code&gt;，不同系统版本，这些代码是有些许差别的，但不管怎样，重点都还是 &lt;code&gt;loadLibrary()&lt;/code&gt; 中调用的一些方法，这些方法基本没变，改变的只是其他代码的优化写法。&lt;/p&gt;
&lt;p&gt;那么，要理清 so 文件的加载流程，或者说，要找出系统是去哪些地址加载 so 文件的，就需要梳理清这些方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;loader.findLibrary()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;doLoad()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一个方法用于寻找 so 文件，所涉及的整个流程应该都在这个方法里，如果可以找到，会返回 so 文件的绝对路径，然后交由 &lt;code&gt;doLoad()&lt;/code&gt; 去加载。&lt;/p&gt;
&lt;h4 id=&quot;java.library.path&quot;&gt;java.library.path&lt;/h4&gt;
&lt;p&gt;但在深入去探索之前，我想先探索另一条分支，loader 为空的场景。loader 什么时候为空，什么时候不为空，我并不清楚，只是看别人的文章分析时说，程序中通过 &lt;code&gt;System.loadlibrary()&lt;/code&gt; 方式加载 so，那么 loader 就不会为空。那，我就信你了，不然我也不知道去哪分析为不为空的场景。&lt;/p&gt;
&lt;p&gt;既然程序不会走另一个分支，为什么我还要先来探索它呢？因为，第一个分支太不好探索了，先从另一个分支摸索点经验，而且还发现了一些感觉可以拿来讲讲的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;System.mapLibraryName()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用于拼接 so 文件名的前缀 &lt;code&gt;lib&lt;/code&gt;，和后缀 &lt;code&gt;.so&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在其他版本的源码中，可能就没有这个变量了，直接就是调用一个方法，但作用都一样，我们看看这个变量的赋值：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//Runtime.mLibPaths
private final String[] mLibPaths = initLibPaths();

//Runtime#initLibPaths()
private static String[] initLibPaths() {
    String javaLibraryPath = System.getProperty(&quot;java.library.path&quot;);
    //...省略
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后都是通过调用 System 的 &lt;code&gt;getProperty()&lt;/code&gt; 方法，读取 &lt;code&gt;java.library.path&lt;/code&gt; 的属性值。&lt;/p&gt;
&lt;p&gt;也就是说，通过读取 &lt;code&gt;java.library.path&lt;/code&gt; 的系统属性值，是可以获取到设备存放 so 库的目录地址的，那么就来看看在哪里有设置这个属性值进去。&lt;/p&gt;
&lt;p&gt;System 内部有一个类型为 Properties 的静态变量，不同版本，这个变量名可能不一样，但作用也都一样，用来存储这些系统属性值，这样程序需要的时候，调用 &lt;code&gt;getProperty()&lt;/code&gt; 读取属性值时其实是来这个静态变量中读取。而变量的初始化地方在类中的 static 代码块中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//System
static {
    //...省略
    //1.初始化一些不变的系统属性值
    unchangeableSystemProperties = initUnchangeableSystemProperties();
    //2.将上述的属性值以及一些默认的系统属性值设置到静态变量中
    systemProperties = createSystemProperties();
    //...
}

//System#initUnchangeableSystemProperties()
private static Properties initUnchangeableSystemProperties() {
    //...省略一些属性值设置
    p.put(&quot;java.vm.vendor&quot;, projectName);
    p.put(&quot;java.vm.version&quot;, runtime.vmVersion());
    p.put(&quot;file.separator&quot;, &quot;/&quot;);
    p.put(&quot;line.separator&quot;, &quot;\n&quot;);
    p.put(&quot;path.separator&quot;, &quot;:&quot;);
    //...
    
    //1.这里是重点
    parsePropertyAssignments(p, specialProperties());

    //...
    return p;
}

//System#createSystemProperties()
private static Properties createSystemProperties() {
    //1.拷贝不可变的一些系统属性值
    Properties p = new PropertiesWithNonOverrideableDefaults(unchangeableSystemProperties);
    //2.设置一些默认的属性值
    setDefaultChangeableProperties(p);
    return p;
}

//System#setDefaultChangeableProperties()
private static void setDefaultChangeableProperties(Properties p) {
    p.put(&quot;java.io.tmpdir&quot;, &quot;/tmp&quot;);
    p.put(&quot;user.home&quot;, &quot;&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;static 静态代码块中的代码其实就是在初始化系统属性值，分两个步骤，一个是先设置一些不可变的属性值，二是设置一些默认的属性值，然后将这些存储在静态变量中。&lt;/p&gt;
&lt;p&gt;但其实，不管在哪个方法中，都没找到有设置 &lt;code&gt;java.library.path&lt;/code&gt; 属性值的代码，那这个属性值到底是在哪里设置的呢？&lt;/p&gt;
&lt;p&gt;关键点在于设置不可变的属性时，有调用了一个 native 层的方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//System
/**
* Returns an array of &quot;key=value&quot; strings containing information not otherwise
* easily available, such as #defined library versions.
*/
private static native String[] specialProperties();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这方法会返回 key=value 形式的字符串数组，然后 &lt;code&gt;parsePropertyAssignments()&lt;/code&gt; 方法会去遍历这些数组，将这些属性值填充到存储系统属性值的静态变量中。&lt;/p&gt;
&lt;p&gt;也就是说，在 native 层还会设置一些属性值，而 &lt;code&gt;java.library.path&lt;/code&gt; 有可能就是在 native 中设置的，那么就跟下去看看吧。&lt;/p&gt;
&lt;p&gt;System 连同包名的全名是：java.lang.System；那么，通常，所对应的 native 层的 cpp 文件名为：java_lang_System.cpp，到这里去看看：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//platform/libcore/luni/src/main/native/java_lang_System.cpp#System_specialProperties()
static jobjectArray System_specialProperties(JNIEnv* env, jclass) {
    std::vector&amp;lt;std::string&amp;gt; properties;

    //...
    
    //1. 获取 LD_LIBRARY_PATH 环境变量值
    const char* library_path = getenv(&quot;LD_LIBRARY_PATH&quot;);
#if defined(HAVE_ANDROID_OS)
    if (library_path == NULL) {
        //2.如果 1 步骤没获取到路径，那么通过该方法获取 so 库的目录路径
        android_get_LD_LIBRARY_PATH(path, sizeof(path));
        library_path = path;
    }
#endif
    if (library_path == NULL) {
        library_path = &quot;&quot;;
    }
    //3.设置 java.library.path 属性值
    properties.push_back(std::string(&quot;java.library.path=&quot;) + library_path);

    return toStringArray(env, properties);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没错吧，对应的 native 层的方法是上述这个，它干的事，其实也是设置一些属性值，我们想要的 &lt;code&gt;java.library.path&lt;/code&gt; 就是在这里设置的。那么，这个属性值来源的逻辑是这样的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先读取 LD_LIBRARY_PATH 环境变量值，如果不为空，就以这个值为准。但我测试过，貌似，程序运行时读取的这个值一直是 null，在 Runtime 的 &lt;code&gt;doLoad()&lt;/code&gt; 方法注释中，Google 有解释是说由于 Android 的进程都是通过 Zygote 进程 fork 过来，所以不能使用 LD_LIBRARY_PATH 。应该，大概，可能是这个意思吧，我英文不大好，你们可以自行去确认一下。&lt;/li&gt;
&lt;li&gt;也就是说，第一步读取的 LD_LIBRARY_PATH 值是为空，所以会进入第二步，调用 android_get_LD_LIBRARY_PATH 方法来读取属性值。（进入这个步骤有个条件是定义了 HAVE_ANDROID_OS 宏变量，我就不去找到底哪里在什么场景下会定义了，看命名我直接猜测 Android 系统就都有定义的了）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么，继续看看 android_get_LD_LIBRARY_PATH 这个方法做了些什么：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//platform/libcore/luni/src/main/native/java_lang_System.cpp
#if defined(HAVE_ANDROID_OS)
extern &quot;C&quot; void android_get_LD_LIBRARY_PATH(char*, size_t);
#endif&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;emmm，看不懂，头疼。那，直接全局搜索下这个方法名试试看吧，结果在另一个 cpp 中找到它的实现：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//platform/bionic/linker/dlfcn.cpp
void android_get_LD_LIBRARY_PATH(char* buffer, size_t buffer_size) {
  ScopedPthreadMutexLocker locker(&amp;amp;g_dl_mutex);
  do_android_get_LD_LIBRARY_PATH(buffer, buffer_size);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一行估计是加锁之类的意思吧，不管，第二行是调用另一个方法，继续跟下去看看：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//platform/bionic/linker/linker.cpp
void do_android_get_LD_LIBRARY_PATH(char* buffer, size_t buffer_size) {
  //...
  char* end = stpcpy(buffer, kDefaultLdPaths[0]);
  *end = ':';
  strcpy(end + 1, kDefaultLdPaths[1]);
}

static const char* const kDefaultLdPaths[] = {
#if defined(__LP64__)
  &quot;/vendor/lib64&quot;,
  &quot;/system/lib64&quot;,
#else
  &quot;/vendor/lib&quot;,
  &quot;/system/lib&quot;,
#endif
  nullptr
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还好 Source Insight 点击方法时有时可以支持直接跳转过去，调用的这个方法又是在另一个 cpp 文件中了。开头省略了一些大小空间校验的代码，然后直接复制了静态常量的值，而这个静态常量在这份文件顶部定义。&lt;/p&gt;
&lt;p&gt;终于跟到底了吧，也就是说，如果有定义了 &lt;strong&gt;__LP64__&lt;/strong&gt; 这个宏变量，那么就将 &lt;code&gt;java.library.path&lt;/code&gt; 属性值赋值为 &quot;/vendor/lib64:/system/lib64&quot;，否则，就赋值为 &quot;/vendor/lib:/system/lib&quot;。&lt;/p&gt;
&lt;p&gt;也就是说，so 文件的目录地址其实是在 native 层通过硬编码方式写死的，网上那些理所当然的说 so 文件的存放目录也就是这四个，是这么来的。那么，说白了，系统默认存放 so 文件的目录就两个，只是有两种场景。&lt;/p&gt;
&lt;p&gt;而至于到底什么场景下会有这个 __LP64__ 宏变量的定义，什么时候没有，我实在没能力继续跟踪下去了，网上搜索了一些资料后，仍旧不是很懂，如果有清楚的大佬，能够告知、指点下就最棒了。&lt;/p&gt;
&lt;p&gt;我自己看了些资料，以及，自己也做个测试：同一个 app，修改它的 primaryCpuAbi 值，调用 System 的 &lt;code&gt;getProperty()&lt;/code&gt; 来读取 &lt;code&gt;java.library.path&lt;/code&gt;，它返回的值是会不同的。&lt;/p&gt;
&lt;p&gt;所以，以我目前的能力以及所掌握的知识，我是这么猜测的，纯属个人猜测：&lt;/p&gt;
&lt;p&gt;__LP64__ 这个宏变量并不是由安卓系统代码来定义的，而是 Linux 系统层面所定义的。在 Linux 系统中，可执行文件，也可以说所运行的程序，如果是 32 位的，那么是没有定义这个宏变量的，如果是 64 位的，那么是有定义这个宏变量的。&lt;/p&gt;
&lt;p&gt;总之，通俗的联想解释，__LP64__ 这个宏变量表示着当前程序是 32 位还是 64 位的意思。（个人理解）&lt;/p&gt;
&lt;p&gt;有时间再继续研究吧，反正这里清楚了，系统默认存放 so 文件的目录只有两个，但有两种场景。vendor 较少用，就不每次都打出来了。也就是说，如果应用在 system/lib 目录中没有找到 so 文件，那么它是不会再自动去 system/lib64 中寻找的，两者它只会选其一。至于选择哪个，因为 Zygote 是有分 32 位还是 64 位进程的，那么刚好可以根据这个为依据。&lt;/p&gt;
&lt;h4 id=&quot;findlibrary&quot;&gt;findLibrary&lt;/h4&gt;
&lt;p&gt;该走回主线了，在支线中的探索已经摸索了些经验了。&lt;/p&gt;
&lt;p&gt;大伙应该还记得吧，System 调用了 &lt;code&gt;loadlibrary()&lt;/code&gt; 之后，内部其实是调用了 Runtime 的 &lt;code&gt;loadLibrary()&lt;/code&gt; 方法，这个方法内部会去调用 ClassLoader 的 &lt;code&gt;findLibrary()&lt;/code&gt; 方法，主要是去寻找这个 so 文件是否存在，如果存在，会返回 so 文件的绝对路径，接着交由 Runtime 的 &lt;code&gt;doLoad()&lt;/code&gt; 方法去加载 so 文件。&lt;/p&gt;
&lt;p&gt;所以，我们想要梳理清楚 so 文件的加载流程，&lt;code&gt;findLibrary()&lt;/code&gt; 是关键。那么，接下去，就来跟着 &lt;code&gt;findLibrary()&lt;/code&gt; 走下去看看吧：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//ClassLoader#findLibrary()
protected String findLibrary(String libName) {
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ClassLoader 只是一个基类，具体实现在其子类，那这里具体运行的是哪个子类呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//System#loadlibrary()
public static void loadLibrary(String libName) {
    Runtime.getRuntime().loadLibrary(libName, VMStack.getCallingClassLoader());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以这里是调用了 VMStack 的一个方法来获取 ClassLoader 对象，那么继续跟进看看：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;native public static ClassLoader getCallingClassLoader();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;又是一个 native 的方法，我尝试过跟进去，没有看懂。那么，换个方向来找出这个基类的具体实现子类是哪个吧，很简单的一个方法，打 log 输出这个对象本身：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ClassLoader classLoader = getClassLoader();
Log.v(TAG, &quot;classLoader = &quot; + classLoader.toString());
//输出
// classLoader = dalvik.system.PathClassLoader[dexPath=/data/app/com.qrcode.qrcode-1.apk,libraryPath=/data/app-lib/com.qrcode.qrcode-1]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上打 Log 代码是从 &lt;a href=&quot;https://my.oschina.net/wolfcs/blog/129696&quot;&gt;Java中System.loadLibrary() 的执行过程&lt;/a&gt; 这篇文章中截取出来的，使用这个方法的前提是你得清楚 VMStack 的 &lt;code&gt;getCallingClassLoader()&lt;/code&gt; 含义其实是获取调用这个方法的类它的类加载器对象。&lt;/p&gt;
&lt;p&gt;或者，你对 Android 的类加载机制有所了解，知道当启动某个 app 时，经过层层工作后，会接着让 LoadedApk 去加载这个 app 的 apk，然后通过 ApplicationLoader 来加载相关代码文件，而这个类内部是实例化了一个 PathClassLoader 对象去进行 dex 的加载。&lt;/p&gt;
&lt;p&gt;不管哪种方式，总之清楚了这里实际上是调用了 PathClassLoader 的 &lt;code&gt;findLibrary()&lt;/code&gt; 方法，但 PathClassLoader 内部并没有这个方法，它继承自 BaseDexClassLoader，所以实际上还是调用了父类的方法，跟进去看看：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//platform/libcore/dalvik/src/main/java/dalvik/system/BaseDexClassLoader.java
public String findLibrary(String name) {
    return pathList.findLibrary(name);
}

private final DexPathList pathList;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内部又调用了 DexPathList 的 &lt;code&gt;findLibrary()&lt;/code&gt; 方法，继续跟进看看：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//platform/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java
public String findLibrary(String libraryName) {
    //1. 拼接前缀：lib，和后缀：.so
    String fileName = System.mapLibraryName(libraryName);
    //2. 遍历所有存放 so 文件的目录，确认指定文件是否存在以及是只读文件
    for (File directory: nativeLibraryDirectories) {
        String path = new File(directory, fileName).getPath();
        if (IoUtils.canOpenReadOnly(path)) {
            return path;
        }
    }
    return null;
}

/** List of native library directories. */
private final File[] nativeLibraryDirectories;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到了这里，会先进行文件名补全操作，拼接上前缀：lib 和后缀：.so，然后遍历所有存放 so 文件的目录，当找到指定文件，且是只读属性，则返回该 so 文件的绝对路径。&lt;/p&gt;
&lt;p&gt;所以，重点就是 nativeLibraryDirectories 这个变量了，这里存放着 so 文件存储的目录路径，那么得看看它在哪里被赋值了：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//platform/libcore/dalvik/src/main/java/dalvik/system/DexPathList.java
public DexPathList(ClassLoader definingContext, String dexPath, String libraryPath, File optimizedDirectory) {
    //...
    //1. 唯一赋值的地方，构造函数
    this.nativeLibraryDirectories = splitLibraryPath(libraryPath);
}

private static File[] splitLibraryPath(String path) {
    // Native libraries may exist in both the system and
    // application library paths, and we use this search order:
    //
    //   1. this class loader's library path for application libraries
    //   2. the VM's library path from the system property for system libraries
    //   (翻译下，大体是说，so 文件的来源有两处：1是应用自身存放 so 文件的目录，2是系统指定的目录)
    // This order was reversed prior to Gingerbread; see http://b/2933456.
    ArrayList &amp;lt; File &amp;gt; result = splitPaths(path, System.getProperty(&quot;java.library.path&quot;), true);
    return result.toArray(new File[result.size()]);
}

//将传入的两个参数的目录地址解析完都存放到集合中
private static ArrayList &amp;lt; File &amp;gt; splitPaths(String path1, String path2, boolean wantDirectories) {
    ArrayList &amp;lt; File &amp;gt; result = new ArrayList &amp;lt; File &amp;gt; ();
    
    splitAndAdd(path1, wantDirectories, result);
    splitAndAdd(path2, wantDirectories, result);
    return result;
}

private static void splitAndAdd(String searchPath, boolean directoriesOnly, ArrayList &amp;lt; File &amp;gt; resultList) {
    if (searchPath == null) {
        return;
    }
    //因为获取系统的 java.library.path 属性值返回的路径是通过 : 拼接的，所以先拆分，然后判断这些目录是否可用 
    for (String path: searchPath.split(&quot;:&quot;)) {
        try {
            StructStat sb = Libcore.os.stat(path);
            if (!directoriesOnly || S_ISDIR(sb.st_mode)) {
                resultList.add(new File(path));
            }
        } catch(ErrnoException ignored) {}
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，nativeLibraryDirectories 这个变量是在构造函数中被赋值。代码不多，总结一下，构造函数会传入一个 libraryPath 参数，表示应用自身存放 so 文件的路径，然后内部会再去调用 System 的 &lt;code&gt;getProperty(&quot;java.library.path&quot;)&lt;/code&gt; 方法获取系统指定的 so 文件目录地址。最后，将这些路径都添加到集合中。&lt;/p&gt;
&lt;p&gt;而且，看添加的顺序，是先添加应用自身的 so 文件目录，然后再添加系统指定的 so 文件目录，也就是说，当加载 so 文件时，是先去应用自身的 so 文件目录地址寻找，没有找到，才会去系统指定的目录。&lt;/p&gt;
&lt;p&gt;而系统指定的目录地址在 native 层的 linker.cpp 文件定义，分两种场景，取决于应用当前的进程是 32 位还是 64 位，32 位的话，则按顺序分别去 vendor/lib 和 system/lib 目录中寻找，64 位则是相对应的 lib64 目录中。&lt;/p&gt;
&lt;p&gt;虽然，so 文件加载流程大体清楚了，但还有两个疑问点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;构造方法参数传入的表示应用自身存放 so 文件目录的 libraryPath 值是哪里来的；&lt;/li&gt;
&lt;li&gt;应用什么时候运行在 32 位或 64 位的进程上；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;nativelibrarydir&quot;&gt;nativeLibraryDir&lt;/h4&gt;
&lt;p&gt;先看第一个疑问点，应用自身存放 so 文件目录的这个值，要追究的话，这是一个很漫长的故事。&lt;/p&gt;
&lt;p&gt;这个过程，我不打算全部都贴代码了，因为很多步骤，我自己也没有去看源码，也是看的别人的文章，我们以倒着追踪的方式来进行追溯吧。&lt;/p&gt;
&lt;p&gt;首先，这个 libraryPath 值是通过 DexPathList 的构造方法传入的，而 BaseDexClassLoader 内部的 DexPathList 对象实例化的地方也是在它自己的构造方法中，同样，它也接收一个 libraryPath 参数值，所以 BaseDexClassLoader 只是做转发，来源并不在它这里。&lt;/p&gt;
&lt;p&gt;那么，再往回走，就是 LoadedApk 实例化 PathClassLoader 对象的地方了，在它的 &lt;code&gt;getClassLoader()&lt;/code&gt; 方法中：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//platform/frameworks/base/core/java/android/app/LoadedApk.java
public ClassLoader getClassLoader() {
    synchronized(this) {
        //...
        final ArrayList &amp;lt; String &amp;gt; libPaths = new ArrayList &amp;lt; &amp;gt;();
        //...
        libPaths.add(mLibDir);
        //...
        final String lib = TextUtils.join(File.pathSeparator, libPaths);
        //...
        mClassLoader = ApplicationLoaders.getDefault().getClassLoader(zip, lib, mBaseClassLoader);
        //...
    }
}

public LoadedApk(ActivityThread activityThread, ApplicationInfo aInfo, CompatibilityInfo compatInfo, ClassLoader baseLoader, boolean securityViolation, boolean includeCode, boolean registerPackage) {
   //...
    mLibDir = aInfo.nativeLibraryDir;
   //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无关代码都省略掉了，也就是说，传给 DexPathList 的 libraryPath 值，其实是将要启动的这个 app 的 ApplicationInfo 中的 nativeLibraryDir 变量值。&lt;/p&gt;
&lt;p&gt;可以看看 ApplicationInfo 中这个变量的注释：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//ApplicationInfo 
/**
* Full path to the directory where native JNI libraries are stored.
* 存放 so 文件的绝对路径
*/
public String nativeLibraryDir;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通俗点解释也就是，存放应用自身 so 文件的目录的绝对路径。那么问题又来了，传给 LoadedApk 的这个 ApplicationInfo 对象哪里来的呢？&lt;/p&gt;
&lt;p&gt;这个就又涉及到应用的启动流程了，大概讲一下：&lt;/p&gt;
&lt;p&gt;我们知道，当要启动其他应用时，其实是通过发送一个 Intent 去启动这个 app 的 LAUNCHER 标志的 Activity。而当这个 Intent 发送出去后，是通过 Binder 通信方式通知了 ActivityManagerServer 去启动这个 Activity。&lt;/p&gt;
&lt;p&gt;AMS 在这个过程中会做很多事，但在所有事之前，它得先解析 Intent，知道要启动的是哪个 app 才能继续接下去的工作，这个工作在 ActivityStackSupervisor 的 &lt;code&gt;resolveActivity()&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//ActivityStackSupervisor.java
ActivityInfo resolveActivity(Intent intent, String resolvedType, int startFlags, ProfilerInfo profilerInfo, int userId) {
    // Collect information about the target of the Intent.
    ActivityInfo aInfo;
    try {
        ResolveInfo rInfo = AppGlobals.getPackageManager().resolveIntent(intent, resolvedType, PackageManager.MATCH_DEFAULT_ONLY | ActivityManagerService.STOCK_PM_FLAGS, userId);
        aInfo = rInfo != null ? rInfo.activityInfo: null;
    } catch(RemoteException e) {
        aInfo = null;
    }
    //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不同版本，可能不是由这个类负责这个工作了，但可以跟着 ActivityManagerService 的 &lt;code&gt;startActivity()&lt;/code&gt; 走下去看看，不用跟很深就能找到，因为这个工作是比较早进行的。&lt;/p&gt;
&lt;p&gt;所以，解析 Intent 获取 app 的相关信息就又交给 PackageManagerService 的 &lt;code&gt;resolveIntent()&lt;/code&gt; 进行了，PKMS 的工作不贴了，我直接说了吧：&lt;/p&gt;
&lt;p&gt;PKMS 会根据 Intent 中目标组件的 packageName，通过一个只有包权限的类 Settings 来获取对应的 ApplicationInfo 信息，这个 Settings 类全名：com.android.server.pm.Settings，它的职责之一是存储所有 app 的基本信息，也就是在 data/system/packages.xml 中各 app 的信息都交由它维护缓存。&lt;/p&gt;
&lt;p&gt;所以，一个 app 的 ApplicationInfo 信息，包括 nativeLibraryDir 我们都可以在 data/system/packages.xml 这份文件中查看到。这份文件的角色我把它理解成类似 PC 端上的注册表，所有 app 的信息都注册在这里。&lt;/p&gt;
&lt;p&gt;那这份 packages.xml 文件的数据又是从哪里来的呢，这又得涉及到 apk 的安装机制过程了。&lt;/p&gt;
&lt;p&gt;简单说一下，一个 app 的安装过程，在解析 apk 包过程中，还会结合各种设备因素等等来决定这个 app 的各种属性，比如说 nativeLibraryDir 这个属性值的确认，就需要考虑这个 app 是三方应用还是系统应用，这个应用的 primaryCpuAbi 属性值是什么，apk 文件的地址等等因素后，最后才确定了应用存放 so 文件的目录地址是哪里。&lt;/p&gt;
&lt;p&gt;举个例子，对于系统应用来说，这个 nativeLibraryDir 值有可能最后是 /system/lib/xxx，也有可能是 system/app/xxx/lib 等等；而对于三方应用来说，这值有可能就是 data/app/xxx/lib；&lt;/p&gt;
&lt;p&gt;也就是说，当 app 安装完成时，这些属性值也就都解析到了，就都会保存到 Settings 中，同时会将这些信息写入到 data/system/packages.xml 中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;到这里，先来小结一下，梳理下前面的内容：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当一个 app 安装的时候，系统会经过各种因素考量，最后确认 app 的一个 nativeLibraryDir 属性值，这个属性值代表应用自身的 so 文件存放地址，这个值也可以在 data/system/packages.xml 中查看。&lt;/p&gt;
&lt;p&gt;当应用调用了 System 的 &lt;code&gt;loadlibrary()&lt;/code&gt; 时，这个 so 文件的加载流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先到 nativeLibraryDir 指向的目录地址中寻找这个 so 文件是否存在、可用；&lt;/li&gt;
&lt;li&gt;如果没找到，那么根据应用进程是 32 位或者 64 位来决定下去应该去哪个目录寻找 so 文件；&lt;/li&gt;
&lt;li&gt;如果是 32 位，则先去 vendor/lib 找，最后再去 system/lib 中寻找；&lt;/li&gt;
&lt;li&gt;如果是 64 位，则先去 vendor/lib64 找，最后再去 system/lib64 中寻找；&lt;/li&gt;
&lt;li&gt;系统默认的目录是在 native 层中的 linker.cpp 文件中指定，更严谨的说法，不是进程是不是 32 位或 64 位，而是是否有定义了 __LP64__ 这个宏变量。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;primarycpuabi&quot;&gt;primaryCpuAbi&lt;/h4&gt;
&lt;p&gt;我们已经清楚了，加载 so 文件的流程，其实就分两步，先去应用自身存放 so 文件的目录（nativeLibraryDir）寻找，找不到，再去系统指定的目录中寻找。&lt;/p&gt;
&lt;p&gt;而系统指定是目录分两种场景，应用进程是 32 位或者 64 位，那么，怎么知道应用是运行在 32 位还是 64 位的呢？又或者说，以什么为依据来决定一个应用是应该跑在 32 位上还是跑在 64 位上？&lt;/p&gt;
&lt;p&gt;这个就取决于一个重要的属性了 primaryCpuAbi，它代表着这个应用的 so 文件使用的是哪个 abi 架构。&lt;/p&gt;
&lt;p&gt;abi 常见的如：arm64-v8a，armeabi-v7a，armeabi，mips，x86_64 等等。&lt;/p&gt;
&lt;p&gt;我们在打包 apk 时，如果不指定，其实默认是会将所有 abi 对应的 so 文件都打包一份，而通常，为了减少 apk 包体积，我们在 build.gradle 脚本中会指定只打其中一两份。但不管 apk 包有多少种不同的 abi 的 so 文件，在 app 安装过程中，最终拷贝到 nativeLibraryDir 中的通常都只有一份，除非你手动指定了要多份。&lt;/p&gt;
&lt;p&gt;那么，app 在安装过程中，怎么知道，应该拷贝 apk 中的 lib 下的哪一份 so 文件呢？这就是由应用的 primaryCpuAbi 属性决定。&lt;/p&gt;
&lt;p&gt;而同样，这个属性一样是在 app 安装过程中确定的，这个过程更加复杂，末尾有给了篇链接，感兴趣可以去看看，大概来说，就是 apk 包中的 so 文件、系统应用、相同 UID 的应用、设备的 abilist 等都对这个属性值的确定过程有所影响。同样，这个属性值也可以在 data/system/packages.xml 中查看。&lt;/p&gt;
&lt;p&gt;那么，这个 primaryCpuAbi 属性值是如何影响应用进程是 32 位还是 64 位的呢？&lt;/p&gt;
&lt;p&gt;这就涉及到 Zygote 方面的知识了。&lt;/p&gt;
&lt;p&gt;在系统启动之后，系统会根据设备的 ro.zygote 属性值决定启动哪个 Zygote，可以通过执行 &lt;code&gt;getprop | grep ro.zygote&lt;/code&gt; 来查看这个属性值，属性值与对应的 Zygote 进程关系如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;zygote32：只启动一个 32 位的 Zygote 进程&lt;/li&gt;
&lt;li&gt;zygote32_64：启动两个 Zygote 进程，分别为 32 位和 64 位，32 位的进程名为 zygote，表示以它为主，64 位进程名为 zygote_secondary ，表示它作为辅助&lt;/li&gt;
&lt;li&gt;zygote64：只启动一个 64 位的 Zygote 进程&lt;/li&gt;
&lt;li&gt;zygote64_32：启动两个 Zygote 进程，分别为 32 位和 64 位，64 位的进程名为 zygote，表示以它为主，32 位进程名为 zygote_secondary ，表示它作为辅助&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而 Zygote 进程启动之后，会打开一个 socket 端口，等待 AMS 发消息过来启动新的应用时 fork 当前 Zygote 进程，所以，如果 AMS 是发给 64 位的 Zygote，那么新的应用自然就是跑在 64 位的进程上；同理，如果发给了 32 位的 Zygote 进程，那么 fork 出来的进程自然也就是 32 位的。&lt;/p&gt;
&lt;p&gt;那么，可以跟随着 AMS 的 &lt;code&gt;startProcessLocked()&lt;/code&gt; 方法，去看看是以什么为依据选择 32 位或 64 位的 Zygote：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//ActivityManagerService
private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
    //...省略
    //1. 获取要启动的 app 的 primaryCpuAbi 属性值，abiOverride 不知道是什么，可能是 Google 开发人员写测试用例用的吧，或者其他一些场景
    String requiredAbi = (abiOverride != null) ? abiOverride: app.info.primaryCpuAbi;
    if (requiredAbi == null) {
        //2. 如果为空，以设备支持的首个 abi 属性值，可执行 getprot ro.product.cpu.abilist 查看
        requiredAbi = Build.SUPPORTED_ABIS[0];
    }
    //...
    
    //3. 调用Precess 的 start 方法，将 requiredAbi 传入
    Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs);
    //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AMS 会先获取要启动的 app 的 primaryCpuAbi 属性值，至于这个 app 的相关信息怎么来的，跟上一小节一样，解析 Intent 时交由 PKMS 去它模块内部的 Settings 读取的。&lt;/p&gt;
&lt;p&gt;如果 primaryCpuAbi 为空，则以设备支持的首个 abi 属性值为主，设备支持的 abi 列表可以通过执行 &lt;code&gt;getprot ro.product.cpu.abilist&lt;/code&gt; 查看，最后调用 Precess 的 &lt;code&gt;start()&lt;/code&gt; 方法，将读取的 abi 值传入：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//Process
public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) {
    //...
    return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs);
    //...
}

private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx {
    //...
    //所以 abi 最终是调用 openZygoteSocketIfNeeded() 方法，传入给它使用
    return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;abi 值又是一层传一层，最终交到了 Process 的 &lt;code&gt;openZygoteSocketIfNeeded()&lt;/code&gt; 方法中使用，跟进看看：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//Process
private static ZygoteState openZygoteSocketIfNeeded(String abi) throws ZygoteStartFailedEx {
    if (primaryZygoteState == null || primaryZygoteState.isClosed()) {
        try {
            //ZYGOTE_SOCKET值为 zygote,
            //通过 ZygoteState 的 connect 方法，连接进程名为 zygote 的 Zygote 进程
            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);
        } catch(IOException ioe) {
            throw new ZygoteStartFailedEx(&quot;Error connecting to primary zygote&quot;, ioe);
        }
    }
    //在进程名为 zygote 的 Zygote 进程支持的 abi 列表中，查看是否支持要启动的 app 的需要的 abi
    if (primaryZygoteState.matches(abi)) {
        return primaryZygoteState;
    }

    // The primary zygote didn't match. Try the secondary.
    if (secondaryZygoteState == null || secondaryZygoteState.isClosed()) {
        try {
             //SECONDARY_ZYGOTE_SOCKET 的值为 zygote_secondary,
            //通过 ZygoteState 的 connect 方法，连接进程名为 zygote_secondary 的 Zygote 进程
            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);
        } catch(IOException ioe) {
            throw new ZygoteStartFailedEx(&quot;Error connecting to secondary zygote&quot;, ioe);
        }
    }
    //在进程名为 zygote_secondary 的 Zygote 进程支持的 abi 列表中，查看是否支持要启动的 app 的需要的 abi
    if (secondaryZygoteState.matches(abi)) {
        return secondaryZygoteState;
    }

    throw new ZygoteStartFailedEx(&quot;Unsupported zygote ABI: &quot; + abi);
}

static ZygoteState primaryZygoteState;
static ZygoteState secondaryZygoteState;
public static final String ZYGOTE_SOCKET = &quot;zygote&quot;;
public static final String SECONDARY_ZYGOTE_SOCKET = &quot;zygote_secondary&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到了这里，是先获取进程名 zygote 的 Zygote 进程，查看它支持的 abi 列表中是否满足要启动的 app 所需的 abi，如果满足，则使用这个 Zygote 来 fork 新进程，否则，获取另一个进程名为 zygote_secondary 的 Zygote 进程，同样查看它支持的 abi 列表中是否满足 app 所需的 abi，如果都不满足，抛异常。&lt;/p&gt;
&lt;p&gt;那么，名为 zygote 和 zygote_secondary 分别对应的是哪个 Zygote 进程呢？哪个对应 32 位，哪个对应 64 位？&lt;/p&gt;
&lt;p&gt;还记得上述说过的，系统启动后，会去根据设备的 ro.zygote 属性决定启动哪个 Zygote 进程吗？对应关系就是这个属性值决定的，举个例子，可以看看 zygote64_32 对应的 Zygote 启动配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//platform/system/core/rootdir/init.zygote64_32.rc
service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote
    class main
    socket zygote stream 660 root system
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart media
    onrestart restart netd

service zygote_secondary /system/bin/app_process32 -Xzygote /system/bin --zygote --socket-name=zygote_secondary
    class main
    socket zygote_secondary stream 660 root system
    onrestart restart zygote&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这份代码前半段的意思就表示，让 Linux 启动一个 service，进程名为 zygote，可执行文件位于 /system/bin/app_process64，后面是参数以及其他命令。&lt;/p&gt;
&lt;p&gt;所以，名为 zygote 和 zygote_secondary 分别对应的是哪个 Zygote 进程，就取决于设备的 ro.zygote 属性。&lt;/p&gt;
&lt;p&gt;而，获取 Zygote 支持的 abi 列表是通过 ZygoteState 的 &lt;code&gt;connect()&lt;/code&gt; 方法，我们继续跟进看看：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//Process$ZygoteState
public static ZygoteState connect(String socketAddress) throws IOException {
    //...

    String abiListString = getAbiList(zygoteWriter, zygoteInputStream);
    Log.i(&quot;Zygote&quot;, &quot;Process: zygote socket opened, supported ABIS: &quot; + abiListString);

    return new ZygoteState(zygoteSocket, zygoteInputStream, zygoteWriter, Arrays.asList(abiListString.split(&quot;,&quot;)));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现没有，源码内部将 Zygote 支持的 abi 列表输出日志了，你们可以自己尝试下，过滤下 TAG 为 Zygote，然后重启下设备，因为如果本来就连着 Zygote，那么是不会走到这里的了，最后看一下相关日志，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;01-01 08:00:13.509 2818-2818/? D/AndroidRuntime: &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; START com.android.internal.os.ZygoteInit uid 0 &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;
01-01 08:00:15.068 2818-2818/? D/Zygote: begin preload
01-01 08:00:15.081 2818-3096/? I/Zygote: Preloading classes...
01-01 08:00:15.409 2818-3097/? I/Zygote: Preloading resources...
01-01 08:00:16.637 2818-3097/? I/Zygote: ...preloaded 343 resources in 1228ms.
01-01 08:00:16.669 2818-3097/? I/Zygote: ...preloaded 41 resources in 33ms.
01-01 08:00:17.242 2818-3096/? I/Zygote: ...preloaded 3005 classes in 2161ms.
01-01 08:00:17.373 2818-2818/? I/Zygote: Preloading shared libraries...
01-01 08:00:17.389 2818-2818/? D/Zygote: end preload
01-01 08:00:17.492 2818-2818/? I/Zygote: System server process 3102 has been created
01-01 08:00:17.495 2818-2818/? I/Zygote: Accepting command socket connections
01-01 08:00:32.789 3102-3121/? I/Zygote: Process: zygote socket opened, supported ABIS: armeabi-v7a,armeabi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;系统启动后，Zygote 工作的相关内容基本都打日志出来了。&lt;/p&gt;
&lt;p&gt;最后，再来稍微理一理：&lt;/p&gt;
&lt;p&gt;app 安装过程，会确定 app 的一个属性值：primaryCpuAbi，它代表着这个应用的 so 文件使用的是哪个 abi 架构，而且它的确定过程很复杂，apk 包中的 so 文件、系统应用、相同 UID 的应用、设备的 abilist 等都对这个属性值的确定过程有所影响。安装成功后，可以在 data/system/packages.xml 中查看这个属性值。&lt;/p&gt;
&lt;p&gt;每启动一个新的应用，都是运行在新的进程中，而新的进程是从 Zygote 进程 fork 过来的，系统在启动时，会根据设备的 ro.zygote 属性值决定启动哪几个 Zygote 进程，然后打开 socket，等待 AMS 发送消息来 fork 新进程。&lt;/p&gt;
&lt;p&gt;当系统要启动一个新的应用时，AMS 在负责这个工作进行到 Process 类的工作时，会先尝试在进程名为 zygote 的 Zygote 进程中，查看它所支持的 abi 列表中是否满足要启动的 app 所需的 abi，如果满足，则以这个 Zygote 为主，fork 新进程，运行在 32 位还是 64 位就跟这个 Zygote 进程一致，而 Zygote 运行在几位上取决于 ro.zygote 对应的文件，如值为 zygote64_32 时，对应着 init.zygote64_32.rc 这份文件，那么此时名为 zygote 的 Zygote 就是运行在 64 位上的。&lt;/p&gt;
&lt;p&gt;而当上述所找的 Zygote 支持的 abi 列表不满足 app 所需的 abi 时，那么再去名为 zygote_secondary 的 Zygote 进程中看看，它所支持的 abi 列表是否满足。&lt;/p&gt;
&lt;p&gt;另外，Zygote 的相关工作流程，包括支持的 abi 列表，系统都有打印相关日志，可过滤 Zygote 查看，如没发现，可重启设备查看。&lt;/p&gt;
&lt;h4 id=&quot;abi-兼容&quot;&gt;abi 兼容&lt;/h4&gt;
&lt;p&gt;so 文件加载的流程，及应用运行在 32 位或 64 位的依据我们都梳理完了，以上内容足够掌握什么场景下，该去哪些目录下加载 so 文件的判断能力了。&lt;/p&gt;
&lt;p&gt;那么，还有个问题，如果应用运行在 64 位上，那么此时，它是否能够使用 armeabi-v7a 的 so 文件？&lt;/p&gt;
&lt;p&gt;首先，先来罗列一下常见的 abi ：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;arm64-v8a，armeabi-v7a，armeabi，mips，mips64，x86，x86_64&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中，运行在 64 位的 Zygote 进程上的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;arm64-v8a，mips64，x86_64&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同样，运行在 32 位的 Zygote 进程上的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;armeabi-v7a，armeabi，mips，x86&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你们如果去网上搜索如下关键字：so 文件，abi 兼容等，你们会发现，蛮多文章里都会说：arm64-v8a 的设备能够向下兼容，支持运行 32 位的 so 文件，如 armeabi-v7a。&lt;/p&gt;
&lt;p&gt;这句话没错，64 位的设备能够兼容运行 32 位的 so 文件，但别只看到这句话啊，良心一些的文章里还有另一句话：&lt;strong&gt;不同 cpu 架构的 so 文件不能够混合使用&lt;/strong&gt;，例如，程序运行期间，要么全部使用 arm64-v8a 的 so 文件，要么全部使用 armeabi-v7a 的 so 文件，你不能跑在 64 位进程上，却使用着 32 位的 so 文件。&lt;/p&gt;
&lt;p&gt;我所理解的兼容，并不是说，64 位的设备，支持你运行在 64 位的 Zygote 进程上时仍旧可以使用 32 位的 so 文件。有些文章里也说了，如果在 64 位的设备上，你选择使用 32 位的 so 文件，那么此时，你就丢失了专门为 64 位优化过的性能（ART，webview，media等等 ）。这个意思就是说，程序启动时是从 32 位的 Zygote 进程 fork 过来的，等于你在 64 位的设备上，但却只运行在 32 位的进程上。&lt;/p&gt;
&lt;p&gt;至于程序如何决定运行在 32 位还是 64 位，上面的章节中也分析过了，以 app 的 primaryCpuAbi 属性值为主，而这个属性值的确定因素之一就是含有的 so 文件所属的 abi。&lt;/p&gt;
&lt;p&gt;如果，你还想自己验证，那么可以跟着 Runtime 的 &lt;code&gt;doLoad()&lt;/code&gt; 方法跟到 native 层去看看，由于我下载的源码版本可能有些问题，我没找到 Runtime 对应的 cpp 文件，但我找到这么段代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//platform/bionic/linker/linker_phdr.cpp
bool ElfReader::VerifyElfHeader() {
  //...
  //1.读取 elf 文件的 header 的 class 信息
  int elf_class = header_.e_ident[EI_CLASS];
#if defined(__LP64__)
  //2. 如果当前进程是64位的，而 elf 文件属于 32 位的，则报错
  if (elf_class != ELFCLASS64) {
    if (elf_class == ELFCLASS32) {
      DL_ERR(&quot;\&quot;%s\&quot; is 32-bit instead of 64-bit&quot;, name_);
    } else {
      DL_ERR(&quot;\&quot;%s\&quot; has unknown ELF class: %d&quot;, name_, elf_class);
    }
    return false;
  }
#else
    //3. 如果当前进程是32位的，而 elf 文件属于 64 位的，则报错
  if (elf_class != ELFCLASS32) {
    if (elf_class == ELFCLASS64) {
      DL_ERR(&quot;\&quot;%s\&quot; is 64-bit instead of 32-bit&quot;, name_);
    } else {
      DL_ERR(&quot;\&quot;%s\&quot; has unknown ELF class: %d&quot;, name_, elf_class);
    }
    return false;
  }
#endif&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加载 so 文件，最终还是交由 native 层去加载，在 Linux 中，so 文件其实就是一个 elf 文件，elf 文件有个 header 头部信息，里面记录着这份文件的一些信息，如所属的是 32 位还是 64 位，abi 的信息等等。&lt;/p&gt;
&lt;p&gt;而 native 层在加载 so 文件之前，会去解析这个 header 信息，当发现，如果当前进程运行在 64 位时，但要加载的 so 文件却是 32 位的，就会报 &lt;code&gt;xxx is 32-bit instead of 64-bit&lt;/code&gt; 异常，同样，如果当前进程是运行在 32 位的，但 so 文件却是 64 位的，此时报 &lt;code&gt;xxx is 64-bit instead of 32-bit&lt;/code&gt; 异常。&lt;/p&gt;
&lt;p&gt;这个异常应该也有碰见过吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.lang.UnsatisfiedLinkError: dlopen failed: &quot;libimagepipeline.so&quot; is 32-bit instead of 64-bit&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以说，64 位设备的兼容，并不是说，允许你运行在 64 位的进程上时，仍旧可以使用 32 位的 so 文件。它的兼容是说，允许你在 64 位的设备上运行 32 位的进程。&lt;/p&gt;
&lt;p&gt;其实，想想也能明白，这就是为什么三方应用安装的时候，并不会将 apk 包中所有 abi 目录下的 so 文件都解压出来，只会解压一种，因为应用在安装过程中，系统已经确定你这个应用是应该运行在 64 位还是 32 位的进程上了，并将这个结果保存在 app 的 primaryCpuAbi 属性值中。&lt;/p&gt;
&lt;p&gt;既然系统已经明确你的应用所运行的进程是 32 位还是 64 位，那么只需拷贝对应的一份 so 文件即可，毕竟 64 位的 so 文件和 32 位的又不能混合使用。&lt;/p&gt;
&lt;p&gt;以上，是我的理解，如果有误，欢迎指点下。&lt;/p&gt;

&lt;p&gt;整篇梳理下来，虽然梳理 so 的加载流程不难，但要掌握知其所以然的程度，就需要多花费一点心思了。&lt;/p&gt;
&lt;p&gt;毕竟都涉及到应用的安装机制，应用启动流程，系统启动机制，Zygote 相关的知识点了。如果你是开发系统应用的，建议还是花时间整篇看一下，毕竟系统应用的集成不像三方应用那样在 apk 安装期间自动将相关 so 文件解压到 nativeLibraryDirectories 路径下了。三方应用很少需要了解 so 的加载流程，但开发系统应用还是清楚点比较好。&lt;/p&gt;
&lt;p&gt;不管怎么说，有时间，可以稍微跟着过一下整篇，相信多少是会有些收获的，如果发现哪里有误，也欢迎指点。没时间的话，那就看看总结吧。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个应用在安装过程中，系统会经过一系列复杂的逻辑确定两个跟 so 文件加载相关的 app 属性值：nativeLibraryDirectories ，primaryCpuAbi ；&lt;/li&gt;
&lt;li&gt;nativeLibraryDirectories 表示应用自身存放 so 文件的目录地址，影响着 so 文件的加载流程；&lt;/li&gt;
&lt;li&gt;primaryCpuAbi 表示应用应该运行在哪种 abi 上，如（armeabi-v7a），它影响着应用是运行在 32 位还是 64 位的进程上，进而影响到寻找系统指定的 so 文件目录的流程；&lt;/li&gt;
&lt;li&gt;以上两个属性，在应用安装结束后，可在 data/system/packages.xml 中查看；&lt;/li&gt;
&lt;li&gt;当调用 System 的 &lt;code&gt;loadLibrary()&lt;/code&gt; 加载 so 文件时，流程如下：&lt;/li&gt;
&lt;li&gt;先到 nativeLibraryDirectories 指向的目录中寻找，是否存在且可用的 so 文件，有则直接加载这里的 so 文件；&lt;/li&gt;
&lt;li&gt;上一步没找到的话，则根据当前进程如果是 32 位的，那么依次去 vendor/lib 和 system/lib 目录中寻找；&lt;/li&gt;
&lt;li&gt;同样，如果当前进程是 64 位的，那么依次去 vendor/lib64 和 system/lib64 目录中寻找；&lt;/li&gt;
&lt;li&gt;当前应用是运行在 32 位还是 64 位的进程上，取决于系统的 ro.zygote 属性和应用的 primaryCpuAbi 属性值，系统的 ro.zygote 可通过执行 getprop 命令查看；&lt;/li&gt;
&lt;li&gt;如果 ro.zygote 属性为 zygote64_32，那么应用启动时，会先在 ro.product.cpu.abilist64 列表中寻找是否支持 primaryCpuAbi 属性，有，则该应用运行在 64 位的进程上；&lt;/li&gt;
&lt;li&gt;如果上一步不支持，那么会在 ro.product.cpu.abilist32 列表中寻找是否支持 primaryCpuAbi 属性，有，则该应用运行在 32 位的进程上；&lt;/li&gt;
&lt;li&gt;如果 ro.zygote 属性为 zygote32_64，则上述两个步骤互换；&lt;/li&gt;
&lt;li&gt;如果应用的 primaryCpuAbi 属性为空，那么以 ro.product.cpu.abilist 列表中第一个 abi 值作为应用的 primaryCpuAbi；&lt;/li&gt;
&lt;li&gt;运行在 64 位的 abi 有：arm64-v8a，mips64，x86_64&lt;/li&gt;
&lt;li&gt;运行在 32 位的 abi 有：armeabi-v7a，armeabi，mips，x86&lt;/li&gt;
&lt;li&gt;通常支持 arm64-v8a 的 64 位设备，都会向下兼容支持 32 位的 abi 运行；&lt;/li&gt;
&lt;li&gt;但应用运行期间，不能混合着使用不同 abi 的 so 文件；&lt;/li&gt;
&lt;li&gt;比如，当应用运行在 64 位进程中时，无法使用 32 位 abi 的 so 文件，同样，应用运行在 32 位进程中时，也无法使用 64 位 abi 的 so 文件；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/csdn_of_coder/article/details/52892266&quot;&gt;1.Android -- 系统进程Zygote的启动分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/itachi85/article/details/64123035&quot;&gt;2.Android应用程序进程启动过程（前篇）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/hp910315/article/details/51733410&quot;&gt;3.如何查找native方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_40107510/article/details/78138874&quot;&gt;4.Android中app进程ABI确定过程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/canney_chen/article/details/50633982&quot;&gt;5.Android 64 bit SO加载机制&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;大家好，我是 dasu，欢迎关注我的公众号（dasuAndroidTv），如果你觉得本篇内容有帮助到你，可以转载但记得要关注，要标明原文哦，谢谢支持~&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1924341-d7190704b160d280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dasuAndroidTv2.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Oct 2018 07:17:00 +0000</pubDate>
<dc:creator>请叫我大苏</dc:creator>
<og:description>最近碰到一些 so 文件问题，顺便将相关知识点梳理一下。 提问 本文的结论是跟着 一层层源码走进去，个人对其的理解所整理的，那么开始看源码之前，先来提几个问题： Q1：你知道 so 文件的加载流程吗？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dasusu/p/9810673.html</dc:identifier>
</item>
<item>
<title>gops —— Go 程序诊断分析工具 - 舆图易稿</title>
<link>http://www.cnblogs.com/shockerli/p/golang-tool-gops.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shockerli/p/golang-tool-gops.html</guid>
<description>&lt;blockquote readability=&quot;5.3064516129032&quot;&gt;
&lt;p&gt;GitHub: &lt;a href=&quot;https://github.com/google/gops&quot; class=&quot;uri&quot;&gt;https://github.com/google/gops&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一个用于列出和诊断分析系统中正在运行的 Go 程序的命令行工具&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;go get -u github.com/google/gops&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;命令帮助&quot;&gt;命令帮助&lt;/h2&gt;
&lt;p&gt;执行 &lt;code&gt;gops help&lt;/code&gt; 查看帮助文档：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;gops is a tool to list and diagnose Go processes.

    gops &amp;lt;cmd&amp;gt; &amp;lt;pid|addr&amp;gt; ...
    gops &amp;lt;pid&amp;gt; # displays process info

Commands:
    stack           Prints the stack trace.
    gc              Runs the garbage collector and blocks until successful.
    setgc           Sets the garbage collection target percentage.
    memstats        Prints the allocation and garbage collection stats.
    version         Prints the Go version used to build the program.
    stats           Prints the vital runtime stats.
    help            Prints this help text.

Profiling commands:
    trace           Runs the runtime tracer for 5 secs and launches &quot;go tool trace&quot;.
    pprof-heap      Reads the heap profile and launches &quot;go tool pprof&quot;.
    pprof-cpu       Reads the CPU profile and launches &quot;go tool pprof&quot;.


All commands require the agent running on the Go process.
Symbol &quot;*&quot; indicates the process runs the agent.&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用详解&quot;&gt;使用详解&lt;/h2&gt;
&lt;p&gt;为了能更好的分析程序，需要在我们的项目中加一行 &lt;code&gt;agent&lt;/code&gt; 诊断分析代码，用于统计分析程序问题。&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;package main

import (
    &quot;log&quot;
    &quot;time&quot;

    &quot;github.com/google/gops/agent&quot;
)

func main() {
    if err := agent.Listen(agent.Options{}); err != nil {
        log.Fatal(err)
    }

    time.Sleep(time.Hour)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;agent.&lt;/code&gt; 支持更多的参数：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// Code reference: github.com/google/gops/agent/agent.go:42

// Options allows configuring the started agent.
type Options struct {
    // Addr is the host:port the agent will be listening at.
    // Optional.
    Addr string

    // ConfigDir is the directory to store the configuration file,
    // PID of the gops process, filename, port as well as content.
    // Optional.
    ConfigDir string

    // ShutdownCleanup automatically cleans up resources if the
    // running process receives an interrupt. Otherwise, users
    // can call Close before shutting down.
    // Optional.
    ShutdownCleanup bool
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Addr&lt;/p&gt;
&lt;p&gt;可选。为远程分析服务提供监听地址，例如: &lt;code&gt;:9119&lt;/code&gt;。配置了该项，那我们可以在本机查看分析远程服务器上的 Go 程序，非常有帮助。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ConfigDir&lt;/p&gt;
&lt;p&gt;可选。用于存放统计数据和配置的目录，默认为当前用户的主目录。也可以通过环境变量&lt;code&gt;GOPS_CONFIG_DIR&lt;/code&gt;设置。具体参考代码：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;const gopsConfigDirEnvKey = &quot;GOPS_CONFIG_DIR&quot;

func ConfigDir() (string, error) {
    if configDir := os.Getenv(gopsConfigDirEnvKey); configDir != &quot;&quot; {
        return configDir, nil
    }

    if runtime.GOOS == &quot;windows&quot; {
        return filepath.Join(os.Getenv(&quot;APPDATA&quot;), &quot;gops&quot;), nil
    }
    homeDir := guessUnixHomeDir()
    if homeDir == &quot;&quot; {
        return &quot;&quot;, errors.New(&quot;unable to get current user home directory: os/user lookup failed; $HOME is empty&quot;)
    }
    return filepath.Join(homeDir, &quot;.config&quot;, &quot;gops&quot;), nil
}

func guessUnixHomeDir() string {
    usr, err := user.Current()
    if err == nil {
        return usr.HomeDir
    }
    return os.Getenv(&quot;HOME&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;: 如果不加 &lt;code&gt;agent&lt;/code&gt; 代码，那我们无法更深入的诊断程序，也就是说无法执行&lt;code&gt;gops memstats&lt;/code&gt;、&lt;code&gt;gops pprof-heap&lt;/code&gt;等所有类似于 &lt;code&gt;gops &amp;lt;cmd&amp;gt; &amp;lt;pid|addr&amp;gt; ...&lt;/code&gt; 的子命令。&lt;/p&gt;
&lt;h3 id=&quot;gops&quot;&gt;gops&lt;/h3&gt;
&lt;p&gt;直接执行 &lt;code&gt;gops&lt;/code&gt; 命令会列出本机所有正在运行的 Go 程序。&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;$ gops

99288 47636 go    go1.10.1 /usr/local/Cellar/go/1.10.1/libexec/bin/go
99300 99288 main* go1.10.1 /private/var/folders/cs/mfl4k8t54_g1thdzvzkdxbbr0000gn/T/go-build375822490/b001/exe/main
99570 2899  gops  go1.10.1 /Users/shocker/gowork/bin/gops
99154 14655 hugo  go1.11.1 /usr/local/Cellar/hugo/0.49.1/bin/hugo&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该命令会显示以下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PID&lt;/li&gt;
&lt;li&gt;PPID&lt;/li&gt;
&lt;li&gt;程序名称&lt;/li&gt;
&lt;li&gt;构建该程序的 Go 版本号&lt;/li&gt;
&lt;li&gt;程序所在绝对路径&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意，列表中有个程序名称后面带了个 &lt;code&gt;*&lt;/code&gt;，表示该程序加入了 &lt;code&gt;gops&lt;/code&gt; 的诊断分析代码。&lt;/p&gt;
&lt;h3 id=&quot;gops-pid&quot;&gt;gops &lt;code&gt;&amp;lt;pid&amp;gt;&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用法: &lt;code&gt;gops &amp;lt;pid&amp;gt;&lt;/code&gt;&lt;br/&gt;查看本机指定 &lt;code&gt;PID&lt;/code&gt; Go 程序的基本信息&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;$ gops 99300

parent PID: 99288
threads:    11
memory usage:   0.157%
cpu usage:  0.013%
username:   shocker
cmd+args:   /var/folders/cs/mfl4k8t54_g1thdzvzkdxbbr0000gn/T/go-build375822490/b001/exe/main
local/remote:   *:9105 &amp;lt;-&amp;gt; :0 (LISTEN)
local/remote:   127.0.0.1:57109 &amp;lt;-&amp;gt; 127.0.0.1:3306 (ESTABLISHED)
local/remote:   *:8000 &amp;lt;-&amp;gt; :0 (LISTEN)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;local/remote&lt;/code&gt; 表示本机建立的监听(LISTEN)，或者与远程服务器建立的链接(ESTABLISHED)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;local/remote: *:9105 &amp;lt;-&amp;gt; :0 (LISTEN)&lt;/code&gt; 中的 &lt;code&gt;*:9105&lt;/code&gt; 是 &lt;code&gt;gops/agent&lt;/code&gt; 提供的服务，&lt;/p&gt;
&lt;h3 id=&quot;gops-tree&quot;&gt;gops tree&lt;/h3&gt;
&lt;p&gt;用法: &lt;code&gt;gops tree&lt;/code&gt;&lt;br/&gt;以目录树的形式展示所有 Go 程序。&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;$ gops tree

...
├── 2899
│   └── 99996 (gops) {go1.10.1}
├── 47636
│   └── 99288 (go) {go1.10.1}
│       └── [*]  99300 (main) {go1.10.1}
└── 14655
    └── 99154 (hugo) {go1.11.1}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gops-stack-pidaddr&quot;&gt;gops stack &lt;code&gt;(&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用法: &lt;code&gt;gops stack (&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;br/&gt;用于显示程序所有堆栈信息，包括每个 goroutine 的堆栈信息、运行状态、运行时长等。&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;$ gops stack 99300

goroutine 7 [running]:
runtime/pprof.writeGoroutineStacks(0x1882720, 0xc4202b8010, 0xd0, 0xd0)
    /usr/local/Cellar/go/1.10.1/libexec/src/runtime/pprof/pprof.go:650 +0xa7
runtime/pprof.writeGoroutine(0x1882720, 0xc4202b8010, 0x2, 0x30, 0xc420068248)
    /usr/local/Cellar/go/1.10.1/libexec/src/runtime/pprof/pprof.go:639 +0x44

goroutine 1 [IO wait, 9 minutes]:
internal/poll.runtime_pollWait(0x1db4da0, 0x72, 0x0)
    /usr/local/Cellar/go/1.10.1/libexec/src/runtime/netpoll.go:173 +0x57
internal/poll.(*pollDesc).wait(0xc4201e7318, 0x72, 0x0, 0x0, 0x0)

# more ...&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gops-memstats-pidaddr&quot;&gt;gops memstats &lt;code&gt;(&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用法: &lt;code&gt;gops memstats (&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;br/&gt;查看程序的内存统计信息&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;$ gops memstats 127.0.0.1:9105

alloc: 1.36MB (1428632 bytes)
total-alloc: 10.21MB (10709376 bytes)
sys: 9.07MB (9509112 bytes)
lookups: 91
mallocs: 102818
frees: 91896
heap-alloc: 1.36MB (1428632 bytes)
heap-sys: 5.22MB (5472256 bytes)
heap-idle: 2.34MB (2457600 bytes)
heap-in-use: 2.88MB (3014656 bytes)
heap-released: 0 bytes
heap-objects: 10922
stack-in-use: 704.00KB (720896 bytes)
stack-sys: 704.00KB (720896 bytes)
stack-mspan-inuse: 47.95KB (49096 bytes)
stack-mspan-sys: 80.00KB (81920 bytes)
stack-mcache-inuse: 6.78KB (6944 bytes)
stack-mcache-sys: 16.00KB (16384 bytes)
other-sys: 1.21MB (1266624 bytes)
gc-sys: 492.00KB (503808 bytes)
next-gc: when heap-alloc &amp;gt;= 4.00MB (4194304 bytes)
last-gc: 2018-10-18 13:37:04.37511973 +0800 CST
gc-pause-total: 9.209158ms
gc-pause: 52831
num-gc: 60
enable-gc: true
debug-gc: false&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gops-gc-pidaddr&quot;&gt;gops gc &lt;code&gt;(&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用法: &lt;code&gt;gops gc (&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;br/&gt;查看指定程序的垃圾回收(GC)信息&lt;/p&gt;
&lt;h3 id=&quot;gops-setgc-pidaddr&quot;&gt;gops setgc &lt;code&gt;(&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用法: &lt;code&gt;gops setgc (&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;br/&gt;设定指定程序的 GC 目标百分比&lt;/p&gt;
&lt;h3 id=&quot;gops-version-pidaddr&quot;&gt;gops version &lt;code&gt;(&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用法: &lt;code&gt;gops version (&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;br/&gt;查看指定程序构建时的 Go 版本号&lt;/p&gt;
&lt;h3 id=&quot;gops-stats-pidaddr&quot;&gt;gops stats &lt;code&gt;(&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用法: &lt;code&gt;gops stats (&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;br/&gt;查看指定程序的 &lt;code&gt;goroutine&lt;/code&gt; 数量、&lt;code&gt;GOMAXPROCS&lt;/code&gt; 值等信息&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;$ gops stats 127.0.0.1:9105

goroutines: 11
OS threads: 14
GOMAXPROCS: 4
num CPU: 4&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gops-pprof-cpu-pidaddr&quot;&gt;gops pprof-cpu &lt;code&gt;(&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用法: &lt;code&gt;gops pprof-cpu (&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;br/&gt;调用并展示 &lt;code&gt;go tool pprof&lt;/code&gt; 工具中关于 CPU 的性能分析数据，操作与 &lt;code&gt;pprof&lt;/code&gt; 一致。&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;$ gops pprof-cpu 99300

Profiling CPU now, will take 30 secs...
Profile dump saved to: /var/folders/cs/mfl4k8t54_g1thdzvzkdxbbr0000gn/T/profile881383738
Profiling dump saved to: /var/folders/cs/mfl4k8t54_g1thdzvzkdxbbr0000gn/T/profile881383738
Binary file saved to: /var/folders/cs/mfl4k8t54_g1thdzvzkdxbbr0000gn/T/binary970030929
File: binary970030929
Type: cpu
Time: Oct 18, 2018 at 2:43pm (CST)
Duration: 30s, Total samples = 0
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gops-pprof-heap-pidaddr&quot;&gt;gops pprof-heap &lt;code&gt;(&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用法: &lt;code&gt;gops pprof-heap (&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;br/&gt;调用并展示 &lt;code&gt;go tool pprof&lt;/code&gt; 工具中关于 heap 的性能分析数据，操作与 &lt;code&gt;pprof&lt;/code&gt; 一致。&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;$ gops pprof-heap 99300

Profile dump saved to: /var/folders/cs/mfl4k8t54_g1thdzvzkdxbbr0000gn/T/profile045800436
Profiling dump saved to: /var/folders/cs/mfl4k8t54_g1thdzvzkdxbbr0000gn/T/profile045800436
Binary file saved to: /var/folders/cs/mfl4k8t54_g1thdzvzkdxbbr0000gn/T/binary315133123
File: binary315133123
Type: inuse_space
Time: Oct 18, 2018 at 2:46pm (CST)
Entering interactive mode (type &quot;help&quot; for commands, &quot;o&quot; for options)
(pprof)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gops-trace-pidaddr&quot;&gt;gops trace &lt;code&gt;(&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;用法: &lt;code&gt;gops trace (&amp;lt;pid&amp;gt;|&amp;lt;addr&amp;gt;)&lt;/code&gt;&lt;br/&gt;追踪程序运行5秒，生成可视化报告，并可在浏览器中查看: &lt;a href=&quot;http://127.0.0.1:61380/&quot; class=&quot;uri&quot;&gt;http://127.0.0.1:61380&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;$ gops trace 99300

Tracing now, will take 5 secs...
Trace dump saved to: /var/folders/cs/mfl4k8t54_g1thdzvzkdxbbr0000gn/T/trace136310737
2018/10/18 14:49:06 Parsing trace...
2018/10/18 14:49:06 Serializing trace...
2018/10/18 14:49:06 Splitting trace...
2018/10/18 14:49:06 Opening browser. Trace viewer is listening on http://127.0.0.1:61380&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;1.2068965517241&quot;&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;https://shockerli.net/post/golang-tool-gops/&quot; class=&quot;uri&quot;&gt;https://shockerli.net/post/golang-tool-gops/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 18 Oct 2018 07:17:00 +0000</pubDate>
<dc:creator>舆图易稿</dc:creator>
<og:description>一个用于列出和诊断分析系统中正在运行的 Go 程序的命令行工具</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shockerli/p/golang-tool-gops.html</dc:identifier>
</item>
<item>
<title>一个奇怪的现象，不知道正在看博客的你有没有注意？？？？？？ - 枫叶、</title>
<link>http://www.cnblogs.com/qq376324789/p/9810649.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qq376324789/p/9810649.html</guid>
<description>&lt;p&gt;&lt;span&gt; &lt;strong&gt;本人也是只要一有时间就大部分呆在博客里面了，最近发现了一个奇怪的现象！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;       &lt;/strong&gt;我也不知道从什么时候开始。谁提出的？谁先开始的？还是出于爱学习？更快知道新的技术动态？还是为了记好笔记？等等一系列的原因。。。。。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       就似乎大部分程序猿都会在某个社区，某个网站，某个博客进行查资料，记笔记，写博客了，当然这一切都看起来似乎并没有什么异常对吧，就是为了更&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;快的找到问题的答案，记好每一个要记得笔记，也确实方便了别人也方便了自己，也确实因为有了博客让很多人学习起来也简单了一些。。。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;问题来了&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;     &lt;/strong&gt;  因为我也是经常查看博客园首页以及一些好的文章和技术介绍以及案例，项目中忘记的知识点也会自觉的来博客园查找。所以对博客园也算是比较熟悉了，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最近眼角一亮，我就发现为什么大家阅读最多的并不是什么多难的技术原理和技术案例，而是程序猿的事迹呀一些感想什么的，到这里是不是觉得很不可思议，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;O(∩_∩)O哈哈~，再看看48小时阅读排行，一眼望去基本大多数阅读量高的都是一些技术以外的内容，当然也有少数写的比较好的技术知识o(*￣︶￣*)o。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;当然即使这样，也并不是代表我们看博客没有进步了。。o(*￣︶￣*)o&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;       &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;到这里我只是觉得有些惊讶，我们开始进入博客的时候最初是为了更好的学习，学习更多别人的经验和技术对吧，但是到现在好像更多的是进来弥补自己的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;焦虑吧，貌似每个人的心中都存在一份焦虑，也是否体现了我们整日对着代码，其实内心已经对它没有多少兴趣了。反倒对一些程序猿的事迹和感想更加感兴趣，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然还有一个好的证明，你作为一名程序猿有时间来看别人的感想和经历，其实说明你是在思考人生的，同时技术上应该是可以完成工作中的基本开发了吧o(*￣︶￣*)o&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不然你不忙着焦头烂耳的去查资料看案例哪有时间来看这些感想对吧O(∩_∩)O哈哈~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     我想这一现象更像是我们写代码的整个过程到结果了，我们看那些事迹是不是让代码人生多了一丝明白，就像写代码一样。百分之80的时候在思考如何写，真&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正&lt;/span&gt;&lt;span&gt;写代码的时间并没有那么多吧，人生也许是这样吧，大部分时间都在思考如何走，真正选择要怎么走的时间只是短短的一瞬间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      整日对着代码确实也有一些乏味，至于学习新的技术吧，好像真正能通过一篇文章就看懂的知识也并不多吧，大部分时候只是有一些问题出现了。来博客找找答&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;案，而且对于日常工作中也并不是每个功能都需要使用新的技术吧，真正要学习技术的时候，我想还是应该去官网看看，或者看看书和视频了。然而大部分人进来逛&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;博客就好像是看到什么就点进去了吧，看一些带技术的标题吧，一眼看过去也不知道是啥。。。O(∩_∩)O哈哈~。。。然后就没有耐心的点出去了。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Oct 2018 07:14:00 +0000</pubDate>
<dc:creator>枫叶、</dc:creator>
<og:description>本人也是只要一有时间就大部分呆在博客里面了，最近发现了一个奇怪的现象！！！ 我也不知道从什么时候开始。谁提出的？谁先开始的？还是出于爱学习？更快知道新的技术动态？还是为了记好笔记？等等一系列的原因。。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qq376324789/p/9810649.html</dc:identifier>
</item>
<item>
<title>使用flask_limiter设定API配额 - 从零开始的程序员生活</title>
<link>http://www.cnblogs.com/lgjbky/p/9810606.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lgjbky/p/9810606.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;闲来无事，突然想到了以前做过的关于后台API安全方面的事，关于接口访问配额的设置，flask有没有很好的库支持呢？一找还真有！主要是对照了库的官方文档自己写了下dome，以供参考。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# -*- coding:utf-8 -*-

import json
from flask import Flask, jsonify, request
from flask_limiter import Limiter, HEADERS  # https://github.com/alisaifee/flask-limiter
from flask_limiter.util import get_remote_address

# import limits.storage   # https://github.com/alisaifee/limits/tree/master/limits    依赖了这个limits库

RATELIMIT_STORAGE_URL = &quot;redis://172.16.4.120:6379&quot;  # 将被限制不可以再正常访问的请求放入缓存
app = Flask(__name__)


@app.after_request
def after_request(response):
    response.headers['Content-Type'] = 'text/html'  # 避免ie8把json数据以下载方式打开
    return response


limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=[&quot;200 per day&quot;, &quot;50 per hour&quot;],
    storage_uri=RATELIMIT_STORAGE_URL,
    headers_enabled=True  # X-RateLimit写入响应头。
)
&quot;&quot;&quot;
root@(none):~# curl -v &quot;http://172.16.2.197:6000/index4&quot;
* Hostname was NOT found in DNS cache
*   Trying 172.16.2.197...
* Connected to 172.16.2.197 (172.16.2.197) port 6000 (#0)
&amp;gt; GET /index4 HTTP/1.1
&amp;gt; User-Agent: curl/7.35.0
&amp;gt; Host: 172.16.2.197:6000
&amp;gt; Accept: */*
&amp;gt; 
* HTTP 1.0, assume close after body
&amp;lt; HTTP/1.0 200 OK
&amp;lt; Content-Type: text/html
&amp;lt; X-RateLimit-Limit: 2
&amp;lt; X-RateLimit-Remaining: 1
&amp;lt; X-RateLimit-Reset: 1539849353
# X-RateLimit-Limit 活动窗口允许的请求总数
# X-RateLimit-Remaining 活动窗口中剩余的请求数。
# X-RateLimit-Reset 自重建窗口以来的UTC时间以来的UTC秒数。
&amp;lt; Retry-After: 3600
&amp;lt; Content-Length: 32
&amp;lt; Server: Werkzeug/0.14.1 Python/2.7.9
&amp;lt; Date: Thu, 18 Oct 2018 06:55:52 GMT
&amp;lt; 
{
  &quot;response&quot;: &quot;mysql_limit&quot;
}
&quot;&quot;&quot;


@app.route(&quot;/slow&quot;)
@limiter.limit(&quot;1 per day&quot;)
def slow():
    return &quot;24&quot;


# curl -v &quot;http://172.16.2.197:6000/slow&quot;
# 127.0.0.1:6379&amp;gt; keys *
# 1) &quot;LIMITER/172.16.4.120/slow/1/1/day&quot;
# 127.0.0.1:6379&amp;gt; TTL &quot;LIMITER/172.16.4.120/slow/1/1/day&quot;
# (integer) 86285       # 设定的失效时间是 1 天

@app.route(&quot;/fast&quot;)  # 默认访问速率
def fast():
    return &quot;42&quot;


@app.route(&quot;/ping&quot;)
@limiter.exempt  # 无访问速率限制
def ping():
    return &quot;PONG&quot;


@app.route(&quot;/&quot;)
@limiter.limit(&quot;1/second&quot;, error_message='chill!')
@limiter.limit(&quot;100/day&quot;)
@limiter.limit(&quot;10/hour&quot;)
@limiter.limit(&quot;1/minute&quot;)
def index():
    return &quot;index&quot;


# curl -v &quot;http://172.16.2.197:6000/&quot; # 访问了一次就触发了下面三条redis记录，清理掉redis记录，可以一分钟内再次访问
# 127.0.0.1:6379&amp;gt; keys *
# 2) &quot;LIMITER/172.16.4.120/index/10/1/hour&quot;
# 3) &quot;LIMITER/172.16.4.120/index/100/1/day&quot;
# 4) &quot;LIMITER/172.16.4.120/index/1/1/minute&quot;


@app.route('/index0')
@limiter.limit(&quot;100/30seconds&quot;, error_message=json.dumps({&quot;data&quot;: &quot;You hit the rate limit&quot;, &quot;error&quot;: 429}))
def index0():
    return jsonify({'response': 'This is a rate limited response'})


@app.route('/index2')
@limiter.limit(&quot;100/day;10/hour;1/minute&quot;)  # 与index()同功效
def index2():
    return jsonify({'response': 'Are we rated limited?'})


@app.route('/index3')
@limiter.exempt
def index3():
    return jsonify({'response': 'We are not rate limited'})


@app.route(&quot;/expensive&quot;)  # exempt_when=callable 当满足给定条件时，可以免除限制
@limiter.limit(&quot;1/day&quot;, exempt_when=lambda: get_remote_address() == &quot;172.16.4.120&quot;)
def expensive_route():
    return jsonify({'response': 'you are wellcome!'})


# 多个路由应共享速率限制的情况（例如，访问有限速率的相同资源保护路由时）
mysql_limit = limiter.shared_limit(&quot;2/hour&quot;, scope=&quot;mysql_flag&quot;)
# 3) &quot;LIMITER/172.16.4.120/mysql_flag/2/1/hour&quot;

@app.route('/index4')
@mysql_limit
def index4():
    return jsonify({'response': 'mysql_limit'})


@app.route('/index5')
@mysql_limit
def index5():
    return jsonify({'response': 'mysql_limit'})


def host_scope(endpoint_name):
    return request.host

# 动态共享限制
host_limit = limiter.shared_limit(&quot;2/hour&quot;, scope=host_scope)
# 1) &quot;LIMITER/172.16.4.120/172.16.2.197:6000/2/1/hour&quot;

@app.route('/index6')
@host_limit
def index6():
    return jsonify({'response': 'host_limit'})


@app.route('/index7')
@host_limit
def index7():
    return jsonify({'response': 'host_limit'})


# @limiter.request_filter这个装饰器只是将一个函数标记为将要测试速率限制的请求的过滤器。如果任何请求过滤器返回True，
# 则不会对该请求执行速率限制。此机制可用于创建自定义白名单。

@limiter.request_filter
def ip_whitelist():
    return request.remote_addr == &quot;127.0.0.1&quot;


@limiter.request_filter
def header_whitelist():
    return request.headers.get(&quot;X-Internal&quot;, &quot;&quot;) == &quot;true&quot;


if __name__ == &quot;__main__&quot;:
    app.run(host='0.0.0.0', port=6000, threaded=True)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;diy简陋版&quot;&gt;DIY简陋版&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# -*- coding:utf-8 -*-
__author__ = &quot;aleimu&quot;
__date__ = &quot;2018.9.28&quot;

# 限制接口短时间调用次数

import redis
import time
from flask import Flask, jsonify, request
from functools import wraps

REDIS_DB = 0
REDIS_HOST = '172.16.4.120'
REDIS_PORT = 6379
REDIS_PASSWORD = ''
IP_LIMIT = 10
TIME_LIMIT = 60

app = Flask(__name__)
r = redis.StrictRedis(host=REDIS_HOST, port=REDIS_PORT, password=REDIS_PASSWORD, db=REDIS_DB, socket_timeout=3000)


@app.before_request  # app 装饰器，会对每一个请求都生效
def before_request():
    ip = request.remote_addr
    ip_count = r.get(ip)
    print(&quot;ip: %s, ip_count: %s&quot; % (ip, ip_count))
    if not ip_count:
        r.set(ip, 1)
        r.expire(ip, TIME_LIMIT)
    else:
        r.incr(ip)  # 将 key 中储存的数字值增一
        if int(ip_count) &amp;gt; IP_LIMIT:
            return jsonify({'code': 401, 'status': &quot;reach the ip limit&quot;, 'message': {}})


# 装饰器 一份钟内限制访问10次，本地缓存
def stat_called_time(func):
    limit_times = [10]  # 这是一个技巧，装饰器内的变量继承每次调用后的变化，变量就必须设置为可变类型
    cache = {}

    @wraps(func)
    def _called_time(*args, **kwargs):
        key = func.__name__
        if key in cache.keys():
            [call_times, updatetime] = cache[key]
            if time.time() - updatetime &amp;lt; TIME_LIMIT:
                cache[key][0] += 1
            else:
                cache[key] = [1, time.time()]
        else:
            call_times = 1
            cache[key] = [call_times, time.time()]
        print('调用次数: %s' % cache[key][0])
        print('限制次数: %s' % limit_times[0])
        if cache[key][0] &amp;lt;= limit_times[0]:
            res = func(*args, **kwargs)
            cache[key][1] = time.time()
            return res
        else:
            print(&quot;超过调用次数了&quot;)
            return jsonify({'code': 401, 'status': &quot;reach the limit&quot;, 'message': {}})

    return _called_time


@app.route(&quot;/call&quot;)
@stat_called_time
def home():
    return jsonify({'code': 200, 'status': &quot;&quot;, 'message': {}})


@app.route(&quot;/&quot;)
def index():
    return jsonify({'code': 200, 'status': &quot;&quot;, 'message': {}})


if __name__ == &quot;__main__&quot;:
    app.run(host='0.0.0.0', port=5000, threaded=True)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参考文档&quot;&gt;参考文档&lt;/h3&gt;
&lt;p&gt;https://flask-limiter.readthedocs.io/en/stable/ # 主要来源&lt;br/&gt;https://github.com/search?l=Python&amp;amp;q=flask_limiter+&amp;amp;type=Code # 参考&lt;/p&gt;
</description>
<pubDate>Thu, 18 Oct 2018 07:09:00 +0000</pubDate>
<dc:creator>从零开始的程序员生活</dc:creator>
<og:description>前言 闲来无事，突然想到了以前做过的关于后台API安全方面的事，关于接口访问配额的设置，flask有没有很好的库支持呢？一找还真有！主要是对照了库的官方文档自己写了下dome，以供参考。 DIY简陋版</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lgjbky/p/9810606.html</dc:identifier>
</item>
<item>
<title>自学Python5.1-面向对象与面向过程 - CARLOS_CHIANG</title>
<link>http://www.cnblogs.com/yaoyaojcy/p/9810588.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaoyaojcy/p/9810588.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yaoyaojcy/p/7418003.html&quot; target=&quot;_blank&quot;&gt;自学Python之路&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;面向过程：根据业务逻辑从上到下写代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;优点：&lt;/span&gt;性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 &lt;/p&gt;
&lt;p&gt;   &lt;span&gt;缺点：&lt;/span&gt;没有面向对象易维护、易复用、易扩展。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面向对象：将数据与函数绑定在一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;优点：&lt;/span&gt;易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护。  &lt;/p&gt;
&lt;p&gt;   &lt;span&gt;缺点：&lt;/span&gt;性能比面向过程低&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、面向过程&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;面向过程？面向过程就是面向解决问题的过程进行编程。&lt;/p&gt;
&lt;p&gt;我们在学习和工作中，当我们去实现某项功能或完成某项任务时，是不是会不自觉的按部就班的罗列出我们要做的事情？（如果没有，建议以后试着步骤化解决问题）。而当我们按着我们罗列的步骤去解决问题时，实质上就是按照面向过程的思想去解决问题。我们罗列的步骤就是过程，按照步骤解决问题就是面向过程。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;传统的面向过程的编程思想总结起来就八个字——&lt;strong&gt;自顶向下，逐步细化&lt;/strong&gt;！实现步骤如下：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将要实现的功能描述为一个从开始到结束按部就班的连续的步骤（过程）；&lt;/li&gt;
&lt;li&gt;依次逐步完成这些步骤，如果某一步的难度较大，又可以将该步骤再次细化为若干个子步骤，以此类推，一直到结束得到想要的结果；&lt;/li&gt;
&lt;li&gt;程序的主体是函数，一个函数就是一个封装起来的模块，可以实现一定的功能，各个子步骤往往就是通过各个函数来完成的，从而实现代码的重用和模块化编程！&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;案例：学生到校报道注册&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;面向过程流程图：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/861679/201610/861679-20161007123537457-257458173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;面向过程，就是按照我们分析好了的步骤，按部就班的依次执行就行了！所以当我们用面向过程的思想去编程或解决问题时，首先一定要把详细的实现过程弄清楚。一旦过程设计清楚，代码的实现简直轻而易举。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二、面向对象&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;所谓的面向对象，就是在编程的时候尽可能的去模拟真实的现实世界，按照现实世界中的逻辑去处理一个问题，分析问题中参与其中的有&lt;strong&gt;哪些实体&lt;/strong&gt;，这些实体应该&lt;strong&gt;有什么属性和方法&lt;/strong&gt;，我们&lt;strong&gt;如何通过调用这些实体的属性和方法&lt;/strong&gt;去解决问题。&lt;/p&gt;
&lt;p&gt;现实世界中，任何一个操作或者是业务逻辑的实现都需要一个实体来完成，也就是说，&lt;strong&gt;实体就是动作的支配者&lt;/strong&gt;，没有实体，就肯定没有动作发生！&lt;/p&gt;
&lt;p&gt;　　现在让我们思考下，上述注册报名的每一个步骤都有哪些动词？&lt;/p&gt;
&lt;p&gt;　　提出 提供 缴 收 获得 分配 增加&lt;/p&gt;
&lt;p&gt;　　有动词就一定有实现这个动作的实体！&lt;/p&gt;
&lt;p&gt;　　所谓的模拟现实世界，就是使计算机的编程语言在解决相关业务逻辑的方式，与真实的业务逻辑的发生保持一致！需要使每一个动作的背后都一个完成这个动作的实体！&lt;/p&gt;
&lt;p&gt;　　因为任何功能的实现都是依赖于一个具体的&lt;strong&gt;实体的“动作|操作|行动”，&lt;/strong&gt;可以看作是一个又一个的实体在发挥其各自的“能力”并在内部进行协调有序的调用过程！&lt;/p&gt;
&lt;p&gt;　　当采用面向对象的思想解决问题时，可分为下面几步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;分析哪些动作是由哪些实体发出的；&lt;/li&gt;
&lt;li&gt;定义这些实体，为其增加相应的属性和功能；&lt;/li&gt;
&lt;li&gt;让实体去执行相应的功能或动作。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　采用面向对象的思想，解决上面的报名问题，应该如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一步：分析那些动作是由哪些实体发出的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;学生提出报名&lt;/li&gt;
&lt;li&gt;学生缴费&lt;/li&gt;
&lt;li&gt;机构收费&lt;/li&gt;
&lt;li&gt;教师分配教室&lt;/li&gt;
&lt;li&gt;班级增加学生信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　于是，在整个过程中，一共有四个实体：&lt;/p&gt;
&lt;p&gt;　　学生、机构、教师、班级！&lt;/p&gt;
&lt;p&gt;　　在现实中的一个具体的实体，就是计算机编程中的一个对象！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二步：定义这些实体，为其增加相应的属性和功能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　属性就是实体在现实世界中的一些特征表现。如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;人的属性：姓名、性别、身高、三围、体重、电话号码、家庭住址、籍贯等&lt;/li&gt;
&lt;li&gt;手机的属性：品牌、价格、颜色、尺寸、待机时间等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　功能就是能完成的动作，在面向对象的术语中，动作就叫作方法或者函数。如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;人的动作（功能）：吃饭、睡觉、学习、打游戏、走路、跑步、缴费！&lt;/li&gt;
&lt;li&gt;手机的动作（功能）：打电话、发短信、拍照、打游戏、视频、看电影等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　下图显示了在上述实例中出现的实体以及相应的属性和功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/861679/201610/861679-20161007123915067-1551339576.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三步：让实体去执行相应的功能或动作&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;学生提出报名&lt;/li&gt;
&lt;li&gt;学生缴费&lt;/li&gt;
&lt;li&gt;学校收费&lt;/li&gt;
&lt;li&gt;教师分配教室&lt;/li&gt;
&lt;li&gt;班级增加学生信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　所以说，面向过程主要是针对功能，而面向对象主要是针对能够实现该功能的背后的实体。面向对象实质上就是面向实体，所以当我们使用面向对象进行编程时，一定要建立这样一个观念：万物皆对象！&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;三、面向对象和面向过程的比较&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;面向过程简单直接，易于入门理解，模块化程度较低。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面向对象相对于面向过程较为复杂，不易理解，模块化程度较高。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可总结为下面三点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;都可以实现代码重用和模块化编程，但是面对对象的模块化更深，数据更封闭，也更安全！因为面向对象的封装性更强！&lt;/li&gt;
&lt;li&gt;面对对象的思维方式更加贴近于现实生活，更容易解决大型的复杂的业务逻辑&lt;/li&gt;
&lt;li&gt;从前期开发角度上来看，面对对象远比面向过程要复杂，但是从维护和扩展功能的角度上来看，面对对象远比面向过程要简单！&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 18 Oct 2018 07:07:00 +0000</pubDate>
<dc:creator>CARLOS_CHIANG</dc:creator>
<og:description>自学Python之路 自学Python5.1-面向对象与面向过程 面向过程：根据业务逻辑从上到下写代码。 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaoyaojcy/p/9810588.html</dc:identifier>
</item>
<item>
<title>SpringBoot(10)  Servlet3.0的注解：自定义原生Servlet、自定义原生Listener - platycoden</title>
<link>http://www.cnblogs.com/platycoden/p/9810569.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/platycoden/p/9810569.html</guid>
<description>&lt;p&gt;一、自定义原生Servlet&lt;/p&gt;
&lt;p&gt;1、启动类里面增加注解 @ServletComponentScan&lt;/p&gt;
&lt;p&gt;2、Servlet上添加注解  @WebServlet(name = &quot;userServlet&quot;,urlPatterns = &quot;/v1/api/test/customs&quot;)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @WebServlet(name = &quot;userServlet&quot;,urlPatterns = &quot;/v1/api/test/customs&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserServlet &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; HttpServlet{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     @Override
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doGet(HttpServletRequest req, HttpServletResponse resp) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;          
&lt;span&gt; 7&lt;/span&gt;          resp.getWriter().print(&quot;custom sevlet&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;         resp.getWriter().flush();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;         resp.getWriter().close();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;     }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doPost(HttpServletRequest req, HttpServletResponse resp)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException, IOException {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.doGet(req, resp);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;二、自定义原生Listener&lt;/p&gt;
&lt;p&gt;常用的监听器 servletContextListener、httpSessionListener、servletRequestListener&lt;/p&gt;
&lt;p&gt;servletContextListener：服务启动，一般用于初始化加载&lt;/p&gt;
&lt;p&gt;servletRequestListener：访问启动，一般用于统计&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@WebListener
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomContextListner &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ServletContextListener{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; contextInitialized(ServletContextEvent sce) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         System.out.println(&quot;======contextInitialized========&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动时触发&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; contextDestroyed(ServletContextEvent sce) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.out.println(&quot;======contextDestroyed========&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@WebListener
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RequestListener &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ServletRequestListener {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; requestDestroyed(ServletRequestEvent sre) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;======requestDestroyed========&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; requestInitialized(ServletRequestEvent sre) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         System.out.println(&quot;======requestInitialized========&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 18 Oct 2018 07:05:00 +0000</pubDate>
<dc:creator>platycoden</dc:creator>
<og:description>一、自定义原生Servlet 1、启动类里面增加注解 @ServletComponentScan 2、Servlet上添加注解 @WebServlet(name = &quot;userSe</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/platycoden/p/9810569.html</dc:identifier>
</item>
</channel>
</rss>