<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>逆向知识之CS辅助/外挂专题.2.实现CS1.6无限夜视仪.无限闪光烟雾高爆弹. - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/9568964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/9568964.html</guid>
<description>&lt;p&gt;关于人物子弹无限可以观看上一篇博客.&lt;/p&gt;
&lt;h2&gt;一丶无限夜视仪.&lt;/h2&gt;
&lt;p&gt;无限夜视仪找法.&lt;/p&gt;
&lt;p&gt;　　　　1.CE附加游戏.&lt;/p&gt;
&lt;p&gt;　　　　2.搜索0或者1.&lt;/p&gt;
&lt;p&gt;　　　　3.修改夜视仪状态为开启或者关闭.&lt;/p&gt;
&lt;p&gt;　　　　4.CE继续搜索.&lt;/p&gt;
&lt;p&gt;　　　　5.筛选数据.&lt;/p&gt;
&lt;p&gt;关于搜索0或者1我们也不知道哪个是打开或者关闭. PS: 因为我找过了.确定了1是打开夜视仪.&lt;/p&gt;
&lt;p&gt;搜索到最后如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901012350960-1943123862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上图所示找到了一个地址.对其修改0或者1可以实现夜视仪的打开关闭.&lt;/p&gt;
&lt;p&gt;对其下访问断点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901012452631-1338953040.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以得出汇编代码使用了基址.所以确定这个是个基地址.  所以直接写入 0 关闭. 1打开即可.&lt;/p&gt;
&lt;h2&gt;二丶无限闪光高爆烟雾弹找法.&lt;/h2&gt;
&lt;p&gt;寻找思路:&lt;/p&gt;
&lt;p&gt;　　　　1.购买高爆&lt;/p&gt;
&lt;p&gt;　　　　2.CE搜索1&lt;/p&gt;
&lt;p&gt;　　　　3.丢掉高爆手雷&lt;/p&gt;
&lt;p&gt;　　　　4.CE搜索0&lt;/p&gt;
&lt;p&gt;　　　　5.循环1 2 3 4步骤.最终得出地址.&lt;/p&gt;
&lt;p&gt;　　　　6.对地址进行过滤.&lt;/p&gt;
&lt;p&gt;通过不断寻找得出以下CE图片&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901014038969-1571726438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对这些地址进行分析: PS: 因为分析过了.所以直接把第三个拉下来.看看谁访问了. (不然写博客写一大堆.不利于观看.手工都能做的)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901014202193-1218466068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS: 上图寻找方法是我先下谁访问了.然后进行手雷投掷.才会出现这种代码.选择下边的&lt;/p&gt;
&lt;p&gt;得出一级偏移 0x5f8&lt;/p&gt;
&lt;p&gt;但是细细的观看代码得出&lt;/p&gt;
&lt;p&gt;edx + ecx * 4 + 0x5f8&lt;/p&gt;
&lt;p&gt;          ecx = c&lt;/p&gt;
&lt;p&gt;　　  c * 4 + 0x5f8  才是我们真正的偏移地址.  算出来的偏移地址是 0x628&lt;/p&gt;
&lt;p&gt;那么我们继续寻找edx值即可.&lt;/p&gt;
&lt;p&gt;PS: 寻找到了.过滤一下.得到下面的图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901014659566-1404443306.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出+ 0x7c是我们的二级偏移. 人物基址我们上次已经找过了&lt;/p&gt;
&lt;p&gt;所以我们测试一下.&lt;/p&gt;
&lt;p&gt;[[[]基址] + 0x7c] + 0x628] = 无限高爆手雷地址&lt;/p&gt;
&lt;p&gt;CE中测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901014807210-282654680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;锁定&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901014836693-2037428174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现确实可以实现无限手雷.&lt;/p&gt;
&lt;p&gt;所以 0x 7c 0x628则是无限手雷的.&lt;/p&gt;
&lt;p&gt;经过测试&lt;/p&gt;
&lt;p&gt;0x624   = 无限闪光&lt;/p&gt;
&lt;p&gt;0x628   = 无限手雷&lt;/p&gt;
&lt;p&gt;0x62c   = 无限烟雾弹&lt;/p&gt;
&lt;h2&gt;三丶编写代码&lt;/h2&gt;
&lt;p&gt;通过上面寻找数据.我们已经找到数据了.所以直接在编程中实现. PS: 为了大家了解逆向应用.所以代码不放出.只会以成品显示.&lt;/p&gt;
&lt;p&gt;无限手雷闪光烟雾弹展示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901015316649-228893586.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;无限夜视仪展示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901015358484-1573030539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 31 Aug 2018 17:54:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<og:description>逆向知识之CS辅助/外挂专题.2.实现CS1.6无限夜视仪.无限闪光烟雾高爆弹. 关于人物子弹无限可以观看上一篇博客. 一丶无限夜视仪. 无限夜视仪找法. 1.CE附加游戏. 2.搜索0或者1. 3.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/9568964.html</dc:identifier>
</item>
<item>
<title>逆向知识之CS1.6辅助/外挂专题.1.实现CS1.6主武器副武器无限子弹 - iBinary</title>
<link>http://www.cnblogs.com/iBinary/p/9568940.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iBinary/p/9568940.html</guid>
<description>&lt;p&gt;　　　　　　　　　　　逆向知识之CS辅助/外挂专题.1.实现CS主武器副武器无限子弹&lt;/p&gt;
&lt;p&gt;PS: 相信大家CS1.6这类的FPS应该玩过.现在我们通过外挂手法.讲解逆向的本质.以及应用.&lt;/p&gt;
&lt;p&gt;关于CS1.6的下载.网络百度下载即可.&lt;/p&gt;
&lt;h2&gt;一丶主武器无限子弹寻找方法.&lt;/h2&gt;
&lt;p&gt;首先我们知道.在CS中主武器有子弹个数.那么我们可以通过CE寻找子弹的个数增加或者减少来进行寻找我们的数据. 关于CE的使用.可以参考网络教程.很简单.主需要来回扫描即可.&lt;/p&gt;
&lt;p&gt;寻找思路:&lt;/p&gt;
&lt;p&gt;　　　　1.首次扫描子弹个数&lt;/p&gt;
&lt;p&gt;　　　　2.变化子弹继续扫描.&lt;/p&gt;
&lt;p&gt;　　　　3.重复2步骤.直到地址很少.&lt;/p&gt;
&lt;p&gt;　　　　4.过滤数据. 可以下拉到地址框中.锁定数据.然后更改游戏中子弹个数看看是否更改.如果没有更改则找到数据.(当然要不断过滤)&lt;/p&gt;
&lt;p&gt;　　　　5.找到基址.如果是动态地址.找访问地址一层一层寻找动态基址.如果是写入.那么找写入.一层一层访问找到动态基址.&lt;/p&gt;
&lt;p&gt;通过扫描我们可以得到动态地址.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901005124098-1911335056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看看谁访问了.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901005232444-1697883709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过代码得知. 一级偏移是CC. 继续寻找esi&lt;/p&gt;
&lt;p&gt;CE搜索ESI的值.以16进制搜索.则寻找到动态地址,继续查看谁访问.得出下面CE的数值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901005354915-1682412099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上图的值. 得到二级偏移5EC  继续寻找esi的值.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901005541174-1218570272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上图得知 +7c,那么三级偏移是0x7c 我们随便点开一个.例如上图.是eax + 0x7c那么寻找eax&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901005647124-359360716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续搜索CE之后发现.有两个绿色的基址. 我们都下来下来看看. 加上我们的偏移. 看看是否是当前的子弹个数.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901005823825-2072080974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现添加之后两个地址都是91也就是我们现在子弹的个数.不能确定是哪个.所以过滤一下.&lt;/p&gt;
&lt;p&gt;1.锁定查看. 在CE中锁定地址.看看子弹是否减少. PS: 自己锁定过了.发现两种都可以.不排除两个都是地址.&lt;/p&gt;
&lt;p&gt;2.大退游戏重新开始.  这种方法试一试.                PS: 发现大退之后两种都可以. 所以基址可能是两个.都可以使用.&lt;/p&gt;
&lt;p&gt;至此我们已经找到了主武器无限子弹的基址+ 偏移了.&lt;/p&gt;
&lt;p&gt;[[[[基址] + 0x7c] + 0x5ec] + 0xcc] = 主武器子弹无限地址&lt;/p&gt;
&lt;p&gt;那么副武器也是类似的找的办法. 可以使用上面寻找.&lt;/p&gt;
&lt;p&gt;但是现在我们知道人物基址了.那么可以使用工具遍历一下.&lt;/p&gt;
&lt;p&gt;首先填入我们已知的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901010406916-1501867264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这款工具的使用.&lt;/p&gt;
&lt;p&gt;1.选择自己的进程&lt;/p&gt;
&lt;p&gt;2.填入基址 + 你想遍历的偏移.&lt;/p&gt;
&lt;p&gt;3.跟你你的偏移层级.选择你要遍历的 层级.比如一级遍历. 选中.然后我们选的三级偏移. 当然我们可以二级偏移给0.那么遍历二级偏移.这样的话那么偏移是基址 + 遍历偏移 + 固定偏移的形式来展示.&lt;/p&gt;
&lt;p&gt;什么意思:&lt;/p&gt;
&lt;p&gt;　　　　比如是我们的基址是0xxxxxxx 一级偏移是 0x1  二级偏移是0x2 三级偏移是0x3 那么我们只想遍历 二级偏移  + 三级偏移.但是我要让二级偏移可变怎么办.那么我们可以这样设置.&lt;/p&gt;
&lt;p&gt;　　　　　　基址 0xxxxx  一级偏移 0x1  二级偏移 0x0  三级偏移0x3  那么遍历出来的数据则是  基址 + 0x + 遍历的值 + 0x3  &lt;/p&gt;
&lt;p&gt;如果还不会使用没看明白.可以网络百度教程. 可以使用我们的笨方法来查找.&lt;/p&gt;
&lt;p&gt;根据上图我们得知. 我们主武器的基址加偏移已经填入了.那么直接遍历得出了72 (当前子弹个数)&lt;/p&gt;
&lt;p&gt;那么我们可以这样想.既然0xCC是子弹的地址. 那么 二级偏移 0x5ec有可能就是主武器对象了. 也就是说0x5ec存储的是主武器的属性值. 那么我们使用工具.遍历一下二级偏移 +0xCc看看有没有发现.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901011102280-1208780866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图我们的操作步骤.&lt;/p&gt;
&lt;p&gt;1.将二级偏移改为0&lt;/p&gt;
&lt;p&gt;2.遍历方式改成2级偏移遍历的方式.每次增长4个字节.遍历1000次.循环累加.&lt;/p&gt;
&lt;p&gt;3.点击开始遍历按钮.&lt;/p&gt;
&lt;p&gt;4.填入12.也就是我们当前的副武器子弹个数.&lt;/p&gt;
&lt;p&gt;5.点击筛选结果.&lt;/p&gt;
&lt;p&gt;操作完之后会得到上图所示.我们可以看到二级偏移0x5dc那么我们添加CE进去看看.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901011322995-1541053680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加之后我们锁定.发现子弹确实不减少.然后大退游戏重新打开.发现也不改变.所以这就是我们副武器的子弹无限了.&lt;/p&gt;
&lt;h2&gt;二丶编写代码.&lt;/h2&gt;
&lt;p&gt;编写代码就简单了.只需要 基址 + 偏移读出然后进行一直写入即可.&lt;/p&gt;
&lt;p&gt;主武器无限子弹基址:  [[[[0x25069bc] + 0x7c] + 0x5ec] + 0xcc]&lt;/p&gt;
&lt;p&gt; 副武器子弹无限基址: [[[[0x25069bc] + 0x7c] + 0x5dc] + 0xcc]&lt;/p&gt;
&lt;p&gt;代码实现可以是易语言可以是VC++. 因为属于外挂技术.所以给大家看看成品.但是不会公布写法.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1197364/201809/1197364-20180901011810417-1606045885.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 31 Aug 2018 17:19:00 +0000</pubDate>
<dc:creator>iBinary</dc:creator>
<og:description>逆向知识之CS辅助/外挂专题.1.实现CS主武器副武器无限子弹 PS: 相信大家CS1.6这类的FPS应该玩过.现在我们通过外挂手法.讲解逆向的本质.以及应用. 关于CS1.6的下载.网络百度下载即可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iBinary/p/9568940.html</dc:identifier>
</item>
<item>
<title>SwingBench 字符模式压测最佳实践 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/9568806.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/9568806.html</guid>
<description>&lt;p&gt;之前写过《&lt;a href=&quot;https://www.cnblogs.com/jyzhao/p/6185463.html&quot;&gt;使用SwingBench 对Oracle RAC DB性能 压力测试&lt;/a&gt;》，使用的是最基础直观的图形模式，已经可以满足大多数需求。&lt;/p&gt;
&lt;p&gt;但是在有些场景下，图形模式可能本身消耗资源过大，尤其在生成大量测试数据时，很可能会由于图形本身的不稳定导致卡死甚至直接中途退出，严重影响效率和测试体验。&lt;br/&gt;而如果采用静默模式，直接使用xml编辑又不能很好的确认改的是否正确。&lt;br/&gt;本文主要介绍下我在做某次压力测试时发现的小技巧。&lt;/p&gt;

&lt;p&gt;之前使用图形界面时，我们直接去执行 ./oewizard 即可调用图形界面按照提示一步步配置最终生成压力测试的数据。&lt;/p&gt;
&lt;p&gt;而使用字符模式，则需要指定参数配置文件以及一些必要的参数，先来看都有哪些参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[oracle@db50 bin]$ ./oewizard -h
usage: parameters:
 -allindexes             build all indexes for schema
 -bigfile                use big file tablespaces
 -c &amp;lt;filename&amp;gt;           wizard config file
 -cl                     run in character mode
 -compositepart          use a composite paritioning model if it exisits
 -compress               use default compression model if it exists
 -create                 create benchmarks schema
 -cs &amp;lt;connectString&amp;gt;     connectring for database
 -dba &amp;lt;username&amp;gt;         dba username for schema creation
 -dbap &amp;lt;password&amp;gt;        password for schema creation
 -debug                  turn on debugging output
 -debugf                 turn on debugging output to file (debug.log)
 -df &amp;lt;datafile&amp;gt;          datafile name used to create schema in
 -drop                   drop benchmarks schema
 -dt &amp;lt;driverType&amp;gt;        driver type (oci|thin)
 -g                      run in graphical mode (default)
 -generate               generate data for benchmark if available
 -h,--help               print this message
 -hashpart               use hash paritioning model if it exists
 -hcccompress            use HCC compression if it exisits
 -nocompress             don't use any database compression
 -noindexes              don't build any indexes for schema
 -nopart                 don't use any database partitioning
 -normalfile             use normal file tablespaces
 -oltpcompress           use OLTP compression if it exisits
 -p &amp;lt;password&amp;gt;           password for benchmark schema
 -part                   use default paritioning model if it exists
 -pkindexes              only create primary keys for schema
 -rangepart              use a range paritioning model if it exisits
 -s                      run in silent mode
 -scale &amp;lt;scale&amp;gt;          mulitiplier for default config
 -sp &amp;lt;soft partitions&amp;gt;   the number of softparitions used. Defaults to cpu
                         count
 -tc &amp;lt;thread count&amp;gt;      the number of threads(parallelism) used to
                         generate data. Defaults to cpus*2
 -ts &amp;lt;tablespace&amp;gt;        tablespace to create schema in
 -u &amp;lt;username&amp;gt;           username for benchmark schema
 -v                      run in verbose mode when running from command
                         line
 -version &amp;lt;version&amp;gt;      version of the benchmark to run
[oracle@db50 bin]$ &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际我这里测试，用到的参数有 -cl, -create, -c, -scale, -tc, -part&lt;br/&gt;其中-cl, -create是必须的；-c是指定某个xml配置文件，-scale是指纯数据量（是默认1G配置的多少倍），-tc是指并行度，-part是指分区。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./oewizard -cl -create -c oewizard.xml -scale 150 -tc 64 -part&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而关于oewizard.xml 这个配置文件，我只改了下面这部分的内容，其他保持不变：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;DefaultParameters&amp;gt;
   &amp;lt;Parameter Key=&quot;datatablespacesexists&quot; Value=&quot;true&quot;/&amp;gt;
   &amp;lt;Parameter Key=&quot;password&quot; Value=&quot;soe&quot;/&amp;gt;
   &amp;lt;Parameter Key=&quot;username&quot; Value=&quot;soe&quot;/&amp;gt;
   &amp;lt;Parameter Key=&quot;datafile&quot; Value=&quot;+DATA&quot;/&amp;gt;
   &amp;lt;Parameter Key=&quot;userexists&quot; Value=&quot;true&quot;/&amp;gt;
   &amp;lt;Parameter Key=&quot;connectionstring&quot; Value=&quot;//db50/jyzhao&quot;/&amp;gt;
   &amp;lt;Parameter Key=&quot;connectiontype&quot; Value=&quot;thin&quot;/&amp;gt;
   &amp;lt;Parameter Key=&quot;onlydropuser&quot; Value=&quot;false&quot;/&amp;gt;
   &amp;lt;Parameter Key=&quot;operation&quot; Value=&quot;create&quot;/&amp;gt;
   &amp;lt;Parameter Key=&quot;tablespace&quot; Value=&quot;SOE&quot;/&amp;gt;
   &amp;lt;Parameter Key=&quot;dbausername&quot; Value=&quot;sys as sysdba&quot;/&amp;gt;
   &amp;lt;Parameter Key=&quot;dbapassword&quot; Value=&quot;oracle&quot;/&amp;gt;
   &amp;lt;Parameter Key=&quot;output&quot; Value=&quot;Verbose&quot;/&amp;gt;
&amp;lt;/DefaultParameters&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要就是确认压测用户及密码，以及数据文件的创建位置、数据库连接字符串、数据库sys用户及密码这些项。&lt;br/&gt;而技巧就是，如果不确认自己的配置文件写的正确与否，可以先这样执行，带入对应的参数，调用图形走一遍check下所有配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./oewizard -c oewizard.xml -scale 150 -tc 64 -part&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;确认无误后，我这里由于生成的数据量很大，裸数据就150G，这还不算索引。所以采用后台执行的方式，并在执行前后记录一个时间：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--1.生成压测数据脚本
$ cat test150.sh 
date
echo &quot;=====Begin=====&quot;
./oewizard -cl -create -c oewizard.xml -scale 150 -tc 64 -part
echo &quot;=====End=====&quot;
date

--2.后台执行，输出日志
nohup sh test150.sh &amp;gt; test150.log &amp;amp;

--3.跟踪日志输出
tail -20f test150.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终花了将近4小时才生成完毕：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[oracle@yzdb1 bin]$ tail -20f test150.log 
Fri Aug 31 10:52:54 CST 2018
=====Begin=====
SwingBench Wizard
Author  :        Dominic Giles
Version :        2.5.0.971

Running in Lights Out Mode using config file : oewizard.xml

============================================
|           Datagenerator Run Stats        |
============================================
Connection Time                        0:00:00.005
Data Generation Time                   3:41:44.395
DDL Creation Time                      0:09:00.405
Total Run Time                         3:50:44.809
Rows Inserted per sec                      136,446
Data Generated (MB) per sec                   10.9
Actual Rows Generated                1,816,220,694


Post Creation Validation Report
===============================
The schema appears to have been created successfully.

Valid Objects
=============
Valid Tables : 'ORDERS','ORDER_ITEMS','CUSTOMERS','WAREHOUSES','ORDERENTRY_METADATA','INVENTORIES','PRODUCT_INFORMATION','PRODUCT_DESCRIPTIONS','ADDRESSES','CARD_DETAILS'
Valid Indexes : 'PRD_DESC_PK','PROD_NAME_IX','PRODUCT_INFORMATION_PK','PROD_SUPPLIER_IX','PROD_CATEGORY_IX','INVENTORY_PK','INV_PRODUCT_IX','INV_WAREHOUSE_IX','ORDER_PK','ORD_SALES_REP_IX','ORD_CUSTOMER_IX','ORD_ORDER_DATE_IX','ORD_WAREHOUSE_IX','ORDER_ITEMS_PK','ITEM_ORDER_IX','ITEM_PRODUCT_IX','WAREHOUSES_PK','WHS_LOCATION_IX','CUSTOMERS_PK','CUST_EMAIL_IX','CUST_ACCOUNT_MANAGER_IX','CUST_FUNC_LOWER_NAME_IX','ADDRESS_PK','ADDRESS_CUST_IX','CARD_DETAILS_PK','CARDDETAILS_CUST_IX'
Valid Views : 'PRODUCTS','PRODUCT_PRICES'
Valid Sequences : 'CUSTOMER_SEQ','ORDERS_SEQ','ADDRESS_SEQ','LOGON_SEQ','CARD_DETAILS_SEQ'
Valid Code : 'ORDERENTRY'
Schema Created
=====End=====
Fri Aug 31 14:43:42 CST 2018&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;事实证明我在执行开始和结束的地方加的这个时间，有些多此一举了哈，人家软件有统计Total Run Time。&lt;/p&gt;

&lt;p&gt;使用图形模式，就是直接执行 ./swingbench 然后配置完成后进行压力测试直接可以直观显示类似下面这样的压测结果：&lt;br/&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/jyzhao/924328/o_swingbench-500users.png&quot;/&gt;&lt;br/&gt;使用字符的话，就需要调用 ./charbench ，有效的参数如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[oracle@db50 bin]$ ./charbench -h
usage: parameters:
 -D &amp;lt;variable=value&amp;gt;           use value for given environment variable
 -a                            run automatically
 -be &amp;lt;stopafter&amp;gt;               end recording statistics after. Value is in
                               the form hh:mm
 -bg                           indicate that charbench will be run in the
                               background
 -bs &amp;lt;startafter&amp;gt;              start recording statistics after. Value is
                               in the form hh:mm
 -c &amp;lt;filename&amp;gt;                 specify config file
 -co &amp;lt;hostname&amp;gt;                specify/override coordinator in
                               configuration file.
 -com &amp;lt;comment&amp;gt;                specify comment for this benchmark run (in
                               double quotes)
 -cpuloc &amp;lt;hostname &amp;gt;           specify/overide location/hostname of the
                               cpu monitor.
 -cpupass                      specify/overide os password of the user
                               used to monitor cpu.
 -cpuuser                      specify/overide os username of the user
                               used to monitor cpu.
 -cs &amp;lt;connectstring&amp;gt;           override connect string in configuration
                               file
 -debug                        turn on debugging. Written to standard out
 -debugf                       turn on debugging. Witten to debug.log.
 -debugfine                    turn on finest level of debugging
 -di &amp;lt;shortname(s)&amp;gt;            disable transactions(s) by short name,
                               comma separated
 -dt &amp;lt;drivertype&amp;gt;              override driver type in configuration file
                               (thin, oci, ttdirect, ttclient)
 -dumptx                       output transaction response times to file
 -dumptxdir &amp;lt;directory name&amp;gt;   directory for transaction response times
                               files
 -en &amp;lt;shortname(s)&amp;gt;            enable transactions(s) by short name, comma
                               separated
 -env                          display environment configuration
 -f                            force data collection and run termination
                               regardless of state
 -g &amp;lt;groupID&amp;gt;                  distributed group identifier
 -h,--help                     print this message
 -i                            run interactively (default)
 -intermax &amp;lt;milliseconds&amp;gt;      override minimum inter transaction sleep
                               time (default = 0)
 -intermin &amp;lt;milliseconds&amp;gt;      override minimum inter transaction sleep
                               time (default = 0)
 -ld &amp;lt;milliseconds&amp;gt;            specify/overide the logon delay
                               (milliseconds)
 -max &amp;lt;milliseconds&amp;gt;           override maximum intra transaction think
                               time in configuration file
 -min &amp;lt;milliseconds&amp;gt;           override minimum intra transaction think
                               time in configuration file
 -p &amp;lt;password&amp;gt;                 override password in configuration file
 -r &amp;lt;filename&amp;gt;                 specify results file
 -rr                           specify/overide refresh rate for charts in
                               secs
 -rt &amp;lt;runtime&amp;gt;                 specify/overide run time for the benchmark.
                               Value is in the form hh:mm
 -s                            run silent
 -stats &amp;lt;stats level&amp;gt;          specify level result stats detail (full or
                               simple)
 -u &amp;lt;username&amp;gt;                 override username in configuration file
 -uc &amp;lt;user count&amp;gt;              override user count in configuration file.
 -v &amp;lt;options&amp;gt;                  display run statistics (vmstat/sar like
                               output), options include (comma separated no spaces).
                               trans|cpu|disk|dml|errs|tpm|tps|users|resp|vresp
 -vo &amp;lt;verboseOutput&amp;gt;           output file for verbose output (defaults to
                               stdout)
[oracle@db50 bin]$ &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而最重要的xml配置文件如果手动编辑就更是很苦恼的一件事，同样利用技巧，图形调用后配置好各参数然后另存为导出一份xml配置即可。&lt;br/&gt;比如导出的xml配置文件是模拟的2000并发的OLTP类型业务，文件名取为oltp2000.xml&lt;br/&gt;那么字符测试就可以直接调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--简单的只看事物量
[oracle@db50 bin]$ ./charbench -c oltp2000.xml

--指定其中一台机器登陆信息，同时看到这台机器的CPU和I/O负载情况，以及响应时间
[oracle@db50 bin]$ ./charbench -c oltp2000.xml -cpuloc db50 -cpuuser oracle -cpupass oracle -v 'users,cpu,disk,tpm,tps,resp' &amp;gt; oltp2000_load50.log
[oracle@db50 bin]$ ./charbench -c oltp2000.xml -cpuloc db52 -cpuuser oracle -cpupass oracle -v 'users,cpu,disk,tpm,tps,resp' &amp;gt; oltp2000_load52.log

--准生产的数据当时没有留存，这里就用我实验环境的数据（50并发）简单说明下：
[oracle@db50 bin]$ tail -20f oltp2000_load50.log 
Author  :        Dominic Giles
Version :        2.5.0.971

Results will be written to results.xml.
Hit Return to Terminate Run...

Time            Users   User    System  Wait    Idle    Bi      Bo      TPM     TPS     Response
23:19:30        [0/50]  0       0       0       0       0       0       0       0       0
23:19:33        [0/50]  0       0       0       0       0       0       0       0       0
23:19:34        [0/50]  11      22      2       65      19      2194    0       0       0
23:19:35        [0/50]  27      44      0       28      155     1514    0       0       0
23:19:36        [0/50]  8       24      1       67      31      1593    0       0       0
23:19:37        [12/50] 5       27      2       65      56      2626    0       0       0
23:19:38        [35/50] 6       11      1       82      39      1152    0       0       0
23:19:39        [50/50] 8       20      2       71      23      2802    0       0       0
23:19:40        [50/50] 16      33      0       51      820     1218    43      43      233
23:19:41        [50/50] 26      73      1       0       1780    580     161     118     390
23:19:42        [50/50] 45      54      1       0       1833    658     264     103     393
23:19:43        [50/50] 36      63      1       0       1959    655     384     120     361
23:19:44        [50/50] 25      75      0       0       1999    703     487     103     366
23:19:45        [50/50] 33      66      1       0       1611    588     563     76      380
23:19:46        [50/50] 46      53      1       0       1727    724     650     87      384
23:19:47        [50/50] 35      64      1       0       1607    694     766     116     376
23:19:48        [50/50] 30      69      1       0       1587    596     852     86      382
23:19:49        [50/50] 31      68      1       0       2227    629     945     93      380
23:19:50        [50/50] 46      54      0       0       2611    689     1034    89      385
23:19:51        [50/50] 35      64      1       0       1763    626     1127    93      385
23:19:52        [50/50] 22      76      2       0       2276    825     1248    121     379
23:19:53        [50/50] 29      70      1       0       2195    787     1378    130     371
23:19:54        [50/50] 43      55      2       0       2075    767     1490    112     365
23:19:55        [50/50] 39      61      0       0       1827    965     1617    127     359
23:19:56        [50/50] 29      71      0       0       1951    646     1715    98      360
23:19:57        [50/50] 37      63      0       0       1611    946     1799    84      365
23:19:58        [50/50] 45      55      0       0       1671    834     1912    113     366
23:19:59        [50/50] 34      66      0       0       1867    705     2023    111     362
23:20:00        [50/50] 39      61      0       0       2235    889     2137    114     358
23:20:01        [50/50] 40      60      0       0       1931    859     2245    108     357
23:20:02        [50/50] 36      64      0       0       1866    892     2362    117     355
23:20:03        [50/50] 38      62      0       0       2758    734     2450    88      353
23:20:04        [50/50] 42      58      0       0       3191    913     2539    89      351
23:20:05        [50/50] 47      53      0       0       2451    935     2636    97      352
23:20:06        [50/50] 48      52      0       0       2059    652     2725    89      350
23:20:07        [50/50] 42      58      0       0       2575    995     2802    77      348
23:20:08        [50/50] 42      58      0       0       2295    658     2868    66      355&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，我这里测试的50个用户[50/50]很快连接上，之后CPU的信息有4列(User, System, Wait, Idle)，I/O的信息(Bi, Bo)有两列，最后三列(TPM, TPS, Response)就分别是每分钟事物量、每秒种事物量、响应时间。&lt;br/&gt;当然了我这里的这个测试环境由于配置很低，且没有做专门的调优，测出的性能数据不是很好看了，只是演示用～&lt;/p&gt;
</description>
<pubDate>Fri, 31 Aug 2018 16:21:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>之前写过《</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/9568806.html</dc:identifier>
</item>
<item>
<title>最近做项目遇到的一些小问题 - 用心改变人生</title>
<link>http://www.cnblogs.com/ccmldl/p/9568869.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ccmldl/p/9568869.html</guid>
<description>&lt;p&gt;　　这两天一直在做项目，没有时间写博客，今天终于熬不住了，一定要写一篇。说一下这两天遇到的问题，就当做一下笔记，防止以后找不到解决办法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装Chrome浏览器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　将下载源加入到系统的源列表: sudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/&lt;/p&gt;
&lt;p&gt;　　导入谷歌软件的公钥，用于下面步骤中对下载软件进行验证:&lt;/p&gt;
&lt;p&gt;　　　　wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add -&lt;/p&gt;
&lt;p&gt;　　对当前系统的可用更新列表进行更新: sudo apt-get update&lt;/p&gt;
&lt;p&gt;　　执行对谷歌 Chrome 浏览器（稳定版）的安装: sudo apt-get install google-chrome-stable&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决Chrome无法启动问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　查看浏览器位置： whereis google-chrome&lt;/p&gt;
&lt;p&gt;　　　　 (我安装的位置)google-chrome: /usr/bin/google-chrome /usr/share/man/man1/google-chrome.1.gz&lt;/p&gt;
&lt;p&gt;　　修改浏览器： vim /usr/bin/google-chrome&lt;/p&gt;
&lt;p&gt;　　将 exec -a &quot;$0&quot; &quot;$HERE/chrome&quot; &quot;$@&quot; 改为 exec -a &quot;$0&quot; &quot;$HERE/chrome&quot; &quot;$@&quot; --user-data-dir --no-sandbox&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ubuntu安装MySQL数据库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一步：&lt;br/&gt;　　如果你的ubuntu是刚安装的，建议你先用sudo apt-get update 把你的系统更新一下，如果你的系统已经更新过了，那么直接开始下面的操作吧。&lt;/p&gt;
&lt;p&gt;第二步：&lt;br/&gt;　　直接在你的ubuntu命令行中输入 sudo apt-get install mysql-server mysql-client 只要这小小的一行代码你就可以安心等待mysql数据库的安装了。这里注意一点中间会弹出一个输入框，让你设置自己的密码，然后确认自己的密码。继续安静等待它安装完成。&lt;/p&gt;
&lt;p&gt;第三步：&lt;br/&gt;　　安装完后重启一下mysql服务 sudo service mysql restart&lt;/p&gt;
&lt;p&gt;第四步：&lt;br/&gt;　　输入mysql -uroot -p 然后输入自己的密码就可以进入mysql了第五步（扩展）：&lt;br/&gt;　　修改mysql配置文件，让mysql支持外部访问。进入mysql后show databases 发现有一个名字为mysql的数据库，然后修改里面的user表中root对应的host，刚开始是localhost，把它修改为%。&lt;br/&gt;　　select user，host from user;&lt;br/&gt;　　update user set host=”%” where user=”root”;&lt;br/&gt;　　select user , host from user;&lt;br/&gt;此时mysql中已经设置好了，接下来设置sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf这个文件。把里面ip地址那一行注释掉。例如：# bind_address : 127.0.0.1 前面加个#&lt;br/&gt;　　然后重启我们的mysql服务 service mysql restart，到这里mysql的安装和一些简单的配制就完成了！！！&lt;/p&gt;
&lt;p class=&quot;markdown_views&quot;&gt;&lt;span&gt;Ubuntu创建pycharm桌面快捷方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一种方法：&lt;/p&gt;
&lt;p&gt;　　进入到安装pycharm的bin目录下，执行命令：./pycharm.sh，然后将图标添加到收藏夹&lt;/p&gt;
&lt;p&gt;第二种方法：&lt;/p&gt;
&lt;p&gt;　　&lt;code&gt;sudo gedit /usr/share/applications/pycharm.desktop&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　将下面的内容复制到文件里面，注意要把&lt;code class=&quot;hljs ini has-numbering&quot;&gt;Exec和&lt;/code&gt;&lt;code class=&quot;hljs ini has-numbering&quot;&gt;Icon的路径改一下，不然会出错&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　1&lt;/span&gt; &lt;span&gt;[Desktop Entry]
　　&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Type=&lt;span&gt;Application
　　&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; Name=&lt;span&gt;Pycharm
　　&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; GenericName=&lt;span&gt;Pycharm3
　　&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; Comment=&lt;span&gt;Pycharm3:The Python IDE
　　&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; Exec=sh &lt;span&gt;/home/snakeson/developer/pycharm-community-2017.2.3/bin/pycharm.sh&lt;/span&gt;&lt;span&gt;
　　&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; Icon=/home/snakeson/developer/pycharm-community-2017.2.3/bin/&lt;span&gt;pycharm.png
　　&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; Terminal=&lt;span&gt;pycharm
　　&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; Categories=Pycharm;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最重要的一步：添加可执行权限&lt;/p&gt;
&lt;p&gt;　　　　&lt;code class=&quot;has-numbering&quot;&gt;sudo chmod +x /usr/share/applications/pycharm.desktop&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;code class=&quot;has-numbering&quot;&gt;将/usr/share/applications/pycharm.desktop文件拷贝到桌面，双击即可运行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ubuntu安装虚拟环境virtualenv&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这个前天已经说过了，就不再详细说了，只需要执行几行命令就可以了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
　　sudo apt-get install virtualenv 
　　sudo apt-get install virtualenvwrapper 
　　source /usr/share/virtualenvwrapper/virtualenvwrapper.sh  
　　mkvirtualenv 环境名(我设置的是venv)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 31 Aug 2018 16:17:00 +0000</pubDate>
<dc:creator>用心改变人生</dc:creator>
<og:description>这两天一直在做项目，没有时间写博客，今天终于熬不住了，一定要写一篇。说一下这两天遇到的问题，就当做一下笔记，防止以后找不到解决办法。 安装Chrome浏览器 将下载源加入到系统的源列表: sudo w</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ccmldl/p/9568869.html</dc:identifier>
</item>
<item>
<title>红黑树——依天理以神遇 - 仪式黑刃</title>
<link>http://www.cnblogs.com/hongshijie/p/9568836.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hongshijie/p/9568836.html</guid>
<description>&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;红黑树是&lt;span lang=&quot;zh-CN&quot;&gt;AVL&lt;span lang=&quot;zh-CN&quot;&gt;树的另一变种，他也能在动态变化的过程中保持某种意义的平衡，对红黑树的操作最坏情况下也只有$O\left( \log n \right)$&lt;span lang=&quot;en-US&quot;&gt;的复杂度&lt;span lang=&quot;zh-CN&quot;&gt;，而且下面我们会看到，对于插入而言我们有另外一种比AVL树更容易的实现方法，非递归的。在具体谈到&lt;span lang=&quot;en-US&quot;&gt;技术细节之前&lt;span lang=&quot;zh-CN&quot;&gt;，我们或许会有疑问：已经有AVL这种渐进复杂度很低的结构了，也能保持平衡，不至于让树高突破天际，那为什么还要研发新的变种呢？动力何在，红黑树在整个平衡树体系里又处于什么地位呢？先看下今天主角的基本信息。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180831235354539-1006737879.png&quot; alt=&quot;&quot; width=&quot;390&quot; height=&quot;365&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;回顾此前的各个结构，不论是线性的向量、列表、栈&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;or&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;队列，也无论半线性的树结构和非线性的图。它们大多呈现这种特征：每经一次动态的操作，逻辑结构变化，然后转入新的状态，此前的状态完全丢失，这类结构也因此称作&lt;span lang=&quot;zh-CN&quot;&gt;ephemeral data structure&lt;span lang=&quot;zh-CN&quot;&gt;。每一个固定时刻的状态都是稍纵即逝的。但是实际场景中这并不够用，很多时候我们可能希望查阅它的历史版本并加以修改之类的。那此前所学就不足以解决问题了，因此要设计新的结构，这是它的动力所在。因此无论静态还是动态操作，除了元素的值，还需要同时指定一个版本号。如果一个数据结构能够支持这种类型的需求，就称作是&lt;span lang=&quot;zh-CN&quot;&gt;persistent structures&lt;span lang=&quot;zh-CN&quot;&gt;，也就是所谓的一致性结构，或者叫可持久化结构（这里给个拓展阅读，陈立杰写过一篇论文叫《可持久化数据结构研究》，对这方面有兴趣的可以研读一番）。乍看之下很好实现这个思想：每做一次动态操作就复制一份副本就行了，每个版本独立保存。但这种朴素（如同村中老汉一般）的想法行得通么？以下就是针对一棵具体的平衡二叉树记录了它整个生命期内的&lt;span lang=&quot;zh-CN&quot;&gt;5&lt;span lang=&quot;zh-CN&quot;&gt;个版本：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180831235410660-2027650474.png&quot; alt=&quot;&quot; width=&quot;683&quot; height=&quot;131&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;如此一来，一旦指定了版本号就可以转入对应的状态，从单次访问效率而言，这个结构还可以接受。如果我们将不同版本的数目记作&lt;span lang=&quot;zh-CN&quot;&gt;h&lt;span lang=&quot;zh-CN&quot;&gt;，就需要$O\left( \log h \right)$&lt;span lang=&quot;en-US&quot;&gt;时间确定状态&lt;span lang=&quot;zh-CN&quot;&gt;，然后用$O\left( \log n \right)$&lt;span lang=&quot;en-US&quot;&gt;时间执行操作&lt;span lang=&quot;zh-CN&quot;&gt;，总体来说单次操作$O\left( \log h\; +\; \log n \right)$&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;，时间复杂度海星。但是空间复杂度就爆炸了，每一个元素都可能会被保存多份，渐近的来说&lt;span lang=&quot;zh-CN&quot;&gt;n&lt;span lang=&quot;zh-CN&quot;&gt;个元素中的每一个，都有可能在这组档案中被保存多达h份。这就意味着空间复杂度将伴随着&lt;span lang=&quot;zh-CN&quot;&gt;h&lt;span lang=&quot;zh-CN&quot;&gt;成线性的速度增长，而空间复杂度也构成了时间复杂度的一个下限。刚才单次的渐进时间是log级别的，现在累计花费的时间会达到$O\left( h\; +\; n \right)$&lt;span lang=&quot;en-US&quot;&gt;的规模&lt;span lang=&quot;zh-CN&quot;&gt;，这肯定不行。那能不能做点改进呢？控制在$O\left( n\; +\; h\; \cdot \; \log n \right)$&lt;span lang=&quot;en-US&quot;&gt;内&lt;span lang=&quot;zh-CN&quot;&gt;：除了所有元素各自占用的空间，能够将每一个版本所消耗的均摊空间量控制在$\log n$&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;的范围内呢？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt;答案是可以&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt;为此我们需要利用同一数据结构相邻版本之间的关联性。对于每一组相邻的版本，新版本都是在老版本上做些许修改得到的： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180831235430719-1100738895.png&quot; alt=&quot;&quot; width=&quot;675&quot; height=&quot;123&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;两个版本绝大部分元素是相同的，二者差异不大。利用这个特点我们很自然的想到一个办法：大量共享，少量更新（就类似前缀和的区间加，大部分不变，做少量修改）。只要实现得当，就能把动态操作的复杂度控制在&lt;span lang=&quot;en-US&quot;&gt;$O\left( h\; +\; n \right)$&lt;span lang=&quot;zh-CN&quot;&gt;。比如对于具体的一棵树，下面是一种可行的实现方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180831235456331-807925810.png&quot; alt=&quot;&quot; width=&quot;764&quot; height=&quot;140&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;在这幅图中每一条红线都对应于一个共享，比如&lt;span lang=&quot;en-US&quot;&gt;1-2&lt;span lang=&quot;en-US&quot;&gt;这&lt;span lang=&quot;zh-CN&quot;&gt;条红线，表示节点&lt;span lang=&quot;zh-CN&quot;&gt;1&lt;span lang=&quot;zh-CN&quot;&gt;同时出现在版本&lt;span lang=&quot;en-US&quot;&gt;0和1中&lt;span lang=&quot;zh-CN&quot;&gt;。其中还有一些蓝色的虚线，它们表示在相邻版本之间的更新量，也是我们必须花费空间存储的量。好消息是：这个量不会太大。比如左边第一条&lt;span lang=&quot;en-US&quot;&gt;8-8'&lt;span lang=&quot;en-US&quot;&gt;的&lt;span lang=&quot;zh-CN&quot;&gt;蓝线就表示：尽管&lt;span lang=&quot;zh-CN&quot;&gt;8&lt;span lang=&quot;zh-CN&quot;&gt;和&lt;span lang=&quot;zh-CN&quot;&gt;8'&lt;span lang=&quot;zh-CN&quot;&gt;对应于同一个数据对象，但是在前和后两个版本中它们的父节点已经发生了变化，因此在新的版本中我们必须为它另存一个副本。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;zh-CN&quot;&gt;听起来有点绕，的确，这种高级结构已经牵扯到计算几何的范畴了。另外$\log n$&lt;span lang=&quot;en-US&quot;&gt;其实还有改进空间&lt;span lang=&quot;zh-CN&quot;&gt;，如果能将前后版本的空间差异控制在$O\left( 1 \right)\; $&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;的范围，那么整体的空间复杂度将进一步优化至$n\; +\; h$&lt;span lang=&quot;zh-CN&quot;&gt; &lt;span lang=&quot;zh-CN&quot;&gt;而不是$h\; \cdot \; \log n$&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;。这也是可以做到的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;具体细节先不说，但是为此所应具备的一项必要条件是非常好理解的：对&lt;span lang=&quot;zh-CN&quot;&gt;BBST&lt;span lang=&quot;zh-CN&quot;&gt;的树形拓扑结构而言，相邻版本之间的差异不能超过常数。令人遗憾，绝大多数的&lt;span lang=&quot;zh-CN&quot;&gt;BBST&lt;span lang=&quot;zh-CN&quot;&gt;，包括此前学过的&lt;span lang=&quot;zh-CN&quot;&gt;AVL&lt;span lang=&quot;zh-CN&quot;&gt;树都不能保证这一点。拓扑结构差异是由自调整过程中的旋转操作导致的，每一次局部的旋转 ，都意味着在结构上引入差异。反过来说，如果需要保证前后版本在拓扑结构上的差异不超过常数，就必须保证：&lt;span lang=&quot;en-US&quot;&gt;2个版本之间&lt;span lang=&quot;zh-CN&quot;&gt;的旋转操作不得超过一个固定数值，这个数不能因输入量而变。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p lang=&quot;en-US&quot;&gt;满足这个优化条件的结构在已学的知识里有么？来找一找，AVL树的两个动态操作中插入是满足的。每次插入之后，一次旋转，全树复原。但是删除就不满足这个了，从AVL树中删除一个节点之后，有可能自底而上逐层引发多达$\log n$次的旋转，从而导致树形拓扑结构的剧烈变化。因此为了使得上述的构思能够兑现，我们就需要这样一种BBST，它的任何动态操作对树形拓扑结构的影响，都能控制在常数的范围之内。发明这个变种之后，根据特征我们将其命名为“红黑树”。&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;阶段性总结一下：红黑树相比于AVL树的特点在于，每次插入/删除后拓扑结构的变化不超过$O\left( 1 \right)\; $。&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;现在来分析一下RBTree的结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180831235529451-1684084795.png&quot; alt=&quot;&quot; width=&quot;477&quot; height=&quot;287&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;增设外部节点nULL，方便考虑，就相当于&lt;span lang=&quot;en-US&quot;&gt;left=right=nULL的初始情况&lt;span lang=&quot;zh-CN&quot;&gt;，这时候这些外部节点就是叶子了。对于这种树有如下四条定义统一约束：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;&lt;li value=&quot;1&quot;&gt;树根是黑色的，叶子（即使是nULL）也是黑色的&lt;/li&gt;
&lt;li&gt;&lt;span lang=&quot;zh-CN&quot;&gt;除了&lt;span lang=&quot;en-US&quot;&gt;root和leaf&lt;span lang=&quot;zh-CN&quot;&gt;，每一个节点或红或黑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;如果一个节点是红色的，那子节点必须是黑色&lt;/li&gt;
&lt;li&gt;从某个节点到叶子的路径上必须包含相同数目的黑色节点&lt;/li&gt;
&lt;/ol&gt;&lt;p lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;挑几个说明一下，第&lt;span lang=&quot;en-US&quot;&gt;3&lt;span lang=&quot;zh-CN&quot;&gt;条虽然简明，但实际上蕴含了很多&lt;span lang=&quot;zh-CN&quot;&gt;人生的经验&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;性质&lt;span lang=&quot;zh-CN&quot;&gt;，比如这要求了不可能出现同时为红的父子两代，换一个有可操作性的表述就是：对于红节点来说，无论是它的孩子还是父亲都必须是黑的，就是可以红黑相间&lt;span lang=&quot;en-US&quot;&gt;or全黑&lt;span lang=&quot;zh-CN&quot;&gt;（它只约束了红色嘛），不准全红。待会我们就会看到，这条规则对于控制红黑树的深度是极其重要的。第&lt;span lang=&quot;en-US&quot;&gt;4条&lt;span lang=&quot;zh-CN&quot;&gt;，可以认为是旨在控制红黑树的平衡性。因为这里要求了，在从任何一个外部节点通往树根的唯一的路径上，黑节点的数目必然相等，那肯定是平衡的，不会一边长一边短。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;那这一堆规则到底对应一棵什么样的树？而这些规则背后又有着什么原理呢？我们来看一个例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180831235551608-528474271.png&quot; alt=&quot;&quot; width=&quot;634&quot; height=&quot;237&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;根是黑色的，叶子貌似不是，但实际上我们之前增加了外部节点，这时候令外部节点统一为黑即可。增设这些是为了方便分析和实现，在例子中我们可以忽略掉。第三条也是满足的，每一个红色节点的父与子都是黑色的。第四点也是满足的，找两条路径数一下就好了。现在有了一些直观感受，但是，回过头去看那四条规则仍感觉艰深晦涩（e&lt;span lang=&quot;en-US&quot;&gt;.g 凭啥两个红色节点不能挨着&lt;span lang=&quot;zh-CN&quot;&gt;、我两条路径上黑色节点数量不一样能咋地？）。那还能不能再直接一点呢？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;他山之石，可以攻玉，我们要用另外一个结构帮助理解。我们来看下面这个案例，为了更好地理解这组规则，我们要做一个等价变换：提升。先看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180831235617978-1448306329.png&quot; alt=&quot;&quot; width=&quot;695&quot; height=&quot;156&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们把每一个红色节点都往上提一层，让他和黑色的父亲同高（注意，部分黑色节点可能会接纳两个红节点）。可以证明的是，绝对不可能出现两个红色节点相邻的情况，不可能。就算在一行上，他们之间必然夹着一个黑色节点。现在开始吧——超级变换形态 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180831235642225-330481031.png&quot; alt=&quot;&quot; width=&quot;993&quot; height=&quot;157&quot;/&gt;&lt;/p&gt;
&lt;p&gt;变成这样了。再来看一个更大的例子，方便我们从宏观上把握红黑树的性质。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180831235700858-142861570.png&quot; alt=&quot;&quot; width=&quot;1075&quot; height=&quot;165&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;这是一颗&lt;span lang=&quot;en-US&quot;&gt;100个节点的树&lt;span lang=&quot;zh-CN&quot;&gt;，底层节点都是&lt;span lang=&quot;en-US&quot;&gt;red&lt;span lang=&quot;zh-CN&quot;&gt;，而且凹凸不平（这对控制树高十分不利）。变换之后呢？来玩个找不同游戏：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;所有底层节点都同高了，对吧！那这一现象是巧合么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180831235727460-891744937.png&quot; alt=&quot;&quot; width=&quot;430&quot; height=&quot;393&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;尽管红黑树的规则艰深晦涩，玄之又玄，但是从提升变换的角度来看，就会变得豁然开朗，宛如一幅长卷铺开。实际上从这个角度来看，&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;红黑树就是&lt;/strong&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;阶的&lt;/strong&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;B&lt;/strong&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;树，（&lt;/strong&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;，&lt;/strong&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;strong&gt;）树&lt;/strong&gt;。&lt;span lang=&quot;zh-CN&quot;&gt;实际的确如此，为了理解这点，只需要将每一个黑节点，与经过提升之后与它高度一致的红节点，整体地视作为一个&lt;span lang=&quot;zh-CN&quot;&gt;B&lt;span lang=&quot;zh-CN&quot;&gt;树的内部节点。这样一来，归纳下来不过四种组合，每一种黑父与红子的组合都对应&lt;span lang=&quot;zh-CN&quot;&gt;4&lt;span lang=&quot;zh-CN&quot;&gt;阶&lt;span lang=&quot;zh-CN&quot;&gt;B&lt;span lang=&quot;zh-CN&quot;&gt;树的某类内部节点：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180831235750803-1578690001.png&quot; alt=&quot;&quot; width=&quot;910&quot; height=&quot;259&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一个内部节点都至少拥有2个分支，至多拥有4个分支，正是4阶B树的特征。&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;那他既然也是B树，自然也是平衡树，我们来个证明吧，这是十分有必要的，因为这会加深对他的理解。我们需要证明的是：由&lt;span lang=&quot;zh-CN&quot;&gt;n&lt;span lang=&quot;zh-CN&quot;&gt;个内部节点所构成的任何一棵红黑树，其高度在渐近意义下都不超过&lt;span lang=&quot;zh-CN&quot;&gt;logn&lt;span lang=&quot;zh-CN&quot;&gt;，当然与所有的&lt;span lang=&quot;zh-CN&quot;&gt;BST&lt;span lang=&quot;zh-CN&quot;&gt;一样&lt;span lang=&quot;zh-CN&quot;&gt;——&lt;span lang=&quot;zh-CN&quot;&gt;拥有&lt;span lang=&quot;zh-CN&quot;&gt;n&lt;span lang=&quot;zh-CN&quot;&gt;个内部节点的红黑树，也必然同时拥有&lt;span lang=&quot;zh-CN&quot;&gt;n+1&lt;span lang=&quot;zh-CN&quot;&gt;个外部节点。简单点说就是证明$\log _{2}\left( n\; +\; 1 \right)\; \leq \; h\; \leq \; 2\; \cdot \; \log _{2}\left( n\; +\; 1 \right)$&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;这个不等式成立&lt;span lang=&quot;zh-CN&quot;&gt;。左边的在B&lt;span lang=&quot;en-US&quot;&gt;-树篇已经证明了&lt;span lang=&quot;zh-CN&quot;&gt;，而且任何BST都是满足的，所以现在只证右边的的就好了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180831235815390-212836632.png&quot; alt=&quot;&quot; width=&quot;437&quot; height=&quot;394&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;zh-CN&quot;&gt;比如就在这棵红黑树中，如果忽略掉人为引入的外部节点，那么每一条这样的路径上所含黑节点是&lt;span lang=&quot;zh-CN&quot;&gt;6&lt;span lang=&quot;zh-CN&quot;&gt;个。根据规则任何一条路径上所含黑节点的总数都应该是&lt;span lang=&quot;zh-CN&quot;&gt;6&lt;span lang=&quot;zh-CN&quot;&gt;，此时我们就称这棵红黑树的黑高度为&lt;span lang=&quot;zh-CN&quot;&gt;6&lt;span lang=&quot;zh-CN&quot;&gt;。尽管加上&lt;span lang=&quot;zh-CN&quot;&gt;3&lt;span lang=&quot;zh-CN&quot;&gt;个红色节点，高度可以到&lt;span lang=&quot;zh-CN&quot;&gt;9&lt;span lang=&quot;zh-CN&quot;&gt;。所谓树高就是全树中最深节点所对应那条通路的长度，而在红黑树中任何一条通路上，可能出现相邻的黑节点，却不允许出现相邻的红色节点。这就意味着在每一条这样的通路上，红色节点$\leq \; \frac{1}{2}$，而黑色节点$\geq \; \frac{1}{2}$。&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;&lt;span lang=&quot;en-US&quot;&gt;&lt;span lang=&quot;zh-CN&quot;&gt;因此红黑树的高度必然不会超过其黑高度的&lt;span lang=&quot;zh-CN&quot;&gt;2&lt;span lang=&quot;zh-CN&quot;&gt;倍。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p lang=&quot;en-US&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;那么这里的黑高度又如何计算呢&lt;span lang=&quot;zh-CN&quot;&gt;？&lt;span lang=&quot;en-US&quot;&gt;正是提升变换&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;span lang=&quot;en-US&quot;&gt;我们知道经过提升变换之后&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;红黑树对应于&lt;span lang=&quot;en-US&quot;&gt;4&lt;span lang=&quot;en-US&quot;&gt;阶的&lt;span lang=&quot;en-US&quot;&gt;B&lt;span lang=&quot;en-US&quot;&gt;树&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1262741/201808/1262741-20180831235836253-1697990650.png&quot; alt=&quot;&quot; width=&quot;706&quot; height=&quot;282&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;在这样一棵&lt;span lang=&quot;en-US&quot;&gt;B&lt;span lang=&quot;en-US&quot;&gt;树中所有的外部节点都像蓝圈中的一样&lt;span lang=&quot;zh-CN&quot;&gt;，整齐的&lt;span lang=&quot;en-US&quot;&gt;分布于底层&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;span lang=&quot;en-US&quot;&gt;而其中的每一个内部节点都是由此前的某个黑父以及他的红子构成的&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;因此此前红黑树中的每一条路径&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span lang=&quot;en-US&quot;&gt;也会在&lt;span lang=&quot;en-US&quot;&gt;B&lt;span lang=&quot;en-US&quot;&gt;树中对应于一条路径&lt;span lang=&quot;zh-CN&quot;&gt;。&lt;span lang=&quot;en-US&quot;&gt;原先这条路径上有多少个黑节点&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;在&lt;span lang=&quot;en-US&quot;&gt;B&lt;span lang=&quot;en-US&quot;&gt;树中对应的那条路径就有多长——这就意味着&lt;span lang=&quot;zh-CN&quot;&gt;，&lt;span lang=&quot;en-US&quot;&gt;这棵&lt;span lang=&quot;en-US&quot;&gt;B&lt;span lang=&quot;en-US&quot;&gt;树的高度应该正好是此前那棵红黑树的黑高度&lt;span lang=&quot;zh-CN&quot;&gt;。也就是：&lt;span lang=&quot;en-US&quot;&gt;B&lt;span lang=&quot;en-US&quot;&gt;树的高度就是其对应的红黑树的黑高度&lt;span lang=&quot;zh-CN&quot;&gt;。而为了计算一棵红黑树的黑高度，只需去计算对应的&lt;span lang=&quot;zh-CN&quot;&gt;B&lt;span lang=&quot;zh-CN&quot;&gt;树高度即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;也就是$h\; \leq \; \log _{2}\frac{n+1}{2}\; +\; 1\; \leq \; \log _{2}\left( n\; +\; 1 \right)$  &lt;/p&gt;
&lt;p&gt;下篇写实现&lt;/p&gt;

</description>
<pubDate>Fri, 31 Aug 2018 16:00:00 +0000</pubDate>
<dc:creator>仪式黑刃</dc:creator>
<og:description>红黑树是AVL树的另一变种，他也能在动态变化的过程中保持某种意义的平衡，对红黑树的操作最坏情况下也只有$O\left( \log n \right)$的复杂度，而且下面我们会看到，对于插入而言我们有另</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hongshijie/p/9568836.html</dc:identifier>
</item>
<item>
<title>$.each()、$.map()区别浅谈 - 那片星空，那片海</title>
<link>http://www.cnblogs.com/jinxing-tc/p/9568832.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinxing-tc/p/9568832.html</guid>
<description>&lt;p&gt;　　遍历应该是各种语言中常会用到的操作了，实现的方法也很多，例如使用for、while等循环语句就可以很轻松的做到对数组或对象的遍历，今天想讲的不是它们，而是简单方便的遍历方法。&lt;/p&gt;
&lt;p&gt;　　大致的整理了一下，经常用到的大概有Jquery的$.each、$.map、each()、map()、get()、toArray()以及js原生的forEach()吧，当然肯定还有一些我不知道的，今天就先谈谈$.each()和$.map()区别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;$.each()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$.each()方法可用于遍历任何对象(包括数组)，结构为：$.each(array/object,function(index/key,value){ code })。index指遍历对象成员的索引，value指成员的内容。如果需要退出循环可使回调函数返回 false，其它返回值将被忽略。&lt;/p&gt;
&lt;p&gt;上栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历数组&lt;/span&gt;
$(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;&lt;span&gt;];
$.each(arr,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(index,value){
    console.log(value&lt;/span&gt;+&quot; &quot;+&lt;span&gt;index);
});
});
&lt;span&gt;结果依次输出
a0
b1
c2
d3&lt;/span&gt;

&lt;span&gt;如果你在循环中放入console.log(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;this)，结果会依次输出string{a}。。。也就是表明返回值为对象。

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历对象&lt;/span&gt;
$(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj = {name:&quot;tony&quot;,age:18,job:&quot;adc&quot;&lt;span&gt;}
$.each(obj,&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(key,value){
    console.log(key&lt;/span&gt;+&quot; &quot;+&lt;span&gt;value);
});
});
&lt;span&gt;结果依次输出
name tony
age &lt;/span&gt;&lt;/span&gt;&lt;span&gt;18
job adc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;$.map()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$.map()方法可以在遍历数组或对象成员的同时，经过回调函数的调用，然后转换到另一个新的数组中（这也是和$.each()的最大区别）。&lt;/p&gt;
&lt;p&gt;结构：$.map(array/object,function(value,index/key){ code })，index指遍历对象成员的索引，value指成员的内容。如果需要退出循环可使回调函数返回 false，其它返回值将被忽略。&lt;/p&gt;
&lt;p&gt;看栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48.5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历数组&lt;/span&gt;
$(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr1 = $.map(arr,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value,index){  &lt;span&gt;//注意回调函数的参数位置和$.each()的不一致&lt;/span&gt;
    console.log(index&lt;/span&gt;+&lt;span&gt;value);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; val = value.toUpperCase();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以在回调函数中对成员进行操作，然后将其返回到新的数组中。toUpperCase()方法转换字符为大写。&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; val;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一定要使用return返回值，否则新数组接受不到&lt;/span&gt;
&lt;span&gt;});
console.log(arr1);&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;　var res = Object.prototype.toString.call(obj1);&lt;span&gt;//使用Object.prototype.toString.call()方法返回传入变量的类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　console.log(res);&lt;/p&gt;
&lt;/div&gt;
&lt;pre&gt;
&lt;span readability=&quot;1&quot;&gt;
});
&lt;span readability=&quot;2&quot;&gt;首先依次输出遍历的结果
a0
b1
c2
d3
输出arr1的结果（可以看出是返回值组成的新数组）
[A,B,C,D]&lt;br/&gt;输出res结果为&lt;br/&gt;Object Array&lt;p&gt;（遍历对象可以参照$.each()方法，只不过返回的仍然是数组）&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里有的同学可能就会疑问$.each()是否也会生成新的数组，眼见为实：&lt;/p&gt;
&lt;p&gt;继续栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
$(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; arr1 = $.each(arr,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(index,value){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; val =&lt;span&gt; value.toUpperCase();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; val;
});
    console.log(arr1);
});
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;输出的结果仍然为
[a,b,c,d]
所以说明返回的只是原数组，而不是生成新数组&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 31 Aug 2018 15:57:00 +0000</pubDate>
<dc:creator>那片星空，那片海</dc:creator>
<og:description>遍历应该是各种语言中常会用到的操作了，实现的方法也很多，例如使用for、while等循环语句就可以很轻松的做到对数组或对象的遍历，今天想讲的不是它们，而是简单方便的遍历方法。 大致的整理了一下，经常用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinxing-tc/p/9568832.html</dc:identifier>
</item>
<item>
<title>菜鸟级appium 必看 - wujianqinjian</title>
<link>http://www.cnblogs.com/wujianqinjian/p/9568833.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wujianqinjian/p/9568833.html</guid>
<description>&lt;p&gt;之所以写这个，因为太多新人，appium环境半天都搭建不好，版本问题，兼容问题等等。&lt;/p&gt;

&lt;p&gt;自己的解决方案：1 官网下载nodejs，建议安装长期支持版&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1209230/201808/1209230-20180831235323938-1939584194.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2 进入appium官网，点击下载，跳转到github上下载对应版本，本人是64位系统&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1209230/201808/1209230-20180831235431737-605739689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1209230/201808/1209230-20180831235457050-1915275863.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后，可以理解有时候大家不方便在职场问，一些可快速解决的问题，我这边都会不时更新，自动化有问题留言，我这边尽快答复大家，毕竟咱这个穷人除了帮别人解决问题，再没有特长了！&lt;/p&gt;

</description>
<pubDate>Fri, 31 Aug 2018 15:57:00 +0000</pubDate>
<dc:creator>wujianqinjian</dc:creator>
<og:description>之所以写这个，因为太多新人，appium环境半天都搭建不好，版本问题，兼容问题等等。 自己的解决方案：1 官网下载nodejs，建议安装长期支持版 2 进入appium官网，点击下载，跳转到githu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wujianqinjian/p/9568833.html</dc:identifier>
</item>
<item>
<title>C++——简单数据类型及布尔类型 - 我要亲亲ლ(°◕‵ƹ′◕ლ)</title>
<link>http://www.cnblogs.com/qinqin-me/p/9568824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qinqin-me/p/9568824.html</guid>
<description>&lt;p&gt;一. 简单数据类型&lt;/p&gt;
&lt;p&gt;       数据类型描述了对象在内存存储区中占据的空间大小，描述了对象能够表示的数据范围&lt;/p&gt;
&lt;p&gt;和类型。C++语言中常用的数据类型有&lt;strong&gt;整型、实型、字符型（这3种类型也被称之为简单数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;据类型）、数组类型、布尔类型、枚举类型、结构体类型、公用体类型、指针类型、引用类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;型&lt;/strong&gt;等。&lt;/p&gt;
&lt;p&gt;       1.整形&lt;/p&gt;
&lt;p&gt;             整型按符号划分，可以分为有符号整型和无符号整型两大类，从长度划分，可以分为&lt;/p&gt;
&lt;p&gt;       普通整型、短整型和长整型3类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1458243/201808/1458243-20180831235034065-1459836876.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        2.实型&lt;/p&gt;
&lt;p&gt;              实型主要包括单精度型、双精度型和长双精度型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1458243/201808/1458243-20180831235123745-1702544402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;              10、010、0x10、10u、10L、10UL、10F&lt;/p&gt;
&lt;p&gt;        3.字符类型&lt;/p&gt;
&lt;p&gt;               在C++语言中，字符类型数据是使用单引号括起来的形式表示的。&lt;/p&gt;
&lt;p&gt;         ‘&lt;span&gt;A&lt;/span&gt;’、’a&lt;span&gt;’、‘&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;’&lt;span&gt;、&lt;/span&gt;‘&lt;span&gt;b&lt;/span&gt;’等&lt;/p&gt;
&lt;p&gt;          定义字符类型数据可以使用char关键字，例如：char chData = 'N';&lt;/p&gt;
&lt;p&gt;二. 布尔类型&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      在逻辑判断中只存在两个值，即真和假。在程序中为了描述逻辑判断的真值和假值提供了布尔类型&lt;/span&gt;——bool。该数据类型提供了两个值true和false，即真值和假值。布尔类型数据可以按整数类型对待，true表示1，false表示0。&lt;/p&gt;
&lt;p&gt;在程序中可以将布尔类型对象赋值给整数类型对象，反之，也可以将整数类型对象赋值给布尔类型对象。&lt;/p&gt;
&lt;p&gt;三.我皮厚，如果觉得还可以，就给我一个亲亲吧ლ(°◕‵ƹ′◕ლ)&lt;/p&gt;
</description>
<pubDate>Fri, 31 Aug 2018 15:54:00 +0000</pubDate>
<dc:creator>我要亲亲ლ(&amp;#176;◕‵ƹ′◕ლ)</dc:creator>
<og:description>一. 简单数据类型 数据类型描述了对象在内存存储区中占据的空间大小，描述了对象能够表示的数据范围 和类型。C++语言中常用的数据类型有整型、实型、字符型（这3种类型也被称之为简单数 据类型）、数组类型</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qinqin-me/p/9568824.html</dc:identifier>
</item>
<item>
<title>在Web界面中实现Excel数据大量导入的处理方式 - 伍华聪</title>
<link>http://www.cnblogs.com/wuhuacong/p/9566946.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhuacong/p/9566946.html</guid>
<description>&lt;p&gt;在早期Bootstrap框架介绍中，我的随笔《&lt;a id=&quot;cb_post_title_url&quot; href=&quot;https://www.cnblogs.com/wuhuacong/p/7297823.html&quot;&gt;结合bootstrap fileinput插件和Bootstrap-table表格插件，实现文件上传、预览、提交的导入Excel数据操作流程&lt;/a&gt;》中介绍了利用Bootstrap FieInput插件上传Excel文件到服务器，然后利用Bootstrap-table表格插件进行展示数据，最后导入到系统里面中，这个导入过程中可以预览到要导入的数据，而且可以选择性的导入。在实际使用过程中，发现使用Ajax导入大批量（几百条记录数据）的情况下，页面就会罢工，估计和提交的数据大小限制有关，为了解决这个问题，并结合导入数据一般都是全部导入的情况下，我们修改下数据导入的过程，从而实现大量数据量的Excel数据导入。&lt;/p&gt;
&lt;h3&gt;1、使用预览数据，并勾选导入的处理方式&lt;/h3&gt;
&lt;p&gt;Excel导入的的界面展示如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/8867/201708/8867-20170807111859549-1949294277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上传文件后，数据直接展示在弹出层的列表里面，这里直接使用了 Bootstrap-table表格插件进行展示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/blog/8867/201708/8867-20170807112140924-1742194312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们就可以把Excel的记录展示出来，实现了预览的功能，勾选必要的记录，然后保存即可提交到服务器进行保存，实现了Excel数据的真正导入数据库处理。&lt;/p&gt;
&lt;p&gt;实际的代码就比较多一点点，详细可以参考下随笔《&lt;a id=&quot;cb_post_title_url&quot; href=&quot;https://www.cnblogs.com/wuhuacong/p/7297823.html&quot;&gt;结合bootstrap fileinput插件和Bootstrap-table表格插件，实现文件上传、预览、提交的导入Excel数据操作流程&lt;/a&gt;》，这里就主要简要介绍下导入的处理逻辑即可，由于是在客户端组装列表数据，然后通过ajax提交的，它的的代码如下所示。（这个也就是后面需要解决的问题）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存导入的数据&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SaveImport() {
            
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; list = [];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造集合对象&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; rows = $import.bootstrapTable('getSelections'&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; rows.length; i++&lt;span&gt;) {
                list.push({
                    &lt;/span&gt;'Name': rows[i].Name, 'Mobile': rows[i].Mobile, 'Email': rows[i].Email, 'Homepage'&lt;span&gt;: rows[i].Homepage,
                    &lt;/span&gt;'Hobby': rows[i].Hobby, 'Gender': rows[i].Gender, 'Age': rows[i].Age, 'BirthDate'&lt;span&gt;: rows[i].BirthDate,
                    &lt;/span&gt;'Height': rows[i].Height, 'Note'&lt;span&gt;: rows[i].Note
                });
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (list.length == 0&lt;span&gt;) {
                showToast(&lt;/span&gt;&quot;请选择一条记录&quot;, &quot;warning&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; postData = { 'list': list };&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以增加其他参数，如{ 'list': list, 'Rucanghao': $(&quot;#Rucanghao&quot;).val() };&lt;/span&gt;
            postData =&lt;span&gt; JSON.stringify(postData);

            $.ajax({
                url: &lt;/span&gt;'/TestUser/SaveExcelData'&lt;span&gt;,
                type: &lt;/span&gt;'post'&lt;span&gt;,
                dataType: &lt;/span&gt;'json'&lt;span&gt;,
                contentType: &lt;/span&gt;'application/json;charset=utf-8'&lt;span&gt;,
                traditional: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (data.Success) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存成功  1.关闭弹出层，2.清空记录显示 3.刷新主列表&lt;/span&gt;
                        showToast(&quot;保存成功&quot;&lt;span&gt;);

                        $(&lt;/span&gt;&quot;#import&quot;).modal(&quot;hide&quot;&lt;span&gt;);
                        $(bodyTag).html(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
                        Refresh();
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        showToast(&lt;/span&gt;&quot;保存失败:&quot; + data.ErrorMessage, &quot;error&quot;&lt;span&gt;);
                    }
                },
                data: postData
            });
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在实际使用过程中，发现数据几百条的时候，页面就罢工了，不能正常插入，搜索下解决问题说是大小受限的问题，但是我在Web.Config里面也设置了上传文件的大小，最终没有找到配置解决思路。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;httpRuntime &lt;/span&gt;&lt;span&gt;executionTimeout&lt;/span&gt;&lt;span&gt;=&quot;600&quot;&lt;/span&gt;&lt;span&gt; maxRequestLength&lt;/span&gt;&lt;span&gt;=&quot;951200&quot;&lt;/span&gt;&lt;span&gt; 
   useFullyQualifiedRedirectUrl&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; minFreeThreads&lt;/span&gt;&lt;span&gt;=&quot;8&quot;&lt;/span&gt;&lt;span&gt; 
   minLocalRequestFreeThreads&lt;/span&gt;&lt;span&gt;=&quot;4&quot;&lt;/span&gt;&lt;span&gt; appRequestQueueLimit&lt;/span&gt;&lt;span&gt;=&quot;100&quot;&lt;/span&gt;&lt;span&gt;  enableVersionHeader&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终这个配置项也无法解决，那么我们只能找其他方式来避免数据大量提交了。&lt;/p&gt;

&lt;h3&gt;2、使用在控制器后台读取Excel文件导入数据库&lt;/h3&gt;
&lt;p&gt;以上的数据导入方式，在一般数据比较少的时候，体验还是不错的，不过它的过程也是先上传Excel文件，然后读取Excel里面的记录，转换为对应的List&amp;lt;T&amp;gt;类型，在序列号JSON列表在前端界面展示。&lt;/p&gt;
&lt;p&gt;既然我们文件在服务器上，并且也可以通过把Excel文件转换为对应的List&amp;lt;T&amp;gt;，那么我们减少用户勾选的步骤，确认后直接读取导入即可，这样处理应该就没有这样的受限于页面数据大小的问题的。&lt;/p&gt;
&lt;p&gt;这样我们以设备信息导入为案例，介绍这个处理过程，如下前端代码是在文件上传到服务器后，用户确认后负责导入的逻辑的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存导入的数据&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt;&lt;span&gt; SaveImport() {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; postData = { 'guid'&lt;span&gt;: importGuid };
            postData &lt;/span&gt;=&lt;span&gt; JSON.stringify(postData);

            $.ajax({
                url: &lt;/span&gt;'/Device/SaveExcelByGuid'&lt;span&gt;,
                type: &lt;/span&gt;'post'&lt;span&gt;,
                dataType: &lt;/span&gt;'json'&lt;span&gt;,
                contentType: &lt;/span&gt;'application/json;charset=utf-8'&lt;span&gt;,
                traditional: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (data) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (data.Success) {
                        Refresh();
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存成功  1.关闭弹出层，2.清空记录显示 3.刷新主列表&lt;/span&gt;
                        showToast(&quot;保存成功&quot;&lt;span&gt;);

                        $(&lt;/span&gt;&quot;#import&quot;).modal(&quot;hide&quot;&lt;span&gt;);
                        $(bodyTag).html(&lt;/span&gt;&quot;&quot;&lt;span&gt;);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        showToast(&lt;/span&gt;&quot;保存失败:&quot; + data.ErrorMessage, &quot;error&quot;&lt;span&gt;);
                    }
                },
                data: postData
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终我们是看到处理方式是在SaveExcelByGuid的控制器方法里面的，这个方法根据服务器的GUID，获取对应Excel文件的信息，然后进行读取和导入操作。&lt;/p&gt;
&lt;p&gt;这个方法的详细代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 在服务端保存Excel
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;guid&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; ActionResult SaveExcelByGuid(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; guid)
        {
            CommonResult result &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CommonResult();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(guid))
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; list = GetDevice(guid);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据guid获取对应的Excel文件，并把内容转换为对应的List&amp;lt;T&amp;gt;&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (list != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (DeviceInfo detail &lt;span&gt;in&lt;/span&gt;&lt;span&gt; list)
                    {
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isExist = BLLFactory&amp;lt;Device&amp;gt;.Instance.IsExistKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DeviceId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, detail.DeviceId);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isExist)
                        {
                            BLLFactory&lt;/span&gt;&amp;lt;Device&amp;gt;&lt;span&gt;.Instance.Insert(detail);
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;成功操作&lt;/span&gt;
                    result.Success = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    result.ErrorMessage &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;导入信息不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                result.ErrorMessage &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;导入信息不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ToJsonContent(result);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中我们看到 GetDevice(guid) 就是获取Excel文件内容并转换为对应的实体类列表过程的。&lt;/p&gt;
&lt;p&gt;其中的GetDevice就是转换为对应实体类集合的过程，代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取设备导入文件，转换为对应的实体类集合
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;guid&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;附件GUID&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; List&amp;lt;DeviceInfo&amp;gt; GetDevice(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; guid)
        {
            List&lt;/span&gt;&amp;lt;DeviceInfo&amp;gt; list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;DeviceInfo&amp;gt;&lt;span&gt;();

            DataTable table &lt;/span&gt;=&lt;span&gt; ConvertExcelFileToTable(guid);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (table != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 数据转换
                &lt;span&gt;foreach&lt;/span&gt; (DataRow dr &lt;span&gt;in&lt;/span&gt;&lt;span&gt; table.Rows)
                {
                    DeviceInfo info &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DeviceInfo();
                    info.DeviceId &lt;/span&gt;= dr[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;设备ID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString();
                    info.VersionInfo &lt;/span&gt;= dr[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;版本信息&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString();
                    info.MinitorInfo &lt;/span&gt;= dr[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;预留监控信息&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString();
                    info.DeviceMsisdn &lt;/span&gt;= dr[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;公话手机号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString();

                    list.Add(info);
                }
                &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而 ConvertExcelFileToTable 就是利用aspose.Cell的Excel操作控件，实现数据转换的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 从附件列表中获取第一个Excel文件，并转换Excel数据为对应的DataTable返回
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;guid&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;附件的Guid&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; DataTable ConvertExcelFileToTable(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; guid)
        {
            DataTable dt &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(guid))
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取上传附件的路径&lt;/span&gt;
                &lt;span&gt;string&lt;/span&gt; serverRealPath = BLLFactory&amp;lt;FileUpload&amp;gt;&lt;span&gt;.Instance.GetFirstFilePath(guid);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(serverRealPath))
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转换Excel文件到DatTable里面&lt;/span&gt;
                    &lt;span&gt;string&lt;/span&gt; error = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
                    dt &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataTable();
                    AsposeExcelTools.ExcelFileToDataTable(serverRealPath, &lt;/span&gt;&lt;span&gt;out&lt;/span&gt; dt, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; error);
                }
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dt;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样实现效果，不考虑用户勾选记录的情况，确认后直接对整个Excel文件进行判断导入操作，一般也是符合我们实际的导入过程的，这样处理起来，再也不会有前面介绍的那种情况了，至少我们能够顺利上传Excel文件，在后台读取Excel文件并转换是没有什么压力的，而且体验效果也很不错，非常快速。&lt;/p&gt;
&lt;p&gt;最后看看大量数据导入后，也能够快速刷新，并能够在分页控件进行展示了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/8867/201808/8867-20180831173927782-1359369128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 31 Aug 2018 15:47:00 +0000</pubDate>
<dc:creator>伍华聪</dc:creator>
<og:description>在早期Bootstrap框架介绍中，我的随笔《结合bootstrap fileinput插件和Bootstrap-table表格插件，实现文件上传、预览、提交的导入Excel数据操作流程》中介绍了利用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhuacong/p/9566946.html</dc:identifier>
</item>
<item>
<title>salesforce lightning零基础学习(六)Lightning Data Service(LDS) - zero.zhang</title>
<link>http://www.cnblogs.com/zero-zyq/p/9384437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zero-zyq/p/9384437.html</guid>
<description>&lt;p&gt;本篇可参看：&lt;a href=&quot;https://trailhead.salesforce.com/modules/lightning_data_service&quot; target=&quot;_blank&quot;&gt;https://trailhead.salesforce.com/modules/lightning_data_service&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Lightning中针对object的detail页面，一个lightning app可能包含了多个components,多个components不可避免的会对这个数据进行CRUD操作，如果我们针对每个component都在init操作时后台SQL进行查询，然后赋值给前台变量，进行CUD操作时，还要考虑其他component的数据是否要级联的改变，这种操作以及设计对于性能的影响还是蛮大的，有什么好的方法可以做到一次搜索或者一次加载，所有的components都共用吗？这个时候，LDS或许可以是你想要的。&lt;/p&gt;
&lt;p&gt;lightning中，我们使用 Lightning Data Service(LDS)去服务于数据层面，LDS 提供了对数据的访问。&lt;/p&gt;
&lt;p&gt;LDS除了可以让一个app的所有的component共用一个share的数据，这样一个更新以后，所有的component(model 为view)都会同步的刷新这个数据。还可以支持用户离线操作数据，当网络连接以后，用户对数据的操作则会进行同步。&lt;/p&gt;
&lt;p&gt;LDS优点概括来说：&lt;/p&gt;
&lt;p&gt;最小化的XMLHttpRequests&lt;/p&gt;
&lt;p&gt;数据只需要搜索一次。&lt;/p&gt;
&lt;p&gt;跨 components 分享数据记录&lt;/p&gt;
&lt;p&gt;当数据改变以后会创建通知。&lt;/p&gt;
&lt;p&gt;优点还有很多，当一个app 涉及到记录的简单的增删改查操作，使用LDS是一个最优的方式。&lt;/p&gt;
&lt;p&gt;说了这么多LDS的优点，那LDS如何使用呢？其实只需要在component中引入 &amp;lt;force:recordData&amp;gt;标签即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一. &amp;lt;force:recordData&amp;gt;属性介绍&lt;/strong&gt;&lt;br/&gt;&amp;lt;force:recordData&amp;gt;标签包含以下的常用属性：&lt;/p&gt;
&lt;p&gt;recordId : 指定哪条记录来加载，此字段为必须字段。&lt;/p&gt;
&lt;p&gt;mode: 指定当前的模式，有 View和Edit两个值。如果针对当前component有update操作，则mode设置为Edit。此字段为必须字段&lt;/p&gt;
&lt;p&gt;layoutType: 决定了哪个layout用于加载， FULL/COMPACT。&lt;/p&gt;
&lt;p&gt;fields: 决定哪些字段用来搜索出来&lt;/p&gt;
&lt;p&gt;layoutType以及fields至少有一个要求必须，因为管理员拥有更改pagelayout的权限，所以layoutType加载的字段具有不确定性，推荐使用fields。&lt;/p&gt;
&lt;p&gt;targetRecord: 此属性相当于这条记录ID对应的记录变量，通过此变量可以访问fields中指定的字段值。&lt;/p&gt;
&lt;p&gt;targetFields: targetRecord对应的字段的视图，通过此字段可以取出fields中的指定的值。&lt;/p&gt;
&lt;p&gt;通过上面的描述可以看出来targetRecord以及targetFields均可以取出fields中指定的字段值，他们两个写法尽管不同，但是他们的表达含义以及取得值相同，后面有具体的描述。&lt;/p&gt;
&lt;p&gt;targetError: 此属性存储Error Message, 如果记录没有正确的提供。&lt;/p&gt;
&lt;p&gt;recordUpdated：此属性指定当记录进行了CUD操作时的事件处理。&lt;/p&gt;
&lt;p&gt;简单Demo如下：其中 {v.accountFields.Name} 等同于{!v.record.fields.Name}.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt;=&quot;flexipage:availableForRecordHome,force:hasRecordId&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;record&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;Object&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;accountException&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;accountFields&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;Object&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;force:recordData
        &lt;/span&gt;&lt;span&gt;recordId&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordId}&quot;&lt;/span&gt;&lt;span&gt;
        aura:id&lt;/span&gt;&lt;span&gt;=&quot;accId&quot;&lt;/span&gt;&lt;span&gt;
        targetRecord&lt;/span&gt;&lt;span&gt;=&quot;{!v.record}&quot;&lt;/span&gt;&lt;span&gt;
        targetFields&lt;/span&gt;&lt;span&gt;=&quot;{!v.accountFields}&quot;&lt;/span&gt;&lt;span&gt;
                targetError&lt;/span&gt;&lt;span&gt;=&quot;{!v.accountException}&quot;&lt;/span&gt;&lt;span&gt;
        fields&lt;/span&gt;&lt;span&gt;=&quot;Id,Name,Industry&quot;&lt;/span&gt;&lt;span&gt;
        mode&lt;/span&gt;&lt;span&gt;=&quot;VIEW&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:card &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;=&quot;{!v.accountFields.Name}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:formattedText &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;=&quot;Industry&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;{!v.record.fields.Industry}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning:card&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 二. LDS的 CUD，错误提示以及自带的事件监听操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;force:recordData组件元素自带了好几个方法用来实现数据的简单的增删改操作。controller.js中通过获取到force:recordData元素后调用相关的方法即可进行DML操作。常用方法如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getNewRecord():创建一条新记录，通常用于insert操作，init handler中调用此方法创建一条ID为空的记录，此方法不会返回任何类型的callback function；&lt;/li&gt;
&lt;li&gt; saveRecord(): 用于 insert/update记录，此方法会返回一个 SaveRecordResult对象的callback function,SaveResult后面会详细介绍；&lt;/li&gt;
&lt;li&gt; deleteRecord():用于记录的delete操作，此方法会返回一个SaveRecordResult对象的callback function。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过上面的常用的三个方法，我们会关注到SaveRecordResult这个对象，此类作为CUD操作的callback返回的唯一参数，此对象具有以下的字段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;objectApiName：当前操作的object的 API name;&lt;/li&gt;
&lt;li&gt;entityLabel： 当前操作的object的label name;&lt;/li&gt;
&lt;li&gt;error: 如果发生系统或者自定义的操作此记录的错误，则返回在error字段里面,此error字段返回的类型为list，可以通过for循环迭代出所有的错误信息。如果当前的操作状态为操作成功（save state为success或者draft）则error为undefined;&lt;/li&gt;
&lt;li&gt;recordId: 当前操作记录的18位的ID;&lt;/li&gt;
&lt;li&gt;state: 返回当前操作的结果状态： SUCCESS(操作成功)/ DRAFT（Server不可达，本地存储成功）/ INCOMPLETE（Server不可达，本地不支持存储）/ERROR（存储错误，由于validation或者其他的原因）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;getNewRecord():此方法用于创建一个空的记录，方法有四个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;objectApiName： 需要创建的 object 的API name;&lt;/li&gt;
&lt;li&gt;recordTypeId:  需要创建的object的record type 的ID，如果没有指定，默认为default record type;&lt;/li&gt;
&lt;li&gt;skipCache：判断是否从server端获取object的template还是从客户端获取；&lt;/li&gt;
&lt;li&gt;callback：当object创建完以后的回调函数，此函数没有任何参数，创建完成以后会自动调用此方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;saveRecord():此方法用于create/edit操作，方法只有一个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;callback：当object create/update完成以后的回调函数，次函数也包含了一个参数，即上面提到的SaveResultResult对象的变量引用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;deleteRecord():此方法用于delete操作，方法也只有一个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;callback：当object delete完成以后的回调函数，次函数也包含了一个参数，即上面提到的SaveResultResult对象的变量引用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面说过，通过LDS可以在数据变化后，共用的component实时的刷新数据，&lt;span&gt;但是当两个同样的字段同时在Edit 模式下，则不会同时刷新，即刷新数据仅限于View模式下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 举个例子：Account 新增一个 Action，用来展示和更新Account的部分字段信息。&lt;/p&gt;
&lt;p&gt;1). accDisplay.cmp ： 用来展示主要的几个字段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt;=&quot;flexipage:availableForRecordHome,force:hasRecordId&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;record&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;Object&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;accountException&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;recordFields&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;Object&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;force:recordData
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;recordId&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordId}&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        aura:id&lt;/span&gt;&lt;span&gt;=&quot;accId&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        targetRecord&lt;/span&gt;&lt;span&gt;=&quot;{!v.record}&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        targetFields&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordFields}&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        fields&lt;/span&gt;&lt;span&gt;=&quot;Name,AccountNumber,Site&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        mode&lt;/span&gt;&lt;span&gt;=&quot;VIEW&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:card &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;=&quot;Acc View&quot;&lt;/span&gt;&lt;span&gt; iconName&lt;/span&gt;&lt;span&gt;=&quot;action:info&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:formattedText &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;=&quot;Name&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordFields.Name}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:formattedText &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;=&quot;Account Number&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordFields.AccountNumber}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:formattedText &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;=&quot;Site&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordFields.Site}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning:card&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2). accEdit2.cmp:更新固定的几个字段&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt;=&quot;force:hasRecordId, 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;                            force:lightningQuickActionWithoutHeader&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;record&quot;&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                    type&lt;/span&gt;&lt;span&gt;=&quot;Object&quot;&lt;/span&gt;&lt;span&gt; description&lt;/span&gt;&lt;span&gt;=&quot;current record reference&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;recordFields&quot;&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                    type&lt;/span&gt;&lt;span&gt;=&quot;Object&quot;&lt;/span&gt;&lt;span&gt; description&lt;/span&gt;&lt;span&gt;=&quot;current record fields list&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:attribute &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;recordError&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                    type&lt;/span&gt;&lt;span&gt;=&quot;String&quot;&lt;/span&gt;&lt;span&gt; description&lt;/span&gt;&lt;span&gt;=&quot;if error occurs,record error reference&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;force:recordData &lt;/span&gt;&lt;span&gt;aura:id&lt;/span&gt;&lt;span&gt;=&quot;editRecordId&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                      fields&lt;/span&gt;&lt;span&gt;=&quot;Name,AccountNumber,Site&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                      recordId&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordId}&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                      targetError&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordError}&quot;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                      targetRecord&lt;/span&gt;&lt;span&gt;=&quot;{!v.record}&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                      targetFields&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordFields}&quot;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                      mode&lt;/span&gt;&lt;span&gt;=&quot;EDIT&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                       &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Display an editing form &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;Edit Account Details&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:card &lt;/span&gt;&lt;span&gt;iconName&lt;/span&gt;&lt;span&gt;=&quot;action:edit&quot;&lt;/span&gt;&lt;span&gt; title&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordFields.Name}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;slds-p-horizontal--small&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:input &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;Name&quot;&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                                 value&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordFields.Name}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:input &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;Account Number&quot;&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                                 value&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordFields.AccountNumber}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:input &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;Site&quot;&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                                 value&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordFields.Site}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:button &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;Save&quot;&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                                  variant&lt;/span&gt;&lt;span&gt;=&quot;brand&quot;&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                                  onclick&lt;/span&gt;&lt;span&gt;=&quot;{!c.handleSaveRecord}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning:card&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; if error occurs, display operate error &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:if &lt;/span&gt;&lt;span&gt;isTrue&lt;/span&gt;&lt;span&gt;=&quot;{!not(empty(v.recordError))}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;recordError&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            {!v.recordError}
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3). AccComponent.cmp: 通过Tab方式展示数据信息，因为想要测试一个场景，所以此component里面引用了两遍accEdit2.cmp&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aura:component &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt;=&quot;flexipage:availableForAllPageTypes,force:lightningQuickAction,force:hasRecordId&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:tabSet &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;slds-tabs_scoped&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:tab &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;Acc View&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:AccDisplay &lt;/span&gt;&lt;span&gt;recordId&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordId}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning:tab&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:tab &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;Acc Edit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:AccEdit2 &lt;/span&gt;&lt;span&gt;recordId&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordId}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning:tab&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;lightning:tab &lt;/span&gt;&lt;span&gt;label&lt;/span&gt;&lt;span&gt;=&quot;Acc Edit2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c:AccEdit2 &lt;/span&gt;&lt;span&gt;recordId&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordId}&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning:tab&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;lightning:tabSet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aura:component&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 4). 新建一个Lightning Action,并且将此Action放在Page Layout中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201808/910966-20180831175613083-553310339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结果展示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 1.点击Edit Test会弹出Pop Up Window&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201808/910966-20180831180158216-1766308018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.在ACC EDIT Tab输入了内容点击Save以后，结果展示位ACC View的Tab会立刻显示输入后save的内容，而ACC Edit2 Tab则会保留原值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/910966/201808/910966-20180831180258863-849849277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 通过结果可以看出来，在mode为view情况下，save以后会立刻显示在view视图中。在mode为Edit情况下，如果edit1有某个字段更新，比如Account Number,则edit2的Account Number不会被更新。这种设计也是正常的，因为如果同步更新会有歧义，但是我们有一些场景还是希望Edit模式下也可以自动更新这些值得，这个时候就可以使用到自带的事件监听。&lt;/p&gt;
&lt;p&gt; 自带事件监听使用非常简单，只需要&amp;lt;force:recordData&amp;gt;标签增加属性：recordUpdated属性设置你需要后台controller绑定的handler即可。&lt;/p&gt;
&lt;p&gt;使用LDS的事件监听有4中类型： CHANGED / LOADED / REMOVED / ERROR。 从名字可以看出来分别对应着 更改 / 加载 / 移除 / 错误。&lt;/p&gt;
&lt;p&gt;下面我们针对上面的程序进行改进，对accEdit2.cmp 优化一下force:recordData组件元素&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;force:recordData &lt;/span&gt;&lt;span&gt;aura:id&lt;/span&gt;&lt;span&gt;=&quot;editRecord2Id&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;                      fields&lt;/span&gt;&lt;span&gt;=&quot;Name,AccountNumber,Site&quot;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;                      recordId&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordId}&quot;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;                      targetError&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordError}&quot;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;                      targetRecord&lt;/span&gt;&lt;span&gt;=&quot;{!v.record}&quot;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;                      targetFields&lt;/span&gt;&lt;span&gt;=&quot;{!v.recordFields}&quot;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;                      mode&lt;/span&gt;&lt;span&gt;=&quot;EDIT&quot;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; &lt;strong&gt;&lt;span&gt;                      recordUpdated&lt;/span&gt;&lt;span&gt;=&quot;{!c.reloadUpdate}&quot;&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;9&lt;/span&gt;                       &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对accEdit2Controller.js增加一个reloadUpdate方法，其中调用&lt;strong&gt;reloadRecord&lt;/strong&gt;()方法可以对force:recordData进行重新数据加载。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; reloadUpdate : &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(component, event, helper) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; eventParams =&lt;span&gt; event.getParams();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(eventParams.changeType == &quot;CHANGED&quot;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; get the changed fields for this record&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; changedFields =&lt;span&gt; eventParams.changedFields;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             console.log('Chaged Fields: ' +&lt;span&gt; JSON.stringify(changedFields));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             component.find('editRecordId'&lt;span&gt;).reloadRecord();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(eventParams.changeType === &quot;LOADED&quot;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             console.log(&quot;Record is loaded successfully.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(eventParams.changeType === &quot;REMOVED&quot;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; deleteRecordResult = $A.get(&quot;e.force:showToast&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            deleteRecordResult.setParams({
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &quot;title&quot;: &quot;Delete Result&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &quot;message&quot;: &quot;The record was deleted.&quot;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            deleteRecordResult.fire();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(eventParams.changeType === &quot;ERROR&quot;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             console.log('Error: ' + component.get(&quot;v.error&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;增强上述方法以后，在重新运行，当ACC Edit Tab中改了相关的值以后，ACC Edit2 Tab的值也会同步的更新，因为LDS已经加载成了最新的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（注意：调用reloadRecord()方法以后，会重新执行事件类型为LOADED的事件设置，demo中如果save以后会打出Record is loaded successfully.）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;使用LDS可以在不使用controller情况下便进行简单的CUD操作，很类似classic 中的standcontroller功能。这种方式在lightning中还是很常见的，但是如果涉及到复杂的数据关联的改动或者transaction中需要进行多次更新操作，建议不使用LDS换成后台controller中去做。篇中只弄了Edit的demo，new以及delete的demo感兴趣的可以自己去玩。篇中有错误的欢迎指出，有问题欢迎留言。&lt;/p&gt;
</description>
<pubDate>Fri, 31 Aug 2018 15:42:00 +0000</pubDate>
<dc:creator>zero.zhang</dc:creator>
<og:description>本篇可参看：https://trailhead.salesforce.com/modules/lightning_data_service Lightning中针对object的detail页面，一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zero-zyq/p/9384437.html</dc:identifier>
</item>
</channel>
</rss>