<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python：解析PDF文本及表格——pdfminer、tabula、pdfplumber 的用法及对比 - 丹枫无迹</title>
<link>http://www.cnblogs.com/gl1573/p/10064438.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gl1573/p/10064438.html</guid>
<description>&lt;p&gt;&lt;span&gt;pdf 是个异常坑爹的东西，有很多处理 pdf 的库，但是没有完美的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;pdfminer3k 是 pdfminer 的 python3 版本，主要用于读取 pdf 中的文本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;网上有很多 pdfminer3k 的代码示例，看过以后，只想吐槽一下，太复杂了，有违 python 的简洁。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; pdfminer.pdfparser &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PDFParser, PDFDocument
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; pdfminer.pdfinterp &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PDFResourceManager, PDFPageInterpreter
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; pdfminer.converter &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PDFPageAggregator
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; pdfminer.layout &lt;span&gt;import&lt;/span&gt;&lt;span&gt; LAParams, LTTextBox
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; pdfminer.pdfinterp &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PDFTextExtractionNotAllowed

path &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.pdf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用文件对象来创建一个pdf文档分析器&lt;/span&gt;
praser = PDFParser(open(path, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个PDF文档&lt;/span&gt;
doc =&lt;span&gt; PDFDocument()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 连接分析器 与文档对象&lt;/span&gt;
&lt;span&gt;praser.set_document(doc)
doc.set_parser(praser)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提供初始化密码&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 如果没有密码 就创建一个空的字符串&lt;/span&gt;
&lt;span&gt;doc.initialize()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检测文档是否提供txt转换，不提供就忽略&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; doc.is_extractable:
    &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;&lt;span&gt; PDFTextExtractionNotAllowed
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建PDf 资源管理器 来管理共享资源&lt;/span&gt;
    rsrcmgr =&lt;span&gt; PDFResourceManager()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个PDF设备对象&lt;/span&gt;
    laparams =&lt;span&gt; LAParams()
    device &lt;/span&gt;= PDFPageAggregator(rsrcmgr, laparams=&lt;span&gt;laparams)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个PDF解释器对象&lt;/span&gt;
    interpreter =&lt;span&gt; PDFPageInterpreter(rsrcmgr, device)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 循环遍历列表，每次处理一个page的内容&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; page &lt;span&gt;in&lt;/span&gt;&lt;span&gt; doc.get_pages():
        interpreter.process_page(page)                        
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 接受该页面的LTPage对象&lt;/span&gt;
        layout =&lt;span&gt; device.get_result()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里layout是一个LTPage对象，里面存放着这个 page 解析出的各种对象&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 包括 LTTextBox, LTFigure, LTImage, LTTextBoxHorizontal 等                            &lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt;&lt;span&gt; layout:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; isinstance(x, LTTextBox):
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(x.get_text().strip())
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;pdfminer 对于表格的处理非常的不友好，能提取出文字，但是没有格式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;pdf&lt;/strong&gt;&lt;strong&gt;表格截图：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/753333/201812/753333-20181204150044109-24451672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;代码运行结果：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/753333/201812/753333-20181204150309145-1058171726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;想把这个结果还原成表格可不容易，加的规则太多必然导致通用性的下降。&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;tabula 是专门用来提取PDF表格数据的，同时支持PDF导出为CSV、Excel格式，但是这工具是用 java 写的，依赖 java7/8。tabula-py 就是对它做了一层 python 的封装，所以也依赖 java7/8。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码很简单：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tabula

path &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.pdf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

df &lt;/span&gt;= tabula.read_pdf(path, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, pages=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;all&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; indexs &lt;span&gt;in&lt;/span&gt;&lt;span&gt; df.index:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(df.loc[indexs].values)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; tabula.convert_into(path, os.path.splitext(path)[0]+'.csv', pages='all')&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;虽然号称是专业处理 pdf 中的表格的，但实际效果也不咋地。还是 pdfminer 中使用的 pdf，运行结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/753333/201812/753333-20181204151103514-371644726.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这结果真的很尴尬啊，表头识别就错了，还有 pdf 中有两张表，我没发现怎么区分表。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;pdfplumber 是按页来处理 pdf 的，可以获得页面的所有文字，并且提供的单独的方法用于提取表格。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pdfplumber

path &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test.pdf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
pdf &lt;/span&gt;=&lt;span&gt; pdfplumber.open(path)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; page &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pdf.pages:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取当前页面的全部文本信息，包括表格中的文字&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(page.extract_text())                        &lt;/span&gt;

    &lt;span&gt;for&lt;/span&gt; table &lt;span&gt;in&lt;/span&gt;&lt;span&gt; page.extract_tables():
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(table)&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; table:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(row)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;---------- 分割线 ----------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

pdf.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;得到的 table 是个 string 类型的二维数组，这里为了跟 tabula 比较，按行输出显示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/753333/201812/753333-20181204151410400-726766967.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，跟 tabula 相比，首先是可以区分表格，其次，准确率也提高了很多，表头的识别完全正确。对于表格中有换行的，识别还不是很正确，但至少列的划分没问题，所以还是能处理的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pdfplumber
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re

path &lt;/span&gt;= r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\abc\服务中标结果__\下载\中标公告-六批大型施工.pdf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
pdf &lt;/span&gt;=&lt;span&gt; pdfplumber.open(path)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; page &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pdf.pages:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(page.extract_text())
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; pdf_table &lt;span&gt;in&lt;/span&gt;&lt;span&gt; page.extract_tables():
        table &lt;/span&gt;=&lt;span&gt; []
        cells &lt;/span&gt;=&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pdf_table:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; any(row):
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果一行全为空，则视为一条记录结束&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; any(cells):
                    table.append(cells)
                    cells &lt;/span&gt;=&lt;span&gt; []
            &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt;&lt;span&gt; all(row):
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果一行全不为空，则本条为新行，上一条结束&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; any(cells):
                    table.append(cells)
                    cells &lt;/span&gt;=&lt;span&gt; []
                table.append(row)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; len(cells) ==&lt;span&gt; 0:
                    cells &lt;/span&gt;=&lt;span&gt; row
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(row)):
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; row[i] &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
                            cells[i] &lt;/span&gt;= row[i] &lt;span&gt;if&lt;/span&gt; cells[i] &lt;span&gt;is&lt;/span&gt; None &lt;span&gt;else&lt;/span&gt; cells[i] +&lt;span&gt; row[i]
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; table:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;([re.sub(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\s+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, cell) &lt;span&gt;if&lt;/span&gt; cell &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; None &lt;span&gt;else&lt;/span&gt; None &lt;span&gt;for&lt;/span&gt; cell &lt;span&gt;in&lt;/span&gt;&lt;span&gt; row])
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;---------- 分割线 ----------&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

pdf.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;经过处理后，运行得到结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/753333/201812/753333-20181204151550612-1613839216.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这结果已经完全正确了，而用 tabula，即便是经过处理也是无法得到这样的结果的。当然对于不同的 pdf，可能需要不同的处理，实际情况还是要自己分析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pdfplumber 也有处理不准确的时候，主要表现在缺列：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我找了另一个 pdf，表格部分截图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/753333/201812/753333-20181204151751348-329425431.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解析结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/753333/201812/753333-20181204151853273-1493496352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4列变成了两列，另外，如果表格有合并单元格的情况，也会有这种问题，我挑这个表格展示是因为比较特殊，没有合并单元格也缺列了。这应该跟 pdf 生成的时候有关。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但其实数据是获取完整的，并没有丢，只是被认为是非表格了。输出 page.extract_text() 如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/753333/201812/753333-20181204152254631-888624681.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然后，我又用 tabula 试了下，结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/753333/201812/753333-20181204152602126-1978833373.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;列是齐了，但是，表头呢？？？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;pdfplumber 还提供了图形Debug功能，可以获得PDF页面的截图，并且用方框框起识别到的文字或表格，帮助判断PDF的识别情况，并且进行配置的调整。要使用这个功能，还需要安装ImageMagick。因为没有用到，所以暂时没有去细究。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;我们在做爬虫的时候，难免会遇到 pdf 需要解析，主要还是针对文本和表格的数据提取。而 python 处理 pdf 的库实在是太多太多了，比如还有 pypdf2，网上资料也比较多，但是我试了，读出来是乱码，没有仔细的读源码所以这个问题也没有解决。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而我对比较常用的3个库比较后觉得，还是 pdfplumber 比较好用，对表格的支持最好。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 04 Dec 2018 07:35:00 +0000</pubDate>
<dc:creator>丹枫无迹</dc:creator>
<og:description>pdf 是个异常坑爹的东西，有很多处理 pdf 的库，但是没有完美的。 一、pdfminer3k pdfminer3k 是 pdfminer 的 python3 版本，主要用于读取 pdf 中的文本。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gl1573/p/10064438.html</dc:identifier>
</item>
<item>
<title>.net core 2.x - docker-linux容器-持续集成(jenkins) - esoftor</title>
<link>http://www.cnblogs.com/Tmc-Blog/p/10064375.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tmc-Blog/p/10064375.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;嗯,持续集成,继上一篇我们继续本篇的持续集成.我们就直奔主题了,不扯淡不漫无边际的扯一堆理论,因为说得再多也不如一练.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;1.准备工作&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;先说明哈,以下操作都是在windows中:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　a).需要下载安装 jenkins 的windows版本&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　b).需要下载安装 docker for windows,安装之后使用的 linux容器,如果不知道的,可以看上一篇&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　c).我们这里的演示使用的github,所以需要一个git的账号,同时需要授权&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;呵呵,你可能会问为啥都是windows,因为我是windows系统,但是linux操作是一样的,看问后面的内容你就知道了.另外,jenkins的 docker的版本也有的,但是操作起来很吃力的,依旧的做了随笔没有发布出来,记录了很多错误.&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1.1.安装jenkins并配置github&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;jenkins获取地址:https://jenkins.io/download/  当前版本是2.138,安装不说了,安装之后可以ctrl+r驶入services.msc查看jenkins的服务是否启动,确定起来之后,我们在浏览器地址栏输入 http://localhost:8080访问jenkins的初始页面:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204140520534-1687807437.png&quot; alt=&quot;&quot; width=&quot;522&quot; height=&quot;253&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;选择第一个安装就行,安装完成之后需要我们解锁jenkins:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204140711617-1409702080.png&quot; alt=&quot;&quot; width=&quot;523&quot; height=&quot;444&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然这是linux下的界面,windows的界面在这个红字部分会把盘符也显示的,直接打开就好了,如果是docker的容器的话,需要先进入这个jenkins的容器,比如:我们就获取一下,先看下容器ID:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;docker container ls --all&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201811/557390-20181128160026080-959707902.png&quot; alt=&quot;&quot; width=&quot;524&quot; height=&quot;94&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取密码:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;docker exec -it 容器ID /bin/bash&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后输入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cat 页面上提供的文件路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201811/557390-20181128160240699-750971064.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就可以看到一个字符产串串了,复制贴进去就好,进入之后会让你设置一个账号密码,那么就设置就行了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204144313159-614766943.png&quot; alt=&quot;&quot; width=&quot;527&quot; height=&quot;477&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 设置完成之后进入到了jenkins的主页:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204144502866-1559238173.png&quot; alt=&quot;&quot; width=&quot;528&quot; height=&quot;325&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们继续进入: 系统管理 --&amp;gt;系统设置,划到下方的 github的配置:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204144744272-933348702.png&quot; alt=&quot;&quot; width=&quot;870&quot; height=&quot;197&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上面输入名称&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204145037155-1607871339.png&quot; alt=&quot;&quot; width=&quot;874&quot; height=&quot;297&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里注意下,点击凭据 的右边的问好,这里显示的  personal access token 跳转到 git的授权设置页面,按照下面的三个权限提示,勾上即可.然后下一步骤:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;点击凭据 Add:&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204144835582-82196310.png&quot; alt=&quot;&quot; width=&quot;392&quot; height=&quot;98&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204144900722-1592575198.png&quot; alt=&quot;&quot; width=&quot;867&quot; height=&quot;380&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入github的账号密码,ID和描述 随便填,点击添加,关闭弹窗&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204145427298-1474810807.png&quot; alt=&quot;&quot; width=&quot;868&quot; height=&quot;186&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后点击 连接测试 显示:&lt;img src=&quot;http://localhost:8080/static/f53c4408/images/none.gif&quot; alt=&quot;&quot; width=&quot;1&quot; height=&quot;16&quot;/&gt;Credentials verified for user 你的github名称,即表示验证成功了.&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1.2.jenkins创建构建项目(任务)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;以下内容比较简单,所以下面就看图操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204145856534-1519711524.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204145959503-432296263.png&quot; alt=&quot;&quot; width=&quot;878&quot; height=&quot;472&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204152502451-141539928.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204152424815-1454420896.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204150346168-646026547.png&quot; alt=&quot;&quot; width=&quot;1440&quot; height=&quot;324&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204150439189-1457486310.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204150511320-1037308549.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这因为我是windows的系统,使用的docker for windows,(虽然是linux容器),所以这里构建中选择的不是shell命令,而是windows的批处理命令:这是构建中的内容:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;echo '还原nuget包引用'&lt;span&gt;
dotnet restore

echo &lt;/span&gt;'编译项目'&lt;span&gt;
dotnet build ESoftor.sln -c Release

echo &lt;/span&gt;'发布发布项目 到指定目录,这我指定了我们dockerfile中设置的工作目录'&lt;span&gt;
dotnet publish ESoftor.WebApi/ESoftor.WebApi.csproj -o /esoftor-api-master

echo &lt;/span&gt;'接下来我们直接执行docker-compose.yaml文件即可,但是这里一定要注意,就是项目的配置文件中的而数据库连接,要改成和docker-compose中的数据库的services的名称一致,所以为了测试docker,我在git上创建了一个 esoftor4docker的分支'&lt;span&gt;
cd /esoftor-api-master

docker-compose build
docker-compose up&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这时候点击应用并保存即可.这里使用到的依旧是基于我们上一篇的内容,一个Dockerfile一个docker-compose.yml文件,这两个的配置稍有更改,参考如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Dockerfile:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 基于microsoft/dotnet:2.1&lt;span&gt;-sdk or dotnet:latest 默认latest 来创建我们的镜像
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; microsoft/dotnet

#指定docker的工作目录为 esoftor-master文件夹,也就是容器的默认的文件夹
&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /usr/local/src/esoftor-api-master
#&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /esoftor-api-master

# docker对外暴露的端口
&lt;/span&gt;&lt;span&gt;EXPOSE&lt;/span&gt; 60000&lt;span&gt;

# 将当前文件夹下的所有文件全部复制到工作目录(如果是在docker进行持续性继承,该行注释掉),如果单纯的只是迁移到docker,这里需要取消注释
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; . /usr/local/src/esoftor-api-master

#&lt;/span&gt;&lt;span&gt;CMD&lt;/span&gt;&lt;span&gt; dotnet ESoftor.WebApi.dll 这里自行百度 CMD和ENTRYPOINT的区别
&lt;/span&gt;&lt;span&gt;ENTRYPOINT&lt;/span&gt; [&quot;dotnet&quot;, &quot;ESoftor.WebApi.dll&quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;docker-compose.yml&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;version: &quot;3&quot;&lt;span&gt;

services:

  esoftor.api:
    image: esoftor.api:v1.&lt;/span&gt;0&lt;span&gt;
    environment:
      - ASPNETCORE_URLS=http:&lt;/span&gt;//0.0.0.0:60000
&lt;span&gt;      - ConnectionString=Server=sql.data;User=sa;Password=520Tmc1314!;Database=esoftor.source.novel2;    
    build:
      context: ./
      dockerfile: Dockerfile
    ports: 
      - &lt;/span&gt;&quot;8089:60000&quot;&lt;span&gt;
    volumes: 
      - ./:/usr/local/src/esoftor-api-master
    container_name: esoftor.api
    depends_on:
      - sql.data

  sql.data:
    image: microsoft/mssql-server-linux:&lt;/span&gt;2017&lt;span&gt;-latest
    environment:
      - SA_PASSWORD=520Tmc1314!
      - ACCEPT_EULA=Y
    ports:
      - &lt;/span&gt;&quot;14333:1433&quot;
      
      &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;将这两个文件放到你的项目的项目中即可:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204150915759-1607216485.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;注意点:&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　1.这里需要注意的是,这两个文件需要设置属性 为可复制 或者始终复制&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　2.Dockerfile和docker-compose中的路径配置一定要一致,docker-compose中的 volumes 的映射,冒号后面的路经必须是绝对路径,否则会报错&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;　　3.docker-compose.yml中的数据库连接配置和项目的连接配置记得要一直,其他.&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这时候我们的jenkins就配置完了,点击&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204151622110-416375859.png&quot; alt=&quot;&quot;/&gt;等待构建完成,这时候可以看构建的日志内容:如下:&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204151702211-2040410725.png&quot; alt=&quot;&quot; width=&quot;252&quot; height=&quot;217&quot;/&gt;:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204151746321-373927938.png&quot; alt=&quot;&quot; width=&quot;688&quot; height=&quot;277&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204151805549-1062106157.png&quot; alt=&quot;&quot; width=&quot;625&quot; height=&quot;313&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204151910142-1595317731.png&quot; alt=&quot;&quot; width=&quot;638&quot; height=&quot;145&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到这里就可以看到和我们上一篇的执行的熟悉的结果了.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 这时候我们看下我们的docker容器的列表:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204152844221-443027089.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以看到我们的项目和数据库都跑起来了,再看下是否可以访问:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557390/201812/557390-20181204152912413-589437363.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嗯,熟悉的界面,熟悉的感觉.就这样!&lt;/p&gt;

&lt;h3&gt;&lt;span&gt; 2.错误记录&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1. dotnet not found:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可能的原因是:　　1).没有安装docker没有pull microsoft/dotnet的镜像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　2).容器(系统)和构建用的指令不一致,也就是要区分下 windows用的是 批处理,linux用的shell.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. ERROR: for esoftor.api  Cannot create container for service esoftor.api: invalid volume specification: '/host_mnt/d/esoftor-api-master:./esoftor-api-master:rw': invalid mount config for type &quot;bind&quot;: invalid mount path: './esoftor-api-master' mount path must be absolute &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出现该错误,和 很明显的就是必须使用绝对路径,这里的绝对路径错误出现在docker-conpose.yml的 volumes映射;改成如下即可:&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;volumes: &lt;/span&gt;&lt;br/&gt;&lt;span&gt;- ./:/usr/local/src/esoftor-api-master&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3.Build timed out (after 10 minutes). Marking the build as aborted.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个问题也是很明显的,构建超时,,,其实不然,是你的配置有问题(如果你那个确定的程序没有问题的话).可以在 jenkins的执行日志的页面,ctrl+f输入exit进行搜索,一般的如果构建失败,上面肯定有某个或者某几个步骤是错误的,会提示exit.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 4.其他....部分忘记记录了,,,,,遇到再留言吧.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 04 Dec 2018 07:27:00 +0000</pubDate>
<dc:creator>esoftor</dc:creator>
<og:description>嗯,持续集成,继上一篇我们继续本篇的持续集成.我们就直奔主题了,不扯淡不漫无边际的扯一堆理论,因为说得再多也不如一练. 1.准备工作 先说明哈,以下操作都是在windows中: a).需要下载安装 j</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tmc-Blog/p/10064375.html</dc:identifier>
</item>
<item>
<title>听科技播客《津津乐道》了解了新知识 - SilentMacUser</title>
<link>http://www.cnblogs.com/refreshing/p/10064364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/refreshing/p/10064364.html</guid>
<description>&lt;p&gt;  播客节目提到了AS，AS到底是什么呢？&lt;/p&gt;
&lt;p&gt;听完了之后，赶紧去找找相关知识了，一下是我在知乎找到的：&lt;/p&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;div readability=&quot;20&quot;&gt;
&lt;p&gt;一个自治系统（Autonomous System，AS）是一组路由器的集合，它们拥有同样的选路策略、被同一技术管理部门管理运行。因此可以说自治系统是一同工作运行，以提供内部选路的内部网关协议的汇集。一个ISP(Internet Service Providers)可以称为一个自治系统，从外部世界来看，一个自治系统是一个单一实体。每个自治系统包含运行外部网关协议BGP和内部网关协议IGP的路由器，其中AS内部使用的IGP协议通常有OSPF和ISIS协议，外部网关协议BGP又分为eBGP和iBGP，eBGP负责在AS之间交换可达性信息，而iBGP负责在AS内部交换外来的可达性信息。&lt;/p&gt;
&lt;p&gt;每个自治系统有一个由因特网登记处或者ISP分配的识别码（ASN）。&lt;/p&gt;
&lt;p&gt;自治系统号ASN（Autonomous System Number）作为一种全球唯一且空间有限的互联网资源，同Internet的IP地址一样，其分配也是分级进行的，其分配机构的分级制度如0节所述。AS号有16比特和32比特的整数值表示的两种类型，目前普遍使用的是16比特整数值表示的类型，因此最大允许有65536个AS号码。其中64512到65535共1023个AS号码被预留用于本地或者私用，另外还有3个AS号作为特殊用途。其余64510个AS号码以AS Block形式在IANA和五大RIR中进行了分配。RIR在其数据库中保存了分配的自治系统的信息，&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;知乎作者：苏三&lt;br/&gt;知乎链接：https://www.zhihu.com/question/31237330/answer/57565774&lt;br/&gt;著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 04 Dec 2018 07:26:00 +0000</pubDate>
<dc:creator>SilentMacUser</dc:creator>
<og:description>播客节目提到了AS，AS到底是什么呢？ 听完了之后，赶紧去找找相关知识了，一下是我在知乎找到的： 一个自治系统（Autonomous System，AS）是一组路由器的集合，它们拥有同样的选路策略、被</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/refreshing/p/10064364.html</dc:identifier>
</item>
<item>
<title>从零单排学Redis【铂金二】 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/10064369.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/10064369.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;只有光头才能变强&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好的，今天我们要上【铂金二】了，如果还没有上铂金的，赶紧先去蹭蹭经验再回来(&lt;strong&gt;不然不带你上分了&lt;/strong&gt;)：&lt;/p&gt;
&lt;p&gt;在上篇中抛出了一个问题：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;抛个问题：如果从服务器挂了，没关系，我们一般会有多个从服务器，其他的请求可以交由没有挂的从服务器继续处理。如果主服务器挂了，怎么办？因为我们的写请求由主服务器处理，只有一台主服务器，那就无法处理写请求了？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Redis提供了&lt;strong&gt;哨兵(Sentinal)机制&lt;/strong&gt;供我们解决上面的情况。如果主服务器挂了，我们可以将从服务器&lt;strong&gt;升级&lt;/strong&gt;为主服务器，等到旧的主服务器(挂掉的那个)重连上来，会将它(挂掉的主服务器)变成从服务器。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个过程叫做&lt;strong&gt;主备切换&lt;/strong&gt;(故障转移)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在正常的情况下，主从加哨兵(Sentinal)机制是这样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/29/1675eb83ba331216?w=1443&amp;amp;h=657&amp;amp;f=png&amp;amp;s=36634&quot; alt=&quot;正常情况下&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主服务器挂了，主从复制操作就中止了，并且哨兵系统是可以察觉出主服务挂了。：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/4/16777e4bc6693ea7?w=1247&amp;amp;h=658&amp;amp;f=png&amp;amp;s=37958&quot; alt=&quot;Sentinel可以察觉主服务掉线，复制操作中止。&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Redis提供哨兵机制可以将&lt;strong&gt;选举&lt;/strong&gt;一台从服务器变成主服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/4/16777e4bc6975cfd?w=1369&amp;amp;h=721&amp;amp;f=png&amp;amp;s=38376&quot; alt=&quot;选举一台从服务器变成主服务器&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后旧的主服务器如果重连了，会变成从服务器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/4/16777e4bc6e0775d?w=1467&amp;amp;h=713&amp;amp;f=png&amp;amp;s=49142&quot; alt=&quot;旧的主服务器如果重连了，会变成从服务器&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这篇文章主要讲讲Redis的哨兵(Sentinal)机制的一些细节。希望看完对大家有所帮助~&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;High Availability: Redis Sentinel is the official high availability solution for Redis.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;哨兵(Sentinal)机制主要用于实现Redis的&lt;strong&gt;高可用性&lt;/strong&gt;，主要的功能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Monitoring. Sentinel constantly checks if your master and slave instances are working as expected.
&lt;ul&gt;&lt;li&gt;Sentinel&lt;strong&gt;不停地监控&lt;/strong&gt;Redis主从服务器是否正常工作&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Notification. Sentinel can notify the system administrator, another computer programs, via an API, that something is wrong with one of the monitored Redis instances.
&lt;ul&gt;&lt;li&gt;如果某个Redis实例有故障，那么哨兵负责&lt;strong&gt;发送消息通知&lt;/strong&gt;管理员&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Automatic failover. If a master is not working as expected, Sentinel can start a failover process where a slave is promoted to master, the other additional slaves are reconfigured to use the new master, and the applications using the Redis server informed about the new address to use when connecting.
&lt;ul&gt;&lt;li&gt;如果主服务器挂掉了，会&lt;strong&gt;自动&lt;/strong&gt;将从服务器提升为主服务器(包括配置都会修改)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Configuration provider. Sentinel acts as a source of authority for clients service discovery: clients connect to Sentinels in order to ask for the address of the current Redis master responsible for a given service. If a failover occurs, Sentinels will report the new address.
&lt;ul&gt;&lt;li&gt;Sentinel可以作为&lt;strong&gt;配置中心&lt;/strong&gt;，能够提供当前主服务器的信息。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面来具体讲讲Sentinel是如何将从服务器提升为主服务器的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;tips:Sentinel可以让我们的Redis实现高可用，Sentinel作为这么一个组件，自身也必然是高可用的(&lt;strong&gt;不可能是单点的&lt;/strong&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;启动和初始化sentinel&quot;&gt;1.1启动和初始化Sentinel&lt;/h2&gt;
&lt;p&gt;首先我们要知道的是：Sentinel本质上只是一个&lt;strong&gt;运行在特殊模式下的Redis服务器&lt;/strong&gt;。因为Sentinel做的事情和Redis服务器是不一样的，所以它们的初始化是有所区别的(比如，Sentinel在初始化的时候并不会载入AOF/RDB文件，因为Sentinel根本就不用数据库)。&lt;/p&gt;
&lt;p&gt;然后，在启动的时候会将普通Redis服务器的代码替换成&lt;strong&gt;Sentinel专用代码&lt;/strong&gt;。(所以Sentinel虽然作为Redis服务器，但是它不能执行SET、DBSIZE等等命令，因为命令表的代码被替换了)&lt;/p&gt;
&lt;p&gt;接着，初始化Sentinel的状态，并根据给定的配置文件&lt;strong&gt;初始化&lt;/strong&gt;Sentinel监视的&lt;strong&gt;主服务器列表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/4/16777e4bc6f575a7?w=1304&amp;amp;h=712&amp;amp;f=png&amp;amp;s=22112&quot; alt=&quot;初始化&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，Sentinel会创建两个&lt;strong&gt;连向主服务器的网络连接&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;命令连接(发送和接收命令)&lt;/li&gt;
&lt;li&gt;订阅连接(订阅主服务器的&lt;code&gt;_sentinel_:hello&lt;/code&gt;频道)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/4/16777e4bc70967bf?w=1037&amp;amp;h=736&amp;amp;f=png&amp;amp;s=46609&quot; alt=&quot;创建网络连接&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;获取和更新信息&quot;&gt;1.2获取和更新信息&lt;/h2&gt;
&lt;p&gt;Sentinel通过主服务器发送INFO命令来获得主服务器属下所有从服务器的地址信息，并为这些从服务器创建相应的实例结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/4/16777e4bc8c318f4?w=1112&amp;amp;h=655&amp;amp;f=png&amp;amp;s=34536&quot; alt=&quot;更新实例结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当发现有&lt;strong&gt;新的从服务器出现时&lt;/strong&gt;，除了创建对应的从服务器实例结构，Sentinel还会创建命令连接和订阅连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/4/16777e4c20a584f0?w=581&amp;amp;h=462&amp;amp;f=png&amp;amp;s=34372&quot; alt=&quot;创建连接&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Sentinel运行的过程中，通过命令连接会以每两秒一次的频率向&lt;strong&gt;监视的主从服务器&lt;/strong&gt;的&lt;code&gt;_sentinel_:hello频道&lt;/code&gt;发送命令(主要发送Sentinel本身的信息，监听主从服务器的信息)，并通过订阅连接接收&lt;code&gt;_sentinel_:hello频道&lt;/code&gt;的信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这样一来一回，我们就可以&lt;strong&gt;更新每个Sentinel实例结构的信息&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;判断主服务器是否下线了&quot;&gt;1.3判断主服务器是否下线了&lt;/h2&gt;
&lt;p&gt;判断主服务器是否下线有两种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主观下线
&lt;ul&gt;&lt;li&gt;Sentinel会以每秒一次的频率向与它创建命令连接的实例(包括主从服务器和其他的Sentinel)&lt;strong&gt;发送PING命令&lt;/strong&gt;，通过PING命令返回的信息判断实例是否在线&lt;/li&gt;
&lt;li&gt;如果一个&lt;strong&gt;主服务器&lt;/strong&gt;在&lt;code&gt;down-after-milliseconds&lt;/code&gt;毫秒内连续向Sentinel发送&lt;strong&gt;无效回复&lt;/strong&gt;，那么当前Sentinel就会&lt;strong&gt;主观认为&lt;/strong&gt;该主服务器已经下线了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;客观下线
&lt;ul&gt;&lt;li&gt;当Sentinel将一个主服务器判断为主观下线以后，为了确认该主服务器是否真的下线，它会向同样监视该主服务器的Sentinel&lt;strong&gt;询问&lt;/strong&gt;，看它们是否也认为该主服务器是否下线。&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;足够多&lt;/strong&gt;的Sentinel认为该主服务器是下线的，那么就判定该主服务为客观下线，并对主服务器执行故障转移操作。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在多少毫秒内无效回复才认定主服务器是主观下线的，以及有多少个Sentinel认为主服务器是下线才认定为客观下线。这都是&lt;strong&gt;可以配置&lt;/strong&gt;的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;选举领头sentinel和故障转移&quot;&gt;1.4选举领头Sentinel和故障转移&lt;/h2&gt;
&lt;p&gt;当一个主服务器认为为客观下线以后，监视这个下线的主服务器的各种Sentinel会进行协商，&lt;strong&gt;选举出一个领头的Sentinel&lt;/strong&gt;，领头的Sentinel会对下线的主服务器执行故障转移操作。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;选举领头Sentinel的规则也比较多，总的来说就是&lt;strong&gt;先到先得&lt;/strong&gt;(哪个快，就选哪个)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;选举出领头的Sentinel之后，领头的Sentinel会对已下线的主服务器执行故障转移操作，包括三个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在已下线主服务器&lt;strong&gt;属下的从服务器中&lt;/strong&gt;，挑选一个转换为主服务器&lt;/li&gt;
&lt;li&gt;让已下线主服务器属下的所有从服务器改为&lt;strong&gt;复制新的主服务器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;已下线的主服务器&lt;strong&gt;重新连接时&lt;/strong&gt;，让他成为新的主服务器的从服务器&lt;/li&gt;
&lt;li&gt;(这三步实际上就是文章开头的图片)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;挑选某一个从服务器作为主服务器也是有&lt;strong&gt;策略&lt;/strong&gt;的，大概如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;（1）跟master断开连接的时长&lt;/li&gt;
&lt;li&gt;（2）slave优先级&lt;/li&gt;
&lt;li&gt;（3）复制offset&lt;/li&gt;
&lt;li&gt;（4）run id&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章主要讲解了Sentinel的作用和工作的基本过程(我觉得已经基本OK了)，其中也涉及到了很多的细节，这里我就没有一一整理出来了。想要深入学习的同学最好自己看看书或者文档~~&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;tips:目前为止的主从+哨兵架构可以说Redis是高可用的，但要清楚的是：Redis还是会&lt;strong&gt;丢失数据&lt;/strong&gt;的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;丢失数据有两种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;异步复制导致的数据丢失
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;有部分数据还没复制到从服务器，主服务器就宕机了&lt;/strong&gt;，此时这些部分数据就丢失了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;脑裂导致的数据丢失
&lt;ul&gt;&lt;li&gt;有时候主服务器脱离了正常网络，跟其他从服务器不能连接。此时哨兵可能就会&lt;strong&gt;认为主服务器下线了&lt;/strong&gt;(然后开启选举，将某个从服务器切换成了主服务器)，但是实际上主服务器还运行着。这个时候，集群里就会有两个服务器(也就是所谓的脑裂)。&lt;/li&gt;
&lt;li&gt;虽然某个从服务器被切换成了主服务器，但是可能客户端&lt;strong&gt;还没来得及切换到新的主服务器&lt;/strong&gt;，客户端还继续写向旧主服务器写数据。旧的服务器重新连接时，会作为从服务器复制新的主服务器(这意味着旧数据丢失)。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以通过以下两个配置&lt;strong&gt;尽量&lt;/strong&gt;减少数据丢失的可能：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;
min-slaves-to-write 1
min-slaves-max-lag 10
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从零单排学Redis【铂金三】，敬请期待~&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;《Redis设计与实现》&lt;/li&gt;
&lt;li&gt;《Redis实战》&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你觉得我写得还不错，了解一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/11/27/167554b3537ce518?w=300&amp;amp;h=390&amp;amp;f=png&amp;amp;s=14868&quot; alt=&quot;帅的人都关注了&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 04 Dec 2018 07:26:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<og:description>Redis哨兵机制，你想要的都有！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/10064369.html</dc:identifier>
</item>
<item>
<title>js 数组详细操作方法及解析合集 - 飞刀还问情</title>
<link>http://www.cnblogs.com/zhongchao666/p/10064235.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhongchao666/p/10064235.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在开发中，数组的使用场景非常多，平日中也涉及到很多数组的&lt;code&gt;api&lt;/code&gt;/相关操作，一直也没有对这块内容进行一块整理总结，很多时候就算用过几次这个&lt;code&gt;api&lt;/code&gt;，在开发中也很容易忘记，还是要谷歌一下。所以就希望对这块内容有一个比较系统性的总结，在这背景下，就有了本篇文章，如果喜欢的话可以点波赞/关注，支持一下，希望大家看完本文可以有所收获。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;本文篇幅较长建议点赞保存再看也便于日后翻阅&quot;&gt;本文篇幅较长，建议点赞保存再看，也便于日后翻阅。&lt;/h2&gt;
&lt;hr/&gt;&lt;h3 id=&quot;创建一个数组&quot;&gt;创建一个数组:&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// 字面量方式:
// 这个方法也是我们最常用的，在初始化数组的时候 相当方便
var a = [3, 11, 8];  // [3,11,8];
// 构造器:
// 实际上 new Array === Array,加不加new 一点影响都没有。
var a = Array(); // [] 
var a = Array(3); // [undefined,undefined,undefined]
var a = Array(3,11,8); // [ 3,11,8 ]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;es6-array.of-返回由所有参数值组成的数组&quot;&gt;ES6 Array.of() 返回由所有参数值组成的数组&lt;/h4&gt;
&lt;p&gt;定义：返回由所有参数值组成的数组，如果没有参数，就返回一个空数组。&lt;/p&gt;
&lt;p&gt;目的：Array.of() 出现的目的是为了解决上述构造器因参数个数不同，导致的行为有差异的问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = Array.of(3, 11, 8); // [3,11,8]
let a = Array.of(3); // [3]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;es6-arrar.from-将两类对象转为真正的数组&quot;&gt;ES6 Arrar.from() 将两类对象转为真正的数组&lt;/h4&gt;
&lt;p&gt;定义：用于将两类对象转为真正的数组（不改变原对象，返回新的数组）。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;第一个参数(必需):要转化为真正数组的对象。&lt;/p&gt;
&lt;p&gt;第二个参数(可选): 类似数组的map方法，对每个元素进行处理，将处理后的值放入返回的数组。&lt;/p&gt;
&lt;p&gt;第三个参数(可选): 用来绑定this。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 1. 对象拥有length属性
let obj = {0: 'a', 1: 'b', 2:'c', length: 3};
let arr = Array.from(obj); // ['a','b','c'];
// 2. 部署了 Iterator接口的数据结构 比如:字符串、Set、NodeList对象
let arr = Array.from('hello'); // ['h','e','l','l']
let arr = Array.from(new Set(['a','b'])); // ['a','b']&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;方法&quot;&gt;方法:&lt;/h2&gt;
&lt;p&gt;数组原型提供了非常多的方法，这里分为三类来讲，一类会改变原数组的值，一类是不会改变原数组，以及数组的遍历方法。&lt;/p&gt;
&lt;h3 id=&quot;改变原数组的方法9个&quot;&gt;改变原数组的方法(9个):&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let a = [1,2,3];
ES5:
a.pop()/ a.shift()/  a.push()/ a.unshift()/ a.reverse()/  a.splice()/ a.sort() 
ES6:
a.copyWithin() / a.fill&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于这些能够改变原数组的方法，要注意避免在循环遍历中改变原数组的选项，比如: 改变数组的长度，导致遍历的长度出现问题。&lt;/p&gt;
&lt;h4 id=&quot;pop-删除一个数组中的最后的一个元素&quot;&gt;pop() 删除一个数组中的最后的一个元素&lt;/h4&gt;
&lt;p&gt;定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。&lt;/p&gt;
&lt;p&gt;参数: 无。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let  a =  [1,2,3];
let item = a.pop();  // 3
console.log(a); // [1,2]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;shift-删除数组的第一个元素&quot;&gt;shift() 删除数组的第一个元素&lt;/h4&gt;
&lt;p&gt;定义: shift()方法删除数组的第一个元素，并返回这个元素。&lt;/p&gt;
&lt;p&gt;参数: 无。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let  a =  [1,2,3];
let item = a.shift();  // 1
console.log(a); // [2,3]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;push-向数组的末尾添加元素&quot;&gt;push() 向数组的末尾添加元素&lt;/h4&gt;
&lt;p&gt;定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。&lt;/p&gt;
&lt;p&gt;参数: item1, item2, …, itemX ,要添加到数组末尾的元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let  a =  [1,2,3];
let item = a.push('末尾');  // 4
console.log(a); // [1,2,3,'末尾']&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;unshift&quot;&gt;unshift()&lt;/h4&gt;
&lt;p&gt;定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。&lt;/p&gt;
&lt;p&gt;参数: item1, item2, …, itemX ,要添加到数组开头的元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let  a =  [1,2,3];
let item = a.unshift('开头');  // 4
console.log(a); // ['开头',1,2,3]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;reverse-颠倒数组中元素的顺序&quot;&gt;reverse() 颠倒数组中元素的顺序&lt;/h4&gt;
&lt;p&gt;定义: reverse() 方法用于颠倒数组中元素的顺序。&lt;/p&gt;
&lt;p&gt;参数: 无&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let  a =  [1,2,3];
a.reverse();  
console.log(a); // [3,2,1]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;splice-添加删除数组元素&quot;&gt;splice() 添加/删除数组元素&lt;/h4&gt;
&lt;p&gt;定义： splice() 方法&lt;strong&gt;向/从数组中添加/删除&lt;/strong&gt;项目，然后返回被删除的项目&lt;/p&gt;
&lt;p&gt;语法： &lt;code&gt;array.splice(index,howmany,item1,.....,itemX)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。&lt;/li&gt;
&lt;li&gt;howmany：必需。要删除的项目数量。如果设置为 0，则不会删除项目。&lt;/li&gt;
&lt;li&gt;item1, …, itemX： 可选。向数组添加的新项目。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;返回值: 如果有元素被删除,返回包含被删除项目的新数组。&lt;/p&gt;
&lt;p&gt;eg1:删除元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = [1, 2, 3, 4, 5, 6, 7];
let item = a.splice(0, 3); // [1,2,3]
console.log(a); // [4,5,6,7]
// 从数组下标0开始，删除3个元素
let item = a.splice(-1, 3); // [7]
// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;eg2: 删除并添加&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; let a = [1, 2, 3, 4, 5, 6, 7];
let item = a.splice(0,3,'添加'); // [1,2,3]
console.log(a); // ['添加',4,5,6,7]
// 从数组下标0开始，删除3个元素，并添加元素'添加'
 let b = [1, 2, 3, 4, 5, 6, 7];
let item = b.splice(-2,3,'添加1','添加2'); // [6,7]
console.log(b); // [1,2,3,4,5,'添加1','添加2']
// 从数组最后第二个元素开始，删除3个元素，并添加两个元素'添加1'、'添加2'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;eg3: 不删除只添加:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = [1, 2, 3, 4, 5, 6, 7];
let item = a.splice(0,0,'添加1','添加2'); // [] 没有删除元素，返回空数组
console.log(a); // ['添加1','添加2',1,2,3,4,5,6,7]
let b = [1, 2, 3, 4, 5, 6, 7];
let item = b.splice(-1,0,'添加1','添加2'); // [] 没有删除元素，返回空数组
console.log(b); // [1,2,3,4,5,6,'添加1','添加2',7] 在最后一个元素的前面添加两个元素&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述三个栗子可以得出:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数组如果元素不够，会删除到最后一个元素为止&lt;/li&gt;
&lt;li&gt;操作的元素，包括开始的那个元素&lt;/li&gt;
&lt;li&gt;可以添加很多个元素&lt;/li&gt;
&lt;li&gt;添加是在开始的元素前面添加的&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;sort-数组排序&quot;&gt;sort() 数组排序&lt;/h4&gt;
&lt;p&gt;定义: sort()方法对数组元素进行排序，并返回这个数组。&lt;/p&gt;
&lt;p&gt;参数可选: 规定排序顺序的比较函数。&lt;/p&gt;
&lt;p&gt;默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用&lt;code&gt;toString()&lt;/code&gt;方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 字符串排列 看起来很正常
var a = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];
a.sort(); // [&quot;Apple&quot;,&quot;Banana&quot;,&quot;Mango&quot;,&quot;Orange&quot;]
// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的
var    a = [10, 1, 3, 20,25,8];
console.log(a.sort()) // [1,10,20,25,3,8];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;比较函数的两个参数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若比较函数返回值&amp;lt;0，那么a将排到b的前面;&lt;/li&gt;
&lt;li&gt;若比较函数返回值=0，那么a 和 b 相对位置不变；&lt;/li&gt;
&lt;li&gt;若比较函数返回值&amp;gt;0，那么b 排在a 将的前面；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于sort()方法更深层级的内部实现以及处理机制可以看一下这篇文章&lt;a href=&quot;https://juejin.im/entry/59f7f3346fb9a04514635552&quot;&gt;深入了解javascript的sort方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sort排序常见用法&lt;/strong&gt;：&lt;/p&gt;
&lt;ol readability=&quot;27&quot;&gt;&lt;li readability=&quot;27&quot;&gt;
&lt;p&gt;数组元素为数字的升序、降序:&lt;/p&gt;
&lt;p&gt;var array = [10, 1, 3, 4,20,4,25,8];&lt;br/&gt;// 升序 a-b &amp;lt; 0 a将排到b的前面，按照a的大小来排序的&lt;br/&gt;// 比如被减数a是10，减数是20 10-20 &amp;lt; 0 被减数a(10)在减数b(20)前面&lt;br/&gt;array.sort(function(a,b){&lt;br/&gt;return a-b;&lt;br/&gt;});&lt;br/&gt;console.log(array); // [1,3,4,4,8,10,20,25];&lt;br/&gt;// 降序 被减数和减数调换了 20-10&amp;gt;0 被减数b(20)在减数a(10)的前面&lt;br/&gt;array.sort(function(a,b){&lt;br/&gt;return b-a;&lt;br/&gt;});&lt;br/&gt;console.log(array); // [25,20,10,8,4,4,3,1];&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;25&quot;&gt;
&lt;p&gt;数组多条件排序&lt;/p&gt;
&lt;p&gt;var array = [{id:10,age:2},{id:5,age:4},{id:6,age:10},{id:9,age:6},{id:2,age:8},{id:10,age:9}];&lt;br/&gt;array.sort(function(a,b){&lt;br/&gt;if(a.id === b.id){// 如果id的值相等，按照age的值降序&lt;br/&gt;return b.age - a.age&lt;br/&gt;}else{ // 如果id的值不相等，按照id的值升序&lt;br/&gt;return a.id - b.id&lt;br/&gt;}&lt;br/&gt;})&lt;br/&gt;// [{&quot;id&quot;:2,&quot;age&quot;:8},{&quot;id&quot;:5,&quot;age&quot;:4},{&quot;id&quot;:6,&quot;age&quot;:10},{&quot;id&quot;:9,&quot;age&quot;:6},{&quot;id&quot;:10,&quot;age&quot;:9},{&quot;id&quot;:10,&quot;age&quot;:2}]&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;自定义比较函数，天空才是你的极限&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;类似的：&lt;strong&gt;运用好返回值，我们可以写出任意符合自己需求的比较函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var array = [{name:'Koro1'},{name:'Koro1'},{name:'OB'},{name:'Koro1'},{name:'OB'},{name:'OB'}];
array.sort(function(a,b){
    if(a.name === 'Koro1'){// 如果name是'Koro1' 返回-1 ，-1&amp;lt;0 a排在b的前面
        return -1
    }else{ // 如果不是的话，a排在b的后面
      return 1
    }
})
// [{&quot;name&quot;:&quot;Koro1&quot;},{&quot;name&quot;:&quot;Koro1&quot;},{&quot;name&quot;:&quot;Koro1&quot;},{&quot;name&quot;:&quot;OB&quot;},{&quot;name&quot;:&quot;OB&quot;},{&quot;name&quot;:&quot;OB&quot;}] &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;es6-copywithin-指定位置的成员复制到其他位置&quot;&gt;ES6: copyWithin() 指定位置的成员复制到其他位置&lt;/h4&gt;
&lt;p&gt;定义: 在当前数组内部，将指定位置的成员复制到其他位置,并返回这个数组。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.copyWithin(target, start = 0, end = this.length)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;三个参数都是数值，如果不是，会自动转为数值.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;target（必需）：从该位置开始替换数据。如果为负值，表示倒数。&lt;/li&gt;
&lt;li&gt;start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。&lt;/li&gt;
&lt;li&gt;end（可选）：到该位置前停止读取数据，默认等于数组长度。使用负数可从数组结尾处规定位置。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;浏览器兼容(MDN): chrome 45,Edge 12,Firefox32,Opera 32,Safari 9, IE 不支持&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]
var a=['OB1','Koro1','OB2','Koro2','OB3','Koro3','OB4','Koro4','OB5','Koro5']
// 2位置开始被替换,3位置开始读取要替换的 5位置前面停止替换
a.copyWithin(2,3,5)
// [&quot;OB1&quot;,&quot;Koro1&quot;,&quot;Koro2&quot;,&quot;OB3&quot;,&quot;OB3&quot;,&quot;Koro3&quot;,&quot;OB4&quot;,&quot;Koro4&quot;,&quot;OB5&quot;,&quot;Koro5&quot;] &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述栗子:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一个参数是开始被替换的元素位置&lt;/li&gt;
&lt;li&gt;要替换数据的位置范围:从第二个参数是开始读取的元素，在第三个参数前面一个元素停止读取&lt;/li&gt;
&lt;li&gt;数组的长度不会改变&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读了几个元素就从开始被替换的地方替换几个元素&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;es6-fill-填充数组&quot;&gt;ES6: fill() 填充数组&lt;/h4&gt;
&lt;p&gt;定义: 使用给定值，填充一个数组。&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;第一个元素(必须): 要填充数组的值&lt;/p&gt;
&lt;p&gt;第二个元素(可选): 填充的开始位置,默认值为0&lt;/p&gt;
&lt;p&gt;第三个元素(可选)：填充的结束位置，默认是为&lt;code&gt;this.length&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7&quot;&gt;MDN浏览器兼容&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;['a', 'b', 'c'].fill(7)
// [7, 7, 7]
['a', 'b', 'c'].fill(7, 1, 2)
// ['a', 7, 'c']&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;不改变原数组的方法8个&quot;&gt;不改变原数组的方法(8个):&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;ES5：
join、toLocateString、toStrigin、slice、cancat、indexOf、lastIndexOf、
ES7：
includes&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;join-数组转字符串&quot;&gt;join() 数组转字符串&lt;/h4&gt;
&lt;p&gt;定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.join(str)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;str(可选): 指定要使用的分隔符，默认使用逗号作为分隔符。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a= ['hello','world'];
let str=a.join(); // 'hello,world'
let str2=a.join('+'); // 'hello+world'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用join方法或者下文说到的toString方法时，当数组中的元素也是数组或者是对象时会出现什么情况？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a= [['OBKoro1','23'],'test'];
let str1=a.join(); // OBKoro1,23,test
let b= [{name:'OBKoro1',age:'23'},'test'];
let str2 = b.join(); // [object Object],test
// 对象转字符串推荐JSON.stringify(obj);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，&lt;code&gt;join()/toString()&lt;/code&gt;方法在数组元素是数组的时候，会将里面的数组也调用&lt;code&gt;join()/toString()&lt;/code&gt;,如果是对象的话，对象会被转为&lt;code&gt;[object Object]&lt;/code&gt;字符串。&lt;/p&gt;
&lt;h4 id=&quot;tolocalestring-数组转字符串&quot;&gt;toLocaleString() 数组转字符串&lt;/h4&gt;
&lt;p&gt;定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.toLocaleString()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数：无。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a=[{name:'OBKoro1'},23,'abcd',new Date()];
let str=a.toLocaleString(); // [object Object],23,abcd,2018/5/28 下午1:52:20 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上述栗子：调用数组的&lt;code&gt;toLocaleString&lt;/code&gt;方法，数组中的每个元素都会调用自身的&lt;code&gt;toLocaleString&lt;/code&gt;方法，对象调用对象的&lt;code&gt;toLocaleString&lt;/code&gt;,Date调用Date的&lt;code&gt;toLocaleString&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;tostring-数组转字符串-不推荐&quot;&gt;toString() 数组转字符串 不推荐&lt;/h4&gt;
&lt;p&gt;定义: toString() 方法可把数组转换为由逗号链接起来的字符串。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.toString()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数: 无。&lt;/p&gt;
&lt;p&gt;该方法的效果和join方法一样，都是用于数组转字符串的，但是与join方法相比没有优势，也不能自定义字符串的分隔符，因此不推荐使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值得注意的是&lt;/strong&gt;：当数组和字符串操作的时候，js 会调用这个方法将数组自动转换成字符串&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let b= [ 'toString','演示'].toString(); // toString,演示
let a= ['调用toString','连接在我后面']+'啦啦啦'; // 调用toString,连接在我后面啦啦啦&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;slice-浅拷贝数组的元素&quot;&gt;slice() 浅拷贝数组的元素&lt;/h4&gt;
&lt;p&gt;定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：字符串也有一个slice() 方法是用来提取字符串的，不要弄混了。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.slice(begin, end);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为0。&lt;/p&gt;
&lt;p&gt;end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a= ['hello','world'];
let b=a.slice(0,1); // ['hello']
a[0]='改变原数组';
console.log(a,b); // ['改变原数组','world'] ['hello']
b[0]='改变拷贝的数组';
 console.log(a,b); // ['改变原数组','world'] ['改变拷贝的数组']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上：新数组是浅拷贝的，&lt;strong&gt;元素是简单数据类型，改变之后不会互相干扰&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果是&lt;strong&gt;复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a= [{name:'OBKoro1'}];
let b=a.slice();
console.log(b,a); // [{&quot;name&quot;:&quot;OBKoro1&quot;}]  [{&quot;name&quot;:&quot;OBKoro1&quot;}]
// a[0].name='改变原数组';
// console.log(b,a); // [{&quot;name&quot;:&quot;改变原数组&quot;}] [{&quot;name&quot;:&quot;改变原数组&quot;}]
// b[0].name='改变拷贝数组',b[0].koro='改变拷贝数组';
//  [{&quot;name&quot;:&quot;改变拷贝数组&quot;,&quot;koro&quot;:&quot;改变拷贝数组&quot;}] [{&quot;name&quot;:&quot;改变拷贝数组&quot;,&quot;koro&quot;:&quot;改变拷贝数组&quot;}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原因在定义上面说过了的：slice()是浅拷贝，对于复杂的数据类型浅拷贝，拷贝的只是指向原数组的指针，所以无论改变原数组，还是浅拷贝的数组，都是改变原数组的数据。&lt;/p&gt;
&lt;h4 id=&quot;cancat&quot;&gt;cancat&lt;/h4&gt;
&lt;p&gt;定义： 方法用于合并两个或多个数组，返回一个新数组。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var newArr =oldArray.concat(arrayX,arrayX,......,arrayX)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。&lt;/p&gt;
&lt;p&gt;eg1:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; let a = [1, 2, 3];
 let b = [4, 5, 6];
 //连接两个数组
 let newVal=a.concat(b); // [1,2,3,4,5,6]
 // 连接三个数组
 let c = [7, 8, 9]
 let newVal2 = a.concat(b, c); // [1,2,3,4,5,6,7,8,9]
 // 添加元素
 let newVal3 = a.concat('添加元素',b, c,'再加一个'); 
 // [1,2,3,&quot;添加元素&quot;,4,5,6,7,8,9,&quot;再加一个&quot;]
// 合并嵌套数组  会浅拷贝嵌套数组
let d = [1,2 ];
let f = [3,[4]];
let newVal4 = d.concat(f); // [1,2,3,[4]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ES6扩展运算符&lt;code&gt;...&lt;/code&gt;合并数组&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;因为ES6的语法更简洁易懂，所以现在合并数组我大部分采用&lt;code&gt;...&lt;/code&gt;来处理，&lt;code&gt;...&lt;/code&gt;运算符可以实现&lt;code&gt;cancat&lt;/code&gt;的每个栗子，且更简洁和具有高度自定义数组元素位置的效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = [2, 3, 4, 5]
let b = [ 4,...a, 4, 4]
console.log(a,b); //  [2, 3, 4, 5] [4,2,3,4,5,4,4]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多关于扩展符的详细内容移步阮一峰大神的&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/array#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6&quot;&gt;ECMAScript 6 入门&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;indexof-查找数组是否存在某个元素返回下标&quot;&gt;indexOf() 查找数组是否存在某个元素，返回下标&lt;/h4&gt;
&lt;p&gt;定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.indexOf(searchElement,fromIndex)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;searchElement(必须):被查找的元素&lt;/p&gt;
&lt;p&gt;fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。&lt;/p&gt;
&lt;p&gt;严格相等的搜索:&lt;/p&gt;
&lt;p&gt;数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等&lt;code&gt;===&lt;/code&gt;搜索元素，即&lt;strong&gt;数组元素要完全匹配&lt;/strong&gt;才能搜索成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：indexOf()不能识别&lt;code&gt;NaN&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a=['啦啦',2,4,24,NaN]
console.log(a.indexOf('啦'));  // -1 
console.log(a.indexOf('NaN'));  // -1 
console.log(a.indexOf('啦啦')); // 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5aad40e4f265da237f1e12ed#heading-10&quot;&gt;数组去重&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;根据获取的数组下标执行操作，改变数组中的值等。&lt;/li&gt;
&lt;li&gt;判断是否存在，执行操作。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;lastindexof-查找指定元素在数组中的最后一个位置&quot;&gt;lastIndexOf() 查找指定元素在数组中的最后一个位置&lt;/h4&gt;
&lt;p&gt;定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;arr.lastIndexOf(searchElement,fromIndex)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;searchElement(必须): 被查找的元素&lt;/p&gt;
&lt;p&gt;fromIndex(可选): 逆向查找开始位置，默认值数组的长度-1，即查找整个数组。&lt;/p&gt;
&lt;p&gt;关于fromIndex有三个规则:&lt;/p&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li&gt;正值。如果该值大于或等于数组的长度，则整个数组会被查找。&lt;/li&gt;
&lt;li&gt;负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)&lt;/li&gt;
&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。&lt;/p&gt;
&lt;p&gt;let a=['OB',4,'Koro1',1,2,'Koro1',3,4,5,'Koro1']; // 数组长度为10&lt;br/&gt;// let b=a.lastIndexOf('Koro1',4); // 从下标4开始往前找 返回下标2&lt;br/&gt;// let b=a.lastIndexOf('Koro1',100); // 大于或数组的长度 查找整个数组 返回9&lt;br/&gt;// let b=a.lastIndexOf('Koro1',-11); // -1 数组不会被查找&lt;br/&gt;let b=a.lastIndexOf('Koro1',-9); // 从第二个元素4往前查找，没有找到 返回-1&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;es7-includes-查找数组是否包含某个元素-返回布尔&quot;&gt;ES7 includes() 查找数组是否包含某个元素 返回布尔&lt;/h4&gt;
&lt;p&gt;定义： 返回一个布尔值，表示某个数组是否包含给定的值&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.includes(searchElement,fromIndex=0)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;searchElement(必须):被查找的元素&lt;/p&gt;
&lt;p&gt;fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;includes方法是为了弥补indexOf方法的缺陷而出现的:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;indexOf方法不能识别&lt;code&gt;NaN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于&lt;code&gt;-1&lt;/code&gt;，表达不够直观&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a=['OB','Koro1',1,NaN];
// let b=a.includes(NaN); // true 识别NaN
// let b=a.includes('Koro1',100); // false 超过数组长度 不搜索
// let b=a.includes('Koro1',-3);  // true 从倒数第三个元素开始搜索 
// let b=a.includes('Koro1',-100);  // true 负值绝对值超过数组长度，搜索整个数组&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;兼容性(MDN): chrome47, Firefox 43,Edge 14,Opera 34, Safari 9,IE 未实现。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;遍历方法12个&quot;&gt;遍历方法(12个):&lt;/h3&gt;
&lt;p&gt;js中遍历数组并不会改变原始数组的方法总共有12个:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ES5：
forEach、every 、some、 fliter、map、reduce、reduceRight、
ES6：
find、findIndex、keys、values、entries&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;关于遍历&quot;&gt;关于遍历：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;关于遍历的效率，可以看一下这篇&lt;a href=&quot;http://louiszhai.github.io/2015/12/18/traverse/#%E6%B5%8B%E8%AF%95%E5%90%84%E6%96%B9%E6%B3%95%E6%95%88%E7%8E%87&quot;&gt;详解JS遍历&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;尽量不要在遍历的时候，修改后面要遍历的值&lt;/li&gt;
&lt;li&gt;尽量不要在遍历的时候修改数组的长度（删除/添加）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;foreach&quot;&gt;forEach&lt;/h4&gt;
&lt;p&gt;定义: 按升序为数组中含有效值的每一项执行一次回调函数。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.forEach(function(currentValue, index, arr), thisValue)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 回调函数的参数
1. currentValue(必须),数组当前元素的值
2. index(可选), 当前元素的索引值
3. arr(可选),数组对象本身&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于forEach()你要知道&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无法中途退出循环，只能用&lt;code&gt;return&lt;/code&gt;退出本次回调，进行下一次回调。&lt;/li&gt;
&lt;li&gt;它总是返回 undefined值,即使你return了一个值。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;下面类似语法同样适用这些规则&quot;&gt;下面类似语法同样适用这些规则&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;1. 对于空数组是不会执行回调函数的
2. 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数
3. 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。
4. 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = [1, 2, ,3]; // 最后第二个元素是空的，不会遍历(undefined、null会遍历)
let obj = { name: 'OBKoro1' };
let result = a.forEach(function (value, index, array) { 
  a[3] = '改变元素';
  a.push('添加到尾端，不会被遍历')
  console.log(value, 'forEach传递的第一个参数'); // 分别打印 1 ,2 ,改变元素
  console.log(this.name); // OBKoro1 打印三次 this绑定在obj对象上
  // break; // break会报错
  return value; // return只能结束本次回调 会执行下次回调
  console.log('不会执行，因为return 会执行下一次循环回调')
}, obj);
console.log(result); // 即使return了一个值,也还是返回undefined
// 回调函数也接受接头函数写法&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;every-检测数组所有元素是否都符合判断条件&quot;&gt;every 检测数组所有元素是否都符合判断条件&lt;/h4&gt;
&lt;p&gt;定义: 方法用于检测数组所有元素是否都符合函数定义的条件&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.every(function(currentValue, index, arr), thisValue)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:(这几个方法的参数，语法都类似)&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 回调函数的参数
1. currentValue(必须),数组当前元素的值
2. index(可选), 当前元素的索引值
3. arr(可选),数组对象本身&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方法返回值规则:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果数组中检测到&lt;strong&gt;有一个元素不满足，则整个表达式返回 false&lt;/strong&gt;，且剩余的元素不会再进行检测。&lt;/li&gt;
&lt;li&gt;如果所有元素&lt;strong&gt;都满足条件，则返回 true&lt;/strong&gt;。=&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function isBigEnough(element, index, array) { 
  return element &amp;gt;= 10; // 判断数组中的所有元素是否都大于10
}
let result = [12, 5, 8, 130, 44].every(isBigEnough);   // false
let result = [12, 54, 18, 130, 44].every(isBigEnough); // true
// 接受箭头函数写法 
[12, 5, 8, 130, 44].every(x =&amp;gt; x &amp;gt;= 10); // false
[12, 54, 18, 130, 44].every(x =&amp;gt; x &amp;gt;= 10); // true&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;some-数组中的是否有满足判断条件的元素&quot;&gt;some 数组中的是否有满足判断条件的元素&lt;/h4&gt;
&lt;p&gt;定义：数组中的是否有满足判断条件的元素&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.some(function(currentValue, index, arr), thisValue)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:(这几个方法的参数，语法都类似)&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 回调函数的参数
1. currentValue(必须),数组当前元素的值
2. index(可选), 当前元素的索引值
3. arr(可选),数组对象本身&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方法返回值规则：&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li&gt;如果&lt;strong&gt;有一个元素满足条件，则表达式返回true&lt;/strong&gt;, 剩余的元素不会再执行检测。&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;如果&lt;strong&gt;没有满足条件的元素，则返回false&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;function isBigEnough(element, index, array) {&lt;br/&gt;return (element &amp;gt;= 10); //数组中是否有一个元素大于 10&lt;br/&gt;}&lt;br/&gt;let result = [2, 5, 8, 1, 4].some(isBigEnough); // false&lt;br/&gt;let result = [12, 5, 8, 1, 4].some(isBigEnough); // true&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;filter-过滤原始数组返回新数组&quot;&gt;filter 过滤原始数组，返回新数组&lt;/h4&gt;
&lt;p&gt;定义: 返回一个新数组, 其包含通过所提供函数实现的测试的所有元素。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let new_array = arr.filter(function(currentValue, index, arr), thisArg)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:(这几个方法的参数，语法都类似)&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 回调函数的参数
1. currentValue(必须),数组当前元素的值
2. index(可选), 当前元素的索引值
3. arr(可选),数组对象本身&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; let a = [32, 33, 16, 40];
let result = a.filter(function (value, index, array) {
  return value &amp;gt;= 18; // 返回a数组中所有大于18的元素
});
console.log(result,a);// [32,33,40] [32,33,16,40]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;map-对数组中的每个元素进行处理返回新的数组&quot;&gt;map 对数组中的每个元素进行处理，返回新的数组&lt;/h4&gt;
&lt;p&gt;定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let new_array = arr.map(function(currentValue, index, arr), thisArg)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:(这几个方法的参数，语法都类似)&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 回调函数的参数
1. currentValue(必须),数组当前元素的值
2. index(可选), 当前元素的索引值
3. arr(可选),数组对象本身&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = ['1','2','3','4'];
let result = a.map(function (value, index, array) {
  return value + '新数组的新元素'
});
console.log(result, a); 
// [&quot;1新数组的新元素&quot;,&quot;2新数组的新元素&quot;,&quot;3新数组的新元素&quot;,&quot;4新数组的新元素&quot;] [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;reduce-为数组提供累加器合并为一个值&quot;&gt;reduce 为数组提供累加器，合并为一个值&lt;/h4&gt;
&lt;p&gt;定义：reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，最终合并为一个值。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.reduce(function(total, currentValue, currentIndex, arr), initialValue)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 回调函数的参数
1. total(必须)，初始值, 或者上一次调用回调返回的值
2. currentValue(必须),数组当前元素的值
3. index(可选), 当前元素的索引值
4. arr(可选),数组对象本身&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;initialValue(可选): 指定第一次回调 的第一个参数。&lt;/p&gt;
&lt;p&gt;回调第一次执行时:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值；&lt;/li&gt;
&lt;li&gt;如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。&lt;/li&gt;
&lt;li&gt;如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 数组求和 
let sum = [0, 1, 2, 3].reduce(function (a, b) {
  return a + b;
}, 0);
// 6
// 将二维数组转化为一维 将数组元素展开
let flattened = [[0, 1], [2, 3], [4, 5]].reduce(
  (a, b) =&amp;gt; a.concat(b),
  []
);
 // [0, 1, 2, 3, 4, 5]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;reduceright-从右至左累加&quot;&gt;reduceRight 从右至左累加&lt;/h4&gt;
&lt;p&gt;这个方法除了与reduce执行方向相反外，其他完全与其一致，请参考上述 reduce 方法介绍。&lt;/p&gt;
&lt;h4 id=&quot;es6find-findindex-根据条件找到数组成员&quot;&gt;ES6：find()&amp;amp; findIndex() 根据条件找到数组成员&lt;/h4&gt;
&lt;p&gt;find()定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回undefined。&lt;/p&gt;
&lt;p&gt;findIndex()定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。&lt;/p&gt;
&lt;p&gt;这两个方法&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let new_array = arr.find(function(currentValue, index, arr), thisArg)
 let new_array = arr.findIndex(function(currentValue, index, arr), thisArg)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:(这几个方法的参数，语法都类似)&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 回调函数的参数
1. currentValue(必须),数组当前元素的值
2. index(可选), 当前元素的索引值
3. arr(可选),数组对象本身&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这两个方法都可以识别&lt;code&gt;NaN&lt;/code&gt;,弥补了&lt;code&gt;indexOf&lt;/code&gt;的不足.&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// find
let a = [1, 4, -5, 10].find((n) =&amp;gt; n &amp;lt; 0); // 返回元素-5
let b = [1, 4, -5, 10,NaN].find((n) =&amp;gt; Object.is(NaN, n));  // 返回元素NaN
// findIndex
let a = [1, 4, -5, 10].findIndex((n) =&amp;gt; n &amp;lt; 0); // 返回索引2
let b = [1, 4, -5, 10,NaN].findIndex((n) =&amp;gt; Object.is(NaN, n));  // 返回索引4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;浏览器兼容(MDN):Chrome 45,Firefox 25,Opera 32, Safari 8, Edge yes,&lt;/p&gt;
&lt;h4 id=&quot;es6-keysvaluesentries-遍历键名遍历键值遍历键名键值&quot;&gt;ES6 keys()&amp;amp;values()&amp;amp;entries() 遍历键名、遍历键值、遍历键名+键值&lt;/h4&gt;
&lt;p&gt;定义：三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.keys()
array.values()
array.entries()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数：无。&lt;/p&gt;
&lt;p&gt;遍历栗子(摘自&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/array#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-entries%EF%BC%8Ckeys-%E5%92%8C-values&quot;&gt;ECMAScript 6 入门&lt;/a&gt;)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 &quot;a&quot;
// 1 &quot;b&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;for..of&lt;/code&gt;中如果遍历中途要退出，可以使用&lt;code&gt;break&lt;/code&gt;退出循环。&lt;/p&gt;
&lt;p&gt;如果不使用&lt;code&gt;for...of&lt;/code&gt;循环，可以手动调用遍历器对象的next方法，进行遍历:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let letter = ['a', 'b', 'c'];
let entries = letter.entries();
console.log(entries.next().value); // [0, 'a']
console.log(entries.next().value); // [1, 'b']
console.log(entries.next().value); // [2, 'c']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;entries()浏览器兼容性(MDN):Chrome 38, Firefox 28,Opera 25,Safari 7.1&lt;/p&gt;
&lt;p&gt;keys()浏览器兼容性(MDN):Chrome 38, Firefox 28,Opera 25,Safari 8,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:目前只有Safari 9支持,，其他浏览器未实现，babel转码器也还未实现&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;参考资料&quot;&gt;参考资料：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/array&quot;&gt;ECMAScript6 入门 数组的扩展&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/aiynmimi/article/details/78667555&quot;&gt;JavaScript Array数组相关汇总&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/entry/59f7f3346fb9a04514635552&quot;&gt;深入了解javascript的sort方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5902d56e1b69e60058c634d6#heading-6&quot;&gt;【深度长文】JavaScript数组所有API全解密&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://louiszhai.github.io/2015/12/18/traverse/#%E6%B5%8B%E8%AF%95%E5%90%84%E6%96%B9%E6%B3%95%E6%95%88%E7%8E%87&quot;&gt;详解JS遍历&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zxhfighter.github.io/blog/javascript/2013/02/27/how-to-judge-a-variable-is-a-array.html&quot;&gt;判断一个变量是否为数组&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/19863166&quot;&gt;在 JavaScript 中，如何求出两个数组的交集和差集？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Measure&lt;/p&gt;
&lt;p&gt;Measure&lt;br/&gt;](&lt;/p&gt;

&lt;h2 id=&quot;前言-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在开发中，数组的使用场景非常多，平日中也涉及到很多数组的&lt;code&gt;api&lt;/code&gt;/相关操作，一直也没有对这块内容进行一块整理总结，很多时候就算用过几次这个&lt;code&gt;api&lt;/code&gt;，在开发中也很容易忘记，还是要谷歌一下。所以就希望对这块内容有一个比较系统性的总结，在这背景下，就有了本篇文章，如果喜欢的话可以点波赞/关注，支持一下，希望大家看完本文可以有所收获。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;本文篇幅较长建议点赞保存再看也便于日后翻阅-1&quot;&gt;本文篇幅较长，建议点赞保存再看，也便于日后翻阅。&lt;/h2&gt;
&lt;hr/&gt;&lt;h3 id=&quot;创建一个数组-1&quot;&gt;创建一个数组:&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;// 字面量方式:
// 这个方法也是我们最常用的，在初始化数组的时候 相当方便
var a = [3, 11, 8];  // [3,11,8];
// 构造器:
// 实际上 new Array === Array,加不加new 一点影响都没有。
var a = Array(); // [] 
var a = Array(3); // [undefined,undefined,undefined]
var a = Array(3,11,8); // [ 3,11,8 ]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;es6-array.of-返回由所有参数值组成的数组-1&quot;&gt;ES6 Array.of() 返回由所有参数值组成的数组&lt;/h4&gt;
&lt;p&gt;定义：返回由所有参数值组成的数组，如果没有参数，就返回一个空数组。&lt;/p&gt;
&lt;p&gt;目的：Array.of() 出现的目的是为了解决上述构造器因参数个数不同，导致的行为有差异的问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = Array.of(3, 11, 8); // [3,11,8]
let a = Array.of(3); // [3]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;es6-arrar.from-将两类对象转为真正的数组-1&quot;&gt;ES6 Arrar.from() 将两类对象转为真正的数组&lt;/h4&gt;
&lt;p&gt;定义：用于将两类对象转为真正的数组（不改变原对象，返回新的数组）。&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;第一个参数(必需):要转化为真正数组的对象。&lt;/p&gt;
&lt;p&gt;第二个参数(可选): 类似数组的map方法，对每个元素进行处理，将处理后的值放入返回的数组。&lt;/p&gt;
&lt;p&gt;第三个参数(可选): 用来绑定this。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 1. 对象拥有length属性
let obj = {0: 'a', 1: 'b', 2:'c', length: 3};
let arr = Array.from(obj); // ['a','b','c'];
// 2. 部署了 Iterator接口的数据结构 比如:字符串、Set、NodeList对象
let arr = Array.from('hello'); // ['h','e','l','l']
let arr = Array.from(new Set(['a','b'])); // ['a','b']&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;方法-1&quot;&gt;方法:&lt;/h2&gt;
&lt;p&gt;数组原型提供了非常多的方法，这里分为三类来讲，一类会改变原数组的值，一类是不会改变原数组，以及数组的遍历方法。&lt;/p&gt;
&lt;h3 id=&quot;改变原数组的方法9个-1&quot;&gt;改变原数组的方法(9个):&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;let a = [1,2,3];
ES5:
a.pop()/ a.shift()/  a.push()/ a.unshift()/ a.reverse()/  a.splice()/ a.sort() 
ES6:
a.copyWithin() / a.fill&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于这些能够改变原数组的方法，要注意避免在循环遍历中改变原数组的选项，比如: 改变数组的长度，导致遍历的长度出现问题。&lt;/p&gt;
&lt;h4 id=&quot;pop-删除一个数组中的最后的一个元素-1&quot;&gt;pop() 删除一个数组中的最后的一个元素&lt;/h4&gt;
&lt;p&gt;定义: pop() 方法删除一个数组中的最后的一个元素，并且返回这个元素。&lt;/p&gt;
&lt;p&gt;参数: 无。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let  a =  [1,2,3];
let item = a.pop();  // 3
console.log(a); // [1,2]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;shift-删除数组的第一个元素-1&quot;&gt;shift() 删除数组的第一个元素&lt;/h4&gt;
&lt;p&gt;定义: shift()方法删除数组的第一个元素，并返回这个元素。&lt;/p&gt;
&lt;p&gt;参数: 无。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let  a =  [1,2,3];
let item = a.shift();  // 1
console.log(a); // [2,3]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;push-向数组的末尾添加元素-1&quot;&gt;push() 向数组的末尾添加元素&lt;/h4&gt;
&lt;p&gt;定义：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。&lt;/p&gt;
&lt;p&gt;参数: item1, item2, …, itemX ,要添加到数组末尾的元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let  a =  [1,2,3];
let item = a.push('末尾');  // 4
console.log(a); // [1,2,3,'末尾']&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;unshift-1&quot;&gt;unshift()&lt;/h4&gt;
&lt;p&gt;定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。&lt;/p&gt;
&lt;p&gt;参数: item1, item2, …, itemX ,要添加到数组开头的元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let  a =  [1,2,3];
let item = a.unshift('开头');  // 4
console.log(a); // ['开头',1,2,3]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;reverse-颠倒数组中元素的顺序-1&quot;&gt;reverse() 颠倒数组中元素的顺序&lt;/h4&gt;
&lt;p&gt;定义: reverse() 方法用于颠倒数组中元素的顺序。&lt;/p&gt;
&lt;p&gt;参数: 无&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let  a =  [1,2,3];
a.reverse();  
console.log(a); // [3,2,1]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;splice-添加删除数组元素-1&quot;&gt;splice() 添加/删除数组元素&lt;/h4&gt;
&lt;p&gt;定义： splice() 方法&lt;strong&gt;向/从数组中添加/删除&lt;/strong&gt;项目，然后返回被删除的项目&lt;/p&gt;
&lt;p&gt;语法： &lt;code&gt;array.splice(index,howmany,item1,.....,itemX)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。&lt;/li&gt;
&lt;li&gt;howmany：必需。要删除的项目数量。如果设置为 0，则不会删除项目。&lt;/li&gt;
&lt;li&gt;item1, …, itemX： 可选。向数组添加的新项目。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;返回值: 如果有元素被删除,返回包含被删除项目的新数组。&lt;/p&gt;
&lt;p&gt;eg1:删除元素&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = [1, 2, 3, 4, 5, 6, 7];
let item = a.splice(0, 3); // [1,2,3]
console.log(a); // [4,5,6,7]
// 从数组下标0开始，删除3个元素
let item = a.splice(-1, 3); // [7]
// 从最后一个元素开始删除3个元素，因为最后一个元素，所以只删除了7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;eg2: 删除并添加&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; let a = [1, 2, 3, 4, 5, 6, 7];
let item = a.splice(0,3,'添加'); // [1,2,3]
console.log(a); // ['添加',4,5,6,7]
// 从数组下标0开始，删除3个元素，并添加元素'添加'
 let b = [1, 2, 3, 4, 5, 6, 7];
let item = b.splice(-2,3,'添加1','添加2'); // [6,7]
console.log(b); // [1,2,3,4,5,'添加1','添加2']
// 从数组最后第二个元素开始，删除3个元素，并添加两个元素'添加1'、'添加2'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;eg3: 不删除只添加:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = [1, 2, 3, 4, 5, 6, 7];
let item = a.splice(0,0,'添加1','添加2'); // [] 没有删除元素，返回空数组
console.log(a); // ['添加1','添加2',1,2,3,4,5,6,7]
let b = [1, 2, 3, 4, 5, 6, 7];
let item = b.splice(-1,0,'添加1','添加2'); // [] 没有删除元素，返回空数组
console.log(b); // [1,2,3,4,5,6,'添加1','添加2',7] 在最后一个元素的前面添加两个元素&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述三个栗子可以得出:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数组如果元素不够，会删除到最后一个元素为止&lt;/li&gt;
&lt;li&gt;操作的元素，包括开始的那个元素&lt;/li&gt;
&lt;li&gt;可以添加很多个元素&lt;/li&gt;
&lt;li&gt;添加是在开始的元素前面添加的&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;sort-数组排序-1&quot;&gt;sort() 数组排序&lt;/h4&gt;
&lt;p&gt;定义: sort()方法对数组元素进行排序，并返回这个数组。&lt;/p&gt;
&lt;p&gt;参数可选: 规定排序顺序的比较函数。&lt;/p&gt;
&lt;p&gt;默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用&lt;code&gt;toString()&lt;/code&gt;方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 字符串排列 看起来很正常
var a = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];
a.sort(); // [&quot;Apple&quot;,&quot;Banana&quot;,&quot;Mango&quot;,&quot;Orange&quot;]
// 数字排序的时候 因为转换成Unicode字符串之后，有些数字会比较大会排在后面 这显然不是我们想要的
var    a = [10, 1, 3, 20,25,8];
console.log(a.sort()) // [1,10,20,25,3,8];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;比较函数的两个参数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若比较函数返回值&amp;lt;0，那么a将排到b的前面;&lt;/li&gt;
&lt;li&gt;若比较函数返回值=0，那么a 和 b 相对位置不变；&lt;/li&gt;
&lt;li&gt;若比较函数返回值&amp;gt;0，那么b 排在a 将的前面；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于sort()方法更深层级的内部实现以及处理机制可以看一下这篇文章&lt;a href=&quot;https://juejin.im/entry/59f7f3346fb9a04514635552&quot;&gt;深入了解javascript的sort方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sort排序常见用法&lt;/strong&gt;：&lt;/p&gt;
&lt;ol readability=&quot;27&quot;&gt;&lt;li readability=&quot;27&quot;&gt;
&lt;p&gt;数组元素为数字的升序、降序:&lt;/p&gt;
&lt;p&gt;var array = [10, 1, 3, 4,20,4,25,8];&lt;br/&gt;// 升序 a-b &amp;lt; 0 a将排到b的前面，按照a的大小来排序的&lt;br/&gt;// 比如被减数a是10，减数是20 10-20 &amp;lt; 0 被减数a(10)在减数b(20)前面&lt;br/&gt;array.sort(function(a,b){&lt;br/&gt;return a-b;&lt;br/&gt;});&lt;br/&gt;console.log(array); // [1,3,4,4,8,10,20,25];&lt;br/&gt;// 降序 被减数和减数调换了 20-10&amp;gt;0 被减数b(20)在减数a(10)的前面&lt;br/&gt;array.sort(function(a,b){&lt;br/&gt;return b-a;&lt;br/&gt;});&lt;br/&gt;console.log(array); // [25,20,10,8,4,4,3,1];&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;25&quot;&gt;
&lt;p&gt;数组多条件排序&lt;/p&gt;
&lt;p&gt;var array = [{id:10,age:2},{id:5,age:4},{id:6,age:10},{id:9,age:6},{id:2,age:8},{id:10,age:9}];&lt;br/&gt;array.sort(function(a,b){&lt;br/&gt;if(a.id === b.id){// 如果id的值相等，按照age的值降序&lt;br/&gt;return b.age - a.age&lt;br/&gt;}else{ // 如果id的值不相等，按照id的值升序&lt;br/&gt;return a.id - b.id&lt;br/&gt;}&lt;br/&gt;})&lt;br/&gt;// [{&quot;id&quot;:2,&quot;age&quot;:8},{&quot;id&quot;:5,&quot;age&quot;:4},{&quot;id&quot;:6,&quot;age&quot;:10},{&quot;id&quot;:9,&quot;age&quot;:6},{&quot;id&quot;:10,&quot;age&quot;:9},{&quot;id&quot;:10,&quot;age&quot;:2}]&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;自定义比较函数，天空才是你的极限&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;类似的：&lt;strong&gt;运用好返回值，我们可以写出任意符合自己需求的比较函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var array = [{name:'Koro1'},{name:'Koro1'},{name:'OB'},{name:'Koro1'},{name:'OB'},{name:'OB'}];
array.sort(function(a,b){
    if(a.name === 'Koro1'){// 如果name是'Koro1' 返回-1 ，-1&amp;lt;0 a排在b的前面
        return -1
    }else{ // 如果不是的话，a排在b的后面
      return 1
    }
})
// [{&quot;name&quot;:&quot;Koro1&quot;},{&quot;name&quot;:&quot;Koro1&quot;},{&quot;name&quot;:&quot;Koro1&quot;},{&quot;name&quot;:&quot;OB&quot;},{&quot;name&quot;:&quot;OB&quot;},{&quot;name&quot;:&quot;OB&quot;}] &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;es6-copywithin-指定位置的成员复制到其他位置-1&quot;&gt;ES6: copyWithin() 指定位置的成员复制到其他位置&lt;/h4&gt;
&lt;p&gt;定义: 在当前数组内部，将指定位置的成员复制到其他位置,并返回这个数组。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.copyWithin(target, start = 0, end = this.length)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;三个参数都是数值，如果不是，会自动转为数值.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;target（必需）：从该位置开始替换数据。如果为负值，表示倒数。&lt;/li&gt;
&lt;li&gt;start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。&lt;/li&gt;
&lt;li&gt;end（可选）：到该位置前停止读取数据，默认等于数组长度。使用负数可从数组结尾处规定位置。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;浏览器兼容(MDN): chrome 45,Edge 12,Firefox32,Opera 32,Safari 9, IE 不支持&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]
var a=['OB1','Koro1','OB2','Koro2','OB3','Koro3','OB4','Koro4','OB5','Koro5']
// 2位置开始被替换,3位置开始读取要替换的 5位置前面停止替换
a.copyWithin(2,3,5)
// [&quot;OB1&quot;,&quot;Koro1&quot;,&quot;Koro2&quot;,&quot;OB3&quot;,&quot;OB3&quot;,&quot;Koro3&quot;,&quot;OB4&quot;,&quot;Koro4&quot;,&quot;OB5&quot;,&quot;Koro5&quot;] &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上述栗子:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一个参数是开始被替换的元素位置&lt;/li&gt;
&lt;li&gt;要替换数据的位置范围:从第二个参数是开始读取的元素，在第三个参数前面一个元素停止读取&lt;/li&gt;
&lt;li&gt;数组的长度不会改变&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;读了几个元素就从开始被替换的地方替换几个元素&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;es6-fill-填充数组-1&quot;&gt;ES6: fill() 填充数组&lt;/h4&gt;
&lt;p&gt;定义: 使用给定值，填充一个数组。&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;第一个元素(必须): 要填充数组的值&lt;/p&gt;
&lt;p&gt;第二个元素(可选): 填充的开始位置,默认值为0&lt;/p&gt;
&lt;p&gt;第三个元素(可选)：填充的结束位置，默认是为&lt;code&gt;this.length&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7&quot;&gt;MDN浏览器兼容&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;['a', 'b', 'c'].fill(7)
// [7, 7, 7]
['a', 'b', 'c'].fill(7, 1, 2)
// ['a', 7, 'c']&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;不改变原数组的方法8个-1&quot;&gt;不改变原数组的方法(8个):&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;ES5：
join、toLocateString、toStrigin、slice、cancat、indexOf、lastIndexOf、
ES7：
includes&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;join-数组转字符串-1&quot;&gt;join() 数组转字符串&lt;/h4&gt;
&lt;p&gt;定义: join() 方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.join(str)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;str(可选): 指定要使用的分隔符，默认使用逗号作为分隔符。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a= ['hello','world'];
let str=a.join(); // 'hello,world'
let str2=a.join('+'); // 'hello+world'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用join方法或者下文说到的toString方法时，当数组中的元素也是数组或者是对象时会出现什么情况？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a= [['OBKoro1','23'],'test'];
let str1=a.join(); // OBKoro1,23,test
let b= [{name:'OBKoro1',age:'23'},'test'];
let str2 = b.join(); // [object Object],test
// 对象转字符串推荐JSON.stringify(obj);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，&lt;code&gt;join()/toString()&lt;/code&gt;方法在数组元素是数组的时候，会将里面的数组也调用&lt;code&gt;join()/toString()&lt;/code&gt;,如果是对象的话，对象会被转为&lt;code&gt;[object Object]&lt;/code&gt;字符串。&lt;/p&gt;
&lt;h4 id=&quot;tolocalestring-数组转字符串-1&quot;&gt;toLocaleString() 数组转字符串&lt;/h4&gt;
&lt;p&gt;定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 toLocaleString() 返回值经调用 join() 方法连接（由逗号隔开）组成。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.toLocaleString()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数：无。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a=[{name:'OBKoro1'},23,'abcd',new Date()];
let str=a.toLocaleString(); // [object Object],23,abcd,2018/5/28 下午1:52:20 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上述栗子：调用数组的&lt;code&gt;toLocaleString&lt;/code&gt;方法，数组中的每个元素都会调用自身的&lt;code&gt;toLocaleString&lt;/code&gt;方法，对象调用对象的&lt;code&gt;toLocaleString&lt;/code&gt;,Date调用Date的&lt;code&gt;toLocaleString&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;tostring-数组转字符串-不推荐-1&quot;&gt;toString() 数组转字符串 不推荐&lt;/h4&gt;
&lt;p&gt;定义: toString() 方法可把数组转换为由逗号链接起来的字符串。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.toString()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数: 无。&lt;/p&gt;
&lt;p&gt;该方法的效果和join方法一样，都是用于数组转字符串的，但是与join方法相比没有优势，也不能自定义字符串的分隔符，因此不推荐使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值得注意的是&lt;/strong&gt;：当数组和字符串操作的时候，js 会调用这个方法将数组自动转换成字符串&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let b= [ 'toString','演示'].toString(); // toString,演示
let a= ['调用toString','连接在我后面']+'啦啦啦'; // 调用toString,连接在我后面啦啦啦&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;slice-浅拷贝数组的元素-1&quot;&gt;slice() 浅拷贝数组的元素&lt;/h4&gt;
&lt;p&gt;定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：字符串也有一个slice() 方法是用来提取字符串的，不要弄混了。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.slice(begin, end);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为0。&lt;/p&gt;
&lt;p&gt;end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a= ['hello','world'];
let b=a.slice(0,1); // ['hello']
a[0]='改变原数组';
console.log(a,b); // ['改变原数组','world'] ['hello']
b[0]='改变拷贝的数组';
 console.log(a,b); // ['改变原数组','world'] ['改变拷贝的数组']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上：新数组是浅拷贝的，&lt;strong&gt;元素是简单数据类型，改变之后不会互相干扰&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果是&lt;strong&gt;复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a= [{name:'OBKoro1'}];
let b=a.slice();
console.log(b,a); // [{&quot;name&quot;:&quot;OBKoro1&quot;}]  [{&quot;name&quot;:&quot;OBKoro1&quot;}]
// a[0].name='改变原数组';
// console.log(b,a); // [{&quot;name&quot;:&quot;改变原数组&quot;}] [{&quot;name&quot;:&quot;改变原数组&quot;}]
// b[0].name='改变拷贝数组',b[0].koro='改变拷贝数组';
//  [{&quot;name&quot;:&quot;改变拷贝数组&quot;,&quot;koro&quot;:&quot;改变拷贝数组&quot;}] [{&quot;name&quot;:&quot;改变拷贝数组&quot;,&quot;koro&quot;:&quot;改变拷贝数组&quot;}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原因在定义上面说过了的：slice()是浅拷贝，对于复杂的数据类型浅拷贝，拷贝的只是指向原数组的指针，所以无论改变原数组，还是浅拷贝的数组，都是改变原数组的数据。&lt;/p&gt;
&lt;h4 id=&quot;cancat-1&quot;&gt;cancat&lt;/h4&gt;
&lt;p&gt;定义： 方法用于合并两个或多个数组，返回一个新数组。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var newArr =oldArray.concat(arrayX,arrayX,......,arrayX)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。&lt;/p&gt;
&lt;p&gt;eg1:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; let a = [1, 2, 3];
 let b = [4, 5, 6];
 //连接两个数组
 let newVal=a.concat(b); // [1,2,3,4,5,6]
 // 连接三个数组
 let c = [7, 8, 9]
 let newVal2 = a.concat(b, c); // [1,2,3,4,5,6,7,8,9]
 // 添加元素
 let newVal3 = a.concat('添加元素',b, c,'再加一个'); 
 // [1,2,3,&quot;添加元素&quot;,4,5,6,7,8,9,&quot;再加一个&quot;]
// 合并嵌套数组  会浅拷贝嵌套数组
let d = [1,2 ];
let f = [3,[4]];
let newVal4 = d.concat(f); // [1,2,3,[4]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ES6扩展运算符&lt;code&gt;...&lt;/code&gt;合并数组&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;因为ES6的语法更简洁易懂，所以现在合并数组我大部分采用&lt;code&gt;...&lt;/code&gt;来处理，&lt;code&gt;...&lt;/code&gt;运算符可以实现&lt;code&gt;cancat&lt;/code&gt;的每个栗子，且更简洁和具有高度自定义数组元素位置的效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = [2, 3, 4, 5]
let b = [ 4,...a, 4, 4]
console.log(a,b); //  [2, 3, 4, 5] [4,2,3,4,5,4,4]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多关于扩展符的详细内容移步阮一峰大神的&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/array#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6&quot;&gt;ECMAScript 6 入门&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;indexof-查找数组是否存在某个元素返回下标-1&quot;&gt;indexOf() 查找数组是否存在某个元素，返回下标&lt;/h4&gt;
&lt;p&gt;定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.indexOf(searchElement,fromIndex)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;searchElement(必须):被查找的元素&lt;/p&gt;
&lt;p&gt;fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。&lt;/p&gt;
&lt;p&gt;严格相等的搜索:&lt;/p&gt;
&lt;p&gt;数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等&lt;code&gt;===&lt;/code&gt;搜索元素，即&lt;strong&gt;数组元素要完全匹配&lt;/strong&gt;才能搜索成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：indexOf()不能识别&lt;code&gt;NaN&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a=['啦啦',2,4,24,NaN]
console.log(a.indexOf('啦'));  // -1 
console.log(a.indexOf('NaN'));  // -1 
console.log(a.indexOf('啦啦')); // 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5aad40e4f265da237f1e12ed#heading-10&quot;&gt;数组去重&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;根据获取的数组下标执行操作，改变数组中的值等。&lt;/li&gt;
&lt;li&gt;判断是否存在，执行操作。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;lastindexof-查找指定元素在数组中的最后一个位置-1&quot;&gt;lastIndexOf() 查找指定元素在数组中的最后一个位置&lt;/h4&gt;
&lt;p&gt;定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;arr.lastIndexOf(searchElement,fromIndex)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;searchElement(必须): 被查找的元素&lt;/p&gt;
&lt;p&gt;fromIndex(可选): 逆向查找开始位置，默认值数组的长度-1，即查找整个数组。&lt;/p&gt;
&lt;p&gt;关于fromIndex有三个规则:&lt;/p&gt;
&lt;ol readability=&quot;7&quot;&gt;&lt;li&gt;正值。如果该值大于或等于数组的长度，则整个数组会被查找。&lt;/li&gt;
&lt;li&gt;负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)&lt;/li&gt;
&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。&lt;/p&gt;
&lt;p&gt;let a=['OB',4,'Koro1',1,2,'Koro1',3,4,5,'Koro1']; // 数组长度为10&lt;br/&gt;// let b=a.lastIndexOf('Koro1',4); // 从下标4开始往前找 返回下标2&lt;br/&gt;// let b=a.lastIndexOf('Koro1',100); // 大于或数组的长度 查找整个数组 返回9&lt;br/&gt;// let b=a.lastIndexOf('Koro1',-11); // -1 数组不会被查找&lt;br/&gt;let b=a.lastIndexOf('Koro1',-9); // 从第二个元素4往前查找，没有找到 返回-1&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;es7-includes-查找数组是否包含某个元素-返回布尔-1&quot;&gt;ES7 includes() 查找数组是否包含某个元素 返回布尔&lt;/h4&gt;
&lt;p&gt;定义： 返回一个布尔值，表示某个数组是否包含给定的值&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.includes(searchElement,fromIndex=0)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;searchElement(必须):被查找的元素&lt;/p&gt;
&lt;p&gt;fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;includes方法是为了弥补indexOf方法的缺陷而出现的:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;indexOf方法不能识别&lt;code&gt;NaN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于&lt;code&gt;-1&lt;/code&gt;，表达不够直观&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a=['OB','Koro1',1,NaN];
// let b=a.includes(NaN); // true 识别NaN
// let b=a.includes('Koro1',100); // false 超过数组长度 不搜索
// let b=a.includes('Koro1',-3);  // true 从倒数第三个元素开始搜索 
// let b=a.includes('Koro1',-100);  // true 负值绝对值超过数组长度，搜索整个数组&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;兼容性(MDN): chrome47, Firefox 43,Edge 14,Opera 34, Safari 9,IE 未实现。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;遍历方法12个-1&quot;&gt;遍历方法(12个):&lt;/h3&gt;
&lt;p&gt;js中遍历数组并不会改变原始数组的方法总共有12个:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ES5：
forEach、every 、some、 fliter、map、reduce、reduceRight、
ES6：
find、findIndex、keys、values、entries&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;关于遍历-1&quot;&gt;关于遍历：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;关于遍历的效率，可以看一下这篇&lt;a href=&quot;http://louiszhai.github.io/2015/12/18/traverse/#%E6%B5%8B%E8%AF%95%E5%90%84%E6%96%B9%E6%B3%95%E6%95%88%E7%8E%87&quot;&gt;详解JS遍历&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;尽量不要在遍历的时候，修改后面要遍历的值&lt;/li&gt;
&lt;li&gt;尽量不要在遍历的时候修改数组的长度（删除/添加）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;foreach-1&quot;&gt;forEach&lt;/h4&gt;
&lt;p&gt;定义: 按升序为数组中含有效值的每一项执行一次回调函数。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.forEach(function(currentValue, index, arr), thisValue)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 回调函数的参数
1. currentValue(必须),数组当前元素的值
2. index(可选), 当前元素的索引值
3. arr(可选),数组对象本身&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于forEach()你要知道&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无法中途退出循环，只能用&lt;code&gt;return&lt;/code&gt;退出本次回调，进行下一次回调。&lt;/li&gt;
&lt;li&gt;它总是返回 undefined值,即使你return了一个值。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;下面类似语法同样适用这些规则-1&quot;&gt;下面类似语法同样适用这些规则&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;1. 对于空数组是不会执行回调函数的
2. 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数
3. 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。
4. 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = [1, 2, ,3]; // 最后第二个元素是空的，不会遍历(undefined、null会遍历)
let obj = { name: 'OBKoro1' };
let result = a.forEach(function (value, index, array) { 
  a[3] = '改变元素';
  a.push('添加到尾端，不会被遍历')
  console.log(value, 'forEach传递的第一个参数'); // 分别打印 1 ,2 ,改变元素
  console.log(this.name); // OBKoro1 打印三次 this绑定在obj对象上
  // break; // break会报错
  return value; // return只能结束本次回调 会执行下次回调
  console.log('不会执行，因为return 会执行下一次循环回调')
}, obj);
console.log(result); // 即使return了一个值,也还是返回undefined
// 回调函数也接受接头函数写法&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;every-检测数组所有元素是否都符合判断条件-1&quot;&gt;every 检测数组所有元素是否都符合判断条件&lt;/h4&gt;
&lt;p&gt;定义: 方法用于检测数组所有元素是否都符合函数定义的条件&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.every(function(currentValue, index, arr), thisValue)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:(这几个方法的参数，语法都类似)&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 回调函数的参数
1. currentValue(必须),数组当前元素的值
2. index(可选), 当前元素的索引值
3. arr(可选),数组对象本身&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方法返回值规则:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果数组中检测到&lt;strong&gt;有一个元素不满足，则整个表达式返回 false&lt;/strong&gt;，且剩余的元素不会再进行检测。&lt;/li&gt;
&lt;li&gt;如果所有元素&lt;strong&gt;都满足条件，则返回 true&lt;/strong&gt;。=&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function isBigEnough(element, index, array) { 
  return element &amp;gt;= 10; // 判断数组中的所有元素是否都大于10
}
let result = [12, 5, 8, 130, 44].every(isBigEnough);   // false
let result = [12, 54, 18, 130, 44].every(isBigEnough); // true
// 接受箭头函数写法 
[12, 5, 8, 130, 44].every(x =&amp;gt; x &amp;gt;= 10); // false
[12, 54, 18, 130, 44].every(x =&amp;gt; x &amp;gt;= 10); // true&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;some-数组中的是否有满足判断条件的元素-1&quot;&gt;some 数组中的是否有满足判断条件的元素&lt;/h4&gt;
&lt;p&gt;定义：数组中的是否有满足判断条件的元素&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.some(function(currentValue, index, arr), thisValue)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:(这几个方法的参数，语法都类似)&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 回调函数的参数
1. currentValue(必须),数组当前元素的值
2. index(可选), 当前元素的索引值
3. arr(可选),数组对象本身&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方法返回值规则：&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li&gt;如果&lt;strong&gt;有一个元素满足条件，则表达式返回true&lt;/strong&gt;, 剩余的元素不会再执行检测。&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;如果&lt;strong&gt;没有满足条件的元素，则返回false&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;function isBigEnough(element, index, array) {&lt;br/&gt;return (element &amp;gt;= 10); //数组中是否有一个元素大于 10&lt;br/&gt;}&lt;br/&gt;let result = [2, 5, 8, 1, 4].some(isBigEnough); // false&lt;br/&gt;let result = [12, 5, 8, 1, 4].some(isBigEnough); // true&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;filter-过滤原始数组返回新数组-1&quot;&gt;filter 过滤原始数组，返回新数组&lt;/h4&gt;
&lt;p&gt;定义: 返回一个新数组, 其包含通过所提供函数实现的测试的所有元素。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let new_array = arr.filter(function(currentValue, index, arr), thisArg)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:(这几个方法的参数，语法都类似)&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 回调函数的参数
1. currentValue(必须),数组当前元素的值
2. index(可选), 当前元素的索引值
3. arr(可选),数组对象本身&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; let a = [32, 33, 16, 40];
let result = a.filter(function (value, index, array) {
  return value &amp;gt;= 18; // 返回a数组中所有大于18的元素
});
console.log(result,a);// [32,33,40] [32,33,16,40]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;map-对数组中的每个元素进行处理返回新的数组-1&quot;&gt;map 对数组中的每个元素进行处理，返回新的数组&lt;/h4&gt;
&lt;p&gt;定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let new_array = arr.map(function(currentValue, index, arr), thisArg)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:(这几个方法的参数，语法都类似)&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 回调函数的参数
1. currentValue(必须),数组当前元素的值
2. index(可选), 当前元素的索引值
3. arr(可选),数组对象本身&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let a = ['1','2','3','4'];
let result = a.map(function (value, index, array) {
  return value + '新数组的新元素'
});
console.log(result, a); 
// [&quot;1新数组的新元素&quot;,&quot;2新数组的新元素&quot;,&quot;3新数组的新元素&quot;,&quot;4新数组的新元素&quot;] [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;reduce-为数组提供累加器合并为一个值-1&quot;&gt;reduce 为数组提供累加器，合并为一个值&lt;/h4&gt;
&lt;p&gt;定义：reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，最终合并为一个值。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.reduce(function(total, currentValue, currentIndex, arr), initialValue)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 回调函数的参数
1. total(必须)，初始值, 或者上一次调用回调返回的值
2. currentValue(必须),数组当前元素的值
3. index(可选), 当前元素的索引值
4. arr(可选),数组对象本身&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;initialValue(可选): 指定第一次回调 的第一个参数。&lt;/p&gt;
&lt;p&gt;回调第一次执行时:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值；&lt;/li&gt;
&lt;li&gt;如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。&lt;/li&gt;
&lt;li&gt;如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 数组求和 
let sum = [0, 1, 2, 3].reduce(function (a, b) {
  return a + b;
}, 0);
// 6
// 将二维数组转化为一维 将数组元素展开
let flattened = [[0, 1], [2, 3], [4, 5]].reduce(
  (a, b) =&amp;gt; a.concat(b),
  []
);
 // [0, 1, 2, 3, 4, 5]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;reduceright-从右至左累加-1&quot;&gt;reduceRight 从右至左累加&lt;/h4&gt;
&lt;p&gt;这个方法除了与reduce执行方向相反外，其他完全与其一致，请参考上述 reduce 方法介绍。&lt;/p&gt;
&lt;h4 id=&quot;es6find-findindex-根据条件找到数组成员-1&quot;&gt;ES6：find()&amp;amp; findIndex() 根据条件找到数组成员&lt;/h4&gt;
&lt;p&gt;find()定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回undefined。&lt;/p&gt;
&lt;p&gt;findIndex()定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。&lt;/p&gt;
&lt;p&gt;这两个方法&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let new_array = arr.find(function(currentValue, index, arr), thisArg)
 let new_array = arr.findIndex(function(currentValue, index, arr), thisArg)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数:(这几个方法的参数，语法都类似)&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 回调函数的参数
1. currentValue(必须),数组当前元素的值
2. index(可选), 当前元素的索引值
3. arr(可选),数组对象本身&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为&lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这两个方法都可以识别&lt;code&gt;NaN&lt;/code&gt;,弥补了&lt;code&gt;indexOf&lt;/code&gt;的不足.&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// find
let a = [1, 4, -5, 10].find((n) =&amp;gt; n &amp;lt; 0); // 返回元素-5
let b = [1, 4, -5, 10,NaN].find((n) =&amp;gt; Object.is(NaN, n));  // 返回元素NaN
// findIndex
let a = [1, 4, -5, 10].findIndex((n) =&amp;gt; n &amp;lt; 0); // 返回索引2
let b = [1, 4, -5, 10,NaN].findIndex((n) =&amp;gt; Object.is(NaN, n));  // 返回索引4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;浏览器兼容(MDN):Chrome 45,Firefox 25,Opera 32, Safari 8, Edge yes,&lt;/p&gt;
&lt;h4 id=&quot;es6-keysvaluesentries-遍历键名遍历键值遍历键名键值-1&quot;&gt;ES6 keys()&amp;amp;values()&amp;amp;entries() 遍历键名、遍历键值、遍历键名+键值&lt;/h4&gt;
&lt;p&gt;定义：三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array.keys()
array.values()
array.entries()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数：无。&lt;/p&gt;
&lt;p&gt;遍历栗子(摘自&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/array#%E6%95%B0%E7%BB%84%E5%AE%9E%E4%BE%8B%E7%9A%84-entries%EF%BC%8Ckeys-%E5%92%8C-values&quot;&gt;ECMAScript 6 入门&lt;/a&gt;)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 &quot;a&quot;
// 1 &quot;b&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;for..of&lt;/code&gt;中如果遍历中途要退出，可以使用&lt;code&gt;break&lt;/code&gt;退出循环。&lt;/p&gt;
&lt;p&gt;如果不使用&lt;code&gt;for...of&lt;/code&gt;循环，可以手动调用遍历器对象的next方法，进行遍历:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let letter = ['a', 'b', 'c'];
let entries = letter.entries();
console.log(entries.next().value); // [0, 'a']
console.log(entries.next().value); // [1, 'b']
console.log(entries.next().value); // [2, 'c']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;entries()浏览器兼容性(MDN):Chrome 38, Firefox 28,Opera 25,Safari 7.1&lt;/p&gt;
&lt;p&gt;keys()浏览器兼容性(MDN):Chrome 38, Firefox 28,Opera 25,Safari 8,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:目前只有Safari 9支持,，其他浏览器未实现，babel转码器也还未实现&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;a href=&quot;http://obkoro1.com/2018/05/30/js-%E6%95%B0%E7%BB%84%E8%AF%A6%E7%BB%86%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%A3%E6%9E%90%E5%90%88%E9%9B%86/&quot;&gt;本文转载于：http://obkoro1.com/2018/05/30/js-%E6%95%B0%E7%BB%84%E8%AF%A6%E7%BB%86%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95%E5%8F%8A%E8%A7%A3%E6%9E%90%E5%90%88%E9%9B%86/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考资料-1&quot;&gt;参考资料：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/array&quot;&gt;ECMAScript6 入门 数组的扩展&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/aiynmimi/article/details/78667555&quot;&gt;JavaScript Array数组相关汇总&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/entry/59f7f3346fb9a04514635552&quot;&gt;深入了解javascript的sort方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5902d56e1b69e60058c634d6#heading-6&quot;&gt;【深度长文】JavaScript数组所有API全解密&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://louiszhai.github.io/2015/12/18/traverse/#%E6%B5%8B%E8%AF%95%E5%90%84%E6%96%B9%E6%B3%95%E6%95%88%E7%8E%87&quot;&gt;详解JS遍历&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://zxhfighter.github.io/blog/javascript/2013/02/27/how-to-judge-a-variable-is-a-array.html&quot;&gt;判断一个变量是否为数组&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/19863166&quot;&gt;在 JavaScript 中，如何求出两个数组的交集和差集？&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 04 Dec 2018 07:12:00 +0000</pubDate>
<dc:creator>飞刀还问情</dc:creator>
<og:description>js 数组详细操作方法及解析合集 前言 在开发中，数组的使用场景非常多，平日中也涉及到很多数组的 /相关操作，一直也没有对这块内容进行一块整理总结，很多时候就算用过几次这个 ，在开发中也很容易忘记，还</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhongchao666/p/10064235.html</dc:identifier>
</item>
<item>
<title>测试开发的成长之路 - 自动化一站式平台(UI、接口) - Anonymous⠀-⠀搭八</title>
<link>http://www.cnblogs.com/daba/p/10064181.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daba/p/10064181.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、相信大家在公司做自动化的时候随着公司的项目用例增加、多人协作会碰到很多问题，代码、数据、版本、项目整合，后期集成等等的会浪费很多时间，而且对于后期维护感觉相当的不便利，为了能解决这些问题，开发一个自动化平台来统一对这些代码、数据、版本、集成进行处理是一个公司自动化成本的一个不错的方法(而且对于刚入行的测试小盆友们也能立马上手)。&lt;/p&gt;
&lt;p&gt;2、今天给大家分享一下本人前段时间完成的一款针对自己公司进行开发的自动化平台的实现思路分享。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;平台功能&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;UI自动化 :&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1、用例支持增删改、维护、调试、结果等等&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2、用例实时日志&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3、用例定位元素采用po模式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;4、用例支持复制功能(可根据项目版本进行多套数据保存)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;5、用例调试带日志、截图、生成报错记录&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;6、用例支持执行脚本浏览器操作回放&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;7、用例支持局部/全局变量&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;8、用例支持分布式用户本地浏览器启动(默认服务器启动)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;9、用例执行状态下可进行中断用例脚本操作&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;10、用例可进行注释&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;11、用例可进行功能用例的描述&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;12、用例支持多线程、目前可同时进行200个用例并行执行(服务器能力有限)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;13、用例脚本执行判断、循环、数组、数据库对接、接口对接等等&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;14、用例与用例之间可互相进行业务调用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;15、测试计划进行版本控制（计划完成时可设置直接将结果发布至钉钉）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;16、测试计划结果报告展示&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;17、支持与jenkins对接，进行自动化发布流程&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;接口自动化：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为接口平台还处在开发阶段，功能还不齐全，现在就先不讲了，等到下次再详细介绍&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;整体框架&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;应用　　&lt;/td&gt;
&lt;td&gt;工具　　&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;语言&lt;/td&gt;
&lt;td&gt;JAVA&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;服务端&lt;/td&gt;
&lt;td&gt;spring + springmvc + mybatis + mysql + 第三方jar包(有点多，我就不在这里阐述了,想要具体了解可以联系我)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;前端&lt;/td&gt;
&lt;td&gt;JQuery + AJAX + Bootstrap + 第三方框架(具体了解可以联系我)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;




&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;UI自动化展示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 1、首页（整体的设计结构、用户操作手册）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027180/201812/1027180-20181204140908102-1438434020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、元素对象页面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027180/201812/1027180-20181204141945400-462448049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、用例编写调试界面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用例的增删改页面、测试数据使用变量、定位值使用PO、还有业务互相调用、用例执行过程中可以进行中断和本地浏览器启动&lt;/p&gt;
&lt;p&gt;用例还可以根据自己项目本身的环境来定义测试环境、目前浏览器只支持chrome和firefox&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027180/201812/1027180-20181204142719612-608777217.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用例执行支持多个线程并行执行、日志是实时的、执行完成后自动更新记录日志、截图、结果，结果为failed时会生成操作视频&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027180/201812/1027180-20181204142559518-1946417345.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、用例复制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用例可以根据项目需求进行用例存档，因为我这边需求只需要存一份预发布环境的用例数据，所有只有一个&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027180/201812/1027180-20181204145800288-395384013.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、UI测试计划&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据计划来作为版本的区分，这个就不多做解释了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027180/201812/1027180-20181204142958102-1136721322.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、UI测试计划结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计划结果完成后的结果展示页&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027180/201812/1027180-20181204143742293-1744523124.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7、钉钉报告展示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为我们公司是自动化发布的流程、所有我的平台计划完成后会在指定的项目组发送自动化结果(自动化发布流程你们可以去问下自己公司的运维)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027180/201812/1027180-20181204144234113-668801352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;接口自动化展示&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1027180/201812/1027180-20181204140707795-1790649569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;最后我想说平台化是目前的趋势，为了赚多点零花钱大家快学起来！！！&lt;/p&gt;
</description>
<pubDate>Tue, 04 Dec 2018 07:06:00 +0000</pubDate>
<dc:creator>Anonymous⠀-⠀搭八</dc:creator>
<og:description>前言 1、相信大家在公司做自动化的时候随着公司的项目用例增加、多人协作会碰到很多问题，代码、数据、版本、项目整合，后期集成等等的会浪费很多时间，而且对于后期维护感觉相当的不便利，为了能解决这些问题，开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/daba/p/10064181.html</dc:identifier>
</item>
<item>
<title>带着新人学springboot的应用08（springboot+jpa的整合） - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/10061756.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/10061756.html</guid>
<description>&lt;p&gt;　　这一节的内容比较简单，是springboot和jpa的简单整合，jpa默认使用hibernate，所以本质就是springboot和hibernate的整合。&lt;/p&gt;
&lt;p&gt;　　说实话，听别人都说spring data jpa很简化操作，不用写多少代码，今天我们就来看看。&lt;/p&gt;
&lt;p&gt;　　顺便一提的是，传统大公司用hibernate比较多，互联网公司用mybatis比较多。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.大概说一下jpa的好处（熟悉的话可以跳过）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　前面说过springboot和mybatis的整合，用mybatis的最大优点就是可以看得见sql语句，我们想改就改，想怎么优化就怎么优化。&lt;/p&gt;
&lt;p&gt;　　但是用过hibernate的小伙伴应该知道，hibernate几乎是看不见sql语句的，因为hibernate底层自动生成，但是前提是你要配置好数据库表和一个javabean的映射关系，也比较麻烦，所以就有了jpa，jpa是一个规范，不是框架（这么说很抽象，你可以把jpa当成一个接口，而hibernate是其中的一个实现类），那么我们使用jpa，那么间接的就使用了hibernate。&lt;/p&gt;
&lt;p&gt;　　那为什么这么麻烦呢？直接使用hibernate不就好了吗？&lt;/p&gt;
&lt;p&gt;　　举个很简单的例子，接口Animal，两个实现类Dog、Cat;假如有个项目我们要使用Dog里的crud方法，直接Animal animal = new Dog（）；然后animal.xx();&lt;/p&gt;
&lt;p&gt;　　过了一段时间我们又有一个项目要使用Cat里面的crud方法，还是Animal animal = new Cat（）；然后animal.xxx();&lt;/p&gt;
&lt;p&gt;　　有没有觉得，代码几乎一样，我们只需要搞清楚Animal中的方法，就能使用两个类，学习的成本降低了差不多一半，真正的事半功倍。&lt;/p&gt;
&lt;p&gt;　　jpa的实现常见的hibernate，OpenJPA，TopLink，EclipseJPA这几种，虽然我只用过hibernate，但是，你学会了jpa之后，另外几种你也就会了，因为方法和操作hibernate一样。&lt;/p&gt;
&lt;p&gt;　　还有就是，开发jpa和开发hibernate的居然是同一个作者...emmmm...&lt;/p&gt;
&lt;p&gt;　　再说一下hibernate和spring整合的时候，应该发现了Dao层还是要写贼多的东西，各种crud方法要慢慢实现；即使用jpa之后，spring整合jpa（实现产品为hibernate），还是摆脱不了要实现crud方法，虽然代码少写了一点，但是治标不治本；&lt;/p&gt;
&lt;p&gt;　　但是就当jpa和Spring Data整合之后，你几乎看不到代码了！就一个接口放在那里，即使你有特殊的需求，你只要写个方法，方法名符合一定的规范，就ok了，你都不用实现（当然，实际的项目中不下心可能就碰到了特别复杂的需求，那么还是老老实实的写sql吧！）。&lt;/p&gt;
&lt;p&gt;　　spring data是spring的一个子项目，专门针对持久化层的，我们用过的spring data radis，spring data rabbitmq都是这个项目的模块之一。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.简单的搭建一下环境　&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，创建springboot项目，要导入的模块web+mysql+jpa+1.5.18&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　话说以前我这版本应该是1.5.16啊，怎么偷偷的趁我不注意自动给我升级到1.5.18了......&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181203223653699-1972450006.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181203223718959-1809548547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　然后配置文件配置数据源（就用默认的数据源） &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181203224143006-854955371.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　配置一个javabean去对应和一张表对应&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181203225106667-291908008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　来看看现在的dao层是什么鬼。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;看清楚，这是一个接口，而且不用标示注解！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181203225357053-794507883.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　为了方便，就不写service层了，直接controller层&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181203225924731-1148815941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　然后运行springboot项目，就会在数据库创建user表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181203230049696-1098427321.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我手动往表里添加几条数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181203230158936-1881572829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　打开浏览器，输入url：http://localhost:8080/hello/2，可以看到结果和控制台的sql语句&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181203230256835-827644938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181203230421559-939275062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这是最简单的使用了，其实这里关键是userDao到底可以用哪些方法，截了一下图，大概可以看到基本的crud方法应该是都实现了，你只需要传入相关的参数即可。&lt;/p&gt;
&lt;p&gt;　　话说每次都说crud，但是具体是哪几个单词知道吗？C（create），R（Read），U（update），D（delete），看到名字应该知道意思吧！&lt;/p&gt;
&lt;p&gt;　　在springdata jpa中，增加和修改方法都是save（）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181204113842668-935982027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　删除，delete（）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181204113956958-1975533320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　查询，方法就多了，但都是类似findxxx（），具体的自己去尝试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181204114146429-1082399775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.貌似比较高级的操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　  &lt;/strong&gt;&lt;/span&gt;所谓高级的操作，无外乎就是自定义嘛！&lt;/p&gt;
&lt;p&gt;　　因为有的高手就觉得我为什么用你这个方法啊，我能不能自定义啊？比如我要..emmm...按照名字来查找记录，ok，jpa也提供给你，但是你要想好一个很特别很特殊的方法名，这个方法名不单单你认识，而且还要程序认识。（玛德，想个方法名都这么多要求，日了狗哦！）&lt;/p&gt;
&lt;p&gt;　　那么我们在dao层自定义一个方法试试（看清楚方法名！）　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181204115223678-787015621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　controller层我试试这个方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181204115302525-943440654.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　看看浏览器能不能访问，能访问，ok&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181204115425410-1428087104.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　所以现在我们要知道的就是自定义的方法名，要符合什么规范？弄清楚这个了，那自定义方法也就ok了。&lt;/p&gt;
&lt;p&gt;　　其实规则就跟原生的sql语句差不多，就是提取了关键字而已，比如我要根据name模糊查找，sql语句就是xxx where name like ‘王%’，关键字就是like；于是我们方法名就是findByNameLike（String name），括号里就是我们要传进去的条件，相当于‘王%’。&lt;/p&gt;
&lt;p&gt;　　我猜底层应该会解析方法名，拼接成sql语句，向数据库发送sql语句进行操作，本质上，一个方法就是一条sql语句。&lt;/p&gt;
&lt;p&gt;　　还有一些关键词，And，Or，Between，OrderBy等等，都可以用于方法名。&lt;/p&gt;
&lt;p&gt;　　我随便列举一下几个方法名参考一下：&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;sourceCode java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;fu&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;findByUserName&lt;span class=&quot;hljs-function&quot;&gt;(String userName);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;sourceCode java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;fu&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;findByUserNameOrEmail&lt;span class=&quot;hljs-function&quot;&gt;(String username, String email);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;sourceCode java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;fu&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;fu&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;countByUserName&lt;span class=&quot;hljs-function&quot;&gt;(String userName);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;sourceCode java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;fu&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;findByEmailLike&lt;span class=&quot;hljs-function&quot;&gt;(String email);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;sourceCode java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;fu&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;fu&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;List&amp;lt;User&amp;gt; &lt;span class=&quot;fu&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;findByUserNameOrderByEmailDesc&lt;span class=&quot;hljs-function&quot;&gt;(String email);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　看名字应该知道是干什么的了，好好体会一下！sql语句用的熟练了，这个应该不难。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.一点小操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　有的时候理想很丰满，现实却很骨感！你一不小心碰到了一个非常复杂的需求，然而用上面这些规则却总是一副日了狗的表情，你就很怀念用sql语句了！玛德，要是我能用sql语句的话，我不要一分钟就能做好了，现在让我编这个方法名就是特么编不出来啊！&lt;/p&gt;
&lt;p&gt;　   ok，springboot data jpa也考虑到了你这种需求，于是我们便能像用mybatis的注解版一样使用jpa了。&lt;/p&gt;
&lt;p&gt;　　请看下面dao层的方法，是不是和mybatis注解版十分相似啊？不过要注意，这里注解里面的语句没记错的话应该是hql语句吧，操作的是实体类！&lt;/p&gt;
&lt;p&gt;　　当然如果你要写原生sql语句，在@Query里面就要加个属性：&lt;span&gt;nativeQuery=true，就可以写原生sql语句了&lt;/span&gt;，很简单，这里不多说。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;可以取别名，可以有占位符，占位符可以直接是？；不过别人都是？1：代表第一个占位符；如果还有？2：第二个占位符；  还有？3：第三个占位符。。。占位符和参数一一对应，当然还可以用@Param（“xxx”）和形参进行参数绑定，这时hql语句占位符也会发生变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;我们就不搞这些花里胡哨的了，怎么简单怎么来：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181204130641624-1504296299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　查询只要@Query一个注解就可以了，但是增加，修改，删除还需要另外一个注解@Modifying，再看一个方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181204131945111-456118343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　要加那个事务的注解，假如不加，会报错，下图所示，emmm....建议增上改方法除了@Query之外，都加上那这两个注解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181204131833282-1022336080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　然后我运行应用，测试了，成功，你们可以自己试试！&lt;/p&gt;
&lt;p&gt;　　其实后面还有分页，多表查询，有点小麻烦所以我就很不要脸的跳过了，嘿嘿嘿！不过还是大概说一下：&lt;/p&gt;
&lt;p&gt;　　分页就是自己定义一下规则，一页多少数据，多少页，包装成一个对象，放到findAll方法里就可以了；而多表查询，前提是两个类建立好关系（就是一对多，多对一什么的），然后重点就是编写@Query里面的hql语句了；&lt;/p&gt;
&lt;p&gt;　　这里我就是给新手小哥们看一看基本操作，想要深入了解的小伙伴可以自己查查资料看看分页和多表级联操作。&lt;/p&gt;
&lt;p&gt;　　其实本来是不想写这个springboot data jpa的，因为用的比较少，还不如springboot+mybatis好玩，不过啊，因为我后面我要说springboot和一个东西的整合，太像springboot jpa了，于是我也顺便说说jpa得了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 04 Dec 2018 06:31:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>这一节的内容比较简单，是springboot和jpa的简单整合，jpa默认使用hibernate，所以本质就是springboot和hibernate的整合。 说实话，听别人都说spring data</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq1995/p/10061756.html</dc:identifier>
</item>
<item>
<title>JAVA 集合类小结 - lgp20151222</title>
<link>http://www.cnblogs.com/ydymz/p/10063888.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ydymz/p/10063888.html</guid>
<description>&lt;h2 id=&quot;toc_h2_0&quot;&gt;一 集合和数组&lt;/h2&gt;
&lt;p&gt;因为本人也是个go的爱好者，所以对于集合类算是摸的比较透的。&lt;/p&gt;
&lt;p&gt;说到集合，必须了解数组和集合。&lt;/p&gt;

&lt;p&gt;Java的数组长度固定，集合长度不定。集合是特定的数据结构的集合。&lt;/p&gt;
&lt;p&gt;而go里面并没有集合，而是叫数组，切片和键值对。数组同样长度固定，切片键值对长度不固定，键值对是k-v结构。&lt;/p&gt;

&lt;p&gt;go和Java的不同就是，切片和键值对要自己写方法成为特定的数据结构，才能合Java的集合类差不多。&lt;/p&gt;
&lt;p&gt;也就是说Java的集合其实是Java开发者为了开发方便，定义的一系列数据结构的。那么只要理解java几个数据结构的特性那么就很好理解了。&lt;/p&gt;


&lt;p&gt;最上层的接口&lt;/p&gt;
&lt;p&gt;map和Iterable。&lt;/p&gt;
&lt;p&gt;map是键值对，Iterable是集合的迭代子。迭代子理解起来，就是集合每个元素的一个包装&lt;/p&gt;

&lt;p&gt;次顶层的接口&lt;/p&gt;
&lt;p&gt;collection实现Iterable接口，提供了按索引取值的方法。&lt;/p&gt;
&lt;p&gt;这里可以看出collection对应go的切片，map和map对应。&lt;/p&gt;


&lt;p&gt;list，set实现collection接口。&lt;/p&gt;

&lt;p&gt;list是有序，可重复的数据。&lt;/p&gt;
&lt;p&gt;set是无序、不能重复数据。&lt;/p&gt;
&lt;p&gt;map是键值对、键不可重复、值可重复。&lt;/p&gt;


&lt;p&gt;在上面说的三大类型下，根据线程安全，查询速度快，插入速度快，排序又有四个功能分类。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;红色为面试常问结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;排序　　　　　　　　　　 &lt;span&gt;TreeSet&lt;/span&gt;，LinkedHashSet　  &lt;span&gt;TreeMap&lt;/span&gt;，LinkedHashMap&lt;/p&gt;
&lt;p&gt;线程安全&lt;span&gt;　　vector　　　 &lt;/span&gt; synchronizedSet　　　　  &lt;span&gt;　Hashtable&lt;/span&gt;，&lt;span&gt;ConcurrentHashMap&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;查询速度快   &lt;span&gt;ArrayList　　  HashSet　　　　　　　　　&lt;/span&gt; &lt;span&gt;HashMap&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;插入速度快   &lt;span&gt;LinkedList　　HashSet&lt;/span&gt;　  　　　　　　　  &lt;span&gt;HashMap　　&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;list本来就是有序的，所以排序为空。&lt;/p&gt;
&lt;p&gt;HashSet，HashMap为什么插入查询快的原因则是，因为用了hash算法。&lt;/p&gt;
&lt;p&gt;LinkedHashSet和LinkedHashMap虽然本质上只是HashSet，HashMap实现了排序接口，但是插入的时候就排序，所以较慢。&lt;/p&gt;
&lt;p&gt;TreeSet，TreeMap本身是按红黑树结构排序，但也能重写排序接口。&lt;/p&gt;
&lt;p&gt;synchronizedSet是Colletions这个工具类里，算是冷门知识点。&lt;/p&gt;


&lt;p&gt;第一，1.8引入了Stream之后，排序基本可以不用了，因为排序的使用次数低，我们不必保证数据插入或者查询一定有序。只需要我们取出来的时候有序即可，而Stream特性则大大的简化了我们自己写排序的代码量。&lt;/p&gt;
&lt;p&gt;第二，分布式下考虑单机的线程安全简直杀鸡用牛刀。基本synchronized，lock，原子类，&lt;em&gt;Voli&lt;/em&gt;date之类的就行了。&lt;/p&gt;
&lt;p&gt;第三，插入速度的考量，降低io操作硬盘操作写操作，基本是每个系统到了后期性能提升一定要考虑的事情，而此时基本使用数组而非集合。&lt;/p&gt;

&lt;p&gt;综上，我们基本使用查询快的类就好了。&lt;/p&gt;


&lt;p&gt;1.遍历迭代子Iterator，而不直接遍历对象&lt;/p&gt;
&lt;p&gt;2.for循环结束，立马回收Iterator&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;for&lt;/span&gt; (Iterator it =&lt;span&gt; map.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry e &lt;/span&gt;=&lt;span&gt; (Map.Entry) it.next();
            System.out.println(&lt;/span&gt;&quot;键&quot; + e.getKey() + &quot;的值为&quot; +&lt;span&gt; e.getValue());
   }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.对数据的删除修改操作，要用迭代子实现（&lt;span&gt;否则可能出现线程安全问题&lt;/span&gt;）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;for&lt;/span&gt; (Iterator&amp;lt;Entry&amp;lt;Long, String&amp;gt;&amp;gt; iterator =&lt;span&gt; &lt;span&gt;map&lt;/span&gt;.entrySet().iterator(); iterator.hasNext();) {
            Entry&lt;/span&gt;&amp;lt;Long, String&amp;gt; entry =&lt;span&gt; iterator.next();
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; key =&lt;span&gt; entry.getKey();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key &amp;lt; 10&lt;span&gt;) {
                iterator.remove();
            }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 04 Dec 2018 06:23:00 +0000</pubDate>
<dc:creator>lgp20151222</dc:creator>
<og:description>一 集合和数组 因为本人也是个go的爱好者，所以对于集合类算是摸的比较透的。 说到集合，必须了解数组和集合。 Java的数组长度固定，集合长度不定。集合是特定的数据结构的集合。 而go里面并没有集合，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ydymz/p/10063888.html</dc:identifier>
</item>
<item>
<title>Java里的函数式接口 - 闵良志</title>
<link>http://www.cnblogs.com/anivia/p/10063808.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/anivia/p/10063808.html</guid>
<description>[unable to retrieve full-text content]函数式接口是在Java8里跟随lambda表达式一起提出的，学习lambda表达式之前，还是先了解一下什么是“函数式接口”。 概念 函数式接口就是指只含有一个抽象函数的接口。这个接口里可以包含任意多个默认方法，任意多个静态方法。函数式接口可以使用注解@FunctionalInterface标注，如果</description>
<pubDate>Tue, 04 Dec 2018 06:11:00 +0000</pubDate>
<dc:creator>闵良志</dc:creator>
<og:description>一 集合和数组 因为本人也是个go的爱好者，所以对于集合类算是摸的比较透的。 说到集合，必须了解数组和集合。 Java的数组长度固定，集合长度不定。集合是特定的数据结构的集合。 而go里面并没有集合，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ydymz/p/10063888.html</dc:identifier>
</item>
<item>
<title>从壹开始微服务 [ DDD ] 之十二 ║ 核心篇【下】：事件驱动EDA 详解 - 老张的哲学</title>
<link>http://www.cnblogs.com/laozhang-is-phi/p/10059878.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laozhang-is-phi/p/10059878.html</guid>
<description>&lt;p&gt;哈喽大家好，又是周二了，时间很快，我的第二个系列DDD领域驱动设计讲解已经接近尾声了，除了今天的时间驱动EDA（也有可能是两篇），然后就是下一篇的事件回溯，就剩下最后的权限验证了，然后就完结了，这两个月我也是一直在自学，然后再想栗子，个人感觉收获还是很大的，比如DDD领域分层设计、CQRS读写分离、CommandBus命令总线、EDA事件驱动、四色原理等等，如果大家真的能踏踏实实的看完，或者说多看看书，对个人的思想提高有很大的帮助，这里要说两点，可能会有一些小伙伴不开心，但是还是要说说：&lt;/p&gt;&lt;p&gt;我想说，其实微服务是一个很宽泛的领域，比如.net core的深入学习，依赖注入的使用，仓储契约、DDD+事件总线的学习、中介者模式、Docker的学习、容器化设计等等等等，这些都属于微服务的范畴，如果这些基础知识不会的话，可能是学不好微服务的。&lt;/p&gt;&lt;p&gt;周末的时候，我又好好的整理了下我的Github上的代码，然后新建了一些分支（如果你不会使用Git命令，可以看我的一个文章：&lt;a href=&quot;https://www.jianshu.com/p/2b666a08a3b5&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/2b666a08a3b5&lt;/a&gt;，会一直更新），主要是这样的（这个数字是对应的文章，比如今天的是第 &lt;strong&gt;12 &lt;/strong&gt;）：&lt;/p&gt;&lt;p&gt;其实我这个系列所说的 DDD领域驱动设计，是一个很丰富的概念，里边包含了DDD的多层设计思想、CQRS、Bus、EDA、ES等等，所以如果你只想要其中的一部分，可以对应的分支进行Clone，比如你单纯想要一个干净的基于DDD四层设计的模板，可以克隆 Framework_DDD_8 这个分支，如果你想带有读写分离，可以克隆 CQRS_DDD_9 这个分支等等，也方便好好研究。&lt;/p&gt;&lt;p&gt;关于CQRS读写分离概念，请注意，分离不一定是分库，一个数据库也能实现读写分离，最简单的就是从Code上来区分。&lt;/p&gt;&lt;p&gt;当然其中也有一些新的问题出现了，这个也可以当作今天的每篇一问：&lt;/p&gt;&lt;p&gt; 你会说，很简单呀，我们直接在 CommandHandler 命令处理程序中处理不就行了，一步一步往下走就可以了呀，如果你现在还有这样的思维，那DDD可真的好好再学习了，为什么呢？很简单，我们当时为什么要把 contrller 的业务逻辑剥离到领域模型，就是为了业务独立化，不让多个不相干的业务缠绕（比如我们之前是把model 验证、错误返回、发邮件等，都是写在 controller 里的），那如果我们再把过多的业务逻辑写到命令处理程序中的话，那命令处理模型不就成为了第二个 controller 了么？我们为业务把 controller 剥离了一次，那今天咱们就继续从 命令处理程序中，再优化一次。&lt;/p&gt;&lt;p&gt;我们先看看官网，在《实现领域驱动设计》一书中对领域事件的定义如下：&lt;/p&gt;&lt;p&gt;领域事件：Domain Event,是针对某个业务来说的，或者说针对某个聚合的业务来说的，例如订单生成这种业务，它可以同时对应一种事件，比如叫做OrderGeneratorEvent，而你的零散业务可能随时会变，加一些业务，减一些业务，而对于订单生成这个事件来说，它是唯一不变的，而我们需要把这些由产生订单而发生变化的事情拿出来，而拿出来的这些业务就叫做＂领域事件＂．其中的领域指的就是订单生成这个聚合；而事件指的就是那些零散业务的统称．&lt;/p&gt;&lt;p&gt;如果你对上一篇命令总线很熟悉，这里就特别简单，几乎是一个模式，只不过总线发布的方式不一样罢了，如果你比较熟悉命令驱动，这里正好温习。如果不了解，这里就一起看吧，千万记得再回去看前两篇内容哟。&lt;/p&gt;&lt;div readability=&quot;211.64114242577&quot;&gt;
&lt;div readability=&quot;26.5&quot;&gt;
&lt;p&gt;一个领域事件可以理解为是发生在一个特定领域中的事件，是你希望在同一个领域中其他部分知道并产生后续动作的事件。一个领域事件必须对业务有价值，有助于形成完整的业务闭环，也即一个领域事件将导致进一步的业务操作。就比如我们今天说到的领域通知，就应该是一个事件，我们从命令中产生的错误提示，通过处理程序，引发到事件总线内，并返回到前台。&lt;/p&gt;

&lt;h3&gt;3、为什么需要领域事件&lt;/h3&gt;
&lt;p&gt;领域事件也是一种基于事件的架构（EDA）。事件架构的好处可以把处理的流程解耦，实现系统可扩展性，提高主业务流程的内聚性。&lt;/p&gt;
&lt;p&gt;在咱们文章的开头，可说到了这个问题，不知道大家是否还记得，咱们再分析一下：&lt;/p&gt;
&lt;p&gt;我们提交了一个添加Student 的申请，系统在完成保存后，可能还需要发送一个通知（当然这里错误信息，也有成功的），当然肯定还会会一些其他的后台服务的活动。如果把这一系列的动作放入一个处理过程中，会产生几个的明显问题：&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;1、一个是命令提交的的事务比较长，性能会有问题，甚至在极端情况下容易引发数据库的严重故障（服务器方面）；&lt;/p&gt;
&lt;p&gt;2、另外提交的服务内聚性差，可维护性差，在业务流程发生变更时候，需要频繁修改主程序（程序员方面）。&lt;/p&gt;
&lt;p&gt;3、我们有时候只关心核心的流程，就比如添加Student，我们只关心是否添加成功，而且我们需要对这个成功有反馈，但是发邮件的功能，我们却不用放在主业务中，甚至发送成功与否，不影响 Student 的正常添加，这样我们就把后续的这些活动事件，从主业务中剥离开，实现了高内聚和低耦合（业务方面）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;还记得 MediatR 有两个中介者模式么：请求/响应 和 发布/订阅。在我们的系统中，添加一个学生命令，就是用到的请求/响应 IRequest 模式，因为我们需要等待当前操作完成，我们需要总线对我们的请求做出响应。&lt;/p&gt;
&lt;p&gt;但是有时候我们不需要在同一请求/响应中立即执行一个动作的结果，只要异步执行这个动作，比如发送电子邮件。在这种情况下，我们使用发布/订阅模式，以异步方式发送电子邮件，并避免让用户等待发送电子邮件。&lt;/p&gt;

&lt;h3&gt;4、领域事件驱动是如何运行的呢？&lt;/h3&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;这个时候，就用到之前我画的图了，中介者模式下，上半部的命令总线已经说完，今天说另一半事件总线：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181203191216154-959678910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当然这里也有一个网上的栗子，很不错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181203191045293-263398144.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p class=&quot;indent&quot;&gt; 从图中我们也可以看到，事件驱动的工作流程呢，在命令模式下，主要是在我们的命令处理程序中出现，在我们对数据进行持久化操作的时候，作为一个后续活动事件来存在，比如我们今天要实现的两个处理工作：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p class=&quot;indent&quot;&gt;1、通知信息的收集（之前我们是采用的缓存 Memory 来实现的）；&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;2、领域通知处理程序（比如发邮件等）；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;indent&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;这个时候，如果你对事件驱动有了一定的理解的话，你就会问，那我们在项目中具体的应该使用呢，请往下看。&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt; &lt;/p&gt;

&lt;p&gt;这个整体流程其实和命令总线分发很像，所以原理就不分析了，相信你如果看了之前的两篇文章的话，一定能看懂今天的内容的。&lt;/p&gt;
&lt;h3&gt;1、定义领域事件标识基类&lt;/h3&gt;
&lt;p&gt;就如上边我们说到的，我们可以定义一个接口，也可以定义一个抽象类，我比较习惯用抽象类，在核心领域层 Christ3D.Domain.Core 中的Events 文件夹中，新建Event.cs 事件基类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Christ3D.Domain.Core.Events
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 事件模型 抽象基类，继承 INotification
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 也就是说，拥有中介者模式中的 发布/订阅模式
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Event : INotification
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 时间戳&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; DateTime Timestamp { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每一个事件都是有状态的&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Event()
        {
            Timestamp &lt;/span&gt;=&lt;span&gt; DateTime.Now;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181203231524955-40014176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2、定义事件总线接口&lt;/h3&gt;
&lt;p class=&quot;indent&quot;&gt;在中介处理接口IMediatorHandler中，定义引发事件接口，作为发布者，完整的 IMediatorHandler.cs 应该是这样的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Christ3D.Domain.Core.Bus
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 中介处理程序接口
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 可以定义多个处理程序
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是异步的
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IMediatorHandler
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 发送命令，将我们的命令模型发布到中介者模块
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt; 泛型 &lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;command&quot;&amp;gt;&lt;/span&gt;&lt;span&gt; 命令模型，比如RegisterStudentCommand &lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        Task SendCommand&amp;lt;T&amp;gt;(T command) &lt;span&gt;where&lt;/span&gt;&lt;span&gt; T : Command;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 引发事件，通过总线，发布事件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt; 泛型 继承 Event：INotification&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;event&quot;&amp;gt;&lt;/span&gt;&lt;span&gt; 事件模型，比如StudentRegisteredEvent，&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 请注意一个细节：这个命名方法和Command不一样，一个是RegisterStudentCommand注册学生命令之前,一个是StudentRegisteredEvent学生被注册事件之后
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        Task &lt;span&gt;RaiseEvent&lt;/span&gt;&amp;lt;T&amp;gt;(T @event) &lt;span&gt;where&lt;/span&gt;&lt;span&gt; T : Event;

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181203231754705-1596984066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3、实现总线分发接口&lt;/h3&gt;
&lt;p class=&quot;indent&quot;&gt; 在基层设施总线层 Christ3D.Infra.Bus 的记忆总线 InMemoryBus.cs 中，实现我们上边的事件分发总线接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 引发事件的实现方法
 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;泛型 继承 Event：INotification&lt;/span&gt;&lt;span&gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;event&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;事件模型，比如StudentRegisteredEvent&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
 &lt;span&gt;public&lt;/span&gt; Task RaiseEvent&amp;lt;T&amp;gt;(T @event) &lt;span&gt;where&lt;/span&gt;&lt;span&gt; T : Event
 {
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; MediatR中介者模式中的第二种方法，发布/订阅模式&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _mediator.Publish(@event);
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意这里使用的是中介模式的第二种——发布/订阅模式，想必这个时候就不用给大家解释为什么要使用这个模式了吧（提示：不需要对请求进行必要的响应，与请求/响应模式做对比思考）。现在我们把事件总线定义（是一个发布者）好了，下一步就是如何定义事件模型和处理程序了也就是订阅者，如果上边的都看懂了，请继续往下走。&lt;/p&gt;


&lt;p class=&quot;indent&quot;&gt; 可能这句话不是很好理解，那说人话就是：我们之前每一个领域模型都会有不同的命令，那每一个命令执行完成，都会有对应的后续事件（比如注册和删除用户肯定是不一样的），当然这个是看具体的业务而定，就比如我们的订单领域模型，主要的有下单、取消订单、删除订单等。&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;我个人感觉，每一个命令模型都会有对应的事件模型，而且一个命令处理方法可能有多个事件方法。具体的请看：&lt;/p&gt;
&lt;h3 class=&quot;indent&quot;&gt;1、定义添加Student 的事件模型&lt;/h3&gt;
&lt;p&gt;当然还会有删除和更新的事件模型，这里就用添加作为栗子，在领域层 Christ3D.Domain 中，新建  Events 文件夹，用来存放我们所有的事件模型，&lt;/p&gt;
&lt;p&gt;因为是 Student 模型，所以我们在 Events 文件夹下，新建 Student 文件夹，并新建 StudentRegisteredEvent.cs 学生添加事件类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Christ3D.Domain.Events
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Student被添加后引发事件
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 继承事件基类标识
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentRegisteredEvent : Event
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造函数初始化，整体事件是一个值对象&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; StudentRegisteredEvent(Guid id, &lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;string&lt;/span&gt; email, DateTime birthDate, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; phone)
        {
            Id &lt;/span&gt;=&lt;span&gt; id;
            Name &lt;/span&gt;=&lt;span&gt; name;
            Email &lt;/span&gt;=&lt;span&gt; email;
            BirthDate &lt;/span&gt;=&lt;span&gt; birthDate;
            Phone &lt;/span&gt;=&lt;span&gt; phone;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Guid Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Email { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime BirthDate { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Phone { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181203234127074-1122203150.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2、定义领域事件的处理程序Handler&lt;/h3&gt;
&lt;p&gt;这个和我们的命令处理程序一样，只不过我们的&lt;strong&gt;命令处理程序&lt;/strong&gt;是总线在&lt;strong&gt;应用服务层&lt;/strong&gt;分发的，而&lt;strong&gt;事件处理程序&lt;/strong&gt;是在&lt;strong&gt;领域层的命令处理程序&lt;/strong&gt;中被总线引发的，可能有点儿拗口，看看下边代码就清楚了，就是一个引用场景的顺序问题。&lt;/p&gt;
&lt;p&gt;在领域层Chirst3D.Domain 中，新建 EventHandlers 文件夹，用来存放我们的事件处理程序，然后新建 Student事件模型的处理程序 StudentEventHandler.cs：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Christ3D.Domain.EventHandlers
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Student事件处理程序
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 继承INotificationHandler&lt;/span&gt;&lt;span&gt;&amp;lt;T&amp;gt;&lt;/span&gt;&lt;span&gt;，可以同时处理多个不同的事件模型
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StudentEventHandler :
        INotificationHandler&lt;/span&gt;&amp;lt;StudentRegisteredEvent&amp;gt;&lt;span&gt;,
        INotificationHandler&lt;/span&gt;&amp;lt;StudentUpdatedEvent&amp;gt;&lt;span&gt;,
        INotificationHandler&lt;/span&gt;&amp;lt;StudentRemovedEvent&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 学习被注册成功后的事件处理方法&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task Handle(StudentRegisteredEvent message, CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 恭喜您，注册成功，欢迎加入我们。&lt;/span&gt;

            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 学生被修改成功后的事件处理方法&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task Handle(StudentUpdatedEvent message, CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 恭喜您，更新成功，请牢记修改后的信息。&lt;/span&gt;

            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 学习被删除后的事件处理方法&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task Handle(StudentRemovedEvent message, CancellationToken cancellationToken)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 您已经删除成功啦，记得以后常来看看。&lt;/span&gt;

            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相信大家应该都能看的明白，在上边的注释已经很清晰的表达了响应的作用，如果有看不懂，咱们可以一起交流。&lt;/p&gt;
&lt;p&gt;好啦，现在第二步已经完成，剩下最后一步：如何通过事件总线分发我们的事件模型了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181203235842131-715124648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3、在事件总线EventBus中引发事件&lt;/h3&gt;
&lt;p&gt;这个使用起来很简单，主要是我们在命令处理程序中，处理完了持久化以后，接下来调用我们的事件总线，对不同的事件模型进行分发，就比如我们的 添加Student 命令处理程序方法中，我们通过工作单元添加成功后，需要做下一步，比如发邮件，那我们就需要这么做。&lt;/p&gt;
&lt;p&gt;在命令处理程序 StudentCommandHandler.cs 中，完善我们的提交成功的处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 持久化&lt;/span&gt;
&lt;span&gt; _studentRepository.Add(customer);

 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 统一提交&lt;/span&gt;
 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Commit())
 {
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提交成功后，这里需要发布领域事件
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比如欢迎用户注册邮件呀，短信呀等&lt;/span&gt;&lt;span&gt;
     Bus.&lt;span&gt;RaiseEvent&lt;/span&gt;(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StudentRegisteredEvent(customer.Id, customer.Name, customer.Email, customer.BirthDate,customer.Phone));
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就很简单的将我们的事件模型分发到了事件总线中去了，这个时候记得要在 IoC 项目中，进行注入。关于触发过程下边我简单说一下。&lt;/p&gt;

&lt;h3&gt;4、整体事件驱动执行过程&lt;/h3&gt;
&lt;p&gt; 说到了这里，你可能发现和命令总线很相似，也可能不是很懂，简单来说，整体流程是这样的：&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;1、首先我们在命令处理程序中调用事件总线来引发事件  Bus.RaiseEvent(........)；&lt;/p&gt;
&lt;p&gt;2、然后在Bus中，将我们的事件模型进行包装成固定的格式   _mediator.Publish(@event)；&lt;/p&gt;
&lt;p&gt;3、然后通过注入的方法，将包装后的事件模型与事件处理程序进行匹配，系统执行事件模型，就自动实例化事件处理程序 StudentEventHandler；&lt;/p&gt;
&lt;p&gt;4、最后执行我们Handler 中各自的处理方法 Task Handle(StudentRegisteredEvent message)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;希望正好也温习下命令总线的执行过程。&lt;/p&gt;

&lt;h3&gt;5、依赖注入事件模型和处理程序&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Domain - Events
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将事件模型和事件处理程序匹配注入&lt;/span&gt;
 services.AddScoped&amp;lt;&lt;span&gt;INotificationHandler&lt;/span&gt;&amp;lt;StudentRegisteredEvent&amp;gt;, &lt;span&gt;StudentEventHandler&lt;/span&gt;&amp;gt;&lt;span&gt;();
 services.AddScoped&lt;/span&gt;&amp;lt;&lt;span&gt;INotificationHandler&lt;/span&gt;&amp;lt;StudentUpdatedEvent&amp;gt;, &lt;span&gt;StudentEventHandler&lt;/span&gt;&amp;gt;&lt;span&gt;();
 services.AddScoped&lt;/span&gt;&amp;lt;&lt;span&gt;INotificationHandler&lt;/span&gt;&amp;lt;StudentRemovedEvent&amp;gt;, &lt;span&gt;StudentEventHandler&lt;/span&gt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个时候，我们DDD领域驱动设计核心篇的第一部分就是这样了，还剩下最后的，事件驱动的&lt;strong&gt;事件源&lt;/strong&gt;和&lt;strong&gt;事件存储/回溯&lt;/strong&gt;，我们下一讲再说。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181204113709661-1727291862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来咱们说说领域通知，为什么要说领域通知呢，大家应该还记得我们之前将错误信息放到了内存中，无论是操作还是业务上都很严重的问题，肯定是不可取的。那我们应该采用什么办法呢，欸？！没错，你会发现，通过上边的事件驱动设计，发现领域通知我们也可以采用这个方法，首先是多个模型之间相互通讯，但又不相互引用；而且也在命令处理程序中，对信息进行分发，和发邮件很类似，那具体如何操作呢，请往下看。&lt;/p&gt;


&lt;h3&gt;1、领域通知模型 DomainNotification &lt;/h3&gt;
&lt;p class=&quot;indent&quot;&gt; 这个通知模型，就像是一个消息队列一样，在我们的内存中，通过通知处理程序进行发布和使用，有自己的生命周期，当被访问并调用完成的时候，会手动对其进行回收，以保证数据的完整性和一致性，这个就很好的解决了咱们之前用Memory缓存通知信息的弊端。&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;在我们的核心领域层 Christ3D.Domain.Core 中，新建文件夹 Notifications ，然后添加领域通知模型 DomainNotification.cs：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Christ3D.Domain.Core.Notifications
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 领域通知模型，用来获取当前总线中出现的通知信息
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 继承自领域事件和 INotification（也就意味着可以拥有中介的发布/订阅模式）
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DomainNotification : &lt;span&gt;Event&lt;/span&gt;
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 标识&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Guid DomainNotificationId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 键（可以根据这个key，获取当前key下的全部通知信息）
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这个我们在事件源和事件回溯的时候会用到，&lt;span&gt;伏笔&lt;/span&gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Key { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 值（与key对应）&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Value { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 版本信息&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Version { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DomainNotification(&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
        {
            DomainNotificationId &lt;/span&gt;=&lt;span&gt; Guid.NewGuid();
            Version &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            Key &lt;/span&gt;=&lt;span&gt; key;
            Value &lt;/span&gt;=&lt;span&gt; value;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;indent&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181204112556733-1202895766.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;indent&quot;&gt;2、领域通知处理程序 DomainNotificationHandler&lt;/h3&gt;
&lt;p class=&quot;indent&quot;&gt;该处理程序，可以理解成，就像一个类的管理工具，在每次对象生命周期内 ，对领域通知进行实例化，获取值，手动回收，这样保证了每次访问的都是当前实例的数据。&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt; 还是在文件夹 Notifications 下，新建处理程序 DomainNotificationHandler.cs：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Christ3D.Domain.Core.Notifications
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 领域通知处理程序，把所有的通知信息放到事件总线中
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 继承 INotificationHandler&lt;/span&gt;&lt;span&gt;&amp;lt;T&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DomainNotificationHandler : INotificationHandler&amp;lt;DomainNotification&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通知信息列表&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; List&amp;lt;DomainNotification&amp;gt;&lt;span&gt; _notifications;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每次访问该处理程序的时候，实例化一个空集合&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DomainNotificationHandler()
        {
            _notifications &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;DomainNotification&amp;gt;&lt;span&gt;();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理方法，把全部的通知信息，添加到内存里&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task Handle(DomainNotification message, CancellationToken cancellationToken)
        {
            _notifications.Add(message);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }
        
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前生命周期内的全部通知信息&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; List&amp;lt;DomainNotification&amp;gt;&lt;span&gt; GetNotifications()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _notifications;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断在当前总线对象周期中，是否存在通知信息&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; HasNotifications()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetNotifications().Any();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 手动回收（清空通知）&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
        {
            _notifications &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; List&amp;lt;DomainNotification&amp;gt;&lt;span&gt;();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到了目前为止，我们的DDD领域驱动设计中的&lt;strong&gt;核心领域层&lt;/strong&gt;部分，已经基本完成了（还剩下下一篇的事件源、事件回溯）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181204113136549-1000131665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;indent&quot;&gt;3、在命令处理程序中发布通知&lt;/h3&gt;
&lt;p&gt; 我们定义好了领域通知的处理程序，我们就可以像上边的发布事件一样，来发布我们的通知信息了。这里用一个栗子来试试：&lt;/p&gt;
&lt;p&gt;在学习命令处理程序 StudentCommandHandler.cs 中的 RegisterStudentCommand 处理方法中，完善：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断邮箱是否存在
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这些业务逻辑，当然要在领域层中（领域命令处理程序中）进行处理&lt;/span&gt;
 &lt;span&gt;if&lt;/span&gt; (_studentRepository.GetByEmail(customer.Email) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
 {
     &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/这里对错误信息进行发布，目前采用缓存形式&lt;/span&gt;
     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;List&amp;lt;string&amp;gt; errorInfo = new List&amp;lt;string&amp;gt;() { &quot;该邮箱已经被使用！&quot; };
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Cache.Set(&quot;ErrorData&quot;, errorInfo);

     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;引发错误事件&lt;/span&gt;
     Bus.RaiseEvent(&lt;span&gt;new&lt;/span&gt; DomainNotification(&lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;该邮箱已经被使用！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Task.FromResult(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Unit());
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个时候，我们把错误通知信息在事件总线中发布出去，剩下的就是需要在别的任何地方订阅即可，还记得哪里么，没错就是我们的自定义视图组件中，我们需要订阅通知信息，展示在页面里。&lt;/p&gt;
&lt;p&gt;注意：我们还要修改一下之前我们的命令处理程序基类 CommandHandler.cs 的验证信息收集方法，因为之前是用缓存来实现的，我们这里也用发布事件来实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将领域命令中的验证错误信息收集
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;目前用的是缓存方法（以后通过领域通知替换）&lt;/span&gt;
 &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; NotifyValidationErrors(Command message)
 {
     List&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; errorInfo = &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
     &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; error &lt;span&gt;in&lt;/span&gt;&lt;span&gt; message.ValidationResult.Errors)
     {
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;errorInfo.Add(error.ErrorMessage);      
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将错误信息提交到事件总线，派发出去&lt;/span&gt;
         _bus.RaiseEvent(&lt;span&gt;new&lt;/span&gt; DomainNotification(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;, error.ErrorMessage));
     }
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将错误信息收集一：缓存方法（错误示范）
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;_cache.Set(&quot;ErrorData&quot;, errorInfo);&lt;/span&gt;
 }
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;4、在视图组件中获取通知信息&lt;/h3&gt;
&lt;p&gt;这个很简单，之前我们用的是注入 IMemory 的方式，在缓存中获取，现在我们通过注入领域通知处理程序来实现，在视图组件 AlertsViewComponent.cs 中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AlertsViewComponent : ViewComponent
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 缓存注入，为了收录信息（错误方法，以后会用通知，通过领域事件来替换）
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; private IMemoryCache _cache;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 领域通知处理程序&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; DomainNotificationHandler _notifications;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造函数注入&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; AlertsViewComponent(&lt;span&gt;INotificationHandler&lt;/span&gt;&amp;lt;&lt;span&gt;DomainNotification&lt;/span&gt;&amp;gt;&lt;span&gt; notifications)
        {&lt;/span&gt;
            _notifications =&lt;span&gt; (&lt;span&gt;DomainNotificationHandler&lt;/span&gt;)notifications;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Alerts 视图组件
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 可以异步，也可以同步，注意方法名称，同步的时候是Invoke
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 我写异步是为了为以后做准备
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IViewComponentResult&amp;gt;&lt;span&gt; InvokeAsync()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从通知处理程序中，获取全部通知信息，并返回给前台&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; notificacoes = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Task.FromResult((_notifications.GetNotifications()));
            notificacoes.ForEach(c &lt;/span&gt;=&amp;gt; ViewData.ModelState.AddModelError(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty, c.Value));

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;5、StudentController 判断是否有通知信息&lt;/h3&gt;
&lt;p&gt; 通过注入的方式，把 INotificationHandler&amp;lt;DomainNotification&amp;gt; 注入控制器，然后因为这个接口可以实例化多个对象，那我们就强类型转换成 DomainNotificationHandler：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181204132455636-763102309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1468246/201812/1468246-20181204132514430-2092713717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里要说明下，记得要对事件处理程序注入，才能使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将事件模型和事件处理程序匹配注入&lt;/span&gt;
 services.AddScoped&amp;lt;&lt;span&gt;INotificationHandler&lt;/span&gt;&amp;lt;&lt;span&gt;DomainNotification&lt;/span&gt;&amp;gt;, &lt;span&gt;DomainNotificationHandler&lt;/span&gt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;



&lt;p class=&quot;indent&quot;&gt;好啦，今天的讲解基本就到这里了，今天重点说明了，我们如何使用事件总线，已经事件驱动模型下如何定义事件模型和事件处理程序，如果你都看懂了呢，这里可以简单回想一下以下几个问题：&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;1、为什么要定义事件驱动呢？（提示词：业务分离）&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;2、我们是在哪里发布这些事件的呢？（提示词：.publish()方法） &lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;3、事件驱动中的生命周期是从哪里开始到哪里接受的？（提示：处理程序Handler）&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;如果你对以上的内容还是比较困惑呢，这里有两个文章可以参考，当然，多沟通才是关键！&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/lori/p/4080426.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/lori/p/4080426.html&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/sD7O95O/article/details/79609305&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/sD7O95O/article/details/79609305&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt; &lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/anjoy8/ChristDDD&quot; target=&quot;_blank&quot;&gt;https://github.com/anjoy8/ChristDDD&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/laozhangIsPhi/ChristDDD&quot; target=&quot;_blank&quot;&gt;https://gitee.com/laozhangIsPhi/ChristDDD&lt;/a&gt; &lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;indent&quot;&gt;--END&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 04 Dec 2018 05:36:00 +0000</pubDate>
<dc:creator>老张的哲学</dc:creator>
<og:description>缘起 哈喽大家好，又是周二了，时间很快，我的第二个系列DDD领域驱动设计讲解已经接近尾声了，除了今天的时间驱动EDA（也有可能是两篇），然后就是下一篇的事件回溯，就剩下最后的权限验证了，然后就完结了，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laozhang-is-phi/p/10059878.html</dc:identifier>
</item>
</channel>
</rss>