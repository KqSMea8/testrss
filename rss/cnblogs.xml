<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>c++面向对象程序设计总结（类的使用） - 两千个秘密</title>
<link>http://www.cnblogs.com/wpbing/p/9774818.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wpbing/p/9774818.html</guid>
<description>&lt;p&gt;本篇算是学习c++有关类的知识的一些易错点吧.....&lt;/p&gt;
&lt;p&gt;并不是特别详细&lt;/p&gt;
&lt;p&gt;几点并不关于类的东西&lt;/p&gt;
&lt;p&gt;1.函数模板，用虚拟类型来实现模板的功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
template &lt;/span&gt;&amp;lt;typename t&amp;gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t为虚拟类型的名字，自己起的&lt;/span&gt;
&lt;span&gt;t maxx(t a,t b,t c)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max(a,max(b,c));
} 

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a=&lt;span&gt;1.1&lt;/span&gt;,b=&lt;span&gt;2.2&lt;/span&gt;,c=&lt;span&gt;3.3&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不管为double 还是int都可以调用maxx &lt;/span&gt;
    cout&amp;lt;&amp;lt;maxx(a,b,c)&amp;lt;&amp;lt;&lt;span&gt;endl;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a1=&lt;span&gt;1&lt;/span&gt;,b1=&lt;span&gt;2&lt;/span&gt;,c1=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
    cout&lt;/span&gt;&amp;lt;&amp;lt;maxx(a1,b1,c1)&amp;lt;&amp;lt;&lt;span&gt;endl;
 } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.关于函数默认的参数值要放到最右边&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; f1(&lt;span&gt;float&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt; c,&lt;span&gt;char&lt;/span&gt; d=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;错误，&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; f2(&lt;span&gt;float&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; c,&lt;span&gt;int&lt;/span&gt; b=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;char&lt;/span&gt; d=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.内置函数&lt;/p&gt;
&lt;p&gt;函数最左边加上inline(我觉得没啥用)，规模很小的函数才用&lt;/p&gt;
&lt;p&gt;4.字符串&lt;/p&gt;
&lt;p&gt;sizeof(string) 为4，因为系统分配的是固定的字节数，存放的是字符串的地址&lt;/p&gt;
&lt;p&gt;.......（以后再补充把）&lt;/p&gt;


&lt;p&gt;开始类的学习&lt;/p&gt;
&lt;p&gt;1.三种类的类型&lt;/p&gt;
&lt;p&gt;public&lt;/p&gt;
&lt;p&gt;这个就不多说了，类的对外接口&lt;/p&gt;
&lt;p&gt;private&lt;/p&gt;
&lt;p&gt;想要访问只能通过该类中的函数来访问&lt;/p&gt;
&lt;p&gt;protected&lt;/p&gt;
&lt;p&gt;和private差不多，区别在于继承时，以后说&lt;/p&gt;

&lt;p&gt;2.类的声明和成员函数的分离（以后更新）&lt;/p&gt;

&lt;p&gt;3.构造函数&lt;/p&gt;
&lt;p&gt;没有返回值，名字和类名字一样#include&amp;lt;iostream&amp;gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; box{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        box(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ,&lt;span&gt;int&lt;/span&gt; ,&lt;span&gt;int&lt;/span&gt; );&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造函数 （有无默认参数都行）&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; volume();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; w;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; l;
};
box::box(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;int&lt;/span&gt; b,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; c)
{
    h&lt;/span&gt;=a,w=b,l=&lt;span&gt;c;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其实一般这样写
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; box::box(int a,int b,int c):h(a),w(b),l(c){}&lt;br/&gt;//注意如果是数组的话  则要写在大括号内&lt;br/&gt;&lt;/span&gt;//box::box(int a,int b,int c,char nam[]):h(a),w(b),l(c)&lt;br/&gt;&lt;em id=&quot;__mceDel&quot;&gt;//{strcpy(name,nam);}&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以用另一个对象初始化另一个&lt;/p&gt;
&lt;p&gt;time t1;&lt;/p&gt;
&lt;p&gt;time t2=t1;   //注意是吧t1的数据成员复制到t2，而不调用t2的构造函数&lt;/p&gt;
&lt;p&gt;4.析构函数&lt;/p&gt;
&lt;p&gt;注意一点，先构造的后析构，相当于栈，先进后出&lt;/p&gt;
&lt;p&gt;静态局部对象，在函数结束时，并不释放，也就不调用析构函数&lt;/p&gt;
&lt;p&gt;5.对象数组&lt;/p&gt;
&lt;p&gt;box b[3] = (1 , 2 ,3)//这样其实不对，这三个实参则分别作为3个元素的第一个实参&lt;/p&gt;
&lt;p&gt;初始化应该&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
box a[&lt;span&gt;3&lt;/span&gt;]=&lt;span&gt;{
    box(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;&lt;span&gt;);
    box(&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;,&lt;span&gt;40&lt;/span&gt;&lt;span&gt;);
    box(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.对象指针&lt;/p&gt;
&lt;p&gt;先说下函数指针。。。。还有函数指针？？？？&lt;/p&gt;
&lt;p&gt;类型名（* 指针变量名）（参数列表）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; (* p)();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p是一个指向void型函数的指针 &lt;/span&gt;
p=fun;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;fun函数入口地址付给p 注意没有括号&lt;/span&gt;
(*p)();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对象成员函数有些复杂&lt;/p&gt;
&lt;p&gt;要求    函数参数类型和个数匹配        函数返回值类型一样     所属的类一样&lt;/p&gt;
&lt;p&gt;void ( time:: *p )();//此时p为指向time类中的成员函数指针&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;time t;
 &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; (time:: *&lt;span&gt;p)();
 p &lt;/span&gt;= &amp;amp;&lt;span&gt;time::gettime();
 (t.&lt;/span&gt;*p)();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7.this指针（指向当前对象）&lt;/p&gt;
&lt;p&gt;当前被调用的成员函数所在对象的起始地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; box::volume()
 {&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (h*l*w);}&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实际为{ return this-&amp;gt;h * this-&amp;gt;l * this-&amp;gt;w;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用时 如 a.volume() ,实际为将对象a的地址传给形参this指针&lt;/p&gt;

&lt;p&gt;8.常对象&lt;br/&gt;只能通过构造函数参数表来对其初始化,所有数据成员绝对不能被改变，并且只能调用它的常成员函数&lt;br/&gt;如果非要改变，要加上 mutable 如有一个计数变量count， 则要 mutable int count;&lt;/p&gt;
&lt;p&gt;非const数据成员 非const函数可引用和改变 const函数可引用不可改变&lt;br/&gt;const数据成员 非const函数可引用不可改变 const函数可引用不可改变&lt;br/&gt;const函数不可调用非const函数&lt;/p&gt;
&lt;p&gt;常指针 如&lt;br/&gt;Time t1;&lt;br/&gt;Time * const p = =&amp;amp;t1;&lt;br/&gt;p不可再改变&lt;br/&gt;常变量只能被常指针指向，，&lt;br/&gt;普通变量也可被常指针指向，但这时该普通变量就在这期间变成的常变量，不能改变&lt;/p&gt;
&lt;p&gt;复制构造函数&lt;br/&gt;Box box2(box);&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;9.静态数据成员&lt;/p&gt;
&lt;p&gt;数据声明前 加 static&lt;br/&gt;特点是可以被每个该同类对象所引用，只能在类体外进行初始化,在类外也可直接引用&lt;br/&gt;如 int Box::height = 10;//不必加static&lt;br/&gt;可以通过对象名来引用，也可以通过类名&lt;br/&gt;如&lt;br/&gt;cout&amp;lt;&amp;lt;a.count&amp;lt;&amp;lt;endl;&lt;br/&gt;cout&amp;lt;&amp;lt;Box::count&amp;lt;&amp;lt;endl;&lt;/p&gt;&lt;p&gt;10.友元&lt;br/&gt;友元函数可以使一般的，也可以是另一个类中的，可以访问私有数据成员&lt;br/&gt;友元类就是全家都是友元函数&lt;br/&gt;注意是单向的，注意不能传递&lt;/p&gt;
&lt;p&gt;11.类的模板&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
temple&amp;lt;&lt;span&gt;class&lt;/span&gt; t&amp;gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;t 为虚拟变量名字 可以有多个，但都要加class 如：temple&amp;lt;class t1,class t2&amp;gt; &lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; compare{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
compare(t a,t b)
{
x&lt;/span&gt;=a,y=&lt;span&gt;b;
}
t max() {
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max(a,b);
}
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
t x,y;
}; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;定义对象时为：&lt;br/&gt;compare&amp;lt;int&amp;gt; cmp(3,4);&lt;br/&gt;//多个时 compare&amp;lt;int ,double&amp;gt; cmp(3,4);&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;12.对运算符的重载&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; yuan{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        yuan(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; b):x(a),y(b){};
        yuan &lt;/span&gt;&lt;span&gt;operator&lt;/span&gt; +(yuan &amp;amp;&lt;span&gt;t)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; yuan(x+t.x, y+&lt;span&gt;t.y);
        }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; x,y;
};             &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时如果有&lt;br/&gt;yuan c1(1,2),c2(1,2),c3;&lt;br/&gt;c3 = c1 + c2;&lt;br/&gt;则实际为 c3 = c1.operator(c2);&lt;/p&gt;
&lt;p&gt;但其实我觉得更方便的是通过友元函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; yuan{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        yuan(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; b):x(a),y(b){};
        friend yuan &lt;/span&gt;&lt;span&gt;operator&lt;/span&gt; +(yuan &amp;amp;t1,yuan &amp;amp;t2)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个其实挺灵活的，可以自行改变 &lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; yuan(t1.x+t2.x, t1.y+&lt;span&gt;t2.y);
        }
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; x,y;
};             &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;c3 = c1 + c2 则解释为operator +(c1,c2);&lt;/p&gt;

&lt;p&gt;13.继承&lt;/p&gt;
&lt;p&gt;派生类拥有基类的数据成员，其分配如下&lt;/p&gt;
&lt;p&gt;先说公有继承&lt;/p&gt;

&lt;p&gt;基类属性                               派生类    &lt;/p&gt;
&lt;p&gt;private                                  不可访问&lt;/p&gt;

&lt;p&gt;public          公有继承后        public&lt;/p&gt;

&lt;p&gt;protected                            protected&lt;/p&gt;

&lt;p&gt;私有继承&lt;/p&gt;
&lt;p&gt;基类属性                               派生类    &lt;/p&gt;
&lt;p&gt;private                                  不可访问&lt;/p&gt;

&lt;p&gt;public          私有继承后        private&lt;/p&gt;

&lt;p&gt;protected                            private&lt;/p&gt;
&lt;p&gt;保护继承&lt;/p&gt;
&lt;p&gt;保护成员：只有子女（派生类）可以访问，（友元函数也不行）&lt;/p&gt;
&lt;p&gt;基类属性                               派生类    &lt;/p&gt;
&lt;p&gt;private                                  不可访问&lt;/p&gt;

&lt;p&gt;public          保护继承后        protected&lt;/p&gt;

&lt;p&gt;protected                            protected&lt;/p&gt;

&lt;p&gt;14.有子对象的派生构造函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; display();
        Student(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n,&lt;span&gt;string&lt;/span&gt;&lt;span&gt; nam):num(n),name(nam){}
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; num;
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name;
};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Student1: &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Student{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        Student1(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n,&lt;span&gt;string&lt;/span&gt; nam,&lt;span&gt;int&lt;/span&gt; n1,&lt;span&gt;string&lt;/span&gt; nam1,&lt;span&gt;int&lt;/span&gt; a,&lt;span&gt;string&lt;/span&gt;&lt;span&gt; ad):
            Student(n,nam),monitor(n1,nam1),age(a),addr(ad){}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意初始化，一般用初始化表来 ，同样的，在多级派生中也是如此来构造&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show()
        {
            monitor.display();
        }
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
        Student monitor;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;派生类中的子对象 &lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; addr;
};
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    
 } &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 多级的形式&lt;/p&gt;
&lt;p&gt;派生类构造名: 基类1构造函数(参数表) , 基类2构造函数(参数表) , 基类3构造函数(参数表) &lt;/p&gt;
&lt;p&gt;{  派生类中新增的数据成员初始化语句 }&lt;/p&gt;
&lt;p&gt;15 . 关于多重继承的二义性问题&lt;/p&gt;
&lt;p&gt;就是继承的函数名  和   派生的函数名一样了&lt;/p&gt;
&lt;p&gt;假设有类A和类B，此时类C同时继承类A和类B，现在问题是  类A 类B  类C都有一个  叫display()的函数 &lt;/p&gt;
&lt;p&gt;C c1;&lt;/p&gt;
&lt;p&gt;c1.display()//此时该是谁呢，是最新的也就是c的display（）。这个会覆盖&lt;/p&gt;
&lt;p&gt;此时要想访问A的display（），则要限定作用域 。&lt;/p&gt;
&lt;p&gt;比如  c.A::display();&lt;/p&gt;
&lt;p&gt;16.虚基类&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1369734/201810/1369734-20181013152617764-309112285.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;D 是 B 和 C 的派生类，B 和 C 又都是继承了A，这样会保留多份数据成员的拷贝&lt;/p&gt;
&lt;p&gt;虚基类是的在继承简介共同基类时只保留一份&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A
{
    A(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){}
    .....
};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; B: &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; A
{
    B(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n):A(n){}
    ...
};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; C: &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; A
{
    C(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n):C(n){}
    ...
};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; D:&lt;span&gt;public&lt;/span&gt; B,&lt;span&gt;public&lt;/span&gt;&lt;span&gt; C
{
    D(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n):A(n),B(n),C(n){}//这个必须由最后的派生类中对直接基类和虚基类初始化
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;17.类型的转化&lt;/p&gt;
&lt;p&gt;派生类可以向基类对象赋值  （大材小用），也可以向积累对象的引用进行赋值或初始化&lt;/p&gt;
&lt;p&gt;派生类对象的地址可以赋给基类对象的指针变量，也就是说，指向基类对象的指针变量也可以用来指向派生类对象&lt;/p&gt;
&lt;p&gt;18.多态性&lt;/p&gt;
&lt;p&gt;分为两种 ，静态多态性和动态多态性（啥玩意啊，玩的怪花（小声bb））&lt;/p&gt;
&lt;p&gt;静态多态性 就是  函数重载   和运算符的重载&lt;/p&gt;
&lt;p&gt;动态  就是通过虚函数来实现的&lt;/p&gt;

&lt;p&gt; 说一下虚函数，作用还是要解决继承中的二义性问题，&lt;/p&gt;
&lt;p&gt;解决方法是想通过指针的方法来实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Student stu(...);
Graduate grad(...);//假设grad是stu的派生，且两者都有display函数
Student &lt;/span&gt;*p = &amp;amp;&lt;span&gt;stu;
p&lt;/span&gt;-&amp;gt;&lt;span&gt;display();
p &lt;/span&gt;= &amp;amp;grad;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;想通过变换指针指向来，但单单的这样做是不行的，因为这样做会把grad类型强制转化成student的类型 &lt;/span&gt;
p-&amp;gt;display();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解决上述问题的方法是将Student类中的display（）函数前加上virtual&lt;/p&gt;
&lt;p&gt;　　注意问题是  成原函数 定义为虚函数后，其派生类都为虚函数&lt;/p&gt;
&lt;p&gt;　　使用方法是指向一个基类对象的指针变量，并使它指向同一类族中需要调用该函数的对象&lt;/p&gt;

&lt;p&gt;19.虚析构函数&lt;/p&gt;
&lt;p&gt;如下面代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Point{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        point();
        &lt;/span&gt;~&lt;span&gt;point();
}; 
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Circle: &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Point
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        Circle();
        &lt;/span&gt;~&lt;span&gt;Circle();
}
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    Point &lt;/span&gt;*p = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Circle;
    &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; p;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;new的一个对象，在释放的时候，只会执行基类的析构函数，而不执行派生类的&lt;/p&gt;
&lt;p&gt;解决方法是  在Point 的析构函数前加上 virtual&lt;/p&gt;
&lt;p&gt;个人理解（这个virtual  在继承中 都会遗传）&lt;/p&gt;
&lt;p&gt;20.纯虚函数&lt;/p&gt;
&lt;p&gt;先说一点吧，往往有一些类，他们不用来生成对象，唯一目的就是用它去建立派生类，叫做抽象类&lt;/p&gt;
&lt;p&gt;比如，点 可以派生出 园 ，圆可以派生出圆柱体  ，但这些都是 shape 的直接派生或者间接派生&lt;/p&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Shape{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; area() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;;}&lt;span&gt;//&lt;/span&gt;&lt;span&gt;虚函数&lt;/span&gt;
        &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; volume() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0.0&lt;/span&gt;;}&lt;span&gt;//&lt;/span&gt;&lt;span&gt;虚函数&lt;/span&gt;
        &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; shapeName() &lt;span&gt;const&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 纯虚函数 形式为 virtual 函数类型 函数名字 (参数列表) =0;&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后来个差不多的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Shape
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; area() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0.00&lt;/span&gt;&lt;span&gt;;}
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; volume() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0.00&lt;/span&gt;&lt;span&gt;;}
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ShapeName() &lt;span&gt;const&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
};
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Point: &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Shape
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        Point(&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; a=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;float&lt;/span&gt; b=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;): x(a), y(b){};
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SetPoint(&lt;span&gt;float&lt;/span&gt; a,&lt;span&gt;float&lt;/span&gt;&lt;span&gt; b)
        {
            x&lt;/span&gt;=a,y=&lt;span&gt;b;
        }
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; getX() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;}
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; getY() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt;&lt;span&gt; y;}
        
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ShapeName() &lt;span&gt;const&lt;/span&gt; {cout&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;point&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;}
        friend ostream &lt;/span&gt;&amp;amp;&lt;span&gt;operator&lt;/span&gt; &amp;lt;&amp;lt;(ostream &amp;amp;,&lt;span&gt;const&lt;/span&gt; Point &amp;amp;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; x,y;
};
ostream &lt;/span&gt;&amp;amp;&lt;span&gt;operator&lt;/span&gt; &amp;lt;&amp;lt;(ostream &amp;amp;output,&lt;span&gt;const&lt;/span&gt; Point &amp;amp;&lt;span&gt;p)
{
        output&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;p.x&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;p.y&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; output;
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Circle: &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Point
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        Circle(&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; x=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;float&lt;/span&gt; y=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;float&lt;/span&gt; r=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;):Point(x,y),radius(r) {}
        
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SetRaidus(&lt;span&gt;float&lt;/span&gt; r){ radius =&lt;span&gt; r;}
        
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; GetRadius() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt;&lt;span&gt; radius;}
        
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; area() &lt;span&gt;const&lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; &lt;span&gt;3.14&lt;/span&gt; * radius *&lt;span&gt; radius;}
        
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ShapeName() &lt;span&gt;const&lt;/span&gt; {cout&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Circle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;}
        
        friend ostream &lt;/span&gt;&amp;amp;&lt;span&gt;operator&lt;/span&gt; &amp;lt;&amp;lt;(ostream &amp;amp;,&lt;span&gt;const&lt;/span&gt; Circle &amp;amp;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; radius;
};
ostream &lt;/span&gt;&amp;amp;&lt;span&gt;operator&lt;/span&gt; &amp;lt;&amp;lt;(ostream &amp;amp;&lt;span&gt;out&lt;/span&gt;,&lt;span&gt;const&lt;/span&gt; Circle &amp;amp;&lt;span&gt;c)
{
    &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;c.x&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;c.y&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;
    &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;c.radius&amp;lt;&amp;lt;&lt;span&gt;endl;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;
}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Yuan: &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Circle
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
        Yuan(&lt;/span&gt;&lt;span&gt;float&lt;/span&gt; x=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;float&lt;/span&gt; y=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;float&lt;/span&gt; r=&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;float&lt;/span&gt; h=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;):Circle(x,y,r),height(h){}
        
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; SetHeight(&lt;span&gt;float&lt;/span&gt; h) {height =&lt;span&gt; h;}
        
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; area() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; * Circle::area() + &lt;span&gt;2&lt;/span&gt; * &lt;span&gt;3.14&lt;/span&gt; * radius *&lt;span&gt; height;}
        
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; vulume() &lt;span&gt;const&lt;/span&gt; {&lt;span&gt;return&lt;/span&gt; Circle::area() *&lt;span&gt; height;}
        
        &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ShapeName() &lt;span&gt;const&lt;/span&gt; {cout&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yuan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;endl;}
        
        friend ostream &lt;/span&gt;&amp;amp;&lt;span&gt;operator&lt;/span&gt; &amp;lt;&amp;lt;(ostream &amp;amp;,&lt;span&gt;const&lt;/span&gt; Yuan &amp;amp;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; height;
};
ostream &lt;/span&gt;&amp;amp; &lt;span&gt;operator&lt;/span&gt; &amp;lt;&amp;lt;(ostream &amp;amp;&lt;span&gt;out&lt;/span&gt;,&lt;span&gt;const&lt;/span&gt; Yuan &amp;amp;&lt;span&gt;Y)
{
    &lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;Y.x&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;Y.y&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],r=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;Y.radius&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;H=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;lt;&amp;lt;Y.height&amp;lt;&amp;lt;&lt;span&gt;endl;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    Point point (&lt;/span&gt;&lt;span&gt;3.2&lt;/span&gt;,&lt;span&gt;4.5&lt;/span&gt;&lt;span&gt;);
    Circle circle(&lt;/span&gt;&lt;span&gt;2.4&lt;/span&gt;,&lt;span&gt;1.2&lt;/span&gt;,&lt;span&gt;5.6&lt;/span&gt;&lt;span&gt;);
    Yuan yuan(&lt;/span&gt;&lt;span&gt;3.4&lt;/span&gt;,&lt;span&gt;6.4&lt;/span&gt;,&lt;span&gt;5.2&lt;/span&gt;,&lt;span&gt;10.5&lt;/span&gt;&lt;span&gt;);
    point.ShapeName();
    cout&lt;/span&gt;&amp;lt;&amp;lt;point&amp;lt;&amp;lt;&lt;span&gt;endl;
    
    circle.ShapeName();
    cout&lt;/span&gt;&amp;lt;&amp;lt;circle&amp;lt;&amp;lt;&lt;span&gt;endl;
    
    yuan.ShapeName();
    cout&lt;/span&gt;&amp;lt;&amp;lt;yuan&amp;lt;&amp;lt;&lt;span&gt;endl;
    
    Shape &lt;/span&gt;*&lt;span&gt;pt;
    pt&lt;/span&gt;=&amp;amp;&lt;span&gt;point;
    pt&lt;/span&gt;-&amp;gt;&lt;span&gt;ShapeName();
    
    pt&lt;/span&gt;=&amp;amp;&lt;span&gt;circle;
    pt&lt;/span&gt;-&amp;gt;&lt;span&gt;ShapeName();
    pt&lt;/span&gt;=&amp;amp;&lt;span&gt;yuan;
    pt&lt;/span&gt;-&amp;gt;&lt;span&gt;ShapeName();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可能以和还会更新吧..............&lt;/p&gt;
</description>
<pubDate>Sat, 13 Oct 2018 15:29:00 +0000</pubDate>
<dc:creator>两千个秘密</dc:creator>
<og:description>本篇算是学习c++有关类的知识的一些易错点吧..... 并不是特别详细 几点并不关于类的东西 1.函数模板，用虚拟类型来实现模板的功能 2.关于函数默认的参数值要放到最右边 3.内置函数 函数最左边加</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wpbing/p/9774818.html</dc:identifier>
</item>
<item>
<title>轻松使用 Redis slowlog - Nuss</title>
<link>http://www.cnblogs.com/Nuss/p/9784732.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Nuss/p/9784732.html</guid>
<description>&lt;div id=&quot;output_wrapper_id&quot; class=&quot;output_wrapper&quot; readability=&quot;54&quot;&gt;
&lt;p&gt;之前中秋项目搞活动，用户比较活跃 SE.Redis 频繁报 Timeout 异常，狂翻了一波 issues 发现提这个问题还蛮多的，作者非常频繁的提到使用 slowlog 这个命令进行排查，那么问题就来了，它是干嘛滴？&lt;/p&gt;
&lt;h2 id=&quot;hredisslowlog&quot;&gt;&lt;span&gt;Redis slowlog 是个什么&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;使用这个命令可以读取或重置 Redis 慢速查询日志。通俗讲就是 redis 可以把执行时间超过我们设定值的命令记录下来，slowlog 是记录到内存中的哦，所以非常快。&lt;/p&gt;
&lt;p&gt;这里的&lt;strong&gt;执行时间&lt;/strong&gt;不包括 I/O 操作,比如与客户端,发送应答等等,就是实际执行命令所需的时间(命令唯一执行的阶段，线程被阻塞且不能同时处理其他请求)。&lt;/p&gt;
&lt;h2 id=&quot;hredisslowlog-1&quot;&gt;&lt;span&gt;设置 Redis slowlog&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;两种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;可以通过配置 redis.conf 来完成。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;运行时，使用 CONFIG GET 和 CONFIG SET 命令配置。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里我们主要说的是第二种方式，您可以使用两个参数来配置慢日志：slowlog-log-slow-than * ,告诉 Redis, 记录超过 * &lt;strong&gt;微秒&lt;/strong&gt; 内的命令执行情况。&lt;/p&gt;
&lt;p&gt;需要注意的是，设置负数表示禁用 slowlog ，而设置 0 则强制记录每个命令的执行情况。&lt;br/&gt;以下是 slowlog 的设置使用说明：&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs css&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;slowlog-log-slower-than&lt;/span&gt; 10000&lt;br/&gt;&quot;&lt;span class=&quot;hljs-selector-tag&quot;&gt;OK&lt;/span&gt;&quot;&lt;p&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;redis&lt;/span&gt; 127&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:6379&lt;/span&gt;&amp;gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;config&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;slowlog-log-slower-than&lt;/span&gt;&lt;br/&gt;1)  &quot;&lt;span class=&quot;hljs-selector-tag&quot;&gt;slowlog-log-slower-than&lt;/span&gt;&quot;&lt;br/&gt;2)  &quot;10000&quot;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么问题又来了，slowlog 是记录再内存中的，如果记录所有的命令 log 会不会把内容撑爆呢？&lt;/p&gt;
&lt;p&gt;答案是当然不会。slowlog 记录的 log 数是有最大长度限制的，我们可以通过 slowlog-max-len 来查询 slowlog 的最大长度。最小值为零。当一个新的命令被记录下来，并且如果已经达到它的最大长度时，最老的一个 log 将从队列中删除，FIFO 。&lt;/p&gt;
&lt;p&gt;另外，使用 slowlog len 命令可以查看当前已记录的数量。&lt;br/&gt;使用 slowlog reset 重置已记录的 slowlog 信息。&lt;/p&gt;
&lt;h2 id=&quot;hslowlog&quot;&gt;&lt;span&gt;如何阅读 slowlog&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;我们已经了解 slowlog 是记录在内存中的，所以您可以启用所有命令的日志记录即 slowlog-log-slow-than 配置参数设置为 0 便于监测性能。&lt;/p&gt;
&lt;p&gt;要读取 slowlog，使用 SLOWLOG GET 获取命令，它返回慢日志中的每一个条目。可以只返回N个最近的条目，将一个附加参数传递给命令（例如 SLOWLOG GET 2）。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs cs&quot; readability=&quot;2&quot;&gt;redis &lt;span class=&quot;hljs-number&quot;&gt;127.0&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;.1&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;6379&lt;/span&gt;&amp;gt; slowlog &lt;span class=&quot;hljs-keyword&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) (integer) &lt;span class=&quot;hljs-number&quot;&gt;14&lt;/span&gt;             &lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) (integer) &lt;span class=&quot;hljs-number&quot;&gt;1309448221&lt;/span&gt;     &lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;) (integer) &lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;             &lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;) &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;hljs-string&quot;&gt;&quot;ping&quot;&lt;/span&gt;                &lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) (integer) &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) (integer) &lt;span class=&quot;hljs-number&quot;&gt;1309448128&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;) (integer) &lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;) &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) &lt;span class=&quot;hljs-string&quot;&gt;&quot;slowlog&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;) &lt;span class=&quot;hljs-string&quot;&gt;&quot;get&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;hljs-string&quot;&gt;&quot;100&quot;&lt;/span&gt;&lt;p&gt;&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;hljs-string&quot;&gt;&quot;127.0.0.1:58217&quot;&lt;/span&gt;         &lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;) &lt;span class=&quot;hljs-string&quot;&gt;&quot;worker-123&quot;&lt;/span&gt;              &lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，需要注意此命令需要 2.2.12及以上版本的 redis 才能支持。&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 13 Oct 2018 15:19:00 +0000</pubDate>
<dc:creator>Nuss</dc:creator>
<og:description>之前中秋项目搞活动，用户比较活跃 SE.Redis 频繁报 Timeout 异常，狂翻了一波 issues 发现提这个问题还蛮多的，作者非常频繁的提到使用 slowlog 这个命令进行排查，那么问题就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Nuss/p/9784732.html</dc:identifier>
</item>
<item>
<title>未来公司的酒会 - mskitten</title>
<link>http://www.cnblogs.com/mozi-song/p/9784727.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mozi-song/p/9784727.html</guid>
<description>&lt;p&gt;面试的时候，未来老板加了我的微信。这几天，他发微信来说，我将来的大老板要从纽约飞过来，请全组人吃饭，邀请我也一起去。&lt;/p&gt;
&lt;p&gt;于是，我见到我的未来同事们啦。&lt;/p&gt;

&lt;p&gt;来到公司，第一感觉是节奏非常快，跟老板讲话的时候我的语速都有点跟不上。不过还好我聪明（？？），立刻就习惯了。&lt;/p&gt;
&lt;p&gt;同事们非常友善，也非常热情，每个人都从座位上站起来跟我握手。老板介绍了大组里三十多位同事的名字，但是我一个都没记住。只记住了有好几个女生，其中有好几个很漂亮。&lt;/p&gt;
&lt;p&gt;老板拉着我转完一圈以后，指着一个靠走道的座位说：这里就是你以后的座位，你可以先坐在这里，下班时我们叫你。当时是下午四点半，我坐了下来，手足无措，我还没从现在的公司离职呢……&lt;/p&gt;
&lt;p&gt;我的账号还没好，所以电脑开不了机。我装作看手机，打量着周围。有一个女生的笑声特别脆亮。老板指着她说：你来带mskitten周围转一下……&lt;/p&gt;
&lt;p&gt;那位女生笑眼弯弯地向我走来，带着我去楼下的果汁店买了两杯38元的果汁（她说没关系，老板请客……），然后我们走进公司的休息室坐下，她不停地说着，十分伶牙俐齿。而她具体说了什么，差不多全都不记得了。巨大的落地窗外面的云朵和浦东的风光，让我完全恍神……&lt;/p&gt;

&lt;p&gt;在与她的对话中，有两点让我确定了她不是表面看起来那么大大咧咧，也让我对新公司好感度爆棚。&lt;/p&gt;
&lt;p&gt;她说：公司是一个资源很丰富的地方，但是要提升自己，一定要有内在的动力。不会有人逼着你学习，但是老板们会很支持你参加各种培训，公司里也有很多原版书可以看，至于去不去利用，就看你自己。通常大家最大的问题是没时间学习。&lt;/p&gt;
&lt;p&gt;她还说（我问公司加班是否严重）：没有一个公司能保证永远不加班。我个人的看法是，只要加班能让你真的学到东西，偶尔加班也没关系。&lt;/p&gt;
&lt;p&gt;我觉得她非常真诚，三观也很正。&lt;/p&gt;
&lt;p&gt;我很感激她第一天就跟我说这些。我从未碰到一个愿意这样提点我的同事。&lt;/p&gt;
&lt;p&gt;所以她虽然看起来大大咧咧，但我打定主意认为她并不一般，值得交朋友。&lt;/p&gt;

&lt;p&gt;第16层的半层都是我们组的人，只有一个女生是产品经理。这个女生戴着眼镜，看到我的时候笑咪咪的，看起来脾气非常好的样子。&lt;/p&gt;
&lt;p&gt;下班时，大家说要走去吃饭的地方，她一脸愁苦：“能不能打车啊？”大家说高峰期不好打，于是她委屈巴拉地拎着包走在后面。&lt;/p&gt;
&lt;p&gt;走在路上。她一直在撒娇：“怎么这么远啊，走不动了……”然后旁边的女生就哄着她：“娘娘啊，再一段就到了，到了就可以吃好吃的了。”她于是提起劲来，快走两步，然后想到了什么，又颓然慢下来，说：“那家东西很难吃……大老板每次都定那家，一定是因为便宜……”&lt;/p&gt;
&lt;p&gt;上菜的时候，她说自己胖，吃了两口就拒绝再吃了。让她再吃点，她非常严肃地摆手说：“我真的饱了！”旁人劝了一阵，看她毫不动摇，于是埋头苦吃起来，她眼巴巴地望着。过了一会，服务生上了一个大披萨，桌子上只有靠近她的地方有位置放。她便自顾自地跟服务生说：“我真的吃不下了，我吃了好多了！放在这里吧。”然后拿了一大块……&lt;/p&gt;
&lt;p&gt;我要赶火车回家的时候，这个女生非常舍不得我走，在旁边各种出主意，叫我陪他们一起high到凌晨，第二天跟现在的公司请假。旁人劝着“来日方长，来日方长——”我这才站起来走了。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;1431316510719061435.gif&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.0546448087431694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/z0aiaCia1F9LK5YVwbIftzktGq0Q8I3CM6ibheYk9icfOxLeCRE9IeQBeQorNvZFIVpf0bWjejKBLqTS6VoVLXyjibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;366&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有一个健身的男生A，听说在公司的啤酒大赛上得了部门第一名，看起来已经不是第一次聊这个话题了，仍难掩得意之色。&lt;/p&gt;
&lt;p&gt;这个啤酒大赛十分奇葩，是某个英国同事私人提议和组织的。每个参赛者都有一名对应的裁判，参赛者必须喝完一定数量（很多）的啤酒，并且在半小时内不准吐，也不准去厕所。裁判记录参赛者喝完酒所用的时间，时间短者排名高。&lt;/p&gt;
&lt;p&gt;这个男生A，听说是只用了三分半，就喝光了全部啤酒，而其他人至少要二十分钟。&lt;/p&gt;
&lt;p&gt;另一个男生B，不知怎么的，对此事耿耿于怀，一定要当场与A一决高下。&lt;/p&gt;
&lt;p&gt;A说：你先去网站上看一下，把排在我后面的人都打败，再来单挑我吧！&lt;/p&gt;
&lt;p&gt;B说：我不喜欢一个人喝酒，我就要跟你单挑！而且我觉得啤酒比赛不合理，比的是胃口，而不是酒量！&lt;/p&gt;
&lt;p&gt;这时男生C插进来说：对哦，那个全公司第一名的美国佬只用了一分钟，他肚子大到坐在椅子上都能垂到地上……&lt;/p&gt;
&lt;p&gt;于是剩下的人怂恿一阵，笑一阵，完全不理站在角落的两位大老板。&lt;/p&gt;

&lt;p&gt;在今天之前，我全然想不到见到未来同事是什么感觉。&lt;/p&gt;
&lt;p&gt;我曾经面试过心仪的S公司，那时得到录取，就像梦幻一般。我想到可以去S公司上班，心里就砰砰直跳。&lt;/p&gt;
&lt;p&gt;像Altucher说的那样，“初恋的感觉”。&lt;/p&gt;
&lt;p&gt;而今天，从搭着写字楼的电梯到十六层见到未来的老板，到坐火车转地铁回到家里，我都很笃定，像双脚稳稳踏在粗糙的大地上。&lt;/p&gt;
&lt;p&gt;这是一种“我配得上来这里上班”的感觉。&lt;/p&gt;

&lt;p&gt;当我把我的辞职信发布在博客上时，得到了许多批评和冷水，最频繁出现的是“你会发现，下一家公司只有更差”。&lt;/p&gt;
&lt;p&gt;或许是我太盲目地乐观，又或许是我还没经历到他们所说的“更差”。我今天所观察到的事实，只是增添了我对未来的信心。&lt;/p&gt;
&lt;p&gt;对我来说，有一群志同道合的同事非常重要。我不喜欢跟混水摸鱼的人一起工作，也不喜欢跟为了表现自己勤奋而加班的人一起工作。&lt;/p&gt;
&lt;p&gt;在现在的公司，我是一个非常格格不入的人。我想学新的东西、想做出一些改变，想好好上班、好好生活、好好玩耍，想跟同事成为生活中的朋友，这在他们眼中看来，似乎都很怪诞。&lt;/p&gt;
&lt;p&gt;我还是努力着，但是感到很孤独。&lt;/p&gt;
&lt;p&gt;当我第一次坐下来，跟未来的同事碰杯，因为一个共同的领悟而哈哈大笑时，我心里突然“啪嗒”一下，有一个声音告诉我：这就是真正适合你的地方啊。&lt;/p&gt;
&lt;p&gt;我知道还是会有奇葩的同事，还是会有我不理解的公司制度，而且会有新的挑战——比我聪明也比我努力的程序员，在高处俯瞰我。&lt;/p&gt;
&lt;p&gt;但我知道，我是他们的同类。我会跟他们一起，去往更精彩的地方。&lt;/p&gt;
&lt;p&gt;这一刻，我是多么快乐啊。&lt;/p&gt;
</description>
<pubDate>Sat, 13 Oct 2018 15:18:00 +0000</pubDate>
<dc:creator>mskitten</dc:creator>
<og:description>面试的时候，未来老板加了我的微信。这几天，他发微信来说，我将来的大老板要从纽约飞过来，请全组人吃饭，邀请我也一起去。 于是，我见到我的未来同事们啦。 来到公司，第一感觉是节奏非常快，跟老板讲话的时候我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mozi-song/p/9784727.html</dc:identifier>
</item>
<item>
<title>设计模式——代理模式 - Mr.yang.localhost</title>
<link>http://www.cnblogs.com/mr-yang-localhost/p/9746184.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mr-yang-localhost/p/9746184.html</guid>
<description>&lt;h2&gt;定义&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;为其他对象提供一种代理以控制对这个对象的访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　代理模式也叫委托模式，日常生活中很常见。帮别人做某某事情时候，自己就是别人的代理；让别人帮自己做什么事情时候，别人就是自己的代理。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;通用类图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181007165545821-1992367803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;Subject抽象主题角色&lt;/h4&gt;
&lt;p&gt;　　抽象主题类是一个普通的业务类型的定义，规定要做什么事情。可以是一个抽象类也可以是一个接口。&lt;/p&gt;
&lt;h4&gt;RealSubject具体主题角色&lt;/h4&gt;
&lt;p&gt;　　被委托（被代理）的角色，是真正事情处理的执行者。&lt;/p&gt;
&lt;h4&gt;Proxy代理主题角色&lt;/h4&gt;
&lt;p&gt;　　委托类（代理类），负责对真实角色的调用，把所有主题限定的方法委托给具体主题角色，也可以在真实主题角色处理前做一些预处理，或在真实主题角色处理后做一些善后处理（比如Spring的AOP）。&lt;/p&gt;
&lt;h2&gt;普通代理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;小时候在家都是妈妈做饭，做饭需要洗菜，切菜，炒菜……有时候妈妈有事忙没按时回家，姐姐就偷偷代替妈妈给大家做饭。如果&lt;span&gt;将做饭简单理解为洗菜、切菜、炒菜三个步骤&lt;/span&gt;，从程序员的角度来记录做饭这件事就很简单了。妈妈和姐姐都需要洗菜、切菜然后再炒菜，所以可以规定炒菜的三个步骤，然后分别实现这三个步骤，所以可以简单表示为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181007163516254-1088827574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ICook定义了炒菜必须要经历的流程：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ICook {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*洗菜&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; washFood();
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*切菜&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cutFood();
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*炒菜&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stirFood();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;妈妈（对于一家人来说，天天吃妈妈做的饭，妈妈就是一个Cooker）做饭的流程：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cooker implements ICook {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; washFood() {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;妈妈在洗菜……&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cutFood() {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;妈妈在切菜……&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stirFood() {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;妈妈在炒菜……&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一个能代理妈妈做饭（实现了ICook接口）的角色&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CookerProxy implements ICook {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICook cooker;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CookerProxy(ICook cooker){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cooker =&lt;span&gt; cooker;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; washFood() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cooker.washFood();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cutFood() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cooker.cutFood();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stirFood() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cooker.stirFood();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;姐姐代替妈妈做饭&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
        Cooker cooker &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cooker();
        ICook cook &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CookerProxy(cooker);
        cook.washFood();
        cook.cutFood();
        cook.stirFood();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;姐姐学会了妈妈的手艺，如果不是亲眼看到，还不知道是姐姐做的饭，这就是真实生活中一个简单的代理例子。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;强制代理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;普通代理是通过代理找到真实的对象，由真实对象去执行动作；但是强制代理却是要通过真实角色查找代理，否则不能访问。也就是不管是通过代理类还是直接new一个真实对象都不能访问，只有通过真实对象委托的代理才能访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还是上面的那个例子，后来妈妈上班去了，中午不能回家做饭了，拿普通代理方式来说，只要是一个会做菜的人，就可以趁着妈妈不在冒充妈妈的身份替妈妈做菜，万一做的很难吃，岂不是把妈妈的招牌给毁了吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是，妈妈想到了个办法，必须由她指定谁可以代替她做菜，不是由她亲自指定的人无法替她做菜：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181013105955982-429648037.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;定义了一个getProxy方法，由Cooker来指定自己的代理，并且代理自己做事之前，先验证下身份：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cooker &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICook {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICook cook;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; washFood() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isProxy()) {
            System.out.println(&lt;/span&gt;&quot;妈妈在洗菜……&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;请妈妈指定的人来炒菜……&quot;&lt;span&gt;);
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cutFood() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isProxy()) {
            System.out.println(&lt;/span&gt;&quot;妈妈在切菜……&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;请妈妈指定的人来炒菜……&quot;&lt;span&gt;);
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stirFood() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isProxy()) {
            System.out.println(&lt;/span&gt;&quot;妈妈在炒菜……&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            System.out.println(&lt;/span&gt;&quot;请妈妈指定的人来炒菜……&quot;&lt;span&gt;);
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ICook getProxy() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cook = &lt;span&gt;new&lt;/span&gt; CookerProxy(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cook;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Boolean isProxy() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.cook == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;只有通过Cooker对象获取（getProxy）代理才能做菜。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;代理扩展&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;姐姐做了几顿饭之后也开始不乐意了，凭什么我要占用玩的时间来给大家做饭？妈妈想了一个好主意，姐姐每做一顿饭可以从妈妈那里领到1块钱，于是姐姐又高高兴兴地给大家做饭了。做饭和付钱是两个单独的功能，是不能混在一起的，可以将上面类图稍作修改：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181013111900172-1299371844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样，在每次做好饭之后就可以记账应该拿到1元钱&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CookerProxy &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ICook, IPay {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ICook cooker;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CookerProxy(ICook cooker){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.cooker =&lt;span&gt; cooker;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; washFood() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cooker.washFood();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; cutFood() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cooker.cutFood();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stirFood() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.cooker.stirFood();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.pay();
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pay() {
        System.out.println(&lt;/span&gt;&quot;做完饭拿到了1元钱&quot;&lt;span&gt;);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ICook getProxy() {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 可以指定代理的代理，暂时没有就是自己 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;代理不仅可以实现主题的接口，还可以实现其他的接口，在目标行为基础之上做个性化处理。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;动态代理&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;后来姐姐长大了，也出门在外了，我们也不能每次都等着吃饭，于是各自都学会了做饭，只要妈妈不在，谁方便了谁就做饭。也就是说，只有饭已经在被做了才知道是谁在做，更灵活了，这就不能提前指定谁来做饭了。对应程序中是：只有在运行时才知道真实类型是谁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将类图稍作修改，如下所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1042079/201810/1042079-20181013152033287-1780461290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;InvocationHandler是java提供的动态代理接口，CookerHandler实现了&lt;span&gt;InvocationHandler&lt;/span&gt;接口，这样可以动态指定代理，运行时才知道类型。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CookerHandler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {
    Class clazz &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    Object obj &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CookerHandler(Object _obj) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.obj =&lt;span&gt; _obj;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        Object result &lt;/span&gt;= method.invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.obj, args);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;动态代理客户端使用示例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dynamicProxy(){
        proxy.dynamicproxy.ICook cook &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; proxy.dynamicproxy.Cooker();

        ClassLoader classLoader &lt;/span&gt;=&lt;span&gt; cook.getClass().getClassLoader();
        Class&lt;/span&gt;&amp;lt;?&amp;gt;[] interfaces =&lt;span&gt; cook.getClass().getInterfaces();
        CookerHandler handler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CookerHandler(cook);

        proxy.dynamicproxy.ICook proxyInstance &lt;/span&gt;=&lt;span&gt; (proxy.dynamicproxy.ICook) Proxy.newProxyInstance(classLoader, interfaces, handler);
        proxyInstance.washFood();
        proxyInstance.cutFood();
        proxyInstance.stirFood();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;动态代理可以参考：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/mr-yang-localhost/p/9244499.html&quot;&gt;Java动态代理之JDK实现和CGlib实现（简单易懂）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文示例代码：&lt;a href=&quot;https://github.com/yangyp8110/design-patterns/tree/master/src/main/java/proxy&quot; target=&quot;_blank&quot;&gt;Proxy Demo&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Oct 2018 15:17:00 +0000</pubDate>
<dc:creator>Mr.yang.localhost</dc:creator>
<og:description>定义 为其他对象提供一种代理以控制对这个对象的访问。 代理模式也叫委托模式，日常生活中很常见。帮别人做某某事情时候，自己就是别人的代理；让别人帮自己做什么事情时候，别人就是自己的代理。 通用类图 Su</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mr-yang-localhost/p/9746184.html</dc:identifier>
</item>
<item>
<title>【Mybtais】Mybatis 插件 Plugin开发（一）动态代理步步解析 - 年轻的老魏</title>
<link>http://www.cnblogs.com/oldwei/p/9784708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/oldwei/p/9784708.html</guid>
<description>&lt;h2&gt;需求：&lt;/h2&gt;
&lt;p&gt;　　对原有系统中的方法进行‘拦截’，在方法执行的前后添加新的处理逻辑。&lt;/p&gt;
&lt;h2&gt;分析：&lt;/h2&gt;
&lt;p&gt;　　不是办法的办法就是，对原有的每个方法进行修改，添加上新的逻辑；如果需要拦截的方法比较少，选择此方法到是会节省成本。但是面对成百上千的方法怎么办？此时需要用到动态代理来实现。&lt;/p&gt;
&lt;h2&gt;场景：&lt;/h2&gt;
&lt;p&gt;　　例如：对原有的系统添加日志记录、添加性能分析等等。。。&lt;/p&gt;
&lt;h2&gt;举例：&lt;/h2&gt;
&lt;p&gt;　　如下，需要对Sleep对象的sleep方法进行“拦截”,并在此方法的执行前后添加新的逻辑。想知道‘睡觉前干了什么？睡觉后干了什么？’&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Sleep {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sleep();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SleepImpl implements Sleep{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; sleep() {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我于&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd HH:mm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).format(&lt;span&gt;new&lt;/span&gt; Date())+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始睡觉&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建动态代理类，实现InvocationHandler接口即可。下面的wrap方法：传入要被代理的对象target。返回包装后的代理对象。$Proxy 打断点会看到这样的对象。针对下面的sleepProxy对象，sleepProxy.sleep()调用需要拦截的方法。实际上调用的是Plugin中的invoke方法。invoke方法中的method.invoke(target,args)是真是的调用被代理对象的sleep方法。所以直接在此语句的前后添加相应的逻辑即可满足需要。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Plugin implements InvocationHandler {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
    Plugin(Object target){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
    }    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;睡觉前做的事&lt;/span&gt;
        Object result =&lt;span&gt; method.invoke(target, args);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;睡觉后做的事&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object wrap(Object target){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Proxy.newProxyInstance(target.getClass().getClassLoader(), 
                target.getClass().getInterfaces(), 
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Plugin(target));
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;        //&lt;/span&gt;&lt;span&gt;要被代理的对象&lt;/span&gt;
        Sleep sleep = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SleepImpl();
&lt;/span&gt;&lt;span&gt;        //&lt;/span&gt;&lt;span&gt;代理对象&lt;/span&gt;
        Sleep sleepProxy =&lt;span&gt; (Sleep)Plugin.wrap(sleep);
        sleepProxy.sleep();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此，你以为就结束了？不 ，这个仅仅是 说了在睡觉 前后做了什么事，加入还想知道，你在睡觉前后吃了什么东西？当然睡觉后吃东西有点说不通。但 意会就可以了。还有其他巴拉巴拉的需求。你该怎么做?是不是要把所有的 新的逻辑都方法 Plugin中invoke方法中去？这样不合适吧！乱 乱 乱 这样。那咱们能不能抽象出来一个拦截接口，接口中有拦截后要做什么的方法。各种需求只需要实现这个拦截接口即可！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Interceptor {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interceptBefore()throws Exception;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interceptAfter()throws Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SleepBeforeAndAfter implements Interceptor {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interceptBefore() throws Exception {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;之前。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interceptAfter() throws Exception {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;之后。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后动态代理类Plugin需要修改&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 动态代理
 * 
 * @author 魏正迪
 * 2018年10月13日
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Plugin implements InvocationHandler {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Interceptor&amp;gt; iList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Interceptor&amp;gt;&lt;span&gt;();

    Plugin(Object target , List&lt;/span&gt;&amp;lt;Interceptor&amp;gt;&lt;span&gt; iList){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.iList =&lt;span&gt; iList;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Interceptor i :iList){
            i.interceptBefore();
        }
        Object result &lt;/span&gt;=&lt;span&gt; method.invoke(target, args);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Interceptor i :iList){
            i.interceptAfter();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object wrap(Object target,List&amp;lt;Interceptor&amp;gt;&lt;span&gt; iList){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Proxy.newProxyInstance(target.getClass().getClassLoader(), 
                target.getClass().getInterfaces(), 
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Plugin(target,iList)
                );
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Sleep sleep &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SleepImpl();
        List&lt;/span&gt;&amp;lt;Interceptor&amp;gt; iList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Interceptor&amp;gt;&lt;span&gt;();
        iList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SleepBeforeAndAfter());
        Sleep sleepProxy &lt;/span&gt;=&lt;span&gt; (Sleep)Plugin.wrap(sleep,iList);
        sleepProxy.sleep();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在想对每个对象的方法进行拦截，直接实现Interceptor接口即可！实现其中的两个方法。此时我们新加的逻辑和原有的逻辑并没有什么交集。假如我们想在interceptor中的两个方法中使用被代理对象的各种属性，此时该怎么做？首先想到是将interceptor接口的两个方法添加参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SleepBeforeAndAfter implements Interceptor {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interceptBefore(Object target, Method method, Object[] args)
            throws Exception {
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;之前。。。interceptBefore(Object target, Method method, Object[] args)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; interceptAfter(Object target, Method method, Object[] args)
            throws Exception {        
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;之后。。。interceptAfter(Object target, Method method, Object[] args)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此，个人感觉没啥问题了【大牛如发现明显不符的请指出】。但但但但是我们奔着简单明了、面向对象的思想（其实就是mybatis源码插件设计）。我们做出进一步的精简。于是Invocation对象产生了。看到Method对象传进来了。我们是不是可以想到，我们不再 在Plugin中的invoke方法中调用method.invoke(target,args);了，而是在Intercetpor中处理完前后逻辑后进行调用。这样分工明确了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 拦截对象的包装
 * @author 魏正迪
 * 2018年10月13日
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Invocation {
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object []args;
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Method method;
    
    Invocation(Object target,Method method,Object[] args){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.args =&lt;span&gt; args;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.method =&lt;span&gt; method;
        
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 执行拦截对象的对应的方法
     * @return
     * @throws Exception
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object process() throws Exception{
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; method.invoke(target, args);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时拦截器Interceptor应该是这样的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Interceptor {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object intercept(Invocation invocation)throws Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SleepBeforeAndAfter implements Interceptor {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object intercept(Invocation invocation) throws Exception{
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;拦截sleep方法要执行的方法之前&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Object result &lt;/span&gt;=&lt;span&gt; invocation.process();
        System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;拦截sleep方法要执行的方法之后&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时Plugin应该是这样的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Plugin implements InvocationHandler {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Interceptor interceptor;
    
    Plugin(Object target,Interceptor interceptor){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.interceptor =&lt;span&gt; interceptor;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object invoke(Object proxy, Method method, Object[] args)
            throws Throwable {        
        Invocation invocation &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Invocation(target,method,args);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; interceptor.intercept(invocation);
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object wrap(Object target,Interceptor interceptor){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Proxy.newProxyInstance(target.getClass().getClassLoader(), 
                target.getClass().getInterfaces(), 
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Plugin(target,interceptor)
                );
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Sleep sleep &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SleepImpl();
        SleepBeforeAndAfter s &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SleepBeforeAndAfter();
        Sleep sleepProxy1 &lt;/span&gt;=&lt;span&gt; (Sleep)Plugin.wrap(sleep,s);
        sleepProxy1.sleep();
        Sleep sleepProxy2 &lt;/span&gt;=&lt;span&gt; (Sleep)Plugin.wrap(sleepProxy1, s);
        sleepProxy2.sleep();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此，mybatis插件开发的引言完毕！其实是使用了动态代理和责任链结合的方式。&lt;/p&gt;


</description>
<pubDate>Sat, 13 Oct 2018 15:14:00 +0000</pubDate>
<dc:creator>年轻的老魏</dc:creator>
<og:description>需求： 对原有系统中的方法进行‘拦截’，在方法执行的前后添加新的处理逻辑。 分析： 不是办法的办法就是，对原有的每个方法进行修改，添加上新的逻辑；如果需要拦截的方法比较少，选择此方法到是会节省成本。但</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/oldwei/p/9784708.html</dc:identifier>
</item>
<item>
<title>【10.13】Bug Bounty Write-up 总结 - zoe宇</title>
<link>http://www.cnblogs.com/zz0eyu/p/9784423.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zz0eyu/p/9784423.html</guid>
<description>&lt;p&gt;今天惯例邮箱收到了Twitter的邮件提醒有新的post，这种邮件每天都能收到几封，正好看到一个Bug Bounty的write up，比较感兴趣，看起来也在我的理解范围之内，这里对这篇write up和另一篇一起做一个总结，希望能对自己对于web security的学习和bug bounty的路程有所帮助。&lt;/p&gt;
&lt;h2&gt;write-up 地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/bugbountywriteup/add-description-to-instagram-posts-on-behalf-of-other-users-6500-7d55b4a24c5a&quot;&gt;Add description to Instagram Posts on behalf of other users - 6500$&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@tbmnull/making-an-xss-triggered-by-csp-bypass-on-twitter-561f107be3e5&quot;&gt;Making an XSS triggered by CSP bypass on Twitter&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Instagram的漏洞&lt;/h2&gt;
&lt;p&gt;一开始&lt;a href=&quot;https://medium.com/@JubaBaghdad?source=post_header_lockup&quot;&gt;作者Sarmad Hassan (Juba Baghdad)&lt;/a&gt;本来想在facebook的页面绕开instagram的验证策略，但是在之后浏览Instgram的官网过程中，发现了&lt;span&gt;Instgram显示的一个新功能&lt;/span&gt;IGTV，您可以通过这个功能发布一个竖屏视频，也可以浏览其他人发布的IGTV视频。&lt;/p&gt;
&lt;p&gt;在测试这个新功能时，作者发现视频发布后，&lt;span&gt;点击编辑选项并通过butpsuite拦截发出的请求&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
POST /media/1887820989027383407/edit/

caption=test&amp;amp;publish_mode=igtv&amp;amp;title=test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上请求中，路径中的1887820989027383407是一个media ID，而&lt;span&gt;作者发现这个ID存在于在Instrgram发布的所有照片、普通视频和IGTV视频中&lt;/span&gt;，而你可以在这些照片或视频中添加可选的Description，IGTV的描述就对用于请求中的caption选项。&lt;/p&gt;
&lt;p&gt;所以如果把media ID换成其他人发布的内容的ID呢？&lt;/p&gt;
&lt;p&gt;首先是怎样找到media ID，作者发现有两种方式&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;查看发出内容的网页源码&lt;/li&gt;
&lt;li&gt;点击发出内容的like按钮，并拦截请求&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;之后的过程就很顺利了，只要其他人发布的内容中并没有添加描述，就可以通过这种方式进行修改。虽然修改media ID之后发出的请求返回了一个带有错误信息的响应，但是对应的其他人发布内容的description已经被改变了。&lt;/p&gt;
&lt;p&gt;从这一个漏洞中我可以学到&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;经常浏览关注网站的网页，查看是否有新的功能出现，这种新功能往往会存在漏洞&lt;/li&gt;
&lt;li&gt;在存在交互，有上传内容的地方，多拦截请求，查看请求中是否有值得注意的地方&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我觉得对于我自己来说，拦截请求这一块是很容易想到的，但更多可能会注意到其中的参数，而不是网址中的那个media ID，而且之后还要由此联想到去修改其他人发布的内容。&lt;/p&gt;
&lt;h2&gt;Twitter的XSS漏洞&lt;/h2&gt;
&lt;p&gt; 这个漏洞发现者&lt;a href=&quot;https://medium.com/@tbmnull?source=post_header_lockup&quot;&gt;tbmnull&lt;/a&gt;一开始就是在&lt;span&gt;挖掘Twitter的子域名&lt;/span&gt;，然后找到了这样一个可能存在xss的网址&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
https://careers.twitter.com/en/jobs-search.html?location=1&quot; onmouseover=”alert(1)&amp;amp;q=1&amp;amp;start=70&amp;amp;team=
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 但是由于&lt;span&gt;存在CSP&lt;/span&gt;，阻止了js代码的执行，弹窗无法弹出，所以关键在于怎样绕过CSP。&lt;/p&gt;
&lt;p&gt;作者花费了很多功夫找到了一个网址&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https://analytics.twitter.com/tpm?tpm_cb=
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请求该网址，&lt;span&gt;响应的Content-Type是application/javascript，而且参数tpm_cb会直接反射到页面上&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;所以作者把这两个发现结合到一起，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
https://careers.twitter.com/en/jobs-search.html?location=1&quot;&amp;gt;&amp;lt;script src=//analytics.twitter.com/tpm?tpm_cb=alert(document.domain)&amp;gt;//
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于两个网址同源，绕过了CSP对js脚本的限制，最终成功弹窗。&lt;/p&gt;
&lt;p&gt;这个漏洞的挖掘思路我个人觉得更符合一般漏洞挖掘的步骤，很多时间和精力+一点点运气，虽然作者在write-up中并没有多提，但是很显然这两个网址的发现是很不容易的。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从子域名开始的漏洞挖掘方法，是否可以写一个爬虫，对网站的子域名进行总结，以及对各种url进行分析，分离出参数&lt;/li&gt;
&lt;li&gt;提交的请求中，网页中原本无法编辑（只能通过列表选择）的位置，也可以通过拦截请求进行修改&lt;/li&gt;
&lt;li&gt;XSS为什么没有发挥作用？是否可以绕过？&lt;/li&gt;
&lt;li&gt;怎样绕过CSP——同源是关键&lt;/li&gt;
&lt;li&gt;漏洞的挖掘需要很耐心和仔细，不要着急&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;以上，是我今天看的两篇write-up，感觉学习web security还是要多看这种实例，才能对各种漏洞有更清晰的认识和理解，之后希望每天都有时间看一两篇write-up，加油！&lt;/p&gt;
</description>
<pubDate>Sat, 13 Oct 2018 14:47:00 +0000</pubDate>
<dc:creator>zoe宇</dc:creator>
<og:description>今天惯例邮箱收到了Twitter的邮件提醒有新的post，这种邮件每天都能收到几封，正好看到一个Bug Bounty的write up，比较感兴趣，看起来也在我的理解范围之内，这里对这篇write u</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zz0eyu/p/9784423.html</dc:identifier>
</item>
<item>
<title>总结学习机器学习过程中用到的数据学知识 - summer哥</title>
<link>http://www.cnblogs.com/airnew/p/9784528.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/airnew/p/9784528.html</guid>
<description>&lt;p&gt;现在机器学习行业持续加温，应届毕业生年薪持续走高，2019年毕业生算法岗年薪40万起，上不封顶，吸引着越来越多的人想往机器学习方向转。但是刚接触到算法时，看到那些数学公式都望而生畏，特别是公式的推导。今天本文就介绍机器学习会用到哪些数学知识，让那些想往机器学习方向转的同学心里有底，知道学习的方向。&lt;/p&gt;
&lt;p&gt;数学是机器学习的内功。作为机器学习的基石，数学知识无论如何是绕不开的，机器学习中大量的问题最终都可以归结为求解最优化问题，微积分、线性代数是最优化方法和理论的基础，很多机器学习算法的建模涉及到概率论，由此可见学好数学知识多么必要。不少准备或刚刚迈入机器学习的同学，在面临数学基础的学习时，会遇到两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不知道机器学习和深度学习到底要用到哪些数学知识&lt;/li&gt;
&lt;li&gt;无法真正理解这些数学知识，并用于机器学习的推导证明&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对此，Summer哥在本文中专门为大家解决这两个问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，在庞杂的数学系统内，哪些知识是在机器学习中真正有用的，对这些知识掌握到什么程度就足够了？&lt;/li&gt;
&lt;li&gt;其次，掌握了的数学知识怎么在机器学习领域内运用，即怎么从机器学习的角度去理解数学知识？&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;一机器学习所需要的数学知识&quot;&gt;一、机器学习所需要的数学知识&lt;/h5&gt;
&lt;p&gt;很多人对于机器学习中的数学知识，谈之色变，一想到实变函数、随机过程、泛函分析等等就不寒而栗。事实上，要理解和掌握绝大部分机器学习算法和理论，尤其是对做工程应用的人而言，真正所需要的数学知识不过尔尔，主要包括了：&lt;span&gt;微积分、线性代数、概率论、最优化方法&lt;/span&gt;&lt;br/&gt;下面我们来一一介绍一下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;微积分&lt;/span&gt;&lt;br/&gt;先说微积分/高等数学。在机器学习中，微积分主要用到了微分部分，作用是求函数的极值，就是很多机器学习库中的求解器（solver）所实现的功能。在机器学习里会用到微积分中的以下知识点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;导数和偏导数的定义与计算方法&lt;/li&gt;
&lt;li&gt;梯度向量的定义&lt;/li&gt;
&lt;li&gt;极值定理，可导函数在极值点处导数或梯度必须为0&lt;/li&gt;
&lt;li&gt;雅克比矩阵，这是向量到向量映射函数的偏导数构成的矩阵，在求导推导中会用到&lt;/li&gt;
&lt;li&gt;Hessian矩阵，这是2阶导数对多元函数的推广，与函数的极值有密切的联系&lt;/li&gt;
&lt;li&gt;凸函数的定义与判断方法&lt;br/&gt;泰勒展开公式&lt;/li&gt;
&lt;li&gt;拉格朗日乘数法，用于求解带等式约束的极值问题&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;相比之下，积分、无穷级数、常微分方程、偏微分方程等在机器学习和深度学习中使用的相对较少。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线性代数&lt;/span&gt;&lt;br/&gt;相比之下，线性代数用的更多。在机器学习的几乎所有地方都有使用，具体用到的知识点有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;向量和它的各种运算，包括加法，减法，数乘，转置，内积&lt;/li&gt;
&lt;li&gt;向量和矩阵的范数，L1范数和L2范数&lt;/li&gt;
&lt;li&gt;矩阵和它的各种运算，包括加法，减法，乘法，数乘&lt;/li&gt;
&lt;li&gt;逆矩阵的定义与性质&lt;/li&gt;
&lt;li&gt;行列式的定义与计算方法&lt;/li&gt;
&lt;li&gt;二次型的定义&lt;/li&gt;
&lt;li&gt;矩阵的正定性&lt;/li&gt;
&lt;li&gt;矩阵的特征值与特征向量&lt;/li&gt;
&lt;li&gt;矩阵的奇异值分解&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;机器学习算法处理的数据一般都是向量、矩阵或者张量。经典的机器学习算法输入的数据都是样本的特征向量，深度学习算法在处理图像时输入的2维的矩阵或者3维的张量。掌握这些知识会使你游刃有余。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;概率论&lt;/span&gt;&lt;br/&gt;如果把机器学习所处理的样本数据看作随机变量/向量，我们就可以用概率论的观点对问题进行建模，这代表了机器学习中很大一类方法。在机器学习里用到的概率论知识点有:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;随机事件的概念，概率的定义与计算方法&lt;/li&gt;
&lt;li&gt;随机变量与概率分布，尤其是连续型随机变量的概率密度函数和分布函数&lt;/li&gt;
&lt;li&gt;条件概率与贝叶斯公式&lt;/li&gt;
&lt;li&gt;常用的概率分布，包括正态分布，伯努利二项分布，均匀分布&lt;/li&gt;
&lt;li&gt;随机变量的均值与方差，协方差&lt;/li&gt;
&lt;li&gt;随机变量的独立性&lt;/li&gt;
&lt;li&gt;最大似然估计&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;最优化方法&lt;/span&gt;&lt;br/&gt;最后要说的是最优化，因为几乎所有机器学习算法归根到底都是在求解最优化问题。求解最优化问题的指导思想是在极值点出函数的导数/梯度必须为0。因此你必须理解梯度下降法，牛顿法这两种常用的算法，它们的迭代公式都可以从泰勒展开公式中得到。如果能知道坐标下降法、拟牛顿法就更好了。&lt;/p&gt;
&lt;p&gt;拉格朗日乘数法在机器学习中用的非常多，用于求解代等式约束的最优化问题，因此熟练的使用它是非常有必要的。&lt;/p&gt;
&lt;p&gt;凸优化是机器学习中经常会提及的一个概念，这是一类特殊的优化问题，它的优化变量的可行域是凸集，目标函数是凸函数。凸优化最好的性质是它的所有局部最优解就是全局最优解，因此求解时不会陷入局部最优解。如果一个问题被证明为是凸优化问题，基本上已经宣告此问题得到了解决。在机器学习中，线性回归、岭回归、支持向量机、logistic回归等很多算法求解的都是凸优化问题。&lt;/p&gt;
&lt;p&gt;拉格朗日对偶为带等式和不等式约束条件的优化问题构造拉格朗日函数，将其变为原问题，这两个问题是等价的。通过这一步变换，将带约束条件的问题转换成不带约束条件的问题。通过变换原始优化变量和拉格朗日乘子的优化次序，进一步将原问题转换为对偶问题，如果满足某种条件，原问题和对偶问题是等价的。这种方法的意义在于可以将一个不易于求解的问题转换成更容易求解的问题。在支持向量机中有拉格朗日对偶的应用。&lt;/p&gt;
&lt;p&gt;KKT条件是拉格朗日乘数法对带不等式约束问题的推广，它给出了带等式和不等式约束的优化问题在极值点处所必须满足的条件。在支持向量机中也有它的应用。&lt;/p&gt;
&lt;p&gt;看完这些，不少同学会安心不少，原来机器学习的数学基础知识大多已经学习过。除流形学习需要简单的微分几何概念之外，深层次的数学知识如实变函数，泛函分析等主要用在一些基础理论结果的证明上，即使不能看懂证明过程，也不影响我们使用具体的机器学习算法。概率图模型、流形学习中基于图的模型会用到图论的一些基本知识，如果学习过离散数学或者数据结构，这些概念很容易理解。&lt;/p&gt;
&lt;h5 id=&quot;二从机器学习的角度学习数学知识&quot;&gt;二、从机器学习的角度学习数学知识&lt;/h5&gt;
&lt;p&gt;不少同学对数学知识的掌握比较扎实，但是一转入机器学习中，就不知道从何下手应用。这就是缺乏了从机器学习的角度看待数学知识的素质。如何把数学知识运用到机器学习的算法中去呢？首先就是要熟知机器学习的算法和理论中对应着哪些数学知识？&lt;/p&gt;
&lt;p&gt;我们来看看典型算法和理论结论所用到的数学知识：&lt;img src=&quot;http://www.bigdata17.com/assets/images/jiqixuexishuxuezhishi.jpg&quot; title=&quot;机器学习数学知识&quot; alt=&quot;机器学习数学知识&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只有明白自己所学的数学知识可以应用到哪一块机器学习的算法或者理论中，才能更有针对的掌握对应的数学知识。另外无论是哪一门学问，都不是一蹴而就的，反反复复地去复习和运用知识，才能牢记掌握，机器学习中的数学知识也不例外。&lt;/p&gt;
</description>
<pubDate>Sat, 13 Oct 2018 14:26:00 +0000</pubDate>
<dc:creator>summer哥</dc:creator>
<og:description>现在机器学习行业持续加温，应届毕业生年薪持续走高，2019年毕业生算法岗年薪40万起，上不封顶，吸引着越来越多的人想往机器学习方向转。但是刚接触到算法时，看到那些数学公式都望而生畏，特别是公式的推导。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/airnew/p/9784528.html</dc:identifier>
</item>
<item>
<title>vue单页应用前进刷新后退不刷新方案探讨 - wonyun</title>
<link>http://www.cnblogs.com/wonyun/p/8763314.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wonyun/p/8763314.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;前端webapp应用为了追求类似于native模式的细致体验，总是在不断的在向native的体验靠拢；比如本文即将要说到的功能，native由于是多页应用，新页面可以启用一个的新的webview来打开，后退其实是关闭当前webview，其上一个webview就自然显示出来；但是在单页的webapp应用中，所有内容其实是在一个页面中展示的，不存在多页的情况，这时就需要前端开发来想办法实现相应的体验效果。&lt;/p&gt;
&lt;p&gt;首先需要说明一下，本文所说的前进刷新后退不刷新是指组件是否重新渲染，比如列表A页面，点击其中的每一项进入详情B页面，然后从B页面后退到列表A页面时，A页面没有重新渲染，也没有重新发送ajax请求。下面，我们就来说说在vue的单页应用中，实现前进刷新后退不刷新的一些实现方案，其他的方案大家可以一起补充。&lt;/p&gt;
&lt;h2 id=&quot;keep-alive方案&quot;&gt;keep-alive方案&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/api/#keep-alive&quot;&gt;keep-alive&lt;/a&gt;是vue官方提供的一种缓存组件实例的方法，vue官网对其用法的介绍：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;keep-alive&amp;gt;&lt;/code&gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正如vue官网的介绍，我们在开发中就可以使用他这一点来缓存后退不用刷新的路由组件。具体的实现思路如下。&lt;/p&gt;
&lt;h3 id=&quot;模板中使用keep-alive来缓存对应的路由组件&quot;&gt;1、模板中使用keep-alive来缓存对应的路由组件&lt;/h3&gt;
&lt;p&gt;在app.vue模板中改写&lt;code&gt;&amp;lt;router-view&amp;gt;&lt;/code&gt;，具体可以这样：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;keep-alive&amp;gt;
    &amp;lt;router-view v-if=&quot;$route.meta.keepAlive&quot;&amp;gt;
        &amp;lt;!-- 这里是会被缓存的视图组件，比如列表A页面 --&amp;gt;
    &amp;lt;/router-view&amp;gt;
&amp;lt;/keep-alive&amp;gt;

&amp;lt;router-view v-if=&quot;!$route.meta.keepAlive&quot;&amp;gt;
    &amp;lt;!-- 这里是不被缓存的视图组件，比如详情B页面--&amp;gt;
&amp;lt;/router-view&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式需要通过vue&lt;a href=&quot;https://router.vuejs.org/zh/guide/advanced/meta.html&quot;&gt;路由元信息&lt;/a&gt;的配合，当然也可以像下面这样：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;keep-alive include=&quot;A&quot;&amp;gt;
    &amp;lt;router-view&amp;gt;
        &amp;lt;!-- 只有路径匹配到的视图组件，如上面的列表A页面会被缓存！ --&amp;gt;
    &amp;lt;/router-view&amp;gt;
&amp;lt;/keep-alive&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式缺点是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;需要事先知道路由组件的**name**值，这在大型项目中不是一个特别好的选择。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在路由配置文件中配置路由元信息&quot;&gt;2、在路由配置文件中配置路由元信息&lt;/h3&gt;
&lt;p&gt;下面以第一种模板方式来展开介绍。对应上面模板文件中的路由元数据配置如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;routes: [{
        path: '/',
        name: 'home',
        component: Home,
        meta: {
            keepAlive: false //此组件不需要被缓存
        }
    },
    {
        path: '/list',
        name: 'list',
        component: List,
        meta: {
            keepAlive: true //此组件需要被缓存
        }
    },
    {
        path: '/detail',
        name: 'detail',
        component: Detail,
        meta: {
            keepAlive: false // 此组件需要被缓存
        }
    }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在keep-alive组件提供activated钩子函数实现数据更新逻辑&quot;&gt;3、在keep-alive组件提供&lt;code&gt;activated&lt;/code&gt;钩子函数实现数据更新逻辑&lt;/h3&gt;
&lt;p&gt;需要强调的是keep-alive组件（这里是指keep-alive包裹的路由组件，下同）与一个vue组件是有区别的，vue的具体生命周期函数可以参考&lt;a href=&quot;https://cn.vuejs.org/v2/guide/instance.html#%E5%AE%9E%E4%BE%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90&quot;&gt;这里&lt;/a&gt;；而&lt;code&gt;keep-alive&lt;/code&gt;组件，除了正常vue组件提供的生命周期之外，其额外新增了2个跟&lt;code&gt;keep-alive&lt;/code&gt;相关的钩子函数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;activated&lt;/strong&gt;： 缓存的组件再次进入时会触发&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;deactivated&lt;/strong&gt;： 缓存的组件离开时会触发&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;既然keep-alive组件提供了这么多生命周期函数钩子，那么这些钩子函数具体的执行顺序是怎样的呢？&lt;/p&gt;
&lt;p&gt;第一次进入keep-alive组件时，其生命周期执行顺序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;beforeRouteEnter --&amp;gt; created --&amp;gt; mounted --&amp;gt; activated --&amp;gt; deactivated&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;非首次进入时，其生命周期执行顺序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;beforeRouteEnter --&amp;gt;activated --&amp;gt; deactivated&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，非首次进入keep-alive组件时，正常的vue组件生命周期函数是不会在执行，而会执行keep-alive新增的两个周期钩子函数。同时也可以看出离开keep-alive组件时其destroy周期函数并没有执行，从侧面证明缓存组件并没有销毁。根据介绍，我们可以：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;通过利用keep-alive提供&lt;code&gt;activated&lt;/code&gt;钩子函数来决定是否进行ajax请求来更新组件，以及&lt;code&gt;deactivated&lt;/code&gt;钩子函数来重置页面相关状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;keep-alive实现后推不刷新的方案，有一些地方需要特别注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;keep-alive组件的更新时机要有清晰的认知&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;意思就是在开发过程中需要知道后退不刷新组件虽然不重新渲染，但是要知道组件数据在什么情况下需要重新发送ajax请求来获取数据，从而更新组件。&lt;/p&gt;
&lt;p&gt;就拿上面的A、B页面来说，我们需要知道列表A页面对应的keep-alive组件在什么时候进行更新，因为进入A页面的入口可以是从B页面后退而来，也可能从其他页面前进而来；当然需要对这两种不同情况需要加以区分，否则A页面的数据就一直是第一次缓存过的数据。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000012083511&quot;&gt;这篇文章&lt;/a&gt;给出了一种解决方案：&lt;/p&gt;
&lt;p&gt;首先，在每个路由元信息meta中添加一个isBack字段，用来解决beforeRouterEnter不能直接访问vue实例。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    ...
    {
        path: '/list',
        name: 'list',
        component: List,
        meta: {
            keepAlive: true, //此组件需要被缓存
            isBack: false
        }
    }
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，借助&lt;code&gt;beforeRouteEnter&lt;/code&gt;钩子函数来判断页面来源：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    beforeRouteEnter(to, from, next) {
      if(from.name === 'detail') { //判断是从哪个路由过来的，若是detail页面不需要刷新获取新数据，直接用之前缓存的数据即可
          to.meta.isBack = true;
      }
      next();
    },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，需要借助keep-alive提供钩子函数&lt;code&gt;activated&lt;/code&gt;来完成是否更新：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  activated() {
    if(!this.$route.meta.isBack) {
      // 如果isBack是false，表明需要获取新数据，否则就不再请求，直接使用缓存的数据
      this.getData(); // ajax获取数据方法
    }
    // 恢复成默认的false，避免isBack一直是true，导致下次无法获取数据
    this.$route.meta.isBack = false
  },&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在&lt;strong&gt;keep-alive组件前进的页面刷新导致keep-alive组件状态丢失&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;继续以上面的A、B页面为例，在进入详情B页面后，然后刷新，这时列表A页面的缓存的数据都丢失了，由于上面的判断规则也会导致不会重新获取数据。所以对于这种问题，还需要额外加一些判断条件。由于keep-alive第一次进入时会执行&lt;strong&gt;created&lt;/strong&gt;方法，所以利用这点加一个标识来加以判断：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;   //第一次进入keep-alive路由组件时
    created() {
      this.isFirstEnter = true;
     // 只有第一次进入或者刷新页面后才会执行此钩子函数，使用keep-alive后（2+次）进入不会再执行此钩子函数
   },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;activated钩子函数也需要增加对应的判断：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  activated() {
     if(!this.$route.meta.isBack || this.isFirstEnter){
         // 如果isBack是false，表明需要获取新数据，否则就不再请求，直接使用缓存的数据
         // 如果isFirstEnter是true，表明是第一次进入此页面或用户刷新了页面，需获取新数据
         this.data = ''// 把数据清空，可以稍微避免让用户看到之前缓存的数据
         this.getData();
     }
     // 恢复成默认的false，避免isBack一直是true，导致下次无法获取数据
     this.$route.meta.isBack=false
     // 恢复成默认的false，避免isBack一直是true，导致每次都获取新数据
     this.isFirstEnter=false;
   },&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;缓存过多keep-alive组件，因常驻内存会导致内存占用过多&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这是一个特别需要注意的问题，尤其是当整个系统或者系统大部分页面都使用keep-alive来缓存组件时，由于其是缓存在内存中的，若不加处理，内存堆积越来越大，导致系统卡顿。正确的解决方案是：&lt;strong&gt;需要及时销毁掉内存缓存的组件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;具体可以参考：&lt;a href=&quot;https://github.com/vuejs/vue/issues/6509#issuecomment-403693256&quot;&gt;vue issue#6509&lt;/a&gt;和&lt;a href=&quot;https://www.jianshu.com/p/cd1baf5b03b0&quot;&gt;记一次vue 的keep-alive踩坑之路&lt;/a&gt;两篇文章的实现思路。&lt;/p&gt;
&lt;h2 id=&quot;嵌套路由&quot;&gt;嵌套路由&lt;/h2&gt;
&lt;p&gt;嵌套路由具体的实现可以参考&lt;a href=&quot;https://router.vuejs.org/zh/guide/essentials/nested-routes.html&quot;&gt;官网&lt;/a&gt;，这种方案也是一种解决思路。下面以一个具体的例子（如下图所示）来说一下实现的具体过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/408483/201810/408483-20181013201453877-1961456778.png&quot; width=&quot;250&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;正如上图所示，一个下单页面有6处跳出当前页面查看规则、协议或者修改具体某些内容的页面，因为这6项依赖这个订单页，那么可以使用路由嵌套来实现这种后退不刷新的过程，下单页作为父路由，其他跳转项可以作为其子路由。具体步骤：&lt;/p&gt;
&lt;h3 id=&quot;配置路由信息&quot;&gt;1、配置路由信息&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    {
      path: '/order',
      component: Order,
      children: [
        {
          path: 'invoice',
          component: Invoice
        }, {
          path: 'contact',
          component: Contact
        },
        {
          path: 'costrule',
          component: CostRule
        }, {
          path: 'refundrule',
          component: RefundRule
        },{
          path: 'useragreement',
          component: UserAgreement
        },{
          path: 'payrule',
          component: PayRule
        }
      ]
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在下单页order组件模板中配置路由嵌套&quot;&gt;2、在下单页&lt;strong&gt;Order&lt;/strong&gt;组件模板中配置路由嵌套。&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    &amp;lt;div class=&quot;safe-area-pb&quot;&amp;gt;
     &amp;lt;purchase /&amp;gt;
     &amp;lt;router-view /&amp;gt;    
    &amp;lt;/div&amp;gt;                  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，通过下单页进入其他页面比如进入修改联系人信息页面，那么路由从&lt;strong&gt;/order&lt;/strong&gt;进入到&lt;strong&gt;/order/contact&lt;/strong&gt;，修改完成后回退会回到父路由&lt;strong&gt;/order&lt;/strong&gt;中，完成后推不刷新的功能。&lt;/p&gt;
&lt;p&gt;当然，正如上面所说的，嵌套路由方案只是一种可选择方案，有其对应的使用场景；另外，使用过程还需要注意以下几点：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;**1、进入子路由后，若是在子路由强制刷新后，父子路由的组件都会重新渲染，执行各自路由组件的生命周期；父路由中设置相关逻辑都会执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;**2、子路由若被其他页面共用，这时进入子路由时会触发第一点的情况，所以最好子路由是父路由独占的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;component组件配合路由方案&quot;&gt;component组件配合路由方案&lt;/h2&gt;
&lt;p&gt;这种方案主要是利用vue提供的动态路由组件&lt;a href=&quot;https://cn.vuejs.org/v2/guide/components.html#%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6&quot;&gt;component&lt;/a&gt;来实现，页面组件的切换不再根据路由path来决定，而是根据不同的业务逻辑加载不同的动态组件。具体的实现可以参考这篇文章解决方案第6点部分：&lt;a href=&quot;https://github.com/DDFE/DDFE-blog/issues/13&quot;&gt;异步加载的业务线如何动态注册路由？&lt;/a&gt;。同样，同步路由也可以使用动态路由来完成对应后退不刷新功能。这不过这种方式的使用场景更急局限。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;上面提供的3种解决方案，第一种方案大家都比较熟悉，后面两种可能相对来说就比较陌生。它们只是解决同一问题的不同解决方案，想必还有其他的解决方案本人没有想到，有其他更好方案的可以一起探讨。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;1、&lt;a href=&quot;https://github.com/DDFE/DDFE-blog/issues/13&quot;&gt;滴滴 webapp 5.0 Vue 2.0 重构经验分享&lt;/a&gt;&lt;br/&gt;2、&lt;a href=&quot;https://segmentfault.com/a/1190000012083511&quot;&gt;另辟蹊径：vue单页面，多路由，前进刷新，后退不刷新&lt;/a&gt;&lt;br/&gt;3、&lt;a href=&quot;https://www.jianshu.com/p/0b0222954483&quot;&gt;vue-router 之 keep-alive&lt;/a&gt;&lt;br/&gt;4、&lt;a href=&quot;https://www.jianshu.com/p/cd1baf5b03b0&quot;&gt;记一次vue 的keep-alive踩坑之路&lt;/a&gt;&lt;br/&gt;5、&lt;a href=&quot;https://github.com/vuejs/vue/issues/6509&quot;&gt;希望keep-alive能增加可以动态删除已缓存组件的功能&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Oct 2018 14:22:00 +0000</pubDate>
<dc:creator>wonyun</dc:creator>
<og:description>引言 前端webapp应用为了追求类似于native模式的细致体验，总是在不断的在向native的体验靠拢；比如本文即将要说到的功能，native由于是多页应用，新页面可以启用一个的新的webview</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wonyun/p/8763314.html</dc:identifier>
</item>
<item>
<title>可能是全网首个支持阿里云Elasticsearch Xapck鉴权的Skywalking - 李国宝</title>
<link>http://www.cnblogs.com/liguobao/p/9784486.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liguobao/p/9784486.html</guid>
<description>&lt;p&gt;对Skywalking有兴趣的同学参见:&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45084693&quot;&gt;年轻人的第一个APM-Skywalking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前在搭建Skywalking的时候发现,官方Skywalking 5.X并支持有鉴权的Elasticsearch.&lt;/p&gt;
&lt;p&gt;而我司有其他需求已经购买了阿里云的Elasticsearch,咨询过阿里云技术支持后他们表示并不能去掉鉴权,所以只好自己想办法了.&lt;/p&gt;
&lt;p&gt;又在Skywalking技术群问了一圈,有其他人也遇到过类似的问题,但是最后还是选择自建ES了.&lt;/p&gt;
&lt;p&gt;实在不想自己再浪费精力去搭建ES了,还是觉得可以尝试一下别的方案.&lt;/p&gt;
&lt;p&gt;然后咨询了一下wusheng大大之后,他说可以自己尝试换一个支持XPack鉴权的Client,应该没什么太大的问题.&lt;/p&gt;
&lt;p&gt;于是就开始了&quot;填坑&quot;之旅.&lt;/p&gt;
&lt;h2 id=&quot;首先是引入x-pack-transport支持&quot;&gt;首先是引入x-pack-transport支持&lt;/h2&gt;
&lt;p&gt;apm-collector/apm-collector-component/client-component/pom.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.elasticsearch.client&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;x-pack-transport&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${elasticsearch.client.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;repositories&amp;gt;
        &amp;lt;repository&amp;gt;
            &amp;lt;id&amp;gt;elasticsearch-releases&amp;lt;/id&amp;gt;
            &amp;lt;url&amp;gt;https://artifacts.elastic.co/maven&amp;lt;/url&amp;gt;
            &amp;lt;releases&amp;gt;
                &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
            &amp;lt;/releases&amp;gt;
            &amp;lt;snapshots&amp;gt;
                &amp;lt;enabled&amp;gt;false&amp;lt;/enabled&amp;gt;
            &amp;lt;/snapshots&amp;gt;
        &amp;lt;/repository&amp;gt;
    &amp;lt;/repositories&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着在 ...in/java/org/apache/skywalking/apm/collector/client/elasticsearch/ElasticSearchClient.java&lt;/p&gt;
&lt;p&gt;加入PreBuiltXPackTransportClient的初始化&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
 private final String securityUser;


 private PreBuiltXPackTransportClient initXPackClient() {
        Settings settings = Settings.builder()
                .put(&quot;cluster.name&quot;, clusterName)
                .put(&quot;xpack.security.transport.ssl.enabled&quot;, false)
                .put(&quot;xpack.security.user&quot;, securityUser)
                .put(&quot;client.transport.sniff&quot;, false).build();
        return new PreBuiltXPackTransportClient(settings);
     }
     private PreBuiltTransportClient initClient() {
        Settings settings = Settings.builder()          Settings settings = Settings.builder()
            .put(&quot;cluster.name&quot;, clusterName)                   .put(&quot;cluster.name&quot;, clusterName)
            .put(&quot;client.transport.sniff&quot;, clusterTransportSniffer)                 .put(&quot;client.transport.sniff&quot;, clusterTransportSniffer)
            .build();                   .build();
        return new PreBuiltTransportClient(settings);
    }

     // 新增 private final String securityUser;
    // 判断这个变量是不是null或者空字符串,如果是就默认初始化,不是则使用initXPackClient初始化
    // 改一下initialize 方法

    private final String securityUser;


     @Override
    public void initialize() throws ClientException {
        if (securityUser == null || &quot;&quot;.equals(securityUser)) {
            client = initClient();
        } else {
            client = initXPackClient();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后还要把apm-collector/pom.xml的elasticsearch.client.version 版本改成5.3.3.&lt;/p&gt;
&lt;p&gt;改完之后因为5.3.3和原来5.5.0有点不一样,需要修改一下很几个地方的代码.&lt;/p&gt;
&lt;p&gt;这时候建议直接使用IDEA build 一下,哪里报错改哪里就好.&lt;/p&gt;
&lt;p&gt;主要都是 searchResponse.getHits().totalHits 改成searchResponse.getHits().totalHits()&lt;/p&gt;
&lt;p&gt;神奇发现5.5.0版本的ES Client把5.3.3的searchResponse.getHits().totalHits() 方法改成了属性.&lt;/p&gt;
&lt;p&gt;不经感慨都是人才啊...&lt;/p&gt;
&lt;p&gt;别的一些基本都是引入 import org.elasticsearch.action.bulk.byscroll.BulkByScrollResponse;&lt;/p&gt;
&lt;p&gt;全部代码在这里:&lt;a href=&quot;https://github.com/liguobao/incubator-skywalking/commit/ae3d43bc7a65a1b955e6bdf75a2356c8ecf53f28&quot;&gt;liguobao/incubator-skywalking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;完整改好的代码在&lt;a href=&quot;https://github.com/liguobao/incubator-skywalking/commit/ae3d43bc7a65a1b955e6bdf75a2356c8ecf53f28&quot;&gt;liguobao/incubator-skywalking&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;同时配置的时候添加一下 securityUser参数,如果ES有鉴权就传入,没有的话就不传,这样就达到鉴权和不鉴权两种需求的兼容了.&lt;/p&gt;
&lt;h2 id=&quot;支持xpack的docker部署方案&quot;&gt;支持xpack的docker部署方案&lt;/h2&gt;
&lt;p&gt;完整原文链接:&lt;a href=&quot;https://github.com/liguobao/skywalking-docker/tree/master/5.x/standalone/all-in-one-xpack&quot;&gt;Skywalking-Dcoker for ES xpack 镜像&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/r/liguobao/skywalking-docker/&quot;&gt;&lt;img src=&quot;https://img.shields.io/docker/build/liguobao/skywalking-docker.svg&quot; alt=&quot;Docker Build Status&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://hub.docker.com/r/liguobao/skywalking-docker/&quot;&gt;&lt;img src=&quot;https://img.shields.io/docker/pulls/liguobao/skywalking-docker.svg&quot; alt=&quot;Docker Pulls&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;dockerfile说明&quot;&gt;Dockerfile说明&lt;/h2&gt;
&lt;p&gt;apache-skywalking-apm-incubating.tar.gz为支持ES X-Pack修改后打包出来的压缩包,此仓库没有这个文件的.&lt;/p&gt;
&lt;p&gt;可以去QQ群:Apache SkyWalking交流群(392443393)群文件中下载apache-skywalking-apm-incubating-xpack.tar.gz&lt;/p&gt;
&lt;p&gt;或者自行编译&lt;a href=&quot;https://github.com/liguobao/incubator-skywalking/tree/5.x&quot;&gt;liguobao/incubator-skywalking/tree/5.x&lt;/a&gt; 此版本的源码.&lt;/p&gt;
&lt;p&gt;编译步骤:&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;# Prepare git, JDK8 and maven3
git clone https://github.com/liguobao/incubator-skywalking.git
cd incubator-skywalking/
git checkout 5.x
#Switch to the tag by using git checkout [tagname] (Optional, switch if want to build a release from source codes)
git submodule init
git submodule update
Run ./mvnw clean package -DskipTests
#All packages are in /dist.(.tar.gz for Linux and .zip for Windows).&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Docker 镜像名称:&lt;a href=&quot;https://hub.docker.com/r/liguobao/skywalking-docker/&quot;&gt;liguobao/skywalking-docker&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;拉取镜像pull-image&quot;&gt;拉取镜像（Pull Image）:&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;docker pull liguobao/skywalking-docker:5.0.RC2.xpack&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;运行镜像runfor-es-xpack&quot;&gt;运行镜像（Run）for ES xpack:&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;docker run -p 8080:8080 -p 10800:10800 -p 11800:11800 -p 12800:12800 -e ES_CLUSTER_NAME=elasticsearch -e ES_ADDRESSES=192.168.2.96:9300 -e SECURITY_USER='elastic:password' -d liguobao/skywalking-docker:5.0.RC2.xpack&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用浏览器访问&lt;code&gt;http://localhost:8080&lt;/code&gt;即可.&lt;/li&gt;
&lt;li&gt;日志挂载 &lt;code&gt;-v /your/log/path:/apache-skywalking-apm-incubating/logs&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;环境变量environment-variables&quot;&gt;环境变量（Environment Variables）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ES_CLUSTER_NAME&lt;/code&gt;,&lt;code&gt;ES_ADDRESSES&lt;/code&gt;:elasticsearch 地址和集群名称。注意：此处Elasticsearch地址中的端口务必是Elasticsearch TCP端口。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SECURITY_USER&lt;/code&gt;,&lt;code&gt;SECURITY_USER&lt;/code&gt;:elasticsearch 的账号密码,使用X-Pack实现的,常见阿里云ES,格式为:'user:password'.此参数不传入或者传入'' ,默认使用没有授权的client.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NAMING_BIND_HOST&lt;/code&gt;,&lt;code&gt;NAMING_BIND_PORT&lt;/code&gt;:OS real network IP(binding required),for agent to find collector cluster.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BIND_HOST&lt;/code&gt;,&lt;code&gt;REMOTE_BIND_PORT&lt;/code&gt;:OS real network IP(binding required),for collector nodes communicate with each other in cluster. collectorN --(gRPC) --&amp;gt; collectorM&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AGENT_GRPC_BIND_PORT&lt;/code&gt;:OS real network IP(binding required),for agent to uplink data(trace/metrics) to collector. agent--(gRPC)--&amp;gt; collector&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AGENT_JETTY_BIND_HOST&lt;/code&gt;,&lt;code&gt;AGENT_JETTY_BIND_PORT&lt;/code&gt;:OS real network IP(binding required), for agent to uplink data(trace/metrics) to collector through HTTP. agent--(HTTP)--&amp;gt; collector&lt;br/&gt;-&lt;code&gt;UI_JETTY_BIND_HOST&lt;/code&gt;,&lt;code&gt;UI_JETTY_BIND_PORT&lt;/code&gt;:Stay in &lt;code&gt;0.0.0.0&lt;/code&gt; if UI starts up in default mode.Change it to OS real network IP(binding required), if deploy collector in different machine.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;与elasticsearch-shanghai-zone镜像配合使用请参考&quot;&gt;与elasticsearch-shanghai-zone镜像配合使用请参考&lt;/h2&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;本来还打算把代码提给主仓库的,但是wusheng 大大说xpack客户端和Apache要求的授权有冲突,遂...&lt;/p&gt;
&lt;p&gt;那就留着自己玩了.&lt;/p&gt;
&lt;p&gt;拜...&lt;/p&gt;
</description>
<pubDate>Sat, 13 Oct 2018 14:17:00 +0000</pubDate>
<dc:creator>李国宝</dc:creator>
<og:description>可能是全网首个支持阿里云Elasticsearch Xapck鉴权的Skywalking 对Skywalking有兴趣的同学参见:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liguobao/p/9784486.html</dc:identifier>
</item>
<item>
<title>小橙书阅读指南（十二）——无向图、深度优先搜索和路径查找算法 - 冷豪</title>
<link>http://www.cnblogs.com/learnhow/p/9784144.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learnhow/p/9784144.html</guid>
<description>&lt;p&gt;在计算机应用中，我们把一系列相连接的节点组成的数据结构，叫做图。今天我们将要介绍它的一种形式——无向图，以及针对这种结构的深度优先搜索和路径查找算法。&lt;/p&gt;
&lt;p&gt;一、无向图数据结构&lt;/p&gt;
&lt;p&gt;接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 图论接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Graph {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 顶点数
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; vertexNum();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 边数
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; edgeNum();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 向图中添加一条v-w的边
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; v
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; w
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; addEdge(&lt;span&gt;int&lt;/span&gt; v, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; w);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 和v相邻的所有顶点
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; v
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Iterable&lt;/span&gt;&amp;lt;Integer&amp;gt; adjoin(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * v的维度
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; v
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; degree(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Graph &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; algorithms.graphs.ifs.Graph {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; vertex; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 顶点&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; edge; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 边&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;&lt;span&gt;[] adj;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Graph(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.vertex =&lt;span&gt; v;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.edge = 0&lt;span&gt;;
        adj &lt;/span&gt;= (ArrayList&amp;lt;Integer&amp;gt;[]) &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList[v];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; v; i++&lt;span&gt;) {
            adj[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; vertexNum() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; vertex;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; edgeNum() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; edge;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; addEdge(&lt;span&gt;int&lt;/span&gt; v, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; w) {
        validateVertex(v);
        validateVertex(w);
        adj[v].add(w);
        adj[w].add(v);
        edge&lt;/span&gt;++&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Iterable&amp;lt;Integer&amp;gt; adjoin(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; adj[v];
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; degree(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; adj[v].size();
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; validateVertex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (v &amp;lt; 0 || v &amp;gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.vertex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、深度搜索优先算法&lt;/p&gt;
&lt;p&gt;对于图的处理我们常常通过系统地检查每一个顶点和每一条边来获取图的各种性质。对于图的问题我们最经常被问及的是：&lt;strong&gt;a点和b点连通吗？如果连通如何到达？&lt;/strong&gt;为了描述方便，我们使用自然数描述图的每一个顶点。&lt;/p&gt;
&lt;p&gt;假设有以下图的结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/871676/201810/871676-20181013183814450-275703380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 左侧数组表示节点，右侧代表与节点连接的其他节点。该结构的标准画法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/871676/201810/871676-20181013202326570-1919491154.png&quot; alt=&quot;&quot; width=&quot;371&quot; height=&quot;279&quot;/&gt;&lt;/p&gt;
&lt;p&gt;算法描述：深度优先搜索从起点出发（0）遍历（2，1，5）并递归（2）与它链接的点，被搜索到的点将不会被再次递归直到所有的点都被搜索到为止。&lt;/p&gt;
&lt;p&gt;深度优先搜索接口与实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接口&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Search {
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; marked(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v);
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; count();
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 图论：深度优先搜索
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DepthFirstSearch &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Search {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;[] marked;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DepthFirstSearch(Graph g, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; s) {
        marked &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;[g.vertexNum()];
        validateVertex(s);
        dfs(g, s);
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 以递归的方式从s起点出发，标记每一个经过的顶点，未被标记的顶点为不连通
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; g
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; v
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; dfs(Graph g, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; v) {
        marked[v] &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        count&lt;/span&gt;++&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; x : g.adjoin(v)) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;marked[x]) {
                dfs(g, x);
            }
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; marked(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v) {
        validateVertex(v);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; marked[v];
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; throw an IllegalArgumentException unless {@code 0 &amp;lt;= vertexNum &amp;lt; V}&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; validateVertex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; v) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; V =&lt;span&gt; marked.length;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (v &amp;lt; 0 || v &amp;gt;=&lt;span&gt; V)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalArgumentException();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这套算法的核心是dfs函数。我们要理解深度优先算法就必须弄清楚算法递归的过程。marked数组记录节点的访问情况，变量x和v的递归过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/871676/201810/871676-20181013203705440-987291460.png&quot; alt=&quot;&quot; width=&quot;82&quot; height=&quot;302&quot;/&gt;&lt;/p&gt;
&lt;p&gt;标准画法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/871676/201810/871676-20181013204127040-566850997.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 深度优先算法按照上面的路径搜索图，由此我们可以获知深度搜索算法的两个特征：&lt;/p&gt;
&lt;p&gt;1.搜索路径沿一条路径向下扩展，每一个节点只会被遍历一次（每一个节点都可以知道在搜索路径上的上一个节点，并唯一确定）。&lt;/p&gt;
&lt;p&gt;2.搜索路径上的任意两点代表可达，但并非最短路径。&lt;/p&gt;
&lt;p&gt;这样我们就可以回答本文最早提出的有关图的第一个问题：&lt;strong&gt;a点和b点连通吗？&lt;/strong&gt;显然，以a为起点搜索整个图，如果b点在路径上则表示连通。&lt;/p&gt;
&lt;p&gt;三、使用深度优先搜索的路径算法&lt;/p&gt;
&lt;p&gt;要回答有关图的第二个问题：&lt;strong&gt;如果连通如何到达？&lt;/strong&gt;回忆上一段我们总结的深度搜索算法的第一个特征，我们可以使用数组结构在存储每一个节点的上一个节点。&lt;/p&gt;
&lt;p&gt;路径搜索接口和实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 寻找路径
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Paths {
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; hasPathTo(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; vertex);

    Iterable&lt;/span&gt;&amp;lt;Integer&amp;gt; pathTo(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; vertex);
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 基于深度优先搜索的路径搜索算法
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DepthFirstPaths &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Paths {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; s;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;[] marked;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] edgeTo;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DepthFirstPaths(Graph g, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; s) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.s =&lt;span&gt; s;
        marked &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;[g.vertexNum()];
        edgeTo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[g.vertexNum()];
        dfs(g, s);
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; dfs(Graph g, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; v) {
        marked[v] &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;&lt;span&gt; w : g.adjoin(v)) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;marked[w]) {
                edgeTo[w] &lt;/span&gt;=&lt;span&gt; v;
                dfs(g, w);
            }
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; hasPathTo(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; vertex) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; marked[vertex];
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Iterable&amp;lt;Integer&amp;gt; pathTo(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; vertex) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;hasPathTo(vertex)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        Stack&lt;/span&gt;&amp;lt;Integer&amp;gt; path = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = vertex; i != s; i =&lt;span&gt; edgeTo[i]) {
            path.push(i);
        }
        path.push(s);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; path;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 算法的标准画法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/871676/201810/871676-20181013205539319-1296289935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相关链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/learnhow/Algorithms-for-Java&quot; target=&quot;_blank&quot;&gt;Algorithms for Java&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Oct 2018 13:01:00 +0000</pubDate>
<dc:creator>冷豪</dc:creator>
<og:description>在计算机应用中，我们把一系列相连接的节点组成的数据结构，叫做图。今天我们将要介绍它的一种形式——无向图，以及针对这种结构的深度优先搜索和路径查找算法。 一、无向图数据结构 接口： 实现类： 二、深度搜</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/learnhow/p/9784144.html</dc:identifier>
</item>
</channel>
</rss>