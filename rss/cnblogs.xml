<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Druid时序数据库常见问题及处理方式 - 影魂的漫漫人生路</title>
<link>http://www.cnblogs.com/yinghun/p/9224701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yinghun/p/9224701.html</guid>
<description>&lt;p&gt;&amp;#13;
                                    &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;×&lt;/span&gt;&lt;span class=&quot;sr-only&quot;&gt;Close&lt;/span&gt;&lt;/button&gt;&amp;#13;
                                    &lt;h4 class=&quot;modal-title&quot;&gt;&amp;#13;
                                        请完成人机识别验证&amp;#13;
                                    &lt;/h4&gt;&amp;#13;
                                &lt;/p&gt;
                                &lt;div class=&quot;modal-body&quot; readability=&quot;33&quot;&gt;
                                    
                                    &lt;p&gt;&amp;#13;
                                        &lt;span id=&quot;geetestLoading&quot;&gt; 验证码组件加载中,请稍后...&lt;/span&gt;&amp;#13;
                                    &lt;/p&gt;
                                &lt;/div&gt;
                            </description>
<pubDate>Mon, 25 Jun 2018 07:59:00 +0000</pubDate>
<dc:creator>影魂的漫漫人生路</dc:creator>
<dc:format>text/html</dc:format>
<dc:identifier>https://passport.cnblogs.com/user/signin?ReturnUrl=http%3A%2F%2Fwww.cnblogs.com%2Fyinghun%2Fp%2F9224701.html&amp;AspxAutoDetectCookieSupport=1</dc:identifier>
</item>
<item>
<title>Python/Django 下载Excel2007 - ITACHl</title>
<link>http://www.cnblogs.com/julygift/p/9224499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/julygift/p/9224499.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、前提&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　上一篇，我写了下载Excel2003的博文，这里写下载Excel2007的博文的原因有三：&lt;/p&gt;
&lt;p&gt;　　　　第一、Excel2003基本已经淘汰了&lt;/p&gt;
&lt;p&gt;　　　　第二、Excel2003下载文件太大，不利于网络传输&lt;/p&gt;
&lt;p&gt;　　　　第三、xlwt这个库有个Bug，就是它不支持单元格字符串长度超过32767【这里，有兴趣的同学可以查看下源码】&lt;/p&gt;
&lt;p&gt;　　好了，废话不多说了，我们进入正题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、安装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　本文使用的是pandas，引入库的方式：pip install pandas&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、使用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　首先、引入该库，例如：&lt;strong&gt;&lt;span&gt;import pandas&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　其次、&lt;/p&gt;
&lt;p&gt;　　　　创建Excel文档：&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;&lt;span&gt;out = BytesIO()&lt;/span&gt;&lt;/strong&gt;　　创建的输出流&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;&lt;span&gt;excel = pandas.ExcelWriter(out, engine = 'xlsxwriter') &lt;/span&gt;&lt;/strong&gt; 这里使用xlsxwriter引擎创建, 创建的文件直接关联到输出流out，安装xlsxwriter也很简单，如： pip install xlsxwriter&lt;/p&gt;
&lt;p&gt;　　　　创建Sheet：&lt;/p&gt;
&lt;p&gt;　　　　　　summary_df = pandas.DataFrame(&lt;strong&gt;&lt;span&gt;{}&lt;/span&gt;&lt;/strong&gt;)　　这里使用空对象创建，下面代码生成的sheet会是一个空sheet&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;strong&gt;&lt;span&gt;summary_df.to_excel(excel, sheet_name = &quot;Summary&quot;, index = False, header = False)&lt;/span&gt;&lt;/strong&gt;　　这里会在excel中创建一个sheet名称为Summary的文档，index=False，使得Excel不会咋第一列创建序号列，xlsxwriter默认会在第一列创建序号列。这里的参数具体用法请参考相关文档。&lt;/p&gt;
&lt;p&gt;　　　　获取sheet：&lt;strong&gt;&lt;span&gt;worksheet = excel.sheets[&quot;Summary&quot;]&lt;/span&gt;&lt;/strong&gt;　　获取sheet名称为summary的sheet名&lt;/p&gt;
&lt;p&gt;　　　　设置列宽：&lt;strong&gt;&lt;span&gt;worksheet.set_column('D:D', 18, long_text_format)&lt;/span&gt;&lt;/strong&gt;　　设置第四列宽度为18，使用样式long_text_format【这个样式需要自己提前定义】&lt;/p&gt;
&lt;p&gt;　　　　保存Excel：&lt;strong&gt;&lt;span&gt;excel.save()&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　Excel文件会直接输出上面创建的输出流out。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;第四、输出&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
response = HttpResponse(out.getvalue(), content_type = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;application/vnd.ms-excel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    dt &lt;/span&gt;=&lt;span&gt; datetime.datetime.now()
    response[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Disposition&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;attachment;filename={} {}.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(urlquote(domain_name), dt.strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y-%m-%d %H-%M-%S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;End downloading...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; response
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;贴下源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;91&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; download_report(request, task_id, domain_name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;全部&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start downloading xlsx...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, task_id)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start downloading...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, domain_name)

    domains &lt;/span&gt;= [{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;domain_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: domain_name}]
    ai_task &lt;/span&gt;= AITask.objects.get(id =&lt;span&gt; task_id)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; domain_name == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;全部&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; 1 ==&lt;span&gt; ai_task.type:
            domains &lt;/span&gt;= Classification.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;domain_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).distinct().filter(type = 1).order_by(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;domain_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; 2 ==&lt;span&gt; ai_task.type:
            domains &lt;/span&gt;= Classification.objects.values(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;domain_name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).distinct().filter(type = 2).order_by(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;domain_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    out &lt;/span&gt;=&lt;span&gt; BytesIO()
    excel &lt;/span&gt;= pandas.ExcelWriter(out, engine = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;xlsxwriter&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    summary_title &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Domain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Pass&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Fail&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    summary_dict &lt;/span&gt;= {title: [] &lt;span&gt;for&lt;/span&gt; title &lt;span&gt;in&lt;/span&gt;&lt;span&gt; summary_title}
    domain_title &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Domain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;One level&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Two level&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Semantic&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Priority&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Intent group&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Intent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Result&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Handle time&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Response time&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Server Domain&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Detail&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

    summary_df &lt;/span&gt;=&lt;span&gt; pandas.DataFrame({})
    summary_df.to_excel(excel, sheet_name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Summary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, index = False, header =&lt;span&gt; False)

    workbook &lt;/span&gt;=&lt;span&gt; excel.book
    body_format &lt;/span&gt;=&lt;span&gt; workbook.add_format(style.body_style)
    header_format &lt;/span&gt;=&lt;span&gt; workbook.add_format(style.head_style)
    long_text_format &lt;/span&gt;=&lt;span&gt; workbook.add_format(style.long_text_style)
    large_text_format &lt;/span&gt;=&lt;span&gt; workbook.add_format(style.large_text_style)

    sheet_data &lt;/span&gt;=&lt;span&gt; {}
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; domain &lt;span&gt;in&lt;/span&gt;&lt;span&gt; domains:
        dmain_name &lt;/span&gt;= domain[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;domain_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
        sheet_data[dmain_name] &lt;/span&gt;= {column_name: [] &lt;span&gt;for&lt;/span&gt; column_name &lt;span&gt;in&lt;/span&gt;&lt;span&gt; domain_title}
        reports &lt;/span&gt;= ai_task.report.filter(semantic__classification__domain_name__exact =&lt;span&gt; dmain_name)

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; len(reports):
            pass_no &lt;/span&gt;= fail_no =&lt;span&gt; 0
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; report &lt;span&gt;in&lt;/span&gt;&lt;span&gt; reports:
                semantic &lt;/span&gt;=&lt;span&gt; report.semantic
                classification &lt;/span&gt;=&lt;span&gt; semantic.classification

                sheet_data[dmain_name][domain_title[0]].append(classification.domain_name)
                sheet_data[dmain_name][domain_title[&lt;/span&gt;1&lt;span&gt;]].append(classification.first_classification)
                sheet_data[dmain_name][domain_title[&lt;/span&gt;2&lt;span&gt;]].append(classification.second_classification)
                sheet_data[dmain_name][domain_title[&lt;/span&gt;3&lt;span&gt;]].append(semantic.name)
                sheet_data[dmain_name][domain_title[&lt;/span&gt;4&lt;span&gt;]].append(classification.semantic_property)
                sheet_data[dmain_name][domain_title[&lt;/span&gt;5&lt;span&gt;]].append(classification.intent_group)
                sheet_data[dmain_name][domain_title[&lt;/span&gt;6&lt;span&gt;]].append(classification.intent)
                sheet_data[dmain_name][domain_title[&lt;/span&gt;7&lt;span&gt;]].append(report.result)
                sheet_data[dmain_name][domain_title[&lt;/span&gt;8&lt;span&gt;]].append(report.in_handle_time)
                sheet_data[dmain_name][domain_title[&lt;/span&gt;9&lt;span&gt;]].append(report.ex_handle_time)
                sheet_data[dmain_name][domain_title[&lt;/span&gt;10&lt;span&gt;]].append(report.server_domain)
                sheet_data[dmain_name][domain_title[&lt;/span&gt;11&lt;span&gt;]].append(report.description)

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ==&lt;span&gt; report.result:
                    pass_no &lt;/span&gt;+= 1
                &lt;span&gt;elif&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fail&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ==&lt;span&gt; report.result:
                    fail_no &lt;/span&gt;+= 1&lt;span&gt;
            sheet_df &lt;/span&gt;=&lt;span&gt; pandas.DataFrame(sheet_data[dmain_name])
            sheet_df.to_excel(excel, sheet_name &lt;/span&gt;= dmain_name, index = False, header = False, startrow = 1&lt;span&gt;)

            worksheet &lt;/span&gt;=&lt;span&gt; excel.sheets[dmain_name]
            worksheet.set_column(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A:C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, None, body_format)
            worksheet.set_column(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:D&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 18&lt;span&gt;, long_text_format)
            worksheet.set_column(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:E&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, None, body_format)
            worksheet.set_column(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F:G&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 30&lt;span&gt;, long_text_format)
            worksheet.set_column(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;H:H&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, None, body_format)
            worksheet.set_column(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I:K&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, None, body_format)
            worksheet.set_column(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;L:L&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 50&lt;span&gt;, large_text_format)

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; col, title &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(sheet_df.columns.values):
                worksheet.write(0, col, title, header_format)

            sheet_data.clear()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;回收内存&lt;/span&gt;
&lt;span&gt;
            summary_dict[summary_title[0]].append(dmain_name)
            summary_dict[summary_title[&lt;/span&gt;1&lt;span&gt;]].append(pass_no)
            summary_dict[summary_title[&lt;/span&gt;2&lt;span&gt;]].append(fail_no)

    summary_df &lt;/span&gt;=&lt;span&gt; pandas.DataFrame(summary_dict)
    summary_df.to_excel(excel, sheet_name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Summary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, index = False, header = False, startrow = 1&lt;span&gt;)
    worksheet &lt;/span&gt;= excel.sheets[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Summary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; col, title &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(summary_df.columns.values):
        worksheet.write(0, col, title, header_format)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(summary_dict[title])):
            worksheet.write(row &lt;/span&gt;+ 1&lt;span&gt;, col, summary_dict[title][row], body_format)
    excel.save()

    response &lt;/span&gt;= HttpResponse(out.getvalue(), content_type = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;application/vnd.ms-excel&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    dt &lt;/span&gt;=&lt;span&gt; datetime.datetime.now()
    response[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Disposition&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;attachment;filename={} {}.xlsx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(urlquote(domain_name), dt.strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y-%m-%d %H-%M-%S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;End downloading...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; response
&lt;/pre&gt;&lt;/div&gt;









</description>
<pubDate>Mon, 25 Jun 2018 07:29:00 +0000</pubDate>
<dc:creator>ITACHl</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/julygift/p/9224499.html</dc:identifier>
</item>
<item>
<title>Linux VXLAN - wipan</title>
<link>http://www.cnblogs.com/wipan/p/9220615.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wipan/p/9220615.html</guid>
<description>&lt;h2&gt;&lt;span&gt;VXLAN协议&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;VXLAN是Virtual eXtensible Local Area Network的缩写，&lt;a href=&quot;https://tools.ietf.org/html/rfc7348&quot; target=&quot;_blank&quot;&gt;RFC 7348&lt;/a&gt;的标题“A Framework for Overlaying Virtualized Layer 2 Networks over Layer 3 Networks”，说明了VXLAN是一个在传统Layer 3网络上架设出来的Layer 2 overlay网络。RFC Abstract如下：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;This document describes Virtual eXtensible Local Area Network (VXLAN), which is used to address the need for overlay networks within virtualized data centers accommodating multiple tenants.  The scheme and the related protocols can be used in networks for cloud service providers and enterprise data centers.  This memo documents the deployed VXLAN protocol for the benefit of the Internet community.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在下面的场景中有两服务器，由三层物理网络连接。这两台服务器可能在同一个机架上，或者在不同的机架上，亦或在物理距离相距甚远的不同数据中心里。有4个VxLAN overlay网络，标识分别为VNI 22, 34, 74, 98。来看看Server 1上的虚拟机VM1-1和Server 2上的虚拟机VM2-4，它们属于相同的标识为VNI 22的VXLAN overlay网络。虚拟机并不知道overlay网络，也不知道VxLAN报文的封装和解封过程，因为这些过程都由物理服务器上的VTEP完成。看到这里，即使你没听说过VTEP这个概念，也大概知道它的作用了吧，VTEP (VXLAN Tunnel End Point), An entity that originates and/or terminates VXLAN tunnels，VTEP负责VxLAN的封装和解封装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398476/201806/1398476-20180624165234673-1622183763.jpg&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;579&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这种部署方法是基于物理机能够感知VXLAN协议，从而可以作为VxLAN的封装和解封点(VTEP) 。另外一种部署方法是把VTEP设备的位置放在网络设备中，比如交换机，可以作为一个VXLAN网络来负责VxLAN报文的封装和解封。在数据中心的部署中，物理机作为VTEP的部署方式能更好地和物理网络设备解耦，并且更加方便运维。&lt;/p&gt;

&lt;h2&gt;Linux上对VXLAN的支持&lt;/h2&gt;
&lt;p&gt;快速搭建和理解VXLAN的方法之一就是利用Linux。从内核3.7版本开始，Linux就开始支持VXLAN。到了内核3.12版本，Linux对VXLAN的支持已经完备，支持单播和组播，IPv4和IPv6。利用man查看ip的link子命令，可以查看是否有vxlan type，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ &lt;span&gt;man&lt;/span&gt; ip-link
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;搜索vxlan，可以看到如下描述，可以利用ip link add增加类型为VXLAN的link。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;VXLAN Type Support&lt;br/&gt;For a link of type VXLAN the following additional arguments are supported:&lt;/p&gt;
&lt;p&gt;ip link add DEVICE type vxlan id VNI [ dev PHYS_DEV ] [ { group | remote } IPADDR ] [ local { IPADDR | any } ] [ ttl TTL ] [ tos TOS ] [ dstport PORT ] [ srcport MIN&lt;br/&gt;MAX ] [ [no]learning ] [ [no]proxy ] [ [no]rsc ] [ [no]l2miss ] [ [no]l3miss ] [ [no]udpcsum ] [ [no]udp6zerocsumtx ] [ [no]udp6zerocsumrx ] [ ageing SECONDS ] [ maxad‐&lt;br/&gt;dress NUMBER ] [ gbp ]&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面的实验在如下环境中完成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;操作系统版本：CentOS Linux release 7.4.1708 (Core)&lt;/li&gt;
&lt;li&gt;内核版本：3.10.0-693.2.2.el7.x86_64&lt;/li&gt;
&lt;li&gt;云虚机vm1 eth0网络接口IP 172.31.0.106，云虚机vm2 eth0网络接口IP 172.31.0.107&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;场景1: 最简单的点对点VXLAN&lt;/h2&gt;
&lt;p&gt;创建简单的点对点VXLAN环境非常简单。如下图所示，只需要在两个机器(物理机或者虚拟机都可以，本实验中是云上的虚拟机环境)中各创建一个vxlan类型的网络接口即可，vxlan类型的接口vxlan1可以作为上文中提到的VTEP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398476/201806/1398476-20180624193502579-1971565070.png&quot; alt=&quot;&quot; width=&quot;532&quot; height=&quot;287&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在上面的环境中，注意我们将vxlan网络接口配置上IP地址，在10.0.0.0/24网段内。在IP地址分配后，Linux系统的路由表就会创建一条路由，去往10.0.0.0/24网段的报文走网络接口vxlan1出去。vm1上去往10.0.0.0/24的报文，在vxlan1上会做VXLAN封装，内层地址是10.0.0.106，外层地址是172.31.0.106。VXLAN报文通过物理网络达到对端vm2上的VETP vxlan1，在vm2的vxlan1接口上做VXLAN协议的解封装，从而结束整个过程。&lt;/p&gt;

&lt;p&gt;上图是一个物理上的示意图，在逻辑上形成的VXLAN overlay网络环境如下图，虚线部分示意出来的Overlay Network和VXLAN Tunnel都是逻辑上的概念。如果有容器和虚机被接入逻辑上的Overlay网络10.0.0.0/24，它们完全不用感知底层物理网络，看起来对端是和自己在同一个二层环境里，就是像是在VETP设备的上面直接构建了一条VXLAN Tunnel，把Overlay网络里的网络接口直接在二层打通。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398476/201806/1398476-20180624183037938-677617269.png&quot; alt=&quot;&quot; width=&quot;565&quot; height=&quot;277&quot;/&gt;&lt;/p&gt;

&lt;p&gt;具体的配置只需要3条命令。如下，在vm1上执行如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# ip link add vxlan1 type vxlan &lt;span&gt;id&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; remote &lt;span&gt;172.31&lt;/span&gt;.&lt;span&gt;0.107&lt;/span&gt; dstport &lt;span&gt;4789&lt;/span&gt;&lt;span&gt; dev eth0
# ip link set vxlan1 up
# ip addr add &lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.106&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; dev vxlan1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的第一条命令创建了一个Linux上类型为vxlan的网络接口，名为vxlan1。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;id: VNI标识是1。&lt;/li&gt;
&lt;li&gt;remote: 作为一个VTEP设备来封装和解封VXLAN报文，需要知道将封装好的VXLAN报文发送到哪个对端VTEP。Linux上可以利用group指定组播组低着，或者利用remote指定对端单播地址。在实验的云环境中默认不支持组播，这里利用remote指定点对点的对端IP地址为172.31.0.107。&lt;/li&gt;
&lt;li&gt;dstport: 指定目的端口为4789。因为当Linux内核3.7版本首次实现XVLAN时，UDP端口还并没有规定下来。很多厂商利用了8472这个端口，Linux也采用了相同的端口。后来IANA分配了4789作为VXLAN的目的UDP端口。如果你需要使用IANA端口，需要用dstport指定。&lt;/li&gt;
&lt;li&gt;dev: 指定VTEP通过哪个物理device来通信，这里是使用eth0。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第二条命令让vxlan1接口up起来。第三条命令给设备分配IP地址10.0.0.106, 子网掩码为24 (255.255.255.0)。&lt;/p&gt;

&lt;p&gt;在vm2上，利用类似方法创建名为vxlan1的网络接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# ip link add vxlan1 type vxlan &lt;span&gt;id&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; remote &lt;span&gt;172.31&lt;/span&gt;.&lt;span&gt;0.106&lt;/span&gt; dstport &lt;span&gt;4789&lt;/span&gt;&lt;span&gt; dev eth0
# ip link set vxlan1 up
# ip addr add &lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.107&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt; dev vxlan1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上简单的命令就完成了所有配置。用ifconfig可以看到vxlan1网络接口，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
# &lt;span&gt;ifconfig&lt;/span&gt;&lt;span&gt; vxlan1
vxlan1: flags&lt;/span&gt;=&lt;span&gt;4163&lt;/span&gt;&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu &lt;span&gt;1450&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.106&lt;/span&gt;  netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;  broadcast &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
        ether &lt;/span&gt;&lt;span&gt;22&lt;/span&gt;:2d:c4:f0:c7:&lt;span&gt;29&lt;/span&gt;  txqueuelen &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看下vm1的如下路由表，去往目的网段10.0.0.0/24的报文将走vxlan1接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# route -&lt;span&gt;n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
&lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;         &lt;span&gt;172.31&lt;/span&gt;.&lt;span&gt;0.253&lt;/span&gt;    &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;         UG    &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;&lt;span&gt; eth0
&lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;        &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;         &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;   U     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;&lt;span&gt; vxlan1
&lt;/span&gt;&lt;span&gt;169.254&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;     &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;         &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;     U     &lt;span&gt;1002&lt;/span&gt;   &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;&lt;span&gt; eth0&lt;br/&gt;&lt;/span&gt;&lt;span&gt;172.31&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;      &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;         &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;   U     &lt;span&gt;0&lt;/span&gt;      &lt;span&gt;0&lt;/span&gt;        &lt;span&gt;0&lt;/span&gt;&lt;span&gt; eth0&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在vm1上ping overlay网络的对端IP地址10.0.0.107，可以ping通。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
# &lt;span&gt;ping&lt;/span&gt; &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.107&lt;/span&gt; -c &lt;span&gt;3&lt;/span&gt;&lt;span&gt;
PING &lt;/span&gt;&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.107&lt;/span&gt; (&lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.107&lt;/span&gt;) &lt;span&gt;56&lt;/span&gt;(&lt;span&gt;84&lt;/span&gt;&lt;span&gt;) bytes of data.
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; bytes from &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.107&lt;/span&gt;: icmp_seq=&lt;span&gt;1&lt;/span&gt; ttl=&lt;span&gt;64&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;=&lt;span&gt;0.447&lt;/span&gt;&lt;span&gt; ms
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; bytes from &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.107&lt;/span&gt;: icmp_seq=&lt;span&gt;2&lt;/span&gt; ttl=&lt;span&gt;64&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;=&lt;span&gt;0.361&lt;/span&gt;&lt;span&gt; ms
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; bytes from &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.107&lt;/span&gt;: icmp_seq=&lt;span&gt;3&lt;/span&gt; ttl=&lt;span&gt;64&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;=&lt;span&gt;0.394&lt;/span&gt;&lt;span&gt; ms

&lt;/span&gt;--- &lt;span&gt;10.0&lt;/span&gt;.&lt;span&gt;0.107&lt;/span&gt; &lt;span&gt;ping&lt;/span&gt; statistics ---
&lt;span&gt;3&lt;/span&gt; packets transmitted, &lt;span&gt;3&lt;/span&gt; received, &lt;span&gt;0&lt;/span&gt;% packet loss, &lt;span&gt;time&lt;/span&gt;&lt;span&gt; 2000ms
rtt min&lt;/span&gt;/avg/max/mdev = &lt;span&gt;0.361&lt;/span&gt;/&lt;span&gt;0.400&lt;/span&gt;/&lt;span&gt;0.447&lt;/span&gt;/&lt;span&gt;0.042&lt;/span&gt; ms
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在ping包的同时，用tcpdump抓vm1 eth0网卡的包。因为报文到达eth0前经过了网络接口vxlan1, 完成了VXLAN的封装，所以在抓包结果里应该能看到完整的VXLAN报文。&lt;/p&gt;
&lt;p&gt;抓包时可以只抓和对端172.31.0.107通信的报文，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tcpdump -i eth0 host &lt;span&gt;172.31&lt;/span&gt;.&lt;span&gt;0.107&lt;/span&gt; -s0 -v -&lt;span&gt;w&lt;/span&gt; vxlan_vni_1.pcap
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;抓包结果如下，wireshark自动将UDP目的端口为4789的报文识别成VXLAN报文，直接显示内层的报文，protocol为ICMP协议。如果使用Linux默认接口8472，显示的应该是UDP协议，还需要修改wireshark的协议设置，让其识别成VXLAN。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398476/201806/1398476-20180624222420946-654903679.png&quot; alt=&quot;&quot; width=&quot;942&quot; height=&quot;334&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;场景2: 容器跨主机通信&lt;/h2&gt;
&lt;p&gt;上面最简单的点对点VXLAN实验只是个简答的演示，没有太多实际工程意义，本节用容器通信来演示一个更加完整的场景。&lt;/p&gt;

&lt;p&gt;场景描述：在vm1和vm2上各部署一个docker容器，默认情况下，一个容器宿主机上的容器能够直接用私网IP地址通信，因为它们利用一个网桥接在一起。而不同宿主机上的容器无法直接用私网IP地址通信。k8s等docker部署软件中的网络组建实际上完成了这部分工作，让不同宿主机的容器能够直接通信。本节使用原生docker，以及在宿主机上自建的vxlan网络接口，来打通不同宿主机上容器，让它们可以直接利用内网IP通信。&lt;/p&gt;
&lt;p&gt;注意：因为实验在云上的虚拟机上完成，上面提到的容器宿主机，用的是云上的虚拟机。容器宿主机也可以是物理机，实验效果不变。&lt;/p&gt;

&lt;h3&gt;准备docker容器&lt;/h3&gt;
&lt;p&gt;安装docker的过程不展开了，&lt;a href=&quot;https://docs.docker.com/install/&quot; target=&quot;_blank&quot;&gt;docker官方文档&lt;/a&gt;有详细的描述。在Linux安装了docker后，可以看到多了一个docker0的网络接口，默认在172.17.0.0/16网段。这个连接容器的网桥。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
# &lt;span&gt;ifconfig&lt;/span&gt;&lt;span&gt; docker0
docker0: flags&lt;/span&gt;=&lt;span&gt;4163&lt;/span&gt;&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu &lt;span&gt;1450&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;172.17&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;  netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;  broadcast &lt;span&gt;172.17&lt;/span&gt;.&lt;span&gt;255.255&lt;/span&gt;&lt;span&gt;
        ether &lt;/span&gt;&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:&lt;span&gt;44&lt;/span&gt;:e8:&lt;span&gt;74&lt;/span&gt;:e8  txqueuelen &lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;6548&lt;/span&gt;  bytes &lt;span&gt;360176&lt;/span&gt; (&lt;span&gt;351.7&lt;/span&gt;&lt;span&gt; KiB)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;7489&lt;/span&gt;  bytes &lt;span&gt;40249455&lt;/span&gt; (&lt;span&gt;38.3&lt;/span&gt;&lt;span&gt; MiB)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用默认172.17.0.0/16网段，docker容器的IP地址都会从172.17.0.2开始分配。为了能使vm1和vm2上的容器使用不同的IP地址，在利用docker run启动容器的时候需要能自定义IP地址，而利用--ip参数自定义IP地址的功能只能在自定网络中支持，所以先创建一个自定义网络，指定网段172.18.0.0/16。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# docker network create --subnet &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;16&lt;/span&gt;&lt;span&gt; mynetwork
3231f89d69f6b3fbe2550392ebe4d00daa3d19e251f66ed2d81f61f2b9184362
# docker network &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
NETWORK ID          NAME                DRIVER              SCOPE
1cb284a6cb33        bridge              bridge              local
069538be0246        host                host                local
3231f89d69f6        mynetwork           bridge              local
0b7934996485        none                &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;                local
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;利用docker network ls查看，可以看到一个新的bridge网络被创建，名称为我指定的mynetwork。利用ifconfig可以看到多了一个网络接口，名字不是dockerXX，而直接以br开头，是一个网桥。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
br-3231f89d69f6: flags=&lt;span&gt;4099&lt;/span&gt;&amp;lt;UP,BROADCAST,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;  netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;  broadcast &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;255.255&lt;/span&gt;&lt;span&gt;
        ether &lt;/span&gt;&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:&lt;span&gt;97&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:a5:f9  txqueuelen &lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;创建一个新的容器，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# docker run -itd --net mynetwork --ip &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.2&lt;/span&gt;&lt;span&gt; centos
16bbaeaaebfccd2a497e3284600f5c0ce230e89678e0ff92f6f4b738c6349f8d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;--net指定自定义网络&lt;/li&gt;
&lt;li&gt;--ip指定IP地址&lt;/li&gt;
&lt;li&gt;centos指定image&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看容器ID和状态，并且登录SHELL，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# docker &lt;span&gt;ps&lt;/span&gt;&lt;span&gt;
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
16bbaeaaebfc        centos              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/bash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;         &lt;span&gt;2&lt;/span&gt; minutes ago       Up &lt;span&gt;2&lt;/span&gt;&lt;span&gt; minutes                            condescending_swartz
# docker exec &lt;/span&gt;-it 16bbaeaaebfc /bin/&lt;span&gt;bash
[root@16bbaeaaebfc &lt;/span&gt;/]# &lt;span&gt;ifconfig&lt;/span&gt;&lt;span&gt;
bash: &lt;/span&gt;&lt;span&gt;ifconfig&lt;/span&gt;: command not found
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意：docker为了创建容器的效率，通常都用了size很小的image，意味着很多常用工具需要安装，比如centos image里面的ifconfig。可以利用yum whatprovides ifconfig命令查看ifconfig输入哪个包，查到属于net-tools-2.0-0.22.20131004git.el7.x86_64包，直接用yum install net-tools -y安装即可。再执行ifconfig命令，可以看到容器eth0网卡的IP地址为172.18.0.2。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[root@16bbaeaaebfc /]# &lt;span&gt;ifconfig&lt;/span&gt;&lt;span&gt; eth0
eth0: flags&lt;/span&gt;=&lt;span&gt;4163&lt;/span&gt;&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.2&lt;/span&gt;  netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;  broadcast &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;255.255&lt;/span&gt;&lt;span&gt;
        ether &lt;/span&gt;&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:ac:&lt;span&gt;12&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;02&lt;/span&gt;  txqueuelen &lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;3319&lt;/span&gt;  bytes &lt;span&gt;19221325&lt;/span&gt; (&lt;span&gt;18.3&lt;/span&gt;&lt;span&gt; MiB)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;2015&lt;/span&gt;  bytes &lt;span&gt;132903&lt;/span&gt; (&lt;span&gt;129.7&lt;/span&gt;&lt;span&gt; KiB)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在vm2上执行同样的操作，在创建新容器的时候，指定IP地址为172.18.0.3，容器的环境即准备完毕。在vm1上的centos 容器中ping 172.18.0.3，和预期一致，是无法ping通的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
[root@16bbaeaaebfc /]# &lt;span&gt;ping&lt;/span&gt; &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.3&lt;/span&gt; -c &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
PING &lt;/span&gt;&lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.3&lt;/span&gt; (&lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.3&lt;/span&gt;) &lt;span&gt;56&lt;/span&gt;(&lt;span&gt;84&lt;/span&gt;&lt;span&gt;) bytes of data.
From &lt;/span&gt;&lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.2&lt;/span&gt; icmp_seq=&lt;span&gt;1&lt;/span&gt;&lt;span&gt; Destination Host Unreachable
From &lt;/span&gt;&lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.2&lt;/span&gt; icmp_seq=&lt;span&gt;2&lt;/span&gt;&lt;span&gt; Destination Host Unreachable

&lt;/span&gt;--- &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.3&lt;/span&gt; &lt;span&gt;ping&lt;/span&gt; statistics ---
&lt;span&gt;2&lt;/span&gt; packets transmitted, &lt;span&gt;0&lt;/span&gt; received, +&lt;span&gt;2&lt;/span&gt; errors, &lt;span&gt;100&lt;/span&gt;% packet loss, &lt;span&gt;time&lt;/span&gt;&lt;span&gt; 1000ms
pipe &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
[root@16bbaeaaebfc &lt;/span&gt;/]# &lt;span&gt;ping&lt;/span&gt; &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; -c &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
PING &lt;/span&gt;&lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; (&lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;) &lt;span&gt;56&lt;/span&gt;(&lt;span&gt;84&lt;/span&gt;&lt;span&gt;) bytes of data.
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; bytes from &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;: icmp_seq=&lt;span&gt;1&lt;/span&gt; ttl=&lt;span&gt;64&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;=&lt;span&gt;0.060&lt;/span&gt;&lt;span&gt; ms
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; bytes from &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;: icmp_seq=&lt;span&gt;2&lt;/span&gt; ttl=&lt;span&gt;64&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;=&lt;span&gt;0.079&lt;/span&gt;&lt;span&gt; ms

&lt;/span&gt;--- &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; &lt;span&gt;ping&lt;/span&gt; statistics ---
&lt;span&gt;2&lt;/span&gt; packets transmitted, &lt;span&gt;2&lt;/span&gt; received, &lt;span&gt;0&lt;/span&gt;% packet loss, &lt;span&gt;time&lt;/span&gt;&lt;span&gt; 999ms
rtt min&lt;/span&gt;/avg/max/mdev = &lt;span&gt;0.060&lt;/span&gt;/&lt;span&gt;0.069&lt;/span&gt;/&lt;span&gt;0.079&lt;/span&gt;/&lt;span&gt;0.012&lt;/span&gt; ms
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;创建VXLAN接口接入docker网桥&lt;/h3&gt;
&lt;p&gt;先来梳理下docker及docker容器在Linux宿主机网络模块中做的操作，梳理清楚之后会发现打通不同宿主机上docker容器的方法非常简单。从宿主Linux系统的视角看操作系统中的网络设备，总结如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;docker0接口&lt;/strong&gt;：网桥，在安装完docker后默认被创建，网段是172.17.0.0/16，网桥的默认IP地址为172.17.0.1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;br-xxxx接口&lt;/strong&gt;：网桥，在创建完自定义docker网络完被创建，网段是被用户指定的172.18.0.0/16，网桥的默认IP地址为172.18.0.1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;vethxxxx接口&lt;/strong&gt;：veth网络接口，在创建一个具体的docker容器后被创建，如果有N个运行的容器，就会有N个veth网络接口。容器中的eth0接口和宿主机的veth网络接口是一个veth网络对，Linux上的veth接口作为一个端口连接入docker网桥，如docker0或其他自定义网桥。这也是为什么一个宿主机上的docker容器能够默认通信的原因，因为它们创建后就被接入到了同一个网桥上。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了方便理解，在默认网段172.17.0.0/16中创建2个容器，在自定义网段中上文已经创建了1个docker容器，利用btctl查看网桥及其接口，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# brctl show
bridge name    bridge &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;        STP enabled    interfaces
br&lt;/span&gt;-3231f89d69f6        &lt;span&gt;8000&lt;/span&gt;&lt;span&gt;.02429722a5f9    no        veth2fa4c50
docker0        &lt;/span&gt;&lt;span&gt;8000&lt;/span&gt;&lt;span&gt;.024244e874e8    no        vethc7cd982
                           　　　　　　　　　　　 vethd3d0c18&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上面的输出结果可以看到，默认网桥docker0上，有vethc7cd982和vethd3d0c18两个网络接口接入。在定义网络网桥br-3231f89d69f6一个端口上，veth2fa4c50网络接口接入。这三个veth网络接口分别连接着一个docker容器的eth0网络接口，连接着同一个网桥的veth网络接口vethc7cd982和vethd3d0c18默认二层能通。&lt;/p&gt;

&lt;p&gt;有了上面的梳理和本文第一节VXLAN网络接口的基础知识，想必打通不同宿主机上docker容器的方法也比较清晰了。思路就是在两个容器宿主机上各创建一个VXLAN接口，并且将VXLAN接口接入docker网桥的端口上，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1398476/201806/1398476-20180625112213032-1399465652.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;353&quot;/&gt;&lt;/p&gt;

&lt;p&gt;有了VXLAN接口的连接后，从vm1上docker容器发出的包到达docker网桥后，可以从网桥的VXLAN接口出去，从而报文在VETP(VXLAN接口)处被封装成VXLAN报文，再从物理网络上到达对端VETP所在的主机vm2。对端VTEP能正确解包VXLAN报文的话，随后即可将报文通过vm2上的docker网桥送到上层的docker容器中。&lt;/p&gt;

&lt;p&gt;具体的配置如下，在vm1上：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# ip link add vxlan_docker type vxlan &lt;span&gt;id&lt;/span&gt; &lt;span&gt;200&lt;/span&gt; remote &lt;span&gt;172.31&lt;/span&gt;.&lt;span&gt;0.107&lt;/span&gt; dstport &lt;span&gt;4789&lt;/span&gt;&lt;span&gt; dev eth0
# ip link set vxlan_docker up
# brctl addif br-3231f89d69f6 vxlan_docker&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;第一条命令创建VNI为200的VXLAN网络接口，名称为vxlan_docker，参数设置和场景1中的各个参数类似。&lt;/li&gt;
&lt;li&gt;第三条命令把新创建的VXLAN接口vxlan_docker接入到docker网桥br-3231f89d69f6中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在vm2上，输入如下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# ip link add vxlan_docker type vxlan &lt;span&gt;id&lt;/span&gt; &lt;span&gt;200&lt;/span&gt; remote &lt;span&gt;172.31&lt;/span&gt;.&lt;span&gt;0.106&lt;/span&gt; dstport &lt;span&gt;4789&lt;/span&gt;&lt;span&gt; dev eth0
# ip link set vxlan_docker up
# brctl addif br&lt;/span&gt;-f4b35af34313 vxlan_docker
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在vm1的docker容器上再ping 172.18.0.3，结果如下，ping可以通。注意RTT的时间，ping 172.18.0.3的RTT在10^(-1)毫秒级别，ping 172.18.0.1的RTT在10^(-2)毫秒级别，前者是走物理网络的延迟，后者是协议栈的延迟，两者有量级上的差别。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
# docker exec -it 16bbaeaaebfc &lt;span&gt;ifconfig&lt;/span&gt;&lt;span&gt; eth0
eth0: flags&lt;/span&gt;=&lt;span&gt;4163&lt;/span&gt;&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.2&lt;/span&gt;  netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;  broadcast &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;255.255&lt;/span&gt;&lt;span&gt;
        ether &lt;/span&gt;&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:ac:&lt;span&gt;12&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;02&lt;/span&gt;  txqueuelen &lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;3431&lt;/span&gt;  bytes &lt;span&gt;19230266&lt;/span&gt; (&lt;span&gt;18.3&lt;/span&gt;&lt;span&gt; MiB)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;2132&lt;/span&gt;  bytes &lt;span&gt;141908&lt;/span&gt; (&lt;span&gt;138.5&lt;/span&gt;&lt;span&gt; KiB)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

# docker exec &lt;/span&gt;-it 16bbaeaaebfc &lt;span&gt;ping&lt;/span&gt; &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.3&lt;/span&gt; -c &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
PING &lt;/span&gt;&lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.3&lt;/span&gt; (&lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.3&lt;/span&gt;) &lt;span&gt;56&lt;/span&gt;(&lt;span&gt;84&lt;/span&gt;&lt;span&gt;) bytes of data.
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; bytes from &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.3&lt;/span&gt;: icmp_seq=&lt;span&gt;1&lt;/span&gt; ttl=&lt;span&gt;64&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;=&lt;span&gt;0.544&lt;/span&gt;&lt;span&gt; ms
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; bytes from &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.3&lt;/span&gt;: icmp_seq=&lt;span&gt;2&lt;/span&gt; ttl=&lt;span&gt;64&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;=&lt;span&gt;0.396&lt;/span&gt;&lt;span&gt; ms

&lt;/span&gt;--- &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.3&lt;/span&gt; &lt;span&gt;ping&lt;/span&gt; statistics ---
&lt;span&gt;2&lt;/span&gt; packets transmitted, &lt;span&gt;2&lt;/span&gt; received, &lt;span&gt;0&lt;/span&gt;% packet loss, &lt;span&gt;time&lt;/span&gt;&lt;span&gt; 1001ms
rtt min&lt;/span&gt;/avg/max/mdev = &lt;span&gt;0.396&lt;/span&gt;/&lt;span&gt;0.470&lt;/span&gt;/&lt;span&gt;0.544&lt;/span&gt;/&lt;span&gt;0.074&lt;/span&gt;&lt;span&gt; ms
#
# docker exec &lt;/span&gt;-it 16bbaeaaebfc &lt;span&gt;ping&lt;/span&gt; &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; -c &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
PING &lt;/span&gt;&lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; (&lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;) &lt;span&gt;56&lt;/span&gt;(&lt;span&gt;84&lt;/span&gt;&lt;span&gt;) bytes of data.
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; bytes from &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;: icmp_seq=&lt;span&gt;1&lt;/span&gt; ttl=&lt;span&gt;64&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;=&lt;span&gt;0.072&lt;/span&gt;&lt;span&gt; ms
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; bytes from &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;: icmp_seq=&lt;span&gt;2&lt;/span&gt; ttl=&lt;span&gt;64&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;=&lt;span&gt;0.072&lt;/span&gt;&lt;span&gt; ms

&lt;/span&gt;--- &lt;span&gt;172.18&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt; &lt;span&gt;ping&lt;/span&gt; statistics ---
&lt;span&gt;2&lt;/span&gt; packets transmitted, &lt;span&gt;2&lt;/span&gt; received, &lt;span&gt;0&lt;/span&gt;% packet loss, &lt;span&gt;time&lt;/span&gt;&lt;span&gt; 999ms
rtt min&lt;/span&gt;/avg/max/mdev = &lt;span&gt;0.072&lt;/span&gt;/&lt;span&gt;0.072&lt;/span&gt;/&lt;span&gt;0.072&lt;/span&gt;/&lt;span&gt;0.000&lt;/span&gt; ms
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后说明，本节只是为了演示Linux VXLAN的用于而构造了这个简单但没有实际用处的场景，在跨主机环境的容器之间利用VXLAN从二层打通。在工程中做容器跨主机通信时有很多方面需要考虑，也有很多项目在致力于这方面的研究。比如&lt;a href=&quot;https://github.com/coreos/flannel&quot; target=&quot;_blank&quot;&gt;Flannel&lt;/a&gt;，通过给每台宿主机分配一个子网的方式为容器提供虚拟网络，它基于Linux TUN/TAP，使用UDP封装IP包来实现L3 overlay网络，并借助etcd维护网络的分配情况。Github上有项目的文档，另外&lt;a href=&quot;http://dockone.io/article/618&quot; target=&quot;_blank&quot;&gt;文章&lt;/a&gt;做了不错的基本介绍。&lt;/p&gt;

&lt;h3&gt; &lt;/h3&gt;

</description>
<pubDate>Mon, 25 Jun 2018 06:58:00 +0000</pubDate>
<dc:creator>wipan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wipan/p/9220615.html</dc:identifier>
</item>
<item>
<title>从.Net到Java学习第九篇——SpringBoot下Thymeleaf - 邹琼俊</title>
<link>http://www.cnblogs.com/jiekzou/p/9216305.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiekzou/p/9216305.html</guid>
<description>&lt;h2&gt;Thymeleaf概述&lt;/h2&gt;
&lt;p&gt;　　Thymeleaf 是一个流行的模板引擎，该模板引擎采用java语言开发。模板引擎是一个技术名称，是跨领域平台的概念，在java语言体系下有模板引擎，在C#、PHP语言体系下也有模板引擎，甚至在JavaScript中也会用到模板引擎技术。&lt;br/&gt;Java生态下的模板引擎有Thymeleaf 、Freemaker、Velocity、Beetl（国产）等。Thymeleaf模板既能用于web环境下，也能用于非web环境下，在非web环境下，它能直接显示模板上的静态数据，在web环境下，它能像JSP一样从后台接收数据并替换掉模板上的静态数据。.net下面的razor也是一个模板引擎。&lt;/p&gt;&lt;p&gt;Thymeleaf它是基于HTML的，以HTML标签为载体，Thymeleaf要寄托在HTML的标签下实现对数据的展示。&lt;br/&gt;Thymeleaf的官方网站：&lt;a href=&quot;http://www.thymeleaf.org&quot; target=&quot;_blank&quot;&gt;http://www.thymeleaf.org&lt;/a&gt;&lt;br/&gt;Spring boot集成了Thymeleaf模板技术，并且Spring boot官方也推荐使用&lt;br/&gt;Thymeleaf来替代JSP技术。&lt;br/&gt;Thymeleaf是另外的一种模板技术，它本身并不属于spring boot，&lt;br/&gt;srpingboot只是很好的集成了这种模板技术，作为前端页面的数据展示。&lt;/p&gt;
&lt;h2&gt;Spring Boot集成Thymeleaf配置&lt;/h2&gt;
&lt;p&gt;（1）修改pom.xml，在Maven中引入Thymeleaf的依赖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;thymeleaf&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-thymeleaf&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（2）在Spring boot的核心配置文件application.yml中对Thymeleaf进行配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;spring:
  profiles:
    active: test
&lt;span&gt;  thymeleaf:
    cache: false &lt;span&gt;#开发阶段，建议关闭Thymeleaf的缓存&lt;/span&gt;
    mode: LEGACYHTML5 &lt;span&gt;#使用遗留的html5以去掉对html标签的校验&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在使用Spring boot的过程中，如果使用thymeleaf作为模板文件，则要求HTML格式必须为严格的html5格式，所有标签必须有结束标签，否则会报错。如果不想对标签进行严格的验证，使用spring.thymeleaf.model=LEGACYHTML5去掉验证，去掉该验证还需要引入许下的依赖，否则会报错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;net.sourceforge.nekohtml&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;nekohtml&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.9.22&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; （3）新建一个控制器&lt;span&gt;ThymeleafController&lt;/span&gt;去映射到模板页&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ThymeleafController {
    @GetMapping(&lt;/span&gt;&quot;/index&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String index(Model model){
        model.addAttribute(&lt;/span&gt;&quot;msg&quot;,&quot;Spring boot集成Thymeleaf&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;index&quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回的是一个页面，可以省略后缀.html&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;（4）在src/main/resources的templates下面新建一个index.html页面用于数据展示，HTML页面的&amp;lt;html&amp;gt;元素中药记得加入以下属性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns:th&lt;/span&gt;&lt;span&gt;=&quot;http://www.thymeleaf.org&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; index.html源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns:th&lt;/span&gt;&lt;span&gt;=&quot;http://www.thymeleaf.org&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;引入thymeleaf&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;${msg}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;你好&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt; Springboot使用thymeleaf作为视图展示，约定将模板文件放置在src/main/resources/templates目录下，静态资源放置在src/main/resources/static目录下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行IDEA项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413851/201806/413851-20180623121325706-2090488820.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不启动spring boot直接在浏览器中浏览这个页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413851/201806/413851-20180623121428635-1450665491.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Thymeleaf标准变量表达式&lt;/h2&gt;
&lt;p&gt;语法：&lt;code&gt;${...}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;变量表达式用于访问容器（tomcat）上下文环境中的变量，功能和JSTL中的${}相同。Thymeleaf中的变量表达式使用${变量名}的方式获取其中的数据。&lt;/p&gt;
&lt;p&gt;新建实体类&lt;span&gt;User&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.yujie.entity;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String sex;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer age;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String email;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getSex() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; sex;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setSex(String sex) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sex =&lt;span&gt; sex;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getAge() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAge(Integer age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getEmail() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; email;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setEmail(String email) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.email =&lt;span&gt; email;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Spring mvc的Controller中使用向前端传输数据，&lt;span&gt;ThymeleafController&lt;/span&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    @GetMapping(&quot;/user&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String user(Model model){
        User user&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setAge(&lt;/span&gt;21&lt;span&gt;);
        user.setEmail(&lt;/span&gt;&quot;zouyujie@126.com&quot;&lt;span&gt;);
        user.setName(&lt;/span&gt;&quot;玉杰&quot;&lt;span&gt;);
        model.addAttribute(&lt;/span&gt;&quot;user&quot;&lt;span&gt;,user);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;user&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;templates目录下面，新建一个user.html页面，前端接收代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns:th&lt;/span&gt;&lt;span&gt;=&quot;http://www.thymeleaf.org&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;引入thymeleaf&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Title&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;用户信息如下：&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;${user.name}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;${user.age}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;${user.email}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413851/201806/413851-20180623164459918-1847516565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;选择变量表达式&lt;/h2&gt;
&lt;p&gt;选择变量表达式，也叫星号变量表达式，使用th:object属性来绑定对象，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;分割线——选择变量表达式&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;th:object&lt;/span&gt;&lt;span&gt;=&quot;${user}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;*{name}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;*{age}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;th:text&lt;/span&gt;&lt;span&gt;=&quot;*{email}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 继续&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/413851/201806/413851-20180623164933554-1884661106.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;选择变量表达式首先使用th:object来绑定后台传来的user对象，然后使用*来代表这个对象，后面{}中的值是此对象中的属性。&lt;br/&gt;选择变量表达式*{...}是另一种类似于变量表达式${...}表示变量的方法。&lt;br/&gt;选择变量表达式在执行时是在选择的对象上求解，而${...}是在上下文的变量Model上求解。&lt;br/&gt;通过th:object属性指明选择变量表达式的求解对象。&lt;br/&gt;标准变量表达式和选择变量表达式可以混合在一起使用，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;div th:object=&quot;${user}&quot;&amp;gt;
    &amp;lt;div th:text=&quot;*{name}&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div th:text=&quot;*{age}&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div th:text=&quot;&lt;span&gt;${user.email}&lt;/span&gt;&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以不使用th:object进行对象的选择，而直接使用*{...}获取数据，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;p&amp;gt;不使用th:object&amp;lt;/p&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;div th:text=&quot;*{user.name}&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div th:text=&quot;*{user.age}&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;div th:text=&quot;*{user.email}&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Thymeleaf的URL表达式&lt;/h2&gt;
&lt;p&gt;语法：&lt;code&gt;@{...}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;URL表达式可用于&amp;lt;script src=&quot;...&quot;&amp;gt;、&amp;lt;link href=&quot;...&quot;&amp;gt;、&amp;lt;a href=&quot;...&quot;&amp;gt;等&lt;br/&gt;1.绝对URL，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;index.html&quot;&lt;/span&gt;&lt;span&gt; th:href&lt;/span&gt;&lt;span&gt;=&quot;@{'http://localhost:8080/user?name='+${user.name}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;index&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.相对URL，相对于页面，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;index.html&quot;&lt;/span&gt;&lt;span&gt; th:href&lt;/span&gt;&lt;span&gt;=&quot;@{'user?name='+${user.name}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;index&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.相对URL，相对于项目上下文，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a &lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;=&quot;index.html&quot;&lt;/span&gt;&lt;span&gt; th:href&lt;/span&gt;&lt;span&gt;=&quot;@{'/user?name='+${user.name}}&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;index&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;项目的上下文名会自动添加，我们可以看下html运行的源码。&lt;/p&gt;
&lt;h2&gt;thymeleaf的常用属性&lt;/h2&gt;
&lt;p&gt;thymeleaf的常用属性：&lt;br/&gt;th:action&lt;br/&gt;th:each&lt;br/&gt;th:href&lt;br/&gt;th:id&lt;br/&gt;th:if&lt;br/&gt;th:unless&lt;br/&gt;th:switch/th:case&lt;br/&gt;th:object&lt;br/&gt;th:src&lt;br/&gt;th:text&lt;br/&gt;th:value&lt;br/&gt;th:attr&lt;br/&gt;th:onclick&lt;br/&gt;th:style&lt;br/&gt;th:method&lt;br/&gt;th:name&lt;br/&gt;th:inline&lt;br/&gt;这些标记大多数和html的标记名称是一样的。&lt;/p&gt;
&lt;h2&gt;thymeleaf表达式基本对象&lt;/h2&gt;
&lt;p&gt;模板引擎提供了一组内置的对象，这些内置的对象可以直接在模板中使用，这些对象由#号开始引用。&lt;/p&gt;
&lt;h3&gt;#request&lt;/h3&gt;
&lt;p&gt;相当于HttpServletRequest对象，这是3.x版本，若是2.x版本使用#httpServletRequest&lt;br/&gt;${#request.getContextPath()}&lt;br/&gt;${#request.getAttribute(&quot;name&quot;)}&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;#session&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;相当于HttpSession&lt;br/&gt;对象，这是3.x版本，若是2.x版本使用#httpSession，需要在后头controller中设置session，&lt;br/&gt;${#session.getAttribute(&quot;phone&quot;)}&lt;br/&gt;${#session.id}&lt;/p&gt;
&lt;h2&gt;thymeleaf表达式功能对象&lt;/h2&gt;
&lt;p&gt;1.模板引擎提供的一组功能性内置对象，可以在模板中直接使用这些对象提供的功能方法。&lt;br/&gt;2.工作中常使用的数据类型，如集合、时间、数值，可以使用thymeleaf提供的功能性对象来处理它们。&lt;br/&gt;3.内置功能对象前都需要加#号，内置对象一般都以s结尾。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;#dates：java.util.Date对象的实用方法，&amp;lt;span th:text=&quot;${#dates.format(curDate,'yyyy-MM-dd HH:mm:ss')}&quot;&amp;gt;&amp;lt;/span&amp;gt;&lt;/li&gt;
&lt;li&gt;#calendars：和dates类似，但是是java.util.Calendar对象。&lt;/li&gt;
&lt;li&gt;#numbers：格式化数据对象的实用方法。&lt;/li&gt;
&lt;li&gt;#strings：字符串对象的实用方法。contains,startsWith,prepending/appending等。&lt;/li&gt;
&lt;li&gt;#objects：对objects操作的实用方法。&lt;/li&gt;
&lt;li&gt;#bools：对布尔值求值的实用方法。&lt;/li&gt;
&lt;li&gt;#arrays：数组的实用方法。&lt;/li&gt;
&lt;li&gt;#lists：list的实用方法.&lt;/li&gt;
&lt;li&gt;#sets：set的实用方法.&lt;/li&gt;
&lt;li&gt;#maps：map的实用方法&lt;/li&gt;
&lt;li&gt;#aggregates：对数组或集合创建聚合的实用方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有条件表达式等等，更多内容可以参考thymeleaf的官网：&lt;a href=&quot;http://www.thymeleaf.org&quot; target=&quot;_blank&quot;&gt;http://www.thymeleaf.org&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Jun 2018 06:56:00 +0000</pubDate>
<dc:creator>邹琼俊</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiekzou/p/9216305.html</dc:identifier>
</item>
<item>
<title>换个角度看问题 - nesger</title>
<link>http://www.cnblogs.com/nesger/p/9224206.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nesger/p/9224206.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5361063-3d50bdebfa7df578.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;换个角度看问题，可以节省你大量时间，提高你的效率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;公司开发的一个 app，有用户反馈在打开网页点击上传图片按钮时，点击拍照不能唤起系统相机。还说在 Android 6.0 以上手机可以，以下不行。&lt;/p&gt;
&lt;p&gt;听到这里，我大概知道应该是权限问题了。&lt;/p&gt;
&lt;p&gt;更多关于权限的可以看下我这篇文章 &lt;a href=&quot;https://www.jianshu.com/p/8de4385b6ade&quot;&gt;android开发之调皮的权限&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;解决之路&quot;&gt;解决之路&lt;/h3&gt;
&lt;p&gt;既然知道是权限问题，那么问题就简单了，在选择系统相机的时候申请权限就可以了。&lt;/p&gt;
&lt;p&gt;然而事实是：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5361063-7d9f3bf0338a6421.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在说明踩坑之路之前我们先说下储备知识。&lt;/p&gt;
&lt;h3 id=&quot;储备知识&quot;&gt;储备知识&lt;/h3&gt;
&lt;p&gt;1.需要一个页面。&lt;br/&gt;代码如下，可以直接保存到记事本，然后修改文件名即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;input type = &quot;file&quot; accept=&quot;image/jpg, image/png, image/jpeg&quot; id=&quot;myFile&quot; /&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;页面内容很简单，就是一个文件上传按钮，支持图片文件上传。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5361063-927950dd4928295a.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.需要一个 Android Demo。&lt;br/&gt;这个 Demo 有一个页面，页面里面就有一个 WebView。&lt;br/&gt;开发过 Android WebView 的都知道，Android 上传文件对于不同的系统做法不一样。&lt;br/&gt;我们这里以 Android 5.0 的文件上传为例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;webview.setWebChromeClient(new WebChromeClient() {
        // For Android &amp;gt;= 5.0
        @Override
        public boolean onShowFileChooser(WebView webView, 
                ValueCallback&amp;lt;Uri[]&amp;gt; filePathCallback, 
                WebChromeClient.FileChooserParams fileChooserParams) {
            //TODO call system intent
            return true;
        }
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相信大家对于上面代码并不陌生。&lt;br/&gt;我们就是需要在 TODO 里面调用系统相机和系统相册等 Intent。&lt;br/&gt;调用后大概效果如下：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5361063-8190ee7b481d129e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;好了，到了这里就可以开始说下踩坑之路了。&lt;/p&gt;
&lt;h3 id=&quot;踩坑之路&quot;&gt;踩坑之路&lt;/h3&gt;
&lt;p&gt;希望知道上面点击的是相机还是文档。&lt;br/&gt;为什么需要知道这个呢？&lt;br/&gt;因为一般 App 启动的时候默认会申请存储权限。&lt;br/&gt;&lt;strong&gt;所以假设用户点击文档，那么是不需要申请相机权限的。&lt;/strong&gt;&lt;br/&gt;因此我们需要做到当用户点击相机的时候才去申请权限。&lt;/p&gt;
&lt;p&gt;所以基于这一点，开始网络查找资料，陷入坑中。&lt;br/&gt;比如：&lt;br/&gt;Intent.ACTION_CHOOSER 与 Intent.ACTION_PICK_ACTIVITY。&lt;br/&gt;当然关于 Intent.ACTION_PICK_ACTIVITY 的例子很少，最后这边弃用了。&lt;br/&gt;再比如：&lt;br/&gt;通过 createChooser(Intent target, CharSequence title, IntentSender sender) 的第三个参数 IntentSender 来判断。&lt;br/&gt;这个也是觉得很复杂，成本较高，不太合适。&lt;/p&gt;
&lt;p&gt;那到底应该怎么处理呢？&lt;br/&gt;这个时候就不要死磕这一点了，而是要&lt;strong&gt;站在巨人的肩膀上&lt;/strong&gt;。&lt;br/&gt;WebView 说到底也可以看成是一个精简版的浏览器，因此我们完全可以参考下浏览器的做法。&lt;/p&gt;
&lt;p&gt;这边使用的手机为三星 S7，以这个手机为例。&lt;/p&gt;
&lt;p&gt;在系统三星浏览器上点击，马上弹出权限申请&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5361063-113c30b61a632f65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此&lt;strong&gt;解决方法之一是点击就申请权限。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 UC 浏览器上点击，弹出如下框（ PS：可能一打开文件进入会提示出错，再打开即可）：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5361063-55976222f29e3267.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;br/&gt;&lt;strong&gt;只有在点击相机拍照才会去申请权限，是不是更好，权限申请更严格。&lt;/strong&gt;&lt;br/&gt;不过实际测试发现了一个 BUG。&lt;br/&gt;就是权限申请如果拒绝，再次点击页面无响应。&lt;br/&gt;估计 UC 浏览器在权限拒绝之后忘记做清理工作了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过参考其他浏览器的实现，相信对你来说解决这个问题是没太多难度的。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;从这个事件，我们可以发现，我们很多时候不需要做第一个吃螃蟹的人。&lt;br/&gt;可以换个角度看问题，不要钻牛角尖。&lt;br/&gt;毕竟公司分配给你任务，是有一个时间的。&lt;br/&gt;不是让你去做研究的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5361063-98a905668adbace4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Jun 2018 06:40:00 +0000</pubDate>
<dc:creator>nesger</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nesger/p/9224206.html</dc:identifier>
</item>
<item>
<title>MVC路由深入详解1---IgnoreRoute - 小王子的博客</title>
<link>http://www.cnblogs.com/xiaowangzi1987/p/9224175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaowangzi1987/p/9224175.html</guid>
<description>&lt;h3&gt;引言&lt;/h3&gt;
&lt;p&gt;Reflector源码反编译工具软件是必备&lt;/p&gt;
&lt;h3&gt;一.由路由注册开始&lt;/h3&gt;
&lt;p&gt;严格的说Route不只属于MVC，MVC所有的请求都是通过路由规则去映射的，所以MVC的头等大事就是路由规则的注册。规则的注册时在Global.asax的Application_Start事件里注册，以下是默认的路由注册代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('26d77c0f-61cf-4b8b-8fe6-c800b5f143bd')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_26d77c0f-61cf-4b8b-8fe6-c800b5f143bd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_26d77c0f-61cf-4b8b-8fe6-c800b5f143bd&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('26d77c0f-61cf-4b8b-8fe6-c800b5f143bd',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_26d77c0f-61cf-4b8b-8fe6-c800b5f143bd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RouteConfig
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RegisterRoutes(RouteCollection routes)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             routes.IgnoreRoute(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{resource}.axd/{*pathInfo}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            routes.MapRoute(
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 url: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller}/{action}/{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 defaults: &lt;span&gt;new&lt;/span&gt; { controller = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, action = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, id =&lt;span&gt; UrlParameter.Optional }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            );
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;我们这篇文章的讲述内容以routes.IgnoreRoute(&quot;{resource}.axd/{*pathInfo}&quot;)深入学习&lt;/p&gt;
&lt;h3&gt;二.Application_Start的传参&lt;/h3&gt;
&lt;p&gt;               IgnoreRoute的方法参数传入是由Application_Start的RouteConfig.RegisterRoutes(RouteTable.Routes)传入。但是RouteConfig类中RegisterRoutes的参数却为RouteCollection，好吧，我们的工作开始了。我们先来看RouteTable有什么深处含义。&lt;/p&gt;
&lt;p&gt;               RouteTable源码：                  &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('83354c8a-d994-4f7f-b15b-9aa4acf18528')&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_83354c8a-d994-4f7f-b15b-9aa4acf18528&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_83354c8a-d994-4f7f-b15b-9aa4acf18528&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('83354c8a-d994-4f7f-b15b-9aa4acf18528',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_83354c8a-d994-4f7f-b15b-9aa4acf18528&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; RouteCollection _instance;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;static&lt;/span&gt;&lt;span&gt; RouteTable()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             _instance = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RouteCollection();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; RouteCollection Routes
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _instance; }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;                RouteTable是一个单例模式（如果不知道这个模式的同学可以去学习一下设计模式）,Routes是一个公共的静态属性，属性的类型是RouteCollection。这也是RouteConfig类中的RegisterRoutes的参数为RouteCollection的缘故。&lt;/p&gt;
&lt;h3&gt;三.RouteCollection的IgnoreRoute&lt;/h3&gt;
&lt;p&gt;                废话不多说，上源码（这个时候就是Reflection的厉害之处了）：         &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RouteCollection:Collection&amp;lt;RouteBase&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, RouteBase&amp;gt;&lt;span&gt; _namedMap;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ReaderWriterLock _rwLock;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RouteCollection()
        {
            _namedMap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, RouteBase&amp;gt;&lt;span&gt;(StringComparer.OrdinalIgnoreCase);
            _rwLock &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReaderWriterLock();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Ignore(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; url)
        {
            Ignore(url, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Ignore(&lt;span&gt;string&lt;/span&gt; url,&lt;span&gt;object&lt;/span&gt;&lt;span&gt; constraints)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (url == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArgumentNullException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            IgnoreRouteInternal item &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IgnoreRouteInternal(url)
            {
                Constraints&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Web.Routing.RouteValueDictionary(constraints)
            };
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.Add(item);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;                上源码中RouteCollection是一个泛型继承了RouteBase的集合类Collection。&lt;/p&gt;
&lt;h3&gt;四.IgnoreRouteInternal&lt;/h3&gt;
&lt;p&gt;                为了更好的深入了解，我们继续深入下去，现在看下IgnoreRouteInternal：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IgnoreRouteInternal:Route
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IgnoreRouteInternal(&lt;span&gt;string&lt;/span&gt; url):&lt;span&gt;base&lt;/span&gt;(url,&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StopRoutingHandler())
        {

        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;                可以看到，这是一个密封类，是不允许被继承的，但他却继承了Route，Route class是继承了RouteBase class。IgnoreRouteInternal有参构造函数调用的是Route的有参构造函数。&lt;/p&gt;
&lt;h3&gt;五.StopRoutingHandler&lt;/h3&gt;
&lt;p&gt;                我们先来拆开StopRoutingHandler 看一下：        &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StopRoutingHandler:System.Web.Routing.IRouteHandler
    {
        IHttpHandler System.Web.Routing.IRouteHandler.GetHttpHandler(System.Web.Routing.RequestContext requestContext)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.GetHttpHandler(requestContext);
        }
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; IHttpHandler GetHttpHandler(System.Web.Routing.RequestContext req)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotSupportedException();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;                StopRoutingHandler是个特殊的RouteHandler对象，它的作用只是告诉UrlRouteModule，虽然某个规则匹配成功了，但是也还是当什么没有发生，说白了，我们需要去忽略一些规则。&lt;/p&gt;
&lt;p&gt;                我们来看一下一个如何被忽略的例子,阻止路由处理.axd文件的请求。&lt;/p&gt;
&lt;p&gt;                    routes.Add(new Route(&quot;{resource}/.axd/{*pathInfo}&quot;,new StopRoutingHandler()));&lt;/p&gt;
&lt;h3&gt;六.IRouteHandler&lt;/h3&gt;
&lt;p&gt;                打打鸡血，我们继续来拆解IRouteHandler     &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     定义类必须实现才能处理匹配路由模式的请求的协定。&lt;/span&gt;
    [TypeForwardedFrom(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Web.Routing, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=31bf3856ad364e35&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IRouteHandler
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 摘要:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     提供处理请求的对象。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   requestContext:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     一个对象，封装有关请求的信息。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回结果:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     一个处理请求的对象。&lt;/span&gt;
        IHttpHandler GetHttpHandler(RequestContext requestContext);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;                IRouteHandler接口方法GetHttpHandler必须返回一个实现了IHttpHandler的信息，接受的参数类型为RequestContext，看到这个RequestContext，大家就会眼前一亮。这个是一个非常重要的点。&lt;/p&gt;
&lt;p&gt;                此处引入一位大神的Blog内容：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;singleposttitle&quot; href=&quot;https://www.cnblogs.com/Leo_wl/p/3380570.html&quot;&gt;深入解析路由系统架构原理&lt;/a&gt; -----&amp;gt;https://www.cnblogs.com/Leo_wl/p/3380570.html&lt;/p&gt;
&lt;h3&gt;七.Route&lt;/h3&gt;
&lt;p&gt;                我们回到第四步,public IgnoreRouteInternal(string url):base(url,new StopRoutingHandler())我们来看看Route的构造函数     &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Route:RouteBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _url;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; System.Web.Routing.IRouteHandler RouteHandler { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Route(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; url,System.Web.Routing.IRouteHandler routeHandler)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._url =&lt;span&gt; url;
            RouteHandler &lt;/span&gt;=&lt;span&gt; routeHandler;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; System.Web.Routing.RouteValueDictionary Constraints { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;八.base.Add(item)&lt;/h3&gt;
&lt;p&gt;                RouteCollection是一个集合类，默认集合，将IgnoreRouteInternal放入集合。&lt;/p&gt;

&lt;h3&gt;思维导图：&lt;/h3&gt;
&lt;p&gt;                &lt;img src=&quot;https://images2018.cnblogs.com/blog/1096235/201806/1096235-20180625143132521-131313610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; System.Web.dll文件反编译后的源码：&lt;a href=&quot;https://files.cnblogs.com/files/xiaowangzi1987/System.Web%E6%BA%90%E7%A0%81.rar&quot;&gt;System.Web.dll&lt;/a&gt;&lt;/p&gt;


</description>
<pubDate>Mon, 25 Jun 2018 06:32:00 +0000</pubDate>
<dc:creator>小王子的博客</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaowangzi1987/p/9224175.html</dc:identifier>
</item>
<item>
<title>POI生成EXCEL文件 - _herbert</title>
<link>http://www.cnblogs.com/yfrs/p/poiexcel.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yfrs/p/poiexcel.html</guid>
<description>&lt;h2 id=&quot;poi生成excel文件&quot;&gt;POI生成EXCEL文件&lt;/h2&gt;
&lt;h2 id=&quot;一背景&quot;&gt;一、背景&lt;/h2&gt;
&lt;p&gt;根据指定格式的&lt;code&gt;JSON&lt;/code&gt;文件生成对应的&lt;code&gt;excel&lt;/code&gt;文件，需求如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持多sheet&lt;/li&gt;
&lt;li&gt;支持单元格合并&lt;/li&gt;
&lt;li&gt;支持插入图片&lt;/li&gt;
&lt;li&gt;支持单元格样式可定制&lt;/li&gt;
&lt;li&gt;需要 标题(title)，表头(head)，数据(data) ，表尾(foot) 明确区分&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二效果预览&quot;&gt;二、效果预览&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/392126/201806/392126-20180625133322079-1479325597.png&quot; alt=&quot;demo图,qq:464884492&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三数据格式&quot;&gt;三、数据格式&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;由于是生成Excel文件，这里值考虑生成xlsx格式的Excel文件，数据多表头默认考虑使用 | 表示，不在使用colspan rowspan作为。如需要表示两列两行，第一列合并表头格式为: A|B,A|C生成的表格为&lt;br/&gt;&lt;/p&gt;
&lt;br/&gt;前端通过post的方式将需要生成的数据构造成符合要求的JSON文件提交跟后台。根据以上需求定义JSON格式如下&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;saveName&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;生成Excel的文件名.xlsx&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;userStyles&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//不能出现重复，在需要设置单元样式的地方，可以直接将style赋值为此值&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&quot;style&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;font&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//设置字体基本格式&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;&quot;blod&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//是否加粗&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;&quot;italic&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//是否倾斜&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;&quot;color&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;#FF0000&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//字体颜色&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;微软雅黑&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//字体名称&lt;/span&gt;
                &lt;span class=&quot;st&quot;&gt;&quot;height&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//大小&lt;/span&gt;
             &lt;span class=&quot;op&quot;&gt;},&lt;/span&gt; 
            &lt;span class=&quot;st&quot;&gt;&quot;fmtStr&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//单元格格式，#,##0.00_);#,##0.00;0 千分位&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;align&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//水平对齐方式 left right center&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;valign&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//垂直对齐方式 top center bottom&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;borderColor&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//设置边框颜色 如 #FF0000&lt;/span&gt;
            &lt;span class=&quot;st&quot;&gt;&quot;bgColor&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//设置单元格填充颜色 &lt;/span&gt;
        &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;sheets&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&quot;sheetName&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//sheet名称&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;// 对应Sheet标题区域数据&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&quot;titleMerge&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//对应Sheet标题区域合并信息&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&quot;head&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [&lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt;]&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//表头信息&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//数据信息&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&quot;dataMerge&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//数据合并信息&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&quot;foot&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//表尾信息&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&quot;footMerge&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; []&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//表尾合并信息&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&quot;img&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; [] &lt;span class=&quot;co&quot;&gt;//图片信息，需要将图片转换base64&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;]
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简要说明&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;head 数组中为JSON对象格式为&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;A|B&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//表头名称，多表头用|分割&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;str&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//此列数据类型 str num ,在excel中日期也是数字类型，通过fmtStr,显示为日期格式&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;field&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;F_FIELD1&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//备用字段，可不用&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;style&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//此列数据为列默认样式，可以是Style对象，也可以是在userStyles中定义的id值&lt;/span&gt;
        &lt;span class=&quot;st&quot;&gt;&quot;align&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;center&quot;&lt;/span&gt;
    &lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;在数组 title data foot 中，列表中的数据，可以是一个单独的值如 1,&quot;a&quot;，也可以是一个对象，当为对象时，格式为&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;value&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//单元格具体的值&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;type&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;co&quot;&gt;//单元格类型，默认str &lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;style&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//单元格样式 可以是Style对象，也可以是在userStyles中定义的id值，如果没设置，默认取head总此列对应的style&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;titleMerge、dataMerge、footMerge数组值为逗号分隔的字符串，其含义为&lt;code&gt;&quot;开始行，结束行，开始列，结束列&quot;&lt;/code&gt;，索引从0开始。如在title中有两行三列数据，现在需要合并一行两列数据对应的值为&lt;code&gt;&quot;0，0，0，1&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;img数组中值为对象，格式&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode javascript&quot;&gt;
&lt;code class=&quot;sourceCode javascript&quot;&gt;&lt;span class=&quot;op&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;col&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//图片开始列&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;row&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//开始行&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;colSpan&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;co&quot;&gt;//列跨度，最小值1&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;rowSpan&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//行跨度，最小值1&lt;/span&gt;
    &lt;span class=&quot;st&quot;&gt;&quot;data&quot;&lt;/span&gt;&lt;span class=&quot;op&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;co&quot;&gt;//base64图片数据如: &quot;data:image/png;base64,iVBO...ggg==&quot;&lt;/span&gt;
&lt;span class=&quot;op&quot;&gt;}&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;四关键实现&quot;&gt;四、关键实现&lt;/h2&gt;
&lt;p&gt;07以后的Excle文件，其实是一个压缩包，里边是一个个的xml文件，其中每一个sheet是一个xml文件，样式是一个xml文件，图片是对应的图片文件，放在media文件夹中，所以，代码思路依次为&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;构建 XSSFWorkbook 对象&lt;/li&gt;
&lt;li&gt;生成样式&lt;/li&gt;
&lt;li&gt;依次生成，title head data foot 行数据&lt;/li&gt;
&lt;li&gt;依次处理合并信息 titlemerge datamerge footmerge&lt;/li&gt;
&lt;li&gt;添加图片信息&lt;/li&gt;
&lt;li&gt;输出文件流&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;功能代码如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;27&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;buildOutputStream&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; FileProducerException {
        &lt;span class=&quot;co&quot;&gt;// 处理传入的JSON数据&lt;/span&gt;
        sheets = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;jsonData&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getJSONArray&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SHEETS&lt;/span&gt;);
        Iterator&amp;lt;Object&amp;gt; sheetIter = sheets.&lt;span class=&quot;fu&quot;&gt;iterator&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (sheets.&lt;span class=&quot;fu&quot;&gt;isEmpty&lt;/span&gt;()) {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;responseData&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;setErrcode&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1001&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;responseData&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;setSuccess&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;responseData&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;setErrmsg&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;无数据可生成&quot;&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;FileProducerException&lt;/span&gt;();
        }
        wb = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;XSSFWorkbook&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;// 建立全局格式&lt;/span&gt;
        JSONArray userStyles = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;jsonData&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getJSONArray&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;USERSTYLES&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;initUserStyles&lt;/span&gt;(userStyles);
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;initDefaultHeadStyle&lt;/span&gt;();

        XSSFSheet ws;
        JSONObject sheet;
        JSONArray sheetData;
        JSONArray sheetTitle;
        JSONArray sheetHead;
        JSONArray sheetFoot;
        JSONArray sheetImgs;

        String sheetName;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sheetIndex = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (sheetIter.&lt;span class=&quot;fu&quot;&gt;hasNext&lt;/span&gt;()) {
            sheet = (JSONObject) sheetIter.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;// 获取sheet名称&lt;/span&gt;
            sheetName = sheet.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SHEET_NAME&lt;/span&gt;);
            ws = wb.&lt;span class=&quot;fu&quot;&gt;createSheet&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (StringUtils.&lt;span class=&quot;fu&quot;&gt;isNotBlank&lt;/span&gt;(sheetName)) {
                wb.&lt;span class=&quot;fu&quot;&gt;setSheetName&lt;/span&gt;(sheetIndex, sheetName);
            }
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sheetRowIndex = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
            sheetTitle = sheet.&lt;span class=&quot;fu&quot;&gt;getJSONArray&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SHEET_TITLE&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;setMergeCells&lt;/span&gt;(ws, sheet.&lt;span class=&quot;fu&quot;&gt;getJSONArray&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SHEET_TITLE_MERGE&lt;/span&gt;),
                    sheetRowIndex);
            sheetRowIndex = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;createRandom&lt;/span&gt;(ws, sheetTitle, sheetRowIndex);

            sheetHead = sheet.&lt;span class=&quot;fu&quot;&gt;getJSONArray&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SHEET_HEAD&lt;/span&gt;);
            sheetRowIndex = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;createHeadColumn&lt;/span&gt;(ws, sheetHead, sheetRowIndex);

            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;setMergeCells&lt;/span&gt;(ws, sheet.&lt;span class=&quot;fu&quot;&gt;getJSONArray&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SHEET_DATA_MERGE&lt;/span&gt;),
                    sheetRowIndex);
            sheetData = sheet.&lt;span class=&quot;fu&quot;&gt;getJSONArray&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SHEET_DATA&lt;/span&gt;);
            sheetRowIndex = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;createData&lt;/span&gt;(ws, sheetData, sheetRowIndex);

            sheetFoot = sheet.&lt;span class=&quot;fu&quot;&gt;getJSONArray&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SHEET_FOOT&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;setMergeCells&lt;/span&gt;(ws, sheet.&lt;span class=&quot;fu&quot;&gt;getJSONArray&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SHEET_FOOT_MERGE&lt;/span&gt;),
                    sheetRowIndex);
            sheetRowIndex = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;createRandom&lt;/span&gt;(ws, sheetFoot, sheetRowIndex);

            sheetImgs = sheet.&lt;span class=&quot;fu&quot;&gt;getJSONArray&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SHEET_IMG&lt;/span&gt;);

            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;setSheetImages&lt;/span&gt;(ws, sheetImgs);
        }

        &lt;span class=&quot;co&quot;&gt;// 返回输出流&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            ByteArrayOutputStream os = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ByteArrayOutputStream();
            wb.&lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(os);
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;outStreams&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(os);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (IOException e) {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;FileProducerException&lt;/span&gt;(e.&lt;span class=&quot;fu&quot;&gt;getMessage&lt;/span&gt;(), e.&lt;span class=&quot;fu&quot;&gt;getCause&lt;/span&gt;());
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成单元格样式对象，包括&lt;code&gt;字体&lt;/code&gt; &lt;code&gt;边框&lt;/code&gt; &lt;code&gt;背景&lt;/code&gt; &lt;code&gt;对齐方式&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; XSSFCellStyle &lt;span class=&quot;fu&quot;&gt;createCellStyle&lt;/span&gt;(JSONObject style) {

        XSSFCellStyle cellStyle = wb.&lt;span class=&quot;fu&quot;&gt;createCellStyle&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;// 设置字体&lt;/span&gt;
        JSONObject font = style.&lt;span class=&quot;fu&quot;&gt;getJSONObject&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;STYLE_FONT&lt;/span&gt;);
        Font excelFont = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;createFont&lt;/span&gt;(font);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (excelFont != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            cellStyle.&lt;span class=&quot;fu&quot;&gt;setFont&lt;/span&gt;(excelFont);
        }
        &lt;span class=&quot;co&quot;&gt;// border统一黑色&lt;/span&gt;
        cellStyle.&lt;span class=&quot;fu&quot;&gt;setBorderBottom&lt;/span&gt;(BorderStyle.&lt;span class=&quot;fu&quot;&gt;THIN&lt;/span&gt;);
        cellStyle.&lt;span class=&quot;fu&quot;&gt;setBorderTop&lt;/span&gt;(BorderStyle.&lt;span class=&quot;fu&quot;&gt;THIN&lt;/span&gt;);
        cellStyle.&lt;span class=&quot;fu&quot;&gt;setBorderLeft&lt;/span&gt;(BorderStyle.&lt;span class=&quot;fu&quot;&gt;THIN&lt;/span&gt;);
        cellStyle.&lt;span class=&quot;fu&quot;&gt;setBorderRight&lt;/span&gt;(BorderStyle.&lt;span class=&quot;fu&quot;&gt;THIN&lt;/span&gt;);

        String borderColor = style.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;BORDER_COLOR&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (StringUtils.&lt;span class=&quot;fu&quot;&gt;isNotBlank&lt;/span&gt;(borderColor)) {
            XSSFColor xfBorderColor = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;XSSFColor&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Color(Integer.&lt;span class=&quot;fu&quot;&gt;parseInt&lt;/span&gt;(
                    borderColor.&lt;span class=&quot;fu&quot;&gt;substring&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;)));
            cellStyle.&lt;span class=&quot;fu&quot;&gt;setBorderColor&lt;/span&gt;(BorderSide.&lt;span class=&quot;fu&quot;&gt;BOTTOM&lt;/span&gt;, xfBorderColor);
            cellStyle.&lt;span class=&quot;fu&quot;&gt;setBorderColor&lt;/span&gt;(BorderSide.&lt;span class=&quot;fu&quot;&gt;TOP&lt;/span&gt;, xfBorderColor);
            cellStyle.&lt;span class=&quot;fu&quot;&gt;setBorderColor&lt;/span&gt;(BorderSide.&lt;span class=&quot;fu&quot;&gt;LEFT&lt;/span&gt;, xfBorderColor);
            cellStyle.&lt;span class=&quot;fu&quot;&gt;setBorderColor&lt;/span&gt;(BorderSide.&lt;span class=&quot;fu&quot;&gt;RIGHT&lt;/span&gt;, xfBorderColor);
        }
        &lt;span class=&quot;co&quot;&gt;// 背景色&lt;/span&gt;
        String bgColor = style.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;BACKGROUND_COLOR&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (StringUtils.&lt;span class=&quot;fu&quot;&gt;isNotBlank&lt;/span&gt;(bgColor)) {
            XSSFColor cellBgColor = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;XSSFColor&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Color(Integer.&lt;span class=&quot;fu&quot;&gt;parseInt&lt;/span&gt;(
                    bgColor.&lt;span class=&quot;fu&quot;&gt;substring&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;)));
            cellStyle.&lt;span class=&quot;fu&quot;&gt;setFillForegroundColor&lt;/span&gt;(cellBgColor);
            cellStyle.&lt;span class=&quot;fu&quot;&gt;setFillPattern&lt;/span&gt;(FillPatternType.&lt;span class=&quot;fu&quot;&gt;SOLID_FOREGROUND&lt;/span&gt;);
        }
        &lt;span class=&quot;co&quot;&gt;// 对齐方式&lt;/span&gt;
        String hAlignment = style.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;HALIGNMENT&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (StringUtils.&lt;span class=&quot;fu&quot;&gt;isNotBlank&lt;/span&gt;(hAlignment))
            cellStyle.&lt;span class=&quot;fu&quot;&gt;setAlignment&lt;/span&gt;(HorizontalAlignment.&lt;span class=&quot;fu&quot;&gt;valueOf&lt;/span&gt;(hAlignment
                    .&lt;span class=&quot;fu&quot;&gt;toUpperCase&lt;/span&gt;()));
        String vAlignment = style.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;VALIGNMENT&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (StringUtils.&lt;span class=&quot;fu&quot;&gt;isNotBlank&lt;/span&gt;(vAlignment))
            cellStyle.&lt;span class=&quot;fu&quot;&gt;setVerticalAlignment&lt;/span&gt;(VerticalAlignment.&lt;span class=&quot;fu&quot;&gt;valueOf&lt;/span&gt;(vAlignment
                    .&lt;span class=&quot;fu&quot;&gt;toUpperCase&lt;/span&gt;()));
        &lt;span class=&quot;co&quot;&gt;// 自动换行TRUE&lt;/span&gt;
        cellStyle.&lt;span class=&quot;fu&quot;&gt;setWrapText&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);

        &lt;span class=&quot;co&quot;&gt;// 格式&lt;/span&gt;
        String fmt = style.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;FMTSTRING&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (StringUtils.&lt;span class=&quot;fu&quot;&gt;isNotBlank&lt;/span&gt;(fmt))
            cellStyle.&lt;span class=&quot;fu&quot;&gt;setDataFormat&lt;/span&gt;(wb.&lt;span class=&quot;fu&quot;&gt;createDataFormat&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;getFormat&lt;/span&gt;(fmt));
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; cellStyle;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建字体样式&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Font &lt;span class=&quot;fu&quot;&gt;createFont&lt;/span&gt;(JSONObject fontCfg) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (fontCfg == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        XSSFFont font = wb.&lt;span class=&quot;fu&quot;&gt;createFont&lt;/span&gt;();
        font.&lt;span class=&quot;fu&quot;&gt;setFontName&lt;/span&gt;(fontCfg.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;FONT_NAME&lt;/span&gt;));
        Boolean fontBoole = fontCfg.&lt;span class=&quot;fu&quot;&gt;getBoolean&lt;/span&gt;(FONT_BLOD);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (fontBoole != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            font.&lt;span class=&quot;fu&quot;&gt;setBold&lt;/span&gt;(fontBoole.&lt;span class=&quot;fu&quot;&gt;booleanValue&lt;/span&gt;());
        fontBoole = fontCfg.&lt;span class=&quot;fu&quot;&gt;getBoolean&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;FONT_ITALIC&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (fontBoole != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            font.&lt;span class=&quot;fu&quot;&gt;setItalic&lt;/span&gt;(fontBoole.&lt;span class=&quot;fu&quot;&gt;booleanValue&lt;/span&gt;());
        fontBoole = fontCfg.&lt;span class=&quot;fu&quot;&gt;getBoolean&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;FONT_UNDERLINE&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (fontBoole != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; fontBoole.&lt;span class=&quot;fu&quot;&gt;booleanValue&lt;/span&gt;() == &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;)
            font.&lt;span class=&quot;fu&quot;&gt;setUnderline&lt;/span&gt;(FontUnderline.&lt;span class=&quot;fu&quot;&gt;SINGLE&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getByteValue&lt;/span&gt;());
        Short fontHeight = fontCfg.&lt;span class=&quot;fu&quot;&gt;getShort&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;FONT_HEIGHT&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (fontHeight != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            font.&lt;span class=&quot;fu&quot;&gt;setFontHeightInPoints&lt;/span&gt;(fontHeight);
        String colorStr = fontCfg.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;FONT_COLOR&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (colorStr != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            font.&lt;span class=&quot;fu&quot;&gt;setColor&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;XSSFColor&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Color(Integer.&lt;span class=&quot;fu&quot;&gt;parseInt&lt;/span&gt;(
                    colorStr.&lt;span class=&quot;fu&quot;&gt;substring&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;), &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;))));
        }
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; font;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;处理表头,表过多表头处理，采用 | 分割的方式，传入head长度为列数据，name中有几个 | 就知道表头有几行。所以针对表头处理有以下几个步骤&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成默认列样式&lt;/li&gt;
&lt;li&gt;填充所有列数据，求出最大行数&lt;/li&gt;
&lt;li&gt;横向合并内容相同的单元&lt;/li&gt;
&lt;li&gt;纵向合并空白的单元格&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;30&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;createHeadColumn&lt;/span&gt;(XSSFSheet ws, JSONArray sheetHead,
            &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sheetRowIndex) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (sheetHead == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; sheetRowIndex;
        Iterator&amp;lt;Object&amp;gt; headIter = sheetHead.&lt;span class=&quot;fu&quot;&gt;iterator&lt;/span&gt;();
        JSONObject curHead = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; colIndex = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        Object colStyle = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; colSize = sheetHead.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;();
        headTypes = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String[colSize];
        headCellStyleKeys = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String[colSize];
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[] headColLevel = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;[colSize];
        String colName = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        String[] colNameAry = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; maxLevel = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; colLevel = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        XSSFCell headCell = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        ArrayList&amp;lt;ArrayList&amp;lt;String&amp;gt;&amp;gt; headValueList = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;ArrayList&amp;lt;String&amp;gt;&amp;gt;();
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (headIter.&lt;span class=&quot;fu&quot;&gt;hasNext&lt;/span&gt;()) {
            curHead = (JSONObject) headIter.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;// 处理默认样式&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (curHead.&lt;span class=&quot;fu&quot;&gt;containsKey&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;COLUMN_STYLE&lt;/span&gt;)) {
                colStyle = curHead.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;COLUMN_STYLE&lt;/span&gt;);
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (colStyle &lt;span class=&quot;kw&quot;&gt;instanceof&lt;/span&gt; JSONObject) {
                    headCellStyleKeys[colIndex] = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;COLUMNSTYLE_PREV&lt;/span&gt;
                            + colIndex;
                    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;userStyles&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;put&lt;/span&gt;(headCellStyleKeys[colIndex],
                            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;createCellStyle&lt;/span&gt;((JSONObject) colStyle));
                } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;userStyles&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;containsKey&lt;/span&gt;(colStyle)) {
                    headCellStyleKeys[colIndex] = (String) colStyle;
                }
            }
            &lt;span class=&quot;co&quot;&gt;// 处理默认列宽&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (curHead.&lt;span class=&quot;fu&quot;&gt;containsKey&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;COLUMN_WIDTH&lt;/span&gt;)) {
                ws.&lt;span class=&quot;fu&quot;&gt;setDefaultColumnWidth&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;pixToExcelWdith&lt;/span&gt;(curHead
                        .&lt;span class=&quot;fu&quot;&gt;getIntValue&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;COLUMN_WIDTH&lt;/span&gt;)));
            }
            &lt;span class=&quot;co&quot;&gt;// 保存列样式&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (curHead.&lt;span class=&quot;fu&quot;&gt;containsKey&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;COLUMN_TYPE&lt;/span&gt;)) {
                headTypes[colIndex] = curHead.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;COLUMN_TYPE&lt;/span&gt;);
            } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                headTypes[colIndex] = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;CELLTYPESTRING&lt;/span&gt;;
            }
            &lt;span class=&quot;co&quot;&gt;// 处理多表头&lt;/span&gt;
            colName = curHead.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;COLUMN_NAME&lt;/span&gt;);
            colNameAry = colName.&lt;span class=&quot;fu&quot;&gt;split&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;\\&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;|&quot;&lt;/span&gt;);
            colLevel = colNameAry.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;;
            headColLevel[colIndex] = colLevel;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (colLevel &amp;gt; maxLevel) {
                maxLevel = colLevel;
            }
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; colLevel; i++) {
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (headValueList.&lt;span class=&quot;fu&quot;&gt;size&lt;/span&gt;() &amp;lt;= i) {
                    headValueList.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;String&amp;gt;());
                }
                headValueList.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(i).&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(colIndex, colNameAry[i]);
                XSSFRow row = ws.&lt;span class=&quot;fu&quot;&gt;getRow&lt;/span&gt;(sheetRowIndex + i);
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (row == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
                    row = ws.&lt;span class=&quot;fu&quot;&gt;createRow&lt;/span&gt;(sheetRowIndex + i);
                }
                headCell = row.&lt;span class=&quot;fu&quot;&gt;createCell&lt;/span&gt;(colIndex);
                headCell.&lt;span class=&quot;fu&quot;&gt;setCellValue&lt;/span&gt;(colNameAry[i]);
                headCell.&lt;span class=&quot;fu&quot;&gt;setCellStyle&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;userStyles&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;HEADSTYLE_KEY&lt;/span&gt;));
            }
            colIndex++;
        }

        &lt;span class=&quot;co&quot;&gt;// 横向合并&lt;/span&gt;
        Iterator&amp;lt;ArrayList&amp;lt;String&amp;gt;&amp;gt; a = headValueList.&lt;span class=&quot;fu&quot;&gt;iterator&lt;/span&gt;();
        JSONArray headMerge = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;JSONArray&lt;/span&gt;();
        String prev = &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;;
        String curent = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; lRowIndex = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; startCol = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; mergeCol = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
        ArrayList&amp;lt;String&amp;gt; columnInfo = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (a.&lt;span class=&quot;fu&quot;&gt;hasNext&lt;/span&gt;()) {
            startCol = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
            mergeCol = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
            prev = &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;;
            columnInfo = a.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;();
            &lt;span class=&quot;co&quot;&gt;// 第三列才能知道，第一列和第二列是否合并&lt;/span&gt;
            columnInfo.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;);
            Iterator&amp;lt;String&amp;gt; b = columnInfo.&lt;span class=&quot;fu&quot;&gt;iterator&lt;/span&gt;();
            XSSFCell lastRowCell = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (b.&lt;span class=&quot;fu&quot;&gt;hasNext&lt;/span&gt;()) {
                curent = b.&lt;span class=&quot;fu&quot;&gt;next&lt;/span&gt;();
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (lRowIndex &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                    lastRowCell = ws.&lt;span class=&quot;fu&quot;&gt;getRow&lt;/span&gt;(sheetRowIndex + lRowIndex - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;)
                            .&lt;span class=&quot;fu&quot;&gt;getCell&lt;/span&gt;(startCol);
                }
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (prev.&lt;span class=&quot;fu&quot;&gt;equalsIgnoreCase&lt;/span&gt;(curent) &amp;amp;&amp;amp; lRowIndex == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                    ws.&lt;span class=&quot;fu&quot;&gt;getRow&lt;/span&gt;(sheetRowIndex + lRowIndex).&lt;span class=&quot;fu&quot;&gt;getCell&lt;/span&gt;(startCol)
                            .&lt;span class=&quot;fu&quot;&gt;setCellType&lt;/span&gt;(Cell.&lt;span class=&quot;fu&quot;&gt;CELL_TYPE_BLANK&lt;/span&gt;);
                    mergeCol++;
                } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (prev.&lt;span class=&quot;fu&quot;&gt;equalsIgnoreCase&lt;/span&gt;(curent)
                        &amp;amp;&amp;amp; lRowIndex &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;
                        &amp;amp;&amp;amp; StringUtils
                                .&lt;span class=&quot;fu&quot;&gt;isBlank&lt;/span&gt;(lastRowCell.&lt;span class=&quot;fu&quot;&gt;getStringCellValue&lt;/span&gt;())) {
                    ws.&lt;span class=&quot;fu&quot;&gt;getRow&lt;/span&gt;(sheetRowIndex + lRowIndex).&lt;span class=&quot;fu&quot;&gt;getCell&lt;/span&gt;(startCol)
                            .&lt;span class=&quot;fu&quot;&gt;setCellType&lt;/span&gt;(Cell.&lt;span class=&quot;fu&quot;&gt;CELL_TYPE_BLANK&lt;/span&gt;);
                    mergeCol++;
                } &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (mergeCol &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; startCol &amp;gt; &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;) {
                        headMerge.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, lRowIndex,
                                lRowIndex, startCol - mergeCol - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,
                                startCol - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;));
                        mergeCol = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
                    }
                }
                startCol++;
                prev = curent;
            }
            lRowIndex++;
        }
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; colSize; i++) {
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (headColLevel[i] &amp;lt; maxLevel) { &lt;span class=&quot;co&quot;&gt;// 存在列合并&lt;/span&gt;
                headMerge.&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(String&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;ch&quot;&gt;%d&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;&lt;/span&gt;, headColLevel[i] - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;,
                        maxLevel - &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;, i, i));
                &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; r = headColLevel[i]; r &amp;lt; maxLevel; r++) {
                    ws.&lt;span class=&quot;fu&quot;&gt;getRow&lt;/span&gt;(sheetRowIndex + r)
                            .&lt;span class=&quot;fu&quot;&gt;createCell&lt;/span&gt;(i)
                            .&lt;span class=&quot;fu&quot;&gt;setCellStyle&lt;/span&gt;(
                                    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;userStyles&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;HEADSTYLE_KEY&lt;/span&gt;));
                }
            }
        }

        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;setMergeCells&lt;/span&gt;(ws, headMerge, sheetRowIndex);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; sheetRowIndex + maxLevel;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加图片,默认采用单元格描点方式，将图片固定指定的单元格区域内&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;addImg&lt;/span&gt;(XSSFSheet ws, JSONObject img, XSSFCreationHelper cHelper) {
        String imgBase64 = img.&lt;span class=&quot;fu&quot;&gt;getString&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SHEET_IMG_DATA&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (StringUtils.&lt;span class=&quot;fu&quot;&gt;isBlank&lt;/span&gt;(imgBase64))
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt;;
        String[] imgary = imgBase64.&lt;span class=&quot;fu&quot;&gt;split&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;,&quot;&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(imgary[&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;]);
        &lt;span class=&quot;dt&quot;&gt;byte&lt;/span&gt;[] imgByte = Base64.&lt;span class=&quot;fu&quot;&gt;decodeBase64&lt;/span&gt;(imgary[&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;]);
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; imgIdx = wb.&lt;span class=&quot;fu&quot;&gt;addPicture&lt;/span&gt;(imgByte, Workbook.&lt;span class=&quot;fu&quot;&gt;PICTURE_TYPE_JPEG&lt;/span&gt;);
        XSSFDrawing drawImg = ws.&lt;span class=&quot;fu&quot;&gt;createDrawingPatriarch&lt;/span&gt;();
        XSSFClientAnchor anchor = cHelper.&lt;span class=&quot;fu&quot;&gt;createClientAnchor&lt;/span&gt;();
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; col = img.&lt;span class=&quot;fu&quot;&gt;getIntValue&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SHEET_IMG_COL&lt;/span&gt;);
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; row = img.&lt;span class=&quot;fu&quot;&gt;getIntValue&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SHEET_IMG_ROW&lt;/span&gt;);
        anchor.&lt;span class=&quot;fu&quot;&gt;setCol1&lt;/span&gt;(col);
        anchor.&lt;span class=&quot;fu&quot;&gt;setRow1&lt;/span&gt;(row);
        XSSFPicture pict = drawImg.&lt;span class=&quot;fu&quot;&gt;createPicture&lt;/span&gt;(anchor, imgIdx);
        Integer colSpan = img.&lt;span class=&quot;fu&quot;&gt;getInteger&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SHEET_IMG_COLSPAN&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (colSpan == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            colSpan = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
        Integer rowSpan = img.&lt;span class=&quot;fu&quot;&gt;getInteger&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SHEET_IMG_ROWSPAN&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (rowSpan == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            rowSpan = &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;;
        pict.&lt;span class=&quot;fu&quot;&gt;resize&lt;/span&gt;(colSpan, rowSpan);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;五总结&quot;&gt;五、总结&lt;/h2&gt;
&lt;p&gt;这次通过传入JSON对象生成样式丰富的excel文件，对于POI操作office文档又更加熟悉一些。相对于解析excel文档，生成就不用考虑文件格式，如：兼容2003格式，考虑大文件sax方式解析。相对于js前端生成excel文件，增加了对生成后文件二次加工的可能性，所以在功能入口中，采用了生成二进制流的方式。文件生成好后，可以继续发送邮件，上传ftp等操作。&lt;br/&gt;重点说明&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于各数据区域数据，保持区域数据独立性（数据索引值）&lt;/li&gt;
&lt;li&gt;对于图片开始行和开始列，索引值是针对一个完整的sheet&lt;/li&gt;
&lt;li&gt;对于表头区域，多表头采用 | 分割，减少部分传输数据&lt;/li&gt;
&lt;li&gt;excel中style为所有sheet共享样式。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 25 Jun 2018 05:40:00 +0000</pubDate>
<dc:creator>_herbert</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yfrs/p/poiexcel.html</dc:identifier>
</item>
<item>
<title>信号和槽：Qt中最差劲的创造 - 尧思齐</title>
<link>http://www.cnblogs.com/tr0217/p/9223937.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tr0217/p/9223937.html</guid>
<description>&lt;p&gt;不要被这个标题唬住了，实际上我是非常认可Qt的。在C++实现的开源产品中没有哪一个的API风格比得上Qt，拥有高度一致性，符合常识，符合直觉，几乎不用学就可以直接上手。或许是由于我们摆脱不了马太效应的控制，赞誉已经给到了Qt的缺陷。Qt的最大问题就是提供了uic和moc。界面设计器生成xml文件，需要uic编译它生成C++代码；组织界面的C++代码其实一点都不复杂，完全可以由界面设计器直接生成。可以给Qt找到需要uic的理由——实现了分工，可以并行，为设计器开发团队屏蔽了C++语法的复杂性。然而，uic相对于界面设计器来说，工作量几乎可以忽略不记，在管理实践上如此不平衡的分工没有任何意义，并行也就说不过去了。组织界面的C++代码完全掌控在Qt团队手里，完全可以用最简单的方式实现（uic生成的c++代码也确实非常简单），这样一来也没有什么“C++语法的复杂性”需要屏蔽了。如果uic对用户来说没有坏处，仅仅给Qt团队增加了工作量，也就无可非议了。但是，uic集成到第三方开发工具中时，导致设计器创建的界面，不能及时生成为C++代码，必须手动执行一下uic。&lt;/p&gt;
&lt;p&gt;uic跟moc比起来，就是小巫见大巫了。提供moc的原因，很大一部分是因为信号和槽机制。每每听到有人带着无比崇敬的态度布道Qt的信号和槽机制，真希望他们能知道信号和槽到底为了什么而存在。还是先来看一段Qt的代码吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
class QDataSourceWidget : public QTreeView
{
        Q_OBJECT
public:
        explicit QDataSourceWidget(QWidget *parent = 0);
        ~QDataSourceWidget();

signals:
        void LayerAdded(IMapPtr, ILayerPtr, ILayerProviderPtr);

protected:
    virtual void LayerAddEvent(IMapPtr map, ILayerPtr layer, ILayerProviderPtr provider)
    {
        emit LayerAdded(map,layer,layerProvider);
    }

private slots:
        void NodeDoubleClicked(const QModelIndex &amp;amp;index)
    {
        ...
        LayerAddEvent(map,layer,provider);
    }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码要完成这样一个功能：当表示数据源的QTreeView的节点双击时，打开数据，为数据创建一个可视化图层添加到map中，然后对外发布一个已经添加新图层的消息。很简单的一个功能，看看为了实现它Qt提供了些什么？4个扩展关键字——Q_OBJECT、signals、slots、emit；3个需要注册到QMetaTypes的自定义类型IMapPtr、ILayerPtr、ILayerProviderPtr（这3种类型实际上是另外3种类型的指针，但是必须得typedef才能注册到QMetaTypes中）；1个元编译器moc。&lt;/p&gt;
&lt;p&gt;非常代价高昂的解决方案，连编译器这种重型武器都上场了。为什么需要编译器？这段代码已经不可以再被称作C++了，就像.NET平台下的c++ cli一样，已经基于C++扩展出了一门新语言。众所周知C++的编译器非常难写，通常新标准发布10年之后都不被完全支持，这跟&lt;strong&gt;C++语义重载过多、语法自相矛盾、机制过于复杂&lt;/strong&gt;不无关系。元编译器没有直接生成机器码，而是将“Qt c++”编译成了能够实现信号和槽机制的标准C++，再由C++编译器编译成机器码。这种方案确实避免了面对不同架构不同版本CPU的麻烦，但是仍然需要面对“Qt c++”中的C++成分。这就是偶尔会遇到元编译器执行失败、元编译器生成的C++代码编译不过的原因。这些现象在新版本Qt中确有很大改观，但是C++标准委员会并没有浪子回头的意思，元编译器即将面对的是更多语义重载、更多语法矛盾、更复杂的机制。&lt;/p&gt;
&lt;p&gt;其实“Qt c++”也没怎么扩展标准C++，就多了4个关键字而已，而这4个关键字就是要派重武器——编译器——上场的罪魁祸首之一。这4个关键字还起了另外一个坏作用，让针对标准C++的代码自动格式化、代码自动完成失效了。对于需要注册QMetaTypes倒没有什么好抱怨的，毕竟带来了其它好处。&lt;/p&gt;
&lt;p&gt;那么Qt以如此之高代价实现的信号和槽机制到底是什么高档玩意呢？说白了就是一种发布/订阅机制而已，对于&lt;strong&gt;没有从语言层面上支持调用栈上的发布/订阅机制&lt;/strong&gt;的编程语言来说，一般通过两种方式来实现——Listener模式和回调函数。java swing就是典型的Listener模式，这个很显然；如果说MFC的Message Map是回调函数，可能会遇到争议。Message Map提供了消息码到消息处理函数指针的映射，消息循环从Message Map中查找到处理某个消息的所有函数指针，然后依次调用。消息循环是框架提供的，只是通过Message Map的形式传进去一个函数指针而已，虽然没有直接调用SetXXXCallBack，不影响它仍然是回调函数。&lt;/p&gt;
&lt;p&gt;Qt为何弃这两种方式不用呢？确实有说得过去的理由。首先，C++没有匿名类，没有垃圾回收机制。如果采用Listener模式，必须得为每个不同签名的消息至少定义一个类，必须得合理地管理这些Listener的生命周期。MFC的Message Map方式，需要在代码中写很多宏，在不考虑代码自动完成时，显然只写下signals和slots两个关键字更为方便。从而，Qt便仓促地选择了由GTK发明的信号和槽的概念。（注：这是笔者帮Qt想的理由，是否还有其它理由笔者没有深入了解。）MFC的Message Map还是有他的拥趸的，wxWidgets便是其中较为知名的一员。&lt;/p&gt;
&lt;p&gt;其实完全可以通过C++实现比Message Map更好的回调机制。在提出实现方式之前先明确一下需求和约束。&lt;/p&gt;
&lt;p&gt;首先是需求，第一，订阅方可以是成员函数、静态函数、C函数、仿函数；第二，发布方可以支持多个订阅者同时订阅。如果满足这两条需求就已经比Qt的信号和槽机制要强大了。&lt;/p&gt;
&lt;p&gt;当然也有一些约束，第一，既然发布方可以支持多个订阅者同时订阅，那么发布方若要采纳订阅者的返回值的话到底应该采纳哪一个的，这是个问题，所以干脆让订阅者全都返回void（Qt目前支持返回非void类型，但是有什么卵用他们内部仍然有争议）；第二，轻量级，不用stl，不用boost（不用boost还说得过去，stl毕竟是c++的标准库。我有我的理由，C++的缺陷导致编译器特别难写，可以说在模板方面找不到实现地完全正确的编译器。一些编译器不能正确的为静态的或者全局的模板类变量生成构造代码，这应该是Google代码规范禁止这么做的原因，全局的和静态的类只能声明为指针，由程序员确保其被正确地构造出来。）。加上这两条约束，仍然不影响满足前两条需求的发布/订阅机制比Qt的信号和槽机制强大。&lt;/p&gt;
&lt;p&gt;接下来给出完全通过C++实现的比Message Map和信号/槽机制更强大更轻量级的回调实现机制。&lt;/p&gt;
&lt;p&gt;首先给出返回值是void类型可以代表成员函数、静态函数、C函数、仿函数的订阅者接口定义。这里用到了C++11的可变模板参数机制，只是为了方便而已。要支持C++98，可以用typelist机制或者直接多定义几个不同参数数量的模板。推荐用后者，typelist可能有些编译器支持不了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
template&amp;lt;typename ...Args&amp;gt;
struct IEventHandler
{
        virtual void operator()(Args&amp;amp;... args) = 0;

        IEventHandler() {};
        virtual ~IEventHandler() {};

private:
        IEventHandler(const IEventHandler &amp;amp;) = delete;
        IEventHandler &amp;amp;operator=(const IEventHandler &amp;amp;) = delete;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来支持静态函数、C函数、仿函数的订阅者实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
template&amp;lt;typename Callable, typename ...Args&amp;gt;
class CallableEventHandler : public IEventHandler&amp;lt;Args...&amp;gt;
{
public:
        CallableEventHandler(Callable handler)
        {
                _handler = handler;
        }

        virtual ~CallableEventHandler() {};

public:
        void operator()(Args&amp;amp;... args)
        {
                _handler(args...);
        }

private:
        Callable _handler;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后，支持成员函数的订阅者实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
template&amp;lt;typename T, typename ...Args&amp;gt;
class EventHandler : public IEventHandler&amp;lt;Args...&amp;gt;
{
public:
        typedef void(T::*Handler)(Args...);
        EventHandler(T* receiver, Handler handler)
        {
                _receiver = receiver;
                _handler = handler;
        }

        virtual ~EventHandler() {};

public:
        void operator()(Args&amp;amp;... args)
        {
                (_receiver-&amp;gt;*_handler)(args...);
        }

private:
        Handler _handler;
        T* _receiver;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，发布方实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;collapse:true;;gutter:true;&quot;&gt;
template&amp;lt;typename ...Args&amp;gt;
class Event
{
public:
        typedef IEventHandler&amp;lt;Args...&amp;gt;* Callable;

public:
        Event() 
        {
                _valid = false;
                _event = nullptr;
        };

        Event(const Callable&amp;amp; h)
        {
                _handler = h;
                _valid = true;
                _event = nullptr;
        }

        ~Event() 
        {
                if (_event != nullptr) 
                {
                        delete _event;
                }
        };

        const Event&amp;lt;Args...&amp;gt;&amp;amp; operator = (const Callable&amp;amp; h)
        {
                _handler = h;
                _valid = true;
                if (_event != nullptr)
                {
                        delete _event;
                        _event = nullptr;
                }

                return *this;
        }

        Event(const Event&amp;lt;Args...&amp;gt; &amp;amp; e)
        {
                this-&amp;gt;Add(e);
        }

        Event&amp;lt;Args...&amp;gt; &amp;amp;operator=(const Event&amp;lt;Args...&amp;gt; &amp;amp; e)
        {
                _valid = false;
                if (_event != nullptr)
                {
                        delete _event;
                        _event = nullptr;
                }

                this-&amp;gt;Add(e);

                return *this;
        }

public:
        void Raise(Args&amp;amp;... args)
        {
                if (_valid)
                {
                        (*_handler)(args...);
                }
                if (_event != nullptr)
                {
                        _event-&amp;gt;Raise(args...);
                }
        }

        void operator()(Args&amp;amp;... args)
        {
                this-&amp;gt;Raise(args...);
        }

public:
        void Add(const Callable&amp;amp; h)
        {
                if (_valid)
                {
                        if (_event != nullptr)
                        {
                                _event-&amp;gt;Add(h);
                        }
                        else
                        {
                                _event = new Event&amp;lt;Args...&amp;gt;(h);
                        }
                }
                else
                {
                        _handler = h;
                        _valid = true;
                }
        }

        void Remove(const Callable&amp;amp; h)
        {
                if (_valid &amp;amp;&amp;amp; _handler == h)
                {
                        if (_event == nullptr)
                        {
                                _valid = false;
                        }
                        else
                        {
                                Event&amp;lt;Args...&amp;gt;* event_ = _event;
                                _valid = _event-&amp;gt;_valid;
                                _handler = _event-&amp;gt;_handler;
                                _event = _event-&amp;gt;_event;

                                event_-&amp;gt;_event = nullptr;
                                delete event_;                          
                        }
                }
                else if (_event != nullptr)
                {
                        _event-&amp;gt;Remove(h);
                }
        }

        void Add(const Event&amp;lt;Args...&amp;gt;&amp;amp; e)
        {
                Event&amp;lt;Args...&amp;gt;* event_ = const_cast&amp;lt;Event&amp;lt;Args...&amp;gt;*&amp;gt;(&amp;amp;e);
                while (event_ != nullptr)
                {
                        if (event_-&amp;gt;_valid)
                        {
                                this-&amp;gt;Add(event_-&amp;gt;_handler);
                        }
                        event_ = event_-&amp;gt;_event;
                }
        }

        void Remove(const Event&amp;lt;Args...&amp;gt;&amp;amp; e)
        {
                Event&amp;lt;Args...&amp;gt;* event_ = const_cast&amp;lt;Event&amp;lt;Args...&amp;gt;*&amp;gt;(&amp;amp;e);
                while (event_ != nullptr)
                {
                        if (event_-&amp;gt;_valid)
                        {
                                this-&amp;gt;Remove(event_-&amp;gt;_handler);
                        }
                        event_ = event_-&amp;gt;_event;
                }
        }

public:

        const Event&amp;lt;Args...&amp;gt;&amp;amp; operator += (const Callable&amp;amp; h)
        {
                this-&amp;gt;Add(h);

                return *this;
        }

        const Event&amp;lt;Args...&amp;gt;&amp;amp; operator -= (const Callable&amp;amp; h)
        {
                this-&amp;gt;Remove(h);

                return *this;
        }

        const Event&amp;lt;Args...&amp;gt;&amp;amp; operator += (const Event&amp;lt;Args...&amp;gt;&amp;amp; e)
        {
                this-&amp;gt;Add(e);

                return *this;
        }

        const Event&amp;lt;Args...&amp;gt;&amp;amp; operator -= (const Event&amp;lt;Args...&amp;gt;&amp;amp; e)
        {
                this-&amp;gt;Remove(e);

                return *this;
        }

private:
        bool _valid;
        Callable _handler;
        Event&amp;lt;Args...&amp;gt;* _event;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仅此而已，加上很多空白行才有不到300行代码。这是我在开源项目&lt;a href=&quot;https://github.com/tr0217/tGis&quot;&gt;tGis&lt;/a&gt;实现的发布/订阅机制，可以采用如下方式使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
Event SomeEvent;
EventHandler handler;
SomeEvent += &amp;amp;handler; // 绑定订阅者到发布者方式一
SomeEvent.Add(&amp;amp;handler); // 绑定订阅者到发布者方式二
SomeEvent += new EventHandler; // 要绑定订阅者到发布者方式三，暂不支持，会导致内存泄漏

SomeEvent(); // 触发事件方式一
SomeEvent.Raise(); //触发事件方式二
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，这个实现方式仍然有些不足。第一，参数不能是右值；触发事件的函数参数不能直接作为事件的参数，不能在事件参数上直接构造对象，而需要先声明个变量接收一下。这个不足解决起来也很简单，加个接收右值参数的重载就行了。（这个不足只是对C++11而言的）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
Event SomeEvent;
SomeEvent(SomeClass()); // C++11中，这样触发事件是错误的，编译不过
SomeClass some; 
SomeEvent(some); // 这样一定是可以的
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二，对订阅者进行了包装，但是没有提供生命周期管理机制。这只是需求和代码量的权衡，我不想就为支持“+= new”式的语法搞出一套生命周期管理机制来。简单的实现方式是auto_ptr，如果愿意，读者可以自己实现。在这里，我要&lt;strong&gt;善意的提醒一句&lt;/strong&gt;，c++里的堆是开发库提供的，很可能不同的链接库以及执行文件中的堆不是一个堆，&lt;strong&gt;用一个堆的delete去删除另一个堆里的对象将会收获一个程序崩溃&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;希望这里提到的缺陷不要影响到读者的技术选型。优势就是优势，缺陷就是缺陷；不能优势大于缺陷之后缺陷也成为了优势，技术人应该有客观的技术态度。要知道我是在用Qt的，参考开源项目&lt;a href=&quot;https://github.com/tr0217/tGis&quot;&gt;tGis&lt;/a&gt;。其实信号和槽机制没有给用户带来什么麻烦，仅仅是给Qt团队带来了巨大的麻烦而已。&lt;/p&gt;
</description>
<pubDate>Mon, 25 Jun 2018 05:36:00 +0000</pubDate>
<dc:creator>尧思齐</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tr0217/p/9223937.html</dc:identifier>
</item>
<item>
<title>要用Identity Server 4 -- OAuth 2.0 超级简介 - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/9221488.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/9221488.html</guid>
<description>&lt;p&gt;OAuth有一些定义:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;OAuth 2.0&lt;/strong&gt;&lt;/span&gt;是一个委托协议, 它可以让那些控制资源的人允许某个应用以代表他们来访问他们控制的资源, 注意是代表这些人, 而不是假冒或模仿这些人. 这个应用从资源的所有者那里获得到&lt;span&gt;&lt;strong&gt;授权(Authorization)&lt;/strong&gt;&lt;/span&gt;和&lt;span&gt;&lt;strong&gt;access token&lt;/strong&gt;&lt;/span&gt;, 随后就可以使用这个access token来访问资源.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(这里提到的假冒或模仿就是指在客户端复制一份用户名和密码，从而获取相应的权限)。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;OAuth 2.0是一个开放的协议, 它允许使用简单和标准的方法从Web, 移动或桌面应用来进行安全的授权(Authorization).&lt;/p&gt;

&lt;p&gt;从这些定义可以看出来, OAuth2 是关于授权(Authorization)的,  客户端应用可以请求access token, 使用这个token就可以访问API资源了.&lt;/p&gt;
&lt;p&gt;因为有很多种类客户端应用的存在, 例如ASP.NET Core MVC, Angular, WPF 等等, 它们都是不同的应用类型, 所以, OAuth2 定义了不同类型的客户端应用应该如何安全的完成授权. OAuth2标准还定义了一些端点, 并且定义了针对不同类型的客户端应用如何使用这些端点.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;Identity Server 4&lt;/strong&gt;&lt;/span&gt; 和 Azure AD 都实现了OAuth 2.0 标准.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;但是上面提到的access token只能用来访问资源, 它无法被用来登录客户端应用. 登录这种操作叫做&lt;span&gt;&lt;strong&gt;认证/身份验证(Authentication)&lt;/strong&gt;&lt;/span&gt;, 而OpenID Connect则可以完成这项工作.&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;OpenID Connect&lt;/strong&gt;&lt;/span&gt;是建立在OAuth2协议上的一个简单的身份标识层, 所以OpenID Connect兼容OAuth2. &lt;/p&gt;
&lt;p&gt;使用OpenID Connect, 客户端应用可以请求一个叫identity token的token, 它会和access token一同返回给客户端应用. 这个identity token就可以被用来登录客户端应用程序, 而这个客户端应用还可以使用access token来访问API资源.&lt;/p&gt;
&lt;p&gt;OpenID Connect还定义了一个&lt;span&gt;&lt;strong&gt;UserInfo端点&lt;/strong&gt;&lt;/span&gt;, (&lt;span&gt;&lt;strong&gt;OAuth2定义了Authorization端点和Token端点&lt;/strong&gt;&lt;/span&gt;)它允许客户端应用获取用户的额外信息. &lt;/p&gt;
&lt;p&gt;此外它还定义了不同类型的应用如何从身份识别提供商(&lt;strong&gt;IDP&lt;/strong&gt;)安全的获取这些token.&lt;/p&gt;

&lt;p&gt;综上, &lt;strong&gt;&lt;span&gt;OpenID Connect是更高级的协议&lt;/span&gt;&lt;/strong&gt;, 它扩展并替代了OAuth2. 尽管现在我们经常说我们在使用OAuth2来保护API, 其实更准确的说, 大多数情况下, 我们使用的是OpenID Connect.&lt;/p&gt;

&lt;p&gt;如果到现在还是不明白OAuth2和OpenID Connect也没关系, 这不是几句话就能描述清楚的东西. 本文我进一步介绍OAuth 2.0.&lt;/p&gt;


&lt;p&gt;OAuth2的目标就是让&lt;strong&gt;客户端&lt;/strong&gt;应用可以代表&lt;strong&gt;资源所有者&lt;/strong&gt;(通常是用户)来访问被保护的&lt;strong&gt;资源:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201806/986268-20180625085353290-495491172.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里的&lt;span&gt;&lt;strong&gt;资源所有者(Resource Owner)&lt;/strong&gt;&lt;/span&gt;, 他拥有访问API资源的权限, 并且他还可以&lt;span&gt;&lt;strong&gt;委派权限(delegate)&lt;/strong&gt;&lt;/span&gt;给其他应用来访问API. 资源所有者通常是可以使用浏览器的人.&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;被保护的资源(Protected Resource)&lt;/strong&gt;&lt;/span&gt;就是资源所有者拥有权限去访问的组件, 它可以是很多种形式的, 但是web API的形式还是最常见的.&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;客户端(Client)&lt;/strong&gt;&lt;/span&gt;应用就是代表资源所有者访问被保护资源的一个软件. 注意它既不是指浏览器, 也不是指给你钱让你开发软件的人. 在OAuth2里面, 它是指被保护的API资源的消费者.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;委拖/委派权限&lt;/h3&gt;
&lt;p&gt;前面提到OAuth2里面, 最终用户可以委派他的一部分权限给客户端应用来代表最终用户来访问被保护的资源. 但是要完成这件事, 还需要一个桥梁来连接客户端应用和被保护资源. 这个组件叫做&lt;span&gt;&lt;strong&gt;授权服务器(Authorization Server, AS)&lt;/strong&gt;&lt;/span&gt;. 这个授权服务器也许就是资源服务器, 但是大多数情况下它们是不同的服务器.&lt;/p&gt;
&lt;p&gt;授权服务器(AS)是被受保护的资源所信任的, 它可以发行具有特定目的的安全凭据给客户端应用, 这个凭据叫做OAuth的 &lt;span&gt;&lt;strong&gt;access token&lt;/strong&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;想要获得access token, 客户端应用首先要把资源所有者发送给授权服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201806/986268-20180625131624631-19906045.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先客户端需要获得权限, 它可能有两种方式来获得权限: 可以从资源所有者那里直接获得权限, 也可以让授权服务器作为中介, 从授权服务器那里间接的获得权限. (&lt;em&gt;上面这个图中描述的是从资源授权者直接获得权限的流程)&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;如果使用授权服务器作为中介的话, 客户端需要把资源所有者发送到授权服务器(可以理解为最终用户使用的浏览器被重定向到了授权服务器), 然后资源所有者在这可以对客户端应用进行授权. &lt;/p&gt;
&lt;p&gt;这时资源所有者要通过身份认证进入授权服务器, 通常还会有一个是否同意授权客户端应用请求的选项, 点击同意后就授权了. 而从客户端应用的角度讲呢, 它可以向资源所有者请求他一部分的功能和&lt;strong&gt;范围(scope)&lt;/strong&gt;, 在将来, 资源所有者可能会逐渐减少它所拥有的功能和范围.&lt;/p&gt;
&lt;p&gt;到这里, 上面写的这个动作/东西叫做&lt;span&gt;&lt;strong&gt;授权(authorization grant&lt;/strong&gt;&lt;/span&gt;).&lt;/p&gt;
&lt;p&gt;一旦执行了授权动作也就是客户端得到了授权(这个授权是一个可以代表资源所有者权限的凭据), 客户端便可以从授权服务器请求access token了. 这个access token就可以被用来访问被保护的资源了.&lt;/p&gt;
&lt;p&gt;下图是使用授权服务器作为中介的流程图, 除了授权, 其它部分和上图表达的都是一个意思:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201806/986268-20180625095039292-711118135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;授权 Authorization Grant&lt;/h2&gt;
&lt;p&gt;授权 (authorization grant) 是一个代表着资源所有者权限的凭据, 它可以被客户端应用来获取access token. OAuth2里面定义了&lt;strong&gt;4种类型的授权&lt;/strong&gt;, 分别是: &lt;span&gt;&lt;strong&gt;auhtorization code&lt;/strong&gt;&lt;/span&gt;, &lt;span&gt;&lt;strong&gt;implicit&lt;/strong&gt;&lt;/span&gt;, &lt;span&gt;&lt;strong&gt;resource owner password credentials&lt;/strong&gt;&lt;/span&gt;, &lt;span&gt;&lt;strong&gt;client credentials&lt;/strong&gt;&lt;/span&gt;. OAuth2还定义了一个扩展机制以便定义其它的授权类型. &lt;/p&gt;
&lt;p&gt;用一句话描述就是, 授权(Authorization Grant)就是获取token的方法.&lt;/p&gt;
&lt;h3&gt;1. Authorization Code&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Authorization Code&lt;/strong&gt;&lt;/span&gt;是使用授权服务器作为客户端和资源所有者的中介来获取的. 所以这里不是采用直接从资源所有者获得授权的方式, 而是采用授权服务器作为中介的方式. 在授权服务器把资源所有者送回到(重定向)客户端的时候带着这个临时的凭据: authorization code (我暂时叫它&lt;span&gt;&lt;strong&gt;授权码&lt;/strong&gt;&lt;/span&gt;吧), 它就代表着资源所有者委托给客户端应用的权限.&lt;/p&gt;
&lt;p&gt;Authorization code在安全方面有一些重要的优点: 可以对客户端应用进行身份认证; access token是直接发送到客户端应用的, 不经过资源所有者的浏览器, 所以不会暴露access token给外界, 包括资源所有者.&lt;/p&gt;

&lt;h3&gt;2. Implicit&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Implicit&lt;/strong&gt;&lt;/span&gt;, 我叫它隐式授权吧. 它是Authorization Code的一个简化版本, 它针对浏览器内的客户端应用(例如js, angular的应用)进行了优化. 在implicit流程里, 没有给客户端发送授权码(authorization code), 而是直接给它发送了access token. 之所以叫这种授权类型implicit, 是因为流程里并没有发行任何中间凭据.&lt;/p&gt;
&lt;p&gt;在implicit流程里发行access token的时候, 授权服务器并没有对客户端应用进行身份认证. 某些情况下, 客户端的身份可以通过带着access token重定向回客户端的URI来验证. acces token可能会暴露给任何使用该浏览器的人或者应用.&lt;/p&gt;
&lt;p&gt;Implicit授权确实可以提高浏览器内应用的响应性和效率, 毕竟它减少了来回往返的次数. 但是方便可能会带来风险, 建议如果可以的话尽量使用Authorization Code, 当然这个需要自己去权衡.&lt;/p&gt;

&lt;h3&gt;3. Resource Owner Password Credentials&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Resource Owner Password Credentials&lt;/strong&gt;&lt;/span&gt;, 资源所有者密码凭据. 顾名思义, 可以直接使用密码凭据(用户名和密码)作为授权来获得access token. 只有当资源所有者和客户端之间高度信任的时候并且其它授权方式不可用的时候才可以使用这种授权方式.&lt;/p&gt;
&lt;p&gt;这里资源所有者的凭据只应该用于一次请求并用于交换access token. 这种授权方式可以让客户端免于存储资源所有者的凭据(如果以后还需要使用的话), 通过交换一个长期有效的access token或refresh token都可以达到这种效果.&lt;/p&gt;

&lt;h3&gt;4. Client Credentials&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Client Credentials&lt;/strong&gt;&lt;/span&gt;. 有时候, 资源或者叫资源服务器并不属于某个最终用户, 也就是没有资源所有者对该资源负责. 但是客户端应用肯定还是要访问这些资源, 这时候就只能使用Client Credentials这种授权方式了.&lt;/p&gt;


&lt;p&gt;OAuth2的4个角色前面已经介绍过, 分别是: 资源所有者 &lt;span&gt;&lt;strong&gt;Resource Owner&lt;/strong&gt;&lt;/span&gt;, 客户端 &lt;span&gt;&lt;strong&gt;Client&lt;/strong&gt;&lt;/span&gt;, 被保护资源 &lt;span&gt;&lt;strong&gt;Protected Resource&lt;/strong&gt;&lt;/span&gt;, 和 授权服务器 &lt;span&gt;&lt;strong&gt;Authorization Server&lt;/strong&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;而OAuth2的组件, 前面也都有提到过, 它们是: &lt;span&gt;&lt;strong&gt;Access Token&lt;/strong&gt;&lt;/span&gt;, &lt;span&gt;&lt;strong&gt;Refresh Token&lt;/strong&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;strong&gt;Scope&lt;/strong&gt;&lt;/span&gt; (范围).&lt;/p&gt;
&lt;p&gt;下面简单介绍下这几个组件.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Access Token:&lt;/strong&gt;&lt;/span&gt; 有时候只被叫做token, 它是用来访问被保护资源的凭据. 它是一个字符串, 它代表了给客户颁发的授权, 也就是委托给客户的权限. OAuth2本身并没有对access token的格式或内容进行定义. 但是access token里面要描述出资源所有者授予的访问权限的范围和持续时间.&lt;/p&gt;
&lt;p&gt;Access Token 通常对客户端应用是不透明的, 也就是说客户端无需去查看access token. 客户端的任务就是把它展示给被保护的资源. 其实access token在整个OAuth2系统里对任何角色都是不透明的, 授权服务器的任务只是发行token, 而被保护资源的任务是验证token. 但是它们都必须理解access token的构成, 并知道access token代表了什么. 而客户端对于access token应该是完全健忘的.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Scopes:&lt;/strong&gt;&lt;/span&gt; OAuth2的scope表示被保护资源那里的一套权限. 在OAuth2里面, scope用区分大小写的字符串表示, 可以用空格作为分隔符来表示多个scope. 这些字符串由授权服务器来定义. 而scope字符串的格式和结构在OAuth2里并没有定义.&lt;/p&gt;
&lt;p&gt;Scope对于限制客户端应用的访问权限有很重要的作用. 客户端应用可以请求一些scopes, 而授权服务器可以允许资源所有者授权或者拒绝特定的scopes. Scope还具有叠加性.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Refresh Token:&lt;/strong&gt;&lt;/span&gt; Refresh Token是用来获得Access Token的凭据. 和acces token差不多, refresh token也是由授权服务器发行给客户端应用的, 客户端不知道也不关心refresh token里面有啥. 但与access token不同的是, refresh token不会被发送给被保护的资源. 客户端是用refresh token来请求新的access token (尤其是当现在的access token过期或者失效时), 但这个过程就不需要资源所有者的参与了. Refresh Token是可选的, 授权服务器会酌情发行refresh token, 如果需要的话, refresh token是在发行access token一同返回的.&lt;/p&gt;
&lt;p&gt;此外refresh token还具备让客户端应用逐渐降低访问权限的能力.&lt;/p&gt;
&lt;p&gt;通过refresh token来取得新的access token的流程如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201806/986268-20180625131658182-1274991207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外一张彩色图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/986268/201806/986268-20180625123747013-1023024902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这张彩图的中文意思是: 客户端使用当前access token访问被保护资源的时候, access token失效或者过期了, 这是从被保护资源返回了一个错误响应; 然后客户端使用refresh token向授权服务器请求了一个新的access token; 得到新的access token后, 客户端使用新的access token请求被保护资源, 这时资源就可以被正常的返回给客户端了.&lt;/p&gt;


&lt;p&gt;OAuth2定义了一套端点(Endpoint), 端点就是web服务器的一个访问路径URI.&lt;/p&gt;
&lt;p&gt;OAuth2定义的端点有&lt;strong&gt;&lt;span&gt;授权端点&lt;/span&gt;&lt;/strong&gt;, &lt;span&gt;&lt;strong&gt;Token端点,&lt;/strong&gt;&lt;/span&gt; 它们都在授权服务器上.&lt;/p&gt;
&lt;p&gt;OAuth2没有定义这些端点URI应该如何被发现和文档的结构.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;授权端点(authorization endpoint)&lt;/strong&gt;&lt;/span&gt;是用来和资源所有者交互的, 资源所有者在这里进行登录(身份认证), 然后通过该端点可以对客户端进行授权(authorization grant). 授权服务器首先要验证资源所有者的身份, 但是验证的方式并不在OAuth2的协议范围内.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Token端点(token endpoint)&lt;/strong&gt;&lt;/span&gt;, 客户端通过向token端点展示它的授权(auhtorization grant)或refresh token来获取access token. 除了implicit之外所有的授权类型都需要使用该端点, 因为implicit的access token是直接发行的.&lt;/p&gt;

&lt;p&gt;本篇文章先到这. 下篇文章再简单介绍一下OpenId Connect.&lt;/p&gt;
&lt;p&gt;那四种授权类型具体的详细流程将在介绍Identity Server 4的时候一同介绍.&lt;/p&gt;

</description>
<pubDate>Mon, 25 Jun 2018 05:10:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/9221488.html</dc:identifier>
</item>
<item>
<title>[.NET] 使用 Senparc.Weixin 接入微信公众号开发：简单实现自动回复 - 反骨仔</title>
<link>http://www.cnblogs.com/liqingwen/p/9219454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqingwen/p/9219454.html</guid>
<description>&lt;h2&gt;目录&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一、前提&lt;/li&gt;
&lt;li&gt;二、基本配置信息简析&lt;/li&gt;
&lt;li&gt;三、配置服务器地址（URL）&lt;/li&gt;
&lt;li&gt;四、请求处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;一、前提&lt;/h2&gt;
&lt;p&gt;　　先申请微信公众号的授权，找到或配置几个关键的信息（开发者ID、开发者密码、IP白名单、令牌和消息加解密密钥等）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201806/711762-20180624010141087-152077902.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;二、基本配置信息简析&lt;/h2&gt;
&lt;p&gt;　　开发者ID：固定的；&lt;/p&gt;
&lt;p&gt;　　开发者密码：自己扫一下就可以看到；&lt;/p&gt;
&lt;p&gt;　　IP白名单：设置自己配置服务器的地址；&lt;/p&gt;
&lt;p&gt;　　服务器地址（URL）：稍后详解；&lt;/p&gt;
&lt;p&gt;　　令牌：随便写，按规则；&lt;/p&gt;
&lt;p&gt;　　消息加解密密钥：随便写，或者随机生成；&lt;/p&gt;

&lt;h2&gt;三、配置服务器地址（URL）&lt;/h2&gt;
&lt;p&gt;　　服务器地址（URL）应该怎么配置呢？图片上的配置的地址是：&lt;a href=&quot;http://www.nidie.com.cn/wechat&quot; target=&quot;_blank&quot;&gt;http://www.nidie.com.cn/wechat&lt;/a&gt; ，那么它对应的控制器应该是怎么样子的呢？&lt;/p&gt;

&lt;p&gt;　　在这里，我使用了第三方的包，需要通过 Nuget 来安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;Senparc.Weixin&quot;&lt;/span&gt;&lt;span&gt; version&lt;/span&gt;&lt;span&gt;=&quot;4.22.1&quot;&lt;/span&gt;&lt;span&gt; targetFramework&lt;/span&gt;&lt;span&gt;=&quot;net471&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;Senparc.Weixin.MP&quot;&lt;/span&gt;&lt;span&gt; version&lt;/span&gt;&lt;span&gt;=&quot;14.14.0&quot;&lt;/span&gt;&lt;span&gt; targetFramework&lt;/span&gt;&lt;span&gt;=&quot;net471&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;Senparc.Weixin.MP.MVC&quot;&lt;/span&gt;&lt;span&gt; version&lt;/span&gt;&lt;span&gt;=&quot;5.4.5&quot;&lt;/span&gt;&lt;span&gt; targetFramework&lt;/span&gt;&lt;span&gt;=&quot;net471&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201806/711762-20180624011508063-484069377.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　接下来新建一个 WeChatController.cs:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Senparc.Weixin.MP;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Senparc.Weixin.MP.Entities.Request;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Senparc.Weixin.MP.MvcExtension;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Wen.MvcDemo.Application.WeChat.MessageHandlers.CustomMessageHandlers;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Wen.MvcDemo.Infrastructure.Configuration;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Wen.MvcDemo.Web.Controllers
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 微信
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WeChatController : Controller
    {
        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; private static field

        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; AppId =&lt;span&gt; ApplicationSettingsFactory.GetApplicationSettings().WeChatAppId;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; EncodingAesKey =&lt;span&gt; ApplicationSettingsFactory.GetApplicationSettings().WeChatEncodingAesKey;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Token =&lt;span&gt; ApplicationSettingsFactory.GetApplicationSettings().WeChatToken;

        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt; private static field

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 微信后台验证地址
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;signature&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;timestamp&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;nonce&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;echostr&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionResult Index(&lt;span&gt;string&lt;/span&gt; signature, &lt;span&gt;string&lt;/span&gt; timestamp, &lt;span&gt;string&lt;/span&gt; nonce, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; echostr)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Content(echostr);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 处理用户发送消息后
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;postModel&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;ActionResult&amp;gt;&lt;span&gt; Index(PostModel postModel)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验签名&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;CheckSignature.Check(postModel.Signature, postModel.Timestamp, postModel.Nonce, Token))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; WeixinResult(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;参数错误！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            postModel.AppId &lt;/span&gt;=&lt;span&gt; AppId;
            postModel.EncodingAESKey &lt;/span&gt;=&lt;span&gt; EncodingAesKey;
            postModel.Token &lt;/span&gt;=&lt;span&gt; Token;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收消息，自定义 MessageHandler，对微信请求进行处理&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; messageHandler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CustomMessageHandler(Request.InputStream, postModel);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行微信处理过程&lt;/span&gt;
            &lt;span&gt;await&lt;/span&gt;&lt;span&gt; messageHandler.ExecuteAsync();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回处理结果&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FixWeixinBugWeixinResult(messageHandler);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201806/711762-20180624012231618-159186082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　代码分析：&lt;/p&gt;
&lt;p&gt;　　里面主要包含了三个静态字段和两个 Index 方法。&lt;/p&gt;
&lt;p&gt;　　其中静态字段对应的就是基本配置信息里面对应的几个参数，平常都是写入配置文件中来进行读取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201806/711762-20180624012725268-82441097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　其中一个标识特性为 HttpGet 的 Index 方法，它是用来通过服务器地址（URL）验证的，当你成功部署到你的服务器后，再点击提交认证就可以通过了。注意的是，需要将代码先提交到服务器，再进行提交确认。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201806/711762-20180624013206611-1720361120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　可能你看到该方法好像只返回 return Content(echostr); 这么简单的代码感到质疑：这能行吗？“我”记得官方文档好像要调用很复杂的方法进行校验才行的！？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201806/711762-20180624013645634-1907158335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上图就是官方文档，但是我只关心通过配置提交认证，也就是我用红圈着色的部分，即原样返回 echostr 参数内容即可。&lt;/p&gt;
&lt;p&gt;　　第二个是实现 Post 请求的 Index 方法，在这里我进行了签名校验（也就是上图文档的校验逻辑），因为使用了第三方库，我们知道传哪些参数过去就可以了，签名通过后就是读取请求信息并进行后续处理的步骤了。&lt;/p&gt;

&lt;h2&gt;四、请求处理&lt;/h2&gt;
&lt;p&gt;　　在上面的处理请求信息的代码中，我自定义了一个类 CustomMessageHandler 来处理消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201806/711762-20180624014335713-2118370004.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IO;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Xml.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Senparc.Weixin.MP.AppStore;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Senparc.Weixin.MP.AppStore.Utility;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Senparc.Weixin.MP.Entities;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Senparc.Weixin.MP.Entities.Request;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Senparc.Weixin.MP.MessageHandlers;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Wen.MvcDemo.Application.WeChat.MessageHandlers.CustomMessageHandlers
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 自定义消息处理
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomMessageHandler : MessageHandler&amp;lt;CustomMessageContext&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CustomMessageHandler(Stream inputStream, PostModel postModel = &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt; maxRecordCount = &lt;span&gt;0&lt;/span&gt;, DeveloperInfo developerInfo = &lt;span&gt;null&lt;/span&gt;) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(inputStream, postModel, maxRecordCount, developerInfo)
        {
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CustomMessageHandler(XDocument requestDocument, PostModel postModel = &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt; maxRecordCount = &lt;span&gt;0&lt;/span&gt;, DeveloperInfo developerInfo = &lt;span&gt;null&lt;/span&gt;) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(requestDocument, postModel, maxRecordCount, developerInfo)
        {
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CustomMessageHandler(RequestMessageBase requestMessageBase, PostModel postModel = &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt; maxRecordCount = &lt;span&gt;0&lt;/span&gt;, DeveloperInfo developerInfo = &lt;span&gt;null&lt;/span&gt;) : &lt;span&gt;base&lt;/span&gt;&lt;span&gt;(requestMessageBase, postModel, maxRecordCount, developerInfo)
        {
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 默认
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;requestMessage&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; IResponseMessageBase DefaultResponseMessage(IRequestMessageBase requestMessage)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; responseMessage = &lt;span&gt;base&lt;/span&gt;.CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ResponseMessageText也可以是News等其他类型&lt;/span&gt;
            responseMessage.Content = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您好，目前使用的微信公众号仍处于开发阶段，现已接入了【图灵机器人】，您可以尝试和他（她）交流。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; responseMessage;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　CustomMessageHandler 类继承了 MessageHandler 类，然后重写了 DefaultResponseMessage() 方法，返回固定的文本值。base.CreateResponseMessage&amp;lt;T&amp;gt;() 方法可以返回多种不同类型的结果值，如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ResponseMessageText -&lt;span&gt; 对应文本消息

ResponseMessageNews &lt;/span&gt;-&lt;span&gt; 对应图文消息

ResponseMessageMusic &lt;/span&gt;-&lt;span&gt; 对应音乐消息

ResponseMessageXXX &lt;/span&gt;- 其他类型以此类推
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　上述方法只是一种默认的消息处理，我们也可以专门针对不同的请求类型做出不同的回应，比如重写 OnTextRequest()，其它重载需要自己观察基类成员：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 文本请求
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;requestMessage&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; IResponseMessageBase OnTextRequest(RequestMessageText requestMessage)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; responseMessage = &lt;span&gt;base&lt;/span&gt;.CreateResponseMessage&amp;lt;ResponseMessageText&amp;gt;&lt;span&gt;();
            responseMessage.Content &lt;/span&gt;= $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;您刚才发送的文字信息是：{requestMessage.Content}。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;\r\n用于换行，requestMessage.Content即用户发过来的文字内容&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; responseMessage;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为在继承 MessageHandler&amp;lt;T&amp;gt; 类的同时，我创建了一个 CustomMessageContext 自定义消息上下文的类，该类内容如下，并没有包含其它方法，直接继承 MessageContext&amp;lt;IRequestMessageBase, IResponseMessageBase&amp;gt; 即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Senparc.Weixin.Context;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Senparc.Weixin.MP.Entities;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Wen.MvcDemo.Application.WeChat.MessageHandlers.CustomMessageHandlers
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 自定义消息上下文
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CustomMessageContext : MessageContext&amp;lt;IRequestMessageBase, IResponseMessageBase&amp;gt;&lt;span&gt;
    {
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　这样，就完成了所有代码的编写，现在我们再次把代码部署好之后就可以开始进行测试了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/711762/201806/711762-20180624015718212-2112500625.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　因为我除了部署自己的站点之外，还接入了【图灵机器人】回复，所以你看到了两条信息。&lt;/p&gt;

</description>
<pubDate>Mon, 25 Jun 2018 05:00:00 +0000</pubDate>
<dc:creator>反骨仔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liqingwen/p/9219454.html</dc:identifier>
</item>
</channel>
</rss>