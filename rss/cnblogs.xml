<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>那些年我们一起追逐的多线程(Thread、ThreadPool、委托异步调用、Task/TaskFactory、Parallerl、async和await) - Yaopengfei(姚鹏飞)</title>
<link>http://www.cnblogs.com/yaopengfei/p/9206924.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaopengfei/p/9206924.html</guid>
<description>&lt;p&gt;&lt;span&gt;一. 背景&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;在刚接触开发的头几年里，说实话，根本不考虑多线程的这个问题，貌似那时候脑子里也有没有多线程的这个概念，所有的业务都是一个线程来处理，不考虑性能问题，当然也没有考虑多线程操作一条记录存在的并发问题，后面随着处理的系统业务越来越复杂，多线程再也回避不了了，也就借此机会深入研究了一下.Net中的多线程的处理方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　发现在.Net领域领域中，多线程的处理大致经历了这么几个阶段：Thread→ThreadPool→委托的异步调用→Task→TaskFactory→Parallerl→async和await。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　关注我博客的人会发现，早在&lt;strong&gt;&lt;span&gt;2017年6月份&lt;/span&gt;&lt;/strong&gt;的时候，就开始整理多线程问题了，大约用了6篇文章的来介绍了.Net中的线程的使用方法，主要是介绍相应类的实例方法的使用，有点帮助文档的意思了哦，最近多线程使用的相当频繁，借此机会重新结合一些实际业务系统介绍一下.Net领域的多线程问题，本次将整合原先的六篇文章(删除或覆盖更新)。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt; 多线程的本质是牺牲空间来换取时间，在同步方法中，逻辑代码需要从上往下按顺序执行代码块，在很多情况下代码块与代码块之间并没有先后依赖关系，而前面的代码块非常耗时，在单线程下，后面的代码块必须等待前面的代码块执行完毕才能执行，在这种情况下，我们开辟出一个新线程去异步执行前面的耗时代码块，而主线程继续往后执行，提高了执行效率，这就是牺牲了空间换取了时间(现在的cpu都是2核4线程、4核心8线程，完全有能力处理多个线程)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;下面补充一下多线程在时间和空间上的开销：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(一). 时间上：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①：开启或销毁一个线程都会通知进出中的dll程序集，让这些dll进行相应的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②：时间片切换，cpu默认最大支持8线程，但你开启了9个线程，必然有一个线程会休眠。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(二). 空间上：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①：用户模式堆栈，一个线程分配1M的堆栈空间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②：内核模式的堆栈，用户模式的参数需要传递到内核模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③：线程的内核数据结构，会存放一下变量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二. 概念的梳理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 1. 进程、线程和多线程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　进程：当一个程序开始运行时，它就是一个进程，进程包括运行中的程序和程序所使用到的内存和系统资源，而一个进程又是由多个线程组成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　线程：线程是程序中的一个&lt;strong&gt;执行流&lt;/strong&gt;，每个线程都有自己的专有寄存器&lt;span lang=&quot;EN-US&quot;&gt;(栈指针、程序计数器等&lt;span lang=&quot;EN-US&quot;&gt;)，但代码区是共享的，即不同的线程可以执行同样的函数。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　多线程：多线程是指程序中包含&lt;strong&gt;多个执行流&lt;/strong&gt;，即在一个程序中可以同时运行多个不同的线程来执行不同的任务，也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 多线程的好处和弊端&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　好处：可以提高&lt;span lang=&quot;EN-US&quot;&gt;CPU的利用率。在多线程程序中，一个线程必须等待的时候，&lt;span lang=&quot;EN-US&quot;&gt;CPU可以运行其它的线程而不是等待，这样就大大提高了程序的效率。&lt;strong&gt;（牺牲空间资源，来换取时间）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　弊端：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　①：线程也是程序，所以线程需要占用内存，线程越多占用内存也越多；&lt;strong&gt;（占内存多）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　②：多线程需要协调和管理，所以需要CPU时间跟踪线程； &lt;strong&gt;（占cpu多）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③：线程之间对共享资源的访问会相互影响，必须解决&lt;span&gt;&lt;strong&gt;竞用共享资源&lt;/strong&gt;&lt;/span&gt;的问题；&lt;strong&gt;（多线程存在资源共享问题）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　④：线程太多会导致控制太复杂，最终可能造成很多Bug。&lt;strong&gt;（管理麻烦，产生意外bug）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 何时建议使用多线程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　①. 当主线程试图执行冗长的操作，但系统会卡界面，体验非常不好，这时候可以开辟一个新线程，来处理这项冗长的工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　②. 当请求别的数据库服务器、业务服务器等，可以开辟一个新线程，让主线程继续干别的事。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　③. 利用多线程拆分复杂运算，提高计算速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 何时不建议使用多线程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当单线程能很好解决，就不要为了使用多线程而用多线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. 同步方法和异步方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;①同步方法：方法从上而下一次执行，一步一步执行，有先后顺序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;           &lt;img src=&quot;https://images2015.cnblogs.com/blog/1031302/201706/1031302-20170624101648538-557382709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　②异步方法：说白了，就是里面有开启了多个线程，主线程单独执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2015.cnblogs.com/blog/1031302/201706/1031302-20170624101754710-649538776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6. 异步多线程的三个特点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　①：同步方法卡界面，原因是主线程被占用；异步方法不卡界面，原因是计算交给了别的线程，主线程空闲.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　②：同步方法慢，原因是只有一个线程计算；异步方法快，原因是多个线程同时计算，但是更消耗资源，不宜太多.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　②：异步多线程是无序的，启动顺序不确定、执行时间不确定、结束时间不确定.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;三. 系列章节&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;　&lt;strong&gt;　&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8094512.html&quot;&gt;&lt;span&gt;第一节：复习委托，并且通过委托的异步调用开启一个新线程和异步回调、异步等待。&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　　&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8135829.html&quot;&gt;&lt;span&gt;第二节：深入剖析Thread的五大方法、数据槽、内存栅栏。&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　　&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8178039.html&quot;&gt;&lt;span&gt;第三节：ThreadPool的线程开启、线程等待、线程池的设置、定时功能。&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　　&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8183530.html&quot;&gt;&lt;span&gt;第四节：Task的启动的四种方式以及Task、TaskFactory的线程等待和线程延续的解决方案。&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　　&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8205337.html&quot;&gt;&lt;span&gt;第五节：Task构造函数之TaskCreationOptions枚举处理父子线程之间的关系。&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　　&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8213263.html&quot;&gt;&lt;span&gt;第六节：深入研究Task实例方法ContinueWith的参数TaskContinuationOptions。&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　　&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8229175.html&quot;&gt;&lt;span&gt;第七节：利用CancellationTokenSource实现任务取消和利用CancellationToken类检测取消异常。&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　　&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8256760.html&quot;&gt;&lt;span&gt;第八节：Task的各类Task&amp;lt;TResult&amp;gt;返回值以及通用线程的异常处理方案。&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　　&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8279848.html&quot;&gt;&lt;span&gt;第九节：深究并行编程Parallel类中的三大方法 (For、ForEach、Invoke）和几大编程模型(SPM、APM、EAP、TAP）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　　&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8283956.html&quot;&gt;&lt;span&gt;第十节：利用async和await简化异步编程模式的几种写法&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　　&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8290228.html&quot;&gt;&lt;span&gt;第十一节：深究用户模式锁的使用场景(异变结构、互锁、旋转锁)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　　&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8303045.html&quot;&gt;&lt;span&gt;第十二节：深究内核模式锁的使用场景(自动事件锁、手动事件锁、信号量、互斥锁、读写锁、动态锁)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　　&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8315212.html&quot;&gt;&lt;span&gt;第十三节：实际开发中使用最多的监视锁Monitor、lock语法糖的扩展、混合锁的使用(ManualResetEvent、SemaphoreSlim、ReaderWriterLockSlim)&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　　&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/8322016.html&quot;&gt;&lt;span&gt;第十四节: 介绍四大并发集合类并结合单例模式下的队列来说明线程安全和非安全的场景及补充性能调优问题。&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　　&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/9206924.html#&quot;&gt;&lt;span&gt;第十五节：&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　　&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/9206924.html#&quot;&gt;&lt;span&gt;第十六节：&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　　&lt;a href=&quot;http://www.cnblogs.com/yaopengfei/p/9206924.html#&quot;&gt;&lt;span&gt;第十七节：&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;




&lt;div&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;作       者 : &lt;span&gt;Yaopengfei(姚鹏飞)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;博客地址 : &lt;a href=&quot;http://www.cnblogs.com/yaopengfei/&quot;&gt;&lt;span&gt;http://www.cnblogs.com/yaopengfei/&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;声     明1 : 本人才疏学浅，用郭德纲的话说“我是一个小学生”，如有错误，欢迎讨论，请勿谩骂^_^。&lt;/li&gt;
&lt;li&gt;声     明2 : 原创博客请在转载时保留原文链接或在文章开头加上本人博客地址，如需代码请留下你的评论，加我QQ：604649488 （备注：评论的博客名）&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;/div&gt;

</description>
<pubDate>Wed, 20 Jun 2018 23:35:00 +0000</pubDate>
<dc:creator>Yaopengfei(姚鹏飞)</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yaopengfei/p/9206924.html</dc:identifier>
</item>
<item>
<title>redis访问安全加固 - 单曲荨环</title>
<link>http://www.cnblogs.com/zhoujie/p/redis2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhoujie/p/redis2.html</guid>
<description>&lt;p&gt;　　由于redis是易受攻击的服务，为了避免可能发生的内网渗透风险，通常需要为redis设置密码，并且设置为仅允许本地访问，或者修改默认端口。&lt;/p&gt;
&lt;p&gt;加固方法可参考如下操作：&lt;/p&gt;
&lt;p&gt;方式一：添加redis认证鉴权&lt;/p&gt;
&lt;p&gt;方式二：配置redis仅监听在本地地址&lt;/p&gt;
&lt;p&gt;方式三：修改默认端口&lt;/p&gt;
&lt;p&gt;需要修改redis配置文件redis.conf，并且重启redis服务后生效。&lt;/p&gt;
&lt;h3&gt;设置redis密码 &lt;/h3&gt;
&lt;p&gt;redis没有实现访问控制这个功能，但是它提供了一个轻量级的认证方式，可以编辑redis.conf配置来启用认证。&lt;/p&gt;
&lt;p&gt;   1、初始化Redis密码：&lt;/p&gt;
&lt;p&gt;   在配置文件中有个参数： requirepass  这个就是配置redis访问密码的参数；&lt;/p&gt;
&lt;p&gt;   比如 requirepass test123；&lt;/p&gt;
&lt;p&gt;   （Ps:需重启Redis才能生效）&lt;/p&gt;
&lt;p&gt;   redis的查询速度是非常快的，外部用户一秒内可以尝试多大150K个密码；所以密码要尽量长（对于DBA 没有必要必须记住密码）；&lt;/p&gt;
&lt;p&gt;   2、不重启Redis设置密码：&lt;/p&gt;
&lt;p&gt;   在配置文件中配置requirepass的密码（当redis重启时密码依然有效）。&lt;/p&gt;
&lt;p&gt;   redis 127.0.0.1:6379&amp;gt; config set requirepass test123&lt;/p&gt;
&lt;p&gt;   查询密码：&lt;/p&gt;
&lt;p&gt;   redis 127.0.0.1:6379&amp;gt; config get requirepass&lt;br/&gt;   (error) ERR operation not permitted&lt;/p&gt;
&lt;p&gt;   密码验证：&lt;/p&gt;
&lt;p&gt;   redis 127.0.0.1:6379&amp;gt; auth test123&lt;br/&gt;   OK&lt;/p&gt;
&lt;p&gt;   再次查询：&lt;/p&gt;
&lt;p&gt;   redis 127.0.0.1:6379&amp;gt; config get requirepass&lt;br/&gt;   1) &quot;requirepass&quot;&lt;br/&gt;   2) &quot;test123&quot;&lt;/p&gt;
&lt;p&gt;   PS：如果配置文件中没添加密码 那么redis重启后，密码失效；&lt;/p&gt;
&lt;p&gt;   3、登陆有密码的Redis：&lt;/p&gt;
&lt;p&gt;   在登录的时候的时候输入密码：&lt;/p&gt;
&lt;p&gt;   redis-cli -p 6379 -a test123&lt;/p&gt;
&lt;p&gt;   先登陆后验证：&lt;/p&gt;
&lt;p&gt;   redis-cli -p 6379&lt;/p&gt;
&lt;p&gt;   redis 127.0.0.1:6379&amp;gt; auth test123&lt;br/&gt;   OK&lt;/p&gt;
&lt;p&gt;   AUTH命令跟其他redis命令一样，是没有加密的；阻止不了攻击者在网络上窃取你的密码；&lt;/p&gt;
&lt;p&gt;   认证层的目标是提供多一层的保护。如果防火墙或者用来保护redis的系统防御外部攻击失败的话，外部用户如果没有通过密码认证还是无法访问redis的。&lt;/p&gt;
&lt;h3&gt;配置redis仅监听在本地地址&lt;/h3&gt;
&lt;p&gt;redis.conf配置文件：&lt;/p&gt;
&lt;p&gt;bind 127.0.0.1&lt;/p&gt;
&lt;p&gt;通常我都设置为bind 0.0.0.0，允许远程连接。修改后重启redis服务。&lt;/p&gt;
&lt;h3&gt;修改默认6379端口&lt;/h3&gt;
&lt;p&gt;redis.conf配置文件：&lt;/p&gt;
&lt;p&gt;port 6666&lt;/p&gt;
&lt;p&gt;默认端口为6379。&lt;/p&gt;
&lt;h3&gt;redis相关命令&lt;/h3&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;可执行文件&lt;/td&gt;
&lt;td&gt;作用&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;redis-server &lt;/td&gt;
&lt;td&gt;启动redis&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;redis-cli&lt;/td&gt;
&lt;td&gt;redis命令行工具&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;redis-benchmark&lt;/td&gt;
&lt;td&gt;基准测试工具&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;redis-check-aof&lt;/td&gt;
&lt;td&gt;AOF持久化文件检测工具和修复工具&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;redis-check-dump&lt;/td&gt;
&lt;td&gt;RDB持久化文件检测工具和修复工具&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;redis-sentinel&lt;/td&gt;
&lt;td&gt;启动redis-sentinel&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;最常用到的是redis-cli&lt;/p&gt;
&lt;p&gt;redis-cli -help 查看参数&lt;/p&gt;
&lt;p&gt;远程连接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-cli -h HOST -p PORT -&lt;span&gt;a Password
如：
redis&lt;/span&gt;-cli -h 127.0.0.1 -p &lt;span&gt;6379&lt;/span&gt; -a test123
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
redis-cli -h HOST -&lt;span&gt;p PORT COMMAND
如：
$redis&lt;/span&gt;-cli -h &lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;-p &lt;span&gt;6379&lt;/span&gt;&lt;span&gt; get hello

&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于命令这篇总结的比较好：&lt;a href=&quot;https://www.cnblogs.com/kongzhongqijing/p/6867960.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/kongzhongqijing/p/6867960.html&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 20 Jun 2018 16:35:00 +0000</pubDate>
<dc:creator>单曲荨环</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhoujie/p/redis2.html</dc:identifier>
</item>
<item>
<title>SimpleDateFormat 如何安全的使用？ - zhisheng_tian</title>
<link>http://www.cnblogs.com/zhisheng/p/9206758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhisheng/p/9206758.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcgy1fshewu3v3yj31hc0zkwix.jpg&quot; alt=&quot;001&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt; 前言&lt;/h3&gt;
&lt;p&gt;为什么会写这篇文章？因为这些天在看《阿里巴巴开发手册详尽版》，没看过的可以关注微信公众号：&lt;strong&gt;zhisheng&lt;/strong&gt;，回复关键字：&lt;strong&gt;阿里巴巴开发手册详尽版&lt;/strong&gt; 就可以获得。&lt;/p&gt;
&lt;h3 id=&quot;关注我&quot;&gt;关注我&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://ohfk1r827.bkt.clouddn.com/blog/180103/C6LG3mGa12.jpg&quot; alt=&quot;mark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;转载请务必注明原创地址为：&lt;a href=&quot;http://www.54tianzhisheng.cn/2018/06/19/SimpleDateFormat/&quot; class=&quot;uri&quot;&gt;http://www.54tianzhisheng.cn/2018/06/19/SimpleDateFormat/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在看的过程中有这么一条：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到这条我立马就想起了我实习的时候有个项目里面就犯了这个错误，记得当时是这样写的：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; SimpleDateFormat df = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;st&quot;&gt;&quot;yyyyMMddHHmmss&quot;&lt;/span&gt;);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以才认真的去研究下这个 SimpleDateFormat，所以才有了这篇文章。&lt;/p&gt;
&lt;h3 id=&quot;它是谁&quot;&gt;它是谁？&lt;/h3&gt;
&lt;p&gt;想必大家对 &lt;code&gt;SimpleDateFormat&lt;/code&gt; 并不陌生。&lt;code&gt;SimpleDateFormat&lt;/code&gt; 是 Java 中一个非常常用的类，他是以区域敏感的方式格式化和解析日期的具体类。 它允许格式化 (date -&amp;gt; text)、语法分析 (text -&amp;gt; date)和标准化。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SimpleDateFormat&lt;/code&gt; 允许以任何用户指定的日期-时间格式方式启动。 但是，建议使用 &lt;code&gt;DateFormat&lt;/code&gt; 中的 &lt;code&gt;getTimeInstance&lt;/code&gt;、 &lt;code&gt;getDateInstance&lt;/code&gt; 或 &lt;code&gt;getDateTimeInstance&lt;/code&gt; 方法来创建一个日期-时间格式。 这几个方法会返回一个默认的日期／时间格式。 你可以根据需要用 &lt;code&gt;applyPattern&lt;/code&gt; 方法修改格式方式。&lt;/p&gt;
&lt;h3 id=&quot;日期时间格式&quot;&gt;日期时间格式&lt;/h3&gt;
&lt;p&gt;日期和时间格式由 &lt;strong&gt;日期和时间模式字符串&lt;/strong&gt; 指定。在 &lt;strong&gt;日期和时间模式字符串&lt;/strong&gt; 中，未加引号的字母 'A' 到 'Z' 和 'a' 到 'z' 被解释为模式字母，用来表示日期或时间字符串元素。文本可以使用单引号 (') 引起来，以免进行解释。所有其他字符均不解释，只是在格式化时将它们简单复制到输出字符串。&lt;/p&gt;
&lt;p&gt;简单的讲：这些 A ——Z，a —— z 这些字母(不被单引号包围的)会被特殊处理替换为对应的日期时间，其他的字符串还是原样输出。&lt;/p&gt;
&lt;p&gt;日期和时间模式(&lt;strong&gt;注意大小写，代表的含义是不同的&lt;/strong&gt;)如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1fshewuz8vij30vm150tfw.jpg&quot; alt=&quot;2018-06-19_11-17-43&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;怎么使用&quot;&gt;怎么使用？&lt;/h3&gt;
&lt;p&gt;日期／时间格式模版样例：（给的时间是：2001-07-04 12:08:56 U.S. Pacific Time time zone）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcgy1fshewwuu6pj30x20mqwio.jpg&quot; alt=&quot;2018-06-19_11-27-39&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.text.SimpleDateFormat;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Date;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Created by zhisheng_tian on 2018/6/19&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; FormatDateTime {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        SimpleDateFormat myFmt = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;st&quot;&gt;&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;&lt;/span&gt;);
        SimpleDateFormat myFmt1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;st&quot;&gt;&quot;yy/MM/dd HH:mm&quot;&lt;/span&gt;);
        SimpleDateFormat myFmt2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;st&quot;&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);&lt;span class=&quot;co&quot;&gt;//等价于now.toLocaleString()&lt;/span&gt;
        SimpleDateFormat myFmt3 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;st&quot;&gt;&quot;yyyy年MM月dd日 HH时mm分ss秒 E &quot;&lt;/span&gt;);
        SimpleDateFormat myFmt4 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;st&quot;&gt;&quot;一年中的第 D 天 一年中第w个星期 一月中第W个星期 在一天中k时 z时区&quot;&lt;/span&gt;);
        Date now = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Date();
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(myFmt&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(now));
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(myFmt1&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(now));
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(myFmt2&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(now));
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(myFmt3&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(now));
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(myFmt4&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(now));
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(now.&lt;span class=&quot;fu&quot;&gt;toGMTString&lt;/span&gt;());
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(now.&lt;span class=&quot;fu&quot;&gt;toLocaleString&lt;/span&gt;());
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(now.&lt;span class=&quot;fu&quot;&gt;toString&lt;/span&gt;());
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2018年06月19日 23时10分05秒
18/06/19 23:10
2018-06-19 23:10:05
2018年06月19日 23时10分05秒 星期二
一年中的第 170 天 一年中第25个星期 一月中第4个星期 在一天中23时 CST时区
19 Jun 2018 15:10:05 GMT
2018-6-19 23:10:05
Tue Jun 19 23:10:05 CST 2018&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用方法很简单，就是先自己定义好时间／日期模版，然后调用 format 方法（传入一个时间 Date 参数）。&lt;/p&gt;
&lt;p&gt;上面的是日期转换成自己想要的字符串格式。下面反过来，将字符串类型装换成日期类型：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.text.ParseException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.text.SimpleDateFormat;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Date;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Created by zhisheng_tian on 2018/6/19&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; StringFormatDate {

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        String time1 = &lt;span class=&quot;st&quot;&gt;&quot;2018年06月19日 23时10分05秒&quot;&lt;/span&gt;;
        String time2 = &lt;span class=&quot;st&quot;&gt;&quot;18/06/19 23:10&quot;&lt;/span&gt;;
        String time3 = &lt;span class=&quot;st&quot;&gt;&quot;2018-06-19 23:10:05&quot;&lt;/span&gt;;
        String time4 = &lt;span class=&quot;st&quot;&gt;&quot;2018年06月19日 23时10分05秒 星期二&quot;&lt;/span&gt;;

        SimpleDateFormat myFmt = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;st&quot;&gt;&quot;yyyy年MM月dd日 HH时mm分ss秒&quot;&lt;/span&gt;);
        SimpleDateFormat myFmt1 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;st&quot;&gt;&quot;yy/MM/dd HH:mm&quot;&lt;/span&gt;);
        SimpleDateFormat myFmt2 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;st&quot;&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);&lt;span class=&quot;co&quot;&gt;//等价于now.toLocaleString()&lt;/span&gt;
        SimpleDateFormat myFmt3 = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;st&quot;&gt;&quot;yyyy年MM月dd日 HH时mm分ss秒 E&quot;&lt;/span&gt;);

        Date date1 = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            date1 = myFmt.&lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(time1);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (ParseException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(date1);

        Date date2 = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            date2 = myFmt1.&lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(time2);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (ParseException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(date2);

        Date date3 = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            date3 = myFmt2.&lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(time3);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (ParseException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(date3);

        Date date4 = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            date4 = myFmt3.&lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(time4);
        } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (ParseException e) {
            e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
        }
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(date4);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Tue Jun 19 23:10:05 CST 2018
Tue Jun 19 23:10:00 CST 2018
Tue Jun 19 23:10:05 CST 2018
Tue Jun 19 23:10:05 CST 2018&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个转换方法也很简单。但是不要高兴的太早，主角不在这。&lt;/p&gt;
&lt;h3 id=&quot;线程不安全&quot;&gt;线程不安全&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcgy1fsheww10htj31g40wedm3.jpg&quot; alt=&quot;2018-06-19_23-56-29&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 SimpleDateFormat 类的 JavaDoc 中，描述了该类不能够保证线程安全，建议为每个线程创建单独的日期／时间格式实例，如果多个线程同时访问一个日期／时间格式，它必须在外部进行同步。那么在多线程环境下调用 format() 和 parse() 方法应该使用同步代码来避免问题。下面我们通过一个具体的场景来一步步的深入学习和理解SimpleDateFormat 类。&lt;/p&gt;
&lt;p&gt;1、每个线程创建单独的日期／时间格式实例&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;大量的创建 SimpleDateFormat 实例对象，然后再丢弃这个对象，占用大量的内存和 JVM 空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、创建一个静态的 SimpleDateFormat 实例，在使用时直接使用这个实例进行操作（我当时就是这么干的😄）&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; SimpleDateFormat df = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;st&quot;&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);
Date date = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Date();
df&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(date);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，这个方法的确很不错，在大部分的时间里面都会工作得很好，但一旦在生产环境中一定负载情况下时，这个问题就出来了。他会出现各种不同的情况，比如转化的时间不正确，比如报错，比如线程被挂死等等。我们看下面的测试用例，拿事实说话：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.text.ParseException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.text.SimpleDateFormat;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Date;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Created by zhisheng_tian on 2018/6/20&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DateUtils {
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; SimpleDateFormat sdf = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;st&quot;&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;formatDate&lt;/span&gt;(Date date) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; ParseException {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; sdf&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(date);
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Date &lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(String strDate) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; ParseException {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; sdf.&lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(strDate);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.text.ParseException;&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; * Created by zhisheng_tian on 2018/6/20&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt; */&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DateUtilsTest {
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestSimpleDateFormatThreadSafe &lt;span class=&quot;kw&quot;&gt;extends&lt;/span&gt; Thread {
        &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
            &lt;span class=&quot;kw&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;join&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;2000&lt;/span&gt;);
                } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (InterruptedException e1) {
                    e1.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
                }
                &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                    System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getName&lt;/span&gt;() + &lt;span class=&quot;st&quot;&gt;&quot;:&quot;&lt;/span&gt; + DateUtils.&lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;2018-06-20 01:18:20&quot;&lt;/span&gt;));
                } &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (ParseException e) {
                    e.&lt;span class=&quot;fu&quot;&gt;printStackTrace&lt;/span&gt;();
                }
            }
        }
    }
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;main&lt;/span&gt;(String[] args) {
        &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;; i++) {
            &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;TestSimpleDateFormatThreadSafe&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;start&lt;/span&gt;();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;Exception in thread &lt;span class=&quot;st&quot;&gt;&quot;Thread-0&quot;&lt;/span&gt; Exception in thread &lt;span class=&quot;st&quot;&gt;&quot;Thread-1&quot;&lt;/span&gt; java.&lt;span class=&quot;fu&quot;&gt;lang&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;NumberFormatException&lt;/span&gt;: For input string: &lt;span class=&quot;st&quot;&gt;&quot;&quot;&lt;/span&gt;
    at java.&lt;span class=&quot;fu&quot;&gt;lang&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;NumberFormatException&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;forInputString&lt;/span&gt;(NumberFormatException.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;65&lt;/span&gt;)
    at java.&lt;span class=&quot;fu&quot;&gt;lang&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Long&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;parseLong&lt;/span&gt;(Long.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;601&lt;/span&gt;)
    at java.&lt;span class=&quot;fu&quot;&gt;lang&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Long&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;parseLong&lt;/span&gt;(Long.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;631&lt;/span&gt;)
    at java.&lt;span class=&quot;fu&quot;&gt;text&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;DigitList&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getLong&lt;/span&gt;(DigitList.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;195&lt;/span&gt;)
    at java.&lt;span class=&quot;fu&quot;&gt;text&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;DecimalFormat&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(DecimalFormat.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;2051&lt;/span&gt;)
    at java.&lt;span class=&quot;fu&quot;&gt;text&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SimpleDateFormat&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;subParse&lt;/span&gt;(SimpleDateFormat.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;1869&lt;/span&gt;)
    at java.&lt;span class=&quot;fu&quot;&gt;text&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SimpleDateFormat&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(SimpleDateFormat.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;1514&lt;/span&gt;)
    at java.&lt;span class=&quot;fu&quot;&gt;text&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;DateFormat&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(DateFormat.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;364&lt;/span&gt;)
    at com.&lt;span class=&quot;fu&quot;&gt;zhisheng&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;demo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;date&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;DateUtils&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(DateUtils.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;19&lt;/span&gt;)
    at com.&lt;span class=&quot;fu&quot;&gt;zhisheng&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;demo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;date&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;DateUtilsTest&lt;/span&gt;$TestSimpleDateFormatThreadSafe.&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;(DateUtilsTest.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;19&lt;/span&gt;)
java.&lt;span class=&quot;fu&quot;&gt;lang&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;NumberFormatException&lt;/span&gt;: For input string: &lt;span class=&quot;st&quot;&gt;&quot;.1818&quot;&lt;/span&gt;
    at java.&lt;span class=&quot;fu&quot;&gt;lang&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;NumberFormatException&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;forInputString&lt;/span&gt;(NumberFormatException.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;65&lt;/span&gt;)
    at java.&lt;span class=&quot;fu&quot;&gt;lang&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Long&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;parseLong&lt;/span&gt;(Long.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;578&lt;/span&gt;)
    at java.&lt;span class=&quot;fu&quot;&gt;lang&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;Long&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;parseLong&lt;/span&gt;(Long.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;631&lt;/span&gt;)
    at java.&lt;span class=&quot;fu&quot;&gt;text&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;DigitList&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getLong&lt;/span&gt;(DigitList.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;195&lt;/span&gt;)
    at java.&lt;span class=&quot;fu&quot;&gt;text&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;DecimalFormat&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(DecimalFormat.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;2051&lt;/span&gt;)
    at java.&lt;span class=&quot;fu&quot;&gt;text&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SimpleDateFormat&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;subParse&lt;/span&gt;(SimpleDateFormat.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;2162&lt;/span&gt;)
    at java.&lt;span class=&quot;fu&quot;&gt;text&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;SimpleDateFormat&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(SimpleDateFormat.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;1514&lt;/span&gt;)
    at java.&lt;span class=&quot;fu&quot;&gt;text&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;DateFormat&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(DateFormat.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;364&lt;/span&gt;)
    at com.&lt;span class=&quot;fu&quot;&gt;zhisheng&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;demo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;date&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;DateUtils&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(DateUtils.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;19&lt;/span&gt;)
    at com.&lt;span class=&quot;fu&quot;&gt;zhisheng&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;demo&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;date&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;DateUtilsTest&lt;/span&gt;$TestSimpleDateFormatThreadSafe.&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;(DateUtilsTest.&lt;span class=&quot;fu&quot;&gt;java&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;19&lt;/span&gt;)
Thread&lt;span class=&quot;dv&quot;&gt;-2&lt;/span&gt;:Sat Jun &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;18&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; CST &lt;span class=&quot;dv&quot;&gt;2201&lt;/span&gt;
Thread&lt;span class=&quot;dv&quot;&gt;-2&lt;/span&gt;:Wed Jun &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;18&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; CST &lt;span class=&quot;dv&quot;&gt;2018&lt;/span&gt;
Thread&lt;span class=&quot;dv&quot;&gt;-2&lt;/span&gt;:Wed Jun &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;18&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; CST &lt;span class=&quot;dv&quot;&gt;2018&lt;/span&gt;
Thread&lt;span class=&quot;dv&quot;&gt;-2&lt;/span&gt;:Wed Jun &lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; &lt;span class=&quot;dv&quot;&gt;01&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;18&lt;/span&gt;:&lt;span class=&quot;dv&quot;&gt;20&lt;/span&gt; CST &lt;span class=&quot;dv&quot;&gt;2018&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：Thread-1和Thread-0报java.lang.NumberFormatException: multiple points错误，直接挂死，没起来；Thread-2 虽然没有挂死，但输出的时间是有错误的，比如我们输入的时间是：2018-06-20 01:18:20 ，当会输出：Sat Jun 20 01:18:20 CST 2201 这样的灵异事件。&lt;/p&gt;
&lt;h3 id=&quot;why&quot;&gt;Why?&lt;/h3&gt;
&lt;p&gt;为什么会出现线程不安全的问题呢？&lt;/p&gt;
&lt;p&gt;下面我们通过看 JDK 源码来看看为什么 SimpleDateFormat 和 DateFormat 类不是线程安全的真正原因：&lt;/p&gt;
&lt;p&gt;SimpleDateFormat 继承了 DateFormat，在 DateFormat 中定义了一个 protected 属性的 Calendar 类的对象：calendar。只是因为 Calendar 类的概念复杂，牵扯到时区与本地化等等，JDK 的实现中使用了成员变量来传递参数，这就造成在多线程的时候会出现错误。&lt;/p&gt;
&lt;p&gt;在 SimpleDateFormat 中的 format 方法源码中：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;22&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; StringBuffer &lt;span class=&quot;fu&quot;&gt;format&lt;/span&gt;(Date date, StringBuffer toAppendTo,FieldPosition pos) {
  pos.&lt;span class=&quot;fu&quot;&gt;beginIndex&lt;/span&gt; = pos.&lt;span class=&quot;fu&quot;&gt;endIndex&lt;/span&gt; = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;;
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;format&lt;/span&gt;(date, toAppendTo, pos.&lt;span class=&quot;fu&quot;&gt;getFieldDelegate&lt;/span&gt;());
}
&lt;span class=&quot;co&quot;&gt;// Called from Format after creating a FieldDelegate&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; StringBuffer &lt;span class=&quot;fu&quot;&gt;format&lt;/span&gt;(Date date, StringBuffer toAppendTo,FieldDelegate delegate) {
  &lt;span class=&quot;co&quot;&gt;// Convert input date to time field list&lt;/span&gt;
  calendar.&lt;span class=&quot;fu&quot;&gt;setTime&lt;/span&gt;(date);
  &lt;span class=&quot;dt&quot;&gt;boolean&lt;/span&gt; useDateFormatSymbols = &lt;span class=&quot;fu&quot;&gt;useDateFormatSymbols&lt;/span&gt;();
  &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;; i &amp;lt; compiledPattern.&lt;span class=&quot;fu&quot;&gt;length&lt;/span&gt;; ) {
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; tag = compiledPattern[i] &amp;gt;&amp;gt;&amp;gt; &lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;;
    &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; count = compiledPattern[i++] &amp;amp; &lt;span class=&quot;bn&quot;&gt;0xff&lt;/span&gt;;
    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (count == &lt;span class=&quot;dv&quot;&gt;255&lt;/span&gt;) {
      count = compiledPattern[i++] &amp;lt;&amp;lt; &lt;span class=&quot;dv&quot;&gt;16&lt;/span&gt;;
      count |= compiledPattern[i++];
    }

    &lt;span class=&quot;kw&quot;&gt;switch&lt;/span&gt; (tag) {
      &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; TAG_QUOTE_ASCII_CHAR:
        toAppendTo.&lt;span class=&quot;fu&quot;&gt;append&lt;/span&gt;((&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;)count);
        &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
      &lt;span class=&quot;kw&quot;&gt;case&lt;/span&gt; TAG_QUOTE_CHARS:
        toAppendTo.&lt;span class=&quot;fu&quot;&gt;append&lt;/span&gt;(compiledPattern, i, count);
        i += count;
        &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
      &lt;span class=&quot;kw&quot;&gt;default&lt;/span&gt;:
        &lt;span class=&quot;fu&quot;&gt;subFormat&lt;/span&gt;(tag, count, delegate, toAppendTo, useDateFormatSymbols);
        &lt;span class=&quot;kw&quot;&gt;break&lt;/span&gt;;
    }
  }
  &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; toAppendTo;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;calendar.setTime(date) 这条语句改变了 calendar，稍后，calendar 还会用到（在 subFormat 方法里），而这就是引发问题的根源。想象一下，在一个多线程环境下，有两个线程持有了同一个 SimpleDateFormat 的实例，分别调用format 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;线程 1 调用 format 方法，改变了 calendar 这个字段。
线程 1 中断了。
线程 2 开始执行，它也改变了 calendar。
线程 2 中断了。
线程 1 回来了&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，calendar 已然不是它所设的值，而是走上了线程 2 设计的道路。如果多个线程同时争抢 calendar 对象，则会出现各种问题，时间不对，线程挂死等等。&lt;/p&gt;
&lt;p&gt;分析一下 format 的实现，我们不难发现，用到成员变量 calendar，唯一的好处，就是在调用 subFormat 时，少了一个参数，却带来了许多的问题。其实，只要在这里用一个局部变量，一路传递下去，所有问题都将迎刃而解。&lt;/p&gt;
&lt;p&gt;这个问题背后隐藏着一个更为重要的问题--无状态：无状态方法的好处之一，就是它在各种环境下，都可以安全的调用。衡量一个方法是否是有状态的，就看它是否改动了其它的东西，比如全局变量，比如实例的字段。format 方法在运行过程中改动了 SimpleDateFormat 的 calendar 字段，所以，它是有状态的。&lt;/p&gt;
&lt;p&gt;这也同时提醒我们在开发和设计系统的时候注意下一下三点:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.自己写公用类的时候，要对多线程调用情况下的后果在注释里进行明确说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.多线程环境下，对每一个共享的可变变量都要注意其线程安全性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.我们的类和方法在做设计的时候，要尽量设计成无状态的&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;解决方法&quot;&gt;解决方法&lt;/h3&gt;
&lt;p&gt;1、&lt;strong&gt;需要的时候创建新实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;在需要用到 SimpleDateFormat 的地方新建一个实例，不管什么时候，将有线程安全问题的对象由共享变为&lt;strong&gt;局部私有&lt;/strong&gt;都能避免多线程问题，不过也加重了创建对象的负担。在一般情况下，这样其实对性能影响比不是很明显的。&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;使用同步：同步 SimpleDateFormat 对象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;import java.text.ParseException;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.text.SimpleDateFormat;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import java.util.Date;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; DateSyncUtil {

    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; SimpleDateFormat sdf = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span class=&quot;st&quot;&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;);

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;formatDate&lt;/span&gt;(Date date) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; ParseException {
        &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt;(sdf) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; sdf&lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(date);
        }  
    }

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; Date &lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(String strDate) &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; ParseException {
        &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt;(sdf) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; sdf.&lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(strDate);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;当线程较多时，当一个线程调用该方法时，其他想要调用此方法的线程就要 block 等待，多线程并发量大的时候会对性能有一定的影响。&lt;/p&gt;
&lt;p&gt;3、&lt;strong&gt;使用 ThreadLocal&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class ConcurrentDateUtil {

    private static ThreadLocal&amp;lt;DateFormat&amp;gt; threadLocal = new ThreadLocal&amp;lt;DateFormat&amp;gt;() {
        @Override
        protected DateFormat initialValue() {
            return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        }
    };

    public static Date parse(String dateStr) throws ParseException {
        return threadLocal.get().parse(dateStr);
    }

    public static String format(Date date) {
        return threadLocal.get().format(date);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;使用 ThreadLocal, 也是将共享变量变为独享，线程独享肯定能比方法独享在并发环境中能减少不少创建对象的开销。如果对性能要求比较高的情况下，一般推荐使用这种方法。&lt;/p&gt;
&lt;h3 id=&quot;java-8-中的解决办法&quot;&gt;Java 8 中的解决办法&lt;/h3&gt;
&lt;p&gt;Java 8 提供了新的日期时间 API，其中包括用于日期时间格式化的 DateTimeFormatter，它与 SimpleDateFormat 最大的区别在于：DateTimeFormatter 是线程安全的，而 SimpleDateFormat 并不是线程安全。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DateTimeFormatter 如何使用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解析日期&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;String dateStr= &lt;span class=&quot;st&quot;&gt;&quot;2018年06月20日&quot;&lt;/span&gt;;
DateTimeFormatter formatter = DateTimeFormatter.&lt;span class=&quot;fu&quot;&gt;ofPattern&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;yyyy年MM月dd日&quot;&lt;/span&gt;);   
LocalDate date= LocalDate.&lt;span class=&quot;fu&quot;&gt;parse&lt;/span&gt;(dateStr, formatter);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;日期转换为字符串&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;LocalDateTime now = LocalDateTime.&lt;span class=&quot;fu&quot;&gt;now&lt;/span&gt;();  
DateTimeFormatter format = DateTimeFormatter.&lt;span class=&quot;fu&quot;&gt;ofPattern&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;yyyy年MM月dd日 hh:mm a&quot;&lt;/span&gt;);
String nowStr = now &lt;span class=&quot;fu&quot;&gt;.format&lt;/span&gt;(format);&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由 DateTimeFormatter 的静态方法 ofPattern() 构建日期格式，LocalDateTime 和 LocalDate 等一些表示日期或时间的类使用 parse 和 format 方法把日期和字符串做转换。&lt;/p&gt;
&lt;p&gt;使用新的 API，整个转换过程都不需要考虑线程安全的问题。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;SimpleDateFormat 是线程不安全的类，多线程环境下注意线程安全问题，如果是 Java 8 ，建议使用 DateTimeFormatter 代替 SimpleDateFormat。&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/zhisheng/p/9206758.html&quot;&gt;http://www.cnblogs.com/peida/archive/2013/05/31/3070790.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;相关文章&quot;&gt;相关文章&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.54tianzhisheng.cn/2018/06/20/java-8-date/&quot;&gt;20 个案例教你在 Java 8 中如何处理日期和时间?&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 Jun 2018 16:07:00 +0000</pubDate>
<dc:creator>zhisheng_tian</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhisheng/p/9206758.html</dc:identifier>
</item>
<item>
<title>.Net基础杂记 - KnifeZ</title>
<link>http://www.cnblogs.com/KnifezZZ/p/9206317.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/KnifezZZ/p/9206317.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1、面向对象程序思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　面向对象是程序开发的一种机制，特征为封装、继承、多态。以面向对象方式编写程序时，将复杂的项目抽象为多个对象互相协作的模型，然后编写模型结构，声明或实现类型的成员，即描述对象的特征和行为，编写不同的类型解决或完成不同的功能，在程序中通过类的实例处理解决实际问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、类和对象区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　类（Class）指一类事物，对象（Object）指属于这一类事物的实体；&lt;/p&gt;
&lt;p&gt;　　类定义了对象的相关数据和方法，类通过构造函数生成对象，对象实现了类的定义，且拥有具体的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、修饰符作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　private 所属类内部可以访问，某些情况可以通过get或set进行读取或修改。&lt;/p&gt;
&lt;p&gt;　　protected 所属类及子类的内部访问。&lt;/p&gt;
&lt;p&gt;　　internal 同一程序集内部访问。&lt;/p&gt;
&lt;p&gt;　　public 公共访问权限，无限制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、sealed修饰符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　用于修饰类、实例方法和属性，修饰类时，该类无法被继承，所以也称为密封类。&lt;/p&gt;
&lt;p&gt;　　abstract（抽象类）必须被继承才有意义，故二者不能共存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5、override和overload&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　overload 方法名相同，函数签名不同，多次overload可以适应不同需要。&lt;/p&gt;
&lt;p&gt;　　override 对基类的拓展或改写，签名必须保持一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6、接口和抽象类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　二者皆无法被实例化，并且未实现部分都由派生类实现，抽象类只能派生类，接口可以派生类和结构。&lt;/p&gt;
&lt;p&gt;　　抽象类的派生类也可以说是受限类，即抽象成员在派生类中不一定被实现。&lt;/p&gt;
&lt;p&gt;　　接口则要求派生类或结构完全实现其成员。&lt;/p&gt;
&lt;p&gt;　　抽象类可以包含已经实现的成员，可以包含字段；&lt;/p&gt;
&lt;p&gt;　　接口只包含未实现的成员，不能包含字段。&lt;/p&gt;
&lt;p&gt;　　类只能继承一个抽象类，但可以继承多个接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7、this和base&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　this用于引用类的当前实例，base用于派生类访问基类成员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8、简述程序集和应用程序域&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　&lt;/strong&gt;　程序集用于解决DLL相关的问题，是自我描述的安装单元，是逻辑单元，而非一个文件。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　程序集可以使包含元数据的多个文件，也可以是一个dll或者exe执行文件。&lt;/p&gt;
&lt;p&gt;　　动态程序集位于内存之中，而非存储文件。&lt;/p&gt;
&lt;p&gt;　　应用程序域是.NET中的程序边界。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9、.NET程序编译过程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;由多种高级语言编写，如c#,vb，最后会被各自编译器编译为一致的中间语言（IL）。然后又CLR（公共语言进行时）提供运行环境，将中间语言编译为机器码供CPU执行。&lt;/p&gt;
&lt;p&gt;　　中间语言采用即时编译，也称JIT编译。这种方式只编译调用的代码部分，编译过的部分存储于内存，下次执行无需再次编译，退出程序时，已编译部分的代码会被清除。&lt;/p&gt;
&lt;p&gt;10、.NET程序中间语言（IL）又称为托管代码，优点为平台无关性，JIT性能优化，语言互操作性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;11、using和命名空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　using可用于引用命名空间，自动释放对象使用的资源，添加别名。&lt;/p&gt;
&lt;p&gt;　　引用命名空间：&lt;/p&gt;
&lt;p&gt;　　using System；&lt;/p&gt;
&lt;p&gt;　　自动释放对象使用资源&lt;/p&gt;
&lt;p&gt;　　using（SqlConnection con=new SqlConnection(conntsr)）{&lt;/p&gt;
&lt;p&gt;　　　　con.Open();&lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;
&lt;p&gt;　　添加别名&lt;/p&gt;
&lt;p&gt;　　using S=System;&lt;/p&gt;
&lt;p&gt;　　命名空间反映程序中的逻辑关系，且有效避免类名冲突。代表各种类的逻辑组织方式，与物理组织方式无关。&lt;/p&gt;
&lt;p&gt;　　用namespace关键字可以自定义命名空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;12、值类型和引用类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　值类型包含数据，引用类型只包含数据的内存地址。&lt;/p&gt;
&lt;p&gt;　　值类型只要离开其定义的作用域，就会从内存中被清除，引用类型引用对象一直存留在托管堆，.NET收集器将自动将其销毁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;13、结构和类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　结构类型是值类型的数据封装体，可用于封装较简单的数据结构，并且和类共享大多数语法。&lt;/p&gt;
&lt;p&gt;　　结构不支持继承，所有结构直接继承自System.ValueType。&lt;/p&gt;
&lt;p&gt;　　结构无法声明无参数的构造函数以及析构函数，因为编译器将提供一个默认的构造函数，并将成员进行初始化。可声明带参的构造函数。&lt;/p&gt;
&lt;p&gt;　　结构的静态字段可直接赋初值，实例成员则不允许。&lt;/p&gt;
&lt;p&gt;　　由于结构类型是值类型，所有实例化可以不使用new运算符。结构的new操作不执行分配内存操作，只执行初始化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;14、栈和堆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　栈指堆栈，堆指托管堆，堆栈可用于存储非实例成员的值类型数据，以及引用类型的变量；而托管堆可用于存储引用类型实例的数据和相关信息。&lt;/p&gt;
&lt;p&gt;15、委托 delegate --&lt;/p&gt;
&lt;p&gt;　　可理解为指向一个函数的引用，事件是一种特殊的委托。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;16、页面传值方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　QueryString 使用简单，但缺乏安全性，值暴露于url，中文需转码。&lt;/p&gt;
&lt;p&gt;　　Session　　使用简单，可传递简单数据类型和对象，数据大小无限制，消耗较多服务器资源。&lt;/p&gt;
&lt;p&gt;　　Cookie 　　使用简单，跨页面表单使用cookie保持用户状态，但易被人认为收集用户隐私。&lt;/p&gt;
&lt;p&gt;　　Server.Transfer 直接在服务器端重定向，使用简单，减少客户端对服务器请求，可传递数据类型和控件的值，但由于url地址不变，若源页面与目标页面不在同一目录或子目录下，使用相对路径的图片、超链接都会错误指向。&lt;/p&gt;
&lt;p&gt;　　Application  使用简单，消耗较少服务器资源，数据大小无限制，可传递数据和对象，但作为全局变量容易被误操作。　　&lt;/p&gt;
&lt;p&gt;　　缓存　　　 整页缓存，实现简单，消耗服务器内存；片段缓存，节省内存，但实现麻烦；应用程序缓存，不局限缓存网页，但实现复杂。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;17、常用调用WebService方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　WSDL.exe命令行工具生成代理类，然后在代码里引用这个类文件&lt;/p&gt;
&lt;p&gt;　　.net程序中添加引用、添加服务引用。&lt;/p&gt;
&lt;p&gt;　　Http协议的Get,Post&lt;/p&gt;
&lt;p&gt;　　HttpClient调用&lt;/p&gt;
&lt;p&gt;18、string str=null,不分配内存空间，string str=“”，分配长度为空字符串的内存空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;19、线程和进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Thread和Process都定义了某种边界。&lt;/p&gt;
&lt;p&gt;　　Thread定义的是代码执行堆栈和执行上下文的边界。&lt;/p&gt;
&lt;p&gt;　　Process定义的是应用程序的边界，不同进程之间不能共享代码和数据空间。&lt;/p&gt;
&lt;p&gt;　　一个进程可包含多个线程。&lt;/p&gt;
&lt;p&gt;　　单个进程能访问的最大内存量为最大虚拟内存的1/2。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;20、Windows服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　运行在后台指定用户（System）下的应用程序，无标准UI界面。在服务开始时创建，在服务结束时销毁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;21、GAC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　全局应用程序集缓存，解决了几个程序共享某一个程序集的问题，不必将被共享的程序集拷贝到应用程序目录下了。&lt;/p&gt;
&lt;p&gt;　　.NET程序加载时首先查看GAC,有则直接使用，没有就再去应用程序目录下查找。&lt;/p&gt;
&lt;p&gt;22、ADO.NET五大对象&lt;/p&gt;
&lt;p&gt;　　Command&lt;/p&gt;
&lt;p&gt;　　Connection&lt;/p&gt;
&lt;p&gt;　　DataReader&lt;/p&gt;
&lt;p&gt;　　DataSet&lt;/p&gt;
&lt;p&gt;　　DataAdapter&lt;/p&gt;
&lt;p&gt;23、TCP/IP端口能侦听多少进程&lt;/p&gt;
&lt;p&gt;　　可侦听多个进程（端口复用）。&lt;/p&gt;
&lt;p&gt;　　端口复用代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Socket soc1=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Socket(AddressFamily.InterNetWork,SocketType.Stream,ProtocolType.Tcp);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; soc1.Bind(&lt;span&gt;new&lt;/span&gt; IPEndPoint(IPAddress.Parse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),&lt;span&gt;8235&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; soc1.listen(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; soc2.SetSocketOption(SocketOptionLevel.Socket,SocketOptionName.ReuseAddress,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; soc2.Bind(&lt;span&gt;new&lt;/span&gt; IPEndPoint(IPAddress.Parse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),&lt;span&gt;8235&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; soc2.listen(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; Console.Read();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;24、 asmx的XML Web服务和SOAP的.Net Remoting&lt;/p&gt;
&lt;p&gt;　　web服务使用消息机制，Remoting采用RPC。Web Service能用于不同平台，Remoting只适用于.Net。&lt;/p&gt;
&lt;p&gt;　　Remoting效率高于XML Web Service。&lt;/p&gt;

&lt;p&gt;----未完待续&lt;/p&gt;









</description>
<pubDate>Wed, 20 Jun 2018 15:52:00 +0000</pubDate>
<dc:creator>KnifeZ</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/KnifezZZ/p/9206317.html</dc:identifier>
</item>
<item>
<title>图解HTTP学习笔记 - 你假装没察觉</title>
<link>http://www.cnblogs.com/heavenYJJ/p/9201790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heavenYJJ/p/9201790.html</guid>
<description>&lt;p&gt;&lt;span&gt;前言：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一直觉得自己在HTTP基础方面都是处于知其然，不知其所以然的样子。最近利用空闲时间拜读了一下图解HTTP，写篇博客记录一下读书笔记。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;TCP三次握手：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① 发送端首先发送一个带SYN标志的数据包给对方&lt;/p&gt;
&lt;p&gt;② 接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认消息&lt;/p&gt;
&lt;p&gt;③ 发送端再回传一个带ACK标志的数据包，代表“握手结束”&lt;/p&gt;
&lt;p&gt;注意：若在握手的过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于Cookie：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 目前我们用的比较多的用户鉴权的方法有两种：cookie和Authorization。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;Authorization&lt;/strong&gt;：用户登录成功后在Response Headers或者在URL里面返回Authorization，然后前端拿到Authorization后进行处理，在每次进行HTTP请求时将该Authorization带在Request Headers上。&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1217259/201806/1217259-20180619234751675-270022918.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Cookie&lt;/strong&gt;：用户登录成功后，Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后再发送出去。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1217259/201806/1217259-20180619235327431-1284283159.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;很明显这两种方式对于前端来说当然是第二种Cookie的方式更爽点，因为第二种方式前端不需要做任何事情&lt;/p&gt;

&lt;p&gt;&lt;span&gt;HTTP首部：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; HTTP首部根据实际用途分为：通用首部字段、请求首部字段、响应首部字段、实体首部字段&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通用首部字段&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;首部字段名&lt;/td&gt;
&lt;td&gt;说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Cache-Control&lt;/td&gt;
&lt;td&gt;控制缓存的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Connection&lt;/td&gt;
&lt;td&gt;逐跳首部、连接的管理&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;创建报文的日期时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Pragma&lt;/td&gt;
&lt;td&gt;报文指令&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Trailer&lt;/td&gt;
&lt;td&gt;报文末端的首部一览&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Transfer-Encoding&lt;/td&gt;
&lt;td&gt;指定报文主体的传输编码方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Upgrade&lt;/td&gt;
&lt;td&gt;升级为其他协议&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Via&lt;/td&gt;
&lt;td&gt;代理服务器的相关信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Waring&lt;/td&gt;
&lt;td&gt;错误通知&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;请求首部字段&lt;/strong&gt;&lt;/p&gt;
&lt;table class=&quot;NormalTable&quot;&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;首部字段名&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;说明&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Accept&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;用户代理可处理的媒体类型&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Accept-Charset&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;优先的字符集&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Accept-Encoding&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;优先的内容编码&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Accept-Language&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;优先的语言（自然语言）&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Authorization&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Web&lt;span class=&quot;fontstyle0&quot;&gt;认证信息&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Expect&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;期待服务器的特定行为&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;From&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;用户的电子邮箱地址&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Host&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;请求资源所在服务器&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;If-Match&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;比较实体标记（&lt;span class=&quot;fontstyle2&quot;&gt;ETag&lt;span class=&quot;fontstyle0&quot;&gt;）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;If-Modified-Since&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;比较资源的更新时间&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;If-None-Match&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;比较实体标记（与 &lt;span class=&quot;fontstyle2&quot;&gt;If-Match &lt;span class=&quot;fontstyle0&quot;&gt;相反）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;If-Range&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;资源未更新时发送实体 &lt;span class=&quot;fontstyle2&quot;&gt;Byte &lt;span class=&quot;fontstyle0&quot;&gt;的范围请求&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;If-Unmodified-Since&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;比较资源的更新时间（与&lt;span class=&quot;fontstyle2&quot;&gt;If-Modified-Since&lt;span class=&quot;fontstyle0&quot;&gt;相反）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Max-Forwards&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;最大传输逐跳数&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Proxy-Authorization&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;代理服务器要求客户端的认证信息&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Range&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体的字节范围请求&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Referer&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;对请求中 &lt;span class=&quot;fontstyle2&quot;&gt;URI &lt;span class=&quot;fontstyle0&quot;&gt;的原始获取方&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;TE&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;传输编码的优先级&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;139&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;User-Agent&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;322&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;HTTP &lt;span class=&quot;fontstyle0&quot;&gt;客户端程序的信息&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;响应首部字段&lt;/strong&gt;&lt;/p&gt;
&lt;table class=&quot;NormalTable&quot;&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;首部字段名&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;说明&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Accept-Ranges&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;是否接受字节范围请求&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Age&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;推算资源创建经过时间&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;ETag&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;资源的匹配信息&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Location&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;令客户端重定向至指定&lt;span class=&quot;fontstyle2&quot;&gt;URI&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Proxy-Authenticate&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;代理服务器对客户端的认证信息&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Retry-After&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;对再次发起请求的时机要求&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Server&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;HTTP&lt;span class=&quot;fontstyle0&quot;&gt;服务器的安装信息&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Vary&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;代理服务器缓存的管理信息&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;131&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;WWW-Authenticate&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;305&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;服务器对客户端的认证信息&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体首部字段 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table class=&quot;NormalTable&quot;&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;首部字段名&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;说明&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Allow&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;资源可支持的&lt;span class=&quot;fontstyle2&quot;&gt;HTTP&lt;span class=&quot;fontstyle0&quot;&gt;方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Content-Encoding&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体主体适用的编码方式&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Content-Language&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体主体的自然语言&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Content-Length&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体主体的大小（单位： 字节）&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Content-Location&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;替代对应资源的&lt;span class=&quot;fontstyle2&quot;&gt;URI&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Content-MD5&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体主体的报文摘要&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Content-Range&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体主体的位置范围&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Content-Type&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体主体的媒体类型&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Expires&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;实体主体过期的日期时间&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td width=&quot;118&quot;&gt;&lt;span class=&quot;fontstyle2&quot;&gt;Last-Modified&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;276&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;资源的最后修改日期时间&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;状态码：&lt;/span&gt;&lt;/p&gt;

&lt;div readability=&quot;52&quot;&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;1XX&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;信息性状态码&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;接收的请求正在处理&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;2XX&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;成功状态码&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;请求正常处理完毕&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;3XX&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;重定向状态码&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;需要进行附加操作以完成请求&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;4XX&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;客户端错误状态码&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;服务器无法处理请求&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;5XX&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;服务器错误状态码&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;服务器处理请求出错&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;常用的一些状态码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;200 OK：表示从客户端发来的请求在服务器端被正常处理了&lt;/p&gt;
&lt;p&gt;204 No Content：该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。一般用于在需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下下。&lt;/p&gt;
&lt;p&gt;206 Partial Content：该状态码表客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容&lt;/p&gt;

&lt;p&gt;301 Moved Permanently：永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。&lt;/p&gt;
&lt;p&gt;302 Found：临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。与301的区别是，代表资源不是被永久移动，只是临时性质的。&lt;/p&gt;
&lt;p&gt;303 See Other：该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源。303和302有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源。&lt;/p&gt;
&lt;p&gt;304 Not Modified：该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304状态码返回时，不包含任何响应的主体部分。304虽然被划分在3XX类别中，但是和重定向没有关系。&lt;/p&gt;
&lt;p&gt;307 Temporary Redirect：临时重定向。该状态码和302有相同的含义，但是307不会将POST变成GET&lt;/p&gt;

&lt;p&gt;400 Bad Request：该状态码表示请求报文中存在语法错误。&lt;/p&gt;
&lt;p&gt;401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证、DIGEST认证）的认证信息。另外若之前已进行过1次请求，则表示用户认证失败。&lt;/p&gt;
&lt;p&gt;403 Forbidden：该状态码表明对请求资源的访问被服务器拒绝了。&lt;/p&gt;
&lt;p&gt;404 Not Found：表明服务器上无法找到请求的资源。&lt;/p&gt;

&lt;p&gt;500 Internal Server Error：表明服务器端在执行请求时发生了错误。&lt;/p&gt;
&lt;p&gt;503 Service Unavailable：表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一次将本书读完后有一种这样的感觉，书中提到的很多知识点都是有所了解或者都能看懂，但是过了一段时间后发现很多地方又忘了，后面找机会再来拜读一下这本书。&lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Wed, 20 Jun 2018 15:37:00 +0000</pubDate>
<dc:creator>你假装没察觉</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/heavenYJJ/p/9201790.html</dc:identifier>
</item>
<item>
<title>我和Python的Py交易》》》》》》函数 - BarkingPig</title>
<link>http://www.cnblogs.com/barkingpig/p/9104056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/barkingpig/p/9104056.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;一 函数是什么？  是数学中的函数？&lt;/h2&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;hr/&gt;&lt;h4&gt;&lt;span&gt;Python中&lt;/span&gt; 函数是指将一组语句的集合通过一个名字&lt;span&gt;(函数名)&lt;/span&gt;封装起来的一段代码。（所以这里的函数是&lt;span&gt;subroutine子程序&lt;/span&gt;）&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;那要函数干嘛。不都是代码吗？只不过函数是通过一个名字被封装起来的一段代码。&lt;/span&gt;&lt;span&gt;有名字就就了不起啊！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;对啊，有名字就是了不起啊，函数可以通过&lt;span&gt;函数名来调用&lt;span&gt;被其封装起来的代码。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;可以理解为是一个&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;变量&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;（&lt;span&gt;函数名&lt;/span&gt;）指向的一段代码。这个变量（&lt;span&gt;函数名&lt;/span&gt;）只是一段&lt;span&gt;没有执行&lt;/span&gt;的代码，&lt;span&gt;变量()&lt;/span&gt;（&lt;span&gt;函数名()&lt;/span&gt;）是表示&lt;span&gt;执行&lt;span&gt;这段代码&lt;/span&gt;&lt;/span&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 函数的作用&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.代码重用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例如:一段用来求两数之和的代码通过一个函数名封装成&lt;span&gt;一个函数&lt;/span&gt;，&lt;span&gt;每当需要&lt;/span&gt;求和功能时就不用在把这段代码敲出来了，直接用函数名来&lt;span&gt;调用&lt;/span&gt;这段代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这样这一段求被封装成函数的求和代码就被&lt;span&gt;重复的使用&lt;/span&gt;了很多次。（还省了你敲代码的时间）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.保持一致性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 每一个调用的函数都是同一个，代码都都是一样的。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.易扩展性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;strong&gt;&lt;span&gt;因为函数保持一致性，所有修改函数，为函数添加新功能时，只要修改一次，所有调用的该函数都会跟着变。&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;&lt;strong&gt; 二 建个函数玩玩&lt;/strong&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;h3&gt;&lt;strong&gt;Python 定义函数使用 def 关键字（&lt;span&gt;Definition&lt;span class=&quot;op_dict_text1 c-gap-right&quot;&gt;n  &lt;span class=&quot;op_dict_text2&quot;&gt;定义&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;）&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; 函数名(&lt;code class=&quot;python plain&quot;&gt;参数列表&lt;/code&gt;):
    函数主体(被封装起来的一段代码)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; have_name():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;有名字就是了不起！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;
&lt;pre&gt;
have_name&lt;span&gt;()  &lt;span&gt;# 用函数名调用函数  have_name函数名是指被封装的代码，have_name()代表是执行这段代码。&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;函数名的命名规则&lt;/strong&gt;：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;函数名必须以下划线或字母开头，可以包含任意字母、数字或下划线的组合。不能使用任何的标点符号；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数名是区分大小写的。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数名不能是保留字。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;想要写出高质量的代码，规范的命名是必不可少的。期待吧，少年，我会开单章随笔来，叨叨这个命名的。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;形参和实参&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;形参&lt;/span&gt;&lt;/strong&gt;：&lt;strong&gt;形式上的参数，是应函数的&lt;span&gt;需求&lt;/span&gt;虚拟出变量。当调用这个函数时，就会传一个参数（&lt;span&gt;实参&lt;/span&gt;）给形参，这样虚拟的变量就变真实了（&lt;span&gt;实参个数，类型应与实参一一对应&lt;/span&gt;）；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;实参&lt;/span&gt;：实际参数，调用函数时传给函数的参数，&lt;span&gt;可以是常量，变量，表达式，函数，传给形参&lt;/span&gt;   ；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　&lt;span&gt;打个比喻来形象的说明形参和实参的关系，在数学的函数 F(X)=X+1 中，X就是形参（&lt;span&gt;这个时候X不代表任何具体的值&lt;/span&gt;），而当把X=1带人这个F(X)函数时，1就是实参。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;区别&lt;/span&gt;：形参是虚拟的，不占用内存空间，形参变量只有在被调用时才分配内存单元，实参是一个变量，占用内存空间。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; tow_sum(a,b):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这个里的a和b是没有分配内存空间的&lt;/span&gt;
    c=a+b          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里的a和b是分配了内存空间的&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)

tow_sum(&lt;/span&gt;1,2)       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1和2 是实参为其分配了内存空间&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;三 和函数形参的促膝长谈&lt;/strong&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;函数的形参可以是&lt;span&gt;各种数据（数字，字符串，元组，列表，字典等），函数名等……&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;函数形参（参数）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;关键字参数&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;默认参数&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;非关键字可变长参数（元组）&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;关键字可变长参数（字典）&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;关键字参数&lt;/strong&gt;&lt;/span&gt;：&lt;span&gt;标准调用&lt;/span&gt;时指定参数的名称，且与函数声明时的参数名称&lt;span&gt;顺序一致&lt;/span&gt;。使用&lt;span&gt;关键字调用&lt;/span&gt;参数允许函数调用时参数的顺序与声明时&lt;span&gt;不一致&lt;/span&gt;，仅根据参数的指定进行赋值。&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; gu(a,b):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; a==1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; b==2&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 标准调用&lt;/span&gt;
gu(1,1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关键字调用（可以不按顺序）&lt;/span&gt;
gu(b=2,a=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;&lt;strong&gt;默认参数&lt;/strong&gt;&lt;/span&gt;：&lt;strong&gt;在函数声明时，指定形参的默认值，调用时可不传入改参数（&lt;span&gt;使用默认值&lt;/span&gt;）。&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; gu(a=1,b=&lt;span&gt;0):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; a==1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; b==2&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

gu()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;
&lt;span&gt;
gu(&lt;/span&gt;2,2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;
&lt;span&gt;
gu(b&lt;/span&gt;=2,a=&lt;span&gt;0)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;非关键字可变长参数（元组）&lt;/strong&gt;&lt;/span&gt;：“&lt;span&gt;非关键字&lt;/span&gt;”“&lt;span&gt;可变长&lt;/span&gt;”顾名思义是允许在调用时传入多个“&lt;span&gt;非关键字&lt;/span&gt;”参数，python会将这些多出来的&lt;span&gt;参数放入一个元组中&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; gu(*&lt;span&gt;s):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(s))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)

gu(&lt;/span&gt;1,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,2,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  &lt;span&gt; &lt;span&gt;#可变长，爱有几个参数就调几个参数&lt;/span&gt;&lt;/span&gt;

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;class 'tuple'&amp;gt;  元组&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (1, '钟鼓馔玉不足贵，但愿长醉不复醒。', 2, '古来圣贤皆寂寞，惟有饮者留其名。')&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;关键字可变长参数（字典）&lt;/strong&gt;&lt;/span&gt;：“&lt;span&gt;关键字&lt;/span&gt;”“&lt;span&gt;可变长&lt;/span&gt;”顾名思义是允许在调用时传入多个“关键字”参数，python会将这些多出来的&lt;span&gt;&amp;lt;参数名, 参数值&amp;gt;放入一个字典中&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; gu(**&lt;span&gt;s):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(s))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(s[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(s[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])

gu(a&lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, b= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  &lt;span&gt;#可变长，爱有几个参数就调几个参数&lt;/span&gt;

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;class 'dict'&amp;gt;  字典&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; {'a': '钟鼓馔玉不足贵，但愿长醉不复醒。', 'b': '古来圣贤皆寂寞，惟有饮者留其名。'}&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;需要注意的是当它们&lt;span&gt;混用时&lt;/span&gt;，关键字变量参数应该为函数定义的最后一个参数，带**&lt;/strong&gt;。&lt;strong&gt;调用函数时参数的输入也有不同的方式。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; gu(a,b,*c,**&lt;span&gt;d):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(d)
gu(&lt;/span&gt;1,2,3,f=7,g=8&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; (3,)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; {'f': 7, 'g': 8}&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; gu(a,b,*c,**&lt;span&gt;d):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(d)
gu(&lt;/span&gt;1,2,*(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;钟鼓馔玉不足贵，但愿长醉不复醒&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,),**{&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;钟鼓馔玉不足贵，但愿长醉不复醒。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;})

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; ('钟鼓馔玉不足贵，但愿长醉不复醒',)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; {'t': '钟鼓馔玉不足贵，但愿长醉不复醒。', 'f': '古来圣贤皆寂寞，惟有饮者留其名。'}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;四 给回扣的返回值&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;要想获取函数的执行结果，就可以用return语句把结果返回&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;return返回值可以是&lt;/strong&gt;&lt;span&gt;各种数据（数字，字符串，元组，列表，字典等），函数名等……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;函数在执行过程中只要遇到return语句，就会停止执行并返回结果，so 也可以理解为 return 语句代表着函数的结束&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果未在函数中指定return,那这个函数的返回值为None，Python会自动给函数加 &lt;span&gt;return None&lt;/span&gt;。&lt;br/&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;return多个对象，解释器会把这多个对象&lt;span&gt;组装成一个元组&lt;/span&gt;作为&lt;span&gt;一个整体&lt;/span&gt;结果输出。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; gu(a):
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a

b &lt;/span&gt;= gu(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;古来圣贤皆寂寞，惟有饮者留其名。&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(b)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;五 就是比你高的高阶函数&lt;/strong&gt;&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;高阶函数&lt;/strong&gt;是&lt;strong&gt;&lt;span&gt;至少满足下列一个条件的函数&lt;/span&gt;&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;接受一个或多个函数作为输入（&lt;span&gt;参数&lt;/span&gt;）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出一个函数（&lt;span&gt;return 返回值&lt;/span&gt;）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;递归函数，修饰器也都是高阶函数的运用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;六 鞭长莫及的作用域&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;作用域研究的是数据的&lt;span&gt;适用范围&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;就像地球的重力加速度g在火星上就不适用。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; globe():
    g &lt;/span&gt;= 9.8

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; mars():
    g &lt;/span&gt;= 3.71
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;上述代码中两个g是&lt;span&gt;毫无关系的&lt;/span&gt;，因为&lt;span&gt;它们的作用域不同一个函数就是一个作用域&lt;/span&gt;。在globe()中的g的只在globe函数中适用，另一个g也是是如此。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这只是作用域的小小体现，&lt;span&gt;作用域不只在函数中有，在类，包中都有体现 。还有如何去调用，修改不同作用域里的数据&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这些都会开单章来唠叨一下。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;七 自娱自乐的递归&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;定义：一个函数在内部调用自身本身，这个函数就是递归函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 说白了就是自己和自己玩（单身人士都懂的）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 必须有一个明确的&lt;span&gt;结束条件 &lt;span&gt;（不可自娱自乐太久要有个度）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 每次进入更深一层递归时，问题规模相比上次递归都应有所减少  &lt;span&gt;（每自娱自乐一次总得缓解一下单身狗的苦）&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 递归效率不高，递归层次&lt;span&gt;过多&lt;/span&gt;会导致栈溢出。&lt;span&gt;（自娱自乐多了伤身）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;注释：(在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数执行结束，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;阶乘的计算&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; **********循环*********&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; factorial(n):
    result &lt;/span&gt;=&lt;span&gt; n
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1&lt;span&gt;, n):
        result &lt;/span&gt;*=&lt;span&gt; i

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(factorial(3&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; **********递归*********&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; factorial_new(n):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n == 1:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 递归结束条件&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;
    result&lt;/span&gt;=factorial_new(n - 1&lt;span&gt;)
    result &lt;/span&gt;= n *&lt;span&gt; result
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result

a &lt;/span&gt;= factorial_new(3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(a)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1361614/201806/1361614-20180620204420215-1637384221.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;递归函数是定义简单，逻辑清晰。理论上，所有的递归函数都可以写&lt;span&gt;成循环的方式&lt;/span&gt;，但循环的逻辑不如递归清晰。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;八 良心的内置函数&lt;/h2&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;内置函数就是Python提供的，可以直接使用的函数，&lt;span&gt;所以&lt;strong&gt;&lt;span&gt;内置函数一般都是使用频繁的函数。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;以后会仔细说一下有哪些内置函数&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;九 无副作用的函数式编程&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;常见的编程范式有&lt;span&gt;命令式编程&lt;/span&gt;，&lt;span&gt;函数式编程&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;命令式编程&lt;/span&gt;&lt;/strong&gt;：是面向计算机硬件的抽象，有变量（对应着存储单元），赋值语句（获取，存储指令），表达式（内存引用和算术运算）和控制语句（跳转指令），&lt;span&gt;命令式程序就是一个冯诺依曼机的按照打孔纸带执行指令。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;函数式编程&lt;/span&gt;：&lt;/span&gt;是面向数学的抽象，&lt;span&gt;&lt;strong&gt;他将计算机运算看做是数学中函数的计算，并且避免了状态以及变量的概念，&lt;/strong&gt;&lt;/span&gt;一句话，&lt;span&gt;函数式程序就是一个表达式&lt;/span&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;面向过程编程，面向对象编程&lt;/span&gt;都是&lt;span&gt;命令式编程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;函数式编程的本质&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;strong&gt;函数式编程中的&lt;span&gt;&lt;strong&gt;函数&lt;/strong&gt;&lt;/span&gt;这个术语不是指计算机中的函数，而是指&lt;span&gt;数学中的函数&lt;/span&gt;，即&lt;span&gt;自变量的映射&lt;/span&gt;。也就是说一个函数的值仅决定于&lt;span&gt;函数参数的值&lt;/span&gt;，不依赖其他状态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;我们要做的是把函数传来传去，而这个，说成术语，我们把他叫做高阶函数&lt;/strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;函数是基本单位，他几乎被用作一切，包括最简单的计算，甚至连变量都被计算所取代。&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;变量只是一个名称，而不是一个存储单元，&lt;span&gt;这是函数式编程与传统的命令式编程最典型的不同之处&lt;/span&gt;。&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;函数式编程取消了&lt;span&gt;赋值模型&lt;/span&gt;，则使&lt;span&gt;数学模型与编程模型完美地达成了统一&lt;/span&gt;&lt;/strong&gt;。&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;函数式编程&lt;span&gt;&lt;span&gt;关心&lt;/span&gt;数据的映射&lt;/span&gt;，命令式编程&lt;span&gt;&lt;span&gt;关心&lt;/span&gt;解决问题的步骤。&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;zm-editable-content clearfix&quot; readability=&quot;43.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算列表中数的平均值&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;***********命令式编程***************&lt;/span&gt;
number = [0,1, 2, 3, 4, 5, 6, 7, 8, 9&lt;span&gt;]
count &lt;/span&gt;=&lt;span&gt; 0
add &lt;/span&gt;=&lt;span&gt; 0

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(number)):
        count &lt;/span&gt;+= 1          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第一步 计数&lt;/span&gt;
        add+= number[i]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第二步 求和&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; count &amp;gt;&lt;span&gt; 0:
    average &lt;/span&gt;= add/ count   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第三步 计算平均数&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(average)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;***********函数式编程***************&lt;/span&gt;
number = [0,1, 2, 3, 4, 5, 6, 7, 8, 9&lt;span&gt;]
average &lt;/span&gt;= sum(number) /&lt;span&gt; len(number)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(average)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎评论，番茄，鸡蛋都砸过来吧！！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Wed, 20 Jun 2018 15:24:00 +0000</pubDate>
<dc:creator>BarkingPig</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/barkingpig/p/9104056.html</dc:identifier>
</item>
<item>
<title>CTPN_论文阅读总结 - ysyouaremyall</title>
<link>http://www.cnblogs.com/ys99/p/9206564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ys99/p/9206564.html</guid>
<description>&lt;h2&gt;论文全名：Detecting Text in Natural Image with Connectionist Text Proposal Network&lt;/h2&gt;
&lt;h2&gt;1.摘要&lt;/h2&gt;
&lt;p&gt;（1）本文提出新型网络CTPN，用于自然图像中的文本行定位。CTPN直接在卷积特征映射中的一系列细粒度文本提议中检测文本行。（创新一）开发了一个垂直锚点机制，联合预测每个固定宽度提议的位置和文本、非文本的分数。（创新二）序列提议通过循环神经网络自然连接起来，该网络无缝的结合到卷积网络中，从而形成可训练的端到端模型。&lt;/p&gt;
&lt;h2&gt;2.引言&lt;/h2&gt;
&lt;p&gt;（1）图像文字检测的应用：图像OCR、多语言翻译、图像检索等。包括检测和识别两个任务，本文聚焦检测任务。由于文本模式的大变化以及背景的高度杂乱，使得检测任务一般比文字识别任务难度更大。&lt;/p&gt;
&lt;p&gt;（2）传统使用自下而上的方式，从低级别字符和笔画检测开始，步骤繁琐，现在普遍被神经网络所代替，无需自行查找特征。&lt;/p&gt;
&lt;p&gt;（3）目前主流的方法Faster-RCNN虽然用于一般目标检测效果良好，但是用在文本检测上并不令人满意。第一：主要由于文本的长度往往都是难以固定，不像一般物体一般都是有相对较固定额边界框；第二：一般物体IOU&amp;gt;0.5可能就可以识别出物体的种类，而文字识别需要更精确的IOU，因为仅仅大于0.5可能根本无法识别出文字。&lt;/p&gt;
&lt;h2&gt;3.贡献&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201806/1326691-20180620210108841-44040230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图一：（a）连接文本提议网络（CTPN）的架构。首先通过VGG16的最后一个卷积映射（conv5）密集的滑动3*3空间窗口。每行的序列窗口通过双向LSTM（BLSTM）循环连接，其中每个窗口的卷积特征（3*3*C）被用作256维的BLSTM（包括两个128维的LSTM）的输入。RNN层连接到512维的全连接层，接着是输出层，联合预测k个锚点的文本、非文本分数，y轴坐标坐标（包括坐标和高度）和边缘调整偏移。（b）CTPN输出连续的固定宽度细粒度文本提议。每个框的颜色表示文本/非文本的分数。只显示文本框正例的分数。&lt;/p&gt;
&lt;p&gt;（1）贡献一：开发了一个垂直锚点机制，联合预测每个固定宽度提议的位置和文本、非文本的分数。&lt;/p&gt;
&lt;p&gt;（2）贡献二：序列提议通过循环神经网络自然连接起来，该网络无缝的结合到卷积网络中，从而形成可训练的端到端模型。&lt;/p&gt;
&lt;p&gt;在ICDAR2013,2015数据集上都取得了很好的成绩。&lt;/p&gt;
&lt;h2&gt;4.相关工作&lt;/h2&gt;
&lt;p&gt;（1）文本检测：过去都是使用自下而上的方法为主，粗略分为连接组件（CC）和基于滑动窗口的方法。特征手动设计，鲁棒性差，设计特征本身往往也十分困难，另外滑动窗口的方法在计算上也十分昂贵。&lt;/p&gt;
&lt;p&gt;（2）目标检测：从选择性搜索的RCNN发展到了RPN网络提供候选框的Faster-RCNN,RPN提议不具有判别性，需要通过额外得成本高昂的CNN模型进一步细化和分类。更重要的是，文本和一般目标检测很大的不同，因此很难直接将通用的目标检测系统应用到这个高度领域化的任务中。&lt;/p&gt;
&lt;h2&gt;5.连接文本提议网络&lt;/h2&gt;
&lt;p&gt;本节详细介绍网络的细节，它包括三个关键的贡献，使文本定位可靠和准确：检测细粒度提议文本，循环连接文本提议和边缘细化。&lt;/p&gt;
&lt;h3&gt;（1）在细粒度提议中检测文本&lt;/h3&gt;
&lt;p&gt;输入的图像任意大小，VGG网络架构决定了总步长和感受野固定为16个和228个像素。而本文锚点的宽度恰好固定为16，刚好各个框互相挨着且不重叠。&lt;/p&gt;
&lt;p&gt;文中k个锚点框，k设置成10，其高度从11个像素到273个像素（每次÷0.7），位置通过高度和y中心坐标度量。如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201806/1326691-20180620214727449-1190051522.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中V={Vc,Vh},V*={V*c,V*h}分别是相对的预测坐标和相对的实际坐标，Cya,ha分别是锚点框的y轴中心高度，Cy,h是输入图片中预测的y轴坐标和高度，C*y，h*是输入图片的实际坐标和高度。&lt;/p&gt;
&lt;p&gt;检测到的文本提议是从&amp;gt;0.7（具有非极大值抑制）的文本/非文本分数的锚点生成的。&lt;/p&gt;
&lt;h3&gt;（2）循环连接文本提议&lt;/h3&gt;
&lt;p&gt;RNN类型：BLSTM（双向LSTM），每个LSTM有128个隐含层。&lt;/p&gt;
&lt;p&gt;RNN输入：每个滑动窗口的3*3*C的特征（可以拉成一列），同一行的窗口的特征形成一个序列。&lt;/p&gt;
&lt;p&gt;RNN输出：每个窗口对应256维特征。&lt;/p&gt;
&lt;p&gt;整个感受野理论上可以覆盖228*width.&lt;/p&gt;
&lt;h3&gt;（3）边缘细化&lt;/h3&gt;
&lt;p&gt;文本行的构建规则。后面详细补充。&lt;/p&gt;
&lt;p&gt;与y中心坐标预测类似，下面是x坐标的相对偏移：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201806/1326691-20180620222308870-418476664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文中每个锚点都预测了x坐标的偏移（这个步骤不是后处理计算的），如图一所示，但最终只使用了文本行边缘的提议。即左右两边。&lt;/p&gt;
&lt;h3&gt;（4）模型输出和损失函数&lt;/h3&gt;
&lt;p&gt;提出的CTPN有三个输出共同连接到最后的FC层，如图一所示，这个三个输出同时预测文本/非文本分数，垂直坐标（v={Vc,Vh}）和边缘细化偏移（o）.,探索k个锚点来预测他们在conv5中的每个空间位置，从而在输出层分别得到2k,2k和k个参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1326691/201806/1326691-20180620225406874-1732668117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中每一个锚点都是一个训练样本，其中每个锚点都是一个训练样本，&lt;span id=&quot;MathJax-Element-189-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;i&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-1651&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-1652&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-1653&quot; class=&quot;mi&quot;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;i是一个小批量数据中一个锚点的索引。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;i&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;未完。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 20 Jun 2018 15:03:00 +0000</pubDate>
<dc:creator>ysyouaremyall</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ys99/p/9206564.html</dc:identifier>
</item>
<item>
<title>缓存的正确使用方式 - baishuchao</title>
<link>http://www.cnblogs.com/baishuchao/p/9206521.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baishuchao/p/9206521.html</guid>
<description>&lt;p&gt;首先，缓存由于其适应高并发和高性能的特性，已经在项目中被广泛使用。在读取缓存方面，大家没啥疑问，都是按照下图的流程来进行业务操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/baishuchao/1226071/o_123.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是在更新缓存方面，对于更新完数据库，是更新缓存呢，还是删除缓存。又或者是先删除缓存，再更新数据库，其实大家存在很大的争议。&lt;/p&gt;
&lt;p&gt;先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，我们可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。&lt;/p&gt;
&lt;p&gt;在这里，我们讨论三种更新策略：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;先更新数据库，再更新缓存&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;先删除缓存，再更新数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;先更新数据库，再删除缓存&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这套方案，大家是普遍反对的。为什么呢？有如下两点原因。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原因一（线程安全角度）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同时有请求A和请求B进行更新操作，那么会出现&lt;/p&gt;
&lt;p&gt;（1）线程A更新了数据库&lt;br/&gt;（2）线程B更新了数据库&lt;br/&gt;（3）线程B更新了缓存&lt;br/&gt;（4）线程A更新了缓存&lt;/p&gt;
&lt;p&gt;这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;原因二（业务场景角度）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有如下两点：&lt;/p&gt;
&lt;p&gt;（1）如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。&lt;/p&gt;
&lt;p&gt;（2）如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。&lt;/p&gt;
&lt;p&gt;接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。&lt;/p&gt;

&lt;p&gt;该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:&lt;/p&gt;
&lt;p&gt;（1）请求A进行写操作，删除缓存&lt;br/&gt;（2）请求B查询发现缓存不存在&lt;br/&gt;（3）请求B去数据库查询得到旧值&lt;br/&gt;（4）请求B将旧值写入缓存&lt;br/&gt;（5）请求A将新值写入数据库&lt;/p&gt;
&lt;p&gt;上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。&lt;/p&gt;
&lt;p&gt;那么，如何解决呢？采用延时双删策略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;伪代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;write&lt;/span&gt;(String key,Object data){

        redis.&lt;span class=&quot;fu&quot;&gt;delKey&lt;/span&gt;(key);

        db.&lt;span class=&quot;fu&quot;&gt;updateData&lt;/span&gt;(data);

        Thread.&lt;span class=&quot;fu&quot;&gt;sleep&lt;/span&gt;(&lt;span class=&quot;dv&quot;&gt;1000&lt;/span&gt;);

        redis.&lt;span class=&quot;fu&quot;&gt;delKey&lt;/span&gt;(key);

    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;转化为中文描述就是&lt;/p&gt;
&lt;p&gt;（1）先淘汰缓存&lt;br/&gt;（2）再写数据库（这两步和原来一样）&lt;br/&gt;（3）休眠1秒，再次淘汰缓存&lt;/p&gt;
&lt;p&gt;这么做，可以将1秒内所造成的缓存脏数据，再次删除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么，这个1秒怎么确定的，具体该休眠多久呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对上面的情形，读者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你用了mysql的读写分离架构怎么办？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ok，在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。&lt;/p&gt;
&lt;p&gt;（1）请求A进行写操作，删除缓存&lt;br/&gt;（2）请求A将数据写入数据库了&lt;br/&gt;（3）请求B查询缓存发现，缓存没有值&lt;br/&gt;（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值&lt;br/&gt;（5）请求B将旧值写入缓存&lt;br/&gt;（6）数据库完成主从同步，从库变为新值&lt;/p&gt;
&lt;p&gt;上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百ms。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;采用这种同步淘汰策略，吞吐量降低怎么办？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ok，那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二次删除,如果删除失败怎么办？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：&lt;/p&gt;
&lt;p&gt;（1）请求A进行写操作，删除缓存&lt;br/&gt;（2）请求B查询发现缓存不存在&lt;br/&gt;（3）请求B去数据库查询得到旧值&lt;br/&gt;（4）请求B将旧值写入缓存&lt;br/&gt;（5）请求A将新值写入数据库&lt;br/&gt;（6）请求A试图去删除请求B写入对缓存值，结果失败了。&lt;/p&gt;
&lt;p&gt;ok,这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。&lt;/p&gt;

&lt;p&gt;首先，先说一下。老外提出了一个缓存更新套路，名为《Cache-Aside pattern》。其中就指出：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;命中：应用程序从cache中取数据，取到后返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;更新：先把数据存到数据库中，成功后，再让缓存失效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，知名社交网站facebook也在论文《Scaling Memcache at Facebook》中提出，他们用的也是先更新数据库，再删缓存的策略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种情况不存在并发问题么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生&lt;/p&gt;
&lt;p&gt;（1）缓存刚好失效&lt;br/&gt;（2）请求A查询数据库，得一个旧值&lt;br/&gt;（3）请求B将新值写入数据库&lt;br/&gt;（4）请求B删除缓存&lt;br/&gt;（5）请求A将查到的旧值写入缓存&lt;/p&gt;
&lt;p&gt;ok，如果发生上述情况，确实是会发生脏数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然而，发生这种情况的概率又有多少呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。&lt;/p&gt;
&lt;p&gt;假设，有人非要抬杠，有强迫症，一定要解决怎么办？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何解决上述并发问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，给缓存设置有效时间是一种方案。其次，采用策略（2）里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还有其他造成不一致的原因么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有的，这也是缓存更新策略（2）和缓存更新策略（3）都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。这也是缓存更新策略（2）里留下的最后一个疑问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何解决？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;提供一个保障的重试机制即可，这里给出两套方案。&lt;/p&gt;
&lt;p&gt;方案一：&lt;/p&gt;
&lt;p&gt;如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_update1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;流程如下所示&lt;/p&gt;
&lt;p&gt;（1）更新数据库数据；&lt;br/&gt;（2）缓存因为种种问题删除失败&lt;br/&gt;（3）将需要删除的key发送至消息队列&lt;br/&gt;（4）自己消费消息，获得需要删除的key&lt;br/&gt;（5）继续重试删除操作，直到成功&lt;br/&gt;然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。&lt;/p&gt;
&lt;p&gt;方案二：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/rjzheng/1202350/o_update2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;流程如下图所示：&lt;/p&gt;
&lt;p&gt;（1）更新数据库数据&lt;br/&gt;（2）数据库会将操作信息写入binlog日志当中&lt;br/&gt;（3）订阅程序提取出所需要的数据以及key&lt;br/&gt;（4）另起一段非业务代码，获得该信息&lt;br/&gt;（5）尝试删除缓存操作，发现删除失败&lt;br/&gt;（6）将这些信息发送至消息队列&lt;br/&gt;（7）重新从消息队列中获得该数据，重试操作。&lt;/p&gt;
</description>
<pubDate>Wed, 20 Jun 2018 14:51:00 +0000</pubDate>
<dc:creator>baishuchao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baishuchao/p/9206521.html</dc:identifier>
</item>
<item>
<title>密码学学习整理二 - WhiteBlackCat</title>
<link>http://www.cnblogs.com/FZfangzheng/p/9206446.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FZfangzheng/p/9206446.html</guid>
<description>&lt;p&gt;密钥流是随机的，则每个密钥比特的概率满足： Pr[k=0]=1/2, Pr[k=1]=1/2&lt;/p&gt;
&lt;p&gt;假设明文流某个比特的概率满足： Pr[m=0]=p, Pr[m=1]=1-p&lt;/p&gt;
&lt;p&gt;对应的密文比特的概率：&lt;/p&gt;
&lt;p&gt;Pr[c=0] = Pr[k=0]&lt;em&gt;Pr[m=0]+Pr[k=1]&lt;/em&gt;Pr[m=1]=1/2&lt;/p&gt;
&lt;p&gt;Pr[c=1] = Pr[k=0]&lt;em&gt;Pr[m=1]+Pr[k=1]&lt;/em&gt;Pr[m=0]=1/2&lt;/p&gt;
</description>
<pubDate>Wed, 20 Jun 2018 14:30:00 +0000</pubDate>
<dc:creator>WhiteBlackCat</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/FZfangzheng/p/9206446.html</dc:identifier>
</item>
<item>
<title>嵌入式单元测试--框架解析 - 啊哈彭</title>
<link>http://www.cnblogs.com/pingwen/p/9206406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pingwen/p/9206406.html</guid>
<description>&lt;h2 id=&quot;1单元测试的必要性&quot; data-source-line=&quot;1&quot;&gt;1.单元测试的必要性&lt;/h2&gt;
&lt;p data-source-line=&quot;2&quot;&gt;单元测试是软件开发的重要一环，尤其对嵌入式开发。因为嵌入式开发受限于开发环境、调试工具等因素，不能和纯PC软件开发一样使用很多先进的工具。这就需要开发者在开发过程中，进行更细的模块划分，更明确的接口，更详尽的测试。根据软件工程理论，1个bug越是在后期越是花费巨大的成本去修复，并且随着系统复杂度的增长，在一个大的系统中去查找某一个细节具体的问题，相比于在小的模块中去查找问题会花费多倍的时间成本。&lt;/p&gt;
&lt;h2 id=&quot;2单元测试框架解剖&quot; data-source-line=&quot;3&quot;&gt;2.单元测试框架解剖&lt;/h2&gt;
&lt;p data-source-line=&quot;4&quot;&gt;一般地单元测试需要实现以下几个基本功能：&lt;br/&gt;&lt;strong&gt;1. assert&lt;/strong&gt;&lt;br/&gt;各种assert，比如AssertTrue、比如AssertFail、AssertStrEquals、AssertIntEquals......&lt;br/&gt;条条大路通罗马，这些Assert有各种功能，其实就是包装了断言的函数。比如AssertStrEquals（str, &quot;open&quot;），进行str和字符串“open”的比较，如果不相同则会报错。&lt;br/&gt;根据框架的结构，在assert失败时候，有的进行长跳转longjmp，有的对类似failCount的全局的变量进行加1并记录错误位置。&lt;br/&gt;&lt;strong&gt;2. 错误位置记录&lt;/strong&gt;&lt;br/&gt;得益于C语言的LINE、FILE宏，这是2个ANSI C标志支持的内置宏定义，可以得到当前的的行数和文件名。 在断言失败的地方，记录文件名和行号，以供用户查询错误的位置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
char buf[HUGE_STRING_LEN];
sprintf(buf, &quot;%s:%d: &quot;, _FILE_, _LINE_);
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;17&quot;&gt;&lt;strong&gt;3. 测试case管理&lt;/strong&gt;&lt;br/&gt;这是测试框架区别于自己写的assert测试函数最根本的地方。 测试框架为了提高函数利用率，减少重复，方便测试例程汇总等，都会进行各种封装。比如以下几条。&lt;br/&gt;1）setup和teardown&lt;br/&gt;大部分的测试框架都提供这两个函数，主要是因为有些测试case，有大量重复的代码，比如准备输入数据，测试完毕后清理现场等通用的功能。&lt;br/&gt;2）测试例子汇总&lt;br/&gt;有的叫做TestSuit，有的叫做TestFixtures。把一类相似功能的测试case进行汇总，方便更高层次的调用，也方便用户管理测试例程。&lt;br/&gt;3）测试的调用&lt;br/&gt;多个测试例程汇总后，构成一个数组（表格），启动运行，一般由xxxRun函数负责。&lt;br/&gt;在嵌入式c中，一般都有一个函数指针来操作，这也是为什么所有的测试case的函数名称都使用相同的声明，test_case需要和调用该测试的指针同类型。&lt;/p&gt;
&lt;p data-source-line=&quot;29&quot;&gt;&lt;strong&gt;4. 测试的执行&lt;/strong&gt;&lt;br/&gt;测试的执行本质就是函数的长跳转。可以看做在父函数中调用子函数，这个子函数如果是测试例程的话，子函数就会包含assert相关的语句，而assert语句在出错后，会记录错位位置和错误消息，然后进行长跳转（longjmp），longjmp和setjmp（buf）成对出现，返回到调用的位置，然后进行下一个测试case。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt; ; i &amp;lt; testSuite-&amp;gt;count ; ++&lt;span&gt;i)
    {
        Test&lt;/span&gt;* testCase = testSuite-&amp;gt;&lt;span&gt;list[i];
        TestRun(testCase);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (testCase-&amp;gt;&lt;span&gt;failed) {
        testSuite&lt;/span&gt;-&amp;gt;failCount += &lt;span&gt;1&lt;/span&gt;&lt;span&gt;; 
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;3-测试框架的本质&quot; data-source-line=&quot;42&quot;&gt;3. 测试框架的本质&lt;/h2&gt;
&lt;p data-source-line=&quot;43&quot;&gt;1）为了更好的组织测试，提供的测试组的批量处理功能，一般由for循环遍历一个table数组实现；&lt;br/&gt;2）为了减少重复进行测公用函数提取，比如准备测试环境和清理现场；&lt;br/&gt;3）测试需要的各种断言；&lt;br/&gt;4）断言失败后的跳转、记录错误位置-FILE-, -LINE-宏的使用；&lt;br/&gt;5）测试case运行的监控和结果的汇总。&lt;/p&gt;
&lt;p data-source-line=&quot;43&quot;&gt;&lt;br/&gt;综上，如果你实现了上面的几个功能，那么也就自己完成了一个测试框架。&lt;br/&gt;其实测试框架是一个很简单的事情，如今测试框架有很多，像VS这样的IDE已经集成了单体测试，所以对于一个开发者怎么规划测试才是测试工作的第一要务。&lt;br/&gt;如何恰当的写测试用例，既不延误开发又不会造成工程臃肿，还能尽可能的覆盖测试范围，这才是测试中最花费功夫的地方。&lt;/p&gt;
</description>
<pubDate>Wed, 20 Jun 2018 14:21:00 +0000</pubDate>
<dc:creator>啊哈彭</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pingwen/p/9206406.html</dc:identifier>
</item>
</channel>
</rss>