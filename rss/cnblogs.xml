<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[原创]分布式系统之缓存的微观应用经验谈（四） 【交互场景篇】 - AutumnBing</title>
<link>http://www.cnblogs.com/bsfz/p/9867952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bsfz/p/9867952.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;分布式系统之缓存的微观应用经验谈（四） 【交互场景篇】&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　近几个月一直在忙些琐事，几乎年后都没怎么闲过。忙忙碌碌中就进入了2018年的秋天了，不得不感叹时间总是如白驹过隙，也不知道收获了什么和失去了什么。最近稍微休息，买了两本与技术无关的书，其一是 Yann Martel 写的《The High Mountains of Portugal》（葡萄牙的高山），发现阅读此书是需要一些耐心的，对人生暗喻很深，也有足够的留白，有兴趣的朋友可以细品下。好了，下面回归正题，尝试写写工作中缓存技术相关的一些实战经验和思考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;正文&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　在分布式Web程序设计中，解决高并发以及内部解耦的关键技术离不开缓存和队列，而缓存角色类似计算机硬件中CPU的各级缓存。如今的业务规模稍大的互联网项目，即使在最初beta版的开发上，都会进行预留设计。但是在诸多应用场景里，也带来了某些高成本的技术问题，需要细致权衡。本系列主要围绕分布式系统中服务端缓存相关技术，也会结合朋友间的探讨提及自己的思考细节。文中若有不妥之处，恳请指正。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;为了方便独立成文，原谅在内容排版上的一点点个人强迫症。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　第四篇打算作为系列最后一篇，这里尝试谈谈缓存的一些并发交互场景，包括与数据库（特指 RDBMS）交互，和一些独立的高并发场景相关补充处理方案（若涉及具体应用同样将主要以Redis举例）。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　另见：分布式系统之缓存的微观应用经验谈（三）（数据分片和集群篇）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　（https://yq.aliyun.com/u/autumnbing）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　　（https://www.cnblogs.com/bsfz/）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;一、简单谈下缓存和数据库的交互流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　为了便于后面的相关讨论，这里约定文中的数据库（Database）均指传统的 RDBMS，使用DB标识，同时需区别于缓存（Cache）里的DB划分空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　我在早前一篇缓存设计细节的文章里，有阐述关于 Cache 自身 CURD 时的一些具体细节，而这里将结合DB，就 DB 和 Cache 之间的并行 CURD 操作进行一些讨论。当然，这里面在交互层面上是一定会涉及到分布式事务（Distributed Transaction）相关的一致性话题，但为了避免表述出现模糊和不必要的边界放大，这里我尽可能剥离开来，专注在基于 Cache 的处理上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　预先抽象这样一个基础场景：DB中存在一张资金关联表（FT），这里 FT 里存储的都是热点条目（属于极高频访问数据），在系统设计时，FT里的数据将与对应的 Cache 服务 C1 进行关联存储（这里仅指一级缓存），以达到提升一定的并发查询性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　　&lt;strong&gt;　1.1 向 FT 中新增（Create）一条数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　通过 SQL 向 FT中插入一条数据：如果插入失败，则不需要对 C1有任何操作；如果插入成功，则此时需要判断，考虑是否在 C1中同步插入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　这种情景一般比较简单，如果没有特别的情况，此刻不需对 C1 做主动插入，而是后续被动插入（后面会提到）。但是如果插入 FT 中的数据往后操作只有删除这个动作，并且 FT的数据经常被批量操作，那么个人建议同步执行对 C1的插入操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　（PS：这里也顺便申明下，如果需要往C1插入，但插入失败，请根据业务场景加入重试机制，后面对Cache的操作均包含这个潜在的动作。至于重试处理失败的情况，如往C1插入一条数据，个人建议是不再过度处理，最终默认是整体操作成功，并进行对应状态返回。这里注意不要与分布式事务的一致性进行混合类比，后面不再赘述。）&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　　　&lt;strong&gt;1.2 准备更新（Update）一条数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　当需要更新 FT 中的一条数据时，意味着之前 C1 中的数据已经无效，而在一个高并发环境中这里无法做到统一的直接更新 C1。首先就需要考虑的是 C1 的数据是主动更新还是被动更新，主动更新即更新完 FT后，同时将数据覆盖进 C1，而被动更新指的是更新完 FT 后，立即淘汰 C1 中的数据，并等待下次查询时重新写入C1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　只要上述请求动作出现了任何并发，比如两个相同动作，动作1和动作2同时发生请求，那么会出现一个不一致的问题：动作1先操作 FT，动作2后操作 FT，然后动作2先操作了C1，动作1后操作了C1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　这样存在不止一个线程并发的更新 FT 数据时，无法确认更新 FT 的顺序和最终更新 C1 的顺序是否保持一致，结果是一定会出现大量 FT 和 C1 中数据出现幻读，而这个在存在主从Cache的情况下这种概率会大大提升（可参见上一章主从复制的部分）。推荐的方式是，如果不考虑Cache 多次需要重写的损耗，在没有其他特殊要求下，可以直接淘汰 C1 中的数据，也额外照顾到了Cache在合适的时候完全命中（Hit）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　其实到这里还没结束，当决定是淘汰 C1 的数据，那么就要选择一个淘汰时机：一种是先更新 FT，然后对C1 执行淘汰；一种则是，先对 C1 执行淘汰，然后才更新FT。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　虽然两种方式都有合适的场景，但这里需要权衡一种概率性问题：当对C1执行淘汰时，又并发了一个对C1的查询操作，此时，C1会从DB拉取数据重新写入，那么C1中即为脏数据，当并发越大，存在数据一直“脏”下去的概率更大。所以，这里更推荐的做法是选择前者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　（注意，这里还有一些去讨论的细节并不打算在此话题延伸，比如关于 C1和FT之间的原子性问题，是否可以采用二阶段/三阶段提交等模拟事务方式和对业务造成的影响。）&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　　&lt;strong&gt;　1.3 开始读取（Read）一条数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　这里就没有太多特别，毕竟应用Cache 的目的就已经说明了读取数据时，只需要遵循“先读Cache再读DB”。即先从C1里拿取数据，如果C1里不存在该数据，则从FT中搜索，搜索完成如果依然不存在该数据，则直接返回Empty状态。如果存在，则同时将该数据保存进C1中，并返回对应状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　顺带提一下，可能有人会说，在某些场景下，即使 C1中有数据，也要先从 FT里优先获取。我赞同，没错，但注意这里不要混淆讨论的主题了，这本质是属于基于一种业务结果的导向，就类似在传统 RDBMS 读写分离情况下，在关键数据的验证处，直接请求主库获取并操作。所以上面说的其实并没有矛盾，我们讨论时要明确清晰，不要混淆。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　　&lt;strong&gt;　1.4 从FT 中删除（Delete）一条数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　与Create相反的操作，通过 SQL 向 FT中移除一条数据：如果移除失败，则不需要对 C1 有任何操作，如删除成功，则将对应C1中数据移除（另外请类比1.2中的一些细节）。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　&lt;strong&gt;　二、谈谈缓存的穿透雪崩等相关问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　　　在项目发展到后期，一些业务场景整体都处于高并发状态，大量QPS对整体业务的负载要求很高，为了避免很多时候脱离架构优化的初衷，还需要在项目中做到很多预先性的规避和细节把控。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　　&lt;strong&gt;　2.1 优化防止缓存击穿&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　当请求发来的查询 Key 在 Cache 中存在，但某一时刻数据过期了，并且此时出现了大量并发请求，那么这里因为 Cache 中 Miss，就会统一去 DB 中搜索，直接造成在很短的时间内，DB 的 QPS 压力会陡增。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　对于这种问题的预防和优化，往往从两方面入手：一是程序中加小粒度的锁/信号（去年有写过一篇关于商城系统里库存并发管控杂记，里面有具体话题的细节扩展，详见：https://www.cnblogs.com/bsfz/ ）；二是将 DB的读取延迟 和 Cache的写入时间尽可能拉到最低；三是对其中过于热点的数据采取一个较大的过期时间并做一定的随机性（这里非必要，可自行权衡）。其实还有一点，少数情况下，可根据场景是否限制，可以增加适当的到期自动刷新的策略，这里也可以考虑在程序中开启固定的线程通知维护。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　　&lt;strong&gt;　2.2 预防大量缓存穿透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　当请求发来的查询 Key 在 Cache 中 Miss，自然就会去 DB 里搜索，这里本身没问题，但是假如查询的 Key 在 DB 中也不存在，那么意味着每次请求实际上都是实打实落在了 DB 上。这种问题比较常见，并且即使并发不是很大的时候 DB 的连接数也轻松达到上限，而且本身也不符合我们设计为了提高QPS的初衷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　　　　　对于这种漏洞性问题的解决方式，同样可以从两方面入手：一是程序可以在第一次从DB搜索数据为 NULL 的时候，直接将 NULL 或者一个标识符 Sign 缓存起来，同时个人建议尽量设置一个小范围的随机过期时间，避免不必要的长期内存占用；二是程序里限制过滤一些不可能存在的数据KEY，如借鉴 Bloom filter 思想，特别是在前端请求到后端的这里，尽量进行一次中间判断处理（如有时对不合法KEY直接返回NULL）。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 15:32:00 +0000</pubDate>
<dc:creator>AutumnBing</dc:creator>
<og:description>第四篇打算作为系列最后一篇，这里尝试谈谈缓存的一些并发交互场景，包括与数据库（特指 RDBMS）交互，和一些独立的高并发场景相关补充处理方案（若涉及具体应用同样将主要以Redis举例）。 另见：分布式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bsfz/p/9867952.html</dc:identifier>
</item>
<item>
<title>python爬虫实战：利用scrapy，短短50行代码下载整站短视频 - 马鸣谦</title>
<link>http://www.cnblogs.com/mamingqian/p/9867697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mamingqian/p/9867697.html</guid>
<description>&lt;p&gt;近日，有朋友向我求助一件小事儿，他在一个短视频app上看到一个好玩儿的段子，想下载下来，可死活找不到下载的方法。这忙我得帮，少不得就抓包分析了一下这个app，找到了视频的下载链接，帮他解决了这个小问题。&lt;/p&gt;
&lt;p&gt;因为这个事儿，勾起了我另一个念头，这不最近一直想把python爬虫方面的知识梳理梳理吗，干脆借机行事，正凑着短视频火热的势头，做一个短视频的爬虫好了，中间用到什么知识就理一理。&lt;/p&gt;
&lt;p&gt;我喜欢把事情说得很直白，如果恰好有初入门的朋友想了解爬虫的技术，可以将就看看，或许对你的认识会有提升。如果有高手路过，最好能指点一二，本人不胜感激。&lt;/p&gt;

&lt;h2&gt;爬虫是什么&lt;/h2&gt;
&lt;p&gt;爬虫就是一段能够从互联网上高效获取数据的程序。&lt;/p&gt;
&lt;p&gt;我们每天都在从互联网上获取数据。当打开浏览器访问百度的时候，我们就从百度的服务器获取数据，当拿起手机在线听歌的时候，我们就从某个app的服务器上获取数据。简单的归纳，这些过程都可以描述为：我们提交一个Request请求，服务器会返回一个Response数据，应用根据Response来渲染页面，给我们展示数据结果。&lt;/p&gt;
&lt;p&gt;爬虫最核心的也是这个过程，提交Requests——〉接受Response。就这样，很简单，当我们在浏览器里打开一个页面，看到页面内容的时候，我们就可以说这个页面被我们采集到了。&lt;/p&gt;
&lt;p&gt;只不过当我们真正进行数据爬取时，一般会需要采集大量的页面，这就需要提交许多的Requests，需要接受许多的Response。数量大了之后，就会涉及到一些比较复杂的处理，比如并发的，比如请求序列，比如去重，比如链接跟踪，比如数据存储，等等。于是，随着问题的延伸和扩展，爬虫就成为了一个相对独立的技术门类。&lt;/p&gt;
&lt;p&gt;但它的本质就是对一系列网络请求和网络响应的处理。&lt;/p&gt;
&lt;h2&gt;爬虫能做什么&lt;/h2&gt;
&lt;p&gt;爬虫的作用和目的只有一个，获取网络数据。我们知道，互联网是个数据的海洋，大量的信息漂浮在其中，想把这些资源收归己用，爬虫是最常用的方式。特别是最近几年大树据挖掘技术和机器学习以及知识图谱等技术的兴盛，更是对数据提出了更大的需求。另外也有很多互联网创业公司，在起步初期自身积累数据较少的时候，也会通过爬虫快速获取数据起步。&lt;/p&gt;

&lt;p&gt;如果你刚刚接触爬虫的概念，我建议你暂时不要使用scrapy框架。或者更宽泛的说，如果你刚刚接触某一个技术门类，我都不建议你直接使用框架，因为框架是对许多基础技术细节的高级抽象，如果你不了解底层实现原理就直接用框架多半会让你云里雾里迷迷糊糊。&lt;/p&gt;
&lt;p&gt;在入门爬虫之初，看scrapy的文档，你会觉得“太复杂了”。当你使用urllib或者Requests开发一个python的爬虫脚本，并逐个去解决了请求头封装、访问并发、队列去重、数据清洗等等问题之后，再回过头来学习scrapy，你会觉得它如此简洁优美，它能节省你大量的时间，它会为一些常见的问题提供成熟的解决方案。&lt;/p&gt;
&lt;h2&gt;scrapy数据流程图&lt;/h2&gt;
&lt;p&gt;这张图是对scrapy框架的经典描述，一时看不懂没有关系，用一段时间再回来看。或者把本文读完再回来看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496761/201810/1496761-20181028212232936-163927190.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在一些书上会把爬虫的基本抓取流程概括为UR&lt;sup&gt;2&lt;/sup&gt;IM，意思是数据爬取的过程是围绕URL、Request（请求）、Response（响应）、Item（数据项）、MoreUrl（更多的Url）展开的。上图的&lt;span&gt;绿色箭头&lt;/span&gt; &lt;span&gt;体现的正是这几个要素的流转过程。图中涉及的四个模块正是用于处理这几类对象的：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Spider模块：负责生成Request对象、解析Response对象、输出Item对象&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Scheduler模块：负责对Request对象的调度&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Downloader模块：负责发送Request请求，接收Response响应&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ItemPipleline模块：负责数据的处理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;scrapy Engine负责模块间的通信&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;各个模块和scrapy引擎之间可以添加一层或多层中间件，负责对出入该模块的UR&lt;sup&gt;2&lt;/sup&gt;IM对象进行处理。&lt;/p&gt;
&lt;h2&gt;scrapy的安装&lt;/h2&gt;
&lt;p&gt;参考官方文档，不再赘述。官方文档：https://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/install.html&lt;/p&gt;

&lt;p&gt;python的优雅之处在于能够让开发者专注于业务逻辑，花更少的时间在枯燥的代码编写调试上。scrapy无疑完美诠释了这一精神。&lt;/p&gt;
&lt;p&gt;开发爬虫的一般步骤是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;确定要爬取的数据（item）&lt;/li&gt;
&lt;li&gt;找到数据所在页面的url&lt;/li&gt;
&lt;li&gt;找到页面间的链接关系，确定如何跟踪（follow）页面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么，我们一步一步来。&lt;/p&gt;
&lt;p&gt;既然是使用scrapy框架，我们先创建项目：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
scrapy startproject DFVideo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 紧接着，我们创建一个爬虫：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
scrapy genspider -t crawl DfVideoSpider eastday.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是我们发现在当前目录下已经自动生成了一个目录：DFVideo&lt;/p&gt;
&lt;p&gt;目录下包括如图文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496761/201810/1496761-20181028220359686-2058101611.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;








&lt;p&gt;spiders文件夹下，自动生成了名为DfVideoSpider.py的文件。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496761/201810/1496761-20181028220555579-1038540780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;






&lt;p&gt;爬虫项目创建之后，我们来确定需要爬取的数据。在items.py中编辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import scrapy


class DfvideoItem(scrapy.Item):
    # define the fields for your item here like:
    # name = scrapy.Field()
    video_url = scrapy.Field()#视频源url
    video_title = scrapy.Field()#视频标题
    video_local_path = scrapy.Field()#视频本地存储路径
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来，我们需要确定视频源的url，这是很关键的一步。&lt;/p&gt;
&lt;p&gt;现在许多的视频播放页面是把视频链接隐藏起来的，这就使得大家无法通过右键另存为，防止了视频别随意下载。&lt;/p&gt;
&lt;p&gt;但是只要视频在页面上播放了，那么必然是要和视频源产生数据交互的，所以只要稍微抓下包就能够发现玄机。&lt;/p&gt;
&lt;p&gt;这里我们使用fiddler抓包分析。&lt;/p&gt;
&lt;p&gt;发现其视频播放页的链接类似于：video.eastday.com/a/180926221513827264568.html?index3lbt&lt;/p&gt;
&lt;p&gt;视频源的数据链接类似于：mvpc.eastday.com/vyule/20180415/20180415213714776507147_1_06400360.mp4&lt;/p&gt;
&lt;p&gt;有了这两个链接，工作就完成了大半：&lt;/p&gt;
&lt;p&gt;在DfVideoSpider.py中编辑&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
# -*- coding: utf-8 -*-
import scrapy
from scrapy.loader import ItemLoader
from scrapy.loader.processors import MapCompose,Join
from DFVideo.items import DfvideoItem
from scrapy.linkextractors import LinkExtractor
from scrapy.spiders import CrawlSpider, Rule
import time
from os import path
import os


class DfvideospiderSpider(CrawlSpider):
    name = 'DfVideoSpider'
    allowed_domains = ['eastday.com']
    start_urls = ['http://video.eastday.com/']

    rules = (
        Rule(LinkExtractor(allow=r'video.eastday.com/a/\d+.html'),
             callback='parse_item', follow=True),
    )

    def parse_item(self, response):
        item = DfvideoItem()
        try:
            item[&quot;video_url&quot;] = response.xpath('//input[@id=&quot;mp4Source&quot;]/@value').extract()[0]
            item[&quot;video_title&quot;] = response.xpath('//meta[@name=&quot;description&quot;]/@content').extract()[0]
            #print(item)
            item[&quot;video_url&quot;] = 'http:' + item['video_url']
            yield scrapy.Request(url=item['video_url'], meta=item, callback=self.parse_video)
        except:
            pass


    def parse_video(self, response):

        i = response.meta
        file_name = Join()([i['video_title'], '.mp4'])
        base_dir = path.join(path.curdir, 'VideoDownload')
        video_local_path = path.join(base_dir, file_name.replace('?', ''))
        i['video_local_path'] = video_local_path

        if not os.path.exists(base_dir):
            os.mkdir(base_dir)

        with open(video_local_path, &quot;wb&quot;) as f:
            f.write(response.body)

        yield i
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 至此，一个简单但强大的爬虫便完成了。&lt;/p&gt;
&lt;p&gt;如果你希望将视频的附加数据保存在数据库，可以在pipeline.py中进行相应的操作，比如存入mongodb中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from scrapy import log
import pymongo

class DfvideoPipeline(object):
    def __init__(self):

        self.mongodb = pymongo.MongoClient(host='127.0.0.1', port=27017)
        self.db = self.mongodb[&quot;DongFang&quot;]

        self.feed_set = self.db[&quot;video&quot;]
        # self.comment_set=self.db[comment_set]

        self.feed_set.create_index(&quot;video_title&quot;, unique=1)
        # self.comment_set.create_index(comment_index,unique=1)

    def process_item(self, item, spider):
        try:
            self.feed_set.update({&quot;video_title&quot;: item[&quot;video_title&quot;]}, item, upsert=True)
        except:
            log.msg(message=&quot;dup key: {}&quot;.format(item[&quot;video_title&quot;]), level=log.INFO)
        return item

    def on_close(self):
        self.mongodb.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 当然，你需要在setting.py中将pipelines打开：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
ITEM_PIPELINES = {
    'TouTiaoVideo.pipelines.ToutiaovideoPipeline': 300,
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;视频文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496761/201810/1496761-20181028222328833-489006776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;今天讲了爬虫的一些基础的概念，不深也不透，主要是通过一个案例给大家一个直观的认识。一些细节上的点后续会专门开文细讲，喜欢的朋友可以关注，一起探讨。&lt;/p&gt;
&lt;p&gt;本文所公布代码仅作为学习交流之用，请勿用于非法用途，负责后果自负。&lt;/p&gt;

</description>
<pubDate>Sun, 28 Oct 2018 14:31:00 +0000</pubDate>
<dc:creator>马鸣谦</dc:creator>
<og:description>近日，有朋友向我求助一件小事儿，他在一个短视频app上看到一个好玩儿的段子，想下载下来，可死活找不到下载的方法。这忙我得帮，少不得就抓包分析了一下这个app，找到了视频的下载链接，帮他解决了这个小问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mamingqian/p/9867697.html</dc:identifier>
</item>
<item>
<title>webpack4.x最详细入门讲解 - Better-Man</title>
<link>http://www.cnblogs.com/BetterMan-/p/9867642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BetterMan-/p/9867642.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;Webpack其实没有想象中的那么难，用得多了，其实套路都一样，本文主要是针对webpack4.x版本，会对平时常用的Webpack配置一一讲解，所以本文也比较长，但如果你能动手跟着本文中的例子完整写一次，相信你会觉得Webpack也不过如此。&lt;/p&gt;
&lt;h4 id=&quot;一什么是webpack为什么使用它&quot;&gt;一、什么是webpack，为什么使用它？&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028215850562-752614317.png&quot; alt=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;什么是webpack&quot;&gt;1.1 什么是webpack？&lt;/h6&gt;
&lt;p&gt;简单来说，它其实就是一个&lt;strong&gt;模块打包器&lt;/strong&gt;。&lt;/p&gt;
&lt;h6 id=&quot;为什么使用它&quot;&gt;1.2 为什么使用它？&lt;/h6&gt;
&lt;p&gt;如果像以前开发时一个html文件可能会引用十几个js文件,而且顺序还不能乱，因为它们存在依赖关系，同时对于ES6+等新的语法，less, sass等CSS预处理都不能很好的解决……，此时就需要一个处理这些问题的工具。&lt;/p&gt;
&lt;p&gt;Webpack就是为处理这些问题而生的，它就是把你的项目当成一个整体，通过一个入口主文件（如：index.js）,从这个文件开始找到你的项目所有的依赖文件并处理它们，最后打包成一个（或多个）浏览器可识别的JavaScript文件。&lt;/p&gt;
&lt;h4 id=&quot;二一个简单的打包例子&quot;&gt;二、一个简单的打包例子&lt;/h4&gt;
&lt;h6 id=&quot;准备工作&quot;&gt;2.1 准备工作&lt;/h6&gt;
&lt;p&gt;首先新建一个空文件夹，用于创建项目，在终端中进入文件夹，如下我在桌面建了一个名为webpack-project的文件夹，使用终端进入文件夹后（如果对命令行不太熟悉，可参考我的博客：&lt;a href=&quot;https://www.cnblogs.com/BetterMan-/p/9699325.html&quot;&gt;前端常用命令行&lt;/a&gt;），使用&lt;code&gt;npm init&lt;/code&gt;命令创建一个package.json文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm init&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028215924815-1440033072.png&quot; alt=&quot;2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入这个命令后，终端会问你一系列诸如项目名称，项目描述，作者等信息，不过如果你不打算发布这个模块，直接一路回车就好。（也可以使用&lt;code&gt;npm init -y&lt;/code&gt;这个命令来一次生成package.json文件，这样终端不会询问你问题）。&lt;/p&gt;
&lt;h6 id=&quot;安装webpack&quot;&gt;2.2 安装webpack&lt;/h6&gt;
&lt;p&gt;如果你想一步到位的话，就把全局webpack和本地项目webpack全都先装了，因为后面一些模块会用到。安装本地项目webapck时把webpack-cli也装上，因为webpack模块把一些功能分到了webpack-cli模块，安装方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install webpack --global                //这是安装全局webpack命令
npm install webpack webpack-cli --save-dev  //这是安装本地项目模块&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;tips&quot;&gt;tips:&lt;/h6&gt;
&lt;blockquote readability=&quot;9.7352941176471&quot;&gt;
&lt;p&gt;上述命令可采用简写，&lt;code&gt;install&lt;/code&gt;可简写为&lt;code&gt;i&lt;/code&gt;,&lt;code&gt;--global&lt;/code&gt;可简写为&lt;code&gt;-g&lt;/code&gt;,&lt;code&gt;--save-dev&lt;/code&gt;可简写为&lt;code&gt;-D&lt;/code&gt;(这个命令是用于把配置添加到package.json的开发环境配置列表中，后面会提到)，&lt;code&gt;--save&lt;/code&gt;可简写为&lt;code&gt;-S&lt;/code&gt;，同时国内我们可以采用cnpm，配置方法可&lt;a href=&quot;http://npm.taobao.org/&quot;&gt;去这里&lt;/a&gt;查看，这样安装速度会相对较快。如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;cnpm i webpack -g               //这是安装全局webpack命令
cnpm i webpack webpack-cli -D   //这是安装本地项目模块&lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;新建文件&quot;&gt;2.3 新建文件&lt;/h6&gt;
&lt;p&gt;在&lt;code&gt;webpack-project&lt;/code&gt;文件夹中新建两个文件夹，分别为src文件夹和dist文件夹，接下来再创建三个文件:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;index.html&lt;/code&gt; --放在dist文件夹中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hello.js&lt;/code&gt; --放在src文件夹中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;index.js&lt;/code&gt; --放在src文件夹中；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此时，项目结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028215939056-440061193.png&quot; alt=&quot;3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在&lt;code&gt;index.html&lt;/code&gt;中写下&lt;code&gt;html&lt;/code&gt;代码，它的作用是为了引入我们打包后的js文件：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Webpack Project&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div id='root'&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;script src=&quot;bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;   &amp;lt;!--这是打包之后的js文件，我们暂时命名为bundle.js--&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在&lt;code&gt;hello.js&lt;/code&gt;中导出一个模块：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// hello.js
module.exports = function() {
    let hello = document.createElement('div');
    hello.innerHTML = &quot;Long time no see!&quot;;
    return hello;
  };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在&lt;code&gt;index.js&lt;/code&gt;中引入这个模块（&lt;code&gt;hello.js&lt;/code&gt;）:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//index.js 
const hello = require('./hello.js');
document.querySelector(&quot;#root&quot;).appendChild(hello());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述操作就相当于我们把&lt;code&gt;hello.js&lt;/code&gt;模块合并到了&lt;code&gt;index.js&lt;/code&gt;模块，之后我们打包时就只需把&lt;code&gt;index.js&lt;/code&gt;模块打包成&lt;code&gt;bundle.js&lt;/code&gt;，然后供&lt;code&gt;index.html&lt;/code&gt;引用即可，这就是最简单的webpack打包原理。&lt;/p&gt;
&lt;h6 id=&quot;开始进行webpack打包&quot;&gt;2.4 开始进行webpack打包&lt;/h6&gt;
&lt;p&gt;在终端中使用如下命令进行打包：&lt;br/&gt;&lt;code&gt;// webpack全局安装的情况下 webpack src/index.js --output dist/bundle.js // --output可简写为-o&lt;/code&gt;&lt;br/&gt;上述就相当于把&lt;code&gt;src&lt;/code&gt;文件夹下的&lt;code&gt;index.js&lt;/code&gt;文件打包到&lt;code&gt;dist&lt;/code&gt;文件下的&lt;code&gt;bundle.js&lt;/code&gt;，这时就生成了&lt;code&gt;bundle.js&lt;/code&gt;供&lt;code&gt;index.html&lt;/code&gt;文件引用。&lt;/p&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028215953601-1648062544.png&quot; alt=&quot;4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出webpack同时编译了&lt;code&gt;index.js&lt;/code&gt;和&lt;code&gt;hello.js&lt;/code&gt;,现在打开&lt;code&gt;index.html&lt;/code&gt;,可以看到如下结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220007236-1204768022.png&quot; alt=&quot;5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没错，我们已经成功使用webpack进行打包，原来webpack也不过如此嘛！但是，每次都在终端中输入这么长的命令，感觉好烦啊，还好有懒人方法，让我们看看。&lt;/p&gt;
&lt;h6 id=&quot;通过配置文件来使用webpack&quot;&gt;2.5 通过配置文件来使用webpack&lt;/h6&gt;
&lt;p&gt;其实webpack是有很多功能的，也是很方便的，我们可以在当前项目的根目录下新建一个配置文件&lt;code&gt;webpack.config.js&lt;/code&gt;，我们写下如下简单配置代码，目前只涉及入口配置（相当于我们的&lt;code&gt;index.js&lt;/code&gt;，从它开始打包）和出口配置（相当于我们打包生成的&lt;code&gt;bundle.js&lt;/code&gt;）。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
module.exports = {
    entry: __dirname + &quot;/src/index.js&quot;, // 入口文件
    output: {
        path: __dirname + &quot;/dist&quot;, //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：&lt;code&gt;__dirname&lt;/code&gt;是node.js中的一个全局变量，它指向当前执行脚本所在的目录，即C:\Users\sjt\DeskTop\webpack-project（这是我当前的目录）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但平时我们看到的脚手架配置也比较喜欢采用node.js的&lt;code&gt;path&lt;/code&gt;模块来处理绝对路径，所以我们也可以采用如下的写法，和上述的效果是一样的：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const path = require('path');
module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：&lt;code&gt;path.join&lt;/code&gt;的功能是拼接路径片段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了这个配置文件，我们只需在终端中运行&lt;code&gt;webpack&lt;/code&gt;命令就可进行打包，这条命令会自动引用webpack.config.js文件中的配置选项，示例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220025425-148053992.png&quot; alt=&quot;6&quot;/&gt;&lt;/p&gt;
&lt;p&gt;搞定，是不是这样更方便了，感觉没那么low了，但还能不能更便捷智能呢？那必须的！&lt;/p&gt;
&lt;h6 id=&quot;更智能的打包方式&quot;&gt;2.6 更智能的打包方式&lt;/h6&gt;
&lt;p&gt;我们现在只在终端中使用&lt;code&gt;webpack&lt;/code&gt;命令来进行打包，要是以后在打包的同时还有更多的操作呢，那不是还得写上更多的命令？所以我们得想办法把这些命令都集成起来，这时候之前的&lt;code&gt;package.json&lt;/code&gt;文件就派上用场了。&lt;br/&gt;现在的package.json文件大概就是如下这样：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;name&quot;: &quot;webpack-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot; //我们要修改的是这里，JSON文件不支持注释，引用时请清除
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;webpack&quot;: &quot;^4.23.1&quot;,
    &quot;webpack-cli&quot;: &quot;^3.1.2&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;name&quot;: &quot;webpack-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack&quot;, //改成这样，注意使用时把注释删掉
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;webpack&quot;: &quot;^4.23.1&quot;,
    &quot;webpack-cli&quot;: &quot;^3.1.2&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：package.json中的script会按你设置的命令名称来执行对应的命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样我们就可以在终端中直接执行&lt;code&gt;npm start&lt;/code&gt;命令来进行打包，&lt;code&gt;start&lt;/code&gt;命令比较特殊，可以直接&lt;code&gt;npm&lt;/code&gt;加上&lt;code&gt;start&lt;/code&gt;就可以执行，如果我们想起其他的名称，如&lt;code&gt;build&lt;/code&gt;时，就需要使用&lt;code&gt;npm run&lt;/code&gt;加上&lt;code&gt;build&lt;/code&gt;，即&lt;code&gt;npm run build&lt;/code&gt;命令。&lt;br/&gt;现在我们执行&lt;code&gt;npm start&lt;/code&gt;命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220037449-1046667047.png&quot; alt=&quot;7&quot;/&gt;&lt;/p&gt;
&lt;p&gt;OK，搞定，是不是很简单，但webpack的功能远不止于此，下面我们继续。&lt;/p&gt;
&lt;h4 id=&quot;三构建本地服务器&quot;&gt;三、构建本地服务器&lt;/h4&gt;
&lt;p&gt;现在我们是通过打开本地文件来查看页面的，看起来总感觉比较low，看别人用vue，react框架时都是运行在本地服务器上的，那我们能不能也那样呢？那必须的！&lt;/p&gt;
&lt;h6 id=&quot;webpack-dev-server配置本地服务器&quot;&gt;3.1 webpack-dev-server配置本地服务器&lt;/h6&gt;
&lt;p&gt;Webpack提供了一个可选的本地开发服务器，这个本地服务器基于node.js构建，它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;cnpm i webpack-dev-server -D&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;devServer作为webpack配置选项中的一项，以下是它的一些配置选项:&lt;br/&gt;| devServer配置选项 | 功能描述 |&lt;br/&gt;| ------ | ------ |&lt;br/&gt;| contentBase | 设置服务器所读取文件的目录，当前我们设置为&quot;./dist&quot; |&lt;br/&gt;| port | 设置端口号，如果省略，默认为&lt;code&gt;8080&lt;/code&gt; |&lt;br/&gt;| inline | 设置为&lt;code&gt;true&lt;/code&gt;，当源文件改变时会自动刷新页面 |&lt;br/&gt;| historyApiFallback | 设置为&lt;code&gt;true&lt;/code&gt;，所有的跳转将指向&lt;code&gt;index.html&lt;/code&gt; |&lt;/p&gt;
&lt;p&gt;现在我们把这些配置加到&lt;code&gt;webpack.config.js&lt;/code&gt;文件上，如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const path = require('path');
module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    },
    devServer: {
        contentBase: &quot;./dist&quot;, // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,   // 设置端口号为8088
        inline: true, // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们继续在&lt;code&gt;package.json&lt;/code&gt;文件中添加启动命令：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;name&quot;: &quot;webpack-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack&quot;,
    &quot;dev&quot;: &quot;webpack-dev-server --open&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;webpack&quot;: &quot;^4.23.1&quot;,
    &quot;webpack-cli&quot;: &quot;^3.1.2&quot;,
    &quot;webpack-dev-server&quot;: &quot;^3.1.10&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们把&lt;code&gt;start&lt;/code&gt;命令名称改为了&lt;code&gt;build&lt;/code&gt;，这样比较语义化，平时的脚手架也多数采用这个名称，我们用&lt;code&gt;dev&lt;/code&gt;（development的缩写，意指开发环境）来启动本地服务器，&lt;code&gt;webpack-dev-server&lt;/code&gt;就是启动服务器的命令，&lt;code&gt;--open&lt;/code&gt;是用于启动完服务器后自动打开浏览器，这时候我们自定义命令方式的便捷性就体现出来了，可以多个命令集成在一起运行，即我们定义了一个&lt;code&gt;dev&lt;/code&gt;命令名称就可以同时运行了&lt;code&gt;webpack-dev-server&lt;/code&gt;和&lt;code&gt;--open&lt;/code&gt;两个命令。&lt;/p&gt;
&lt;p&gt;现在在终端输入&lt;code&gt;npm run dev&lt;/code&gt;运行服务器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220051243-1068981107.png&quot; alt=&quot;8&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们即可在http://localhost:8088/中查看页面(退出服务器，可使用&lt;code&gt;ctrl+c&lt;/code&gt;后，再按&lt;code&gt;y&lt;/code&gt;确认，即可退出服务器运行)&lt;/p&gt;
&lt;h6 id=&quot;source-maps调试配置&quot;&gt;3.2 Source Maps调试配置&lt;/h6&gt;
&lt;p&gt;作为开发，代码调试当然少不了，那么问题来了，经过打包后的文件，你是不容易找到出错的地方的，&lt;code&gt;Source Map&lt;/code&gt;就是用来解决这个问题的。&lt;/p&gt;
&lt;p&gt;通过如下配置，我们会在打包时生成对应于打包文件的&lt;code&gt;.map&lt;/code&gt;文件，使得编译后的代码可读性更高，更易于调试。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const path = require('path');
module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    },
    devServer: {
        contentBase: &quot;./dist&quot;, // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,  // 设置端口号为8088
        inline: true, // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
    },
    devtool: 'source-map'  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置好后，我们再次运行&lt;code&gt;npm run build&lt;/code&gt;进行打包，这时我们会发现在&lt;code&gt;dist&lt;/code&gt;文件夹中多出了一个&lt;code&gt;bundle.js.map&lt;/code&gt;文件如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220103471-2022126498.png&quot; alt=&quot;9&quot;/&gt;&lt;br/&gt;如果我们的代码有bug，在浏览器的调试工具中会提示错误出现的位置，这就是&lt;code&gt;devtool: 'source-map'&lt;/code&gt;配置项的作用。&lt;/p&gt;
&lt;h4 id=&quot;四loaders&quot;&gt;四、Loaders&lt;/h4&gt;
&lt;p&gt;loaders是webpack最强大的功能之一，通过不同的loader，webpack有能力调用外部的脚本或工具，实现对不同格式的文件的处理，例如把&lt;code&gt;scss&lt;/code&gt;转为&lt;code&gt;css&lt;/code&gt;，将ES66、ES7等语法转化为当前浏览器能识别的语法，将JSX转化为js等多项功能。&lt;/p&gt;
&lt;p&gt;Loaders需要单独安装并且需要在&lt;code&gt;webpack.config.js&lt;/code&gt;中的&lt;code&gt;modules&lt;/code&gt;配置项下进行配置，Loaders的配置包括以下几方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;test&lt;/code&gt;：一个用以匹配loaders所处理文件的拓展名的正则表达式（必须）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loader&lt;/code&gt;：loader的名称（必须）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;include/exclude&lt;/code&gt;：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;options&lt;/code&gt;：为loaders提供额外的设置选项（可选）&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;配置css-loader&quot;&gt;4.1 配置css-loader&lt;/h6&gt;
&lt;p&gt;如果我们要加载一个css文件，需要安装配置&lt;code&gt;style-loader&lt;/code&gt;和&lt;code&gt;css-loader&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cnpm i style-loader css-loader -D&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const path = require('path');
module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    },
    devServer: {
        contentBase: &quot;./dist&quot;, // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,  // 设置端口号为8088
        inline: true, // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
    },
    devtool: 'source-map',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ['style-loader', 'css-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            }
        ]
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在src文件夹下新建&lt;code&gt;css&lt;/code&gt;文件夹，该文件夹内新建&lt;code&gt;style.css&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* style.css */
body {
    background: gray;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;index.js&lt;/code&gt;中引用它：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//index.js 
import './css/style.css';  //导入css

const hello = require('./hello.js');
document.querySelector(&quot;#root&quot;).appendChild(hello());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时我们运行&lt;code&gt;npm run dev&lt;/code&gt;，会发现页面背景变成了灰色。&lt;/p&gt;
&lt;p&gt;如果是要编译sass文件呢？&lt;/p&gt;
&lt;h6 id=&quot;配置sass&quot;&gt;4.2 配置sass&lt;/h6&gt;
&lt;pre&gt;
&lt;code&gt;cnpm i sass-loader node-sass -D // 因为sass-loader依赖于node-sass，所以还要安装node-sass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加sass的rules:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const path = require('path');
module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    },
    devServer: {
        contentBase: &quot;./dist&quot;, // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,  // 设置端口号为8088
        inline: true, // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
    },
    devtool: 'source-map',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ['style-loader', 'css-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {
                test: /\.(scss|sass)$/,   // 正则匹配以.scss和.sass结尾的文件
                use: ['style-loader', 'css-loader', 'sass-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            }
        ]
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在css文件夹中新建&lt;code&gt;blue.scss&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre class=&quot;scss&quot;&gt;
&lt;code&gt;/* blue.scss */
$blue: blue;
body{
    color: $blue;
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;index.js&lt;/code&gt;中引入&lt;code&gt;blue.scss&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//index.js 
import './css/style.css';   // 导入css
import './css/blue.scss';   // 导入scss

const hello = require('./hello.js');
document.querySelector(&quot;#root&quot;).appendChild(hello());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时&lt;code&gt;npm run dev&lt;/code&gt;重新启动服务器，应该会出现如下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220114674-2019467125.png&quot; alt=&quot;10&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有诸如图片loader、字体loader等就不一一列出来了，感兴趣的可前往&lt;a href=&quot;https://www.webpackjs.com/guides/asset-management/&quot;&gt;webpack官网&lt;/a&gt;查看，都是一样的套路。&lt;/p&gt;
&lt;h4 id=&quot;五babel&quot;&gt;五、Babel&lt;/h4&gt;
&lt;p&gt;Babel其实是一个编译JavaScript的平台，它可以编译代码帮你达到以下目的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;让你能使用最新的JavaScript代码（ES6，ES7...），而不用管新标准是否被当前使用的浏览器完全支持；&lt;/li&gt;
&lt;li&gt;让你能使用基于JavaScript进行了拓展的语言，比如React的JSX；&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;babel的安装与配置&quot;&gt;5.1 Babel的安装与配置&lt;/h6&gt;
&lt;p&gt;Babel其实是几个模块化的包，其核心功能位于称为&lt;code&gt;babel-core&lt;/code&gt;的npm包中，webpack可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析ES6的&lt;code&gt;babel-preset-env&lt;/code&gt;包和解析JSX的&lt;code&gt;babel-preset-react&lt;/code&gt;包）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cnpm i babel-core babel-loader babel-preset-env babel-preset-react -D
// babel-preset-env的env表示是对当前环境的预处理，而不是像以前使用babel-preset-es2015只能针对某个环境&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const path = require('path');
module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    },
    devServer: {
        contentBase: &quot;./dist&quot;, // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,  // 设置端口号为8088
        inline: true, // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
    },
    devtool: 'source-map',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ['style-loader', 'css-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {
                test: /\.(scss|sass)$/,   // 正则匹配以.scss和.sass结尾的文件
                use: ['style-loader', 'css-loader', 'sass-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {                             // jsx配置
                test: /(\.jsx|\.js)$/,   
                use: {                    // 注意use选择如果有多项配置，可写成这种对象形式
                    loader: &quot;babel-loader&quot;,
                    options: {
                        presets: [
                            &quot;env&quot;, &quot;react&quot;
                        ]
                    }
                },
                exclude: /node_modules/
            }
        ]
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们已经可以支持ES6及JSX的语法了，我们用react来试试，但使用react还得先安装两个模块&lt;code&gt;react&lt;/code&gt;和&lt;code&gt;react-dom&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cnpm i react react-dom -D&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们把&lt;code&gt;hello.js&lt;/code&gt;文件修改一下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// hello.js
import React, {Component} from 'react'; // 这两个模块必须引入

let name = Alan;

export default class Hello extends Component{
    render() {
        return (
            &amp;lt;div&amp;gt;
                {name}
            &amp;lt;/div&amp;gt;
        );
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;index.js&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//index.js 
import './css/style.css';  // 导入css
import './css/blue.scss';  // 导入scss

import React from 'react';
import {render} from 'react-dom';
import Hello from './hello'; // 可省略.js后缀名

render(&amp;lt;Hello /&amp;gt;, document.getElementById('root'));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时运行&lt;code&gt;npm run dev&lt;/code&gt;后你可能会发现如下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220127040-1188524929.png&quot; alt=&quot;11&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是因为官方默认&lt;code&gt;babel-loader | babel&lt;/code&gt;对应的版本需要一致: 即&lt;code&gt;babel-loader&lt;/code&gt;需要搭配最新版本&lt;code&gt;babel&lt;/code&gt;，详细可参考&lt;a href=&quot;https://www.cnblogs.com/soyxiaobi/p/9554565.html&quot;&gt;这篇博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;两种解决方案:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;回退低版本&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;cnpm i babel-loader@7 babel-core babel-preset-env -D&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;更新到最高版本:&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;cnpm i babel-loader @babel/core @babel/preset-env webpack -D&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我这里采取的是第一个方案，回退后，再此运行&lt;code&gt;npm run dev&lt;/code&gt;，得到如下结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220138019-1372767647.png&quot; alt=&quot;12&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里了是不是感觉很爽，不就是配置嘛，想要使用什么就配置什么。&lt;/p&gt;
&lt;h6 id=&quot;优化babel配置&quot;&gt;5.2 优化babel配置&lt;/h6&gt;
&lt;p&gt;虽然babel完全可以在&lt;code&gt;webpack.config.js&lt;/code&gt;中进行配置，但现在不是都提倡模块化嘛，也许之后babel膨胀了，增加了更多的配置项呢？&lt;br/&gt;那我们不如把它提取出来，把它放到根目录下的&lt;code&gt;.babelrc&lt;/code&gt;文件下（webpack会自动调用&lt;code&gt;.babelrc&lt;/code&gt;里的babel配置选项）。&lt;/p&gt;
&lt;p&gt;我们在项目根目录下新建&lt;code&gt;.babelrc&lt;/code&gt;文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220149499-1836743362.png&quot; alt=&quot;13&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const path = require('path');
module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    },
    devServer: {
        contentBase: &quot;./dist&quot;, // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,  // 设置端口号为8088
        inline: true, // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
    },
    devtool: 'source-map',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ['style-loader', 'css-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {
                test: /\.(scss|sass)$/,   // 正则匹配以.scss和.sass结尾的文件
                use: ['style-loader', 'css-loader', 'sass-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {                             // jsx配置
                test: /(\.jsx|\.js)$/,   
                use: {                    // 注意use选择如果有多项配置，可写成这种对象形式
                    loader: &quot;babel-loader&quot;
                },
                exclude: /node_modules/   // 排除匹配node_modules模块
            }
        ]
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;// .babelrc 使用时把注释删掉，该文件不能添加注释
{
    &quot;presets&quot;: [&quot;env&quot;, &quot;react&quot;]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时不出问题的话应该一切运行正常，接下来让我们进入强大的插件模块。&lt;/p&gt;
&lt;h4 id=&quot;六插件plugins&quot;&gt;六、插件（Plugins）&lt;/h4&gt;
&lt;p&gt;插件（Plugins）是用来拓展Webpack功能的，它们会在整个构建过程中生效，执行相关的任务。&lt;br/&gt;Loaders和Plugins常常被弄混，但是他们其实是完全不同的东西，可以这么来说，loaders是在打包构建过程中用来处理源文件的（JSX，Scss，Less..），一次处理一个，插件并不直接操作单个文件，它直接对整个构建过程其作用。&lt;/p&gt;
&lt;h6 id=&quot;如何使用&quot;&gt;6.1 如何使用&lt;/h6&gt;
&lt;p&gt;使用某个插件，需要通过&lt;code&gt;npm&lt;/code&gt;进行安装，然后在&lt;code&gt;webpack.config.js&lt;/code&gt;配置文件的&lt;code&gt;plugins&lt;/code&gt;(是一个数组)配置项中添加该插件的实例，下面我们先来使用一个简单的版权声明插件。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const webpack = require('webpack');  // 这个插件不需要安装，是基于webpack的，需要引入webpack模块

module.exports = {
    ...
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ['style-loader', 'css-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {
                test: /\.(scss|sass)$/,   // 正则匹配以.scss和.sass结尾的文件
                use: ['style-loader', 'css-loader', 'sass-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {                             // jsx配置
                test: /(\.jsx|\.js)$/,   
                use: {                    // 注意use选择如果有多项配置，可写成这种对象形式
                    loader: &quot;babel-loader&quot;
                },
                exclude: /node_modules/   // 排除匹配node_modules模块
            }
        ]
    },
    plugins: [
        new webpack.BannerPlugin('版权所有，翻版必究')  // new一个插件的实例 
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行&lt;code&gt;npm run build&lt;/code&gt;打包后我们看到&lt;code&gt;bundle.js&lt;/code&gt;文件显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220201562-1891928150.png&quot; alt=&quot;14&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;自动生成html文件htmlwebpackplugin&quot;&gt;6.2 自动生成html文件(HtmlWebpackPlugin)&lt;/h6&gt;
&lt;p&gt;到目前为止我们都是使用一开始建好的&lt;code&gt;index.html&lt;/code&gt;文件，而且也是手动引入&lt;code&gt;bundle.js&lt;/code&gt;，要是以后我们引入不止一个js文件，而且更改js文件名的话，也得手动更改&lt;code&gt;index.html&lt;/code&gt;中的js文件名，所以能不能自动生成&lt;code&gt;index.html&lt;/code&gt;且自动引用打包后的js呢？&lt;code&gt;HtmlWebpackPlugin&lt;/code&gt;插件就是用来解决这个问题的：&lt;/p&gt;
&lt;p&gt;首先安装该插件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cnpm i html-webpack-plugin -D&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们对项目结构进行一些更改：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把&lt;code&gt;dist&lt;/code&gt;整个文件夹删除；&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;src&lt;/code&gt;文件夹下新建一个&lt;code&gt;index.template.html&lt;/code&gt;(名称自定义)文件模板（当然这个是可选的，因为就算不设置模板，&lt;code&gt;HtmlWebpackPlugin&lt;/code&gt;插件也会生成默认&lt;code&gt;html&lt;/code&gt;文件，这里我们设置模块会让我们的开发更加灵活），如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!-- index.template.html --&amp;gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Here is Template&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id='root'&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;webpack.config.js&lt;/code&gt;中我们引入了&lt;code&gt;HtmlWebpackPlugin&lt;/code&gt;插件，并配置了引用了我们设置的模板，如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
const path = require('path');  // 路径处理模块
const webpack = require('webpack');  // 这个插件不需要安装，是基于webpack的，需要引入webpack模块
const HtmlWebpackPlugin = require('html-webpack-plugin'); // 引入HtmlWebpackPlugin插件

module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    },
    devServer: {
        contentBase: &quot;./dist&quot;, // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,  // 设置端口号为8088
        inline: true, // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
    },
    devtool: 'source-map',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ['style-loader', 'css-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {
                test: /\.(scss|sass)$/,   // 正则匹配以.scss和.sass结尾的文件
                use: ['style-loader', 'css-loader', 'sass-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {                             // jsx配置
                test: /(\.jsx|\.js)$/,   
                use: {                    // 注意use选择如果有多项配置，可写成这种对象形式
                    loader: &quot;babel-loader&quot;
                },
                exclude: /node_modules/   // 排除匹配node_modules模块
            }
        ]
    },
    plugins: [
        new webpack.BannerPlugin('版权所有，翻版必究'),  // new一个插件的实例 
        new HtmlWebpackPlugin({
            template: path.join(__dirname, &quot;/src/index.template.html&quot;)// new一个这个插件的实例，并传入相关的参数
        })
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们使用&lt;code&gt;npm run build&lt;/code&gt;进行打包，你会发现，&lt;code&gt;dist&lt;/code&gt;文件夹和&lt;code&gt;html&lt;/code&gt;文件都会自动生成，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220214163-970720656.png&quot; alt=&quot;15&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么会自动生成&lt;code&gt;dist&lt;/code&gt;文件夹呢？因为我们在&lt;code&gt;output&lt;/code&gt;出口配置项中定义了出口文件所在的位置为&lt;code&gt;dist&lt;/code&gt;文件夹，且出口文件名为&lt;code&gt;bundle.js&lt;/code&gt;，所以&lt;code&gt;HtmlWebpackPlugin&lt;/code&gt;会自动帮你在&lt;code&gt;index.html&lt;/code&gt;中引用名为&lt;code&gt;bundle.js&lt;/code&gt;文件，如果你在&lt;code&gt;webpack.config.js&lt;/code&gt;文件中更改了出口文件名，&lt;code&gt;index.html&lt;/code&gt;中也会自动更改该文件名，这样以后修改起来是不是方便多了？&lt;/p&gt;
&lt;h6 id=&quot;清理dist文件夹cleanwebpackplugin&quot;&gt;6.3 清理&lt;code&gt;/dist&lt;/code&gt;文件夹(CleanWebpackPlugin)&lt;/h6&gt;
&lt;p&gt;你可能已经注意到，在我们删掉&lt;code&gt;/dist&lt;/code&gt;文件夹之前，由于前面的代码示例遗留，导致我们的&lt;code&gt;/dist&lt;/code&gt;文件夹比较杂乱。&lt;code&gt;webpack&lt;/code&gt;会生成文件，然后将这些文件放置在&lt;code&gt;/dist&lt;/code&gt;文件夹中，但是&lt;code&gt;webpack&lt;/code&gt;无法追踪到哪些文件是实际在项目中用到的。&lt;/p&gt;
&lt;p&gt;通常，在每次构建前清理&lt;code&gt;/dist&lt;/code&gt;文件夹，是比较推荐的做法，因此只会生成用到的文件，这时候就用到&lt;code&gt;CleanWebpackPlugin&lt;/code&gt;插件了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cnpm i clean-webpack-plugin -D&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
...
const CleanWebpackPlugin = require('clean-webpack-plugin'); // 引入CleanWebpackPlugin插件

module.exports = {
    ...
    plugins: [
        new webpack.BannerPlugin('版权所有，翻版必究'),  // new一个插件的实例 
        new HtmlWebpackPlugin({
            template: path.join(__dirname, &quot;/src/index.template.html&quot;)// new一个这个插件的实例，并传入相关的参数
        }),
        new CleanWebpackPlugin(['dist']),  // 所要清理的文件夹名称
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插件的使用方法都是一样的，首先引入，然后new一个实例，实例可传入参数。&lt;/p&gt;
&lt;p&gt;现在我们运行&lt;code&gt;npm run build&lt;/code&gt;后就会发现，webpack会先将&lt;code&gt;/dist&lt;/code&gt;文件夹删除，然后再生产新的&lt;code&gt;/dist&lt;/code&gt;文件夹。&lt;/p&gt;
&lt;h6 id=&quot;热更新hotmodulereplacementplugin&quot;&gt;6.4 热更新(HotModuleReplacementPlugin)&lt;/h6&gt;
&lt;p&gt;&lt;code&gt;HotModuleReplacementPlugin&lt;/code&gt;（HMR）是一个很实用的插件，可以在我们修改代码后自动刷新预览效果。&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;devServer&lt;/code&gt;配置项中添加&lt;code&gt;hot: true&lt;/code&gt;参数。&lt;/li&gt;
&lt;li&gt;因为&lt;code&gt;HotModuleReplacementPlugin&lt;/code&gt;是&lt;code&gt;webpack&lt;/code&gt;模块自带的，所以引入&lt;code&gt;webpack&lt;/code&gt;后，在&lt;code&gt;plugins&lt;/code&gt;配置项中直接使用即可。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.config.js
...
const webpack = require('webpack');  // 这个插件不需要安装，是基于webpack的，需要引入webpack模块

module.exports = {
    ...
    devServer: {
        contentBase: &quot;./dist&quot;, // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,  // 设置端口号为8088
        inline: true, // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
        hot: true // 热更新
    },
    ...
    plugins: [
        new webpack.BannerPlugin('版权所有，翻版必究'),  // new一个插件的实例 
        new HtmlWebpackPlugin({
            template: path.join(__dirname, &quot;/src/index.template.html&quot;)// new一个这个插件的实例，并传入相关的参数
        }),
        new CleanWebpackPlugin(['dist']),  // 传入所要清理的文件夹名称
        new webpack.HotModuleReplacementPlugin() // 热更新插件 
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时我们重新启动项目&lt;code&gt;npm run dev&lt;/code&gt;后，修改&lt;code&gt;hello.js&lt;/code&gt;的内容，会发现浏览器预览效果会自动刷新（也许反应会比较慢，因为我们使用了&lt;code&gt;source-map&lt;/code&gt;和其他配置的影响，后面代码分离的时候我们再处理）。&lt;/p&gt;
&lt;h3 id=&quot;七项目优化及拓展&quot;&gt;七、项目优化及拓展&lt;/h3&gt;
&lt;h6 id=&quot;代码分离&quot;&gt;7.1 代码分离&lt;/h6&gt;
&lt;p&gt;在当前的开发环境都是提倡模块化，webpack自然不例外，我们前面的&lt;code&gt;webpack.config.js&lt;/code&gt;配置文件，其实也没配置多少东西就这么多了，要是以后增加了更多配置，岂不是看得眼花缭乱，所以最好的方法就是把它拆分，方便管理：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们在根目录下新建三个文件，分别为&lt;code&gt;webpack.common.js&lt;/code&gt;、&lt;code&gt;webpack.dev.js&lt;/code&gt;、&lt;code&gt;webpack.prod.js&lt;/code&gt;，分别代表公共配置文件、开发环境配置文件、生产环境（指项目上线时的环境）配置文件。&lt;/li&gt;
&lt;li&gt;安装一个合并模块插件：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;cnpm i webpack-merge -D&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;将&lt;code&gt;webpack.config.js&lt;/code&gt;的代码拆分到上述新建的三个文件中，然后把&lt;code&gt;webpack.config.js&lt;/code&gt;文件删除，具体如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.common.js
const path = require('path');  // 路径处理模块
const webpack = require('webpack');  // 这个插件不需要安装，是基于webpack的，需要引入webpack模块
const HtmlWebpackPlugin = require('html-webpack-plugin'); // 引入HtmlWebpackPlugin插件

module.exports = {
    entry: path.join(__dirname, &quot;/src/index.js&quot;), // 入口文件
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;bundle.js&quot; //打包后输出文件的文件名
    },
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ['style-loader', 'css-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {
                test: /\.(scss|sass)$/,   // 正则匹配以.scss和.sass结尾的文件
                use: ['style-loader', 'css-loader', 'sass-loader']  // 需要用的loader，一定是这个顺序，因为调用loader是从右往左编译的
            },
            {                             // jsx配置
                test: /(\.jsx|\.js)$/,   
                use: {                    // 注意use选择如果有多项配置，可写成这种对象形式
                    loader: &quot;babel-loader&quot;
                },
                exclude: /node_modules/   // 排除匹配node_modules模块
            }
        ]
    },
    plugins: [
        new webpack.BannerPlugin('版权所有，翻版必究'),  // new一个插件的实例 
        new HtmlWebpackPlugin({
            template: path.join(__dirname, &quot;/src/index.template.html&quot;)// new一个这个插件的实例，并传入相关的参数
        }),
        new webpack.HotModuleReplacementPlugin()
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.dev.js
const merge = require('webpack-merge');  // 引入webpack-merge功能模块
const common = require('./webpack.common.js'); // 引入webpack.common.js

module.exports = merge(common, {   // 将webpack.common.js合并到当前文件
    devServer: {
        contentBase: &quot;./dist&quot;,   // 本地服务器所加载文件的目录
        port: &quot;8088&quot;,  // 设置端口号为8088
        inline: true,  // 文件修改后实时刷新
        historyApiFallback: true, //不跳转
        hot: true     //热加载
    }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.prod.js
const merge = require('webpack-merge');
const common = require('./webpack.common.js');
const CleanWebpackPlugin = require('clean-webpack-plugin'); // 引入CleanWebpackPlugin插件

module.exports = merge(common, { // 将webpack.common.js合并到当前文件
    devtool: 'source-map',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度
    plugins: [
        new CleanWebpackPlugin(['dist']),  // 所要清理的文件夹名称
    ]
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时我们的项目目录如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220227193-1234902752.png&quot; alt=&quot;17&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置&lt;code&gt;package.json&lt;/code&gt;的&lt;code&gt;scripts&lt;/code&gt;命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;name&quot;: &quot;webpack-project&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack --config webpack.prod.js&quot;,
    &quot;dev&quot;: &quot;webpack-dev-server --open --config webpack.dev.js&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;,
  &quot;devDependencies&quot;: {
    &quot;babel-core&quot;: &quot;^6.26.3&quot;,
    &quot;babel-loader&quot;: &quot;^7.1.5&quot;,
    &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;,
    &quot;babel-preset-react&quot;: &quot;^6.24.1&quot;,
    &quot;clean-webpack-plugin&quot;: &quot;^0.1.19&quot;,
    &quot;css-loader&quot;: &quot;^1.0.0&quot;,
    &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;,
    &quot;node-sass&quot;: &quot;^4.9.4&quot;,
    &quot;react&quot;: &quot;^16.6.0&quot;,
    &quot;react-dom&quot;: &quot;^16.6.0&quot;,
    &quot;sass-loader&quot;: &quot;^7.1.0&quot;,
    &quot;style-loader&quot;: &quot;^0.23.1&quot;,
    &quot;webpack&quot;: &quot;^4.23.1&quot;,
    &quot;webpack-cli&quot;: &quot;^3.1.2&quot;,
    &quot;webpack-dev-server&quot;: &quot;^3.1.10&quot;,
    &quot;webpack-merge&quot;: &quot;^4.1.4&quot;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们把&lt;code&gt;build&lt;/code&gt;命令改为了&lt;code&gt;webpack --config webpack.prod.js&lt;/code&gt;，意思是把打包配置指向&lt;code&gt;webpack.prod.js&lt;/code&gt;配置文件，而之前我们只需要使用一个&lt;code&gt;webpack&lt;/code&gt;命令为什么就可以运行了？因为&lt;code&gt;webpack&lt;/code&gt;命令是默认指向&lt;code&gt;webpack.config.js&lt;/code&gt;这个文件名称了，现在我们把文件名称改了，所以就需要自定义指向新的文件，&lt;code&gt;dev&lt;/code&gt;命令中的指令也同理。&lt;/p&gt;
&lt;p&gt;然后我们运行&lt;code&gt;npm run build&lt;/code&gt;和&lt;code&gt;npm run dev&lt;/code&gt;，效果应该和我们分离代码前是一样的。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;注：说道&lt;code&gt;package.json&lt;/code&gt;文件，顺便就多提几句，因为也许有些朋友可能对我们安装模块时加的&lt;code&gt;-D&lt;/code&gt;、&lt;code&gt;-S&lt;/code&gt;或&lt;code&gt;-g&lt;/code&gt;命令存在一些疑惑，因为不知道什么时候加什么尾缀。&lt;br/&gt;其实这个&lt;code&gt;package.json&lt;/code&gt;文件是用于我们安装依赖的，可以把它当成一份依赖安装说明表，就是如果我们把项目上传或者发给其他的开发同事，肯定不会把&lt;code&gt;/node_modules&lt;/code&gt;文件夹也发送过去，因为这太大了，不现实也没必要。&lt;br/&gt;开发同事只需要有这份&lt;code&gt;package.json&lt;/code&gt;文件，然后&lt;code&gt;npm install&lt;/code&gt;就可以把我们所需要的依赖都安装下来，但前提是&lt;code&gt;package.json&lt;/code&gt;文件上有记录，这就是安装模块时加上&lt;code&gt;-D&lt;/code&gt;,&lt;code&gt;-S&lt;/code&gt;命令的原因。&lt;br/&gt;&lt;code&gt;-D&lt;/code&gt;的全称是&lt;code&gt;--save-dev&lt;/code&gt;指开发环境时需要用到的依赖，会记录在&lt;code&gt;package.json&lt;/code&gt;文件中的&lt;code&gt;devDependencies&lt;/code&gt;选项中，而&lt;code&gt;-S&lt;/code&gt;是&lt;code&gt;--save&lt;/code&gt;是指生产环境也就是上线环境中需要用到的依赖，会记录在&lt;code&gt;package.json&lt;/code&gt;文件中的&lt;code&gt;dependencies&lt;/code&gt;选项中，&lt;code&gt;-g&lt;/code&gt;的全称是&lt;code&gt;--global&lt;/code&gt;指安装全局命令，就是我们在本电脑的任何项目中都能使用到的命令，比如安装&lt;code&gt;cnpm&lt;/code&gt;这个淘宝镜像命令就会用到&lt;code&gt;-g&lt;/code&gt;命令。&lt;br/&gt;所以我们在安装模块时一定不要忘了加上对应的尾缀命令，让我们的模块有迹可循，否则其他的开发同事接手你的项目的话，会不会下班后（放学后）在门口等你就不知道了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;扯远了，希望不要嫌弃，也是想讲得更详细嘛！&lt;/p&gt;
&lt;h6 id=&quot;多入口多出口&quot;&gt;7.2 多入口多出口&lt;/h6&gt;
&lt;p&gt;到目前为止我们都是一个入口文件和一个出口文件，要是我不止一个入口文件呢？下面我们来试试：&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;webpack.common.js&lt;/code&gt;中的&lt;code&gt;entry&lt;/code&gt;入口有三种写法，分别为字符串、数组和对象，平时我们用得比较多的是对象，所以我们把它改为对象的写法，首先我们在&lt;code&gt;src&lt;/code&gt;文件夹下新建&lt;code&gt;two.js&lt;/code&gt;文件，名称任意。因为有多个入口，所以肯定得多个出口来进行一一对应了，所以&lt;code&gt;entry&lt;/code&gt;和&lt;code&gt;output&lt;/code&gt;配置如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.common.js
...
module.exports = {
    entry: {
        index: path.join(__dirname, &quot;/src/index.js&quot;),
        two: path.join(__dirname, &quot;/src/two.js&quot;)
    }, 
    output: {
        path: path.join( __dirname, &quot;/dist&quot;), //打包后的文件存放的地方
        filename: &quot;[name].js&quot; //打包后输出文件的文件名
    },
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// two.js
function two() {
    let element = document.createElement('div');
    element.innerHTML = '我是第二个入口文件';
    return element;
}

document.getElementById('root').appendChild(two());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们运行&lt;code&gt;npm run build&lt;/code&gt;打包后发现&lt;code&gt;/dist&lt;/code&gt;文件夹下会多出&lt;code&gt;two.js&lt;/code&gt;文件，同时&lt;code&gt;index.html&lt;/code&gt;也会自动将&lt;code&gt;two.js&lt;/code&gt;引入，然后我们运行&lt;code&gt;npm run dev&lt;/code&gt;显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220237558-1724532675.png&quot; alt=&quot;18&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;增加css前缀分离css消除冗余css分离图片&quot;&gt;7.3 增加css前缀、分离css、消除冗余css、分离图片&lt;/h6&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;增加css前缀&lt;/strong&gt;&lt;br/&gt;平时我们写css时，一些属性需要手动加上前缀，比如&lt;code&gt;-webkit-border-radius: 10px;&lt;/code&gt;，在webpack中我们能不能让它自动加上呢？那是必须的，首先肯定得安装模块了：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;cnpm i postcss-loader autoprefixer -D&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装好这两个模块后，在项目根目录下新建&lt;code&gt;postcss.config.js&lt;/code&gt;文件:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// postcss.config.js
module.exports = {
    plugins: [
        require('autoprefixer')  // 引用autoprefixer模块
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;style.css&lt;/code&gt;中增加以下样式：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* style.css */
body {
    background: #999;
}

#root div{
    width: 200px;
    margin-top: 50px;
    transform: rotate(45deg); /* 这个属性会产生前缀 */
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;webpack.common.js&lt;/code&gt;文件中的&lt;code&gt;css-loader&lt;/code&gt;配置：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;...
module.exports = {
    ...
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: [            
                    {loader: 'style-loader'}, // 这里采用的是对象配置loader的写法
                    {loader: 'css-loader'},
                    {loader: 'postcss-loader'} // 使用postcss-loader
                ]  
            },
            ...
        ]
    },
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们运行&lt;code&gt;npm run dev&lt;/code&gt;后css样式中会自动添加前缀，显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220250613-127989039.png&quot; alt=&quot;19&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;分离css&lt;/strong&gt;&lt;br/&gt;虽然webpack的理念是把css、js全都打包到一个文件里，但要是我们想把css分离出来该怎么做呢？&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;cnpm i extract-text-webpack-plugin@next -D  // 加上@next是为了安装最新的，否则会出错&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完以上插件后在&lt;code&gt;webpack.common.js&lt;/code&gt;文件中引入并使用该插件：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.common.js
...
const ExtractTextPlugin = require('extract-text-webpack-plugin') //引入分离插件

module.exports = {
    ...
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ExtractTextPlugin.extract({  // 这里我们需要调用分离插件内的extract方法
                    fallback: 'style-loader',  // 相当于回滚，经postcss-loader和css-loader处理过的css最终再经过style-loader处理
                    use: ['css-loader', 'postcss-loader']
                })
            },
            ...
        ]
    },
    plugins: [
        ...
        new ExtractTextPlugin('css/index.css') // 将css分离到/dist文件夹下的css文件夹中的index.css
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行&lt;code&gt;npm run build&lt;/code&gt;后会发现&lt;code&gt;/dist&lt;/code&gt;文件夹内多出了&lt;code&gt;/css&lt;/code&gt;文件夹及&lt;code&gt;index.css&lt;/code&gt;文件。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;消除冗余css&lt;/strong&gt;&lt;br/&gt;有时候我们css写得多了，可能会不自觉的写重复了一些样式，这就造成了多余的代码，上线前又忘了检查，对于这方面，我们应该尽量去优化它，webpack就有这个功能。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;cnpm i purifycss-webpack purify-css glob -D&lt;/code&gt;&lt;br/&gt;安装完上述三个模块后，因为正常来说是在生产环境中优化代码，所以我们应该是在&lt;code&gt;webpack.prod.js&lt;/code&gt;文件中进行配置，引入&lt;code&gt;clean-webpack-plugin&lt;/code&gt;及&lt;code&gt;glob&lt;/code&gt;插件并使用它们：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.prod.js
const merge = require('webpack-merge');
const common = require('./webpack.common.js');
const CleanWebpackPlugin = require('clean-webpack-plugin'); // 引入CleanWebpackPlugin插件

const path = require('path');
const PurifyCssWebpack = require('purifycss-webpack'); // 引入PurifyCssWebpack插件
const glob = require('glob');  // 引入glob模块,用于扫描全部html文件中所引用的css

module.exports = merge(common, {   // 将webpack.common.js合并到当前文件
    devtool: 'source-map',  // 会生成对于调试的完整的.map文件，但同时也会减慢打包速度
    plugins: [
        new CleanWebpackPlugin(['dist']),  // 所要清理的文件夹名称
        new PurifyCssWebpack({
            paths: glob.sync(path.join(__dirname, 'src/*.html')) // 同步扫描所有html文件中所引用的css
        })
    ]
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在&lt;code&gt;style.css&lt;/code&gt;文件中增加一些多余的代码试试：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* style.css */
body {
    background: #999;
}

#root div{
    width: 200px;
    margin-top: 50px;
    transform: rotate(45deg); /* 这个属性会产生前缀 */
}

.a{                 /* 冗余css */
    color: black;     
}

.b{                 /* 冗余css */
    width: 50px;
    height: 50px;
    background: yellow;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们运行&lt;code&gt;npm run build&lt;/code&gt;后发现打包后的&lt;code&gt;index.css&lt;/code&gt;中是没有多余的&lt;code&gt;.a&lt;/code&gt;和&lt;code&gt;.b&lt;/code&gt;代码的：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* index.css */

body {
  background: #999;
}

#root div {
  width: 200px;
  margin-top: 50px;
  -webkit-transform: rotate(45deg);
  transform: rotate(45deg);
  /* 这个属性会产生前缀 */
}
/*# sourceMappingURL=index.css.map*/&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;处理图片&lt;/strong&gt;&lt;br/&gt;到目前为止我们还没讲到图片的问题，如果要使用图片，我们得安装两个loader：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;// 虽然我们只需使用url-loader，但url-loader是依赖于file-loader的，所以也要安装
cnpm i url-loader file-loader -D &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在&lt;code&gt;webpack.common.js&lt;/code&gt;中配置&lt;code&gt;url-loader&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.common.js
...
module.exports = {
    ...
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ExtractTextPlugin.extract({
                    fallback: 'style-loader',
                    use: ['css-loader', 'postcss-loader']
                })
            },
            {
                test: /\.(png|jpg|svg|gif)$/,  // 正则匹配图片格式名
                use: [
                    {
                        loader: 'url-loader'  // 使用url-loader
                    }
                ]
            },
            ...
        ]
    },
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们修改一下&lt;code&gt;style.css&lt;/code&gt;，把背景改为图片背景：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* style.css */
body {
    background: url(../images/coffee.png) top right repeat-y;  /* 设为图片背景 */
}

#root div{
    width: 200px;
    margin-top: 50px;
    transform: rotate(45deg); /* 这个属性会产生前缀 */
}

.a{
    color: black;
}

.b{
    width: 50px;
    height: 50px;
    background: yellow;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行&lt;code&gt;npm run dev&lt;/code&gt;后显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220304534-246820192.png&quot; alt=&quot;20&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是背景图片变成了&lt;code&gt;base64&lt;/code&gt;，因为webpack会自动优化图片，减少发送请求，但是如果我想把它变成路径的该怎么做？&lt;/p&gt;
&lt;p&gt;我们可以把&lt;code&gt;webpack.common.js&lt;/code&gt;的loader配置更改一下，增加&lt;code&gt;options&lt;/code&gt;选项：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.common.js
...
module.exports = {
    ...
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ExtractTextPlugin.extract({
                    fallback: 'style-loader',
                    use: ['css-loader', 'postcss-loader']
                })
            },
            {
                test: /\.(png|jpg|svg|gif)$/,
                use: [
                    {
                        loader: 'url-loader',
                        options: {
                            limit: 1000  // 限制只有小于1kb的图片才转为base64，例子图片为1.47kb,所以不会被转化
                        }
                    }
                ]
            },
            ...
        ]
    },
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们运行&lt;code&gt;npm run build&lt;/code&gt;后，再运行&lt;code&gt;npm run dev&lt;/code&gt;，额，图片是没有转成base64了，但是图片怎么不显示了？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220316736-1997271601.png&quot; alt=&quot;21&quot;/&gt;&lt;/p&gt;
&lt;p&gt;问题就出在路径上，我们之前图片的路径是在&lt;code&gt;../images&lt;/code&gt;文件夹下，但是打包出来后没有这个路径了，图片直接和文件同级了，所以我们需要在&lt;code&gt;webpack.common.js&lt;/code&gt;中给它设置一个文件夹：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.common.js
...
module.exports = {
    ...
    module: {
        rules: [
            ...
            {
                test: /\.(png|jpg|svg|gif)$/,
                use: [
                    {
                        loader: 'url-loader',
                        options: {
                            limit: 1000,  // 限制只有小于1kb的图片才转为base64，例子图片为1.47kb,所以不会被转化
                            outputPath: 'images'  // 设置打包后图片存放的文件夹名称
                        }
                    }
                ]
            },
            ...
        ]
    },
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续&lt;code&gt;npm run build&lt;/code&gt;打包再&lt;code&gt;npm run dev&lt;/code&gt;运行，我的天！图片还是不显示！&lt;br/&gt;调试工具上看图片路径有&lt;code&gt;images&lt;/code&gt;文件夹了，但是我的&lt;code&gt;../&lt;/code&gt;呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220328695-22813844.png&quot; alt=&quot;22&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这又涉及到配置路径的问题上了，我们还需要在css-loader中给背景图片设置一个公共路径&lt;code&gt;publicPath: '../'&lt;/code&gt;，如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// webpack.common.js
...
module.exports = {
    ...
    module: {
        rules: [
            {
                test: /\.css$/,   // 正则匹配以.css结尾的文件
                use: ExtractTextPlugin.extract({
                    fallback: 'style-loader',
                    use: ['css-loader', 'postcss-loader'],
                    publicPath: '../'  // 给背景图片设置一个公共路径
                })
            },
            {
                test: /\.(png|jpg|svg|gif)$/,
                use: [
                    {
                        loader: 'url-loader',
                        options: {
                            limit: 1000,  // 限制只有小于1kb的图片才转为base64，例子图片为1.47kb,所以不会被转化
                            outputPath: 'images'  // 设置打包后图片存放的文件夹名称
                        }
                    }
                ]
            },
            ...
        ]
    },
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在再&lt;code&gt;npm run build&lt;/code&gt;打包再&lt;code&gt;npm run dev&lt;/code&gt;启动，OK！没毛病！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220341623-450034724.png&quot; alt=&quot;23&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是不是很热闹？到现在我们不知不觉中也同时解决了图片分离的问题，偷偷高兴一下吧！&lt;/p&gt;
&lt;h6 id=&quot;压缩代码&quot;&gt;7.4 压缩代码&lt;/h6&gt;
&lt;p&gt;在webpack4.x版本中当你打包时会自动把js压缩了，而且&lt;code&gt;npm run dev&lt;/code&gt;运行服务器时，当你修改代码时，热更新很慢，这是因为你修改后webpack又自动为你打包，这就导致了在开发环境中效率很慢，所以我们需要把开发环境和生产环境区分开来，这时就体现出我们代码分离的便捷性了，&lt;code&gt;webpack.dev.js&lt;/code&gt;代表开发环境的配置，&lt;code&gt;webpack.prod.js&lt;/code&gt;代表生产环境的配置，这时我们只要在&lt;code&gt;package.json&lt;/code&gt;文件中配置对应环境的命令即可：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  ...
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;webpack --config webpack.prod.js --mode production&quot;,
    &quot;dev&quot;: &quot;webpack-dev-server --open --config webpack.dev.js --mode development&quot;
  },
  ...
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--mode production&lt;/code&gt;表示打包时是生产环境，会自己将js进行压缩，而&lt;code&gt;--mode development&lt;/code&gt;表示当前是开发环境，不需要进行压缩。这同时也解决了之前一直遗留的警告问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1306384/201810/1306384-20181028220354432-15442521.png&quot; alt=&quot;24&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;好了，到现在我们基本把webapck常用的功能都走了一遍，写得有点长，感谢你能仔细的看到这里，希望能对你有所帮助，如果有发现不对的地方，也请多多指教。其实webpack还有很多功能，这里也没讲述完全，但相信你现在对webpack也有了一定的了解，更多的webpack探索一定难不倒你！&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 14:21:00 +0000</pubDate>
<dc:creator>Better-Man</dc:creator>
<og:description>本文主要是针对webpack4.x版本，会对平时常用的Webpack配置一一讲解，各个功能点都有对应的详细例子，所以本文也比较长，但如果你能动手跟着本文中的例子完整写一次，相信你会觉得Webpack也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BetterMan-/p/9867642.html</dc:identifier>
</item>
<item>
<title>RabbitMQ TroubleShooting - baidixing</title>
<link>http://www.cnblogs.com/jiagoushi/p/9867515.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiagoushi/p/9867515.html</guid>
<description>&lt;p&gt;   RabbitMQ是一款优秀的消息队列中间件，提供了稳定、监控完善的产品，但是软件就会有bug。为了前进路径可以畅通，我们必须了解出现的一些故障的快速处理方式，毕竟在生产环境，时间就是生命，尽快的处理是避免产生事故的最有效方式。&lt;/p&gt;
&lt;p&gt;了解常见的一些故障，我们可以有针对的处理预案，快速、高效的处理故障，更好的运维是我们一直的追求。&lt;/p&gt;
&lt;p&gt;查看故障信息，RabbitMQ出现故障，要通过一些有效途径快速的获取故障原因，而不能是每次都通过重启RabbitMQ服务的方式来解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何查看故障信息，从几个方面&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;h3&gt;通过rabbitmqctl status ，在出现故障 服务器，查看当前MQ运行状态，该命令可以看到一些非常有用的信息&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;通过rabbitmqctl cluster_status ,查看集群状态是否正常。在RabbitMQ集群由于网络原因而可能出现网络割裂的情况下，可以通过该命令查看集群运行状态&lt;/h3&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;h3&gt;查看rabbitmq 运行日志文件。可能有的小伙伴不知道该文件在哪里，在RABBITMQ_LOG_BASE定义的位置，还有小伙伴可能又要问RABBITMQ_LOG_BASE是什么，我只能说这个是rabbitmq的环境变量值，在rabbitMQ安装路径/sbin 目录下，注意看有一个rabbitmq-env.bat 文件。请通过记事本打开该文件，然后搜索RABBITMQ_LOG_BASE，可以看到具体路径。更多的就不详细聊了，在RABBITMQ配置文件我会专门说明&lt;/h3&gt;&lt;hr/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;故障信息一览&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;-1.5&quot;&gt;&lt;li&gt;&lt;u&gt;  通过localhost:15672 无法打开监控页面。&lt;/u&gt;&lt;br/&gt;     原因：1、RabbitMQ服务未开启 2、未开启监控插件。 &lt;br/&gt;     解决方案：&lt;br/&gt;    1、通过rabbitmq-service start 开启RabbitMQ服务&lt;br/&gt;    2、通过rabbitmq-plugins enable rabbitmq_management 开启监控插件。&lt;br/&gt;  通过以上两种方式的操作，监控页面一般都可以正常打开了。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;&lt;u&gt;localhost:15672  的登录密码不知道？&lt;/u&gt;&lt;br/&gt;  原因：不懂rabbitmq或rabbitmq的超级小白，或者在安装时将guest用户删除(概率极小)，我当时第一次学习也是这样，打开了监控面板，一脸懵逼，因为我压根不知道登录  密码。&lt;br/&gt;  解决方案：&lt;br/&gt;    1、如果未使用RabbitMQ配置文件或未更改rabbitmq的配置文件，就是说采用的是默认配置。那么我们就必须知道RabbitMQ安装以后会默认存在一个用户,账号与密码均 是guest。&lt;br/&gt;   2、使用默认账号密码均是guest的用户，仍旧无法登录。那么为我们就要开始第二步了，通过rabbitmqctl list_users 查看是否有guest用户。正常情况下，应该显示&lt;p&gt;      C:\Program Files\RabbitMQ Server\rabbitmq_server-3.7.8\sbin&amp;gt;rabbitmqctl list_users&lt;br/&gt;      Listing users ...&lt;br/&gt;      guest [administrator]&lt;/p&gt;
      如果未看到一个用户，那么我们可以创建一个用户guozhiqi(名称随意)来执行登录。&lt;br/&gt;    具体操作：&lt;br/&gt;       1、执行rabbitmqctl add_user   guozhiqi  guozhiqi  （rabbitmqctl add_user  用户名  密码）。执行完该命令后仍旧无法通过guozhiqi/guozhiqi登录的，因为这个用户是没有管理权限的。&lt;br/&gt;       2、执行授权操作  rabbitmqctl  set_user_tags guozhiqi administrator (rabbitmqctl  set_user_tags 用户名   角色(administrator,monitoring, management))&lt;br/&gt;       3、此时通过用户guozhiqi 就可以登录了&lt;br/&gt;       4、登录进去你会发现，只能查看，不能进行任何修改或新增操作，原因是没有权限。此时，针对运维人员就需要给用户guozhqi授权，执行rabbitmqctl set_permissions -p / username &lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;.*&quot; &lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;.*&quot; &lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;.*&quot; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;3、更改guest权限。通过rabbitmqctl change_password guest guest。也可以通过guest/guest用户登录啦。。。。 &lt;/li&gt;
&lt;li&gt;&lt;u&gt;执行rabbitmqctl list_users ，出现Error: this command requires the 'rabbit' app to be running on the target node. Start it with 'rabbitmqctl start_app'.&lt;/u&gt;&lt;br/&gt;解决方案：这个错误很明显的指出了app未运行。很多人会弄混一个事情，就是一个rabbitmq service可以有多个app存在，也就是说可以搭建单机集群。&lt;br/&gt;rabbitmq-service start/rabbitmq-service stop 是针对rabbitmq服务的操作。&lt;br/&gt;什么情况下才会执行这个操作呢？  目前我已知的有两种，一种是rabbitmq配置文件更改需要重新启动(还需要重新安装奥)，另一种就是服务停止 需要开启&lt;br/&gt;rabbitmqctl stop_app/rabbitmqctl start_app 什么情况下会执行呢？首先我们要知道这两个命令的作用是什么。关闭或开启当前app，注意是当前。有兴趣的哈，可以搜索单机集群搭建。&lt;/li&gt;
&lt;li&gt;&lt;u&gt;windows服务开启失败。RabbitMQ: Erlang machine stopped instantly (distribution name conflict?）&lt;/u&gt;&lt;br/&gt;解决方案：如果重命名服务器名称或使用其他账户登录系统，可能会出现该问题。使用安装rabbitmq的账户进行登录。&lt;br/&gt;                 查看rabbitmq目录是否包含中文或特殊字符，如果有的话，请更改安装目录。&lt;/li&gt;
&lt;/ol&gt;





&lt;p&gt;rabbitmq故障一览，持续记录出现的RabbitMQ故障及解决方式。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 14:03:00 +0000</pubDate>
<dc:creator>baidixing</dc:creator>
<og:description>RabbitMQ是一款优秀的消息队列中间件，提供了稳定、监控完善的产品，但是软件就会有bug。为了前进路径可以畅通，我们必须了解出现的一些故障的快速处理方式，毕竟在生产环境，时间就是生命，尽快的处理是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiagoushi/p/9867515.html</dc:identifier>
</item>
<item>
<title>SDL2源码分析之OpenGL ES在windows上的渲染过程 - HarlanC</title>
<link>http://www.cnblogs.com/harlanc/p/9867414.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/harlanc/p/9867414.html</guid>
<description>&lt;h2 id=&quot;ffmpeg-sdl2实现的简易播放器&quot;&gt;ffmpeg + SDL2实现的简易播放器&lt;/h2&gt;
&lt;p&gt;ffmpeg和SDL非常强大，通过使用ffmpeg和SDL可以用100多行代码就实现一个简易的播放器（来自网上的源码，找不到出处了）:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#define __STDC_CONSTANT_MACROS


#define SDL_MAIN_HANDLED 1

 
#ifdef _WIN32
//Windows
//extern &quot;C&quot;
//{
#include &quot;libavcodec/avcodec.h&quot;
#include &quot;libavformat/avformat.h&quot;
#include &quot;libswscale/swscale.h&quot;
#include &quot;SDL2/SDL.h&quot;
//};
#else
//Linux...
#ifdef __cplusplus
extern &quot;C&quot;
{
#endif
#include &amp;lt;libavcodec/avcodec.h&amp;gt;
#include &amp;lt;libavformat/avformat.h&amp;gt;
#include &amp;lt;libswscale/swscale.h&amp;gt;
#include &amp;lt;SDL2/SDL.h&amp;gt;
#ifdef __cplusplus
};
#endif
#endif
 
 
//Full Screen
#define SHOW_FULLSCREEN 0
//Output YUV420P 
#define OUTPUT_YUV420P 0

int main(int argc, char *argv[]) {
    AVFormatContext *pFormatCtx = NULL;
    int videoStream;
    unsigned i;
    AVCodecContext *pCodecCtxOrig = NULL;
    AVCodecContext *pCodecCtx = NULL;
    AVCodec *pCodec = NULL;
    AVFrame *pFrame = NULL;
    AVPacket packet;
    int frameFinished;
    struct SwsContext *sws_ctx = NULL;
    SDL_Event event;
    SDL_Window *screen;
    SDL_Renderer *renderer;
    SDL_Texture *texture;
    Uint8 *yPlane, *uPlane, *vPlane;
    size_t yPlaneSz, uvPlaneSz;
    int uvPitch;

    if (argc &amp;lt; 2) {
        fprintf(stderr, &quot;Usage: test &amp;lt;file&amp;gt;\n&quot;);
        exit(1);
    }
    printf(&quot;it is a test\n&quot;);
    // Register all formats and codecs
    av_register_all();

    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) {
        fprintf(stderr, &quot;Could not initialize SDL - %s\n&quot;, SDL_GetError());
        exit(1);
    }

    // Open video file
    if (avformat_open_input(&amp;amp;pFormatCtx,argv[1], NULL, NULL) != 0)
        return -1; // Couldn't open file

    // Retrieve stream information
    if (avformat_find_stream_info(pFormatCtx, NULL) &amp;lt; 0)
        return -1; // Couldn't find stream information

    // Dump information about file onto standard error
    av_dump_format(pFormatCtx, 0, argv[1], 0);

    // Find the first video stream
    videoStream = -1;
    for (i = 0; i &amp;lt; pFormatCtx-&amp;gt;nb_streams; i++)
        if (pFormatCtx-&amp;gt;streams[i]-&amp;gt;codec-&amp;gt;codec_type == AVMEDIA_TYPE_VIDEO) {
            videoStream = i;
            break;
        }
    if (videoStream == -1)
        return -1; // Didn't find a video stream

    // Get a pointer to the codec context for the video stream
    pCodecCtxOrig = pFormatCtx-&amp;gt;streams[videoStream]-&amp;gt;codec;
    // Find the decoder for the video stream
    pCodec = avcodec_find_decoder(pCodecCtxOrig-&amp;gt;codec_id);
    if (pCodec == NULL) {
        fprintf(stderr, &quot;Unsupported codec!\n&quot;);
        return -1; // Codec not found
    }

    // Copy context
    pCodecCtx = avcodec_alloc_context3(pCodec);
    if (avcodec_copy_context(pCodecCtx, pCodecCtxOrig) != 0) {
        fprintf(stderr, &quot;Couldn't copy codec context&quot;);
        return -1; // Error copying codec context
    }

    // Open codec
    if (avcodec_open2(pCodecCtx, pCodec, NULL) &amp;lt; 0)
        return -1; // Could not open codec

    // Allocate video frame
    pFrame = av_frame_alloc();

    // Make a screen to put our video
    screen = SDL_CreateWindow(
            &quot;FFmpeg Tutorial&quot;,
            SDL_WINDOWPOS_UNDEFINED,
            SDL_WINDOWPOS_UNDEFINED,
            pCodecCtx-&amp;gt;width,
            pCodecCtx-&amp;gt;height,
            0
        );

    if (!screen) {
        fprintf(stderr, &quot;SDL: could not create window - exiting\n&quot;);
        exit(1);
    }

    renderer = SDL_CreateRenderer(screen, -1, 0);
    if (!renderer) {
        fprintf(stderr, &quot;SDL: could not create renderer - exiting\n&quot;);
        exit(1);
    }

    // Allocate a place to put our YUV image on that screen
    texture = SDL_CreateTexture(
            renderer,
            SDL_PIXELFORMAT_YV12,
            SDL_TEXTUREACCESS_STREAMING,
            pCodecCtx-&amp;gt;width,
            pCodecCtx-&amp;gt;height
        );
    if (!texture) {
        fprintf(stderr, &quot;SDL: could not create texture - exiting\n&quot;);
        exit(1);
    }

    // initialize SWS context for software scaling
    sws_ctx = sws_getContext(pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height,
            pCodecCtx-&amp;gt;pix_fmt, pCodecCtx-&amp;gt;width, pCodecCtx-&amp;gt;height,
            AV_PIX_FMT_YUV420P,
            SWS_BILINEAR,
            NULL,
            NULL,
            NULL);

    // set up YV12 pixel array (12 bits per pixel)
    yPlaneSz = pCodecCtx-&amp;gt;width * pCodecCtx-&amp;gt;height;
    uvPlaneSz = pCodecCtx-&amp;gt;width * pCodecCtx-&amp;gt;height / 4;
    yPlane = (Uint8*)malloc(yPlaneSz);
    uPlane = (Uint8*)malloc(uvPlaneSz);
    vPlane = (Uint8*)malloc(uvPlaneSz);
    if (!yPlane || !uPlane || !vPlane) {
        fprintf(stderr, &quot;Could not allocate pixel buffers - exiting\n&quot;);
        exit(1);
    }

    uvPitch = pCodecCtx-&amp;gt;width / 2;
    while (av_read_frame(pFormatCtx, &amp;amp;packet) &amp;gt;= 0) {
        // Is this a packet from the video stream?
        if (packet.stream_index == videoStream) {
            // Decode video frame
            avcodec_decode_video2(pCodecCtx, pFrame, &amp;amp;frameFinished, &amp;amp;packet);

            // Did we get a video frame?
            if (frameFinished) {
                AVPicture pict;
                pict.data[0] = yPlane;
                pict.data[1] = uPlane;
                pict.data[2] = vPlane;
                pict.linesize[0] = pCodecCtx-&amp;gt;width;
                pict.linesize[1] = uvPitch;
                pict.linesize[2] = uvPitch;

                // Convert the image into YUV format that SDL uses
                sws_scale(sws_ctx, (uint8_t const * const *) pFrame-&amp;gt;data,
                        pFrame-&amp;gt;linesize, 0, pCodecCtx-&amp;gt;height, pict.data,
                        pict.linesize);

                SDL_UpdateYUVTexture(
                        texture,
                        NULL,
                        yPlane,
                        pCodecCtx-&amp;gt;width,
                        uPlane,
                        uvPitch,
                        vPlane,
                        uvPitch
                    );

                SDL_RenderClear(renderer);
                SDL_RenderCopy(renderer, texture, NULL, NULL);
                SDL_RenderPresent(renderer);

            }
        }

        // Free the packet that was allocated by av_read_frame
        av_free_packet(&amp;amp;packet);
        SDL_PollEvent(&amp;amp;event);
        switch (event.type) {
        case SDL_QUIT:
            SDL_DestroyTexture(texture);
            SDL_DestroyRenderer(renderer);
            SDL_DestroyWindow(screen);
            SDL_Quit();
            exit(0);
            break;
        default:
            break;
        }

    }

    // Free the YUV frame
    av_frame_free(&amp;amp;pFrame);
    free(yPlane);
    free(uPlane);
    free(vPlane);

    // Close the codec
    avcodec_close(pCodecCtx);
    avcodec_close(pCodecCtxOrig);

    // Close the video file
    avformat_close_input(&amp;amp;pFormatCtx);

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ffmpeg用来解码，使用SDL进行渲染。笔者着重对如何在windows平台上使用SDL进行视频渲染进行一下分析。前面的文章已经介绍了&lt;a href=&quot;https://www.cnblogs.com/harlanc/p/9569960.html&quot;&gt;如何在windows平台上搭建gcc编译环境&lt;/a&gt;，然后执行如下命令编译出可执行程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; $gcc simpleplayer.c -L/local/bin -L/bin -I/local/include -I/include -lavformat -lavcodec -lsdl2 -lavutil -lswscale&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;windows平台下编译下面这句宏定义很关键：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; #define SDL_MAIN_HANDLED 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应为SDL中已经定义了main函数，不使用SDL中的main就需要加上面的宏定义，如果不加这句话的话会报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; c:/mingw/bin/../lib/gcc/mingw32/6.3.0/../../../libmingw32.a(main.o):(.text.startup+0xa0): undefined reference to `WinMain@16'       &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终生成a.exe，执行如下命令进行视频播放：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./a.exe ed_1024_512kb.mp4&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;源码下载&quot;&gt;源码下载&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.libsdl.org/download-2.0.php&quot;&gt;SDL2.0源码&lt;/a&gt;，选择上面的source code下载下来。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;p&gt;作者看SDL源码时是按照认为对自己有用的代码逻辑有目的的进行分析和理解，因此像是走马观花，不会对每个细节都分析的很清楚，下面按照简易播放器的调用过程从头到尾把相关的SDL源码走一遍。SDL的渲染函数都是以SDL开头的，下面对简易播放器中的这些变量和函数进行分析：&lt;/p&gt;
&lt;h3 id=&quot;几个变量&quot;&gt;几个变量&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;SDL_Event event;//保存渲染结束事件
SDL_Window *screen;//播放器窗口
SDL_Renderer *renderer;//渲染对象
SDL_Texture *texture;//纹理对象&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sdl_init&quot;&gt;SDL_Init&lt;/h3&gt;
&lt;p&gt;用于初始化各个子系统：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终会调用下面的函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int
SDL_InitSubSystem(Uint32 flags)
{
           ...
        /* Initialize the video subsystem */
        if ((flags &amp;amp; SDL_INIT_VIDEO)){
    #if !SDL_VIDEO_DISABLED
            if (SDL_PrivateShouldInitSubsystem(SDL_INIT_VIDEO)) {
                if (SDL_VideoInit(NULL) &amp;lt; 0) {
                    return (-1);
                }
            }
            SDL_PrivateSubsystemRefCountIncr(SDL_INIT_VIDEO);
    #else
            return SDL_SetError(&quot;SDL not built with video support&quot;);
    #endif
        }
    .....       
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们只看一下视频子系统的初始化:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/*
 * Initialize the video and event subsystems -- determine native pixel format
 */
int
SDL_VideoInit(const char *driver_name)
{
     ...
     /* Select the proper video driver */
    index = 0;
    video = NULL;
    if (driver_name == NULL) {
        driver_name = SDL_getenv(&quot;SDL_VIDEODRIVER&quot;);
    }
    if (driver_name != NULL) {
        for (i = 0; bootstrap[i]; ++i) {
            if (SDL_strncasecmp(bootstrap[i]-&amp;gt;name, driver_name, SDL_strlen(driver_name)) == 0) {
                if (bootstrap[i]-&amp;gt;available()) {
                    video = bootstrap[i]-&amp;gt;create(index);
                    break;
                }
            }
        }
    } else {
        for (i = 0; bootstrap[i]; ++i) {
            if (bootstrap[i]-&amp;gt;available()) {
                video = bootstrap[i]-&amp;gt;create(index);
                if (video != NULL) {
                    break;
                }
            }
        }
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;着重看一下视频驱动的选择，调用此函数的参数传进来的为NULL，进来之后会通过调用SDL_getenv获取driver_name，但是看了一下windows的环境变量中没有叫做SDL_VIDEODRIVER的。因此会接着往下走，else里面会把驱动数组从头到尾遍历一遍，只要找到一个available的元素，即使用此驱动。看一下驱动数组的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; /* Available video drivers */
static VideoBootStrap *bootstrap[] = {
#if SDL_VIDEO_DRIVER_COCOA//mac
    &amp;amp;COCOA_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_X11
    &amp;amp;X11_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_MIR
    &amp;amp;MIR_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_WAYLAND
    &amp;amp;Wayland_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_VIVANTE
    &amp;amp;VIVANTE_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_DIRECTFB
    &amp;amp;DirectFB_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_WINDOWS//windows
    &amp;amp;WINDOWS_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_WINRT//windows RT
    &amp;amp;WINRT_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_HAIKU
    &amp;amp;HAIKU_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_PANDORA
    &amp;amp;PND_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_UIKIT //iphone
    &amp;amp;UIKIT_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_ANDROID
    &amp;amp;Android_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_PSP
    &amp;amp;PSP_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_KMSDRM
    &amp;amp;KMSDRM_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_RPI
    &amp;amp;RPI_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_NACL
    &amp;amp;NACL_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_EMSCRIPTEN
    &amp;amp;Emscripten_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_QNX
    &amp;amp;QNX_bootstrap,
#endif
#if SDL_VIDEO_DRIVER_DUMMY
    &amp;amp;DUMMY_bootstrap,
#endif
    NULL
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此数组中的元素由宏定义来决定其加入与否，SDL_VIDEO_DRIVER_WINDOWS 是在SDL_config_windows.h中被定义的，此头文件在SDL_config.h中被引用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* Add any platform that doesn't build using the configure system. */
#if defined(__WIN32__)
#include &quot;SDL_config_windows.h&quot;
#elif defined(__WINRT__)
#include &quot;SDL_config_winrt.h&quot;
#elif defined(__MACOSX__)
#include &quot;SDL_config_macosx.h&quot;
#elif defined(__IPHONEOS__)
#include &quot;SDL_config_iphoneos.h&quot;
#elif defined(__ANDROID__)
#include &quot;SDL_config_android.h&quot;
#elif defined(__PSP__)
#include &quot;SDL_config_psp.h&quot;
#else
/* This is a minimal configuration just to get SDL running on new platforms */
#include &quot;SDL_config_minimal.h&quot;
#endif /* platform config */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见不同平台中会引用对应的头文件，win32会引用SDL_config_windows.h，然后会选择对应的驱动程序，在SDL_VIDEO_DRIVER_WINDOWS 前面的几个宏定义除了MAC之外，对其余的都不熟悉，暂且认定，这些宏定义在windwos中不会被定义。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;video = bootstrap[i]-&amp;gt;create(index);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;选择windows驱动之后,调用create函数进行创建，create函数指向的是如下函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static SDL_VideoDevice * WIN_CreateDevice(int devindex)
{
     ....
     /* Set the function pointers */
    device-&amp;gt;VideoInit = WIN_VideoInit;
    device-&amp;gt;VideoQuit = WIN_VideoQuit;
    device-&amp;gt;GetDisplayBounds = WIN_GetDisplayBounds;
    device-&amp;gt;GetDisplayUsableBounds = WIN_GetDisplayUsableBounds;
    device-&amp;gt;GetDisplayDPI = WIN_GetDisplayDPI;
    device-&amp;gt;GetDisplayModes = WIN_GetDisplayModes;
    device-&amp;gt;SetDisplayMode = WIN_SetDisplayMode;
    device-&amp;gt;PumpEvents = WIN_PumpEvents;

    device-&amp;gt;CreateSDLWindow = WIN_CreateWindow;
    device-&amp;gt;CreateSDLWindowFrom = WIN_CreateWindowFrom;
    device-&amp;gt;SetWindowTitle = WIN_SetWindowTitle;
    device-&amp;gt;SetWindowIcon = WIN_SetWindowIcon;
    device-&amp;gt;SetWindowPosition = WIN_SetWindowPosition;
    device-&amp;gt;SetWindowSize = WIN_SetWindowSize;
    device-&amp;gt;GetWindowBordersSize = WIN_GetWindowBordersSize;
    device-&amp;gt;SetWindowOpacity = WIN_SetWindowOpacity;
    device-&amp;gt;ShowWindow = WIN_ShowWindow;
    device-&amp;gt;HideWindow = WIN_HideWindow;
    device-&amp;gt;RaiseWindow = WIN_RaiseWindow;
    device-&amp;gt;MaximizeWindow = WIN_MaximizeWindow;
    device-&amp;gt;MinimizeWindow = WIN_MinimizeWindow;
    device-&amp;gt;RestoreWindow = WIN_RestoreWindow;
    device-&amp;gt;SetWindowBordered = WIN_SetWindowBordered;
    device-&amp;gt;SetWindowResizable = WIN_SetWindowResizable;
    device-&amp;gt;SetWindowFullscreen = WIN_SetWindowFullscreen;
    device-&amp;gt;SetWindowGammaRamp = WIN_SetWindowGammaRamp;
    device-&amp;gt;GetWindowGammaRamp = WIN_GetWindowGammaRamp;
    device-&amp;gt;SetWindowGrab = WIN_SetWindowGrab;
    device-&amp;gt;DestroyWindow = WIN_DestroyWindow;
    device-&amp;gt;GetWindowWMInfo = WIN_GetWindowWMInfo;
    device-&amp;gt;CreateWindowFramebuffer = WIN_CreateWindowFramebuffer;
    device-&amp;gt;UpdateWindowFramebuffer = WIN_UpdateWindowFramebuffer;
    device-&amp;gt;DestroyWindowFramebuffer = WIN_DestroyWindowFramebuffer;
    device-&amp;gt;OnWindowEnter = WIN_OnWindowEnter;
    device-&amp;gt;SetWindowHitTest = WIN_SetWindowHitTest;

    device-&amp;gt;shape_driver.CreateShaper = Win32_CreateShaper;
    device-&amp;gt;shape_driver.SetWindowShape = Win32_SetWindowShape;
    device-&amp;gt;shape_driver.ResizeWindowShape = Win32_ResizeWindowShape;

#if SDL_VIDEO_OPENGL_WGL
    device-&amp;gt;GL_LoadLibrary = WIN_GL_LoadLibrary;
    device-&amp;gt;GL_GetProcAddress = WIN_GL_GetProcAddress;
    device-&amp;gt;GL_UnloadLibrary = WIN_GL_UnloadLibrary;
    device-&amp;gt;GL_CreateContext = WIN_GL_CreateContext;
    device-&amp;gt;GL_MakeCurrent = WIN_GL_MakeCurrent;
    device-&amp;gt;GL_SetSwapInterval = WIN_GL_SetSwapInterval;
    device-&amp;gt;GL_GetSwapInterval = WIN_GL_GetSwapInterval;
    device-&amp;gt;GL_SwapWindow = WIN_GL_SwapWindow;
    device-&amp;gt;GL_DeleteContext = WIN_GL_DeleteContext;
#elif SDL_VIDEO_OPENGL_EGL        
    /* Use EGL based functions */
    device-&amp;gt;GL_LoadLibrary = WIN_GLES_LoadLibrary;
    device-&amp;gt;GL_GetProcAddress = WIN_GLES_GetProcAddress;
    device-&amp;gt;GL_UnloadLibrary = WIN_GLES_UnloadLibrary;
    device-&amp;gt;GL_CreateContext = WIN_GLES_CreateContext;
    device-&amp;gt;GL_MakeCurrent = WIN_GLES_MakeCurrent;
    device-&amp;gt;GL_SetSwapInterval = WIN_GLES_SetSwapInterval;
    device-&amp;gt;GL_GetSwapInterval = WIN_GLES_GetSwapInterval;
    device-&amp;gt;GL_SwapWindow = WIN_GLES_SwapWindow;
    device-&amp;gt;GL_DeleteContext = WIN_GLES_DeleteContext;
#endif
#if SDL_VIDEO_VULKAN
    device-&amp;gt;Vulkan_LoadLibrary = WIN_Vulkan_LoadLibrary;
    device-&amp;gt;Vulkan_UnloadLibrary = WIN_Vulkan_UnloadLibrary;
    device-&amp;gt;Vulkan_GetInstanceExtensions = WIN_Vulkan_GetInstanceExtensions;
    device-&amp;gt;Vulkan_CreateSurface = WIN_Vulkan_CreateSurface;
#endif

    device-&amp;gt;StartTextInput = WIN_StartTextInput;
    device-&amp;gt;StopTextInput = WIN_StopTextInput;
    device-&amp;gt;SetTextInputRect = WIN_SetTextInputRect;

    device-&amp;gt;SetClipboardText = WIN_SetClipboardText;
    device-&amp;gt;GetClipboardText = WIN_GetClipboardText;
    device-&amp;gt;HasClipboardText = WIN_HasClipboardText;

    device-&amp;gt;free = WIN_DeleteDevice;
    ...
}   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终得到了我们想要的，此函数里面指定了特定平台下需要的功能函数。在接下来的流程中，基本所有的特定平台的功能函数都来源于此。可以发现，在SDL_config_windows.h中，定义了多个和OpenGL相关的宏定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* Enable OpenGL support */
#ifndef SDL_VIDEO_OPENGL
#define SDL_VIDEO_OPENGL    1
#endif
#ifndef SDL_VIDEO_OPENGL_WGL
#define SDL_VIDEO_OPENGL_WGL    1
#endif
#ifndef SDL_VIDEO_RENDER_OGL
#define SDL_VIDEO_RENDER_OGL    1
#endif
#ifndef SDL_VIDEO_RENDER_OGL_ES2
#define SDL_VIDEO_RENDER_OGL_ES2    1
#endif
#ifndef SDL_VIDEO_OPENGL_ES2
#define SDL_VIDEO_OPENGL_ES2    1
#endif
#ifndef SDL_VIDEO_OPENGL_EGL
#define SDL_VIDEO_OPENGL_EGL    1
#endif&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而WIN_CreateDevice中会优先判断SDL_VIDEO_OPENGL_WGL，因此程序会使用WGL而不是EGL(关于EGL的&lt;a href=&quot;https://www.cnblogs.com/harlanc/p/9681643.html#_label0_2&quot;&gt;简单介绍&lt;/a&gt;)。本片文章不会去详细分析WGL，而是要分析GL ES，可以按照简易播放器的流程继续往下走，但是到使用WGL的地方会去分析EGL。&lt;/p&gt;
&lt;h3 id=&quot;sdl_createwindow&quot;&gt;SDL_CreateWindow&lt;/h3&gt;
&lt;p&gt;此函数用于创建显示视频的窗体，下面是平台相关的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if (_this-&amp;gt;CreateSDLWindow &amp;amp;&amp;amp; _this-&amp;gt;CreateSDLWindow(_this, window) &amp;lt; 0) {
    SDL_DestroyWindow(window);
    return NULL;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CreateSDLWindow来自前面提到过的WIN_CreateDevice函数，指向的是如下函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int
WIN_CreateWindow(_THIS, SDL_Window * window)
{
    ...
    hwnd = CreateWindow(SDL_Appname, TEXT(&quot;&quot;), style, x, y, w, h, parent, NULL,
                 SDL_Instance, NULL);//此函数为windows API，创建一个windows窗口
    ...
                /* The rest of this macro mess is for OpenGL or OpenGL ES windows */
    #if SDL_VIDEO_OPENGL_ES2
        if (_this-&amp;gt;gl_config.profile_mask == SDL_GL_CONTEXT_PROFILE_ES
    #if SDL_VIDEO_OPENGL_WGL
            &amp;amp;&amp;amp; (!_this-&amp;gt;gl_data || WIN_GL_UseEGL(_this))
    #endif /* SDL_VIDEO_OPENGL_WGL */
        ) {
    #if SDL_VIDEO_OPENGL_EGL
            if (WIN_GLES_SetupWindow(_this, window) &amp;lt; 0) {
                WIN_DestroyWindow(_this, window);
                return -1;
            }
            return 0;
    #else
            return SDL_SetError(&quot;Could not create GLES window surface (EGL support not configured)&quot;);
    #endif /* SDL_VIDEO_OPENGL_EGL */ 
        }
    #endif /* SDL_VIDEO_OPENGL_ES2 */
    
    #if SDL_VIDEO_OPENGL_WGL
        if (WIN_GL_SetupWindow(_this, window) &amp;lt; 0) {
            WIN_DestroyWindow(_this, window);
            return -1;
        }
    #else
        return SDL_SetError(&quot;Could not create GL window (WGL support not configured)&quot;);
    #endif
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看一下WIN_GLES_SetupWindow 函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int WIN_GLES_SetupWindow(_THIS,SDL_Windows *window){

    /* The current context is lost in here; save it and reset it. */
    SDL_WindowData *windowdata = (SDL_WindowData *) window-&amp;gt;driverdata;
    SDL_Window *current_win = SDL_GL_GetCurrentWindow();
    SDL_GLContext current_ctx = SDL_GL_GetCurrentContext();


    if (_this-&amp;gt;egl_data == NULL) {
        if (SDL_EGL_LoadLibrary(_this, NULL, EGL_DEFAULT_DISPLAY, 0) &amp;lt; 0) {
            SDL_EGL_UnloadLibrary(_this);
            return -1;
        }
    }
  
    /* Create the GLES window surface */
    windowdata-&amp;gt;egl_surface = SDL_EGL_CreateSurface(_this, (NativeWindowType)windowdata-&amp;gt;hwnd);

    if (windowdata-&amp;gt;egl_surface == EGL_NO_SURFACE) {
        return SDL_SetError(&quot;Could not create GLES window surface&quot;);
    }

    return WIN_GLES_MakeCurrent(_this, current_win, current_ctx);    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果egl数据为空，则进行EGL动态库的加载，加载libEGL.dll之前，由注释得知需要加载OpenGL库才能正常工作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* EGL AND OpenGL ES support via ANGLE */
#define DEFAULT_EGL &quot;libEGL.dll&quot;
#define DEFAULT_OGL_ES2 &quot;libGLESv2.dll&quot;


int
SDL_EGL_LoadLibrary(_THIS, const char *egl_path, NativeDisplayType native_display, EGLenum platform)
{
    ...
    //加载GL ES
    path = DEFAULT_OGL_ES2;
    egl_dll_handle = SDL_LoadObject(path);     
    ...
    //加载EGL
    if (path == NULL) {
        path = DEFAULT_EGL;
    }
    dll_handle = SDL_LoadObject(path);
    ...
    //加载EGL相关函数
    /* Load new function pointers */
    LOAD_FUNC(eglGetDisplay);
    LOAD_FUNC(eglInitialize);
    LOAD_FUNC(eglTerminate);
    LOAD_FUNC(eglGetProcAddress);
    LOAD_FUNC(eglChooseConfig);
    LOAD_FUNC(eglGetConfigAttrib);
    LOAD_FUNC(eglCreateContext);
    LOAD_FUNC(eglDestroyContext);
    LOAD_FUNC(eglCreatePbufferSurface);
    LOAD_FUNC(eglCreateWindowSurface);
    LOAD_FUNC(eglDestroySurface);
    LOAD_FUNC(eglMakeCurrent);
    LOAD_FUNC(eglSwapBuffers);
    LOAD_FUNC(eglSwapInterval);
    LOAD_FUNC(eglWaitNative);
    LOAD_FUNC(eglWaitGL);
    LOAD_FUNC(eglBindAPI);
    LOAD_FUNC(eglQueryString);
    LOAD_FUNC(eglGetError);
    ...
    /* Try the implementation-specific eglGetDisplay even if eglGetPlatformDisplay fails */
    //1.获取 EGL Display 对象
    if (_this-&amp;gt;egl_data-&amp;gt;egl_display == EGL_NO_DISPLAY) {
        _this-&amp;gt;egl_data-&amp;gt;egl_display = _this-&amp;gt;egl_data-&amp;gt;eglGetDisplay(native_display);
    }
    if (_this-&amp;gt;egl_data-&amp;gt;egl_display == EGL_NO_DISPLAY) {
        return SDL_SetError(&quot;Could not get EGL display&quot;);
    }
    //2.初始化与 EGLDisplay 之间的连接
    if (_this-&amp;gt;egl_data-&amp;gt;eglInitialize(_this-&amp;gt;egl_data-&amp;gt;egl_display, NULL, NULL) != EGL_TRUE) {
        return SDL_SetError(&quot;Could not initialize EGL&quot;);
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看&lt;a href=&quot;https://www.cnblogs.com/harlanc/p/9681643.html#_label0_2&quot;&gt;关于EGL的介绍&lt;/a&gt;中使用EGL绘图的步骤, SDL_EGL_LoadLibrary中执行了1，2两步。&lt;/p&gt;
&lt;p&gt;接下来创建surface:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;EGLSurface *
SDL_EGL_CreateSurface(_THIS, NativeWindowType nw) 
{
    /* max 2 values plus terminator. */
    EGLint attribs[3];
    int attr = 0;
    
    EGLSurface * surface;
    //3.获取 EGLConfig 对象 
    if (SDL_EGL_ChooseConfig(_this) != 0) {
        return EGL_NO_SURFACE;
    }
    
#if SDL_VIDEO_DRIVER_ANDROID
    {
        /* Android docs recommend doing this!
         * Ref: http://developer.android.com/reference/android/app/NativeActivity.html 
         */
        EGLint format;
        _this-&amp;gt;egl_data-&amp;gt;eglGetConfigAttrib(_this-&amp;gt;egl_data-&amp;gt;egl_display,
                                            _this-&amp;gt;egl_data-&amp;gt;egl_config, 
                                            EGL_NATIVE_VISUAL_ID, &amp;amp;format);

        ANativeWindow_setBuffersGeometry(nw, 0, 0, format);
    }
#endif    
    if (_this-&amp;gt;gl_config.framebuffer_srgb_capable) {
#ifdef EGL_KHR_gl_colorspace
        if (SDL_EGL_HasExtension(_this, SDL_EGL_DISPLAY_EXTENSION, &quot;EGL_KHR_gl_colorspace&quot;)) {
            attribs[attr++] = EGL_GL_COLORSPACE_KHR;
            attribs[attr++] = EGL_GL_COLORSPACE_SRGB_KHR;
        } else
#endif
        {
            SDL_SetError(&quot;EGL implementation does not support sRGB system framebuffers&quot;);
            return EGL_NO_SURFACE;
        }
    }
    
    attribs[attr++] = EGL_NONE;
    //5.创建 EGLSurface 实例
    surface = _this-&amp;gt;egl_data-&amp;gt;eglCreateWindowSurface(
            _this-&amp;gt;egl_data-&amp;gt;egl_display,
            _this-&amp;gt;egl_data-&amp;gt;egl_config,
            nw, &amp;amp;attribs[0]);
    if (surface == EGL_NO_SURFACE) {
        SDL_EGL_SetError(&quot;unable to create an EGL window surface&quot;, &quot;eglCreateWindowSurface&quot;);
    }
    return surface;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先获取EGLConfig 对象,然后创建EGLSurface&lt;/p&gt;
&lt;h3 id=&quot;sdl_createrenderer&quot;&gt;SDL_CreateRenderer&lt;/h3&gt;
&lt;p&gt;我们选择的是OpenGL ES的driver:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#if SDL_VIDEO_RENDER_OGL_ES
    &amp;amp;GLES_RenderDriver,
#endif&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此Render函数为OpenGL ES的driver中的Render函数，也就是GLES_CreateRenderer：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SDL_RenderDriver GLES_RenderDriver = {
    GLES_CreateRenderer,
    {
     &quot;opengles&quot;,
     (SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC),
     1,
     {SDL_PIXELFORMAT_ABGR8888},
     0,
     0}
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看一下Render函数的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SDL_Renderer *
GLES_CreateRenderer(SDL_Window * window, Uint32 flags)
{

      SDL_Renderer *renderer;
    ...
      renderer-&amp;gt;WindowEvent = GLES_WindowEvent;
    renderer-&amp;gt;GetOutputSize = GLES_GetOutputSize;
    renderer-&amp;gt;SupportsBlendMode = GLES_SupportsBlendMode;
    renderer-&amp;gt;CreateTexture = GLES_CreateTexture;
    renderer-&amp;gt;UpdateTexture = GLES_UpdateTexture;
    renderer-&amp;gt;LockTexture = GLES_LockTexture;
    renderer-&amp;gt;UnlockTexture = GLES_UnlockTexture;
    renderer-&amp;gt;SetRenderTarget = GLES_SetRenderTarget;
    renderer-&amp;gt;UpdateViewport = GLES_UpdateViewport;
    renderer-&amp;gt;UpdateClipRect = GLES_UpdateClipRect;
    renderer-&amp;gt;RenderClear = GLES_RenderClear;
    renderer-&amp;gt;RenderDrawPoints = GLES_RenderDrawPoints;
    renderer-&amp;gt;RenderDrawLines = GLES_RenderDrawLines;
    renderer-&amp;gt;RenderFillRects = GLES_RenderFillRects;
    renderer-&amp;gt;RenderCopy = GLES_RenderCopy;
    renderer-&amp;gt;RenderCopyEx = GLES_RenderCopyEx;
    renderer-&amp;gt;RenderReadPixels = GLES_RenderReadPixels;
    renderer-&amp;gt;RenderPresent = GLES_RenderPresent;
    renderer-&amp;gt;DestroyTexture = GLES_DestroyTexture;
    renderer-&amp;gt;DestroyRenderer = GLES_DestroyRenderer;
    renderer-&amp;gt;GL_BindTexture = GLES_BindTexture;
    renderer-&amp;gt;GL_UnbindTexture = GLES_UnbindTexture;
    renderer-&amp;gt;info = GLES_RenderDriver.info;
    renderer-&amp;gt;info.flags = SDL_RENDERER_ACCELERATED;
    renderer-&amp;gt;driverdata = data;
    renderer-&amp;gt;window = window;

    data-&amp;gt;context = SDL_GL_CreateContext(window);
    if (!data-&amp;gt;context) {
        GLES_DestroyRenderer(renderer);
        goto error;
    }
    if (SDL_GL_MakeCurrent(window, data-&amp;gt;context) &amp;lt; 0) {
        GLES_DestroyRenderer(renderer);
        goto error;
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此函数指定了GL ES使用的一些渲染函数，执行了上面提到的EGL渲染步骤的4，6步。看一下SDL_GL_CreateContext函数的具体内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SDL_GLContext
SDL_GL_CreateContext(SDL_Window * window)
{
    SDL_GLContext ctx = NULL;
    CHECK_WINDOW_MAGIC(window, NULL);

    if (!(window-&amp;gt;flags &amp;amp; SDL_WINDOW_OPENGL)) {
        SDL_SetError(&quot;The specified window isn't an OpenGL window&quot;);
        return NULL;
    }

    ctx = _this-&amp;gt;GL_CreateContext(_this, window);

    /* Creating a context is assumed to make it current in the SDL driver. */
    if (ctx) {
        _this-&amp;gt;current_glwin = window;
        _this-&amp;gt;current_glctx = ctx;
        SDL_TLSSet(_this-&amp;gt;current_glwin_tls, window, NULL);
        SDL_TLSSet(_this-&amp;gt;current_glctx_tls, ctx, NULL);
    }
    return ctx;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的GL_CreateContext函数为Windows平台下的GL ES版本的函数，由前面的WIN_CreateDevice指定的:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SDL_GLContext
WIN_GLES_CreateContext(_THIS, SDL_Window * window)
{
    SDL_GLContext context;
    SDL_WindowData *data = (SDL_WindowData *)window-&amp;gt;driverdata;

#if SDL_VIDEO_OPENGL_WGL
    if (_this-&amp;gt;gl_config.profile_mask != SDL_GL_CONTEXT_PROFILE_ES) {
        /* Switch to WGL based functions */
        WIN_GLES_UnloadLibrary(_this);
        _this-&amp;gt;GL_LoadLibrary = WIN_GL_LoadLibrary;
        _this-&amp;gt;GL_GetProcAddress = WIN_GL_GetProcAddress;
        _this-&amp;gt;GL_UnloadLibrary = WIN_GL_UnloadLibrary;
        _this-&amp;gt;GL_CreateContext = WIN_GL_CreateContext;
        _this-&amp;gt;GL_MakeCurrent = WIN_GL_MakeCurrent;
        _this-&amp;gt;GL_SetSwapInterval = WIN_GL_SetSwapInterval;
        _this-&amp;gt;GL_GetSwapInterval = WIN_GL_GetSwapInterval;
        _this-&amp;gt;GL_SwapWindow = WIN_GL_SwapWindow;
        _this-&amp;gt;GL_DeleteContext = WIN_GL_DeleteContext;

        if (WIN_GL_LoadLibrary(_this, NULL) != 0) {
            return NULL;
        }

        return WIN_GL_CreateContext(_this, window);
    }
#endif

    context = SDL_EGL_CreateContext(_this, data-&amp;gt;egl_surface);
    return context;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们没有使用WGL，因此最终调用的是SDL_EGL_CreateContext，上面提到的EGL渲染过程的第4和第6步骤最终在此函数中进行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SDL_GLContext
    SDL_EGL_CreateContext(_THIS, EGLSurface egl_surface)
{
    ...

    egl_context = _this-&amp;gt;egl_data-&amp;gt;eglCreateContext(_this-&amp;gt;egl_data-&amp;gt;egl_display,
                                      _this-&amp;gt;egl_data-&amp;gt;egl_config,
                                      share_context, attribs);

    if (egl_context == EGL_NO_CONTEXT) {
        SDL_EGL_SetError(&quot;Could not create EGL context&quot;, &quot;eglCreateContext&quot;);
        return NULL;
    }

    _this-&amp;gt;egl_data-&amp;gt;egl_swapinterval = 0;

    if (SDL_EGL_MakeCurrent(_this, egl_surface, egl_context) &amp;lt; 0) {
        /* Save the SDL error set by SDL_EGL_MakeCurrent */
        char errorText[1024];
        SDL_strlcpy(errorText, SDL_GetError(), SDL_arraysize(errorText));

        /* Delete the context, which may alter the value returned by SDL_GetError() */
        SDL_EGL_DeleteContext(_this, egl_context);

        /* Restore the SDL error */
        SDL_SetError(&quot;%s&quot;, errorText);

        return NULL;
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sdl_createtexture&quot;&gt;SDL_CreateTexture&lt;/h3&gt;
&lt;p&gt;从此函数开始就是EGL绘图步骤的第七步骤，使用相关的gl*函数进行绘制。从表至里的分析就不进行了，最终调用的创建texture函数为GLES_CreateTexture，我们看一下gl开头的openGL相关函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static int
GLES_CreateTexture(SDL_Renderer * renderer, SDL_Texture * texture)
{
    GLES_RenderData *renderdata = (GLES_RenderData *) renderer-&amp;gt;driverdata;
    ...

    renderdata-&amp;gt;glGetError();
    renderdata-&amp;gt;glEnable(GL_TEXTURE_2D);//we need to enable texturing before drawing the scene
    /*
    Any nonzero unsigned integer may be used as a texture name. To avoid
    accidentally reusing names, consistently use glGenTextures() to provide
    unused texture names.
    */
    renderdata-&amp;gt;glGenTextures(1, &amp;amp;data-&amp;gt;texture);
    result = renderdata-&amp;gt;glGetError();
    if (result != GL_NO_ERROR) {
        SDL_free(data);
        return GLES_SetError(&quot;glGenTextures()&quot;, result);
    }

    data-&amp;gt;type = GL_TEXTURE_2D;
    /* no NPOV textures allowed in OpenGL ES (yet) */
    texture_w = power_of_2(texture-&amp;gt;w);
    texture_h = power_of_2(texture-&amp;gt;h);
    data-&amp;gt;texw = (GLfloat) texture-&amp;gt;w / texture_w;
    data-&amp;gt;texh = (GLfloat) texture-&amp;gt;h / texture_h;

    data-&amp;gt;format = format;
    data-&amp;gt;formattype = type;
    scaleMode = GetScaleQuality();
    /*
    glBindTexture(), both creates and uses texture objects.
    When a texture name is initially bound (used with glBindTexture()), a new
    texture object is created with default values for the texture image and texture properties
    */
    renderdata-&amp;gt;glBindTexture(data-&amp;gt;type, data-&amp;gt;texture);
    /*
    Sets various parameters that control how a texture is treated as it’s applied
    to a fragment or stored in a texture object
    */
    renderdata-&amp;gt;glTexParameteri(data-&amp;gt;type, GL_TEXTURE_MIN_FILTER, scaleMode);
    renderdata-&amp;gt;glTexParameteri(data-&amp;gt;type, GL_TEXTURE_MAG_FILTER, scaleMode);
    renderdata-&amp;gt;glTexParameteri(data-&amp;gt;type, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    renderdata-&amp;gt;glTexParameteri(data-&amp;gt;type, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    /*
    
    Defines a two-dimensional texture, or a one-dimensional texture array.
    */
    renderdata-&amp;gt;glTexImage2D(data-&amp;gt;type, 0, internalFormat, texture_w,
                             texture_h, 0, format, type, NULL);
    /*
    Disable it if texture rendering operations are finished.
    */
    renderdata-&amp;gt;glDisable(GL_TEXTURE_2D);

    result = renderdata-&amp;gt;glGetError();
    if (result != GL_NO_ERROR) {
        SDL_free(data);
        return GLES_SetError(&quot;glTexImage2D()&quot;, result);
    }
    
    texture-&amp;gt;driverdata = data;
    return 0;
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后成功创建了texture。&lt;/p&gt;
&lt;h3 id=&quot;sdl_updateyuvtexture&quot;&gt;SDL_UpdateYUVTexture&lt;/h3&gt;
&lt;p&gt;万事俱备，只欠东风，OpenGL texture创建完成后，就只等渲染了。SDL中的渲染函数为SDL_UpdateYUVTexture,我们还是直接看Open GL ES版本的渲染函数GLES_UpdateTexture:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static int
GLES_UpdateTexture(SDL_Renderer * renderer, SDL_Texture * texture,
                   const SDL_Rect * rect, const void *pixels, int pitch)
{
    GLES_RenderData *renderdata = (GLES_RenderData *) renderer-&amp;gt;driverdata;
    
    ...
    /* Reformat the texture data into a tightly packed array */
    srcPitch = rect-&amp;gt;w * SDL_BYTESPERPIXEL(texture-&amp;gt;format);
    src = (Uint8 *)pixels;
    if (pitch != srcPitch) {
        blob = (Uint8 *)SDL_malloc(srcPitch * rect-&amp;gt;h);
        if (!blob) {
            return SDL_OutOfMemory();
        }
        src = blob;
        for (y = 0; y &amp;lt; rect-&amp;gt;h; ++y) {
            SDL_memcpy(src, pixels, srcPitch);
            src += srcPitch;
            pixels = (Uint8 *)pixels + pitch;
        }
        src = blob;
    }

    /* Create a texture subimage with the supplied data */
    renderdata-&amp;gt;glGetError();
    //enable texturing before drawing the scene
    renderdata-&amp;gt;glEnable(data-&amp;gt;type);
    /*
    When binding to a previously created texture object, that texture object becomes active. 
    */
    renderdata-&amp;gt;glBindTexture(data-&amp;gt;type, data-&amp;gt;texture);
    /*
    it describes how the bitmap data is stored in computer memory
    */
    renderdata-&amp;gt;glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    /*
    Defines a two-dimensional texture image that replaces all or part of
    a contiguous subregion (in 2D, it’s simply a rectangle) of the current,
    existing two-dimensional texture image.
    */
    renderdata-&amp;gt;glTexSubImage2D(data-&amp;gt;type,
                    0,
                    rect-&amp;gt;x,
                    rect-&amp;gt;y,
                    rect-&amp;gt;w,
                    rect-&amp;gt;h,
                    data-&amp;gt;format,
                    data-&amp;gt;formattype,
                    src);
    renderdata-&amp;gt;glDisable(data-&amp;gt;type);
    SDL_free(blob);

    if (renderdata-&amp;gt;glGetError() != GL_NO_ERROR) {
        return SDL_SetError(&quot;Failed to update texture&quot;);
    }
    return 0;
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;pixels为需要显示的像素数据，pitch为像素间距。&lt;/p&gt;
&lt;h3 id=&quot;sdl_renderclear&quot;&gt;SDL_RenderClear&lt;/h3&gt;
&lt;p&gt;还是只看GL ES的最终调用，主要理解glClear和glClearColor这两个函数，来自官方文档的解释写在注释中了，glClear函数用来清除窗口，glClearColor用于设置清理窗口之后显示的颜色。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static int
GLES_RenderClear(SDL_Renderer * renderer)
{
    GLES_RenderData *data = (GLES_RenderData *) renderer-&amp;gt;driverdata;

    GLES_ActivateRenderer(renderer);

    /*
    glClearColor() establishes what color the window will be cleared to, and
    glClear() actually clears the window. Once the clearing color is set, the
    window is cleared to that color whenever glClear() is called. This clearing
    color can be changed with another call to glClearColor().
    */

    data-&amp;gt;glClearColor((GLfloat) renderer-&amp;gt;r * inv255f,
                 (GLfloat) renderer-&amp;gt;g * inv255f,
                 (GLfloat) renderer-&amp;gt;b * inv255f,
                 (GLfloat) renderer-&amp;gt;a * inv255f);
    
    if (renderer-&amp;gt;clipping_enabled) {
        data-&amp;gt;glDisable(GL_SCISSOR_TEST);
    }

    data-&amp;gt;glClear(GL_COLOR_BUFFER_BIT);

    if (renderer-&amp;gt;clipping_enabled) {
        data-&amp;gt;glEnable(GL_SCISSOR_TEST);
    }

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sdl_rendercopy&quot;&gt;SDL_RenderCopy&lt;/h3&gt;
&lt;p&gt;图像的绘制在这个函数中进行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static int
GLES_RenderCopy(SDL_Renderer * renderer, SDL_Texture * texture,
                const SDL_Rect * srcrect, const SDL_FRect * dstrect)
{
    GLES_RenderData *data = (GLES_RenderData *) renderer-&amp;gt;driverdata;
    GLES_TextureData *texturedata = (GLES_TextureData *) texture-&amp;gt;driverdata;
    GLfloat minx, miny, maxx, maxy;
    GLfloat minu, maxu, minv, maxv;
    GLfloat vertices[8];
    GLfloat texCoords[8];

    GLES_ActivateRenderer(renderer);

    data-&amp;gt;glEnable(GL_TEXTURE_2D);

    data-&amp;gt;glBindTexture(texturedata-&amp;gt;type, texturedata-&amp;gt;texture);

    if (texture-&amp;gt;modMode) {
        GLES_SetColor(data, texture-&amp;gt;r, texture-&amp;gt;g, texture-&amp;gt;b, texture-&amp;gt;a);
    } else {
        GLES_SetColor(data, 255, 255, 255, 255);
    }

    GLES_SetBlendMode(data, texture-&amp;gt;blendMode);

    //启用或者停止纹理坐标
    GLES_SetTexCoords(data, SDL_TRUE);

    minx = dstrect-&amp;gt;x;
    miny = dstrect-&amp;gt;y;
    maxx = dstrect-&amp;gt;x + dstrect-&amp;gt;w;
    maxy = dstrect-&amp;gt;y + dstrect-&amp;gt;h;

    minu = (GLfloat) srcrect-&amp;gt;x / texture-&amp;gt;w;
    minu *= texturedata-&amp;gt;texw;
    maxu = (GLfloat) (srcrect-&amp;gt;x + srcrect-&amp;gt;w) / texture-&amp;gt;w;
    maxu *= texturedata-&amp;gt;texw;
    minv = (GLfloat) srcrect-&amp;gt;y / texture-&amp;gt;h;
    minv *= texturedata-&amp;gt;texh;
    maxv = (GLfloat) (srcrect-&amp;gt;y + srcrect-&amp;gt;h) / texture-&amp;gt;h;
    maxv *= texturedata-&amp;gt;texh;

    vertices[0] = minx;
    vertices[1] = miny;
    vertices[2] = maxx;
    vertices[3] = miny;
    vertices[4] = minx;
    vertices[5] = maxy;
    vertices[6] = maxx;
    vertices[7] = maxy;

    texCoords[0] = minu;
    texCoords[1] = minv;
    texCoords[2] = maxu;
    texCoords[3] = minv;
    texCoords[4] = minu;
    texCoords[5] = maxv;
    texCoords[6] = maxu;
    texCoords[7] = maxv;

    //告诉openGL顶点坐标数据的位置
    data-&amp;gt;glVertexPointer(2, GL_FLOAT, 0, vertices);
    //告诉OpenGL纹理坐标的位置
    data-&amp;gt;glTexCoordPointer(2, GL_FLOAT, 0, texCoords);
    //将数据绘制出来
    data-&amp;gt;glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);

    data-&amp;gt;glDisable(GL_TEXTURE_2D);

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sdl_renderpresent&quot;&gt;SDL_RenderPresent&lt;/h3&gt;
&lt;p&gt;顾名思义，此函数用于显示图像，他执行了EGL绘图步骤的第8步：eglSwapBuffer()，切换 front buffer 和 back buffer 送显，看一下GL ES的RenderPresent函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static void
GLES_RenderPresent(SDL_Renderer * renderer)
{
    GLES_ActivateRenderer(renderer);

    SDL_GL_SwapWindow(renderer-&amp;gt;window);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;激活Render之后就进行Swap,windows GL ES中的实现是在如下函数中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;WIN_GLES_SwapWindow&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此函数在源码中搜索了半天没有搜到，原来是用了宏定义。。。，太隐蔽了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SDL_EGL_SwapWindow_impl(WIN)


#define SDL_EGL_SwapWindow_impl(BACKEND) int \
BACKEND ## _GLES_SwapWindow(_THIS, SDL_Window * window) \
{\
    return SDL_EGL_SwapBuffers(_this, ((SDL_WindowData *) window-&amp;gt;driverdata)-&amp;gt;egl_surface);\
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终调用了EGL的eglSwapBuffers函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int
SDL_EGL_SwapBuffers(_THIS, EGLSurface egl_surface)
{
    if (!_this-&amp;gt;egl_data-&amp;gt;eglSwapBuffers(_this-&amp;gt;egl_data-&amp;gt;egl_display, egl_surface)) {
        return SDL_EGL_SetError(&quot;unable to show color buffer in an OS-native window&quot;, &quot;eglSwapBuffers&quot;);
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sdl_pollevent&quot;&gt;SDL_PollEvent&lt;/h3&gt;
&lt;p&gt;此函数一看便知是用于侦听各种事件的，源码不再细究。&lt;/p&gt;
&lt;p&gt;接下来就是一些销毁释放的过程了。&lt;/p&gt;
&lt;h3 id=&quot;sdl_destroytexture&quot;&gt;SDL_DestroyTexture&lt;/h3&gt;
&lt;p&gt;销毁texture通过调用glDeleteTextures来实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static void
GLES_DestroyTexture(SDL_Renderer * renderer, SDL_Texture * texture)
{
    GLES_RenderData *renderdata = (GLES_RenderData *) renderer-&amp;gt;driverdata;

    GLES_TextureData *data = (GLES_TextureData *) texture-&amp;gt;driverdata;

    GLES_ActivateRenderer(renderer);

    if (!data) {
        return;
    }
    if (data-&amp;gt;texture) {
        renderdata-&amp;gt;glDeleteTextures(1, &amp;amp;data-&amp;gt;texture);
    }
    SDL_free(data-&amp;gt;pixels);
    SDL_free(data);
    texture-&amp;gt;driverdata = NULL;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sdl_destroyrenderer&quot;&gt;SDL_DestroyRenderer&lt;/h3&gt;
&lt;p&gt;渲染对象的销毁使用如下函数，上面出现过glDeleteFramebuffersOES类似的函数，没有仔细研究，搜索了openGL的官方文档，竟然没有任何说明，看字面意思就是删除相关缓存的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static void
GLES_DestroyRenderer(SDL_Renderer * renderer)
{
    GLES_RenderData *data = (GLES_RenderData *) renderer-&amp;gt;driverdata;

    if (data) {
        if (data-&amp;gt;context) {
            while (data-&amp;gt;framebuffers) {
               GLES_FBOList *nextnode = data-&amp;gt;framebuffers-&amp;gt;next;
               data-&amp;gt;glDeleteFramebuffersOES(1, &amp;amp;data-&amp;gt;framebuffers-&amp;gt;FBO);
               SDL_free(data-&amp;gt;framebuffers);
               data-&amp;gt;framebuffers = nextnode;
            }
            SDL_GL_DeleteContext(data-&amp;gt;context);
        }
        SDL_free(data);
    }
    SDL_free(renderer);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后删除Context：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void
WIN_GLES_DeleteContext(_THIS, SDL_GLContext context)
{
    SDL_EGL_DeleteContext(_this, context);
    WIN_GLES_UnloadLibrary(_this);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在SDL_EGL_DeleteContext中调用EGL销毁函数eglDestroyContext，EGL绘图的第11步。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void
SDL_EGL_DeleteContext(_THIS, SDL_GLContext context)
{
    EGLContext egl_context = (EGLContext) context;

    /* Clean up GLES and EGL */
    if (!_this-&amp;gt;egl_data) {
        return;
    }
    
    if (egl_context != NULL &amp;amp;&amp;amp; egl_context != EGL_NO_CONTEXT) {
        SDL_EGL_MakeCurrent(_this, NULL, NULL);
        _this-&amp;gt;egl_data-&amp;gt;eglDestroyContext(_this-&amp;gt;egl_data-&amp;gt;egl_display, egl_context);
    }
        
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;WIN_GLES_UnloadLibrary 函数实际上为SDL_EGL_UnloadLibrary函数:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define WIN_GLES_UnloadLibrary SDL_EGL_UnloadLibrary

void
SDL_EGL_UnloadLibrary(_THIS)
{
    if (_this-&amp;gt;egl_data) {
        if (_this-&amp;gt;egl_data-&amp;gt;egl_display) {
            _this-&amp;gt;egl_data-&amp;gt;eglTerminate(_this-&amp;gt;egl_data-&amp;gt;egl_display);
            _this-&amp;gt;egl_data-&amp;gt;egl_display = NULL;
        }

        if (_this-&amp;gt;egl_data-&amp;gt;dll_handle) {
            SDL_UnloadObject(_this-&amp;gt;egl_data-&amp;gt;dll_handle);
            _this-&amp;gt;egl_data-&amp;gt;dll_handle = NULL;
        }
        if (_this-&amp;gt;egl_data-&amp;gt;egl_dll_handle) {
            SDL_UnloadObject(_this-&amp;gt;egl_data-&amp;gt;egl_dll_handle);
            _this-&amp;gt;egl_data-&amp;gt;egl_dll_handle = NULL;
        }
        
        SDL_free(_this-&amp;gt;egl_data);
        _this-&amp;gt;egl_data = NULL;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用EGL终止函数，终止了与EGLDisplay之间的连接，也就是EGL绘图的第12步，然后卸载相关的DLL。&lt;/p&gt;
&lt;h3 id=&quot;sdl_destorywindow&quot;&gt;SDL_DestoryWindow&lt;/h3&gt;
&lt;p&gt;调用windows函数 DestroyWindow销毁窗体：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; void
WIN_DestroyWindow(_THIS, SDL_Window * window)
{
    SDL_WindowData *data = (SDL_WindowData *) window-&amp;gt;driverdata;

    if (data) {
        ReleaseDC(data-&amp;gt;hwnd, data-&amp;gt;hdc);
        RemoveProp(data-&amp;gt;hwnd, TEXT(&quot;SDL_WindowData&quot;));
        if (data-&amp;gt;created) {
            DestroyWindow(data-&amp;gt;hwnd);
            if (data-&amp;gt;parent) {
                DestroyWindow(data-&amp;gt;parent);
            }
        } else {
            /* Restore any original event handler... */
            if (data-&amp;gt;wndproc != NULL) {
#ifdef GWLP_WNDPROC
                SetWindowLongPtr(data-&amp;gt;hwnd, GWLP_WNDPROC,
                                 (LONG_PTR) data-&amp;gt;wndproc);
#else
                SetWindowLong(data-&amp;gt;hwnd, GWL_WNDPROC,
                              (LONG_PTR) data-&amp;gt;wndproc);
#endif
            }
        }
        SDL_free(data);
    }
    window-&amp;gt;driverdata = NULL;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;sdl_quit&quot;&gt;SDL_Quit&lt;/h3&gt;
&lt;p&gt;只看视频系统的Quit函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void
WIN_VideoQuit(_THIS)
{
    WIN_QuitModes(_this);
    WIN_QuitKeyboard(_this);
    WIN_QuitMouse(_this);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://my.oschina.net/sweetdark/blog/185398&quot;&gt;OpenGL超级宝典笔记——顶点数组&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 13:45:00 +0000</pubDate>
<dc:creator>HarlanC</dc:creator>
<og:description>SDL2源码分析之OpenGL ES在windows上的渲染过程 ffmpeg + SDL2实现的简易播放器 ffmpeg和SDL非常强大，通过使用ffmpeg和SDL可以用100多行代码就实现一个简</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/harlanc/p/9867414.html</dc:identifier>
</item>
<item>
<title>RNN入门（4）利用LSTM实现整数加法运算 - jclian91</title>
<link>http://www.cnblogs.com/jclian91/p/9867229.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jclian91/p/9867229.html</guid>
<description>&lt;p&gt;  本文将介绍LSTM模型在实现整数加法方面的应用。&lt;br/&gt;  我们以0-255之间的整数加法为例，生成的结果在0到510之间。为了能利用深度学习模型模拟整数的加法运算，我们需要将输入的两个加数和输出的结果用二进制表示，这样就能得到向量，如加数在0-255内，可以用8位0-1向量来表示，前面的空位用0填充；结果在0-510内，可以用9位0-1向量来表示，前面的空位用0填充。因为两个加数均在0-255内变化，所以共有256*256=65536个输入向量以及65536个输出向量，输入向量为两个加数的二进制向量的拼接结果，因而是个16为的输入向量。用以下的Python代码可以模拟以上过程：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import numpy as np

# 最多8位二进制
BINARY_DIM = 8

# 将整数表示成为binary_dim位的二进制数，高位用0补齐
def int_2_binary(number, binary_dim):
    binary_list = list(map(lambda x: int(x), bin(number)[2:]))
    number_dim = len(binary_list)
    result_list = [0]*(binary_dim-number_dim)+binary_list
    return result_list

# 将一个二进制数组转为整数
def binary2int(binary_array):
    out = 0
    for index, x in enumerate(reversed(binary_array)):
        out += x * pow(2, index)
    return out

# 将[0,2**BINARY_DIM)所有数表示成二进制
binary = np.array([int_2_binary(x, BINARY_DIM) for x in range(2**BINARY_DIM)])
# print(binary)

# 样本的输入向量和输出向量
dataX = []
dataY = []
for i in range(binary.shape[0]):
    for j in range(binary.shape[0]):
        dataX.append(np.append(binary[i], binary[j]))
        dataY.append(int_2_binary(i+j, BINARY_DIM+1))

# print(dataX)
# print(dataY)

# 重新特征X和目标变量Y数组，适应LSTM模型的输入和输出
X = np.reshape(dataX, (len(dataX), 2*BINARY_DIM, 1))
# print(X.shape)
Y = np.array(dataY)
# print(dataY.shape)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在以上代码中，得到的dataX和dataY以满足要求，但为了能让LSTM模型处理，需要改变这两个数据集的形状。&lt;br/&gt;  我们采用LSTM模型来训练上述数据，LSTM模型的结构很简单，就是简单的一层LSTM层，然后加上Dropout层，最后是全连接层，激活函数采用sigmoid函数，采用的损失函数为平均平方误差。整个结构的示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-6f741cf12dc24b88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;LSTM模型的结构示意图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模型训练的代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.layers import LSTM
from keras import losses
from keras.utils import plot_model

# 定义LSTM模型
model = Sequential()
model.add(LSTM(256, input_shape=(X.shape[1], X.shape[2])))
model.add(Dropout(0.2))
model.add(Dense(Y.shape[1], activation='sigmoid'))
model.compile(loss=losses.mean_squared_error, optimizer='adam')
# print(model.summary())

# plot model
plot_model(model, to_file=r'./model.png', show_shapes=True)
# train model
epochs = 100
model.fit(X, Y, epochs=epochs, batch_size=128)
# save model
mp = r'./LSTM_Operation.h5'
model.save(mp)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该LSTM模型每批训练128个样本，共训练100次，采用Adam优化器减少损失值。&lt;br/&gt;  对这个模型进行训练，训练100次，损失值为0.0045。接下来我们就要用这个训练好的模型来预测。我们预测的方法为，虽然挑两个在0-255内的加数，转化为二进制向量作为输入向量，然后由LSTM模型输出结果，将该结果取整作为输出向量中的元素，最后将这个输出向量转化为整数，就是预测的两个加数的和。模型预测的代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# use LSTM model to predict
for _ in range(100):
    start = np.random.randint(0, len(dataX)-1)
    # print(dataX[start])
    number1 = dataX[start][0:BINARY_DIM]
    number2 = dataX[start][BINARY_DIM:]
    print('='*30)
    print('%s: %s'%(number1, binary2int(number1)))
    print('%s: %s'%(number2, binary2int(number2)))
    sample = np.reshape(X[start], (1, 2*BINARY_DIM, 1))
    predict = np.round(model.predict(sample), 0).astype(np.int32)[0]
    print('%s: %s'%(predict, binary2int(predict)))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;预测的100组样本的输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;==============================
[1 0 0 1 1 1 0 1]: 157
[0 1 1 1 0 0 0 1]: 113
[1 0 0 0 0 1 1 1 0]: 270
==============================
[1 1 1 0 1 0 1 0]: 234
[0 1 0 0 1 1 0 0]: 76
[1 0 0 1 1 0 1 1 0]: 310
==============================
[1 1 0 0 0 1 0 0]: 196
[1 1 0 1 1 0 1 1]: 219
[1 1 0 0 1 1 1 1 1]: 415
==============================
[0 0 1 1 1 0 1 0]: 58
[0 0 1 0 0 0 1 1]: 35
[0 0 1 0 1 1 1 0 1]: 93
==============================
[1 0 0 0 0 0 0 0]: 128
[0 1 1 1 1 0 0 1]: 121
[0 1 1 1 1 1 0 0 1]: 249
==============================
[1 1 1 1 0 1 1 0]: 246
[1 1 0 1 0 1 0 1]: 213
[1 1 1 0 0 1 0 1 1]: 459
==============================
[1 1 1 0 0 1 1 0]: 230
[1 0 0 0 0 0 0 0]: 128
[1 0 1 1 0 0 1 1 0]: 358
==============================
[1 0 1 0 0 0 1 1]: 163
[0 1 1 0 0 1 0 1]: 101
[1 0 0 0 0 1 0 0 0]: 264
==============================
[1 0 1 0 0 1 1 0]: 166
[0 1 0 1 0 0 0 0]: 80
[0 1 1 1 1 0 1 1 0]: 246
==============================
[0 0 0 0 1 0 1 1]: 11
[0 1 0 0 0 1 0 1]: 69
[0 0 1 0 1 0 0 0 0]: 80
==============================
[1 1 1 1 0 1 1 1]: 247
[0 1 1 1 0 0 0 0]: 112
[1 0 1 1 0 0 1 1 1]: 359
==============================
[1 0 1 0 1 0 0 1]: 169
[1 1 0 0 0 0 0 0]: 192
[1 0 1 1 0 1 0 0 1]: 361
==============================
[1 0 1 1 0 0 0 1]: 177
[1 0 0 0 1 0 1 1]: 139
[1 0 0 1 1 1 1 0 0]: 316
==============================
[0 1 0 0 0 1 1 0]: 70
[0 0 1 0 1 1 1 0]: 46
[0 0 1 1 1 0 1 0 0]: 116
==============================
[1 0 0 1 1 0 1 1]: 155
[1 1 0 0 0 0 0 1]: 193
[1 0 1 0 1 1 1 0 0]: 348
==============================
[1 0 1 1 0 0 1 0]: 178
[1 0 0 0 1 1 1 1]: 143
[1 0 1 0 0 0 0 0 1]: 321
==============================
[0 1 0 1 1 1 1 1]: 95
[1 1 1 0 0 1 0 0]: 228
[1 0 1 0 0 0 0 1 1]: 323
==============================
[1 0 0 1 1 1 1 0]: 158
[0 0 0 1 1 0 0 1]: 25
[0 1 0 1 1 0 1 1 1]: 183
==============================
[1 1 1 0 1 0 1 1]: 235
[1 1 0 0 0 0 0 1]: 193
[1 1 0 1 0 1 1 0 0]: 428
==============================
[0 1 0 1 1 1 0 1]: 93
[0 1 1 1 0 1 1 0]: 118
[0 1 1 0 1 0 0 1 1]: 211
==============================
[1 1 1 1 1 1 1 1]: 255
[1 1 1 1 1 1 1 0]: 254
[1 1 1 1 1 1 1 0 1]: 509
==============================
[0 1 0 1 1 0 0 1]: 89
[0 1 0 1 1 1 1 0]: 94
[0 1 0 1 1 0 1 1 1]: 183
==============================
[0 1 1 1 0 0 0 0]: 112
[0 0 1 1 0 1 0 0]: 52
[0 1 0 1 0 0 1 0 0]: 164
==============================
[1 0 0 0 0 0 0 0]: 128
[1 1 0 1 1 0 1 0]: 218
[1 0 1 0 1 1 0 1 0]: 346
==============================
[0 0 1 1 0 1 0 1]: 53
[1 0 1 1 1 1 1 0]: 190
[0 1 1 1 1 0 0 1 1]: 243
==============================
[0 1 1 1 1 0 0 0]: 120
[1 1 0 1 0 1 0 1]: 213
[1 0 1 0 0 1 1 0 1]: 333
==============================
[0 1 1 1 1 0 1 1]: 123
[1 1 1 0 1 1 0 1]: 237
[1 0 1 1 0 1 0 0 0]: 360
==============================
[1 0 0 1 1 0 1 0]: 154
[0 1 1 0 1 0 0 1]: 105
[1 0 0 0 0 0 0 1 1]: 259
==============================
[0 0 0 1 1 0 0 1]: 25
[0 1 0 1 1 0 1 0]: 90
[0 0 1 1 1 0 0 1 1]: 115
==============================
[1 1 1 1 0 0 0 1]: 241
[0 0 0 1 1 1 1 1]: 31
[1 0 0 0 1 0 0 0 0]: 272
==============================
[0 1 0 0 0 1 1 0]: 70
[1 1 1 0 1 0 0 1]: 233
[1 0 0 1 0 1 1 1 1]: 303
==============================
[1 0 1 0 1 1 0 1]: 173
[0 1 1 1 0 1 0 0]: 116
[1 0 0 1 0 0 0 0 1]: 289
==============================
[0 1 0 0 1 0 0 0]: 72
[1 1 1 1 1 0 1 0]: 250
[1 0 1 0 0 0 0 1 0]: 322
==============================
[1 1 1 1 0 0 0 0]: 240
[0 1 0 0 0 0 1 0]: 66
[1 0 0 1 1 0 0 1 0]: 306
==============================
[0 1 0 0 0 1 1 1]: 71
[1 0 0 1 0 1 1 0]: 150
[0 1 1 0 1 1 1 0 1]: 221
==============================
[0 1 1 0 1 1 0 1]: 109
[0 0 1 0 0 1 0 1]: 37
[0 1 0 0 1 0 0 1 0]: 146
==============================
[1 1 0 0 0 0 0 0]: 192
[1 1 1 0 0 0 0 1]: 225
[1 1 0 1 0 0 0 0 1]: 417
==============================
[1 0 0 0 0 0 1 1]: 131
[1 1 0 1 1 1 1 0]: 222
[1 0 1 1 0 0 0 0 1]: 353
==============================
[0 0 0 0 0 1 0 0]: 4
[1 1 1 0 0 0 1 0]: 226
[0 1 1 1 0 0 1 1 0]: 230
==============================
[1 1 1 0 1 1 1 1]: 239
[1 1 0 1 1 0 1 1]: 219
[1 1 1 0 0 1 0 1 0]: 458
==============================
[0 0 1 1 0 1 0 1]: 53
[1 1 1 1 0 0 1 0]: 242
[1 0 0 1 0 0 1 1 1]: 295
==============================
[1 0 0 1 0 0 0 1]: 145
[0 1 0 0 0 1 0 0]: 68
[0 1 1 0 1 0 1 0 1]: 213
==============================
[0 0 1 1 0 0 0 0]: 48
[1 0 1 1 0 1 1 1]: 183
[0 1 1 1 0 0 1 1 1]: 231
==============================
[0 1 1 0 0 1 1 1]: 103
[0 0 0 1 1 1 1 0]: 30
[0 1 0 0 0 0 1 0 1]: 133
==============================
[0 1 0 1 1 1 0 1]: 93
[1 1 0 1 0 0 1 0]: 210
[1 0 0 1 0 1 1 1 1]: 303
==============================
[1 0 0 0 1 0 1 0]: 138
[0 1 1 1 1 0 0 1]: 121
[1 0 0 0 0 0 0 1 1]: 259
==============================
[0 0 0 0 0 0 1 1]: 3
[0 0 1 1 0 0 0 1]: 49
[0 0 0 1 1 0 1 0 0]: 52
==============================
[1 0 0 0 0 0 1 0]: 130
[0 0 0 1 0 0 0 0]: 16
[0 1 0 0 1 0 0 1 0]: 146
==============================
[0 0 0 1 0 0 0 0]: 16
[1 0 0 1 0 0 1 0]: 146
[0 1 0 1 0 0 0 1 0]: 162
==============================
[0 1 0 1 0 1 0 0]: 84
[0 0 0 0 1 1 0 0]: 12
[0 0 1 1 0 0 0 0 0]: 96
==============================
[1 0 1 0 1 0 1 1]: 171
[1 1 0 1 1 0 1 1]: 219
[1 1 0 0 0 0 1 1 0]: 390
==============================
[1 1 1 1 1 1 1 0]: 254
[0 1 1 0 1 0 1 0]: 106
[1 0 1 1 0 1 0 0 0]: 360
==============================
[1 0 0 0 0 0 1 0]: 130
[0 0 0 0 1 1 1 0]: 14
[0 1 0 0 1 0 0 0 0]: 144
==============================
[1 0 1 0 0 1 0 1]: 165
[0 0 1 1 1 0 1 1]: 59
[0 1 1 1 0 0 0 0 0]: 224
==============================
[0 0 1 1 1 0 1 0]: 58
[1 1 1 1 0 0 1 0]: 242
[1 0 0 1 0 1 1 0 0]: 300
==============================
[0 1 0 0 1 1 0 1]: 77
[0 0 0 1 1 1 1 1]: 31
[0 0 1 1 0 1 1 0 0]: 108
==============================
[1 0 0 1 1 0 1 0]: 154
[0 1 0 1 0 1 0 1]: 85
[0 1 1 1 0 1 1 1 1]: 239
==============================
[0 1 1 0 1 1 0 1]: 109
[0 1 1 0 1 0 0 1]: 105
[0 1 1 0 1 0 1 1 0]: 214
==============================
[0 1 1 1 1 1 1 1]: 127
[0 1 1 1 0 0 1 0]: 114
[0 1 1 1 1 0 0 0 1]: 241
==============================
[0 1 1 0 0 1 0 1]: 101
[0 1 0 1 0 0 0 0]: 80
[0 1 0 1 1 0 1 0 1]: 181
==============================
[0 1 1 0 1 1 1 0]: 110
[0 1 0 1 0 1 1 0]: 86
[0 1 1 0 0 0 1 0 0]: 196
==============================
[0 0 0 1 0 0 1 1]: 19
[1 0 0 1 0 0 0 0]: 144
[0 1 0 1 0 0 0 1 1]: 163
==============================
[1 1 1 1 0 1 0 0]: 244
[1 1 0 1 0 0 1 1]: 211
[1 1 1 0 0 0 1 1 1]: 455
==============================
[0 0 0 0 1 1 1 0]: 14
[1 0 1 1 0 0 1 0]: 178
[0 1 1 0 0 0 0 0 0]: 192
==============================
[0 1 1 0 0 0 0 0]: 96
[1 0 0 1 1 1 0 0]: 156
[0 1 1 1 1 1 1 0 0]: 252
==============================
[0 0 1 1 0 1 0 0]: 52
[0 1 1 1 1 1 0 1]: 125
[0 1 0 1 1 0 0 0 1]: 177
==============================
[0 0 0 0 1 1 0 0]: 12
[0 1 0 1 1 1 0 1]: 93
[0 0 1 1 0 1 0 0 1]: 105
==============================
[0 1 1 0 0 1 0 1]: 101
[1 1 0 1 0 1 0 0]: 212
[1 0 0 1 1 1 0 0 1]: 313
==============================
[1 1 0 0 0 0 0 1]: 193
[1 1 0 0 1 1 0 1]: 205
[1 1 0 0 0 1 1 1 0]: 398
==============================
[0 1 1 1 0 0 1 0]: 114
[0 0 0 0 0 0 0 0]: 0
[0 0 1 1 1 0 0 1 0]: 114
==============================
[1 0 0 0 1 1 1 0]: 142
[1 0 1 1 1 1 0 1]: 189
[1 0 1 0 0 1 0 1 1]: 331
==============================
[1 0 1 1 0 1 1 1]: 183
[0 1 0 1 0 1 1 0]: 86
[1 0 0 0 0 1 1 0 1]: 269
==============================
[1 0 1 0 0 0 1 1]: 163
[1 1 1 0 0 1 0 1]: 229
[1 1 0 0 0 1 0 0 0]: 392
==============================
[0 0 1 1 0 0 0 1]: 49
[1 1 1 0 0 1 1 1]: 231
[1 0 0 0 1 1 0 0 0]: 280
==============================
[1 0 0 0 1 1 1 1]: 143
[1 0 1 0 1 0 0 0]: 168
[1 0 0 1 1 0 1 1 1]: 311
==============================
[0 1 0 0 0 0 0 0]: 64
[0 0 0 0 0 1 0 1]: 5
[0 0 1 0 0 0 1 0 1]: 69
==============================
[1 1 1 1 1 0 1 1]: 251
[1 0 1 1 1 0 0 1]: 185
[1 1 0 1 1 0 1 0 0]: 436
==============================
[1 1 1 0 1 1 1 0]: 238
[1 1 0 0 0 0 1 0]: 194
[1 1 0 1 1 0 0 0 0]: 432
==============================
[0 0 1 1 1 1 0 0]: 60
[0 0 0 1 0 1 1 1]: 23
[0 0 1 0 1 0 0 1 1]: 83
==============================
[0 1 1 1 0 1 0 0]: 116
[1 1 1 1 1 1 0 0]: 252
[1 0 1 1 1 0 0 0 0]: 368
==============================
[1 1 0 1 0 1 1 0]: 214
[1 1 1 1 0 1 0 0]: 244
[1 1 1 0 0 1 0 1 0]: 458
==============================
[1 1 1 1 1 1 1 0]: 254
[1 1 0 1 0 0 0 1]: 209
[1 1 1 0 0 1 1 1 1]: 463
==============================
[0 0 0 0 0 0 1 0]: 2
[0 0 0 0 1 1 0 1]: 13
[0 0 0 0 0 1 1 1 1]: 15
==============================
[0 1 1 0 0 1 1 1]: 103
[1 0 1 1 1 1 1 0]: 190
[1 0 0 1 0 0 1 0 1]: 293
==============================
[1 1 1 1 0 1 1 0]: 246
[0 1 0 1 0 0 1 0]: 82
[1 0 1 0 0 1 0 0 0]: 328
==============================
[0 1 1 1 0 0 1 1]: 115
[0 0 1 1 1 0 1 1]: 59
[0 1 0 1 0 1 1 1 0]: 174
==============================
[0 1 0 1 1 0 0 1]: 89
[0 1 1 0 1 0 1 1]: 107
[0 1 1 0 0 0 1 0 0]: 196
==============================
[0 1 0 0 0 1 0 0]: 68
[0 0 1 1 1 0 0 0]: 56
[0 0 1 1 1 1 1 0 0]: 124
==============================
[1 1 0 0 1 0 0 0]: 200
[1 0 1 0 0 0 1 0]: 162
[1 0 1 1 0 1 0 1 0]: 362
==============================
[1 1 1 1 0 0 1 1]: 243
[0 1 1 0 0 0 1 1]: 99
[1 0 1 0 1 0 1 1 0]: 342
==============================
[0 0 1 0 1 0 0 1]: 41
[0 1 0 0 1 0 0 1]: 73
[0 0 1 1 1 0 0 1 0]: 114
==============================
[0 0 0 1 1 1 0 1]: 29
[1 0 1 0 1 1 1 0]: 174
[0 1 1 0 0 1 0 1 1]: 203
==============================
[0 0 0 0 1 1 1 1]: 15
[0 0 1 1 1 1 0 1]: 61
[0 0 1 0 0 1 1 0 0]: 76
==============================
[1 1 1 1 1 0 1 1]: 251
[1 1 0 1 0 0 0 0]: 208
[1 1 1 0 0 1 0 1 1]: 459
==============================
[1 1 1 0 1 0 0 0]: 232
[0 1 1 0 0 0 1 0]: 98
[1 0 1 0 0 1 0 1 0]: 330
==============================
[1 0 1 1 0 1 0 0]: 180
[0 1 0 1 0 1 1 1]: 87
[1 0 0 0 0 1 0 1 1]: 267
==============================
[1 0 0 0 0 1 1 0]: 134
[1 0 0 1 0 1 0 1]: 149
[1 0 0 0 1 1 0 1 1]: 283
==============================
[1 0 1 0 1 1 0 1]: 173
[0 1 1 1 1 1 0 0]: 124
[1 0 0 1 0 1 0 0 1]: 297
==============================
[0 1 0 0 1 0 0 0]: 72
[0 1 1 0 0 0 1 1]: 99
[0 1 0 1 0 1 0 1 1]: 171
==============================
[1 1 0 1 0 1 0 1]: 213
[0 0 0 1 1 1 1 0]: 30
[0 1 1 1 1 0 0 1 1]: 243&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  可以看到，这个简单的LSTM模型的预测的结果全部正确。因此，这就可以用来模拟0-255内的整数的加法运算，是不是很神奇呢？&lt;br/&gt;  如果需要想将加数的范围扩大，只需要改变代码中的BINARY_DIM变量即可。但是，加数的范围越大，样本就越大，如2**10=1024内的加法，就会有1024*1024=1048576个样本，这样大的样本量的无疑需要更多的训练时间。&lt;br/&gt;  本文到此结束，感谢阅读~如果不当之处，请速联系笔者，欢迎大家交流~祝您好运~&lt;/p&gt;
&lt;p&gt;注意：本人现已开通微信公众号： Python爬虫与算法（微信号为：easy_web_scrape）， 欢迎大家关注哦~~&lt;/p&gt;
&lt;p&gt;完整的Python代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import numpy as np
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.layers import LSTM
from keras import losses
from keras.utils import plot_model

# 最多8位二进制
BINARY_DIM = 8

# 将整数表示成为binary_dim位的二进制数，高位用0补齐
def int_2_binary(number, binary_dim):
    binary_list = list(map(lambda x: int(x), bin(number)[2:]))
    number_dim = len(binary_list)
    result_list = [0]*(binary_dim-number_dim)+binary_list
    return result_list

# 将一个二进制数组转为整数
def binary2int(binary_array):
    out = 0
    for index, x in enumerate(reversed(binary_array)):
        out += x * pow(2, index)
    return out

# 将[0,2**BINARY_DIM)所有数表示成二进制
binary = np.array([int_2_binary(x, BINARY_DIM) for x in range(2**BINARY_DIM)])
# print(binary)

# 样本的输入向量和输出向量
dataX = []
dataY = []
for i in range(binary.shape[0]):
    for j in range(binary.shape[0]):
        dataX.append(np.append(binary[i], binary[j]))
        dataY.append(int_2_binary(i+j, BINARY_DIM+1))

# print(dataX)
# print(dataY)

# 重新特征X和目标变量Y数组，适应LSTM模型的输入和输出
X = np.reshape(dataX, (len(dataX), 2*BINARY_DIM, 1))
# print(X.shape)
Y = np.array(dataY)
# print(dataY.shape)

# 定义LSTM模型
model = Sequential()
model.add(LSTM(256, input_shape=(X.shape[1], X.shape[2])))
model.add(Dropout(0.2))
model.add(Dense(Y.shape[1], activation='sigmoid'))
model.compile(loss=losses.mean_squared_error, optimizer='adam')
# print(model.summary())

# plot model
plot_model(model, to_file=r'./model.png', show_shapes=True)
# train model
epochs = 100
model.fit(X, Y, epochs=epochs, batch_size=128)
# save model
mp = r'./LSTM_Operation.h5'
model.save(mp)

# use LSTM model to predict
for _ in range(100):
    start = np.random.randint(0, len(dataX)-1)
    # print(dataX[start])
    number1 = dataX[start][0:BINARY_DIM]
    number2 = dataX[start][BINARY_DIM:]
    print('='*30)
    print('%s: %s'%(number1, binary2int(number1)))
    print('%s: %s'%(number2, binary2int(number2)))
    sample = np.reshape(X[start], (1, 2*BINARY_DIM, 1))
    predict = np.round(model.predict(sample), 0).astype(np.int32)[0]
    print('%s: %s'%(predict, binary2int(predict)))&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 28 Oct 2018 13:15:00 +0000</pubDate>
<dc:creator>jclian91</dc:creator>
<og:description>RNN入门（4）利用LSTM实现整数加法运算~</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jclian91/p/9867229.html</dc:identifier>
</item>
<item>
<title>用node探究http缓存 - 大~熊</title>
<link>http://www.cnblogs.com/floor/p/9867194.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/floor/p/9867194.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;用node搞web服务和直接用tomcat、Apache做服务器不太一样， 很多工作都需要自己做。缓存策略也要自己选择，虽然有像koa-static，express.static这些东西可以用来管理静态资源，但是为了开发或配置时更加得心应手，知其所以然，有了解http缓存的必要。另外，http缓存作为一个前端优化的一个要点，也应该有所了解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;什么是http缓存&quot;&gt;什么是http缓存&lt;/h2&gt;
&lt;ul readability=&quot;0.44362017804154&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;RFC 7234 (&lt;a href=&quot;https://tools.ietf.org/pdf/rfc7234.pdf&quot; class=&quot;uri&quot;&gt;https://tools.ietf.org/pdf/rfc7234.pdf&lt;/a&gt;)指出HTTP缓存是响应消息的本地存储，并且是控制其中消息的存储、检索和删除的子系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;通俗讲: http协议规定了一些指令, 实现http协议的服务器和浏览器根据这些指令决定要不要以及如何把响应存储起来以备后续使用.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;http缓存的意义&quot;&gt;http缓存的意义&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;提高响应速度&lt;/li&gt;
&lt;li&gt;减少带宽占用, 省流量&lt;/li&gt;
&lt;li&gt;减小服务器压力&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;不指定任何与缓存有关的指令&quot;&gt;不指定任何与缓存有关的指令&lt;/h2&gt;
&lt;p&gt;这种情况下浏览器不做缓存, 每次都会想服务器请求. 但是比较奇怪的是在nginx的实现中, 这种情况下还是被代理服务器做了缓存.也就是说, 当多次请求同一个资源时, 代理服务器只向源服务器请求一次.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演示第1个例子nothing_1&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;强制缓存&quot;&gt;强制缓存&lt;/h2&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;所谓强制缓存就是给出资源的到期时间&lt;code&gt;expires&lt;/code&gt;或者有效时间&lt;code&gt;max-age&lt;/code&gt;, 在这个时间之内该资源应该被缓存.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如何让一个资源被强缓存&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1.expires&lt;/p&gt;
&lt;p&gt;这个字段定义了一个资源到期的时间. 看一个实际的例子:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1128201/201810/1128201-20181028210733508-677033489.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这个&lt;code&gt;expires&lt;/code&gt;是个&lt;code&gt;GMT&lt;/code&gt;时间, 它的工作机制是, 首次请求时, 服务器在响应中加上&lt;code&gt;expires&lt;/code&gt;标识资源的到期时间, 浏览器缓存这个资源, 再次请求时, 浏览器将上一次请求到这个资源的过期时间与自己的系统时间对比, 若系统时间小于过期时间, 则证明资源没有过期, 直接用上次缓存的资源, 不必请求; 否则重新请求, 服务器在响应中给出新的过期时间.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演示第9个例子expires_9&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const d  = new Date(Date.now() + 5000);
res.writeHead(200, {
    'Content-Type': 'image/png',
    'expires': d.toGMTString()
});
res.end(img);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.Cache-Control:[public | private,] max-age=&lt;span class=&quot;math inline&quot;&gt;\({n}, s-maxage=\)&lt;/span&gt;{m}&lt;/p&gt;
&lt;p&gt;&lt;code&gt;expires&lt;/code&gt; 存在的问题是他依赖于客户端的系统时间, 客户端系统时间错误可能会引起判断错误. HTTP1.1增加了&lt;code&gt;Cache-Control&lt;/code&gt;解决此问题, 这个指令值比较丰富, 常见的如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;public/private: 标识资源能不能被代理服务器缓存, &lt;code&gt;public&lt;/code&gt; 标识资源既能被代理服务器缓存也能被浏览器缓存, &lt;code&gt;private&lt;/code&gt;标识资源只能被浏览器缓存, 不能被代理服务器缓存.&lt;/li&gt;
&lt;li&gt;max-age: 用于指定在客户端缓存的有效时间, 单位s, 超过n秒需要重新请求, 不超过则可以使用缓存&lt;/li&gt;
&lt;li&gt;s-maxage: 这个是针对代理服务器的, 表示资源在代理服务器缓存时间没有超过这个时间不必向源服务器请求, 否则需要.&lt;/li&gt;
&lt;li&gt;no-cache: 有这个指令表示不走浏览器缓存了, 协商缓存还可以走&lt;/li&gt;
&lt;li&gt;no-store: 强制无缓存, 协商缓存也不走了, 测试发下即使响应中有&lt;code&gt;Last-Modified&lt;/code&gt;, 浏览器请求时页不会带&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;一个实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1128201/201810/1128201-20181028210751997-1669644123.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演示第2,3,4,5,7&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;协商缓存&quot;&gt;协商缓存&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;所谓协商缓存就是客户端想用缓存资源时先向服务器询问, 如果服务器如果认为这个资源没有过期, 可以继续用则给出304响应, 客户端继续使用原来的资源; 否则给出200, 并在响应body加上资源, 客户端使新的资源.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1.Last-Modified与If-Modified-Since&lt;/p&gt;
&lt;p&gt;这个机制是, 服务器在响应头中加上&lt;code&gt;Last-Modified&lt;/code&gt;, 一般是一个资源的最后修改时间, 浏览器首次请求时获得这个时间, 下一次请求时将这个时间放在请求头的&lt;code&gt;If-Modified-Since&lt;/code&gt;, 服务器收到这个&lt;code&gt;If-Modified-Since&lt;/code&gt;时间&lt;code&gt;n&lt;/code&gt;后查询资源的最后修改时间&lt;code&gt;m&lt;/code&gt;与之对比, 若&lt;code&gt;m&amp;gt;n&lt;/code&gt;, 给出200响应, 更新&lt;code&gt;Last-Modified&lt;/code&gt;为新的值, body中为这个资源, 浏览器收到后使用新的资源; 否则给出304响应, body无数据, 浏览器使用上一次缓存的资源.&lt;/p&gt;
&lt;p&gt;2.Etag与If-None-Match&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Last-Modified&lt;/code&gt;模式存两个问题, 一是它是秒级别的比对, 所以当资源的变化小于一秒时浏览器可能使用错误的资源; 二是资源的最新修改时间变了可能内容并没有变, 但是还是会给出完整响应, 造成浪费. 基于此在HTTP1.1引入了Etag模式.&lt;/p&gt;
&lt;p&gt;这个与上面的&lt;code&gt;Last-Modified&lt;/code&gt;机制基本相同, 不过不再是比对最后修改时间而是比对资源的标识, 这个Etag一般是基于资源内容生成的标识. 由于Etag是基于内容生成的, 所以当且仅当内容变化才会给出完整响应, 无浪费和错误的问题.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演示第8, 10&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何选择缓存策略&quot;&gt;如何选择缓存策略&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn&quot; class=&quot;uri&quot;&gt;https://developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=zh-cn&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;附录&quot;&gt;附录&lt;/h2&gt;
&lt;p&gt;1.演示代码&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const http = require('http');
const fs = require('fs');
let etag = 0;
let tpl = fs.readFileSync('./index.html');
let img = fs.readFileSync('./test.png');
http.createServer((req, res) =&amp;gt; {
    etag++; // 我是个假的eTag
    console.log('---&amp;gt;', req.url);
    switch (req.url) {
        // 模板
        case '/index':
            res.writeHead(200, {
                'Content-Type': 'text/html',
                'Cache-Control': 'no-store'
            });
            res.end(tpl);
            break;
        // 1. 不给任何与缓存相关的头, 任何情况下, 既不会被浏览器缓存, 也不会被代理服务缓存
        case '/img/nothing_1':
            res.writeHead(200, {
                'Content-Type': 'image/png'
            });
            res.end(img);
            break;
            
        // 2. 设置了no-cache表明每次要使用缓存资源前需要向服务器确认
        case '/img/cache-control=no-cache_2':
            res.writeHead(200, {
                'Content-Type': 'image/png',
                'cache-control': 'no-cache'
            });
            res.end(img);
            break;

        // 3. 设置max-age表示在浏览器最多缓存的时间
        case '/img/cache-control=max-age_3':
            res.writeHead(200, {
                'Content-Type': 'image/png',
                'cache-control': 'max-age=10'
            });
            res.end(img);
            break;

        // 4. 设置了max-age s-maxage public: public 是说这个资源可以被服务器缓存, 也可以被浏览器缓存, 
        // max-age意思是浏览器的最长缓存时间为n秒, s-maxage表明代理服务器的最长缓存时间为那么多秒
        case '/img/cache-control=max-age_s-maxage_public_4':
            res.writeHead(200, {
                'Content-Type': 'image/png',
                'cache-control': 'public, max-age=10, s-maxage=40'
            });
            res.end(img);
            break;

        // 设置了max-age s-maxage private: private 是说这个资源只能被浏览器缓存, 不能被代理服务器缓存
        // max-age说明了在浏览器最长缓存时间, 这里的s-maxage实际是无效的, 因为不能被代理服务缓存
        case '/img/cache-control=max-age_s-maxage_private_5':
            res.writeHead(200, {
                'Content-Type': 'image/png',
                'cache-control': 'private, max-age=10, s-maxage=40'
            });
            res.end(img);
            break;
        
        // 7. 可以被代理服务器缓存, 确不能被浏览器缓存
        case '/img/cache-control=private_max-age_7':
            res.writeHead(200, {
                'Content-Type': 'image/png',
                'cache-control': 'public, s-maxage=40'
            });
            res.end(img);
            break;
        // 8. 协商缓存
        case '/img/talk_8':
            let stats = fs.statSync('./test.png');
            let mtimeMs = stats.mtimeMs;
            let If_Modified_Since = req.headers['if-modified-since'];
            let oldTime = 0;
            if(If_Modified_Since) {
                const If_Modified_Since_Date = new Date(If_Modified_Since);
                oldTime = If_Modified_Since_Date.getTime();
            }
            
            mtimeMs = Math.floor(mtimeMs / 1000) * 1000;    // 这种方式的精度是秒, 所以毫秒的部分忽略掉
            console.log('mtimeMs', mtimeMs);
            console.log('oldTime', oldTime);
            if(oldTime &amp;lt; mtimeMs) {
                res.writeHead(200, {
                    'Cache-Control': 'no-cache',   
                    // 测试发现, 必须要有max-age=0 或者no-cache,或者expires为当前, 才会协商, 否则没有协商的过程 
                    'Last-Modified': new Date(mtimeMs).toGMTString()
                });
                res.end(fs.readFileSync('./test.png'));
            }else {
                res.writeHead(304);
                res.end();
            }
           
        // 9. 设置了expires, 表示资源到期时间
        case '/img/expires_9':
            const d  = new Date(Date.now() + 5000);
            res.writeHead(200, {
                'Content-Type': 'image/png',
                'expires': d.toGMTString()
            });
            res.end(img);
            break;
        
        // 10. 设置了expires, 表示资源到期时间
        case '/img/etag_10':
            const If_None_Match = req.headers['if-none-match'];
            console.log('If_None_Match,',If_None_Match);
            if(If_None_Match != etag) {
                res.writeHead(200, {
                    'Content-Type': 'image/png',
                    'Etag': String(etag)
                });
                res.end(img);
            }else {
                res.statusCode = 304;
                res.end();
            }
            
            break;

        // 11. no-store 能协商缓存吗? 不能, 请求不会带if-modified-since
        case '/img/no-store_11':
            const stats2 = fs.statSync('./test.png');
            let mtimeMs2 = stats2.mtimeMs;
            let If_Modified_Since2 = req.headers['if-modified-since'];
            let oldTime2 = 0;
            if(If_Modified_Since2) {
                const If_Modified_Since_Date = new Date(If_Modified_Since2);
                oldTime2 = If_Modified_Since_Date.getTime();
            }
            
            mtimeMs2 = Math.floor(mtimeMs2 / 1000) * 1000;    // 这种方式的精度是秒, 所以毫秒的部分忽略掉
            console.log('mtimeMs', mtimeMs2);
            console.log('oldTime', oldTime2);
            if(oldTime2 &amp;lt; mtimeMs2) {
                res.writeHead(200, {
                    'Cache-Control': 'no-store',   
                    // 测试发现, 必须要有max-age=0 或者no-cache,或者expires为当前, 才会协商, 否则没有协商的过程 
                    'Last-Modified': new Date(mtimeMs2).toGMTString()
                });
                res.end(fs.readFileSync('./test.png'));
            }else {
                res.writeHead(304);
                res.end();
            }
        default:
            res.statusCode = 404;
            res.statusMessage = 'Not found',
            res.end();
    }

}).listen(1234);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.测试用代理服务器nginx配置&lt;/p&gt;
&lt;p&gt;不要问我这是个啥, 我是copy的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;worker_processes  8;
  
events {
    worker_connections  65535;
}
  
http {
    include       mime.types;
    default_type  application/octet-stream;
    charset utf-8;
 
    log_format  main  '$http_x_forwarded_for $remote_addr $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_cookie&quot; $host $request_time';
    sendfile       on;
    tcp_nopush     on;
    tcp_nodelay    on;
    keepalive_timeout  65;
    proxy_connect_timeout 500;
    #跟后端服务器连接的超时时间_发起握手等候响应超时时间
    proxy_read_timeout 600;
    #连接成功后_等候后端服务器响应的时间_其实已经进入后端的排队之中等候处理
    proxy_send_timeout 500;
    #后端服务器数据回传时间_就是在规定时间内后端服务器必须传完所有数据
    proxy_buffer_size 128k;
    #代理请求缓存区_这个缓存区间会保存用户的头信息以供Nginx进行规则处理_一般只要能保存下头信息即可  
    proxy_buffers 4 128k;
    #同上 告诉Nginx保存单个用的几个Buffer最大用多大空间
    proxy_busy_buffers_size 256k;
    #如果系统很忙的时候可以申请更大的proxy_buffers 官方推荐*2
    proxy_temp_file_write_size 128k;
    #设置web缓存区名为cache_one,内存缓存空间大小为12000M，自动清除超过15天没有被访问过的缓存数据，硬盘缓存空间大小200g
    #要想开启nginx的缓存功能，需要添加此处的两行内容！
    #设置Web缓存区名称为cache_one,内存缓存空间大小为500M,缓存的数据超过1天没有被访问就自动清除;访问的缓存数据,硬盘缓存空间大小为30G
    proxy_cache_path /usr/local/nginx/proxy_cache_path levels=1:2 keys_zone=cache_one:500m inactive=1d max_size=30g;
 
    #创建缓存的时候可能生成一些临时文件存放的位置
    proxy_temp_path /usr/local/nginx/proxy_temp_path;
 
    fastcgi_connect_timeout 3000;
    fastcgi_send_timeout 3000;
    fastcgi_read_timeout 3000;
    fastcgi_buffer_size 256k;
    fastcgi_buffers 8 256k;
    fastcgi_busy_buffers_size 256k;
    fastcgi_temp_file_write_size 256k;
    fastcgi_intercept_errors on;
  
     
    client_header_timeout 600s;
    client_body_timeout 600s;
  
    client_max_body_size 100m;             
    client_body_buffer_size 256k;           
  
    gzip  off;
    gzip_min_length  1k;
    gzip_buffers     4 16k;
    gzip_http_version 1.1;
    gzip_comp_level 9;
    gzip_types       text/plain application/x-javascript text/css application/xml text/javascript;
    gzip_vary on;
  
 
    include vhosts/*.conf;
    server {
        listen       80;
        server_name  localhost;
        location / {
            proxy_pass  http://127.0.0.1:1234;
            proxy_set_header   Host             $http_host;
            proxy_set_header   X-Real-IP        $remote_addr;
            proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;
            proxy_redirect off;
            proxy_cache cache_one;
            #此处的cache_one必须于上一步配置的缓存区域名称相同
            proxy_cache_valid 200 304 12h;
            proxy_cache_valid 301 302 1d;
            proxy_cache_valid any 1h;
            #不同的请求设置不同的缓存时效
            proxy_cache_key $uri$is_args$args;
            #生产缓存文件的key，通过4个string变量结合生成
            expires off;
            #加了这个的话会自己修改cache-control, 写成off则不会
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/book/5b936540f265da0a9624b04b/section/5b9ba651f265da0ac726e5de&quot; class=&quot;uri&quot;&gt;https://juejin.im/book/5b936540f265da0a9624b04b/section/5b9ba651f265da0ac726e5de&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是一个付费的册子，可能没法访问&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 13:10:00 +0000</pubDate>
<dc:creator>大~熊</dc:creator>
<og:description>用node搞web服务和直接用tomcat、Apache做服务器不太一样， 很多工作都需要自己做。缓存策略也要自己选择，虽然有像koa-static，express.static这些东西可以用来管理静</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/floor/p/9867194.html</dc:identifier>
</item>
<item>
<title>如何在运行时(Runtime)获得泛型的真正类型 - 小黑客</title>
<link>http://www.cnblogs.com/xiaoheike/p/9867060.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoheike/p/9867060.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;由于Java 的类型擦除机制，在编译时泛型都被转为了Object，例如&lt;code&gt;List&amp;lt;String&amp;gt;&lt;/code&gt;经过编译之后将变为类型 List。可以通过以下的方式再运行时获得泛型的真正类型&lt;/p&gt;
&lt;h2 id=&quot;泛型如何获得具体类型&quot;&gt;泛型如何获得具体类型&lt;/h2&gt;
&lt;h2 id=&quot;list-例子如下&quot;&gt;List 例子如下&lt;/h2&gt;
&lt;p&gt;来自：&lt;a href=&quot;https://stackoverflow.com/questions/1942644/get-generic-type-of-java-util-list&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/1942644/get-generic-type-of-java-util-list&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package test;

import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.util.ArrayList;
import java.util.List;

public class Test {

    List&amp;lt;String&amp;gt; stringList = new ArrayList&amp;lt;String&amp;gt;();
    List&amp;lt;Integer&amp;gt; integerList = new ArrayList&amp;lt;Integer&amp;gt;();

    public static void main(String... args) throws Exception {
        Field stringListField = Test.class.getDeclaredField(&quot;stringList&quot;);
        ParameterizedType stringListType = (ParameterizedType) stringListField.getGenericType();
        Class&amp;lt;?&amp;gt; stringListClass = (Class&amp;lt;?&amp;gt;) stringListType.getActualTypeArguments()[0];
        System.out.println(stringListClass); // class java.lang.String.

        Field integerListField = Test.class.getDeclaredField(&quot;integerList&quot;);
        ParameterizedType integerListType = (ParameterizedType) integerListField.getGenericType();
        Class&amp;lt;?&amp;gt; integerListClass = (Class&amp;lt;?&amp;gt;) integerListType.getActualTypeArguments()[0];
        System.out.println(integerListClass); // class java.lang.Integer.
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;map-的例子如下&quot;&gt;Map 的例子如下&lt;/h2&gt;
&lt;p&gt;来自：&lt;a href=&quot;https://stackoverflow.com/questions/3687766/how-to-get-value-type-of-a-map-in-java&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/3687766/how-to-get-value-type-of-a-map-in-java&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.lang.reflect.*;
import java.util.*;

public class Generic {
    private Map&amp;lt;String, Number&amp;gt; map = new HashMap&amp;lt;String, Number&amp;gt;();

    public static void main(String[] args) {
        try {
            ParameterizedType pt = (ParameterizedType)Generic.class.getDeclaredField(&quot;map&quot;).getGenericType();
            for(Type type : pt.getActualTypeArguments()) {
                System.out.println(type.toString());
            }
        } catch(NoSuchFieldException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际二者都利用的反射，都是基于 &lt;code&gt;java.lang.reflect.ParameterizedType&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;jackson-中如何反序列化泛型&quot;&gt;jackson 中如何反序列化泛型&lt;/h2&gt;
&lt;p&gt;jackson 中将JSON 转为Map 的可以通过如下代码实现，方式一：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ObjectMapper mapper = new ObjectMapper();
String json = &quot;{\&quot;name\&quot;:\&quot;mkyong\&quot;, \&quot;age\&quot;:29}&quot;;

Map map = mapper.readValue(json, Map.class);
Object name = map.get(&quot;name&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述只是指定了是 Map 类型，但是没有指定Map里边存放的数据是什么类型，所以得到结果之后还需要对 &lt;code&gt;Object name&lt;/code&gt; 做一次强制类型转换才能够使用。&lt;/p&gt;
&lt;p&gt;可以使用方式二，告知实际 &lt;code&gt;Map&lt;/code&gt; 中存放的对象，从而得到正确的类型，代码如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ObjectMapper mapper = new ObjectMapper();
String json = &quot;{\&quot;name\&quot;:\&quot;mkyong\&quot;, \&quot;age\&quot;:29}&quot;;

Map&amp;lt;String, Object&amp;gt; map = mapper.readValue(json, new TypeReference&amp;lt;Map&amp;lt;String, String&amp;gt;&amp;gt;(){});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;TypeReference&lt;/code&gt;实际上就是告诉了 &lt;code&gt;ObjectMapper&lt;/code&gt; 反序列化时要转换的真正类型是什么。&lt;/p&gt;
&lt;h3 id=&quot;typereference-源码&quot;&gt;TypeReference 源码&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.fasterxml.jackson.core.type;

import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

public abstract class TypeReference&amp;lt;T&amp;gt; implements Comparable&amp;lt;TypeReference&amp;lt;T&amp;gt;&amp;gt; {
    protected final Type _type;

    protected TypeReference() {
        Type superClass = this.getClass().getGenericSuperclass();
        if (superClass instanceof Class) {
            throw new IllegalArgumentException(&quot;Internal error: TypeReference constructed without actual type information&quot;);
        } else {
            this._type = ((ParameterizedType)superClass).getActualTypeArguments()[0];
        }
    }

    public Type getType() {
        return this._type;
    }

    public int compareTo(TypeReference&amp;lt;T&amp;gt; o) {
        return 0;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有一个 &lt;code&gt;protected&lt;/code&gt; 的构造器，所以在使用的时候默认就会执行该构造器，上述方案二将会走到分支代码 &lt;code&gt;this._type = ((ParameterizedType)superClass).getActualTypeArguments()[0];&lt;/code&gt;，从而 &lt;code&gt;getType&lt;/code&gt; 能够得到正确的类型。实际上也是根据 &lt;code&gt;ParameterizedType&lt;/code&gt; 获得真正的类型。&lt;/p&gt;
&lt;h3 id=&quot;通过-typereference-获得真正类型&quot;&gt;通过 TypeReference 获得真正类型&lt;/h3&gt;
&lt;p&gt;代码类似如下，最后得到的 &lt;code&gt;tmpType1&lt;/code&gt; 是 &lt;code&gt;Class&lt;/code&gt; 类型，就能够基于它其他的操作了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;TypeReference&amp;lt;Map&amp;lt;String, Test&amp;gt;&amp;gt; typeReference = new TypeReference&amp;lt;Map&amp;lt;String, Test&amp;gt;&amp;gt;(){};
ParameterizedType type = (ParameterizedType)typeReference.getType();
for (Type tmpType : type.getActualTypeArguments()) {
    Class&amp;lt;?&amp;gt; tmpType1 = (Class&amp;lt;?&amp;gt;) tmpType;
    System.out.println(tmpType1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;欢迎转载，但请注明本文链接，谢谢你。&lt;br/&gt;2018.10.28 20:47&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 12:48:00 +0000</pubDate>
<dc:creator>小黑客</dc:creator>
<og:description>前言 由于Java 的类型擦除机制，在编译时泛型都被转为了Object，例如 经过编译之后将变为类型 List。可以通过以下的方式再运行时获得泛型的真正类型 泛型如何获得具体类型 List 例子如下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoheike/p/9867060.html</dc:identifier>
</item>
<item>
<title>springboot缓存开发 - Yrion</title>
<link>http://www.cnblogs.com/wyq178/p/9840985.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq178/p/9840985.html</guid>
<description>&lt;p&gt;前言：缓存在开发中是一个必不可少的优化点，近期在公司的项目重构中，关于缓存优化了很多点，比如在加载一些数据比较多的场景中,会大量使用缓存机制提高接口响应速度,简介提升用户体验。关于缓存,很多人对它都是既爱又恨，爱它的是:它能大幅提升响应效率，恨的是它如果处理不好,没有用好比如LRU这种策略，没有及时更新数据库的数据就会导致数据产生滞后，进而产生用户的误读，或者疑惑。这是很严重的一个问题，比如我在公司和某家公司(国内的一线旅游开发公司)的对接的时候，线上总是出现我们推送接口数据但是网站的数据产生滞后的现象，询问对方的技术人员，告诉我们是缓存的问题，只要删除缓存就没事了，我只能无奈...所以如何处理好缓存,对我们开发人员来说是一个很棘手的问题。不过关于这一切，springboot已经提供给我们很便捷的开发工具！本篇博客就来探索springBoot的缓存注解如何使用！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇博客的目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一：springBoot开启缓存注解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二：常用缓存注解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三：使用实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四：总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;一：springBoot开启注解&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.1:搭建springBoot环境&lt;/p&gt;
&lt;p&gt;   在idea中，搭建一个springboot是很简单easy的。接下来我简单说一下步骤：&lt;/p&gt;
&lt;p&gt;File-&amp;gt;new-&amp;gt;projiect-&amp;gt;Spring Initializer-&amp;gt;next-&amp;gt;named-&amp;gt;web(选中)-&amp;gt;Finish-&amp;gt;new Window&lt;/p&gt;
&lt;p&gt;1.2:开始缓存&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
@EnableAutoConfiguration
@EnableCaching
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SpringbootcacheApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(SpringbootcacheApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;主要是@EnableCaching用于开启缓存注解的驱动，否则后面使用的缓存都是无效的！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二：常用缓存注解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2.1：@CacheConfig&lt;/p&gt;
&lt;p&gt; 这个注解的的主要作用就是全局配置缓存，比如配置缓存的名字（cacheNames),只需要在类上配置一次，下面的方法就默认以全局配置为主，不需要二次配置，节省了部分代码。&lt;/p&gt;
&lt;p&gt;2.2：@Cacheable&lt;/p&gt;
&lt;p&gt;这个注解是最重要的,主要实现的功能再进行一个读操作的时候。就是先从缓存中查询，如果查找不到，就会走数据库的执行方法，这是缓存的注解最重要的一个方法，基本上我们的所有缓存实现都要依赖于它。它具有的属性为cacheNames:缓存名字，condtion：缓存的条件，unless:不缓存的条件。可以指定SPEL表达式来实现,也可以指定缓存的key，缓存的内部实现一般都是key,value形式，类似于一个Map（实际上cacheable的缓存的底层实现就是concurrenHashMap）,指定了key，那么缓存就会以key作为键，以方法的返回结果作为值进行映射。&lt;/p&gt;
&lt;p&gt;2.3：@CacheEvict&lt;/p&gt;
&lt;p&gt;这个注解主要是配合@Cacheable一起使用的，它的主要作用就是清除缓存，当方法进行一些更新、删除操作的时候，这个时候就要删除缓存。如果不删除缓存，就会出现读取不到最新缓存的情况，拿到的数据都是过期的。它可以指定缓存的key和conditon，它有一个重要的属性叫做allEntries默认是false,也可以指定为true,主要作用就是清除所有的缓存，而不以指定的key为主。&lt;/p&gt;
&lt;p&gt;2.3:@CachePut&lt;/p&gt;
&lt;p&gt;这个注解它总是会把数据缓存，而不会去每次做检查它是否存在，相比之下它的使用场景就比较少，毕竟我们希望并不是每次都把所有的数据都给查出来，我们还是希望能找到缓存的数据，直接返回，这样能提升我们的软件效率。&lt;/p&gt;
&lt;p&gt;2.4:@cache&lt;/p&gt;
&lt;p&gt;这个注解它是上面的注解的综合体，包含上面的三个注解（cacheable、cachePut、CacheEvict），可以使用这一个注解来包含上面的所有的注解，看源码如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201810/1066538-20181028190613219-1049940709.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的注解总结如下表格：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201810/1066538-20181028191424400-749356175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三：使用实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.1:建立数据库&lt;/p&gt;
&lt;p&gt; 我们来新建一个表，含义为文章，下面的示例将会在这张表中进行操作，所使用的框架为SSM+springboot&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; Artile (
`id`  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT ,
`title`  &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; gbk COLLATE gbk_chinese_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; ,
`author`  &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; gbk COLLATE gbk_chinese_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; ,
`content`  mediumtext &lt;/span&gt;&lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; gbk COLLATE gbk_chinese_ci &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; ,
`&lt;/span&gt;&lt;span&gt;file_name&lt;/span&gt;`  &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;) &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt; gbk COLLATE gbk_chinese_ci &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; ,
`state`  &lt;/span&gt;&lt;span&gt;smallint&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; COMMENT &lt;span&gt;'&lt;/span&gt;&lt;span&gt;状态&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ,
&lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`)
)
ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;InnoDB
&lt;/span&gt;&lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CHARACTER&lt;/span&gt; &lt;span&gt;SET&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;gbk COLLATE&lt;span&gt;=&lt;/span&gt;&lt;span&gt;gbk_chinese_ci
AUTO_INCREMENT&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;
ROW_FORMAT&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;COMPACT
;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.2:Mapper层&lt;/p&gt;
&lt;p&gt;主要就是对Article进行增删改查的业务操作，映射到具体的xml的sql里，然后用service去调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ArticleMapper {


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 插入一篇文章
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; title
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; author
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; content
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; fileName
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Integer addArticle(@Param(&quot;title&quot;) String  title,@Param(&quot;author&quot;&lt;span&gt;)String author,
                              @Param(&lt;/span&gt;&quot;content&quot;)String content,@Param(&quot;fileName&quot;&lt;span&gt;)String fileName);
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根据id获取文章
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Article getArticleById(@Param(&quot;id&quot;&lt;span&gt;) Integer id);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 更新content
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; content
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Integer updateContentById(@Param(&quot;content&quot;)String content,@Param(&quot;id&quot;&lt;span&gt;)Integer id);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根据id删除文章
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; Integer removeArticleById(@Param(&quot;id&quot;&lt;span&gt;)Integer id);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得上一次插入的id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getLastInertId();

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.3：service层&lt;/p&gt;
&lt;p&gt;主要需要注意的是我们上述讲述的缓存注解都是基于service层(不能放在contoller和dao层)，首先我们在类上配置一个CacheConfig,然后配置一个cacheNames,那么下面的方法都是以这个缓存名字作为默认值，他们的缓存名字都是这个，不必进行额外的配置。当进行select查询方法的时候，我们配置上@Cacheable，并指定key,这样除了第一次之外，我们都会把结果缓存起来，以后的结果都会把这个缓存直接返回。而当进行更新数据（删除或者更新操作）的时候，使用@CacheEvict来清除缓存，防止调用@Cacheabel的时候没有更新缓存&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service
@CacheConfig(cacheNames &lt;/span&gt;= &quot;articleCache&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ArticleService {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; AtomicInteger count =&lt;span&gt;new&lt;/span&gt; AtomicInteger(0&lt;span&gt;);

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ArticleMapper articleMapper;


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 增加一篇文章 每次就进行缓存
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @CachePut
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer addArticle(Article article){
        Integer result &lt;/span&gt;=&lt;span&gt; articleMapper.addArticle(article.getTitle(), article.getAuthor(), article.getContent(), article.getFileName());
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result&amp;gt;0&lt;span&gt;) {
            Integer lastInertId &lt;/span&gt;=&lt;span&gt; articleMapper.getLastInertId();
            System.out.println(&lt;/span&gt;&quot;--执行增加操作--id:&quot; +&lt;span&gt; lastInertId);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取文章  以传入的id为键，当state为0的时候不进行缓存
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id 文章id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Cacheable(key &lt;/span&gt;= &quot;#id&quot;,unless = &quot;#result.state==0&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Article getArticle(Integer id) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟耗时操作&lt;/span&gt;
            Thread.sleep(5000&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
            e.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Article artcile =&lt;span&gt; articleMapper.getArticleById(id);
        System.out.println(&lt;/span&gt;&quot;--执行数据库查询操作&quot;+count.incrementAndGet()+&quot;次&quot;+&quot;id:&quot;+&lt;span&gt;id);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; artcile;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过id更新内容 清除以id作为键的缓存
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @CacheEvict(key &lt;/span&gt;= &quot;#id&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer updateContentById(String contetnt, Integer id) {
        Integer result &lt;/span&gt;=&lt;span&gt; articleMapper.updateContentById(contetnt, id);
        System.out.println(&lt;/span&gt;&quot;--执行更新操作id:--&quot;+&lt;span&gt;id);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过id移除文章
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id  清除以id作为键的缓存
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @CacheEvict(key &lt;/span&gt;= &quot;#id&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer removeArticleById(Integer id){
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Integer result =&lt;span&gt; articleMapper.removeArticleById(id);
        System.out.println(&lt;/span&gt;&quot;执行删除操作,id:&quot;+&lt;span&gt;id);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.4:controller层&lt;/p&gt;
&lt;p&gt;主要是接受客户端的请求，我们配置了@RestController表示它是一个rest风格的应用程序，在收到add请求会增加一条数据，get请求会查询一条数据，resh会更新一条数据,rem会删除一条数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RestController
@ComponentScan(basePackages &lt;/span&gt;= {&quot;com.wyq.controller&quot;, &quot;com.wyq.service&quot;&lt;span&gt;})
@MapperScan(basePackages &lt;/span&gt;= {&quot;com.wyq.dao&quot;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ArticleController {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ArticleService articleService;

    @Autowired
    ArticleMapper articleMapper;

    @PostMapping(&lt;/span&gt;&quot;/add&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ResultVo addArticle(@RequestBody Article article) {

        System.out.println(article.toString());
        Integer result &lt;/span&gt;=&lt;span&gt; articleService.addArticle(article);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result &amp;gt;= 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultVo.success(result);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultVo.fail();
    }


    @GetMapping(&lt;/span&gt;&quot;/get&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ResultVo getArticle(@RequestParam(&quot;id&quot;&lt;span&gt;) Integer id) {

        Long start &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();
        Article article &lt;/span&gt;=&lt;span&gt; articleService.getArticle(id);
        Long end &lt;/span&gt;=&lt;span&gt; System.currentTimeMillis();
        System.out.println(&lt;/span&gt;&quot;耗时：&quot;+(end-&lt;span&gt;start));

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; article)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultVo.success(article);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultVo.fail();
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 更新一篇文章
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; contetnt
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @GetMapping(&lt;/span&gt;&quot;/resh&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ResultVo update(@RequestParam(&quot;content&quot;) String contetnt, @RequestParam(&quot;id&quot;&lt;span&gt;) Integer id) {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Integer result =&lt;span&gt; articleService.updateContentById(contetnt, id);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultVo.success(result);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultVo.fail();
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 删除一篇文章
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; id
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @GetMapping(&lt;/span&gt;&quot;/rem&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ResultVo remove(@RequestParam(&quot;id&quot;&lt;span&gt;) Integer id) {

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; Integer result =&lt;span&gt; articleService.removeArticleById(id);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultVo.success(result);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResultVo.fail();
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 3.5：测试&lt;/p&gt;
&lt;p&gt;这里使用postman模拟接口请求&lt;/p&gt;
&lt;p&gt;3.5.1：首先我们来增加一篇文章：请求add接口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201810/1066538-20181028200639448-218117459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后台返回表示成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201810/1066538-20181028200811193-945756043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我看到后台数据库已经插入了数据，它的id是11&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201810/1066538-20181028200927478-542989313.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.5.2：执行查询操作&lt;/p&gt;
&lt;p&gt;在查询操作中，getArticle,我使用线程睡眠的方式，模拟了5秒的时间来处理耗时性业务，第一次请求肯定会查询数据库，理论上第二次请求，将会走缓存，我们来测试一下:首先执行查询操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201810/1066538-20181028201310188-699389994.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接口响应成功，再看一下后台打印：表示执行了一次查询操作，耗时5078秒&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201810/1066538-20181028201417682-42372789.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好，重点来了，我们再次请求接口看看会返回什么？理论上，将不会走数据库执行操作，并且耗时会大大减少：与上面的比对，这次没有打印执行数据库查询操作，证明没有走数据库，并且耗时只有5ms，成功了！缓存发挥作用，从5078秒减小到5秒！大大提升了响应速度，哈哈！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201810/1066538-20181028201523977-1151247926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.5.3：更新操作&lt;/p&gt;
&lt;p&gt;当我们进行修改操作的时候，我们希望缓存的数据被清空：看接口返回值成功了，再看数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201810/1066538-20181028201916726-541170498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201810/1066538-20181028201953074-1306302625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后台控制台打印：&lt;/p&gt;
&lt;p&gt;--执行更新操作id:--11&lt;/p&gt;
&lt;p&gt; 趁热打铁，我们再次请求三次查询接口，看看会返回什么？每次都会返回这样的结果，但是我的直观感受就是第一次最慢，第二次、第三次返回都很快&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201810/1066538-20181028202159326-240462117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看看后台打印了什么？执行id为11的数据库查询操作，这是因为缓存被清空了，所以它又走数据库了（获得最新数据），然后后面的查询都会走缓存！很明显，实验成功！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066538/201810/1066538-20181028202315215-127358546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.5.4：删除操作&lt;/p&gt;
&lt;p&gt;同理，在删除操作中，执行了一次删除，那么缓存也会被清空，查询的时候会再次走数据库，这里就不给具体实验效果了，如果需要的同学，可以把代码下载下来，自己测试一下就知道了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 四：总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   本篇博客介绍了springBoot中缓存的一些使用方法，如何在开发中使用缓存？怎样合理的使用都是值得我们学习的地方，缓存能大大提升程序的响应速度，提升用户体验，不过它适用的场景也是读多写少的业务场景，如果数据频繁修改，缓存将会失去意义，每次还是执行的数据库操作！如何使用好它，还有更高效的方式，比如使用redis\memoryCache等专业组件，本篇博客只是探讨的spring的注解缓存，相对来说比较简单。希望起到抛砖引玉的作用，在以后博客中，我将介绍redis如何搭建集群来实现缓存！&lt;/p&gt;
&lt;p&gt;本篇博客的代码示例下载地址(适用于intel idea)：链接：https://pan.baidu.com/s/1CkRCFTlzfbKyg1R15Er6tw 密码：nda4（如果文件失效请及时联系我，补链）&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 12:40:00 +0000</pubDate>
<dc:creator>Yrion</dc:creator>
<og:description>前言：缓存在开发中是一个必不可少的优化点，近期在公司的项目重构中，关于缓存优化了很多点，比如在加载一些数据比较多的场景中,会大量使用缓存机制提高接口响应速度,简介提升用户体验。关于缓存,很多人对它都是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq178/p/9840985.html</dc:identifier>
</item>
<item>
<title>.NET in Browser - Blazor - kingreatwill</title>
<link>http://www.cnblogs.com/kingreatwill/p/9865945.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kingreatwill/p/9865945.html</guid>
<description>&lt;p&gt;Blazor 是一个实验性的. NET web 框架, 使用 C# 和 HTML 在任何浏览器中不需要插件即可运行 WebAssembly 程序集。&lt;/p&gt;

&lt;p&gt;WebAssembly是一种新的适合于编译到Web的，可移植的，大小和加载时间高效的格式，是一种新的字节码格式。它的缩写是”.wasm”，.wasm 为文件名后缀，是一种新的底层安全的“二进制”语法。它被定义为“精简、加载时间短的格式和执行模型”，并且被设计为Web 多编程语言目标文件格式。&lt;br/&gt;这意味着浏览器端的性能会得到极大提升，它也使得我们能够实现一个底层构建模块的集合.&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/liuyan19891230/article/details/79144332&quot;&gt;介绍1&lt;/a&gt; &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/WebAssembly/Concepts&quot;&gt;介绍2&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;稳定，成熟，高效 ： .net standard, msbuild&lt;/li&gt;
&lt;li&gt;快速，可扩展性，可靠 ： .net core用于后端服务&lt;/li&gt;
&lt;li&gt;现代语言 ： C#&lt;/li&gt;
&lt;li&gt;一流的开发工具: Visual studio&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;客户端web开发一直是JavaScript的唯一领域。WebAssembly准备通过向语言、框架和工具的完整生态系统开放web来改变这一点。Blazor是一个通过WebAssembly网络平台将.net引入网络的实验性项目。使用.net进行全栈Web开发，并且不需要插件或代码转换，可适用于所有现代浏览器，包括移动浏览器。可以理解为，这是一个C#语言的Vue, Angular, React。&lt;/p&gt;
&lt;p&gt;Browser + Razor = Blazor&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;组件化开发&lt;/li&gt;
&lt;li&gt;支持路由&lt;/li&gt;
&lt;li&gt;布局&lt;/li&gt;
&lt;li&gt;依赖注入&lt;/li&gt;
&lt;li&gt;javascript互操作&lt;/li&gt;
&lt;li&gt;自动构建&lt;/li&gt;
&lt;li&gt;调试&lt;/li&gt;
&lt;li&gt;发布&lt;/li&gt;
&lt;li&gt;应用程序大小优化&lt;/li&gt;
&lt;li&gt;在不支持WebAssembly的浏览器中回溯到asm.js&lt;/li&gt;
&lt;li&gt;丰富的智能感知和工具&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1 客户端模式&lt;br/&gt;将cs和cshtml编译打包成静态文件，可直接部署到web服务器，发布文件如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/676668/201810/676668-20181028193537029-2022413308.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2 服务端工作模式&lt;br/&gt;服务端工作模式是要依赖dotnet，dotnet作为后端服务，通过SignalR与浏览器通讯&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/676668/201810/676668-20181028200739056-29308173.png&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;优化运行时性能&lt;/li&gt;
&lt;li&gt;AOT编译到WebAssembly&lt;/li&gt;
&lt;li&gt;优化下载大小&lt;/li&gt;
&lt;li&gt;改进对.net standard的支持&lt;/li&gt;
&lt;li&gt;实时重装（SignalR断开后需要刷新页面）&lt;/li&gt;
&lt;li&gt;延迟加载应用程序区域&lt;/li&gt;
&lt;li&gt;服务端渲染&lt;/li&gt;
&lt;li&gt;安全&lt;/li&gt;
&lt;li&gt;表单和验证&lt;/li&gt;
&lt;li&gt;测试框架&lt;/li&gt;
&lt;li&gt;跨平台工具（Blazor+Electron）&lt;/li&gt;
&lt;li&gt;服务器端状态和连接管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Blazor 目前版本是0.6，目前更新比较频繁，但是已经可以用来开发后端应用了。这里有一套Blazor框架，可以实现Blazor服务端工作方式和客户端工作方式的切换，不需要修改任何代码, 前端用Razor实现SEO，后端用Blazor，当Blazor是以Server-Side工作时，直接后端依赖注入，当Blazor以Client-Side工作时，Host将Service 转换成 Controller 提供API， 前端通过HttpClient调用（防止业务dll泄漏，这个也是Blazor将要解决的安全问题）&lt;/p&gt;
</description>
<pubDate>Sun, 28 Oct 2018 12:09:00 +0000</pubDate>
<dc:creator>kingreatwill</dc:creator>
<og:description>什么是Blazor Blazor 是一个实验性的. NET web 框架, 使用 C 和 HTML 在任何浏览器中不需要插件即可运行 WebAssembly 程序集。 什么是WebAssembly W</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kingreatwill/p/9865945.html</dc:identifier>
</item>
</channel>
</rss>