<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【WPF】【UWP】借鉴 asp.net core 管道处理模型打造图片缓存控件 ImageEx - h82258652</title>
<link>http://www.cnblogs.com/h82258652/p/8820725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/h82258652/p/8820725.html</guid>
<description>&lt;p&gt;在 Web 开发中，img 标签用来呈现图片，而且一般来说，浏览器是会对这些图片进行缓存的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180413153633296-145957026.png&quot;&gt;&lt;img title=&quot;QQ截图20180412110412&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180413153633713-251725314.png&quot; alt=&quot;QQ截图20180412110412&quot; width=&quot;1577&quot; height=&quot;786&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比如访问百度，我们可以发现，图片、脚本这种都是从缓存（内存缓存/磁盘缓存）中加载的，而不是再去访问一次百度的服务器，这样一方面改善了响应速度，另一方面也减轻了服务端的压力。&lt;/p&gt;

&lt;p&gt;但是，对于 WPF 和 UWP 开发来说，原生的 Image 控件是只有内存缓存的，并没有磁盘缓存的，所以一旦程序退出了，下次再重新启动程序的话，那还是得从服务器上面取图片的。因此，打造一个具备缓存（尤其是磁盘缓存）的 Image 控件还是有必要的。&lt;/p&gt;
&lt;p&gt;在 WPF 和 UWP 中，我们都知道 Image 控件 Source 属性的类型是 ImageSource，但是，如果我们使用数据绑定的话，是可以绑定一个字符串的，在运行的时候，我们会发现 Source 属性变成了一个 BitmapImage 类型的对象。那么可以推论出，是框架给我们做了一些转换。经过查阅 WPF 的相关资料，发现是 ImageSource 这个类型上有一个 TypeConverterAttribute：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180413153634331-1176634672.png&quot;&gt;&lt;img title=&quot;QQ截图20180413130857&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180413153634993-1969473854.png&quot; alt=&quot;QQ截图20180413130857&quot; width=&quot;864&quot; height=&quot;216&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;查看 ImageSourceConverter 的源码（&lt;a title=&quot;https://referencesource.microsoft.com/#PresentationCore/Core/CSharp/System/Windows/Media/ImageSourceConverter.cs,0f008db560b688fe&quot; href=&quot;https://referencesource.microsoft.com/#PresentationCore/Core/CSharp/System/Windows/Media/ImageSourceConverter.cs,0f008db560b688fe&quot;&gt;https://referencesource.microsoft.com/#PresentationCore/Core/CSharp/System/Windows/Media/ImageSourceConverter.cs,0f008db560b688fe&lt;/a&gt;），我们可以看到这么一段&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180413153635589-1548574311.png&quot;&gt;&lt;img title=&quot;QQ截图20180413131203&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180413153636199-1229836950.png&quot; alt=&quot;QQ截图20180413131203&quot; width=&quot;1213&quot; height=&quot;210&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因此，在对 Source 属性进行绑定的时候，我们的数据源是可以使用：string、Stream、Uri、byte[] 这些类型的，当然还有它自身 ImageSource（BitmapImage 是 ImageSource 的子类）。&lt;/p&gt;
&lt;p&gt;虽然有 5 种这么多，然而最终我们需要的是 ImageSource。另外 Uri 就相当于 string 的转换。再仔细分析的话，我们大概可以得出下面的结论：&lt;/p&gt;
&lt;p&gt;string –&amp;gt; Uri –&amp;gt; byte[] –&amp;gt; Stream –&amp;gt; ImageSource&lt;/p&gt;
&lt;p&gt;其中 Uri 到 byte[] 就是相当于从 Uri 对应的地方加载图片数据，常见的就是 web、磁盘和程序内嵌资源。&lt;/p&gt;
&lt;p&gt;在某些节点我们是可以加上缓存的，如碰到一个 http/https 的地址，那可以先检查本地是否有缓存文件，有就直接加载不去访问服务器了。&lt;/p&gt;

&lt;p&gt;经过整理，基本可以得出如下的流程图。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180413153637001-898215854.png&quot;&gt;&lt;img title=&quot;ImageEx流程图&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180413153637658-397739041.png&quot; alt=&quot;ImageEx流程图&quot; width=&quot;1011&quot; height=&quot;1162&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看出，流程是一个自上而下，再自下而上的流程。这里就相当于是一个管道处理模型。每一行等价于一个管道，然后整个流程相当于整个管道串联起来。&lt;/p&gt;

&lt;p&gt;在代码的实现过程中，我借鉴了 asp.net core 中的 middleware 的处理过程。&lt;a title=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-2.1&amp;amp;tabs=aspnetcore2x&quot; href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-2.1&amp;amp;tabs=aspnetcore2x&quot;&gt;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-2.1&amp;amp;tabs=aspnetcore2x&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180413153638040-793983138.png&quot;&gt;&lt;img title=&quot;request-delegate-pipeline&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180413153639333-1532968536.png&quot; alt=&quot;request-delegate-pipeline&quot; width=&quot;600&quot; height=&quot;384&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 asp.net core 中，middleware 的其中一种写法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AspNetCoreMiddleware
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; before&lt;/span&gt;
        &lt;span&gt;await&lt;/span&gt;&lt;span&gt; next(context);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; after&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先建立一个类似 HttpContext 的上下文，用于在这个管道模型中处理，我就叫 LoadingContext：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LoadingContext&amp;lt;TResult&amp;gt; &lt;span&gt;where&lt;/span&gt; TResult : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] _httpResponseBytes;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TResult _result;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; LoadingContext(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; source)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (source == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(source));
        }

        OriginSource &lt;/span&gt;=&lt;span&gt; source;
        Current &lt;/span&gt;=&lt;span&gt; source;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; Current { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[] HttpResponseBytes
    {
        &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; =&amp;gt;&lt;span&gt; _httpResponseBytes;
        &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_httpResponseBytes != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InvalidOperationException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value has been set.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            _httpResponseBytes &lt;/span&gt;=&lt;span&gt; value;
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; OriginSource { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TResult Result
    {
        &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; =&amp;gt;&lt;span&gt; _result;
        &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_result != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InvalidOperationException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value has been set.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            _result &lt;/span&gt;=&lt;span&gt; value;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里有四个属性，OriginSource 代码输入的原始 Source，Current 代码当前的 Source 值，在一开始是与 OriginSource 一致的。Result 代表了最终的输出，一般不需要用户手动设置，只需要到达管道底部的话，如果 Result 仍然为空，那么将 Current 赋值给 Result 就是了。HttpResponseBytes 一旦设置了就不可再设置。&lt;/p&gt;
&lt;p&gt;可能你们会问，为啥要单独弄 HttpResponseBytes 这个属性呢，不能在下载完成的时候缓存到磁盘吗？这里考虑到下载回来的不一定是一幅图片，等到后面成功了，得到一个 ImageSource 对象了，那才能认为这是一个图片，这时候才缓存。&lt;/p&gt;
&lt;p&gt;另外为啥是泛型，这里考虑到扩展性，搞不好某个 Image 的 Source 类型就不是 ImageSource 呢(*^_^*)&lt;/p&gt;
&lt;p&gt;而 RequestDelegate 是一个委托，签名如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; System.Threading.Tasks.Task RequestDelegate(HttpContext context);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此我仿照，代码里就建一个 PipeDelegate 的委托。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; Task PipeDelegate&amp;lt;TResult&amp;gt;([NotNull]LoadingContext&amp;lt;TResult&amp;gt; context, CancellationToken cancellationToken = &lt;span&gt;default&lt;/span&gt;(CancellationToken)) &lt;span&gt;where&lt;/span&gt; TResult : &lt;span&gt;class&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;NotNullAttribute 是来自 &lt;a href=&quot;https://www.nuget.org/packages/JetBrains.Annotations/&quot;&gt;JetBrains.Annotations&lt;/a&gt; 这个 nuget 包的。&lt;/p&gt;
&lt;p&gt;另外微软爸爸说，支持取消的话，那是好做法，要表扬的，因此加上了 CancellationToken 参数。&lt;/p&gt;

&lt;p&gt;接下来那就可以准备我们自己的 middleware 了，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; PipeBase&amp;lt;TResult&amp;gt; : IDisposable &lt;span&gt;where&lt;/span&gt; TResult : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsInDesignMode =&amp;gt; (&lt;span&gt;bool&lt;/span&gt;)DesignerProperties.IsInDesignModeProperty.GetMetadata(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(DependencyObject)).DefaultValue;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Dispose()
    {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; Task InvokeAsync([NotNull]LoadingContext&amp;lt;TResult&amp;gt; context, [NotNull]PipeDelegate&amp;lt;TResult&amp;gt; next, CancellationToken cancellationToken = &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(CancellationToken));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;跟 asp.net core 的 middleware 很像，这里我加了一个 IsInDesignMode 属性，毕竟在设计器模式下面，就没必要跑缓存相关的分支了。&lt;/p&gt;

&lt;p&gt;那么，我们自己的 middleware，也就是 Pipe 有了，该怎么串联起来呢，这里我们可以看 asp.net core 的源码&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://github.com/aspnet/HttpAbstractions/blob/a78b194a84cfbc560a56d6d951eb71c8367d17bb/src/Microsoft.AspNetCore.Http/Internal/ApplicationBuilder.cs&quot; href=&quot;https://github.com/aspnet/HttpAbstractions/blob/a78b194a84cfbc560a56d6d951eb71c8367d17bb/src/Microsoft.AspNetCore.Http/Internal/ApplicationBuilder.cs&quot;&gt;https://github.com/aspnet/HttpAbstractions/blob/a78b194a84cfbc560a56d6d951eb71c8367d17bb/src/Microsoft.AspNetCore.Http/Internal/ApplicationBuilder.cs&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        public&lt;/span&gt;&lt;span&gt; RequestDelegate Build()
        {
            RequestDelegate app &lt;/span&gt;= context =&amp;gt;&lt;span&gt;
            {
                context.Response.StatusCode &lt;/span&gt;= &lt;span&gt;404&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
            };

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; component &lt;span&gt;in&lt;/span&gt;&lt;span&gt; _components.Reverse())
            {
                app &lt;/span&gt;=&lt;span&gt; component(app);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; app;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 _components 的定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IList&amp;lt;Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;&amp;gt; _components = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Func&amp;lt;RequestDelegate, RequestDelegate&amp;gt; 代表输入了一个委托，返回了一个委托。而上面 app 就相当于管道的最底部了，因为无法处理了，因此就赋值为 404 了。至于为啥要反转一下列表，这个大家可以自己手动试试，这里也不好解析。&lt;/p&gt;
&lt;p&gt;因此，我编写出如下的代码来组装我们的 Pipe。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; PipeDelegate&amp;lt;TResult&amp;gt; Build&amp;lt;TResult&amp;gt;(IEnumerable&amp;lt;Type&amp;gt; pipes) &lt;span&gt;where&lt;/span&gt; TResult : &lt;span&gt;class&lt;/span&gt;&lt;span&gt;
{
    PipeDelegate&lt;/span&gt;&amp;lt;TResult&amp;gt; end = (context, cancellationToken) =&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (context.Result == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            context.Result &lt;/span&gt;= context.Current &lt;span&gt;as&lt;/span&gt;&lt;span&gt; TResult;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (context.Result == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotSupportedException();
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
    };

    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; pipeType &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pipes.Reverse())
    {
        Func&lt;/span&gt;&amp;lt;PipeDelegate&amp;lt;TResult&amp;gt;, PipeDelegate&amp;lt;TResult&amp;gt;&amp;gt; handler = next =&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (context, cancellationToken) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; pipe = CreatePipe&amp;lt;TResult&amp;gt;&lt;span&gt;(pipeType))
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pipe.InvokeAsync(context, next, cancellationToken);
                }
            };
        };
        end &lt;/span&gt;=&lt;span&gt; handler(end);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; end;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码比 asp.net core  的复杂一点，先看上面 end 的初始化。因为到达了管道的底部，如果 Result 仍然是空的话，那么尝试将 Current 赋值给 Result，如果执行后还是空，那说明输入的 Source 是不支持的类型，就直接抛出异常好了。&lt;/p&gt;
&lt;p&gt;在下面的循环体中，handler 等价于上面 asp.net core 的 component，接受了一个委托，返回了一个委托。&lt;/p&gt;
&lt;p&gt;委托体中，根据当前管道的类型创建了一个实例，并执行 InvokeAsync 方法。&lt;/p&gt;

&lt;p&gt;构建管道的代码也有了，因此加载逻辑也没啥难的了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task SetSourceAsync(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; source)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_image == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            _lastLoadCts&lt;/span&gt;?&lt;span&gt;.Cancel();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (source == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                _image.Source &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                VisualStateManager.GoToState(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, NormalStateName, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            _lastLoadCts &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancellationTokenSource();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                VisualStateManager.GoToState(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, LoadingStateName, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt; LoadingContext&amp;lt;ImageSource&amp;gt;&lt;span&gt;(source);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pipeDelegate = PipeBuilder.Build&amp;lt;ImageSource&amp;gt;&lt;span&gt;(Pipes);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; retryDelay =&lt;span&gt; RetryDelay;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; policy = Policy.Handle&amp;lt;Exception&amp;gt;().WaitAndRetryAsync(RetryCount, count =&amp;gt; retryDelay, (ex, delay) =&amp;gt;&lt;span&gt;
                {
                    context.Reset();
                });
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; policy.ExecuteAsync(() =&amp;gt;&lt;span&gt; pipeDelegate.Invoke(context, _lastLoadCts.Token));

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_lastLoadCts.IsCancellationRequested)
                {
                    _image.Source &lt;/span&gt;=&lt;span&gt; context.Result;
                    VisualStateManager.GoToState(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, OpenedStateName, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    ImageOpened&lt;/span&gt;?.Invoke(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, EventArgs.Empty);
                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_lastLoadCts.IsCancellationRequested)
                {
                    _image.Source &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    VisualStateManager.GoToState(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;, FailedStateName, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
                    ImageFailed&lt;/span&gt;?.Invoke(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ImageExFailedEventArgs(source, ex));
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们的 ImageEx 控件里面必然需要有一个原生的 Image 控件进行承载（不然咋显示）。&lt;/p&gt;
&lt;p&gt;这里我定义了 4 个 VisualState：&lt;/p&gt;
&lt;p&gt;Normal：未加载，Source 为 null 的情况。&lt;/p&gt;
&lt;p&gt;Opened：加载成功，并引发 ImageOpened 事件。&lt;/p&gt;
&lt;p&gt;Failed：加载失败，并引发 ImageFailed 事件。&lt;/p&gt;
&lt;p&gt;Loading：正在加载。&lt;/p&gt;
&lt;p&gt;在这段代码中，我引入了 Polly 这个库，用于重试，一旦出现异常，就重置 context 到初始状态，再重新执行管道。&lt;/p&gt;
&lt;p&gt;而 _lastLoadCts 的类型是 CancellationTokenSource，因为如果 Source 发生快速变化的话，那么先前还在执行的就需要放弃掉了。&lt;/p&gt;


&lt;p&gt;最后奉上源代码（含 WPF 和 UWP demo）：&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;https://github.com/h82258652/HN.Controls.ImageEx&quot; href=&quot;https://github.com/h82258652/HN.Controls.ImageEx&quot;&gt;https://github.com/h82258652/HN.Controls.ImageEx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;先声明，如果你在真实项目中使用出了问题，本人一概不负责的说。&lt;a href=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180413153639655-2083983868.png&quot;&gt;&lt;img title=&quot;2018new_doge_thumb&quot; src=&quot;https://images2018.cnblogs.com/blog/484187/201804/484187-20180413153640101-1397654060.png&quot; alt=&quot;2018new_doge_thumb&quot; width=&quot;36&quot; height=&quot;36&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文只是介绍了一下具体关键点的实现思路，诸如磁盘缓存、Pipe 的服务注入（弄了一个很简单的）这些可以参考源代码中的实现。&lt;/p&gt;
&lt;p&gt;另外源码中值得改进的地方应该是有的，希望大家能给出一些好的想法和意见，毕竟个人能力有限。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Apr 2018 07:37:00 +0000</pubDate>
<dc:creator>h82258652</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/h82258652/p/8820725.html</dc:identifier>
</item>
<item>
<title>js中的面向对象（一）封装 - maqingyuan</title>
<link>http://www.cnblogs.com/maqingyuan/p/8820641.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/maqingyuan/p/8820641.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1.简单的封装（定义）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  //cart1 具有三个属性&lt;br/&gt;var cat1 = {};
  cat1.name = '阿黄';
  cat1.sex = '男';
  cat1.age = 11;&lt;br/&gt;//cat2 也同样具有三个属性
  var cat2 = {};
  cat2.name = '小黑';
  cat2.sex = '女';
  cat2.age = '10';&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把cat1和cat2看成是一个对象，它们都具有三个属性。&lt;/p&gt;
&lt;p&gt;缺点：一时如果有多个对象，写起来就比较麻烦，二是实例和原型之间没有任何联系。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.原始模型封装（在1的基础上进行改进）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function Cat(name,sex,age){
        return {
            name:name,
            sex:sex,
            age:age
        }

    }
    var cat1 = Cat('小黄','男','11');
    var cat2 = Cat('小黑','女','10');
    alert(cat1.name);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;缺点：cat1和cat2没有什么内在联系，不能反应他们是同一原型对象的实例。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.构造函数的封装&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function Cat(name,age,sex){
    this.name = name;
    this.sex = sex;
    this.age = age;
}
var cat1 = new Cat('小黄','男','11');
var cat2 = new Cat('小黑','女','10');&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表面上是没有什么缺点，但是如以下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function Cat(name,age,sex){
    this.name = name;
    this.sex = sex;
    this.age = age;
    this.type = '猫科动物';
}
var cat1 = new Cat('小黄','男','11');
var cat2 = new Cat('小黑','女','10');&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;cat1和cat2都是属于猫科动物，但是在创建对象原型Cat的实例cat1和cat2时都会创建一次type属性；这样就会造成内存的浪费。&lt;/p&gt;

&lt;p&gt;4.&lt;strong&gt;prototype模式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function Cat(name,sex,age){
    this.name = name;
    this.sex = sex;
    this.age = age;
}
Cat.prototype.type = '猫科动物';
Cat.prototype.say = function (){alert(&quot;喵喵&quot;);};
var cat1 = new Cat();
alert(cat1.type);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;原理：Javascript规定，每一个构造函数都有一个&lt;code&gt;prototype&lt;/code&gt;属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。&lt;/p&gt;
&lt;p&gt;个人理解是将相同的属性“放在”一个内存之中，当创建cat1和cat2实例时，他们的属性都会指向同一个内存，从而不用重复创建。&lt;/p&gt;
&lt;p&gt;prototype验证&lt;/p&gt;
&lt;p&gt;1)isPrototypeOf&lt;/p&gt;
&lt;p&gt;2)hasOwnProperty&lt;/p&gt;
&lt;p&gt;3)in&lt;/p&gt;

&lt;p&gt;本文参考： &lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/05/object-oriented_javascript_encapsulation.html&quot; target=&quot;_blank&quot;&gt;阮一峰的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 谢谢大家关注，小的将不屑努力！！！ &amp;lt;maqingyuan&amp;gt;&lt;/p&gt;

</description>
<pubDate>Fri, 13 Apr 2018 07:27:00 +0000</pubDate>
<dc:creator>maqingyuan</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/maqingyuan/p/8820641.html</dc:identifier>
</item>
<item>
<title>绝对路径的表示方式为什么是&quot;/usr&quot;而不是&quot;//usr&quot; - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/8820633.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/8820633.html</guid>
<description>&lt;p&gt;今天闲逛贴吧，竟然看到有个人问绝对路径的表示方式为什么不是&lt;code&gt;//usr/local&lt;/code&gt;而是&lt;code&gt;/usr/local&lt;/code&gt;。原文：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/733013/201804/733013-20180413143403464-876765450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我想99%的人都没想过这个问题，都理所当然的认为：它不就是根&quot;/&quot;吗？&lt;/p&gt;
&lt;p&gt;很巧，我是个探索狂和强迫症患者，当年回炉复习文件系统的时候，正好琢磨过这个问题。下面是我的理解，自认能解释的通。但本人毕竟菜鸟，也没法验证是否真是如此，如有错误，欢迎大牛指正。&lt;/p&gt;
&lt;p&gt;我的结论是：&quot;//usr/local&quot;是正确的，和&quot;/usr/local&quot;的意义完全相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.根文件系统具有&quot;自引用&quot;性，&quot;/&quot;和&quot;//&quot;无论是功能上还是意义上，都完全相同。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.除了根目录外的任意目录，其内的&quot;.&quot;和&quot;..&quot;的inode号不一致，它们分别是当前目录的硬链接和父目录的硬链接。但是根目录下的&quot;.&quot;和&quot;..&quot;的inode号一致，都是根目录的硬链接。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root&lt;span class=&quot;hljs-variable&quot;&gt;@node1&lt;/span&gt; ~]
total &lt;span class=&quot;hljs-number&quot;&gt;204&lt;/span&gt;
      &lt;span class=&quot;hljs-number&quot;&gt;155&lt;/span&gt; drwxr-xr-&lt;span class=&quot;hljs-keyword&quot;&gt;x&lt;/span&gt;.  &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt; root root  &lt;span class=&quot;hljs-number&quot;&gt;4096&lt;/span&gt; May &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;2017&lt;/span&gt; .
      &lt;span class=&quot;hljs-number&quot;&gt;128&lt;/span&gt; dr-xr-xr-&lt;span class=&quot;hljs-keyword&quot;&gt;x&lt;/span&gt;.  &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt; root root  &lt;span class=&quot;hljs-number&quot;&gt;4096&lt;/span&gt; May &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;2017&lt;/span&gt; ..

[root&lt;span class=&quot;hljs-variable&quot;&gt;@node1&lt;/span&gt; ~]
total &lt;span class=&quot;hljs-number&quot;&gt;36&lt;/span&gt;
      &lt;span class=&quot;hljs-number&quot;&gt;128&lt;/span&gt; dr-xr-xr-&lt;span class=&quot;hljs-keyword&quot;&gt;x&lt;/span&gt;.  &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt; root root &lt;span class=&quot;hljs-number&quot;&gt;4096&lt;/span&gt; May &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;2017&lt;/span&gt; .
      &lt;span class=&quot;hljs-number&quot;&gt;128&lt;/span&gt; dr-xr-xr-&lt;span class=&quot;hljs-keyword&quot;&gt;x&lt;/span&gt;.  &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt; root root &lt;span class=&quot;hljs-number&quot;&gt;4096&lt;/span&gt; May &lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;2017&lt;/span&gt; ..
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.&lt;strong&gt;在Linux操作系统启动的时候，内核先有&quot;虚拟根文件系统&quot;，表示方法为&quot;/&quot;，之后找到真实的根文件系统，从&quot;虚拟跟文件系统&quot;切换到&quot;真实根文件系统&quot;。切换的方式就是将真实的根文件系统&quot;挂载&quot;到虚拟根文件系统上(并非真的挂载，但可以这么理解)。所以到这里正确的方式是&quot;//&quot;，其中第一个&quot;/&quot;是虚拟根目录，第二个&quot;/&quot;是真实根文件系统。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此，根文件系统下的&quot;..&quot;代表的是第一个&quot;/&quot;，即虚根，&quot;.&quot;代表的是第二个&quot;/&quot;，代表的是真实根目录。&lt;/p&gt;
&lt;p&gt;在切换到真实根文件系统时，虚根和实根的inode号是一致的。但为什么能一致？虚根为什么也有inode号？&lt;/p&gt;
&lt;p&gt;这是因为在每个分区创建为文件系统的时候，一定会预先保留几个特殊的inode号，相同的文件系统，这些预留inode号一定是相同的。例如ext类的文件系统中，为&quot;/&quot;保留的inode号为2，为&quot;/proc&quot;保留的inode号为1。这些预留的inode号就是为了给切换到真实根文件系统前的虚拟根文件系统使用的，它们记录在initrd/initramfs中。这样以来，既能为虚根分配inode，又能保证在切换时，&quot;/&quot;(虚根)和&quot;//&quot;(实根)的inode号保持一致，并在系统成功启动后使用。&lt;/p&gt;

&lt;p&gt;之所以可以使用&quot;/&quot;来代替&quot;//&quot;，也许是为了方便，也许是为了某些一致性，谁知道呢，甚至上面我的推理也是错误的呢。此外，除了绝对路径的前缀&quot;/&quot;，路径中的任意&quot;/&quot;都可以替换为&quot;//&quot;，例如&quot;/usr//local&quot;也能正确表示&quot;/usr/local&quot;。但它们和前缀的&quot;//&quot;意义不同。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7048359.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到Linux系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7048359.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7576137.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到网站架构系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7576137.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/7586194.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;回到数据库系列文章大纲：http://www.cnblogs.com/f-ck-need-u/p/7586194.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/f-ck-need-u/p/8820633.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;转载请注明出处：http://www.cnblogs.com/f-ck-need-u/p/8820633.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注：若您觉得这篇文章还不错请点击右下角推荐，您的支持能激发作者更大的写作热情，非常感谢！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Apr 2018 07:26:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/8820633.html</dc:identifier>
</item>
<item>
<title>机器学习之五：神经网络、反向传播算法推导 - Fordestiny</title>
<link>http://www.cnblogs.com/Fordestiny/p/8819978.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Fordestiny/p/8819978.html</guid>
<description>&lt;h2 id=&quot;一逻辑回归的局限&quot;&gt;一、逻辑回归的局限&lt;/h2&gt;
&lt;p&gt;在逻辑回归一节中，使用逻辑回归的多分类，实现了识别20*20的图片上的数字。&lt;/p&gt;
&lt;p&gt;但所使用的是一个一阶的模型，并没有使用多项式，为什么？&lt;/p&gt;
&lt;p&gt;可以设想一下，在原有400个特征的数据样本中，增加二次、三次、四次多项式，会是什么情形？&lt;/p&gt;
&lt;p&gt;很显然，训练样本的特征数量将会拔高多个数量级，而且，更重要的，要在一个式子中拟合这么多的特征，其难度是非常大的，可能无法收敛到一个比较理想的状态。&lt;/p&gt;
&lt;p&gt;也就是说，逻辑回归没法提供很复杂的模型。&lt;/p&gt;
&lt;p&gt;因为其本质上是一个线性的分类器，擅长解决的是线性可分的问题。&lt;/p&gt;
&lt;p&gt;那么非线性可分问题，要怎么解决？&lt;/p&gt;
&lt;h4 id=&quot;解决思路&quot;&gt;解决思路&lt;/h4&gt;
&lt;p&gt;如果有一种方法，将非线性可分问题先进行特征提取，变为接近线性可分，那么再应用一次逻辑回归，是否就能解决非线性问题了？&lt;/p&gt;
&lt;p&gt;这便是神经网络的思想。&lt;/p&gt;
&lt;h2 id=&quot;二神经网络&quot;&gt;二、神经网络&lt;/h2&gt;
&lt;h4 id=&quot;结构&quot;&gt;1、结构&lt;/h4&gt;
&lt;p&gt;神经网络的结构，如下图所示&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://wx4.sinaimg.cn/mw690/ec98cc4agy1fqavy256mdj207r08bwf1.jpg&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;上面是一个最简单的模型，分为三层：输入层、隐藏层、输出层。
&lt;p&gt;其中，隐藏层可以是多层结构，通过扩展隐藏层的结构，可以构建更得杂的模型，例如下面的模型：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://wx2.sinaimg.cn/mw690/ec98cc4agy1fqazaso0uzj20ek0943zr.jpg&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;每一层的输出，皆是下一层的输出，层层连接而成，形成一个网络。
&lt;p&gt;网络中的节点，称为神经元。每个神经元，其实就是进行一次类似逻辑回归的运算（之所以说是&quot;类似&quot;，是因为可以使用逻辑回归，也有别的算法代替，但可以使用逻逻回归来理解它的运算机理）。&lt;/p&gt;
&lt;p&gt;根据上面前言中的分析，显然，隐藏层是进行特征的提取，而输出层，其实就是进行逻辑回归。&lt;/p&gt;
&lt;h4 id=&quot;为何说隐藏层是进行特征提取&quot;&gt;为何说隐藏层是进行特征提取？&lt;/h4&gt;
&lt;p&gt;为方便理解，这里假设所有神经元执行逻辑回归。&lt;/p&gt;
&lt;p&gt;一次逻辑回归，可以将平面一分为二。神经网络中，执行的是 N 多个逻辑回归，那么可以将平面切割为 N 多个区域，这些区域最后由输出层进行综合后做为结果。&lt;/p&gt;
&lt;p&gt;如果只关注输出层，那么这些前面切割出来的区域，其实可以当作是一种特征，是一种更高级的特征，由原始样本提取出来的。这就是特征的提取。&lt;/p&gt;
&lt;h4 id=&quot;计算原理&quot;&gt;2、计算原理&lt;/h4&gt;
&lt;h4 id=&quot;前向传播计算输出&quot;&gt;2.1 前向传播，计算输出&lt;/h4&gt;
&lt;p&gt;下面求解当一个样本从输入层输入时，如何得到最终结果。&lt;/p&gt;
&lt;p&gt;假设每个神经元，都执行逻辑回归的计算，则第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 层网络的输出为：&lt;span class=&quot;math display&quot;&gt;\[a^{(i)} = g(z^{(i)}) = g(\Theta^Ta^{(i-1)}) \tag{1}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;以如下三层网络为例：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://wx4.sinaimg.cn/mw690/ec98cc4agy1fqavy256mdj207r08bwf1.jpg&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;各层的输入输出如下：
&lt;p&gt;Input layer：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ a^{(1)} = x \]&lt;/span&gt;&lt;br/&gt;Hidden layer：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} z^{(2)} &amp;amp;= \Theta^{(1)}a^{(1)} \\ a^{(2)} &amp;amp;= g(z^{(2)}) \end{split} \]&lt;/span&gt;&lt;br/&gt;Output layer：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} z^{(3)} &amp;amp;= \Theta^{(2)}a^{(2)} \\ a^{(3)} &amp;amp;= g(z^{(2)}) \end{split} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;即整个网络的最终结果为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ h_\theta(x) = a^{(3)} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上述流程：以上一层的输出，作为下一层的输入，一层一层叠加运算后，得到最终的输出，这个计算方法，称为“前向传播”&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;反向传播求theta矩阵&quot;&gt;2.2 反向传播，求theta矩阵&lt;/h4&gt;
&lt;p&gt;训练算法的目的是“求取使得误差函数最小化的参数矩阵”，用梯度下降法处理最小化误差，需要计算误差函数J、以及J对theta的偏导数。&lt;/p&gt;
&lt;h4 id=&quot;误差函数j&quot;&gt;2.2.1 误差函数J&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ J(\Theta) = -\frac{1}{m} \sum_{i=1}^{m}\sum_{k=1}^{K}[y_k^{(i)}log(h_\Theta(x^{(i)}))_k + (1-y_k^{(i)})log(1-h_\theta(x^{(i)}))_k] + \frac{\lambda}{2m}\sum_{l=1}^{L-1}\sum_{i=1}^{S_l}\sum_{j=1}^{S_l+1}(\Theta_{ji}^{(l)})^2 \tag{2} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt; 为输出层的单元数，即类别数。在计算误差的时候，需要将每一类都计算进去。后面的正则项是整个神经网络中所有的参数 &lt;span class=&quot;math inline&quot;&gt;\(\Theta\)&lt;/span&gt; 的值之和。&lt;/p&gt;
&lt;h4 id=&quot;j对theta偏导数&quot;&gt;2.2.2 J对theta偏导数&lt;/h4&gt;
&lt;p&gt;这里先给结果，后面再做推导：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial}{\partial\Theta_{ij}^{(l)}}J(\Theta) = \frac{1}{m}\sum_{t=1}^{m}\delta_i^{(t)(l+1)}a_j^{(t)(l)} + \frac{\lambda}{m}\sum_{l=1}^{L-1}\sum_{i=1}^{S_l}\sum_{j=1}^{S_l+1}(\Theta_{ji}^{(l)}) \tag{3} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{cases} \delta^{(L)} &amp;amp;=&amp;amp; a^{(L)}-y \\ \\ \delta^{(l)} &amp;amp;=&amp;amp; \delta^{(l+1)}*(\Theta^{(l+1)})^T*g'(z^{(l)}) \\ \\ \delta^{(0)} &amp;amp;=&amp;amp; 0 \\ \end{cases} \tag{4} \]&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;上述公式描述的内容&quot;&gt;上述公式描述的内容&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;第 &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt; 层的误差，可以通过第 &lt;span class=&quot;math inline&quot;&gt;\(l+1\)&lt;/span&gt; 层的误差计算出来，而最后一层的误差，就是系统通过前向传播计算出的值与样本 &lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt; 值的差。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;也就是说，从输出层开始，各层误差能通过一层一层反向迭代的方式得到，确定误差之后，偏导数便也随之计算出来，进而可进行模型的调整。这就是，“反向传播算法”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而反向传播的内容，其实是误差。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;关于误差的直观理解&quot;&gt;关于误差的直观理解：&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;输出层的误差，即为系统的总误差；&lt;/p&gt;
&lt;p&gt;中间层的误差，即为每一层对总误差的贡献值(所以，&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt; 矩阵，在前向传播中，是特征权重，而在反向传播中，就是误差权重)；&lt;/p&gt;
&lt;p&gt;而输入层，其输出即为原始数据，即无误差。&lt;/p&gt;
&lt;h4 id=&quot;反向传播算法的推导过程&quot;&gt;2.2.3 反向传播算法的推导过程&lt;/h4&gt;
&lt;h4 id=&quot;第一部分推导偏导数&quot;&gt;(1) 第一部分，推导偏导数&lt;/h4&gt;
&lt;p&gt;上面给出了反向传播的结论，以下进行推导。&lt;/p&gt;
&lt;p&gt;矩阵形式计算第 &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt; 层的偏导数：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} \frac{\partial J(\Theta)}{\partial\Theta^{(l)}} &amp;amp;= \frac{\partial J(\Theta)}{\partial z^{(l+1)}} * \frac{\partial z^{(l+1)}}{\partial \Theta^{(l)}} \\ \\ &amp;amp;= \frac{\partial J(\Theta)}{\partial z^{(l+1)}} * \frac{\partial (\Theta^{(l)}*a^{(l)})}{\partial \Theta^{(l)}} \\ \\ &amp;amp;= \frac{\partial J(\Theta)}{\partial z^{(l+1)}} * a^{(l)} \end{split} \tag{5} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&quot;math display&quot;&gt;\[\delta^{(l)} = \frac{\partial J(\Theta)}{\partial z^{(l)}} \tag{6}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;则有&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} \frac{\partial J(\Theta)}{\partial\Theta^{(l)}} &amp;amp;=&amp;amp; \frac{\partial J(\Theta)}{\partial z^{(l+1)}} * a^{(l)} \\ \\ &amp;amp;=&amp;amp; \delta^{(l+1)} * a^{(l)} \\ \end{split} \tag{7} \]&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;第二部分推导误差delta&quot;&gt;(2) 第二部分，推导误差delta&lt;/h4&gt;
&lt;p&gt;上面推导过程中，有这个式子：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \delta^{(l)} = \frac{\partial J(\Theta)}{\partial z^{(l)}} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;表示了什么意思？下面分别从输出层、及中间层来推导、解释这个式子。&lt;/p&gt;
&lt;p&gt;因误差函数如下(这里省略掉正则项)&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ J(\Theta) = -\frac{1}{m} \sum_{i=1}^{m}\sum_{k=1}^{K}[y_k^{(i)}log(h_\Theta(x^{(i)}))_k + (1-y_k^{(i)})log(1-h_\theta(x^{(i)}))_k] \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此式表达的是总误差，那么，对于输出层的每个神经元的误差，可用矩阵表示为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ C = - [ylog(h_\Theta(x)) + (1-y)log(1-h_\theta(x))] \tag{8} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;故输出层的误差为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} \delta^{(L)} &amp;amp;=&amp;amp; \frac{\partial J(\Theta)}{\partial z^{(L)}} = \frac{\partial C}{\partial z^{(L)}} \\ \\ &amp;amp;=&amp;amp; \frac{\partial }{\partial z^{(L)}} [ylog(h_\Theta(x)) + (1-y)log(1-h_\theta(x))] \\ \\ &amp;amp;=&amp;amp; -\frac{y}{g(z^{(L)})}g'(z^{(L)}) - \frac{1-y}{1-g(z^{(L)})}(-g'(z^{(L)})) \\ \\ &amp;amp;=&amp;amp; \frac{g(z^{(L)})-y}{g(z^{(L)})(1-g(z^{(L)}))}(g'(z^{(L)})) \\ \\ &amp;amp;=&amp;amp; g(z^{(L)})-y \\ \\ &amp;amp;=&amp;amp; a^{(L)}-y \end{split} \tag{9} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个结果，有点意思了，表示出输层的 &lt;span class=&quot;math inline&quot;&gt;\(\delta\)&lt;/span&gt; 值，就是系统输出值与样本 &lt;span class=&quot;math inline&quot;&gt;\(Y\)&lt;/span&gt; 值的差。所以，我们称 &lt;span class=&quot;math inline&quot;&gt;\(\delta\)&lt;/span&gt; 为神经系统各层结构的各个神经元的误差。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h4 id=&quot;中间层误差推导&quot;&gt;中间层误差推导&lt;/h4&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于第 &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt; 层&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{split} \delta^{(l)} &amp;amp;=&amp;amp; \frac{\partial J(\Theta)}{\partial z^{(l)}} \\ \\ &amp;amp;=&amp;amp; \frac{\partial J(\Theta)}{\partial z^{(l+1)}} * \frac{\partial z^{(l+1)}}{\partial z^{(l)}} \\ \\ &amp;amp;=&amp;amp; \delta^{(l+1)} * \frac{\partial [(\Theta^{(l+1)})^T*g(z^{(l)})]}{\partial z^{(l)}} \\ \\ &amp;amp;=&amp;amp; \delta^{(l+1)} * (\Theta^{(l+1)})^T*g'(z^{(l)}) \\ \end{split} \tag{10}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;即第 &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt; 层的误差，能用第 &lt;span class=&quot;math inline&quot;&gt;\(l+1\)&lt;/span&gt; 层的误差计算得到，与先前所定的结论完全一致。&lt;/p&gt;
&lt;p&gt;这就是反向传播的所有推导的内容。&lt;/p&gt;
&lt;h2 id=&quot;三程序实现&quot;&gt;三、程序实现&lt;/h2&gt;
&lt;p&gt;例子来源于，吴恩达的机器学习编程题。样本与逻辑回归中的多分类的数字识别相同。&lt;/p&gt;
&lt;h4 id=&quot;计算损失函数及梯度&quot;&gt;1、计算损失函数、及梯度&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;function [J grad] = nnCostFunction(nn_params, ...
                                   input_layer_size, ...
                                   hidden_layer_size, ...
                                   num_labels, ...
                                   X, y, lambda)
Theta1 = reshape(nn_params(1:hidden_layer_size * (input_layer_size + 1)), ...
                 hidden_layer_size, (input_layer_size + 1));

Theta2 = reshape(nn_params((1 + (hidden_layer_size * (input_layer_size + 1))):end), ...
                 num_labels, (hidden_layer_size + 1));

% Setup some useful variables
m = size(X, 1);
         
% You need to return the following variables correctly 
J = 0;
Theta1_grad = zeros(size(Theta1));
Theta2_grad = zeros(size(Theta2));


% ------ 前向传播计算输出 ------

% input layer
a1 = [ones(m, 1) X]; %add +1 to X;
% hidden layer
a2 = sigmoid(a1 * Theta1');
a2 = [ones(m, 1) a2];
% output layer
a3 = sigmoid(a2 * Theta2');

% ------ 样本的Y值 ------
% [1 0 0 0 0 0 0 0 0 0] -- the value is 1
% [0 1 0 0 0 0 0 0 0 0] -- the value is 2
Y = zeros(m,num_labels);
for i = 1 : m
    Y(i,y(i)) = 1;
end

% ------ 损失函数J ------
J = (sum(sum(-Y .* log(a3))) - sum(sum((1-Y) .* log(1-a3)))) / m ;
% remove theta0
t1 = Theta1(:,2:end);
t2 = Theta2(:,2:end);
regularize = lambda / 2 / m * (sum(sum(t1.^2)) + sum(sum(t2.^2)));
J = J + regularize;

% ------ 反向传播计算各层误差 ------
delta3 = a3 - Y;
delta2 = delta3 * Theta2 .* a2 .* (1 - a2);
delta2 = delta2(:,2:end);

% ------ 计算梯度 ------
Theta1_grad = ( delta2' * a1 + [zeros(size(t1,1),1) t1] * lambda) / m;
Theta2_grad = ( delta3' * a2 + [zeros(size(t2,1),1) t2] * lambda) / m;

% Unroll gradients
grad = [Theta1_grad(:) ; Theta2_grad(:)];

end
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;前向传播及计算delta中需要用到sigmoid函数及其导数&quot;&gt;2、前向传播及计算delta中，需要用到sigmoid函数及其导数&lt;/h4&gt;
&lt;h4 id=&quot;sigmoid函数&quot;&gt;2.1 sigmoid函数&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;function g = sigmoid(z)
g = 1.0 ./ (1.0 + exp(-z));
end
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;sigmoid函数的导数&quot;&gt;2.2 sigmoid函数的导数&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;function g = sigmoidGradient(z)
g = sigmoid(z) .* (1 - sigmoid(z));
end
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;训练过程&quot;&gt;3、训练过程&lt;/h4&gt;
&lt;h4 id=&quot;随机初始化theta参数矩阵&quot;&gt;3.1、随机初始化theta参数矩阵&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;initial_Theta1 = randInitializeWeights(input_layer_size, hidden_layer_size);
initial_Theta2 = randInitializeWeights(hidden_layer_size, num_labels);

% Unroll parameters
initial_nn_params = [initial_Theta1(:) ; initial_Theta2(:)];
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;逻辑回归中，theta矩阵可以初始化为同一个值，如全0或全1。但神经网络中却不行。&lt;/p&gt;
&lt;p&gt;原因在于：神经网络中，神经元是以全连接的形式组织起来的，即n-1层的任意一个节点，都与第n层所有节点相连接。&lt;/p&gt;
&lt;p&gt;若是初始化时theta矩阵初始化为同一个值，同一个层的每一个神经元都进行相同的运算，多个神经元进行相同的运算，这对于数据的拟合没有任何用处，只是浪费资源，造成冗余。此为对称现象。&lt;/p&gt;
&lt;p&gt;随机初始化参数的实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function W = randInitializeWeights(L_in, L_out)
W = zeros(L_out, 1 + L_in);
epsilon_init = 0.12;
W = rand(L_out, 1 + L_in) * 2 * epsilon_init - epsilon_init;
end
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;初始化参数&quot;&gt;3.2、初始化参数&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;options = optimset('MaxIter', 100);

% 正则项参数
lambda = 1;

% 损失函数
costFunction = @(p) nnCostFunction(p, ...
                                   input_layer_size, ...
                                   hidden_layer_size, ...
                                   num_labels, X, y, lambda);
% 梯度下降计算参数
[nn_params, cost] = fmincg(costFunction, initial_nn_params, options);

% 获取两层神经网络的参数
Theta1 = reshape(nn_params(1:hidden_layer_size * (input_layer_size + 1)), ...
                 hidden_layer_size, (input_layer_size + 1));

Theta2 = reshape(nn_params((1 + (hidden_layer_size * (input_layer_size + 1))):end), ...
                 num_labels, (hidden_layer_size + 1));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;预测&quot;&gt;4、预测&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;pred = predict(Theta1, Theta2, X);

fprintf('\nTraining Set Accuracy: %f\n', mean(double(pred == y)) * 100);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，其预测结果，比逻辑回归准确率高接近3个点。&lt;/p&gt;
&lt;p&gt;原因在于：神经网络所能构建的模型，比逻辑回归更为复杂，其对数据的拟合能力也更强。&lt;/p&gt;
&lt;p&gt;predict函数，使用训练得到的参数矩阵，前向传播计算得到结果即为输出层，输出层表示一个输入样本经过经神网络计算之后，其可能属于各个分类的概率值。与逻辑回归类似，取最大值即为最终的结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function p = predict(Theta1, Theta2, X)

m = size(X, 1);
num_labels = size(Theta2, 1);

p = zeros(size(X, 1), 1);

h1 = sigmoid([ones(m, 1) X] * Theta1');
h2 = sigmoid([ones(m, 1) h1] * Theta2');
[dummy, p] = max(h2, [], 2);

end
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 13 Apr 2018 07:10:00 +0000</pubDate>
<dc:creator>Fordestiny</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Fordestiny/p/8819978.html</dc:identifier>
</item>
<item>
<title>机器学习之四：支持向量机推导 - Fordestiny</title>
<link>http://www.cnblogs.com/Fordestiny/p/8660464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Fordestiny/p/8660464.html</guid>
<description>&lt;h2 id=&quot;一支持向量机svm&quot;&gt;一、支持向量机（SVM）&lt;/h2&gt;
&lt;p&gt;支持向量机，是用于解决分类问题。为什么叫做支持向量机，后面的内容再做解释，这里先跳过。&lt;/p&gt;
&lt;p&gt;在之前&lt;a href=&quot;http://www.cnblogs.com/Fordestiny/p/8561293.html&quot;&gt;《逻辑回归》&lt;/a&gt;的文章中，我们讨论过，对于分类问题的解决，就是要找出一条能将数据划分开的边界。&lt;/p&gt;
&lt;p&gt;对于不同的算法，其定义的边界可能是不同的，对于SVM算法，是如何定义其边界的？其定义方法有什么优点？将是下面要讨论的内容。&lt;/p&gt;
&lt;h4 id=&quot;哪个模型更优&quot;&gt;1、哪个模型更优&lt;/h4&gt;
&lt;p&gt;先来讨论一个二分类问题。&lt;/p&gt;
&lt;p&gt;数据样本如下图所示：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://wx2.sinaimg.cn/mw690/ec98cc4agy1fp35a8rv0pj209506qgld.jpg&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;其可能的划分边界可能是如下图中的蓝线、红线：&lt;br/&gt;&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://wx1.sinaimg.cn/mw690/ec98cc4agy1fp35a8rj4oj2098071wea.jpg&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;图中的蓝、红两种分类边界，都能达到分类的效果，但是哪一个效果更优？
&lt;p&gt;评判一个模型的优劣，最主要的，是其对样本的泛化能力。&lt;/p&gt;
&lt;p&gt;若有一个新样本，其二维特征位置，如下图蓝色方块所示：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://wx3.sinaimg.cn/mw690/ec98cc4agy1fp35a8rny5j209d06x743.jpg&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;两个模型，所得到的结果，显然是各不相同的，但从聚类的情况来看，该样本更偏向于“圆”的分类。
&lt;p&gt;也就是说，蓝色边界所表示的模型，更有代表性。&lt;/p&gt;
&lt;p&gt;而它，也是SVM算法所得到的模型。&lt;strong&gt;从直观上看，SVM确定的边界，刚好在两类样本的“中间”位置，不偏不倚&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面接着讨论，SVM是如何确定边界的。&lt;/p&gt;
&lt;h4 id=&quot;支持向量机&quot;&gt;2、支持向量机&lt;/h4&gt;
&lt;p&gt;支持向量机的基本思想是：找到集合边缘上的若干数据（称为支持向量），用这些点找出一个平面（称为决策面），使得支持向量到该平面的距离最长。&lt;/p&gt;
&lt;p&gt;该算法，依靠支持向量来求解边界，支持向量机这个名字，也来源于此。&lt;/p&gt;
&lt;p&gt;以上面的样本为例，解释SVM的步聚，如下图：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://wx1.sinaimg.cn/mw690/ec98cc4agy1fp35a8sgr3j209207eq2r.jpg&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;br/&gt;如下两步：
&lt;p&gt;综上所述，虽然还未涉及SVM的具体运算，但可以初步看出，支持向量机有如下优点：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;计算量少。只使用了支持向量进行计算，而其他距离边界很远的点，其特征很明显，不会引起歧义，不用参与计算。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;泛化能力好。因其定义的边界，距离正负样本距离是最长的，具备良好的区分效果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二svm推导&quot;&gt;二、SVM推导&lt;/h2&gt;
&lt;p&gt;本节，将讨论SVM寻找决策面的数学推理过程。&lt;/p&gt;
&lt;p&gt;根据数据集的属性，可以将这个问题分为两个层次：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;线性可分：数据分布简单，如上面的例子。可以找到一个超平面，直接在原始空间中将数据进行切分。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;线性不可分：数据分布复杂，不存在这样的超平面，则通过将原始空间映射到一个高维空间，在高维空间对数据进行划分。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;线性可分决策面&quot;&gt;1、线性可分决策面&lt;/h3&gt;
&lt;p&gt;线性可分是一个最简单的分类问题，下面做推导。&lt;/p&gt;
&lt;h4 id=&quot;首先是样本集&quot;&gt;1.1、首先是样本集&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ {(x_1,y_1),(x_2,y_2),...,(x_n,y_n)} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 的取值为 {+1,−1}。&lt;/p&gt;
&lt;h4 id=&quot;决策面方程&quot;&gt;1.2、决策面方程&lt;/h4&gt;
&lt;p&gt;从第一节知道，分类的手段是取得一个符合条件的决策平面。&lt;/p&gt;
&lt;p&gt;平面可以用方程表示：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ w^Tx + b = 0 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么问题的解决，则转化为找到符合条件的 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;，条件是：使得数据集边缘若干点，到这个平面的距离是最长的。&lt;/p&gt;
&lt;p&gt;因两类数据分布在决策平面的两侧，所以，&lt;span class=&quot;math inline&quot;&gt;\(y = -1\)&lt;/span&gt; 的样本点所在区域可表示为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[w^Tx + b &amp;lt; 0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同理， &lt;span class=&quot;math inline&quot;&gt;\(y = +1\)&lt;/span&gt; 的样本点所在区域为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[w^Tx + b &amp;gt; 0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么支持向量所在的平面可以表示为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[w^Tx + b = \pm A\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在后面的优化中，其实&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;的值为多少，并不影响结果，为了方便计算，令 &lt;span class=&quot;math inline&quot;&gt;\(A = 1\)&lt;/span&gt;，即：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[w^Tx + b = \pm 1\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br/&gt;&lt;img src=&quot;https://wx4.sinaimg.cn/mw690/ec98cc4agy1fpr7s3i3n4j20a8083weo.jpg&quot; alt=&quot;image&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;h4 id=&quot;计算最长距离&quot;&gt;1.3、计算最长距离&lt;/h4&gt;
&lt;p&gt;有了决策平面，接下来便是要计算支持向量到决策平台的距离，当该距离最长时所得到的参数，就是所需要的解。&lt;/p&gt;
&lt;p&gt;由几何知识可知，点到平面的距离可以表示为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \gamma = \frac{w^Tx+b}{{||w||}} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此距离称为几何距离，存在正负。&lt;/p&gt;
&lt;p&gt;而算法的目标，就是找到一个集合 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; (支持向量)，使得 &lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt; 的值最小。&lt;/p&gt;
&lt;p&gt;因 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 的取值为{+1,−1}，所以上式可以乘上一个 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;，使该距离恒为正。&lt;/p&gt;
&lt;p&gt;所以最大距离可表示为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \gamma_{max} = max({\frac{y(w^Tx+b)}{{||w||}}}) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;结合上一节的假设，支持向量所在方程：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ w^Tx + b = \pm 1 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;故而&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ y(w^Tx+b) = 1 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;则最大距离简化为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \gamma_{max} = max({\frac{1}{{||w||}}}) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;求解上式最大值，等同于求解下式的最小化值&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ min({\frac{1}{{2}}}||w||^2) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里增加了一个1/2系数、和一个平方，是为了方便求导。一求导两者就相消了。&lt;/p&gt;
&lt;p&gt;这个式子有还有一些限制条件，完整的写下来，应该是这样的：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ min({\frac{1}{{2}}}||w||^2),s.t,y(w^Tx+b)\geq1 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;s.t.后面的限制条件可以看做是一个凸多面体，我们要做的就是在这个凸多面体中找到最优解。&lt;/p&gt;
&lt;p&gt;求解该式，可以用拉格朗日乘子法去解，使用了KKT条件的理论。&lt;/p&gt;
&lt;h4 id=&quot;求最优解&quot;&gt;1.4、求最优解&lt;/h4&gt;
&lt;p&gt;对于具体的求解理论，这里不进行讨论，直接给出待求解式子的拉格朗日目标函数，如下，目标是让 $L(w,b,a) $ 针对 $ a $ 达到最大值：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(w,b,a) =\frac{1}{{2}}||w||^2-\sum_{i=1}^n \alpha_i(y_i(w^Tx+b)-1) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如何求解？&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 是关于 &lt;span class=&quot;math inline&quot;&gt;\(w、b、a\)&lt;/span&gt; 三个变量的函数，要得到使得 &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 最大的 &lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;，需进行两步操作：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先需要先排除掉 &lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt; 的影响，&lt;strong&gt;让&lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt;关于&lt;span class=&quot;math inline&quot;&gt;\(w、b\)&lt;/span&gt; 最小化&lt;/strong&gt;。如此一来，不管 &lt;span class=&quot;math inline&quot;&gt;\(w、b\)&lt;/span&gt; 如何改变，&lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 都不会再变小&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接着&lt;strong&gt;再让 &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 关于 &lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt; 取最大值&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（1）求&lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 关于 &lt;span class=&quot;math inline&quot;&gt;\(w、b\)&lt;/span&gt; 最小值&lt;/p&gt;
&lt;p&gt;在可导的情况下，极值在导数为0的位置。于是令 &lt;span class=&quot;math inline&quot;&gt;\(L\)&lt;/span&gt; 关于 &lt;span class=&quot;math inline&quot;&gt;\(w、b\)&lt;/span&gt; 的偏导数为0，即：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial L}{\partial w} = 0 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial L}{\partial b} = 0 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;求解上面的导数，得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ w=\sum_{i=1}^n\alpha_iy_ix_i \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \sum_{i=1}^n\alpha_iy_i = 0 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将上两式代入 $L(w,b,a) $，得到对偶问题的表达式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(w,b,a) =\frac{1}{{2}}\sum_{i=1}^n\alpha_i - \frac{1}{{2}}\sum_{i,j=1}^n\alpha_i\alpha_jy_iy_jx^T_ix_j \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;于是新的目标问题及限制条件为（对偶问题）:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{cases} max_a(\sum_{i=1}^n\alpha_i - \frac{1}{{2}}\sum_{i,j=1}^n\alpha_i\alpha_jy_iy_jx^T_ix_j) \\ \\ s.t.,\alpha \geq0,i=1,2,...,n \\ \\ \sum_{i=1}^n\alpha_iy_i = 0 \end{cases} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个就是我们需要最终优化的式子，只关于 &lt;span class=&quot;math inline&quot;&gt;\(α\)&lt;/span&gt; 向量的式子。&lt;/p&gt;
&lt;p&gt;(2) L关于 &lt;span class=&quot;math inline&quot;&gt;\(α\)&lt;/span&gt; 的最大值&lt;/p&gt;
&lt;p&gt;上式最终的对偶问题，是一个凸二次规划问题，理论上用任何一个解决凸二次规划的软件包都可以解决。&lt;/p&gt;
&lt;p&gt;一般使用SMO算法，输入是样本，输出是 &lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;SMO基本思想是，不断执行如下两个步骤，直至收敛：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;选取一对参数&lt;span class=&quot;math inline&quot;&gt;\((\alpha_i,\alpha_j)\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;固定 &lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt; 向量的其他参数，将&lt;span class=&quot;math inline&quot;&gt;\((\alpha_i,\alpha_j)\)&lt;/span&gt;代入上述表达式进行求最优解获得更新后的&lt;span class=&quot;math inline&quot;&gt;\((\alpha_i,\alpha_j)\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;解出 &lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt; 后，&lt;span class=&quot;math inline&quot;&gt;\(w、b\)&lt;/span&gt;也就确定下来，进而能得到决策面。&lt;/p&gt;
&lt;p&gt;具体的SMO算法细节，有些超过本文的定位，就不在此处展开。&lt;/p&gt;
&lt;h3 id=&quot;线性不可分决策面&quot;&gt;2、线性不可分决策面&lt;/h3&gt;
&lt;p&gt;上面讨论了线性可分的数据集的处理方式。但是，实际应用中的数据样本，可能更多的是线性不可分的，即不能找到一个可以将数据分类的超平面。&lt;/p&gt;
&lt;p&gt;这种情况下，一般使用核函数将原始空间映射到一个高维空间，在高维高间对数据进行划分。理论上只要维度足够高，那么总能做到分类。&lt;/p&gt;
&lt;h4 id=&quot;决策面方程-1&quot;&gt;2.1 决策面方程&lt;/h4&gt;
&lt;p&gt;在线性可分的基础上，将样本 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，进行一次变换，得到&lt;span class=&quot;math inline&quot;&gt;\(\phi(x)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;超平台变为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ w^T\phi(x) + b = 0 \]&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;求最优解-1&quot;&gt;2.2 求最优解&lt;/h4&gt;
&lt;p&gt;整个推理过程，与线性可分的基本一样，唯一不同的，是将各个公式化中的 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，换成 &lt;span class=&quot;math inline&quot;&gt;\(\phi(x)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;即得到对遇问题：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{cases} max_a(\sum_{i=1}^n\alpha_i - \frac{1}{{2}}\sum_{i,j=1}^n\alpha_i\alpha_jy_iy_j\phi(x_i)^T\phi(x_j)) \\ \\ s.t.,\alpha \geq0,i=1,2,...,n \\ \\ \sum_{i=1}^n\alpha_iy_i = 0 \end{cases} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;令：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \phi(x_i)^T\phi(x_j) = K(x_i,x_j) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个式子所做的事情就是将线性的空间映射到高维的空间，K函数有很多种，下面是比较典型的两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多项式核&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ K(x_i,x_j) = (x_i.x_j+1)^d \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ K(x_i,x_j) = exp(-\frac{(x_i-x_j)^2}{2\sigma^2}) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最后一样能通过各类软件包，例如SMO，实现求解。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Apr 2018 07:09:00 +0000</pubDate>
<dc:creator>Fordestiny</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Fordestiny/p/8660464.html</dc:identifier>
</item>
<item>
<title>Spring源码情操陶冶-任务定时器ConcurrentTaskScheduler - 南柯问天</title>
<link>http://www.cnblogs.com/question-sky/p/8819850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/question-sky/p/8819850.html</guid>
<description>&lt;blockquote readability=&quot;3.7021276595745&quot;&gt;
&lt;p&gt;承接前文&lt;a href=&quot;http://www.cnblogs.com/question-sky/p/8733461.html&quot;&gt;Spring源码情操陶冶#task:scheduled-tasks解析器&lt;/a&gt;，本文在前文的基础上讲解&lt;strong&gt;单核心线程&lt;/strong&gt;线程池的工作原理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;应用附例&quot;&gt;应用附例&lt;/h3&gt;
&lt;p&gt;承接前文的例子，如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode xml&quot;&gt;
&lt;code class=&quot;sourceCode xml&quot;&gt;&lt;span class=&quot;co&quot;&gt;&amp;lt;!--define bean for schedule task--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;bean&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; id=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;taskBean&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;com.jing.test.spring.task.TaskBean&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/bean&amp;gt;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;&amp;lt;task:scheduled-tasks&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;task:scheduled&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;taskBean&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;doInit&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; cron=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0 0 0 ? * *&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/task:scheduled&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;task:scheduled&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; ref=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;taskBean&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; method=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;doClear&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; cron=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;0 0 23 ? * *&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&amp;lt;/task:scheduled&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/task:scheduled-tasks&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即我们不配置&lt;code&gt;task:scheduled-tasks&lt;/code&gt;的属性&lt;code&gt;scheduler&lt;/code&gt;，则会采取&lt;code&gt;org.springframework.scheduling.concurrent.ConcurrentTaskScheduler&lt;/code&gt;任务定时器。&lt;/p&gt;
&lt;h3 id=&quot;实例化缘由&quot;&gt;实例化缘由&lt;/h3&gt;
&lt;p&gt;可以直接去看前文的&lt;code&gt;ContextLifecycleScheduledTaskRegistrar#scheduleTasks()&lt;/code&gt;的一个代码片段，如下&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;scheduleTasks&lt;/span&gt;() {
        ****
        ****
        &lt;span class=&quot;co&quot;&gt;// 如果不指定scheduler属性，则默认使用单线程池模型&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;taskScheduler&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;localExecutor&lt;/span&gt; = Executors.&lt;span class=&quot;fu&quot;&gt;newSingleThreadScheduledExecutor&lt;/span&gt;();
            &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;taskScheduler&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ConcurrentTaskScheduler&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;localExecutor&lt;/span&gt;);
        }
        ****

}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以观察下该定时器所包含的&lt;strong&gt;线程池对象&lt;/strong&gt;，调用的是&lt;strong&gt;JDK Executors&lt;/strong&gt;的静态方法&lt;code&gt;newSingleThreadScheduledExecutor()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;static&lt;/span&gt; ScheduledExecutorService &lt;span class=&quot;fu&quot;&gt;newSingleThreadScheduledExecutor&lt;/span&gt;() {
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; DelegatedScheduledExecutorService
            (&lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ScheduledThreadPoolExecutor(&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;));
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接去看&lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt;构造函数&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ScheduledThreadPoolExecutor(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; corePoolSize) {
        &lt;span class=&quot;co&quot;&gt;// 应用ThreadPoolExecutor的构造方法，这里很熟悉了&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(corePoolSize, Integer.&lt;span class=&quot;fu&quot;&gt;MAX_VALUE&lt;/span&gt;, &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;, NANOSECONDS,
              &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;DelayedWorkQueue&lt;/span&gt;());
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面看出，创建的线程池类型为&lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt;，其内部情况如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;核心线程-1个&lt;/li&gt;
&lt;li&gt;最大可创建线程-Integer.MAX_VALUE&lt;/li&gt;
&lt;li&gt;空闲线程活动时间-0秒&lt;/li&gt;
&lt;li&gt;线程队列-DelayedWorkQueue&lt;/li&gt;
&lt;li&gt;拒绝策略-AbortPolicy(抛异常信息)&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;定时器执行入口&quot;&gt;定时器执行入口&lt;/h3&gt;
&lt;p&gt;由前文得知，定时器会根据任务的类型执行&lt;code&gt;TaskScheduler&lt;/code&gt;接口的&lt;code&gt;scheduleAtFixedRate()&lt;/code&gt;或者&lt;code&gt;scheduleWithFixedDelay()&lt;/code&gt;抑或是&lt;code&gt;schedule()&lt;/code&gt;方法。为了方便理解，我们就拿&lt;code&gt;schedule()&lt;/code&gt;方法入手&lt;/p&gt;
&lt;h4 id=&quot;concurrenttaskschedulerschedule&quot;&gt;ConcurrentTaskScheduler#schedule()&lt;/h4&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ScheduledFuture&amp;lt;?&amp;gt; &lt;span class=&quot;fu&quot;&gt;schedule&lt;/span&gt;(Runnable task, Trigger trigger) {
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;// jdk1.8不支持，jdk1.7支持&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;enterpriseConcurrentScheduler&lt;/span&gt;) {
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;EnterpriseConcurrentTriggerScheduler&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;schedule&lt;/span&gt;(&lt;span class=&quot;fu&quot;&gt;decorateTask&lt;/span&gt;(task, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;), trigger);
            }
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                &lt;span class=&quot;co&quot;&gt;// ErrorHandler一般为LoggingErrorHandler，打印错误日志，也可以直接抛出异常&lt;/span&gt;
                ErrorHandler errorHandler = (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;errorHandler&lt;/span&gt; != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; ? &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;errorHandler&lt;/span&gt; : TaskUtils.&lt;span class=&quot;fu&quot;&gt;getDefaultErrorHandler&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;));
                &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ReschedulingRunnable&lt;/span&gt;(task, trigger, &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scheduledExecutor&lt;/span&gt;, errorHandler).&lt;span class=&quot;fu&quot;&gt;schedule&lt;/span&gt;();
            }
        }
        &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (RejectedExecutionException ex) {
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;TaskRejectedException&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;Executor [&quot;&lt;/span&gt; + &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scheduledExecutor&lt;/span&gt; + &lt;span class=&quot;st&quot;&gt;&quot;] did not accept task: &quot;&lt;/span&gt; + task, ex);
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由上述代码可知，最后包装为&lt;code&gt;ReschedulingRunnable&lt;/code&gt;类来调用&lt;code&gt;schedule()&lt;/code&gt;方法，OK，在此之前我们必须好好观察下&lt;code&gt;ReschedulingRunnable&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;reschedulingrunnable&quot;&gt;ReschedulingRunnable&lt;/h4&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li&gt;
&lt;p&gt;首先看下其UML类图&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1111874/201804/1111874-20180413141504578-1529531282.png&quot; alt=&quot;ReschedulingRunnable_UML&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;再看下其构造函数&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;co&quot;&gt;/**&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;*  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param delegate &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;ScheduledMethodRunnable.class Object&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;*  &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;*  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param trigger &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;一般为CronTrigger&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;*  &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;*  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param executor &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;ScheduledThreadPoolExecutor.class Object&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;*  &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;*  &lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;@param errorHandler &lt;/span&gt;&lt;span class=&quot;co&quot;&gt;一般为LoggingErrorHandler.class Object&lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;*  &lt;/span&gt;
&lt;span class=&quot;co&quot;&gt;*/&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ReschedulingRunnable&lt;/span&gt;(Runnable delegate, Trigger trigger, ScheduledExecutorService executor, ErrorHandler errorHandler) {
    &lt;span class=&quot;co&quot;&gt;// 由父类保存真实的Runnable对象&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;(delegate, errorHandler);
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;trigger&lt;/span&gt; = trigger;
    &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;executor&lt;/span&gt; = executor;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2.5&quot;&gt;
&lt;p&gt;然后直接看下&lt;code&gt;schedule()&lt;/code&gt;方法的代码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ScheduledFuture&amp;lt;?&amp;gt; &lt;span class=&quot;fu&quot;&gt;schedule&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;triggerContextMonitor&lt;/span&gt;) {
        &lt;span class=&quot;co&quot;&gt;// 计算下一次执行的时间&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scheduledExecutionTime&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;trigger&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;nextExecutionTime&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;triggerContext&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scheduledExecutionTime&lt;/span&gt; == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;) {
            &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
        }
        &lt;span class=&quot;co&quot;&gt;// 由上述的执行时间计算需要延迟的时间，精确到毫秒&lt;/span&gt;
        &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; initialDelay = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scheduledExecutionTime&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getTime&lt;/span&gt;() - System.&lt;span class=&quot;fu&quot;&gt;currentTimeMillis&lt;/span&gt;();
        &lt;span class=&quot;co&quot;&gt;// 由ScheduledThreadPoolExecutor执行定时任务&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;currentFuture&lt;/span&gt; = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;executor&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;schedule&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;, initialDelay, TimeUnit.&lt;span class=&quot;fu&quot;&gt;MILLISECONDS&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;12.5&quot;&gt;
&lt;p&gt;为了理解方便，我们不直接跳至&lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt;看源码，我们脑壳想想，肯定会调用其中的&lt;code&gt;run()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
    Date actualExecutionTime = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Date();
    &lt;span class=&quot;co&quot;&gt;// 调用委托类DelegatingErrorHandlingRunnable的run方法&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;();
    &lt;span class=&quot;co&quot;&gt;// 更新时间戳并回调shedule()方法使其能周期性执行任务&lt;/span&gt;
    Date completionTime = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; Date();
    &lt;span class=&quot;kw&quot;&gt;synchronized&lt;/span&gt; (&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;triggerContextMonitor&lt;/span&gt;) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;triggerContext&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;update&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;scheduledExecutionTime&lt;/span&gt;, actualExecutionTime, completionTime);
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (!&lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;currentFuture&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;isCancelled&lt;/span&gt;()) {
            &lt;span class=&quot;fu&quot;&gt;schedule&lt;/span&gt;();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接看下父类&lt;code&gt;DelegatingErrorHandlingRunnable#run()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;fu&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;() {
    &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;delegate&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;run&lt;/span&gt;();
    }
    &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (UndeclaredThrowableException ex) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;errorHandler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;handleError&lt;/span&gt;(ex.&lt;span class=&quot;fu&quot;&gt;getUndeclaredThrowable&lt;/span&gt;());
    }
    &lt;span class=&quot;kw&quot;&gt;catch&lt;/span&gt; (Throwable ex) {
        &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;errorHandler&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;handleError&lt;/span&gt;(ex);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述的代码则会去执行委托类&lt;code&gt;ScheduledMethodRunnable&lt;/code&gt;的&lt;code&gt;run()&lt;/code&gt;方法，脑壳想想就是通过&lt;strong&gt;JDK的method.invoke(Object obj,Object.. args)&lt;/strong&gt;方法执行我们&lt;em&gt;自定义写的业务&lt;/em&gt;。并由&lt;code&gt;errorHandler&lt;/code&gt;捕获异常进行善后，默认只是进行error级别的日志输出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对此类作下小结&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;执行定时器最终调用&lt;code&gt;ScheduledThreadPoolExecutor#schedule()&lt;/code&gt;方法，并返回&lt;code&gt;ScheduledFuture&lt;/code&gt;对象&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;其&lt;code&gt;run()&lt;/code&gt;方法最终会调用&lt;code&gt;ScheduledMethodRunnable&lt;/code&gt;对象来执行用户自定义的业务&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;其&lt;code&gt;run()&lt;/code&gt;方法也会调用&lt;code&gt;schedule()&lt;/code&gt;方法来&lt;strong&gt;重复执行第一点的步骤&lt;/strong&gt;以达到定时执行的效果&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;concurrenttaskscheduler如何保证单线程活跃执行任务&quot;&gt;ConcurrentTaskScheduler如何保证单线程活跃执行任务&lt;/h3&gt;
&lt;p&gt;我们从上文得知，其&lt;code&gt;corePoolSize=1&lt;/code&gt;，最终原因我们需要从&lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt;这个继承了&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;通用线程池类来了解&lt;/p&gt;
&lt;h4 id=&quot;scheduledthreadpoolexecutorschedule&quot;&gt;ScheduledThreadPoolExecutor#schedule()&lt;/h4&gt;
&lt;p&gt;直接看下源码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; ScheduledFuture&amp;lt;?&amp;gt; &lt;span class=&quot;fu&quot;&gt;schedule&lt;/span&gt;(Runnable command,
                                       &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; delay,
                                       TimeUnit unit) {
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (command == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; || unit == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
            &lt;span class=&quot;kw&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; NullPointerException();
        &lt;span class=&quot;co&quot;&gt;// 直接返回ScheduledFutureTask对象&lt;/span&gt;
        RunnableScheduledFuture&amp;lt;?&amp;gt; t = &lt;span class=&quot;fu&quot;&gt;decorateTask&lt;/span&gt;(command,
            &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; ScheduledFutureTask&amp;lt;Void&amp;gt;(command, &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;,
                                          &lt;span class=&quot;fu&quot;&gt;triggerTime&lt;/span&gt;(delay, unit)));
        &lt;span class=&quot;co&quot;&gt;// 延迟执行策略，继续追踪&lt;/span&gt;
        &lt;span class=&quot;fu&quot;&gt;delayedExecute&lt;/span&gt;(t);
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; t;
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继续追踪&lt;code&gt;delayedExecute()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;delayedExecute&lt;/span&gt;(RunnableScheduledFuture&amp;lt;?&amp;gt; task) {
        &lt;span class=&quot;co&quot;&gt;// 如果线程池关闭了则直接拒绝任务&lt;/span&gt;
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isShutdown&lt;/span&gt;())
            &lt;span class=&quot;fu&quot;&gt;reject&lt;/span&gt;(task);
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;// 优先将任务放入DelayQueue队列&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;super&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;getQueue&lt;/span&gt;().&lt;span class=&quot;fu&quot;&gt;add&lt;/span&gt;(task);
            &lt;span class=&quot;co&quot;&gt;// 保护策略，避免添加到队列后线程池关闭了，尝试删除任务&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;fu&quot;&gt;isShutdown&lt;/span&gt;() &amp;amp;&amp;amp;
                !&lt;span class=&quot;fu&quot;&gt;canRunInCurrentRunState&lt;/span&gt;(task.&lt;span class=&quot;fu&quot;&gt;isPeriodic&lt;/span&gt;()) &amp;amp;&amp;amp;
                &lt;span class=&quot;fu&quot;&gt;remove&lt;/span&gt;(task))
                task.&lt;span class=&quot;fu&quot;&gt;cancel&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
            &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt;
                &lt;span class=&quot;co&quot;&gt;// 确保已有线程在跑&lt;/span&gt;
                &lt;span class=&quot;fu&quot;&gt;ensurePrestart&lt;/span&gt;();
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继续追踪&lt;code&gt;ensurePrestart()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ensurePrestart&lt;/span&gt;() {
        &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; wc = &lt;span class=&quot;fu&quot;&gt;workerCountOf&lt;/span&gt;(ctl.&lt;span class=&quot;fu&quot;&gt;get&lt;/span&gt;());
        &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (wc &amp;lt; corePoolSize)
            &lt;span class=&quot;fu&quot;&gt;addWorker&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;true&lt;/span&gt;);
        &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (wc == &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
            &lt;span class=&quot;fu&quot;&gt;addWorker&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;kw&quot;&gt;false&lt;/span&gt;);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由上述的源码我们可以得知&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当线程池数小于执行的核心线程数&lt;code&gt;corePoolSize&lt;/code&gt;，则会创建线程，不管核心与否我们都可以得知&lt;strong&gt;一旦当前线程数&amp;gt;=核心线程数，则不会进行新线程的创建&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;ConcurrentTaskScheduler&lt;/code&gt;指定的&lt;code&gt;corePoolSize=1&lt;/code&gt;，由第一点得知，&lt;strong&gt;永远只有一个线程存在于线程池中&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;concurrenttaskscheduler如何保证任务延迟指定时长后被执行&quot;&gt;ConcurrentTaskScheduler如何保证任务延迟指定时长后被执行&lt;/h3&gt;
&lt;p&gt;为了避免大片的源码影响我们的阅读以及理解，博主只在此处指出&lt;code&gt;ConcurrentTaskScheduler&lt;/code&gt;所拥有&lt;code&gt;DelayQueue&lt;/code&gt;队列的&lt;code&gt;take()&lt;/code&gt;方法实现了延迟等待的效果&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; E &lt;span class=&quot;fu&quot;&gt;take&lt;/span&gt;() &lt;span class=&quot;kw&quot;&gt;throws&lt;/span&gt; InterruptedException {
        &lt;span class=&quot;dt&quot;&gt;final&lt;/span&gt; ReentrantLock lock = &lt;span class=&quot;kw&quot;&gt;this&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;lock&lt;/span&gt;;
        &lt;span class=&quot;co&quot;&gt;// 可重入同步锁，确保该方法线程安全&lt;/span&gt;
        lock.&lt;span class=&quot;fu&quot;&gt;lockInterruptibly&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
            &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; (;;) {
                E first = q.&lt;span class=&quot;fu&quot;&gt;peek&lt;/span&gt;();
                &lt;span class=&quot;co&quot;&gt;// 队列无任务，那就处于休眠等待&lt;/span&gt;
                &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (first == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                    available.&lt;span class=&quot;fu&quot;&gt;await&lt;/span&gt;();
                &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                    &lt;span class=&quot;co&quot;&gt;// 获取还需等待的时间&lt;/span&gt;
                    &lt;span class=&quot;dt&quot;&gt;long&lt;/span&gt; delay = first.&lt;span class=&quot;fu&quot;&gt;getDelay&lt;/span&gt;(NANOSECONDS);
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (delay &amp;lt;= &lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;)
                        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; q.&lt;span class=&quot;fu&quot;&gt;poll&lt;/span&gt;();
                    first = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;; &lt;span class=&quot;co&quot;&gt;// don't retain ref while waiting&lt;/span&gt;
                    &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (leader != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                        available.&lt;span class=&quot;fu&quot;&gt;await&lt;/span&gt;();
                    &lt;span class=&quot;kw&quot;&gt;else&lt;/span&gt; {
                        Thread thisThread = Thread.&lt;span class=&quot;fu&quot;&gt;currentThread&lt;/span&gt;();
                        leader = thisThread;
                        &lt;span class=&quot;kw&quot;&gt;try&lt;/span&gt; {
                            &lt;span class=&quot;co&quot;&gt;// 等待相应的时间后才可放行，采取的是Condition的机制&lt;/span&gt;
                            available.&lt;span class=&quot;fu&quot;&gt;awaitNanos&lt;/span&gt;(delay);
                        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
                            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (leader == thisThread)
                                leader = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;
                        }
                    }
                }
            }
        } &lt;span class=&quot;kw&quot;&gt;finally&lt;/span&gt; {
            &lt;span class=&quot;co&quot;&gt;// 唤醒等待的线程或者等待的条件&lt;/span&gt;
            &lt;span class=&quot;kw&quot;&gt;if&lt;/span&gt; (leader == &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; q.&lt;span class=&quot;fu&quot;&gt;peek&lt;/span&gt;() != &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;)
                available.&lt;span class=&quot;fu&quot;&gt;signal&lt;/span&gt;();
            lock.&lt;span class=&quot;fu&quot;&gt;unlock&lt;/span&gt;();
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码用到了可重入锁以及锁条件Condition的相关知识，后续会详细分析锁的相关知识。此处作下总结&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;锁为可重入锁，即相同的线程可再次获取该锁，不必等待阻塞&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;的&lt;code&gt;Condition&lt;/code&gt;机制，其类似于&lt;code&gt;Object.wait()&lt;/code&gt;机制&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;其调用&lt;code&gt;available.awaitNanos(delay);&lt;/code&gt;方法使当前线程休眠指定的时间后，最终会调用&lt;code&gt;q.poll()&lt;/code&gt;方法返回待处理的任务&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;em&gt;有兴趣的读者可自行阅读&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;的&lt;code&gt;runWorker()&lt;/code&gt;方法和&lt;code&gt;getTask()&lt;/code&gt;方法，便可以彻底理解&lt;code&gt;ScheduledThreadPoolExecutor&lt;/code&gt;的定时机制&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CocurrentTaskScheduler&lt;/code&gt;指定的单线程模型，会让任务按照&lt;code&gt;FIFO&lt;/code&gt;的机制有序的被执行，这个模型不大适合多个任务的同时定时执行，会导致任务执行有一定的延迟性。所以建议与spring结合时配置&lt;code&gt;task:scheduler&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Apr 2018 06:59:00 +0000</pubDate>
<dc:creator>南柯问天</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/question-sky/p/8819850.html</dc:identifier>
</item>
<item>
<title>Spring学习(1)——快速入门 - 我没有三颗心脏丶</title>
<link>http://www.cnblogs.com/wmyskxz/p/8820371.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmyskxz/p/8820371.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-34e6864b15c793ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;认识-spring-框架&quot;&gt;认识 Spring 框架&lt;/h2&gt;
&lt;p&gt;Spring 框架是 Java 应用最广的框架，它的&lt;strong&gt;成功来源于理念，而不是技术本身&lt;/strong&gt;，它的理念包括 &lt;strong&gt;IoC (Inversion of Control，控制反转)&lt;/strong&gt; 和 &lt;strong&gt;AOP(Aspect Oriented Programming，面向切面编程)&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;什么是-spring&quot;&gt;什么是 Spring：&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;Spring 是一个&lt;strong&gt;轻量级的 DI / IoC 和 AOP 容器的开源框架&lt;/strong&gt;，来源于 Rod Johnson 在其著作&lt;strong&gt;《Expert one on one J2EE design and development》&lt;/strong&gt;中阐述的部分理念和原型衍生而来。&lt;/li&gt;
&lt;li&gt;Spring 提倡以&lt;strong&gt;“最少侵入”&lt;/strong&gt;的方式来管理应用中的代码，这意味着我们可以随时安装或者卸载 Spring&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;适用范围：任何 Java 应用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Spring 的根本使命：简化 Java 开发&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;尽管 J2EE 能够赶上 Spring 的步伐，&lt;strong&gt;但 Spring 并没有停止前进，&lt;/strong&gt; Spring 继续在其他领域发展，而 J2EE 则刚刚开始涉及这些领域，或者还没有完全开始在这些领域的创新。&lt;strong&gt;移动开发、社交 API 集成、NoSQL 数据库、云计算以及大数据&lt;/strong&gt;都是 Spring 正在涉足和创新的领域。Spring 的前景依然会很美好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;spring-中常用术语&quot;&gt;Spring 中常用术语：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;框架：&lt;/strong&gt;是能&lt;strong&gt;完成一定功能&lt;/strong&gt;的&lt;strong&gt;半成品&lt;/strong&gt;。&lt;br/&gt;框架能够帮助我们完成的是：&lt;strong&gt;项目的整体框架、一些基础功能、规定了类和对象如何创建，如何协作等&lt;/strong&gt;，当我们开发一个项目时，框架帮助我们完成了一部分功能，我们自己再完成一部分，那这个项目就完成了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非侵入式设计：&lt;/strong&gt;&lt;br/&gt;从框架的角度可以理解为：&lt;strong&gt;无需继承框架提供的任何类&lt;/strong&gt;&lt;br/&gt;这样我们在更换框架时，之前写过的代码几乎可以继续使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;轻量级和重量级：&lt;/strong&gt;&lt;br/&gt;轻量级是相对于重量级而言的，&lt;strong&gt;轻量级一般就是非入侵性的、所依赖的东西非常少、资源占用非常少、部署简单等等&lt;/strong&gt;，其实就是&lt;strong&gt;比较容易使用&lt;/strong&gt;，而&lt;strong&gt;重量级正好相反&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JavaBean：&lt;/strong&gt;&lt;br/&gt;即&lt;strong&gt;符合 JavaBean 规范&lt;/strong&gt;的 Java 类&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;POJO：&lt;/strong&gt;即 &lt;strong&gt;Plain Old Java Objects，简单老式 Java 对象&lt;/strong&gt;&lt;br/&gt;它可以包含业务逻辑或持久化逻辑，但&lt;strong&gt;不担当任何特殊角色&lt;/strong&gt;且&lt;strong&gt;不继承或不实现任何其它Java框架的类或接口。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;注意：bean 的各种名称——虽然 Spring 用 bean 或者 JavaBean 来表示应用组件，但并不意味着 Spring 组件必须遵循 JavaBean 规范，一个 Spring 组件可以是任意形式的 POJO。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;容器：&lt;/strong&gt;&lt;br/&gt;在日常生活中容器就是一种盛放东西的器具，从程序设计角度看就是&lt;strong&gt;装对象的的对象&lt;/strong&gt;，因为存在&lt;strong&gt;放入、拿出等&lt;/strong&gt;操作，所以容器还要&lt;strong&gt;管理对象的生命周期&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;spring-的优势&quot;&gt;Spring 的优势&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;低侵入 / 低耦合&lt;/strong&gt; （降低组件之间的耦合度，实现软件各层之间的解耦）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;声明式事务管理&lt;/strong&gt;（基于切面和惯例）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方便集成其他框架&lt;/strong&gt;（如MyBatis、Hibernate）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;降低 Java 开发难度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Spring 框架中包括了 J2EE 三层的每一层的解决方案（一站式）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;spring-能帮我们做什么&quot;&gt;Spring 能帮我们做什么&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;①.Spring&lt;/strong&gt; 能帮我们根据配置文件&lt;strong&gt;创建及组装对象之间的依赖关系&lt;/strong&gt;。&lt;br/&gt;&lt;strong&gt;②.Spring 面向切面编程&lt;/strong&gt;能帮助我们&lt;strong&gt;无耦合的实现日志记录，性能统计，安全控制。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;③.Spring&lt;/strong&gt; 能&lt;strong&gt;非常简单的帮我们管理数据库事务&lt;/strong&gt;。&lt;br/&gt;&lt;strong&gt;④.Spring&lt;/strong&gt; 还&lt;strong&gt;提供了与第三方数据访问框架（如Hibernate、JPA）无缝集成&lt;/strong&gt;，而且自己也提供了一套&lt;strong&gt;JDBC访问模板&lt;/strong&gt;来方便数据库访问。&lt;br/&gt;&lt;strong&gt;⑤.Spring&lt;/strong&gt; 还提供与&lt;strong&gt;第三方Web（如Struts1/2、JSF）框架无缝集成&lt;/strong&gt;，而且自己也提供了一套&lt;strong&gt;Spring MVC&lt;/strong&gt;框架，来方便web层搭建。&lt;br/&gt;&lt;strong&gt;⑥.Spring&lt;/strong&gt; 能&lt;strong&gt;方便的与Java EE（如Java Mail、任务调度）整合&lt;/strong&gt;，与&lt;strong&gt;更多技术整合（比如缓存框架）&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;spring-的框架结构&quot;&gt;Spring 的框架结构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-a7c003d175bd41af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Data Access/Integration层&lt;/strong&gt;包含有JDBC、ORM、OXM、JMS和Transaction模块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Web层&lt;/strong&gt;包含了Web、Web-Servlet、WebSocket、Web-Porlet模块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AOP模块&lt;/strong&gt;提供了一个符合AOP联盟标准的面向切面编程的实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Core Container(核心容器)：&lt;/strong&gt;包含有Beans、Core、Context和SpEL模块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Test模块&lt;/strong&gt;支持使用JUnit和TestNG对Spring组件进行测试。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;spring-ioc-和-di-简介&quot;&gt;Spring IoC 和 DI 简介&lt;/h2&gt;
&lt;h4 id=&quot;iocinverse-of-control控制反转&quot;&gt;IoC：Inverse of Control（控制反转）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;读作&lt;strong&gt;“反转控制”&lt;/strong&gt;，更好理解，不是什么技术，而是一种&lt;strong&gt;设计思想&lt;/strong&gt;，就是&lt;strong&gt;将原本在程序中手动创建对象的控制权，交由Spring框架来管理。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;正控：&lt;/strong&gt;若要使用某个对象，需要&lt;strong&gt;自己去负责对象的创建&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反控：&lt;/strong&gt;若要使用某个对象，只需要&lt;strong&gt;从 Spring 容器中获取需要使用的对象，不关心对象的创建过程&lt;/strong&gt;，也就是把&lt;strong&gt;创建对象的控制权反转给了Spring框架&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;好莱坞法则：&lt;/strong&gt;Don’t call me ,I’ll call you&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;一个例子&quot;&gt;一个例子&lt;/h4&gt;
&lt;p&gt;控制反转显然是一个抽象的概念，我们举一个鲜明的例子来说明。&lt;/p&gt;
&lt;p&gt;在现实生活中，人们要用到一样东西的时候，第一反应就是去找到这件东西，比如想喝新鲜橙汁，在没有饮品店的日子里，最直观的做法就是：买果汁机、买橙子，然后准备开水。值得注意的是：这些都是你自己&lt;strong&gt;“主动”创造&lt;/strong&gt;的过程，也就是说一杯橙汁需要你自己创造。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-e460070aba0d8ab0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然而到了今时今日，由于饮品店的盛行，当我们想喝橙汁时，第一想法就转换成了找到饮品店的联系方式，通过电话等渠道描述你的需要、地址、联系方式等，下订单等待，过一会儿就会有人送来橙汁了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-5cebd72ddc461d18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请注意你并没有“主动”去创造橙汁&lt;/strong&gt;，橙汁是由饮品店创造的，而不是你，然而也完全达到了你的要求，甚至比你创造的要好上那么一些。&lt;/p&gt;
&lt;h4 id=&quot;编写第一个-spring-程序&quot;&gt;编写第一个 Spring 程序&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;新建一个空的 Java 项目，命名为【spring】&lt;/li&gt;
&lt;li&gt;新建一个名为【lib】的目录，并添加进必要的 jar 包，导入项目&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-dada8347bc57dc1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;仅仅为一部分，下方还有一些包&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在 Packge【pojo】下新建一个【Source】类：&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package pojo;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; Source {  
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String fruit;   &lt;span class=&quot;co&quot;&gt;// 类型&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String sugar;   &lt;span class=&quot;co&quot;&gt;// 糖分描述&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; String size;    &lt;span class=&quot;co&quot;&gt;// 大小杯    &lt;/span&gt;
    &lt;span class=&quot;co&quot;&gt;/* setter and getter */&lt;/span&gt;
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;在 【src】 目录下新建一个 【applicationContext.xml】 文件，通过 xml 文件配置的方式装配我们的 bean&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;

    &amp;lt;bean name=&quot;source&quot; class=&quot;pojo.Source&quot;&amp;gt;
        &amp;lt;property name=&quot;fruit&quot; value=&quot;橙子&quot;/&amp;gt;
        &amp;lt;property name=&quot;sugar&quot; value=&quot;多糖&quot;/&amp;gt;
        &amp;lt;property name=&quot;size&quot; value=&quot;超大杯&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在 Packge【test】下新建一个【TestSpring】类：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;package test;

import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import pojo.Source;

public class TestSpring {

    @Test
    public void test(){
        ApplicationContext context = new ClassPathXmlApplicationContext(
                new String[]{&quot;applicationContext.xml&quot;}
        );

        Source source = (Source) context.getBean(&quot;source&quot;);
        System.out.println(source.getFruit());
        System.out.println(source.getSugar());
        System.out.println(source.getSize());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;运行测试代码，可以正常拿到 xml 配置的 bean&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-f9923130c12739cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传统的方式：&lt;/strong&gt;&lt;br/&gt;通过new 关键字主动创建一个对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IOC方式：&lt;/strong&gt;&lt;br/&gt;对象的生命周期由Spring来管理，直接从Spring那里去获取一个对象。 IOC是反转控制 (Inversion Of Control)的缩写，就像控制权从本来在自己手里，交给了Spring。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-bb752724e10e0df2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;获取对象方式的转变&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;参考地址：&lt;a href=&quot;http://how2j.cn/k/spring/spring-ioc-di/87.html#nowhere&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;didependency-injection依赖注入&quot;&gt;DI：Dependency Injection（依赖注入）&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;指 Spring 创建对象的过程中，&lt;strong&gt;将对象依赖属性（简单值，集合，对象）通过配置设值给该对象&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;继续上面的例子&quot;&gt;继续上面的例子&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;在 Packge【pojo】下新建一个【JuiceMaker】类：&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package pojo;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; JuiceMaker {

    &lt;span class=&quot;co&quot;&gt;// 唯一关联了一个 Source 对象&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;private&lt;/span&gt; Source source = &lt;span class=&quot;kw&quot;&gt;null&lt;/span&gt;;

    &lt;span class=&quot;co&quot;&gt;/* setter and getter */&lt;/span&gt;

    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;fu&quot;&gt;makeJuice&lt;/span&gt;(){
        String juice = &lt;span class=&quot;st&quot;&gt;&quot;xxx用户点了一杯&quot;&lt;/span&gt; + source.&lt;span class=&quot;fu&quot;&gt;getFruit&lt;/span&gt;() + source.&lt;span class=&quot;fu&quot;&gt;getSugar&lt;/span&gt;() + source.&lt;span class=&quot;fu&quot;&gt;getSize&lt;/span&gt;();
        &lt;span class=&quot;kw&quot;&gt;return&lt;/span&gt; juice;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;在 xml 文件中配置 JuiceMaker 对象：&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;注意：&lt;/strong&gt;这里要使用 ref 来&lt;strong&gt;注入&lt;/strong&gt;另一个对象&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;

    &amp;lt;bean name=&quot;source&quot; class=&quot;pojo.Source&quot;&amp;gt;
        &amp;lt;property name=&quot;fruit&quot; value=&quot;橙子&quot;/&amp;gt;
        &amp;lt;property name=&quot;sugar&quot; value=&quot;多糖&quot;/&amp;gt;
        &amp;lt;property name=&quot;size&quot; value=&quot;超大杯&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean name=&quot;juickMaker&quot; class=&quot;pojo.JuiceMaker&quot;&amp;gt;
        &amp;lt;property name=&quot;source&quot; ref=&quot;source&quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在 【TestSpring】 中添加如下代码：&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode java&quot;&gt;
&lt;code class=&quot;sourceCode java&quot;&gt;&lt;span class=&quot;kw&quot;&gt;package test;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;import org.junit.Test;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.ApplicationContext;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import org.springframework.context.support.ClassPathXmlApplicationContext;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import pojo.JuiceMaker;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;import pojo.Source;&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kw&quot;&gt;class&lt;/span&gt; TestSpring {

    &lt;span class=&quot;fu&quot;&gt;@Test&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;test&lt;/span&gt;(){
        ApplicationContext context = &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;fu&quot;&gt;ClassPathXmlApplicationContext&lt;/span&gt;(
                &lt;span class=&quot;kw&quot;&gt;new&lt;/span&gt; String[]{&lt;span class=&quot;st&quot;&gt;&quot;applicationContext.xml&quot;&lt;/span&gt;}
        );

        Source source = (Source) context.&lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;source&quot;&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(source.&lt;span class=&quot;fu&quot;&gt;getFruit&lt;/span&gt;());
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(source.&lt;span class=&quot;fu&quot;&gt;getSugar&lt;/span&gt;());
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(source.&lt;span class=&quot;fu&quot;&gt;getSize&lt;/span&gt;());

        JuiceMaker juiceMaker = (JuiceMaker) context.&lt;span class=&quot;fu&quot;&gt;getBean&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;&quot;juickMaker&quot;&lt;/span&gt;);
        System.&lt;span class=&quot;fu&quot;&gt;out&lt;/span&gt;.&lt;span class=&quot;fu&quot;&gt;println&lt;/span&gt;(juiceMaker.&lt;span class=&quot;fu&quot;&gt;makeJuice&lt;/span&gt;());
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ol&gt;&lt;li&gt;运行测试代码：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-ce9088fbfe46301b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;IoC 和 DI 其实是同一个概念的不同角度描述，DI 相对 IoC 而言，&lt;strong&gt;明确描述了“被注入对象依赖 IoC 容器配置依赖对象”&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;ioc-如何实现的&quot;&gt;IoC 如何实现的&lt;/h4&gt;
&lt;p&gt;最后我们简单说说IoC是如何实现的。想象一下如果我们自己来实现这个依赖注入的功能，我们怎么来做？ 无外乎：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;读取标注或者配置文件，看看JuiceMaker依赖的是哪个Source，拿到类名&lt;/li&gt;
&lt;li&gt;使用反射的API，基于类名实例化对应的对象实例&lt;/li&gt;
&lt;li&gt;将对象实例，通过构造函数或者 setter，传递给 JuiceMaker&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们发现其实自己来实现也不是很难，Spring实际也就是这么做的。这么看的话其实IoC就是一个工厂模式的升级版！当然要做一个成熟的IoC框架，还是非常多细致的工作要做，Spring不仅提供了一个已经成为业界标准的Java IoC框架，还提供了更多强大的功能，所以大家就别去造轮子啦！希望了解IoC更多实现细节不妨通过学习Spring的源码来加深理解！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;引用地址：&lt;a href=&quot;https://www.tianmaying.com/tutorial/spring-ioc&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;spring-aop-简介&quot;&gt;Spring AOP 简介&lt;/h2&gt;
&lt;p&gt;如果说 IoC 是 Spring 的核心，那么面向切面编程就是 Spring 最为重要的功能之一了，在数据库事务中切面编程被广泛使用。&lt;/p&gt;
&lt;h4 id=&quot;aop-即-aspect-oriented-program-面向切面编程&quot;&gt;AOP 即 Aspect Oriented Program 面向切面编程&lt;/h4&gt;
&lt;p&gt;首先，在面向切面编程的思想里面，把功能分为核心业务功能，和周边功能。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所谓的核心业务&lt;/strong&gt;，比如登陆，增加数据，删除数据都叫核心业务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所谓的周边功能&lt;/strong&gt;，比如性能统计，日志，事务管理等等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;周边功能在 Spring 的面向切面编程AOP思想里，即被定义为切面&lt;/p&gt;
&lt;p&gt;在面向切面编程AOP的思想里面，核心业务功能和切面功能分别独立进行开发，然后把切面功能和核心业务功能 &quot;编织&quot; 在一起，这就叫AOP&lt;/p&gt;
&lt;h4 id=&quot;aop-的目的&quot;&gt;AOP 的目的&lt;/h4&gt;
&lt;p&gt;AOP能够将那些与业务无关，&lt;strong&gt;却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来&lt;/strong&gt;，便于&lt;strong&gt;减少系统的重复代码&lt;/strong&gt;，&lt;strong&gt;降低模块间的耦合度&lt;/strong&gt;，并&lt;strong&gt;有利于未来的可拓展性和可维护性&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;aop-当中的概念&quot;&gt;AOP 当中的概念：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;切入点（Pointcut）&lt;br/&gt;在哪些类，哪些方法上切入（&lt;strong&gt;where&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;通知（Advice）&lt;br/&gt;在方法执行的什么实际（&lt;strong&gt;when:&lt;/strong&gt;方法前/方法后/方法前后）做什么（&lt;strong&gt;what:&lt;/strong&gt;增强的功能）&lt;/li&gt;
&lt;li&gt;切面（Aspect）&lt;br/&gt;切面 = 切入点 + 通知，通俗点就是：&lt;strong&gt;在什么时机，什么地方，做什么增强！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;织入（Weaving）&lt;br/&gt;把切面加入到对象，并创建出代理对象的过程。（由 Spring 来完成）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;aop-编程&quot;&gt;AOP 编程&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;在 Packge【service】下创建 【ProductService】类：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;package service;

public class ProductService {
    public void doSomeService(){
        System.out.println(&quot;doSomeService&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在 xml 文件中装配该 bean：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;bean name=&quot;productService&quot; class=&quot;service.ProductService&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在【TestSpring】中编写测试代码，运行：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-c190e07d3a051a65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在 Packge【aspect】下准备日志切面 【LoggerAspect】类：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;package aspect;

import org.aspectj.lang.ProceedingJoinPoint;

public class LoggerAspect {
    
    public Object log(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println(&quot;start log:&quot; + joinPoint.getSignature().getName());
        Object object = joinPoint.proceed();
        System.out.println(&quot;end log:&quot; + joinPoint.getSignature().getName());
        return object;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在 xml 文件中声明业务对象和日志切面：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;
   http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
   http://www.springframework.org/schema/aop
   http://www.springframework.org/schema/aop/spring-aop-3.0.xsd
   http://www.springframework.org/schema/tx
   http://www.springframework.org/schema/tx/spring-tx-3.0.xsd
   http://www.springframework.org/schema/context
   http://www.springframework.org/schema/context/spring-context-3.0.xsd&quot;&amp;gt;

    &amp;lt;bean name=&quot;productService&quot; class=&quot;service.ProductService&quot; /&amp;gt;
    &amp;lt;bean id=&quot;loggerAspect&quot; class=&quot;aspect.LoggerAspect&quot;/&amp;gt;

    &amp;lt;!-- 配置AOP --&amp;gt;
    &amp;lt;aop:config&amp;gt;
        &amp;lt;!-- where：在哪些地方（包.类.方法）做增加 --&amp;gt;
        &amp;lt;aop:pointcut id=&quot;loggerCutpoint&quot;
                      expression=&quot;execution(* service.ProductService.*(..)) &quot;/&amp;gt;

        &amp;lt;!-- what:做什么增强 --&amp;gt;
        &amp;lt;aop:aspect id=&quot;logAspect&quot; ref=&quot;loggerAspect&quot;&amp;gt;
            &amp;lt;!-- when:在什么时机（方法前/后/前后） --&amp;gt;
            &amp;lt;aop:around pointcut-ref=&quot;loggerCutpoint&quot; method=&quot;log&quot;/&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;再次运行 TestSpring 中的测试代码，代码并没有改变，但是在业务方法运行之前和运行之后，都分别输出了日志信息：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-343746f0a4eb7ce0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.3290322580645&quot;&gt;
&lt;p&gt;欢迎转载，转载请注明出处！&lt;br/&gt;@我没有三颗心脏&lt;br/&gt;CSDN博客：&lt;a href=&quot;http://blog.csdn.net/qq939419061&quot; class=&quot;uri&quot;&gt;http://blog.csdn.net/qq939419061&lt;/a&gt;&lt;br/&gt;简书：&lt;a href=&quot;http://www.jianshu.com/u/a40d61a49221&quot; class=&quot;uri&quot;&gt;http://www.jianshu.com/u/a40d61a49221&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 13 Apr 2018 06:57:00 +0000</pubDate>
<dc:creator>我没有三颗心脏丶</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wmyskxz/p/8820371.html</dc:identifier>
</item>
<item>
<title>【Jhipster】升级/修改 数据库结构 - 东北小狐狸</title>
<link>http://www.cnblogs.com/hellxz/p/8819503.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hellxz/p/8819503.html</guid>
<description>&lt;h3&gt;前提&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;1、jhipster环境，jdk1.8，yeoman，node.js安装环境参考&lt;a href=&quot;https://www.jhipster.tech/installation/&quot; target=&quot;_blank&quot;&gt;官方wiki&lt;/a&gt;，环境问题参考&lt;a href=&quot;http://www.cnblogs.com/hellxz/p/8707028.html&quot; target=&quot;_blank&quot;&gt;我的博客&lt;/a&gt;，如果出现注册中心空白页，请参考&lt;a href=&quot;http://www.cnblogs.com/hellxz/p/8744158.html&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、首先需要启动jhipster基础服务，jhipster-registry-master，uaa，gateway，新建一个微服务应用，参考&lt;a href=&quot;https://www.jhipster.tech/creating-microservices/&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、创建实体，cd到微服务目录，自动创建数据库，参考&lt;a href=&quot;https://www.jhipster.tech/creating-an-entity/&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;，这里我们创建一个clazz实体，本文主要修改这个实体，有一个classNo int型，className Stirng型&lt;/p&gt;
&lt;p&gt;4、还需要知道how to 查询dev环境的数据库，比较简单，简单讲下：启动新建的微服务应用，查看端口号(这里以8081举例)，访问 localhost:8081/h2-console&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149398/201804/1149398-20180413114405291-22210066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149398/201804/1149398-20180413114432753-1171647693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中就是我们熟悉的查询界面了，接下来我们看看修改数据库&lt;/p&gt;

&lt;h3&gt;正文&lt;/h3&gt;
&lt;hr/&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;p&gt;鉴于jhipster升级/修改数据库结构有 三种方式，这里分开来介绍下&lt;/p&gt;

&lt;h3 id=&quot;使用entity-sub-generator-更新数据库&quot;&gt;使用entity sub-generator 更新数据库&lt;/h3&gt;
&lt;hr/&gt;
&lt;p&gt;1、cd到需要修改的微服务应用项目文件夹&lt;/p&gt;
&lt;p&gt;2、运行&lt;a href=&quot;https://jhipster.github.io/creating-an-entity/&quot; target=&quot;_blank&quot;&gt;entity sub-generator&lt;/a&gt;：命令 yo jhipster:entity 需要修改的实体名（第一次是创建，如果已经存在则提示修改）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149398/201804/1149398-20180413115934570-2025927465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、根据需要选择添加字段到这个实体，还是删除字段，这里没有修改，可以使用remove之后再添加，这里选添加做测试，添加一个名为class_desc，字段类型为String&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/1149398/201804/1149398-20180413125602866-2097734476.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不继续输入n，当然了如果想继续添加也无所谓，后边添加约束也可以不添加&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149398/201804/1149398-20180413130013562-2049439698.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时这个实体就修改完毕了，同时自动创建 changelog 到 &lt;code&gt;src/main/resources/config/liquibase/changelog&lt;/code&gt;目录中，并且自动添加到&lt;code&gt;src/main/resources/config/liquibase/master.xml&lt;/code&gt;文件中，这里就是liquibase等待这个项目启动去改变数据库的事了。&lt;/p&gt;
&lt;p&gt;这一切都是自动发生的，如果仅想简单的修改表结构，可以这样，也不用继续看下文了，启动项目即可&lt;/p&gt;

&lt;h3 id=&quot;手动编辑-changelog-更新数据库&quot;&gt;手动编辑 changelog 更新数据库&lt;/h3&gt;
&lt;hr/&gt;
&lt;p&gt;当然这种一看就是最麻烦的那种，其实不难&lt;/p&gt;
&lt;p&gt;1、修改jpa实体，比如我现在想为clazz实体和数据库添加一个字段class_test，类型为String&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149398/201804/1149398-20180413131018907-1892359589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、编写changelog文件&lt;/p&gt;
&lt;p&gt;创建 changelog文件到 &lt;code&gt;src/main/resources/config/liquibase/changelog&lt;/code&gt; 命名格式为yyyMMddHHmmss_描述.xml（可以少写一些），例如这里就用201804131020_modify_entity_Clazz.xml，参考&lt;a href=&quot;http://www.liquibase.org/documentation/changes/&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;databaseChangeLog
    &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:ext&lt;/span&gt;&lt;span&gt;=&quot;http://www.liquibase.org/xml/ns/dbchangelog-ext&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.5.xsd
                        http://www.liquibase.org/xml/ns/dbchangelog-ext http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-ext.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;now&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;now()&quot;&lt;/span&gt;&lt;span&gt; dbms&lt;/span&gt;&lt;span&gt;=&quot;h2&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;now&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;now()&quot;&lt;/span&gt;&lt;span&gt; dbms&lt;/span&gt;&lt;span&gt;=&quot;mysql&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;autoIncrement&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;floatType&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;float4&quot;&lt;/span&gt;&lt;span&gt; dbms&lt;/span&gt;&lt;span&gt;=&quot;postgresql, h2&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;floatType&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;float&quot;&lt;/span&gt;&lt;span&gt; dbms&lt;/span&gt;&lt;span&gt;=&quot;mysql, oracle, mssql&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
        add column class_test to table clazz
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;changeSet &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;&lt;strong&gt;&lt;span&gt;2018041320&lt;/span&gt;&lt;/strong&gt;&quot;&lt;/span&gt;&lt;span&gt; author&lt;/span&gt;&lt;span&gt;=&quot;hellxz&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;  &amp;lt;!--注意，这个id必须为&lt;span&gt;当前时间的值&lt;/span&gt;，格式为：yyyyMMddHHmmss,否则启动会报错--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;addColumn &lt;/span&gt;&lt;span&gt;tableName&lt;/span&gt;&lt;span&gt;=&quot;clazz&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;column &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;clazz_test&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;varchar(50)&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;addColumn&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;changeSet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　&amp;lt;!--下边的这些是增删改查的一些写法，可以参考一下 --&amp;gt;&lt;br/&gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
        modify table clazz column from class_no to class_id
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;  &amp;lt;changeSet id=&quot;201804131020&quot; author=&quot;hellxz&quot;&amp;gt;
        &amp;lt;renameColumn tableName=&quot;clazz&quot; oldColumnName=&quot;class_no&quot; newColumnName=&quot;class_id&quot;/&amp;gt;
    &amp;lt;/changeSet&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 
        modify table clazz column class_id from integer datetype to varchar
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;changeSet id=&quot;201804131105&quot; author=&quot;hellxz&quot;&amp;gt;
        &amp;lt;modifyDataType tableName=&quot;clazz&quot; columnName=&quot;class_id&quot; newDataType=&quot;varchar(50)&quot; schemaName=&quot;public&quot;/&amp;gt;
    &amp;lt;/changeSet&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
        drop column class_id from table clazz
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;changeSet id=&quot;201804131113&quot; author=&quot;hellxz&quot;&amp;gt;
        &amp;lt;dropColumn tableName=&quot;clazz&quot; columnName=&quot;class_id&quot;/&amp;gt;
    &amp;lt;/changeSet&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
        add new column class_info datatype varchar
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; &amp;lt;changeSet id=&quot;201804131141&quot; author=&quot;hellxz&quot;&amp;gt;
        &amp;lt;addColumn tableName=&quot;clazz&quot;&amp;gt;
            &amp;lt;column name=&quot;class_id&quot; type=&quot;varchar(255)&quot;/&amp;gt;
        &amp;lt;/addColumn&amp;gt;
    &amp;lt;/changeSet&amp;gt; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;databaseChangeLog&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、将上边修改的文件路径添加 changelog 到 &lt;code&gt;src/main/resources/config/liquibase/master.xml&lt;/code&gt;中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;databaseChangeLog
    &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.liquibase.org/xml/ns/dbchangelog&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.5.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; jhipster-needle-liquibase-add-changelog - JHipster will add liquibase changelogs here &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; jhipster-needle-liquibase-add-constraints-changelog - JHipster will add liquibase constraints changelogs here &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;strong&gt;&lt;span&gt;&amp;lt;include file=&quot;config/liquibase/changelog/201804131020_modify_entity_Clazz.xml&quot; relativeToChangelogFile=&quot;false&quot;/&amp;gt;&lt;/span&gt;&lt;/strong&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;databaseChangeLog&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、重新启动微服务应用，如果没有error，请进入h2-console查看，&lt;/p&gt;
&lt;p&gt;下边是正常情况下的数据库情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149398/201804/1149398-20180413133806679-1819070246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;使用Maven liquibase:diff更新数据库&lt;/h3&gt;
&lt;hr/&gt;&lt;h3 id=&quot;使用maven-liquibasediff更新数据库&quot;&gt; &lt;/h3&gt;


&lt;ul&gt;&lt;li&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译程序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;问题解决&lt;/h3&gt;
&lt;hr/&gt;
&lt;p&gt;1、启动项目输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149398/201804/1149398-20180413132735266-1348925473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进入刚才修改的changelog文件中，请修改刚才写的id为当前时间值yyyyMMddHHmmss，分钟不能差，秒也可以不写，重启应用试验&lt;/li&gt;
&lt;li&gt;注意如果修改之后还是这样，请查看&lt;code&gt;master.xml&lt;/code&gt;中是否include其他时间已经过期的文件，注释掉即可&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、出现如下图问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149398/201804/1149398-20180413134923060-595232329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个问题是说之前我们已经创建了这个字段，进入h2-console查看，的确存在&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1149398/201804/1149398-20180413135200047-1419096146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、对于每次启动都会报错这个问题，我的建议是注释掉&lt;code&gt;master.xml&lt;/code&gt;中引入的文件&lt;/p&gt;

&lt;p&gt;&lt;span&gt;声明：本博文为本人实际操作经验写成，转载请注明出处，或者别让我看到&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Apr 2018 05:57:00 +0000</pubDate>
<dc:creator>东北小狐狸</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hellxz/p/8819503.html</dc:identifier>
</item>
<item>
<title>RTKLIB源码解析（一）——单点定位(pntpos.c) - 塔奇克马敲代码</title>
<link>http://www.cnblogs.com/taqikema/p/8819798.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taqikema/p/8819798.html</guid>
<description>&lt;p&gt;标签： GNSS RTKLIB 单点定位&lt;/p&gt;
&lt;p&gt;前段时间一直忙着写毕业论文，所以也没有太多时间来阅读 RTKLIB源码，最近好歹把 pntpos中的相关代码看了一遍，知道了 RTKLIB是如何实现单点伪距定位的。这里把每一个函数都做成了小卡片的形式，每个函数大都包含函数签名、所在文件、功能说明、参数说明、处理过程、注意事项和我的疑惑这几个部分，介绍了阅读代码时我自己的看法和疑惑。所以希望诸位看官能帮忙解答我的疑惑，与我交流，也希望能帮助后来也有需要阅读 RTKLIB源码的人，给他们多提供一份思路。总而言之，既为人，也为己。&lt;br/&gt;这份文档是使用 Cmd Markdown完成的，在作业部落上其格式显式的非常完整，但是在博客园中&lt;code&gt;目录&lt;/code&gt;、&lt;code&gt;代码块&lt;/code&gt;和&lt;code&gt;流程图&lt;/code&gt;似乎都没有显示出来，所以这里也贴上本文在作业部落上的链接&lt;a href=&quot;https://www.zybuluo.com/taqikema/note/1101465&quot;&gt;RTKLIB源码解析（一）——单点定位(pntpos.c)&lt;/a&gt;，对格式“零容忍”的同学请移步那里。&lt;/p&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;pntpos&quot;&gt;pntpos&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; pntpos (&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; obsd_t *obs, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; nav_t *nav, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; prcopt_t *opt, sol_t *sol,
            &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel, ssat_t *ssat, &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *msg)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;&lt;strong&gt;所在文件&lt;/strong&gt;：pntpos.c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：依靠多普勒频移测量值和伪距来进行单点定位，给出接收机的位置、速度和钟差&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;函数参数，&lt;span class=&quot;dv&quot;&gt;8&lt;/span&gt;个：
obsd_t     *obs      I     observation data
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;        n         I     number of observation data
nav_t      *nav      I     navigation data
prcopt_t   *opt      I     processing options
sol_t      *sol      IO    solution
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;     *azel     IO    azimuth/elevation angle (rad) (NULL: no output)
ssat_t     *ssat     IO    satellite status              (NULL: no output)
&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;       *msg      O     error message &lt;span class=&quot;kw&quot;&gt;for&lt;/span&gt; error exit
返回类型:
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;                  O     (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:ok,&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:error)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;调用关系&lt;/strong&gt;：&lt;br/&gt;&lt;code&gt;如无特别说明，本文所出现的流程图中，纵向代表时间上的先后调用顺序，横向代表层次上的逐级调用顺序。&lt;/code&gt;&lt;br/&gt;```flow&lt;br/&gt;st=&amp;gt;start: pntpos&lt;br/&gt;satposs_=&amp;gt;operation: satposs&lt;br/&gt;estpos_=&amp;gt;operation: estpos&lt;br/&gt;raim_fde_=&amp;gt;operation: raim_fde&lt;br/&gt;estvel_=&amp;gt;operation: estvel&lt;br/&gt;e=&amp;gt;end: end&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;st-&amp;gt;satposs_-&amp;gt;estpos_-&amp;gt;raim_fde_-&amp;gt;estvel_-&amp;gt;e&lt;br/&gt;```&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#pntpos&quot;&gt;pntpos&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satposs&quot;&gt;satposs&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#estpos&quot;&gt;estpos&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#raim_fde&quot;&gt;raim_fde&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#estvel&quot;&gt;estvel&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;检查卫星个数是否大于 0&lt;/li&gt;
&lt;li&gt;当处理选项 &lt;code&gt;opt&lt;/code&gt;中的模式不是单点模式时，电离层校正采用 &lt;code&gt;Klobuchar模型&lt;/code&gt;，对流层校正则采用 &lt;code&gt;Saastamoinen模型&lt;/code&gt;；相反，当其为单点模式时，对输入参数 &lt;code&gt;opt&lt;/code&gt;不做修改。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satposs&quot;&gt;satposs&lt;/a&gt;函数，按照所观测到的卫星顺序计算出每颗卫星的位置、速度、{钟差、频漂}。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#estpos&quot;&gt;estpos&lt;/a&gt;函数，通过伪距实现绝对定位，计算出接收机的位置和钟差，顺带返回实现定位后每颗卫星的{方位角、仰角}、定位时有效性、定位后伪距残差。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#raim_fde&quot;&gt;raim_fde&lt;/a&gt;函数，对上一步得到的定位结果进行接收机自主正直性检测（&lt;code&gt;RAIM&lt;/code&gt;）。通过再次使用 &lt;code&gt;vsat&lt;/code&gt;数组，这里只会在对定位结果有贡献的卫星数据进行检测。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#estvel&quot;&gt;estvel&lt;/a&gt;函数，依靠多普勒频移测量值计算接收机的速度。这里只使用通过了上一步 &lt;code&gt;RAIM_FDE&lt;/code&gt;操作的卫星数据，所以对于计算出的速度就没有再次进行 &lt;code&gt;RAIM&lt;/code&gt;了。&lt;/li&gt;
&lt;li&gt;首先将 &lt;code&gt;ssat_t&lt;/code&gt;结构体数组的 vs(定位时有效性)、azel（方位角、仰角）、resp(伪距残余)、resc(载波相位残余)和 snr(信号强度)都置为 0，然后再将实现定位后的 azel、snr赋予 &lt;code&gt;ssat_t&lt;/code&gt;结构体数组，而 vs、resp则只赋值给那些对定位有贡献的卫星，没有参与定位的卫星，这两个属性值为 0。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;这里只计算了接收机的钟差，而没有计算接收机的频漂，原因在于 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#estvel&quot;&gt;estvel&lt;/a&gt;函数中虽然计算得到了接收机频漂，但并没有将其输出到 &lt;code&gt;sol_t:dtr&lt;/code&gt;中。&lt;/li&gt;
&lt;li&gt;C语言中用 &lt;code&gt;malloc&lt;/code&gt;申请的内存需要自己调用 &lt;code&gt;free&lt;/code&gt;来予以回收，源码中的 &lt;code&gt;mat&lt;/code&gt;、&lt;code&gt;imat&lt;/code&gt;、&lt;code&gt;zeros&lt;/code&gt;等函数都只是申请了内存，并没有进行内存的回收，&lt;strong&gt;在使用这些函数时，用户必须自己调用 &lt;code&gt;free&lt;/code&gt;来回收内存&lt;/strong&gt;！源码中将使用这些函数的代码放置在同一行，在调用函数结尾处也统一进行内存回收，位置较为明显，不致于轻易忘记。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;源码中将 &lt;code&gt;obs[0].time&lt;/code&gt;作为星历选择时间传递给 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satposs&quot;&gt;satposs&lt;/a&gt;函数，这样对于每一颗观测卫星，都要使用第一颗观测卫星的数据接收时间作为选择星历的时间标准。是否应该每颗卫星都使用自己的观测时间？或者应该使用每颗卫星自己的信号发射时间？，还是说这点差别对选择合适的星历其实没有关系？&lt;/li&gt;
&lt;li&gt;这里规定能够执行 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#raim_fde&quot;&gt;raim_fde&lt;/a&gt;函数的前提是数目大于等于 6，感觉不是只要大于等于 5就可以了吗？&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;satposs&quot;&gt;satposs&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; satposs(gtime_t teph, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; obsd_t *obs, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; nav_t *nav,
             &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ephopt, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *rs, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *dts, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *var, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *svh)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st_-&amp;gt;ephclk1-&amp;gt;satpos_-&amp;gt;cond&lt;br/&gt;cond(no)-&amp;gt;e&lt;br/&gt;cond(yes,rigth)-&amp;gt;ephclk2-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satposs&quot;&gt;satposs&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ephclk&quot;&gt;ephclk&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satpos&quot;&gt;satpos&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;按照观测数据的顺序，首先将将当前观测卫星的 rs、dts、var和svh数组的元素置 0。&lt;/li&gt;
&lt;li&gt;通过判断某一频率下信号的伪距是否为 0，来得到此时所用的频率个数。注意，频率个数不能大于 &lt;code&gt;NFREQ&lt;/code&gt;（默认为 3）。&lt;/li&gt;
&lt;li&gt;用数据接收时间减去伪距信号传播时间，得到卫星信号的发射时间。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ephclk&quot;&gt;ephclk&lt;/a&gt;函数，由广播星历计算出当前观测卫星的钟差。注意，此时的钟差是没有考虑相对论效应和 TGD的。&lt;/li&gt;
&lt;li&gt;用 3中的信号发射时间减去 4中的钟偏，得到 GPS时间下的卫星信号发射时间。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satpos&quot;&gt;satpos&lt;/a&gt;函数，计算信号发射时刻卫星的 P(ecef,m)、V(ecef,m/s)、C((s|s/s))。注意，这里计算出的钟差是考虑了相对论效应的了，只是还没有考虑 TGD。&lt;/li&gt;
&lt;li&gt;如果由 6中计算出的钟偏为 0，就再次调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ephclk&quot;&gt;ephclk&lt;/a&gt;函数，将其计算出的卫星钟偏作为最终的结果。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ephclk&quot;&gt;ephclk&lt;/a&gt;函数计算的钟偏是没有考虑相对论和 TGD的，而 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satpos&quot;&gt;satpos&lt;/a&gt;函数考虑了相对论，没有考虑 TGD。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;对于处理过程中的第3步，数据接收时间减去伪距信号传播时间，这里的数据接收时间应该是有接收机得到的，本身应该是包含接收机钟差的，所以最终得到的信号发射时间应该也是不准确的。难道说接收机钟差较小，在此时可以忽略不计？&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ephclk&quot;&gt;ephclk&lt;/a&gt;函数最终是通过调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#eph2clk&quot;&gt;eph2clk&lt;/a&gt;来计算卫星钟偏的，但对于后者，我有问题。&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#eph2clk_q&quot;&gt;见 eph2clk处我的疑惑&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;为什么要进行 7中操作？&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;estpos&quot;&gt;estpos&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; estpos(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; obsd_t *obs, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *rs, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *dts,
           &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *vare, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *svh, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; nav_t *nav,
           &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; prcopt_t *opt, sol_t *sol, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *vsat,
           &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *resp, &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *msg)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;rescode_-&amp;gt;lsq_-&amp;gt;valsol_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#estpos&quot;&gt;estpos&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#rescode&quot;&gt;rescode&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#lsq&quot;&gt;lsq&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#valsol&quot;&gt;valsol&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;将 &lt;code&gt;sol-&amp;gt;rr&lt;/code&gt;的前 3项赋值给 x数组。&lt;/li&gt;
&lt;li&gt;开始迭代定位计算，首先调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#rescode&quot;&gt;rescode&lt;/a&gt;函数，计算在当前接收机位置和钟差值的情况下，定位方程的右端部分 &lt;code&gt;v(nv\*1)&lt;/code&gt;、几何矩阵 &lt;code&gt;H(NX*nv)&lt;/code&gt;、此时所得的伪距残余的方差 &lt;code&gt;var&lt;/code&gt;、所有观测卫星的 &lt;code&gt;azel&lt;/code&gt;{方位角、仰角}、定位时有效性 &lt;code&gt;vsat&lt;/code&gt;、定位后伪距残差 &lt;code&gt;resp&lt;/code&gt;、参与定位的卫星个数 &lt;code&gt;ns&lt;/code&gt;和方程个数 &lt;code&gt;nv&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;确定方程组中方程的个数要大于未知数的个数。&lt;/li&gt;
&lt;li&gt;以伪距残余的标准差的倒数作为权重，对 H和 v分别左乘权重对角阵，得到加权之后的 H和 v。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#lsq&quot;&gt;lsq&lt;/a&gt;函数，根据 $\Delta x=(HH^T)^{-1}Hv$和 $Q=(HH^T)^{-1}$，得到当前 x的修改量和定位误差协方差矩阵中的权系数阵。&lt;/li&gt;
&lt;li&gt;将 5中求得的 x加入到当前 x值中，得到更新之后的 x值。&lt;/li&gt;
&lt;li&gt;如果 5中求得的修改量小于截断因子(目前是1e-4)，则将 6中得到的 x值作为最终的定位结果，对 &lt;code&gt;sol&lt;/code&gt;的相应参数赋值，之后再调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#valsol&quot;&gt;valsol&lt;/a&gt;函数确认当前解是否符合要求（伪距残余小于某个 $\chi^2$值和 &lt;code&gt;GDOP&lt;/code&gt;小于某个门限值）。否则，进行下一次循环。&lt;/li&gt;
&lt;li&gt;如果超过了规定的循环次数，则输出发散信息后，返回 0。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;关于第 1步，如果是第一次定位，即输入的 &lt;code&gt;sol&lt;/code&gt;为空，则 x初值为 0；如果之前有过定位，则通过 1中操作可以将上一历元的定位值作为该历元定位的初始值。&lt;/li&gt;
&lt;li&gt;关于定位方程，书中的写法如下：&lt;br/&gt;$$&lt;br/&gt;G \begin{bmatrix} \Delta x \ \Delta y \ \Delta z \ \delta t_u \end{bmatrix} = b&lt;br/&gt;$$&lt;br/&gt;其中，&lt;br/&gt;$$&lt;br/&gt;G = \begin{bmatrix}&lt;br/&gt;-e^1_x &amp;amp; -e^1_y &amp;amp; -e^1_z &amp;amp; 1 \&lt;br/&gt;-e^2_x &amp;amp; -e^2_y &amp;amp; -e^2_z &amp;amp; 1 \&lt;br/&gt;\cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots \&lt;br/&gt;-e^N_x &amp;amp; -e^N_y &amp;amp; -e^N_z &amp;amp; 1&lt;br/&gt;\end{bmatrix}&lt;br/&gt;\qquad&lt;br/&gt;b = \begin{bmatrix}&lt;br/&gt;\rho_r^1-(r_r^1+c·dt_r-c·dt_s^1+I^1+T^1) \&lt;br/&gt;\rho_r^2-(r_r^2+c·dt_r-c·dt_s^2+I^2+T^2) \&lt;br/&gt;\cdots \&lt;br/&gt;\rho_r^N-(r_r^N+c·dt_r-c·dt_s^N+I^N+T^N)&lt;br/&gt;\end{bmatrix}&lt;br/&gt;$$&lt;br/&gt;而 RTKLIB中采用的方程是下面这样的（这里先假设未知数的个数为 4）：&lt;br/&gt;$$&lt;br/&gt;H^T \begin{bmatrix} \Delta x \ \Delta y \ \Delta z \ \delta t_u \end{bmatrix} = b&lt;br/&gt;$$&lt;br/&gt;其中，$H=G^T$。&lt;/li&gt;
&lt;li&gt;关于加权最小二乘，这里的权重值是对角阵，这是建立在假设不同测量值的误差之间是彼此独立的；另外，这个&lt;strong&gt;权重值并不单是距测量误差的，而是方程右端 &lt;code&gt;b&lt;/code&gt;整体的测量误差&lt;/strong&gt;。最后，大部分资料上这里都是把权重矩阵 &lt;code&gt;W&lt;/code&gt;保留到方程的解的表达式当中，而&lt;strong&gt;这里是直接对 H和 v分别左乘权重对角阵，得到加权之后的 H和 v，其表示形式像是没有加权一样&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果某次迭代过程中步长小于门限值(1e-4)，但经 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#valsol&quot;&gt;valsol&lt;/a&gt;函数检验后该解无效，则会直接返回 0，并不会再进行下一次迭代计算。&lt;/li&gt;
&lt;li&gt;因为该函数有两个返回路径，而且又调用了 &lt;code&gt;mat&lt;/code&gt;函数来构建矩阵，所以在两个返回路径处都需要调用 &lt;code&gt;free&lt;/code&gt;函数来回收内存。&lt;/li&gt;
&lt;li&gt;源码中的 dtr实际上单位是 m，是乘以了光速之后的。&lt;/li&gt;
&lt;li&gt;在对 &lt;code&gt;sol&lt;/code&gt;结构体赋值时，并没有直接将接收机钟差 dtr赋值给 &lt;code&gt;sol_dtr&lt;/code&gt;，而是通过在 &lt;code&gt;sol&lt;/code&gt;中存储的是减去接收机钟差后的信号观测时间，来讲该信息包括到 &lt;code&gt;sol&lt;/code&gt;中了。&lt;/li&gt;
&lt;li&gt;源码中定位方程的个数 &lt;code&gt;nv&lt;/code&gt;要大于有效观测卫星的个数 &lt;code&gt;ns&lt;/code&gt;，这里为了防止亏秩，似乎又加了 3个未知数和观测方程。&lt;/li&gt;
&lt;li&gt;在每一次重新调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#rescode&quot;&gt;rescode&lt;/a&gt;函数时，其内部并没有对 v、H和 var清零处理，所以当方程数变少时，可能会存在尾部仍保留上一次数据的情况，但是因为数组相乘时都包含所需计算的长度，所以这种情况并不会对计算结果造成影响。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-2&quot;&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;$\color{red}{1. 这里的 NX=7不明白，应该只有 4个未知数的啊！}$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;raim_fde&quot;&gt;raim_fde&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;21&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; raim_fde(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; obsd_t *obs, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *rs,
             &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *dts, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *vare, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *svh,
             &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; nav_t *nav, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; prcopt_t *opt, sol_t *sol,
             &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *vsat, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *resp, &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *msg)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;estpos_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#raim_fde&quot;&gt;raim_fde&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#estpos&quot;&gt;estpos&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;关于观测卫星数目的循环，每次舍弃一颗卫星，计算使用余下卫星进行定位的定位值。&lt;/li&gt;
&lt;li&gt;舍弃一颗卫星后，将剩下卫星的数据复制到一起，调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#estpos&quot;&gt;estpos&lt;/a&gt;函数，计算使用余下卫星进行定位的定位值。&lt;/li&gt;
&lt;li&gt;累加使用当前卫星实现定位后的伪距残差平方和与可用微信数目，如果 &lt;code&gt;nvsat&amp;lt;5&lt;/code&gt;，则说明当前卫星数目过少，无法进行 &lt;code&gt;RAIM_FDE&lt;/code&gt;操作。&lt;/li&gt;
&lt;li&gt;计算伪距残差平方和的标准平均值，如果大于 &lt;code&gt;rms&lt;/code&gt;，则说明当前定位结果更合理，将 &lt;code&gt;stat&lt;/code&gt;置为 1，重新更新 &lt;code&gt;sol&lt;/code&gt;、&lt;code&gt;azel&lt;/code&gt;、&lt;code&gt;vsat&lt;/code&gt;(当前被舍弃的卫星，此值置为0)、&lt;code&gt;resp&lt;/code&gt;等值，并将当前的 &lt;code&gt;rms_e&lt;/code&gt;更新到 `rms'中。&lt;/li&gt;
&lt;li&gt;继续弃用下一颗卫星，重复 2-4操作。总而言之，将同样是弃用一颗卫星条件下，伪距残差标准平均值最小的组合所得的结果作为最终的结果输出。&lt;/li&gt;
&lt;li&gt;如果 stat不为 0，则说明在弃用卫星的前提下有更好的解出现，输出信息，指出弃用了哪科卫星。&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;free&lt;/code&gt;函数回收相应内存。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;使用了 &lt;code&gt;mat&lt;/code&gt;和 &lt;code&gt;malloc&lt;/code&gt;函数后要使用 &lt;code&gt;free&lt;/code&gt;函数来回收内存。&lt;/li&gt;
&lt;li&gt;源码中有很多关于 i、j、k的循环。其中，i表示最外面的大循环，每次将将第 i颗卫星舍弃不用，这是通过 &lt;code&gt;if (j==i) continue&lt;/code&gt;实现的；j表示剩余使用的卫星的循环，每次进行相应数据的赋值；k表示参与定位的卫星的循环，与 j一起使用。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;这里执行 &lt;code&gt;RAIM&lt;/code&gt;至少要有 6颗可用卫星，可是我感觉 5颗就够了呀！&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;estvel&quot;&gt;estvel&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; estvel(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; obsd_t *obs, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *rs, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *dts,
            &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; nav_t *nav, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; prcopt_t *opt, sol_t *sol,
            &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *vsat)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;resdop_-&amp;gt;lsq_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#estvel&quot;&gt;estvel&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#resdop&quot;&gt;resdop&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#lsq&quot;&gt;lsq&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;在最大迭代次数限制内，调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#resdop&quot;&gt;resdop&lt;/a&gt;，计算定速方程组左边的几何矩阵和右端的速度残余，返回定速时所使用的卫星数目。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#lsq&quot;&gt;lsq&lt;/a&gt;函数，解出 {速度、频漂}的步长，累加到 x中。&lt;/li&gt;
&lt;li&gt;检查当前计算出的步长的绝对值是否小于 &lt;code&gt;1E-6&lt;/code&gt;。是，则说明当前解已经很接近真实值了，将接收机三个方向上的速度存入到 &lt;code&gt;sol_t.rr&lt;/code&gt;中；否，则进行下一次循环。&lt;/li&gt;
&lt;li&gt;执行完所有迭代次数，使用 &lt;code&gt;free&lt;/code&gt;回收内存。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;最终向 &lt;code&gt;sol_t&lt;/code&gt;类型存储定速解时，并没有存储所计算出的接收器时钟频漂。&lt;/li&gt;
&lt;li&gt;这里不像定位时，初始值可能为上一历元的位置(从 sol中读取初始值)，定速的初始值直接给定为 0.&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;ephclk&quot;&gt;ephclk&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ephclk(gtime_t time, gtime_t teph, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sat, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; nav_t *nav, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *dts)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;satsys_-&amp;gt;seleph_-&amp;gt;eph2clk_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ephclk&quot;&gt;ephclk&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satsys&quot;&gt;satsys&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#seleph&quot;&gt;seleph&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#eph2clk&quot;&gt;eph2clk&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;首先调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satsys&quot;&gt;satsys&lt;/a&gt;函数，根据卫星编号确定该卫星所属的导航系统和该卫星在该系统中的 &lt;code&gt;PRN&lt;/code&gt;编号。&lt;/li&gt;
&lt;li&gt;对于 GPS导航系统，调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#seleph&quot;&gt;seleph&lt;/a&gt;函数来选择 &lt;code&gt;toe&lt;/code&gt;值与星历选择时间标准 &lt;code&gt;teph&lt;/code&gt;最近的那个星历。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#eph2clk&quot;&gt;eph2clk&lt;/a&gt;函数，通过广播星历和信号发射时间计算出卫星钟差。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;此时计算出的卫星钟偏是没有考虑相对论效应和 TGD的。&lt;/li&gt;
&lt;li&gt;目前我还只关心 RTKLIB对于 GPS导航所进行的数据处理，所以这里在选择星历和计算钟差时都&lt;strong&gt;只介绍与 GPS系统有关的函数&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#eph2clk_q&quot;&gt;见 eph2clk处&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;satpos&quot;&gt;satpos&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; satpos(gtime_t time, gtime_t teph, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sat, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ephopt, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; nav_t *nav, 
           &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *rs, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *dts, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *var, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *svh)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;ephpos_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satpos&quot;&gt;satpos&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ephpos&quot;&gt;ephpos&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;判断星历选项的值，如果是 &lt;code&gt;EPHOPT_BRDC&lt;/code&gt;，调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ephpos&quot;&gt;ephpos&lt;/a&gt;函数，根据广播星历计算出算信号发射时刻卫星的 P、V、C&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;此时计算出的卫星钟差考虑了相对论，还没有考虑 TGD。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目前还只阅读了如何从广播星历中计算卫星 P、V、C的代码&lt;/strong&gt;，关于如何从精密星历中计算，等对精密星历的理论背景有了更多了解之后再予以添加。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;satsys&quot;&gt;satsys&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; satsys(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sat, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *prn)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所在文件&lt;/strong&gt;：rtkcmn.c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：根据卫星编号确定该卫星所属的导航系统和该卫星在该系统中的 &lt;code&gt;PRN&lt;/code&gt;编号&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;函数参数，&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;个：
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;    sat       I   satellite number (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;-MAXSAT)
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;    *prn      IO  satellite prn/slot number (NULL: no output)
返回类型:
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;         satellite system (SYS_GPS,SYS_GLO,...)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;为处理意外情况（卫星号不在 &lt;code&gt;1-MAXSAT&lt;/code&gt;之内），先令卫星系统为 &lt;code&gt;SYS_NONE&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;按照 TRKLIB中定义相应宏的顺序来判断是否是 GPS、GLO、GAL系统等，判断标准是将卫星号减去前面的导航系统所拥有的卫星个数，来判断剩余卫星个数是否小于等于本系统的卫星个数。&lt;/li&gt;
&lt;li&gt;确定所属的系统后，通过加上最小卫星编号的 &lt;code&gt;PRN&lt;/code&gt;再减去 1，得到该卫星在该系统中的 &lt;code&gt;PRN&lt;/code&gt;编号。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;这里的卫星号是从 1开始排序的，这也是很多函数中与之有关的数组在调用时形式写为 &lt;code&gt;A[B.sat-1]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;seleph&quot;&gt;seleph&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;eph_t *seleph(gtime_t time, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sat, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; iode, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; nav_t *nav)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所在文件&lt;/strong&gt;：ephemeris.c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：从导航数据中选择星历。当 &lt;code&gt;iode&amp;gt;=0&lt;/code&gt;时，选择与输入期号相同的星历；否则，选择 &lt;code&gt;toe&lt;/code&gt;值与星历选择时间标准 &lt;code&gt;time&lt;/code&gt;最近的那个星历。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;函数参数，&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;个：
gtime_t  time      I   time to select ephemeris (gpst)
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;      sat       I   satellite number (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;-MAXSAT)
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;      iode      I   星历数据期号
nav_t    *nav      I   navigation data
返回类型:
eph_t *         星历数据&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;根据该卫星所属的导航系统给与星历参考时间的最大时间间隔 &lt;code&gt;tmax&lt;/code&gt;赋予相应的值。&lt;/li&gt;
&lt;li&gt;遍历导航数据，首先确保所查找星历的卫星号是否相同，接着确保星历期号是否相同。&lt;/li&gt;
&lt;li&gt;接着确保星历选择时间与代查找星历的参考时间的间隔是否小于 &lt;code&gt;tmax&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;对于通过了 2-3验证的星历，如果此时对于输入的期号，有 &lt;code&gt;iode&amp;gt;=0&lt;/code&gt;，则该星历就是所要寻找的星历；否则，验证 3中的 &lt;code&gt;t&lt;/code&gt;是否满足 &lt;code&gt;t&amp;lt;=tmin&lt;/code&gt;。满足的话，就令 &lt;code&gt;tmin=t&lt;/code&gt;，该星历目前是距离参考时间最近的。&lt;/li&gt;
&lt;li&gt;循环 2-4步操作，遍历完导航数据中的所有星历。如果都没有符合条件的，就输出信息并返回 NULL；否则，返回所查找到的星历。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;对于 GPS系统，星历数据期号每 2h更新一次，所以 RTKLIB中对 &lt;code&gt;MAXDTOE&lt;/code&gt;的定义为 7200。&lt;/li&gt;
&lt;li&gt;如果存在两个相邻时间段的星历，通过 4中令 &lt;code&gt;tmin=t&lt;/code&gt;的操作可以最终查找出参考时间距 &lt;code&gt;time&lt;/code&gt;最近的那个星历。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;为什么 &lt;code&gt;tmax&lt;/code&gt;和&lt;code&gt;tmin&lt;/code&gt;都要加 1？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IODE正常情况下应该都是 &amp;gt;=0的，为什么还要考虑 &amp;lt;0的情况？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;考虑到星历中卫星的健康状况，这里在选择星历时是否也应该验证 &lt;code&gt;eph.svh==0&lt;/code&gt;呢？&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;eph2clk&quot;&gt;eph2clk&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; eph2clk (gtime_t time, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; eph_t *eph)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所在文件&lt;/strong&gt;：ephemeris.c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：根据信号发射时间和广播星历，计算卫星钟差&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;函数参数，&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;个
gtime_t time     I   time by satellite clock (gpst)
eph_t    *eph    I   broadcast ephemeris
返回类型：
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;    satellite clock bias (s) without relativeity correction&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;计算与星历参考时间的偏差 dt = t-toc。&lt;/li&gt;
&lt;li&gt;利用二项式校正计算出卫星钟差，从 dt中减去这部分，然后再进行一次上述操作，得到最终的 dt。&lt;/li&gt;
&lt;li&gt;使用二项式校正得到最终的钟差。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;看不懂上述处理过程，跟以往资料上都不一样。咋回事？&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;ephpos&quot;&gt;ephpos&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ephpos(gtime_t time, gtime_t teph, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sat, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; nav_t *nav,
           &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; iode, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *rs, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *dts, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *var, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *svh)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;satsys_-&amp;gt;seleph_-&amp;gt;eph2pos_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ephpos&quot;&gt;ephpos&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satsys&quot;&gt;satsys&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#seleph&quot;&gt;seleph&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#eph2pos&quot;&gt;eph2pos&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satsys&quot;&gt;satsys&lt;/a&gt;函数，确定该卫星所属的导航系统。&lt;/li&gt;
&lt;li&gt;如果该卫星属于 GPS系统，则调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#seleph&quot;&gt;seleph&lt;/a&gt;函数来选择广播星历。&lt;/li&gt;
&lt;li&gt;根据选中的广播星历，调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#eph2pos&quot;&gt;eph2pos&lt;/a&gt;函数来计算信号发射时刻卫星的 位置、钟差和相应结果的误差。&lt;/li&gt;
&lt;li&gt;在信号发射时刻的基础上给定一个微小的时间间隔，再次计算新时刻的 P、V、C。与 3结合，通过扰动法计算出卫星的速度和频漂。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;这里是使用&lt;strong&gt;扰动法&lt;/strong&gt;计算卫星的速度和频漂，并没有使用那些位置和钟差公式对时间求导的结果。&lt;/li&gt;
&lt;li&gt;由于是调用的 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#eph2pos&quot;&gt;eph2pos&lt;/a&gt;函数，计算得到的钟差考虑了相对论效应，还没有考虑 TGD&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;eph2pos&quot;&gt;eph2pos&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; eph2pos(gtime_t time, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; eph_t *eph, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *rs, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *dts, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *var)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所在文件&lt;/strong&gt;：ephemeris.c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：根据广播星历计算出算信号发射时刻卫星的位置和钟差&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;函数参数，&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;个
gtime_t  time      I   transmission time by satellite clock
eph_t    *eph      I   broadcast ephemeris
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;   *rs       O   satellite positions and velocities，长度为6*n，{x,y,z,vx,vy,vz}(ecef)(m,m/s)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;   *dts      O   satellite clocks，长度为2*n， {bias,drift} (s|s/s)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;   *var      O   sat position and clock error variances (m^&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
返回类型：
none&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;与大部分资料上计算卫星位置和钟差的过程是一样的，只是这里在计算偏近点角 E时采用的是牛顿法来进行迭代求解。&lt;/li&gt;
&lt;li&gt;计算误差直接采用 &lt;code&gt;URA&lt;/code&gt;值来标定，具体对应关系可在 &lt;code&gt;ICD-GPS-200C P83&lt;/code&gt;中找到。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;这里在计算钟差时，就与大部分资料上介绍的一样了，只进行了一次二项式校正。另外，这里的钟差考虑了相对论效应，并没有考虑 TGD。&lt;/li&gt;
&lt;li&gt;在计算偏近点角 E时，这里采用的是牛顿法来进行迭代求解，这里与很多资料上可能不一样，具体内容可在 &lt;code&gt;RTKLIB manual P143&lt;/code&gt;中找到。&lt;/li&gt;
&lt;li&gt;补充几个程序中的参数说明：&lt;br/&gt;&lt;code&gt;C mu， 地球引力常数 eph-&amp;gt;A， 轨道长半径 omgea, 地球自转角速度&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;rescode&quot;&gt;rescode&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;25&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; rescode(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; iter, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; obsd_t *obs, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *rs,
                   &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *dts, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *vare, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *svh,
                   &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; nav_t *nav, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *x, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; prcopt_t *opt,
                   &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *v, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *H, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *var, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *vsat,
                   &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *resp, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *ns)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;&lt;strong&gt;所在文件&lt;/strong&gt;：pntpos.c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：计算在当前接收机位置和钟差值的情况下，定位方程的右端部分 &lt;code&gt;v(nv\*1)&lt;/code&gt;、几何矩阵 &lt;code&gt;H(NX*nv)&lt;/code&gt;、此时所得的伪距残余的方差 &lt;code&gt;var&lt;/code&gt;、所有观测卫星的 &lt;code&gt;azel&lt;/code&gt;{方位角、仰角}、定位时有效性 &lt;code&gt;vsat&lt;/code&gt;、定位后伪距残差 &lt;code&gt;resp&lt;/code&gt;、参与定位的卫星个数 &lt;code&gt;ns&lt;/code&gt;和方程个数 &lt;code&gt;nv&lt;/code&gt;。&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;函数参数，&lt;span class=&quot;dv&quot;&gt;17&lt;/span&gt;个
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;      iter      I    迭代次数
obsd_t   *obs      I    observation data
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;      n         I    number of observation data
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;   *rs       I   satellite positions and velocities，长度为6*n，{x,y,z,vx,vy,vz}(ecef)(m,m/s)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;   *dts      I   satellite clocks，长度为2*n， {bias,drift} (s|s/s)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;   *vare     I   sat position and clock error variances (m^&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;)
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;      *svh      I   sat health flag (-&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:correction not available)
nav_t    *nav      I   navigation data
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;   *x        I   本次迭代开始之前的定位值
prcopt_t *opt      I   processing options
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;   *v        O   定位方程的右端部分，伪距残余
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;   *H        O   定位方程中的几何矩阵
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;   *var      O   参与定位的伪距残余方差
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;   *azel     O   对于当前定位值，每一颗观测卫星的 {方位角、高度角}
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;      *vsat     O   每一颗观测卫星在当前定位时是否有效
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;   *resp     O   每一颗观测卫星的伪距残余， (P-(r+c*dtr-c*dts+I+T))
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;      *ns       O   参与定位的卫星的个数
返回类型：
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;                O   定位方程组的方程个数&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;调用关系&lt;/strong&gt;：&lt;br/&gt;```flow&lt;br/&gt;st=&amp;gt;start: rescode&lt;br/&gt;ecef2pos_=&amp;gt;operation: ecef2pos&lt;br/&gt;satsys_=&amp;gt;operation: satsys&lt;br/&gt;geodist_=&amp;gt;operation: geodist&lt;br/&gt;satazel_=&amp;gt;operation: satazel&lt;br/&gt;prange_=&amp;gt;operation: prange&lt;br/&gt;satexclude_=&amp;gt;operation: satexclude&lt;br/&gt;ionocorr_=&amp;gt;operation: ionocorr&lt;br/&gt;tropcorr_=&amp;gt;operation: tropcorr&lt;br/&gt;varerr_=&amp;gt;operation: varerr&lt;br/&gt;e=&amp;gt;end: end&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;st-&amp;gt;ecef2pos_-&amp;gt;satsys_-&amp;gt;geodist_-&amp;gt;satazel_-&amp;gt;prange_-&amp;gt;satexclude_-&amp;gt;ionocorr_-&amp;gt;tropcorr_-&amp;gt;varerr_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#rescode&quot;&gt;rescode&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ecef2pos&quot;&gt;ecef2pos&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satsys&quot;&gt;satsys&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#geodist&quot;&gt;geodist&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satazel&quot;&gt;satazel&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#prange&quot;&gt;prange&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satexclude&quot;&gt;satexclude&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ionocorr&quot;&gt;ionocorr&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#tropcorr&quot;&gt;tropcorr&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#varerr&quot;&gt;varerr&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;将之前得到的定位解信息赋值给 &lt;code&gt;rr&lt;/code&gt;和&lt;code&gt;dtr&lt;/code&gt;数组，以进行关于当前解的伪距残余的相关计算。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ecef2pos&quot;&gt;ecef2pos&lt;/a&gt;函数，将上一步中得到的位置信息由 ECEF转化为大地坐标系。&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;vsat&lt;/code&gt;、&lt;code&gt;azel&lt;/code&gt;和 &lt;code&gt;resp&lt;/code&gt;数组置 0，因为在前后两次定位结果中，每颗卫星的上述信息都会发生变化。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satsys&quot;&gt;satsys&lt;/a&gt;函数，验证卫星编号是否合理及其所属的导航系统。&lt;/li&gt;
&lt;li&gt;检测当前观测卫星是否和下一个相邻数据重复。是，则 &lt;code&gt;i++&lt;/code&gt;后继续下一次循环；否，则进入下一步。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#geodist&quot;&gt;geodist&lt;/a&gt;函数，计算卫星和当前接收机位置之间的几何距离和 &lt;code&gt;receiver-to-satellite&lt;/code&gt;方向的单位向量。然后检验几何距离是否 &amp;gt;0。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satazel&quot;&gt;satazel&lt;/a&gt;函数，计算在接收机位置处的站心坐标系中卫星的方位角和仰角，检验仰角是否 $\geq$截断值。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#prange&quot;&gt;prange&lt;/a&gt;函数，得到伪距值。&lt;/li&gt;
&lt;li&gt;可以在处理选项中事先指定只选用哪些导航系统或卫星来进行定位，这是通过调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satexclude&quot;&gt;satexclude&lt;/a&gt;函数完成的。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ionocorr&quot;&gt;ionocorr&lt;/a&gt;函数，计算电离层延时(m)。&lt;/li&gt;
&lt;li&gt;上一步中所得的电离层延时是建立在 L1信号上的，当使用其它频率信号时，依据所用信号频组中第一个频率的波长与 L1波长的关系，对上一步得到的电离层延时进行修正。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#tropcorr&quot;&gt;tropcorr&lt;/a&gt;函数，计算对流层延时(m)。&lt;/li&gt;
&lt;li&gt;由 $\rho_r^i-(r_r^i+dt_r-c·dt_s^i+I^i+T^i)$，计算出此时的伪距残余。&lt;/li&gt;
&lt;li&gt;组装几何矩阵，前 3行为 6中计算得到的视线单位向量的反向，第 4行为 1，其它行为 0。&lt;/li&gt;
&lt;li&gt;将参与定位的卫星的定位有效性标志设为 1，给当前卫星的伪距残余赋值，参与定位的卫星个数 &lt;code&gt;ns&lt;/code&gt;加 1.&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#varerr&quot;&gt;varerr&lt;/a&gt;函数，计算此时的导航系统误差（可能会包括 &lt;code&gt;IFLC&lt;/code&gt;选项时的电离层延时），然后累加计算用户测距误差(URE)。&lt;/li&gt;
&lt;li&gt;为了防止亏秩，人为的添加了几组观测方程。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;返回值 &lt;code&gt;v&lt;/code&gt;和 &lt;code&gt;resp&lt;/code&gt;的主要区别在于长度不一致， &lt;code&gt;v&lt;/code&gt;是需要参与定位方程组的解算的，维度为 nv&lt;em&gt;1；而 resp仅表示所有观测卫星的伪距残余，维度为 n&lt;/em&gt;1，对于没有参与定位的卫星，该值为 0。&lt;/li&gt;
&lt;li&gt;源码中 &lt;code&gt;dtr&lt;/code&gt;的单位是 m。&lt;/li&gt;
&lt;li&gt;16中的 &lt;code&gt;URE&lt;/code&gt;值包括 ①卫星星历和钟差的误差 ②大气延时误差 ③伪距测量的码偏移误差 ④导航系统的误差&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;关于 5中的去除重复数据的过程，有以下几个看法：&lt;br/&gt;① 这样做的前提是相同卫星的重复数据必须相邻出现！&lt;br/&gt;② 为什么在这里要进行重复数据检测，&lt;strong&gt;在构建 &lt;code&gt;obsd_t&lt;/code&gt;结构体时就可以进行这项工作&lt;/strong&gt;呀？&lt;br/&gt;③ 5中当数据重复时，&lt;code&gt;i++&lt;/code&gt;后继续下一次循环，这样的话会直接略去后面所重复的数据，这样做就会将两个相邻重复数据都忽略掉，就相当于&lt;strong&gt;重复数据都不使用&lt;/strong&gt;。感觉可以用其中一个的啊！&lt;/li&gt;
&lt;li&gt;11步中，&lt;strong&gt;为什么要选择所用信号频组中第一个频率的波长来进行电离层延时修正呢？还有，电离层延时的值发生了改变，那这里的方差是否也需要跟着一起改变呢？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在计算电离/对流层延时时，均传入了 &lt;code&gt;iter&amp;gt;0?opt-&amp;gt;ionoopt:IONOOPT_BRDC&lt;/code&gt;或 &lt;code&gt;iter&amp;gt;0?opt-&amp;gt;tropopt:TROPOPT_SAAS&lt;/code&gt;参数，都强调了当 &lt;code&gt;iter==0&lt;/code&gt;时，会强制使用 &lt;code&gt;Klobuchar&lt;/code&gt;或&lt;code&gt;Saastamoinen&lt;/code&gt;模型。这会不会是&lt;strong&gt;因为这两种模型都是属于对接收机位置不是非常敏感的类型？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;这里&lt;strong&gt;亏秩应该就是欠定方程的意思吧&lt;/strong&gt;？这里 &lt;strong&gt;17中的操作没有看懂&lt;/strong&gt;，也没能找到相关理论依据&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;lsq&quot;&gt;lsq&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; lsq(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *A, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *y, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *x, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *Q)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;matmul_-&amp;gt;matinv_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#lsq&quot;&gt;lsq&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#matmul&quot;&gt;matmul&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;首先计算右半部分 $A_y=Ay$。&lt;/li&gt;
&lt;li&gt;再计算左半部分括号里面的值 $Q=AA^T$。&lt;/li&gt;
&lt;li&gt;计算 Q矩阵的逆 $Q^{-1}$，但仍存储在 Q中，最后再右乘 $A_y$，得到 x的值。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;对于加权最小二乘，可以直接在调用该函数之前直接将 A、y进行加权处理，之后在调用该函数，这样得到的就是加权最小二乘的解。&lt;/li&gt;
&lt;li&gt;所有的矩阵都是列优先存储的，对于整个源代码来说，矩阵都是这样存储的。所以对于代码中出现的一维矩阵，基本都应该是列向量。在阅读数组下标时，记住这一点是非常重要的。&lt;/li&gt;
&lt;li&gt;矩阵求逆并不简单，尤其是对于接近奇异的矩阵。但是由于这是个基本功能，并不打算继续深入下去。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;valsol&quot;&gt;valsol&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; valsol(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *vsat, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n,
           &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; prcopt_t *opt, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *v, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; nv, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; nx, &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *msg)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;dops_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#valsol&quot;&gt;valsol&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#dops&quot;&gt;dops&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;先计算定位后伪距残余平方加权和 &lt;code&gt;vv&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;检查是否满足 $vv&amp;gt;\chi^2(nv-nx-1)$。是，则说明此时的定位解误差过大，返回 0；否则，转到下一步。&lt;/li&gt;
&lt;li&gt;复制 azel，这里只复制那些对于定位结果有贡献的卫星的 zael值，并且统计实现定位时所用卫星的数目。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#dops&quot;&gt;dops&lt;/a&gt;函数，计算各种精度因子(DOP)，检验是否有 &lt;code&gt;0&amp;lt;GDOP&amp;lt;max&lt;/code&gt;。否，则说明该定位解的精度不符合要求，返回 0；是，则返回 1。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;关于 2中的 $\chi^2$检验，这里这里与 &lt;code&gt;RTKLIB manual P160&lt;/code&gt;中不一致（但与教材一致），文档中满足 $\frac{v^Tv}{nv-nx-1}&amp;gt;\chi^2(nv-nx-1)$时就会不合格。与文档中相比，这里的写法将会放宽对于位置解的检验。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;matmul&quot;&gt;matmul&lt;/h2&gt;
&lt;p&gt;源码中定义了两个 matmul函数，一个是在包含了 &lt;code&gt;LAPACK/BLAS/MKL&lt;/code&gt;库使用，调用其中的 &lt;code&gt;degmn&lt;/code&gt;函数来完成矩阵相乘操作。这里主要说明在没有包含上述库时自定义的矩阵相乘函数。&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; matmul(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt; *tr, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; k, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; m, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; alpha,
            &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *A, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *B, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; beta, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *C)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所在文件&lt;/strong&gt;：rtkcmn.c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：可进行如下矩阵运算 C = alpha&lt;em&gt;A&lt;/em&gt;B + beta*C，并且能通过 tr标志来选择是否对 A、B进行转置&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;函数参数，&lt;span class=&quot;dv&quot;&gt;6&lt;/span&gt;个
&lt;span class=&quot;dt&quot;&gt;char&lt;/span&gt;     *tr       I   transpose flags (&lt;span class=&quot;st&quot;&gt;&quot;N&quot;&lt;/span&gt;:normal,&lt;span class=&quot;st&quot;&gt;&quot;T&quot;&lt;/span&gt;:transpose)
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;      n,k,m     I   size of (transposed) matrix A,B
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;   alpha     I   alpha
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;   *A,*B     I   (transposed) matrix A (n x m), B (m x k)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;   beta      I   beta
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;   *C        IO  matrix C (n x k)
返回类型：
none&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;根据 &lt;code&gt;tr&lt;/code&gt;的值确定矩阵相乘标志，即&lt;br/&gt;$$&lt;br/&gt;\begin{matrix}&lt;br/&gt;A&lt;em&gt;B \rightarrow NN \rightarrow 1 \&lt;br/&gt;A&lt;/em&gt;B^T \rightarrow NT \rightarrow 2 \&lt;br/&gt;A^T&lt;em&gt;B \rightarrow TN \rightarrow 3 \&lt;br/&gt;A^T&lt;/em&gt;B^T \rightarrow TT \rightarrow 4&lt;br/&gt;\end{matrix}&lt;br/&gt;$$&lt;/li&gt;
&lt;li&gt;按照 &lt;code&gt;f&lt;/code&gt;的值，分别执行相应的元素相乘并累加操作。&lt;/li&gt;
&lt;li&gt;对于 2中得到的乘积 tmp，执行 C = alpha&lt;em&gt;tmp + beta&lt;/em&gt;C操作。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;在调用该函数时，要确保矩阵的维度是否和上述参数说明一致&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所有的矩阵都是列优先存储的&lt;/strong&gt;，记住这一点，对于看明白 2中不同相乘方式时，元素如何相乘累加是至关重要的。&lt;/li&gt;
&lt;li&gt;矩阵求逆并不简单，尤其是对于接近奇异的矩阵。但是由于这是个基本功能，并不打算继续深入下去。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;dops&quot;&gt;dops&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; dops(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ns, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; elmin, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *dop)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;matmul_-&amp;gt;matinv_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#dops&quot;&gt;dops&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#matmul&quot;&gt;matmul&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#matinv&quot;&gt;matinv&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;先按照如下站心坐标系时的几何矩阵 $\tilde{G}$的表达式求出其值。&lt;br/&gt;$$&lt;br/&gt;\tilde{G} = \begin{bmatrix}&lt;br/&gt;cos\theta^1sin\alpha^1 &amp;amp; cos\theta^2sin\alpha^2 &amp;amp; \vdots &amp;amp; cos\theta^Nsin\alpha^N \&lt;br/&gt;cos\theta^1cos\alpha^1 &amp;amp; cos\theta^2cos\alpha^2 &amp;amp; \vdots &amp;amp; cos\theta^Ncos\alpha^N \&lt;br/&gt;sin\theta^1 &amp;amp; sin\theta^2 &amp;amp; \vdots &amp;amp; sin\theta^N \&lt;br/&gt;1 &amp;amp; 1 &amp;amp; \vdots &amp;amp; 1&lt;br/&gt;\end{bmatrix}&lt;br/&gt;$$&lt;/li&gt;
&lt;li&gt;检验上述矩阵的列数是否$\geq$ 4。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#matmul&quot;&gt;matmul&lt;/a&gt;和&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#matinv&quot;&gt;matinv&lt;/a&gt;函数，计算出 $\tilde{H} = (\tilde{G}\tilde{G}^T)^{-1}$的值。&lt;/li&gt;
&lt;li&gt;如果能正确计算出逆矩阵，就按照顺序计算出 GDOP、PDOP、HDOP和 VDOP的值。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;1中几何矩阵 $\tilde{G}$与书中的不一致，&lt;strong&gt;前 3行均少了一个负号&lt;/strong&gt;，我自己推导之后也觉得应该有负号，即为&lt;br/&gt;$$&lt;br/&gt;\tilde{G} = \begin{bmatrix}&lt;br/&gt;-cos\theta^1sin\alpha^1 &amp;amp; -cos\theta^2sin\alpha^2 &amp;amp; \vdots &amp;amp; -cos\theta^Nsin\alpha^N \&lt;br/&gt;-cos\theta^1cos\alpha^1 &amp;amp; -cos\theta^2cos\alpha^2 &amp;amp; \vdots &amp;amp; -cos\theta^Ncos\alpha^N \&lt;br/&gt;-sin\theta^1 &amp;amp; -sin\theta^2 &amp;amp; \vdots &amp;amp; -sin\theta^N \&lt;br/&gt;1 &amp;amp; 1 &amp;amp; \vdots &amp;amp; 1&lt;br/&gt;\end{bmatrix}&lt;br/&gt;$$&lt;br/&gt;不过，由于 $\tilde{H} = (\tilde{G}\tilde{G}^T)^{-1}$，在括号里面的矩阵相乘时，是否有负号只对底边靠左 3个元素和右边靠上 3个元素有影响（多了个负号），然后再进行求逆之后，前 3行是否有负号就对对角线上的元素似乎没有影响了。&lt;/li&gt;
&lt;li&gt;感觉在 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#rescode&quot;&gt;rescode&lt;/a&gt;函数中，在检验一个观测卫星的伪距信息是否可用时，已经进行过是否大于截断高度角的检测了。这里所用的卫星仰角又都是属于参与了定位的卫星，所以感觉这里应该不需要再进行一次高度角检测了吧？&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;ecef2enu&quot;&gt;ecef2enu&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ecef2enu(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *pos, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *r, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *e)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;xyz2enu_-&amp;gt;matmul_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ecef2enu&quot;&gt;ecef2enu&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#xyz2enu&quot;&gt;xyz2enu&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#matmul&quot;&gt;matmul&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;先调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#xyz2enu&quot;&gt;xyz2enu&lt;/a&gt;函数计算此时的坐标变换矩阵 E。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#matmul&quot;&gt;matmul&lt;/a&gt;计算 $E*r$的值，即为目标值。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;xyz2enu&quot;&gt;xyz2enu&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; xyz2enu(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *pos, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *E)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所在文件&lt;/strong&gt;：rtkcmn.c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：计算将ECEF中的向量转换到站心坐标系中的转换矩阵。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;函数参数，&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;个
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *pos      I   geodetic position {lat,lon} (rad)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *E        O   vector in local tangental coordinate {e,n,u}
返回类型：
none&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;按照大部分资料上的写法计算 3*3的矩阵，优先按列存储。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;ecef2pos&quot;&gt;ecef2pos&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;void&lt;/span&gt; ecef2pos(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *r, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *pos)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所在文件&lt;/strong&gt;：rtkcmn.c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：将 ECEF坐标系(X、Y、Z)转换成大地坐标系($\lambda、\phi、h$)。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;函数参数，&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;个
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;  *r        I   ecef position {x,y,z} (m)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;  *pos      O   geodetic position {lat,lon,h} (rad,m)
返回类型：
none&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.2016129032258&quot;&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;4.6941176470588&quot;&gt;
&lt;p&gt;这里采用的方法与很多资料上的并不一致，而关于源码中方法的具体理论推导和计算过程，见 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8678596.html&quot;&gt;ECEF和大地坐标系的相互转化&lt;/a&gt;一文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;geodist&quot;&gt;geodist&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; geodist(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *rs, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *rr, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *e)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所在文件&lt;/strong&gt;：rtkcmn.c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：计算卫星和当前接收机位置之间的几何距离和 &lt;code&gt;receiver-to-satellite&lt;/code&gt;方向的单位向量。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;函数参数，&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;个
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *rs       I   satellilte position (ecef at transmission) (m)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *rr       I   receiver position (ecef at reception) (m)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *e        O   line-of-sight unit vector (ecef)
返回类型：
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;           O   geometric distance (m) (&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;&amp;gt;:error/no satellite position)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;检查卫星到 WGS84坐标系原点的距离是否大于基准椭球体的长半径。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ps-pr&lt;/code&gt;，计算由接收机指向卫星方向的观测矢量，之后在计算出相应的单位矢量。&lt;/li&gt;
&lt;li&gt;考虑到地球自转，即信号发射时刻卫星的位置与信号接收时刻卫星的位置在 WGS84坐标系中并不一致，进行关于 &lt;code&gt;Sagnac效应&lt;/code&gt;的校正。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;3中&lt;strong&gt;使用关于 &lt;code&gt;Sagnac效应&lt;/code&gt;的校正来考虑地球自转对卫星位置的影响，与教材中的地球自转校正并不一样，二者是否描述的是同一个事情？&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;satazel&quot;&gt;satazel&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; satazel(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *pos, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *e, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;ecef2enu_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satazel&quot;&gt;satazel&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ecef2enu&quot;&gt;ecef2enu&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ecef2enu&quot;&gt;ecef2enu&lt;/a&gt;函数，将 &lt;code&gt;pos&lt;/code&gt;处的向量转换到以改点为原点的站心坐标系中。&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;atan2&lt;/code&gt;函数计算出方位角，然后再算出仰角。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;这里在计算方位角时，要使用 &lt;code&gt;atan2&lt;/code&gt;函数，而不能是 &lt;code&gt;atan&lt;/code&gt;函数，详细原因见 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8663223.html&quot;&gt;C语言中的atan和atan2&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;prange&quot;&gt;prange&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; prange(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; obsd_t *obs, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; nav_t *nav, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel,
              &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; iter, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; prcopt_t *opt, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *var)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;satsys_-&amp;gt;testsnr_-&amp;gt;gettgd_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#prange&quot;&gt;prange&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satsys&quot;&gt;satsys&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#testsnr&quot;&gt;testsnr&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#gettgd&quot;&gt;gettgd&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;首先调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satsys&quot;&gt;satsys&lt;/a&gt;确定该卫星属于 RTKLIB设计时给定的几个导航系统之中。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;NFREQ&amp;gt;=3&lt;/code&gt;且该卫星属于 &lt;code&gt;GAL/SBS&lt;/code&gt;系统，则 &lt;code&gt;j=2&lt;/code&gt;。而如果出现 &lt;code&gt;NFREQ&amp;lt;2||lam[i]==0.0||lam[j]==0.0&lt;/code&gt;中的其中一个，直接返回 0.&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;iter&amp;gt;0&lt;/code&gt;时，调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#testsnr&quot;&gt;testsnr&lt;/a&gt;函数，测试第i、j(&lt;code&gt;IFLC&lt;/code&gt;)个频率信号的载噪比是否符合要求。&lt;/li&gt;
&lt;li&gt;计算出 $\gamma$值(f1^2/f2^2，见ICD-GPS-200C P90)，从 &lt;code&gt;obs&lt;/code&gt;和 &lt;code&gt;nav&lt;/code&gt;数据中读出测量伪距值和 &lt;code&gt;码偏移值(?)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;从数据中读出的P1_P2==0，则使用 TGD代替，TGD值由 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#gettgd&quot;&gt;gettgd&lt;/a&gt;函数计算得到。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;ionoopt==IONOOPT_IFLC&lt;/code&gt;，根据 &lt;code&gt;obs-&amp;gt;code&lt;/code&gt;的值来决定是否对 P1、P2进行修正，之后再组合出 IFLC时的伪距值(ICD-GPS-200C P91)。否则，则是针对单频接收即进行的数据处理。先对 P1进行修正，然后再计算出伪距值（PC）&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;sateph==EPHOPT_SBAS&lt;/code&gt;，则还要对 PC进行处理。之后给该函数计算出的伪距值的方差赋值。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;该函数到底在对伪距进行哪部分的计算？计算进行 C/A码修正后的伪距值？&lt;/li&gt;
&lt;li&gt;在调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#testsnr&quot;&gt;testsnr&lt;/a&gt;函数时，为什么要有 &lt;code&gt;iter&amp;gt;0&lt;/code&gt;的限制？为什么第一次迭代就不能调用这些函数呢？&lt;/li&gt;
&lt;li&gt;2中操作的含义不明白，还有为什么出现 3个条件中的一个，就要返回 0呢？&lt;/li&gt;
&lt;li&gt;5中关于 IFLC模型伪距的重新计算是看明白了，但是 &lt;code&gt;P1_P2&lt;/code&gt;、&lt;code&gt;P1_C1&lt;/code&gt;、&lt;code&gt;P1_C2&lt;/code&gt;这些变量具体代表什么含义，以及&lt;code&gt;P1_P2==0.0&lt;/code&gt;时使用 TGD代替和最后关于 &lt;code&gt;sbas clock based C1&lt;/code&gt;的操作看不懂。。。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;satexclude&quot;&gt;satexclude&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; satexclude(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sat, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; svh, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; prcopt_t *opt)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所在文件&lt;/strong&gt;：rtkcmn.c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：检测某颗卫星在定位时是否需要将其排除，排除标准为该卫星是否处理选项预先规定的导航系统或排除标志。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;函数参数，&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;个
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;       sat     I   satellite number，从 &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;开始
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;       svh     I   sv health flag(&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:ok)
prcopt_t  *opt    I   processing options (NULL: not used)
返回类型：
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;               O   &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:excluded,&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:not excluded&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;首先调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#satsys&quot;&gt;satsys&lt;/a&gt;函数得到该卫星所属的导航系统。&lt;/li&gt;
&lt;li&gt;接着检验 &lt;code&gt;svh&amp;lt;0&lt;/code&gt;。是，则说明在 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ephpos&quot;&gt;ephpos&lt;/a&gt;函数中调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#seleph&quot;&gt;seleph&lt;/a&gt;为该卫星选择星历时，并无合适的星历可用，返回 1；否，则进入下一步。&lt;/li&gt;
&lt;li&gt;如果处理选项不为空，则检测处理选项中对该卫星的排除标志的值&lt;code&gt;(1:excluded,2:included)&lt;/code&gt;，之后再检测该卫星所属的导航系统与处理选项中预先设定的是否一致。否，返回 1；是，进入下一步。&lt;/li&gt;
&lt;li&gt;如果此时 &lt;code&gt;svh&amp;gt;0&lt;/code&gt;，说明此时卫星健康状况出现问题，此卫星不可用，返回 1。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;3中再在比较该卫星与预先规定的导航系统是否一致时，使用了 &lt;code&gt;sys&amp;amp;opt-&amp;gt;navsys&lt;/code&gt;来进行比较。这样做的好处是当 &lt;code&gt;opt-&amp;gt;navsys=sys&lt;/code&gt;或 &lt;code&gt;opt-&amp;gt;navsys=SYS_ALL&lt;/code&gt;时，结果都会为真。之所以会这样，是因为在 &lt;code&gt;rtklib.h&lt;/code&gt;文件中定义这些导航系统变量的时候，所赋的值在二进制形式下都是只有一位为 &lt;code&gt;1&lt;/code&gt;的数。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;对于 3中检测，先验证状态排除标志，后验证导航系统，这样就可能出现排除标志符合要求而所属系统不符合要求的状况，而 3中做法会将上述状况设为 &lt;code&gt;included&lt;/code&gt;!&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;另外，注意到在 3中检测之后仍验证了 &lt;code&gt;svh&amp;gt;0&lt;/code&gt;，那如果出现 &lt;code&gt;svh&lt;/code&gt;不合乎要求而排除标志符合要求的状况，3中做法却会将上述状况设为 &lt;code&gt;included&lt;/code&gt;!&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;ionocorr&quot;&gt;ionocorr&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;15&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ionocorr(gtime_t time, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; nav_t *nav, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sat, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *pos,
             &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; ionoopt, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *ion, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *var)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;c1_(yes)-&amp;gt;ionmodel_-&amp;gt;e&lt;br/&gt;c1_(no)-&amp;gt;c2_(yes)-&amp;gt;iontec_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ionocorr&quot;&gt;ionocorr&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ionmodel&quot;&gt;ionmodel&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#iontec&quot;&gt;iontec&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;根据 &lt;code&gt;opt&lt;/code&gt;的值，选用不同的电离层模型计算方法。当 &lt;code&gt;ionoopt==IONOOPT_BRDC&lt;/code&gt;时，调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ionmodel&quot;&gt;ionmodel&lt;/a&gt;，计算 &lt;code&gt;Klobuchar模型&lt;/code&gt;时的电离层延时 (L1，m)；当 &lt;code&gt;ionoopt==IONOOPT_TEC&lt;/code&gt;时，调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#iontec&quot;&gt;iontec&lt;/a&gt;，计算 &lt;code&gt;TEC网格模型&lt;/code&gt;时的电离层延时 (L1，m)。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;当 &lt;code&gt;ionoopt==IONOOPT_IFLC&lt;/code&gt;时，此时通过此函数计算得到的延时和方差都为 0。其实，对于 &lt;code&gt;IFLC&lt;/code&gt;模型，其延时值在 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#prange&quot;&gt;prange&lt;/a&gt;函数中计算伪距时已经包括在里面了，而方差是在 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#varerr&quot;&gt;varerr&lt;/a&gt;函数中计算的，并且会作为导航系统误差的一部分给出。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;tropcorr&quot;&gt;tropcorr&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; tropcorr(gtime_t time, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; nav_t *nav, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *pos,
                 &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; tropopt, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *trp, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *var)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;tropmodel_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#dops&quot;&gt;dops&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#tropmodel&quot;&gt;tropmodel&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;当 &lt;code&gt;tropopt==TROPOPT_SAAS&lt;/code&gt;或一些其它情况时，调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#tropmodel&quot;&gt;tropmodel&lt;/a&gt;函数，计算 &lt;code&gt;Saastamoinen模型&lt;/code&gt;下的对流层延时。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;貌似对流层延时与信号频率无关，所以这里计算得到的值并不是只针对于 &lt;code&gt;L1&lt;/code&gt;信号！&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;varerr&quot;&gt;varerr&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; varerr(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; prcopt_t *opt, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; el, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sys)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所在文件&lt;/strong&gt;：pntpos.c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：计算导航系统伪距测量值的误差&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;函数参数，&lt;span class=&quot;dv&quot;&gt;3&lt;/span&gt;个
prcopt_t  *opt    I   processing options
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;    el      I   elevation angle (rad)
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;       sys     I   所属的导航系统
返回类型：
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;            O   导航系统伪距测量值的误差&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;确定 sys系统的误差因子。&lt;/li&gt;
&lt;li&gt;计算由导航系统本身所带来的误差的方差。&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;ionoopt==IONOOPT_IFLC&lt;/code&gt;时，&lt;code&gt;IFLC&lt;/code&gt;模型的方差也会添加到最终计算得到的方差中。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;本函数整体到底是为了计算哪一部分的误差，还是没搞清楚。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IFLC&lt;/code&gt;模型的方差为什么可以用 &lt;code&gt;varr*=SQR(3.0)&lt;/code&gt;计算？&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;testsnr&quot;&gt;testsnr&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; testsnr(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; base, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; freq, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; el, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; snr,
            &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; snrmask_t *mask)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;matmul_-&amp;gt;matinv_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#dops&quot;&gt;dops&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#matmul&quot;&gt;matmul&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#matinv&quot;&gt;matinv&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;满足下列情况之一 &lt;code&gt;!mask-&amp;gt;ena[base]||freq&amp;lt;0||freq&amp;gt;=NFREQ&lt;/code&gt;，返回 0.&lt;/li&gt;
&lt;li&gt;对 &lt;code&gt;el&lt;/code&gt;处理变换，根据后面 &lt;code&gt;i&lt;/code&gt;的值得到不同的阈值 &lt;code&gt;minsnr&lt;/code&gt;，而对 &lt;code&gt;1&amp;lt;=i&amp;lt;=8&lt;/code&gt;的情况，则使用线性插值计算出 &lt;code&gt;minsnr&lt;/code&gt;的值。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;这个函数貌似是根据接收机高度角和信号频率来检测该信号是否可用，但 &lt;code&gt;mask&lt;/code&gt;在这里应该翻译成什么？看了下调用该函数的地方，返回 0(unmasked)似乎是合理的、希望看到的情况，即 &lt;code&gt;snr&amp;gt;=minsnr&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;满足 1中条件的情况，感觉应该是不合理的情形，为什么反而返回 0呢？&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;gettgd&quot;&gt;gettgd&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; gettgd(&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; sat, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; nav_t *nav)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所在文件&lt;/strong&gt;：pntpos.c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：检测某颗卫星在定位时是否需要将其排除，排除标准为该卫星是否处理选项预先规定的导航系统或排除标志。&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;函数参数，&lt;span class=&quot;dv&quot;&gt;2&lt;/span&gt;个
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;       sat     I   satellite number，从 &lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;开始
nav_t    *nav     I   navigation data
返回类型：
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;            O   tgd parameter (m)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;从导航数据的星历中选择卫星号与 &lt;code&gt;sat&lt;/code&gt;相同的那个星历，读取 tgd[0]参数后乘上光速。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;ionmodel&quot;&gt;ionmodel&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; ionmodel(gtime_t t, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *ion, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *pos,
                &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所在文件&lt;/strong&gt;：rtkcmn.c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：计算采用 &lt;code&gt;Klobuchar模型&lt;/code&gt;时的电离层延时 (L1，m)。&lt;/li&gt;
&lt;li readability=&quot;4.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;20&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;函数参数，&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;个
gtime_t t        I   time (gpst)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *ion      I   iono model parameters {a0,a1,a2,a3,b0,b1,b2,b3}
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *pos      I   receiver position {lat,lon,h} (rad,m)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel     I   azimuth/elevation angle {az,el} (rad)
返回类型：
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;           O   ionospheric delay (L1) (m)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;主要都是数学计算，其过程可以在 &lt;code&gt;ICD-GPS-200C P148&lt;/code&gt;中找到。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;这里计算的电离层延时是相对于 GPS-L1信号而言的，其它频率信号需要进行一次转换。&lt;/li&gt;
&lt;li&gt;计算过程中很多角度的单位是半圆，即 $\pi$弧度。在阅读代码时，记住这一点非常重要！比如，虽然上述过程与 &lt;code&gt;ICD-GPS-200C P148&lt;/code&gt;中一致，但可能与大部分资料上的过程还是会有所区别。尤其是下面这个公式。&lt;br/&gt;$ \Psi = \frac{0.0137}{E+0.01}-0.022 \qquad (ICD-GPS-200C) $&lt;br/&gt;$ EA = (\frac{445°}{el+20°})-4° \qquad (王虎，GPS精密单点定位中电离层延迟改正模型的研究与分析)$&lt;br/&gt;但是将下面公式的角度转化成半圆，即左右两边都除以 180，就可以得到上面的公式了！&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;iontec&quot;&gt;iontec&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; iontec(gtime_t time, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; nav_t *nav, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *pos,
           &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; opt, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *delay, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *var)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;iondelay_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#iontec&quot;&gt;iontec&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#iondelay&quot;&gt;iondelay&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;检测高度角和接收机高度是否大于阈值。否，则延迟为 0，方差为 &lt;code&gt;VAR_NOTEC&lt;/code&gt;，返回 1；是，则进入下一步。&lt;/li&gt;
&lt;li&gt;从 &lt;code&gt;nav_t.tec&lt;/code&gt;中找出第一个 &lt;code&gt;tec[i].time&lt;/code&gt; &amp;gt; &lt;code&gt;time&lt;/code&gt;（输入参数，信号接收时间）的 &lt;code&gt;tec&lt;/code&gt;数据。然后通过 &lt;code&gt;i==0||i&amp;gt;=nav-&amp;gt;nt&lt;/code&gt;，确保 &lt;code&gt;time&lt;/code&gt;是在所给出的 &lt;code&gt;nav_t.tec&lt;/code&gt;包含的时间段之中！&lt;/li&gt;
&lt;li&gt;通过确认所找到的时间段的右端点减去左端点，来确保时间间隔 &lt;code&gt;!=&lt;/code&gt; 0。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#iondelay&quot;&gt;iondelay&lt;/a&gt;来计算所属时间段两端端点的电离层延时。&lt;/li&gt;
&lt;li&gt;由两端的延时，插值计算出观测时间点处的值。而对于两端延时的组合，有 3种情况。&lt;br/&gt;① 两个端点都计算出错，输出错误信息，返回 0.&lt;br/&gt;② 两个端点都有值，线性插值出观测时间点的值，返回 1.&lt;br/&gt;③ 只有一个端点有值，将其结果作为观测时间处的值，返回 1.&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;由于是通过调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#iondelay&quot;&gt;iondelay&lt;/a&gt;来计算所属时间段端点的电离层延时，所以这里求出来的值是以 &lt;code&gt;L1信号&lt;/code&gt;为前提的。&lt;/li&gt;
&lt;li&gt;关于 5中的第 ②种情况，&lt;code&gt;RTKLIB manual P152 (E.5.20)式&lt;/code&gt;是错误的，左端点TEC值得时间权重值应该是 $(t_{i+1}-t)/(t_{i+1}-t_i)$。manual中可能是搞反了，源码中是正确的，与我的看法相同。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;1中当高度角和接收机高度较小时，为什么延迟要为 0呢？&lt;/li&gt;
&lt;li&gt;可能是个对最终结果没有什么影响的小细节， 虽然时间间隔 &lt;code&gt;tt&lt;/code&gt;后面用得到，但是由于 2中的操作，其实3中的时间间隔肯定是 &lt;code&gt;&amp;gt;0&lt;/code&gt;的！&lt;/li&gt;
&lt;li&gt;目前关于 &lt;code&gt;tec model&lt;/code&gt;，我还没有找到很好的相关方面的文章！&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;iondelay&quot;&gt;iondelay&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; iondelay(gtime_t time, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; tec_t *tec, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *pos,
             &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; opt, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *delay, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *var)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;ionppp_-&amp;gt;interptec_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#iondelay&quot;&gt;iondelay&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ionppp&quot;&gt;ionppp&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#interptec&quot;&gt;interptec&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;按照 &lt;code&gt;RTKLIB manual P152&lt;/code&gt;中的公式(E.5.19)，先计算出与频率有关的中间项。&lt;/li&gt;
&lt;li&gt;整体过程是按照电离层的高度，从起始高度开始，逐层计算每一层的延时和方差，之后累加到一起。下面再具体阐述。&lt;/li&gt;
&lt;li&gt;首先调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ionppp&quot;&gt;ionppp&lt;/a&gt;函数，计算出在当前电离层高度时，电离层穿刺点的位置 &lt;code&gt;{lat,lon,h} (rad,m)&lt;/code&gt;和倾斜率( $1/cos \zeta$)。&lt;/li&gt;
&lt;li&gt;按照 &lt;code&gt;opt&lt;/code&gt;的值可能再次进行修正。&lt;code&gt;opt&amp;amp;1&lt;/code&gt;，则按照 &lt;code&gt;M-SLM映射函数&lt;/code&gt;重新计算倾斜率；&lt;code&gt;opt&amp;amp;2&lt;/code&gt;，则在日固坐标系中考虑地球自转，重新计算穿刺点经度；&lt;/li&gt;
&lt;li&gt;由 TEC网格计算穿刺点的电子数总量，然后按照 (E.5.19)累加电离层延时(m)和方差。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;这里在计算电离层延时(m)时，是假设信号为 L1的！&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;4中操作看不懂，貌似跟 地/日坐标系和 &lt;code&gt;SL/M-SL&lt;/code&gt;有关？&lt;/li&gt;
&lt;li&gt;IONEX文件中的电离层模型，高度真的有很多层吗？&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;ionppp&quot;&gt;ionppp&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; ionppp(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *pos, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; re,
              &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; hion, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *posp)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所在文件&lt;/strong&gt;：rtkcmn.c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：计算电离层穿刺点的位置 &lt;code&gt;{lat,lon,h} (rad,m)&lt;/code&gt;和倾斜率( $1/cos \zeta$)。&lt;/li&gt;
&lt;li readability=&quot;2.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;函数参数，&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;个
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *pos      I   receiver position {lat,lon,h} (rad,m)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel     I   azimuth/elevation angle {az,el} (rad)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; re        I   earth radius (km)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; hion      I   altitude of ionosphere (km)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *posp     O   pierce point position {lat,lon,h} (rad,m)
返回类型：
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;           O   倾斜率&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;与处理过程相对应的公式，请见 &lt;code&gt;RTKLIB manual P151&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;说明文档中的 &lt;code&gt;z&lt;/code&gt;并不是仰角&lt;code&gt;azel[1]&lt;/code&gt;，而是仰角关于$\pi/2$的补角，所以程序中在计算 &lt;code&gt;rp&lt;/code&gt;是采用的是 &lt;code&gt;cos(azel[1])&lt;/code&gt;的写法。&lt;/li&gt;
&lt;li&gt;可能因为后面再从 TEC网格数据中插值时，并不需要高度信息，所以这里穿刺点位置 &lt;code&gt;posp&lt;/code&gt;中的第三项高度，其实并没有进行赋值，&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;interptec&quot;&gt;interptec&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; interptec(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; tec_t *tec, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; k, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *posp, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *value,
              &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *rms)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所在文件&lt;/strong&gt;：ionex.c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：通过在经纬度网格点上进行双线性插值，计算第 k个高度层时穿刺点处的电子数总量 TEC&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;函数参数，&lt;span class=&quot;dv&quot;&gt;5&lt;/span&gt;个
tec_t   *tec       I   tec grid data
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;     k          I   高度方向上的序号，可以理解为电离层序号
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;  *posp      I   pierce point position {lat,lon,h} (rad,m)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;  *value     O   计算得到的刺穿点处的电子数总量(tecu) 
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;  *rms       O   所计算的电子数总量的误差的标准差(tecu) 
返回类型：
&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt;                O    (&lt;span class=&quot;dv&quot;&gt;1&lt;/span&gt;:ok,&lt;span class=&quot;dv&quot;&gt;0&lt;/span&gt;:error)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;将 &lt;code&gt;value&lt;/code&gt;和 &lt;code&gt;rms&lt;/code&gt;所指向的值置为 0。&lt;/li&gt;
&lt;li&gt;检验 &lt;code&gt;tec&lt;/code&gt;的纬度和经度间隔是否为 0。是，则直接返回 0。&lt;/li&gt;
&lt;li&gt;将穿刺点的经纬度分别减去网格点的起始经纬度，再除以网格点间距，对结果进行取整，得到穿刺点所在网格的序号和穿刺点所在网格的位置(比例)。&lt;/li&gt;
&lt;li&gt;按照下图的顺序，调用 &lt;code&gt;dataindex&lt;/code&gt;函数分别计算这些网格点的 &lt;code&gt;tec&lt;/code&gt;数据在 &lt;code&gt;tec.data&lt;/code&gt;中的下标，从而得到这些网格点处的 &lt;code&gt;TEC&lt;/code&gt;值和相应误差的标准差。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2018/04/11/5ace00add62d0.png&quot; alt=&quot;网格点计算顺序图&quot;/&gt;&lt;/li&gt;
&lt;li&gt;如果四个网格点的 TEC值都 &amp;gt;0，则说明穿刺点位于网格内，使用双线性插值计算出穿刺点的 TEC值；否则使用最邻近的网格点值作为穿刺点的 TEC值，不过前提是网格点的 TEC&amp;gt;0；否则，选用四个网格点中 &amp;gt;0的值的平均值作为穿刺点的 TEC值。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;对于lats[3]，其含义分别为起始纬度、终止纬度和间隔，对 lons[3]、hgts[3]，其含义也是类似的。&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;dataindex&lt;/code&gt;函数， i、j、k都是从 0开始的，意味着分别代表各自方向上第 i+1、j+1、k+1层，并且是按照纬度、经度、高度的优先顺序来存储网格点数据的。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;关于输出参数 &lt;code&gt;rms&lt;/code&gt;，按照其名称，应该是 &lt;code&gt;均方根值&lt;/code&gt;，但是在调用了该函数的 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#iondelay&quot;&gt;iondelay&lt;/a&gt;中，确是把它的平方当做方差的一部分进行累加。所以我估计 &lt;strong&gt;&lt;code&gt;tec.rms&lt;/code&gt;值得应该是相应网格点数据值的方差&lt;/strong&gt;？&lt;/li&gt;
&lt;li&gt;老实说，源码中关于 &lt;code&gt;tec-&amp;gt;lons[2]&lt;/code&gt;大于或者小于 0所做的处理，并没有看得太明白。另外，个人感觉 3中减去网格点起始经度后的差值应该也不会超过 360°吧？&lt;/li&gt;
&lt;li&gt;整体由网格点数据插值穿刺点值得过程可以明白，但 &lt;code&gt;tec.data&lt;/code&gt;会 &amp;lt;0吗？还有在网格外是指某一个网格的外面，还是整体 TEC大网格的四个角外面？&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;tropmodel&quot;&gt;tropmodel&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; tropmodel(gtime_t time, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *pos, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel,
                 &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; humi)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;所在文件&lt;/strong&gt;：rtkcmn.c&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;功能说明&lt;/strong&gt;：由标准大气和 &lt;code&gt;Saastamoinen&lt;/code&gt;模型，计算电离层延时(m)&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数说明&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;函数参数，&lt;span class=&quot;dv&quot;&gt;4&lt;/span&gt;个
gtime_t time     I   time
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *pos      I   receiver position {lat,lon,h} (rad,m)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel     I   azimuth/elevation angle {az,el} (rad)
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; humi      I   relative humidity
返回类型：
&lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt;           O   tropospheric delay (m)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;与处理过程相对应的公式，请见 &lt;code&gt;RTKLIB manual P149&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;我的疑惑&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;源码中关于 &lt;code&gt;trph&lt;/code&gt;的计算，与大多数文献和 &lt;code&gt;RTKLIB manual P149 (E.5.4)&lt;/code&gt;有所不同，咋回事儿呢？&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;resdop&quot;&gt;resdop&lt;/h2&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;18&quot;&gt;
&lt;pre class=&quot;sourceCode c&quot;&gt;
&lt;code class=&quot;sourceCode c&quot;&gt;&lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; resdop(&lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; obsd_t *obs, &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; n, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *rs, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *dts,
           &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; nav_t *nav, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *rr, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *x,
           &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *azel, &lt;span class=&quot;dt&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;dt&quot;&gt;int&lt;/span&gt; *vsat, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *v, &lt;span class=&quot;dt&quot;&gt;double&lt;/span&gt; *H)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;st-&amp;gt;ecef2pos_-&amp;gt;xyz2enu_-&amp;gt;matmul_-&amp;gt;e&lt;br/&gt;```&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#resdop&quot;&gt;resdop&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ecef2pos&quot;&gt;ecef2pos&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#xyz2enu&quot;&gt;xyz2enu&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#matmul&quot;&gt;matmul&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理过程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#ecef2pos&quot;&gt;ecef2pos&lt;/a&gt;函数，将接收机位置由 ECEF转换为大地坐标系。&lt;/li&gt;
&lt;li&gt;调用 &lt;a href=&quot;http://www.cnblogs.com/taqikema/p/8819798.html#xyz2enu&quot;&gt;xyz2enu&lt;/a&gt;函数，计算此时的坐标转换矩阵。&lt;/li&gt;
&lt;li&gt;满足下列条件 &lt;code&gt;obs[i].D[0]==0.0||lam==0.0||!vsat[i]||norm(rs+3+i*6,3)&amp;lt;=0.0&lt;/code&gt;之一，则当前卫星在定速时不可用，直接进行下一次循环。&lt;/li&gt;
&lt;li&gt;计算当前接收机位置下 ENU中的视向量，然后转换得到 ECEF中视向量的值。&lt;/li&gt;
&lt;li&gt;计算 ECEF中卫星相对于接收机的速度，然后再计算出考虑了地球自转的用户和卫星之间的几何距离变化率，校正公式见 &lt;code&gt;RTKLIB manual P159 (E.6.29)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;根据公式 计算出方程右端项的多普勒残余，然后再构建左端项的几何矩阵。最后再将观测方程数增 1.&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;这里与定位不同，构建几何矩阵时，就只有 4个未知数，而定位时是有 &lt;code&gt;NX&lt;/code&gt;个。并且没有像定位那样为了防止亏秩而进行约束处理。&lt;/li&gt;
&lt;li&gt;多普勒定速方程中几何矩阵 G与定位方程中的一样，前三行都是 ECEF坐标系中由接收机指向卫星的单位观测矢量的反向。而由于转换矩阵 S本身是一个正交单位矩阵($S^T=S^{-1}$)，所以这里在计算 ECEF中的视向量时，对 &lt;code&gt;E&lt;/code&gt;进行了转置处理。&lt;/li&gt;
&lt;li&gt;这里构建的左端几何矩阵 H，也与定位方程中的一样，是大部分资料上的几何矩阵的转置。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;</description>
<pubDate>Fri, 13 Apr 2018 05:35:00 +0000</pubDate>
<dc:creator>塔奇克马敲代码</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/taqikema/p/8819798.html</dc:identifier>
</item>
<item>
<title>php--观察者模式 - xiaobaiskill</title>
<link>http://www.cnblogs.com/xiaobaiskill/p/8819493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaobaiskill/p/8819493.html</guid>
<description>&lt;h3&gt;&lt;strong&gt;&lt;span&gt;一、定义&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　观察者模式(Observer),当一个对象的状态发生改变时，依赖他的对象会全部收到通知，并自动更新。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;观察者模式利用“组合”将许多观察者组合进主题中。对象(观察者——主题)之间的这种关系不是通过继承产生的，而是在运行时利用组合的方式产生的。 ——&lt;span&gt;多用组合，少用继承！&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;二、应用场景&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　一个事件发生后,要执行一连串更新操作.传统的编程方式,就是在事件的代码之后直接加入处理逻辑,当更新得逻辑增多之后,代码会变得难以维护.这种方式是耦合的,侵入式的,增加新的逻辑需要改变事件主题的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 今天正好遇到了一个观察者模式的使用&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 功能需要：我的项目代码中需要添加一个上传图片的功能，但是上传图片完成后需要做一件事。图片数据保存至数据库&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 分析：如果我们将代码逻辑操作，图片路径写入了数据库，后期修改了表的格式，或者添加了其他的字段，我们都需要留意上传图片的这边的代码，这样是不利于代码的统一维护的。&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 问题：能否将两者分离开， 上传完图片及自动触发 储存图片数据的代码，但储存图片数据又不写在上传图片的逻辑中？&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解决： 上传图片是library层的操作， 存储图片数据是model层的操作。将两者关联，在上传图片完成前调用方法添加存储图片数据model（观察者），&lt;br/&gt;# 图片上传完成后，触发存储图片数据model（观察者）的方法保存图片数据至数据类&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;三、实现过程&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　两个原则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、封闭开放原则&lt;/span&gt;
&lt;span&gt;对于功能实现，是封闭的，
但对功能的内容是开放的

对修改是封闭的
对扩展时开放的



&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2、多用组合，少用扩展&lt;/span&gt;
&lt;span&gt;类与类之间存在关联关系，可以相互借用对方的方法，而不是添加更多的逻辑代码

类的扩展不易过多，层级过多容易发生混乱&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　功能需要：图片上传完成，保存图片数据至数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_11e70710-c300-4823-bc0a-6dcfe82d8b1c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_11e70710-c300-4823-bc0a-6dcfe82d8b1c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_11e70710-c300-4823-bc0a-6dcfe82d8b1c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; upload
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; register(&lt;span&gt;$obj&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;$this&lt;/span&gt;-&amp;gt;_observers[] = &lt;span&gt;$obj&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; trigger(&lt;span&gt;$data&lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;empty&lt;/span&gt;(&lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;_observers)) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$this&lt;/span&gt;-&amp;gt;_observers &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$obj&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;$obj&lt;/span&gt;-&amp;gt;&lt;span&gt;add_upload();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; html5upload()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;.....&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;$this&lt;/span&gt;-&amp;gt;&lt;span&gt;trigger();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; picture_model
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; add_upload()
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;echo&lt;/span&gt; '图片存储成功'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;$upload&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; upload();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;$upload&lt;/span&gt;-&amp;gt;register(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; picture_model());
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;$upload&lt;/span&gt;-&amp;gt;html5upload();
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;上面代码的简单实现&lt;/span&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;四、总结&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　当某个事件（逻辑）完成，需要执行其他关联事件（逻辑）时，可使用此模式。&lt;/p&gt;



</description>
<pubDate>Fri, 13 Apr 2018 03:58:00 +0000</pubDate>
<dc:creator>xiaobaiskill</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaobaiskill/p/8819493.html</dc:identifier>
</item>
</channel>
</rss>