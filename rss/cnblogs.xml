<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>前端leader找我谈心：我是如何从刚毕业的前端菜鸟一步步成长为前端架构师的？ - 闰土大叔</title>
<link>http://www.cnblogs.com/running-runtu/p/9038725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/running-runtu/p/9038725.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;strong&gt;谈谈学习&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我做前端已经有五年的时间了，从大学刚毕业的时候，我是一个完全什么都不懂的小白。虽然我大学里学的是软件工程专业，但是因为在大学里荒废学业，每天只知道打游戏，基本上到大学毕业之前我是什么都不会的，而且大学里是没有教前端相关的东西的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我是在大学毕业之前，两三个月，自学了一点点前端的皮毛，也就是会写一点点的html和css。那个时候找工作也不容易，终于有一个公司收留了我，虽然说工资什么的我们暂时按下不提。但是至少他们要我，我就非常地开心了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从那个时候开始，因为有了项目要做，所以我逼迫自己，每天去学习新的内容。那个时候我从jQuery开始做，因为公司的项目比较特殊，就是单页应用，总共加起来大概就五六个页面，但是要一次性全部加载完，后续的所有数据都是根据接口去获取。那个时候没有框架，没有React，ngular也刚刚出来，还并不流行。所以那个时候我们就用jQuery。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然后我就想办法去做，第一版做的非常的烂，就一个js文件我写了3000多行代码。所以在那个时候我逼迫自己想办法去解决各种问题。我就针对自己当时的认知，比如说js文件太大了，应该怎么办？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然后我去网上搜，我发现了sea.js这个东西。我学习了它异步加载JavaScript的方法，后来才把它引用到项目里。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当我发现代码量多了，很难去维护这个逻辑，还有页面的切换。于是我就去网上搜资料学习，发现有backbone.js这个东西，它可以帮我解决这个问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在后来这段时间里，我积累了非常多的东西，也是我进步最快的一个时期。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当我再去接触到这些Vue、React这些框架的时候，我先去学习了一遍它们主要是解决了什么问题，它们主要的功能有哪些。然后我再尝试用到项目里面去。那个时候，我刚开始学的是Angular，当时也没有了解到有构建工具这个概念。那时候最多只知道有Grunt，帮你去压缩一下js。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当时，我还没有模块化的概念。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;后来又做了一些项目，发现了很多的问题，我再去想办法去解决。这个时候才会知道有Webpack这些模块化组织代码的工具。我就是在这种环境下一步一步成长起来的。我所有学的内容，对于前端的了解，基本上都是基于我想要去解决一个问题，然后再去网上搜相关的内容，然后去想办法把这个问题解决掉。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以对于我来说，学习这个东西，你要知道你要解决什么问题。然后你学的这个东西，它解决了什么问题。它适不适合用在你遇到的这些问题上，以及你在学习这个内容之前，你必须要对它的整体有一个了解。不然的话，你就是瞎用。你用的方法可能根本就不是这个框架要解决的问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;比如Vue，大家对于vue整体有一个概念之后，再去用到一个项目里面去。而项目一开始我们做的时候并不要求做的特别的复杂。只要你基础扎实，你肯定有办法去解决这些在项目里碰到的问题。而在解决问题的过程当中，才是你掌握了你学习到的东西，巩固了你学习到的这些内容的地方。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以这就是我要谈的学习。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;谈谈前端&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现在的前端跟五年前的前端是天壤之别。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;五年前的前端，框架之流刚刚兴起，也就是Angular带的头，那个时候刚出来没多久。那个时候流行什么呢？就是写页面模板。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们写好html、css，以及这个页面上简单的动画效果，比如说点击一下有什么事件之类的。然后这个东西写好之后干嘛呢？丢给后端人员他们用后端模板，比如说最多的用Java，Java有jsp模板语言，接着把数据填进去，就OK了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这个时候我们一个网站有很多页面怎么办呢？比如说我们写了很多的html页面，写好之后交给后端人员，然后他们整合在模板，再把数据动态插进去。这样的话，每个http的请求发送到后端那边，后端根据这个http请求，返回不同的模板，并且把数据渲染进去，最终返回给用户。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这就是以前的前端。那么现在的前端呢？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们把渲染模板的操作从后端挪到了前端来做。因为把模板渲染这部分拿到前端来做，所以很多业务逻辑的判断、渲染、数据获取等都要在前端来做。这个时候就大大加深了前端的业务逻辑。它包含的内容就比以前上升了好几个量级。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;在这种情况下，我们需要一个框架去整理代码。而这个时候就会出现各种帮助我们前端开发者去处理这些内容的东西，比如说我们有了前端路由的概念，我们有了store状态管理的概念。以前MVC的时候，还有过其他的处理数据的方式，反正各种各样的工具帮我们去处理这个问题。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;伴随着前端业务代码越来越复杂，我们用以前的方式去写JavaScript代码，效率非常的低。因为我们写的JavaScript代码很多都受浏览器兼容的限制，或者是它的低版本的很多功能不支持，导致我们写起来非常的蛋疼。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;彼时前端界不缺人才，他们发明了各种各样的工具，比如用babel让我们能提前享受到最新的JavaScript语法带来的很多很好用的功能。当我们有了React这类框架之后，希望前端的应用以js作为入口，而不是以html作为入口。我们html里显示的内容都是从js里面渲染出来的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;由于整个应用基本上以js作为入口，我们就需要用js来处理css、图片等其他静态资源。这个时候我们发现，js本身不是用来处理这些东西的，而我们又迫切需要一些工具来处理这个问题，因此又出现了webpack。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以前端的发展速度在整个编程界来说，是相对特别快的。主要的原因就是因为以前的前端它的标准实在是太低了。现在补充的很多js 的标准、前端的一些标准都是以前发展缓慢，落下来的。所以说，现在只能说是慢慢地变成了一个正常的状态，而不是说已经超前非常多了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;前端现在要入门的童鞋，对你们来说，其实不算是一个特别好的时机。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果你之前是有基础的，那么还可以。如果你之前一点基础都没有，你会发现前端进来之后，你要学的东西特别的多，各种各样的东西。在这种鱼龙混杂的时候，你必须要保持一颗好奇心，保持一个吸收新知识的能力。你要经常去看一些文章，或者是GitHub，或者是一些厉害的程序员的博客。他们有发现新的东西，好玩的东西，都会分享出来。然后你要立马去学习，因为它有可能就是将来的主流。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以现在去学习前端，你要时刻保持一种学习的心态。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;谈谈面试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;现在的前端状态有点混乱，发展节奏有点快，你仅仅是想把vue学好是不可能的。你要学vue就必须要学webpack。当然你可以直接用vue-cli去生成一个项目。但是对于好奇的你，肯定会想，vue-cli里面到底做了哪些东西。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然后当你以后出去面试的时候，你跟面试官说，你做过vue的项目。然后面试官肯定会问你一些webpack相关的一些东西。这个时候你又说不出个所以然来。他会问你，那你的项目是怎么生成的，你会说用vue-cli脚手架生成的。他会问你，那你有没有看过vue-cli里面生成的一些代码，然后这个时候你又说没有。那么他对你的期望值就会变得非常的低。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当然有的面试官还会不厌其烦地问你，为什么我们用webpack生成的文件名后面要带上一串哈希码？这个问题至少我问过很多初中级的童鞋，他们都是不知道的，不太清楚，或者只是清楚一些有概念叫做缓存。但是至于这个文件名后面加一堆哈希码，到底是做什么事情，他们不太清楚。浏览器如何去缓存，他们也不太清楚。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以webpack是一个逃不开的话题。然后还有vue-router、vuex这些已经算是vue项目开发的三驾马车。因此当你想学好vue的时候，意味着你还要学好webpack、vue-router、vuex。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当然，服务端渲染也是值得讨论的话题。这些东西要去全部学习好，对于基础比较差的童鞋来讲，确实有点难，他一下子接收的东西实在太多了。一旦涉及到webpack，而webpack又是跑在node端的，所以你还要学习用node.js如何去写脚本。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当然，如果对于追求上进的你来说，还想学习下SSR服务端渲染，首先你要去学习用node.js如何去写一个server，然后还有服务端的接口实现，虽然这是一个纯后端的实现内容。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;当你以为这就结束了的话，你就错了。如果你面试的是BATJ等互联网大厂，面试官可能还会问你http相关的内容。比如说，面试官会问你，像http的get、post、put、delete这些request methods它们又有什么用，有什么区别？从语义上来讲，http的code又有什么用。当这些问题抛向你的时候，如果你平时没有注意积累这方面的技术知识，此时的你是否依然会处于一个懵圈的状态？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这些东西，对于一个纯做前端，纯做页面的童鞋来说的话，你确实不用特别的了解。但是你一旦升级为一个工程师，你要去跟后端交流一些接口，你要去思考统筹整个项目的时候，你必须要了解。不然的话，你会踩非常多的坑，犯非常多的错误。导致你的整个项目到后期维护的时候，有很多的内容到后期是没办法去升级的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;讲了这么多关于学习、前端、面试等话题，终归学习是要讲效率的，如果你学了非常多的时间，发现自己还是不怎么会，你就会特别没有成就感。当时就不会想继续学下去了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;最后，向内认知，向外行走。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;谨以此文与君共勉。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;以上内容参考自某大型互联网公司前端架构师的心路历程，在此表示感谢。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最新的文章都会第一时间更新在我的公众号&amp;lt;&lt;strong&gt;闰土大叔&lt;/strong&gt;&amp;gt;里面，欢迎关注。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/701424/201805/701424-20180514232310270-544612060.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 14 May 2018 15:29:00 +0000</pubDate>
<dc:creator>闰土大叔</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/running-runtu/p/9038725.html</dc:identifier>
</item>
<item>
<title>Netflix性能监控工具Vector - 壮壮熊</title>
<link>http://www.cnblogs.com/zhouqinxiong/p/9038712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouqinxiong/p/9038712.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;简介：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        Vector是Netflix开源的主机级性能监控框架，向每位工程师的浏览器提供精心挑选的高分辨率系统和应用程序指标。&lt;/p&gt;
&lt;p&gt;        登录到系统并从shell运行大量命令是一种选择，但是通常涉及的复杂性可能成为工程师希望将其作为长期解决方案的障碍。此外，传统的集中式系统监控解决方案往往很复杂，尤其是对于一次性或临时使用而言，这种解决方案将是一种矫枉过正。&lt;/p&gt;
&lt;p&gt;        Vector为用户提供了一种简单的方式，用于近乎实时地可视化和分析系统和应用程序级度量。它利用经过测试的开源系统监控框架Performance Co-Pilot（PCP），在顶层提供灵活且用户友好的用户界面。 UI以高达1秒的分辨率轮询度量标准，将数据呈现在完全可配置的仪表板中，以简化交叉度量关联和分析。&lt;/p&gt;
&lt;p&gt;        PCP的无状态模型使其轻量且强大。它在主机上的开销可以忽略不计，因为客户负责跟踪状态，采样率和计算。此外，指标不会跨主机汇总，也不会在用户的浏览器会话之外保持不变，从而保持框架清晰。 &lt;span&gt;Vector只需要您希望监控的主机上安装的本地浏览器和PCP&lt;/span&gt;。不需要中间收集器，服务器或数据库基础结构。&lt;/p&gt;
&lt;p&gt;        最终的监控页面如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/440176/201805/440176-20180514231615361-2081512165.png&quot; alt=&quot;&quot; width=&quot;1130&quot; height=&quot;829&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;架构图：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/440176/201805/440176-20180514231624666-1103879188.png&quot; alt=&quot;&quot; width=&quot;1130&quot; height=&quot;461&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.4078260869565217&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yNV7KSicILb5xhEdiagsCanWfCEG8oBJTOeZfA7Cs7N7mP7QwtGpRjfy2uICWibAk76xdyEmp753EQib440GpbJcYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;安装PCP：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;源码安装，环境：Ubuntu14.04&lt;/p&gt;
&lt;p&gt;1、获得当前版本的源代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/performancecopilot/pcp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、建立要编译pcp软件的依赖环境：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ apt-&lt;span&gt;get&lt;/span&gt; build-dep pcp
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、编译和安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ cd pcp
$ .&lt;/span&gt;/configure --prefix=/usr --sysconfdir=/etc --localstatedir=/&lt;span&gt;var&lt;/span&gt; --with-&lt;span&gt;webapi
$ make
$ groupadd &lt;/span&gt;-&lt;span&gt;r pcp
$ useradd &lt;/span&gt;-c &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Performance Co-Pilot&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -g pcp -d /&lt;span&gt;var&lt;/span&gt;/lib/pcp -M -r -s /usr/sbin/&lt;span&gt;nologin pcp
$ make install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;安装Vector：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;源码安装&lt;/p&gt;
&lt;p&gt;1、从Github上获取源代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/Netflix/vector.git&lt;/span&gt;
$ cd vector
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、编译vertor，这里需要你的服务器上安装有Node.JS, npm 和 Bower。这里几个工具请自行Google或百度安装。安装这些依赖后&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$ npm install
$ bower install
$ gulp build&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、使用Gulp的开发Web服务器运行Vector并实时重新加载。 为了启动Gulp的Web服务器，只需执行服务任务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ gulp serve
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://images2018.cnblogs.com/blog/440176/201805/440176-20180514231728300-1682681367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 14 May 2018 15:23:00 +0000</pubDate>
<dc:creator>壮壮熊</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhouqinxiong/p/9038712.html</dc:identifier>
</item>
<item>
<title>spring cloud 入门系列七：基于Git存储的分布式配置中心--Spring Cloud Config - JAVA开发老菜鸟</title>
<link>http://www.cnblogs.com/sam-uncle/p/9036053.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sam-uncle/p/9036053.html</guid>
<description>&lt;p&gt;我们前面接触到的spring cloud组件都是基于Netflix的组件进行实现的，这次我们来看下spring cloud 团队自己创建的一个全新项目：Spring Cloud Config.&lt;br/&gt;它用来为分布式系统中的基础设施和微服务提供集中化的外部配置支持，分为服务端和客户端两个部分。&lt;/p&gt;
&lt;p&gt;其中服务端也称为分布式配置中心，他是独立的微服务应用，用来连接配置仓库并为客户端提供获取接口(这些接口返回配置信息、加密、解密信息等)；&lt;/p&gt;
&lt;p&gt;客户端是微服务架构中的各个微服务应用或基础设施，它们通过制定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。&lt;br/&gt;由于配置中心默认采用Git来存储配置信息，因此我们会用到Git相关的内容，如果没有用过Git或者忘记怎么用了，可以参考下廖雪峰老师的&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot;&gt;Git教程&lt;/a&gt;。&lt;br/&gt;另外，我自己用的Git远程仓库是码云。&lt;br/&gt;====================华丽的分割线===================&lt;br/&gt;接下来看下代码怎么实现。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、准备远程Git仓库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在Gitee上新建一个项目https://gitee.com/sam-uncle/spring-cloud-learning&lt;/li&gt;
&lt;li&gt;在项目下新建子目录spring-cloud-config-file，然后新建三个文件
&lt;ol&gt;&lt;li&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201805/1345071-20180514163008919-621335425.png&quot; alt=&quot;&quot;/&gt;
&lt;/li&gt;
&lt;li&gt;内容分别是&lt;span class=&quot;py&quot;&gt;from&lt;span class=&quot;p&quot;&gt;=&lt;span class=&quot;s&quot;&gt;git-dev-1.0、&lt;span class=&quot;py&quot;&gt;from&lt;span class=&quot;p&quot;&gt;=&lt;span class=&quot;s&quot;&gt;git-test-1.0、&lt;span class=&quot;py&quot;&gt;from&lt;span class=&quot;p&quot;&gt;=&lt;span class=&quot;s&quot;&gt;git-1.0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;新建一个分支config-lable-test，新分支里面新建三个同名的文件，不过内容分别是from&lt;span class=&quot;p&quot;&gt;=&lt;span class=&quot;s&quot;&gt;git-dev-2.0、&lt;span class=&quot;py&quot;&gt;from&lt;span class=&quot;p&quot;&gt;=&lt;span class=&quot;s&quot;&gt;git-test-2.0、&lt;span class=&quot;py&quot;&gt;from&lt;span class=&quot;p&quot;&gt;=&lt;span class=&quot;s&quot;&gt;git-2.0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、构建配置中心&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;先给出最终代码结构：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201805/1345071-20180514151827679-330662155.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　搭建过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新建maven工程config-server&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;修改POM文件
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.sam&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;config-server&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.5.1.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;javaVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;javaVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 使用dependencyManagement进行版本管理 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-dependencies&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Camden.SR6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 引入config server依赖 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-config-server&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;创建启动类
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @EnableConfigServer
 * 
 * 开启Spring Cloud Config 的服务端功能
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@SpringBootApplication
@EnableConfigServer
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigServerApp {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(ConfigServerApp.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;配置application.properties文件，指定远程仓库信息
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
server.port=7001&lt;span&gt;
spring.application.name&lt;/span&gt;=config-&lt;span&gt;server

#配置Git仓库的地址
spring.cloud.config.server.git.uri&lt;/span&gt;=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;gitee.com/sam-uncle/spring-cloud-learning/&lt;/span&gt;
&lt;span&gt;#配置仓库路径下的相对搜索位置，可以配置多个
spring.cloud.config.server.git.search&lt;/span&gt;-paths=spring-cloud-config-&lt;span&gt;file
#这里配置你的Git仓库的用户名
spring.cloud.config.server.git.username&lt;/span&gt;=&lt;span&gt;&lt;em&gt;用户名&lt;/em&gt;
#这里配置你的Git仓库的密码
spring.cloud.config.server.git.password&lt;/span&gt;=&lt;em&gt;密码&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;启动并验证&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　　　访问配置信息的URL与配置文件的映射关系如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;/{application}/{profile} [/{label}]&lt;/li&gt;
&lt;li&gt;/{application}-{profile}.yml&lt;/li&gt;
&lt;li&gt;/{label}/{application}-{profile}.yml&lt;/li&gt;
&lt;li&gt;/{application}-{profile}.properties&lt;/li&gt;
&lt;li&gt;/{label}/{appliction}-{profile}.properties&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　上面的url会映射{application}-{profile}.properties对应的配置文件，其中{label}对应Git上不同的分支，默认是master。&lt;/p&gt;
&lt;p&gt;　　　　通过浏览器访问http://localhost:7001/sam/dev/config-label-test,结果如下：&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201805/1345071-20180514204453611-2012505138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;三、实现客户端&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 　  &lt;/span&gt;&lt;/strong&gt;最终代码结构：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201805/1345071-20180514230359517-257063183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　搭建过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新建maven工程config-client&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;修改POM文件
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt;
    xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.sam&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;config-client&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.5.1.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;javaVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;javaVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 使用dependencyManagement进行版本管理 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-dependencies&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Camden.SR6&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencyManagement&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 引入config依赖 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-config&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;创建启动类
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConfigClientApp {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(ConfigClientApp.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;配置bootstrap.properties文件，指定config-server位置
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
server.port=7002&lt;span&gt;
#{application}
spring.application.name&lt;/span&gt;=&lt;span&gt;sam
#{profile}
spring.cloud.config.profile&lt;/span&gt;=&lt;span&gt;dev
#{label}
spring.cloud.config.label&lt;/span&gt;=&lt;span&gt;master

#config server uri
spring.cloud.config.uri&lt;/span&gt;=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:7001/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;创建controller
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@RefreshScope
@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestController {

    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 通过@Value 来讲配置文件中的值写入到代码中
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Value(&lt;/span&gt;&quot;${from}&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String from;

    @RequestMapping(&lt;/span&gt;&quot;/from&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String from() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; from;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;启动并测试&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　　　&lt;img src=&quot;https://images2018.cnblogs.com/blog/1345071/201805/1345071-20180514225453678-933035224.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、工作原理&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;Spring Cloud Config配置中心的工作原理如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端启动时，根据bootstrap.properties中配置的应用名{application}、环境名{profile}、分支名{label}，向Config Server请求获取配置信息。&lt;/li&gt;
&lt;li&gt;Config Server根据自己维护的Git仓库信息和客户传递过来的配置定位信息去查找配置信息。&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;通过git clone命令将找到的配置信息下载到本地（Config Server的文件系统中）。在通过页面访问或启动客户端的时候，我们在服务端能看到如下下载的log：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;-&lt;span&gt;14&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt;:&lt;span&gt;58.055&lt;/span&gt;  INFO &lt;span&gt;3084&lt;/span&gt; --- [nio-&lt;span&gt;7001&lt;/span&gt;-exec-&lt;span&gt;1&lt;/span&gt;] o.s.c.c.s.e.NativeEnvironmentRepository  : Adding property source: file:/C:/Users/sam/AppData/Local/Temp/config-repo-&lt;span&gt;8627749771720918793&lt;/span&gt;/spring-cloud-config-file/sam-&lt;span&gt;dev.properties
&lt;/span&gt;&lt;span&gt;2018&lt;/span&gt;-&lt;span&gt;05&lt;/span&gt;-&lt;span&gt;14&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt;:&lt;span&gt;58.055&lt;/span&gt;  INFO &lt;span&gt;3084&lt;/span&gt; --- [nio-&lt;span&gt;7001&lt;/span&gt;-exec-&lt;span&gt;1&lt;/span&gt;] o.s.c.c.s.e.NativeEnvironmentRepository  : Adding property source: file:/C:/Users/sam/AppData/Local/Temp/config-repo-&lt;span&gt;8627749771720918793&lt;/span&gt;/spring-cloud-config-file/sam.properties
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;Config Server创建Spring 的ApplicationContext实例，并从Git本地仓库中加载配置文件，最后将这些配置内容读取出来返回给客户端。&lt;/li&gt;
&lt;li&gt;客户端在获取外部配置信息后加载到客户端的applicationContext实例。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 14 May 2018 15:00:00 +0000</pubDate>
<dc:creator>JAVA开发老菜鸟</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sam-uncle/p/9036053.html</dc:identifier>
</item>
<item>
<title>设计模式之模板方法(Template Method) - tosser</title>
<link>http://www.cnblogs.com/tosser/p/9033517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tosser/p/9033517.html</guid>
<description>&lt;p&gt;　　在整理模板方法之前，先来说点废话吧。除了记录学习总结，也来记录一下生活吧。&lt;/p&gt;
&lt;p&gt;　　我们公司的老板在北京，老板也会因为项目来公司，不过不是天天来。公司有个同事，只要老板不在就天天迟到，而且一天比一天晚，经常来了公司没多久，午饭的外卖就送到公司了。前几天，外卖竟然比他还来的早（外卖11点半送到的），公司一个不怎么说废话的同事说了一句“兵马未动，粮草先行”。其他同事都觉得他说的很是到位。&lt;/p&gt;

&lt;p&gt;模板方法模式的定义&lt;/p&gt;
&lt;p&gt;　　定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。&lt;/p&gt;
&lt;p&gt;　　我的理解是，在一个较为通用的流程中或步骤中，只有具体的某个步骤可能是不相同的。比如，实现一个“我下面给你吃……”，首先把水倒入锅里，第二步下面，最后把面从锅里捞出来。这个流程是固定的，但是可能第二部在南方和北方就不一样了，比如北方人吃刀削面，所以下的是刀削面，南方人吃的是热干面，所以第二步下的是热干面。也就是具体的面不一样了，而整个的流程算法是相同的。&lt;/p&gt;

&lt;p&gt;代码示例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TemplateMethod {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         System.out.println(&quot;南方人下面给你吃&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         NanFang nf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NanFang();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        nf.zhuMian();;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         
&lt;span&gt; 7&lt;/span&gt;         System.out.println(&quot;++++++++++++++++++++++++&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         
&lt;span&gt; 9&lt;/span&gt;         System.out.println(&quot;北方人下面给你吃&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         BeiFang bf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeiFang();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        bf.zhuMian();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Mian {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; zhuMian() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         System.out.println(&quot;把水倒入锅里&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        xiaMian();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         System.out.println(&quot;把面从锅里捞出来&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         System.out.println(&quot;面给你吃&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; xiaMian();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; NanFang &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Mian {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; xiaMian() {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         System.out.println(&quot;热干面&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BeiFang &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Mian {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; xiaMian() {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         System.out.println(&quot;刀削面&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　编译运行如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/892439/201805/892439-20180514224246560-603107637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;　　总结来自于《大话设计模式》一书中第十章“考题抄错会做也白搭——模板方法模式”。&lt;/p&gt;
&lt;p&gt;1、既然用了继承，并且肯定这个继承有意义，就应该要成为子类的模板，所有重复的代码都应该要上升到父类去，而不是让每个子类都去重复；&lt;/p&gt;
&lt;p&gt;2、当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法模式来处理；&lt;/p&gt;
&lt;p&gt;3、模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势；&lt;/p&gt;
&lt;p&gt;4、当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。&lt;/p&gt;


</description>
<pubDate>Mon, 14 May 2018 14:55:00 +0000</pubDate>
<dc:creator>tosser</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tosser/p/9033517.html</dc:identifier>
</item>
<item>
<title>模拟业务最小测试用例02 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/9038472.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/9038472.html</guid>
<description>&lt;p&gt;Oracle数据库对很多开发人员而言，基本就只是一个存储数据的仓库，只不过这个仓库功能非常强大，额外提供了很多好用的功能，需要的时候会用就好，不会纠结于某个细节。而对很多DBA而言，正好相反，喜欢沉溺于某些细节上，对某些小知识点对应的原理理解的非常透彻，但却往往很少会站在开发层面认识Oracle。&lt;br/&gt;本文旨在构造一份相对较全面的测试数据，对开发常用的对象都模拟创建一份测试用例，DBA就可以直接拿去做一些基本测试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;环境：&lt;/strong&gt;Oracle 11.2.0.4&lt;/p&gt;

&lt;p&gt;初始化测试数据的脚本主要包含了如下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.表空间创建&lt;/li&gt;
&lt;li&gt;2.用户创建及赋权&lt;/li&gt;
&lt;li&gt;3.表创建&lt;/li&gt;
&lt;li&gt;4.索引创建&lt;/li&gt;
&lt;li&gt;5.视图、同义词、序列、dblink&lt;/li&gt;
&lt;li&gt;6.存储过程、函数、包、定时任务、触发器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;脚本：&lt;/strong&gt;initData.sh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
#name：initData.sh
#function：to initial data for test.
#usage: oracle用户登录，执行 sh initData.sh &amp;gt; /tmp/initData.log

#logon database
sqlplus -S / as sysdba &amp;lt;&amp;lt;EOF


prompt ============================
prompt ==  summary         
prompt ============================
prompt
prompt 1.表空间创建 
prompt 2.用户创建及赋权
prompt 3.表创建
prompt 4.索引创建
prompt 5.视图、同义词、序列、dblink
prompt 6.存储过程、函数、包、定时任务、触发器
prompt

prompt ============================
prompt == 1.表空间创建 
prompt ============================
prompt Tablespace：DBS_D_JINGYU
prompt Tablespace：DBS_I_JINGYU
prompt TEMPORARY Tablespace：TEMP_JINGYU
prompt 
-- 数据表空间
create tablespace dbs_d_jingyu datafile size 30M autoextend on maxsize 500M;
-- 临时表空间
create temporary tablespace temp_jingyu tempfile size 30M autoextend on maxsize 500M;
-- 索引表空间(可选)
create tablespace dbs_i_jingyu datafile size 30M autoextend on maxsize 500M;


prompt ============================
prompt == 2.用户创建及赋权
prompt ============================
prompt User：jingyu 权限：connect, resource
prompt User：ludan  权限：connect, resource, dba
prompt
-- 假设创建用户 jingyu 密码 jingyu，默认临时表空间 temp_jingyu， 默认数据表空间 dbs_d_jingyu。
CREATE USER jingyu IDENTIFIED BY jingyu
  TEMPORARY TABLESPACE temp_jingyu
  DEFAULT TABLESPACE dbs_d_jingyu
  QUOTA UNLIMITED ON dbs_d_jingyu;

-- 假设创建用户 ludan 密码 ludan，默认临时表空间temp_jingyu， 默认数据表空间 dbs_d_jingyu。
CREATE USER ludan IDENTIFIED BY ludan
  TEMPORARY TABLESPACE temp_jingyu
  DEFAULT TABLESPACE dbs_d_jingyu
  QUOTA UNLIMITED ON dbs_d_jingyu;

-- 赋权
grant resource, connect to jingyu;
grant resource, connect, dba to ludan;


prompt ============================
prompt == 3.表创建
prompt ============================
prompt 

prompt 3.1 普通堆表
prompt ============================
prompt
--3.1 普通堆表
--prepare 
conn /as sysdba
alter user scott identified by tiger account unlock;
conn scott/tiger
grant select on emp to jingyu;
grant select on dept to jingyu;

-- 业务用户登录
conn jingyu/jingyu
-- 删除 emp
--drop table emp cascade constraints purge;
--drop table dept cascade constraints purge;
-- 创建emp
create table emp tablespace dbs_d_jingyu as select * from scott.emp;
create table dept tablespace dbs_d_jingyu as select * from scott.dept;
-- 查询T1,T2表数据量
select count(1) from emp;
select count(1) from dept;
-- 创建后面JOB用到的表
create table t_times(col1 date);
create table t_sum(col1 date, col2 number);
create table t_times_old as select * from t_times where 1=2;

-- 业务用户登录
conn ludan/ludan
-- 创建 t_obj
create table t_obj as select * from dba_objects;
-- 查询 数据量
select count(1) from t_obj;

prompt 3.2 分区表
prompt ============================
prompt
--3.2 分区表
conn ludan/ludan
create table t_obj_part
partition by range(CREATED)
(
  partition P2015 values less than (TO_DATE(' 2016-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    tablespace dbs_d_jingyu,
  partition P2016 values less than (TO_DATE(' 2017-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    tablespace dbs_d_jingyu,
  partition P2017 values less than (TO_DATE(' 2018-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    tablespace dbs_d_jingyu,
  partition P2018 values less than (TO_DATE(' 2019-01-01 00:00:00', 'SYYYY-MM-DD HH24:MI:SS', 'NLS_CALENDAR=GREGORIAN'))
    tablespace dbs_d_jingyu
) as select * from t_obj;

select count(1) from t_obj_part partition(P2018);

prompt 3.3 全局临时表
prompt ============================
prompt
--3.3 全局临时表
conn ludan/ludan
create global temporary table t_tmp_session on commit preserve rows as select * from dba_objects where 1 = 2;
create global temporary table t_tmp_transaction on commit delete rows as select * from dba_objects where 1 = 2;

prompt 3.4 索引组织表
prompt ============================
prompt
--3.4 索引组织表
conn jingyu/jingyu
--select dbms_metadata.get_ddl('TABLE',upper('emp'),'JINGYU') from dual;

CREATE TABLE emp_iot
   (    &quot;EMPNO&quot; NUMBER(4,0),
        &quot;ENAME&quot; VARCHAR2(10),
        &quot;JOB&quot; VARCHAR2(9),
        &quot;MGR&quot; NUMBER(4,0),
        &quot;HIREDATE&quot; DATE,
        &quot;SAL&quot; NUMBER(7,2),
        &quot;COMM&quot; NUMBER(7,2),
        &quot;DEPTNO&quot; NUMBER(2,0),
        primary key(empno)
   )organization index;

insert into emp_iot select * from emp;
commit;

--select * from jingyu.emp where empno = 7788;
--select * from jingyu.emp_iot where empno = 7788;

--select * from jingyu.emp where ename = 'SCOTT';
--select * from jingyu.emp_iot where ename = 'SCOTT';

prompt 3.5 簇表
prompt ============================
prompt
--3.5 簇表
conn jingyu/jingyu

create cluster shc
(cust_id number,
order_dt timestamp SORT)
hashkeys 10000
hash is cust_id
size 8192;

create table cust_orders(
cust_id number,
order_dt timestamp SORT,
order_number number,
username varchar2(30),
ship_addr number,
bill_addr number,
invoice_num number
)
cluster shc(cust_id, order_dt);

--select * from dba_objects where object_name = 'SHC';

prompt 3.6 外部表
prompt ============================
prompt
--3.6 外部表
conn /as sysdba
!mkdir -p /home/oracle/external_table
create or replace directory external_table as '/home/oracle/external_table';
grant read,write on directory external_table to jingyu;

conn jingyu/jingyu
create table ext_emp (ename,job,sal,dname)
organization external
(type oracle_datapump default directory external_table location('ext_emp'))
as select ename,job,sal,dname from emp join dept on emp.deptno=dept.deptno;


prompt ============================
prompt == 4.索引创建
prompt ============================
prompt 主键、外键、唯一索引、普通索引、位图索引、函数索引
prompt

prompt 4.1 普通B-Tree索引
prompt ============================
prompt
--4.1 普通B-Tree索引
--ludan.idx_t_obj_name
conn ludan/ludan
create index idx_t_obj_name on t_obj(object_name) tablespace dbs_i_jingyu;
--jingyu.empno
conn jingyu/jingyu
create index idx_emp_1 on emp(empno, ename) tablespace dbs_i_jingyu;
create index idx_emp_2 on emp(mgr) tablespace dbs_i_jingyu;

prompt 4.2 唯一索引
prompt ============================
prompt
--4.2 唯一索引
conn ludan/ludan
create unique index ux_t_obj_id on t_obj(object_id) tablespace dbs_i_jingyu;

prompt 4.3 位图索引
prompt ============================
prompt
--4.3 位图索引
conn jingyu/jingyu
create bitmap index bx_emp_job on emp(job) tablespace dbs_i_jingyu;

prompt 4.4 函数索引
prompt ============================
prompt
--4.4 函数索引
conn jingyu/jingyu
create index fx_emp_hiredate on emp(to_char(hiredate,'yyyy-mm-dd')) tablespace dbs_i_jingyu;
--select * from jingyu.emp where to_char(hiredate,'yyyy-mm-dd') = '1981-11-17';

prompt 4.5 主键、外键
prompt ============================
prompt
--4.5 主键、外键
conn jingyu/jingyu
alter table emp add constraint pk_emp_empno primary key(empno);
alter table dept add constraint pk_dept_deptno primary key(deptno);
alter table emp add constraint fk_emp_references_dept foreign key(deptno) references dept(deptno);


prompt ============================
prompt == 5.视图、同义词、序列、dblink
prompt ============================
prompt 视图、同义词、序列、dblink
prompt

prompt 5.1 视图
prompt ============================
prompt
--5.1 视图
conn /as sysdba
grant create view to jingyu;

conn jingyu/jingyu
create view emp_high_sal as select * from emp where sal &amp;gt; 3000;

prompt 5.2 同义词
prompt ============================
prompt
--5.2 同义词
conn ludan/ludan
create synonym s_emp for jingyu.emp;
create synonym s_dept for jingyu.dept;

--public synonym
create public synonym pubic_emp for jingyu.emp;
create public synonym pubic_dept for jingyu.dept;

prompt 5.3 序列
prompt ============================
prompt
--5.3 序列
conn jingyu/jingyu

--drop sequence seq_1;
create sequence seq_1 start with 1 increment by 1;

--drop table t_test_seq purge;
create table t_test_seq(id number, name varchar2(20));
insert into t_test_seq values(seq_1.nextval, 'jingyu');
insert into t_test_seq values(seq_1.nextval, 'jingyu');
insert into t_test_seq values(seq_1.nextval, 'jingyu');
commit;

prompt 5.4 dblink
prompt ============================
prompt
--5.4 dblink
--tnsnames.ora
--JYZHAO =
--  (DESCRIPTION =
--    (ADDRESS = (PROTOCOL = TCP)(HOST = jyrac-scan)(PORT = 1521))
--    (CONNECT_DATA =
--      (SERVER = DEDICATED)
--      (SERVICE_NAME = jyzhao)
--    )
--  )

--connect user
conn ludan/ludan
--private dblink
create database link to_jyzhao_jy connect to jingyu identified by jingyu using 'JYZHAO';
--public dblink
create public database link to_jyzhao_ld connect to ludan identified by ludan using 'JYZHAO';

prompt ============================
prompt == 6.存储过程、函数、包、定时任务、触发器
prompt ============================
prompt 存储过程、函数、包、定时任务
prompt

prompt 6.1 存储过程：
prompt ============================
prompt
--6.1 存储过程：
--功能：可以输入雇员名，新工资，可以修改雇员的工资。
conn jingyu/jingyu
create or replace procedure p_update_sal(v_ename varchar2,v_newsal number) is
    begin
        update emp set sal=v_newsal where ename=v_ename;
        commit;
    end;
/

prompt 6.2 函数：
prompt ============================
prompt
--6.2 函数：
--功能：输入雇员的姓名，返回该雇员的年薪。
conn jingyu/jingyu
create function f_yearSal(empName varchar2) return number is
    yearSal number(7,2);
    begin
        select sal * 12 + nvl(comm,0) * 12 into yearSal from emp where ename=empName;
        return yearSal;
    end;
/

--SQL&amp;gt; 调用函数
--var income number;
--call f_yearSal('SCOTT') into:income;
--set serveroutput on
--exec dbms_output.put_line(:income);

prompt 6.3 包：
prompt ============================
prompt
--6.3 包
--package
create package pkg_emp is
    procedure p_update_sal(v_ename varchar2,v_newsal number);
    function f_yearSal(empName varchar2) return number;
end;
/

--package body
create or replace package body pkg_emp is
    procedure p_update_sal(v_ename varchar2,v_newsal number) is
        begin
            update emp set sal=v_newsal where ename=v_ename;
            commit;
        end;
    function f_yearSal(empName varchar2) return number is
        yearSal number(7,2);
        begin
            select sal * 12 + nvl(comm,0) * 12 into yearSal from emp where ename=empName;
            return yearSal;
        end;
    end;
/


--调用包中的过程：
--call pkg_emp.p_update_sal('SMITH',133);
--调用包中的函数：
--var abc number
--call pkg_emp.f_yearSal('SMITH') into:abc;

prompt 6.4 JOB：
prompt ============================
prompt
--6.4 JOB
--select OWNER, JOB_NAME, JOB_STYLE, JOB_TYPE, STATE from DBA_SCHEDULER_JOBS;
--select JOB_NAME, JOB_STYLE, JOB_TYPE, STATE from USER_SCHEDULER_JOBS;
conn ludan/ludan

--作业功能：每秒向T_TIMES表插入当前系统时间，运行1w次后终止。
BEGIN
sys.dbms_scheduler.create_job( 
job_name =&amp;gt; '&quot;JINGYU&quot;.&quot;J_INSERT&quot;',
job_type =&amp;gt; 'PLSQL_BLOCK',
job_action =&amp;gt; 'begin
  -- Insert PL/SQL code here
  insert into t_times values(sysdate);
  commit;
end;',
repeat_interval =&amp;gt; 'FREQ=SECONDLY',
start_date =&amp;gt; to_timestamp_tz('2015-12-09 05:05:00 Asia/Shanghai', 'YYYY-MM-DD HH24:MI:SS TZR'),
job_class =&amp;gt; '&quot;DEFAULT_JOB_CLASS&quot;',
comments =&amp;gt; 'Insert the current date into the T_TIMES table.',
auto_drop =&amp;gt; FALSE,
enabled =&amp;gt; FALSE);
sys.dbms_scheduler.set_attribute( name =&amp;gt; '&quot;JINGYU&quot;.&quot;J_INSERT&quot;', attribute =&amp;gt; 'max_runs', value =&amp;gt; 10000); 
END;
/

--ENABLE(启动作业)
exec dbms_scheduler.enable('&quot;JINGYU&quot;.&quot;J_INSERT&quot;');
--DISABLE(禁用作业)
--exec dbms_scheduler.disable('&quot;JINGYU&quot;.&quot;J_INSERT&quot;');
--DROP_JOB（删除作业）
--exec dbms_scheduler.drop_job('&quot;J_INSERT&quot;');



prompt 6.5 触发器：
prompt ============================
prompt
--6.5 Trigger
conn jingyu/jingyu
--功能：只要有更新emp表的操作，就会记录sal字段的变化。
--drop table aud_salary_history;
create table aud_salary_history(
empno NUMBER(4),
old_sal NUMBER(7,2),
new_sal NUMBER(7,2),
change_time varchar2(50)
);

create or replace trigger tri_sal after update
on emp
    for each row
begin
    insert into aud_salary_history VALUES
  (:OLD.empno, :OLD.sal, :NEW.sal, TO_CHAR(SYSDATE, 'yyyy-mm-dd hh24:mi:ss'));
end;
/

--update emp set sal = 1000 where empno=7369;
--select * from aud_salary_history;
--rollback;

prompt ============================
prompt ===initData Completed!!!====
prompt ============================

EOF&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;清空测试数据的脚本主要包含如下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.删除用户&lt;/li&gt;
&lt;li&gt;2.删除表空间&lt;/li&gt;
&lt;li&gt;3.删除public对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;脚本：&lt;/strong&gt;delData.sh&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
#name：delData.sh
#function：to delete data for test.
#usage: oracle用户登录，执行 sh delData.sh &amp;gt; /tmp/delData.log

#logon database
sqlplus -S / as sysdba &amp;lt;&amp;lt;EOF

prompt ============================
prompt == 1.Drop User
prompt ============================
prompt 
--drop user 
--select s.username, s.sid, s.serial#, p.spid from v$session s, v$process p where s.paddr = p.addr and s.username = 'JINGYU';
select s.username, s.sid, s.serial#, p.spid from v\$session s, v\$process p where s.paddr = p.addr and s.username is not null;
drop user ludan cascade;
drop user jingyu cascade;

prompt ============================
prompt == 2.Drop Tablespace
prompt ============================
prompt 
--drop tablespace
drop tablespace dbs_d_jingyu including contents and datafiles;
drop tablespace dbs_i_jingyu including contents and datafiles;
drop tablespace temp_jingyu including contents and datafiles;

prompt ============================
prompt == 3.Drop Public Objects
prompt ============================
prompt 
--public dblink
select dbms_metadata.get_ddl('DB_LINK',DB_LINK,'PUBLIC') FROM DBA_DB_LINKS where owner='PUBLIC';
drop public database link TO_JYZHAO_LD;
select dbms_metadata.get_ddl('DB_LINK',DB_LINK,'PUBLIC') FROM DBA_DB_LINKS where owner='PUBLIC';

--public synonym
SELECT DBMS_METADATA.GET_DDL('SYNONYM',a.SYNONYM_NAME,a.owner) FROM DBA_SYNONYMS a where a.owner ='PUBLIC' and table_owner in ('JINGYU','LUDAN');
drop public synonym PUBIC_DEPT;
drop public synonym PUBIC_EMP;
SELECT DBMS_METADATA.GET_DDL('SYNONYM',a.SYNONYM_NAME,a.owner) FROM DBA_SYNONYMS a where a.owner ='PUBLIC' and table_owner in ('JINGYU','LUDAN');

--external tables
select * from dba_external_tables;
--外部表会随用户被删除而删除,但外部表真实的文件还在，需要删除掉（rm命令危险，故注释掉手工执行）：
--!rm -rf /home/oracle/external_table

prompt ============================
prompt ===delData Completed!!!====
prompt ============================

EOF&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 14 May 2018 14:53:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/9038472.html</dc:identifier>
</item>
<item>
<title>基于ASP.NET MVC 微信网页登录授权(scope为snsapi_base) 流程  上 获取OPENID - SuiTao</title>
<link>http://www.cnblogs.com/suitao/p/9038547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/suitao/p/9038547.html</guid>
<description>&lt;p&gt;流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/933224/201805/933224-20180514214718940-503038980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们需要判断是否存在OPENID  首先我们得先定义一个全局的OPENID 类似于普通账号密码登录系统的 当前登录用户ID  因为我是MVC 框架  我这里定义一个控制器基类 BaseController 然后将OPENID定义在BaseController中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseController : Controller
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; openid
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;get&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; Session[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;openid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;set&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 Session[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;openid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然后定义一个HomeController   写一个 测试登录功能&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : BaseController
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; GET: Home&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Login()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(openid)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;openid不存在  跳转授权&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处忽略10万行授权相关代码&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处忽略3000行获取用户信息相关&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 以上为一个大概 忽略大部分无关紧要代码后的微信授权登录功能代码     当然很多人要的都不是这些  接下来 是一些更详细的代码  大概分为2个大模块&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取OPENID &lt;/li&gt;
&lt;li&gt;获取用户信息&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里我将这2个模块写成2个方法定义在WXHelper类中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WXHelper {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetOpenID() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;openid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User_UserInfo GetUserInfo() {
            User_UserInfo model_UserInfo &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User_UserInfo();

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; model_UserInfo;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后之前的Login Action 可以改成这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Login()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(openid)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;openid不存在  跳转授权&lt;/span&gt;
&lt;span&gt;            {
                openid &lt;/span&gt;=&lt;span&gt; WXHelper.GetOpenID();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LoginUserInfo 是我当前登录用户信息  你们自行找方式存 Session 或者全局变量之类的&lt;/span&gt;
            LoginUserInfo =&lt;span&gt; WXHelper.GetUserInfo();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们开始实现第一个方法    GetOpenID  &lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421140842&quot;&gt;官方API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里具体请求我就不 多说了   主意 几个地方  这里我是采用的 方式为 scope=snsapi_base  &lt;/p&gt;
&lt;p&gt;因为这里回调地址 无法写本地地址进行调试 所以我采用 手动记录code  并在有效期内手动在本地写入code 继续往下调试&lt;/p&gt;
&lt;p&gt;不情愿的贴上代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取code 方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetWeChat_Code()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; urlhead = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; rediretUrl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https%3a%2f%2fxxxx.com%2fHome%2fLoadCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; strUrl = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{urlhead}open.weixin.qq.com/connect/oauth2/authorize?appid={appid}&amp;amp;redirect_uri={rediretUrl}&amp;amp;response_type=code&amp;amp;scope=snsapi_base&amp;amp;state=qwe12e12e#wechat_redirect&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处省略n行get请求方法&lt;/span&gt;
        }    
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;细心的朋友可能会发现上面的redireUrl 地址指向的是Home 控制器下面 LoadCode 这个 方法  SO&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;#region&lt;/span&gt; 微信授权回调
        &lt;span&gt;public&lt;/span&gt; ActionResult LoadCode(&lt;span&gt;string&lt;/span&gt; code, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; state)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;因为MVC 的参数映射 所以我只需要把 code  和state  写成方法参数即可 这里我就可以获取到code方法了 然后我们直接通过code 获取OPENID &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;#region&lt;/span&gt; 获取OpenID

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetOpenId(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; code)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; urlhead = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; strUrl = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{urlhead}api.weixin.qq.com/sns/oauth2/access_token?appid={appid}&amp;amp;secret={secret}&amp;amp;code={code}&amp;amp;grant_type=authorization_code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            Access_openid token &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Access_openid();
            HttpWebRequest req &lt;/span&gt;= (HttpWebRequest)HttpWebRequest.Create(strUrl);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用GET形式请求指定的地址 &lt;/span&gt;
            req.Method = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (WebResponse wr =&lt;span&gt; req.GetResponse())
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HttpWebResponse myResponse = (HttpWebResponse)req.GetResponse();  &lt;/span&gt;
                StreamReader reader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(wr.GetResponseStream(), Encoding.UTF8);
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; content =&lt;span&gt; reader.ReadToEnd();
                reader.Close();
                reader.Dispose();

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在这里对Access_token 赋值  &lt;/span&gt;
                token = JsonConvert.DeserializeObject&amp;lt;Access_openid&amp;gt;&lt;span&gt;(content);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; token.openid;
        }

        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果有人对这个Access_openid 对象感到懵逼的话  这里说一下 这个对象就是下图中 红框 获取到的JSON数据 的对象 这里我们是  snsapi_base  所以只需要 openid 切 整个授权过程到次结束&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/933224/201805/933224-20180514221448285-298646113.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 14 May 2018 14:36:00 +0000</pubDate>
<dc:creator>SuiTao</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/suitao/p/9038547.html</dc:identifier>
</item>
<item>
<title>flask模板 - renpingsheng</title>
<link>http://www.cnblogs.com/renpingsheng/p/9038533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renpingsheng/p/9038533.html</guid>
<description>&lt;p&gt;做为python web开发领域的一员，flask跟Django在很多地方用法以都是相似的，比如flask的模板&lt;/p&gt;
&lt;p&gt;模板就是服务器端的页面，在模板中可以使用服务端的语法进行输出控制&lt;/p&gt;
&lt;h2 id=&quot;模板的工作原理&quot;&gt;1.模板的工作原理&lt;/h2&gt;
&lt;p&gt;在视图函数中，通过&lt;code&gt;render_template&lt;/code&gt;方法返回一个页面，然后通过Jinja2语法来进行渲染&lt;/p&gt;
&lt;p&gt;简单来说，就是把服务器端的html页面解释成用户看到的页面，而视图函数是通过上下文对象来进行变量的传递&lt;/p&gt;
&lt;p&gt;在项目开发中，视图函数经常会把一些服务器处理完成的变量传递给前端页面进行渲染，&lt;/p&gt;
&lt;p&gt;比如在下面的例子中，由&lt;code&gt;render_template&lt;/code&gt;返回html页面时，携带一些变量数据给Jinja2语法进行渲染&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;13&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Flask, render_template

app &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Flask(&lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt;)
app.debug &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;

&lt;span class=&quot;at&quot;&gt;@app.route&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; hello_world():
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Hello World!'&lt;/span&gt;

&lt;span class=&quot;at&quot;&gt;@app.route&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/detail'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; detail():
    message &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {
        &lt;span class=&quot;st&quot;&gt;'name'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'jack'&lt;/span&gt;,
        &lt;span class=&quot;co&quot;&gt;'text'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'杰克'&lt;/span&gt;
    }
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; render_template(&lt;span class=&quot;st&quot;&gt;'detail.html'&lt;/span&gt;,info&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;message)

&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'__main__'&lt;/span&gt;:
    app.run(debug&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前端页面detail.html内容为：&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;8&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Title&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;{{ info.name }}详细信息&lt;span class=&quot;kw&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    我的名字叫：{{ info.text }}
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动项目，浏览器打开&lt;code&gt;http://127.0.0.1:5000/detail&lt;/code&gt;页面，前端页面渲染后效果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1133627/201805/1133627-20180514223019668-153588341.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么此时，如果后台返回给前端的变量为一段html代码，返回给前端经过Jinja2语法渲染后，效果会是怎么样的呢？？&lt;/p&gt;
&lt;h2 id=&quot;jinja2语法安全机制&quot;&gt;2.Jinja2语法安全机制&lt;/h2&gt;
&lt;p&gt;修改message变量，然后由render_template返回&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;10&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;at&quot;&gt;@app.route&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/detail'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; detail():
    message &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {
        &lt;span class=&quot;st&quot;&gt;'name'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'jack'&lt;/span&gt;,
        &lt;span class=&quot;co&quot;&gt;'text'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'&amp;lt;h2&amp;gt;杰克&amp;lt;/h2&amp;gt;'&lt;/span&gt;
    }
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; render_template(&lt;span class=&quot;st&quot;&gt;'detail.html'&lt;/span&gt;,info&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;message)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前端页面不变，刷新浏览器，效果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1133627/201805/1133627-20180514223029235-1752825641.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，返回的变量中包含html代码，但是Jinja2语法并没有对这一小段代码进行渲染，而是直接显示了出来&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;实际上这是为了安全，因为如果后台返回的html代码中包含恶意的js代码，如果直接就渲染了，会造成站点被攻击。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那如果我就是想渲染后台返回给前端的HTML代码，那应该怎么办呢&lt;/p&gt;
&lt;p&gt;在flask中，如果确认后台返回给前端进行渲染的变量中包含的HTML代码是安全的，则可以使用一些方法来对这段HTML代码也进行渲染&lt;/p&gt;
&lt;h3 id=&quot;方法一autoescape-关闭安全机制&quot;&gt;方法一：autoescape 关闭安全机制&lt;/h3&gt;
&lt;p&gt;这种方法与Django的模板语法相同&lt;/p&gt;
&lt;p&gt;后台代码不变，修改前端detail.html代码&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Title&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
{% autoescape false %}
&lt;span class=&quot;kw&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;{{ info.name }}详细信息&lt;span class=&quot;kw&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    我的名字叫：{{ info.text }}
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
{% endautoescape %}
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，再次刷新页面，查看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1133627/201805/1133627-20180514223039083-2049570692.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;方法二调用jinja2的safe过滤器&quot;&gt;方法二，调用Jinja2的safe过滤器&lt;/h3&gt;
&lt;p&gt;如果觉得第一种方法有点麻烦，可以使用第二种方法&lt;/p&gt;
&lt;p&gt;后台代码不变，同样修改detail.html页面&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Title&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;{{ info.name }}详细信息&lt;span class=&quot;kw&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    我的名字叫：{{ info.text | safe }}
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，再次刷新页面，效果跟第一种方法一样&lt;/p&gt;
&lt;p&gt;在flask中，Jinja2语法提供了很多过滤器，可以在下面的地址进行查找&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://jinja.pocoo.org/docs/dev/templates/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义过滤器&quot;&gt;3.自定义过滤器&lt;/h2&gt;
&lt;p&gt;在写文章或博客的时候，很多时候都会用到Markdown语法&lt;/p&gt;
&lt;p&gt;在flask的Jinja2语法中，并没有标准的Markdown语法过滤器，此时可以使用扩展来自定义Markdown语法过滤器&lt;/p&gt;
&lt;p&gt;修改flask项目文件&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;14&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Flask, render_template

app &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Flask(&lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt;)
app.debug &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;

&lt;span class=&quot;at&quot;&gt;@app.route&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; hello_world():
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Hello World!'&lt;/span&gt;

&lt;span class=&quot;at&quot;&gt;@app.route&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/detail'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; detail():
    message &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {
        &lt;span class=&quot;st&quot;&gt;'name'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'jack'&lt;/span&gt;,
        &lt;span class=&quot;co&quot;&gt;'text'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'&amp;lt;h2&amp;gt;杰克&amp;lt;/h2&amp;gt;'&lt;/span&gt;
    }
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; render_template(&lt;span class=&quot;st&quot;&gt;'detail.html'&lt;/span&gt;,info&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;message,markdown&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'## Markdown编辑器&amp;lt;br&amp;gt;`注释`'&lt;/span&gt;)

&lt;span class=&quot;at&quot;&gt;@app.template_filter&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'md'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; markdown_html(txt):
    &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; markdown &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; markdown
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; markdown(txt)

&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'__main__'&lt;/span&gt;:
    app.run(debug&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改detail.html前端页面&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Title&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;{{ info.name }}详细信息&lt;span class=&quot;kw&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    我的名字叫：{{ info.text | safe }}
    {{ markdown | md | safe }}
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;刷新浏览器，查看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1133627/201805/1133627-20180514223049570-154627894.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在实际开发中，&lt;code&gt;后台向模板中传递的不只有变量和filter，还可能会向前端传递一个方法&lt;/code&gt;，此时可以使用flask的上下文来实现&lt;/p&gt;
&lt;p&gt;修改flask项目文件&lt;/p&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;17&quot;&gt;
&lt;pre class=&quot;sourceCode python&quot;&gt;
&lt;code class=&quot;sourceCode python&quot;&gt;&lt;span class=&quot;co&quot;&gt;#-*- coding: utf-8 -*-&lt;/span&gt;

&lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; Flask, render_template

app &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; Flask(&lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt;)
app.debug &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;

&lt;span class=&quot;at&quot;&gt;@app.route&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; hello_world():
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'Hello World!'&lt;/span&gt;

&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; read_md(filename):
    &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; functools &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;reduce&lt;/span&gt;
    &lt;span class=&quot;cf&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;open&lt;/span&gt;(filename,encoding&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'utf-8'&lt;/span&gt;) &lt;span class=&quot;im&quot;&gt;as&lt;/span&gt; md_file:
        content &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;reduce&lt;/span&gt;(&lt;span class=&quot;kw&quot;&gt;lambda&lt;/span&gt; x,y:x &lt;span class=&quot;op&quot;&gt;+&lt;/span&gt; y, md_file.readlines())
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; content

&lt;span class=&quot;at&quot;&gt;@app.context_processor&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; methods():
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;bu&quot;&gt;dict&lt;/span&gt;(read_md&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;read_md)

&lt;span class=&quot;at&quot;&gt;@app.route&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'/detail'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; detail():
    message &lt;span class=&quot;op&quot;&gt;=&lt;/span&gt; {
        &lt;span class=&quot;st&quot;&gt;'name'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'jack'&lt;/span&gt;,
        &lt;span class=&quot;co&quot;&gt;'text'&lt;/span&gt;:&lt;span class=&quot;st&quot;&gt;'&amp;lt;h2&amp;gt;杰克&amp;lt;/h2&amp;gt;'&lt;/span&gt;
    }
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; render_template(&lt;span class=&quot;st&quot;&gt;'detail.html'&lt;/span&gt;,info&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;message,markdown&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;'## Markdown'&lt;/span&gt;)

&lt;span class=&quot;at&quot;&gt;@app.template_filter&lt;/span&gt;(&lt;span class=&quot;st&quot;&gt;'md'&lt;/span&gt;)
&lt;span class=&quot;kw&quot;&gt;def&lt;/span&gt; markdown_html(txt):
    &lt;span class=&quot;im&quot;&gt;from&lt;/span&gt; markdown &lt;span class=&quot;im&quot;&gt;import&lt;/span&gt; markdown
    &lt;span class=&quot;cf&quot;&gt;return&lt;/span&gt; markdown(txt)

&lt;span class=&quot;cf&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;va&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;op&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;st&quot;&gt;'__main__'&lt;/span&gt;:
    app.run(debug&lt;span class=&quot;op&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;va&quot;&gt;True&lt;/span&gt;)&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想在Jinja2语法中调用后台定义的某个函数时，比如在这个例子中，前端页面中调用后台定义的read_md方法来处理某个Markdown格式的文件时，可以使用&lt;code&gt;context_processor上下文处理器&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在项目中应用了context_processor时，&lt;code&gt;flask会把context_processor装饰的方法注册到Jinja2模板语法中&lt;/code&gt;来，这样就可以在Jinja2语法中调用后台的方法了&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;用context_processor装饰的后台方法可以在前端所有的Jinja2语法中调用&lt;br/&gt;修改前端页面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;sourceCode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;sourceCode html&quot;&gt;
&lt;code class=&quot;sourceCode html&quot;&gt;&lt;span class=&quot;dt&quot;&gt;&amp;lt;!DOCTYPE &lt;/span&gt;html&lt;span class=&quot;dt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;html&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; lang=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;meta&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; charset=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kw&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Title&lt;span class=&quot;kw&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;{{ info.name }}详细信息&lt;span class=&quot;kw&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
    我的名字叫：{{ info.text | safe }}
    {{ markdown | md | safe }}
    {{ read_md('editor.md') |md| safe}}
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kw&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;刷新浏览器，查看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1133627/201805/1133627-20180514223104986-147615258.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用过滤器和context_processor配置一起使用时，可以很灵活的进行页面的渲染&lt;/p&gt;
</description>
<pubDate>Mon, 14 May 2018 14:32:00 +0000</pubDate>
<dc:creator>renpingsheng</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renpingsheng/p/9038533.html</dc:identifier>
</item>
<item>
<title>嵌入Python | 调用Python模块中有参数的函数 - 林哥学堂</title>
<link>http://www.cnblogs.com/zhanglin-0/p/9038450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanglin-0/p/9038450.html</guid>
<description>&lt;div id=&quot;output_wrapper_id&quot; class=&quot;output_wrapper&quot; readability=&quot;21.660869565217&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;开发环境&lt;br/&gt;Python版本：3.6.4 (32-bit)&lt;br/&gt;编辑器：Visual Studio Code&lt;br/&gt;C++环境：Visual Studio 2013&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;需求说明&lt;/code&gt;&lt;br/&gt;前一篇&lt;a href=&quot;http://www.cnblogs.com/zhanglin-0/p/9032194.html&quot; target=&quot;_blank&quot;&gt;《嵌入Python|调用无参数的函数》&lt;/a&gt;中我们成功的在C++主程序中嵌入了Python，并且调用了Python模块中的一个无参数的函数。这一篇我们将在此基础上，实现在主程序中调用Python模块中有参数的函数，&lt;code&gt;使两者互动起来&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;h0say_hipy&quot;&gt;&lt;span&gt;0 准备say_hi.py模块&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在say_hi.py中增加含有一个参数的函数prt_hello和含有两个参数的函数zl_add，完整代码如下图：&lt;br/&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1119441/201805/1119441-20180514220740728-1965420984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;h1&quot;&gt;&lt;span&gt;1 主程序中调用含有一个参数的函数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;将主程序中的数据作为参数直接传入Python模块中函数，肯定是不行的，这中间需要进行转换。&lt;code&gt;参数要以tuple元组的形式传入&lt;/code&gt;，即需将主程序的数据转换为元组。&lt;br/&gt;主程序源代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1119441/201805/1119441-20180514220804923-867281313.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主程序运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1119441/201805/1119441-20180514220829657-589252696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;h2&quot;&gt;&lt;span&gt;2 主程序中调用含有两个参数的函数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;通过如下示例介绍一下两种构造参数元组的方法：&lt;br/&gt;主程序源代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1119441/201805/1119441-20180514220854178-1681880914.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主程序运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/1119441/201805/1119441-20180514220910752-2050521174.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;其它情况下的参数类似以上的处理方法，详细参考官方文档：&lt;a href=&quot;https://docs.python.org/3/c-api/arg.html#building-values&quot; target=&quot;_blank&quot;&gt;https://docs.python.org/3/c-api/arg.html#building-values&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;h3&quot;&gt;&lt;span&gt;3 下篇预告&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在主程序中对Python模块中&lt;code&gt;函数的返回值&lt;/code&gt;加以解析&lt;/li&gt;
&lt;li&gt;总结&lt;code&gt;Py_BuildValue&lt;/code&gt;的用法&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
</description>
<pubDate>Mon, 14 May 2018 14:12:00 +0000</pubDate>
<dc:creator>林哥学堂</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanglin-0/p/9038450.html</dc:identifier>
</item>
<item>
<title>Java并发之ReentrantReadWriteLock - 数月亮</title>
<link>http://www.cnblogs.com/gemine/p/9038205.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gemine/p/9038205.html</guid>
<description>&lt;p&gt;        上篇文章简单的介绍了ReentrantLock可重入锁。事实上我们可以理解可重入锁是一种排他锁，排他锁在同一个时刻只能够由一个线程进行访问。这就与我们实际使用过程中有点不想符合了，比如说当我们进行读写文件操作的时候，我们可能允许多个线程进行读文件操作，而对写文件只需要控制一个线程既可以。在这种业务情况下如果使用排他锁，可能不太符合而且效率也可能有些低下。&lt;/p&gt;
&lt;p&gt;        一、ReentrantReadWriteLock介绍&lt;/p&gt;
&lt;p&gt;读写锁维护了一对锁，一个读锁和一个写锁。通过分离读锁和写锁使得并发性相比一般的排他锁在性能上有更好的一些优势。&lt;/p&gt;
&lt;p&gt;        二、ReentrantReadWriteLock的特性&lt;/p&gt;
&lt;p&gt;公平性选择：支持公平锁和非公平锁。&lt;/p&gt;
&lt;p&gt;可重入性：支持可重入性。例读线程获取了读锁以后可以继续获取读锁。写线程获取写锁以后可以继续获取写锁。&lt;/p&gt;
&lt;p&gt;锁降级：遵循获取读锁，获取写锁在释放写锁的次序。支持写锁降级为读锁。&lt;/p&gt;
&lt;p&gt;        三、接口和API&lt;/p&gt;
&lt;p&gt;读写锁ReentrantReadWriteLock实现接口ReadWriteLock。接口ReadWriteLock实现了两个方法。&lt;/p&gt;
&lt;p&gt;即readLock()方法和writeLock()方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; public interface ReadWriteLock {
&lt;span&gt;  2&lt;/span&gt;        Lock readLock();
&lt;span&gt;  3&lt;/span&gt;        Lock writeLock();
&lt;span&gt;  4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ReentrantReadWriteLock定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     /** 内部类  读锁 */
&lt;span&gt;  2&lt;/span&gt;     private final ReentrantReadWriteLock.ReadLock readerLock;
&lt;span&gt;  3&lt;/span&gt;     /** 内部类  写锁 */
&lt;span&gt;  4&lt;/span&gt;     private final ReentrantReadWriteLock.WriteLock writerLock;
&lt;span&gt;  5&lt;/span&gt;     final Sync sync;
&lt;span&gt;  6&lt;/span&gt;     /** 使用默认（非公平）的排序属性创建一个新的 ReentrantReadWriteLock */
&lt;span&gt;  7&lt;/span&gt;     public ReentrantReadWriteLock() {
&lt;span&gt;  8&lt;/span&gt;         this(false);
&lt;span&gt;  9&lt;/span&gt;     }
&lt;span&gt; 10&lt;/span&gt;     /** 使用给定的公平策略创建一个新的 ReentrantReadWriteLock */
&lt;span&gt; 11&lt;/span&gt;     public ReentrantReadWriteLock(boolean fair) {
&lt;span&gt; 12&lt;/span&gt;         sync = fair ? new FairSync() : new NonfairSync();
&lt;span&gt; 13&lt;/span&gt;         readerLock = new ReadLock(this);
&lt;span&gt; 14&lt;/span&gt;         writerLock = new WriteLock(this);
&lt;span&gt; 15&lt;/span&gt;     }
&lt;span&gt; 16&lt;/span&gt;     /** 返回用于写入操作的锁 */
&lt;span&gt; 17&lt;/span&gt;     public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }
&lt;span&gt; 18&lt;/span&gt;     /** 返回用于读取操作的锁 */
&lt;span&gt; 19&lt;/span&gt;     public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }
&lt;span&gt; 20&lt;/span&gt;     abstract static class Sync extends AbstractQueuedSynchronizer {
&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt;     }
&lt;span&gt; 23&lt;/span&gt;     public static class WriteLock implements Lock, java.io.Serializable{
&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt;     }
&lt;span&gt; 26&lt;/span&gt;     public static class ReadLock implements Lock, java.io.Serializable {
&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举例读写锁使用。使用读写锁将线程不安全的HashMap集合缓存变为线程安全的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; public class Cache {
&lt;span&gt;  2&lt;/span&gt;     static Map&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Object&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; map = new HashMap&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;Object&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;(); static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); static Lock r = rwl.readLock();
&lt;span&gt;  3&lt;/span&gt;     static Lock w = rwl.writeLock();
&lt;span&gt;  4&lt;/span&gt;     // 获取一个key对应的value
&lt;span&gt;  5&lt;/span&gt;     public static final Object get(String key) {
&lt;span&gt;  6&lt;/span&gt;         r.lock(); try {
&lt;span&gt;  7&lt;/span&gt;             return map.get(key);
&lt;span&gt;  8&lt;/span&gt;         } finally {
&lt;span&gt;  9&lt;/span&gt;             r.unlock();
&lt;span&gt; 10&lt;/span&gt;         }
&lt;span&gt; 11&lt;/span&gt;     }
&lt;span&gt; 12&lt;/span&gt;     // 设置key对应的value，并返回旧的value
&lt;span&gt; 13&lt;/span&gt;     public static final Object put(String key, Object value) {
&lt;span&gt; 14&lt;/span&gt;         w.lock(); try {
&lt;span&gt; 15&lt;/span&gt;             return map.put(key, value);
&lt;span&gt; 16&lt;/span&gt;         } finally {
&lt;span&gt; 17&lt;/span&gt;             w.unlock();
&lt;span&gt; 18&lt;/span&gt;         }
&lt;span&gt; 19&lt;/span&gt;     }
&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt;     // 清空所有的内容
&lt;span&gt; 22&lt;/span&gt;     public static final void clear() {
&lt;span&gt; 23&lt;/span&gt;         w.lock(); try {
&lt;span&gt; 24&lt;/span&gt;             map.clear();
&lt;span&gt; 25&lt;/span&gt;         } finally {
&lt;span&gt; 26&lt;/span&gt;             w.unlock();
&lt;span&gt; 27&lt;/span&gt;         }
&lt;span&gt; 28&lt;/span&gt;     }
&lt;span&gt; 29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;         四、读写锁的实现简单分析&lt;/p&gt;
&lt;p&gt;在ReentrantLock中使用一个int类型的state来表示同步状态，该值表示锁被一个线程重复获取的次数。但是读写锁ReentrantReadWriteLock内部维护着一对锁，需要用一个变量维护多种状态。所以读写锁采用“按位切割使用”的方式来维护这个变量，将其切分为两部分，高16为表示读，低16为表示写。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://images2018.cnblogs.com/blog/648116/201805/648116-20180514211514624-74480027.png&quot;&gt;&lt;img width=&quot;500&quot; height=&quot;227&quot; title=&quot;2018-05-14_203211&quot; alt=&quot;2018-05-14_203211&quot; src=&quot;https://images2018.cnblogs.com/blog/648116/201805/648116-20180514211515598-1638745408.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当前同步状态表示一个线程已经获取了写锁，且重进入了两次，同时也连续获取了两次读锁。那么读写锁是如何迅速确定读锁和写锁的状态呢？通过为运算。假如当前同步状态为S，那么写状态等于 &lt;strong&gt;S &amp;amp; 0x0000FFFF（将高16位全部抹去）&lt;/strong&gt;，读状态等于&lt;strong&gt;S &amp;gt;&amp;gt;&amp;gt; 16(无符号补0右移16位)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;        4.1、写锁的获取。写锁是一个可支持重入的排他锁。写锁的获取最终会调用tryAcquire(int arg)。注意：如果存在读锁，则写锁不能被获取，原因在于：读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当 前写线程的操作。&lt;/p&gt;
&lt;p&gt;源码中该方法为以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;  protected final boolean tryAcquire(int acquires) {
&lt;span&gt;  2&lt;/span&gt;         Thread current = Thread.currentThread();
&lt;span&gt;  3&lt;/span&gt;         //当前锁个数
&lt;span&gt;  4&lt;/span&gt;         int c = getState();
&lt;span&gt;  5&lt;/span&gt;         //写锁
&lt;span&gt;  6&lt;/span&gt;         int w = exclusiveCount(c);
&lt;span&gt;  7&lt;/span&gt;         if (c != 0) {
&lt;span&gt;  8&lt;/span&gt;             //c != 0 &amp;amp;&amp;amp; w == 0 表示存在读锁
&lt;span&gt;  9&lt;/span&gt;             //当前线程不是已经获取写锁的线程
&lt;span&gt; 10&lt;/span&gt;             if (w == 0 || current != getExclusiveOwnerThread())
&lt;span&gt; 11&lt;/span&gt;                 return false;
&lt;span&gt; 12&lt;/span&gt;             //超出最大范围
&lt;span&gt; 13&lt;/span&gt;             if (w + exclusiveCount(acquires) &amp;gt; MAX_COUNT)
&lt;span&gt; 14&lt;/span&gt;                 throw new Error(&quot;Maximum lock count exceeded&quot;);
&lt;span&gt; 15&lt;/span&gt;             setState(c + acquires);
&lt;span&gt; 16&lt;/span&gt;             return true;
&lt;span&gt; 17&lt;/span&gt;         }
&lt;span&gt; 18&lt;/span&gt;         //是否需要阻塞
&lt;span&gt; 19&lt;/span&gt;         if (writerShouldBlock() ||
&lt;span&gt; 20&lt;/span&gt;                 !compareAndSetState(c, c + acquires))
&lt;span&gt; 21&lt;/span&gt;             return false;
&lt;span&gt; 22&lt;/span&gt;         //设置获取锁的线程为当前线程
&lt;span&gt; 23&lt;/span&gt;         setExclusiveOwnerThread(current);
&lt;span&gt; 24&lt;/span&gt;         return true;
&lt;span&gt; 25&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        4.2、写锁的释放：当写锁中写锁的状态值为0的时候。从而等待的线程这个时候可以获取读写锁了。&lt;/p&gt;
&lt;p&gt;       4.3、读锁的获取：读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态(依靠CAS保证线程安全)。如果当前线程在获取读锁时，写锁已被其他线程 获取，则进入等待状态。&lt;/p&gt;
&lt;p&gt;       4.4、读锁的释放：读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的值是（1&amp;lt;&amp;lt;16）。&lt;/p&gt;
&lt;p&gt;       五、锁降级&lt;/p&gt;
&lt;p&gt;锁降级指的是写锁降级为读锁的情况。详细具体指的是当前拥有写锁的线程，在获取到读锁，然后在释放写锁的过程。注意：如果当前线程拥有写锁，然后将其释放，最后再获取读 锁，这种分段完成的过程不能称之为锁降级。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; public void processData() {
&lt;span&gt;  2&lt;/span&gt;     readLock.lock();
&lt;span&gt;  3&lt;/span&gt;     if (!update) {
&lt;span&gt;  4&lt;/span&gt;     // 必须先释放读锁
&lt;span&gt;  5&lt;/span&gt;     readLock.unlock();
&lt;span&gt;  6&lt;/span&gt;     // 锁降级从写锁获取到开始
&lt;span&gt;  7&lt;/span&gt;     writeLock.lock();
&lt;span&gt;  8&lt;/span&gt;     try {
&lt;span&gt;  9&lt;/span&gt;       if (!update) {
&lt;span&gt; 10&lt;/span&gt;       // 准备数据的流程（略）
&lt;span&gt; 11&lt;/span&gt;       update = true;
&lt;span&gt; 12&lt;/span&gt;     } 
&lt;span&gt; 13&lt;/span&gt;     readLock.lock();
&lt;span&gt; 14&lt;/span&gt;     } finally {
&lt;span&gt; 15&lt;/span&gt;       writeLock.unlock();
&lt;span&gt; 17&lt;/span&gt;    }
&lt;span&gt; 18&lt;/span&gt;    try {
&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt;    }
&lt;span&gt; 21&lt;/span&gt;    // 锁降级完成，写锁降级为读锁
&lt;span&gt; 22&lt;/span&gt;    // 使用数据的流程（略）
&lt;span&gt; 23&lt;/span&gt;    } finally {
&lt;span&gt; 24&lt;/span&gt;      readLock.unlock();
&lt;span&gt; 25&lt;/span&gt;    }
&lt;span&gt; 26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;锁降级中读锁的获取是否必要呢？答案是必要的。主要是为了保证数据的可见性，如果当前A线程不获取读锁而是直接释放写锁，假设此刻另一个线程B获取了写锁并修改了数据，那么当前A线程无法感知线程B的数据更新。如果当前线程A获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进 行数据更新。&lt;/p&gt;
&lt;p&gt;RentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程）。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了 数据，则其更新对其他获取到读锁的线程是不可见的。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;1、Java并发编程的艺术&lt;/p&gt;
&lt;p&gt;2、Java并发编程网&lt;/p&gt;
</description>
<pubDate>Mon, 14 May 2018 13:15:00 +0000</pubDate>
<dc:creator>数月亮</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gemine/p/9038205.html</dc:identifier>
</item>
<item>
<title>Java动态代理（一） - 鹏&amp;鹏</title>
<link>http://www.cnblogs.com/liaoweipeng/p/9038030.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liaoweipeng/p/9038030.html</guid>
<description>&lt;p&gt;　　好久没有动笔了，最近想巩固一下自己的基础知识，最近听到一同事问为什么JDK动态代理不能代理类，一听感觉懵逼呀！自己好像也不能很好的描述出来，所以想用2篇文章来复习一下动态代理知识；&lt;/p&gt;
&lt;h2&gt;一、什么是静态代理？什么是动态代理？　　&lt;/h2&gt;
&lt;p&gt;　　静态代理：&lt;br/&gt;　　　　静态代理是在写代码中就把各个代理关系给理清了，在编译期就确定了类之间的关系；&lt;br/&gt;　　动态代理：&lt;br/&gt;　　　　在程序运行期间根据需要动态的创建代理类及其实例，来完成具体的功能；&lt;/p&gt;
&lt;h2&gt;二、为什么要使用代理？　　&lt;/h2&gt;
&lt;p&gt;　　兄弟，你打方法的出入参的代码可以推一个房子了吧。使用代理可以将代码解耦，很多时候我们只要去关注我们最核心的实现，一些其他方面我可以交给代理去实现。最好的说明就是我们日常的AOP日志了，就是靠代理实现的。&lt;/p&gt;
&lt;h2&gt;三、简单的代理实现　　&lt;/h2&gt;
&lt;p&gt;　　静态代理的简单实现代码参考我前面的代理模式的代码：&lt;br/&gt;　　今天我们先要写一下动态代理的简单代码：　　&lt;/p&gt;
&lt;h3&gt;　  InvocationHandler　　　　&lt;/h3&gt;
&lt;p&gt;　　　　InvocationHandler是JDK中提供的专门用于实现基于接口的动态代理的接口，主要用于进行方法调用模块，而代理类和实例的生成需要借助Proxy类完成。每个代理类的实例的调用处理器都是实现该接口实现的，而且是必备的，即每个动态代理实例的实现都必须拥有实现该接口的调用处理器，也可以这么说，每个动态代理实例都对应一个调用处理器。这里要区分两个概念，代理类和代理实例，调用处理器是在创建代理实例的时候才与其关联起来的，所以它与代理实例是一一对应的，而不是代理类。 　　&lt;/p&gt;
&lt;h3&gt;　　Proxy　　　　&lt;/h3&gt;
&lt;p&gt;　　　　Proxy类是JDK提供的用于生成动态代理类和其实例的类。我们可以通过Proxy中的静态方法getProxyClass来生成代理类，需要的参数为类加载器和接口列表（数组），然后再通过反射调用代理类的构造器来生成代理实例，需要以一个InvocationHandler作为参数（体现出方法调用是与实例相关的，而非类）。&lt;br/&gt;　　了解了上面我们开始写代码实现：&lt;/p&gt;
&lt;p&gt;　　先写一个接口UserService,里面包含一个根据id查询用户名的方法，我们在这个查询方法的前后打印出出入参&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 1 package&lt;span&gt; com.roc.study.proxy;
 2 
 3 /**
 4  * &amp;lt;code&amp;gt;用户service&amp;lt;/code&amp;gt;
 5  * &amp;lt;b&amp;gt;Note&amp;lt;/b&amp;gt;
 6  *
 7  * @author liaowp
 8  * @see
 9  * @since 2018/5/14
10  */
11 
12 public interface&lt;span&gt; UserService {
13 
14     /**
15      * 查询用户名称
16      * @param id
17      * @return
18      */
19 &lt;span&gt;    String getUserName(Integer id);
20 
21 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 package&lt;span&gt; com.roc.study.proxy;
 2 
 3 /**
 4  * &amp;lt;code&amp;gt;用户service实现类&amp;lt;/code&amp;gt;
 5  * &amp;lt;b&amp;gt;Note&amp;lt;/b&amp;gt;
 6  *
 7  * @author liaowp
 8  * @see
 9  * @since 2018/5/14
10  */
11 public class UserServiceImpl implements&lt;span&gt; UserService {
12 
13     /**
14      * 查询用户名称
15      *
16      * @return
17      */
18 &lt;span&gt;    @Override
19     public&lt;span&gt; String getUserName(Integer id) {
20         System.out.println(&quot;liaowp&quot;&lt;span&gt;);
21         return &quot;liaowp&quot;&lt;span&gt;;
22 &lt;span&gt;    }
23 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
 1 package&lt;span&gt; com.roc.study.proxy;
 2 
 3 import&lt;span&gt; java.lang.reflect.InvocationHandler;
 4 import&lt;span&gt; java.lang.reflect.Method;
 5 import&lt;span&gt; java.lang.reflect.Proxy;
 6 
 7 /**
 8  * &amp;lt;code&amp;gt;用户代理类&amp;lt;/code&amp;gt;
 9  * &amp;lt;b&amp;gt;Note&amp;lt;/b&amp;gt;
10  *
11  * @author liaowp
12  * @see
13  * @since 2018/5/14
14  */
15 
16 public class UserInvocationHandler implements&lt;span&gt; InvocationHandler {
17 
18     private&lt;span&gt; Object target;
19 
20     public&lt;span&gt; UserInvocationHandler(Object target) {
21         this.target =&lt;span&gt; target;
22 &lt;span&gt;    }
23 
24     /**
25      * 在代理实例上处理方法调用并返回结果。
26      * 当在与其关联的代理实例上调用方法时，将在调用处理程序上调用此方法。
27      * @param proxy 我们所代理的那个真实对象
28      * @param method 方法
29      * @param args 入参
30      * @return
31      * @throws Throwable
32      */
33 &lt;span&gt;    @Override
34     public Object invoke(Object proxy, Method method, Object[] args) throws&lt;span&gt; Throwable {
35         System.out.println(&quot;入参args-&amp;gt;&quot; +&lt;span&gt; args);
36         // 执行目标对象的方法
37         Object result =&lt;span&gt; method.invoke(target, args);
38         System.out.println(&quot;出参args-&amp;gt;&quot;+&lt;span&gt;result.toString());
39         return&lt;span&gt; result;
40 &lt;span&gt;    }
41 
42     /**
43      * 获取目标对象的代理对象
44      * @return 代理对象
45      */
46     public&lt;span&gt; Object getProxy() {
47         return&lt;span&gt; Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),
48                 target.getClass().getInterfaces(), this&lt;span&gt;);
49 &lt;span&gt;    }
50 
51 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; com.roc.study.proxy;

/**
 * &amp;lt;code&amp;gt;代理测试类&amp;lt;/code&amp;gt;
 * &amp;lt;b&amp;gt;Note&amp;lt;/b&amp;gt;
 *
 * @author liaowp
 * @see
 * @since 2018/5/14
 */
public class&lt;span&gt; ProxyTest {

    public static void&lt;span&gt; main(String[] args) {
        UserService userService = new&lt;span&gt; UserServiceImpl();
        UserInvocationHandler userInvocationHandler = new&lt;span&gt; UserInvocationHandler(userService);
        // 根据目标对象生成代理对象
        UserService proxy =&lt;span&gt; (UserService) userInvocationHandler.getProxy();
        // 调用代理对象的方法
        proxy.getUserName(1&lt;span&gt;);
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;入参args-&amp;gt;[Ljava.lang.Object;@5cad8086&lt;br/&gt;liaowp&lt;br/&gt;出参args-&amp;gt;liaowp&lt;/p&gt;
&lt;p&gt;Process finished with exit code 0&lt;/p&gt;
</description>
<pubDate>Mon, 14 May 2018 13:07:00 +0000</pubDate>
<dc:creator>鹏&amp;amp;鹏</dc:creator>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liaoweipeng/p/9038030.html</dc:identifier>
</item>
</channel>
</rss>