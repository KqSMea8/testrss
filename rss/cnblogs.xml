<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>php 中 exit()的作用 - JinFish</title>
<link>http://www.cnblogs.com/huangshizhou/p/9823501.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangshizhou/p/9823501.html</guid>
<description>&lt;p&gt;exit() 函数输出一条消息，并退出当前脚本。&lt;/p&gt;
&lt;p&gt;该函数是 &lt;a title=&quot;PHP die() 函数&quot; href=&quot;http://www.w3school.com.cn/php/func_misc_die.asp&quot;&gt;die()&lt;/a&gt; 函数的别名。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE html&amp;gt;

&amp;lt;html&amp;gt;
 
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
&amp;lt;title&amp;gt;无标题文档&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
 
&amp;lt;body&amp;gt;&lt;span&gt;
这是一句话
&lt;/span&gt;&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;这是第一句话&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;exit&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;这是第二句话&quot;&lt;span&gt;;
&lt;/span&gt;?&amp;gt;


&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;这是第三句话&quot;&lt;span&gt;;
&lt;/span&gt;?&amp;gt;&lt;span&gt;

这也是一句话
&lt;/span&gt;&amp;lt;/body&amp;gt;


&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该代码会显示 这是一句话 这是第一句话&lt;/p&gt;
&lt;p&gt;由此案例可以得知，exit()会退出整个脚本，而不只是使当前&amp;lt;?php?&amp;gt;范围的脚本停止。当然，也可以在exit里输入文本来显示信息。&lt;/p&gt;
</description>
<pubDate>Sat, 20 Oct 2018 15:38:00 +0000</pubDate>
<dc:creator>JinFish</dc:creator>
<og:description>exit() 函数输出一条消息，并退出当前脚本。 该函数是 die() 函数的别名。 该代码会显示 这是一句话 这是第一句话 由此案例可以得知，exit()会退出整个脚本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangshizhou/p/9823501.html</dc:identifier>
</item>
<item>
<title>责任链模式（Chain Of Responsibility） - ---dgw博客</title>
<link>http://www.cnblogs.com/dgwblog/p/9823497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dgwblog/p/9823497.html</guid>
<description>&lt;h4 id=&quot;chain-of-responsibility&quot;&gt;Chain Of Responsibility？&lt;/h4&gt;
&lt;p&gt;这种情况下，我们可以考虑将多个对象组成一条职责链，然后按照它们在职责链上的顺序一个一个地找出到底应该谁来负责处理。&lt;br/&gt;通俗：她告诉我们应该去“营业窗口”。然后等我们到了“营业窗口”后，又被告知应该去“售后部门”。等我们好不容易赶到了“售后部门”，又被告知应该去“资料中心”，因此最后我们又不得不赶往“资料中心”。像这样，在找到合适的办事人之前，我们被不断地踢给一个又一个人，这就是“推卸责任”。&lt;/p&gt;
&lt;h4 id=&quot;理解职责&quot;&gt;理解职责&lt;/h4&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;理解好责任链设计模式关键在于 SolveAnswer是处理者而NoSolve、LimitSolve、OddSolve、SpcialSolve才是具体的处理者。&lt;br/&gt;在SolveAnswer用模版设计的模式定义遇到解决问题的策略办法，能解决就在当前实现的解决方法的子类进行解决，不能解决就在继续向下面的责任类继续传递。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;|名字 +++++++++++++++++++++++++++++++说明&lt;br/&gt;|Question|表示发生的问题的类。它带有问题编号（number）&lt;br/&gt;SolveAnswer用来解决问题的抽象类&lt;br/&gt;NoSolve用来解决问题的具体类（永远“不处理问题”）&lt;br/&gt;LimitSolve用来解决问题的具体类（仅解决编号小于指定编号的问题）&lt;br/&gt;OddSolve|用来解决问题的具体类（仅解决奇数编号的问题）&lt;br/&gt;SpcialSolve用来解决问题的具体类（仅解决指定编号的问题）&lt;br/&gt;MainT 制作SolveAnswer的职责链，制造问题并测试程序行为&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;比较重要的话: &lt;strong&gt;Chain of Responsibility模式的最大优点就在于它弱化了发出请求的人（Client角色）和处理请求的人（ConcreteHandler角色）之间的关系。Client角色向第一个ConcreteHandler角色发出请求，然后请求会在职责链中传播，直到某个ConcreteHandler角色处理该请求。&lt;br/&gt;如果不使用该模式，就必须有某个伟大的角色知道“谁应该处理什么请求”，这有点类似中央集权制。而让“发出请求的人”知道“谁应该处理该请求”并不明智，因为如果发出请求的人不得不知道处理请求的人各自的责任分担情况，就会降低其作为可复用的组件的独立性。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;需要知道的技术点：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;使用Chain of Responsibility模式可以推卸请求，直至找到合适的处理请求的对象，这样确实提高了程序的灵活性，但是会有一定的处理延迟：当然你也可以通过算法来定义处理的特殊路径，但是未免太多余麻烦：所以有的时候我们不如直接显示调用来提高灵活性。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;uml&quot;&gt;UML&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181020233639707-1683296524.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;时序图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1160484/201810/1160484-20181020233642534-1377568772.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;code&quot;&gt;Code&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Question :&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class Question {

    private int question_number;

    public Question(int question_number) {
        this.question_number = question_number;
    }

    public int getQuestion_number() {
        return question_number;
    }

    @Override
    public String toString() {
        return &quot;Question{&quot; +
                &quot;question_number=&quot; + question_number +
                '}';
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;SolveAnswer&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public abstract class SolveAnswer {

    private String Solve_Name;

    // 继承链者
    private SolveAnswer next;

    public SolveAnswer(String solve_Name) {
        Solve_Name = solve_Name;
    }

    /**
     * 设置需要推卸责任的对象
     */
    public SolveAnswer setNext(SolveAnswer solveAnswer){
        this.next=solveAnswer;
        return next;
    }

    /**
     * 解决问题的步骤
     */
    public final void support(Question question){
        if(solve(question)){
            finish(question);
        }else if(next!=null){
            this.next.support(question);
        }else{
            fail(question);
        }
    }

    /**
     * 交给子类取解决
     * @param question
     * @return
     */
    protected abstract boolean solve(Question question);

    /**
     *
     * @param question
     */
    private void finish(Question question) {
        System.out.println(question+&quot;能被解决&quot;+this.toString()+&quot;.&quot;);
    }

    /**
     *
     * @param question
     */
    private void fail(Question question) {
        System.out.println(question+&quot;不能被解决.&quot;);
    }

    @Override
    public String toString() {
        return &quot;[&quot;+this.Solve_Name+ &quot;]&quot;;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;NoSolve SpcialSolve OddSolve LimitSolve&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class LimitSolve extends SolveAnswer {

    private int limit;

    public LimitSolve(String solve_Name ,int limit) {
        super(solve_Name);
        this.limit=limit;
    }

    @Override
    public boolean solve(Question question) {

        if(question.getQuestion_number()&amp;lt;limit){
            return true;
        }else{
            return false;
        }

    }
}

public class NoSolve extends SolveAnswer{


    public NoSolve(String solve_Name) {
        super(solve_Name);
    }

    @Override
    public boolean solve(Question question) {
        return false;
    }
}

public class OddSolve extends SolveAnswer {

    public OddSolve(String solve_Name) {
        super(solve_Name);
    }

    @Override
    public boolean solve(Question question) {
        if(question.getQuestion_number()%2==1){
            return  true;
        }else{
            return false;
        }
    }
}

public class SpcialSolve extends SolveAnswer {

    private int special;

    public SpcialSolve(String solve_Name,int specalNum) {
        super(solve_Name);
        this.special=specalNum;
    }

    @Override
    public boolean solve(Question question) {
        if(question.getQuestion_number()==special){
            return true;
        }else {
            return false;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;MainT 测试&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class MainT {

    public static void main(String[] args) {

        SolveAnswer tom=new NoSolve(&quot;cat1&quot;);
        SolveAnswer tom2=new LimitSolve(&quot;cat2&quot;,100);
        SolveAnswer tom3=new OddSolve(&quot;cat3&quot;);
        //只能解决225问题
        SolveAnswer tom4=new SpcialSolve(&quot;cat4&quot;,225);

        tom.setNext(tom2).setNext(tom3).setNext(tom4);

        for (int i = 0; i &amp;lt; 300; i+=3) {
                tom.support(new Question(i));
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 20 Oct 2018 15:37:00 +0000</pubDate>
<dc:creator>---dgw博客</dc:creator>
<og:description>Chain Of Responsibility？ 这种情况下，我们可以考虑将多个对象组成一条职责链，然后按照它们在职责链上的顺序一个一个地找出到底应该谁来负责处理。 通俗：她告诉我们应该去“营业窗口”</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dgwblog/p/9823497.html</dc:identifier>
</item>
<item>
<title>SmartCode 使用常见问题 - Ahoo-Wang</title>
<link>http://www.cnblogs.com/Ahoo-Wang/p/SmartCode-common-problem.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Ahoo-Wang/p/SmartCode-common-problem.html</guid>
<description>&lt;h2 id=&quot;smartcode-能干什么&quot;&gt;SmartCode 能干什么？&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;SmartCode = IDataSource -&amp;gt; IBuildTask -&amp;gt; IOutput =&amp;gt; Build Everything&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SmartCode的执行流是 数据源-&amp;gt;构建任务-&amp;gt;输出，也就是说应用场景非常广泛。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从DB读取数据结构，最终生成整个解决方案=代码生成器（SmartCode.Db）&lt;/li&gt;
&lt;li&gt;ETL，其实很显然SmartCode执行流跟ETL很像，做一些相应的扩展便可支持ETL&lt;/li&gt;
&lt;li&gt;Mode First，从Model类结构解析出数据源，最终生成SQL脚本，执行生成DB结构，并生成整个解决方案&lt;/li&gt;
&lt;li&gt;静态文档生成器&lt;/li&gt;
&lt;li&gt;还有很多等待你去发掘&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;smartcode-扩展性如何&quot;&gt;SmartCode 扩展性如何&lt;/h2&gt;
&lt;p&gt;SmartCode 插件机制拥有非常灵活的扩展能力，SmartCode 中一切都是插件。只要继承IPlugin接口即可，然后配置到appsettings.json，然后通过IPluginManager获取插件实例。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;Logging&quot;: {
    &quot;IncludeScopes&quot;: false,
    &quot;Console&quot;: {
      &quot;LogLevel&quot;: {
        &quot;Default&quot;: &quot;Debug&quot;
      }
    }
  },
  &quot;SmartCode&quot;: {
    &quot;Version&quot;: &quot;v1.7.0&quot;,
    &quot;Plugins&quot;: [
      {
        &quot;Type&quot;: &quot;SmartCode.IDataSource,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.Db.DbSource,SmartCode.Db&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.IBuildTask,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.App.BuildTasks.ClearBuildTask,SmartCode.App&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.IBuildTask,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.App.BuildTasks.MultiTemplateBuildTask,SmartCode.App&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.IBuildTask,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.Db.BuildTasks.BuildTask,SmartCode.Db&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.IBuildTask,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.Db.BuildTasks.ProjectBuildTask,SmartCode.Db&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.IOutput,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.App.Outputs.FileOutput,SmartCode.App&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.INamingConverter,SmartCode&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.Db.TableNamingConverter,SmartCode.Db&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.TemplateEngine.ITemplateEngine,SmartCode.TemplateEngine&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.TemplateEngine.Impl.HandlebarsTemplateEngine,SmartCode.TemplateEngine&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.TemplateEngine.ITemplateEngine,SmartCode.TemplateEngine&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.TemplateEngine.Impl.OfficialRazorTemplateEngine,SmartCode.TemplateEngine&quot;
      },
      {
        &quot;Type&quot;: &quot;SmartCode.Db.IDbTypeConverter,SmartCode.Db&quot;,
        &quot;ImplType&quot;: &quot;SmartCode.Db.DbTypeConverter.DefaultDbTypeConverter,SmartCode.Db&quot;
      }
    ]
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何自定义模板&quot;&gt;如何自定义模板&lt;/h2&gt;
&lt;p&gt;目前SmartCode支持俩种模板引擎 &lt;strong&gt;Razor&lt;/strong&gt; &amp;amp; &lt;strong&gt;Handlebars&lt;/strong&gt; 。&lt;br/&gt;Razor 模板引擎使用的是官方版本，这一点上.NETer同学可以很轻松的自定义SmartCode模板，需要注意的是Razor模板的Model为BuildContext,具体方法可以参考源代码中的模板。编写完成之后放到RazorTemplates，构建时指定好即可。&lt;/p&gt;
&lt;h2 id=&quot;代码生成器支持多少种数据库&quot;&gt;代码生成器支持多少种数据库&lt;/h2&gt;
&lt;p&gt;SmartCode获取数据源结构使用的是&lt;a href=&quot;https://github.com/Ahoo-Wang/SmartSql&quot;&gt;SmartSql&lt;/a&gt;，所以SmartCode支持所有ADO.NET驱动相关的数据库：MySql/PostgreSql/SqlServer/Oracle/SQLite 等&lt;/p&gt;
&lt;h2 id=&quot;smartcode-代码生成器如何使用&quot;&gt;SmartCode 代码生成器如何使用&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/457833/201810/457833-20181020233436882-1692614721.gif&quot; alt=&quot;SmartCode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 20 Oct 2018 15:36:00 +0000</pubDate>
<dc:creator>Ahoo-Wang</dc:creator>
<og:description>SmartCode 能干什么？ SmartCode = IDataSource IBuildTask IOutput = Build Everything SmartCode的执行流是 数据源 构建任</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Ahoo-Wang/p/SmartCode-common-problem.html</dc:identifier>
</item>
<item>
<title>框架设计原则（梁飞） - 莫那-鲁道</title>
<link>http://www.cnblogs.com/stateis0/p/9823450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stateis0/p/9823450.html</guid>
<description>&lt;h2&gt;大纲&lt;/h2&gt;
&lt;p&gt;1 模块分包原则&lt;br/&gt;2 框架扩展原则&lt;br/&gt;3 领域划分原则&lt;br/&gt;4 接口分离原则&lt;br/&gt;5 组件协作原则&lt;br/&gt;6 功能演进原则&lt;/p&gt;
&lt;p&gt;我将对每个原则进行自己的解读，如有不对，还请指教 ：）&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;1 模块分包原则&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1842&quot; data-height=&quot;966&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-cdc90616f48ca317.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; width=&quot;452&quot; height=&quot;237&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/4236553-cdc90616f48ca317.png&quot; data-original-width=&quot;1842&quot; data-original-height=&quot;966&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;506514&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;说说我的理解。这里其实是从框架结构的解读来解读，这里的包指的是 Maven 的 module。&lt;/p&gt;
&lt;p&gt;复用度，指的是 maven 包的复用。可以理解为工具类。这个工具类不应该变化无常。&lt;/p&gt;
&lt;p&gt;稳定度：被依赖的包应该保持稳定，或者说，被依赖者应当比依赖者稳定，且不能成环状依赖。如果不稳定，将会影响其他的包。&lt;/p&gt;
&lt;p&gt;抽象度，越抽象，越稳定。越具体，越容易变化。&lt;/p&gt;
&lt;p&gt;同时，梁飞给出了一个公式，但是实践起来有点麻烦.......&lt;/p&gt;
&lt;p&gt;关于模块分包，可以参见更详细的博客。 &lt;a href=&quot;http://javatar.iteye.com/blog/1188028&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;以HTTL为例讲讲模块分包&amp;amp;领域模型&amp;amp;扩展框架&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;2 框架扩展原则&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1082&quot; data-height=&quot;674&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-1cc980030bdcc3d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;249&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/4236553-1cc980030bdcc3d1.png&quot; data-original-width=&quot;1082&quot; data-original-height=&quot;674&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;106011&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这是其实是说的比较多的东西了。&lt;/p&gt;
&lt;p&gt;什么是微核心 + 插件？按照作者的说法，核心只负责装配插件。这样，无论是作者自己的功能，还是第三方的功能，都是平等的，再多的插件也不会影响软件架构，因为没有硬编码，且都是可以卸载的。甚至微核也是可以扩展的。：）&lt;/p&gt;
&lt;p&gt;同时，插件的组装规则是统一的。说到这里，你应该想到了 IDEA，Maven，Eclipse 等等。&lt;/p&gt;
&lt;p&gt;然后说外置生命周期。这个其实我是有一点不理解的。按照作者的说法，其实是说，框架只负责管理对象，对象的出生和死亡不由框架负责。即，用户应将实例注册到框架中。&lt;/p&gt;
&lt;p&gt;但 Spring 似乎不是这么做的。同时，如果使用注册机制，那么就需要硬编码。或者说，Spring 本身就是管理 Bean 生命周期的框架，而 Dubbo 的职责不在于此？&lt;/p&gt;
&lt;p&gt;最少化概念模型，这个其实是一种优化。&lt;/p&gt;
&lt;p&gt;一致化数据模型：例如 URL 这种对象，就是一致化数据模型，拒绝使用 String 拼接，解析。&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;3 领域划分原则&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1730&quot; data-height=&quot;870&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-f1c8ef84562c176c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; width=&quot;551&quot; height=&quot;277&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/4236553-f1c8ef84562c176c.png&quot; data-original-width=&quot;1730&quot; data-original-height=&quot;870&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;304674&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这是在框架设计中，是非常重要的。&lt;/p&gt;
&lt;p&gt;PPT 中已经说的非常清楚，我就不再说明。其中，Invocation 一定要轻量。否则，对 GC 来说，将是很大的压力（使用对象池？性能不好。）&lt;/p&gt;
&lt;p&gt;说说他的好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;结构清晰，这个不必讲吧。&lt;/li&gt;
&lt;li&gt;充血模型......这个怎么理解？&lt;/li&gt;
&lt;li&gt;可变和不可变状态分离，可变状态集中。通常实体域都是只读的，即不变状态。会话域都是可变状态。&lt;/li&gt;
&lt;li&gt;所有领域模型线程安全。无锁编程（lock-free 非常重要）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关于他们的线程安全性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;服务域无状态，天生线程安全。&lt;/li&gt;
&lt;li&gt;实体域属性只读，线程安全。&lt;/li&gt;
&lt;li&gt;会话域工作在栈中，线程安全。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以，需要保证他们是这么设计的，才能实现无锁编程。&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;4 接口分离原则&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1396&quot; data-height=&quot;1004&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-85cf6df6bdac6163.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; width=&quot;335&quot; height=&quot;241&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/4236553-85cf6df6bdac6163.png&quot; data-original-width=&quot;1396&quot; data-original-height=&quot;1004&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;513717&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;关于接口分离，我认为是单一职责的一种实现。&lt;/p&gt;
&lt;p&gt;其中提到 API 和 SPI，API 面向用户，SPI 面向开发者。两者必须分离。&lt;/p&gt;
&lt;p&gt;声明式 API 和过程式 SPI ，没看懂，看懂的说一下。：）&lt;/p&gt;
&lt;p&gt;API 可配置，一定可编程，这个不用说吧。&lt;/p&gt;
&lt;p&gt;区分命令和查询，例如，不应该有 updateAndGet 这个方法（不包括原子类），应该分成 2 个方法，保证 get 方法幂等。&lt;/p&gt;
&lt;p&gt;对称性接口：很简单，有 get 方法，就应该有 set 方法，有 add 就由 remove，称之为对称性和完备性。这样用户能自行推导出接口。&lt;/p&gt;
&lt;p&gt;兼容性：如果接口加方法，应该是增加子接口的方式。其他的没看明白.......&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;5 组件协作原则&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1412&quot; data-height=&quot;1590&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-e38bd0a40b19206d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; width=&quot;234&quot; height=&quot;263&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/4236553-e38bd0a40b19206d.png&quot; data-original-width=&quot;1412&quot; data-original-height=&quot;1590&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;842198&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这个就比较爽了，我们知道 Dubbo 是管道式设计。一个 Invoker 贯通整个流程，事实上，web 服务器都是这么设计的。例如 Tomcat ，Netty。&lt;/p&gt;
&lt;p&gt;关于派发，还记得 Spring 的 dispatchServlet 吗？&lt;/p&gt;
&lt;p&gt;关于状态的共享：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分布是什么？即通过行为传递（适合交互性系统）。&lt;/li&gt;
&lt;li&gt;共享是什么？通过一个固定的点获取，称之为仓库（适合管理状态的系统）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主过程拦截，还记得 Mybatis 留给我们的插件吗？还记得 Spring 留给我们的拦截器吗？框架要在关键节点留出拦截点供用户扩展。&lt;/p&gt;
&lt;p&gt;事件派发：观察者模式，Reactor 模式，另外提到 Proactor 模式，查了一下，通常在 GNU 编程中，由 OS 支持。&lt;/p&gt;
&lt;p&gt;Dubbo 暴露、引用、调用事件，都预留了监听器。&lt;/p&gt;
&lt;p&gt;关键路径，即在管道使用职责连模式进行拦截，保证每个拦截器职责单一。&lt;/p&gt;
&lt;p&gt;非关键路径，需要有监听机制，不能影响主流程运行。&lt;/p&gt;
&lt;p&gt;关于协作防御，我理解为防御性编程。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分离可靠操作和不可靠操作。不可靠操作尽量范围要小。&lt;/li&gt;
&lt;li&gt;状态分离，尽量无状态。状态要尽可能小。&lt;/li&gt;
&lt;li&gt;对状态要尽早验证，因为如果失败，通常无人回滚。前后断言验证状态正确性。&lt;/li&gt;
&lt;li&gt;异常防御，应该是预见性的异常，异常包含环境信息。&lt;/li&gt;
&lt;li&gt;降低修改成本，防止埋雷：不要根据异常类型做分支判断。保持 null 和 empty 一致。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h2&gt;6 功能演进原则&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1398&quot; data-height=&quot;760&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-231023fac9a633b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;207&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/4236553-231023fac9a633b6.png&quot; data-original-width=&quot;1398&quot; data-original-height=&quot;760&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;421693&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;第一就是开闭原则，微核心加插件机制能够支持。&lt;br/&gt;软件质量的下降，来源于修改。&lt;/p&gt;
&lt;p&gt;加功能的姿势：应该是增量式，而不是扩充式，即不在原有基础上修改，而是新增加功能。&lt;/p&gt;
&lt;p&gt;关于高阶：顶层接口尽量抽象，且不能依赖底层实现。这样，当底层实现变化时，高层无需变化。&lt;/p&gt;
&lt;p&gt;例如 Dubbo 泛化，在顶层就足够抽象，底层实现方式不影响高层。&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;总结&lt;/h2&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1828&quot; data-height=&quot;1034&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4236553-60328aeaccfc19cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; width=&quot;461&quot; height=&quot;261&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/4236553-60328aeaccfc19cf.png&quot; data-original-width=&quot;1828&quot; data-original-height=&quot;1034&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;215828&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;以上是梁飞总结。&lt;/p&gt;
&lt;p&gt;今天说的框架设计和现在大部分人喜欢说的架构设计有所不同，现在似乎只需要再 processon 上放几个阿里云组件，再连几条线，就是架构设计了 ：）&lt;/p&gt;
&lt;p&gt;我个人认为，框架设计更能考验一个程序员对程序的抽象和管理能力（也许措辞不当？）&lt;/p&gt;
&lt;p&gt;然后，再说说我的总结：关于一个系统的设计，这里应该指的是框架的设计，首先要知道用户需求（废话）。根据需求抽象出模型，再变成代码，且是可扩展，可复用的代码。&lt;/p&gt;
&lt;p&gt;这里提到的 6 个原则，应该算是比较成熟的原则了。&lt;/p&gt;
&lt;p&gt;1 微核 + 插件，非常理想化，例如 SOFA，也有自己的扩展机制。&lt;/p&gt;
&lt;p&gt;2 关于领域模型设计，这 3 个模型的职责一定要划分清楚，同时实现无锁编程，这个对于系统的性能非常重要。&lt;/p&gt;
&lt;p&gt;3 关于组件协作，一个系统有多个组件，通常需要进行状态的共享，在 Dubbo 中，使用行为进行传递，也就是会话域。&lt;/p&gt;
&lt;p&gt;4 关于功能演进，请遵循开闭原则，但前提通常是有一个好的内核。&lt;/p&gt;
&lt;p&gt;5 关于接口分离和模块分包，通常在后期重构能够达到更好的效果？&lt;/p&gt;
&lt;p&gt;好了，洋洋洒洒说了不少，读者如有更好的见解，请与我分享，毕竟现在关注这块的人不多了。：）期待和对此感兴趣的人一起讨论&lt;/p&gt;
</description>
<pubDate>Sat, 20 Oct 2018 15:19:00 +0000</pubDate>
<dc:creator>莫那-鲁道</dc:creator>
<og:description>读梁飞博客和其分享的 PPT 总结笔记。期待和对此感兴趣的人一起讨论 ：）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stateis0/p/9823450.html</dc:identifier>
</item>
<item>
<title>关于ios 11.X后微信wifi认证，无法打开微信，无法重定向到weixin：开头网址等问题的处理 - 繁华ros</title>
<link>http://www.cnblogs.com/fanhua999/p/9823437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanhua999/p/9823437.html</guid>
<description>&lt;p&gt;&lt;strong&gt;环境：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　认证路由ROS ，认证后台python django&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ios11系统 更新以来先后出现微信wifi认证，无法打开微信，无法重定向到weixin：开头网址等相关问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265917/201810/1265917-20181020223020584-799421010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;经过问题的收集，查询到网络上此类问题普遍存在&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;收集到的有如下网址，市面上大多数厂商在使用微信wifi 认证都存在这个问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　http://www.ruijie.com.cn/fw/wt/61089/&lt;/p&gt;
&lt;p&gt;　　http://www.adslr.com/bbs/forum.php?mod=viewthread&amp;amp;tid=1143&lt;/p&gt;
&lt;p&gt;　　https://www.v2ex.com/t/445255&lt;/p&gt;
&lt;p&gt;　　http://www.tg-net.cn/faq_article507_399.html&lt;/p&gt;
&lt;p&gt;　　http://www.natshell.com/plus/view.php?aid=1319&lt;/p&gt;
&lt;p&gt;　　http://www.sohu.com/a/193853473_421197&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;收集到的一些解决办法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　http://www.xiegaosheng.com/post/view?id=99&lt;/p&gt;
&lt;p&gt;　　https://segmentfault.com/a/1190000016226365?utm_source=tag-newest&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面简单说明下此类问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　无法打开微信认证问题，只有IOS 11.X后会出现。&lt;/p&gt;
&lt;p&gt;　　默认IOS 认证连接上wifi 会自动弹出wifi 认证页面，后台会自动临时放行。认证页面的状态显示完成。&lt;/p&gt;
&lt;p&gt;　　用户点击一键打开微信连接wifi，会提示 无法重定向到weixin：开头网址。&lt;/p&gt;
&lt;p&gt;　　导致不能打开微信，完成微信wifi认证。&lt;/p&gt;
&lt;p&gt;　　然后，在此继续打开safari浏览器，输入http开头的网址。会继续提示微信wifi认证。然后打开微信成功。&lt;/p&gt;
&lt;p&gt;　　说明，默认的认证页面 存在了限制，导致无法使用微信相关的私有协议网址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何解决?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　需要解决之类问题，就需要引导用户去加载到safari上才能打开微信完成微信认证。&lt;/p&gt;
&lt;p&gt;　　所以首先要判断系统是否为ios&lt;/p&gt;
&lt;p&gt;　　下面是JS代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;首次加载页面提示正在准备网络中&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; btntime1(btn1) {
        btn.style.display&lt;/span&gt;='none'&lt;span&gt;;
        btn1.style.display&lt;/span&gt;=''&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (wait ==0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;倒计时加载完显示一键打开微信&lt;/span&gt;
            btn1.style.display='none'&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是ios&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; u =&lt;span&gt; navigator.userAgent;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isAndroid = u.indexOf('Android') &amp;gt; -1 || u.indexOf('Adr') &amp;gt; -1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;android终端&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; isiOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ios终端&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isiOS) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是ios，就显示ios的a标签&lt;/span&gt;
                    btn.style.display='none'&lt;span&gt;;
                    btn3.style.display&lt;/span&gt;=''&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ios_auto_url =&quot;{{ loginurl }}&quot;.replace(&quot;login&quot;,&quot;&quot;) + &quot;ios_auto_weixin_login.html&quot;&lt;span&gt;;
                    setTimeout(&lt;/span&gt;&quot;captive();&quot;,500&lt;span&gt;);
                    btn3.href&lt;/span&gt;=&lt;span&gt; ios_auto_url;

                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是ios，就显示默认的a标签，&lt;/span&gt;
                    btn3.style.display='none'&lt;span&gt;;
                    btn.style.display&lt;/span&gt;=''&lt;span&gt;;
                }
            wait &lt;/span&gt;= 5&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
           btn1.style.backgroundColor&lt;/span&gt;= &quot;#f2f2f2&quot;&lt;span&gt;;
           btn1.style.color&lt;/span&gt;= &quot;#bbb1b1&quot;&lt;span&gt;;
           btn1.innerHTML&lt;/span&gt;=&quot;正在准备网络(&quot; + wait +&quot;)&quot;&lt;span&gt;;
           wait &lt;/span&gt;--&lt;span&gt;;
           setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
               btntime1(btn1);
           },
           &lt;/span&gt;1000&lt;span&gt;)
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　判断是IOS 就把 一键打开微信认证的 A 标签&lt;span id=&quot;transmark&quot;/&gt;href地址改成自己定义好的网址。&lt;/p&gt;
&lt;p&gt;　　此时用户的状态是临时放行的。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1265917/201810/1265917-20181020225636315-759126724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　用户点击自己定义的一个html地址，这个html地址就会从safari上打开，加载微信认证页面。这个认证页面也会自动去加载微信&lt;/p&gt;
&lt;p&gt;　　　　（ps:重新设置一个html页面，和重新设置一个能自动加载呼起微信函数认证页面）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1265917/201810/1265917-20181020225727260-650191858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;yoghurt&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　用户就点下微信打开就可以完成微信认证了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265917/201810/1265917-20181020225745525-1216391099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;期待优化的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　目前这种流程大部分手机可以正常使用，但是还是有少部分手机会认证页面不自动关闭。&lt;/p&gt;
&lt;p&gt;　　这时候就在页面上提示点击右上角完成，然后就到safari浏览器中完成微信认证。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265917/201810/1265917-20181020230256220-438695111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　也可以优化下页面，变成这种有剪头指引的。让用户体验更好。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1265917/201810/1265917-20181020230407093-805351987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　目前测试了一天，还是存在一个手机无法浏览器中打开的问题，和个别手机会认证两次才会成功的问题。&lt;/p&gt;
&lt;p&gt;　　所以期待你的流程优化。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;也&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 20 Oct 2018 15:12:00 +0000</pubDate>
<dc:creator>繁华ros</dc:creator>
<og:description>环境： 认证路由ROS ，认证后台python django ios11系统 更新以来先后出现微信wifi认证，无法打开微信，无法重定向到weixin：开头网址等相关问题。 经过问题的收集，查询到网络</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fanhua999/p/9823437.html</dc:identifier>
</item>
<item>
<title>一文秒懂如何搭建一个最简单的充值系统 - 戎&quot;码&quot;一生</title>
<link>http://www.cnblogs.com/lucky_hu/p/9823406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lucky_hu/p/9823406.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;     阅读完本文大概需要5分钟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;移动支付&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;微信支付&lt;/li&gt;
&lt;li&gt;支付宝支付&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;充值体系&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;最基础的架构&lt;/li&gt;
&lt;li&gt;生产环境应用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;     一切都是生意。“天下熙熙皆为利来,天下攘攘皆为利往”。不知从什么时候起，人类社会诞生了公司这样的组织,而这个组织把人们结合在一起,产生了各种行业和商业形态，最后,公司的一切活动都变成了生意。当然,大公司有大公司的生意,小公司有小公司的买卖。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;     过去几年saas服务软件大行其道,这其中就有大家熟悉的阿里云服务,客户注册账户+线上支付就能使用软件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;     线上支付,相信大家都不陌生。支付宝,微信,云闪付,苹果支付等,人人都离不开支付通道。我们看到很多大公司都有自己的支付体系和金融体系。大厂,财大气粗,有足够的投入可以自建高可用的支付体系。那么,如何中小微企业想在做点小生意,没有足够的资源自建支付体系,怎么玩？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;     借力。这就好比大厂花了大价钱,找到水源,然后挖了一口井，小店也得活不是,给点佣金，分一股“清泉”吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;一、移动支付&lt;/strong&gt;&lt;br/&gt;　&lt;/p&gt;
&lt;blockquote readability=&quot;2.5510204081633&quot;&gt;
&lt;p&gt;本文代码示例是基于威富通移动支付(&lt;a href=&quot;https://www.swiftpass.cn/products/epay/page.html&quot; class=&quot;uri&quot;&gt;https://www.swiftpass.cn/products/epay/page.html&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;微信支付&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;     场景介绍&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;用户扫描商户展示在各种场景的二维码进行支付。:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;     步骤1：商户根据微信支付的规则，为不同商品生成不同的二维码（如图6.1），展示在各种场景，用于用户扫描购买。&lt;/p&gt;
&lt;p&gt;     步骤2：用户使用微信“扫一扫”（如图6.2）扫描二维码后，获取商品支付信息，引导用户完成支付（如图6.3）。&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%9801.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;     步骤3：用户确认支付，输入支付密码（如图6.4）。&lt;/p&gt;
&lt;p&gt;     步骤4：支付完成后会提示用户支付成功（如图6.5），商户后台得到支付成功的通知，然后进行发货处理。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%9802.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;p&gt;     查看是否安装成功:&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/java%E7%89%88%E6%9C%AC.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;p&gt;     笔者在实际项目中要使用微信扫码付款功能,开发的时候选择的是微信扫码支付的模式一(&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_4&quot; class=&quot;uri&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_4&lt;/a&gt;)&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E5%BE%AE%E4%BF%A1%E6%89%AB%E6%8F%8F%E6%94%AF%E4%BB%98.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;     代码片段&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
        /// 威富通-微信支付
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;total_fee&quot;&amp;gt;订单金额&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;orderno&quot;&amp;gt;订单号&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;productName&quot;&amp;gt;产品名称&amp;lt;/param&amp;gt;
        private void WebChat(decimal total_fee, string orderno, string productName)
        {
            try
            {
                total_fee = total_fee * 100;//单位：分
                PayReqEntity entity = new PayReqEntity();
                entity.mch_id =“商户ID”
                string key =“KEY&quot;;//您申请的
                entity.key = key;
                entity.req_url = &quot;https://pay.swiftpass.cn/pay/gateway&quot;;
                entity.service = &quot;pay.weixin.native&quot;;
                entity.version = &quot;2.0&quot;;
                entity.out_trade_no = orderno;
                entity.body = productName;
                entity.attach = &quot;&quot;;
                entity.total_fee = Math.Round(total_fee).ToString();
                entity.time_start = &quot;&quot;;
                entity.time_expire = &quot;&quot;;
                entity.mch_create_ip = AppUtils.GetIp();
                entity.notify_url = ChargeHelper.BuildUrl() + &quot;WebChat/Notify.aspx&quot;;
                WeChatPayInterface service = new WeChatPayInterface();
                PayResEntity result = service.SubmitPay(entity);
                if (!result.IsSuccess)
                {
                    string msg = result.Message;
                    if (msg.Contains(&quot;订单已存在&quot;))
                    {
                        msg = msg + &quot;,请重新下单！&quot;;
                    }
                    Response.Write(&quot;&amp;lt;script&amp;gt;alert('&quot; + msg + &quot;')&amp;lt;/script&amp;gt;&quot;);
                    return;
                }
                Session[&quot;pavlue&quot;] = result.arr;
                Response.Redirect(&quot;WebChat/Pay.aspx&quot;);
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;     付款完成之后,会回调WebChat/Pay.aspx页面,执行订单业务功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void callback()
        {
            try
            {
                WeChatPayInterface service = new WeChatPayInterface();
                Stream stream = Request.InputStream;
                string key = &quot;KEY&quot;;//你申请的
                NotifyResEntity result = service.PayResult(key, stream);
                if (!result.IsSuccess)
                {
                    Log.Info(&quot;[威富通-微信支付回调]：&quot; + result.Message);
                    Response.Write(&quot;failure&quot;);
                    return;
                }
                Hashtable data = result.data;
                /*-----------交易状态------------
                 SUCCESS—支付成功
                 REFUND—转入退款
                 NOTPAY—未支付
                 CLOSED—已关闭
                 PAYERROR—支付失败(其他原因，如银行返回失败)
                 ------------------------------------ */
                string out_trade_no = data[&quot;out_trade_no&quot;].ToString();//商户订单号
                int status = Convert.ToInt32(data[&quot;status&quot;]);//返回状态码(0表示成功，非0表示失败此字段是通信标识，非交易标识，交易是否成功需要查看 result_code 来判断)
                int result_code = Convert.ToInt32(data[&quot;result_code&quot;]);//业务结果(0表示成功，非0表示失败)
                if (status == 0 &amp;amp;&amp;amp; result_code == 0)
                {
                    string total_fee = data[&quot;total_fee&quot;].ToString();//总金额，以分为单位，不允许包含任何字、符号
                    string transaction_id = data[&quot;transaction_id&quot;].ToString();//平台交易单号
                    //此处可以在添加相关处理业务 ，更新数据库表中的记录。
                    int proxyid = 0;
                    string bankbill = &quot;&quot;;
                    ulong employeeid = 1;
                    string comment = &quot;微信支付&quot;;
                    string billtype = &quot;正常订单&quot;;
                    int payment = 24;//微信支付
                    string bankname = &quot;&quot;;
                    string payer = &quot;&quot;;
                    string orderno = out_trade_no;
                    string taobaopayno = transaction_id;
                    decimal amountpaid = 0;
                    if (!string.IsNullOrEmpty(total_fee))
                    {
                        amountpaid = Convert.ToDecimal(total_fee) / 100;
                    }
         
                    //TODO:业务处理部分
                    Response.Write(&quot;success&quot;);
                    return;
                    
                }
                else
                {
                    Log.Info(&quot;[威富通-微信支付回调]：商户订单号out_trade_no=&quot; + out_trade_no + &quot;状态码status=&quot; + status + &quot;,业务结果result_code=&quot; + result_code);
                }
            }
            catch (Exception ex)
            {
                Log.Info(&quot;[威富通-微信支付回调]异常：&quot; + ex);
            }
            Response.Write(&quot;failure&quot;);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.&lt;strong&gt;支付宝支付&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     场景介绍&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;    扫码支付，指用户打开支付宝钱包中的“扫一扫”功能，扫描商户针对每个订单实时生成的订单二维码，并在手机端确认支付。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;     调用流程&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.open.alipay.com/194/105170/&quot; class=&quot;uri&quot;&gt;https://docs.open.alipay.com/194/105170/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%9801.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;    商户系统调用支付宝预下单接口alipay.trade.precreate，获得该订单二维码图片地址。&lt;br/&gt;    发起轮询获得支付结果：等待5秒后调用交易查询接口alipay.trade.query通过支付时传入的商户订单号(out_trade_no)查询支付结果（返回参数TRADE_STATUS），如果仍然返回等待用户付款（WAIT_BUYER_PAY），则再次等待5秒后继续查询，直到返回确切的支付结果（成功TRADE_SUCCESS 或 已撤销关闭TRADE_CLOSED），或是超出轮询时间。在最后一次查询仍然返回等待用户付款的情况下，必须立即调用交易撤销接口alipay.trade.cancel将这笔交易撤销，避免用户继续支付。&lt;br/&gt;    除了主动轮询，也可以通过接受异步通知获得支付结果，详见扫码异步通知，注意一定要对异步通知做验签，确保通知是支付宝发出的。&lt;/p&gt;
&lt;p&gt;代码片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; private void Alipay(decimal total_fee, string orderno, string productName)
        {
            total_fee = total_fee * 100;//单位：分
            PayReqEntity entity = new PayReqEntity();
            entity.mch_id = &quot;商户ID&quot;;
            string key = 商户Key&quot;&quot;;
            entity.key = key;
            entity.req_url = &quot;https://pay.swiftpass.cn/pay/gateway&quot;;
            entity.service = &quot;pay.alipay.native&quot;;
            entity.version = &quot;2.0&quot;;
            entity.out_trade_no = orderno;
            entity.body = productName;
            entity.attach = &quot;&quot;;
            entity.total_fee = Math.Round(total_fee).ToString();
            entity.time_start = &quot;&quot;;
            entity.time_expire = &quot;&quot;;
            entity.mch_create_ip = AppUtils.GetIp();
            entity.notify_url = ChargeHelper.BuildUrl() + &quot;Alipay/Notify.aspx&quot;;
            WeChatPayInterface service = new WeChatPayInterface();
            PayResEntity result = service.SubmitPay(entity);
            if (!result.IsSuccess)
            {
                string msg = result.Message;
                if (msg.Contains(&quot;订单已存在&quot;))
                {
                    msg = msg + &quot;,请重新下单！&quot;;
                }
                Response.Write(&quot;&amp;lt;script&amp;gt;alert('&quot; + msg + &quot;')&amp;lt;/script&amp;gt;&quot;);
                return;
            }
            Session[&quot;alipay_pavlue&quot;] = result.arr;
            Response.Redirect(&quot;Alipay/Pay.aspx&quot;);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    支付完成,同样回调Alipay/Pay.aspx&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void callback()
        {
            try
            {
                WeChatPayInterface service = new WeChatPayInterface();
                Stream stream = Request.InputStream;
                string key = &quot;KEY&quot;;//填写自己的
                NotifyResEntity result = service.PayResult(key, stream);
                if (!result.IsSuccess)
                {
                    Log.Info(&quot;[威富通-支付宝支付回调]：&quot; + result.Message);
                    Response.Write(&quot;failure&quot;);
                    return;
                }
                Hashtable data = result.data;
                /*-----------交易状态------------
                 SUCCESS—支付成功
                 REFUND—转入退款
                 NOTPAY—未支付
                 CLOSED—已关闭
                 PAYERROR—支付失败(其他原因，如银行返回失败)
                 ------------------------------------ */
                //string trade_state = data[&quot;trade_state&quot;].ToString();
                string out_trade_no = data[&quot;out_trade_no&quot;].ToString();//商户订单号
                int status = Convert.ToInt32(data[&quot;status&quot;]);//返回状态码(0表示成功，非0表示失败此字段是通信标识，非交易标识，交易是否成功需要查看 result_code 来判断)
                int result_code = Convert.ToInt32(data[&quot;result_code&quot;]);//业务结果(0表示成功，非0表示失败)
                if (status == 0 &amp;amp;&amp;amp; result_code == 0)
                {
                    string total_fee = data[&quot;total_fee&quot;].ToString();//总金额，以分为单位，不允许包含任何字、符号
                    string transaction_id = data[&quot;transaction_id&quot;].ToString();//平台交易单号
                    //此处可以在添加相关处理业务 ，更新数据库表中的记录。
                    int proxyid = 0;
                    string bankbill = &quot;&quot;;
                    ulong employeeid = 1;
                    string comment = &quot;支付宝支付&quot;;
                    string billtype = &quot;正常订单&quot;;
                    int payment = 23;//威富通-支付宝支付
                    string bankname = &quot;&quot;;
                    string payer = &quot;&quot;;
                    string orderno = out_trade_no;
                    string taobaopayno = transaction_id;
                    decimal amountpaid = 0;
                    if (!string.IsNullOrEmpty(total_fee))
                    {
                        amountpaid = Convert.ToDecimal(total_fee) / 100;
                    }
                    //TODO:业务处理部分
                    Response.Write(&quot;success&quot;);
                    return;
                }
                else
                {
                    Log.Info(&quot;[威富通-支付宝支付回调]：商户订单号out_trade_no=&quot; + out_trade_no + &quot;状态码status=&quot; + status + &quot;,业务结果result_code=&quot; + result_code);
                }
            }
            catch (Exception ex)
            {
                Log.Info(&quot;[威富通-支付宝支付回调]异常：&quot; + ex);
            }
            Response.Write(&quot;failure&quot;);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;二、充值体系&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;任何一家公司做生意的都会使用支付业务,这里以SAAS行业支付为例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;center&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E5%85%85%E5%80%BC%E4%BD%93%E7%B3%BB.png&quot;/&gt;&lt;/center&gt;
&lt;ul&gt;&lt;li&gt;订单生成流程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;     在实际生产环境中中,订单的流程也是较为重要的一环。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E5%AE%A2%E6%88%B7%E5%85%85%E5%80%BC%E6%B5%81%E7%A8%8B.png&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
&lt;ul&gt;&lt;li&gt;防止重复支付&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;     支付完成,回调的时候检测订单状态。已支付的就不再执行。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如何保证支付一致性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;     在实际生产环境中中,总会发生支付接口支付成功,回调执行订单业务失败的情况，简单的办法是可以增加一个单独检查业务,定时对不一致的订单进行二次执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     基本的充值体系是通用的。订单业务量大的可以增加消息队列处理。在保证一致性方面,我们在该架构上还有很多细节可以完善。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四、参考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     个人微信公众号:&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;&lt;br/&gt;&lt;img src=&quot;http://ou71ojlz3.bkt.clouddn.com/%E7%A0%81%E5%86%9C%E5%95%86%E4%B8%9A%E5%8F%82%E8%B0%8B%20%282%29.jpg&quot;/&gt;&lt;br/&gt;&lt;/center&gt;
</description>
<pubDate>Sat, 20 Oct 2018 15:01:00 +0000</pubDate>
<dc:creator>戎&amp;quot;码&amp;quot;一生</dc:creator>
<og:description>&amp; 160; &amp; 160;&amp; 160;&amp; 160;阅读完本文大概需要5分钟。 目录 移动支付 微信支付 支付宝支付 充值体系 最基础的架构 生产环境应用 总结 参考 &amp; 160; &amp; 160;&amp; 16</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lucky_hu/p/9823406.html</dc:identifier>
</item>
<item>
<title>SpringBoot 之Actuator. - JMCui</title>
<link>http://www.cnblogs.com/jmcui/p/9820579.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jmcui/p/9820579.html</guid>
<description>&lt;h2&gt;一、Actuator 介绍&lt;/h2&gt;
&lt;p&gt;    Actuator 是 SpringBoot 项目中一个非常强大一个功能，有助于对应用程序进行监视和管理，通过 restful api 请求来监管、审计、收集应用的运行情况。&lt;/p&gt;
&lt;p&gt;    Actuator 的核心是端点 Endpoint，它用来监视应用程序及交互，spring-boot-actuator 中已经内置了非常多的 Endpoint（health、info、beans、metrics、httptrace、shutdown等等），同时也允许我们自己扩展自己的 Endpoints。每个 Endpoint 都可以启用和禁用。要远程访问 Endpoint，还必须通过 JMX 或 HTTP 进行暴露，大部分应用选择HTTP，Endpoint 的ID默认映射到一个带 &lt;strong&gt;/actuator&lt;/strong&gt; 前缀的URL。例如，health 端点默认映射到 &lt;strong&gt;/actuator/health&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;二、Actuator 使用&lt;/h2&gt;
&lt;p&gt;    启用 Actuator 最简单方式是添加 &lt;strong&gt;spring-boot-starter-actuator&lt;/strong&gt; ‘Starter’依赖。 &lt;/p&gt;
&lt;h3&gt;    1、pom.xml&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 2、监控 —— Actuator插件 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-actuator&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;    2、application.yml&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;management&lt;/strong&gt;:
  &lt;strong&gt;endpoints&lt;/strong&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 暴露 EndPoint 以供访问，有jmx和web两种方式，exclude 的优先级高于 include&lt;/span&gt;
&lt;span&gt;&lt;span&gt;    jmx&lt;/span&gt;:
      exposure:
        exclude: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        include: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    web&lt;/span&gt;:
      exposure:
      &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; exclude: '*'&lt;/span&gt;
        include: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;health&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mappings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logfile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metrics&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shutdown&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;env&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
      base&lt;/span&gt;-path: /actuator  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 配置 Endpoint 的基础路径&lt;/span&gt;
      cors: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 配置跨域资源共享&lt;/span&gt;
        allowed-origins: http://&lt;span&gt;example.com
        allowed&lt;/span&gt;-&lt;span&gt;methods: GET,POST
    enabled&lt;/span&gt;-by-default: true &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 修改全局 endpoint 默认设置&lt;/span&gt;
&lt;span&gt;&lt;strong&gt;  endpoint&lt;/strong&gt;:
    &lt;span&gt;auditevents&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、显示当前引用程序的审计事件信息，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
      cache:
        time&lt;/span&gt;-to-live: 10s &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 配置端点缓存响应的时间&lt;/span&gt;
    &lt;span&gt;beans&lt;/span&gt;: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2、显示一个应用中所有 Spring Beans 的完整列表，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;conditions&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3、显示配置类和自动配置类的状态及它们被应用和未被应用的原因，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;configprops&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4、显示一个所有@ConfigurationProperties的集合列表，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;env&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5、显示来自Spring的 ConfigurableEnvironment的属性，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;flyway&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6、显示数据库迁移路径，如果有的话，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;health&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 7、显示健康信息，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
      show&lt;/span&gt;-&lt;span&gt;details: always
    &lt;span&gt;info&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 8、显示任意的应用信息，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;liquibase&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 9、展示任何Liquibase数据库迁移路径，如果有的话，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;metrics&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 10、展示当前应用的metrics信息，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;mappings&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 11、显示一个所有@RequestMapping路径的集合列表，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;scheduledtasks&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 12、显示应用程序中的计划任务，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;sessions&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 13、允许从Spring会话支持的会话存储中检索和删除(retrieval and deletion)用户会话。使用Spring Session对反应性Web应用程序的支持时不可用。默认开启。&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;shutdown&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 14、允许应用以优雅的方式关闭，默认关闭&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;threaddump&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 15、执行一个线程dump&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; web 应用时可以使用以下端点&lt;/span&gt;
    &lt;span&gt;heapdump&lt;/span&gt;: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 16、    返回一个GZip压缩的hprof堆dump文件，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;jolokia&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 17、通过HTTP暴露JMX beans（当Jolokia在类路径上时，WebFlux不可用），默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;logfile&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 18、返回日志文件内容（如果设置了logging.file或logging.path属性的话），支持使用HTTP Range头接收日志文件内容的部分信息，默认开启&lt;/span&gt;
&lt;span&gt;      enabled: true
    &lt;span&gt;prometheus&lt;/span&gt;: &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;19、以可以被Prometheus服务器抓取的格式显示metrics信息，默认开启&lt;/span&gt;
      enabled: true
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    这大抵就是全部默认的 Endpoint 的配置了，怎么样？强大吧！之前做了一个网络监控的项目，就是能够实时查看服务器的 CPU、内存、磁盘、IO 这些（基于 sigar.jar 实现），然后现在发现 SpringBoot 就这样轻松支持了，还更强大，更简便......&lt;/p&gt;
&lt;p&gt;    默认的 Endpoint 映射前缀是 &lt;strong&gt;/actuator&lt;/strong&gt;，可以通过如上 base-path 自定义设置。&lt;/p&gt;
&lt;p&gt;    每个 Endpoint 都可以配置开启或者禁用。但是仅仅开启 Endpoint 是不够的，还需要通过 jmx 或者 web 暴露他们，通过 exclude 和 include 属性配置。&lt;/p&gt;
&lt;h3&gt;    3、效果&lt;/h3&gt;
&lt;p&gt;    做好了如上的配置，接下来我们只需要访问对应的 Endpoint 就可以啦，&lt;span&gt;/actuator/[Endpoint ID]&lt;/span&gt;（http://127.0.0.1:8080/actuator/health）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1153954/201810/1153954-20181020094706537-1978178389.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、自定义 Endpoint&lt;/h2&gt;
&lt;p&gt;    自定义 Endpoint 端点，只需要在我们的新建Bean上使用 &lt;strong&gt;@Endpoint&lt;/strong&gt; 注解即可。则 Bean 中的方法就可以通过 JMX 或者 HTTP 公开。除此之外，你还可以使用 &lt;strong&gt;@JmxEndpoint&lt;/strong&gt; 或 &lt;strong&gt;@WebEndpoint&lt;/strong&gt; 编写 EndPoint。但是这些 EndPoint 仅限于各自的公开方式。例如，@WebEndpoint 仅通过HTTP公开，而不通过JMX公开。&lt;/p&gt;
&lt;p&gt;    那么是不是类中所有的方法都支持对外公开呢？很明显不是的。这里又要提到三个注解，只有加三个注解的方法才支持对外公开，并且每个注解都有支持它的 HTTP method。如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Operation&lt;/th&gt;
&lt;th&gt;HTTP method&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;@ReadOperation&lt;/td&gt;
&lt;td&gt;GET&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@WriteOperation&lt;/td&gt;
&lt;td&gt;POST&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;@DeleteOperation&lt;/td&gt;
&lt;td&gt;DELETE&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;    Endpoint 上的操作通过参数接收输入。 当通过网络公开时，这些参数的值取自URL的查询参数和JSON请求主体。 通过JMX公开时，参数将映射到MBean操作的参数。参数默认是必需的,可以通过使用 &lt;strong&gt;@Nullable&lt;/strong&gt; 注释使其成为可选的。&lt;/p&gt;
&lt;p&gt;    可以通过使用 &lt;strong&gt;@Selector&lt;/strong&gt; 注释操作方法的一个或多个参数来进一步定制路径。@Selector 会将路径上的参数作为变量传递给操作方法。这个注解有点诡异，且听我徐徐道来~~&lt;/p&gt;
&lt;h3&gt;    1、Endpoint Bean&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
@Endpoint(id &lt;/span&gt;= &quot;my&quot;, enableByDefault = &lt;span&gt;true&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置 id，并选择是否默认开启&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyEndPoint {

    @ReadOperation
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt;&lt;span&gt; getPaths() {
        List&lt;/span&gt;&amp;lt;String&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        list.add(&lt;/span&gt;&quot;java&quot;&lt;span&gt;);
        list.add(&lt;/span&gt;&quot;c++&quot;&lt;span&gt;);
        list.add(&lt;/span&gt;&quot;python&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
    }

    @ReadOperation
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String get(@Selector String arg0) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arg0;
    }&lt;br/&gt;@WriteOperation
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String post() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;post&quot;&lt;span&gt;;
    }

    @DeleteOperation
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer delete() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;    2、暴露 Endpoint&lt;/h3&gt;
&lt;p&gt;设置好了上面的 Endpoint Bean，还不能真正的访问到它们，需要在 application.yml 中将它们暴露出来：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;management&lt;/strong&gt;:
  endpoints:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 暴露 EndPoint 以供访问，有jmx和web两种方式，exclude 的优先级高于 include&lt;/span&gt;
&lt;span&gt;&lt;span&gt;    jmx&lt;/span&gt;:
      exposure:
        exclude: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        include: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    web&lt;/span&gt;:
      exposure:
      &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; exclude: '*'&lt;/span&gt;
        include: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;health&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;info&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mappings&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;logfile&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;metrics&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shutdown&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;env&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;做好这些配置后，你就能访问到 Endpoint 了（http://127.0.0.1:8080/actuator/my）&lt;/p&gt;
&lt;h3&gt;    3、@Selector&lt;/h3&gt;
&lt;p&gt;注意到没有，上面的 Endpoint 有一个 @Selector 参数的方法，并且参数名是 arg0，这个参数名是有学问滴......&lt;/p&gt;
&lt;p&gt;原来我给的参数名是 path，原来我设想我可以访问 /actuator/my/[任意字符] 的路径，但是会报 400 参数不匹配错误。但是嘞，/actuator/my/[任意字符]?path=[任意字符] 是正常访问的，真是奇了怪了！&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;原来，为了使 @Selector 正常工作，必须使用嵌入的参数名称编译 Endpoint（-parameters&lt;/span&gt;&lt;/span&gt;&lt;span&gt;），如下。或者将参数名改为 arg0 就能达到目的。&lt;span&gt;&lt;a href=&quot;https://stackoverflow.com/questions/47920201/how-do-you-use-selector-in-writeoperation-in-spring-boot-2-0-actuator-endp&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;这个是 stackoverflow 上的一个解释~&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.apache.maven.plugins&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;maven-compiler-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;compilerArgs&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;-parameters&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;arg&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;compilerArgs&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 或者：
    &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.7.0&amp;lt;/version&amp;gt;
        &amp;lt;configuration&amp;gt;
            &amp;lt;parameters&amp;gt;true&amp;lt;/parameters&amp;gt;
        &amp;lt;/configuration&amp;gt;
    &amp;lt;/plugin&amp;gt;
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;tips：&lt;/span&gt;&lt;/strong&gt; -parameters 的方式我没有验证通过呀~~汗&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;演示源代码：&lt;/strong&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/JMCuixy/Thymeleaf&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/JMCuixy/Thymeleaf&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 20 Oct 2018 14:10:00 +0000</pubDate>
<dc:creator>JMCui</dc:creator>
<og:description>一、Actuator 介绍 Actuator 是 SpringBoot 项目中一个非常强大一个功能，有助于对应用程序进行监视和管理，通过 restful api 请求来监管、审计、收集应用的运行情况。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jmcui/p/9820579.html</dc:identifier>
</item>
<item>
<title>一起学HBase——简单介绍HBase各种组件 - summer哥</title>
<link>http://www.cnblogs.com/airnew/p/9823149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/airnew/p/9823149.html</guid>
<description>&lt;p&gt;HBase是谷歌BigTble的开源实现。谷歌的三篇论文拉开了大数据江湖的序幕，铸就了现在以Hadoop为主的大数据技术生态圈。而HBase是开源的大数据数据库，和传统的行式数据库不同的是，HBase是列式数据库。列式数据的特点是开源横向扩展，将一张表的数据存储在hadoop集群的不同datanode中，一张表的存储量可以达到T级别。这是行式关系型数据库无法实现的。本文主要讲解HBase的基本概念，只有概念清楚了才能更好的在我们的系统中使用HBase。&lt;/p&gt;
&lt;h3 id=&quot;核心组件介绍&quot;&gt;核心组件介绍&lt;/h3&gt;
&lt;p&gt;Table：可理解为传统数据库中的一个表，但因为SchemaLess的设计，它较之传统数据库的表而言，在设计上更加灵活。&lt;/p&gt;
&lt;p&gt;Region：将表横向切割为一个个子表，子表在HBase中被称之为Region。&lt;/p&gt;
&lt;p&gt;RegionServer：数据服务进程，Region必须部署在某一个RegionServer上才可以提供读写服务。&lt;/p&gt;
&lt;p&gt;HFile：HBase数据库在底层分布式文件系统中的文件组织形式。&lt;/p&gt;
&lt;p&gt;Column Family：一些列的集合。不同的Column Family数据被存储在不同的路径中。&lt;/p&gt;
&lt;p&gt;MemStore：用来在内存中缓存一定大小的数据，达到设定的阈值后批量写入到底层文件系统中。数据是有序的。&lt;/p&gt;
&lt;p&gt;下图清晰的展示了Table，Region，RegionServer，HFile，MemStore，Column Family在HBase的逻辑关系。&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/hbasetheory1.png&quot; title=&quot;HBase基础知识&quot; alt=&quot;HBase基础知识&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图显示了HBase集群中的关键进程&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/hbasetheory2.png&quot; title=&quot;HBase基础知识&quot; alt=&quot;HBase基础知识&quot;/&gt;&lt;br/&gt;Zookeeper：HBase集群的调度器，可以用于将HBase RegionServer信息注册到zookeeper中，查询HBase RegionServer状态信息，HMaster启动时会将HBase系统表-ROOT-加载到zookeeper集群中，通过zookeeper集群可以获取当前系统表.META.的存储所对应的RegionServer信息&lt;br/&gt;。&lt;br/&gt;Master，通过jps命令显示的进程名称是HMaster，在负责表管理操作，Region到各个RegionServer的分配以及RegionServer Failover的处理等。&lt;/p&gt;
&lt;p&gt;RegionServer进程提供数据读写服务。&lt;/p&gt;
&lt;p&gt;NameNode，Hadoop进程，处理来自Master的请求，H管理DFS文件系统的命名空间NameSpace。&lt;/p&gt;
&lt;p&gt;DataNode，Hadoop数据节点进程，HBase的所有数据都存在Hadoop的DataNode中。&lt;/p&gt;
&lt;h3 id=&quot;keyvalue数据存储结构&quot;&gt;KeyValue数据存储结构&lt;/h3&gt;
&lt;p&gt;HBase所存储的数据是以KeyValue形式存放的，KeyValue有特定的数据结构，如下图所示，一个KeyValue可以理解成HBase表中的一个列，当一行存在多个列时，将包含多个KeyValue，同一行的KeyValue有可能存储在不同的文件中，但在读取时，会按需合并在一起返回给客户端。&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/hbasetheory3.png&quot; title=&quot;HBase基础知识&quot; alt=&quot;HBase基础知识&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户写数据时，需要定义用户数据的RowKey,指定每一列所存放的Column Family,并且为其定义相应的Qualifier（列名），Value部分存放用户数据。Hbase中每一行可拥有不同的KeyValues，这就是HBase Schema-less的特点。&lt;/p&gt;
&lt;p&gt;HBase中支持数据的多版本，通过带有不同时间戳的多个KeyValue版本来实现的，如下图所示。&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/hbasetheory5.png&quot; title=&quot;HBase基础知识&quot; alt=&quot;HBase基础知识&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HBase所保存的版本数据是可配置的，默认存放3个版本。在普通的读取流程中，旧版本的数据时不可见的，但通过制定版本数或者版本号的读取，可以获取旧版本数据。下图是普通读取刘恒与多版本读取流程的对比。&lt;/p&gt;
&lt;h3 id=&quot;灵活的列定义&quot;&gt;灵活的列定义&lt;/h3&gt;
&lt;p&gt;用户数据存入到HBase表中时，需要进行Qualifier(KeyValue/列)设计。一个最简单的设计是保持HBase的列与用户数据的列一致，如下图1的设计。这种设计，基本上与关系型数据库的设计是一致的，但这种设计会带来较大的数据冗余(KeyValue结构开销)。但HBase基于KeyValue的接口，决定了这种设计可以是非常灵活的，例如，我们也可以考虑为HBase的每一行只设置两个列，其中，Name为一个列，其他内容合并到一个列中，如下图2所示。&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/hbasetheory6.png&quot; title=&quot;HBase基础知识&quot; alt=&quot;HBase基础知识&quot;/&gt;&lt;/p&gt;
&lt;p&gt;尽管我们在使用HBase表存放数据的时候，需要预先做好列的设计。但这个设计仅仅由应用层感知，HBase并没有存放任何的Schema信息来描述这个设计。也就是说，应用层需要知道为每一个表/每一行设计了什么样的列(KeyValue)，然后在地区的时候做相应的解析。既然HBase中并没有Schema信息，name，每一行中的列，也可以是任意添加的。如下图所示，绿色背景的KeyValue为后续增加的。&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/hbasetheory7.png&quot; title=&quot;HBase基础知识&quot; alt=&quot;HBase基础知识&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;column-family&quot;&gt;Column Family&lt;/h3&gt;
&lt;p&gt;假设为表设置了两个列族，而且，定义了每一个列簇中要存放的列，如下图所示：&lt;br/&gt;{Name} -&amp;gt; Column Family - A, {City,Phone,Gender} -&amp;gt; Column Familly-B。不同列簇的数据会被存储在不同的路径中。即，设置多个列簇时一行数据可能存在于两个路径中。整行读取的时候，需要将两个路径中的数据合并在一起蔡可以获取完整的一行记录。但如果仅仅读取Name一列的话，只需要读取Column Family-A即可。&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/hbasetheory8.png&quot; title=&quot;HBase基础知识&quot; alt=&quot;HBase基础知识&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 20 Oct 2018 13:52:00 +0000</pubDate>
<dc:creator>summer哥</dc:creator>
<og:description>HBase是谷歌BigTble的开源实现。谷歌的三篇论文拉开了大数据江湖的序幕，铸就了现在以Hadoop为主的大数据技术生态圈。而HBase是开源的大数据数据库，和传统的行式数据库不同的是，HBase</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/airnew/p/9823149.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core中服务的生命周期选项区别和用法 - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/9823076.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/9823076.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　在做一个小的Demo中，在一个界面上两次调用视图组件，并且在视图组件中都调用了数据库查询，结果发现，一直报错，将两个视图组件的调用分离，单独进行，却又是正常的，寻找一番，发现是配置依赖注入服务时，对于服务的生命周期没有配置得当导致，特此做一次实验来认识三者之间(甚至是四者之间的用法及区别)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　本文demo地址(具体见WebApi控制器中):&lt;a href=&quot;https://gitee.com/530521314/koInstance.git&quot; target=&quot;_blank&quot;&gt;https://gitee.com/530521314/koInstance.git&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、服务的生命周期&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在Asp.Net Core中，内置容器负责管理服务的生命周期，从被依赖注入容器创建开始，等我们调用完服务时，到容器释放该服务的所有实力为止，有几种形式表现：&lt;/p&gt;
&lt;p&gt;　　1、Transient：每次请求服务时，都会创建一个新实例，这种生命周期适合用于轻量级服务（如Repository和ApplicationService服务）。&lt;/p&gt;
&lt;p&gt;　　2、Scoped：为每个HTTP请求创建一个实例，生命周期将横贯整次请求。&lt;/p&gt;
&lt;p&gt;　　3、SingleTon：在第一次请求服务时，为该服务创建一个实例，之后每次请求将会使用第一次创建好的服务。&lt;/p&gt;
&lt;p&gt;　　4、Instance：与SingleTon类似，但在应用程序启动时会将该实例注册到容器中，可以理解为比SingleTon还早存在。&lt;/p&gt;
&lt;p&gt;　　应用程序中相关服务的控制生命周期的方法时通过相应的Add*指定，如下三种，当然还可以通过扩展方法来简化ConfigurationServices方法中所见的代码数量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
services.AddTransient&amp;lt;IApplicationService, ApplicationService&amp;gt;&lt;span&gt;();
services.AddScoped&lt;/span&gt;&amp;lt;IApplicationService, ApplicationService&amp;gt;&lt;span&gt;();
services.AddSingleton&lt;/span&gt;&amp;lt;IApplicationService, ApplicationService&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、代码设计服务生命周期&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　首先设计一些服务相关的操作接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_b08933b3-07cc-440d-857b-d80f1cb98324&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b08933b3-07cc-440d-857b-d80f1cb98324&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b08933b3-07cc-440d-857b-d80f1cb98324&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperation
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        Guid GetGuid();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationTransient: IOperation
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationScoped : IOperation
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationSingleton : IOperation
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationInstance : IOperation
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;    
&lt;span&gt;24&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;基础服务接口&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　其次对这些操作类予以实现并生成相关服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_8e1c5861-5faf-43ab-8936-961ba7015a6c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_8e1c5861-5faf-43ab-8936-961ba7015a6c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8e1c5861-5faf-43ab-8936-961ba7015a6c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 常规服务
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;  4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Operation : IOperation
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Guid _guid;
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Operation()
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;             _guid =&lt;span&gt; Guid.NewGuid();
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Operation(Guid guid)
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;             _guid = guid == Guid.Empty ?&lt;span&gt; Guid.NewGuid() : guid;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Guid GetGuid()
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _guid;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; 
&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 瞬时服务
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OperationTransient : IOperationTransient
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Guid _guid;
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationTransient()
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;             _guid =&lt;span&gt; Guid.NewGuid();
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationTransient(Guid guid)
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;             _guid = guid == Guid.Empty ?&lt;span&gt; Guid.NewGuid() : guid;
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; 
&lt;span&gt; 41&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Guid GetGuid()
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _guid;
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 单次请求内服务固定
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OperationScoped : IOperationScoped
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Guid _guid;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationScoped()
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             _guid =&lt;span&gt; Guid.NewGuid();
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationScoped(Guid guid)
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;             _guid = guid == Guid.Empty ?&lt;span&gt; Guid.NewGuid() : guid;
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Guid GetGuid()
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _guid;
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 72&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 所有请求内固定服务
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OperationSingleton : IOperationSingleton
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Guid _guid;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationSingleton()
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;             _guid =&lt;span&gt; Guid.NewGuid();
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationSingleton(Guid guid)
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;             _guid = guid == Guid.Empty ?&lt;span&gt; Guid.NewGuid() : guid;
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Guid GetGuid()
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _guid;
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; 
&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 应用程序内固定服务
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OperationInstance : IOperationInstance
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Guid _guid;
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationInstance()
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt;             _guid =&lt;span&gt; Guid.NewGuid();
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; 
&lt;span&gt;106&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationInstance(Guid guid)
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;             _guid = guid == Guid.Empty ?&lt;span&gt; Guid.NewGuid() : guid;
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Guid GetGuid()
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _guid;
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;基础服务具体实现&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　对基础服务的聚合接口，提供统一服务接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_e404f470-dddd-406c-b651-327d805bca58&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e404f470-dddd-406c-b651-327d805bca58&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e404f470-dddd-406c-b651-327d805bca58&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IOperationService
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取四种形式的Guid码
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetGuidString();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;聚合服务接口&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　对基础服务的聚合实现，将基础服务全部接入进来作为统一服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_c2786653-77a4-4309-a421-77603c0a5355&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_c2786653-77a4-4309-a421-77603c0a5355&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c2786653-77a4-4309-a421-77603c0a5355&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 服务调用
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OperationService : IOperationService
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IOperationTransient _transientOperation { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IOperationScoped _scopedOperation { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IOperationSingleton _singletonOperation { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IOperationInstance _instanceOperation { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; OperationService(IOperationTransient transientOperation,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            IOperationScoped scopedOperation,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            IOperationSingleton singletonOperation,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            IOperationInstance instanceOperation)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             _transientOperation =&lt;span&gt; transientOperation;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             _scopedOperation =&lt;span&gt; scopedOperation;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             _singletonOperation =&lt;span&gt; singletonOperation;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             _instanceOperation =&lt;span&gt; instanceOperation;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetGuidString()
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Transient:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;_transientOperation.GetGuid(),
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Scoped:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;_scopedOperation.GetGuid(),
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Singleton:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt;_singletonOperation.GetGuid(),
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Instance:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;_instanceOperation.GetGuid(),
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;聚合服务的实现&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　在控制器中进行服务注入&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    [ApiController]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValuesController : ControllerBase
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IOperationService _operationService;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ValuesController(IOperationService operationService)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             _operationService =&lt;span&gt; operationService;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        [HttpGet]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        [Route(nameof(GetGuidString))]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetGuidString()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, _operationService.GetGuidString());
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在StartUp中完成服务注入逻辑，这里实现服务注入的方式多种均可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
services.AddTransient&amp;lt;IOperationTransient, OperationTransient&amp;gt;&lt;span&gt;();
services.AddScoped&lt;/span&gt;&amp;lt;IOperationScoped, OperationScoped&amp;gt;&lt;span&gt;();
services.AddSingleton&lt;/span&gt;&amp;lt;IOperationSingleton, OperationSingleton&amp;gt;&lt;span&gt;();&lt;br/&gt;//应用程序启动时便注入该实例
services.AddSingleton&lt;/span&gt;&amp;lt;IOperationInstance&amp;gt;(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OperationInstance(Guid.Empty));
services.AddTransient&lt;/span&gt;&amp;lt;IOperationService, OperationService&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　通过访问预期Api地址可以得到不同的四种基础服务的Guid信息，&lt;/p&gt;
&lt;p&gt;　　第一次启动程序(不关闭)发起访问：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201810/1133736-20181020202700048-2029519958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第二次(第一次基础上再次访问)发起访问：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201810/1133736-20181020202714830-1469125807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看见，两次访问下，Singleton和Instance是相同的，都是由应用程序启动时和应用服务加载时决定完毕，Singleton在首次进入服务时进行分配，并始终保持不变，而Instance在应用程序启动时，便将实例注入，进入服务也保持着最先的实例，没有重新分配实例。而Transient和Scoped则进行着变化。&lt;/p&gt;
&lt;p&gt;　　关闭程序，重启，第三次发起访问：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201810/1133736-20181020202751014-1076736110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以见到，Singleton和Instance都发生了变化，也说明了之前在Singleton和Instance处写上的作用。&lt;/p&gt;
&lt;p&gt;　　接下来开始设计Transient和Scoped的不同之处，对于已有代码加上新功能，此次我们只针对Scoped和Transient进行比较。&lt;/p&gt;
&lt;p&gt;　　首先在StartUp中将HttpContextAccessor服务注入，目的是在后期能够针对Scoped获取新的服务实例(尽管两个实例是相同的)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
   services.AddHttpContextAccessor();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接着在聚合服务中增加一个方法，用来针对Transient、Scoped测试。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取Transient、Scoped的Guid码
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; GetTransientAndScopedGuidString();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在聚合服务实现中实现该方法并对已有的服务重新获取实例，得到不同实例下的Guid码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetTransientAndScopedGuidString()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var tempTransientService = (IOperationTransient)ServiceLocator.Instance.GetService(typeof(IOperationTransient));&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; tempTransientService = (IOperationTransient)_httpContextAccessor.HttpContext.RequestServices.GetService(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IOperationTransient));
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; tempScopedService = (IOperationScoped)_httpContextAccessor.HttpContext.RequestServices.GetService(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IOperationScoped));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原生Transient请求服务:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;_transientOperation.GetGuid(),
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;手动Transient请求服务:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt; tempTransientService.GetGuid(),
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原生Scoped请求服务:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;_scopedOperation.GetGuid(),
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;手动Scoped请求服务:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;tempScopedService.GetGuid(),
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在控制器部分调用该聚合服务即可，并返回相应的结果，本次我返回的结果：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201810/1133736-20181020213329519-1827201712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到，对于Scoped来讲，一次请求内多次访问同一个服务是共用一个服务实例的，而对于Transient则是，每次访问都是新的服务实例。&lt;/p&gt;
&lt;p&gt;　　至此，对于这四种服务生命周期算是掌握的差不多了。&lt;/p&gt;

&lt;p&gt;　　参考：&lt;/p&gt;
&lt;p&gt;　　   蒋老师文章： &lt;a href=&quot;http://www.cnblogs.com/artech/p/asp-net-core-di-register.html&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/artech/p/asp-net-core-di-register.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　 　  田园里的蟋蟀：&lt;a href=&quot;https://www.cnblogs.com/xishuai/p/asp-net-core-ioc-di-get-service.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/xishuai/p/asp-net-core-ioc-di-get-service.html&lt;/a&gt;&lt;/p&gt;


&lt;pre class=&quot;lang-java prettyprint prettyprinted&quot;&gt;
&lt;code&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;strong&gt;2018-10-20,望技术有成后能回来看见自己的脚步&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

</description>
<pubDate>Sat, 20 Oct 2018 13:38:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<og:description>在做一个小的Demo中，在一个界面上两次调用视图组件，并且在视图组件中都调用了数据库查询，结果发现，一直报错，将两个视图组件的调用分离，单独进行，却又是正常的，寻找一番，发现是配置依赖注入服务时，对于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CKExp/p/9823076.html</dc:identifier>
</item>
<item>
<title>浅谈前端实现页面加载进度条以及 nprogress.js 的实现 - 子迟</title>
<link>http://www.cnblogs.com/zichi/p/9823043.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zichi/p/9823043.html</guid>
<description>&lt;p&gt;以前在 Vue 的项目用了 &lt;a href=&quot;https://github.com/rstacruz/nprogress&quot;&gt;nprogress&lt;/a&gt; 这个插件，一直对于其如何得知加载进度充满好奇，最近又看到了「前端如何实现页面加载进度条」这个问题，今天周六恰好一探究竟。以下仅为一家之言，如有异议，欢迎指出。&lt;/p&gt;

&lt;p&gt;首先不得不说，&lt;strong&gt;前端的页面加载进度条其实有两种&lt;/strong&gt;，所以你得先搞清楚说的是哪一种。&lt;/p&gt;
&lt;p&gt;第一种，进度条显示的是 &lt;strong&gt;前端静态资源&lt;/strong&gt; 的加载。比如你打开一个页面，页面需要加载 js、css、img 等静态资源，那么每加载完一个资源（监听 onload 事件或者类似事件），进度条就向前滚动一下，直到加载完所有，进度条到头。&lt;/p&gt;
&lt;p&gt;实际操作中，如果不做前置静态资源配置，基本不可能实现，因为你很难在代码中获取页面加载所需要的 js、css、img 资源，假设可以获取，还需要监听它们的 onload 事件，即使能实现这个进度条，也是一件 &lt;strong&gt;性价比很低&lt;/strong&gt; 的事情，除非一个情况。&lt;/p&gt;
&lt;p&gt;没错，这个特殊情况就是 &lt;strong&gt;游戏资源的加载&lt;/strong&gt;。我们在写游戏的时候，通常需要把静态资源项目都列出来到配置中，而且，这个资源请求，一般比较耗时，这个时候，我们就需要这样一个进度条，因为前置条件也已经满足（资源已经列出），而如果只是写一个普通的页面，我们一般不会手动去列出静态资源。（具体实现我没有研究过，实际可能更加复杂，详见 &lt;a href=&quot;https://www.zhihu.com/question/31952175/answer/54078627&quot;&gt;这个回答&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;第二种情况，也是我们现在通常说的进度条加载，举个简单的例子，GitHub 中就有用到。先打开我的 GitHub 主页 &lt;a href=&quot;https://github.com/hanzichi&quot; class=&quot;uri&quot;&gt;https://github.com/hanzichi&lt;/a&gt;，然后点击 tab 中的 Stars 标签，这个时候 url 会变成 &lt;a href=&quot;https://github.com/hanzichi?tab=stars&quot; class=&quot;uri&quot;&gt;https://github.com/hanzichi?tab=stars&lt;/a&gt;，进度条开始加载，当页面内容切换过去的时候，进度条结束。&lt;/p&gt;
&lt;p&gt;以上实现，其实就是 pjax 的实现，忽略掉 &quot;p&quot; 的部分，其实就是一个普通的 ajax。当页面发起 ajax 请求的时候，显示进度条，ajax 结束的时候，进度条到头，从而实现整个页面加载。这种情况，其实通常都会搭档 SPA 出现。&lt;/p&gt;

&lt;p&gt;以上第二种情况，业界有个成熟的插件 &lt;a href=&quot;http://ricostacruz.com/nprogress/&quot;&gt;NProgress&lt;/a&gt;。它的 API 非常简单，&lt;code&gt;NProgress.start()&lt;/code&gt; 表示进度条开始，&lt;code&gt;NProgress.done()&lt;/code&gt; 表示进度条结束。&lt;/p&gt;
&lt;p&gt;如果搭配 pjax，可以这样用：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$(document).on('pjax:start', function() { NProgress.start(); });
$(document).on('pjax:end',   function() { NProgress.done();  });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Vue 中，可以这样用：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;router.beforeEach((to, from, next) =&amp;gt; {
  NProgress.start()
  next()
})

router.afterEach(() =&amp;gt; {
  NProgress.done() // 结束 Progress
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;甚至，普通的页面中也可以用，页面开始的时候 &lt;code&gt;NProgress.start()&lt;/code&gt;，window.onload 的回调中运行 &lt;code&gt;NProgress.done()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NProgress.start()&lt;/code&gt; 和 &lt;code&gt;NProgress.done()&lt;/code&gt; 过程中，进度条会不断加载，时快时慢，这个速度的控制，依赖的是什么？答案是，&lt;strong&gt;进度条的进度其实是假的，进度是 NProgress 自己在代码中控制的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们可以看下 &lt;a href=&quot;https://github.com/rstacruz/nprogress/blob/master/nprogress.js&quot;&gt;源码&lt;/a&gt;，调用 &lt;code&gt;NProgress.start&lt;/code&gt; 后，会持续调用 &lt;code&gt;NProgress.inc&lt;/code&gt; 方法，我们看下这个方法实现：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;NProgress.inc = function(amount) {
  var n = NProgress.status;

  if (!n) {
    return NProgress.start();
  } else if(n &amp;gt; 1) {
    return;
  } else {
    if (typeof amount !== 'number') {
      if (n &amp;gt;= 0 &amp;amp;&amp;amp; n &amp;lt; 0.2) { amount = 0.1; }
      else if (n &amp;gt;= 0.2 &amp;amp;&amp;amp; n &amp;lt; 0.5) { amount = 0.04; }
      else if (n &amp;gt;= 0.5 &amp;amp;&amp;amp; n &amp;lt; 0.8) { amount = 0.02; }
      else if (n &amp;gt;= 0.8 &amp;amp;&amp;amp; n &amp;lt; 0.99) { amount = 0.005; }
      else { amount = 0; }
    }

    n = clamp(n + amount, 0, 0.994);
    return NProgress.set(n);
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中的 amount 就是进度条增量（0 为进度条起始值，1 为进度条终止值），可以从数值上判断，进度条增长速度是越来越慢。当进度条增长到 99.4% 的时候，就停止了，直到调用 &lt;code&gt;NProgress.done()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;其实，某些场景，想获取真实进度也是可以的，xhr2 其实是可以获取进度的，用 ajax 上传文件就可以持续获取进度进行展示，本文就不展开讨论了。&lt;/p&gt;
&lt;p&gt;本文的结论是，绝大多数情况下看到的前端页面进度条展示，都是假的，只是特效 ...&lt;/p&gt;
</description>
<pubDate>Sat, 20 Oct 2018 13:32:00 +0000</pubDate>
<dc:creator>子迟</dc:creator>
<og:description>以前在 Vue 的项目用了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zichi/p/9823043.html</dc:identifier>
</item>
</channel>
</rss>